# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "모듈 객체"

#: ../../c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module "
"type.  This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"이 :c:type:`PyTypeObject` 인스턴스는 파이썬 모듈 형을 나타냅니다. 이것은 "
"``types.ModuleType``\\으로 파이썬 프로그램에 노출됩니다."

#: ../../c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. "
"This function always succeeds."
msgstr "*p*\\가 모듈 객체이거나 모듈 객체의 서브 형이면 참을 반환합니다. 이 함수는 항상 성공합니다."

#: ../../c-api/module.rst:27
msgid ""
"Return true if *p* is a module object, but not a subtype of "
":c:data:`PyModule_Type`.  This function always succeeds."
msgstr ""
"*p*\\가 모듈 객체이지만, :c:data:`PyModule_Type`\\의 서브 형이 아니면 참을 반환합니다. 이 함수는 항상 "
"성공합니다."

#: ../../c-api/module.rst:40
#, fuzzy
msgid ""
"Return a new module object with :attr:`module.__name__` set to *name*. "
"The module's :attr:`!__name__`, :attr:`~module.__doc__`, "
":attr:`~module.__package__` and :attr:`~module.__loader__` attributes are"
" filled in (all but :attr:`!__name__` are set to ``None``). The caller is"
" responsible for setting a :attr:`~module.__file__` attribute."
msgstr ""
":attr:`__name__` 어트리뷰트가 *name*\\으로 설정된 새 모듈 객체를 반환합니다. 모듈의 "
":attr:`__name__`, :attr:`__doc__`, :attr:`__package__` 및 "
":attr:`__loader__` 어트리뷰트가 채워집니다 (:attr:`__name__`\\을 제외하고 모두 ``None``\\으로"
" 설정됩니다); :attr:`__file__` 어트리뷰트를 제공하는 것은 호출자의 책임입니다."

#: ../../c-api/module.rst:46 ../../c-api/module.rst:272
#: ../../c-api/module.rst:474
msgid "Return ``NULL`` with an exception set on error."
msgstr ""

#: ../../c-api/module.rst:50
#, fuzzy
msgid ""
":attr:`~module.__package__` and :attr:`~module.__loader__` are now set to"
" ``None``."
msgstr ":attr:`__package__`\\와 :attr:`__loader__`\\가 ``None``\\으로 설정됩니다."

#: ../../c-api/module.rst:57
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
":c:func:`PyModule_NewObject`\\와 비슷하지만, name이 유니코드 객체 대신 UTF-8로 인코딩된 "
"문자열입니다."

#: ../../c-api/module.rst:65
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the "
"module object. If *module* is not a module object (or a subtype of a "
"module object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"*module*\\의 이름 공간을 구현하는 딕셔너리 객체를 반환합니다; 이 객체는 모듈 객체의 "
":attr:`~object.__dict__` 어트리뷰트와 같습니다. *module*\\이 모듈 객체(또는 모듈 객체의 서브 형)가 "
"아니면, :exc:`SystemError`\\가 발생하고 ``NULL``\\이 반환됩니다."

#: ../../c-api/module.rst:70
#, fuzzy
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's "
":attr:`~object.__dict__`."
msgstr ""
"확장은 모듈의 :attr:`~object.__dict__`\\를 직접 조작하지 말고 다른 "
":c:func:`PyModule_\\*`\\과 :c:func:`PyObject_\\*` 함수를 사용하는 것이 좋습니다."

#: ../../c-api/module.rst:81
#, fuzzy
msgid ""
"Return *module*'s :attr:`~module.__name__` value.  If the module does not"
" provide one, or if it is not a string, :exc:`SystemError` is raised and "
"``NULL`` is returned."
msgstr ""
"*module*\\의 :attr:`__name__` 값을 반환합니다. 모듈이 제공하지 않거나, 문자열이 아니면, "
":exc:`SystemError`\\가 발생하고 ``NULL``\\이 반환됩니다."

#: ../../c-api/module.rst:90
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded "
"to ``'utf-8'``."
msgstr ":c:func:`PyModule_GetNameObject`\\와 비슷하지만 ``'utf-8'``\\로 인코딩된 이름을 반환합니다."

#: ../../c-api/module.rst:95
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See "
":c:member:`PyModuleDef.m_size`."
msgstr ""
"모듈의 \"상태\", 즉 모듈 생성 시 할당된 메모리 블록을 가리키는 포인터나 ``NULL``\\을 반환합니다. "
":c:member:`PyModuleDef.m_size`\\를 참조하십시오."

#: ../../c-api/module.rst:102
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the "
"module was created, or ``NULL`` if the module wasn't created from a "
"definition."
msgstr ""
"모듈이 만들어진 :c:type:`PyModuleDef` 구조체에 대한 포인터나 모듈이 정의에서 만들어지지 않았으면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/module.rst:112
#, fuzzy
msgid ""
"Return the name of the file from which *module* was loaded using "
"*module*'s :attr:`~module.__file__` attribute.  If this is not defined, "
"or if it is not a string, raise :exc:`SystemError` and return ``NULL``; "
"otherwise return a reference to a Unicode object."
msgstr ""
"*module*\\의 :attr:`__file__` 어트리뷰트를 사용하여 *module*\\이 로드된 파일 이름을 반환합니다. "
"정의되지 않았거나 유니코드 문자열이 아니면, :exc:`SystemError`\\를 발생시키고 ``NULL``\\을 반환합니다; "
"그렇지 않으면 유니코드 객체에 대한 참조를 반환합니다."

#: ../../c-api/module.rst:122
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ":c:func:`PyModule_GetFilenameObject`\\와 비슷하지만 'utf-8'로 인코딩된 파일명을 반환합니다."

#: ../../c-api/module.rst:125
#, fuzzy
msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename`\\은 인코딩할 수 없는 파일명에 대해 "
":c:type:`UnicodeEncodeError`\\를 발생시킵니다, 대신 "
":c:func:`PyModule_GetFilenameObject`\\를 사용하십시오."

#: ../../c-api/module.rst:133
msgid "Initializing C modules"
msgstr "C 모듈 초기화"

#: ../../c-api/module.rst:135
msgid ""
"Modules objects are usually created from extension modules (shared "
"libraries which export an initialization function), or compiled-in "
"modules (where the initialization function is added using "
":c:func:`PyImport_AppendInittab`). See :ref:`building` or :ref"
":`extending-with-embedding` for details."
msgstr ""
"모듈 객체는 일반적으로 확장 모듈(초기화 함수를 내보내는 공유 라이브러리)이나 컴파일된 모듈(초기화 함수가 "
":c:func:`PyImport_AppendInittab`\\을 사용하여 추가된)에서 만들어집니다. 자세한 내용은 "
":ref:`building`\\나 :ref:`extending-with-embedding`\\를 참조하십시오."

#: ../../c-api/module.rst:140
msgid ""
"The initialization function can either pass a module definition instance "
"to :c:func:`PyModule_Create`, and return the resulting module object, or "
"request \"multi-phase initialization\" by returning the definition struct"
" itself."
msgstr ""
"초기화 함수는 모듈 정의 인스턴스를 :c:func:`PyModule_Create`\\에 전달하고 결과 모듈 객체를 반환하거나, 정의"
" 구조체 자체를 반환하여 \"다단계 초기화\"를 요청할 수 있습니다."

#: ../../c-api/module.rst:146
msgid ""
"The module definition struct, which holds all information needed to "
"create a module object. There is usually only one statically initialized "
"variable of this type for each module."
msgstr ""
"모듈 객체를 만드는 데 필요한 모든 정보를 담고 있는 모듈 정의 구조체. 일반적으로 각 모듈에 대해 이 형의 정적으로 초기화된 "
"변수가 하나만 있습니다."

#: ../../c-api/module.rst:152
#, fuzzy
msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`."
msgstr "이 멤버를 항상 :const:`PyModuleDef_HEAD_INIT`\\로 초기화하십시오."

#: ../../c-api/module.rst:156
msgid "Name for the new module."
msgstr "새 모듈의 이름."

#: ../../c-api/module.rst:160
msgid ""
"Docstring for the module; usually a docstring variable created with "
":c:macro:`PyDoc_STRVAR` is used."
msgstr "모듈의 독스트링; 일반적으로 :c:macro:`PyDoc_STRVAR`\\로 만들어진 독스트링 변수가 사용됩니다."

#: ../../c-api/module.rst:165
msgid ""
"Module state may be kept in a per-module memory area that can be "
"retrieved with :c:func:`PyModule_GetState`, rather than in static "
"globals. This makes modules safe for use in multiple sub-interpreters."
msgstr ""
"모듈 상태는 정적 전역이 아닌 :c:func:`PyModule_GetState`\\로 조회할 수 있는 모듈별 메모리 영역에 유지될 "
"수 있습니다. 이것은 여러 서브 인터프리터에서 모듈을 사용하는 것을 안전하게 만듭니다."

#: ../../c-api/module.rst:169
#, fuzzy
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the "
":c:member:`~PyModuleDef.m_free` function has been called, if present."
msgstr ""
"이 메모리 영역은 모듈 생성 시 *m_size*\\를 기준으로 할당되며, 모듈 객체가 할당 해제될 때 (있다면 "
":c:member:`m_free` 함수가 호출된 후에) 해제됩니다."

#: ../../c-api/module.rst:173
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr "``m_size``\\를 ``-1``\\로 설정하면 모듈이 전역 상태를 갖기 때문에 서브 인터프리터를 지원하지 않는다는 뜻입니다."

#: ../../c-api/module.rst:176
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for"
" its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"음수가 아닌 값으로 설정하면 모듈을 다시 초기화 할 수 있다는 뜻이며 상태에 필요한 추가 메모리양을 지정합니다. 다단계 초기화에는 "
"음이 아닌 ``m_size``\\가 필요합니다."

#: ../../c-api/module.rst:181
msgid "See :PEP:`3121` for more details."
msgstr "자세한 내용은 :PEP:`3121`\\을 참조하십시오."

#: ../../c-api/module.rst:185
msgid ""
"A pointer to a table of module-level functions, described by "
":c:type:`PyMethodDef` values.  Can be ``NULL`` if no functions are "
"present."
msgstr ""
":c:type:`PyMethodDef` 값으로 기술되는 모듈 수준 함수 테이블에 대한 포인터. 함수가 없으면 ``NULL``\\일 "
"수 있습니다."

#: ../../c-api/module.rst:190
#, python-brace-format
msgid ""
"An array of slot definitions for multi-phase initialization, terminated "
"by a ``{0, NULL}`` entry. When using single-phase initialization, "
"*m_slots* must be ``NULL``."
msgstr ""
"다단계 초기화를 위한 슬롯 정의 배열, ``{0, NULL}`` 항목으로 종료됩니다. 단단계 초기화를 사용할 때, "
"*m_slots*\\는 ``NULL``\\이어야 합니다."

#: ../../c-api/module.rst:196
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "버전 3.5 이전에는, 이 멤버가 항상 ``NULL``\\로 설정되었으며, 다음과 같이 정의되었습니다:"

#: ../../c-api/module.rst:203
msgid ""
"A traversal function to call during GC traversal of the module object, or"
" ``NULL`` if not needed."
msgstr "모듈 객체의 GC 탐색 중 호출할 탐색 함수나, 필요하지 않으면 ``NULL``."

#: ../../c-api/module.rst:206 ../../c-api/module.rst:221
#: ../../c-api/module.rst:242
#, fuzzy
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created "
"and before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`~PyModuleDef.m_size`"
" is greater than 0 and the module state (as returned by "
":c:func:`PyModule_GetState`) is ``NULL``."
msgstr ""
"모듈 상태가 요청되었지만, 아직 할당되지 않았으면 이 함수가 호출되지 않습니다. 이것은 모듈이 만들이진 직후, 모듈이 실행되기 "
"직전의 경우입니다 (:c:data:`Py_mod_exec` 함수). 더 정확하게는, :c:member:`m_size`\\가 0보다 "
"크고 모듈 상태(:c:func:`PyModule_GetState`\\가 반환하는)가 ``NULL``\\이면 이 함수가 호출되지 "
"않습니다."

#: ../../c-api/module.rst:213 ../../c-api/module.rst:234
#: ../../c-api/module.rst:249
msgid "No longer called before the module state is allocated."
msgstr "모듈 상태가 할당되기 전에 더는 호출되지 않습니다."

#: ../../c-api/module.rst:218
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr "모듈 객체의 GC 정리 중에 호출할 정리(clear) 함수나, 필요하지 않으면 ``NULL``."

#: ../../c-api/module.rst:228
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* "
"called before a module is deallocated. For example, when reference "
"counting is enough to determine that an object is no longer used, the "
"cyclic garbage collector is not involved and "
":c:member:`~PyModuleDef.m_free` is called directly."
msgstr ""

#: ../../c-api/module.rst:239
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` "
"if not needed."
msgstr "모듈 객체 할당 해제 중에 호출할 함수나, 필요하지 않으면 ``NULL``."

#: ../../c-api/module.rst:253
msgid "Single-phase initialization"
msgstr "단단계 초기화"

#: ../../c-api/module.rst:255
msgid ""
"The module initialization function may create and return the module "
"object directly. This is referred to as \"single-phase initialization\", "
"and uses one of the following two module creation functions:"
msgstr ""
"모듈 초기화 함수는 모듈 객체를 직접 만들고 반환할 수 있습니다. 이것을 \"단단계 초기화\"라고 하며, 다음 두 모듈 생성 함수 "
"중 하나를 사용합니다:"

#: ../../c-api/module.rst:261
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to "
":c:macro:`PYTHON_API_VERSION`."
msgstr ""
"*def*\\의 정의에 따라, 새 모듈 객체를 만듭니다. 이것은 *module_api_version*\\이 "
":const:`PYTHON_API_VERSION`\\으로 설정된 :c:func:`PyModule_Create2`\\처럼 동작합니다."

#: ../../c-api/module.rst:268
msgid ""
"Create a new module object, given the definition in *def*, assuming the "
"API version *module_api_version*.  If that version does not match the "
"version of the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"*def*\\의 정의에 따라, API 버전 *module_api_version*\\을 가정하여 새 모듈 객체를 만듭니다. 해당 "
"버전이 실행 중인 인터프리터 버전과 일치하지 않으면, :exc:`RuntimeWarning`\\을 발생시킵니다."

#: ../../c-api/module.rst:276
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr "이 함수는 대부분 :c:func:`PyModule_Create`\\를 대신 사용해야 합니다; 확실히 필요할 때만 사용하십시오."

#: ../../c-api/module.rst:279
#, fuzzy
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like "
":c:func:`PyModule_AddObjectRef`."
msgstr ""
"초기화 함수에서 반환되기 전에, 결과 모듈 객체는 일반적으로 :c:func:`PyModule_AddObject`\\와 같은 함수를 "
"사용하여 채워집니다."

#: ../../c-api/module.rst:285
msgid "Multi-phase initialization"
msgstr "다단계 초기화"

#: ../../c-api/module.rst:287
#, fuzzy
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like "
"Python modules: the initialization is split between the *creation phase*,"
" when the module object is created, and the *execution phase*, when it is"
" populated. The distinction is similar to the :py:meth:`!__new__` and "
":py:meth:`!__init__` methods of classes."
msgstr ""
"확장을 지정하는 다른 방법은 \"다단계 초기화\"를 요청하는 것입니다. 이 방법으로 만들어진 확장 모듈은 파이썬 모듈과 더 비슷하게"
" 동작합니다: 초기화는 모듈 객체가 만들어질 때의 *생성 단계(creation phase)*\\와 채워질 때의 *실행 "
"단계(execution phase)*\\로 분할됩니다. 구별은 클래스의 :py:meth:`__new__`\\와 "
":py:meth:`__init__` 메서드와 유사합니다."

#: ../../c-api/module.rst:294
#, fuzzy
msgid ""
"Unlike modules created using single-phase initialization, these modules "
"are not singletons: if the *sys.modules* entry is removed and the module "
"is re-imported, a new module object is created, and the old module is "
"subject to normal garbage collection -- as with Python modules. By "
"default, multiple modules created from the same definition should be "
"independent: changes to one should not affect the others. This means that"
" all state should be specific to the module object (using e.g. using "
":c:func:`PyModule_GetState`), or its contents (such as the module's "
":attr:`~object.__dict__` or individual classes created with "
":c:func:`PyType_FromSpec`)."
msgstr ""
"단단계 초기화를 사용하여 만들어진 모듈과 달리, 이 모듈은 싱글톤이 아닙니다: *sys.modules* 항목을 제거하고 모듈을 다시"
" 임포트 하면, 새 모듈 객체가 만들어지고, 이전 모듈은 일반 가비지 수집이 적용됩니다 -- 파이썬 모듈과 마찬가지입니다. "
"기본적으로, 같은 정의에서 만들어진 여러 모듈은 독립적이어야 합니다: 하나를 변경해도 다른 모듈에는 영향을 미치지 않습니다. 즉, "
"모든 상태는 모듈 객체(예를 들어 :c:func:`PyModule_GetState`\\를 사용해서)나 그 내용(가령 모듈의 "
":attr:`__dict__`\\나 :c:func:`PyType_FromSpec`\\으로 만든 개별 클래스)으로 제한되어야 합니다."

#: ../../c-api/module.rst:304
msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`. Making sure "
"multiple modules are independent is typically enough to achieve this."
msgstr ""
"다단계 초기화를 사용하여 만들어진 모든 모듈은 :ref:`서브 인터프리터 <sub-interpreter-support>`\\를 "
"지원할 것으로 기대됩니다. 다중 모듈을 독립적으로 유지하는 것은 일반적으로 이를 달성하기에 충분합니다."

#: ../../c-api/module.rst:308
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-"
"empty :c:member:`~PyModuleDef.m_slots`. Before it is returned, the "
"``PyModuleDef`` instance must be initialized with the following function:"
msgstr ""
"다단계 초기화를 요청하기 위해, 초기화 함수(PyInit_modulename)는 비어 있지 않은 "
":c:member:`~PyModuleDef.m_slots`\\를 가진 :c:type:`PyModuleDef` 인스턴스를 반환합니다."
" 반환되기 전에, ``PyModuleDef`` 인스턴스를 다음 함수를 사용하여 초기화해야 합니다:"

#: ../../c-api/module.rst:315
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr "모듈 정의가 형과 참조 횟수를 올바르게 보고하는 올바르게 초기화된 파이썬 객체이게 합니다."

#: ../../c-api/module.rst:318
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr "*def*\\를 ``PyObject*``\\로 캐스트 하거나, 에러가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/module.rst:322
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr "모듈 정의의 *m_slots* 멤버는 ``PyModuleDef_Slot`` 구조체의 배열을 가리켜야 합니다:"

#: ../../c-api/module.rst:329
msgid "A slot ID, chosen from the available values explained below."
msgstr "아래 설명된 사용 가능한 값 중에서 선택된, 슬롯 ID."

#: ../../c-api/module.rst:333
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "슬롯 ID에 따라 그 의미가 달라지는, 슬롯의 값."

#: ../../c-api/module.rst:337
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "*m_slots* 배열은 id가 0인 슬롯으로 종료해야 합니다."

#: ../../c-api/module.rst:339
msgid "The available slot types are:"
msgstr "사용 가능한 슬롯 형은 다음과 같습니다:"

#: ../../c-api/module.rst:343
msgid ""
"Specifies a function that is called to create the module object itself. "
"The *value* pointer of this slot must point to a function of the "
"signature:"
msgstr ""
"모듈 객체 자체를 만들기 위해 호출되는 함수를 지정합니다. 이 슬롯의 *value* 포인터는 다음과 같은 서명을 갖는 함수를 "
"가리켜야 합니다:"

#: ../../c-api/module.rst:350
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"이 함수는 :PEP:`451`\\에 정의된 대로, :py:class:`~importlib.machinery.ModuleSpec` "
"인스턴스와 모듈 정의를 받습니다. 새 모듈 객체를 반환하거나, 에러를 설정하고 ``NULL``\\을 반환해야 합니다."

#: ../../c-api/module.rst:355
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may "
"result in an infinite loop."
msgstr ""
"이 함수는 최소한으로 유지해야 합니다. 특히 같은 모듈을 다시 임포트 하려고 시도하면 무한 루프가 발생할 수 있어서, 임의의 파이썬"
" 코드를 호출하면 안 됩니다."

#: ../../c-api/module.rst:359
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "하나의 모듈 정의에서 여러 ``Py_mod_create`` 슬롯을 지정할 수 없습니다."

#: ../../c-api/module.rst:362
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a"
" normal module object using :c:func:`PyModule_New`. The name is taken "
"from *spec*, not the definition, to allow extension modules to "
"dynamically adjust to their place in the module hierarchy and be imported"
" under different names through symlinks, all while sharing a single "
"module definition."
msgstr ""
"``Py_mod_create``\\를 지정하지 않으면, 임포트 절차는 :c:func:`PyModule_New`\\를 사용하여 일반 "
"모듈 객체를 만듭니다. 이름은 정의가 아니라 *spec*\\에서 취합니다, 확장 모듈이 단일 모듈 정의를 공유하면서 모듈 계층 "
"구조에서 해당 위치에 동적으로 조정되고 심볼릭 링크를 통해 다른 이름으로 임포트 될 수 있도록 하기 위함입니다."

#: ../../c-api/module.rst:368
msgid ""
"There is no requirement for the returned object to be an instance of "
":c:type:`PyModule_Type`. Any type can be used, as long as it supports "
"setting and getting import-related attributes. However, only "
"``PyModule_Type`` instances may be returned if the ``PyModuleDef`` has "
"non-``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; non-zero "
"``m_size``; or slots other than ``Py_mod_create``."
msgstr ""
"반환된 객체가 :c:type:`PyModule_Type`\\의 인스턴스 일 필요는 없습니다. 임포트 관련 어트리뷰트 설정과 읽기를 "
"지원하는 한 모든 형을 사용할 수 있습니다. 그러나, ``PyModuleDef``\\에 ``NULL``\\이 아닌 "
"``m_traverse``, ``m_clear``, ``m_free``; 0이 아닌 ``m_size``; 또는 "
"``Py_mod_create`` 이외의 슬롯이 있으면, ``PyModule_Type`` 인스턴스 만 반환될 수 있습니다."

#: ../../c-api/module.rst:377
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"모듈을 *실행*\\하기 위해 호출되는 함수를 지정합니다. 이것은 파이썬 모듈의 코드를 실행하는 것과 동등합니다: 일반적으로, 이 "
"함수는 클래스와 상수를 모듈에 추가합니다. 함수의 서명은 다음과 같습니다:"

#: ../../c-api/module.rst:386
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in "
"the order they appear in the *m_slots* array."
msgstr "여러 개의 ``Py_mod_exec`` 슬롯이 지정되면, *m_slots* 배열에 나타나는 순서대로 처리됩니다."

#: ../../c-api/module.rst:391 ../../c-api/module.rst:424
msgid "Specifies one of the following values:"
msgstr ""

#: ../../c-api/module.rst:397
msgid "The module does not support being imported in subinterpreters."
msgstr ""

#: ../../c-api/module.rst:401
msgid ""
"The module supports being imported in subinterpreters, but only when they"
" share the main interpreter's GIL. (See :ref:`isolating-extensions-"
"howto`.)"
msgstr ""

#: ../../c-api/module.rst:407
msgid ""
"The module supports being imported in subinterpreters, even when they "
"have their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""

#: ../../c-api/module.rst:411
msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr ""

#: ../../c-api/module.rst:414
#, fuzzy
msgid ""
"Multiple ``Py_mod_multiple_interpreters`` slots may not be specified in "
"one module definition."
msgstr "하나의 모듈 정의에서 여러 ``Py_mod_create`` 슬롯을 지정할 수 없습니다."

#: ../../c-api/module.rst:417
msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import "
"machinery defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."
msgstr ""

#: ../../c-api/module.rst:430
msgid ""
"The module depends on the presence of the global interpreter lock (GIL), "
"and may access global state without synchronization."
msgstr ""

#: ../../c-api/module.rst:435
msgid "The module is safe to run without an active GIL."
msgstr ""

#: ../../c-api/module.rst:437
msgid ""
"This slot is ignored by Python builds not configured with :option"
":`--disable-gil`.  Otherwise, it determines whether or not importing this"
" module will cause the GIL to be automatically enabled. See "
":ref:`whatsnew313-free-threaded-cpython` for more detail."
msgstr ""

#: ../../c-api/module.rst:442
#, fuzzy
msgid ""
"Multiple ``Py_mod_gil`` slots may not be specified in one module "
"definition."
msgstr "하나의 모듈 정의에서 여러 ``Py_mod_create`` 슬롯을 지정할 수 없습니다."

#: ../../c-api/module.rst:444
msgid ""
"If ``Py_mod_gil`` is not specified, the import machinery defaults to "
"``Py_MOD_GIL_USED``."
msgstr ""

#: ../../c-api/module.rst:449
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr "다단계 초기화에 대한 자세한 내용은 :PEP:`489`\\를 참조하십시오."

#: ../../c-api/module.rst:452
msgid "Low-level module creation functions"
msgstr "저수준 모듈 생성 함수"

#: ../../c-api/module.rst:454
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating "
"module objects dynamically. Note that both ``PyModule_FromDefAndSpec`` "
"and ``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"다단계 초기화를 사용할 때 수면 아래에서는 다음 함수가 호출됩니다. 이들은 직접 사용할 수 있는데, 예를 들어 모듈 객체를 동적으로"
" 생성할 때 그렇습니다. 모듈을 완전히 초기화하려면 ``PyModule_FromDefAndSpec``\\과 "
"``PyModule_ExecDef``\\를 모두 호출해야 함에 유의하십시오."

#: ../../c-api/module.rst:461
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def* and the "
"ModuleSpec *spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` "
"with *module_api_version* set to :c:macro:`PYTHON_API_VERSION`."
msgstr ""
"주어진 *모듈*\\의 정의와 ModuleSpec *spec*\\으로 새 모듈 객체를 만듭니다. 이것은 "
"*module_api_version*\\이 :const:`PYTHON_API_VERSION`\\으로 설정된 "
":c:func:`PyModule_FromDefAndSpec2`\\처럼 동작합니다."

#: ../../c-api/module.rst:469
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def* and the "
"ModuleSpec *spec*, assuming the API version *module_api_version*. If that"
" version does not match the version of the running interpreter, a "
":exc:`RuntimeWarning` is emitted."
msgstr ""
"API 버전 *module_api_version*\\을 가정하여, 주어진 *모듈*\\의 정의와 ModuleSpec "
"*spec*\\으로 새 모듈 객체를 만듭니다. 해당 버전이 실행 중인 인터프리터 버전과 일치하지 않으면, "
":exc:`RuntimeWarning`\\을 발생시킵니다."

#: ../../c-api/module.rst:478
msgid ""
"Most uses of this function should be using "
":c:func:`PyModule_FromDefAndSpec` instead; only use this if you are sure "
"you need it."
msgstr ""
"이 함수는 대부분 :c:func:`PyModule_FromDefAndSpec`\\을 대신 사용해야 합니다; 확실히 필요할 때만 "
"사용하십시오."

#: ../../c-api/module.rst:485
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr "*def*\\에 지정된 모든 실행 슬롯(:c:data:`Py_mod_exec`)을 처리합니다."

#: ../../c-api/module.rst:491
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"*module*\\의 독스트링을 *docstring*\\으로 설정합니다. 이 함수는 ``PyModule_Create``\\나 "
"``PyModule_FromDefAndSpec``\\을 사용하여 ``PyModuleDef``\\에서 모듈을 만들 때 자동으로 "
"호출됩니다."

#: ../../c-api/module.rst:500
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on"
" individual entries (due to the lack of a shared module namespace, module"
" level \"functions\" implemented in C typically receive the module as "
"their first parameter, making them similar to instance methods on Python "
"classes). This function is called automatically when creating a module "
"from ``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"``NULL`` 종료 *functions* 배열의 함수를 *module*\\에 추가합니다. 개별 항목에 대한 자세한 내용은 "
":c:type:`PyMethodDef` 설명서를 참조하십시오 (공유 모듈 이름 공간이 없기 때문에, C로 구현된 모듈 수준 "
"\"함수(functions)\"는 일반적으로 첫 번째 매개 변수로 모듈을 수신하여, 파이썬 클래스의 인스턴스 메서드와 유사하게 "
"만듭니다). 이 함수는 ``PyModule_Create``\\나 ``PyModule_FromDefAndSpec``\\을 사용하여 "
"``PyModuleDef``\\에서 모듈을 만들 때 자동으로 호출됩니다."

#: ../../c-api/module.rst:512
msgid "Support functions"
msgstr "지원 함수"

#: ../../c-api/module.rst:514
msgid ""
"The module initialization function (if using single phase initialization)"
" or a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"모듈 초기화 함수(단단계 초기화를 사용하는 경우)나 모듈 실행 슬롯에서 호출되는 함수(다단계 초기화를 사용하는 경우)는, 모듈 상태"
" 초기화를 도우려고 다음 함수를 사용할 수 있습니다:"

#: ../../c-api/module.rst:521
#, fuzzy
msgid ""
"Add an object to *module* as *name*.  This is a convenience function "
"which can be used from the module's initialization function."
msgstr ""
"*module*\\에 정수 상수를 *name*\\으로 추가합니다. 이 편의 함수는 모듈의 초기화 함수에서 사용할 수 있습니다. 에러"
" 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#: ../../c-api/module.rst:524
msgid "On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""

#: ../../c-api/module.rst:526 ../../c-api/module.rst:577
#: ../../c-api/module.rst:604
msgid "Example usage::"
msgstr ""

#: ../../c-api/module.rst:528
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""

#: ../../c-api/module.rst:540
msgid ""
"To be convenient, the function accepts ``NULL`` *value* with an exception"
" set. In this case, return ``-1`` and just leave the raised exception "
"unchanged."
msgstr ""

#: ../../c-api/module.rst:544
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""

#: ../../c-api/module.rst:547
#, python-brace-format
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""

#: ../../c-api/module.rst:556
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in "
"this case, since *obj* can be ``NULL``."
msgstr ""

#: ../../c-api/module.rst:559
msgid ""
"The number of different *name* strings passed to this function should be "
"kept small, usually by only using statically allocated strings as *name*."
" For names that aren't known at compile time, prefer calling "
":c:func:`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. "
"For more details, see :c:func:`PyUnicode_InternFromString`, which may be "
"used internally to create a key object."
msgstr ""

#: ../../c-api/module.rst:572
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but \"steals\" a reference to"
" *value*. It can be called with a result of function that returns a new "
"reference without bothering to check its result or even saving it to a "
"variable."
msgstr ""

#: ../../c-api/module.rst:579
#, python-brace-format
msgid ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"
msgstr ""

#: ../../c-api/module.rst:588
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""

#: ../../c-api/module.rst:591
msgid ""
"The new :c:func:`PyModule_Add` or :c:func:`PyModule_AddObjectRef` "
"functions are recommended, since it is easy to introduce reference leaks "
"by misusing the :c:func:`PyModule_AddObject` function."
msgstr ""

#: ../../c-api/module.rst:598
#, fuzzy
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` "
"only releases the reference to *value* **on success**."
msgstr ""
"참조를 훔치는 다른 함수와 달리, ``PyModule_AddObject()``\\는 **성공 시**\\에만 *value*\\의 참조"
" 횟수를 감소시킵니다."

#: ../../c-api/module.rst:601
#, fuzzy
msgid ""
"This means that its return value must be checked, and calling code must "
":c:func:`Py_XDECREF` *value* manually on error."
msgstr ""
"이는 반환 값을 확인해야 하며, 에러 시 호출하는 코드가 수동으로 *value*\\를 :c:func:`Py_DECREF` 해야 함을"
" 뜻합니다. 사용법 예::"

#: ../../c-api/module.rst:606
#, python-brace-format
msgid ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."
msgstr ""

#: ../../c-api/module.rst:619
msgid ":c:func:`PyModule_AddObject` is :term:`soft deprecated`."
msgstr ""

#: ../../c-api/module.rst:624
#, fuzzy
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function"
" can be used from the module's initialization function. Return ``-1`` "
"with an exception set on error, ``0`` on success."
msgstr ""
"*module*\\에 정수 상수를 *name*\\으로 추가합니다. 이 편의 함수는 모듈의 초기화 함수에서 사용할 수 있습니다. 에러"
" 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#: ../../c-api/module.rst:628
msgid ""
"This is a convenience function that calls :c:func:`PyLong_FromLong` and "
":c:func:`PyModule_AddObjectRef`; see their documentation for details."
msgstr ""

#: ../../c-api/module.rst:634
#, fuzzy
msgid ""
"Add a string constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function.  The string "
"*value* must be ``NULL``-terminated. Return ``-1`` with an exception set "
"on error, ``0`` on success."
msgstr ""
"*module*\\에 문자열 상수를 *name*\\으로 추가합니다. 이 편의 함수는 모듈의 초기화 함수에서 사용할 수 있습니다. "
"문자열 *value*\\는 ``NULL``\\로 끝나야 합니다. 에러 시 ``-1``\\을, 성공 시 ``0``\\을 반환합니다."

#: ../../c-api/module.rst:639
msgid ""
"This is a convenience function that calls "
":c:func:`PyUnicode_InternFromString` and :c:func:`PyModule_AddObjectRef`;"
" see their documentation for details."
msgstr ""

#: ../../c-api/module.rst:646
#, fuzzy
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the "
"int constant *AF_INET* with the value of *AF_INET* to *module*. Return "
"``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"*module*\\에 int 상수를 추가합니다. 이름과 값은 *macro*\\에서 취합니다. 예를 들어 "
"``PyModule_AddIntMacro(module, AF_INET)``\\은 *AF_INET* 값을 가진 int 상수 "
"*AF_INET*\\을 *module*\\에 추가합니다. 에러 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#: ../../c-api/module.rst:654
msgid "Add a string constant to *module*."
msgstr "*module*\\에 문자열 상수를 추가합니다."

#: ../../c-api/module.rst:658
#, fuzzy
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken "
"from the last component of :c:member:`~PyTypeObject.tp_name` after dot. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"*module*\\에 형 객체를 추가합니다. 내부적으로 :c:func:`PyType_Ready`\\를 호출하여 형 객체를 "
"파이널라이즈합니다. 형 객체의 이름은 점 뒤 :c:member:`~PyTypeObject.tp_name`\\의 마지막 구성 요소에서"
" 가져옵니다. 에러가 발생하면 ``-1``, 성공하면 ``0``\\을 반환합니다."

#: ../../c-api/module.rst:668
msgid ""
"Indicate that *module* does or does not support running without the "
"global interpreter lock (GIL), using one of the values from "
":c:macro:`Py_mod_gil`. It must be called during *module*'s initialization"
" function. If this function is not called during module initialization, "
"the import machinery assumes the module does not support running without "
"the GIL. This function is only available in Python builds configured with"
" :option:`--disable-gil`. Return ``-1`` with an exception set on error, "
"``0`` on success."
msgstr ""

#: ../../c-api/module.rst:681
msgid "Module lookup"
msgstr "모듈 조회"

#: ../../c-api/module.rst:683
msgid ""
"Single-phase initialization creates singleton modules that can be looked "
"up in the context of the current interpreter. This allows the module "
"object to be retrieved later with only a reference to the module "
"definition."
msgstr ""
"단단계 초기화는 현재 인터프리터의 컨텍스트에서 조회할 수 있는 싱글톤 모듈을 만듭니다. 이는 나중에 모듈 정의에 대한 참조만으로 "
"모듈 객체를 검색할 수 있도록 합니다."

#: ../../c-api/module.rst:687
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"이 함수들은 다단계 초기화를 사용하여 만들어진 모듈에서는 작동하지 않습니다. 단일 정의에서 그러한 모듈이 여러 개 만들어질 수 있기"
" 때문입니다."

#: ../../c-api/module.rst:692
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been "
"attached to the interpreter state with :c:func:`PyState_AddModule` "
"beforehand. In case the corresponding module object is not found or has "
"not been attached to the interpreter state yet, it returns ``NULL``."
msgstr ""
"현재 인터프리터에 대해 *def*\\에서 만들어진 모듈 객체를 반환합니다. 이 메서드를 사용하려면 먼저 모듈 객체가 "
":c:func:`PyState_AddModule`\\로 인터프리터 상태에 연결되어 있어야 합니다. 해당 모듈 객체를 찾을 수 없거나"
" 인터프리터 상태에 아직 연결되지 않았으면, ``NULL``\\을 반환합니다."

#: ../../c-api/module.rst:699
msgid ""
"Attaches the module object passed to the function to the interpreter "
"state. This allows the module object to be accessible via "
":c:func:`PyState_FindModule`."
msgstr ""
"함수에 전달된 모듈 객체를 인터프리터 상태에 연결합니다. 이는 :c:func:`PyState_FindModule`\\을 통해 모듈 "
"객체에 액세스 할 수 있도록 합니다."

#: ../../c-api/module.rst:702
msgid "Only effective on modules created using single-phase initialization."
msgstr "단단계 초기화를 사용하여 만든 모듈에만 효과가 있습니다."

#: ../../c-api/module.rst:704
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a "
"module, so it is unnecessary (but harmless) to call it from module "
"initialization code. An explicit call is needed only if the module's own "
"init code subsequently calls ``PyState_FindModule``. The function is "
"mainly intended for implementing alternative import mechanisms (either by"
" calling it directly, or by referring to its implementation for details "
"of the required state updates)."
msgstr ""
"파이썬은 모듈을 임포트 한 후 자동으로 ``PyState_AddModule``\\을 호출하므로, 모듈 초기화 코드에서 호출하는 것은"
" 불필요합니다 (하지만 무해합니다). 모듈의 자체 초기화 코드가 추후 ``PyState_FindModule``\\을 호출하는 "
"경우에만 명시적인 호출이 필요합니다. 이 함수는 주로 대안 임포트 메커니즘을 구현하기 위한 것입니다 (직접 호출하거나, 필요한 상태"
" 갱신에 대한 자세한 내용에 대해 해당 구현을 참조함으로써)."

#: ../../c-api/module.rst:712 ../../c-api/module.rst:723
msgid "The caller must hold the GIL."
msgstr "호출자는 GIL을 보유해야 합니다."

#: ../../c-api/module.rst:714
msgid "Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""

#: ../../c-api/module.rst:720
#, fuzzy
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr "*def*\\에서 만들어진 모듈 객체를 인터프리터 상태에서 제거합니다. 성공하면 0을, 실패하면 -1을 반환합니다."

#: ../../c-api/module.rst:8
#, fuzzy
msgid "object"
msgstr "모듈 객체"

#: ../../c-api/module.rst:8
#, fuzzy
msgid "module"
msgstr "모듈 조회"

#: ../../c-api/module.rst:13
msgid "ModuleType (in module types)"
msgstr ""

#: ../../c-api/module.rst:33 ../../c-api/module.rst:77
msgid "__name__ (module attribute)"
msgstr ""

#: ../../c-api/module.rst:33
msgid "__doc__ (module attribute)"
msgstr ""

#: ../../c-api/module.rst:33 ../../c-api/module.rst:108
msgid "__file__ (module attribute)"
msgstr ""

#: ../../c-api/module.rst:33
msgid "__package__ (module attribute)"
msgstr ""

#: ../../c-api/module.rst:33
msgid "__loader__ (module attribute)"
msgstr ""

#: ../../c-api/module.rst:63
msgid "__dict__ (module attribute)"
msgstr ""

#: ../../c-api/module.rst:77 ../../c-api/module.rst:108
msgid "SystemError (built-in exception)"
msgstr ""

#~ msgid ""
#~ "Add an object to *module* as "
#~ "*name*.  This is a convenience function"
#~ " which can be used from the "
#~ "module's initialization function.  This steals"
#~ " a reference to *value* on success."
#~ " Return ``-1`` on error, ``0`` on "
#~ "success."
#~ msgstr ""
#~ "*name*\\으로 *module*\\에 객체를 추가합니다. 모듈의 "
#~ "초기화 함수에서 사용할 수 있는 편의 함수입니다. "
#~ "성공 시 *value*\\에 대한 참조를 훔칩니다. 에러"
#~ " 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#~ msgid "Return 0 on success or -1 on failure."
#~ msgstr "성공하면 0을, 실패하면 -1을 반환합니다."

