# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr "초기화, 파이널리제이션 및 스레드"

#: ../../c-api/init.rst:10
#, fuzzy
msgid ""
"See :ref:`Python Initialization Configuration <init-config>` for details "
"on how to configure the interpreter prior to initialization."
msgstr ":ref:`파이썬 초기화 구성 <init-config>`\\도 참조하십시오."

#: ../../c-api/init.rst:16
msgid "Before Python Initialization"
msgstr "파이썬 초기화 전"

#: ../../c-api/init.rst:18
msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function"
" must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables"
" <global-conf-vars>`."
msgstr ""
"파이썬을 내장한 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기 전에 :c:func:`Py_Initialize` 함수를"
" 호출해야 합니다; 몇 가지 함수와 :ref:`전역 구성 변수 <global-conf-vars>`\\는 예외입니다."

#: ../../c-api/init.rst:23
msgid "The following functions can be safely called before Python is initialized:"
msgstr "파이썬이 초기화되기 전에 다음 함수를 안전하게 호출할 수 있습니다:"

#: ../../c-api/init.rst:25
msgid "Functions that initialize the interpreter:"
msgstr ""

#: ../../c-api/init.rst:27
#, fuzzy
msgid ":c:func:`Py_Initialize`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:28
#, fuzzy
msgid ":c:func:`Py_InitializeEx`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:29
#, fuzzy
msgid ":c:func:`Py_InitializeFromConfig`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:30
#, fuzzy
msgid ":c:func:`Py_BytesMain`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:31
#, fuzzy
msgid ":c:func:`Py_Main`"
msgstr ":c:func:`Py_SetPath`"

#: ../../c-api/init.rst:32
msgid "the runtime pre-initialization functions covered in :ref:`init-config`"
msgstr ""

#: ../../c-api/init.rst:34
msgid "Configuration functions:"
msgstr "구성 함수:"

#: ../../c-api/init.rst:36
msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

#: ../../c-api/init.rst:37
msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

#: ../../c-api/init.rst:38
#, fuzzy
msgid ":c:func:`!PyInitFrozenExtensions`"
msgstr ":c:func:`PyInitFrozenExtensions`"

#: ../../c-api/init.rst:39
msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

#: ../../c-api/init.rst:40
msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

#: ../../c-api/init.rst:41
msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

#: ../../c-api/init.rst:42
msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

#: ../../c-api/init.rst:43
msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

#: ../../c-api/init.rst:44
msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

#: ../../c-api/init.rst:45
msgid "the configuration functions covered in :ref:`init-config`"
msgstr ""

#: ../../c-api/init.rst:47
msgid "Informative functions:"
msgstr "정보 함수:"

#: ../../c-api/init.rst:49 ../../c-api/init.rst:57
msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:50
msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

#: ../../c-api/init.rst:51
msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

#: ../../c-api/init.rst:52
msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

#: ../../c-api/init.rst:53
msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

#: ../../c-api/init.rst:54
msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

#: ../../c-api/init.rst:55
msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

#: ../../c-api/init.rst:56
msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:59
msgid "Utilities:"
msgstr "유틸리티:"

#: ../../c-api/init.rst:61
msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

#: ../../c-api/init.rst:62
msgid "the status reporting and utility functions covered in :ref:`init-config`"
msgstr ""

#: ../../c-api/init.rst:64
msgid "Memory allocators:"
msgstr "메모리 할당자:"

#: ../../c-api/init.rst:66
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:67
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/init.rst:68
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/init.rst:69
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/init.rst:71
#, fuzzy
msgid "Synchronization:"
msgstr "비동기 알림"

#: ../../c-api/init.rst:73
#, fuzzy
msgid ":c:func:`PyMutex_Lock`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:74
#, fuzzy
msgid ":c:func:`PyMutex_Unlock`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:78
#, fuzzy
msgid ""
"Despite their apparent similarity to some of the functions listed above, "
"the following functions **should not be called** before the interpreter "
"has been initialized: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, "
":c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, "
":c:func:`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, "
":c:func:`Py_GetProgramName`, :c:func:`PyEval_InitThreads`, and "
":c:func:`Py_RunMain`."
msgstr ""
"다음 함수는 :c:func:`Py_Initialize` 전에 **호출하면 안 됩니다**: "
":c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, "
":c:func:`Py_GetExecPrefix`, :c:func:`Py_GetProgramFullPath`, "
":c:func:`Py_GetPythonHome`, :c:func:`Py_GetProgramName` 및 "
":c:func:`PyEval_InitThreads`."

#: ../../c-api/init.rst:90
msgid "Global configuration variables"
msgstr "전역 구성 변수"

#: ../../c-api/init.rst:92
msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled by "
":ref:`command line options <using-on-interface-options>`."
msgstr ""
"파이썬에는 다양한 기능과 옵션을 제어하기 위한 전역 구성 변수가 있습니다. 기본적으로, 이러한 플래그는 :ref:`명령 줄 옵션 "
"<using-on-interface-options>`\\에 의해 제어됩니다."

#: ../../c-api/init.rst:96
msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` sets "
":c:data:`Py_BytesWarningFlag` to 1 and ``-bb`` sets "
":c:data:`Py_BytesWarningFlag` to 2."
msgstr ""
"옵션에 의해 플래그가 설정되면, 플래그 값은 옵션이 설정된 횟수입니다. 예를 들어, ``-b``\\는 "
":c:data:`Py_BytesWarningFlag` 를 1로 설정하고 ``-bb``\\는 "
":c:data:`Py_BytesWarningFlag` 를 2로 설정합니다."

#: ../../c-api/init.rst:102
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.bytes_warning` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:106
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with "
":class:`str` or :class:`bytes` with :class:`int`.  Issue an error if "
"greater or equal to ``2``."
msgstr ""
":class:`bytes`\\나 :class:`bytearray`\\와 :class:`str`\\을, 또는 "
":class:`bytes`\\를 :class:`int`\\와 비교할 때 경고를 발행합니다. ``2``\\보다 크거나 같으면 에러를 "
"발행합니다."

#: ../../c-api/init.rst:110
msgid "Set by the :option:`-b` option."
msgstr ":option:`-b` 옵션으로 설정합니다."

#: ../../c-api/init.rst:116
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.parser_debug` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:120
msgid ""
"Turn on parser debugging output (for expert only, depending on "
"compilation options)."
msgstr "구문 분석기 디버깅 출력을 켭니다 (전문가 전용, 컴파일 옵션에 의존합니다)."

#: ../../c-api/init.rst:123
msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr ":option:`-d` 옵션과 :envvar:`PYTHONDEBUG` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:130
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.write_bytecode` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:134
msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the "
"import of source modules."
msgstr "0이 아닌 값으로 설정하면, 파이썬은 소스 모듈을 임포트 할 때 ``.pyc`` 파일을 쓰려고 하지 않습니다."

#: ../../c-api/init.rst:137
msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ":option:`-B` 옵션과 :envvar:`PYTHONDONTWRITEBYTECODE` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:144
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.pathconfig_warnings` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:148
msgid ""
"Suppress error messages when calculating the module search path in "
":c:func:`Py_GetPath`."
msgstr ":c:func:`Py_GetPath`\\에서 모듈 검색 경로를 계산할 때 에러 메시지를 표시하지 않습니다."

#: ../../c-api/init.rst:151
#, fuzzy
msgid "Private flag used by ``_freeze_module`` and ``frozenmain`` programs."
msgstr "``_freeze_importlib``\\와 ``frozenmain`` 프로그램에서 사용하는 개인 플래그입니다."

#: ../../c-api/init.rst:157
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.hash_seed` and :c:member:`PyConfig.use_hash_seed` "
"should be used instead, see :ref:`Python Initialization Configuration "
"<init-config>`."
msgstr ""

#: ../../c-api/init.rst:162
msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set "
"to a non-empty string."
msgstr ":envvar:`PYTHONHASHSEED` 환경 변수가 비어 있지 않은 문자열로 설정되면 ``1``\\로 설정합니다."

#: ../../c-api/init.rst:165
msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr "플래그가 0이 아니면, :envvar:`PYTHONHASHSEED` 환경 변수를 읽어 비밀 해시 시드를 초기화합니다."

#: ../../c-api/init.rst:172
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.use_environment` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:176
#, fuzzy
msgid ""
"Ignore all :envvar:`!PYTHON*` environment variables, e.g. "
":envvar:`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""
"설정될 수 있는 모든 :envvar:`PYTHON*` 환경 변수 (예를 들어 :envvar:`PYTHONPATH`\\와 "
":envvar:`PYTHONHOME`)를 무시합니다."

#: ../../c-api/init.rst:179
msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr ":option:`-E`\\와 :option:`-I` 옵션으로 설정됩니다."

#: ../../c-api/init.rst:185
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.inspect` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:189
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, "
"even when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"스크립트가 첫 번째 인자로 전달되거나 :option:`-c` 옵션을 사용할 때, :data:`sys.stdin`\\가 터미널로 "
"보이지 않더라도 스크립트나 명령을 실행한 후 대화 형 모드로 들어갑니다."

#: ../../c-api/init.rst:193
msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` "
"environment variable."
msgstr ":option:`-i` 옵션과 :envvar:`PYTHONINSPECT` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:200
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.interactive` should be used instead, see :ref:`Python"
" Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:204
msgid "Set by the :option:`-i` option."
msgstr ":option:`-i` 옵션으로 설정됩니다."

#: ../../c-api/init.rst:210
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.isolated` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:214
msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"격리 모드로 파이썬을 실행합니다. 격리 모드에서 :data:`sys.path`\\는 스크립트의 디렉터리도 사용자의 site-"
"packages 디렉터리도 포함하지 않습니다."

#: ../../c-api/init.rst:217
msgid "Set by the :option:`-I` option."
msgstr ":option:`-I` 옵션으로 설정됩니다."

#: ../../c-api/init.rst:225
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyPreConfig.legacy_windows_fs_encoding` should be used "
"instead, see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:229
#, fuzzy
msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error"
" handler, instead of the UTF-8 encoding with ``surrogatepass`` error "
"handler, for the :term:`filesystem encoding and error handler`."
msgstr "플래그가 0이 아니면, 파일 시스템 인코딩에 UTF-8 인코딩 대신 ``mbcs`` 인코딩을 사용합니다."

#: ../../c-api/init.rst:233
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
":envvar:`PYTHONLEGACYWINDOWSFSENCODING` 환경 변수가 비어 있지 않은 문자열로 설정되면 "
"``1``\\로 설정합니다."

#: ../../c-api/init.rst:236
msgid "See :pep:`529` for more details."
msgstr "자세한 내용은 :pep:`529`\\를 참조하십시오."

#: ../../c-api/init.rst:238 ../../c-api/init.rst:256
msgid "Availability"
msgstr "가용성"

#: ../../c-api/init.rst:244
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.legacy_windows_stdio` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:248
#, fuzzy
msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of "
":class:`!io._WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""
"플래그가 0이 아니면, :mod:`sys` 표준 스트림을 위해 :class:`WindowsConsoleIO` 대신 "
":class:`io.FileIO`\\를 사용합니다."

#: ../../c-api/init.rst:251
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment "
"variable is set to a non-empty string."
msgstr ""
":envvar:`PYTHONLEGACYWINDOWSSTDIO` 환경 변수가 비어 있지 않은 문자열로 설정되면 ``1``\\로 "
"설정합니다."

#: ../../c-api/init.rst:254
msgid "See :pep:`528` for more details."
msgstr "자세한 내용은 :pep:`528`\\을 참조하십시오."

#: ../../c-api/init.rst:262
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.site_import` should be used instead, see :ref:`Python"
" Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:266
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call "
":func:`site.main` if you want them to be triggered)."
msgstr ""
"모듈 :mod:`site` 임포트와 이에 수반되는 :data:`sys.path`\\의 사이트 종속적인 조작을 비활성화합니다. 또한 "
"나중에 :mod:`site`\\를 명시적으로 임포트 할 때도 이러한 조작을 비활성화합니다 (트리거 하려면 "
":func:`site.main`\\을 호출하십시오)."

#: ../../c-api/init.rst:271
msgid "Set by the :option:`-S` option."
msgstr ":option:`-S` 옵션으로 설정됩니다."

#: ../../c-api/init.rst:277
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.user_site_directory` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:281
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to "
":data:`sys.path`."
msgstr ""
":data:`사용자 site-packages 디렉터리 <site.USER_SITE>`\\를 :data:`sys.path`\\에 "
"추가하지 않습니다."

#: ../../c-api/init.rst:284
msgid ""
"Set by the :option:`-s` and :option:`-I` options, and the "
":envvar:`PYTHONNOUSERSITE` environment variable."
msgstr ""
":option:`-s`\\와 :option:`-I` 옵션, 그리고 :envvar:`PYTHONNOUSERSITE` 환경 변수로 "
"설정됩니다."

#: ../../c-api/init.rst:291
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.optimization_level` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:295
msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` "
"environment variable."
msgstr ":option:`-O` 옵션과 :envvar:`PYTHONOPTIMIZE` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:302
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.quiet` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:306
msgid "Don't display the copyright and version messages even in interactive mode."
msgstr "대화형 모드에서도 저작권과 버전 메시지를 표시하지 않습니다."

#: ../../c-api/init.rst:308
msgid "Set by the :option:`-q` option."
msgstr ":option:`-q` 옵션으로 설정됩니다."

#: ../../c-api/init.rst:316
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.buffered_stdio` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:320
msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "stdout과 stderr 스트림을 버퍼링 해제하도록 강제합니다."

#: ../../c-api/init.rst:322
msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ":option:`-u` 옵션과 :envvar:`PYTHONUNBUFFERED` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:329
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.verbose` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:333
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or "
"equal to ``2``, print a message for each file that is checked for when "
"searching for a module. Also provides information on module cleanup at "
"exit."
msgstr ""
"모듈이 초기화될 때마다, 로드된 위치(파일명이나 내장 모듈)를 표시하는 메시지를 인쇄합니다. ``2``\\보다 크거나 같으면, "
"모듈을 검색할 때 검사되는 각 파일에 대한 메시지를 인쇄합니다. 또한 종료 시 모듈 정리에 대한 정보를 제공합니다."

#: ../../c-api/init.rst:338
msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` "
"environment variable."
msgstr ":option:`-v` 옵션과 :envvar:`PYTHONVERBOSE` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:345
msgid "Initializing and finalizing the interpreter"
msgstr "인터프리터 초기화와 파이널리제이션"

#: ../../c-api/init.rst:360
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; see "
":ref:`Before Python Initialization <pre-init-safe>` for the few "
"exceptions."
msgstr ""
"파이썬 인터프리터를 초기화합니다. 파이썬을 내장하는 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기 전에 호출해야 "
"합니다; 몇 가지 예외는 :ref:`파이썬 초기화 전 <pre-init-safe>`\\을 참조하십시오."

#: ../../c-api/init.rst:364
#, fuzzy
msgid ""
"This initializes the table of loaded modules (``sys.modules``), and "
"creates the fundamental modules :mod:`builtins`, :mod:`__main__` and "
":mod:`sys`. It also initializes the module search path (``sys.path``). It"
" does not set ``sys.argv``; use the :ref:`Python Initialization "
"Configuration <init-config>` API for that. This is a no-op when called "
"for a second time (without calling :c:func:`Py_FinalizeEx` first).  There"
" is no return value; it is a fatal error if the initialization fails."
msgstr ""
"이것은 로드된 모듈의 테이블(``sys.modules``)을 초기화하고, 기반 모듈 :mod:`builtins`, "
":mod:`__main__` 및 :mod:`sys`\\를 만듭니다. 또한, 모듈 검색 경로(``sys.path``)를 초기화합니다."
" ``sys.argv``\\는 설정하지 않습니다; 이를 위해서는 :c:func:`PySys_SetArgvEx` 를 사용하십시오.  "
"(:c:func:`Py_FinalizeEx` 를 먼저 호출하지 않고) 두 번째로 호출하면 아무런 일도 하지 않습니다. 반환 값이 "
"없습니다; 초기화에 실패하면 치명적인 에러입니다."

#: ../../c-api/init.rst:372 ../../c-api/init.rst:386
#, fuzzy
msgid ""
"Use :c:func:`Py_InitializeFromConfig` to customize the :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ":ref:`파이썬 초기화 구성 <init-config>`\\도 참조하십시오."

#: ../../c-api/init.rst:376
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, "
"which will also affect non-Python uses of the console using the C "
"Runtime."
msgstr ""
"윈도우에서, 콘솔 모드를 ``O_TEXT``\\에서 ``O_BINARY``\\로 변경합니다, C 런타임을 사용하는 콘솔의 비 파이썬"
" 사용에도 영향을 미칩니다."

#: ../../c-api/init.rst:382
#, fuzzy
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. "
"If *initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which may be useful when CPython is embedded as part of a "
"larger application."
msgstr ""
"이 함수는 *initsigs*\\가 ``1``\\이면 :c:func:`Py_Initialize`\\처럼 작동합니다. "
"*initsigs*\\가 ``0``\\이면, 시그널 처리기의 초기화 등록을 건너뛰는데, 파이썬이 내장될 때 유용할 수 있습니다."

#: ../../c-api/init.rst:392
msgid ""
"Initialize Python from *config* configuration, as described in :ref"
":`init-from-config`."
msgstr ""

#: ../../c-api/init.rst:395
msgid ""
"See the :ref:`init-config` section for details on pre-initializing the "
"interpreter, populating the runtime configuration structure, and querying"
" the returned status structure."
msgstr ""

#: ../../c-api/init.rst:402
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this "
"returns false until :c:func:`Py_Initialize` is called again."
msgstr ""
"파이썬 인터프리터가 초기화되었으면 참(0이 아님)을 반환하고, 그렇지 않으면 거짓(0)을 반환합니다. "
":c:func:`Py_FinalizeEx` 가 호출된 후, :c:func:`Py_Initialize`\\가 다시 호출될 때까지 "
"거짓을 반환합니다."

#: ../../c-api/init.rst:409
msgid ""
"Return true (non-zero) if the main Python interpreter is :term:`shutting "
"down <interpreter shutdown>`. Return false (zero) otherwise."
msgstr ""

#: ../../c-api/init.rst:417
#, fuzzy
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent "
"use of Python/C API functions, and destroy all sub-interpreters (see "
":c:func:`Py_NewInterpreter` below) that were created and not yet "
"destroyed since the last call to :c:func:`Py_Initialize`.  Ideally, this "
"frees all memory allocated by the Python interpreter.  This is a no-op "
"when called for a second time (without calling :c:func:`Py_Initialize` "
"again first)."
msgstr ""
":c:func:`Py_Initialize`\\와 후속 파이썬/C API 함수 사용에 의해 수행된 모든 초기화를 실행 취소하고, "
":c:func:`Py_Initialize`\\에 대한 마지막 호출 이후 만들어졌지만, 아직 삭제되지 않은 모든 서브 인터프리터(아래"
" :c:func:`Py_NewInterpreter`\\를 참조하십시오)를 제거합니다. 이상적으로, 이것은 파이썬 인터프리터가 할당한"
" 모든 메모리를 해제합니다.  (먼저 :c:func:`Py_Initialize`\\를 다시 호출하지 않고) 두 번째로 호출하면 "
"아무런 일도 하지 않습니다. 일반적으로 반환 값은 ``0``\\입니다. 파이널리제이션 도중 에러가 발생하면 (버퍼링 된 데이터 "
"플러시) ``-1``\\이 반환됩니다."

#: ../../c-api/init.rst:424
msgid ""
"Since this is the reverse of :c:func:`Py_Initialize`, it should be called"
" in the same thread with the same interpreter active.  That means the "
"main thread and the main interpreter. This should never be called while "
":c:func:`Py_RunMain` is running."
msgstr ""

#: ../../c-api/init.rst:429
msgid ""
"Normally the return value is ``0``. If there were errors during "
"finalization (flushing buffered data), ``-1`` is returned."
msgstr ""

#: ../../c-api/init.rst:433
msgid ""
"This function is provided for a number of reasons.  An embedding "
"application might want to restart Python without having to restart the "
"application itself. An application that has loaded the Python interpreter"
" from a dynamically loadable library (or DLL) might want to free all "
"memory allocated by Python before unloading the DLL. During a hunt for "
"memory leaks in an application a developer might want to free all memory "
"allocated by Python before exiting from the application."
msgstr ""
"이 함수는 여러 가지 이유로 제공됩니다. 내장 응용 프로그램이 응용 프로그램 자체를 다시 시작하지 않고 파이썬을 다시 시작하고 싶을"
" 수 있습니다. 동적으로 로드할 수 있는 라이브러리(또는 DLL)에서 파이썬 인터프리터를 로드한 응용 프로그램은 DLL을 언로드 "
"하기 전에 파이썬이 할당한 모든 메모리를 해제하고 싶을 수 있습니다. 응용 프로그램에서 메모리 누수를 찾는 동안 개발자는 응용 "
"프로그램을 종료하기 전에 파이썬에서 할당한 모든 메모리를 해제하고 싶을 것입니다."

#: ../../c-api/init.rst:441
#, fuzzy
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules "
"is done in random order; this may cause destructors "
"(:meth:`~object.__del__` methods) to fail when they depend on other "
"objects (even functions) or modules.  Dynamically loaded extension "
"modules loaded by Python are not unloaded.  Small amounts of memory "
"allocated by the Python interpreter may not be freed (if you find a leak,"
" please report it).  Memory tied up in circular references between "
"objects is not freed.  Some memory allocated by extension modules may not"
" be freed.  Some extensions may not work properly if their initialization"
" routine is called more than once; this can happen if an application "
"calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` more than once."
msgstr ""
"**버그와 주의 사항:** 모듈의 모듈과 객체 파괴는 임의의 순서로 수행됩니다; 이로 인해 파괴자(:meth:`__del__` "
"메서드)가 다른 객체(함수조차)나 모듈에 의존할 때 실패할 수 있습니다. 파이썬에서 로드한 동적으로 로드된 확장 모듈은 언로드 되지"
" 않습니다. 파이썬 인터프리터가 할당한 소량의 메모리는 해제되지 않을 수 있습니다 (누수를 발견하면, 보고해 주십시오). 객체 간의"
" 순환 참조에 묶여있는 메모리는 해제되지 않습니다. 확장 모듈이 할당한 일부 메모리는 해제되지 않을 수 있습니다. 일부 확장은 "
"초기화 루틴이 두 번 이상 호출되면 제대로 작동하지 않을 수 있습니다; 응용 프로그램이 "
":c:func:`Py_Initialize`\\와 :c:func:`Py_FinalizeEx`\\를 두 번 이상 호출하면 이 문제가 "
"발생할 수 있습니다."

#: ../../c-api/init.rst:452
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython._PySys_ClearAuditHooks`` with no arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트 <auditing>` ``cpython._PySys_ClearAuditHooks`` 를 "
"발생시킵니다."

#: ../../c-api/init.rst:459
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr "이것은 :c:func:`Py_FinalizeEx`\\의 이전 버전과 호환되는 반환 값을 무시하는 버전입니다."

#: ../../c-api/init.rst:465
msgid ""
"Similar to :c:func:`Py_Main` but *argv* is an array of bytes strings, "
"allowing the calling application to delegate the text decoding step to "
"the CPython runtime."
msgstr ""

#: ../../c-api/init.rst:474
msgid ""
"The main program for the standard interpreter, encapsulating a full "
"initialization/finalization cycle, as well as additional behaviour to "
"implement reading configurations settings from the environment and "
"command line, and then executing ``__main__`` in accordance with :ref"
":`using-on-cmdline`."
msgstr ""

#: ../../c-api/init.rst:480
msgid ""
"This is made available for programs which wish to support the full "
"CPython command line interface, rather than just embedding a Python "
"runtime in a larger application."
msgstr ""

#: ../../c-api/init.rst:484
msgid ""
"The *argc* and *argv* parameters are similar to those which are passed to"
" a C program's :c:func:`main` function, except that the *argv* entries "
"are first converted to ``wchar_t`` using :c:func:`Py_DecodeLocale`. It is"
" also important to note that the argument list entries may be modified to"
" point to strings other than those passed in (however, the contents of "
"the strings pointed to by the argument list are not modified)."
msgstr ""

#: ../../c-api/init.rst:491
msgid ""
"The return value will be ``0`` if the interpreter exits normally (i.e., "
"without an exception), ``1`` if the interpreter exits due to an "
"exception, or ``2`` if the argument list does not represent a valid "
"Python command line."
msgstr ""

#: ../../c-api/init.rst:496
msgid ""
"Note that if an otherwise unhandled :exc:`SystemExit` is raised, this "
"function will not return ``1``, but exit the process, as long as "
"``Py_InspectFlag`` is not set. If ``Py_InspectFlag`` is set, execution "
"will drop into the interactive Python prompt, at which point a second "
"otherwise unhandled :exc:`SystemExit` will still exit the process, while "
"any other means of exiting will set the return value as described above."
msgstr ""

#: ../../c-api/init.rst:503
msgid ""
"In terms of the CPython runtime configuration APIs documented in the "
":ref:`runtime configuration <init-config>` section (and without "
"accounting for error handling), ``Py_Main`` is approximately equivalent "
"to::"
msgstr ""

#: ../../c-api/init.rst:507
msgid ""
"PyConfig config;\n"
"PyConfig_InitPythonConfig(&config);\n"
"PyConfig_SetArgv(&config, argc, argv);\n"
"Py_InitializeFromConfig(&config);\n"
"PyConfig_Clear(&config);\n"
"\n"
"Py_RunMain();"
msgstr ""

#: ../../c-api/init.rst:515
msgid ""
"In normal usage, an embedding application will call this function "
"*instead* of calling :c:func:`Py_Initialize`, :c:func:`Py_InitializeEx` "
"or :c:func:`Py_InitializeFromConfig` directly, and all settings will be "
"applied as described elsewhere in this documentation. If this function is"
" instead called *after* a preceding runtime initialization API call, then"
" exactly which environmental and command line configuration settings will"
" be updated is version dependent (as it depends on which settings "
"correctly support being modified after they have already been set once "
"when the runtime was first initialized)."
msgstr ""

#: ../../c-api/init.rst:528
msgid "Executes the main module in a fully configured CPython runtime."
msgstr ""

#: ../../c-api/init.rst:530
msgid ""
"Executes the command (:c:member:`PyConfig.run_command`), the script "
"(:c:member:`PyConfig.run_filename`) or the module "
"(:c:member:`PyConfig.run_module`) specified on the command line or in the"
" configuration. If none of these values are set, runs the interactive "
"Python prompt (REPL) using the ``__main__`` module's global namespace."
msgstr ""

#: ../../c-api/init.rst:536
msgid ""
"If :c:member:`PyConfig.inspect` is not set (the default), the return "
"value will be ``0`` if the interpreter exits normally (that is, without "
"raising an exception), or ``1`` if the interpreter exits due to an "
"exception. If an otherwise unhandled :exc:`SystemExit` is raised, the "
"function will immediately exit the process instead of returning ``1``."
msgstr ""

#: ../../c-api/init.rst:542
msgid ""
"If :c:member:`PyConfig.inspect` is set (such as when the :option:`-i` "
"option is used), rather than returning when the interpreter exits, "
"execution will instead resume in an interactive Python prompt (REPL) "
"using the ``__main__`` module's global namespace. If the interpreter "
"exited with an exception, it is immediately raised in the REPL session. "
"The function return value is then determined by the way the *REPL "
"session* terminates: returning ``0`` if the session terminates without "
"raising an unhandled exception, exiting immediately for an unhandled "
":exc:`SystemExit`, and returning ``1`` for any other unhandled exception."
msgstr ""

#: ../../c-api/init.rst:552
msgid ""
"This function always finalizes the Python interpreter regardless of "
"whether it returns a value or immediately exits the process due to an "
"unhandled :exc:`SystemExit` exception."
msgstr ""

#: ../../c-api/init.rst:556
msgid ""
"See :ref:`Python Configuration <init-python-config>` for an example of a "
"customized Python that always runs in isolated mode using "
":c:func:`Py_RunMain`."
msgstr ""

#: ../../c-api/init.rst:562
msgid ""
"Register an :mod:`atexit` callback for the target interpreter *interp*. "
"This is similar to :c:func:`Py_AtExit`, but takes an explicit interpreter"
" and data pointer for the callback."
msgstr ""

#: ../../c-api/init.rst:566
msgid "The :term:`GIL` must be held for *interp*."
msgstr ""

#: ../../c-api/init.rst:571
msgid "Process-wide parameters"
msgstr "프로세스 전체 매개 변수"

#: ../../c-api/init.rst:581
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.program_name` should be used instead, see "
":ref:`Python Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:585
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called "
"for the first time, if it is called at all.  It tells the interpreter the"
" value of the ``argv[0]`` argument to the :c:func:`main` function of the "
"program (converted to wide characters). This is used by "
":c:func:`Py_GetPath` and some other functions below to find the Python "
"run-time libraries relative to the interpreter executable.  The default "
"value is ``'python'``.  The argument should point to a zero-terminated "
"wide character string in static storage whose contents will not change "
"for the duration of the program's execution.  No code in the Python "
"interpreter will change the contents of this storage."
msgstr ""
"(호출된다면) 이 함수는 :c:func:`Py_Initialize`\\가 처음으로 호출되기 전에 호출되어야 합니다. 인터프리터에게 "
"프로그램의 :c:func:`main` 함수에 대한 ``argv[0]`` 인자의 값을 알려줍니다 (와이드 문자로 변환됩니다). 이것은"
" :c:func:`Py_GetPath`\\와 아래의 다른 함수에서 인터프리터 실행 파일과 관련된 파이썬 런타임 라이브러리를 찾는 데"
" 사용됩니다. 기본값은 ``'python'``\\입니다. 인자는 프로그램을 실행하는 동안 내용이 변경되지 않는 정적 저장소의 0으로"
" 끝나는 와이드 문자열을 가리켜야 합니다. 파이썬 인터프리터의 코드는 이 저장소의 내용을 변경하지 않습니다."

#: ../../c-api/init.rst:596 ../../c-api/init.rst:838 ../../c-api/init.rst:874
#: ../../c-api/init.rst:900
#, fuzzy
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a "
":c:expr:`wchar_t*` string."
msgstr ""
"바이트 문자열을 디코딩하여 :c:type:`wchar_*` 문자열을 얻는데 :c:func:`Py_DecodeLocale`\\을 "
"사용합니다."

#: ../../c-api/init.rst:604
#, fuzzy
msgid ""
"Return the program name set with :c:member:`PyConfig.program_name`, or "
"the default. The returned string points into static storage; the caller "
"should not modify its value."
msgstr ""
":c:func:`Py_SetProgramName` 으로 설정된 프로그램 이름이나 기본값을 반환합니다. 반환된 문자열은 정적 저장소를"
" 가리킵니다; 호출자는 값을 수정해서는 안 됩니다."

#: ../../c-api/init.rst:608 ../../c-api/init.rst:630 ../../c-api/init.rst:676
#: ../../c-api/init.rst:698 ../../c-api/init.rst:724 ../../c-api/init.rst:912
#, fuzzy
msgid ""
"This function should not be called before :c:func:`Py_Initialize`, "
"otherwise it returns ``NULL``."
msgstr "이 함수는 더는 :c:func:`Py_Initialize()` 전에 호출할 수 없습니다."

#: ../../c-api/init.rst:611 ../../c-api/init.rst:633 ../../c-api/init.rst:679
#: ../../c-api/init.rst:701 ../../c-api/init.rst:729 ../../c-api/init.rst:915
#, fuzzy
msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr "다음 함수는 모두 :c:func:`Py_Initialize` 이후에 호출되어야 합니다."

#: ../../c-api/init.rst:614 ../../c-api/init.rst:704
msgid "Get :data:`sys.executable` instead."
msgstr ""

#: ../../c-api/init.rst:620
#, fuzzy
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:member:`PyConfig.program_name` and some environment variables; "
"for example, if the program name is ``'/usr/local/bin/python'``, the "
"prefix is ``'/usr/local'``. The returned string points into static "
"storage; the caller should not modify its value.  This corresponds to the"
" :makevar:`prefix` variable in the top-level :file:`Makefile` and the "
":option:`--prefix` argument to the :program:`configure` script at build "
"time.  The value is available to Python code as ``sys.base_prefix``. It "
"is only useful on Unix.  See also the next function."
msgstr ""
"설치된 플랫폼 독립적 파일에 대한 *prefix*\\를 반환합니다. 이것은 :c:func:`Py_SetProgramName` 으로 "
"설정된 프로그램 이름과 일부 환경 변수의 여러 복잡한 규칙을 통해 파생됩니다; 예를 들어, 프로그램 이름이 "
"``'/usr/local/bin/python'``\\이면, prefix는 ``'/usr/local'``\\입니다. 반환된 문자열은 "
"정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이는 최상위 수준 :file:`Makefile`\\의 "
":makevar:`prefix` 변수와 빌드 시 :program:`configure` 스크립트의 ``--prefix`` 인자에 "
"해당합니다. 이 값은 파이썬 코드에서 ``sys.prefix``\\로 사용할 수 있습니다. 유닉스에서만 유용합니다. 다음 함수도 "
"참조하십시오."

#: ../../c-api/init.rst:636
msgid ""
"Get :data:`sys.base_prefix` instead, or :data:`sys.prefix` if "
":ref:`virtual environments <venv-def>` need to be handled."
msgstr ""

#: ../../c-api/init.rst:643
#, fuzzy
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This "
"is derived through a number of complicated rules from the program name "
"set with :c:member:`PyConfig.program_name` and some environment "
"variables; for example, if the program name is "
"``'/usr/local/bin/python'``, the exec-prefix is ``'/usr/local'``.  The "
"returned string points into static storage; the caller should not modify "
"its value.  This corresponds to the :makevar:`exec_prefix` variable in "
"the top-level :file:`Makefile` and the ``--exec-prefix`` argument to the "
":program:`configure` script at build  time.  The value is available to "
"Python code as ``sys.base_exec_prefix``.  It is only useful on Unix."
msgstr ""
"설치된 플랫폼-*종속적* 파일에 대한 *exec-prefix*\\를 반환합니다. 이것은 "
":c:func:`Py_SetProgramName` 으로 설정된 프로그램 이름과 일부 환경 변수의 여러 복잡한 규칙을 통해 "
"파생됩니다; 예를 들어 프로그램 이름이 ``'/usr/local/bin/python'``\\이면, exec-prefix는 "
"``'/usr/local'``\\입니다. 반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 값을 수정해서는 안 됩니다. 이는 "
"최상위 수준 :file:`Makefile`\\의 :makevar:`exec_prefix` 변수와 빌드 시 "
":program:`configure` 스크립트의 ``--exec-prefix`` 인자에 해당합니다. 이 값은 파이썬 코드에서 "
"``sys.exec_prefix``\\로 사용할 수 있습니다. 유닉스에서만 유용합니다."

#: ../../c-api/init.rst:654
msgid ""
"Background: The exec-prefix differs from the prefix when platform "
"dependent files (such as executables and shared libraries) are installed "
"in a different directory tree.  In a typical installation, platform "
"dependent files may be installed in the :file:`/usr/local/plat` subtree "
"while platform independent may be installed in :file:`/usr/local`."
msgstr ""
"배경: exec-prefix는 플랫폼 종속적 파일(가령 실행 파일과 공유 라이브러리)이 다른 디렉터리 트리에 설치될 때 "
"prefix와 다릅니다. 일반 설치에서, 플랫폼 종속적 파일은 :file:`/usr/local/plat` 서브 트리에 설치되고 "
"플랫폼 독립적 파일은 :file:`/usr/local`\\에 설치될 수 있습니다."

#: ../../c-api/init.rst:660
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system "
"are considered the same platform, but Intel machines running Solaris 2.x "
"are another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system "
"generally also form different platforms.  Non-Unix operating systems are "
"a different story; the installation strategies on those systems are so "
"different that the prefix and exec-prefix are meaningless, and set to the"
" empty string. Note that compiled Python bytecode files are platform "
"independent (but not independent from the Python version by which they "
"were compiled!)."
msgstr ""
"일반적으로 말해서, 플랫폼은 하드웨어와 소프트웨어 제품군의 조합입니다, 예를 들어 Solaris 2.x 운영 체제를 실행하는 "
"Sparc 기계들은 같은 플랫폼으로 간주하지만, Solaris 2.x를 실행하는 Intel 기계는 다른 플랫폼이며, 리눅스를 "
"실행하는 Intel 기계는 또 다른 플랫폼입니다. 같은 운영 체제의 서로 다른 주 개정판도 일반적으로 다른 플랫폼을 형성합니다. 비"
" 유닉스 운영 체제는 다른 이야기입니다; 이러한 시스템의 설치 전략이 너무 다르기 때문에 prefix와 exec-prefix는 "
"의미가 없으며, 빈 문자열로 설정됩니다. 컴파일된 파이썬 바이트 코드 파일은 플랫폼 독립적임에 유의하십시오 (그러나 이들을 "
"컴파일하는데 사용된 파이썬 버전에는 종속적입니다!)."

#: ../../c-api/init.rst:671
msgid ""
"System administrators will know how to configure the :program:`mount` or "
":program:`automount` programs to share :file:`/usr/local` between "
"platforms while having :file:`/usr/local/plat` be a different filesystem "
"for each platform."
msgstr ""
"시스템 관리자는 :file:`/usr/local/plat`\\을 각 플랫폼에 대해 다른 파일 시스템으로 사용하면서 플랫폼 간에 "
":file:`/usr/local`\\을 공유하도록 :program:`mount`\\나 :program:`automount` "
"프로그램을 구성하는 방법을 알 것입니다."

#: ../../c-api/init.rst:682
msgid ""
"Get :data:`sys.base_exec_prefix` instead, or :data:`sys.exec_prefix` if "
":ref:`virtual environments <venv-def>` need to be handled."
msgstr ""

#: ../../c-api/init.rst:692
#, fuzzy
msgid ""
"Return the full program name of the Python executable; this is  computed "
"as a side-effect of deriving the default module search path  from the "
"program name (set by :c:member:`PyConfig.program_name`). The returned "
"string points into static storage; the caller should not modify its "
"value.  The value is available to Python code as ``sys.executable``."
msgstr ""
"파이썬 실행 파일의 전체 프로그램 이름을 반환합니다; 이것은 프로그램 이름(위의 :c:func:`Py_SetProgramName` "
"으로 설정됩니다)에서 기본 모듈 검색 경로를 파생하는 부작용으로 계산됩니다. 반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 "
"값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 ``sys.executable``\\로 사용할 수 있습니다."

#: ../../c-api/init.rst:714
#, fuzzy
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:member:`PyConfig.program_name`) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned"
" string points into static storage; the caller should not modify its "
"value.  The list :data:`sys.path` is initialized with this value on "
"interpreter startup; it can be (and usually is) modified later to change "
"the search path for loading modules."
msgstr ""
"기본 모듈 검색 경로를 반환합니다; 이것은 프로그램 이름(위의 :c:func:`Py_SetProgramName` 으로 설정됩니다)과"
" 일부 환경 변수에서 계산됩니다. 반환된 문자열은 플랫폼 종속적 구분자로 분할된 일련의 디렉터리 이름으로 구성됩니다. 구분자는 "
"유닉스와 Mac OS X에서는 ``':'``, 윈도우에서는 ``';'``\\입니다. 반환된 문자열은 정적 저장소를 가리킵니다; "
"호출자는 값을 수정해서는 안 됩니다. 리스트 :data:`sys.path`\\는 인터프리터 시작 시 이 값으로 초기화됩니다; 모듈을"
" 로드하기 위한 검색 경로를 변경하기 위해 나중에 수정할 수 있습니다 (그리고 보통 그렇게 합니다)."

#: ../../c-api/init.rst:732
msgid "Get :data:`sys.path` instead."
msgstr ""

#: ../../c-api/init.rst:738
msgid ""
"Return the version of this Python interpreter.  This is a string that "
"looks something like ::"
msgstr "이 파이썬 인터프리터의 버전을 반환합니다. 이것은 다음과 같은 문자열입니다 ::"

#: ../../c-api/init.rst:741
msgid "\"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\""
msgstr ""

#: ../../c-api/init.rst:745
#, fuzzy
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated "
"by a period.  The returned string points into static storage; the caller "
"should not modify its value.  The value is available to Python code as "
":data:`sys.version`."
msgstr ""
"첫 번째 단어(첫 번째 스페이스 문자까지)는 현재 파이썬 버전입니다; 처음 세 문자는 마침표로 구분된 주 버전과 부 버전입니다. "
"반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 "
":data:`sys.version`\\으로 사용할 수 있습니다."

#: ../../c-api/init.rst:750
msgid "See also the :c:var:`Py_Version` constant."
msgstr ""

#: ../../c-api/init.rst:757
#, fuzzy
msgid ""
"Return the platform identifier for the current platform.  On Unix, this "
"is formed from the \"official\" name of the operating system, converted "
"to lower case, followed by the major revision number; e.g., for Solaris "
"2.x, which is also known as SunOS 5.x, the value is ``'sunos5'``.  On "
"macOS, it is ``'darwin'``.  On Windows, it is ``'win'``.  The returned "
"string points into static storage; the caller should not modify its "
"value.  The value is available to Python code as ``sys.platform``."
msgstr ""
"현재 플랫폼의 플랫폼 식별자를 반환합니다. 유닉스에서, 이것은 운영 체제의 \"공식적인\" 이름으로 구성되며, 소문자로 변환되고, "
"그 뒤에 주 개정 번호가 붙습니다; 예를 들어, SunOS 5.x라고도 하는 Solaris 2.x의 경우, 값은 "
"``'sunos5'``\\입니다. Mac OS X에서는, ``'darwin'``\\입니다. 윈도우에서는, "
"``'win'``\\입니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 "
"코드에서 ``sys.platform``\\으로 사용할 수 있습니다."

#: ../../c-api/init.rst:768
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr "현재 파이썬 버전에 대한 공식 저작권 문자열을 반환합니다, 예를 들어"

#: ../../c-api/init.rst:770
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:774
msgid ""
"The returned string points into static storage; the caller should not "
"modify its value.  The value is available to Python code as "
"``sys.copyright``."
msgstr ""
"반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 "
"``sys.copyright``\\로 사용할 수 있습니다."

#: ../../c-api/init.rst:780
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr "현재 파이썬 버전을 빌드하는 데 사용된 컴파일러 표시를 대괄호 감싸서 반환합니다, 예를 들면::"

#: ../../c-api/init.rst:783
msgid "\"[GCC 2.7.2.2]\""
msgstr ""

#: ../../c-api/init.rst:787 ../../c-api/init.rst:801
msgid ""
"The returned string points into static storage; the caller should not "
"modify its value.  The value is available to Python code as part of the "
"variable ``sys.version``."
msgstr ""
"반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 변수 "
"``sys.version``\\의 일부로 제공됩니다."

#: ../../c-api/init.rst:794
msgid ""
"Return information about the sequence number and build date and time  of "
"the current Python interpreter instance, for example ::"
msgstr "현재 파이썬 인터프리터 인스턴스의 시퀀스 번호와 빌드 날짜 및 시간에 대한 정보를 반환합니다, 예를 들어 ::"

#: ../../c-api/init.rst:797
msgid "\"#67, Aug  1 1997, 22:34:28\""
msgstr ""

#: ../../c-api/init.rst:813
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.argv`, :c:member:`PyConfig.parse_argv` and "
":c:member:`PyConfig.safe_path` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:818
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the"
" difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be "
"an empty string.  If this function fails to initialize :data:`sys.argv`, "
"a fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"*argc* 및 *argv*\\에 기반해서 :data:`sys.argv`\\를 설정합니다. 이 매개 변수는 프로그램의 "
":c:func:`main` 함수에 전달된 것과 유사하지만, 첫 번째 항목이 파이썬 인터프리터를 호스팅하는 실행 파일이 아니라 실행될"
" 스크립트 파일을 참조해야 한다는 차이점이 있습니다. 실행할 스크립트가 없으면, *argv*\\의 첫 번째 항목은 빈 문자열일 수 "
"있습니다. 이 함수가 :data:`sys.argv` 초기화에 실패하면, :c:func:`Py_FatalError`\\를 사용하여 "
"치명적인 조건을 표시합니다."

#: ../../c-api/init.rst:826
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* "
"is non-zero, the function also modifies :data:`sys.path` according to the"
" following algorithm:"
msgstr ""
"*updatepath*\\가 0이면, 여기까지가 이 함수가 하는 모든 일입니다. *updatepath*\\가 0이 아니면, 함수는 "
"다음 알고리즘에 따라 :data:`sys.path`\\도 수정합니다:"

#: ../../c-api/init.rst:830
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to "
":data:`sys.path`."
msgstr ""
"기존 스크립트의 이름이 ``argv[0]``\\으로 전달되면, 스크립트가 있는 디렉터리의 절대 경로가 :data:`sys.path`"
" 앞에 추가됩니다."

#: ../../c-api/init.rst:833
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an"
" existing file name), an empty string is prepended to :data:`sys.path`, "
"which is the same as prepending the current working directory "
"(``\".\"``)."
msgstr ""
"그렇지 않으면 (즉, *argc*\\가 ``0``\\이거나 ``argv[0]``\\이 기존 파일 이름을 가리키지 않으면), "
":data:`sys.path` 앞에 빈 문자열이 추가됩니다, 이는 현재 작업 디렉터리(``\".\"``)를 앞에 추가하는 것과 "
"같습니다."

#: ../../c-api/init.rst:841 ../../c-api/init.rst:877
#, fuzzy
msgid ""
"See also :c:member:`PyConfig.orig_argv` and :c:member:`PyConfig.argv` "
"members of the :ref:`Python Initialization Configuration <init-config>`."
msgstr ":ref:`파이썬 초기화 구성 <init-config>`\\도 참조하십시오."

#: ../../c-api/init.rst:845
#, fuzzy
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*,"
" and update :data:`sys.path` themselves if desired. See :cve:`2008-5983`."
msgstr ""
"단일 스크립트 실행 이외의 목적으로 파이썬 인터프리터를 내장하는 응용 프로그램은 ``0``\\을 *updatepath*\\로 "
"전달하고, 원하는 대로 :data:`sys.path`\\를 스스로 갱신하는 것이 좋습니다. `CVE-2008-5983 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_\\을 "
"참조하십시오."

#: ../../c-api/init.rst:850
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called "
":c:func:`PySys_SetArgv`, for example using::"
msgstr ""
"3.1.3 이전 버전에서는, :c:func:`PySys_SetArgv`\\를 호출한 후 첫 번째 :data:`sys.path` "
"요소를 수동으로 제거하여 같은 효과를 얻을 수 있습니다, 예를 들어 다음을 사용하여::"

#: ../../c-api/init.rst:854
msgid "PyRun_SimpleString(\"import sys; sys.path.pop(0)\\n\");"
msgstr ""

#: ../../c-api/init.rst:866
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.argv` and :c:member:`PyConfig.parse_argv` should be "
"used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""

#: ../../c-api/init.rst:870
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set "
"to ``1`` unless the :program:`python` interpreter was started with the "
":option:`-I`."
msgstr ""
"이 함수는 :program:`python` 인터프리터가 :option:`-I`\\로 시작되지 않는 한 *updatepath*\\가 "
"``1``\\로 설정된 :c:func:`PySys_SetArgvEx`\\처럼 작동합니다."

#: ../../c-api/init.rst:880
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "*updatepath* 값은 :option:`-I`\\에 따라 다릅니다."

#: ../../c-api/init.rst:887
msgid ""
"This API is kept for backward compatibility: setting "
":c:member:`PyConfig.home` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""

#: ../../c-api/init.rst:891
msgid ""
"Set the default \"home\" directory, that is, the location of the standard"
" Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the "
"argument string."
msgstr ""
"기본 \"홈\" 디렉터리, 즉 표준 파이썬 라이브러리의 위치를 설정합니다. 인자 문자열의 의미는 "
":envvar:`PYTHONHOME` 을 참조하십시오."

#: ../../c-api/init.rst:895
msgid ""
"The argument should point to a zero-terminated character string in static"
" storage whose contents will not change for the duration of the program's"
" execution.  No code in the Python interpreter will change the contents "
"of this storage."
msgstr ""
"인자는 프로그램을 실행하는 동안 내용이 변경되지 않는 정적 저장소에 있는 0으로 끝나는 문자열을 가리켜야 합니다. 파이썬 "
"인터프리터의 코드는 이 저장소의 내용을 변경하지 않습니다."

#: ../../c-api/init.rst:908
#, fuzzy
msgid ""
"Return the default \"home\", that is, the value set by "
":c:member:`PyConfig.home`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""
"기본 \"홈\", 즉 :c:func:`Py_SetPythonHome` 에 대한 이전 호출에서 설정한 값이나 설정되었다면 "
":envvar:`PYTHONHOME` 환경 변수의 값을 반환합니다."

#: ../../c-api/init.rst:918
#, fuzzy
msgid ""
"Get :c:member:`PyConfig.home` or :envvar:`PYTHONHOME` environment "
"variable instead."
msgstr ":option:`-O` 옵션과 :envvar:`PYTHONOPTIMIZE` 환경 변수로 설정됩니다."

#: ../../c-api/init.rst:926
msgid "Thread State and the Global Interpreter Lock"
msgstr "스레드 상태와 전역 인터프리터 록"

#: ../../c-api/init.rst:933
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support "
"multi-threaded Python programs, there's a global lock, called the "
":term:`global interpreter lock` or :term:`GIL`, that must be held by the "
"current thread before it can safely access Python objects. Without the "
"lock, even the simplest operations could cause problems in a multi-"
"threaded program: for example, when two threads simultaneously increment "
"the reference count of the same object, the reference count could end up "
"being incremented only once instead of twice."
msgstr ""
"파이썬 인터프리터는 완전히 스레드 안전하지 않습니다. 다중 스레드 파이썬 프로그램을 지원하기 위해, 파이썬 객체에 안전하게 "
"액세스하기 전에 현재 스레드가 보유해야 하는 :term:`전역 인터프리터 록 <global interpreter lock>` 혹은 "
":term:`GIL`\\이라고 하는 전역 록이 있습니다. 록 없이는, 가장 간단한 연산조차도 다중 스레드 프로그램에서 문제를 일으킬"
" 수 있습니다: 예를 들어, 두 스레드가 동시에 같은 객체의 참조 횟수를 증가시키면, 참조 횟수가 두 번이 아닌 한 번만 증가할 수"
" 있습니다."

#: ../../c-api/init.rst:943
msgid ""
"Therefore, the rule exists that only the thread that has acquired the "
":term:`GIL` may operate on Python objects or call Python/C API functions."
" In order to emulate concurrency of execution, the interpreter regularly "
"tries to switch threads (see :func:`sys.setswitchinterval`).  The lock is"
" also released around potentially blocking I/O operations like reading or"
" writing a file, so that other Python threads can run in the meantime."
msgstr ""
"따라서, :term:`GIL`\\을 획득한 스레드만 파이썬 객체에서 작동하거나 파이썬/C API 함수를 호출할 수 있다는 규칙이 "
"있습니다. 동시 실행을 모방하기 위해 인터프리터는 정기적으로 스레드 전환을 시도합니다 "
"(:func:`sys.setswitchinterval`\\을 참조하십시오). 록은 파일 읽기나 쓰기와 같은 잠재적인 블로킹 I/O "
"연산에 대해서도 해제되므로, 그동안 다른 파이썬 스레드가 실행될 수 있습니다."

#: ../../c-api/init.rst:953
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information"
" inside a data structure called :c:type:`PyThreadState`.  There's also "
"one global variable pointing to the current :c:type:`PyThreadState`: it "
"can be retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"파이썬 인터프리터는 :c:type:`PyThreadState` 라는 데이터 구조체 내에 스레드 별 부기(bookkeeping) "
"정보를 보관합니다. 현재 :c:type:`PyThreadState` 를 가리키는 하나의 전역 변수도 있습니다: "
":c:func:`PyThreadState_Get`\\을 사용하여 얻을 수 있습니다."

#: ../../c-api/init.rst:959
msgid "Releasing the GIL from extension code"
msgstr "확장 코드에서 GIL 해제하기"

#: ../../c-api/init.rst:961
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple"
" structure::"
msgstr ":term:`GIL`\\을 조작하는 대부분의 확장 코드는 다음과 같은 간단한 구조로 되어 있습니다::"

#: ../../c-api/init.rst:964
msgid ""
"Save the thread state in a local variable.\n"
"Release the global interpreter lock.\n"
"... Do some blocking I/O operation ...\n"
"Reacquire the global interpreter lock.\n"
"Restore the thread state from the local variable."
msgstr ""

#: ../../c-api/init.rst:970
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr "이것은 매우 일반적이어서 이를 단순화하기 위해 한 쌍의 매크로가 존재합니다::"

#: ../../c-api/init.rst:972
msgid ""
"Py_BEGIN_ALLOW_THREADS\n"
"... Do some blocking I/O operation ...\n"
"Py_END_ALLOW_THREADS"
msgstr ""

#: ../../c-api/init.rst:980
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and "
"declares a hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` "
"macro closes the block."
msgstr ""
":c:macro:`Py_BEGIN_ALLOW_THREADS` 매크로는 새 블록을 열고 숨겨진 지역 변수를 선언합니다; "
":c:macro:`Py_END_ALLOW_THREADS` 매크로는 블록을 닫습니다."

#: ../../c-api/init.rst:984
msgid "The block above expands to the following code::"
msgstr "위의 블록은 다음 코드로 확장됩니다::"

#: ../../c-api/init.rst:986
msgid ""
"PyThreadState *_save;\n"
"\n"
"_save = PyEval_SaveThread();\n"
"... Do some blocking I/O operation ...\n"
"PyEval_RestoreThread(_save);"
msgstr ""

#: ../../c-api/init.rst:996
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock"
" and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global"
" variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"이 함수들의 작동 방식은 다음과 같습니다: 전역 인터프리터 록이 현재 스레드 상태에 대한 포인터를 보호하는 데 사용됩니다. 록을 "
"해제하고 스레드 상태를 저장할 때, 록이 해제되기 전에 현재 스레드 상태 포인터를 가져와야 합니다 (다른 스레드가 즉시 록을 "
"획득하고 전역 변수에 자신의 스레드 상태를 저장할 수 있기 때문입니다). 반대로, 록을 획득하고 스레드 상태를 복원할 때, 스레드 "
"상태 포인터를 저장하기 전에 록을 획득해야 합니다."

#: ../../c-api/init.rst:1005
msgid ""
"Calling system I/O functions is the most common use case for releasing "
"the GIL, but it can also be useful before calling long-running "
"computations which don't need access to Python objects, such as "
"compression or cryptographic functions operating over memory buffers.  "
"For example, the standard :mod:`zlib` and :mod:`hashlib` modules release "
"the GIL when compressing or hashing data."
msgstr ""
"시스템 I/O 함수 호출은 GIL을 릴리스하는 가장 일반적인 사용 사례이지만, 메모리 버퍼를 통해 작동하는 압축이나 암호화 함수와 "
"같이, 파이썬 객체에 액세스할 필요가 없는 장기 실행 계산을 호출하기 전에도 유용할 수 있습니다. 예를 들어, 표준 "
":mod:`zlib`\\와 :mod:`hashlib` 모듈은 데이터를 압축하거나 해싱할 때 GIL을 해제합니다."

#: ../../c-api/init.rst:1016
msgid "Non-Python created threads"
msgstr "파이썬이 만들지 않은 스레드"

#: ../../c-api/init.rst:1018
msgid ""
"When threads are created using the dedicated Python APIs (such as the "
":mod:`threading` module), a thread state is automatically associated to "
"them and the code showed above is therefore correct.  However, when "
"threads are created from C (for example by a third-party library with its"
" own thread management), they don't hold the GIL, nor is there a thread "
"state structure for them."
msgstr ""
"전용 파이썬 API(가령 :mod:`threading` 모듈)를 사용하여 스레드를 만들면, 스레드 상태가 자동으로 연결되므로 위에 "
"표시된 코드가 올바릅니다. 그러나, 스레드가 C에서 만들어질 때 (예를 들어 자체 스레드 관리 기능이 있는 제삼자 라이브러리에 "
"의해), GIL을 보유하지 않고, 그들을 위한 스레드 상태 구조도 없습니다."

#: ../../c-api/init.rst:1025
msgid ""
"If you need to call Python code from these threads (often this will be "
"part of a callback API provided by the aforementioned third-party "
"library), you must first register these threads with the interpreter by "
"creating a thread state data structure, then acquiring the GIL, and "
"finally storing their thread state pointer, before you can start using "
"the Python/C API.  When you are done, you should reset the thread state "
"pointer, release the GIL, and finally free the thread state data "
"structure."
msgstr ""
"이러한 스레드에서 파이썬 코드를 호출해야 하면 (종종 앞서 언급한 제삼자 라이브러리에서 제공하는 콜백 API의 일부가 됩니다), "
"먼저 스레드 상태 자료 구조를 만들어서 인터프리터에 이러한 스레드를 등록한 다음, GIL을 획득하고, 마지막으로 파이썬/C API "
"사용을 시작하기 전에 스레드 상태 포인터를 저장합니다. 완료되면, 스레드 상태 포인터를 재설정하고, GIL을 해제한 다음, "
"마지막으로 스레드 상태 자료 구조를 해제해야 합니다."

#: ../../c-api/init.rst:1033
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` "
"functions do all of the above automatically.  The typical idiom for "
"calling into Python from a C thread is::"
msgstr ""
":c:func:`PyGILState_Ensure`\\와 :c:func:`PyGILState_Release` 함수는 위의 모든 작업을"
" 자동으로 수행합니다. C 스레드에서 파이썬을 호출하는 일반적인 관용구는 다음과 같습니다::"

#: ../../c-api/init.rst:1037
msgid ""
"PyGILState_STATE gstate;\n"
"gstate = PyGILState_Ensure();\n"
"\n"
"/* Perform Python actions here. */\n"
"result = CallSomeFunction();\n"
"/* evaluate result or handle exception */\n"
"\n"
"/* Release the thread. No Python API allowed beyond this point. */\n"
"PyGILState_Release(gstate);"
msgstr ""

#: ../../c-api/init.rst:1047
#, fuzzy
msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters (using "
":c:func:`Py_NewInterpreter`), but mixing multiple interpreters and the "
"``PyGILState_*`` API is unsupported."
msgstr ""
":c:func:`PyGILState_\\*` 함수는 (:c:func:`Py_Initialize`\\에 의해 자동으로 만들어진) 전역"
" 인터프리터 하나만 있다고 가정함에 유의하십시오. 파이썬은 추가 인터프리터를 만드는 것을 지원하지만 "
"(:c:func:`Py_NewInterpreter`\\를 사용해서), 다중 인터프리터와 :c:func:`PyGILState_\\*`"
" API를 혼합하는 것은 지원되지 않습니다."

#: ../../c-api/init.rst:1057
msgid "Cautions about fork()"
msgstr "fork()에 대한 주의 사항"

#: ../../c-api/init.rst:1059
msgid ""
"Another important thing to note about threads is their behaviour in the "
"face of the C :c:func:`fork` call. On most systems with :c:func:`fork`, "
"after a process forks only the thread that issued the fork will exist.  "
"This has a concrete impact both on how locks must be handled and on all "
"stored state in CPython's runtime."
msgstr ""
"스레드에 대해 주목해야 할 또 다른 중요한 점은 C :c:func:`fork` 호출 시 스레드의 동작입니다. "
":c:func:`fork`\\를 사용하는 대부분의 시스템에서는, 프로세스가 포크한 후에 포크를 발행한 스레드만 존재합니다. 이는 "
"록을 처리해야 하는 방법과 CPython 런타임에 저장된 모든 상태 모두에 구체적인 영향을 미칩니다."

#: ../../c-api/init.rst:1065
#, fuzzy
msgid ""
"The fact that only the \"current\" thread remains means any locks held by"
" other threads will never be released. Python solves this for "
":func:`os.fork` by acquiring the locks it uses internally before the "
"fork, and releasing them afterwards. In addition, it resets any :ref"
":`lock-objects` in the child. When extending or embedding Python, there "
"is no way to inform Python of additional (non-Python) locks that need to "
"be acquired before or reset after a fork. OS facilities such as "
":c:func:`!pthread_atfork` would need to be used to accomplish the same "
"thing. Additionally, when extending or embedding Python, calling "
":c:func:`fork` directly rather than through :func:`os.fork` (and "
"returning to or calling into Python) may result in a deadlock by one of "
"Python's internal locks being held by a thread that is defunct after the "
"fork. :c:func:`PyOS_AfterFork_Child` tries to reset the necessary locks, "
"but is not always able to."
msgstr ""
"\"현재\" 스레드만 남아 있다는 사실은 다른 스레드가 보유한 록이 해제되지 않음을 의미합니다. 파이썬은 포크 전에 내부적으로 "
"사용하는 록을 획득하고 나중에 해제하여 :func:`os.fork`\\에 대해 이 문제를 해결합니다. 또한, 자식의 모든 :ref"
":`lock-objects`\\를 재설정합니다. 파이썬을 확장하거나 내장할 때, 포크 이전에 획득하거나 이후에 재설정해야 하는 "
"추가(비 파이썬) 록을 파이썬에 알릴 방법이 없습니다. :c:func:`pthread_atfork`\\와 같은 OS 기능을 사용하여"
" 같은 작업을 수행해야 합니다. 또한, 파이썬을 확장하거나 내장할 때, :func:`os.fork`\\를 통하지 않고 직접 "
":c:func:`fork`\\를 호출하면 (그리고 파이썬으로 반환하거나 파이썬을 호출하면), 포크 이후에 사라지는 스레드가 보유하는"
" 파이썬의 내부 록 중 하나에 의해 교착 상태가 발생할 수 있습니다. :c:func:`PyOS_AfterFork_Child`\\는 "
"필요한 록을 재설정하려고 하지만, 항상 할 수 있는 것은 아닙니다."

#: ../../c-api/init.rst:1080
msgid ""
"The fact that all other threads go away also means that CPython's runtime"
" state there must be cleaned up properly, which :func:`os.fork` does.  "
"This means finalizing all other :c:type:`PyThreadState` objects belonging"
" to the current interpreter and all other :c:type:`PyInterpreterState` "
"objects.  Due to this and the special nature of the :ref:`\"main\" "
"interpreter <sub-interpreter-support>`, :c:func:`fork` should only be "
"called in that interpreter's \"main\" thread, where the CPython global "
"runtime was originally initialized. The only exception is if "
":c:func:`exec` will be called immediately after."
msgstr ""
"다른 모든 스레드가 사라진다는 사실은 또한 CPython의 런타임 상태가 :func:`os.fork`\\와 마찬가지로 적절하게 "
"정리되어야 함을 의미합니다. 이것은 현재 인터프리터와 다른 모든 :c:type:`PyInterpreterState` 객체에 속하는 "
"다른 모든 :c:type:`PyThreadState` 객체를 파이널리제이션 하는 것을 의미합니다. 이것과 :ref:`\"메인\" "
"인터프리터 <sub-interpreter-support>`\\의 특수한 특성으로 인해, :c:func:`fork`\\는 "
"CPython 전역 런타임이 원래 초기화된 인터프리터의 \"메인\" 스레드에서만 호출되어야 합니다. 유일한 예외는 "
":c:func:`exec`\\가 그 후에 즉시 호출되는 경우입니다."

#: ../../c-api/init.rst:1093
msgid "High-level API"
msgstr "고수준 API"

#: ../../c-api/init.rst:1095
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr "다음은 C 확장 코드를 작성하거나 파이썬 인터프리터를 내장할 때 가장 일반적으로 사용되는 형과 함수입니다:"

#: ../../c-api/init.rst:1100
msgid ""
"This data structure represents the state shared by a number of "
"cooperating threads.  Threads belonging to the same interpreter share "
"their module administration and a few other internal items. There are no "
"public members in this structure."
msgstr ""
"이 자료 구조는 여러 협력 스레드가 공유하는 상태를 나타냅니다. 같은 인터프리터에 속하는 스레드는 모듈 관리와 몇 가지 다른 내부 "
"항목을 공유합니다. 이 구조체에는 공개 멤버가 없습니다."

#: ../../c-api/init.rst:1105
msgid ""
"Threads belonging to different interpreters initially share nothing, "
"except process state like available memory, open file descriptors and "
"such.  The global interpreter lock is also shared by all threads, "
"regardless of to which interpreter they belong."
msgstr ""
"다른 인터프리터에 속한 스레드는 사용 가능한 메모리, 열린 파일 기술자 등과 같은 프로세스 상태를 제외하고는, 처음에는 아무것도 "
"공유하지 않습니다. 전역 인터프리터 록은 어떤 인터프리터에 속해 있는지에 관계없이 모든 스레드에서 공유됩니다."

#: ../../c-api/init.rst:1113
#, fuzzy
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is:"
msgstr ""
"이 자료 구조는 단일 스레드의 상태를 나타냅니다. 유일한 공용 데이터 멤버는 이 스레드의 인터프리터 상태를 가리키는 "
":attr:`interp`\\(:c:type:`PyInterpreterState *`)입니다."

#: ../../c-api/init.rst:1118
#, fuzzy
msgid "This thread's interpreter state."
msgstr "메인 인터프리터 상태 객체를 반환합니다."

#: ../../c-api/init.rst:1129
msgid "Deprecated function which does nothing."
msgstr "아무것도 하지 않는 폐지된 함수."

#: ../../c-api/init.rst:1131
msgid "In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr "파이썬 3.6과 이전 버전에서는, 이 함수가 존재하지 않으면 GIL을 만들었습니다."

#: ../../c-api/init.rst:1133
msgid "The function now does nothing."
msgstr "이제 이 함수는 아무 작업도 수행하지 않습니다."

#: ../../c-api/init.rst:1136
msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't "
"have to call it yourself anymore."
msgstr "이 함수는 이제 :c:func:`Py_Initialize()`\\에 의해 호출되어서, 여러분은 더는 직접 호출할 필요가 없습니다."

#: ../../c-api/init.rst:1140
msgid "This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr "이 함수는 더는 :c:func:`Py_Initialize()` 전에 호출할 수 없습니다."

#: ../../c-api/init.rst:1150
msgid ""
"Release the global interpreter lock (if it has been created) and reset "
"the thread state to ``NULL``, returning the previous thread state (which "
"is not ``NULL``).  If the lock has been created, the current thread must "
"have acquired it."
msgstr ""
"(만들었다면) 전역 인터프리터 록을 해제하고 스레드 상태를 ``NULL``\\로 재설정하고, 이전 스레드 상태(``NULL``\\이"
" 아닙니다)를 반환합니다. 록이 만들어졌다면, 현재 스레드가 록을 획득했어야 합니다."

#: ../../c-api/init.rst:1158
msgid ""
"Acquire the global interpreter lock (if it has been created) and set the "
"thread state to *tstate*, which must not be ``NULL``.  If the lock has "
"been created, the current thread must not have acquired it, otherwise "
"deadlock ensues."
msgstr ""
"(만들었다면) 전역 인터프리터 록을 획득하고 스레드 상태를 ``NULL``\\이 아니어야 하는 *tstate*\\로 설정합니다. "
"록이 만들어졌다면, 현재 스레드가 이를 획득하지 않았어야 합니다, 그렇지 않으면 교착 상태가 발생합니다."

#: ../../c-api/init.rst:1164 ../../c-api/init.rst:1223
#: ../../c-api/init.rst:1519
#, fuzzy
msgid ""
"Calling this function from a thread when the runtime is finalizing will "
"terminate the thread, even if the thread was not created by Python. You "
"can use :c:func:`Py_IsFinalizing` or :func:`sys.is_finalizing` to check "
"if the interpreter is in process of being finalized before calling this "
"function to avoid unwanted termination."
msgstr ""
"런타임이 파이널리제이션 될 때 스레드에서 이 함수를 호출하면, 스레드가 파이썬에 의해 만들어지지 않았더라도 스레드가 종료됩니다. "
"원치 않는 종료를 방지하려면 :c:func:`_Py_IsFinalizing`\\이나 "
":func:`sys.is_finalizing`\\을 사용하여 이 함수를 호출하기 전에 인터프리터가 파이널리제이션 되고 있는지 확인할"
" 수 있습니다."

#: ../../c-api/init.rst:1172
msgid ""
"Return the current thread state.  The global interpreter lock must be "
"held. When the current thread state is ``NULL``, this issues a fatal "
"error (so that the caller needn't check for ``NULL``)."
msgstr ""
"현재 스레드 상태를 반환합니다. 전역 인터프리터 록을 보유해야 합니다. 현재 스레드 상태가 ``NULL``\\이면 치명적인 에러가 "
"발생합니다 (그래서 호출자가 ``NULL``\\을 확인할 필요가 없습니다)."

#: ../../c-api/init.rst:1176
#, fuzzy
msgid "See also :c:func:`PyThreadState_GetUnchecked`."
msgstr ":c:func:`PyEval_GetFrame`\\도 참조하십시오."

#: ../../c-api/init.rst:1181
msgid ""
"Similar to :c:func:`PyThreadState_Get`, but don't kill the process with a"
" fatal error if it is NULL. The caller is responsible to check if the "
"result is NULL."
msgstr ""

#: ../../c-api/init.rst:1185
msgid ""
"In Python 3.5 to 3.12, the function was private and known as "
"``_PyThreadState_UncheckedGet()``."
msgstr ""

#: ../../c-api/init.rst:1192
msgid ""
"Swap the current thread state with the thread state given by the argument"
" *tstate*, which may be ``NULL``.  The global interpreter lock must be "
"held and is not released."
msgstr ""
"현재 스레드 상태를 인자 *tstate*\\(``NULL``\\일 수 있습니다)가 제공하는 스레드 상태와 스와프합니다. 전역 "
"인터프리터 록을 보유해야 하며 해제되지 않습니다."

#: ../../c-api/init.rst:1197
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr "다음 함수는 스레드 로컬 저장소를 사용하며, 서브 인터프리터와 호환되지 않습니다:"

#: ../../c-api/init.rst:1202
msgid ""
"Ensure that the current thread is ready to call the Python C API "
"regardless of the current state of Python, or of the global interpreter "
"lock. This may be called as many times as desired by a thread as long as "
"each call is matched with a call to :c:func:`PyGILState_Release`. In "
"general, other thread-related APIs may be used between "
":c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` calls as "
"long as the thread state is restored to its previous state before the "
"Release().  For example, normal usage of the "
":c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` "
"macros is acceptable."
msgstr ""
"현재 스레드가 파이썬의 현재 상태나 전역 인터프리터 록과 관계없이 파이썬 C API를 호출할 준비가 되었는지 확인합니다. 이것은 각"
" 호출이 :c:func:`PyGILState_Release`\\에 대한 호출과 쌍을 이루는 한 스레드에서 원하는 만큼 여러 번 "
"호출될 수 있습니다. 일반적으로, 스레드 상태가 Release() 전에 이전 상태로 복원되는 한 "
":c:func:`PyGILState_Ensure`\\와 :c:func:`PyGILState_Release` 호출 간에 다른 스레드 "
"관련 API를 사용할 수 있습니다. 예를 들어, :c:macro:`Py_BEGIN_ALLOW_THREADS`\\와 "
":c:macro:`Py_END_ALLOW_THREADS` 매크로의 정상적인 사용은 허용됩니다."

#: ../../c-api/init.rst:1212
msgid ""
"The return value is an opaque \"handle\" to the thread state when "
":c:func:`PyGILState_Ensure` was called, and must be passed to "
":c:func:`PyGILState_Release` to ensure Python is left in the same state. "
"Even though recursive calls are allowed, these handles *cannot* be shared"
" - each unique call to :c:func:`PyGILState_Ensure` must save the handle "
"for its call to :c:func:`PyGILState_Release`."
msgstr ""
"반환 값은 :c:func:`PyGILState_Ensure`\\가 호출되었을 때의 스레드 상태에 대한 불투명한 \"핸들\"이며, "
"파이썬이 같은 상태에 있도록 하려면 :c:func:`PyGILState_Release`\\로 전달되어야 합니다. 재귀 호출이 "
"허용되더라도, 이 핸들들은 공유할 수 *없습니다* - :c:func:`PyGILState_Ensure`\\에 대한 각 고유 호출은 "
"자신의 :c:func:`PyGILState_Release`\\에 대한 호출을 위해 핸들을 저장해야 합니다."

#: ../../c-api/init.rst:1219
msgid ""
"When the function returns, the current thread will hold the GIL and be "
"able to call arbitrary Python code.  Failure is a fatal error."
msgstr "함수가 반환할 때, 현재 스레드는 GIL을 보유하고 임의의 파이썬 코드를 호출할 수 있습니다. 실패는 치명적인 에러입니다."

#: ../../c-api/init.rst:1231
msgid ""
"Release any resources previously acquired.  After this call, Python's "
"state will be the same as it was prior to the corresponding "
":c:func:`PyGILState_Ensure` call (but generally this state will be "
"unknown to the caller, hence the use of the GILState API)."
msgstr ""
"이전에 획득 한 모든 자원을 해제합니다. 이 호출 후에, 파이썬의 상태는 해당 :c:func:`PyGILState_Ensure` "
"호출 이전과 같습니다 (그러나 일반적으로 이 상태는 호출자에게 알려지지 않아서, GILState API를 사용합니다)."

#: ../../c-api/init.rst:1236
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to "
":c:func:`PyGILState_Release` on the same thread."
msgstr ""
":c:func:`PyGILState_Ensure`\\에 대한 모든 호출은 같은 스레드에서 "
":c:func:`PyGILState_Release`\\에 대한 호출과 쌍을 이뤄야 합니다."

#: ../../c-api/init.rst:1242
msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main "
"thread always has such a thread-state, even if no auto-thread-state call "
"has been made on the main thread.  This is mainly a helper/diagnostic "
"function."
msgstr ""
"이 스레드의 현재 스레드 상태를 가져옵니다. 현재 스레드에서 GILState API가 사용되지 않았으면 ``NULL``\\을 반환할"
" 수 있습니다. 메인 스레드에서 자동 스레드 상태 호출(auto-thread-state call)이 수행되지 않은 경우에도, 메인 "
"스레드에는 항상 이러한 스레드 상태가 있음에 유의하십시오. 이것은 주로 도우미/진단 함수입니다."

#: ../../c-api/init.rst:1250
msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` "
"otherwise. This function can be called from any thread at any time. Only "
"if it has had its Python thread state initialized and currently is "
"holding the GIL will it return ``1``. This is mainly a helper/diagnostic "
"function.  It can be useful for example in callback contexts or memory "
"allocation functions when knowing that the GIL is locked can allow the "
"caller to perform sensitive actions or otherwise behave differently."
msgstr ""
"현재 스레드가 GIL을 보유하고 있으면 ``1``\\을 반환하고 그렇지 않으면 ``0``\\을 반환합니다. 이 함수는 아무 때나 "
"모든 스레드에서 호출할 수 있습니다. 파이썬 스레드 상태가 초기화되었고 현재 GIL을 보유하고 있을 때만 ``1``\\을 "
"반환합니다. 이것은 주로 도우미/진단 함수입니다. 예를 들어 콜백 컨텍스트나 메모리 할당 함수에서 유용할 수 있는데, GIL이 잠겨"
" 있다는 것을 알면 호출자가 민감한 작업을 수행하거나 그렇지 않으면 다르게 동작하도록 할 수 있습니다."

#: ../../c-api/init.rst:1262
msgid ""
"The following macros are normally used without a trailing semicolon; look"
" for example usage in the Python source distribution."
msgstr "다음 매크로는 일반적으로 후행 세미콜론 없이 사용됩니다; 파이썬 소스 배포에서 사용 예를 찾으십시오."

#: ../../c-api/init.rst:1268
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Note that it contains an opening brace; it must "
"be matched with a following :c:macro:`Py_END_ALLOW_THREADS` macro.  See "
"above for further discussion of this macro."
msgstr ""
"이 매크로는 ``{ PyThreadState *_save; _save = PyEval_SaveThread();`` 로 확장됩니다. "
"여는 중괄호가 포함되어 있음에 유의하십시오; 뒤따르는 :c:macro:`Py_END_ALLOW_THREADS` 매크로와 일치해야 "
"합니다. 이 매크로에 대한 자세한 내용은 위를 참조하십시오."

#: ../../c-api/init.rst:1276
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier "
":c:macro:`Py_BEGIN_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro."
msgstr ""
"이 매크로는 ``PyEval_RestoreThread(_save); }``\\로 확장됩니다. 닫는 중괄호가 포함되어 있음에 "
"유의하십시오; 이전 :c:macro:`Py_BEGIN_ALLOW_THREADS` 매크로와 일치해야 합니다. 이 매크로에 대한 자세한"
" 내용은 위를 참조하십시오."

#: ../../c-api/init.rst:1284
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent "
"to :c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"이 매크로는 ``PyEval_RestoreThread(_save);`` 로 확장됩니다: 닫는 중괄호가 없는 "
":c:macro:`Py_END_ALLOW_THREADS`\\와 동등합니다."

#: ../../c-api/init.rst:1290
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent "
"to :c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and "
"variable declaration."
msgstr ""
"이 매크로는 ``_save = PyEval_SaveThread();`` 로 확장됩니다: 여는 중괄호와 변수 선언이 없는 "
":c:macro:`Py_BEGIN_ALLOW_THREADS`\\와 동등합니다."

#: ../../c-api/init.rst:1296
msgid "Low-level API"
msgstr "저수준 API"

#: ../../c-api/init.rst:1298
msgid ""
"All of the following functions must be called after "
":c:func:`Py_Initialize`."
msgstr "다음 함수는 모두 :c:func:`Py_Initialize` 이후에 호출되어야 합니다."

#: ../../c-api/init.rst:1300
msgid ":c:func:`Py_Initialize()` now initializes the :term:`GIL`."
msgstr ":c:func:`Py_Initialize()`\\는 이제 :term:`GIL`\\을 초기화합니다."

#: ../../c-api/init.rst:1306
msgid ""
"Create a new interpreter state object.  The global interpreter lock need "
"not be held, but may be held if it is necessary to serialize calls to "
"this function."
msgstr ""
"새 인터프리터 상태 객체를 만듭니다. 전역 인터프리터 록을 보유할 필요는 없지만, 이 함수에 대한 호출을 직렬화해야 하면 보유할 수"
" 있습니다."

#: ../../c-api/init.rst:1310
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.PyInterpreterState_New`` with no arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트 <auditing>` ``cpython.PyInterpreterState_New``\\를 "
"발생시킵니다."

#: ../../c-api/init.rst:1315
msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr "인터프리터 상태 객체의 모든 정보를 재설정합니다. 전역 인터프리터 록을 보유해야 합니다."

#: ../../c-api/init.rst:1318
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.PyInterpreterState_Clear`` with no arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트 <auditing>` ``cpython.PyInterpreterState_Clear``\\를 "
"발생시킵니다."

#: ../../c-api/init.rst:1323
msgid ""
"Destroy an interpreter state object.  The global interpreter lock need "
"not be held.  The interpreter state must have been reset with a previous "
"call to :c:func:`PyInterpreterState_Clear`."
msgstr ""
"인터프리터 상태 객체를 파괴합니다. 전역 인터프리터 록은 보유할 필요 없습니다. 인터프리터 상태는 "
":c:func:`PyInterpreterState_Clear`\\에 대한 이전 호출로 재설정되었어야 합니다."

#: ../../c-api/init.rst:1330
msgid ""
"Create a new thread state object belonging to the given interpreter "
"object. The global interpreter lock need not be held, but may be held if "
"it is necessary to serialize calls to this function."
msgstr ""
"주어진 인터프리터 객체에 속하는 새 스레드 상태 객체를 만듭니다. 전역 인터프리터 록을 보유할 필요는 없지만, 이 함수에 대한 "
"호출을 직렬화해야 하면 보유할 수 있습니다."

#: ../../c-api/init.rst:1337
msgid ""
"Reset all information in a thread state object.  The global interpreter "
"lock must be held."
msgstr "스레드 상태 객체의 모든 정보를 재설정합니다. 전역 인터프리터 록을 보유해야 합니다."

#: ../../c-api/init.rst:1340
msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback."
" Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""
"이 함수는 이제 :c:member:`PyThreadState.on_delete` 콜백을 호출합니다. 이전에는, "
":c:func:`PyThreadState_Delete`\\에서 호출했습니다."

#: ../../c-api/init.rst:1344
msgid "The :c:member:`PyThreadState.on_delete` callback was removed."
msgstr ""

#: ../../c-api/init.rst:1350
msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to "
":c:func:`PyThreadState_Clear`."
msgstr ""
"스레드 상태 객체를 파괴합니다. 전역 인터프리터 록은 보유할 필요 없습니다. 스레드 상태는 "
":c:func:`PyThreadState_Clear`\\에 대한 이전 호출로 재설정되었어야 합니다."

#: ../../c-api/init.rst:1357
#, fuzzy
msgid ""
"Destroy the current thread state and release the global interpreter lock."
" Like :c:func:`PyThreadState_Delete`, the global interpreter lock must be"
" held. The thread state must have been reset with a previous call to "
":c:func:`PyThreadState_Clear`."
msgstr ""
"현재 스레드 상태를 파괴하고 전역 인터프리터 록을 해제합니다. :c:func:`PyThreadState_Delete`\\와 "
"마찬가지로, 전역 인터프리터 록은 유지할 필요 없습니다. 스레드 상태는 :c:func:`PyThreadState_Clear`\\에 "
"대한 이전 호출로 재설정되었어야 합니다."

#: ../../c-api/init.rst:1365
msgid "Get the current frame of the Python thread state *tstate*."
msgstr "파이썬 스레드 상태 *tstate*\\의 현재 프레임을 가져옵니다."

#: ../../c-api/init.rst:1367
#, fuzzy
msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is "
"currently executing."
msgstr "강한 참조를 반환합니다. 현재 실행 중인 프레임이 없으면 ``NULL``\\을 반환합니다."

#: ../../c-api/init.rst:1370
msgid "See also :c:func:`PyEval_GetFrame`."
msgstr ":c:func:`PyEval_GetFrame`\\도 참조하십시오."

#: ../../c-api/init.rst:1372 ../../c-api/init.rst:1381
#: ../../c-api/init.rst:1390
msgid "*tstate* must not be ``NULL``."
msgstr "*tstate*\\는 ``NULL``\\이 아니어야 합니다."

#: ../../c-api/init.rst:1379
msgid ""
"Get the unique thread state identifier of the Python thread state "
"*tstate*."
msgstr "파이썬 스레드 상태 *tstate*\\의 고유한 스레드 상태 식별자를 가져옵니다."

#: ../../c-api/init.rst:1388
msgid "Get the interpreter of the Python thread state *tstate*."
msgstr "파이썬 스레드 상태 *tstate*\\의 인터프리터를 가져옵니다."

#: ../../c-api/init.rst:1397
#, fuzzy
msgid "Suspend tracing and profiling in the Python thread state *tstate*."
msgstr "파이썬 스레드 상태 *tstate*\\의 현재 프레임을 가져옵니다."

#: ../../c-api/init.rst:1399
msgid "Resume them using the :c:func:`PyThreadState_LeaveTracing` function."
msgstr ""

#: ../../c-api/init.rst:1406
msgid ""
"Resume tracing and profiling in the Python thread state *tstate* "
"suspended by the :c:func:`PyThreadState_EnterTracing` function."
msgstr ""

#: ../../c-api/init.rst:1409
msgid ""
"See also :c:func:`PyEval_SetTrace` and :c:func:`PyEval_SetProfile` "
"functions."
msgstr ""

#: ../../c-api/init.rst:1417
msgid "Get the current interpreter."
msgstr "현재 인터프리터를 가져옵니다."

#: ../../c-api/init.rst:1419
msgid ""
"Issue a fatal error if there no current Python thread state or no current"
" interpreter. It cannot return NULL."
msgstr "현재 파이썬 스레드 상태가 없거나 현재 인터프리터가 없으면 치명적인 에러를 발행합니다. NULL을 반환할 수 없습니다."

#: ../../c-api/init.rst:1422 ../../c-api/init.rst:1432
#: ../../c-api/init.rst:1454
msgid "The caller must hold the GIL."
msgstr "호출자는 GIL을 보유해야 합니다."

#: ../../c-api/init.rst:1429
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so "
"then ``-1`` is returned and an error is set."
msgstr "인터프리터의 고유 ID를 반환합니다. 그렇게 하는데 에러가 발생하면 ``-1``\\이 반환되고 에러가 설정됩니다."

#: ../../c-api/init.rst:1439
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"인터프리터별 데이터가 저장될 수 있는 딕셔너리를 반환합니다. 이 함수가 ``NULL``\\을 반환하면 예외는 발생하지 않았고 "
"호출자는 인터프리터별 딕셔너리를 사용할 수 없다고 가정해야 합니다."

#: ../../c-api/init.rst:1443
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"이것은 확장이 인터프리터별 상태 정보를 저장하는 데 사용해야 하는 :c:func:`PyModule_GetState()`\\를 "
"대체하는 것이 아닙니다."

#: ../../c-api/init.rst:1451
msgid ""
"Return a :term:`strong reference` to the ``__main__`` :ref:`module object"
" <moduleobjects>` for the given interpreter."
msgstr ""

#: ../../c-api/init.rst:1461
msgid "Type of a frame evaluation function."
msgstr "프레임 평가 함수의 형."

#: ../../c-api/init.rst:1463
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of "
"generators: if non-zero, handle the current exception."
msgstr "*throwflag* 매개 변수는 제너레이터의 ``throw()`` 메서드에서 사용됩니다: 0이 아니면, 현재 예외를 처리합니다."

#: ../../c-api/init.rst:1466
msgid "The function now takes a *tstate* parameter."
msgstr "이제 함수는 *tstate* 매개 변수를 취합니다."

#: ../../c-api/init.rst:1469
msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr ""

#: ../../c-api/init.rst:1474
msgid "Get the frame evaluation function."
msgstr "프레임 평가 함수를 가져옵니다."

#: ../../c-api/init.rst:1476 ../../c-api/init.rst:1484
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr ":pep:`523` \"CPython에 프레임 평가 API 추가\"를 참조하십시오."

#: ../../c-api/init.rst:1482
msgid "Set the frame evaluation function."
msgstr "프레임 평가 함수를 설정합니다."

#: ../../c-api/init.rst:1491
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store "
"state in the dictionary.  It is okay to call this function when no "
"current thread state is available. If this function returns ``NULL``, no "
"exception has been raised and the caller should assume no current thread "
"state is available."
msgstr ""
"확장이 스레드별 상태 정보를 저장할 수 있는 딕셔너리를 반환합니다. 각 확장은 딕셔너리에 상태를 저장하는 데 사용할 고유 키를 "
"사용해야 합니다. 현재 스레드 상태를 사용할 수 없을 때 이 함수를 호출해도 됩니다. 이 함수가 ``NULL``\\을 반환하면, "
"예외는 발생하지 않았고 호출자는 현재 스레드 상태를 사용할 수 없다고 가정해야 합니다."

#: ../../c-api/init.rst:1500
#, fuzzy
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be "
"raised. This function does not steal any references to *exc*. To prevent "
"naive misuse, you must write your own C extension to call this.  Must be "
"called with the GIL held. Returns the number of thread states modified; "
"this is normally one, but will be zero if the thread id isn't found.  If "
"*exc* is ``NULL``, the pending exception (if any) for the thread is "
"cleared. This raises no exceptions."
msgstr ""
"스레드에서 비동기적으로 예외를 발생시킵니다. *id* 인자는 대상 스레드의 스레드 id입니다; *exc*\\는 발생시킬 예외 "
"객체입니다. 이 함수는 *exc*\\에 대한 어떤 참조도 훔치지 않습니다. 순진한 오용을 방지하려면, 이를 호출하는 자체 C 확장을"
" 작성해야 합니다. GIL을 보유한 채로 호출해야 합니다. 수정된 스레드 상태 수를 반환합니다; 일반적으로 1이지만, 스레드 id를"
" 찾지 못하면 0이 됩니다. *exc*\\가 :const:`NULL`\\이면, 스레드에 대해 계류 중인 예외가 (있다면) "
"지워집니다. 이것은 예외를 일으키지 않습니다."

#: ../../c-api/init.rst:1508
#, fuzzy
msgid ""
"The type of the *id* parameter changed from :c:expr:`long` to "
":c:expr:`unsigned long`."
msgstr "*id* 매개 변수의 형이 :c:type:`long`\\에서 :c:type:`unsigned long`\\으로 변경되었습니다."

#: ../../c-api/init.rst:1514
msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which must not be ``NULL``.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"전역 인터프리터 록을 획득하고 현재 스레드 상태를 *tstate*\\로 설정합니다. *tstate*\\는 ``NULL``\\이 "
"아니어야 합니다. 록은 이전에 만들어진 것이어야 합니다. 이 스레드에 이미 록이 있으면, 교착 상태가 발생합니다."

#: ../../c-api/init.rst:1525
msgid ""
"Updated to be consistent with :c:func:`PyEval_RestoreThread`, "
":c:func:`Py_END_ALLOW_THREADS`, and :c:func:`PyGILState_Ensure`, and "
"terminate the current thread if called while the interpreter is "
"finalizing."
msgstr ""
":c:func:`PyEval_RestoreThread`, :c:func:`Py_END_ALLOW_THREADS` 및 "
":c:func:`PyGILState_Ensure`\\와 일관되도록 갱신되었으며, 인터프리터가 파이널리제이션 하는 동안 호출되면 현재"
" 스레드를 종료합니다."

#: ../../c-api/init.rst:1530
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always"
" available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread`\\는 (스레드가 초기화되지 않았을 때조차) 항상 사용할 수 있는 고수준 "
"함수입니다."

#: ../../c-api/init.rst:1536
msgid ""
"Reset the current thread state to ``NULL`` and release the global "
"interpreter lock.  The lock must have been created earlier and must be "
"held by the current thread.  The *tstate* argument, which must not be "
"``NULL``, is only used to check that it represents the current thread "
"state --- if it isn't, a fatal error is reported."
msgstr ""
"현재 스레드 상태를 ``NULL``\\로 재설정하고 전역 인터프리터 록을 해제합니다. 록은 이전에 만들어졌어야 하고 현재 스레드가 "
"보유해야 합니다. ``NULL``\\이 아니어야 하는 *tstate* 인자는 현재 스레드 상태를 나타내는지 확인하는 데만 사용됩니다"
" --- 그렇지 않으면, 치명적인 에러가 보고됩니다."

#: ../../c-api/init.rst:1542
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread`\\는 (스레드가 초기화되지 않은 경우에조차) 항상 사용할 수 있는 고수준 "
"함수입니다."

#: ../../c-api/init.rst:1549
msgid "Sub-interpreter support"
msgstr "서브 인터프리터 지원"

#: ../../c-api/init.rst:1551
msgid ""
"While in most uses, you will only embed a single Python interpreter, "
"there are cases where you need to create several independent interpreters"
" in the same process and perhaps even in the same thread. Sub-"
"interpreters allow you to do that."
msgstr ""
"대부분의 경우, 단일 파이썬 인터프리터만 내장할 것입니다만, 같은 프로세스, 어쩌면 같은 스레드에서 여러 독립 인터프리터를 만들어야"
" 하는 경우가 있습니다. 서브 인터프리터는 그렇게 할 수 있도록 합니다."

#: ../../c-api/init.rst:1556
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  "
"Unlike sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for "
"execution during runtime initialization and is usually the active "
"interpreter during runtime finalization.  The "
":c:func:`PyInterpreterState_Main` function returns a pointer to its "
"state."
msgstr ""
"\"메인\" 인터프리터는 런타임이 초기화될 때 만들어지는 첫 번째 인터프리터입니다. 보통은 프로세스에서 유일한 파이썬 "
"인터프리터입니다. 서브 인터프리터와 달리, 메인 인터프리터는 시그널 처리와 같은 고유한 프로세스 전역 책임을 갖습니다. 또한 런타임"
" 초기화 동안 실행을 담당하며 일반적으로 런타임 파이널리제이션 동안 활성 인터프리터입니다. "
":c:func:`PyInterpreterState_Main` 함수는 그것의 상태에 대한 포인터를 반환합니다."

#: ../../c-api/init.rst:1563
msgid ""
"You can switch between sub-interpreters using the "
":c:func:`PyThreadState_Swap` function. You can create and destroy them "
"using the following functions:"
msgstr ""
":c:func:`PyThreadState_Swap` 함수를 사용하여 서브 인터프리터 간에 전환할 수 있습니다. 다음 함수를 사용하여"
" 만들고 파괴할 수 있습니다:"

#: ../../c-api/init.rst:1569
msgid ""
"Structure containing most parameters to configure a sub-interpreter. Its "
"values are used only in :c:func:`Py_NewInterpreterFromConfig` and never "
"modified by the runtime."
msgstr ""

#: ../../c-api/init.rst:1575
msgid "Structure fields:"
msgstr ""

#: ../../c-api/init.rst:1579
msgid ""
"If this is ``0`` then the sub-interpreter will use its own \"object\" "
"allocator state. Otherwise it will use (share) the main interpreter's."
msgstr ""

#: ../../c-api/init.rst:1583
msgid ""
"If this is ``0`` then "
":c:member:`~PyInterpreterConfig.check_multi_interp_extensions` must be "
"``1`` (non-zero). If this is ``1`` then "
":c:member:`~PyInterpreterConfig.gil` must not be "
":c:macro:`PyInterpreterConfig_OWN_GIL`."
msgstr ""

#: ../../c-api/init.rst:1591
msgid ""
"If this is ``0`` then the runtime will not support forking the process in"
" any thread where the sub-interpreter is currently active. Otherwise fork"
" is unrestricted."
msgstr ""

#: ../../c-api/init.rst:1595
msgid ""
"Note that the :mod:`subprocess` module still works when fork is "
"disallowed."
msgstr ""

#: ../../c-api/init.rst:1600
msgid ""
"If this is ``0`` then the runtime will not support replacing the current "
"process via exec (e.g. :func:`os.execv`) in any thread where the sub-"
"interpreter is currently active. Otherwise exec is unrestricted."
msgstr ""

#: ../../c-api/init.rst:1605
msgid ""
"Note that the :mod:`subprocess` module still works when exec is "
"disallowed."
msgstr ""

#: ../../c-api/init.rst:1610
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't"
" create threads. Otherwise threads are allowed."
msgstr ""

#: ../../c-api/init.rst:1616
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't"
" create daemon threads. Otherwise daemon threads are allowed (as long as "
":c:member:`~PyInterpreterConfig.allow_threads` is non-zero)."
msgstr ""

#: ../../c-api/init.rst:1623
msgid ""
"If this is ``0`` then all extension modules may be imported, including "
"legacy (single-phase init) modules, in any thread where the sub-"
"interpreter is currently active. Otherwise only multi-phase init "
"extension modules (see :pep:`489`) may be imported. (Also see "
":c:macro:`Py_mod_multiple_interpreters`.)"
msgstr ""

#: ../../c-api/init.rst:1630
msgid ""
"This must be ``1`` (non-zero) if "
":c:member:`~PyInterpreterConfig.use_main_obmalloc` is ``0``."
msgstr ""

#: ../../c-api/init.rst:1635
msgid ""
"This determines the operation of the GIL for the sub-interpreter. It may "
"be one of the following:"
msgstr ""

#: ../../c-api/init.rst:1642
msgid "Use the default selection (:c:macro:`PyInterpreterConfig_SHARED_GIL`)."
msgstr ""

#: ../../c-api/init.rst:1646
#, fuzzy
msgid "Use (share) the main interpreter's GIL."
msgstr "메인 인터프리터 상태 객체를 반환합니다."

#: ../../c-api/init.rst:1650
#, fuzzy
msgid "Use the sub-interpreter's own GIL."
msgstr "현재 인터프리터를 가져옵니다."

#: ../../c-api/init.rst:1652
msgid ""
"If this is :c:macro:`PyInterpreterConfig_OWN_GIL` then "
":c:member:`PyInterpreterConfig.use_main_obmalloc` must be ``0``."
msgstr ""

#: ../../c-api/init.rst:1666
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and "
":mod:`sys`.  The table of loaded modules (``sys.modules``) and the module"
" search path (``sys.path``) are also separate.  The new environment has "
"no ``sys.argv`` variable.  It has new standard I/O stream file objects "
"``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` (however these refer to "
"the same underlying file descriptors)."
msgstr ""
"새 서브 인터프리터를 만듭니다. 이것은 파이썬 코드 실행을 위한 (거의) 완전히 분리된 환경입니다. 특히, 새 인터프리터에는 기본 "
"모듈 :mod:`builtins`, :mod:`__main__` 및 :mod:`sys`\\를 포함하여, 모든 임포트 된 모듈의 "
"개별, 독립 버전을 갖습니다. 로드된 모듈 테이블(``sys.modules``)과 모듈 검색 경로(``sys.path``)도 "
"별개입니다. 새 환경에는 ``sys.argv`` 변수가 없습니다. 새로운 표준 I/O 스트림 파일 객체 ``sys.stdin``, "
"``sys.stdout`` 및 ``sys.stderr``\\을 갖습니다 (단, 같은 하부 파일 기술자를 참조합니다)."

#: ../../c-api/init.rst:1676
msgid ""
"The given *config* controls the options with which the interpreter is "
"initialized."
msgstr ""

#: ../../c-api/init.rst:1679
#, fuzzy
msgid ""
"Upon success, *tstate_p* will be set to the first thread state created in"
" the new sub-interpreter.  This thread state is made in the current "
"thread state. Note that no actual thread is created; see the discussion "
"of thread states below.  If creation of the new interpreter is "
"unsuccessful, *tstate_p* is set to ``NULL``; no exception is set since "
"the exception state is stored in the current thread state and there may "
"not be a current thread state."
msgstr ""
"반환 값은 새 서브 인터프리터에서 만들어진 첫 번째 스레드 상태를 가리킵니다. 이 스레드 상태는 현재 스레드 상태에서 만들어집니다."
" 실제 스레드가 만들어지지 않음에 유의하십시오; 아래 스레드 상태에 대한 설명을 참조하십시오. 새 인터프리터를 만드는 데 실패하면,"
" ``NULL``\\이 반환됩니다; 예외 상태는 현재 스레드 상태에 저장되고 현재 스레드 상태가 없을 수 있어서 예외가 설정되지 "
"않습니다. (다른 모든 파이썬/C API 함수와 마찬가지로, 전역 인터프리터 록을 이 함수를 호출하기 전에 보유해야 하며 반환될 때"
" 계속 유지됩니다; 그러나, 대부분의 다른 파이썬/C API 함수와 달리, 진입할 때 현재 스레드 상태가 있을 필요는 없습니다.)"

#: ../../c-api/init.rst:1688
msgid ""
"Like all other Python/C API functions, the global interpreter lock must "
"be held before calling this function and is still held when it returns.  "
"Likewise a current thread state must be set on entry.  On success, the "
"returned thread state will be set as current.  If the sub-interpreter is "
"created with its own GIL then the GIL of the calling interpreter will be "
"released.  When the function returns, the new interpreter's GIL will be "
"held by the current thread and the previously interpreter's GIL will "
"remain released here."
msgstr ""

#: ../../c-api/init.rst:1699
msgid ""
"Sub-interpreters are most effective when isolated from each other, with "
"certain functionality restricted::"
msgstr ""

#: ../../c-api/init.rst:1702
#, python-brace-format
msgid ""
"PyInterpreterConfig config = {\n"
"    .use_main_obmalloc = 0,\n"
"    .allow_fork = 0,\n"
"    .allow_exec = 0,\n"
"    .allow_threads = 1,\n"
"    .allow_daemon_threads = 0,\n"
"    .check_multi_interp_extensions = 1,\n"
"    .gil = PyInterpreterConfig_OWN_GIL,\n"
"};\n"
"PyThreadState *tstate = NULL;\n"
"PyStatus status = Py_NewInterpreterFromConfig(&tstate, &config);\n"
"if (PyStatus_Exception(status)) {\n"
"    Py_ExitStatusException(status);\n"
"}"
msgstr ""

#: ../../c-api/init.rst:1717
msgid ""
"Note that the config is used only briefly and does not get modified. "
"During initialization the config's values are converted into various "
":c:type:`PyInterpreterState` values.  A read-only copy of the config may "
"be stored internally on the :c:type:`PyInterpreterState`."
msgstr ""

#: ../../c-api/init.rst:1726
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr "확장 모듈은 다음과 같이 (서브) 인터프리터 간에 공유됩니다:"

#: ../../c-api/init.rst:1728
msgid ""
"For modules using multi-phase initialization, e.g. "
":c:func:`PyModule_FromDefAndSpec`, a separate module object is created "
"and initialized for each interpreter. Only C-level static and global "
"variables are shared between these module objects."
msgstr ""
"다단계 초기화를 사용하는 모듈의 경우, 예를 들어 :c:func:`PyModule_FromDefAndSpec`, 각 인터프리터에 "
"대해 별도의 모듈 객체가 만들어지고 초기화됩니다. C 수준 정적과 전역 변수만 이러한 모듈 객체 간에 공유됩니다."

#: ../../c-api/init.rst:1734
msgid ""
"For modules using single-phase initialization, e.g. "
":c:func:`PyModule_Create`, the first time a particular extension is "
"imported, it is initialized normally, and a (shallow) copy of its "
"module's dictionary is squirreled away. When the same extension is "
"imported by another (sub-)interpreter, a new module is initialized and "
"filled with the contents of this copy; the extension's ``init`` function "
"is not called. Objects in the module's dictionary thus end up shared "
"across (sub-)interpreters, which might cause unwanted behavior (see `Bugs"
" and caveats`_ below)."
msgstr ""
"단단계 초기화를 사용하는 모듈의 경우, 예를 들어 :c:func:`PyModule_Create`, 특정 확장이 처음 임포트 될 때,"
" 정상적으로 초기화되고, 모듈 딕셔너리의 (얕은) 사본이 저장됩니다. 다른 (서브) 인터프리터가 같은 확장을 임포트 할 때, 새 "
"모듈이 초기화되고 이 복사본의 내용으로 채워집니다; 확장의 ``init`` 함수는 호출되지 않습니다. 따라서 모듈 딕셔너리의 객체는"
" (서브) 인터프리터 간에 공유되어, 원치 않는 동작을 일으킬 수 있습니다 (아래 `버그와 주의 사항 <Bugs and "
"caveats_>`_\\을 참조하십시오)."

#: ../../c-api/init.rst:1745
msgid ""
"Note that this is different from what happens when an extension is "
"imported after the interpreter has been completely re-initialized by "
"calling :c:func:`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that "
"case, the extension's ``initmodule`` function *is* called again. As with "
"multi-phase initialization, this means that only C-level static and "
"global variables are shared between these modules."
msgstr ""
"이것은 인터프리터가 :c:func:`Py_FinalizeEx`\\와 :c:func:`Py_Initialize`\\를 호출하여 완전히"
" 다시 초기화된 후 확장을 임포트 할 때 일어나는 것과 다름에 유의하십시오; 이 경우, 확장의 ``initmodule`` 함수가 "
"다시 *호출됩니다*. 다단계 초기화와 마찬가지로, 이는 C 수준의 정적과 전역 변수만 이러한 모듈 간에 공유됨을 의미합니다."

#: ../../c-api/init.rst:1765
msgid ""
"Create a new sub-interpreter.  This is essentially just a wrapper around "
":c:func:`Py_NewInterpreterFromConfig` with a config that preserves the "
"existing behavior.  The result is an unisolated sub-interpreter that "
"shares the main interpreter's GIL, allows fork/exec, allows daemon "
"threads, and allows single-phase init modules."
msgstr ""

#: ../../c-api/init.rst:1777
#, fuzzy
msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion "
"of thread states below.  When the call returns, the current thread state "
"is ``NULL``.  All thread states associated with this interpreter are "
"destroyed.  The global interpreter lock used by the target interpreter "
"must be held before calling this function.  No GIL is held when it "
"returns."
msgstr ""
"주어진 스레드 상태로 표현되는 (서브) 인터프리터를 파괴합니다. 주어진 스레드 상태는 현재 스레드 상태여야 합니다. 아래의 스레드 "
"상태에 대한 설명을 참조하십시오. 호출이 반환되면, 현재 스레드 상태는 ``NULL``\\입니다. 이 인터프리터와 관련된 모든 "
"스레드 상태가 파괴됩니다. (전역 인터프리터 록을 이 함수를 호출하기 전에 보유해야 하며 반환될 때 여전히 유지됩니다.) "
":c:func:`Py_FinalizeEx`\\는 그 시점에서 명시적으로 파괴되지 않은 모든 서브 인터프리터를 파괴합니다."

#: ../../c-api/init.rst:1785
msgid ""
":c:func:`Py_FinalizeEx` will destroy all sub-interpreters that haven't "
"been explicitly destroyed at that point."
msgstr ""

#: ../../c-api/init.rst:1790
msgid "A Per-Interpreter GIL"
msgstr ""

#: ../../c-api/init.rst:1792
msgid ""
"Using :c:func:`Py_NewInterpreterFromConfig` you can create a sub-"
"interpreter that is completely isolated from other interpreters, "
"including having its own GIL.  The most important benefit of this "
"isolation is that such an interpreter can execute Python code without "
"being blocked by other interpreters or blocking any others.  Thus a "
"single Python process can truly take advantage of multiple CPU cores when"
" running Python code.  The isolation also encourages a different approach"
" to concurrency than that of just using threads. (See :pep:`554`.)"
msgstr ""

#: ../../c-api/init.rst:1802
msgid ""
"Using an isolated interpreter requires vigilance in preserving that "
"isolation.  That especially means not sharing any objects or mutable "
"state without guarantees about thread-safety.  Even objects that are "
"otherwise immutable (e.g. ``None``, ``(1, 5)``) can't normally be shared "
"because of the refcount.  One simple but less-efficient approach around "
"this is to use a global lock around all use of some state (or object). "
"Alternately, effectively immutable objects (like integers or strings) can"
" be made safe in spite of their refcounts by making them "
":term:`immortal`. In fact, this has been done for the builtin singletons,"
" small integers, and a number of other builtin objects."
msgstr ""

#: ../../c-api/init.rst:1813
msgid ""
"If you preserve isolation then you will have access to proper multi-core "
"computing without the complications that come with free-threading. "
"Failure to preserve isolation will expose you to the full consequences of"
" free-threading, including races and hard-to-debug crashes."
msgstr ""

#: ../../c-api/init.rst:1818
msgid ""
"Aside from that, one of the main challenges of using multiple isolated "
"interpreters is how to communicate between them safely (not break "
"isolation) and efficiently.  The runtime and stdlib do not provide any "
"standard approach to this yet.  A future stdlib module would help "
"mitigate the effort of preserving isolation and expose effective tools "
"for communicating (and sharing) data between interpreters."
msgstr ""

#: ../../c-api/init.rst:1829
msgid "Bugs and caveats"
msgstr "버그와 주의 사항"

#: ../../c-api/init.rst:1831
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using"
" low-level file operations like  :func:`os.close` they can (accidentally "
"or maliciously) affect each other's open files.  Because of the way "
"extensions are shared between (sub-)interpreters, some extensions may not"
" work properly; this is especially likely when using single-phase "
"initialization or (static) global variables. It is possible to insert "
"objects created in one sub-interpreter into a namespace of another "
"(sub-)interpreter; this should be avoided if possible."
msgstr ""
"서브 인터프리터(및 메인 인터프리터)는 같은 프로세스의 일부이기 때문에, 그들 간의 절연이 완벽하지 않습니다 --- 예를 들어, "
":func:`os.close`\\와 같은 저수준 파일 연산을 사용하면 서로의 열린 파일에 (실수로 혹은 악의적으로) 영향을 미칠 수"
" 있습니다. (서브) 인터프리터 간에 확장이 공유되는 방식 때문에, 일부 확장이 제대로 작동하지 않을 수 있습니다; 이것은 특히 "
"단단계 초기화나 (정적) 전역 변수를 사용할 때 특히 그렇습니다. 한 서브 인터프리터에서 만든 객체를 다른 (서브) 인터프리터의 "
"이름 공간에 삽입할 수 있습니다; 가능하면 피해야 합니다."

#: ../../c-api/init.rst:1841
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong "
"(sub-)interpreter's dictionary of loaded modules. It is equally important"
" to avoid sharing objects from which the above are reachable."
msgstr ""
"서브 인터프리터 간에 사용자 정의 함수, 메서드, 인스턴스 또는 클래스를 공유하지 않도록 특별한 주의를 기울여야 합니다. 이러한 "
"객체에 의해 실행되는 임포트 연산은 잘못된 (서브) 인터프리터의 로드된 모듈 딕셔너리에 영향을 미칠 수 있기 때문입니다. 위의 "
"것들에서 접근할 수 있는 객체를 공유하지 않는 것도 마찬가지로 중요합니다."

#: ../../c-api/init.rst:1847
#, fuzzy
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is"
" delicate, because these APIs assume a bijection between Python thread "
"states and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and "
":c:func:`PyGILState_Release` calls. Furthermore, extensions (such as "
":mod:`ctypes`) using these APIs to allow calling of Python code from non-"
"Python created threads will probably be broken when using sub-"
"interpreters."
msgstr ""
"또한 이 기능을 :c:func:`PyGILState_\\*` API와 결합하는 것은 까다로움에 유의하십시오. 이러한 API는, 서브"
" 인터프리터의 존재로 인해 깨어진 가정인, 파이썬 스레드 상태와 OS 수준 스레드 사이의 일대일 관계를 가정하기 때문입니다. "
":c:func:`PyGILState_Ensure`\\와 :c:func:`PyGILState_Release` 호출의 일치하는 쌍 "
"사이에 서브 인터프리터를 전환하지 않는 것이 좋습니다. 또한, 이러한 API를 사용하여 파이썬이 아닌 스레드에서 생성된 스레드에서 "
"파이썬 코드를 호출할 수 있도록 하는 확장(가령 :mod:`ctypes`)은 서브 인터프리터를 사용할 때 망가질 수 있습니다."

#: ../../c-api/init.rst:1858
msgid "Asynchronous Notifications"
msgstr "비동기 알림"

#: ../../c-api/init.rst:1860
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function "
"pointer and a void pointer argument."
msgstr ""
"메인 인터프리터 스레드에 비동기 알림을 보내는 메커니즘이 제공됩니다. 이러한 알림은 함수 포인터와 void 포인터 인자의 형태를 "
"취합니다."

#: ../../c-api/init.rst:1867
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the "
"main thread.  On failure, ``-1`` is returned without setting any "
"exception."
msgstr ""
"메인 인터프리터 스레드에서 호출할 함수를 예약합니다. 성공하면 ``0``\\이 반환되고 *func*\\는 메인 스레드에서 호출되기 "
"위해 큐에 추가됩니다. 실패 시, 예외 설정 없이 ``-1``\\이 반환됩니다."

#: ../../c-api/init.rst:1871
msgid ""
"When successfully queued, *func* will be *eventually* called from the "
"main interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with "
"both these conditions met:"
msgstr ""
"성공적으로 큐에 넣으면, *func*\\는 *arg* 인자를 사용하여 *결국* 메인 인터프리터 스레드에서 호출됩니다. 정상적으로 "
"실행되는 파이썬 코드와 비교할 때 비동기적으로 호출되지만, 다음 두 조건이 모두 충족됩니다:"

#: ../../c-api/init.rst:1876
msgid "on a :term:`bytecode` boundary;"
msgstr ":term:`바이트 코드 <bytecode>` 경계에서;"

#: ../../c-api/init.rst:1877
msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* "
"can therefore use the full C API)."
msgstr ""
"메인 스레드가 :term:`전역 인터프리터 록 <global interpreter lock>`\\을 보유하면서 (따라서 "
"*func*\\는 전체 C API를 사용할 수 있습니다)."

#: ../../c-api/init.rst:1880
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an "
"exception set.  *func* won't be interrupted to perform another "
"asynchronous notification recursively, but it can still be interrupted to"
" switch threads if the global interpreter lock is released."
msgstr ""
"*func*\\는 성공하면 ``0``\\을, 실패하면 예외 설정과 함께 ``-1``\\을 반환해야 합니다. *func*\\는 다른 "
"비동기 알림을 재귀적으로 수행하기 위해 중단되지 않지만, 전역 인터프리터 록이 해제되면 스레드를 전환하기 위해 여전히 중단될 수 "
"있습니다."

#: ../../c-api/init.rst:1885
msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr "이 함수는 실행하는 데 현재 스레드 상태가 필요하지 않으며, 전역 인터프리터 록이 필요하지 않습니다."

#: ../../c-api/init.rst:1888
msgid ""
"To call this function in a subinterpreter, the caller must hold the GIL. "
"Otherwise, the function *func* can be scheduled to be called from the "
"wrong interpreter."
msgstr ""
"서브 인터프리터에서 이 함수를 호출하려면 호출자가 GIL을 보유해야 합니다. 그렇지 않으면, 함수 *func*\\가 잘못된 "
"인터프리터에서 호출되도록 예약될 수 있습니다."

#: ../../c-api/init.rst:1893
msgid ""
"This is a low-level function, only useful for very special cases. There "
"is no guarantee that *func* will be called as quick as possible.  If the "
"main thread is busy executing a system call, *func* won't be called "
"before the system call returns.  This function is generally **not** "
"suitable for calling Python code from arbitrary C threads.  Instead, use "
"the :ref:`PyGILState API<gilstate>`."
msgstr ""
"이것은 매우 특별한 경우에만 유용한, 저수준 함수입니다. *func*\\가 가능한 한 빨리 호출된다는 보장은 없습니다. 메인 "
"스레드가 시스템 호출을 실행 중이라 바쁘면, 시스템 호출이 반환되기 전에 *func*\\가 호출되지 않습니다. 이 함수는 일반적으로"
" 임의의 C 스레드에서 파이썬 코드를 호출하는 데 적합하지 **않습니다**. 대신, :ref:`PyGILState "
"API<gilstate>`\\를 사용하십시오."

#: ../../c-api/init.rst:1902
msgid ""
"If this function is called in a subinterpreter, the function *func* is "
"now scheduled to be called from the subinterpreter, rather than being "
"called from the main interpreter. Each subinterpreter now has its own "
"list of scheduled calls."
msgstr ""
"이 함수가 서브 인터프리터에서 호출되면, *func* 함수는 이제 메인 인터프리터에서 호출되지 않고 서브 인터프리터에서 호출되도록 "
"예약됩니다. 이제 각 서브 인터프리터는 자체 예약된 호출 목록을 갖습니다."

#: ../../c-api/init.rst:1911
msgid "Profiling and Tracing"
msgstr "프로파일링과 추적"

#: ../../c-api/init.rst:1916
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for "
"profiling, debugging, and coverage analysis tools."
msgstr ""
"파이썬 인터프리터는 프로파일링과 실행 추적 기능을 연결하기 위한 몇 가지 저수준 지원을 제공합니다. 프로파일링, 디버깅 및 커버리지"
" 분석 도구에 사용됩니다."

#: ../../c-api/init.rst:1920
msgid ""
"This C interface allows the profiling or tracing code to avoid the "
"overhead of calling through Python-level callable objects, making a "
"direct C function call instead.  The essential attributes of the facility"
" have not changed; the interface allows trace functions to be installed "
"per-thread, and the basic events reported to the trace function are the "
"same as had been reported to the Python-level trace functions in previous"
" versions."
msgstr ""
"이 C 인터페이스를 사용하면 프로파일링이나 추적 코드가 파이썬 수준의 콜러블 객체를 통해 호출하는 오버헤드를 피하고, 대신 직접 C"
" 함수를 호출할 수 있습니다. 시설의 필수 어트리뷰트는 변경되지 않았습니다; 인터페이스는 추적 함수를 스레드별로 설치할 수 있도록 "
"하며, 추적 함수에 보고되는 기본 이벤트는 이전 버전의 파이썬 수준 추적 함수에 보고된 것과 같습니다."

#: ../../c-api/init.rst:1930
#, fuzzy
msgid ""
"The type of the trace function registered using "
":c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The first "
"parameter is the object passed to the registration function as *obj*, "
"*frame* is the frame object to which the event pertains, *what* is one of"
" the constants :c:data:`PyTrace_CALL`, :c:data:`PyTrace_EXCEPTION`, "
":c:data:`PyTrace_LINE`, :c:data:`PyTrace_RETURN`, "
":c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION`, "
":c:data:`PyTrace_C_RETURN`, or :c:data:`PyTrace_OPCODE`, and *arg* "
"depends on the value of *what*:"
msgstr ""
":c:func:`PyEval_SetProfile`\\과 :c:func:`PyEval_SetTrace`\\를 사용하여 등록된 추적 "
"함수의 형입니다. 첫 번째 매개 변수는 등록 함수에 *obj*\\로 전달된 객체이고, *frame*\\은 이벤트가 관련된 프레임 "
"객체이고, *what*\\은 상수 :const:`PyTrace_CALL`, :const:`PyTrace_EXCEPTION`, "
":const:`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:`PyTrace_C_CALL`, "
":const:`PyTrace_C_EXCEPTION`, :const:`PyTrace_C_RETURN` 또는 "
":const:`PyTrace_OPCODE` 중 하나이고, *arg*\\는 *what*\\의 값에 따라 다릅니다:"

#: ../../c-api/init.rst:1939
msgid "Value of *what*"
msgstr "*what*\\의 값"

#: ../../c-api/init.rst:1939
msgid "Meaning of *arg*"
msgstr "*arg*\\의 의미"

#: ../../c-api/init.rst:1941
#, fuzzy
msgid ":c:data:`PyTrace_CALL`"
msgstr ":const:`PyTrace_CALL`"

#: ../../c-api/init.rst:1941 ../../c-api/init.rst:1946
#: ../../c-api/init.rst:1957
msgid "Always :c:data:`Py_None`."
msgstr "항상 :c:data:`Py_None`."

#: ../../c-api/init.rst:1943
#, fuzzy
msgid ":c:data:`PyTrace_EXCEPTION`"
msgstr ":const:`PyTrace_EXCEPTION`"

#: ../../c-api/init.rst:1943
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr ":func:`sys.exc_info`\\에서 반환된 예외 정보."

#: ../../c-api/init.rst:1946
#, fuzzy
msgid ":c:data:`PyTrace_LINE`"
msgstr ":const:`PyTrace_LINE`"

#: ../../c-api/init.rst:1948
#, fuzzy
msgid ":c:data:`PyTrace_RETURN`"
msgstr ":const:`PyTrace_RETURN`"

#: ../../c-api/init.rst:1948
msgid "Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr "호출자에게 반환되는 값, 또는 예외로 인한 것이면 ``NULL``."

#: ../../c-api/init.rst:1951
#, fuzzy
msgid ":c:data:`PyTrace_C_CALL`"
msgstr ":const:`PyTrace_C_CALL`"

#: ../../c-api/init.rst:1951 ../../c-api/init.rst:1953
#: ../../c-api/init.rst:1955
msgid "Function object being called."
msgstr "호출되는 함수 객체."

#: ../../c-api/init.rst:1953
#, fuzzy
msgid ":c:data:`PyTrace_C_EXCEPTION`"
msgstr ":const:`PyTrace_C_EXCEPTION`"

#: ../../c-api/init.rst:1955
#, fuzzy
msgid ":c:data:`PyTrace_C_RETURN`"
msgstr ":const:`PyTrace_C_RETURN`"

#: ../../c-api/init.rst:1957
#, fuzzy
msgid ":c:data:`PyTrace_OPCODE`"
msgstr ":const:`PyTrace_OPCODE`"

#: ../../c-api/init.rst:1962
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function "
"when a new call to a function or method is being reported, or a new entry"
" into a generator. Note that the creation of the iterator for a generator"
" function is not reported as there is no control transfer to the Python "
"bytecode in the corresponding frame."
msgstr ""
"함수나 메서드에 대한 새 호출이 보고되거나, 제너레이터에 대한 새 항목이 보고될 때 :c:type:`Py_tracefunc` 함수에"
" 대한 *what* 매개 변수의 값. 제너레이터 함수에 대한 이터레이터의 생성은 해당 프레임의 파이썬 바이트 코드로의 제어 전송이 "
"없기 때문에 보고되지 않음에 유의하십시오."

#: ../../c-api/init.rst:1971
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function "
"when an exception has been raised.  The callback function is called with "
"this value for *what* when after any bytecode is processed after which "
"the exception becomes set within the frame being executed.  The effect of"
" this is that as exception propagation causes the Python stack to unwind,"
" the callback is called upon return to each frame as the exception "
"propagates.  Only trace functions receives these events; they are not "
"needed by the profiler."
msgstr ""
"예외가 발생했을 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값. 콜백 함수는 실행되는 프레임"
" 내에서 바이트 코드가 처리된 후 예외가 설정될 때 *what*\\에 대해 이 값으로 호출됩니다. 이것의 효과는 예외 전파로 인해 "
"파이썬 스택이 되감기는 것입니다, 예외가 전파되어 각 프레임으로 반환할 때 콜백이 호출됩니다. 추적 함수만 이러한 이벤트를 "
"수신합니다; 프로파일러에는 필요하지 않습니다."

#: ../../c-api/init.rst:1982
#, fuzzy
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being"
" reported. It may be disabled for a frame by setting "
":attr:`~frame.f_trace_lines` to *0* on that frame."
msgstr ""
"줄 번호 이벤트가 보고될 때 *what* 매개 변수로 :c:type:`Py_tracefunc` 함수(하지만 프로파일링 함수는 "
"아닙니다)에 전달되는 값. 해당 프레임의 :attr:`f_trace_lines`\\를 *0*\\으로 설정하여 해당 프레임에 대해 "
"비활성화 할 수 있습니다."

#: ../../c-api/init.rst:1990
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions "
"when a call is about to return."
msgstr "호출이 반환되려고 할 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값."

#: ../../c-api/init.rst:1996
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions "
"when a C function is about to be called."
msgstr "C 함수가 호출되려고 할 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값."

#: ../../c-api/init.rst:2002
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions "
"when a C function has raised an exception."
msgstr "C 함수에서 예외가 발생했을 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값."

#: ../../c-api/init.rst:2008
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions "
"when a C function has returned."
msgstr "C 함수가 반환했을 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값."

#: ../../c-api/init.rst:2014
#, fuzzy
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions "
"(but not profiling functions) when a new opcode is about to be executed."
"  This event is not emitted by default: it must be explicitly requested "
"by setting :attr:`~frame.f_trace_opcodes` to *1* on the frame."
msgstr ""
"새 옵코드가 실행되려고 할 때 :c:type:`Py_tracefunc` 함수(하지만 프로파일링 함수는 아닙니다)에 대한 *what*"
" 매개 변수의 값. 이 이벤트는 기본적으로 방출되지 않습니다: 프레임의 :attr:`f_trace_opcodes`\\를 *1*\\로"
" 설정하여 명시적으로 요청해야 합니다."

#: ../../c-api/init.rst:2022
#, fuzzy
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to "
"the function as its first parameter, and may be any Python object, or "
"``NULL``.  If the profile function needs to maintain state, using a "
"different value for *obj* for each thread provides a convenient and "
"thread-safe place to store it.  The profile function is called for all "
"monitored events except :c:data:`PyTrace_LINE` :c:data:`PyTrace_OPCODE` "
"and :c:data:`PyTrace_EXCEPTION`."
msgstr ""
"프로파일러 함수를 *func*\\로 설정합니다. *obj* 매개 변수는 첫 번째 매개 변수로 함수에 전달되며, 임의의 파이썬 객체나"
" ``NULL``\\일 수 있습니다. 프로파일 함수가 상태를 유지해야 하면, 스레드마다 *obj*\\에 다른 값을 사용하면 "
"저장하기에 편리하고 스레드 안전한 위치를 제공합니다. 프로파일 함수는 :const:`PyTrace_LINE`, "
":const:`PyTrace_OPCODE` 및 :const:`PyTrace_EXCEPTION`\\을 제외한 모든 관찰되는 이벤트에 "
"대해 호출됩니다."

#: ../../c-api/init.rst:2029
msgid "See also the :func:`sys.setprofile` function."
msgstr ""

#: ../../c-api/init.rst:2031 ../../c-api/init.rst:2038
#: ../../c-api/init.rst:2057 ../../c-api/init.rst:2064
msgid "The caller must hold the :term:`GIL`."
msgstr "호출자는 :term:`GIL`\\을 보유하고 있어야 합니다."

#: ../../c-api/init.rst:2035
msgid ""
"Like :c:func:`PyEval_SetProfile` but sets the profile function in all "
"running threads belonging to the current interpreter instead of the "
"setting it only on the current thread."
msgstr ""

#: ../../c-api/init.rst:2040
msgid ""
"As :c:func:`PyEval_SetProfile`, this function ignores any exceptions "
"raised while setting the profile functions in all threads."
msgstr ""

#: ../../c-api/init.rst:2048
#, fuzzy
msgid ""
"Set the tracing function to *func*.  This is similar to "
":c:func:`PyEval_SetProfile`, except the tracing function does receive "
"line-number events and per-opcode events, but does not receive any event "
"related to C function objects being called.  Any trace function "
"registered using :c:func:`PyEval_SetTrace` will not receive "
":c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION` or "
":c:data:`PyTrace_C_RETURN` as a value for the *what* parameter."
msgstr ""
"추적 함수를 *func*\\로 설정합니다. 추적 함수가 줄 번호 이벤트와 옵코드별 이벤트를 수신하지만, 호출되는 C 함수 객체와 "
"관련된 이벤트를 수신하지 않는다는 점을 제외하면, :c:func:`PyEval_SetProfile`\\과 유사합니다. "
":c:func:`PyEval_SetTrace`\\를 사용하여 등록된 모든 추적 함수는 *what* 매개 변수의 값으로 "
":const:`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION` 또는 "
":const:`PyTrace_C_RETURN`\\을 수신하지 않습니다."

#: ../../c-api/init.rst:2055
#, fuzzy
msgid "See also the :func:`sys.settrace` function."
msgstr ":c:func:`PyEval_GetFrame`\\도 참조하십시오."

#: ../../c-api/init.rst:2061
msgid ""
"Like :c:func:`PyEval_SetTrace` but sets the tracing function in all "
"running threads belonging to the current interpreter instead of the "
"setting it only on the current thread."
msgstr ""

#: ../../c-api/init.rst:2066
msgid ""
"As :c:func:`PyEval_SetTrace`, this function ignores any exceptions raised"
" while setting the trace functions in all threads."
msgstr ""

#: ../../c-api/init.rst:2072
msgid "Reference tracing"
msgstr ""

#: ../../c-api/init.rst:2078
msgid ""
"The type of the trace function registered using "
":c:func:`PyRefTracer_SetTracer`. The first parameter is a Python object "
"that has been just created (when **event** is set to "
":c:data:`PyRefTracer_CREATE`) or about to be destroyed (when **event** is"
" set to :c:data:`PyRefTracer_DESTROY`). The **data** argument is the "
"opaque pointer that was provided when :c:func:`PyRefTracer_SetTracer` was"
" called."
msgstr ""

#: ../../c-api/init.rst:2088
#, fuzzy
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions "
"when a Python object has been created."
msgstr "C 함수가 반환했을 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값."

#: ../../c-api/init.rst:2093
#, fuzzy
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions "
"when a Python object has been destroyed."
msgstr "C 함수가 반환했을 때 :c:type:`Py_tracefunc` 함수에 대한 *what* 매개 변수의 값."

#: ../../c-api/init.rst:2098
msgid ""
"Register a reference tracer function. The function will be called when a "
"new Python has been created or when an object is going to be destroyed. "
"If **data** is provided it must be an opaque pointer that will be "
"provided when the tracer function is called. Return ``0`` on success. Set"
" an exception and return ``-1`` on error."
msgstr ""

#: ../../c-api/init.rst:2104
msgid ""
"Not that tracer functions **must not** create Python objects inside or "
"otherwise the call will be re-entrant. The tracer also **must not** clear"
" any existing exception or set an exception.  The GIL will be held every "
"time the tracer function is called."
msgstr ""

#: ../../c-api/init.rst:2109 ../../c-api/init.rst:2120
#, fuzzy
msgid "The GIL must be held when calling this function."
msgstr "이러한 함수를 호출할 때 GIL을 보유할 필요는 *없습니다*; 그들은 자체 록을 제공합니다."

#: ../../c-api/init.rst:2115
msgid ""
"Get the registered reference tracer function and the value of the opaque "
"data pointer that was registered when :c:func:`PyRefTracer_SetTracer` was"
" called. If no tracer was registered this function will return NULL and "
"will set the **data** pointer to NULL."
msgstr ""

#: ../../c-api/init.rst:2127
msgid "Advanced Debugger Support"
msgstr "고급 디버거 지원"

#: ../../c-api/init.rst:2132
msgid "These functions are only intended to be used by advanced debugging tools."
msgstr "이 함수들은 고급 디버깅 도구에서만 사용하기 위한 것입니다."

#: ../../c-api/init.rst:2137
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr "인터프리터 상태 객체들의 리스트의 머리에 있는 객체를 반환합니다."

#: ../../c-api/init.rst:2142
msgid "Return the main interpreter state object."
msgstr "메인 인터프리터 상태 객체를 반환합니다."

#: ../../c-api/init.rst:2147
msgid ""
"Return the next interpreter state object after *interp* from the list of "
"all such objects."
msgstr "인터프리터 상태 객체들의 리스트에서 *interp* 이후의 다음 인터프리터 상태 객체를 반환합니다."

#: ../../c-api/init.rst:2153
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the "
"list of threads associated with the interpreter *interp*."
msgstr ""
"인터프리터 *interp*\\와 관련된 스레드 리스트에서 첫 번째 :c:type:`PyThreadState` 객체에 대한 포인터를 "
"반환합니다."

#: ../../c-api/init.rst:2159
msgid ""
"Return the next thread state object after *tstate* from the list of all "
"such objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"같은 :c:type:`PyInterpreterState` 객체에 속하는 모든 스레드 객체 리스트에서 *tstate* 이후의 다음 "
"스레드 상태 객체를 반환합니다."

#: ../../c-api/init.rst:2166
msgid "Thread Local Storage Support"
msgstr "스레드 로컬 저장소 지원"

#: ../../c-api/init.rst:2170
#, fuzzy
msgid ""
"The Python interpreter provides low-level support for thread-local "
"storage (TLS) which wraps the underlying native TLS implementation to "
"support the Python-level thread local storage API "
"(:class:`threading.local`).  The CPython C level APIs are similar to "
"those offered by pthreads and Windows: use a thread key and functions to "
"associate a :c:expr:`void*` value per thread."
msgstr ""
"파이썬 인터프리터는 파이썬 수준의 스레드 로컬 저장소 API(:class:`threading.local`)를 지원하기 위해 하부 "
"네이티브 TLS 구현을 래핑하는 스레드 로컬 저장소(TLS)에 대한 저수준 지원을 제공합니다. CPython C 수준 API는 "
"pthread와 윈도우에서 제공하는 API와 유사합니다: 스레드 키와 함수를 사용하여 스레드 당 :c:type:`void*` 값을 "
"연결합니다."

#: ../../c-api/init.rst:2177
msgid ""
"The GIL does *not* need to be held when calling these functions; they "
"supply their own locking."
msgstr "이러한 함수를 호출할 때 GIL을 보유할 필요는 *없습니다*; 그들은 자체 록을 제공합니다."

#: ../../c-api/init.rst:2180
msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS "
"APIs, you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
":file:`Python.h`\\에는 TLS API 선언이 포함되어 있지 않음에 유의하십시오, 스레드 로컬 저장소를 사용하려면 "
":file:`pythread.h`\\를 포함해야 합니다."

#: ../../c-api/init.rst:2184
#, fuzzy
msgid ""
"None of these API functions handle memory management on behalf of the "
":c:expr:`void*` values.  You need to allocate and deallocate them "
"yourself. If the :c:expr:`void*` values happen to be :c:expr:`PyObject*`,"
" these functions don't do refcount operations on them either."
msgstr ""
"이러한 API 함수 중 어느 것도 :c:type:`void*` 값을 대신해서 메모리 관리를 처리하지 않습니다. 직접 할당하고 할당 "
"해제해야 합니다. :c:type:`void*` 값이 :c:type:`PyObject*` 이라면, 이 함수들은 참조 횟수 연산도 "
"수행하지 않습니다."

#: ../../c-api/init.rst:2192
msgid "Thread Specific Storage (TSS) API"
msgstr "스레드별 저장소 (TSS - Thread Specific Storage) API"

#: ../../c-api/init.rst:2194
#, fuzzy
msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within"
" the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""
"CPython 인터프리터 내에서 기존 TLS API의 사용을 대체하기 위해 TSS API가 도입되었습니다. 이 API는 스레드 키를"
" 나타내기 위해 :c:type:`int` 대신 새로운 형 :c:type:`Py_tss_t`\\를 사용합니다."

#: ../../c-api/init.rst:2200
msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr "\"CPython의 스레드-로컬 저장소를 위한 새로운 C-API\" (:pep:`539`)"

#: ../../c-api/init.rst:2205
msgid ""
"This data structure represents the state of a thread key, the definition "
"of which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no"
" public members in this structure."
msgstr ""
"이 자료 구조는 스레드 키의 상태를 나타내며, 정의는 하부 TLS 구현에 따라 달라질 수 있으며, 키의 초기화 상태를 나타내는 내부"
" 필드가 있습니다. 이 구조체에는 공개 멤버가 없습니다."

#: ../../c-api/init.rst:2210
msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
":ref:`Py_LIMITED_API <stable>`\\가 정의되지 않을 때, "
":c:macro:`Py_tss_NEEDS_INIT`\\로 이 형의 정적 할당이 허용됩니다."

#: ../../c-api/init.rst:2216
msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. "
"Note that this macro won't be defined with :ref:`Py_LIMITED_API "
"<stable>`."
msgstr ""
"이 매크로는 :c:type:`Py_tss_t` 변수의 초기화자(initializer)로 확장됩니다. 이 매크로는 "
":ref:`Py_LIMITED_API <stable>`\\에서 정의되지 않음에 유의하십시오."

#: ../../c-api/init.rst:2221
msgid "Dynamic Allocation"
msgstr "동적 할당"

#: ../../c-api/init.rst:2223
msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension "
"modules built with :ref:`Py_LIMITED_API <stable>`, where static "
"allocation of this type is not possible due to its implementation being "
"opaque at build time."
msgstr ""
":ref:`Py_LIMITED_API <stable>`\\로 빌드된 확장 모듈에 필요한, 빌드 시점에 구현이 불투명해서 형의 정적 "
"할당이 불가능한 :c:type:`Py_tss_t`\\의 동적 할당."

#: ../../c-api/init.rst:2230
msgid ""
"Return a value which is the same state as a value initialized with "
":c:macro:`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic "
"allocation failure."
msgstr ""
":c:macro:`Py_tss_NEEDS_INIT`\\로 초기화된 값과 같은 상태의 값을 반환하거나, 동적 할당 실패 시 "
"``NULL``\\을 반환합니다."

#: ../../c-api/init.rst:2237
#, fuzzy
msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after "
"first calling :c:func:`PyThread_tss_delete` to ensure any associated "
"thread locals have been unassigned. This is a no-op if the *key* argument"
" is ``NULL``."
msgstr ""
"모든 관련 스레드 로컬의 대입을 해제하도록 :c:func:`PyThread_tss_delete`\\를 먼저 호출한 후, "
":c:func:`PyThread_tss_alloc`\\에 의해 할당된 주어진 *key*\\를 할당 해제합니다. *key* 인자가 "
"`NULL`\\이면 아무런 일도 하지 않습니다."

#: ../../c-api/init.rst:2243
#, fuzzy
msgid ""
"A freed key becomes a dangling pointer. You should reset the key to "
"``NULL``."
msgstr "해제된 키는 매달린(dangling) 포인터가 됩니다, 키를 `NULL`\\로 재설정해야 합니다."

#: ../../c-api/init.rst:2248
msgid "Methods"
msgstr "메서드"

#: ../../c-api/init.rst:2250
msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, "
"the behaviors of :c:func:`PyThread_tss_set` and "
":c:func:`PyThread_tss_get` are undefined if the given :c:type:`Py_tss_t` "
"has not been initialized by :c:func:`PyThread_tss_create`."
msgstr ""
"이 함수들의 매개 변수 *key*\\는 ``NULL``\\이 아니어야 합니다. 또한, 주어진 :c:type:`Py_tss_t`\\가"
" :c:func:`PyThread_tss_create`\\로 초기화되지 않았으면, "
":c:func:`PyThread_tss_set`\\과 :c:func:`PyThread_tss_get`\\의 동작은 정의되지 "
"않습니다."

#: ../../c-api/init.rst:2258
msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been "
"initialized by :c:func:`PyThread_tss_create`."
msgstr ""
"주어진 :c:type:`Py_tss_t`\\가 :c:func:`PyThread_tss_create`\\로 초기화되었으면 0이 아닌 "
"값을 반환합니다."

#: ../../c-api/init.rst:2264
msgid ""
"Return a zero value on successful initialization of a TSS key.  The "
"behavior is undefined if the value pointed to by the *key* argument is "
"not initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be "
"called repeatedly on the same key -- calling it on an already initialized"
" key is a no-op and immediately returns success."
msgstr ""
"TSS 키 초기화에 성공하면 0 값을 반환합니다. *key* 인자가 가리키는 값이 "
":c:macro:`Py_tss_NEEDS_INIT`\\로 초기화되지 않으면 동작이 정의되지 않습니다. 이 함수는 같은 키에서 "
"반복적으로 호출될 수 있습니다 -- 이미 초기화된 키에 대해 호출하면 아무런 일도 하지 않으며 즉시 성공을 반환합니다."

#: ../../c-api/init.rst:2273
msgid ""
"Destroy a TSS key to forget the values associated with the key across all"
" threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again by "
":c:func:`PyThread_tss_create`. This function can be called repeatedly on "
"the same key -- calling it on an already destroyed key is a no-op."
msgstr ""
"TSS 키를 삭제하여 모든 스레드에서 키와 관련된 값을 잊게 하고, 키의 초기화 상태를 초기화되지 않음으로 변경합니다. 파괴된 키는"
" :c:func:`PyThread_tss_create`\\로 다시 초기화할 수 있습니다. 이 함수는 같은 키에서 반복적으로 호출될 "
"수 있습니다 -- 이미 파괴된 키에 대해 호출하면 아무런 일도 하지 않습니다."

#: ../../c-api/init.rst:2282
#, fuzzy
msgid ""
"Return a zero value to indicate successfully associating a "
":c:expr:`void*` value with a TSS key in the current thread.  Each thread "
"has a distinct mapping of the key to a :c:expr:`void*` value."
msgstr ""
"현재 스레드에서 :c:type:`void*` 값을 TSS 키와 성공적으로 연결했음을 나타내는 0 값을 반환합니다. 각 스레드에는 "
"키에서 :c:type:`void*` 값으로의 고유한 매핑이 있습니다."

#: ../../c-api/init.rst:2289
#, fuzzy
msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current"
" thread.  This returns ``NULL`` if no value is associated with the key in"
" the current thread."
msgstr ""
"현재 스레드의 TSS 키와 관련된 :c:type:`void*` 값을 반환합니다. 현재 스레드에 키와 연결된 값이 없으면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/init.rst:2297
msgid "Thread Local Storage (TLS) API"
msgstr "스레드 로컬 저장소 (TLS) API"

#: ../../c-api/init.rst:2299
msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API "
"<thread-specific-storage-api>`."
msgstr "이 API는 :ref:`스레드별 저장소 (TSS) API <thread-specific-storage-api>`\\로 대체됩니다."

#: ../../c-api/init.rst:2304
msgid ""
"This version of the API does not support platforms where the native TLS "
"key is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""
"이 버전의 API는 ``int``\\로 안전하게 캐스트 할 수 없는 방식으로 네이티브 TLS 키가 정의된 플랫폼을 지원하지 "
"않습니다. 이러한 플랫폼에서, :c:func:`PyThread_create_key`\\는 실패 상태로 즉시 반환되며, 다른 TLS "
"함수는 이러한 플랫폼에서 모두 아무런 일도 하지 않습니다."

#: ../../c-api/init.rst:2309
msgid ""
"Due to the compatibility problem noted above, this version of the API "
"should not be used in new code."
msgstr "위에서 언급한 호환성 문제로 인해, 이 버전의 API를 새 코드에서 사용해서는 안 됩니다."

#: ../../c-api/init.rst:2320
msgid "Synchronization Primitives"
msgstr ""

#: ../../c-api/init.rst:2322
msgid "The C-API provides a basic mutual exclusion lock."
msgstr ""

#: ../../c-api/init.rst:2326
msgid ""
"A mutual exclusion lock.  The :c:type:`!PyMutex` should be initialized to"
" zero to represent the unlocked state.  For example::"
msgstr ""

#: ../../c-api/init.rst:2329
#, python-brace-format
msgid "PyMutex mutex = {0};"
msgstr ""

#: ../../c-api/init.rst:2331
msgid ""
"Instances of :c:type:`!PyMutex` should not be copied or moved.  Both the "
"contents and address of a :c:type:`!PyMutex` are meaningful, and it must "
"remain at a fixed, writable location in memory."
msgstr ""

#: ../../c-api/init.rst:2337
msgid ""
"A :c:type:`!PyMutex` currently occupies one byte, but the size should be "
"considered unstable.  The size may change in future Python releases "
"without a deprecation period."
msgstr ""

#: ../../c-api/init.rst:2345
msgid ""
"Lock mutex *m*.  If another thread has already locked it, the calling "
"thread will block until the mutex is unlocked.  While blocked, the thread"
" will temporarily release the :term:`GIL` if it is held."
msgstr ""

#: ../../c-api/init.rst:2353
msgid ""
"Unlock mutex *m*. The mutex must be locked --- otherwise, the function "
"will issue a fatal error."
msgstr ""

#: ../../c-api/init.rst:2361
msgid "Python Critical Section API"
msgstr ""

#: ../../c-api/init.rst:2363
msgid ""
"The critical section API provides a deadlock avoidance layer on top of "
"per-object locks for :term:`free-threaded <free threading>` CPython.  "
"They are intended to replace reliance on the :term:`global interpreter "
"lock`, and are no-ops in versions of Python with the global interpreter "
"lock."
msgstr ""

#: ../../c-api/init.rst:2368
msgid ""
"Critical sections avoid deadlocks by implicitly suspending active "
"critical sections and releasing the locks during calls to "
":c:func:`PyEval_SaveThread`. When :c:func:`PyEval_RestoreThread` is "
"called, the most recent critical section is resumed, and its locks "
"reacquired.  This means the critical section API provides weaker "
"guarantees than traditional locks -- they are useful because their "
"behavior is similar to the :term:`GIL`."
msgstr ""

#: ../../c-api/init.rst:2375
msgid ""
"The functions and structs used by the macros are exposed for cases where "
"C macros are not available. They should only be used as in the given "
"macro expansions. Note that the sizes and contents of the structures may "
"change in future Python versions."
msgstr ""

#: ../../c-api/init.rst:2382
msgid ""
"Operations that need to lock two objects at once must use "
":c:macro:`Py_BEGIN_CRITICAL_SECTION2`.  You *cannot* use nested critical "
"sections to lock more than one object at once, because the inner critical"
" section may suspend the outer critical sections.  This API does not "
"provide a way to lock more than two objects at once."
msgstr ""

#: ../../c-api/init.rst:2388
msgid "Example usage::"
msgstr ""

#: ../../c-api/init.rst:2390
#, python-brace-format
msgid ""
"static PyObject *\n"
"set_field(MyObject *self, PyObject *value)\n"
"{\n"
"   Py_BEGIN_CRITICAL_SECTION(self);\n"
"   Py_SETREF(self->field, Py_XNewRef(value));\n"
"   Py_END_CRITICAL_SECTION();\n"
"   Py_RETURN_NONE;\n"
"}"
msgstr ""

#: ../../c-api/init.rst:2399
msgid ""
"In the above example, :c:macro:`Py_SETREF` calls :c:macro:`Py_DECREF`, "
"which can call arbitrary code through an object's deallocation function."
"  The critical section API avoids potential deadlocks due to reentrancy "
"and lock ordering by allowing the runtime to temporarily suspend the "
"critical section if the code triggered by the finalizer blocks and calls "
":c:func:`PyEval_SaveThread`."
msgstr ""

#: ../../c-api/init.rst:2407
msgid ""
"Acquires the per-object lock for the object *op* and begins a critical "
"section."
msgstr ""

#: ../../c-api/init.rst:2410 ../../c-api/init.rst:2424
#: ../../c-api/init.rst:2439 ../../c-api/init.rst:2453
msgid "In the free-threaded build, this macro expands to::"
msgstr ""

#: ../../c-api/init.rst:2412
msgid ""
"{\n"
"    PyCriticalSection _py_cs;\n"
"    PyCriticalSection_Begin(&_py_cs, (PyObject*)(op))"
msgstr ""

#: ../../c-api/init.rst:2416 ../../c-api/init.rst:2445
msgid "In the default build, this macro expands to ``{``."
msgstr ""

#: ../../c-api/init.rst:2422
msgid "Ends the critical section and releases the per-object lock."
msgstr ""

#: ../../c-api/init.rst:2426
msgid ""
"    PyCriticalSection_End(&_py_cs);\n"
"}"
msgstr ""

#: ../../c-api/init.rst:2429 ../../c-api/init.rst:2458
msgid "In the default build, this macro expands to ``}``."
msgstr ""

#: ../../c-api/init.rst:2435
msgid ""
"Acquires the per-objects locks for the objects *a* and *b* and begins a "
"critical section.  The locks are acquired in a consistent order (lowest "
"address first) to avoid lock ordering deadlocks."
msgstr ""

#: ../../c-api/init.rst:2441
msgid ""
"{\n"
"    PyCriticalSection2 _py_cs2;\n"
"    PyCriticalSection2_Begin(&_py_cs2, (PyObject*)(a), (PyObject*)(b))"
msgstr ""

#: ../../c-api/init.rst:2451
msgid "Ends the critical section and releases the per-object locks."
msgstr ""

#: ../../c-api/init.rst:2455
msgid ""
"    PyCriticalSection2_End(&_py_cs2);\n"
"}"
msgstr ""

#: ../../c-api/init.rst:350
msgid "PyEval_InitThreads()"
msgstr ""

#: ../../c-api/init.rst:350
msgid "modules (in module sys)"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:710
msgid "path (in module sys)"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:710 ../../c-api/init.rst:1145
#: ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "module"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "builtins"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "__main__"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "sys"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:710
msgid "search"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:710
msgid "path"
msgstr ""

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1722 ../../c-api/init.rst:1775
msgid "Py_FinalizeEx (C function)"
msgstr ""

#: ../../c-api/init.rst:576
#, fuzzy
msgid "Py_Initialize()"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:576 ../../c-api/init.rst:808
msgid "main()"
msgstr ""

#: ../../c-api/init.rst:576
msgid "Py_GetPath()"
msgstr ""

#: ../../c-api/init.rst:689
msgid "executable (in module sys)"
msgstr ""

#: ../../c-api/init.rst:743 ../../c-api/init.rst:785 ../../c-api/init.rst:799
msgid "version (in module sys)"
msgstr ""

#: ../../c-api/init.rst:755
msgid "platform (in module sys)"
msgstr ""

#: ../../c-api/init.rst:772
msgid "copyright (in module sys)"
msgstr ""

#: ../../c-api/init.rst:808
msgid "Py_FatalError()"
msgstr ""

#: ../../c-api/init.rst:808
msgid "argv (in module sys)"
msgstr ""

#: ../../c-api/init.rst:928
#, fuzzy
msgid "global interpreter lock"
msgstr "스레드 상태와 전역 인터프리터 록"

#: ../../c-api/init.rst:928
#, fuzzy
msgid "interpreter lock"
msgstr "서브 인터프리터 지원"

#: ../../c-api/init.rst:928
msgid "lock, interpreter"
msgstr ""

#: ../../c-api/init.rst:941
msgid "setswitchinterval (in module sys)"
msgstr ""

#: ../../c-api/init.rst:950
msgid "PyThreadState (C type)"
msgstr ""

#: ../../c-api/init.rst:976
msgid "Py_BEGIN_ALLOW_THREADS (C macro)"
msgstr ""

#: ../../c-api/init.rst:976
msgid "Py_END_ALLOW_THREADS (C macro)"
msgstr ""

#: ../../c-api/init.rst:992
msgid "PyEval_RestoreThread (C function)"
msgstr ""

#: ../../c-api/init.rst:992
msgid "PyEval_SaveThread (C function)"
msgstr ""

#: ../../c-api/init.rst:1123
msgid "PyEval_AcquireThread()"
msgstr ""

#: ../../c-api/init.rst:1123
msgid "PyEval_ReleaseThread()"
msgstr ""

#: ../../c-api/init.rst:1123
msgid "PyEval_SaveThread()"
msgstr ""

#: ../../c-api/init.rst:1123
msgid "PyEval_RestoreThread()"
msgstr ""

#: ../../c-api/init.rst:1145
msgid "_thread"
msgstr ""

#: ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "stdout (in module sys)"
msgstr ""

#: ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "stderr (in module sys)"
msgstr ""

#: ../../c-api/init.rst:1658 ../../c-api/init.rst:1757
msgid "stdin (in module sys)"
msgstr ""

#: ../../c-api/init.rst:1722
msgid "Py_Initialize (C function)"
msgstr ""

#: ../../c-api/init.rst:1752
msgid "close (in module os)"
msgstr ""

#~ msgid ":c:func:`Py_SetStandardStreamEncoding`"
#~ msgstr ":c:func:`Py_SetStandardStreamEncoding`"

#~ msgid ":c:func:`PySys_AddWarnOption`"
#~ msgstr ":c:func:`PySys_AddWarnOption`"

#~ msgid ":c:func:`PySys_AddXOption`"
#~ msgstr ":c:func:`PySys_AddXOption`"

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우."

#~ msgid ""
#~ "This function should be called before"
#~ " :c:func:`Py_Initialize`, if it is called"
#~ " at all. It specifies which encoding"
#~ " and error handling to use with "
#~ "standard IO, with the same meanings "
#~ "as in :func:`str.encode`."
#~ msgstr ""
#~ "이 함수는 (호출한다면) :c:func:`Py_Initialize` 전에 "
#~ "호출해야 합니다. :func:`str.encode`\\에서와 같은 의미로, "
#~ "표준 IO에 사용할 인코딩과 에러 처리를 지정합니다."

#~ msgid ""
#~ "It overrides :envvar:`PYTHONIOENCODING` values, "
#~ "and allows embedding code to control "
#~ "IO encoding when the environment "
#~ "variable does not work."
#~ msgstr ""
#~ ":envvar:`PYTHONIOENCODING` 값을 재정의(overrides)하고, 환경"
#~ " 변수가 작동하지 않을 때 내장(embedding) 코드가 "
#~ "IO 인코딩을 제어할 수 있도록 합니다."

#~ msgid ""
#~ "*encoding* and/or *errors* may be "
#~ "``NULL`` to use :envvar:`PYTHONIOENCODING` "
#~ "and/or default values (depending on "
#~ "other settings)."
#~ msgstr ""
#~ "*encoding* 및/또는 *errors*\\는 "
#~ ":envvar:`PYTHONIOENCODING` 및/또는 기본값(다른 설정에 따라"
#~ " 다릅니다)을 사용하기 위해 ``NULL``\\일 수 있습니다."

#~ msgid ""
#~ "Note that :data:`sys.stderr` always uses "
#~ "the \"backslashreplace\" error handler, "
#~ "regardless of this (or any other) "
#~ "setting."
#~ msgstr ""
#~ ":data:`sys.stderr`\\은 이 (또는 다른) 설정과 관계없이"
#~ " 항상 \"backslashreplace\" 에러 처리기를 사용함에 "
#~ "유의하십시오."

#~ msgid ""
#~ "If :c:func:`Py_FinalizeEx` is called, this "
#~ "function will need to be called "
#~ "again in order to affect subsequent "
#~ "calls to :c:func:`Py_Initialize`."
#~ msgstr ""
#~ ":c:func:`Py_FinalizeEx`\\가 호출되면, 이 함수는 "
#~ ":c:func:`Py_Initialize`\\에 대한 후속 호출에 영향을 "
#~ "미치기 위해 다시 호출되어야 합니다."

#~ msgid ""
#~ "Returns ``0`` if successful, a nonzero"
#~ " value on error (e.g. calling after"
#~ " the interpreter has already been "
#~ "initialized)."
#~ msgstr "성공하면 ``0``\\을 반환하고, 에러 시 (예를 들어 인터프리터가 이미 초기화된 후 호출) 0이 아닌 값을 반환합니다."

#~ msgid ""
#~ "Set the default module search path.  "
#~ "If this function is called before "
#~ ":c:func:`Py_Initialize`, then :c:func:`Py_GetPath` "
#~ "won't attempt to compute a default "
#~ "search path but uses the one "
#~ "provided instead.  This is useful if "
#~ "Python is embedded by an application "
#~ "that has full knowledge of the "
#~ "location of all modules.  The path "
#~ "components should be separated by the"
#~ " platform dependent delimiter character, "
#~ "which is ``':'`` on Unix and Mac"
#~ " OS X, ``';'`` on Windows."
#~ msgstr ""
#~ "기본 모듈 검색 경로를 설정합니다. 이 함수가 "
#~ ":c:func:`Py_Initialize` 이전에 호출되면, "
#~ ":c:func:`Py_GetPath`\\는 기본 검색 경로를 계산하지 "
#~ "않고 대신 제공된 경로를 사용합니다. 이는 모든 "
#~ "모듈의 위치를 완전히 알고 있는 응용 프로그램에 "
#~ "파이썬이 내장된 경우 유용합니다. 경로 구성 요소는 "
#~ "플랫폼 종속적 구분자 문자(유닉스에서는 ``':'``, 윈도우에서는"
#~ " ``';'``)로 구분해야 합니다."

#~ msgid ""
#~ "This also causes :data:`sys.executable` to "
#~ "be set to the program full path"
#~ " (see :c:func:`Py_GetProgramFullPath`) and for"
#~ " :data:`sys.prefix` and :data:`sys.exec_prefix` "
#~ "to be empty.  It is up to "
#~ "the caller to modify these if "
#~ "required after calling :c:func:`Py_Initialize`."
#~ msgstr ""
#~ "또한 :data:`sys.executable`\\이 프로그램 전체 경로 "
#~ "(:c:func:`Py_GetProgramFullPath` 를 참조하십시오)로 설정되고 "
#~ ":data:`sys.prefix`\\와 :data:`sys.exec_prefix`\\가 비어있도록 "
#~ "합니다. :c:func:`Py_Initialize`\\를 호출한 후 필요할 "
#~ "때 이를 수정하는 것은 호출자에게 달려 있습니다."

#~ msgid ""
#~ "The path argument is copied internally,"
#~ " so the caller may free it "
#~ "after the call completes."
#~ msgstr "경로 인자는 내부적으로 복사되므로, 호출이 완료된 후 호출자가 할당 해제할 수 있습니다."

#~ msgid ""
#~ "The program full path is now used"
#~ " for :data:`sys.executable`, instead of the"
#~ " program name."
#~ msgstr "이제 프로그램 이름 대신 프로그램 전체 경로가 :data:`sys.executable`\\에 사용됩니다."

#~ msgid ""
#~ "Returns a non-zero value if "
#~ ":c:func:`PyEval_InitThreads` has been called.  "
#~ "This function can be called without "
#~ "holding the GIL, and therefore can "
#~ "be used to avoid calls to the "
#~ "locking API when running single-"
#~ "threaded."
#~ msgstr ""
#~ ":c:func:`PyEval_InitThreads`\\가 호출되었으면, 0이 아닌 "
#~ "값을 반환합니다. 이 함수는 GIL을 보유하지 않고 "
#~ "호출할 수 있어서, 단일 스레드를 실행할 때 록"
#~ " API 호출을 회피하는 데 사용할 수 있습니다."

#~ msgid "The :term:`GIL` is now initialized by :c:func:`Py_Initialize()`."
#~ msgstr ":term:`GIL`\\은 이제 :c:func:`Py_Initialize()`\\에 의해 초기화됩니다."

#~ msgid ""
#~ "Acquire the global interpreter lock.  "
#~ "The lock must have been created "
#~ "earlier. If this thread already has "
#~ "the lock, a deadlock ensues."
#~ msgstr "전역 인터프리터 록을 획득합니다. 록은 이전에 만들어졌어야 합니다. 이 스레드에 이미 록이 있으면, 교착 상태가 발생합니다."

#~ msgid ""
#~ "This function does not update the "
#~ "current thread state.  Please use "
#~ ":c:func:`PyEval_RestoreThread` or "
#~ ":c:func:`PyEval_AcquireThread` instead."
#~ msgstr ""
#~ "이 함수는 현재 스레드 상태를 갱신하지 않습니다. "
#~ "대신 :c:func:`PyEval_RestoreThread`\\나 "
#~ ":c:func:`PyEval_AcquireThread`\\를 사용하십시오."

#~ msgid ""
#~ "Release the global interpreter lock.  "
#~ "The lock must have been created "
#~ "earlier."
#~ msgstr "전역 인터프리터 록을 해제합니다. 록은 이전에 만들어졌어야 합니다."

#~ msgid ""
#~ "This function does not update the "
#~ "current thread state.  Please use "
#~ ":c:func:`PyEval_SaveThread` or "
#~ ":c:func:`PyEval_ReleaseThread` instead."
#~ msgstr ""
#~ "이 함수는 현재 스레드 상태를 갱신하지 않습니다. "
#~ "대신 :c:func:`PyEval_SaveThread`\\나 "
#~ ":c:func:`PyEval_ReleaseThread`\\를 사용하십시오."

