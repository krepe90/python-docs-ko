# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/gcsupport.rst:6
msgid "Supporting Cyclic Garbage Collection"
msgstr "순환 가비지 수집 지원"

#: ../../c-api/gcsupport.rst:8
msgid ""
"Python's support for detecting and collecting garbage which involves "
"circular references requires support from object types which are "
"\"containers\" for other objects which may also be containers.  Types "
"which do not store references to other objects, or which only store "
"references to atomic types (such as numbers or strings), do not need to "
"provide any explicit support for garbage collection."
msgstr ""
"순환 참조를 포함하는 가비지를 탐지하고 수집하는 파이썬의 지원은 역시 컨테이너일 수 있는 다른 객체의 \"컨테이너\" 인 객체 형의"
" 지원이 필요합니다. 다른 객체에 대한 참조를 저장하지 않거나, 원자 형(가령 숫자나 문자열)에 대한 참조만 저장하는 형은 가비지 "
"수집에 대한 어떤 명시적인 지원을 제공할 필요가 없습니다."

#: ../../c-api/gcsupport.rst:15
msgid ""
"To create a container type, the :c:member:`~PyTypeObject.tp_flags` field "
"of the type object must include the :c:macro:`Py_TPFLAGS_HAVE_GC` and "
"provide an implementation of the :c:member:`~PyTypeObject.tp_traverse` "
"handler.  If instances of the type are mutable, a "
":c:member:`~PyTypeObject.tp_clear` implementation must also be provided."
msgstr ""
"컨테이너형을 만들려면, 형 객체의 :c:member:`~PyTypeObject.tp_flags` 필드가 "
":c:macro:`Py_TPFLAGS_HAVE_GC`\\를 포함해야 하고 "
":c:member:`~PyTypeObject.tp_traverse` 처리기 구현을 제공해야 합니다. 형의 인스턴스가 가변이면, "
":c:member:`~PyTypeObject.tp_clear` 구현도 제공해야 합니다."

#: ../../c-api/gcsupport.rst:21
msgid ":c:macro:`Py_TPFLAGS_HAVE_GC`"
msgstr ":c:macro:`Py_TPFLAGS_HAVE_GC`"

#: ../../c-api/gcsupport.rst:22
msgid ""
"Objects with a type with this flag set must conform with the rules "
"documented here.  For convenience these objects will be referred to as "
"container objects."
msgstr "이 플래그가 설정된 형의 객체는 여기에 설명된 규칙을 준수해야 합니다. 편의를 위해 이러한 객체를 컨테이너 객체라고 하겠습니다."

#: ../../c-api/gcsupport.rst:26
msgid "Constructors for container types must conform to two rules:"
msgstr "컨테이너형의 생성자는 두 가지 규칙을 준수해야 합니다:"

#: ../../c-api/gcsupport.rst:28
msgid ""
"The memory for the object must be allocated using "
":c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"객체의 메모리는 :c:macro:`PyObject_GC_New` 나 :c:macro:`PyObject_GC_NewVar`\\를 "
"사용하여 할당해야 합니다."

#: ../../c-api/gcsupport.rst:31
msgid ""
"Once all the fields which may contain references to other containers are "
"initialized, it must call :c:func:`PyObject_GC_Track`."
msgstr ""
"다른 컨테이너에 대한 참조를 포함할 수 있는 모든 필드가 초기화되면, :c:func:`PyObject_GC_Track`\\를 "
"호출해야 합니다."

#: ../../c-api/gcsupport.rst:34
msgid ""
"Similarly, the deallocator for the object must conform to a similar pair "
"of rules:"
msgstr "마찬가지로, 객체의 할당해제자(deallocator)는 비슷한 규칙 쌍을 준수해야 합니다:"

#: ../../c-api/gcsupport.rst:37
msgid ""
"Before fields which refer to other containers are invalidated, "
":c:func:`PyObject_GC_UnTrack` must be called."
msgstr "다른 컨테이너를 참조하는 필드가 무효화 되기 전에, :c:func:`PyObject_GC_UnTrack`\\를 호출해야 합니다."

#: ../../c-api/gcsupport.rst:40
msgid "The object's memory must be deallocated using :c:func:`PyObject_GC_Del`."
msgstr "객체의 메모리는 :c:func:`PyObject_GC_Del`\\를 사용하여 할당 해제되어야 합니다."

#: ../../c-api/gcsupport.rst:43
msgid ""
"If a type adds the Py_TPFLAGS_HAVE_GC, then it *must* implement at least "
"a :c:member:`~PyTypeObject.tp_traverse` handler or explicitly use one "
"from its subclass or subclasses."
msgstr ""

#: ../../c-api/gcsupport.rst:47
msgid ""
"When calling :c:func:`PyType_Ready` or some of the APIs that indirectly "
"call it like :c:func:`PyType_FromSpecWithBases` or "
":c:func:`PyType_FromSpec` the interpreter will automatically populate the"
" :c:member:`~PyTypeObject.tp_flags`, "
":c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields if the type inherits from a "
"class that implements the garbage collector protocol and the child class "
"does *not* include the :c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""

#: ../../c-api/gcsupport.rst:57
msgid ""
"Analogous to :c:macro:`PyObject_New` but for container objects with the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
":c:macro:`PyObject_New`\\와 유사하지만, :c:macro:`Py_TPFLAGS_HAVE_GC` 플래그가 설정된 "
"컨테이너 객체를 위한 것."

#: ../../c-api/gcsupport.rst:62
msgid ""
"Analogous to :c:macro:`PyObject_NewVar` but for container objects with "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
":c:macro:`PyObject_NewVar`\\와 유사하지만, :c:macro:`Py_TPFLAGS_HAVE_GC` 플래그가 "
"설정된 컨테이너 객체를 위한 것."

#: ../../c-api/gcsupport.rst:67
msgid ""
"Analogous to :c:macro:`PyObject_GC_New` but allocates *extra_size* bytes "
"at the end of the object (at offset "
":c:member:`~PyTypeObject.tp_basicsize`). The allocated memory is "
"initialized to zeros, except for the :c:type:`Python object header "
"<PyObject>`."
msgstr ""

#: ../../c-api/gcsupport.rst:73
msgid ""
"The extra data will be deallocated with the object, but otherwise it is "
"not managed by Python."
msgstr ""

#: ../../c-api/gcsupport.rst:77
msgid ""
"The function is marked as unstable because the final mechanism for "
"reserving extra data after an instance is not yet decided. For allocating"
" a variable number of fields, prefer using :c:type:`PyVarObject` and "
":c:member:`~PyTypeObject.tp_itemsize` instead."
msgstr ""

#: ../../c-api/gcsupport.rst:88
msgid ""
"Resize an object allocated by :c:macro:`PyObject_NewVar`. Returns the "
"resized object of type ``TYPE*`` (refers to any C type) or ``NULL`` on "
"failure."
msgstr ""
":c:macro:`PyObject_NewVar`\\에 의해 할당된 객체의 크기를 변경합니다. 형 ``TYPE*`` (모든 C 형을 "
"나타냅니다) 의 크기가 조정된 객체나 실패하면 ``NULL``\\을 반환합니다."

#: ../../c-api/gcsupport.rst:92
msgid ""
"*op* must be of type :c:expr:`PyVarObject *` and must not be tracked by "
"the collector yet. *newsize* must be of type :c:type:`Py_ssize_t`."
msgstr ""
"*op*\\는 형 :c:expr:`PyVarObject *`\\이어야 하고 아직 수거기가 추적하지 않아야 합니다. "
"*newsize*\\는 형 :c:type:`Py_ssize_t`\\이어야 합니다."

#: ../../c-api/gcsupport.rst:99
msgid ""
"Adds the object *op* to the set of container objects tracked by the "
"collector.  The collector can run at unexpected times so objects must be "
"valid while being tracked.  This should be called once all the fields "
"followed by the :c:member:`~PyTypeObject.tp_traverse` handler become "
"valid, usually near the end of the constructor."
msgstr ""
"수거기가 추적하는 컨테이너 객체 집합에 객체 *op*\\를 추가합니다. 수거기는 예기치 않은 시간에 실행될 수 있으므로 추적되는 "
"동안 객체가 유효해야 합니다. :c:member:`~PyTypeObject.tp_traverse` 처리기가 탐색하는 모든 필드가 "
"유효해지면 호출해야 합니다, 보통 생성자의 끝부분 근처입니다."

#: ../../c-api/gcsupport.rst:108
msgid ""
"Returns non-zero if the object implements the garbage collector protocol,"
" otherwise returns 0."
msgstr "객체가 가비지 수거기 프로토콜을 구현하면 0이 아닌 값을 반환하고, 그렇지 않으면 0을 반환합니다."

#: ../../c-api/gcsupport.rst:111
msgid ""
"The object cannot be tracked by the garbage collector if this function "
"returns 0."
msgstr "이 함수가 0을 반환하면 가비지 수거기가 객체를 추적할 수 없습니다."

#: ../../c-api/gcsupport.rst:116
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* "
"is being currently tracked by the garbage collector and 0 otherwise."
msgstr ""
"*op*\\의 객체 형이 GC 프로토콜을 구현하고 *op*\\가 현재 가비지 수거기가 추적 중이면 1을 반환하고 그렇지 않으면 0을"
" 반환합니다."

#: ../../c-api/gcsupport.rst:119
msgid "This is analogous to the Python function :func:`gc.is_tracked`."
msgstr "이것은 파이썬 함수 :func:`gc.is_tracked`\\에 해당합니다."

#: ../../c-api/gcsupport.rst:126
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* "
"has been already finalized by the garbage collector and 0 otherwise."
msgstr ""
"*op*\\의 객체 형이 GC 프로토콜을 구현하고 가비지 수거기가 *op*\\를 이미 파이널라이즈 했으면 1을 반환하고 그렇지 "
"않으면 0을 반환합니다."

#: ../../c-api/gcsupport.rst:129
msgid "This is analogous to the Python function :func:`gc.is_finalized`."
msgstr "이것은 파이썬 함수 :func:`gc.is_finalized`\\에 해당합니다."

#: ../../c-api/gcsupport.rst:136
msgid ""
"Releases memory allocated to an object using :c:macro:`PyObject_GC_New` "
"or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
":c:macro:`PyObject_GC_New` 나 :c:macro:`PyObject_GC_NewVar`\\를 사용하여 객체에 "
"할당된 메모리를 해제합니다."

#: ../../c-api/gcsupport.rst:142
msgid ""
"Remove the object *op* from the set of container objects tracked by the "
"collector.  Note that :c:func:`PyObject_GC_Track` can be called again on "
"this object to add it back to the set of tracked objects.  The "
"deallocator (:c:member:`~PyTypeObject.tp_dealloc` handler) should call "
"this for the object before any of the fields used by the "
":c:member:`~PyTypeObject.tp_traverse` handler become invalid."
msgstr ""
"수거기가 추적하는 컨테이너 객체 집합에서 *op* 객체를 제거합니다. :c:func:`PyObject_GC_Track`\\를 이 "
"객체에 대해 다시 호출하여 추적 객체 집합에 다시 추가할 수 있음에 유의하십시오. "
"할당해제자(:c:member:`~PyTypeObject.tp_dealloc` 처리기)는 "
":c:member:`~PyTypeObject.tp_traverse` 처리기에서 사용하는 필드가 무효화 되기 전에 객체에 대해 이 "
"함수를 호출해야 합니다."

#: ../../c-api/gcsupport.rst:151
msgid ""
"The :c:func:`!_PyObject_GC_TRACK` and :c:func:`!_PyObject_GC_UNTRACK` "
"macros have been removed from the public C API."
msgstr ""
":c:func:`!_PyObject_GC_TRACK`\\과 :c:func:`!_PyObject_GC_UNTRACK` 매크로는 공용 "
"C API에서 제거되었습니다."

#: ../../c-api/gcsupport.rst:154
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function "
"parameter of this type:"
msgstr ":c:member:`~PyTypeObject.tp_traverse` 처리기는 다음과 같은 형의 함수 매개 변수를 받아들입니다:"

#: ../../c-api/gcsupport.rst:159
msgid ""
"Type of the visitor function passed to the "
":c:member:`~PyTypeObject.tp_traverse` handler. The function should be "
"called with an object to traverse as *object* and the third parameter to "
"the :c:member:`~PyTypeObject.tp_traverse` handler as *arg*.  The Python "
"core uses several visitor functions to implement cyclic garbage "
"detection; it's not expected that users will need to write their own "
"visitor functions."
msgstr ""
":c:member:`~PyTypeObject.tp_traverse` 처리기에 전달되는 방문자 함수의 형. 이 함수는 탐색하는 객체를"
" *object*\\로, :c:member:`~PyTypeObject.tp_traverse` 처리기의 세 번째 매개 변수를 "
"*arg*\\로 호출되어야 합니다. 파이썬 코어는 순환 가비지 탐지를 구현하기 위해 여러 방문자 함수를 사용합니다; 사용자가 자신의"
" 방문자 함수를 작성해야 할 필요는 없습니다."

#: ../../c-api/gcsupport.rst:166
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler must have the following"
" type:"
msgstr ":c:member:`~PyTypeObject.tp_traverse` 처리기는 다음 형이어야 합니다:"

#: ../../c-api/gcsupport.rst:171
msgid ""
"Traversal function for a container object.  Implementations must call the"
" *visit* function for each object directly contained by *self*, with the "
"parameters to *visit* being the contained object and the *arg* value "
"passed to the handler.  The *visit* function must not be called with a "
"``NULL`` object argument.  If *visit* returns a non-zero value that value"
" should be returned immediately."
msgstr ""
"컨테이너 객체의 탐색 함수입니다. 구현은 *self*\\에 직접 포함된 각 객체에 대해 *visit* 함수를 호출해야 하며, "
"*visit*\\에 대한 매개 변수는 포함된 객체와 처리기로 전달된 *arg* 값입니다. *visit* 함수는 ``NULL`` "
"object 인자로 호출하면 안 됩니다. *visit*\\가 0이 아닌 값을 반환하면 그 값이 즉시 반환되어야 합니다."

#: ../../c-api/gcsupport.rst:178
msgid ""
"To simplify writing :c:member:`~PyTypeObject.tp_traverse` handlers, a "
":c:func:`Py_VISIT` macro is provided.  In order to use this macro, the "
":c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg*:"
msgstr ""
":c:member:`~PyTypeObject.tp_traverse` 처리기 작성을 단순화하기 위해, "
":c:func:`Py_VISIT` 매크로가 제공됩니다. 이 매크로를 사용하려면, "
":c:member:`~PyTypeObject.tp_traverse` 구현은 인자의 이름을 정확히 *visit* 와 *arg*\\로 "
"지정해야 합니다:"

#: ../../c-api/gcsupport.rst:185
msgid ""
"If *o* is not ``NULL``, call the *visit* callback, with arguments *o* and"
" *arg*.  If *visit* returns a non-zero value, then return it. Using this "
"macro, :c:member:`~PyTypeObject.tp_traverse` handlers look like::"
msgstr ""
"*o*\\가 ``NULL``\\이 아니면, *o* 와 *arg* 인자로 *visit* 콜백을 호출합니다. *visit*\\가 0이 "
"아닌 값을 반환하면, 그것을 반환합니다. 이 매크로를 사용하면, :c:member:`~PyTypeObject.tp_traverse`"
" 처리기가 다음과 같아집니다::"

#: ../../c-api/gcsupport.rst:190
#, python-brace-format
msgid ""
"static int\n"
"my_traverse(Noddy *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->foo);\n"
"    Py_VISIT(self->bar);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"my_traverse(Noddy *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->foo);\n"
"    Py_VISIT(self->bar);\n"
"    return 0;\n"
"}"

#: ../../c-api/gcsupport.rst:198
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` handler must be of the "
":c:type:`inquiry` type, or ``NULL`` if the object is immutable."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 처리기는 :c:type:`inquiry` 형이거나 객체가 불변이면 "
"``NULL``\\이어야 합니다."

#: ../../c-api/gcsupport.rst:204
msgid ""
"Drop references that may have created reference cycles.  Immutable "
"objects do not have to define this method since they can never directly "
"create reference cycles.  Note that the object must still be valid after "
"calling this method (don't just call :c:func:`Py_DECREF` on a reference)."
"  The collector will call this method if it detects that this object is "
"involved in a reference cycle."
msgstr ""
"참조 순환을 생성했을 수 있는 참조를 삭제합니다. 불변 객체는 참조 순환을 직접 생성할 수 없으므로, 이 메서드를 정의 할 필요가 "
"없습니다. 이 메서드를 호출한 후에도 객체가 유효해야 합니다 (단지 참조에 대해 :c:func:`Py_DECREF`\\를 호출하지 "
"마십시오). 이 객체가 참조 순환에 참여하고 있음을 수거기가 감지하면 이 메서드를 호출합니다."

#: ../../c-api/gcsupport.rst:213
msgid "Controlling the Garbage Collector State"
msgstr "가비지 수거기 상태 제어하기"

#: ../../c-api/gcsupport.rst:215
msgid ""
"The C-API provides the following functions for controlling garbage "
"collection runs."
msgstr ""

#: ../../c-api/gcsupport.rst:220
msgid ""
"Perform a full garbage collection, if the garbage collector is enabled. "
"(Note that :func:`gc.collect` runs it unconditionally.)"
msgstr ""

#: ../../c-api/gcsupport.rst:223
msgid ""
"Returns the number of collected + unreachable objects which cannot be "
"collected. If the garbage collector is disabled or already collecting, "
"returns ``0`` immediately. Errors during garbage collection are passed to"
" :data:`sys.unraisablehook`. This function does not raise exceptions."
msgstr ""

#: ../../c-api/gcsupport.rst:233
msgid ""
"Enable the garbage collector: similar to :func:`gc.enable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""

#: ../../c-api/gcsupport.rst:241
msgid ""
"Disable the garbage collector: similar to :func:`gc.disable`. Returns the"
" previous state, 0 for disabled and 1 for enabled."
msgstr ""

#: ../../c-api/gcsupport.rst:249
msgid ""
"Query the state of the garbage collector: similar to "
":func:`gc.isenabled`. Returns the current state, 0 for disabled and 1 for"
" enabled."
msgstr ""

#: ../../c-api/gcsupport.rst:256
msgid "Querying Garbage Collector State"
msgstr "가비지 수거기 상태 조회하기"

#: ../../c-api/gcsupport.rst:258
msgid ""
"The C-API provides the following interface for querying information about"
" the garbage collector."
msgstr ""

#: ../../c-api/gcsupport.rst:263
msgid ""
"Run supplied *callback* on all live GC-capable objects. *arg* is passed "
"through to all invocations of *callback*."
msgstr ""

#: ../../c-api/gcsupport.rst:267
msgid ""
"If new objects are (de)allocated by the callback it is undefined if they "
"will be visited."
msgstr ""

#: ../../c-api/gcsupport.rst:270
msgid ""
"Garbage collection is disabled during operation. Explicitly running a "
"collection in the callback may lead to undefined behaviour e.g. visiting "
"the same objects multiple times or not at all."
msgstr ""

#: ../../c-api/gcsupport.rst:278
msgid ""
"Type of the visitor function to be passed to "
":c:func:`PyUnstable_GC_VisitObjects`. *arg* is the same as the *arg* "
"passed to ``PyUnstable_GC_VisitObjects``. Return ``1`` to continue "
"iteration, return ``0`` to stop iteration. Other return values are "
"reserved for now so behavior on returning anything else is undefined."
msgstr ""

