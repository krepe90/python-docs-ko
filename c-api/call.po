# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/call.rst:6
msgid "Call Protocol"
msgstr "호출 프로토콜"

#: ../../c-api/call.rst:8
msgid ""
"CPython supports two different calling protocols: *tp_call* and "
"vectorcall."
msgstr "CPython은 두 가지 호출 프로토콜을 지원합니다: *tp_call*\\과 벡터콜(vectorcall)."

#: ../../c-api/call.rst:12
msgid "The *tp_call* Protocol"
msgstr "*tp_call* 프로토콜"

#: ../../c-api/call.rst:14
msgid ""
"Instances of classes that set :c:member:`~PyTypeObject.tp_call` are "
"callable. The signature of the slot is::"
msgstr ""
":c:member:`~PyTypeObject.tp_call`\\을 설정하는 클래스의 인스턴스는 콜러블입니다. 슬롯의 서명은 다음과 "
"같습니다::"

#: ../../c-api/call.rst:17
msgid "PyObject *tp_call(PyObject *callable, PyObject *args, PyObject *kwargs);"
msgstr ""

#: ../../c-api/call.rst:19
msgid ""
"A call is made using a tuple for the positional arguments and a dict for "
"the keyword arguments, similarly to ``callable(*args, **kwargs)`` in "
"Python code. *args* must be non-NULL (use an empty tuple if there are no "
"arguments) but *kwargs* may be *NULL* if there are no keyword arguments."
msgstr ""
"파이썬 코드의 ``callable(*args, **kwargs)`` 와 유사하게, 위치 인자를 위한 튜플과 키워드 인자를 위한 "
"딕셔너리를 사용하여 호출합니다. *args*\\는 NULL이 아니어야 합니다 (인자가 없으면 빈 튜플을 사용하십시오). 하지만 "
"키워드 인자가 없으면 *kwargs*\\는 *NULL*\\일 수 있습니다."

#: ../../c-api/call.rst:25
msgid ""
"This convention is not only used by *tp_call*: "
":c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_init` "
"also pass arguments this way."
msgstr ""
"이 규칙은 *tp_call*\\에서만 사용되는 것이 아닙니다: :c:member:`~PyTypeObject.tp_new`\\와 "
":c:member:`~PyTypeObject.tp_init`\\도 인자를 이런 식으로 전달합니다."

#: ../../c-api/call.rst:29
#, fuzzy
msgid ""
"To call an object, use :c:func:`PyObject_Call` or another :ref:`call API "
"<capi-call>`."
msgstr ""
"객체를 호출하려면, :c:func:`PyObject_Call`\\이나 다른 :ref:`호출 API <capi-call>`\\를 "
"사용하십시오."

#: ../../c-api/call.rst:36
msgid "The Vectorcall Protocol"
msgstr "벡터콜(Vectorcall) 프로토콜"

#: ../../c-api/call.rst:40
msgid ""
"The vectorcall protocol was introduced in :pep:`590` as an additional "
"protocol for making calls more efficient."
msgstr "벡터콜 프로토콜은 :pep:`590`\\에서 호출 효율을 높이기 위한 추가 프로토콜로 도입되었습니다."

#: ../../c-api/call.rst:43
msgid ""
"As rule of thumb, CPython will prefer the vectorcall for internal calls "
"if the callable supports it. However, this is not a hard rule. "
"Additionally, some third-party extensions use *tp_call* directly (rather "
"than using :c:func:`PyObject_Call`). Therefore, a class supporting "
"vectorcall must also implement :c:member:`~PyTypeObject.tp_call`. "
"Moreover, the callable must behave the same regardless of which protocol "
"is used. The recommended way to achieve this is by setting "
":c:member:`~PyTypeObject.tp_call` to :c:func:`PyVectorcall_Call`. This "
"bears repeating:"
msgstr ""
"경험 규칙으로, CPython은 콜러블이 지원하면 내부 호출에 대해 벡터콜을 선호합니다. 그러나 이것은 엄격한 규칙이 아닙니다. "
"또한, 일부 제삼자 확장은 (:c:func:`PyObject_call`\\을 사용하지 않고) *tp_call*\\을 직접 "
"사용합니다. 따라서, 벡터콜을 지원하는 클래스도 :c:member:`~PyTypeObject.tp_call`\\을 구현해야 합니다."
" 또한, 어떤 프로토콜을 사용하는지와 관계없이 콜러블은 동일하게 작동해야 합니다. 이를 위해 권장되는 방법은 "
":c:member:`~PyTypeObject.tp_call`\\을 :c:func:`PyVectorcall_Call`\\로 설정하는 "
"것입니다. 이것이 반복을 처리합니다:"

#: ../../c-api/call.rst:57
msgid ""
"A class supporting vectorcall **must** also implement "
":c:member:`~PyTypeObject.tp_call` with the same semantics."
msgstr ""
"벡터콜을 지원하는 클래스도 같은 의미가 있도록 :c:member:`~PyTypeObject.tp_call`\\을 **반드시** "
"구현해야 합니다."

#: ../../c-api/call.rst:62
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag is now removed from a "
"class when the class's :py:meth:`~object.__call__` method is reassigned. "
"(This internally sets :c:member:`~PyTypeObject.tp_call` only, and thus "
"may make it behave differently than the vectorcall function.) In earlier "
"Python versions, vectorcall should only be used with :c:macro:`immutable "
"<Py_TPFLAGS_IMMUTABLETYPE>` or static types."
msgstr ""

#: ../../c-api/call.rst:69
msgid ""
"A class should not implement vectorcall if that would be slower than "
"*tp_call*. For example, if the callee needs to convert the arguments to "
"an args tuple and kwargs dict anyway, then there is no point in "
"implementing vectorcall."
msgstr ""
"*tp_call*\\보다 느려진다면 클래스는 벡터콜을 구현해서는 안 됩니다. 예를 들어, 피호출자가 어차피 인자를 인자 튜플과 "
"kwargs 딕셔너리로 변환해야 하면, 벡터콜을 구현할 이유가 없습니다."

#: ../../c-api/call.rst:74
#, fuzzy
msgid ""
"Classes can implement the vectorcall protocol by enabling the "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag and setting "
":c:member:`~PyTypeObject.tp_vectorcall_offset` to the offset inside the "
"object structure where a *vectorcallfunc* appears. This is a pointer to a"
" function with the following signature:"
msgstr ""
"클래스는 :const:`Py_TPFLAGS_HAVE_VECTORCALL` 플래그를 활성화하고 "
":c:member:`~PyTypeObject.tp_vectorcall_offset`\\을 *vectorcallfunc* 가 등장하는"
" 객체 구조체 내부의 오프셋으로 설정하여 벡터콜 프로토콜을 구현할 수 있습니다. 이것은 다음과 같은 서명을 갖는 함수를 가리키는 "
"포인터입니다:"

#: ../../c-api/call.rst:82
msgid "*callable* is the object being called."
msgstr "*callable*\\은 호출되는 객체입니다."

#: ../../c-api/call.rst:83
msgid "*args* is a C array consisting of the positional arguments followed by the"
msgstr "*args*\\는 위치 인자와 그 뒤를 따르는 키워드 인자의 값으로 구성된 C 배열입니다."

#: ../../c-api/call.rst:84
msgid ""
"values of the keyword arguments. This can be *NULL* if there are no "
"arguments."
msgstr "인자가 없으면 *NULL*\\일 수 있습니다."

#: ../../c-api/call.rst:86
msgid "*nargsf* is the number of positional arguments plus possibly the"
msgstr "*nargsf*\\는 위치 인자의 수에"

#: ../../c-api/call.rst:87
#, fuzzy
msgid ""
":c:macro:`PY_VECTORCALL_ARGUMENTS_OFFSET` flag. To get the actual number "
"of positional arguments from *nargsf*, use :c:func:`PyVectorcall_NARGS`."
msgstr ""
":const:`PY_VECTORCALL_ARGUMENTS_OFFSET` 플래그를 더한 것입니다. *nargsf*\\에서 실제 위치 "
"인자 수를 얻으려면, :c:func:`PyVectorcall_NARGS`\\를 사용하십시오."

#: ../../c-api/call.rst:90
msgid "*kwnames* is a tuple containing the names of the keyword arguments;"
msgstr "*kwnames*\\는 키워드 인자의 이름을 포함하는 튜플입니다;"

#: ../../c-api/call.rst:91
msgid ""
"in other words, the keys of the kwargs dict. These names must be strings "
"(instances of ``str`` or a subclass) and they must be unique. If there "
"are no keyword arguments, then *kwnames* can instead be *NULL*."
msgstr ""
"다시 말해, kwargs 딕셔너리의 키. 이 이름들은 문자열(``str``\\이나 서브 클래스의 인스턴스)이어야하며 고유해야 "
"합니다. 키워드 인자가 없으면, *kwnames*\\는 대신 *NULL*\\일 수 있습니다."

#: ../../c-api/call.rst:98
msgid ""
"If this flag is set in a vectorcall *nargsf* argument, the callee is "
"allowed to temporarily change ``args[-1]``. In other words, *args* points"
" to argument 1 (not 0) in the allocated vector. The callee must restore "
"the value of ``args[-1]`` before returning."
msgstr ""
"이 플래그가 벡터콜 *nargsf* 인자에 설정되면, 피호출자는 일시적으로 ``args[-1]``\\을 변경할 수 있습니다. 즉, "
"*args*\\는 할당된 벡터에서 인자 1(0이 아닙니다)을 가리킵니다. 피호출자는 반환하기 전에 ``args[-1]`` 값을 "
"복원해야 합니다."

#: ../../c-api/call.rst:103
msgid ""
"For :c:func:`PyObject_VectorcallMethod`, this flag means instead that "
"``args[0]`` may be changed."
msgstr ""
":c:func:`PyObject_VectorcallMethod` 의 경우, 이 플래그는 대신 ``args[0]``\\이 변경될 수 "
"있음을 의미합니다."

#: ../../c-api/call.rst:106
#, fuzzy
msgid ""
"Whenever they can do so cheaply (without additional allocation), callers "
"are encouraged to use :c:macro:`PY_VECTORCALL_ARGUMENTS_OFFSET`. Doing so"
" will allow callables such as bound methods to make their onward calls "
"(which include a prepended *self* argument) very efficiently."
msgstr ""
"(추가 할당 없이) 저렴하게 할 수 있을 때마다, 호출자는 "
":const:`PY_VECTORCALL_ARGUMENTS_OFFSET`\\을 사용하는 것이 좋습니다. 이렇게 하면 연결된 메서드와 "
"같은 콜러블이 후속 호출(앞에 *self* 인자를 포함하는)을 매우 효율적으로 만들 수 있습니다."

#: ../../c-api/call.rst:113
msgid ""
"To call an object that implements vectorcall, use a :ref:`call API <capi-"
"call>` function as with any other callable. :c:func:`PyObject_Vectorcall`"
" will usually be most efficient."
msgstr ""
"벡터콜을 구현하는 객체를 호출하려면, 다른 콜러블과 마찬가지로 :ref:`호출 API <capi-call>` 함수를 사용하십시오. "
":c:func:`PyObject_Vectorcall`\\은 일반적으로 가장 효율적입니다."

#: ../../c-api/call.rst:119
msgid "Recursion Control"
msgstr "재귀 제어"

#: ../../c-api/call.rst:121
msgid ""
"When using *tp_call*, callees do not need to worry about :ref:`recursion "
"<recursion>`: CPython uses :c:func:`Py_EnterRecursiveCall` and "
":c:func:`Py_LeaveRecursiveCall` for calls made using *tp_call*."
msgstr ""
"*tp_call*\\을 사용할 때, 피호출자는 :ref:`재귀 <recursion>`\\에 대해 걱정할 필요가 없습니다: "
"CPython은 *tp_call*\\을 사용하여 호출한 경우 :c:func:`Py_EnterRecursiveCall` 과 "
":c:func:`Py_LeaveRecursiveCall` 을 사용합니다."

#: ../../c-api/call.rst:126
msgid ""
"For efficiency, this is not the case for calls done using vectorcall: the"
" callee should use *Py_EnterRecursiveCall* and *Py_LeaveRecursiveCall* if"
" needed."
msgstr ""
"효율성을 위해, 벡터콜을 사용하여 호출한 경우에는 그렇지 않습니다: 피호출자는 필요하면 *Py_EnterRecursiveCall* "
"과 *Py_LeaveRecursiveCall* 을 사용해야 합니다."

#: ../../c-api/call.rst:132
msgid "Vectorcall Support API"
msgstr "벡터콜 지원 API"

#: ../../c-api/call.rst:136
msgid ""
"Given a vectorcall *nargsf* argument, return the actual number of "
"arguments. Currently equivalent to::"
msgstr "벡터콜 *nargsf* 인자가 주어지면, 실제 인자 수를 반환합니다. 현재 다음과 동등합니다::"

#: ../../c-api/call.rst:140
msgid "(Py_ssize_t)(nargsf & ~PY_VECTORCALL_ARGUMENTS_OFFSET)"
msgstr ""

#: ../../c-api/call.rst:142
msgid ""
"However, the function ``PyVectorcall_NARGS`` should be used to allow for "
"future extensions."
msgstr "그러나, 향후 확장을 위해 ``PyVectorcall_NARGS`` 함수를 사용해야 합니다."

#: ../../c-api/call.rst:149
msgid ""
"If *op* does not support the vectorcall protocol (either because the type"
" does not or because the specific instance does not), return *NULL*. "
"Otherwise, return the vectorcall function pointer stored in *op*. This "
"function never raises an exception."
msgstr ""
"*op*\\가 벡터콜 프로토콜을 지원하지 않으면 (형이 지원하지 않거나 인스턴스가 지원하지 않기 때문에), *NULL*\\을 "
"반환합니다. 그렇지 않으면, *op*\\에 저장된 벡터콜 함수 포인터를 반환합니다. 이 함수는 예외를 발생시키지 않습니다."

#: ../../c-api/call.rst:154
msgid ""
"This is mostly useful to check whether or not *op* supports vectorcall, "
"which can be done by checking ``PyVectorcall_Function(op) != NULL``."
msgstr ""
"이것은 *op*\\가 벡터콜을 지원하는지를 확인하는 데 주로 유용하며, ``PyVectorcall_Function(op) != "
"NULL``\\을 확인하여 수행 할 수 있습니다."

#: ../../c-api/call.rst:161
msgid ""
"Call *callable*'s :c:type:`vectorcallfunc` with positional and keyword "
"arguments given in a tuple and dict, respectively."
msgstr ""
"튜플과 딕셔너리에 각각 주어진 위치와 키워드 인자로 *callable*\\의 :c:type:`vectorcallfunc` 를 "
"호출합니다."

#: ../../c-api/call.rst:164
#, fuzzy
msgid ""
"This is a specialized function, intended to be put in the "
":c:member:`~PyTypeObject.tp_call` slot or be used in an implementation of"
" ``tp_call``. It does not check the :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`"
" flag and it does not fall back to ``tp_call``."
msgstr ""
"이것은 :c:member:`~PyTypeObject.tp_call` 슬롯에 넣거나 ``tp_call`` 구현에 사용하기 위한 특수 "
"함수입니다. :const:`Py_TPFLAGS_HAVE_VECTORCALL` 플래그를 확인하지 않고 ``tp_call``\\로 폴 "
"백하지 않습니다."

#: ../../c-api/call.rst:175
msgid "Object Calling API"
msgstr "객체 호출 API"

#: ../../c-api/call.rst:177
#, fuzzy
msgid ""
"Various functions are available for calling a Python object. Each "
"converts its arguments to a convention supported by the called object – "
"either *tp_call* or vectorcall. In order to do as little conversion as "
"possible, pick one that best fits the format of data you have available."
msgstr ""
"파이썬 객체를 호출하기 위해 다양한 함수를 사용할 수 있습니다. 각각은 인자를 호출된 객체가 지원하는 규칙으로 변환합니다 - "
"*tp_call* 또는 벡터콜. 가능한 한 적은 변환을 수행하려면, 사용 가능한 데이터 형식에 가장 적합한 것을 선택하십시오."

#: ../../c-api/call.rst:183
msgid ""
"The following table summarizes the available functions; please see "
"individual documentation for details."
msgstr "다음 표는 사용 가능한 함수를 요약한 것입니다; 자세한 내용은 개별 설명서를 참조하십시오."

#: ../../c-api/call.rst:187
msgid "Function"
msgstr "함수"

#: ../../c-api/call.rst:187
msgid "callable"
msgstr "콜러블"

#: ../../c-api/call.rst:187
msgid "args"
msgstr "args"

#: ../../c-api/call.rst:187
msgid "kwargs"
msgstr "kwargs"

#: ../../c-api/call.rst:189
msgid ":c:func:`PyObject_Call`"
msgstr ":c:func:`PyObject_Call`"

#: ../../c-api/call.rst:189 ../../c-api/call.rst:191 ../../c-api/call.rst:193
#: ../../c-api/call.rst:195 ../../c-api/call.rst:197 ../../c-api/call.rst:201
#: ../../c-api/call.rst:209 ../../c-api/call.rst:211
msgid "``PyObject *``"
msgstr "``PyObject *``"

#: ../../c-api/call.rst:189
msgid "tuple"
msgstr "튜플"

#: ../../c-api/call.rst:189 ../../c-api/call.rst:211
msgid "dict/``NULL``"
msgstr "딕셔너리/``NULL``"

#: ../../c-api/call.rst:191
msgid ":c:func:`PyObject_CallNoArgs`"
msgstr ":c:func:`PyObject_CallNoArgs`"

#: ../../c-api/call.rst:191 ../../c-api/call.rst:193 ../../c-api/call.rst:195
#: ../../c-api/call.rst:197 ../../c-api/call.rst:199 ../../c-api/call.rst:201
#: ../../c-api/call.rst:203 ../../c-api/call.rst:205 ../../c-api/call.rst:207
msgid "---"
msgstr "---"

#: ../../c-api/call.rst:193
msgid ":c:func:`PyObject_CallOneArg`"
msgstr ":c:func:`PyObject_CallOneArg`"

#: ../../c-api/call.rst:193 ../../c-api/call.rst:207
msgid "1 object"
msgstr "1 객체"

#: ../../c-api/call.rst:195
msgid ":c:func:`PyObject_CallObject`"
msgstr ":c:func:`PyObject_CallObject`"

#: ../../c-api/call.rst:195
msgid "tuple/``NULL``"
msgstr "튜플/``NULL``"

#: ../../c-api/call.rst:197
msgid ":c:func:`PyObject_CallFunction`"
msgstr ":c:func:`PyObject_CallFunction`"

#: ../../c-api/call.rst:197 ../../c-api/call.rst:199
msgid "format"
msgstr "포맷(format)"

#: ../../c-api/call.rst:199
msgid ":c:func:`PyObject_CallMethod`"
msgstr ":c:func:`PyObject_CallMethod`"

#: ../../c-api/call.rst:199
msgid "obj + ``char*``"
msgstr "obj + ``char*``"

#: ../../c-api/call.rst:201
msgid ":c:func:`PyObject_CallFunctionObjArgs`"
msgstr ":c:func:`PyObject_CallFunctionObjArgs`"

#: ../../c-api/call.rst:201 ../../c-api/call.rst:203
msgid "variadic"
msgstr "가변(variadic)"

#: ../../c-api/call.rst:203
msgid ":c:func:`PyObject_CallMethodObjArgs`"
msgstr ":c:func:`PyObject_CallMethodObjArgs`"

#: ../../c-api/call.rst:203 ../../c-api/call.rst:205 ../../c-api/call.rst:207
msgid "obj + name"
msgstr "obj + name"

#: ../../c-api/call.rst:205
msgid ":c:func:`PyObject_CallMethodNoArgs`"
msgstr ":c:func:`PyObject_CallMethodNoArgs`"

#: ../../c-api/call.rst:207
msgid ":c:func:`PyObject_CallMethodOneArg`"
msgstr ":c:func:`PyObject_CallMethodOneArg`"

#: ../../c-api/call.rst:209
msgid ":c:func:`PyObject_Vectorcall`"
msgstr ":c:func:`PyObject_Vectorcall`"

#: ../../c-api/call.rst:209 ../../c-api/call.rst:211 ../../c-api/call.rst:213
msgid "vectorcall"
msgstr "벡터콜"

#: ../../c-api/call.rst:211
msgid ":c:func:`PyObject_VectorcallDict`"
msgstr ":c:func:`PyObject_VectorcallDict`"

#: ../../c-api/call.rst:213
msgid ":c:func:`PyObject_VectorcallMethod`"
msgstr ":c:func:`PyObject_VectorcallMethod`"

#: ../../c-api/call.rst:213
msgid "arg + name"
msgstr "arg + name"

#: ../../c-api/call.rst:219
msgid ""
"Call a callable Python object *callable*, with arguments given by the "
"tuple *args*, and named arguments given by the dictionary *kwargs*."
msgstr ""
"튜플 *args*\\로 주어진 인자와 딕셔너리 *kwargs*\\로 주어진 이름있는 인자로 콜러블 파이썬 객체 "
"*callable*\\을 호출합니다."

#: ../../c-api/call.rst:222
msgid ""
"*args* must not be *NULL*; use an empty tuple if no arguments are needed."
" If no named arguments are needed, *kwargs* can be *NULL*."
msgstr ""
"*args*\\는 *NULL*\\이 아니어야 합니다ㅣ 인자가 필요 없으면 빈 튜플을 사용하십시오. 이름있는 인자가 필요하지 않으면,"
" *kwargs*\\는 *NULL*\\일 수 있습니다."

#: ../../c-api/call.rst:225 ../../c-api/call.rst:237 ../../c-api/call.rst:248
#: ../../c-api/call.rst:259 ../../c-api/call.rst:271 ../../c-api/call.rst:291
#: ../../c-api/call.rst:310 ../../c-api/call.rst:324 ../../c-api/call.rst:333
#: ../../c-api/call.rst:345 ../../c-api/call.rst:358 ../../c-api/call.rst:392
msgid ""
"Return the result of the call on success, or raise an exception and "
"return *NULL* on failure."
msgstr "성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 *NULL*\\을 반환합니다."

#: ../../c-api/call.rst:228
msgid ""
"This is the equivalent of the Python expression: ``callable(*args, "
"**kwargs)``."
msgstr "이것은 다음 파이썬 표현식과 동등합니다: ``callable(*args, **kwargs)``."

#: ../../c-api/call.rst:234
msgid ""
"Call a callable Python object *callable* without any arguments. It is the"
" most efficient way to call a callable Python object without any "
"argument."
msgstr ""
"인자 없이 콜러블 파이썬 객체 *callable*\\을 호출합니다. 인자 없이 콜러블 파이썬 객체를 호출하는 가장 효율적인 "
"방법입니다."

#: ../../c-api/call.rst:245
msgid ""
"Call a callable Python object *callable* with exactly 1 positional "
"argument *arg* and no keyword arguments."
msgstr "정확히 1개의 위치 인자 *arg*\\로 키워드 인자 없이 콜러블 파이썬 객체 *callable*\\을 호출합니다."

#: ../../c-api/call.rst:256
msgid ""
"Call a callable Python object *callable*, with arguments given by the "
"tuple *args*.  If no arguments are needed, then *args* can be *NULL*."
msgstr ""
"튜플 *args*\\에 의해 주어진 인자로 콜러블 파이썬 객체 *callable*\\을 호출합니다. 인자가 필요하지 않으면 "
"*args*\\는 *NULL*\\일 수 있습니다."

#: ../../c-api/call.rst:262 ../../c-api/call.rst:274
msgid "This is the equivalent of the Python expression: ``callable(*args)``."
msgstr "이것은 다음 파이썬 표현식과 동등합니다: ``callable(*args)``."

#: ../../c-api/call.rst:267
msgid ""
"Call a callable Python object *callable*, with a variable number of C "
"arguments. The C arguments are described using a :c:func:`Py_BuildValue` "
"style format string.  The format can be *NULL*, indicating that no "
"arguments are provided."
msgstr ""
"가변 개수의 C 인자로 콜러블 파이썬 객체 *callable*\\을 호출합니다. C 인자는 "
":c:func:`Py_BuildValue` 스타일 포맷 문자열을 사용하여 기술됩니다. format은 *NULL*\\일 수 있으며, "
"인자가 제공되지 않음을 나타냅니다."

#: ../../c-api/call.rst:276
#, fuzzy
msgid ""
"Note that if you only pass :c:expr:`PyObject *` args, "
":c:func:`PyObject_CallFunctionObjArgs` is a faster alternative."
msgstr ""
":c:type:`PyObject *` 인자만 전달한다면 :c:func:`PyObject_CallFunctionObjArgs` 가 더"
" 빠른 대안임에 유의하십시오."

#: ../../c-api/call.rst:279
msgid "The type of *format* was changed from ``char *``."
msgstr "*format*\\의 형이 ``char *``\\에서 변경되었습니다."

#: ../../c-api/call.rst:285
msgid ""
"Call the method named *name* of object *obj* with a variable number of C "
"arguments.  The C arguments are described by a :c:func:`Py_BuildValue` "
"format string that should produce a tuple."
msgstr ""
"가변 개수의 C 인자를 사용하여 객체 *obj*\\의 *name*\\이라는 이름의 메서드를 호출합니다. C 인자는 튜플을 생성해야 "
"하는 :c:func:`Py_BuildValue` 포맷 문자열로 기술됩니다."

#: ../../c-api/call.rst:289
msgid "The format can be *NULL*, indicating that no arguments are provided."
msgstr "format은 *NULL*\\일 수 있으며, 인자가 제공되지 않음을 나타냅니다."

#: ../../c-api/call.rst:294
msgid ""
"This is the equivalent of the Python expression: ``obj.name(arg1, arg2, "
"...)``."
msgstr "이것은 다음 파이썬 표현식과 동등합니다: ``obj.name(arg1, arg2, ...)``."

#: ../../c-api/call.rst:297
#, fuzzy
msgid ""
"Note that if you only pass :c:expr:`PyObject *` args, "
":c:func:`PyObject_CallMethodObjArgs` is a faster alternative."
msgstr ""
":c:type:`PyObject *` 인자만 전달한다면 :c:func:`PyObject_CallMethodObjArgs` 가 더 "
"빠른 대안임에 유의하십시오."

#: ../../c-api/call.rst:300
msgid "The types of *name* and *format* were changed from ``char *``."
msgstr "*name*\\과 *format*\\의 형이 ``char *``\\에서 변경되었습니다."

#: ../../c-api/call.rst:306
#, fuzzy
msgid ""
"Call a callable Python object *callable*, with a variable number of "
":c:expr:`PyObject *` arguments.  The arguments are provided as a variable"
" number of parameters followed by *NULL*."
msgstr ""
"가변 개수의 :c:type:`PyObject *` 인자로 콜러블 파이썬 객체 *callable*\\을 호출합니다. 인자는 "
"*NULL*\\로 끝나는 가변 개수의 매개 변수로 제공됩니다."

#: ../../c-api/call.rst:313
msgid ""
"This is the equivalent of the Python expression: ``callable(arg1, arg2, "
"...)``."
msgstr "이것은 다음 파이썬 표현식과 동등합니다: ``callable(arg1, arg2, ...)``."

#: ../../c-api/call.rst:319
#, fuzzy
msgid ""
"Call a method of the Python object *obj*, where the name of the method is"
" given as a Python string object in *name*.  It is called with a variable"
" number of :c:expr:`PyObject *` arguments.  The arguments are provided as"
" a variable number of parameters followed by *NULL*."
msgstr ""
"파이썬 객체 *obj*\\의 메서드를 호출합니다. 여기서 메서드 이름은 *name*\\에서 파이썬 문자열 객체로 제공됩니다. 가변 "
"개수의 :c:type:`PyObject *` 인자로 호출됩니다. 인자는 *NULL*\\로 끝나는 가변 개수의 매개 변수로 "
"제공됩니다."

#: ../../c-api/call.rst:330
msgid ""
"Call a method of the Python object *obj* without arguments, where the "
"name of the method is given as a Python string object in *name*."
msgstr ""
"인자 없이 파이썬 객체 *obj*\\의 메서드를 호출합니다. 여기서 메서드 이름은 *name*\\에서 파이썬 문자열 객체로 "
"제공됩니다."

#: ../../c-api/call.rst:341
msgid ""
"Call a method of the Python object *obj* with a single positional "
"argument *arg*, where the name of the method is given as a Python string "
"object in *name*."
msgstr ""
"단일 위치 인자 *arg*\\로 파이썬 객체 *obj*\\의 메서드를 호출합니다. 여기서 메서드 이름은 *name*\\에서 파이썬 "
"문자열 객체로 제공됩니다."

#: ../../c-api/call.rst:353
msgid ""
"Call a callable Python object *callable*. The arguments are the same as "
"for :c:type:`vectorcallfunc`. If *callable* supports vectorcall_, this "
"directly calls the vectorcall function stored in *callable*."
msgstr ""
"콜러블 파이썬 객체 *callable*\\을 호출합니다. 인자는 :c:type:`vectorcallfunc` 와 같습니다. "
"*callable*\\이 `벡터콜 <vectorcall_>`_\\을 지원하면, *callable*\\에 저장된 벡터콜 함수를 직접 "
"호출합니다."

#: ../../c-api/call.rst:365
msgid ""
"Call *callable* with positional arguments passed exactly as in the "
"vectorcall_ protocol, but with keyword arguments passed as a dictionary "
"*kwdict*. The *args* array contains only the positional arguments."
msgstr ""
"위치 인자가 `벡터콜 <vectorcall_>`_ 프로토콜과 정확히 일치하지만 딕셔너리 *kwdict*\\로 전달된 키워드 인자로 "
"*callable*\\을 호출합니다. *args* 배열은 위치 인자만 포함합니다."

#: ../../c-api/call.rst:369
msgid ""
"Regardless of which protocol is used internally, a conversion of "
"arguments needs to be done. Therefore, this function should only be used "
"if the caller already has a dictionary ready to use for the keyword "
"arguments, but not a tuple for the positional arguments."
msgstr ""
"내부적으로 사용되는 프로토콜과 관계없이, 인자를 변환해야 합니다. 따라서, 이 함수는 호출자에게 이미 키워드 인자로 사용할 준비가 "
"된 딕셔너리가 있지만, 위치 인자에 대한 튜플이 없을 때만 사용해야 합니다."

#: ../../c-api/call.rst:379
#, fuzzy
msgid ""
"Call a method using the vectorcall calling convention. The name of the "
"method is given as a Python string *name*. The object whose method is "
"called is *args[0]*, and the *args* array starting at *args[1]* "
"represents the arguments of the call. There must be at least one "
"positional argument. *nargsf* is the number of positional arguments "
"including *args[0]*, plus :c:macro:`PY_VECTORCALL_ARGUMENTS_OFFSET` if "
"the value of ``args[0]`` may temporarily be changed. Keyword arguments "
"can be passed just like in :c:func:`PyObject_Vectorcall`."
msgstr ""
"벡터콜 호출 규칙을 사용하여 메서드를 호출합니다. 메서드 이름은 파이썬 문자열 *name*\\으로 제공됩니다. 메서드가 호출되는 "
"객체는 *args[0]*\\이며, *args[1]*\\에서 시작하는 *args* 배열은 호출의 인자를 나타냅니다. 하나 이상의 위치"
" 인자가 있어야 합니다. *nargsf*\\는 *args[0]*\\을 포함한 위치 인자의 수이며, ``args[0]`` 값이 "
"일시적으로 변경될 수 있으면 :const:`PY_VECTORCALL_ARGUMENTS_OFFSET`\\이 더해집니다. 키워드 인자는"
" :c:func:`PyObject_Vectorcall`\\에서처럼 전달될 수 있습니다."

#: ../../c-api/call.rst:388
#, fuzzy
msgid ""
"If the object has the :c:macro:`Py_TPFLAGS_METHOD_DESCRIPTOR` feature, "
"this will call the unbound method object with the full *args* vector as "
"arguments."
msgstr ""
"객체에 :const:`Py_TPFLAGS_METHOD_DESCRIPTOR` 기능이 있으면, 전체 *args* 벡터를 인자로 연결되지"
" 않은 메서드 객체를 호출합니다."

#: ../../c-api/call.rst:399
msgid "Call Support API"
msgstr "호출 지원 API"

#: ../../c-api/call.rst:403
msgid ""
"Determine if the object *o* is callable.  Return ``1`` if the object is "
"callable and ``0`` otherwise.  This function always succeeds."
msgstr ""
"객체 *o*\\가 콜러블 인지 판별합니다. 객체가 콜러블 이면 ``1``\\을, 그렇지 않으면 ``0``\\을 반환합니다. 이 "
"함수는 항상 성공합니다."

#~ msgid ""
#~ "In CPython 3.8, the vectorcall API "
#~ "and related functions were available "
#~ "provisionally under names with a leading"
#~ " underscore: ``_PyObject_Vectorcall``, "
#~ "``_Py_TPFLAGS_HAVE_VECTORCALL``, ``_PyObject_VectorcallMethod``,"
#~ " ``_PyVectorcall_Function``, ``_PyObject_CallOneArg``, "
#~ "``_PyObject_CallMethodNoArgs``, ``_PyObject_CallMethodOneArg``."
#~ " Additionally, ``PyObject_VectorcallDict`` was "
#~ "available as ``_PyObject_FastCallDict``. The "
#~ "old names are still defined as "
#~ "aliases of the new, non-underscored "
#~ "names."
#~ msgstr ""
#~ "CPython 3.8에서 벡터콜 API와 관련 함수는 앞에"
#~ " 밑줄이 붙은 이름으로 잠정적으로 사용할 수 있었습니다:"
#~ " ``_PyObject_Vectorcall``, ``_Py_TPFLAGS_HAVE_VECTORCALL``,"
#~ " ``_PyObject_VectorcallMethod``, ``_PyVectorcall_Function``,"
#~ " ``_PyObject_CallOneArg``, ``_PyObject_CallMethodNoArgs``,"
#~ " ``_PyObject_CallMethodOneArg``. 또한, "
#~ "``PyObject_VectorcallDict``\\는 ``_PyObject_FastCallDict``\\로 "
#~ "제공되었습니다. 이전 이름은 여전히 밑줄이 없는 새로운 "
#~ "이름의 별칭으로 정의됩니다."

#~ msgid "This function is not part of the :ref:`limited API <stable>`."
#~ msgstr "이 함수는 :ref:`제한된 API <stable>`\\의 일부가 아닙니다."

