# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/object.rst:6
msgid "Object Protocol"
msgstr "객체 프로토콜"

#: ../../c-api/object.rst:11
msgid "Get a :term:`strong reference` to a constant."
msgstr ""

#: ../../c-api/object.rst:13
msgid "Set an exception and return ``NULL`` if *constant_id* is invalid."
msgstr ""

#: ../../c-api/object.rst:15
msgid "*constant_id* must be one of these constant identifiers:"
msgstr ""

#: ../../c-api/object.rst:20
msgid "Constant Identifier"
msgstr ""

#: ../../c-api/object.rst:20
msgid "Value"
msgstr ""

#: ../../c-api/object.rst:20
msgid "Returned object"
msgstr ""

#: ../../c-api/object.rst:22 ../../c-api/object.rst:27
msgid "``0``"
msgstr "``0``"

#: ../../c-api/object.rst:22
msgid ":py:data:`None`"
msgstr ":py:data:`None`"

#: ../../c-api/object.rst:23 ../../c-api/object.rst:28
msgid "``1``"
msgstr "``1``"

#: ../../c-api/object.rst:23
msgid ":py:data:`False`"
msgstr ":py:data:`False`"

#: ../../c-api/object.rst:24
msgid "``2``"
msgstr "``2``"

#: ../../c-api/object.rst:24
msgid ":py:data:`True`"
msgstr ":py:data:`True`"

#: ../../c-api/object.rst:25
msgid "``3``"
msgstr "``3``"

#: ../../c-api/object.rst:25
msgid ":py:data:`Ellipsis`"
msgstr ":py:data:`Ellipsis`"

#: ../../c-api/object.rst:26
msgid "``4``"
msgstr "``4``"

#: ../../c-api/object.rst:26
msgid ":py:data:`NotImplemented`"
msgstr ":py:data:`NotImplemented`"

#: ../../c-api/object.rst:27
msgid "``5``"
msgstr "``5``"

#: ../../c-api/object.rst:28
msgid "``6``"
msgstr "``6``"

#: ../../c-api/object.rst:29
msgid "``7``"
msgstr "``7``"

#: ../../c-api/object.rst:29
msgid "``''``"
msgstr "``''``"

#: ../../c-api/object.rst:30
msgid "``8``"
msgstr "``8``"

#: ../../c-api/object.rst:30
msgid "``b''``"
msgstr "``b''``"

#: ../../c-api/object.rst:31
msgid "``9``"
msgstr "``9``"

#: ../../c-api/object.rst:31
msgid "``()``"
msgstr "``()``"

#: ../../c-api/object.rst:34
msgid ""
"Numeric values are only given for projects which cannot use the constant "
"identifiers."
msgstr ""

#: ../../c-api/object.rst:42
msgid "In CPython, all of these constants are :term:`immortal`."
msgstr ""

#: ../../c-api/object.rst:47
msgid ""
"Similar to :c:func:`Py_GetConstant`, but return a :term:`borrowed "
"reference`."
msgstr ""

#: ../../c-api/object.rst:50
msgid ""
"This function is primarily intended for backwards compatibility: using "
":c:func:`Py_GetConstant` is recommended for new code."
msgstr ""

#: ../../c-api/object.rst:53
msgid ""
"The reference is borrowed from the interpreter, and is valid until the "
"interpreter finalization."
msgstr ""

#: ../../c-api/object.rst:61
msgid ""
"The ``NotImplemented`` singleton, used to signal that an operation is not"
" implemented for the given type combination."
msgstr "지정된 형 조합에 대해 연산이 구현되지 않았음을 알리는 데 사용되는 ``NotImplemented`` 싱글톤."

#: ../../c-api/object.rst:67
msgid ""
"Properly handle returning :c:data:`Py_NotImplemented` from within a C "
"function (that is, create a new :term:`strong reference` to "
":const:`NotImplemented` and return it)."
msgstr ""
"C 함수 내에서 :c:data:`Py_NotImplemented` 반환을 올바르게 처리합니다 (즉, "
":const:`NotImplemented`\\에 대한 새로운 :term:`강한 참조 <strong reference>`\\를 만들고"
" 반환합니다)."

#: ../../c-api/object.rst:74
msgid ""
"Flag to be used with multiple functions that print the object (like "
":c:func:`PyObject_Print` and :c:func:`PyFile_WriteObject`). If passed, "
"these function would use the :func:`str` of the object instead of the "
":func:`repr`."
msgstr ""

#: ../../c-api/object.rst:82
msgid ""
"Print an object *o*, on file *fp*.  Returns ``-1`` on error.  The flags "
"argument is used to enable certain printing options.  The only option "
"currently supported is :c:macro:`Py_PRINT_RAW`; if given, the :func:`str`"
" of the object is written instead of the :func:`repr`."
msgstr ""
"파일 *fp*\\에 객체 *o*\\를 인쇄합니다. 에러 시 ``-1``\\을 반환합니다. flags 인자는 특정 인쇄 옵션을 "
"활성화하는 데 사용됩니다. 현재 지원되는 유일한 옵션은 :c:macro:`Py_PRINT_RAW`\\입니다; 주어지면, "
":func:`repr` 대신 객체의 :func:`str`\\이 기록됩니다."

#: ../../c-api/object.rst:90
msgid ""
"Returns ``1`` if *o* has the attribute *attr_name*, and ``0`` otherwise. "
"This is equivalent to the Python expression ``hasattr(o, attr_name)``. On"
" failure, return ``-1``."
msgstr ""
"*o*\\에 *attr_name* 어트리뷰트가 있으면 ``1``\\을, 그렇지 않으면 ``0``\\을 반환합니다. 이것은 파이썬 "
"표현식 ``hasattr(o, attr_name)``\\과 동등합니다. 실패하면, ``-1``\\을 반환합니다."

#: ../../c-api/object.rst:99
msgid ""
"This is the same as :c:func:`PyObject_HasAttrWithError`, but *attr_name* "
"is specified as a :c:expr:`const char*` UTF-8 encoded bytes string, "
"rather than a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:108
msgid ""
"Returns ``1`` if *o* has the attribute *attr_name*, and ``0`` otherwise. "
"This function always succeeds."
msgstr ""
"*o*\\에 *attr_name* 어트리뷰트가 있으면 ``1``\\을, 그렇지 않으면 ``0``\\을 반환합니다. 이 함수는 항상 "
"성공합니다."

#: ../../c-api/object.rst:113
msgid ""
"Exceptions that occur when this calls :meth:`~object.__getattr__` and "
":meth:`~object.__getattribute__` methods aren't propagated, but instead "
"given to :func:`sys.unraisablehook`. For proper error handling, use "
":c:func:`PyObject_HasAttrWithError`, :c:func:`PyObject_GetOptionalAttr` "
"or :c:func:`PyObject_GetAttr` instead."
msgstr ""

#: ../../c-api/object.rst:122
msgid ""
"This is the same as :c:func:`PyObject_HasAttr`, but *attr_name* is "
"specified as a :c:expr:`const char*` UTF-8 encoded bytes string, rather "
"than a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:128
msgid ""
"Exceptions that occur when this calls :meth:`~object.__getattr__` and "
":meth:`~object.__getattribute__` methods or while creating the temporary "
":class:`str` object are silently ignored. For proper error handling, use "
":c:func:`PyObject_HasAttrStringWithError`, "
":c:func:`PyObject_GetOptionalAttrString` or "
":c:func:`PyObject_GetAttrString` instead."
msgstr ""
":meth:`~object.__getattr__`\\과 :meth:`~object.__getattribute__` 메서드를 호출할 "
"때나 임시 :class:`str` 객체를 만드는 중에 발생하는 예외는 조용히 무시됩니다. 적절한 에러 처리를 위해서는, 대신 "
":c:func:`PyObject_HasAttrStringWithError`, "
":c:func:`PyObject_GetOptionalAttrString` 또는 "
":c:func:`PyObject_GetAttrString`\\을 사용하십시오."

#: ../../c-api/object.rst:138
msgid ""
"Retrieve an attribute named *attr_name* from object *o*. Returns the "
"attribute value on success, or ``NULL`` on failure.  This is the "
"equivalent of the Python expression ``o.attr_name``."
msgstr ""
"객체 *o*\\에서 *attr_name*\\이라는 이름의 어트리뷰트를 가져옵니다. 성공하면 어트리뷰트 값을, 실패하면 "
"``NULL``\\을 반환합니다. 이것은 파이썬 표현식 ``o.attr_name``\\과 동등합니다."

#: ../../c-api/object.rst:142
msgid ""
"If the missing attribute should not be treated as a failure, you can use "
":c:func:`PyObject_GetOptionalAttr` instead."
msgstr ""

#: ../../c-api/object.rst:148
msgid ""
"This is the same as :c:func:`PyObject_GetAttr`, but *attr_name* is "
"specified as a :c:expr:`const char*` UTF-8 encoded bytes string, rather "
"than a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:152
msgid ""
"If the missing attribute should not be treated as a failure, you can use "
":c:func:`PyObject_GetOptionalAttrString` instead."
msgstr ""

#: ../../c-api/object.rst:158
msgid ""
"Variant of :c:func:`PyObject_GetAttr` which doesn't raise "
":exc:`AttributeError` if the attribute is not found."
msgstr ""

#: ../../c-api/object.rst:161
msgid ""
"If the attribute is found, return ``1`` and set *\\*result* to a new "
":term:`strong reference` to the attribute. If the attribute is not found,"
" return ``0`` and set *\\*result* to ``NULL``; the :exc:`AttributeError` "
"is silenced. If an error other than :exc:`AttributeError` is raised, "
"return ``-1`` and set *\\*result* to ``NULL``."
msgstr ""

#: ../../c-api/object.rst:173
msgid ""
"This is the same as :c:func:`PyObject_GetOptionalAttr`, but *attr_name* "
"is specified as a :c:expr:`const char*` UTF-8 encoded bytes string, "
"rather than a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:181
msgid ""
"Generic attribute getter function that is meant to be put into a type "
"object's ``tp_getattro`` slot.  It looks for a descriptor in the "
"dictionary of classes in the object's MRO as well as an attribute in the "
"object's :attr:`~object.__dict__` (if present).  As outlined in "
":ref:`descriptors`, data descriptors take preference over instance "
"attributes, while non-data descriptors don't.  Otherwise, an "
":exc:`AttributeError` is raised."
msgstr ""
"형 객체의 ``tp_getattro`` 슬롯에 배치되는 일반 어트리뷰트 게터(getter) 함수. 객체의 (있다면) "
":attr:`~object.__dict__`\\에 있는 어트리뷰트뿐만 아니라 객체의 MRO에 있는 클래스의 딕셔너리에 있는 "
"디스크립터를 찾습니다. :ref:`descriptors`\\에 요약된 것처럼, 데이터 디스크립터는 인스턴스 어트리뷰트보다 "
"우선하지만, 비 데이터 디스크립터는 그렇지 않습니다. 그렇지 않으면, :exc:`AttributeError`\\가 발생합니다."

#: ../../c-api/object.rst:191
msgid ""
"Set the value of the attribute named *attr_name*, for object *o*, to the "
"value *v*. Raise an exception and return ``-1`` on failure; return ``0`` "
"on success.  This is the equivalent of the Python statement ``o.attr_name"
" = v``."
msgstr ""
"객체 *o*\\에 대해, *attr_name*\\이라는 이름의 어트리뷰트 값을 *v* 값으로 설정합니다. 실패 시 예외를 발생시키고"
" ``-1``\\을 반환합니다. 성공하면 ``0``\\을 반환합니다. 이것은 파이썬 문장 ``o.attr_name = v``\\와 "
"동등합니다."

#: ../../c-api/object.rst:196
msgid ""
"If *v* is ``NULL``, the attribute is deleted. This behaviour is "
"deprecated in favour of using :c:func:`PyObject_DelAttr`, but there are "
"currently no plans to remove it."
msgstr ""
"*v*\\가 ``NULL``\\이면, 어트리뷰트가 삭제됩니다. 이 동작은 폐지되었고 "
":c:func:`PyObject_DelAttr`\\로 대체되었습니다만, 현재 제거할 계획이 없습니다."

#: ../../c-api/object.rst:203
msgid ""
"This is the same as :c:func:`PyObject_SetAttr`, but *attr_name* is "
"specified as a :c:expr:`const char*` UTF-8 encoded bytes string, rather "
"than a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:207
msgid ""
"If *v* is ``NULL``, the attribute is deleted, but this feature is "
"deprecated in favour of using :c:func:`PyObject_DelAttrString`."
msgstr ""
"*v*\\가 ``NULL``\\이면, 어트리뷰트가 삭제되지만, 이 기능은 폐지되었고 "
":c:func:`PyObject_DelAttrString`\\으로 대체되었습니다."

#: ../../c-api/object.rst:210
msgid ""
"The number of different attribute names passed to this function should be"
" kept small, usually by using a statically allocated string as "
"*attr_name*. For attribute names that aren't known at compile time, "
"prefer calling :c:func:`PyUnicode_FromString` and "
":c:func:`PyObject_SetAttr` directly. For more details, see "
":c:func:`PyUnicode_InternFromString`, which may be used internally to "
"create a key object."
msgstr ""

#: ../../c-api/object.rst:220
msgid ""
"Generic attribute setter and deleter function that is meant to be put "
"into a type object's :c:member:`~PyTypeObject.tp_setattro` slot.  It "
"looks for a data descriptor in the dictionary of classes in the object's "
"MRO, and if found it takes preference over setting or deleting the "
"attribute in the instance dictionary. Otherwise, the attribute is set or "
"deleted in the object's :attr:`~object.__dict__` (if present). On "
"success, ``0`` is returned, otherwise an :exc:`AttributeError` is raised "
"and ``-1`` is returned."
msgstr ""
"형 객체의 :c:member:`~PyTypeObject.tp_setattro` 슬롯에 배치되는 일반 어트리뷰트 세터(setter)와"
" 딜리터(deleter) 함수. 객체의 MRO에 있는 클래스의 딕셔너리에서 데이터 디스크립터를 찾고, 발견되면 인스턴스 딕셔너리에 "
"있는 어트리뷰트를 설정하거나 삭제하는 것보다 우선합니다. 그렇지 않으면, 객체의 (있다면) "
":attr:`~object.__dict__`\\에서 어트리뷰트가 설정되거나 삭제됩니다. 성공하면 ``0``\\이 반환되고, 그렇지 "
"않으면 :exc:`AttributeError`\\가 발생하고 ``-1``\\이 반환됩니다."

#: ../../c-api/object.rst:232
msgid ""
"Delete attribute named *attr_name*, for object *o*. Returns ``-1`` on "
"failure. This is the equivalent of the Python statement ``del "
"o.attr_name``."
msgstr ""
"객체 *o*\\에 대해, *attr_name*\\이라는 이름의 어트리뷰트를 삭제합니다. 실패 시 ``-1``\\을 반환합니다. "
"이것은 파이썬 문장 ``del o.attr_name``\\과 동등합니다."

#: ../../c-api/object.rst:238
msgid ""
"This is the same as :c:func:`PyObject_DelAttr`, but *attr_name* is "
"specified as a :c:expr:`const char*` UTF-8 encoded bytes string, rather "
"than a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:242
msgid ""
"The number of different attribute names passed to this function should be"
" kept small, usually by using a statically allocated string as "
"*attr_name*. For attribute names that aren't known at compile time, "
"prefer calling :c:func:`PyUnicode_FromString` and "
":c:func:`PyObject_DelAttr` directly. For more details, see "
":c:func:`PyUnicode_InternFromString`, which may be used internally to "
"create a key object for lookup."
msgstr ""

#: ../../c-api/object.rst:253
msgid ""
"A generic implementation for the getter of a ``__dict__`` descriptor. It "
"creates the dictionary if necessary."
msgstr "``__dict__`` 디스크립터의 게터(getter)를 위한 일반적인 구현. 필요하면 딕셔너리를 만듭니다."

#: ../../c-api/object.rst:256
msgid ""
"This function may also be called to get the :py:attr:`~object.__dict__` "
"of the object *o*. Pass ``NULL`` for *context* when calling it. Since "
"this function may need to allocate memory for the dictionary, it may be "
"more efficient to call :c:func:`PyObject_GetAttr` when accessing an "
"attribute on the object."
msgstr ""

#: ../../c-api/object.rst:262
msgid "On failure, returns ``NULL`` with an exception set."
msgstr ""

#: ../../c-api/object.rst:269
msgid ""
"A generic implementation for the setter of a ``__dict__`` descriptor. "
"This implementation does not allow the dictionary to be deleted."
msgstr "``__dict__`` 디스크립터의 세터(setter)를 위한 일반적인 구현. 이 구현은 딕셔너리 삭제를 허락하지 않습니다."

#: ../../c-api/object.rst:277
msgid ""
"Return a pointer to :py:attr:`~object.__dict__` of the object *obj*. If "
"there is no ``__dict__``, return ``NULL`` without setting an exception."
msgstr ""

#: ../../c-api/object.rst:280
msgid ""
"This function may need to allocate memory for the dictionary, so it may "
"be more efficient to call :c:func:`PyObject_GetAttr` when accessing an "
"attribute on the object."
msgstr ""

#: ../../c-api/object.rst:287
msgid ""
"Compare the values of *o1* and *o2* using the operation specified by "
"*opid*, which must be one of :c:macro:`Py_LT`, :c:macro:`Py_LE`, "
":c:macro:`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_GT`, or "
":c:macro:`Py_GE`, corresponding to ``<``, ``<=``, ``==``, ``!=``, ``>``, "
"or ``>=`` respectively. This is the equivalent of the Python expression "
"``o1 op o2``, where ``op`` is the operator corresponding to *opid*. "
"Returns the value of the comparison on success, or ``NULL`` on failure."
msgstr ""
"*opid*\\에 의해 지정된 연산을 사용하여 *o1*\\과 *o2*\\의 값을 비교합니다. *opid*\\는 "
":c:macro:`Py_LT`, :c:macro:`Py_LE`, :c:macro:`Py_EQ`, :c:macro:`Py_NE`, "
":c:macro:`Py_GT` 또는 :c:macro:`Py_GE` 중 하나여야 하고 각각 ``<``, ``<=``, ``==``, "
"``!=``, ``>`` 또는 ``>=``\\에 해당합니다. 이는 파이썬 표현식 ``o1 op o2``\\와 동등합니다. 여기서 "
"``op``\\는 *opid*\\에 해당하는 연산자입니다. 성공 시 비교 값을, 실패 시 ``NULL``\\을 반환합니다."

#: ../../c-api/object.rst:297
msgid ""
"Compare the values of *o1* and *o2* using the operation specified by "
"*opid*, like :c:func:`PyObject_RichCompare`, but returns ``-1`` on error,"
" ``0`` if the result is false, ``1`` otherwise."
msgstr ""

#: ../../c-api/object.rst:302
msgid ""
"If *o1* and *o2* are the same object, :c:func:`PyObject_RichCompareBool` "
"will always return ``1`` for :c:macro:`Py_EQ` and ``0`` for "
":c:macro:`Py_NE`."
msgstr ""
"*o1*\\과 *o2*\\가 같은 객체이면, :c:func:`PyObject_RichCompareBool` 은 항상 "
":c:macro:`Py_EQ`\\의 경우는 ``1``\\을, :c:macro:`Py_NE`\\의 경우는 ``0``\\을 반환합니다."

#: ../../c-api/object.rst:307
msgid ""
"Format *obj* using *format_spec*. This is equivalent to the Python "
"expression ``format(obj, format_spec)``."
msgstr ""

#: ../../c-api/object.rst:310
msgid ""
"*format_spec* may be ``NULL``. In this case the call is equivalent to "
"``format(obj)``. Returns the formatted string on success, ``NULL`` on "
"failure."
msgstr ""

#: ../../c-api/object.rst:318
msgid ""
"Compute a string representation of object *o*.  Returns the string "
"representation on success, ``NULL`` on failure.  This is the equivalent "
"of the Python expression ``repr(o)``.  Called by the :func:`repr` built-"
"in function."
msgstr ""
"객체 *o*\\의 문자열 표현을 계산합니다. 성공하면 문자열 표현을, 실패하면 ``NULL``\\을 반환합니다. 이것은 파이썬 "
"표현식 ``repr(o)``\\와 동등합니다. :func:`repr` 내장 함수에 의해 호출됩니다."

#: ../../c-api/object.rst:322 ../../c-api/object.rst:346
msgid ""
"This function now includes a debug assertion to help ensure that it does "
"not silently discard an active exception."
msgstr "이 함수에는 이제 디버그 어서션이 포함되어 있어 활성 예외를 조용히 버리지 않도록 합니다."

#: ../../c-api/object.rst:330
msgid ""
"As :c:func:`PyObject_Repr`, compute a string representation of object "
"*o*, but escape the non-ASCII characters in the string returned by "
":c:func:`PyObject_Repr` with ``\\x``, ``\\u`` or ``\\U`` escapes.  This "
"generates a string similar to that returned by :c:func:`PyObject_Repr` in"
" Python 2. Called by the :func:`ascii` built-in function."
msgstr ""
":c:func:`PyObject_Repr`\\처럼, 객체 *o*\\의 문자열 표현을 계산하지만, ``\\x``, ``\\u`` 또는"
" ``\\U`` 이스케이프를 사용하여 :c:func:`PyObject_Repr`\\이 반환한 문자열에서 비 ASCII 문자를 "
"이스케이프 합니다. 이것은 파이썬 2에서 :c:func:`PyObject_Repr`\\에 의해 반환된 것과 유사한 문자열을 "
"생성합니다. :func:`ascii` 내장 함수에 의해 호출됩니다."

#: ../../c-api/object.rst:341
msgid ""
"Compute a string representation of object *o*.  Returns the string "
"representation on success, ``NULL`` on failure.  This is the equivalent "
"of the Python expression ``str(o)``.  Called by the :func:`str` built-in "
"function and, therefore, by the :func:`print` function."
msgstr ""
"객체 *o*\\의 문자열 표현을 계산합니다. 성공 시 문자열 표현을, 실패 시 ``NULL``\\을 반환합니다. 이것은 파이썬 "
"표현식 ``str(o)``\\와 동등합니다. :func:`str` 내장 함수에 의해, 따라서 :func:`print` 함수에 "
"의해서도 호출됩니다."

#: ../../c-api/object.rst:355
msgid ""
"Compute a bytes representation of object *o*.  ``NULL`` is returned on "
"failure and a bytes object on success.  This is equivalent to the Python "
"expression ``bytes(o)``, when *o* is not an integer.  Unlike "
"``bytes(o)``, a TypeError is raised when *o* is an integer instead of a "
"zero-initialized bytes object."
msgstr ""
"객체 *o*\\의 바이트열 표현을 계산합니다. 실패하면 ``NULL``\\을, 성공하면 바이트열 객체를 반환됩니다. 이는 "
"*o*\\가 정수가 아닐 때 파이썬 표현식 ``bytes(o)``\\와 동등합니다. ``bytes(o)``\\와 달리, *o*\\가"
" 정수이면 0으로 초기화된 바이트열 객체 대신 TypeError가 발생합니다."

#: ../../c-api/object.rst:364
msgid ""
"Return ``1`` if the class *derived* is identical to or derived from the "
"class *cls*, otherwise return ``0``.  In case of an error, return ``-1``."
msgstr ""
"클래스 *derived*\\가 클래스 *cls*\\와 동일하거나 *cls*\\에서 파생되었으면 ``1``\\을 반환하고, 그렇지 "
"않으면 ``0``\\을 반환합니다. 에러가 발생하면 ``-1``\\을 반환합니다."

#: ../../c-api/object.rst:367 ../../c-api/object.rst:386
msgid ""
"If *cls* is a tuple, the check will be done against every entry in *cls*."
" The result will be ``1`` when at least one of the checks returns ``1``, "
"otherwise it will be ``0``."
msgstr ""
"*cls*\\가 튜플이면, *cls*\\의 모든 항목에 대해 검사가 수행됩니다. 적어도 하나의 검사에서 ``1``\\을 반환하면 "
"결과는 ``1``\\이 되고, 그렇지 않으면 ``0``\\이 됩니다."

#: ../../c-api/object.rst:371
msgid ""
"If *cls* has a :meth:`~type.__subclasscheck__` method, it will be called "
"to determine the subclass status as described in :pep:`3119`.  Otherwise,"
" *derived* is a subclass of *cls* if it is a direct or indirect subclass,"
" i.e. contained in :attr:`cls.__mro__ <type.__mro__>`."
msgstr ""
"*cls*\\에 :meth:`~type.__subclasscheck__` 메서드가 있으면, :pep:`3119`\\에 설명된 대로 "
"서브 클래스 상태를 판별하기 위해 호출됩니다. 그렇지 않으면, *derived*\\가 직접 또는 간접 서브 클래스일 때 "
"*cls*\\의 서브 클래스입니다, 즉 :attr:`cls.__mro__ <type.__mro__>`\\에 포함되어 있습니다."

#: ../../c-api/object.rst:376
msgid ""
"Normally only class objects, i.e. instances of :class:`type` or a derived"
" class, are considered classes.  However, objects can override this by "
"having a :attr:`~type.__bases__` attribute (which must be a tuple of base"
" classes)."
msgstr ""
"일반적으로 클래스 객체(즉 :class:`type`\\이나 파생 클래스의 인스턴스)만 클래스로 간주합니다. 그러나, 객체는 "
":attr:`~type.__bases__` 어트리뷰트(베이스 클래스의 튜플이어야 합니다)를 가짐으로써 이를 재정의할 수 있습니다."

#: ../../c-api/object.rst:383
msgid ""
"Return ``1`` if *inst* is an instance of the class *cls* or a subclass of"
" *cls*, or ``0`` if not.  On error, returns ``-1`` and sets an exception."
msgstr ""
"*inst*\\가 *cls* 클래스나 *cls*\\의 서브 클래스의 인스턴스이면 ``1``\\을 반환하고, 그렇지 않으면 "
"``0``\\을 반환합니다. 에러가 발생하면 ``-1``\\을 반환하고 예외를 설정합니다."

#: ../../c-api/object.rst:390
msgid ""
"If *cls* has a :meth:`~type.__instancecheck__` method, it will be called "
"to determine the subclass status as described in :pep:`3119`.  Otherwise,"
" *inst* is an instance of *cls* if its class is a subclass of *cls*."
msgstr ""
"*cls*\\에 :meth:`~type.__instancecheck__` 메서드가 있으면, :pep:`3119`\\에 설명된 대로 "
"서브 클래스 상태를 판별하기 위해 호출됩니다. 그렇지 않으면, *inst*\\는 해당 클래스가 *cls*\\의 서브 클래스일 때 "
"*cls*\\의 인스턴스입니다."

#: ../../c-api/object.rst:394
msgid ""
"An instance *inst* can override what is considered its class by having a "
":attr:`~object.__class__` attribute."
msgstr ""
"인스턴스 *inst*\\는 :attr:`~object.__class__` 어트리뷰트를 가짐으로써 클래스로 간주하는 것을 재정의할 수"
" 있습니다."

#: ../../c-api/object.rst:397
msgid ""
"An object *cls* can override if it is considered a class, and what its "
"base classes are, by having a :attr:`~type.__bases__` attribute (which "
"must be a tuple of base classes)."
msgstr ""
"객체 *cls*\\는 :attr:`~type.__bases__` 어트리뷰트(베이스 클래스의 튜플이어야 합니다)를 가짐으로써, "
"클래스로 간주하는지와 베이스 클래스가 무엇인지를 재정의할 수 있습니다."

#: ../../c-api/object.rst:406
msgid ""
"Compute and return the hash value of an object *o*.  On failure, return "
"``-1``. This is the equivalent of the Python expression ``hash(o)``."
msgstr ""
"객체 *o*\\의 해시값을 계산하고 반환합니다. 실패하면 ``-1``\\을 반환합니다. 이것은 파이썬 표현식 "
"``hash(o)``\\와 동등합니다."

#: ../../c-api/object.rst:409
msgid ""
"The return type is now Py_hash_t.  This is a signed integer the same size"
" as :c:type:`Py_ssize_t`."
msgstr "반환형은 이제 Py_hash_t입니다. 이것은 :c:type:`Py_ssize_t`\\와 같은 크기의 부호 있는 정수입니다."

#: ../../c-api/object.rst:416
msgid ""
"Set a :exc:`TypeError` indicating that ``type(o)`` is not "
":term:`hashable` and return ``-1``. This function receives special "
"treatment when stored in a ``tp_hash`` slot, allowing a type to "
"explicitly indicate to the interpreter that it is not hashable."
msgstr ""
"``type(o)``\\가 :term:`해시 가능 <hashable>`\\하지 않음을 나타내는 :exc:`TypeError`\\를 "
"설정하고 ``-1``\\을 반환합니다. 이 함수는 ``tp_hash`` 슬롯에 저장될 때 특수한 처방을 받아서, 인터프리터에 형이 "
"해시 가능하지 않음을 명시적으로 알립니다."

#: ../../c-api/object.rst:424
msgid ""
"Returns ``1`` if the object *o* is considered to be true, and ``0`` "
"otherwise. This is equivalent to the Python expression ``not not o``.  On"
" failure, return ``-1``."
msgstr ""
"객체 *o*\\를 참으로 간주하면 ``1``\\을, 그렇지 않으면 ``0``\\을 반환합니다. 이것은 파이썬 표현식 ``not "
"not o``\\와 동등합니다. 실패하면 ``-1``\\을 반환합니다."

#: ../../c-api/object.rst:431
msgid ""
"Returns ``0`` if the object *o* is considered to be true, and ``1`` "
"otherwise. This is equivalent to the Python expression ``not o``.  On "
"failure, return ``-1``."
msgstr ""
"객체 *o*\\를 참으로 간주하면 ``0``\\을, 그렇지 않으면 ``1``\\을 반환합니다. 이것은 파이썬 표현식 ``not "
"o``\\와 동등합니다. 실패하면 ``-1``\\을 반환합니다."

#: ../../c-api/object.rst:440
msgid ""
"When *o* is non-``NULL``, returns a type object corresponding to the "
"object type of object *o*. On failure, raises :exc:`SystemError` and "
"returns ``NULL``.  This is equivalent to the Python expression "
"``type(o)``. This function creates a new :term:`strong reference` to the "
"return value. There's really no reason to use this function instead of "
"the :c:func:`Py_TYPE()` function, which returns a pointer of type "
":c:expr:`PyTypeObject*`, except when a new :term:`strong reference` is "
"needed."
msgstr ""
"*o*\\가 ``NULL``\\이 아니면, 객체 *o*\\의 객체 형에 해당하는 형 객체를 반환합니다. 실패하면 "
":exc:`SystemError`\\를 발생시키고 ``NULL``\\을 반환합니다. 이것은 파이썬 표현식 ``type(o)``\\와"
" 동등합니다. 이 함수는 반환 값에 대한 새로운 :term:`강한 참조 <strong reference>`\\를 만듭니다. 새로운 "
":term:`강한 참조 <strong reference>`\\가 필요할 때를 제외하고, :c:expr:`PyTypeObject*` "
"형의 포인터를 반환하는 :c:func:`Py_TYPE()` 함수 대신 이 함수를 사용할 이유가 없습니다."

#: ../../c-api/object.rst:452
msgid ""
"Return non-zero if the object *o* is of type *type* or a subtype of "
"*type*, and ``0`` otherwise.  Both parameters must be non-``NULL``."
msgstr ""
"객체 *o*\\가 *type* 형이거나 *type*\\의 서브 형이면 0이 아닌 값을 반환하고, 그렇지 않으면 ``0``\\을 "
"반환합니다. 두 매개 변수 모두 ``NULL``\\이 아니어야 합니다."

#: ../../c-api/object.rst:461
msgid ""
"Return the length of object *o*.  If the object *o* provides either the "
"sequence and mapping protocols, the sequence length is returned.  On "
"error, ``-1`` is returned.  This is the equivalent to the Python "
"expression ``len(o)``."
msgstr ""
"객체 *o*\\의 길이를 반환합니다. 객체 *o*\\가 시퀀스와 매핑 프로토콜을 제공하면, 시퀀스 길이가 반환됩니다. 에러가 "
"발생하면 ``-1``\\이 반환됩니다. 이것은 파이썬 표현식 ``len(o)``\\와 동등합니다."

#: ../../c-api/object.rst:468
msgid ""
"Return an estimated length for the object *o*. First try to return its "
"actual length, then an estimate using :meth:`~object.__length_hint__`, "
"and finally return the default value. On error return ``-1``. This is the"
" equivalent to the Python expression ``operator.length_hint(o, "
"defaultvalue)``."
msgstr ""
"*o* 객체의 추정된 길이를 반환합니다. 먼저 실제 길이를 반환하려고 시도한 다음, "
":meth:`~object.__length_hint__`\\를 사용하여 추정값을 반환하고, 마지막으로 기본값을 반환합니다. 에러 시"
" ``-1``\\을 반환합니다. 이것은 파이썬 표현식 ``operator.length_hint(o, "
"defaultvalue)``\\와 동등합니다."

#: ../../c-api/object.rst:478
msgid ""
"Return element of *o* corresponding to the object *key* or ``NULL`` on "
"failure. This is the equivalent of the Python expression ``o[key]``."
msgstr ""
"객체 *key*\\에 해당하는 *o*\\의 요소를 반환하거나 실패 시 ``NULL``\\을 반환합니다. 이것은 파이썬 표현식 "
"``o[key]``\\와 동등합니다."

#: ../../c-api/object.rst:484
msgid ""
"Map the object *key* to the value *v*.  Raise an exception and return "
"``-1`` on failure; return ``0`` on success.  This is the equivalent of "
"the Python statement ``o[key] = v``.  This function *does not* steal a "
"reference to *v*."
msgstr ""
"객체 *key*\\를 값 *v*\\에 매핑합니다. 실패 시 예외를 발생시키고 ``-1``\\을 반환합니다; 성공하면 ``0``\\을"
" 반환합니다. 이것은 파이썬 문장 ``o[key] = v``\\와 동등합니다. 이 함수는 *v*\\에 대한 참조를 훔치지 "
"*않습니다*."

#: ../../c-api/object.rst:492
msgid ""
"Remove the mapping for the object *key* from the object *o*.  Return "
"``-1`` on failure.  This is equivalent to the Python statement ``del "
"o[key]``."
msgstr ""
"객체 *o*\\에서 객체 *key*\\에 대한 매핑을 제거합니다. 실패하면 ``-1``\\을 반환합니다. 이것은 파이썬 문장 "
"``del o[key]``\\와 동등합니다."

#: ../../c-api/object.rst:498
msgid ""
"This is the same as :c:func:`PyObject_DelItem`, but *key* is specified as"
" a :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/object.rst:505
msgid ""
"This is equivalent to the Python expression ``dir(o)``, returning a "
"(possibly empty) list of strings appropriate for the object argument, or "
"``NULL`` if there was an error.  If the argument is ``NULL``, this is "
"like the Python ``dir()``, returning the names of the current locals; in "
"this case, if no execution frame is active then ``NULL`` is returned but "
":c:func:`PyErr_Occurred` will return false."
msgstr ""
"이것은 파이썬 표현식 ``dir(o)``\\와 동등하며, 객체 인자에 적합한 문자열의 (비어있을 수 있는) 리스트를 반환하거나, "
"에러가 있으면 ``NULL``\\을 반환합니다. 인자가 ``NULL``\\이면, 파이썬 ``dir()``\\과 비슷하며, 현재 "
"지역(locals)의 이름들을 반환합니다; 이 경우, 실행 프레임이 활성화되어 있지 않으면 ``NULL``\\이 반환되지만 "
":c:func:`PyErr_Occurred`\\는 거짓을 반환합니다."

#: ../../c-api/object.rst:514
msgid ""
"This is equivalent to the Python expression ``iter(o)``. It returns a new"
" iterator for the object argument, or the object  itself if the object is"
" already an iterator.  Raises :exc:`TypeError` and returns ``NULL`` if "
"the object cannot be iterated."
msgstr ""
"이것은 파이썬 표현식 ``iter(o)``\\와 동등합니다. 객체 인자에 대한 새로운 이터레이터를 반환하거나, 객체가 이미 "
"이터레이터이면 객체 자체를 반환합니다. 객체를 이터레이트 할 수 없으면 :exc:`TypeError`\\를 발생시키고 "
"``NULL``\\을 반환합니다."

#: ../../c-api/object.rst:522
msgid ""
"This is equivalent to the Python ``__iter__(self): return self`` method. "
"It is intended for :term:`iterator` types, to be used in the "
":c:member:`PyTypeObject.tp_iter` slot."
msgstr ""

#: ../../c-api/object.rst:528
msgid ""
"This is the equivalent to the Python expression ``aiter(o)``. Takes an "
":class:`AsyncIterable` object and returns an :class:`AsyncIterator` for "
"it. This is typically a new iterator but if the argument is an "
":class:`AsyncIterator`, this returns itself. Raises :exc:`TypeError` and "
"returns ``NULL`` if the object cannot be iterated."
msgstr ""
"이것은 파이썬 표현식 ``aiter(o)``\\와 동등합니다. :class:`AsyncIterable`\\을 받아서 그 것의 "
":class:`AsyncIterator`\\를 반환합니다. 보통 새 이터레이터이지만, 인자가 "
":class:`AsyncIterator`\\면 그 자신을 반환합니다. 객체를 이터레이트 할 수 없으면 "
":exc:`TypeError`\\를 발생시키고 ``NULL``\\을 반환합니다."

#: ../../c-api/object.rst:538
msgid "Get a pointer to subclass-specific data reserved for *cls*."
msgstr ""

#: ../../c-api/object.rst:540
msgid ""
"The object *o* must be an instance of *cls*, and *cls* must have been "
"created using negative :c:member:`PyType_Spec.basicsize`. Python does not"
" check this."
msgstr ""

#: ../../c-api/object.rst:544
msgid "On error, set an exception and return ``NULL``."
msgstr ""

#: ../../c-api/object.rst:550
msgid ""
"Return the size of the instance memory space reserved for *cls*, i.e. the"
" size of the memory :c:func:`PyObject_GetTypeData` returns."
msgstr ""

#: ../../c-api/object.rst:553
msgid ""
"This may be larger than requested using :c:member:`-PyType_Spec.basicsize"
" <PyType_Spec.basicsize>`; it is safe to use this larger size (e.g. with "
":c:func:`!memset`)."
msgstr ""

#: ../../c-api/object.rst:556
msgid ""
"The type *cls* **must** have been created using negative "
":c:member:`PyType_Spec.basicsize`. Python does not check this."
msgstr ""

#: ../../c-api/object.rst:560
msgid "On error, set an exception and return a negative value."
msgstr ""

#: ../../c-api/object.rst:566
msgid ""
"Get a pointer to per-item data for a class with "
":c:macro:`Py_TPFLAGS_ITEMS_AT_END`."
msgstr ""

#: ../../c-api/object.rst:569
msgid ""
"On error, set an exception and return ``NULL``. :py:exc:`TypeError` is "
"raised if *o* does not have :c:macro:`Py_TPFLAGS_ITEMS_AT_END` set."
msgstr ""

#: ../../c-api/object.rst:577
msgid "Visit the managed dictionary of *obj*."
msgstr ""

#: ../../c-api/object.rst:579 ../../c-api/object.rst:588
msgid ""
"This function must only be called in a traverse function of the type "
"which has the :c:macro:`Py_TPFLAGS_MANAGED_DICT` flag set."
msgstr ""

#: ../../c-api/object.rst:586
msgid "Clear the managed dictionary of *obj*."
msgstr ""

#: ../../c-api/object.rst:316 ../../c-api/object.rst:328
#: ../../c-api/object.rst:353 ../../c-api/object.rst:404
#: ../../c-api/object.rst:438 ../../c-api/object.rst:459
msgid "built-in function"
msgstr "내장 함수"

#: ../../c-api/object.rst:316
msgid "repr"
msgstr "repr"

#: ../../c-api/object.rst:328
msgid "ascii"
msgstr "아스키"

#: ../../c-api/object.rst:336
msgid "string"
msgstr "문자열"

#: ../../c-api/object.rst:336
msgid "PyObject_Str (C function)"
msgstr "PyObject_Str (C 함수)"

#: ../../c-api/object.rst:353
msgid "bytes"
msgstr "바이트열"

#: ../../c-api/object.rst:404
msgid "hash"
msgstr "해시"

#: ../../c-api/object.rst:438
msgid "type"
msgstr "형"

#: ../../c-api/object.rst:459
msgid "len"
msgstr "len"

#~ msgid ""
#~ "Determine if the object *o* is "
#~ "callable.  Return ``1`` if the object"
#~ " is callable and ``0`` otherwise.  "
#~ "This function always succeeds."
#~ msgstr ""
#~ "객체 *o*\\가 콜러블인지 판별합니다. 객체가 콜러블이면 "
#~ "``1``\\을, 그렇지 않으면 ``0``\\을 반환합니다. 이 "
#~ "함수는 항상 성공합니다."

#~ msgid ""
#~ "Call a callable Python object "
#~ "*callable*, with arguments given by the"
#~ " tuple *args*, and named arguments "
#~ "given by the dictionary *kwargs*."
#~ msgstr ""
#~ "튜플 *args*\\로 제공된 인자와 딕셔너리 *kwargs*\\로"
#~ " 제공된 이름있는 인자로 콜러블 파이썬 객체 "
#~ "*callable*\\을 호출합니다."

#~ msgid ""
#~ "*args* must not be ``NULL``, use "
#~ "an empty tuple if no arguments are"
#~ " needed. If no named arguments are"
#~ " needed, *kwargs* can be ``NULL``."
#~ msgstr ""
#~ "*args*\\는 ``NULL``\\이 아니어야 합니다, 인자가 필요하지"
#~ " 않으면 빈 튜플을 사용하십시오. 이름있는 인자가 "
#~ "필요하지 않으면, *kwargs*\\는 ``NULL``\\일 수 "
#~ "있습니다."

#~ msgid ""
#~ "Return the result of the call on"
#~ " success, or raise an exception and"
#~ " return ``NULL`` on failure."
#~ msgstr "성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "This is the equivalent of the "
#~ "Python expression: ``callable(*args, **kwargs)``."
#~ msgstr "이것은 파이썬 표현식 ``callable(*args, **kwargs)``\\와 동등합니다."

#~ msgid ""
#~ "Call a callable Python object "
#~ "*callable*, with arguments given by the"
#~ " tuple *args*.  If no arguments are"
#~ " needed, then *args* can be ``NULL``."
#~ msgstr ""
#~ "튜플 *args*\\로 제공된 인자로 콜러블 파이썬 객체"
#~ " *callable*\\을 호출합니다. 인자가 필요하지 않으면, "
#~ "*args*\\는 ``NULL``\\일 수 있습니다."

#~ msgid "This is the equivalent of the Python expression: ``callable(*args)``."
#~ msgstr "이것은 파이썬 표현식 ``callable(*args)``\\와 동등합니다."

#~ msgid ""
#~ "Call a callable Python object "
#~ "*callable*, with a variable number of"
#~ " C arguments. The C arguments are "
#~ "described using a :c:func:`Py_BuildValue` "
#~ "style format string.  The format can "
#~ "be ``NULL``, indicating that no "
#~ "arguments are provided."
#~ msgstr ""
#~ "가변 개수의 C 인자로 콜러블 파이썬 객체 "
#~ "*callable*\\을 호출합니다. C 인자는 "
#~ ":c:func:`Py_BuildValue` 스타일 포맷 문자열을 사용하여 "
#~ "기술됩니다. format은 ``NULL``\\일 수 있으며, 인자가"
#~ " 제공되지 않았음을 나타냅니다."

#~ msgid ""
#~ "Note that if you only pass "
#~ ":c:type:`PyObject *` args, "
#~ ":c:func:`PyObject_CallFunctionObjArgs` is a faster"
#~ " alternative."
#~ msgstr ""
#~ ":c:type:`PyObject \\*` args 만 전달한다면, "
#~ ":c:func:`PyObject_CallFunctionObjArgs` 가 더 빠른 "
#~ "대안임에 유의하십시오."

#~ msgid "The type of *format* was changed from ``char *``."
#~ msgstr "*format*\\의 형이 ``char *``\\에서 변경되었습니다."

#~ msgid ""
#~ "Call the method named *name* of "
#~ "object *obj* with a variable number "
#~ "of C arguments.  The C arguments "
#~ "are described by a :c:func:`Py_BuildValue` "
#~ "format string that should  produce a "
#~ "tuple."
#~ msgstr ""
#~ "가변 개수의 C 인자로 객체 *obj*\\의 "
#~ "*name*\\이라는 메서드를 호출합니다. C 인자는 튜플을 "
#~ "생성해야 하는 :c:func:`Py_BuildValue` 포맷 문자열로 "
#~ "기술됩니다."

#~ msgid "The format can be ``NULL``, indicating that no arguments are provided."
#~ msgstr "format은 ``NULL``\\일 수 있으며, 인자가 제공되지 않았음을 나타냅니다."

#~ msgid ""
#~ "This is the equivalent of the "
#~ "Python expression: ``obj.name(arg1, arg2, "
#~ "...)``."
#~ msgstr "이것은 파이썬 표현식 ``obj.name(arg1, arg2, ...)``\\와 동등합니다."

#~ msgid ""
#~ "Note that if you only pass "
#~ ":c:type:`PyObject *` args, "
#~ ":c:func:`PyObject_CallMethodObjArgs` is a faster "
#~ "alternative."
#~ msgstr ""
#~ ":c:type:`PyObject \\*` args 만 전달한다면, "
#~ ":c:func:`PyObject_CallMethodObjArgs` 가 더 빠른 "
#~ "대안임에 유의하십시오."

#~ msgid "The types of *name* and *format* were changed from ``char *``."
#~ msgstr "*name*\\과 *format*\\의 형이 ``char *``\\에서 변경되었습니다."

#~ msgid ""
#~ "Call a callable Python object "
#~ "*callable*, with a variable number of"
#~ " :c:type:`PyObject*` arguments.  The arguments"
#~ " are provided as a variable number"
#~ " of parameters followed by ``NULL``."
#~ msgstr ""
#~ "가변 개수의 :c:type:`PyObject\\*` 인자로 콜러블 파이썬"
#~ " 객체 *callable*\\을 호출합니다. 인자는 ``NULL``\\로"
#~ " 끝나는 가변 개수의 매개 변수로 제공됩니다."

#~ msgid ""
#~ "This is the equivalent of the "
#~ "Python expression: ``callable(arg1, arg2, "
#~ "...)``."
#~ msgstr "이것은 파이썬 표현식 ``callable(arg1, arg2, ...)``\\와 동등합니다."

#~ msgid ""
#~ "Calls a method of the Python "
#~ "object *obj*, where the name of "
#~ "the method is given as a Python"
#~ " string object in *name*.  It is "
#~ "called with a variable number of "
#~ ":c:type:`PyObject*` arguments.  The arguments "
#~ "are provided as a variable number "
#~ "of parameters followed by ``NULL``."
#~ msgstr ""
#~ "파이썬 객체 *obj*\\의 메서드를 호출합니다. 여기서 "
#~ "메서드 이름은 *name*\\에서 파이썬 문자열 객체로 "
#~ "제공됩니다. 가변 개수 :c:type:`PyObject\\*` 인자로 "
#~ "호출됩니다. 인자는 ``NULL``\\로 끝나는 가변 개수의 "
#~ "매개 변수로 제공됩니다."

#~ msgid ""
#~ "Call a callable Python object "
#~ "*callable*, using :c:data:`vectorcall "
#~ "<PyTypeObject.tp_vectorcall_offset>` if possible."
#~ msgstr ""
#~ "가능하면 :c:data:`벡터콜 <PyTypeObject.tp_vectorcall_offset>`\\을"
#~ " 사용하여, 콜러블 파이썬 객체 *callable*\\을 "
#~ "호출합니다."

#~ msgid "*args* is a C array with the positional arguments."
#~ msgstr "*args*\\는 위치 인자가 있는 C 배열입니다."

#~ msgid ""
#~ "*nargsf* is the number of positional "
#~ "arguments plus optionally the flag "
#~ ":const:`PY_VECTORCALL_ARGUMENTS_OFFSET` (see below). "
#~ "To get actual number of arguments, "
#~ "use :c:func:`PyVectorcall_NARGS(nargsf) "
#~ "<PyVectorcall_NARGS>`."
#~ msgstr ""
#~ "*nargsf*\\는 위치 인자의 수와 선택적인 플래그 "
#~ ":const:`PY_VECTORCALL_ARGUMENTS_OFFSET`\\입니다 (아래를 참조하십시오)."
#~ " 실제 인자의 개수를 얻으려면, "
#~ ":c:func:`PyVectorcall_NARGS(nargsf) <PyVectorcall_NARGS>`\\를 "
#~ "사용하십시오."

#~ msgid ""
#~ "*kwnames* can be either ``NULL`` (no "
#~ "keyword arguments) or a tuple of "
#~ "keyword names. In the latter case, "
#~ "the values of the keyword arguments "
#~ "are stored in *args* after the "
#~ "positional arguments. The number of "
#~ "keyword arguments does not influence "
#~ "*nargsf*."
#~ msgstr ""
#~ "*kwnames*\\는 ``NULL``\\(키워드 인자 없음)이나 키워드 "
#~ "이름의 튜플일 수 있습니다. 후자의 경우, 키워드 "
#~ "인자의 값은 위치 인자 다음에 *args*\\에 저장됩니다."
#~ " 키워드 인자의 수는 *nargsf*\\에 영향을 미치지 "
#~ "않습니다."

#~ msgid ""
#~ "*kwnames* must contain only objects of"
#~ " type ``str`` (not a subclass), and"
#~ " all keys must be unique."
#~ msgstr "*kwnames*\\는 ``str`` 형(서브 클래스는 아닙니다)의 객체만 포함해야 하며, 모든 키는 고유해야 합니다."

#~ msgid ""
#~ "This uses the vectorcall protocol if "
#~ "the callable supports it; otherwise, the"
#~ " arguments are converted to use "
#~ ":c:member:`~PyTypeObject.tp_call`."
#~ msgstr ""
#~ "callable이 지원한다면 벡터콜 프로토콜을 사용합니다; 그렇지 "
#~ "않으면, 인자는 :c:member:`~PyTypeObject.tp_call`\\을 사용하도록"
#~ " 변환됩니다."

#~ msgid ""
#~ "This function is provisional and "
#~ "expected to become public in Python "
#~ "3.9, with a different name and, "
#~ "possibly, changed semantics. If you use"
#~ " the function, plan for updating your"
#~ " code for Python 3.9."
#~ msgstr ""
#~ "이 함수는 잠정적이며 파이썬 3.9에서 다른 이름으로 "
#~ "변경되고 어쩌면 의미도 변경되어 공개될 예정입니다. 이 "
#~ "함수를 사용한다면, 파이썬 3.9를 위해 코드를 변경할 "
#~ "준비를 하십시오."

#~ msgid ""
#~ "If set in a vectorcall *nargsf* "
#~ "argument, the callee is allowed to "
#~ "temporarily change ``args[-1]``. In other "
#~ "words, *args* points to argument 1 "
#~ "(not 0) in the allocated vector. "
#~ "The callee must restore the value "
#~ "of ``args[-1]`` before returning."
#~ msgstr ""
#~ "벡터콜 *nargsf* 인자에 설정되면, 피호출자는 일시적으로 "
#~ "``args[-1]``\\을 변경할 수 있습니다. 즉, *args*\\는"
#~ " 할당된 벡터에서 인자 1(0이 아닙니다)을 가리킵니다. "
#~ "피호출자는 반환하기 전에 ``args[-1]`` 값을 복원해야 "
#~ "합니다."

#~ msgid ""
#~ "Whenever they can do so cheaply "
#~ "(without additional allocation), callers are"
#~ " encouraged to use "
#~ ":const:`PY_VECTORCALL_ARGUMENTS_OFFSET`. Doing so "
#~ "will allow callables such as bound "
#~ "methods to make their onward calls "
#~ "(which include a prepended *self* "
#~ "argument) cheaply."
#~ msgstr ""
#~ "(추가 할당 없이) 저렴하게 할 수 있을 때마다,"
#~ " 호출자는 :const:`PY_VECTORCALL_ARGUMENTS_OFFSET`\\을 사용하는"
#~ " 것이 좋습니다. 이렇게 하면 연결된 메서드와 같은"
#~ " 콜러블 항목이 선행 호출(*self* 인자를 앞에 "
#~ "붙이는 것을 포함합니다)을 저렴하게 만들 수 있습니다."

#~ msgid ""
#~ "Given a vectorcall *nargsf* argument, "
#~ "return the actual number of arguments."
#~ " Currently equivalent to ``nargsf & "
#~ "~PY_VECTORCALL_ARGUMENTS_OFFSET``."
#~ msgstr ""
#~ "주어진 벡터콜 *nargsf* 인자에서 실제 인자 수를 "
#~ "반환합니다. 현재 ``nargsf & "
#~ "~PY_VECTORCALL_ARGUMENTS_OFFSET``\\과 동등합니다."

#~ msgid ""
#~ "Same as :c:func:`_PyObject_Vectorcall` except "
#~ "that the keyword arguments are passed"
#~ " as a dictionary in *kwdict*. This"
#~ " may be ``NULL`` if there are "
#~ "no keyword arguments."
#~ msgstr ""
#~ "키워드 인자가 *kwdict* 딕셔너리로 전달된다는 점을 "
#~ "제외하고는 :c:func:`_PyObject_Vectorcall`\\과 같습니다. 키워드"
#~ " 인자가 없으면 *kwdict*\\는 ``NULL``\\일 수 "
#~ "있습니다."

#~ msgid ""
#~ "For callables supporting :c:data:`vectorcall "
#~ "<PyTypeObject.tp_vectorcall_offset>`, the arguments "
#~ "are internally converted to the "
#~ "vectorcall convention. Therefore, this "
#~ "function adds some overhead compared to"
#~ " :c:func:`_PyObject_Vectorcall`. It should only"
#~ " be used if the caller already "
#~ "has a dictionary ready to use."
#~ msgstr ""
#~ ":c:data:`벡터콜 <PyTypeObject.tp_vectorcall_offset>`\\을 지원하는"
#~ " 콜러블의 경우, 인자는 내부적으로 벡터콜 규칙으로 "
#~ "변환됩니다. 따라서, 이 함수는 "
#~ ":c:func:`_PyObject_Vectorcall`\\에 비해 약간의 오버헤드를 "
#~ "추가합니다. 호출자에게 이미 사용할 준비가 된 딕셔너리가"
#~ " 있을 때만 사용해야 합니다."

#~ msgid ""
#~ "Note that exceptions which occur while"
#~ " calling :meth:`__getattr__` and "
#~ ":meth:`__getattribute__` methods will get "
#~ "suppressed. To get error reporting use"
#~ " :c:func:`PyObject_GetAttr()` instead."
#~ msgstr ""
#~ ":meth:`__getattr__`\\과 :meth:`__getattribute__` 메서드를 "
#~ "호출하는 동안 발생하는 예외는 억제됨에 유의하십시오. 에러"
#~ " 보고를 얻으려면 대신 :c:func:`PyObject_GetAttr()`\\을 "
#~ "사용하십시오."

#~ msgid ""
#~ "Retrieve an attribute named *attr_name* "
#~ "from object *o*. Returns the attribute"
#~ " value on success, or ``NULL`` on "
#~ "failure. This is the equivalent of "
#~ "the Python expression ``o.attr_name``."
#~ msgstr ""
#~ "객체 *o*\\에서 *attr_name*\\이라는 이름의 어트리뷰트를 "
#~ "가져옵니다. 성공하면 어트리뷰트 값을, 실패하면 ``NULL``\\을"
#~ " 반환합니다. 이것은 파이썬 표현식 ``o.attr_name``\\과 "
#~ "동등합니다."

#~ msgid ""
#~ "If *v* is ``NULL``, the attribute "
#~ "is deleted, however this feature is "
#~ "deprecated in favour of using "
#~ ":c:func:`PyObject_DelAttr`."
#~ msgstr ""
#~ "*v*\\가 ``NULL``\\이면, 어트리뷰트가 삭제되지만, 이 기능은"
#~ " 폐지되었고 :c:func:`PyObject_DelAttr`\\로 대체되었습니다."

#~ msgid ""
#~ "Compare the values of *o1* and "
#~ "*o2* using the operation specified by"
#~ " *opid*, which must be one of "
#~ ":const:`Py_LT`, :const:`Py_LE`, :const:`Py_EQ`, "
#~ ":const:`Py_NE`, :const:`Py_GT`, or :const:`Py_GE`,"
#~ " corresponding to ``<``, ``<=``, ``==``,"
#~ " ``!=``, ``>``, or ``>=`` respectively. "
#~ "Returns ``-1`` on error, ``0`` if "
#~ "the result is false, ``1`` otherwise."
#~ " This is the equivalent of the "
#~ "Python expression ``o1 op o2``, where"
#~ " ``op`` is the operator corresponding "
#~ "to *opid*."
#~ msgstr ""
#~ "*opid*\\에 의해 지정된 연산을 사용하여 *o1*\\과 "
#~ "*o2*\\의 값을 비교합니다. *opid*\\는 :const:`Py_LT`,"
#~ " :const:`Py_LE`, :const:`Py_EQ`, :const:`Py_NE`, "
#~ ":const:`Py_GT` 또는 :const:`Py_GE` 중 하나여야 "
#~ "하고 각각 ``<``, ``<=``, ``==``, ``!=``, "
#~ "``>`` 또는 ``>=``\\에 해당합니다. 에러 시 "
#~ "``-1``\\을, 결과가 거짓이면 ``0``\\을, 그렇지 않으면"
#~ " ``1``\\을 반환합니다. 이는 파이썬 표현식 ``o1 "
#~ "op o2``\\와 동등합니다. 여기서 ``op``\\는 "
#~ "*opid*\\에 해당하는 연산자입니다."

