# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "유니코드 객체와 코덱"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "유니코드 객체"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling "
"the complete range of Unicode characters while staying memory efficient."
"  There are special cases for strings where all code points are below "
"128, 256, or 65536; otherwise, code points must be below 1114112 (which "
"is the full Unicode range)."
msgstr ""
"파이썬 3.3에서 :pep:`393`\\을 구현한 이후, 유니코드 객체는 내부적으로 다양한 표현을 사용하여 전체 유니코드 문자 "
"범위를 처리하면서 메모리 효율성을 유지합니다. 모든 코드 포인트가 128, 256 또는 65536 미만인 문자열에 대한 특별한 "
"경우가 있습니다; 그렇지 않으면, 코드 포인트는 1114112 (전체 유니코드 범위) 미만이어야 합니다."

#: ../../c-api/unicode.rst:20
msgid ""
"UTF-8 representation is created on demand and cached in the Unicode "
"object."
msgstr ""

#: ../../c-api/unicode.rst:23
#, fuzzy
msgid ""
"The :c:type:`Py_UNICODE` representation has been removed since Python "
"3.12 with deprecated APIs. See :pep:`623` for more information."
msgstr ""
"\"레거시\" 유니코드 객체는 폐지된 API와 함께 파이썬 3.12에서 제거됩니다. 그 이후로 모든 유니코드 객체는 \"규범적\"이"
" 됩니다. 자세한 정보는 :pep:`623`\\을 참조하십시오."

#: ../../c-api/unicode.rst:29
msgid "Unicode Type"
msgstr "유니코드 형"

#: ../../c-api/unicode.rst:31
msgid ""
"These are the basic Unicode object types used for the Unicode "
"implementation in Python:"
msgstr "다음은 파이썬에서 유니코드 구현에 사용되는 기본 유니코드 객체 형입니다:"

#: ../../c-api/unicode.rst:38
msgid ""
"These types are typedefs for unsigned integer types wide enough to "
"contain characters of 32 bits, 16 bits and 8 bits, respectively.  When "
"dealing with single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"이 형들은 각각 32비트, 16비트 및 8비트의 문자를 포함하기에 충분한 부호 없는 정수 형을 위한 typedef 입니다. 단일 "
"유니코드 문자를 처리할 때는, :c:type:`Py_UCS4`\\를 사용하십시오."

#: ../../c-api/unicode.rst:47
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform."
msgstr "이것은 플랫폼에 따라 16비트 형이나 32비트 형인 :c:type:`wchar_t`\\의 typedef 입니다."

#: ../../c-api/unicode.rst:50
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending "
"on whether you selected a \"narrow\" or \"wide\" Unicode version of "
"Python at build time."
msgstr ""
"이전 버전에서, 이것은 빌드 시 파이썬의 \"내로우(narrow)\"나 \"와이드(wide)\" 유니코드 버전 중 어느 것을 "
"선택했는지에 따라 16비트 형이나 32비트 형이었습니다."

#: ../../c-api/unicode.rst:62
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  "
"In almost all cases, they shouldn't be used directly, since all API "
"functions that deal with Unicode objects take and return "
":c:type:`PyObject` pointers."
msgstr ""
"이 :c:type:`PyObject` 서브 형들은 파이썬 유니코드 객체를 나타냅니다. 거의 모든 경우에, 유니코드 객체를 처리하는 "
"모든 API 함수가 :c:type:`PyObject` 포인터를 취하고 반환하므로 직접 사용해서는 안 됩니다."

#: ../../c-api/unicode.rst:71
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode "
"type.  It is exposed to Python code as ``str``."
msgstr ""
"이 :c:type:`PyTypeObject` 인스턴스는 파이썬 유니코드 형을 나타냅니다. 파이썬 코드에 ``str``\\로 "
"노출됩니다."

#: ../../c-api/unicode.rst:75
#, fuzzy
msgid ""
"The following APIs are C macros and static inlined functions for fast "
"checks and access to internal read-only data of Unicode objects:"
msgstr ""
"다음 API는 실제로는 C 매크로이며 빠른 검사를 수행하고 유니코드 객체의 내부 읽기 전용 데이터에 액세스하는 데 사용할 수 "
"있습니다:"

#: ../../c-api/unicode.rst:80
#, fuzzy
msgid ""
"Return true if the object *obj* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr "객체 *o*\\가 유니코드 객체이거나 유니코드 서브 형의 인스턴스이면 참을 반환합니다. 이 함수는 항상 성공합니다."

#: ../../c-api/unicode.rst:86
#, fuzzy
msgid ""
"Return true if the object *obj* is a Unicode object, but not an instance "
"of a subtype.  This function always succeeds."
msgstr "객체 *o*\\가 유니코드 객체이지만, 서브 형의 인스턴스가 아니면 참을 반환합니다. 이 함수는 항상 성공합니다."

#: ../../c-api/unicode.rst:92
msgid "Returns ``0``. This API is kept only for backward compatibility."
msgstr ""

#: ../../c-api/unicode.rst:96
#, fuzzy
msgid "This API does nothing since Python 3.12."
msgstr "이 함수는 예외를 발생시키지 않습니다."

#: ../../c-api/unicode.rst:102
#, fuzzy
msgid ""
"Return the length of the Unicode string, in code points.  *unicode* has "
"to be a Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"유니코드 문자열의 길이를 코드 포인트로 반환합니다. *o*\\는 \"규범적(canonical)\" 표현의 유니코드 객체여야 합니다 "
"(검사하지 않습니다)."

#: ../../c-api/unicode.rst:112
#, fuzzy
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or "
"UCS4 integer types for direct character access.  No checks are performed "
"if the canonical representation has the correct character size; use "
":c:func:`PyUnicode_KIND` to select the right function."
msgstr ""
"직접 문자 액세스를 위해 UCS1, UCS2 또는 UCS4 정수 형으로 캐스트 된 규범적(canonical) 표현에 대한 포인터를 "
"반환합니다. 규범적(canonical) 표현이 올바른 문자 크기인지 검사하지 않습니다; "
":c:func:`PyUnicode_KIND`\\를 사용하여 올바른 매크로를 선택하십시오. 이것을 액세스하기 전에 "
":c:func:`PyUnicode_READY`\\가 호출되었어야 합니다."

#: ../../c-api/unicode.rst:124
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr ":c:func:`PyUnicode_KIND` 매크로의 값을 반환합니다."

#: ../../c-api/unicode.rst:128
#, fuzzy
msgid "``PyUnicode_WCHAR_KIND`` has been removed."
msgstr "``PyUnicode_WCHAR_KIND``\\는 폐지되었습니다."

#: ../../c-api/unicode.rst:134
#, fuzzy
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  "
"*unicode* has to be a Unicode object in the \"canonical\" representation "
"(not checked)."
msgstr ""
"이 유니코드 객체가 데이터를 저장하는 데 사용하는 문자 당 바이트 수를 나타내는 PyUnicode 종류 상수 (위를 참조하십시오) "
"중 하나를 반환합니다. *o*\\는 \"규범적(canonical)\" 표현의 유니코드 객체여야 합니다 (검사하지 않습니다)."

#: ../../c-api/unicode.rst:143
#, fuzzy
msgid ""
"Return a void pointer to the raw Unicode buffer.  *unicode* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"원시 유니코드 버퍼에 대한 void 포인터를 반환합니다. *o*\\는 \"규범적(canonical)\" 표현의 유니코드 객체여야 "
"합니다 (검사하지 않습니다)."

#: ../../c-api/unicode.rst:152
#, fuzzy
msgid ""
"Write into a canonical representation *data* (as obtained with "
":c:func:`PyUnicode_DATA`).  This function performs no sanity checks, and "
"is intended for usage in loops.  The caller should cache the *kind* value"
" and *data* pointer as obtained from other calls.  *index* is the index "
"in the string (starts at 0) and *value* is the new code point value which"
" should be written to that location."
msgstr ""
"규범적(canonical) 표현 *data*\\(:c:func:`PyUnicode_DATA`\\로 얻은 대로)에 씁니다. 이 "
"매크로는 온전성 검사(sanity checks)를 수행하지 않으며 루프에서 사용하기 위한 것입니다. 호출자는 다른 매크로 호출에서 "
"얻은 대로 *kind* 값과 *data* 포인터를 캐시 해야 합니다. *index*\\는 문자열의 인덱스(0에서 시작합니다)이고 "
"*value*\\는 해당 위치에 기록되어야 하는 새 코드 포인트 값입니다."

#: ../../c-api/unicode.rst:165
msgid ""
"Read a code point from a canonical representation *data* (as obtained "
"with :c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr ""
"규범적(canonical) 표현 *data*\\(:c:func:`PyUnicode_DATA`\\로 얻은 대로)에서 코드 포인트를 "
"읽습니다. 검사나 준비(ready) 호출이 수행되지 않습니다."

#: ../../c-api/unicode.rst:173
#, fuzzy
msgid ""
"Read a character from a Unicode object *unicode*, which must be in the "
"\"canonical\" representation.  This is less efficient than "
":c:func:`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"\"규범적(canonical)\" 표현이어야 하는, 유니코드 객체 *o*\\에서 문자를 읽습니다. 여러 연속 읽기를 수행한다면 "
":c:func:`PyUnicode_READ`\\보다 효율성이 떨어집니다."

#: ../../c-api/unicode.rst:182
#, fuzzy
msgid ""
"Return the maximum code point that is suitable for creating another "
"string based on *unicode*, which must be in the \"canonical\" "
"representation.  This is always an approximation but more efficient than "
"iterating over the string."
msgstr ""
"\"규범적(canonical)\" 표현이어야 하는, *o*\\를 기반으로 다른 문자열을 만드는 데 적합한 최대 코드 포인트를 "
"반환합니다. 이것은 항상 근사치이지만 문자열을 이터레이트 하는 것보다 효율적입니다."

#: ../../c-api/unicode.rst:191
msgid ""
"Return ``1`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr ""
"언어 정의에 따라 문자열이 유효한 식별자이면 ``1``\\을 반환합니다, 섹션 :ref:`identifiers`. 그렇지 않으면 "
"``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:194
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string "
"is not ready."
msgstr "문자열이 준비(ready)되지 않았을 때, 이 함수는 더는 :c:func:`Py_FatalError`\\를 호출하지 않습니다."

#: ../../c-api/unicode.rst:200
msgid "Unicode Character Properties"
msgstr "유니코드 문자 속성"

#: ../../c-api/unicode.rst:202
msgid ""
"Unicode provides many different character properties. The most often "
"needed ones are available through these macros which are mapped to C "
"functions depending on the Python configuration."
msgstr ""
"유니코드는 다양한 문자 속성을 제공합니다. 가장 자주 필요한 것은 파이썬 구성에 따라 C 함수에 매핑되는 이러한 매크로를 통해 "
"사용할 수 있습니다."

#: ../../c-api/unicode.rst:209
msgid "Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr "*ch*\\가 공백 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:214
msgid "Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr "*ch*\\가 소문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:219
msgid "Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr "*ch*\\가 대문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:224
msgid "Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr "*ch*\\가 제목 케이스 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:229
msgid "Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr "*ch*\\가 줄 바꿈 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:234
msgid "Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr "*ch*\\가 10진수 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:239
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "*ch*\\가 디짓(digit) 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:244
msgid "Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr "*ch*\\가 숫자(numeric) 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:249
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic "
"character."
msgstr "*ch*\\가 알파벳 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:254
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric "
"character."
msgstr "*ch*\\가 영숫자 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:259
#, fuzzy
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character,"
" in the sense of :meth:`str.isprintable`."
msgstr "*ch*\\가 공백 문자인지에 따라 ``1``\\이나 ``0``\\을 반환합니다."

#: ../../c-api/unicode.rst:263
msgid "These APIs can be used for fast direct character conversions:"
msgstr "다음 API는 빠른 직접 문자 변환에 사용할 수 있습니다:"

#: ../../c-api/unicode.rst:268
msgid "Return the character *ch* converted to lower case."
msgstr "소문자로 변환된 문자 *ch*\\를 반환합니다."

#: ../../c-api/unicode.rst:273
msgid "Return the character *ch* converted to upper case."
msgstr "대문자로 변환된 문자 *ch*\\를 반환합니다."

#: ../../c-api/unicode.rst:278
msgid "Return the character *ch* converted to title case."
msgstr "제목 케이스로 변환된 문자 *ch*\\를 반환합니다."

#: ../../c-api/unicode.rst:283
#, fuzzy
msgid ""
"Return the character *ch* converted to a decimal positive integer.  "
"Return ``-1`` if this is not possible.  This function does not raise "
"exceptions."
msgstr ""
"10진 양의 정수로 변환된 문자 *ch*\\를 반환합니다. 이것이 불가능하면 ``-1``\\을 반환합니다. 이 매크로는 예외를 "
"발생시키지 않습니다."

#: ../../c-api/unicode.rst:289
#, fuzzy
msgid ""
"Return the character *ch* converted to a single digit integer. Return "
"``-1`` if this is not possible.  This function does not raise exceptions."
msgstr ""
"한 자리 정수로 변환된 문자 *ch*\\를 반환합니다. 이것이 불가능하면 ``-1``\\을 반환합니다. 이 매크로는 예외를 "
"발생시키지 않습니다."

#: ../../c-api/unicode.rst:295
#, fuzzy
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this "
"is not possible.  This function does not raise exceptions."
msgstr ""
"double로 변환된 문자 *ch*\\를 반환합니다. 이것이 불가능하면 ``-1.0``\\을 반환합니다. 이 매크로는 예외를 "
"발생시키지 않습니다."

#: ../../c-api/unicode.rst:299
msgid "These APIs can be used to work with surrogates:"
msgstr "다음 API를 사용하여 서로게이트를 다룰 수 있습니다:"

#: ../../c-api/unicode.rst:303
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "*ch*\\가 서로게이트인지 확인합니다 (``0xD800 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:307
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "*ch*\\가 상위 서로게이트인지 확인합니다 (``0xD800 <= ch <= 0xDBFF``)."

#: ../../c-api/unicode.rst:311
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "*ch*\\가 하위 서로게이트인지 확인합니다 (``0xDC00 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:315
#, fuzzy
msgid ""
"Join two surrogate code points and return a single :c:type:`Py_UCS4` "
"value. *high* and *low* are respectively the leading and trailing "
"surrogates in a surrogate pair. *high* must be in the range [0xD800; "
"0xDBFF] and *low* must be in the range [0xDC00; 0xDFFF]."
msgstr ""
"두 서로게이트 문자를 결합하고 단일 Py_UCS4 값을 반환합니다. *high*\\와 *low*\\는 각각 서로게이트 쌍의 선행과 "
"후행 서로게이트입니다."

#: ../../c-api/unicode.rst:322
msgid "Creating and accessing Unicode strings"
msgstr "유니코드 문자열 생성과 액세스"

#: ../../c-api/unicode.rst:324
msgid ""
"To create Unicode objects and access their basic sequence properties, use"
" these APIs:"
msgstr "유니코드 객체를 만들고 기본 시퀀스 속성에 액세스하려면 다음 API를 사용하십시오:"

#: ../../c-api/unicode.rst:329
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded"
" up to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"새 유니코드 객체를 만듭니다. *maxchar*\\은 문자열에 배치할 실제 최대 코드 포인트여야 합니다. 근삿값으로, 127, "
"255, 65535, 1114111 시퀀스에서 가장 가까운 값으로 올림 할 수 있습니다."

#: ../../c-api/unicode.rst:333
msgid ""
"This is the recommended way to allocate a new Unicode object.  Objects "
"created using this function are not resizable."
msgstr "이것은 새 유니코드 객체를 할당하는 데 권장되는 방법입니다. 이 함수를 사용하여 만든 객체는 크기를 조정할 수 없습니다."

#: ../../c-api/unicode.rst:336
msgid "On error, set an exception and return ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:344
msgid ""
"Create a new Unicode object with the given *kind* (possible values are "
":c:macro:`PyUnicode_1BYTE_KIND` etc., as returned by "
":c:func:`PyUnicode_KIND`).  The *buffer* must point to an array of *size*"
" units of 1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"주어진 *kind*\\(가능한 값은 :c:func:`PyUnicode_KIND`\\에 의해 반환된 "
":c:macro:`PyUnicode_1BYTE_KIND` 등입니다)로 새로운 유니코드 객체를 만듭니다. *buffer*\\는 "
"kind에 따라 문자 당 1, 2 또는 4바이트의 *size* 단위의 배열을 가리켜야 합니다."

#: ../../c-api/unicode.rst:349
msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string "
"(:c:macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in "
"the UCS1 range, it will be transformed into UCS1 "
"(:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""

#: ../../c-api/unicode.rst:360
#, fuzzy
msgid ""
"Create a Unicode object from the char buffer *str*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. The return value might be a shared object, i.e. modification of "
"the data is not allowed."
msgstr ""
"char 버퍼 *u*\\에서 유니코드 객체를 만듭니다. 바이트는 UTF-8로 인코딩된 것으로 해석됩니다. 버퍼는 새 객체에 "
"복사됩니다. 버퍼가 ``NULL``\\이 아니면, 반환 값은 공유 객체일 수 있습니다, 즉, 데이터 수정이 허용되지 않습니다."

#: ../../c-api/unicode.rst:366
#, fuzzy
msgid "This function raises :exc:`SystemError` when:"
msgstr "이 함수는 예외를 발생시키지 않습니다."

#: ../../c-api/unicode.rst:368
msgid "*size* < 0,"
msgstr ""

#: ../../c-api/unicode.rst:369
msgid "*str* is ``NULL`` and *size* > 0"
msgstr ""

#: ../../c-api/unicode.rst:371
msgid "*str* == ``NULL`` with *size* > 0 is not allowed anymore."
msgstr ""

#: ../../c-api/unicode.rst:377
#, fuzzy
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*str*."
msgstr "UTF-8로 인코딩된 널-종료 char 버퍼 *u*\\에서 유니코드 객체를 만듭니다."

#: ../../c-api/unicode.rst:383
#, fuzzy
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number "
"of arguments, calculate the size of the resulting Python Unicode string "
"and return a string with the values formatted into it.  The variable "
"arguments must be C types and must correspond exactly to the format "
"characters in the *format* ASCII-encoded string."
msgstr ""
"C :c:func:`printf`\\ -스타일 *format* 문자열과 가변 개수의 인자를 취해서, 결과 파이썬 유니코드 문자열의 "
"크기를 계산하고 포맷된 값이 들어간 문자열을 반환합니다. 변수 인자는 C형이어야 하며 *format* ASCII 인코딩된 문자열의 "
"포맷 문자와 정확히 일치해야 합니다. 다음 포맷 문자가 허용됩니다:"

#: ../../c-api/unicode.rst:389
msgid ""
"A conversion specifier contains two or more characters and has the "
"following components, which must occur in this order:"
msgstr ""

#: ../../c-api/unicode.rst:392
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: ../../c-api/unicode.rst:394
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""

#: ../../c-api/unicode.rst:397
msgid ""
"Minimum field width (optional). If specified as an ``'*'`` (asterisk), "
"the actual width is given in the next argument, which must be of type "
":c:expr:`int`, and the object to convert comes after the minimum field "
"width and optional precision."
msgstr ""

#: ../../c-api/unicode.rst:402
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision."
" If specified as ``'*'`` (an asterisk), the actual precision is given in "
"the next argument, which must be of type :c:expr:`int`, and the value to "
"convert comes after the precision."
msgstr ""

#: ../../c-api/unicode.rst:407
msgid "Length modifier (optional)."
msgstr ""

#: ../../c-api/unicode.rst:409
msgid "Conversion type."
msgstr ""

#: ../../c-api/unicode.rst:411
msgid "The conversion flag characters are:"
msgstr ""

#: ../../c-api/unicode.rst:416
msgid "Flag"
msgstr ""

#: ../../c-api/unicode.rst:416
msgid "Meaning"
msgstr ""

#: ../../c-api/unicode.rst:418
msgid "``0``"
msgstr ""

#: ../../c-api/unicode.rst:418
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: ../../c-api/unicode.rst:420
msgid "``-``"
msgstr ""

#: ../../c-api/unicode.rst:420
msgid ""
"The converted value is left adjusted (overrides the ``0`` flag if both "
"are given)."
msgstr ""

#: ../../c-api/unicode.rst:424
msgid ""
"The length modifiers for following integer conversions (``d``, ``i``, "
"``o``, ``u``, ``x``, or ``X``) specify the type of the argument "
"(:c:expr:`int` by default):"
msgstr ""

#: ../../c-api/unicode.rst:431
msgid "Modifier"
msgstr ""

#: ../../c-api/unicode.rst:431
#, fuzzy
msgid "Types"
msgstr "형"

#: ../../c-api/unicode.rst:433
msgid "``l``"
msgstr ""

#: ../../c-api/unicode.rst:433
msgid ":c:expr:`long` or :c:expr:`unsigned long`"
msgstr ""

#: ../../c-api/unicode.rst:435
msgid "``ll``"
msgstr ""

#: ../../c-api/unicode.rst:435
msgid ":c:expr:`long long` or :c:expr:`unsigned long long`"
msgstr ""

#: ../../c-api/unicode.rst:437
msgid "``j``"
msgstr ""

#: ../../c-api/unicode.rst:437
msgid ":c:type:`intmax_t` or :c:type:`uintmax_t`"
msgstr ""

#: ../../c-api/unicode.rst:439
msgid "``z``"
msgstr ""

#: ../../c-api/unicode.rst:439
msgid ":c:type:`size_t` or :c:type:`ssize_t`"
msgstr ""

#: ../../c-api/unicode.rst:441
msgid "``t``"
msgstr ""

#: ../../c-api/unicode.rst:441
msgid ":c:type:`ptrdiff_t`"
msgstr ""

#: ../../c-api/unicode.rst:444
msgid ""
"The length modifier ``l`` for following conversions ``s`` or ``V`` "
"specify that the type of the argument is :c:expr:`const wchar_t*`."
msgstr ""

#: ../../c-api/unicode.rst:447
msgid "The conversion specifiers are:"
msgstr ""

#: ../../c-api/unicode.rst:453
msgid "Conversion Specifier"
msgstr ""

#: ../../c-api/unicode.rst:454
msgid "Type"
msgstr "형"

#: ../../c-api/unicode.rst:455
msgid "Comment"
msgstr "주석"

#: ../../c-api/unicode.rst:457
msgid "``%``"
msgstr ""

#: ../../c-api/unicode.rst:458
msgid "*n/a*"
msgstr "*n/a*"

#: ../../c-api/unicode.rst:459
#, fuzzy, python-format
msgid "The literal ``%`` character."
msgstr "리터럴 % 문자."

#: ../../c-api/unicode.rst:461
msgid "``d``, ``i``"
msgstr ""

#: ../../c-api/unicode.rst:462 ../../c-api/unicode.rst:466
#: ../../c-api/unicode.rst:470 ../../c-api/unicode.rst:474
#: ../../c-api/unicode.rst:478
msgid "Specified by the length modifier"
msgstr ""

#: ../../c-api/unicode.rst:463
msgid "The decimal representation of a signed C integer."
msgstr ""

#: ../../c-api/unicode.rst:465
msgid "``u``"
msgstr ""

#: ../../c-api/unicode.rst:467
msgid "The decimal representation of an unsigned C integer."
msgstr ""

#: ../../c-api/unicode.rst:469
msgid "``o``"
msgstr ""

#: ../../c-api/unicode.rst:471
msgid "The octal representation of an unsigned C integer."
msgstr ""

#: ../../c-api/unicode.rst:473
msgid "``x``"
msgstr ""

#: ../../c-api/unicode.rst:475
msgid "The hexadecimal representation of an unsigned C integer (lowercase)."
msgstr ""

#: ../../c-api/unicode.rst:477
msgid "``X``"
msgstr ""

#: ../../c-api/unicode.rst:479
msgid "The hexadecimal representation of an unsigned C integer (uppercase)."
msgstr ""

#: ../../c-api/unicode.rst:481
msgid "``c``"
msgstr ""

#: ../../c-api/unicode.rst:482
msgid ":c:expr:`int`"
msgstr ""

#: ../../c-api/unicode.rst:483
#, fuzzy
msgid "A single character."
msgstr "C int로 표현된, 단일 문자."

#: ../../c-api/unicode.rst:485
msgid "``s``"
msgstr ""

#: ../../c-api/unicode.rst:486
msgid ":c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ""

#: ../../c-api/unicode.rst:487
msgid "A null-terminated C character array."
msgstr "널-종료 C 문자 배열."

#: ../../c-api/unicode.rst:489
msgid "``p``"
msgstr ""

#: ../../c-api/unicode.rst:490
#, fuzzy
msgid ":c:expr:`const void*`"
msgstr "const void\\*"

#: ../../c-api/unicode.rst:491
#, fuzzy
msgid ""
"The hex representation of a C  pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal"
" ``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"C 포인터의 16진수 표현. 플랫폼의 ``printf``\\가 산출하는 내용과 관계없이 리터럴 ``0x``\\로 시작하는 것이 "
"보장된다는 점을 제외하면 거의 ``printf(\"%p\")``\\와 동등합니다."

#: ../../c-api/unicode.rst:496
msgid "``A``"
msgstr ""

#: ../../c-api/unicode.rst:497 ../../c-api/unicode.rst:501
#: ../../c-api/unicode.rst:511 ../../c-api/unicode.rst:515
#: ../../c-api/unicode.rst:519 ../../c-api/unicode.rst:524
#, fuzzy
msgid ":c:expr:`PyObject*`"
msgstr "PyObject\\*"

#: ../../c-api/unicode.rst:498
msgid "The result of calling :func:`ascii`."
msgstr ":func:`ascii`\\를 호출한 결과."

#: ../../c-api/unicode.rst:500
msgid "``U``"
msgstr ""

#: ../../c-api/unicode.rst:502
msgid "A Unicode object."
msgstr "유니코드 객체."

#: ../../c-api/unicode.rst:504
msgid "``V``"
msgstr ""

#: ../../c-api/unicode.rst:505
msgid ":c:expr:`PyObject*`, :c:expr:`const char*` or :c:expr:`const wchar_t*`"
msgstr ""

#: ../../c-api/unicode.rst:506
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C "
"character array as a second parameter (which will be used, if the first "
"parameter is ``NULL``)."
msgstr ""
"유니코드 객체(``NULL``\\일 수 있습니다)와 두 번째 매개 변수로서 널-종료 C 문자 배열 (첫 번째 매개 변수가 "
"``NULL``\\이면 사용됩니다)."

#: ../../c-api/unicode.rst:510
msgid "``S``"
msgstr ""

#: ../../c-api/unicode.rst:512
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr ":c:func:`PyObject_Str`\\을 호출한 결과."

#: ../../c-api/unicode.rst:514
msgid "``R``"
msgstr ""

#: ../../c-api/unicode.rst:516
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr ":c:func:`PyObject_Repr`\\을 호출한 결과."

#: ../../c-api/unicode.rst:518
msgid "``T``"
msgstr ""

#: ../../c-api/unicode.rst:520
msgid ""
"Get the fully qualified name of an object type; call "
":c:func:`PyType_GetFullyQualifiedName`."
msgstr ""

#: ../../c-api/unicode.rst:523
msgid "``#T``"
msgstr ""

#: ../../c-api/unicode.rst:525
msgid ""
"Similar to ``T`` format, but use a colon (``:``) as separator between the"
" module name and the qualified name."
msgstr ""

#: ../../c-api/unicode.rst:528
msgid "``N``"
msgstr ""

#: ../../c-api/unicode.rst:529 ../../c-api/unicode.rst:534
msgid ":c:expr:`PyTypeObject*`"
msgstr ""

#: ../../c-api/unicode.rst:530
msgid ""
"Get the fully qualified name of a type; call "
":c:func:`PyType_GetFullyQualifiedName`."
msgstr ""

#: ../../c-api/unicode.rst:533
msgid "``#N``"
msgstr ""

#: ../../c-api/unicode.rst:535
msgid ""
"Similar to ``N`` format, but use a colon (``:``) as separator between the"
" module name and the qualified name."
msgstr ""

#: ../../c-api/unicode.rst:539
#, fuzzy, python-format
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes or :c:type:`wchar_t` items "
"(if the length modifier ``l`` is used) for ``\"%s\"`` and ``\"%V\"`` (if "
"the ``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""
"너비 포매터 단위는 바이트가 아닌 문자 수입니다. 정밀도 포매터 단위는 ``\"%s\"``\\와 ``\"%V\"``\\의 경우는 "
"바이트 수이고 (``PyObject*`` 인자가 ``NULL``\\이면), ``\"%A\"``, ``\"%U\"``, "
"``\"%S\"``, ``\"%R\"`` 및 ``\"%V\"``\\의 경우 문자 수입니다 (``PyObject*`` 인자가 "
"``NULL``\\이 아니면)."

#: ../../c-api/unicode.rst:547
msgid ""
"Unlike to C :c:func:`printf` the ``0`` flag has effect even when a "
"precision is given for integer conversions (``d``, ``i``, ``u``, ``o``, "
"``x``, or ``X``)."
msgstr ""

#: ../../c-api/unicode.rst:551
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "``\"%lld\"``\\와 ``\"%llu\"``\\에 대한 지원이 추가되었습니다."

#: ../../c-api/unicode.rst:554
#, python-format
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "``\"%li\"``, ``\"%lli\"`` 및 ``\"%zi\"``\\에 대한 지원이 추가되었습니다."

#: ../../c-api/unicode.rst:557
#, python-format
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr ""
"``\"%s\"``, ``\"%A\"``, ``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"``\\에"
" 대한 너비와 정밀도 포매터 지원이 추가되었습니다."

#: ../../c-api/unicode.rst:561
msgid ""
"Support for conversion specifiers ``o`` and ``X``. Support for length "
"modifiers ``j`` and ``t``. Length modifiers are now applied to all "
"integer conversions. Length modifier ``l`` is now applied to conversion "
"specifiers ``s`` and ``V``. Support for variable width and precision "
"``*``. Support for flag ``-``."
msgstr ""

#: ../../c-api/unicode.rst:569
#, fuzzy
msgid ""
"An unrecognized format character now sets a :exc:`SystemError`. In "
"previous versions it caused all the rest of the format string to be "
"copied as-is to the result string, and any extra arguments discarded."
msgstr "인식할 수 없는 포맷 문자는 나머지 포맷 문자열이 모두 결과 문자열에 그대로 복사되고, 추가 인자는 버려지도록 합니다."

#: ../../c-api/unicode.rst:573
#, fuzzy, python-format
msgid "Support for ``%T``, ``%#T``, ``%N`` and ``%#N`` formats added."
msgstr "``\"%li\"``, ``\"%lli\"`` 및 ``\"%zi\"``\\에 대한 지원이 추가되었습니다."

#: ../../c-api/unicode.rst:579
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly "
"two arguments."
msgstr "정확히 두 개의 인자를 취한다는 점을 제외하면 :c:func:`PyUnicode_FromFormat`\\과 동일합니다."

#: ../../c-api/unicode.rst:585
#, fuzzy
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), "
"return a new :term:`strong reference` to the object."
msgstr ""
"필요하면 유니코드 서브 형의 인스턴스를 새로운 진짜 유니코드 객체에 복사합니다. *obj*\\가 이미 (서브 형이 아닌) 진짜 "
"유니코드 객체이면, 참조 횟수를 증가시키고 참조를 반환합니다."

#: ../../c-api/unicode.rst:589
msgid "Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr "유니코드나 이의 서브 형 이외의 객체는 :exc:`TypeError`\\를 발생시킵니다."

#: ../../c-api/unicode.rst:594
#, fuzzy
msgid "Create a Unicode Object from the given Unicode code point *ordinal*."
msgstr "UTF-8로 인코딩된 널-종료 char 버퍼 *u*\\에서 유니코드 객체를 만듭니다."

#: ../../c-api/unicode.rst:596
msgid ""
"The ordinal must be in ``range(0x110000)``. A :exc:`ValueError` is raised"
" in the case it is not."
msgstr ""

#: ../../c-api/unicode.rst:603
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "인코딩된 객체 *obj*\\를 유니코드 객체로 디코딩합니다."

#: ../../c-api/unicode.rst:605
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and "
"using the error handling defined by *errors*. Both can be ``NULL`` to "
"have the interface use the default values (see :ref:`builtincodecs` for "
"details)."
msgstr ""
":class:`bytes`, :class:`bytearray` 및 기타 :term:`바이트열류 객체 <bytes-like "
"object>`\\는 주어진 *encoding*\\에 따라 *errors*\\로 정의한 에러 처리를 사용하여 디코딩됩니다. 둘 다 "
"``NULL``\\이 될 수 있고, 이 경우 인터페이스는 기본값을 사용합니다 (자세한 내용은 "
":ref:`builtincodecs`\\를 참조하십시오)."

#: ../../c-api/unicode.rst:611
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to"
" be set."
msgstr "유니코드 객체를 포함한 다른 모든 객체는 :exc:`TypeError`\\가 설정되도록 합니다."

#: ../../c-api/unicode.rst:614
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is "
"responsible for decref'ing the returned objects."
msgstr "API는 에러가 있으면 ``NULL``\\을 반환합니다. 호출자는 반환된 객체의 참조 횟수를 감소시킬 책임이 있습니다."

#: ../../c-api/unicode.rst:620
msgid ""
"Return the name of the default string encoding, ``\"utf-8\"``. See "
":func:`sys.getdefaultencoding`."
msgstr ""

#: ../../c-api/unicode.rst:623
msgid ""
"The returned string does not need to be freed, and is valid until "
"interpreter shutdown."
msgstr ""

#: ../../c-api/unicode.rst:629
msgid "Return the length of the Unicode object, in code points."
msgstr "유니코드 객체의 길이를 코드 포인트로 반환합니다."

#: ../../c-api/unicode.rst:631
msgid "On error, set an exception and return ``-1``."
msgstr ""

#: ../../c-api/unicode.rst:642
#, fuzzy
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to "
":c:func:`!memcpy` if possible.  Returns ``-1`` and sets an exception on "
"error, otherwise returns the number of copied characters."
msgstr ""
"한 유니코드 객체에서 다른 객체로 문자를 복사합니다. 이 함수는 필요하면 문자 변환을 수행하고 가능하면 "
":c:func:`memcpy`\\로 폴백합니다. 에러 시 ``-1``\\을 반환하고 예외를 설정합니다, 그렇지 않으면 복사된 문자 "
"수를 반환합니다."

#: ../../c-api/unicode.rst:653
msgid ""
"Fill a string with a character: write *fill_char* into "
"``unicode[start:start+length]``."
msgstr "문자로 문자열을 채웁니다: *fill_char*\\을 ``unicode[start:start+length]``\\에 씁니다."

#: ../../c-api/unicode.rst:656
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if "
"the string has more than 1 reference."
msgstr "*fill_char*\\이 문자열 최대 문자보다 크거나, 문자열에 둘 이상의 참조가 있으면 실패합니다."

#: ../../c-api/unicode.rst:659
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr "기록된 문자 수를 반환하거나, 에러 시 ``-1``\\을 반환하고 예외를 발생시킵니다."

#: ../../c-api/unicode.rst:668
msgid ""
"Write a character to a string.  The string must have been created through"
" :c:func:`PyUnicode_New`.  Since Unicode strings are supposed to be "
"immutable, the string must not be shared, or have been hashed yet."
msgstr ""
"문자열에 문자를 씁니다. 문자열은 :c:func:`PyUnicode_New`\\를 통해 만들었어야 합니다. 유니코드 문자열은 "
"불변이므로, 문자열을 공유하거나 아직 해시 하지 않아야 합니다."

#: ../../c-api/unicode.rst:672
msgid ""
"This function checks that *unicode* is a Unicode object, that the index "
"is not out of bounds, and that the object can be modified safely (i.e. "
"that it its reference count is one)."
msgstr ""
"이 함수는 *unicode*\\가 유니코드 객체인지, 인덱스가 범위를 벗어났는지, 객체가 안전하게 수정될 수 있는지 (즉, 참조 "
"횟수가 1인지) 확인합니다."

#: ../../c-api/unicode.rst:676
#, fuzzy
msgid "Return ``0`` on success, ``-1`` on error with an exception set."
msgstr "예외가 발생하면 모두 ``NULL``\\이나 ``-1``\\을 반환합니다."

#: ../../c-api/unicode.rst:683
#, fuzzy
msgid ""
"Read a character from a string.  This function checks that *unicode* is a"
" Unicode object and the index is not out of bounds, in contrast to "
":c:func:`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""
"문자열에서 문자를 읽습니다. 이 함수는 매크로 버전 :c:func:`PyUnicode_READ_CHAR`\\와 달리 "
"*unicode*\\가 유니코드 객체이고 인덱스가 범위를 벗어났는지 확인합니다."

#: ../../c-api/unicode.rst:687
#, fuzzy
msgid "Return character on success, ``-1`` on error with an exception set."
msgstr "기록된 문자 수를 반환하거나, 에러 시 ``-1``\\을 반환하고 예외를 발생시킵니다."

#: ../../c-api/unicode.rst:695
#, fuzzy
msgid ""
"Return a substring of *unicode*, from character index *start* (included) "
"to character index *end* (excluded).  Negative indices are not supported."
" On error, set an exception and return ``NULL``."
msgstr ""
"문자 인덱스 *start*\\(포함합니다)에서 문자 인덱스 *end*\\(제외합니다)까지 *str*\\의 하위 문자열을 반환합니다."
" 음수 인덱스는 지원되지 않습니다."

#: ../../c-api/unicode.rst:705
#, fuzzy
msgid ""
"Copy the string *unicode* into a UCS4 buffer, including a null character,"
" if *copy_null* is set.  Returns ``NULL`` and sets an exception on error "
"(in particular, a :exc:`SystemError` if *buflen* is smaller than the "
"length of *unicode*).  *buffer* is returned on success."
msgstr ""
"*copy_null*\\이 설정되면, 널 문자를 포함하여 문자열 *u*\\를 UCS4 버퍼에 복사합니다. 에러 시 "
"``NULL``\\을 반환하고 예외를 설정합니다 (특히, *buflen*\\이 *u*\\의 길이보다 작으면 "
":exc:`SystemError`). 성공하면 *buffer*\\가 반환됩니다."

#: ../../c-api/unicode.rst:715
#, fuzzy
msgid ""
"Copy the string *unicode* into a new UCS4 buffer that is allocated using "
":c:func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a "
":exc:`MemoryError` set.  The returned buffer always has an extra null "
"code point appended."
msgstr ""
"문자열 *u*\\를 :c:func:`PyMem_Malloc`\\을 사용하여 할당된 새 UCS4 버퍼에 복사합니다. 이것이 실패하면,"
" ``NULL``\\이 반환되고 :exc:`MemoryError`\\가 설정됩니다. 반환된 버퍼에는 항상 추가 널 코드 포인트가 "
"있습니다."

#: ../../c-api/unicode.rst:724
msgid "Locale Encoding"
msgstr "로케일 인코딩"

#: ../../c-api/unicode.rst:726
msgid ""
"The current locale encoding can be used to decode text from the operating"
" system."
msgstr "현재 로케일 인코딩을 사용하여 운영 체제에서 온 텍스트를 디코딩 할 수 있습니다."

#: ../../c-api/unicode.rst:733
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses"
" ``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end "
"with a null character but cannot contain embedded null characters."
msgstr ""
"안드로이드와 VxWorks의 UTF-8이나 다른 플랫폼의 현재 로케일 인코딩의 문자열을 디코딩합니다. 지원되는 에러 처리기는 "
"``\"strict\"``\\와 ``\"surrogateescape\"``\\(:pep:`383`)입니다. 디코더는 "
"*errors*\\가 ``NULL``\\이면 ``\"strict\"`` 에러 처리기를 사용합니다. *str*\\은 널 문자로 끝나야"
" 하지만 널 문자를 포함할 수 없습니다."

#: ../../c-api/unicode.rst:740
#, fuzzy
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from "
"the :term:`filesystem encoding and error handler`."
msgstr ""
":c:data:`Py_FileSystemDefaultEncoding`\\(파이썬 시작 시 읽은 로케일 인코딩)에서 문자열을 "
"디코딩하려면 :c:func:`PyUnicode_DecodeFSDefaultAndSize`\\를 사용하십시오."

#: ../../c-api/unicode.rst:743 ../../c-api/unicode.rst:778
#, fuzzy
msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "이 함수는 파이썬 UTF-8 모드를 무시합니다."

#: ../../c-api/unicode.rst:747 ../../c-api/unicode.rst:863
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr ":c:func:`Py_DecodeLocale` 함수."

#: ../../c-api/unicode.rst:751
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_DecodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"이 함수는 이제 안드로이드를 제외하고 ``surrogateescape`` 에러 처리기에 현재 로케일 인코딩도 사용합니다. 이전에는,"
" :c:func:`Py_DecodeLocale`\\이 ``surrogateescape``\\에 사용되었고, 현재 로케일 인코딩은 "
"``strict``\\에 사용되었습니다."

#: ../../c-api/unicode.rst:760
#, fuzzy
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the "
"string length using :c:func:`!strlen`."
msgstr ""
":c:func:`PyUnicode_DecodeLocaleAndSize`\\와 유사하지만, :c:func:`strlen`\\을 "
"사용하여 문자열 길이를 계산합니다."

#: ../../c-api/unicode.rst:768
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the "
"current locale encoding on other platforms. The supported error handlers "
"are ``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder "
"uses ``\"strict\"`` error handler if *errors* is ``NULL``. Return a "
":class:`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"유니코드 객체를 안드로이드와 VxWorks에서 UTF-8로 인코딩하거나, 다른 플랫폼에서 현재 로케일 인코딩으로 인코딩합니다. "
"지원되는 에러 처리기는 ``\"strict\"``\\와 ``\"surrogateescape\"``\\(:pep:`383`)입니다. "
"인코더는 *errors*\\가 ``NULL``\\이면 ``\"strict\"`` 에러 처리기를 사용합니다. "
":class:`bytes` 객체를 반환합니다. *unicode*\\는 내장된 널 문자를 포함할 수 없습니다."

#: ../../c-api/unicode.rst:775
#, fuzzy
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to the "
":term:`filesystem encoding and error handler`."
msgstr ""
"문자열을 :c:data:`Py_FileSystemDefaultEncoding`\\(파이썬 시작 시 읽은 로케일 인코딩)으로 "
"인코딩하려면 :c:func:`PyUnicode_EncodeFSDefault`\\를 사용하십시오."

#: ../../c-api/unicode.rst:782 ../../c-api/unicode.rst:894
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr ":c:func:`Py_EncodeLocale` 함수."

#: ../../c-api/unicode.rst:786
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, "
":c:func:`Py_EncodeLocale` was used for the ``surrogateescape``, and the "
"current locale encoding was used for ``strict``."
msgstr ""
"이 함수는 이제 안드로이드를 제외하고 ``surrogateescape`` 에러 처리기에 현재 로케일 인코딩도 사용합니다. 이전에는 "
":c:func:`Py_EncodeLocale`\\이 ``surrogateescape``\\에 사용되었고, 현재 로케일 인코딩은 "
"``strict``\\에 사용되었습니다."

#: ../../c-api/unicode.rst:795
msgid "File System Encoding"
msgstr "파일 시스템 인코딩"

#: ../../c-api/unicode.rst:797
msgid ""
"Functions encoding to and decoding from the :term:`filesystem encoding "
"and error handler` (:pep:`383` and :pep:`529`)."
msgstr ""

#: ../../c-api/unicode.rst:800
#, fuzzy
msgid ""
"To encode file names to :class:`bytes` during argument parsing, the "
"``\"O&\"`` converter should be used, passing "
":c:func:`!PyUnicode_FSConverter` as the conversion function:"
msgstr ""
"인자 구문 분석 중에 파일 이름을 :class:`str`\\로 디코딩하려면, ``\"O&\"`` 변환기를 사용하고 "
":c:func:`PyUnicode_FSDecoder`\\를 변환 함수로 전달해야 합니다:"

#: ../../c-api/unicode.rst:806
#, fuzzy
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: encode :class:`str` "
"objects -- obtained directly or through the :class:`os.PathLike` "
"interface -- to :class:`bytes` using :c:func:`PyUnicode_EncodeFSDefault`;"
" :class:`bytes` objects are output as-is. *result* must be an address of "
"a C variable of type :c:expr:`PyObject*` (or :c:expr:`PyBytesObject*`). "
"On success, set the variable to a new :term:`strong reference` to a "
":ref:`bytes object <bytesobjects>` which must be released when it is no "
"longer used and return a non-zero value "
"(:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null bytes are not allowed in"
" the result. On failure, return ``0`` with an exception set."
msgstr ""
"ParseTuple 변환기: (직접 또는 :class:`os.PathLike` 인터페이스를 통해 얻은) :class:`str` "
"객체를 :c:func:`PyUnicode_EncodeFSDefault`\\를 사용하여 :class:`bytes`\\로 인코딩합니다;"
" :class:`bytes` 객체는 있는 그대로의 출력입니다. *result*\\는 더는 사용되지 않을 때 해제해야 하는 "
":c:type:`PyBytesObject*`\\여야 합니다."

#: ../../c-api/unicode.rst:818
msgid ""
"If *obj* is ``NULL``, the function releases a strong reference stored in "
"the variable referred by *result* and returns ``1``."
msgstr ""

#: ../../c-api/unicode.rst:823 ../../c-api/unicode.rst:850
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../c-api/unicode.rst:826
#, fuzzy
msgid ""
"To decode file names to :class:`str` during argument parsing, the "
"``\"O&\"`` converter should be used, passing "
":c:func:`!PyUnicode_FSDecoder` as the conversion function:"
msgstr ""
"인자 구문 분석 중에 파일 이름을 :class:`str`\\로 디코딩하려면, ``\"O&\"`` 변환기를 사용하고 "
":c:func:`PyUnicode_FSDecoder`\\를 변환 함수로 전달해야 합니다:"

#: ../../c-api/unicode.rst:832
#, fuzzy
msgid ""
":ref:`PyArg_Parse\\* converter <arg-parsing>`: decode :class:`bytes` "
"objects -- obtained either directly or indirectly through the "
":class:`os.PathLike` interface -- to :class:`str` using "
":c:func:`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` objects are "
"output as-is. *result* must be an address of a C variable of type "
":c:expr:`PyObject*` (or :c:expr:`PyUnicodeObject*`). On success, set the "
"variable to a new :term:`strong reference` to a :ref:`Unicode object "
"<unicodeobjects>` which must be released when it is no longer used and "
"return a non-zero value (:c:macro:`Py_CLEANUP_SUPPORTED`). Embedded null "
"characters are not allowed in the result. On failure, return ``0`` with "
"an exception set."
msgstr ""
"ParseTuple 변환기: (직접 또는 :class:`os.PathLike` 인터페이스를 통해 간접적으로 얻은) "
":class:`bytes` 객체를 :c:func:`PyUnicode_DecodeFSDefaultAndSize`\\를 사용하여 "
":class:`str`\\로 디코딩합니다; :class:`str` 객체는 있는 그대로의 출력입니다. *result*\\는 더는 "
"사용되지 않을 때 해제해야 하는 :c:type:`PyUnicodeObject*`\\여야 합니다."

#: ../../c-api/unicode.rst:845
msgid ""
"If *obj* is ``NULL``, release the strong reference to the object referred"
" to by *result* and return ``1``."
msgstr ""

#: ../../c-api/unicode.rst:856
msgid "Decode a string from the :term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/unicode.rst:858
#, fuzzy
msgid ""
"If you need to decode a string from the current locale encoding, use "
":c:func:`PyUnicode_DecodeLocaleAndSize`."
msgstr ""
":c:data:`Py_FileSystemDefaultEncoding` 은 시작 시 로케일 인코딩에서 초기화되며 나중에 수정할 수 "
"없습니다. 현재 로케일 인코딩에서 문자열을 디코딩해야 하면, "
":c:func:`PyUnicode_DecodeLocaleAndSize`\\를 사용하십시오."

#: ../../c-api/unicode.rst:865 ../../c-api/unicode.rst:878
#: ../../c-api/unicode.rst:898
msgid ""
"The :term:`filesystem error handler <filesystem encoding and error "
"handler>` is now used."
msgstr ""

#: ../../c-api/unicode.rst:872
#, fuzzy
msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr ""
":c:data:`Py_FileSystemDefaultEncoding` 과 "
":c:data:`Py_FileSystemDefaultEncodeErrors` 에러 처리기를 사용하여 널 종료 문자열을 디코딩합니다."

#: ../../c-api/unicode.rst:875
#, fuzzy
msgid ""
"If the string length is known, use "
":c:func:`PyUnicode_DecodeFSDefaultAndSize`."
msgstr "문자열 길이를 알고 있으면 :c:func:`PyUnicode_DecodeFSDefaultAndSize`\\를 사용하십시오."

#: ../../c-api/unicode.rst:885
#, fuzzy
msgid ""
"Encode a Unicode object to the :term:`filesystem encoding and error "
"handler`, and return :class:`bytes`. Note that the resulting "
":class:`bytes` object can contain null bytes."
msgstr ""
":c:data:`Py_FileSystemDefaultEncodeErrors` 에러 처리기를 사용하여 유니코드 객체를 "
":c:data:`Py_FileSystemDefaultEncoding`\\로 인코딩하고, :class:`bytes`\\를 반환합니다."
" 결과 :class:`bytes` 객체에는 널 바이트가 포함될 수 있음에 유의하십시오."

#: ../../c-api/unicode.rst:889
#, fuzzy
msgid ""
"If you need to encode a string to the current locale encoding, use "
":c:func:`PyUnicode_EncodeLocale`."
msgstr ""
":c:data:`Py_FileSystemDefaultEncoding` 은 시작 시 로케일 인코딩에서 초기화되며 나중에 수정할 수 "
"없습니다. 현재 로케일 인코딩으로 문자열을 인코딩해야 하면, :c:func:`PyUnicode_EncodeLocale`\\을 "
"사용하십시오."

#: ../../c-api/unicode.rst:903
msgid "wchar_t Support"
msgstr "wchar_t 지원"

#: ../../c-api/unicode.rst:905
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr "지원하는 플랫폼에 대한 :c:type:`wchar_t` 지원:"

#: ../../c-api/unicode.rst:909
#, fuzzy
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *wstr* of the "
"given *size*. Passing ``-1`` as the *size* indicates that the function "
"must itself compute the length, using :c:func:`!wcslen`. Return ``NULL`` "
"on failure."
msgstr ""
"주어진 *size*\\의 :c:type:`wchar_t` 버퍼 *w*\\에서 유니코드 객체를 만듭니다. ``-1``\\을 "
"*size*\\로 전달하면 함수가 wcslen을 사용하여 길이를 스스로 계산해야 함을 나타냅니다. 실패하면 ``NULL``\\을 "
"반환합니다."

#: ../../c-api/unicode.rst:917
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer "
"*wstr*.  At most *size* :c:type:`wchar_t` characters are copied "
"(excluding a possibly trailing null termination character).  Return the "
"number of :c:type:`wchar_t` characters copied or ``-1`` in case of an "
"error."
msgstr ""

#: ../../c-api/unicode.rst:922
msgid ""
"When *wstr* is ``NULL``, instead return the *size* that would be required"
" to store all of *unicode* including a terminating null."
msgstr ""

#: ../../c-api/unicode.rst:925
#, fuzzy
msgid ""
"Note that the resulting :c:expr:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the"
" :c:expr:`wchar_t*` string is null-terminated in case this is required by"
" the application. Also, note that the :c:expr:`wchar_t*` string might "
"contain null characters, which would cause the string to be truncated "
"when used with most C functions."
msgstr ""
"유니코드 객체 내용을 :c:type:`wchar_t` 버퍼 *w*\\에 복사합니다. 최대 *size* "
":c:type:`wchar_t` 문자가 복사됩니다 (후행 널 종료 문자가 제외될 수 있습니다). 복사된 "
":c:type:`wchar_t` 문자 수나 에러가 발생하면 ``-1``\\을 반환합니다. 결과 :c:type:`wchar_t*` "
"문자열은 널로 종료될 수도 있고 아닐 수도 있음에 유의하십시오. 응용 프로그램에 필요하면 :c:type:`wchar_t*` 문자열이"
" 널로 끝나는지 확인하는 것은 호출자의 책임입니다. 또한, :c:type:`wchar_t*` 문자열에는 널 문자가 포함될 수 "
"있으며, 이로 인해 대부분의 C 함수와 함께 사용될 때 문자열이 잘리게 됨에 유의하십시오."

#: ../../c-api/unicode.rst:935
#, fuzzy
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` "
"string might contain null characters, which would cause the string to be "
"truncated when used with most C functions. If *size* is ``NULL`` and the "
":c:expr:`wchar_t*` string contains null characters a :exc:`ValueError` is"
" raised."
msgstr ""
"유니코드 객체를 와이드 문자 문자열로 변환합니다. 출력 문자열은 항상 널 문자로 끝납니다. *size*\\가 ``NULL``\\이 "
"아니면, (후행 널 종료 문자를 제외한) 와이드 문자의 수를 *\\*size*\\에 씁니다. 결과 :c:type:`wchar_t` "
"문자열이 널 문자를 포함할 수 있고, 이로 인해 대부분의 C 함수와 함께 사용될 때 문자열이 잘리게 됨에 유의하십시오. "
"*size*\\가 ``NULL``\\이고 :c:type:`wchar_t*` 문자열이 널 문자를 포함하면 "
":exc:`ValueError`\\가 발생합니다."

#: ../../c-api/unicode.rst:943
#, fuzzy
msgid ""
"Returns a buffer allocated by :c:macro:`PyMem_New` (use "
":c:func:`PyMem_Free` to free it) on success. On error, returns ``NULL`` "
"and *\\*size* is undefined. Raises a :exc:`MemoryError` if memory "
"allocation is failed."
msgstr ""
"성공 시 :c:func:`PyMem_Alloc`\\에 의해 할당된 버퍼를 반환합니다 (:c:func:`PyMem_Free`\\를 "
"사용하여 해제하십시오). 에러 시, ``NULL``\\을 반환하고 *\\*size*\\는 정의되지 않습니다. 메모리 할당이 실패하면"
" :exc:`MemoryError`\\를 발생시킵니다."

#: ../../c-api/unicode.rst:950
#, fuzzy
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the "
":c:expr:`wchar_t*` string contains null characters."
msgstr ""
"*size*\\가 ``NULL``\\이고 :c:type:`wchar_t*` 문자열이 널 문자를 포함하면 "
":exc:`ValueError`\\를 발생시킵니다."

#: ../../c-api/unicode.rst:958
msgid "Built-in Codecs"
msgstr "내장 코덱"

#: ../../c-api/unicode.rst:960
msgid ""
"Python provides a set of built-in codecs which are written in C for "
"speed. All of these codecs are directly usable via the following "
"functions."
msgstr "파이썬은 속도를 위해 C로 작성된 내장 코덱 집합을 제공합니다. 이러한 코덱들은 모두 다음 함수들을 통해 직접 사용할 수 있습니다."

#: ../../c-api/unicode.rst:963
msgid ""
"Many of the following APIs take two arguments encoding and errors, and "
"they have the same semantics as the ones of the built-in :func:`str` "
"string object constructor."
msgstr ""
"다음 API의 대부분은 두 개의 인자 encoding과 errors를 취하며, 내장 :func:`str` 문자열 객체 생성자의 "
"것들과 같은 의미입니다."

#: ../../c-api/unicode.rst:967
#, fuzzy
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which"
" is UTF-8.  The file system calls should use "
":c:func:`PyUnicode_FSConverter` for encoding file names. This uses the "
":term:`filesystem encoding and error handler` internally."
msgstr ""
"encoding을 ``NULL``\\로 설정하면 기본 인코딩인 UTF-8이 사용됩니다. 파일 시스템 호출은 파일 이름 인코딩에 "
":c:func:`PyUnicode_FSConverter`\\를 사용해야 합니다. 이것은 내부적으로 변수 "
":c:data:`Py_FileSystemDefaultEncoding` 을 사용합니다. 이 변수는 읽기 전용으로 처리되어야 합니다: "
"일부 시스템에서는 정적 문자열에 대한 포인터가 되고, 다른 시스템에서는 실행 시간에 변경됩니다 (가령 응용 프로그램이 "
"setlocale을 호출할 때)."

#: ../../c-api/unicode.rst:972
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning"
" to use the default handling defined for the codec.  Default error "
"handling for all built-in codecs is \"strict\" (:exc:`ValueError` is "
"raised)."
msgstr ""
"에러 처리는 errors로 설정되는데, 코덱에 대해 정의된 기본 처리를 사용함을 의미하는 ``NULL``\\로 설정될 수도 "
"있습니다. 모든 내장 코덱에 대한 기본 에러 처리는 \"strict\" 입니다 (:exc:`ValueError`\\가 발생합니다)."

#: ../../c-api/unicode.rst:976
#, fuzzy
msgid ""
"The codecs all use a similar interface.  Only deviations from the "
"following generic ones are documented for simplicity."
msgstr "코덱은 모두 유사한 인터페이스를 사용합니다. 단순성을 위해 다음에 나오는 일반 코덱과의 차이만 설명합니다."

#: ../../c-api/unicode.rst:981
msgid "Generic Codecs"
msgstr "일반 코덱"

#: ../../c-api/unicode.rst:983
msgid "These are the generic codec APIs:"
msgstr "다음은 일반 코덱 API입니다:"

#: ../../c-api/unicode.rst:989
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str*. *encoding* and *errors* have the same meaning as the parameters of"
" the same name in the :func:`str` built-in function.  The codec to be "
"used is looked up using the Python codec registry.  Return ``NULL`` if an"
" exception was raised by the codec."
msgstr ""
"인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. *encoding*\\과 "
"*errors*\\는 :func:`str` 내장 함수의 같은 이름의 매개 변수와 같은 의미입니다. 사용할 코덱은 파이썬 코덱 "
"레지스트리를 사용하여 조회됩니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:999
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the "
"same name in the Unicode :meth:`~str.encode` method. The codec to be used"
" is looked up using the Python codec registry. Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. *encoding*\\과 *errors*\\는 유니코드 "
":meth:`~str.encode` 메서드의 같은 이름의 매개 변수와 같은 의미입니다. 사용할 코덱은 파이썬 코덱 레지스트리를 "
"사용하여 조회됩니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1007
msgid "UTF-8 Codecs"
msgstr "UTF-8 코덱"

#: ../../c-api/unicode.rst:1009
msgid "These are the UTF-8 codec APIs:"
msgstr "다음은 UTF-8 코덱 API입니다:"

#: ../../c-api/unicode.rst:1014
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded "
"string *str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"UTF-8로 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1021
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If"
" *consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences "
"will not be treated as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"*consumed*\\가 ``NULL``\\이면, :c:func:`PyUnicode_DecodeUTF8`\\처럼 동작합니다. "
"*consumed*\\가 ``NULL``\\이 아니면, 후행 불완전한 UTF-8 바이트 시퀀스는 에러로 처리되지 않습니다. 이러한 "
"바이트는 디코딩되지 않으며 디코딩된 바이트 수는 *consumed*\\에 저장됩니다."

#: ../../c-api/unicode.rst:1029
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes"
" object.  Error handling is \"strict\".  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"UTF-8을 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 \"strict\" "
"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1033 ../../c-api/unicode.rst:1048
msgid ""
"The function fails if the string contains surrogate code points "
"(``U+D800`` - ``U+DFFF``)."
msgstr ""

#: ../../c-api/unicode.rst:1039
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store "
"the size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The "
"returned buffer always has an extra null byte appended (not included in "
"*size*), regardless of whether there are any other null code points."
msgstr ""
"유니코드 객체의 UTF-8 인코딩에 대한 포인터를 반환하고, 인코딩된 표현의 크기를 (바이트 단위로) *size*\\에 저장합니다."
" *size* 인자는 ``NULL``\\일 수 있습니다; 이 경우 크기가 저장되지 않습니다. 반환된 버퍼에는 다른 널 코드 포인트가"
" 있는지에 관계없이, 항상 추가 널 바이트가 추가됩니다 (*size*\\에 포함되지 않습니다)."

#: ../../c-api/unicode.rst:1045
msgid ""
"On error, set an exception, set *size* to ``-1`` (if it's not NULL) and "
"return ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:1051
#, fuzzy
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object,"
" and subsequent calls will return a pointer to the same buffer.  The "
"caller is not responsible for deallocating the buffer. The buffer is "
"deallocated and pointers to it become invalid when the Unicode object is "
"garbage collected."
msgstr ""
"이것은 유니코드 객체에서 문자열의 UTF-8 표현을 캐시하고, 후속 호출은 같은 버퍼에 대한 포인터를 반환합니다. 호출자는 버퍼 "
"할당 해제에 대한 책임이 없습니다."

#: ../../c-api/unicode.rst:1058 ../../c-api/unicode.rst:1080
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "반환형은 이제 ``char *``\\가 아니라 ``const char *``\\입니다."

#: ../../c-api/unicode.rst:1061
msgid "This function is a part of the :ref:`limited API <limited-c-api>`."
msgstr ""

#: ../../c-api/unicode.rst:1067
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr ":c:func:`PyUnicode_AsUTF8AndSize`\\와 같지만, 크기를 저장하지 않습니다."

#: ../../c-api/unicode.rst:1071
msgid ""
"This function does not have any special behavior for `null characters "
"<https://en.wikipedia.org/wiki/Null_character>`_ embedded within "
"*unicode*. As a result, strings containing null characters will remain in"
" the returned string, which some C functions might interpret as the end "
"of the string, leading to truncation. If truncation is an issue, it is "
"recommended to use :c:func:`PyUnicode_AsUTF8AndSize` instead."
msgstr ""

#: ../../c-api/unicode.rst:1085
msgid "UTF-32 Codecs"
msgstr "UTF-32 코덱"

#: ../../c-api/unicode.rst:1087
msgid "These are the UTF-32 codec APIs:"
msgstr "다음은 UTF-32 코덱 API입니다:"

#: ../../c-api/unicode.rst:1093
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the "
"error handling. It defaults to \"strict\"."
msgstr ""
"UTF-32로 인코딩된 버퍼 문자열에서 *size* 바이트를 디코딩하고 해당 유니코드 객체를 반환합니다. "
"*errors*\\(``NULL``\\이 아니면)는 에러 처리를 정의합니다. 기본값은 \"strict\"입니다."

#: ../../c-api/unicode.rst:1097 ../../c-api/unicode.rst:1147
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the "
"given byte order::"
msgstr "*byteorder*\\가 ``NULL``\\이 아니면, 디코더는 지정된 바이트 순서를 사용하여 디코딩을 시작합니다::"

#: ../../c-api/unicode.rst:1100 ../../c-api/unicode.rst:1150
msgid ""
"*byteorder == -1: little endian\n"
"*byteorder == 0:  native order\n"
"*byteorder == 1:  big endian"
msgstr ""

#: ../../c-api/unicode.rst:1104
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are"
" a byte order mark (BOM), the decoder switches to this byte order and the"
" BOM is not copied into the resulting Unicode string.  If ``*byteorder`` "
"is ``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"``*byteorder``\\가 0이고, 입력 데이터의 처음 4바이트가 바이트 순서 표시(BOM)이면, 디코더가 이 바이트 순서로 "
"전환되고 BOM은 결과 유니코드 문자열에 복사되지 않습니다. ``*byteorder``\\가 ``-1``\\이나 ``1``\\이면,"
" 모든 바이트 순서 표시가 출력에 복사됩니다."

#: ../../c-api/unicode.rst:1109
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the "
"end of input data."
msgstr "완료 후, *\\*byteorder*\\는 입력 데이터의 끝에서 현재 바이트 순서로 설정됩니다."

#: ../../c-api/unicode.rst:1112 ../../c-api/unicode.rst:1163
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr "*byteorder*\\가 ``NULL``\\이면, 코덱은 네이티브 순서 모드로 시작합니다."

#: ../../c-api/unicode.rst:1114 ../../c-api/unicode.rst:1165
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1120
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. "
"If *consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` "
"will not treat trailing incomplete UTF-32 byte sequences (such as a "
"number of bytes not divisible by four) as an error. Those bytes will not "
"be decoded and the number of bytes that have been decoded will be stored "
"in *consumed*."
msgstr ""
"*consumed*\\가 ``NULL``\\이면, :c:func:`PyUnicode_DecodeUTF32`\\처럼 동작합니다. "
"*consumed*\\가 ``NULL``\\이 아니면, :c:func:`PyUnicode_DecodeUTF32Stateful` 은 "
"후행 불완전 UTF-32 바이트 시퀀스(가령 4로 나누어떨어지지 않는 바이트 수)를 에러로 처리하지 않습니다. 이러한 바이트는 "
"디코딩되지 않으며 디코딩된 바이트 수는 *consumed*\\에 저장됩니다."

#: ../../c-api/unicode.rst:1129
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte "
"order. The string always starts with a BOM mark.  Error handling is "
"\"strict\". Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"네이티브 바이트 순서로 UTF-32 인코딩을 사용하여 파이썬 바이트 문자열을 반환합니다. 문자열은 항상 BOM 마크로 시작합니다. "
"에러 처리는 \"strict\"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1135
msgid "UTF-16 Codecs"
msgstr "UTF-16 코덱"

#: ../../c-api/unicode.rst:1137
msgid "These are the UTF-16 codec APIs:"
msgstr "다음은 UTF-16 코덱 API입니다:"

#: ../../c-api/unicode.rst:1143
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the "
"error handling. It defaults to \"strict\"."
msgstr ""
"UTF-16으로 인코딩된 버퍼 문자열에서 *size* 바이트를 디코딩하고 해당 유니코드 객체를 반환합니다. "
"*errors*\\(``NULL``\\이 아니면)는 에러 처리를 정의합니다. 기본값은 \"strict\"입니다."

#: ../../c-api/unicode.rst:1154
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are "
"a byte order mark (BOM), the decoder switches to this byte order and the "
"BOM is not copied into the resulting Unicode string.  If ``*byteorder`` "
"is ``-1`` or ``1``, any byte order mark is copied to the output (where it"
" will result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"``*byteorder``\\가 0이고, 입력 데이터의 처음 2바이트가 바이트 순서 표시(BOM)이면, 디코더는 이 바이트 순서로 "
"전환되고 BOM은 결과 유니코드 문자열에 복사되지 않습니다. ``*byteorder``\\가 ``-1``\\이나 ``1``\\이면 "
"모든 바이트 순서 표시가 출력에 복사됩니다 (``\\ufeff``\\나 ``\\ufffe`` 문자가 됩니다)."

#: ../../c-api/unicode.rst:1160
#, fuzzy
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the "
"end of input data."
msgstr "완료 후, *\\*byteorder*\\는 입력 데이터의 끝에서 현재 바이트 순서로 설정됩니다."

#: ../../c-api/unicode.rst:1171
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. "
"If *consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` "
"will not treat trailing incomplete UTF-16 byte sequences (such as an odd "
"number of bytes or a split surrogate pair) as an error. Those bytes will "
"not be decoded and the number of bytes that have been decoded will be "
"stored in *consumed*."
msgstr ""
"*consumed*\\가 ``NULL``\\이면, :c:func:`PyUnicode_DecodeUTF16`\\처럼 동작합니다. "
"*consumed*\\가 ``NULL``\\이 아니면, :c:func:`PyUnicode_DecodeUTF16Stateful` 은 "
"후행 불완전 UTF-16 바이트 시퀀스(가령 홀수 바이트 수나 분할 서로게이트 쌍)를 에러로 처리하지 않습니다. 이러한 바이트는 "
"디코딩되지 않으며 디코딩된 바이트 수는 *consumed*\\에 저장됩니다."

#: ../../c-api/unicode.rst:1180
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte "
"order. The string always starts with a BOM mark.  Error handling is "
"\"strict\". Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"네이티브 바이트 순서로 UTF-16 인코딩을 사용하여 파이썬 바이트 문자열을 반환합니다. 문자열은 항상 BOM 마크로 시작합니다. "
"에러 처리는 \"strict\"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1186
msgid "UTF-7 Codecs"
msgstr "UTF-7 코덱"

#: ../../c-api/unicode.rst:1188
msgid "These are the UTF-7 codec APIs:"
msgstr "다음은 UTF-7 코덱 API입니다:"

#: ../../c-api/unicode.rst:1193
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"UTF-7로 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1200
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  "
"If *consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections"
" will not be treated as an error.  Those bytes will not be decoded and "
"the number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"*consumed*\\가 ``NULL``\\이면, :c:func:`PyUnicode_DecodeUTF7`\\처럼 동작합니다. "
"*consumed*\\가 ``NULL``\\이 아니면, 후행 불완전한 UTF-7 base-64 섹션은 에러로 처리되지 않습니다. "
"이러한 바이트는 디코딩되지 않으며 디코딩된 바이트 수는 *consumed*\\에 저장됩니다."

#: ../../c-api/unicode.rst:1207
msgid "Unicode-Escape Codecs"
msgstr "유니코드 이스케이프 코덱"

#: ../../c-api/unicode.rst:1209
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "다음은 \"유니코드 이스케이프(Unicode Escape)\" 코덱 API입니다:"

#: ../../c-api/unicode.rst:1215
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"유니코드 이스케이프 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면"
" ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1221
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"유니코드 이스케이프를 사용하여 유니코드 객체를 인코딩하고 결과를 bytes 객체로 반환합니다. 에러 처리는 "
"\"strict\"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1227
msgid "Raw-Unicode-Escape Codecs"
msgstr "원시 유니코드 이스케이프 코덱"

#: ../../c-api/unicode.rst:1229
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "다음은 \"원시 유니코드 이스케이프(Raw Unicode Escape)\" 코덱 API입니다:"

#: ../../c-api/unicode.rst:1235
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-"
"Escape encoded string *str*.  Return ``NULL`` if an exception was raised "
"by the codec."
msgstr ""
"원시 유니코드 이스케이프 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 "
"발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1241
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as"
" a bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"원시 유니코드 이스케이프를 사용하여 유니코드 객체를 인코딩하고 결과를 bytes 객체로 반환합니다. 에러 처리는 "
"\"strict\"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1247
msgid "Latin-1 Codecs"
msgstr "Latin-1 코덱"

#: ../../c-api/unicode.rst:1249
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during "
"encoding."
msgstr ""
"다음은 Latin-1 코덱 API입니다: Latin-1은 처음 256개의 유니코드 서수에 해당하며 인코딩 중에 코덱에서 이들만 "
"허용됩니다."

#: ../../c-api/unicode.rst:1255
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Latin-1 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1261
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Latin-1을 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 "
"\"strict\"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1267
msgid "ASCII Codecs"
msgstr "ASCII 코덱"

#: ../../c-api/unicode.rst:1269
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr "다음은 ASCII 코덱 API입니다. 7비트 ASCII 데이터만 허용됩니다. 다른 모든 코드는 에러를 생성합니다."

#: ../../c-api/unicode.rst:1275
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"ASCII 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1281
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes"
" object.  Error handling is \"strict\".  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"ASCII를 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 \"strict\"입니다."
" 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1287
msgid "Character Map Codecs"
msgstr "문자 맵 코덱"

#: ../../c-api/unicode.rst:1289
#, fuzzy
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`!encodings` package). The codec uses "
"mappings to encode and decode characters.  The mapping objects provided "
"must support the :meth:`~object.__getitem__` mapping interface; "
"dictionaries and sequences work well."
msgstr ""
"이 코덱은 다양한 코덱을 구현하는 데 사용할 수 있다는 점에서 특별합니다 (실제로 :mod:`encodings` 패키지에 포함된 "
"대부분의 표준 코덱을 얻기 위해 수행되었습니다). 코덱은 매핑을 사용하여 문자를 인코딩하고 디코딩합니다. 제공된 매핑 객체는 "
":meth:`__getitem__` 매핑 인터페이스를 지원해야 합니다; 딕셔너리와 시퀀스가 잘 작동합니다."

#: ../../c-api/unicode.rst:1295
msgid "These are the mapping codec APIs:"
msgstr "다음은 매핑 코덱 API입니다:"

#: ../../c-api/unicode.rst:1300
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str* using the given *mapping* object.  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"주어진 *mapping* 객체를 사용하여 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. "
"코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1304
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else "
"*mapping* must map bytes ordinals (integers in the range from 0 to 255) "
"to Unicode strings, integers (which are then interpreted as Unicode "
"ordinals) or ``None``.  Unmapped data bytes -- ones which cause a "
":exc:`LookupError`, as well as ones which get mapped to ``None``, "
"``0xFFFE`` or ``'\\ufffe'``, are treated as undefined mappings and cause "
"an error."
msgstr ""
"*mapping*\\이 ``NULL``\\이면, Latin-1 디코딩이 적용됩니다. 그렇지 않으면 *mapping*\\은 바이트 "
"서수(0에서 255 사이의 정수)를 유니코드 문자열, 정수(유니코드 서수로 해석됩니다) 또는 ``None``\\으로 매핑해야합니다."
" 매핑되지 않은 데이터 바이트(``None``, ``0xFFFE`` 또는 ``'\\ufffe'``\\로 매핑되는 것뿐만 아니라, "
":exc:`LookupError`\\를 유발하는 것)은 정의되지 않은 매핑으로 처리되어 에러를 발생시킵니다."

#: ../../c-api/unicode.rst:1315
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL``"
" if an exception was raised by the codec."
msgstr ""
"주어진 *mapping* 객체를 사용하여 유니코드 객체를 인코딩하고 결과를 bytes 객체로 반환합니다. 에러 처리는 "
"\"strict\"입니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1319
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"*mapping* 객체는 유니코드 서수 정수를 bytes 객체, 0에서 255 사이의 정수 또는 ``None``\\으로 매핑해야 "
"합니다. ``None``\\에 매핑되는 것뿐만 아니라 매핑되지 않은 문자 서수(:exc:`LookupError`\\를 유발하는 "
"것)는 \"정의되지 않은 매핑\"으로 처리되어 에러가 발생합니다."

#: ../../c-api/unicode.rst:1325
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr "다음 코덱 API는 유니코드를 유니코드로 매핑한다는 점에서 특별합니다."

#: ../../c-api/unicode.rst:1329
msgid ""
"Translate a string by applying a character mapping table to it and return"
" the resulting Unicode object. Return ``NULL`` if an exception was raised"
" by the codec."
msgstr ""
"문자 매핑 테이블을 적용하여 문자열을 변환하고 결과 유니코드 객체를 반환합니다. 코덱에서 예외가 발생하면 ``NULL``\\을 "
"반환합니다."

#: ../../c-api/unicode.rst:1333
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr "매핑 테이블은 유니코드 서수 정수를 유니코드 서수 정수나 ``None``\\(문자가 삭제되도록 합니다)에 매핑해야 합니다."

#: ../../c-api/unicode.rst:1336
#, fuzzy
msgid ""
"Mapping tables need only provide the :meth:`~object.__getitem__` "
"interface; dictionaries and sequences work well.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) are left untouched and "
"are copied as-is."
msgstr ""
"매핑 테이블은 :meth:`__getitem__` 인터페이스 만 제공하면 됩니다; 딕셔너리와 시퀀스가 잘 작동합니다. 매핑되지 않은"
" 문자 서수(:exc:`LookupError`\\를 유발하는 것)는 건드리지 않고 그대로 복사됩니다."

#: ../../c-api/unicode.rst:1340
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr "*errors*\\는 코덱에서의 일반적인 의미입니다. 기본 에러 처리를 사용함을 나타내는 ``NULL``\\일 수 있습니다."

#: ../../c-api/unicode.rst:1345
msgid "MBCS codecs for Windows"
msgstr "윈도우 용 MBCS 코덱"

#: ../../c-api/unicode.rst:1347
msgid ""
"These are the MBCS codec APIs. They are currently only available on "
"Windows and use the Win32 MBCS converters to implement the conversions.  "
"Note that MBCS (or DBCS) is a class of encodings, not just one.  The "
"target encoding is defined by the user settings on the machine running "
"the codec."
msgstr ""
"다음은 MBCS 코덱 API입니다. 현재 윈도우에서만 사용할 수 있으며 Win32 MBCS 변환기를 사용하여 변환을 구현합니다. "
"MBCS(또는 DBCS)는 단지 하나가 아니라 인코딩 클래스임에 유의하십시오. 대상 인코딩은 코덱을 실행하는 기계의 사용자 설정에 "
"의해 정의됩니다."

#: ../../c-api/unicode.rst:1354
#, fuzzy
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded "
"string *str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"MBCS 인코딩된 문자열 *s*\\의 *size* 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1361
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If"
" *consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will "
"not decode trailing lead byte and the number of bytes that have been "
"decoded will be stored in *consumed*."
msgstr ""
"*consumed*\\가 ``NULL``\\이면, :c:func:`PyUnicode_DecodeMBCS`\\처럼 동작합니다. "
"*consumed*\\가 ``NULL``\\이 아니면, :c:func:`PyUnicode_DecodeMBCSStateful` 은 "
"후행 선행(lead) 바이트를 디코딩하지 않고 디코딩된 바이트 수가 *consumed*\\에 저장됩니다."

#: ../../c-api/unicode.rst:1370
msgid ""
"Similar to :c:func:`PyUnicode_DecodeMBCSStateful`, except uses the code "
"page specified by *code_page*."
msgstr ""

#: ../../c-api/unicode.rst:1376
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"MBCS를 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 \"strict\"입니다. "
"코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1383
#, fuzzy
msgid ""
"Encode the Unicode object using the specified code page and return a "
"Python bytes object.  Return ``NULL`` if an exception was raised by the "
"codec. Use :c:macro:`!CP_ACP` code page to get the MBCS encoder."
msgstr ""
"지정된 코드 페이지를 사용하여 유니코드 객체를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 "
"``NULL``\\을 반환합니다. :c:data:`CP_ACP` 코드 페이지를 사용하여 MBCS 인코더를 얻습니다."

#: ../../c-api/unicode.rst:1391
msgid "Methods & Slots"
msgstr "메서드와 슬롯"

#: ../../c-api/unicode.rst:1397
msgid "Methods and Slot Functions"
msgstr "메서드와 슬롯 함수"

#: ../../c-api/unicode.rst:1399
msgid ""
"The following APIs are capable of handling Unicode objects and strings on"
" input (we refer to them as strings in the descriptions) and return "
"Unicode objects or integers as appropriate."
msgstr ""
"다음 API는 입력의 유니코드 객체와 문자열을 (설명에서 문자열이라고 하겠습니다) 처리할 수 있으며 적절하게 유니코드 객체나 정수를"
" 반환합니다."

#: ../../c-api/unicode.rst:1403
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr "예외가 발생하면 모두 ``NULL``\\이나 ``-1``\\을 반환합니다."

#: ../../c-api/unicode.rst:1408
msgid "Concat two strings giving a new Unicode string."
msgstr "두 문자열을 이어붙여 하나의 새로운 유니코드 문자열을 제공합니다."

#: ../../c-api/unicode.rst:1413
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  "
"If negative, no limit is set.  Separators are not included in the "
"resulting list."
msgstr ""
"문자열을 분할하여 유니코드 문자열 리스트를 제공합니다. *sep*\\이 ``NULL``\\이면, 모든 공백 부분 문자열에서 분할이 "
"수행됩니다. 그렇지 않으면, 주어진 구분자에서 분할이 일어납니다. 최대 *maxsplit* 분할이 수행됩니다. 음수이면, 제한이 "
"설정되지 않습니다. 구분자는 결과 리스트에 포함되지 않습니다."

#: ../../c-api/unicode.rst:1418 ../../c-api/unicode.rst:1428
#: ../../c-api/unicode.rst:1449 ../../c-api/unicode.rst:1462
#, fuzzy
msgid "On error, return ``NULL`` with an exception set."
msgstr "코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#: ../../c-api/unicode.rst:1420
msgid "Equivalent to :py:meth:`str.split`."
msgstr ""

#: ../../c-api/unicode.rst:1425
msgid ""
"Similar to :c:func:`PyUnicode_Split`, but splitting will be done "
"beginning at the end of the string."
msgstr ""

#: ../../c-api/unicode.rst:1430
msgid "Equivalent to :py:meth:`str.rsplit`."
msgstr ""

#: ../../c-api/unicode.rst:1435
#, fuzzy
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode "
"strings. CRLF is considered to be one line break.  If *keepends* is "
"``0``, the Line break characters are not included in the resulting "
"strings."
msgstr ""
"줄 바꿈에서 유니코드 문자열을 분할하여, 유니코드 문자열 리스트를 반환합니다. CRLF는 하나의 줄 바꿈으로 간주합니다. "
"*keepend*\\가 ``0``\\이면, 결과 문자열에 줄 바꿈 문자가 포함되지 않습니다."

#: ../../c-api/unicode.rst:1442
msgid ""
"Split a Unicode string at the first occurrence of *sep*, and return a "
"3-tuple containing the part before the separator, the separator itself, "
"and the part after the separator. If the separator is not found, return a"
" 3-tuple containing the string itself, followed by two empty strings."
msgstr ""

#: ../../c-api/unicode.rst:1447 ../../c-api/unicode.rst:1460
msgid "*sep* must not be empty."
msgstr ""

#: ../../c-api/unicode.rst:1451
msgid "Equivalent to :py:meth:`str.partition`."
msgstr ""

#: ../../c-api/unicode.rst:1456
msgid ""
"Similar to :c:func:`PyUnicode_Partition`, but split a Unicode string at "
"the last occurrence of *sep*. If the separator is not found, return a "
"3-tuple containing two empty strings, followed by the string itself."
msgstr ""

#: ../../c-api/unicode.rst:1464
msgid "Equivalent to :py:meth:`str.rpartition`."
msgstr ""

#: ../../c-api/unicode.rst:1469
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr "주어진 *separator*\\를 사용하여 문자열 시퀀스를 연결하고 결과 유니코드 문자열을 반환합니다."

#: ../../c-api/unicode.rst:1476
#, fuzzy
msgid ""
"Return ``1`` if *substr* matches ``unicode[start:end]`` at the given tail"
" end (*direction* == ``-1`` means to do a prefix match, *direction* == "
"``1`` a suffix match), ``0`` otherwise. Return ``-1`` if an error "
"occurred."
msgstr ""
"*substr*\\이 주어진 꼬리 끝에서 (*direction* == ``-1``\\은 접두사 일치를 수행함을 의미하고, "
"*direction* == ``1``\\은 접미사 일치를 의미합니다) ``str[start:end]``\\와 일치하면 "
"``1``\\을 반환합니다, 그렇지 않으면 ``0``\\을 반환합니다. 에러가 발생하면 ``-1``\\을 반환합니다."

#: ../../c-api/unicode.rst:1484
#, fuzzy
msgid ""
"Return the first position of *substr* in ``unicode[start:end]`` using the"
" given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index "
"of the first match; a value of ``-1`` indicates that no match was found, "
"and ``-2`` indicates that an error occurred and an exception has been "
"set."
msgstr ""
"주어진 *direction*\\을 사용하여 (*direction* == ``1``\\은 정방향 검색을 의미하고, "
"*direction* == ``-1``\\은 역방향 검색을 의미합니다) ``str[start:end]``\\에서 "
"*substr*\\의 첫 번째 위치를 반환합니다. 반환 값은 첫 번째 일치의 인덱스입니다; ``-1`` 값은 일치하는 항목이 없음을"
" 나타내고, ``-2``\\는 에러가 발생했고 예외가 설정되었음을 나타냅니다."

#: ../../c-api/unicode.rst:1494
#, fuzzy
msgid ""
"Return the first position of the character *ch* in ``unicode[start:end]``"
" using the given *direction* (*direction* == ``1`` means to do a forward "
"search, *direction* == ``-1`` a backward search).  The return value is "
"the index of the first match; a value of ``-1`` indicates that no match "
"was found, and ``-2`` indicates that an error occurred and an exception "
"has been set."
msgstr ""
"주어진 *direction*\\을 사용하여 (*direction* == ``1``\\은 정방향 검색을 의미하고, "
"*direction* == ``-1``\\은 역방향 검색을 의미합니다) ``str[start:end]``\\에서 문자 *ch*\\의"
" 첫 번째 위치를 반환합니다. 반환 값은 첫 번째 일치의 인덱스입니다; ``-1`` 값은 일치하는 항목이 없음을 나타내고, "
"``-2``\\는 에러가 발생했고 예외가 설정되었음을 나타냅니다."

#: ../../c-api/unicode.rst:1502
#, fuzzy
msgid "*start* and *end* are now adjusted to behave like ``unicode[start:end]``."
msgstr "*start*\\와 *end*\\는 이제 ``str[start:end]``\\처럼 작동하도록 조정됩니다."

#: ../../c-api/unicode.rst:1509
#, fuzzy
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``unicode[start:end]``.  Return ``-1`` if an error occurred."
msgstr ""
"``str[start:end]``\\에서 *substr*\\이 겹치지 않게 등장하는 횟수를 반환합니다. 에러가 발생하면 "
"``-1``\\을 반환합니다."

#: ../../c-api/unicode.rst:1516
#, fuzzy
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *unicode* with "
"*replstr* and return the resulting Unicode object. *maxcount* == ``-1`` "
"means replace all occurrences."
msgstr ""
"*str*\\에서 *substr*\\의 최대 *maxcount* 등장을 *replstr*\\로 바꾸고 결과 유니코드 객체를 "
"반환합니다. *maxcount* == ``-1``\\은 모든 등장을 교체함을 의미합니다."

#: ../../c-api/unicode.rst:1523
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal,"
" and greater than, respectively."
msgstr "두 문자열을 비교하고 각각 작음, 같음, 큼에 대해 ``-1``, ``0``, ``1``\\을 반환합니다."

#: ../../c-api/unicode.rst:1526
msgid ""
"This function returns ``-1`` upon failure, so one should call "
":c:func:`PyErr_Occurred` to check for errors."
msgstr ""
"이 함수는 실패 시 ``-1``\\을 반환하므로, 에러를 확인하기 위해 :c:func:`PyErr_Occurred`\\를 호출해야 "
"합니다."

#: ../../c-api/unicode.rst:1532
msgid ""
"Compare a Unicode object with a char buffer which is interpreted as being"
" UTF-8 or ASCII encoded and return true (``1``) if they are equal, or "
"false (``0``) otherwise. If the Unicode object contains surrogate code "
"points (``U+D800`` - ``U+DFFF``) or the C string is not valid UTF-8, "
"false (``0``) is returned."
msgstr ""

#: ../../c-api/unicode.rst:1539 ../../c-api/unicode.rst:1560
msgid "This function does not raise exceptions."
msgstr "이 함수는 예외를 발생시키지 않습니다."

#: ../../c-api/unicode.rst:1546
#, fuzzy
msgid ""
"Similar to :c:func:`PyUnicode_EqualToUTF8AndSize`, but compute *string* "
"length using :c:func:`!strlen`. If the Unicode object contains null "
"characters, false (``0``) is returned."
msgstr ""
":c:func:`PyUnicode_DecodeLocaleAndSize`\\와 유사하지만, :c:func:`strlen`\\을 "
"사용하여 문자열 길이를 계산합니다."

#: ../../c-api/unicode.rst:1555
#, fuzzy
msgid ""
"Compare a Unicode object, *unicode*, with *string* and return ``-1``, "
"``0``, ``1`` for less than, equal, and greater than, respectively. It is "
"best to pass only ASCII-encoded strings, but the function interprets the "
"input string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""
"유니코드 객체 *uni*\\를 *string*\\과 비교하고 각각 작음, 같음, 큼에 대해 ``-1``, ``0``, "
"``1``\\을 반환합니다. ASCII로 인코딩된 문자열만 전달하는 것이 가장 좋지만, 비 ASCII 문자가 포함되면 함수는 입력 "
"문자열을 ISO-8859-1로 해석합니다."

#: ../../c-api/unicode.rst:1565
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr "두 유니코드 문자열을 풍부한 비교(rich comparison) 하고 다음 중 하나를 반환합니다:"

#: ../../c-api/unicode.rst:1567
msgid "``NULL`` in case an exception was raised"
msgstr "예외가 발생하면 ``NULL``"

#: ../../c-api/unicode.rst:1568
#, fuzzy
msgid ":c:data:`Py_True` or :c:data:`Py_False` for successful comparisons"
msgstr "성공적인 비교는 :const:`Py_True`\\나 :const:`Py_False`"

#: ../../c-api/unicode.rst:1569
#, fuzzy
msgid ":c:data:`Py_NotImplemented` in case the type combination is unknown"
msgstr "형 조합을 알 수 없으면 :const:`Py_NotImplemented`"

#: ../../c-api/unicode.rst:1571
#, fuzzy
msgid ""
"Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, "
":c:macro:`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT`, and "
":c:macro:`Py_LE`."
msgstr ""
"*op*\\에 가능한 값은 :const:`Py_GT`, :const:`Py_GE`, :const:`Py_EQ`, "
":const:`Py_NE`, :const:`Py_LT` 및 :const:`Py_LE`\\입니다."

#: ../../c-api/unicode.rst:1577
msgid ""
"Return a new string object from *format* and *args*; this is analogous to"
" ``format % args``."
msgstr "*format*\\과 *args*\\에서 새 문자열 객체를 반환합니다; 이것은 ``format % args``\\와 유사합니다."

#: ../../c-api/unicode.rst:1583
#, fuzzy
msgid ""
"Check whether *substr* is contained in *unicode* and return true or false"
" accordingly."
msgstr "*element*\\가 *container*\\에 포함되어 있는지 확인하고 그에 따라 참이나 거짓을 반환합니다."

#: ../../c-api/unicode.rst:1586
#, fuzzy
msgid ""
"*substr* has to coerce to a one element Unicode string. ``-1`` is "
"returned if there was an error."
msgstr "*element*\\는 단일 요소 유니코드 문자열로 강제 변환해야 합니다. 에러가 있으면 ``-1``\\이 반환됩니다."

#: ../../c-api/unicode.rst:1592
#, fuzzy
msgid ""
"Intern the argument :c:expr:`*p_unicode` in place.  The argument must be "
"the address of a pointer variable pointing to a Python Unicode string "
"object.  If there is an existing interned string that is the same as "
":c:expr:`*p_unicode`, it sets :c:expr:`*p_unicode` to it (releasing the "
"reference to the old string object and creating a new :term:`strong "
"reference` to the interned string object), otherwise it leaves "
":c:expr:`*p_unicode` alone and interns it."
msgstr ""
"인자 *\\*string*\\을 제자리에서 인턴(intern) 합니다.  인자는 파이썬 유니코드 문자열을 가리키는 포인터 변수의 "
"주소여야 합니다. *\\*string*\\과 같은 기존 인턴 문자열이 있으면, *\\*string*\\을 그것으로 설정합니다 (이전"
" 문자열 객체의 참조 횟수를 감소시키고 인턴 된 문자열 객체의 참조 횟수를 증가시킵니다), 그렇지 않으면 *\\*string*\\만"
" 홀로 두고 인턴 합니다 (참조 횟수를 증가시킵니다). (설명: 참조 횟수에 대해 많은 이야기가 있지만, 이 함수를 참조 횟수 "
"중립이라고 생각하십시오; 호출 전에 소유한 경우에만 호출 후 객체를 소유합니다.)"

#: ../../c-api/unicode.rst:1599
msgid ""
"(Clarification: even though there is a lot of talk about references, "
"think of this function as reference-neutral. You must own the object you "
"pass in; after the call you no longer own the passed-in reference, but "
"you newly own the result.)"
msgstr ""

#: ../../c-api/unicode.rst:1604
msgid ""
"This function never raises an exception. On error, it leaves its argument"
" unchanged without interning it."
msgstr ""

#: ../../c-api/unicode.rst:1607
msgid ""
"Instances of subclasses of :py:class:`str` may not be interned, that is, "
":c:expr:`PyUnicode_CheckExact(*p_unicode)` must be true. If it is not, "
"then -- as with any other error -- the argument is left unchanged."
msgstr ""

#: ../../c-api/unicode.rst:1611
msgid ""
"Note that interned strings are not “immortal”. You must keep a reference "
"to the result to benefit from interning."
msgstr ""

#: ../../c-api/unicode.rst:1617
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace`, meant for statically allocated "
"strings."
msgstr ""

#: ../../c-api/unicode.rst:1620
#, fuzzy
msgid ""
"Return a new (\"owned\") reference to either a new Unicode string object "
"that has been interned, or an earlier interned string object with the "
"same value."
msgstr ""
":c:func:`PyUnicode_FromString`\\과 :c:func:`PyUnicode_InternInPlace`\\의 "
"조합, 인턴(intern) 된 새 유니코드 문자열 객체나, 같은 값을 가진 이전에 인턴 된 문자열 객체에 대한 새 (\"소유된\")"
" 참조를 반환합니다."

#: ../../c-api/unicode.rst:1624
msgid ""
"Python may keep a reference to the result, or make it :term:`immortal`, "
"preventing it from being garbage-collected promptly. For interning an "
"unbounded number of different strings, such as ones coming from user "
"input, prefer calling :c:func:`PyUnicode_FromString` and "
":c:func:`PyUnicode_InternInPlace` directly."
msgstr ""

#: ../../c-api/unicode.rst:1632
msgid "Strings interned this way are made :term:`immortal`."
msgstr ""

#~ msgid ""
#~ ":c:type:`Py_UNICODE*` and UTF-8 representations "
#~ "are created on demand and cached "
#~ "in the Unicode object.  The "
#~ ":c:type:`Py_UNICODE*` representation is deprecated"
#~ " and inefficient."
#~ msgstr ""
#~ ":c:type:`Py_UNICODE*`\\와 UTF-8 표현은 요청 시 "
#~ "만들어지고 유니코드 객체에 캐시 됩니다. "
#~ ":c:type:`Py_UNICODE*` 표현은 폐지되었으며 비효율적입니다."

#~ msgid ""
#~ "Due to the transition between the "
#~ "old APIs and the new APIs, Unicode"
#~ " objects can internally be in two "
#~ "states depending on how they were "
#~ "created:"
#~ msgstr "이전 API와 새 API 간의 전환으로 인해, 유니코드 객체는 만들어진 방법에 따라 내부적으로 두 가지 상태가 될 수 있습니다:"

#~ msgid ""
#~ "\"canonical\" Unicode objects are all "
#~ "objects created by a non-deprecated "
#~ "Unicode API.  They use the most "
#~ "efficient representation allowed by the "
#~ "implementation."
#~ msgstr ""
#~ "\"규범적(canonical)\" 유니코드 객체는 폐지되지 않은 유니코드"
#~ " API에 의해 만들어진 모든 객체입니다. 구현에서 "
#~ "허용하는 가장 효율적인 표현을 사용합니다."

#~ msgid ""
#~ "\"legacy\" Unicode objects have been "
#~ "created through one of the deprecated"
#~ " APIs (typically :c:func:`PyUnicode_FromUnicode`) "
#~ "and only bear the :c:type:`Py_UNICODE*` "
#~ "representation; you will have to call"
#~ " :c:func:`PyUnicode_READY` on them before "
#~ "calling any other API."
#~ msgstr ""
#~ "\"레거시\" 유니코드 객체는 폐지된 API 중 "
#~ "하나(일반적으로 :c:func:`PyUnicode_FromUnicode`)를 통해 만들어지고"
#~ " :c:type:`Py_UNICODE*` 표현만 포함합니다; 다른 API를"
#~ " 호출하기 전에 이들에 대해 "
#~ ":c:func:`PyUnicode_READY`\\를 호출해야 합니다."

#~ msgid ""
#~ "Ensure the string object *o* is in"
#~ " the \"canonical\" representation.  This is"
#~ " required before using any of the "
#~ "access macros described below."
#~ msgstr ""
#~ "문자열 객체 *o*\\가 \"규범적(canonical)\" 표현인지 "
#~ "확인합니다. 이것은 아래에 설명된 액세스 매크로를 사용하기"
#~ " 전에 필요합니다."

#~ msgid ""
#~ "Returns ``0`` on success and ``-1`` "
#~ "with an exception set on failure, "
#~ "which in particular happens if memory"
#~ " allocation fails."
#~ msgstr ""
#~ "성공 시 ``0``\\을 반환하고, 실패 시 예외를 "
#~ "설정하면서 ``-1``\\을 반환하는데, 특히 메모리 할당이 "
#~ "실패하면 발생합니다."

#~ msgid "This API will be removed with :c:func:`PyUnicode_FromUnicode`."
#~ msgstr "이 API는 :c:func:`PyUnicode_FromUnicode`\\와 함께 제거됩니다."

#~ msgid ""
#~ "Return the size of the deprecated "
#~ ":c:type:`Py_UNICODE` representation, in code "
#~ "units (this includes surrogate pairs as"
#~ " 2 units).  *o* has to be a "
#~ "Unicode object (not checked)."
#~ msgstr ""
#~ "폐지된 :c:type:`Py_UNICODE` 표현의 크기를 코드 단위로"
#~ " 반환합니다 (서로게이트 쌍을 2단위로 포함합니다). *o*\\는"
#~ " 유니코드 객체여야 합니다 (검사하지 않습니다)."

#~ msgid ""
#~ "Part of the old-style Unicode API,"
#~ " please migrate to using "
#~ ":c:func:`PyUnicode_GET_LENGTH`."
#~ msgstr ""
#~ "이전 스타일 유니코드 API의 일부입니다, "
#~ ":c:func:`PyUnicode_GET_LENGTH`\\를 사용하여 마이그레이션 하십시오."

#~ msgid ""
#~ "Return the size of the deprecated "
#~ ":c:type:`Py_UNICODE` representation in bytes.  "
#~ "*o* has to be a Unicode object "
#~ "(not checked)."
#~ msgstr ""
#~ "폐지된 :c:type:`Py_UNICODE` 표현의 크기를 바이트 단위로"
#~ " 반환합니다. *o*\\는 유니코드 객체여야 합니다 (검사하지"
#~ " 않습니다)."

#~ msgid ""
#~ "Return a pointer to a "
#~ ":c:type:`Py_UNICODE` representation of the "
#~ "object.  The returned buffer is always"
#~ " terminated with an extra null code"
#~ " point.  It may also contain embedded"
#~ " null code points, which would cause"
#~ " the string to be truncated when "
#~ "used in most C functions.  The "
#~ "``AS_DATA`` form casts the pointer to"
#~ " :c:type:`const char *`.  The *o* "
#~ "argument has to be a Unicode "
#~ "object (not checked)."
#~ msgstr ""
#~ "객체의 :c:type:`Py_UNICODE` 표현에 대한 포인터를 "
#~ "반환합니다. 반환된 버퍼는 항상 추가 널 코드 "
#~ "포인트로 끝납니다. 또한 내장된 널 코드 포인트를 "
#~ "포함할 수 있는데, 대부분의 C 함수에서 사용될 때"
#~ " 문자열이 잘리도록 합니다. ``AS_DATA`` 형식은 포인터를"
#~ " :c:type:`const char *`\\로 캐스트 합니다. "
#~ "*o* 인자는 유니코드 객체여야 합니다 (검사하지 않습니다)."

#~ msgid ""
#~ "This macro is now inefficient -- "
#~ "because in many cases the "
#~ ":c:type:`Py_UNICODE` representation does not "
#~ "exist and needs to be created --"
#~ " and can fail (return ``NULL`` with"
#~ " an exception set).  Try to port "
#~ "the code to use the new "
#~ ":c:func:`PyUnicode_nBYTE_DATA` macros or use "
#~ ":c:func:`PyUnicode_WRITE` or :c:func:`PyUnicode_READ`."
#~ msgstr ""
#~ "이 매크로는 이제 비효율적이고 -- 많은 경우에 "
#~ ":c:type:`Py_UNICODE` 표현이 존재하지 않고 만들어야 해서"
#~ " -- 실패할 수 있습니다 (예외 설정과 함께 "
#~ "``NULL``\\을 반환합니다). 새 :c:func:`PyUnicode_nBYTE_DATA`"
#~ " 매크로를 사용하거나 :c:func:`PyUnicode_WRITE`\\나 "
#~ ":c:func:`PyUnicode_READ`\\를 사용하도록 코드를 이식하십시오."

#~ msgid ""
#~ "Part of the old-style Unicode API,"
#~ " please migrate to using the "
#~ ":c:func:`PyUnicode_nBYTE_DATA` family of macros."
#~ msgstr ""
#~ "이전 스타일 유니코드 API의 일부입니다. "
#~ ":c:func:`PyUnicode_nBYTE_DATA` 매크로 계열을 사용하도록 "
#~ "마이그레이션 하십시오."

#~ msgid ""
#~ "Return ``1`` or ``0`` depending on "
#~ "whether *ch* is a printable character."
#~ " Nonprintable characters are those "
#~ "characters defined in the Unicode "
#~ "character database as \"Other\" or "
#~ "\"Separator\", excepting the ASCII space "
#~ "(0x20) which is considered printable.  "
#~ "(Note that printable characters in this"
#~ " context are those which should not"
#~ " be escaped when :func:`repr` is "
#~ "invoked on a string. It has no "
#~ "bearing on the handling of strings "
#~ "written to :data:`sys.stdout` or "
#~ ":data:`sys.stderr`.)"
#~ msgstr ""
#~ "*ch*\\가 인쇄 가능한 문자인지에 따라 ``1``\\이나 "
#~ "``0``\\을 반환합니다. 인쇄할 수 없는 문자는, 인쇄"
#~ " 가능한 것으로 간주하는 ASCII 스페이스(0x20)를 제외하고,"
#~ " 유니코드 문자 데이터베이스에서 \"Other\"나 \"Separator\"로"
#~ " 정의된 문자입니다. (이 문맥에서 인쇄 가능한 문자는"
#~ " :func:`repr`\\이 문자열에 대해 호출될 때 이스케이프"
#~ " 되지 않아야 하는 문자임에 유의하십시오. "
#~ ":data:`sys.stdout`\\이나 :data:`sys.stderr`\\에 기록된 "
#~ "문자열의 처리와 관련이 없습니다.)"

#~ msgid "This function uses simple case mappings."
#~ msgstr "이 함수는 간단한 케이스 매핑을 사용합니다."

#~ msgid ""
#~ "If *u* is ``NULL``, this function "
#~ "behaves like :c:func:`PyUnicode_FromUnicode` with"
#~ " the buffer set to ``NULL``.  This"
#~ " usage is deprecated in favor of "
#~ ":c:func:`PyUnicode_New`, and will be removed"
#~ " in Python 3.12."
#~ msgstr ""
#~ "*u*\\가 ``NULL``\\이면, 이 함수는 버퍼가 "
#~ "``NULL``\\로 설정된 :c:func:`PyUnicode_FromUnicode`\\처럼 "
#~ "작동합니다. 이 사용법은 폐지되어 :c:func:`PyUnicode_New`\\로"
#~ " 대체되었고, 파이썬 3.12에서 제거됩니다."

#~ msgid "Format Characters"
#~ msgstr "포맷 문자"

#~ msgid ":attr:`%%`"
#~ msgstr ":attr:`%%`"

#~ msgid ":attr:`%c`"
#~ msgstr ":attr:`%c`"

#~ msgid "int"
#~ msgstr "int"

#~ msgid ":attr:`%d`"
#~ msgstr ":attr:`%d`"

#~ msgid "Equivalent to ``printf(\"%d\")``. [1]_"
#~ msgstr "``printf(\"%d\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%u`"
#~ msgstr ":attr:`%u`"

#~ msgid "unsigned int"
#~ msgstr "unsigned int"

#~ msgid "Equivalent to ``printf(\"%u\")``. [1]_"
#~ msgstr "``printf(\"%u\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%ld`"
#~ msgstr ":attr:`%ld`"

#~ msgid "long"
#~ msgstr "long"

#~ msgid "Equivalent to ``printf(\"%ld\")``. [1]_"
#~ msgstr "``printf(\"%ld\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%li`"
#~ msgstr ":attr:`%li`"

#~ msgid "Equivalent to ``printf(\"%li\")``. [1]_"
#~ msgstr "``printf(\"%li\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%lu`"
#~ msgstr ":attr:`%lu`"

#~ msgid "unsigned long"
#~ msgstr "unsigned long"

#~ msgid "Equivalent to ``printf(\"%lu\")``. [1]_"
#~ msgstr "``printf(\"%lu\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%lld`"
#~ msgstr ":attr:`%lld`"

#~ msgid "long long"
#~ msgstr "long long"

#~ msgid "Equivalent to ``printf(\"%lld\")``. [1]_"
#~ msgstr "``printf(\"%lld\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%lli`"
#~ msgstr ":attr:`%lli`"

#~ msgid "Equivalent to ``printf(\"%lli\")``. [1]_"
#~ msgstr "``printf(\"%lli\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%llu`"
#~ msgstr ":attr:`%llu`"

#~ msgid "unsigned long long"
#~ msgstr "unsigned long long"

#~ msgid "Equivalent to ``printf(\"%llu\")``. [1]_"
#~ msgstr "``printf(\"%llu\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%zd`"
#~ msgstr ":attr:`%zd`"

#~ msgid "Py_ssize_t"
#~ msgstr "Py_ssize_t"

#~ msgid "Equivalent to ``printf(\"%zd\")``. [1]_"
#~ msgstr "``printf(\"%zd\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%zi`"
#~ msgstr ":attr:`%zi`"

#~ msgid "Equivalent to ``printf(\"%zi\")``. [1]_"
#~ msgstr "``printf(\"%zi\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%zu`"
#~ msgstr ":attr:`%zu`"

#~ msgid "size_t"
#~ msgstr "size_t"

#~ msgid "Equivalent to ``printf(\"%zu\")``. [1]_"
#~ msgstr "``printf(\"%zu\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%i`"
#~ msgstr ":attr:`%i`"

#~ msgid "Equivalent to ``printf(\"%i\")``. [1]_"
#~ msgstr "``printf(\"%i\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%x`"
#~ msgstr ":attr:`%x`"

#~ msgid "Equivalent to ``printf(\"%x\")``. [1]_"
#~ msgstr "``printf(\"%x\")``\\와 동등합니다. [1]_"

#~ msgid ":attr:`%s`"
#~ msgstr ":attr:`%s`"

#~ msgid "const char\\*"
#~ msgstr "const char\\*"

#~ msgid ":attr:`%p`"
#~ msgstr ":attr:`%p`"

#~ msgid ":attr:`%A`"
#~ msgstr ":attr:`%A`"

#~ msgid ":attr:`%U`"
#~ msgstr ":attr:`%U`"

#~ msgid ":attr:`%V`"
#~ msgstr ":attr:`%V`"

#~ msgid "PyObject\\*, const char\\*"
#~ msgstr "PyObject\\*, const char\\*"

#~ msgid ":attr:`%S`"
#~ msgstr ":attr:`%S`"

#~ msgid ":attr:`%R`"
#~ msgstr ":attr:`%R`"

#~ msgid ""
#~ "For integer specifiers (d, u, ld, "
#~ "li, lu, lld, lli, llu, zd, zi, "
#~ "zu, i, x): the 0-conversion flag "
#~ "has effect even when a precision "
#~ "is given."
#~ msgstr ""
#~ "정수 지정자 (d, u, ld, li, lu, "
#~ "lld, lli, llu, zd, zi, zu, i, "
#~ "x)의 경우: 0-변환 플래그는 정밀도가 제공되는 경우에도"
#~ " 적용됩니다."

#~ msgid "Deprecated Py_UNICODE APIs"
#~ msgstr "폐지된 Py_UNICODE API"

#~ msgid ""
#~ "These API functions are deprecated with"
#~ " the implementation of :pep:`393`. "
#~ "Extension modules can continue using "
#~ "them, as they will not be removed"
#~ " in Python 3.x, but need to be"
#~ " aware that their use can now "
#~ "cause performance and memory hits."
#~ msgstr ""
#~ "이 API 함수들은 :pep:`393` 구현에 의해 "
#~ "폐지되었습니다. 파이썬 3.x에서 제거되지 않기 때문에, 확장"
#~ " 모듈은 계속해서 사용할 수 있지만, 이제 그 "
#~ "사용으로 인해 성능과 메모리 문제가 있을 수 있음을"
#~ " 인식해야 합니다."

#~ msgid ""
#~ "Create a Unicode object from the "
#~ "Py_UNICODE buffer *u* of the given "
#~ "size. *u* may be ``NULL`` which "
#~ "causes the contents to be undefined. "
#~ "It is the user's responsibility to "
#~ "fill in the needed data.  The "
#~ "buffer is copied into the new "
#~ "object."
#~ msgstr ""
#~ "주어진 크기(size)의 Py_UNICODE 버퍼 *u*\\에서 유니코드"
#~ " 객체를 만듭니다. *u*\\는 ``NULL``\\일 수 있으며,"
#~ " 이럴 때는 내용이 정의되지 않습니다. 필요한 데이터를"
#~ " 채우는 것은 사용자의 책임입니다. 버퍼가 새 객체에"
#~ " 복사됩니다."

#~ msgid ""
#~ "If the buffer is not ``NULL``, the"
#~ " return value might be a shared "
#~ "object. Therefore, modification of the "
#~ "resulting Unicode object is only allowed"
#~ " when *u* is ``NULL``."
#~ msgstr ""
#~ "버퍼가 ``NULL``\\이 아니면, 반환 값은 공유 객체일"
#~ " 수 있습니다. 따라서, 결과 유니코드 객체의 수정은"
#~ " *u*\\가 ``NULL``\\일 때만 허용됩니다."

#~ msgid ""
#~ "If the buffer is ``NULL``, "
#~ ":c:func:`PyUnicode_READY` must be called once"
#~ " the string content has been filled"
#~ " before using any of the access "
#~ "macros such as :c:func:`PyUnicode_KIND`."
#~ msgstr ""
#~ "버퍼가 ``NULL``\\이면, :c:func:`PyUnicode_KIND`\\와 같은 "
#~ "액세스 매크로를 사용하기 전에 문자열 내용이 채워지면 "
#~ ":c:func:`PyUnicode_READY`\\를 호출해야 합니다."

#~ msgid ""
#~ "Part of the old-style Unicode API,"
#~ " please migrate to using "
#~ ":c:func:`PyUnicode_FromKindAndData`, "
#~ ":c:func:`PyUnicode_FromWideChar`, or "
#~ ":c:func:`PyUnicode_New`."
#~ msgstr ""
#~ "이전 스타일 유니코드 API의 일부입니다. "
#~ ":c:func:`PyUnicode_FromKindAndData`, "
#~ ":c:func:`PyUnicode_FromWideChar` 또는 "
#~ ":c:func:`PyUnicode_New`\\를 사용하여 마이그레이션 하십시오."

#~ msgid ""
#~ "Return a read-only pointer to the"
#~ " Unicode object's internal :c:type:`Py_UNICODE`"
#~ " buffer, or ``NULL`` on error. This"
#~ " will create the :c:type:`Py_UNICODE*` "
#~ "representation of the object if it "
#~ "is not yet available. The buffer "
#~ "is always terminated with an extra "
#~ "null code point. Note that the "
#~ "resulting :c:type:`Py_UNICODE` string may also"
#~ " contain embedded null code points, "
#~ "which would cause the string to be"
#~ " truncated when used in most C "
#~ "functions."
#~ msgstr ""
#~ "유니코드 객체의 내부 :c:type:`Py_UNICODE` 버퍼에 대한"
#~ " 읽기 전용 포인터를 반환하거나, 에러 시 "
#~ "``NULL``\\을 반환합니다. 아직 사용할 수 없으면 "
#~ "객체의 :c:type:`Py_UNICODE*` 표현을 만듭니다. 버퍼는 "
#~ "항상 여분의 널 코드 포인트로 종료됩니다. 결과 "
#~ ":c:type:`Py_UNICODE` 문자열에는 내장된 널 코드 포인트도"
#~ " 포함될 수 있으며, 이때는 대부분의 C 함수에서 "
#~ "사용될 때 문자열이 잘림에 유의하십시오."

#~ msgid ""
#~ "Part of the old-style Unicode API,"
#~ " please migrate to using "
#~ ":c:func:`PyUnicode_AsUCS4`, :c:func:`PyUnicode_AsWideChar`, "
#~ ":c:func:`PyUnicode_ReadChar` or similar new "
#~ "APIs."
#~ msgstr ""
#~ "이전 스타일 유니코드 API의 일부입니다. "
#~ ":c:func:`PyUnicode_AsUCS4`, :c:func:`PyUnicode_AsWideChar`, "
#~ ":c:func:`PyUnicode_ReadChar` 또는 유사한 새 API를 "
#~ "사용하여 마이그레이션 하십시오."

#~ msgid ""
#~ "Create a Unicode object by replacing "
#~ "all decimal digits in :c:type:`Py_UNICODE` "
#~ "buffer of the given *size* by "
#~ "ASCII digits 0--9 according to "
#~ "their decimal value.  Return ``NULL`` if"
#~ " an exception occurs."
#~ msgstr ""
#~ "주어진 *size*\\의 :c:type:`Py_UNICODE` 버퍼에 있는 "
#~ "모든 10진 숫자들을 10진 값에 따라 ASCII "
#~ "숫자 0--9로 대체하여 유니코드 객체를 만듭니다. "
#~ "예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`Py_UNICODE_TODECIMAL`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`Py_UNICODE_TODECIMAL` 을 사용하여 마이그레이션 "
#~ "하십시오."

#~ msgid ""
#~ "Like :c:func:`PyUnicode_AsUnicode`, but also "
#~ "saves the :c:func:`Py_UNICODE` array length"
#~ " (excluding the extra null terminator) "
#~ "in *size*. Note that the resulting "
#~ ":c:type:`Py_UNICODE*` string may contain "
#~ "embedded null code points, which would"
#~ " cause the string to be truncated "
#~ "when used in most C functions."
#~ msgstr ""
#~ ":c:func:`PyUnicode_AsUnicode`\\와 비슷하지만, "
#~ ":c:func:`Py_UNICODE` 배열 길이(추가 널 종료 제외)를"
#~ " *size*\\에 저장하기도 합니다. 결과 "
#~ ":c:type:`Py_UNICODE*` 문자열에는 내장된 널 코드 "
#~ "포인트가 포함될 수 있으며, 이때는 대부분의 C "
#~ "함수에서 사용될 때 문자열이 잘림에 유의하십시오."

#~ msgid ""
#~ "Create a copy of a Unicode string"
#~ " ending with a null code point. "
#~ "Return ``NULL`` and raise a "
#~ ":exc:`MemoryError` exception on memory "
#~ "allocation failure, otherwise return a "
#~ "new allocated buffer (use :c:func:`PyMem_Free`"
#~ " to free the buffer). Note that "
#~ "the resulting :c:type:`Py_UNICODE*` string may"
#~ " contain embedded null code points, "
#~ "which would cause the string to be"
#~ " truncated when used in most C "
#~ "functions."
#~ msgstr ""
#~ "널 코드 포인트로 끝나는 유니코드 문자열의 복사본을 "
#~ "만듭니다. 메모리 할당 실패 시 ``NULL``\\을 반환하고"
#~ " :exc:`MemoryError` 예외를 발생시킵니다, 그렇지 않으면 "
#~ "새로 할당된 버퍼를 반환합니다 (버퍼를 해제하려면 "
#~ ":c:func:`PyMem_Free`\\를 사용하십시오). 결과 "
#~ ":c:type:`Py_UNICODE*` 문자열에는 내장된 널 코드 "
#~ "포인트가 포함될 수 있으며, 이때는 대부분의 C "
#~ "함수에서 사용될 때 문자열이 잘림에 유의하십시오."

#~ msgid ""
#~ "Please migrate to using "
#~ ":c:func:`PyUnicode_AsUCS4Copy` or similar new "
#~ "APIs."
#~ msgstr ":c:func:`PyUnicode_AsUCS4Copy` 나 유사한 새 API를 사용하여 마이그레이션 하십시오."

#~ msgid ""
#~ "Return the size of the deprecated "
#~ ":c:type:`Py_UNICODE` representation, in code "
#~ "units (this includes surrogate pairs as"
#~ " 2 units)."
#~ msgstr "폐지된 :c:type:`Py_UNICODE` 표현의 크기를 코드 단위로 반환합니다 (서로게이트 쌍을 2단위로 포함합니다)."

#~ msgid ""
#~ "To encode and decode file names "
#~ "and other environment strings, "
#~ ":c:data:`Py_FileSystemDefaultEncoding` should be "
#~ "used as the encoding, and "
#~ ":c:data:`Py_FileSystemDefaultEncodeErrors` should be "
#~ "used as the error handler (:pep:`383`"
#~ " and :pep:`529`). To encode file "
#~ "names to :class:`bytes` during argument "
#~ "parsing, the ``\"O&\"`` converter should "
#~ "be used, passing :c:func:`PyUnicode_FSConverter` "
#~ "as the conversion function:"
#~ msgstr ""
#~ "파일 이름과 기타 환경 문자열을 인코딩하고 디코딩하려면,"
#~ " :c:data:`Py_FileSystemDefaultEncoding` 을 인코딩으로 "
#~ "사용하고, :c:data:`Py_FileSystemDefaultEncodeErrors`\\를 에러 "
#~ "처리기로 사용해야 합니다 (:pep:`383`\\과 :pep:`529`). "
#~ "인자 구문 분석 중에 파일 이름을 "
#~ ":class:`bytes`\\로 인코딩하려면, ``\"O&\"`` 변환기를 사용하고"
#~ " :c:func:`PyUnicode_FSConverter`\\를 변환 함수로 전달해야"
#~ " 합니다:"

#~ msgid ""
#~ "Decode a string using "
#~ ":c:data:`Py_FileSystemDefaultEncoding` and the "
#~ ":c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
#~ msgstr ""
#~ ":c:data:`Py_FileSystemDefaultEncoding` 과 "
#~ ":c:data:`Py_FileSystemDefaultEncodeErrors` 에러 처리기를 "
#~ "사용하여 문자열을 디코딩합니다."

#~ msgid ""
#~ "If :c:data:`Py_FileSystemDefaultEncoding` is not "
#~ "set, fall back to the locale "
#~ "encoding."
#~ msgstr ":c:data:`Py_FileSystemDefaultEncoding` 이 설정되지 않으면, 로케일 인코딩으로 폴백합니다."

#~ msgid "Use :c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
#~ msgstr ":c:data:`Py_FileSystemDefaultEncodeErrors` 에러 처리기를 사용합니다."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer *s* "
#~ "of the given *size* and return a"
#~ " Python bytes object.  *encoding* and "
#~ "*errors* have the same meaning as "
#~ "the parameters of the same name in"
#~ " the Unicode :meth:`~str.encode` method.  "
#~ "The codec to be used is looked "
#~ "up using the Python codec registry.  "
#~ "Return ``NULL`` if an exception was "
#~ "raised by the codec."
#~ msgstr ""
#~ "주어진 *size*\\의 :c:type:`Py_UNICODE` 버퍼 *s*\\를"
#~ " 인코딩하고 파이썬 bytes 객체를 반환합니다. "
#~ "*encoding*\\과 *errors*\\는 유니코드 :meth:`~str.encode`"
#~ " 메서드의 같은 이름의 매개 변수와 같은 의미입니다."
#~ " 사용할 코덱은 파이썬 코덱 레지스트리를 사용하여 "
#~ "조회됩니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "In the case of an error, ``NULL``"
#~ " is returned with an exception set"
#~ " and no *size* is stored."
#~ msgstr "에러가 발생하면, ``NULL``\\이 예외 설정과 함께 반환되고 *size*\\가 저장되지 않습니다."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer *s* "
#~ "of the given *size* using UTF-8 "
#~ "and return a Python bytes object.  "
#~ "Return ``NULL`` if an exception was "
#~ "raised by the codec."
#~ msgstr ""
#~ "UTF-8을 사용하여 주어진 *size*\\의 :c:type:`Py_UNICODE`"
#~ " 버퍼 *s*\\를 인코딩하고 파이썬 bytes 객체를 "
#~ "반환합니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsUTF8String`, "
#~ ":c:func:`PyUnicode_AsUTF8AndSize` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsUTF8String`, "
#~ ":c:func:`PyUnicode_AsUTF8AndSize` 나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Return a Python bytes object holding "
#~ "the UTF-32 encoded value of the "
#~ "Unicode data in *s*.  Output is "
#~ "written according to the following byte"
#~ " order::"
#~ msgstr ""
#~ "*s*\\에 있는 유니코드 데이터의 UTF-32로 인코딩된 "
#~ "값을 포함하는 파이썬 bytes 객체를 반환합니다. 출력은"
#~ " 다음 바이트 순서에 따라 기록됩니다::"

#~ msgid ""
#~ "If byteorder is ``0``, the output "
#~ "string will always start with the "
#~ "Unicode BOM mark (U+FEFF). In the "
#~ "other two modes, no BOM mark is"
#~ " prepended."
#~ msgstr ""
#~ "byteorder가 ``0``\\이면, 출력 문자열은 항상 유니코드"
#~ " BOM 마크(U+FEFF)로 시작합니다. 다른 두 모드에서는,"
#~ " BOM 마크가 앞에 추가되지 않습니다."

#~ msgid ""
#~ "If ``Py_UNICODE_WIDE`` is not defined, "
#~ "surrogate pairs will be output as "
#~ "a single code point."
#~ msgstr "``Py_UNICODE_WIDE``\\가 정의되지 않으면, 서로게이트 쌍이 단일 코드 포인트로 출력됩니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsUTF32String` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다. "
#~ ":c:func:`PyUnicode_AsUTF32String` 이나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Return a Python bytes object holding "
#~ "the UTF-16 encoded value of the "
#~ "Unicode data in *s*.  Output is "
#~ "written according to the following byte"
#~ " order::"
#~ msgstr ""
#~ "*s*\\에 있는 유니코드 데이터의 UTF-16 인코딩된 값을"
#~ " 포함하는 파이썬 bytes 객체를 반환합니다. 출력은 "
#~ "다음 바이트 순서에 따라 기록됩니다::"

#~ msgid ""
#~ "If ``Py_UNICODE_WIDE`` is defined, a "
#~ "single :c:type:`Py_UNICODE` value may get "
#~ "represented as a surrogate pair. If "
#~ "it is not defined, each "
#~ ":c:type:`Py_UNICODE` values is interpreted as"
#~ " a UCS-2 character."
#~ msgstr ""
#~ "``Py_UNICODE_WIDE``\\가 정의되면, 단일 :c:type:`Py_UNICODE`"
#~ " 값이 서로게이트 쌍으로 표시될 수 있습니다. 정의되지"
#~ " 않으면, 각 :c:type:`Py_UNICODE` 값은 UCS-2 "
#~ "문자로 해석됩니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsUTF16String` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsUTF16String` 이나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given size using UTF-7 and "
#~ "return a Python bytes object.  Return"
#~ " ``NULL`` if an exception was raised"
#~ " by the codec."
#~ msgstr ""
#~ "UTF-7을 사용하여 주어진 크기의 :c:type:`Py_UNICODE` "
#~ "버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. "
#~ "코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "If *base64SetO* is nonzero, \"Set O\""
#~ " (punctuation that has no otherwise "
#~ "special meaning) will be encoded in "
#~ "base-64.  If *base64WhiteSpace* is nonzero,"
#~ " whitespace will be encoded in "
#~ "base-64.  Both are set to zero for"
#~ " the Python \"utf-7\" codec."
#~ msgstr ""
#~ "*base64SetO* 가 0이 아니면, \"Set O\"(다른 "
#~ "특별한 의미가 없는 구두점)는 base-64로 인코딩됩니다. "
#~ "*base64WhiteSpace* 가 0이 아니면, 공백은 "
#~ "base-64로 인코딩됩니다. 파이썬 \"utf-7\" 코덱의 경우"
#~ " 둘 다 0으로 설정됩니다."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* using Unicode-Escape"
#~ " and return a bytes object.  Return"
#~ " ``NULL`` if an exception was raised"
#~ " by the codec."
#~ msgstr ""
#~ "유니코드 이스케이프를 사용하여 주어진 *size*\\의 "
#~ ":c:type:`Py_UNICODE` 버퍼를 인코딩하고 bytes 객체를 "
#~ "반환합니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsUnicodeEscapeString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsUnicodeEscapeString` 을 사용하여 "
#~ "마이그레이션 하십시오."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* using Raw-Unicode-"
#~ "Escape and return a bytes object.  "
#~ "Return ``NULL`` if an exception was "
#~ "raised by the codec."
#~ msgstr ""
#~ "원시 유니코드 이스케이프를 사용하여 주어진 *size*\\의 "
#~ ":c:type:`Py_UNICODE` 버퍼를 인코딩하고 bytes 객체를 "
#~ "반환합니다. 코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsRawUnicodeEscapeString` or"
#~ " :c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsRawUnicodeEscapeString` 이나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* using Latin-1 and "
#~ "return a Python bytes object.  Return"
#~ " ``NULL`` if an exception was raised"
#~ " by the codec."
#~ msgstr ""
#~ "Latin-1을 사용하여 주어진 *size*\\의 "
#~ ":c:type:`Py_UNICODE` 버퍼를 인코딩하고 파이썬 bytes "
#~ "객체를 반환합니다. 코덱에서 예외가 발생하면 ``NULL``\\을 "
#~ "반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsLatin1String` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsLatin1String` 이나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* using ASCII and "
#~ "return a Python bytes object.  Return"
#~ " ``NULL`` if an exception was raised"
#~ " by the codec."
#~ msgstr ""
#~ "ASCII를 사용하여 주어진 *size*\\의 :c:type:`Py_UNICODE`"
#~ " 버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. "
#~ "코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsASCIIString` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsASCIIString` 이나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* using the given "
#~ "*mapping* object and return the result"
#~ " as a bytes object.  Return ``NULL``"
#~ " if an exception was raised by "
#~ "the codec."
#~ msgstr ""
#~ "주어진 *mapping* 객체를 사용하여 주어진 *size*\\의 "
#~ ":c:type:`Py_UNICODE` 버퍼를 인코딩하고 그 결과를 "
#~ "bytes 객체로 반환합니다. 코덱에서 예외가 발생하면 "
#~ "``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsCharmapString` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsCharmapString` 이나 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

#~ msgid ""
#~ "Translate a :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* by applying a "
#~ "character *mapping* table to it and "
#~ "return the resulting Unicode object. "
#~ "Return ``NULL`` when an exception was"
#~ " raised by the codec."
#~ msgstr ""
#~ "문자 *mapping* 테이블을 적용하여 주어진 *size*\\의 "
#~ ":c:type:`Py_UNICODE` 버퍼를 변환하고 결과 유니코드 "
#~ "객체를 반환합니다. 코덱에서 예외가 발생하면 ``NULL``\\을 "
#~ "반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_Translate`. or "
#~ ":ref:`generic codec based API <codec-"
#~ "registry>`"
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_Translate`\\나 :ref:`일반 코덱 기반 "
#~ "API <codec-registry>`\\를 사용하여 마이그레이션 "
#~ "하십시오."

#~ msgid ""
#~ "Encode the :c:type:`Py_UNICODE` buffer of "
#~ "the given *size* using MBCS and "
#~ "return a Python bytes object.  Return"
#~ " ``NULL`` if an exception was raised"
#~ " by the codec."
#~ msgstr ""
#~ "MBCS를 사용하여 주어진 *size*\\의 :c:type:`Py_UNICODE`"
#~ " 버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. "
#~ "코덱에서 예외가 발생하면 ``NULL``\\을 반환합니다."

#~ msgid ""
#~ "Part of the old-style "
#~ ":c:type:`Py_UNICODE` API; please migrate to"
#~ " using :c:func:`PyUnicode_AsMBCSString`, "
#~ ":c:func:`PyUnicode_EncodeCodePage` or "
#~ ":c:func:`PyUnicode_AsEncodedString`."
#~ msgstr ""
#~ "이전 스타일 :c:type:`Py_UNICODE` API의 일부입니다; "
#~ ":c:func:`PyUnicode_AsMBCSString`, "
#~ ":c:func:`PyUnicode_EncodeCodePage` 또는 "
#~ ":c:func:`PyUnicode_AsEncodedString` 을 사용하여 마이그레이션"
#~ " 하십시오."

