# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "메모리 관리"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "개요"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python"
" objects and data structures. The management of this private heap is "
"ensured internally by the *Python memory manager*.  The Python memory "
"manager has different components which deal with various dynamic storage "
"management aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"파이썬의 메모리 관리에는 모든 파이썬 객체와 데이터 구조를 포함하는 비공개 힙(private heap)을 수반합니다. 이 비공개 "
"힙의 관리는 *파이썬 메모리 관리자*\\에 의해 내부적으로 이루어집니다. 파이썬 메모리 관리자는 공유, 세그먼트 화, 사전 할당 "
"또는 캐싱과 같은 동적 스토리지 관리의 다양한 측면을 처리하는 서로 다른 구성 요소를 가지고 있습니다."

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by "
"interacting with the memory manager of the operating system. On top of "
"the raw memory allocator, several object-specific allocators operate on "
"the same heap and implement distinct memory management policies adapted "
"to the peculiarities of every object type. For example, integer objects "
"are managed differently within the heap than strings, tuples or "
"dictionaries because integers imply different storage requirements and "
"speed/space tradeoffs. The Python memory manager thus delegates some of "
"the work to the object-specific allocators, but ensures that the latter "
"operate within the bounds of the private heap."
msgstr ""
"가장 낮은 수준에서, 원시 메모리 할당자는 운영 체제의 메모리 관리자와 상호 작용하여 비공개 힙에 모든 파이썬 관련 데이터를 "
"저장하기에 충분한 공간이 있는지 확인합니다. 원시 메모리 할당자 위에, 여러 개의 객체별 할당자가 같은 힙에서 작동하며 각 객체 "
"형의 특성에 맞는 고유한 메모리 관리 정책을 구현합니다. 예를 들어, 정수는 다른 스토리지 요구 사항과 속도/공간 절충을 "
"의미하므로, 정수 객체는 힙 내에서 문자열, 튜플 또는 딕셔너리와는 다르게 관리됩니다. 따라서 파이썬 메모리 관리자는 일부 작업을 "
"객체별 할당자에게 위임하지만, 후자가 비공개 힙의 경계 내에서 작동하도록 합니다."

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over"
" it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and "
"other internal buffers is performed on demand by the Python memory "
"manager through the Python/C API functions listed in this document."
msgstr ""
"파이썬 힙의 관리는 인터프리터 자체에 의해 수행되며, 사용자는 힙 내부의 메모리 블록에 대한 객체 포인터를 규칙적으로 조작하더라도,"
" 사용자가 제어할 수 없다는 것을 이해하는 것이 중요합니다. 파이썬 객체와 기타 내부 버퍼를 위한 힙 공간 할당은 이 설명서에 "
"나열된 파이썬/C API 함수를 통해 파이썬 메모리 관리자의 요청에 따라 수행됩니다."

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate"
" on Python objects with the functions exported by the C library: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
"  This will result in  mixed calls between the C allocator and the Python"
" memory manager with fatal consequences, because they implement different"
" algorithms and operate on different heaps.  However, one may safely "
"allocate and release memory blocks with the C library allocator for "
"individual purposes, as shown in the following example::"
msgstr ""
"메모리 손상을 피하고자, 확장 작성자는 C 라이브러리에서 내보낸 함수를 파이썬 객체에 대해 실행하지 않아야 합니다: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` 및 :c:func:`free`. "
"그렇게 한다면, 서로 다른 알고리즘을 구현하고 다른 힘에 작동하기 때문에, C 할당자와 파이썬 메모리 관리자 간에 혼합 호출이 "
"발생하여 치명적인 결과를 초래합니다. 그러나, 다음 예제와 같이 개별 목적으로 C 라이브러리 할당자를 사용하여 메모리 블록을 "
"안전하게 할당하고 해제할 수 있습니다::"

#: ../../c-api/memory.rst:58
msgid ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Do some I/O operation involving buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"return res;"
msgstr ""

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the "
"C library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"이 예에서, I/O 버퍼에 대한 메모리 요청은 C 라이브러리 할당자에 의해 처리됩니다. 파이썬 메모리 관리자는 결과로 반환되는 "
"바이트열 객체의 할당에만 관여합니다."

#: ../../c-api/memory.rst:72
#, fuzzy
msgid ""
"In most situations, however, it is recommended to allocate memory from "
"the Python heap specifically because the latter is under control of the "
"Python memory manager. For example, this is required when the interpreter"
" is extended with new object types written in C. Another reason for using"
" the Python heap is the desire to *inform* the Python memory manager "
"about the memory needs of the extension module. Even when the requested "
"memory is used exclusively for internal, highly specific purposes, "
"delegating all memory requests to the Python memory manager causes the "
"interpreter to have a more accurate image of its memory footprint as a "
"whole. Consequently, under certain circumstances, the Python memory "
"manager may or may not trigger appropriate actions, like garbage "
"collection, memory compaction or other preventive procedures. Note that "
"by using the C library allocator as shown in the previous example, the "
"allocated memory for the I/O buffer escapes completely the Python memory "
"manager."
msgstr ""
"그러나 대부분의 경우, 파이썬 힙에서 메모리를 할당하는 것이 좋습니다. 파이썬 힙은 파이썬 메모리 관리자가 제어하기 때문입니다. "
"예를 들어, 인터프리터가 C로 작성된 새로운 객체 형으로 확장될 때 필요합니다. 파이썬 힙을 사용하는 또 다른 이유는 확장 모듈의 "
"메모리 요구에 대해 파이썬 메모리 관리자에게 *알리고자* 하는 것입니다. 요청된 메모리가 내부적이고 매우 특정한 목적으로만 사용될 "
"때도, 모든 메모리 요청을 파이썬 메모리 관리자에 위임하면 인터프리터가 전체 메모리 요구량에 대한 더 정확한 이미지를 갖게 됩니다."
" 결과적으로, 특정 상황에서, 파이썬 메모리 관리자는 가비지 수집, 메모리 압축 또는 기타 예방 절차와 같은 적절한 작업을 트리거 "
"하거나 그러지 않을 수 있습니다. 앞의 예에서와같이 C 라이브러리 할당자를 사용하면, I/O 버퍼에 할당된 메모리가 파이썬 메모리 "
"관리자를 완전히 우회하게 됨에 유의하십시오."

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure "
"the memory allocators used by Python."
msgstr ":envvar:`PYTHONMALLOC` 환경 변수를 사용하여 파이썬에서 사용하는 메모리 할당자를 구성할 수 있습니다."

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print"
" statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time"
" a new pymalloc object arena is created, and on shutdown."
msgstr ""
":envvar:`PYTHONMALLOCSTATS` 환경 변수는 새로운 pymalloc 객체 아레나(arena)가 만들어질 때마다 "
"그리고 종료 시 :ref:`pymalloc 메모리 할당자 <pymalloc>`\\의 통계를 인쇄하는 데 사용될 수 있습니다."

#: ../../c-api/memory.rst:96
msgid "Allocator Domains"
msgstr ""

#: ../../c-api/memory.rst:100
msgid ""
"All allocating functions belong to one of three different \"domains\" "
"(see also :c:type:`PyMemAllocatorDomain`). These domains represent "
"different allocation strategies and are optimized for different purposes."
" The specific details on how every domain allocates memory or what "
"internal functions each domain calls is considered an implementation "
"detail, but for debugging purposes a simplified table can be found at "
":ref:`here <default-memory-allocators>`. The APIs used to allocate and "
"free a block of memory must be from the same domain. For example, "
":c:func:`PyMem_Free` must be used to free memory allocated using "
":c:func:`PyMem_Malloc`."
msgstr ""

#: ../../c-api/memory.rst:109
msgid "The three allocation domains are:"
msgstr ""

#: ../../c-api/memory.rst:111
msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where "
"the allocator can operate without the :term:`GIL`. The memory is "
"requested directly from the system. See :ref:`Raw Memory Interface <raw-"
"memoryinterface>`."
msgstr ""

#: ../../c-api/memory.rst:116
msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed "
"with the :term:`GIL` held. The memory is taken from the Python private "
"heap. See :ref:`Memory Interface <memoryinterface>`."
msgstr ""

#: ../../c-api/memory.rst:121
msgid ""
"Object domain: intended for allocating memory for Python objects. The "
"memory is taken from the Python private heap. See :ref:`Object allocators"
" <objectinterface>`."
msgstr ""

#: ../../c-api/memory.rst:126
msgid ""
"The :term:`free-threaded <free threading>` build requires that only "
"Python objects are allocated using the \"object\" domain and that all "
"Python objects are allocated using that domain. This differs from the "
"prior Python versions, where this was only a best practice and not a hard"
" requirement."
msgstr ""

#: ../../c-api/memory.rst:130
msgid ""
"For example, buffers (non-Python objects) should be allocated using "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_RawMalloc`, or :c:func:`malloc`, "
"but not :c:func:`PyObject_Malloc`."
msgstr ""

#: ../../c-api/memory.rst:133
msgid "See :ref:`Memory Allocation APIs <free-threaded-memory-allocation>`."
msgstr ""

#: ../../c-api/memory.rst:139
msgid "Raw Memory Interface"
msgstr "원시 메모리 인터페이스"

#: ../../c-api/memory.rst:141
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does"
" not need to be held."
msgstr ""
"다음 함수 집합은 시스템 할당자에 대한 래퍼입니다. 이러한 함수는 스레드 안전해서, :term:`GIL <global "
"interpreter lock>`\\을 유지할 필요는 없습니다."

#: ../../c-api/memory.rst:145
#, fuzzy
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses "
"the following functions: :c:func:`malloc`, :c:func:`calloc`, "
":c:func:`realloc` and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1,"
" 1)``) when requesting zero bytes."
msgstr ""
":ref:`기본 원시 메모리 할당자 <default-memory-allocators>`\\는 다음 함수를 사용합니다: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` 및 :c:func:`free`; "
"0바이트를 요청할 때 ``malloc(1)``\\(또는 ``calloc(1, 1)``)을 호출합니다."

#: ../../c-api/memory.rst:154 ../../c-api/memory.rst:225
#: ../../c-api/memory.rst:335
#, fuzzy
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"*n* 바이트를 할당하고 할당된 메모리를 가리키는 :c:type:`void*` 형의 포인터를 반환하거나, 요청이 실패하면 "
"``NULL``\\을 반환합니다."

#: ../../c-api/memory.rst:157
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if "
"possible, as if ``PyMem_RawMalloc(1)`` had been called instead. The "
"memory will not have been initialized in any way."
msgstr ""
"0바이트를 요청하면 가능하면 ``PyMem_RawMalloc(1)``\\이 대신 호출된 것처럼 가능하면 고유한 ``NULL``\\이"
" 아닌 포인터를 반환합니다. 메모리는 어떤 식으로든 초기화되지 않습니다."

#: ../../c-api/memory.rst:164 ../../c-api/memory.rst:235
#: ../../c-api/memory.rst:345
#, fuzzy
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and "
"returns a pointer of type :c:expr:`void*` to the allocated memory, or "
"``NULL`` if the request fails. The memory is initialized to zeros."
msgstr ""
"크기가 각각 *elsize* 바이트인 *nelem* 개의 요소를 할당하고 할당된 메모리를 가리키는 :c:type:`void*` 형의"
" 포인터를 반환하거나, 요청이 실패하면 ``NULL``\\을 반환합니다. 메모리는 0으로 초기화됩니다."

#: ../../c-api/memory.rst:168
msgid ""
"Requesting zero elements or elements of size zero bytes returns a "
"distinct non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, "
"1)`` had been called instead."
msgstr ""
"0개의 요소나 0바이트 크기의 요소를 요청하면 ``PyMem_RawCalloc(1, 1)``\\이 대신 호출된 것처럼 가능하면 "
"고유한 ``NULL``\\이 아닌 포인터를 반환합니다."

#: ../../c-api/memory.rst:177 ../../c-api/memory.rst:248
#: ../../c-api/memory.rst:358
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents "
"will be unchanged to the minimum of the old and the new sizes."
msgstr ""
"*p*\\가 가리키는 메모리 블록의 크기를 *n* 바이트로 조정합니다. 내용은 이전과 새로운 크기의 최솟값 내에서는 변경되지 "
"않습니다."

#: ../../c-api/memory.rst:180
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; "
"else if *n* is equal to zero, the memory block is resized but is not "
"freed, and the returned pointer is non-``NULL``."
msgstr ""
"*p*\\가 ``NULL``\\이면, 호출은 ``PyMem_RawMalloc(n)``\\과 동등합니다; *n*\\이 0과 같으면, "
"메모리 블록의 크기는 조정되지만 해제되지는 않고, 반환된 포인터는 ``NULL``\\이 아닙니다."

#: ../../c-api/memory.rst:184
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`."
msgstr ""
"*p*\\가 ``NULL``\\이 아닌 한, :c:func:`PyMem_RawMalloc`, "
":c:func:`PyMem_RawRealloc` 또는 :c:func:`PyMem_RawCalloc`\\에 대한 이전 호출에 의해 "
"반환된 것이어야 합니다."

#: ../../c-api/memory.rst:188
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p*"
" remains a valid pointer to the previous memory area."
msgstr ""
"요청이 실패하면, :c:func:`PyMem_RawRealloc`\\은 ``NULL``\\을 반환하고 *p*\\는 이전 메모리 "
"영역에 대한 유효한 포인터로 유지됩니다."

#: ../../c-api/memory.rst:194
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned "
"by a previous call to :c:func:`PyMem_RawMalloc`, "
":c:func:`PyMem_RawRealloc` or :c:func:`PyMem_RawCalloc`.  Otherwise, or "
"if ``PyMem_RawFree(p)`` has been called before, undefined behavior "
"occurs."
msgstr ""
"*p*\\가 가리키는 메모리 블록을 해제합니다. *p*\\는 :c:func:`PyMem_RawMalloc`, "
":c:func:`PyMem_RawRealloc` 또는 :c:func:`PyMem_RawCalloc`\\에 대한 이전 호출로 반환된 "
"것이어야 합니다. 그렇지 않거나 ``PyMem_RawFree(p)``\\가 앞서 호출되었으면, 정의되지 않은 동작이 일어납니다."

#: ../../c-api/memory.rst:199 ../../c-api/memory.rst:269
#: ../../c-api/memory.rst:379
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "*p*\\가 ``NULL``\\이면, 아무 작업도 수행되지 않습니다."

#: ../../c-api/memory.rst:205
msgid "Memory Interface"
msgstr "메모리 인터페이스"

#: ../../c-api/memory.rst:207 ../../c-api/memory.rst:315
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for "
"allocating and releasing memory from the Python heap."
msgstr ""
"ANSI C 표준에 따라 모델링 되었지만 0바이트를 요청할 때의 동작을 지정한 다음 함수 집합은 파이썬 힙에서 메모리를 할당하고 "
"해제하는 데 사용할 수 있습니다."

#: ../../c-api/memory.rst:211
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`기본 메모리 할당자 <default-memory-allocators>`\\는 :ref:`pymalloc 메모리 할당자 "
"<pymalloc>`\\를 사용합니다."

#: ../../c-api/memory.rst:216 ../../c-api/memory.rst:330
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr "이 함수를 사용할 때는 :term:`GIL <global interpreter lock>`\\을 유지해야 합니다."

#: ../../c-api/memory.rst:221
msgid "The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr "기본 할당자는 이제 시스템 :c:func:`malloc` 대신 pymalloc 입니다."

#: ../../c-api/memory.rst:228
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if "
"possible, as if ``PyMem_Malloc(1)`` had been called instead. The memory "
"will not have been initialized in any way."
msgstr ""
"0바이트를 요청하면 ``PyMem_Malloc(1)``\\이 대신 호출된 것처럼 가능하면 고유한 ``NULL``\\이 아닌 포인터를"
" 반환합니다. 메모리는 어떤 식으로든 초기화되지 않습니다."

#: ../../c-api/memory.rst:239
msgid ""
"Requesting zero elements or elements of size zero bytes returns a "
"distinct non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` "
"had been called instead."
msgstr ""
"0개의 요소나 0바이트 크기의 요소를 요청하면 ``PyMem_Calloc(1, 1)``\\이 대신 호출된 것처럼 가능하면 고유한 "
"``NULL``\\이 아닌 포인터를 반환합니다."

#: ../../c-api/memory.rst:251
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, "
"and the returned pointer is non-``NULL``."
msgstr ""
"*p*\\가 ``NULL``\\이면, 호출은 ``PyMem_Malloc(n)``\\과 동등합니다; 그렇지 않고 *n*\\이 0과 "
"같으면, 메모리 블록의 크기는 조정되지만 해제되지는 않으며, 반환된 포인터는 ``NULL``\\이 아닙니다."

#: ../../c-api/memory.rst:255
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or "
":c:func:`PyMem_Calloc`."
msgstr ""
"*p*\\가 ``NULL``\\이 아닌 한, :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` "
"또는 :c:func:`PyMem_Calloc`\\에 대한 이전 호출이 반환한 것이어야 합니다."

#: ../../c-api/memory.rst:258
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"요청이 실패하면, :c:func:`PyMem_Realloc`\\은 ``NULL``\\을 반환하고 *p*\\는 이전 메모리 영역에 "
"대한 유효한 포인터로 유지됩니다."

#: ../../c-api/memory.rst:264
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned "
"by a previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or "
":c:func:`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"*p*\\가 가리키는 메모리 블록을 해제합니다. *p*\\는 :c:func:`PyMem_Malloc`, "
":c:func:`PyMem_Realloc` 또는 :c:func:`PyMem_Calloc`\\에 대한 이전 호출이 반환한 것이어야 "
"합니다. 그렇지 않거나 ``PyMem_Free(p)``\\가 앞서 호출되었으면 정의되지 않은 동작이 일어납니다."

#: ../../c-api/memory.rst:271
msgid ""
"The following type-oriented macros are provided for convenience.  Note  "
"that *TYPE* refers to any C type."
msgstr "편의를 위해 다음과 같은 형 지향 매크로가 제공됩니다. *TYPE*\\이 모든 C형을 나타냄에 유의하십시오."

#: ../../c-api/memory.rst:277
#, fuzzy
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` "
"bytes of memory.  Returns a pointer cast to ``TYPE*``.  The memory will "
"not have been initialized in any way."
msgstr ""
":c:func:`PyMem_Malloc`\\과 같지만, ``(n * sizeof(TYPE))`` 바이트의 메모리를 할당합니다. "
":c:type:`TYPE*`\\로 캐스트 된 포인터를 반환합니다. 메모리는 어떤 식으로든 초기화되지 않습니다."

#: ../../c-api/memory.rst:284
#, fuzzy
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n "
"* sizeof(TYPE))`` bytes.  Returns a pointer cast to ``TYPE*``. On return,"
" *p* will be a pointer to the new memory area, or ``NULL`` in the event "
"of failure."
msgstr ""
":c:func:`PyMem_Realloc`\\과 같지만, 메모리 블록의 크기는 ``(n * sizeof(TYPE))`` 바이트로 "
"조정됩니다. :c:type:`TYPE*`\\로 캐스트 된 포인터를 반환합니다. 반환한 후에, *p*\\는 새로운 메모리 영역에 대한"
" 포인터이거나, 실패하면 ``NULL``\\이 됩니다."

#: ../../c-api/memory.rst:289
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the "
"original value of *p* to avoid losing memory when handling errors."
msgstr ""
"이것은 C 전처리기 매크로입니다; *p*\\는 항상 다시 대입됩니다. 에러를 처리할 때 메모리 손실을 피하려면 *p*\\의 원래 "
"값을 보관하십시오."

#: ../../c-api/memory.rst:295
msgid "Same as :c:func:`PyMem_Free`."
msgstr ":c:func:`PyMem_Free`\\와 같습니다."

#: ../../c-api/memory.rst:297
msgid ""
"In addition, the following macro sets are provided for calling the Python"
" memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary "
"compatibility across Python versions and is therefore deprecated in "
"extension modules."
msgstr ""
"또한, 위에 나열된 C API 함수를 사용하지 않고, 파이썬 메모리 할당자를 직접 호출하기 위해 다음 매크로 집합이 제공됩니다. "
"그러나, 이들을 사용하면 파이썬 버전을 가로지르는 바이너리 호환성이 유지되지 않아서 확장 모듈에서는 폐지되었습니다."

#: ../../c-api/memory.rst:302
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

#: ../../c-api/memory.rst:303
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

#: ../../c-api/memory.rst:304
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:305
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

#: ../../c-api/memory.rst:306
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:307
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:313
msgid "Object allocators"
msgstr "객체 할당자"

#: ../../c-api/memory.rst:320
msgid ""
"There is no guarantee that the memory returned by these allocators can be"
" successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""

#: ../../c-api/memory.rst:325
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`기본 객체 할당자 <default-memory-allocators>`\\는 :ref:`pymalloc 메모리 할당자 "
"<pymalloc>`\\를 사용합니다."

#: ../../c-api/memory.rst:338
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if "
"possible, as if ``PyObject_Malloc(1)`` had been called instead. The "
"memory will not have been initialized in any way."
msgstr ""
"0바이트를 요청하면 ``PyObject_Malloc(1)``\\이 대신 호출된 것처럼 가능하면 고유한 ``NULL``\\이 아닌 "
"포인터를 반환합니다. 메모리는 어떤 식으로든 초기화되지 않습니다."

#: ../../c-api/memory.rst:349
msgid ""
"Requesting zero elements or elements of size zero bytes returns a "
"distinct non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, "
"1)`` had been called instead."
msgstr ""
"0개의 요소나 0바이트 크기의 요소를 요청하면 ``PyObject_Calloc(1, 1)``\\이 대신 호출된 것처럼 가능하면 "
"고유한 ``NULL``\\이 아닌 포인터를 반환합니다."

#: ../../c-api/memory.rst:361
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; "
"else if *n* is equal to zero, the memory block is resized but is not "
"freed, and the returned pointer is non-``NULL``."
msgstr ""
"*p*\\가 ``NULL``\\이면, 호출은 ``PyObject_Malloc(n)``\\과 동등합니다; 그렇지 않고 *n*\\이 "
"0과 같으면, 메모리 블록의 크기는 조정되지만 해제되지 않고, 반환된 포인터는 ``NULL``\\이 아닙니다."

#: ../../c-api/memory.rst:365
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`."
msgstr ""
"*p*\\가 ``NULL``\\이 아닌 한, :c:func:`PyObject_Malloc`, "
":c:func:`PyObject_Realloc` 또는 :c:func:`PyObject_Calloc`\\에 대한 이전 호출에 의해 "
"반환된 것이어야 합니다."

#: ../../c-api/memory.rst:368
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p*"
" remains a valid pointer to the previous memory area."
msgstr ""
"요청이 실패하면, :c:func:`PyObject_Realloc`\\은 ``NULL``\\을 반환하고 *p*\\는 이전 메모리 "
"영역에 대한 유효한 포인터로 유지됩니다."

#: ../../c-api/memory.rst:374
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned "
"by a previous call to :c:func:`PyObject_Malloc`, "
":c:func:`PyObject_Realloc` or :c:func:`PyObject_Calloc`.  Otherwise, or "
"if ``PyObject_Free(p)`` has been called before, undefined behavior "
"occurs."
msgstr ""
"*p*\\가 가리키는 메모리 블록을 해제합니다. 이 블록은 :c:func:`PyObject_Malloc`, "
":c:func:`PyObject_Realloc` 또는 :c:func:`PyObject_Calloc`\\에 대한 이전 호출에 의해 "
"반환된 것이어야 합니다. 그렇지 않거나 ``PyObject_Free(p)``\\가 이전에 호출되었으면 정의되지 않은 동작이 "
"일어납니다."

#: ../../c-api/memory.rst:385
msgid "Default Memory Allocators"
msgstr "기본 메모리 할당자"

#: ../../c-api/memory.rst:387
msgid "Default memory allocators:"
msgstr "기본 메모리 할당자:"

#: ../../c-api/memory.rst:390
msgid "Configuration"
msgstr "구성"

#: ../../c-api/memory.rst:390
msgid "Name"
msgstr "이름"

#: ../../c-api/memory.rst:390
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:390
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:390
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:392
msgid "Release build"
msgstr "릴리스 빌드"

#: ../../c-api/memory.rst:392
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:392 ../../c-api/memory.rst:394
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:392
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:393
msgid "Debug build"
msgstr "디버그 빌드"

#: ../../c-api/memory.rst:393
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:393 ../../c-api/memory.rst:395
msgid "``malloc`` + debug"
msgstr "``malloc`` + 디버그"

#: ../../c-api/memory.rst:393
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + 디버그"

#: ../../c-api/memory.rst:394
msgid "Release build, without pymalloc"
msgstr "pymalloc 없는 배포 빌드"

#: ../../c-api/memory.rst:394
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:395
msgid "Debug build, without pymalloc"
msgstr "pymalloc 없는 디버그 빌드"

#: ../../c-api/memory.rst:395
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:398
msgid "Legend:"
msgstr "범례:"

#: ../../c-api/memory.rst:400
#, fuzzy
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "이름: :envvar:`PYTHONMALLOC` 환경 변수의 값"

#: ../../c-api/memory.rst:401
#, fuzzy
msgid ""
"``malloc``: system allocators from the standard C library, C functions: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: 표준 C 라이브러리의 시스템 할당자, C 함수: :c:func:`malloc`, "
":c:func:`calloc`, :c:func:`realloc` 및 :c:func:`free`"

#: ../../c-api/memory.rst:403
#, fuzzy
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`pymalloc 메모리 할당자 <pymalloc>`"

#: ../../c-api/memory.rst:404
msgid ""
"``mimalloc``: :ref:`mimalloc memory allocator <mimalloc>`.  The pymalloc "
"allocator will be used if mimalloc support isn't available."
msgstr ""

#: ../../c-api/memory.rst:406
#, fuzzy
msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators "
"<pymem-debug-hooks>`."
msgstr "\"+ 디버그\": :c:func:`PyMem_SetupDebugHooks` 에 의해 설치된 디버그 훅 포함"

#: ../../c-api/memory.rst:408
msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr ""

#: ../../c-api/memory.rst:413
msgid "Customize Memory Allocators"
msgstr "메모리 할당자 사용자 정의"

#: ../../c-api/memory.rst:419
#, fuzzy
msgid ""
"Structure used to describe a memory block allocator. The structure has "
"the following fields:"
msgstr "메모리 블록 할당자를 기술하는 데 사용되는 구조체. 구조체에는 네 개의 필드가 있습니다:"

#: ../../c-api/memory.rst:423 ../../c-api/memory.rst:670
msgid "Field"
msgstr "필드"

#: ../../c-api/memory.rst:423 ../../c-api/memory.rst:670
msgid "Meaning"
msgstr "의미"

#: ../../c-api/memory.rst:425 ../../c-api/memory.rst:672
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:425 ../../c-api/memory.rst:672
msgid "user context passed as first argument"
msgstr "첫 번째 인자로 전달된 사용자 컨텍스트"

#: ../../c-api/memory.rst:427
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:427
msgid "allocate a memory block"
msgstr "메모리 블록을 할당합니다"

#: ../../c-api/memory.rst:429
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:429
msgid "allocate a memory block initialized with zeros"
msgstr "0으로 초기화된 메모리 블록을 할당합니다"

#: ../../c-api/memory.rst:432
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:432
msgid "allocate or resize a memory block"
msgstr "메모리 블록을 할당하거나 크기 조정합니다"

#: ../../c-api/memory.rst:434
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:434
msgid "free a memory block"
msgstr "메모리 블록을 해제합니다"

#: ../../c-api/memory.rst:437
#, fuzzy
msgid ""
"The :c:type:`!PyMemAllocator` structure was renamed to "
":c:type:`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
":c:type:`PyMemAllocator` 구조체의 이름이 :c:type:`PyMemAllocatorEx`\\로 바뀌고 새로운 "
"``calloc`` 필드가 추가되었습니다."

#: ../../c-api/memory.rst:444
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "할당자 도메인을 식별하는 데 사용되는 열거형. 도메인:"

#: ../../c-api/memory.rst:450 ../../c-api/memory.rst:459
#: ../../c-api/memory.rst:468
msgid "Functions:"
msgstr "함수:"

#: ../../c-api/memory.rst:452
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:453
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:454
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:455
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:461
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:462
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:463
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:464
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:470
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:471
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:472
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:473
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:477
msgid "Get the memory block allocator of the specified domain."
msgstr "지정된 도메인의 메모리 블록 할당자를 가져옵니다."

#: ../../c-api/memory.rst:482
msgid "Set the memory block allocator of the specified domain."
msgstr "지정된 도메인의 메모리 블록 할당자를 설정합니다."

#: ../../c-api/memory.rst:484
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr "새 할당자는 0바이트를 요청할 때 고유한 ``NULL``\\이 아닌 포인터를 반환해야 합니다."

#: ../../c-api/memory.rst:487
#, fuzzy
msgid ""
"For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""
":c:data:`PYMEM_DOMAIN_RAW` 도메인의 경우, 할당자는 스레드 안전해야 합니다: 할당자가 호출될 때 "
":term:`GIL <global interpreter lock>`\\을 잡지 않습니다."

#: ../../c-api/memory.rst:491
msgid ""
"For the remaining domains, the allocator must also be thread-safe: the "
"allocator may be called in different interpreters that do not share a "
"``GIL``."
msgstr ""

#: ../../c-api/memory.rst:495
msgid ""
"If the new allocator is not a hook (does not call the previous "
"allocator), the :c:func:`PyMem_SetupDebugHooks` function must be called "
"to reinstall the debug hooks on top on the new allocator."
msgstr ""
"새 할당자가 훅이 아니면 (이전 할당자를 호출하지 않으면), :c:func:`PyMem_SetupDebugHooks` 함수를 "
"호출하여 새 할당자 위에 디버그 훅을 다시 설치해야 합니다."

#: ../../c-api/memory.rst:499
msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python"
" with PyPreConfig <c-preinit>`."
msgstr ""

#: ../../c-api/memory.rst:504
msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ""

#: ../../c-api/memory.rst:506
msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before "
":c:func:`Py_InitializeFromConfig` to install a custom memory allocator. "
"There are no restrictions over the installed allocator other than the "
"ones imposed by the domain (for instance, the Raw Domain allows the "
"allocator to be called without the GIL held). See :ref:`the section on "
"allocator domains <allocator-domains>` for more information."
msgstr ""

#: ../../c-api/memory.rst:514
msgid ""
"If called after Python has finish initializing (after "
":c:func:`Py_InitializeFromConfig` has been called) the allocator **must**"
" wrap the existing allocator. Substituting the current allocator for some"
" other arbitrary one is **not supported**."
msgstr ""

#: ../../c-api/memory.rst:519
msgid "All allocators must be thread-safe."
msgstr ""

#: ../../c-api/memory.rst:525
msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-"
"hooks>` to detect memory errors."
msgstr ""

#: ../../c-api/memory.rst:532
#, fuzzy
msgid "Debug hooks on the Python memory allocators"
msgstr "파이썬 메모리 할당자 함수에 있는 버그를 감지하기 위한 훅을 설정합니다."

#: ../../c-api/memory.rst:534
msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the "
":c:func:`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""

#: ../../c-api/memory.rst:539
#, fuzzy
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install "
"debug hooks on a Python compiled in release mode (ex: "
"``PYTHONMALLOC=debug``)."
msgstr ""
"파이썬이 디버그 모드에서 컴파일되면 이러한 훅은 :ref:`기본적으로 설치됩니다 <default-memory-"
"allocators>`. :envvar:`PYTHONMALLOC` 환경 변수를 사용하여 릴리스 모드에서 컴파일된 파이썬에 디버그 "
"훅을 설치할 수 있습니다."

#: ../../c-api/memory.rst:542
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug "
"hooks after calling :c:func:`PyMem_SetAllocator`."
msgstr ""

#: ../../c-api/memory.rst:545
#, fuzzy
msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte"
" ``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by "
"\"forbidden bytes\" filled with the byte ``0xFD`` "
"(``PYMEM_FORBIDDENBYTE``). Strings of these bytes are unlikely to be "
"valid addresses, floats, or ASCII strings."
msgstr ""
"새로 할당된 메모리는 바이트 ``0xCD``\\(``CLEANBYTE``)로 채워지고, 해제된 메모리는 바이트 "
"``0xDD``\\(``DEADBYTE``)로 채워집니다. 메모리 블록은 \"금지된 바이트\"(``FORBIDDENBYTE``: "
"바이트 ``0xFD``)로 둘러싸여 있습니다."

#: ../../c-api/memory.rst:552
msgid "Runtime checks:"
msgstr "실행 시간 검사:"

#: ../../c-api/memory.rst:554
#, fuzzy
msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"API 위반 탐지, 예: :c:func:`PyMem_Malloc`\\이 할당한 버퍼에 대해 호출된 "
":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:556
#, fuzzy
msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "버퍼 시작 전에 쓰기 감지 (버퍼 언더플로)"

#: ../../c-api/memory.rst:557
#, fuzzy
msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "버퍼 끝 뒤에 쓰기 감지 (버퍼 오버플로)"

#: ../../c-api/memory.rst:558
#, fuzzy
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when "
"allocator functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex: "
":c:func:`PyObject_Malloc`) and :c:macro:`PYMEM_DOMAIN_MEM` (ex: "
":c:func:`PyMem_Malloc`) domains are called."
msgstr ""
":c:data:`PYMEM_DOMAIN_OBJ`\\(예: :c:func:`PyObject_Malloc`)와 "
":c:data:`PYMEM_DOMAIN_MEM`\\(예: :c:func:`PyMem_Malloc`) 도메인의 할당자 함수가 호출될 "
"때 :term:`GIL <global interpreter lock>`\\이 유지되는지 확인"

#: ../../c-api/memory.rst:563
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and "
"the memory block was traced."
msgstr ""
"에러가 발생하면, 디버그 훅은 :mod:`tracemalloc` 모듈을 사용하여 메모리 블록이 할당된 곳의 트레이스백을 가져옵니다."
" :mod:`tracemalloc`\\이 파이썬 메모리 할당을 추적 중이고 메모리 블록이 추적될 때만 트레이스백이 표시됩니다."

#: ../../c-api/memory.rst:568
msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each"
" block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function"
" (``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs"
" from a Python slice):"
msgstr ""

#: ../../c-api/memory.rst:574
msgid "``p[-2*S:-S]``"
msgstr ""

#: ../../c-api/memory.rst:575
msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian "
"(easier to read in a memory dump)."
msgstr ""

#: ../../c-api/memory.rst:577
msgid "``p[-S]``"
msgstr ""

#: ../../c-api/memory.rst:578
msgid "API identifier (ASCII character):"
msgstr ""

#: ../../c-api/memory.rst:580
msgid "``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`."
msgstr ""

#: ../../c-api/memory.rst:581
msgid "``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`."
msgstr ""

#: ../../c-api/memory.rst:582
msgid "``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`."
msgstr ""

#: ../../c-api/memory.rst:584
msgid "``p[-S+1:0]``"
msgstr ""

#: ../../c-api/memory.rst:585
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""

#: ../../c-api/memory.rst:587
msgid "``p[0:N]``"
msgstr ""

#: ../../c-api/memory.rst:588
msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to "
"catch reference to uninitialized memory.  When a realloc-like function is"
" called requesting a larger memory block, the new excess bytes are also "
"filled with PYMEM_CLEANBYTE.  When a free-like function is called, these "
"are overwritten with PYMEM_DEADBYTE, to catch reference to freed memory."
"  When a realloc- like function is called requesting a smaller memory "
"block, the excess old bytes are also filled with PYMEM_DEADBYTE."
msgstr ""

#: ../../c-api/memory.rst:596
msgid "``p[N:N+S]``"
msgstr ""

#: ../../c-api/memory.rst:597
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""

#: ../../c-api/memory.rst:599
msgid "``p[N+S:N+2*S]``"
msgstr ""

#: ../../c-api/memory.rst:600
msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined "
"by default)."
msgstr ""

#: ../../c-api/memory.rst:603
msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or "
"realloc-like function.  Big-endian :c:type:`size_t`.  If \"bad memory\" "
"is detected later, the serial number gives an excellent way to set a "
"breakpoint on the next run, to capture the instant at which this block "
"was passed out.  The static function bumpserialno() in obmalloc.c is the "
"only place the serial number is incremented, and exists so you can set "
"such a breakpoint easily."
msgstr ""

#: ../../c-api/memory.rst:610
msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been "
"altered, diagnostic output is written to stderr, and the program is "
"aborted via Py_FatalError().  The other main failure mode is provoking a "
"memory error when a program reads up one of the special bit patterns and "
"tries to use it as an address.  If you get in a debugger then and look at"
" the object, you're likely to see that it's entirely filled with "
"PYMEM_DEADBYTE (meaning freed memory is getting used) or PYMEM_CLEANBYTE "
"(meaning uninitialized memory is getting used)."
msgstr ""

#: ../../c-api/memory.rst:619
#, fuzzy
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use "
":mod:`tracemalloc` to get the traceback where a memory block was "
"allocated. The debug hooks now also check if the GIL is held when "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` "
"domains are called."
msgstr ""
"이 함수는 이제 릴리스 모드에서 컴파일된 파이썬에서도 작동합니다. 에러가 발생하면, 디버그 훅은 이제 "
":mod:`tracemalloc`\\을 사용하여 메모리 블록이 할당된 곳의 트레이스백을 가져옵니다. 또한 디버그 훅은 이제 "
":c:data:`PYMEM_DOMAIN_OBJ`\\와 :c:data:`PYMEM_DOMAIN_MEM` 도메인의 함수가 호출될 때 "
"GIL을 잡는지 확인합니다."

#: ../../c-api/memory.rst:627
#, fuzzy
msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` "
"(``PYMEM_DEADBYTE``) and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been "
"replaced with ``0xCD``, ``0xDD`` and ``0xFD`` to use the same values than"
" Windows CRT debug ``malloc()`` and ``free()``."
msgstr ""
"바이트 패턴 ``0xCB``\\(``CLEANBYTE``), ``0xDB``\\(``DEADBYTE``) 및 "
"``0xFB``\\(``FORBIDDENBYTE``)는 윈도우 CRT 디버그 ``malloc()`` 및 ``free()``\\와 "
"같은 값을 사용하도록 ``0xCD``, ``0xDD`` 및 ``0xFD``\\로 대체되었습니다."

#: ../../c-api/memory.rst:637
msgid "The pymalloc allocator"
msgstr "pymalloc 할당자"

#: ../../c-api/memory.rst:639
#, fuzzy
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or"
" equal to 512 bytes) with a short lifetime. It uses memory mappings "
"called \"arenas\" with a fixed size of either 256 KiB on 32-bit platforms"
" or 1 MiB on 64-bit platforms. It falls back to :c:func:`PyMem_RawMalloc`"
" and :c:func:`PyMem_RawRealloc` for allocations larger than 512 bytes."
msgstr ""
"파이썬에는 수명이 짧은 작은 (512바이트 이하) 객체에 최적화된 *pymalloc* 할당자가 있습니다. 256 KiB의 고정 "
"크기를 갖는 \"아레나(arena)\"라는 메모리 매핑을 사용합니다. 512 바이트보다 큰 할당의 경우 "
":c:func:`PyMem_RawMalloc`\\과 :c:func:`PyMem_RawRealloc`\\으로 대체됩니다."

#: ../../c-api/memory.rst:645
#, fuzzy
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of"
" the :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and "
":c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc*\\은 :c:data:`PYMEM_DOMAIN_MEM`\\(예: :c:func:`PyMem_Malloc`)과 "
":c:data:`PYMEM_DOMAIN_OBJ`\\(예: :c:func:`PyObject_Malloc`) 도메인의 :ref:`기본 "
"할당자 <default-memory-allocators>`\\입니다."

#: ../../c-api/memory.rst:649
msgid "The arena allocator uses the following functions:"
msgstr "아레나 할당자는 다음 함수를 사용합니다:"

#: ../../c-api/memory.rst:651
#, fuzzy
msgid ":c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,"
msgstr "윈도우에서 :c:func:`VirtualAlloc`\\과 :c:func:`VirtualFree`,"

#: ../../c-api/memory.rst:652
#, fuzzy
msgid ":c:func:`!mmap` and :c:func:`!munmap` if available,"
msgstr "사용할 수 있으면 :c:func:`mmap`\\과 :c:func:`munmap`"

#: ../../c-api/memory.rst:653
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr "그렇지 않으면 :c:func:`malloc`\\과 :c:func:`free`"

#: ../../c-api/memory.rst:655
msgid ""
"This allocator is disabled if Python is configured with the :option"
":`--without-pymalloc` option. It can also be disabled at runtime using "
"the :envvar:`PYTHONMALLOC` environment variable (ex: "
"``PYTHONMALLOC=malloc``)."
msgstr ""

#: ../../c-api/memory.rst:660
msgid "Customize pymalloc Arena Allocator"
msgstr "pymalloc 아레나 할당자 사용자 정의"

#: ../../c-api/memory.rst:666
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr "아레나 할당자를 기술하는 데 사용되는 구조체. 이 구조체에는 세 개의 필드가 있습니다:"

#: ../../c-api/memory.rst:674
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:674
msgid "allocate an arena of size bytes"
msgstr "size 바이트의 아레나를 할당합니다"

#: ../../c-api/memory.rst:676
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:676
msgid "free an arena"
msgstr "아레나를 해제합니다"

#: ../../c-api/memory.rst:681
msgid "Get the arena allocator."
msgstr "아레나 할당자를 얻습니다."

#: ../../c-api/memory.rst:685
msgid "Set the arena allocator."
msgstr "아레나 할당자를 설정합니다."

#: ../../c-api/memory.rst:690
#, fuzzy
msgid "The mimalloc allocator"
msgstr "pymalloc 할당자"

#: ../../c-api/memory.rst:694
msgid ""
"Python supports the mimalloc allocator when the underlying platform "
"support is available. mimalloc \"is a general purpose allocator with "
"excellent performance characteristics. Initially developed by Daan Leijen"
" for the runtime systems of the Koka and Lean languages.\""
msgstr ""

#: ../../c-api/memory.rst:699
msgid "tracemalloc C API"
msgstr "tracemalloc C API"

#: ../../c-api/memory.rst:705
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr ":mod:`tracemalloc` 모듈에서 할당된 메모리 블록을 추적합니다."

#: ../../c-api/memory.rst:707
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate "
"memory to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"성공하면 ``0``\\을 반환하고, 에러가 발생하면 (추적을 저장하기 위한 메모리를 할당하지 못했습니다) ``-1``\\을 "
"반환합니다. tracemalloc이 비활성화되었으면 ``-2``\\를 반환합니다."

#: ../../c-api/memory.rst:710
msgid "If memory block is already tracked, update the existing trace."
msgstr "메모리 블록이 이미 추적되면, 기존 추적을 갱신합니다."

#: ../../c-api/memory.rst:714
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ":mod:`tracemalloc` 모듈에서 할당된 메모리 블록을 추적 해제합니다. 블록이 추적되지 않으면 아무것도 하지 않습니다."

#: ../../c-api/memory.rst:717
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr "tracemalloc이 비활성화되었으면 ``-2``\\를 반환하고, 그렇지 않으면 ``0``\\을 반환합니다."

#: ../../c-api/memory.rst:723
msgid "Examples"
msgstr "예"

#: ../../c-api/memory.rst:725
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that"
" the I/O buffer is allocated from the Python heap by using the first "
"function set::"
msgstr ""
"다음은 :ref:`memoryoverview` 섹션에서 따온 예제입니다. I/O 버퍼가 첫 번째 함수 집합을 사용하여 파이썬 힙에서"
" 할당되도록 다시 작성되었습니다::"

#: ../../c-api/memory.rst:728
msgid ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_Malloc */\n"
"return res;"
msgstr ""

#: ../../c-api/memory.rst:738
msgid "The same code using the type-oriented function set::"
msgstr "형 지향 함수 집합을 사용하는 같은 코드입니다::"

#: ../../c-api/memory.rst:740
msgid ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Del(buf); /* allocated with PyMem_New */\n"
"return res;"
msgstr ""

#: ../../c-api/memory.rst:750
msgid ""
"Note that in the two examples above, the buffer is always manipulated via"
" functions belonging to the same set. Indeed, it is required to use the "
"same memory API family for a given memory block, so that the risk of "
"mixing different allocators is reduced to a minimum. The following code "
"sequence contains two errors, one of which is labeled as *fatal* because "
"it mixes two different allocators operating on different heaps. ::"
msgstr ""
"위의 두 가지 예에서, 버퍼는 항상 같은 집합에 속하는 함수를 통해 조작됨에 유의하십시오. 실제로, 서로 다른 할당자를 혼합할 "
"위험이 최소로 줄어들도록, 주어진 메모리 블록에 대해 같은 메모리 API 패밀리를 사용하는 것은 필수입니다 . 다음 코드 시퀀스에는"
" 두 개의 에러가 있으며, 그중 하나는 서로 다른 힙에서 작동하는 두 개의 다른 할당자를 혼합하기 때문에 "
"*치명적(fatal)*\\인 것으로 표시됩니다. ::"

#: ../../c-api/memory.rst:757
msgid ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */\n"
"free(buf2);       /* Right -- allocated via malloc() */\n"
"free(buf1);       /* Fatal -- should be PyMem_Del()  */"
msgstr ""

#: ../../c-api/memory.rst:765
#, fuzzy
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the"
" Python heap, objects in Python are allocated and released with "
":c:macro:`PyObject_New`, :c:macro:`PyObject_NewVar` and "
":c:func:`PyObject_Del`."
msgstr ""
"파이썬 힙에서 원시 메모리 블록을 처리하기 위한 함수 외에도, 파이썬의 객체는 :c:func:`PyObject_New`, "
":c:func:`PyObject_NewVar` 및 :c:func:`PyObject_Del`\\로 할당되고 해제됩니다."

#: ../../c-api/memory.rst:769
msgid ""
"These will be explained in the next chapter on defining and implementing "
"new object types in C."
msgstr "이것들은 C로 새로운 객체 형을 정의하고 구현하는 것에 대한 다음 장에서 설명될 것입니다."

#: ../../c-api/memory.rst:43
msgid "malloc (C function)"
msgstr ""

#: ../../c-api/memory.rst:43
msgid "calloc (C function)"
msgstr ""

#: ../../c-api/memory.rst:43
msgid "realloc (C function)"
msgstr ""

#: ../../c-api/memory.rst:43
msgid "free (C function)"
msgstr ""

