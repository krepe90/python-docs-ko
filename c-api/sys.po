# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/sys.rst:6
msgid "Operating System Utilities"
msgstr "운영 체제 유틸리티"

#: ../../c-api/sys.rst:11
#, fuzzy
msgid ""
"Return the file system representation for *path*. If the object is a "
":class:`str` or :class:`bytes` object, then a new :term:`strong "
"reference` is returned. If the object implements the :class:`os.PathLike`"
" interface, then :meth:`~os.PathLike.__fspath__` is returned as long as "
"it is a :class:`str` or :class:`bytes` object. Otherwise :exc:`TypeError`"
" is raised and ``NULL`` is returned."
msgstr ""
"*path*\\에 대한 파일 시스템 표현을 반환합니다. 객체가 :class:`str`\\이나 :class:`bytes` 객체이면, "
"참조 횟수가 증가합니다. 객체가 :class:`os.PathLike` 인터페이스를 구현하면, "
":meth:`~os.PathLike.__fspath__`\\가 :class:`str`\\나 :class:`bytes` 객체일 때 "
"반환됩니다. 그렇지 않으면, :exc:`TypeError`\\가 발생하고 ``NULL``\\이 반환됩니다."

#: ../../c-api/sys.rst:24
#, fuzzy
msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* "
"is deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the :c:member:`PyConfig.interactive` "
"is non-zero, this function also returns true if the *filename* pointer is"
" ``NULL`` or if the name is equal to one of the strings ``'<stdin>'`` or "
"``'???'``."
msgstr ""
"이름이 *filename*\\인 표준 I/O 파일 *fp*\\를 대화식으로 간주하면 참(0이 아닙니다)을 반환합니다. "
"``isatty(fileno(fp))``\\가 참인 파일의 경우입니다. 전역 플래그 "
":c:data:`Py_InteractiveFlag`\\가 참이면, 이 함수는 *filename* 포인터가 ``NULL``\\이거나 "
"이름이 문자열 ``'<stdin>'``\\이나 ``'???'`` 중 하나와 같을 때도 참을 반환합니다."

#: ../../c-api/sys.rst:30
msgid "This function must not be called before Python is initialized."
msgstr ""

#: ../../c-api/sys.rst:35
msgid ""
"Function to prepare some internal state before a process fork.  This "
"should be called before calling :c:func:`fork` or any similar function "
"that clones the current process. Only available on systems where "
":c:func:`fork` is defined."
msgstr ""
"프로세스 포크 전에 내부 상태를 준비하는 함수. :c:func:`fork`\\나 현재 프로세스를 복제하는 유사한 함수를 호출하기 "
"전에 호출해야 합니다. :c:func:`fork`\\가 정의된 시스템에서만 사용 가능합니다."

#: ../../c-api/sys.rst:41
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" "
"thread <fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"C :c:func:`fork` 호출은 (:ref:`\"메인\" 인터프리터 <sub-interpreter-support>`\\의) "
":ref:`\"메인\" 스레드 <fork-and-threads>`\\에서만 이루어져야 합니다. "
"``PyOS_BeforeFork()``\\도 마찬가지입니다."

#: ../../c-api/sys.rst:51
msgid ""
"Function to update some internal state after a process fork.  This should"
" be called from the parent process after calling :c:func:`fork` or any "
"similar function that clones the current process, regardless of whether "
"process cloning was successful. Only available on systems where "
":c:func:`fork` is defined."
msgstr ""
"프로세스 포크 후 일부 내부 상태를 갱신하는 함수. 프로세스 복제가 성공했는지와 관계없이, :c:func:`fork`\\나 현재 "
"프로세스를 복제하는 유사한 함수를 호출한 후 부모 프로세스에서 호출해야 합니다. :c:func:`fork`\\가 정의된 시스템에서만"
" 사용 가능합니다."

#: ../../c-api/sys.rst:58
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" "
"thread <fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`).  The same is true for "
"``PyOS_AfterFork_Parent()``."
msgstr ""
"C :c:func:`fork` 호출은 (:ref:`\"메인\" 인터프리터 <sub-interpreter-support>`\\의) "
":ref:`\"메인\" 스레드 <fork-and-threads>`\\에서만 이루어져야 합니다. "
"``PyOS_AfterFork_Parent()``\\도 마찬가지입니다."

#: ../../c-api/sys.rst:68
msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or "
"any similar function that clones the current process, if there is any "
"chance the process will call back into the Python interpreter. Only "
"available on systems where :c:func:`fork` is defined."
msgstr ""
"프로세스 포크 후 내부 인터프리터 상태를 갱신하는 함수. :c:func:`fork`\\나 현재 프로세스를 복제하는 유사한 함수를 "
"호출한 후, 프로세스가 파이썬 인터프리터를 다시 호출할 가능성이 있으면 자식 프로세스에서 호출해야 합니다. "
":c:func:`fork`\\가 정의된 시스템에서만 사용 가능합니다."

#: ../../c-api/sys.rst:75
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" "
"thread <fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"C :c:func:`fork` 호출은 (:ref:`\"메인\" 인터프리터 <sub-interpreter-support>`\\의) "
":ref:`\"메인\" 스레드 <fork-and-threads>`\\에서만 이루어져야 합니다. "
"``PyOS_AfterFork_Child()``\\도 마찬가지입니다."

#: ../../c-api/sys.rst:83
msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to"
" be called by :c:func:`PyOS_BeforeFork()`, "
":c:func:`PyOS_AfterFork_Parent` and  :c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork`\\를 사용하면 :c:func:`PyOS_BeforeFork()`, "
":c:func:`PyOS_AfterFork_Parent` 및 :c:func:`PyOS_AfterFork_Child`\\에서 호출될 "
"사용자 정의 파이썬 함수를 등록 할 수 있습니다."

#: ../../c-api/sys.rst:90
msgid ""
"Function to update some internal state after a process fork; this should "
"be called in the new process if the Python interpreter will continue to "
"be used. If a new executable is loaded into the new process, this "
"function does not need to be called."
msgstr ""
"프로세스 포크 후 일부 내부 상태를 갱신하는 함수; 파이썬 인터프리터가 계속 사용된다면 새로운 프로세스에서 호출되어야 합니다. 새 "
"실행 파일이 새 프로세스에 로드되면, 이 함수를 호출할 필요가 없습니다."

#: ../../c-api/sys.rst:95
msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "이 함수는 :c:func:`PyOS_AfterFork_Child()`\\로 대체되었습니다."

#: ../../c-api/sys.rst:103
#, fuzzy
msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :c:macro:`!USE_STACKCHECK` is "
"defined (currently on certain versions of Windows using the Microsoft "
"Visual C++ compiler). :c:macro:`!USE_STACKCHECK` will be defined "
"automatically; you should never change the definition in your own code."
msgstr ""
"인터프리터에 스택 공간이 부족하면 참을 반환합니다. 이것은 신뢰성 있는 확인이지만, :const:`USE_STACKCHECK`\\이"
" 정의되어 있을 때만 사용할 수 있습니다 (현재 마이크로소프트 Visual C++ 컴파일러를 사용하는 윈도우에서). "
":const:`USE_STACKCHECK`\\은 자동으로 정의됩니다; 여러분 자신의 코드에서 정의를 변경해서는 안 됩니다."

#: ../../c-api/sys.rst:115
#, fuzzy
msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper"
" around either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call "
"those functions directly!"
msgstr ""
"시그널 *i*\\에 대한 현재 시그널 처리기를 반환합니다. 이것은 :c:func:`sigaction`\\이나 "
":c:func:`signal`\\을 감싸는 얇은 래퍼입니다. 그 함수들을 직접 호출하지 마십시오! "
":c:type:`PyOS_sighandler_t`\\는 :c:type:`void (\\*)(int)`\\의 typedef "
"별칭입니다."

#: ../../c-api/sys.rst:122
#, fuzzy
msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`!sigaction` or "
":c:func:`!signal`.  Do not call those functions directly!"
msgstr ""
"시그널 *i*\\의 시그널 처리기를 *h*\\로 설정합니다; 이전 시그널 처리기를 반환합니다. 이것은 "
":c:func:`sigaction`\\이나 :c:func:`signal`\\을 감싸는 얇은 래퍼입니다. 그 함수들을 직접 호출하지 "
"마십시오! :c:type:`PyOS_sighandler_t`\\는 :c:type:`void (\\*)(int)`\\의 typedef"
" 별칭입니다."

#: ../../c-api/sys.rst:129
msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` "
"API with the :c:func:`PyConfig_SetBytesString` function which ensures "
"that :ref:`Python is preinitialized <c-preinit>`."
msgstr ""

#: ../../c-api/sys.rst:133 ../../c-api/sys.rst:200
msgid ""
"This function must not be called before :ref:`Python is preinitialized "
"<c-preinit>` and so that the LC_CTYPE locale is properly configured: see "
"the :c:func:`Py_PreInitialize` function."
msgstr ""

#: ../../c-api/sys.rst:137
#, fuzzy
msgid ""
"Decode a byte string from the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
":ref:`surrogateescape 에러 처리기 <surrogateescape>`\\를 사용하여 로케일 인코딩에서 바이트열을 "
"디코딩합니다: 디코딩할 수 없는 바이트열은 U+DC80..U+DCFF 범위의 문자로 디코딩됩니다. 바이트 시퀀스를 서로게이트 문자로"
" 디코딩 할 수 있으면, 이들을 디코딩하는 대신 surrogateescape 에러 처리기를 사용하여 바이트열를 이스케이프 합니다."

#: ../../c-api/sys.rst:144
msgid ""
"Return a pointer to a newly allocated wide character string, use "
":c:func:`PyMem_RawFree` to free the memory. If size is not ``NULL``, "
"write the number of wide characters excluding the null character into "
"``*size``"
msgstr ""
"새로 할당된 와이드 문자(wide character) 문자열에 대한 포인터를 반환합니다, 메모리를 해제하려면 "
":c:func:`PyMem_RawFree`\\를 사용하십시오. size가 ``NULL``\\이 아니면, 널 문자를 제외한 와이드 "
"문자 수를 ``*size``\\에 기록합니다."

#: ../../c-api/sys.rst:148
msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* "
"is not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or "
"set to ``(size_t)-2`` on decoding error."
msgstr ""
"디코딩 에러나 메모리 할당 에러 시 ``NULL``\\을 반환합니다. *size*\\가 ``NULL``\\이 아니면, 메모리 에러 "
"시 ``*size``\\가 ``(size_t)-1``\\로 설정되고, 디코딩 에러 시 ``(size_t)-2``\\로 설정됩니다."

#: ../../c-api/sys.rst:152 ../../c-api/sys.rst:192
msgid ""
"The :term:`filesystem encoding and error handler` are selected by "
":c:func:`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` "
"and :c:member:`~PyConfig.filesystem_errors` members of "
":c:type:`PyConfig`."
msgstr ""

#: ../../c-api/sys.rst:156
msgid ""
"Decoding errors should never happen, unless there is a bug in the C "
"library."
msgstr "C 라이브러리에 버그가 없으면, 디코딩 에러가 발생하지 않아야 합니다."

#: ../../c-api/sys.rst:159
msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string"
" back to a byte string."
msgstr "문자열을 바이트열로 다시 인코딩하려면 :c:func:`Py_EncodeLocale` 함수를 사용하십시오."

#: ../../c-api/sys.rst:164
msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and "
":c:func:`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
":c:func:`PyUnicode_DecodeFSDefaultAndSize`\\와 "
":c:func:`PyUnicode_DecodeLocaleAndSize` 함수."

#: ../../c-api/sys.rst:169 ../../c-api/sys.rst:211
#, fuzzy
msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr "이 함수는 파이썬 UTF-8 모드에서 UTF-8 인코딩을 사용합니다."

#: ../../c-api/sys.rst:173
#, fuzzy
msgid ""
"The function now uses the UTF-8 encoding on Windows if "
":c:member:`PyPreConfig.legacy_windows_fs_encoding` is zero;"
msgstr ""
"이 함수는 이제 윈도우에서 :c:data:`Py_LegacyWindowsFSEncodingFlag`\\가 0이면 UTF-8 인코딩을"
" 사용합니다;"

#: ../../c-api/sys.rst:180
#, fuzzy
msgid ""
"Encode a wide character string to the :term:`filesystem encoding and "
"error handler`. If the error handler is :ref:`surrogateescape error "
"handler <surrogateescape>`, surrogate characters in the range "
"U+DC80..U+DCFF are converted to bytes 0x80..0xFF."
msgstr ""
":ref:`surrogateescape 에러 처리기 <surrogateescape>`\\를 사용하여 와이드 문자(wide "
"character) 문자열을 로케일 인코딩으로 인코딩합니다: U+DC80..U+DCFF 범위의 서로게이트 문자는 바이트 "
"0x80..0xFF로 변환됩니다."

#: ../../c-api/sys.rst:185
#, fuzzy
msgid ""
"Return a pointer to a newly allocated byte string, use "
":c:func:`PyMem_Free` to free the memory. Return ``NULL`` on encoding "
"error or memory allocation error."
msgstr ""
"새로 할당된 바이트열에 대한 포인터를 반환합니다, 메모리를 해제하려면 :c:func:`PyMem_Free`\\를 사용하십시오. "
"인코딩 에러나 메모리 할당 에러 시 ``NULL``\\을 반환합니다"

#: ../../c-api/sys.rst:189
msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"error_pos가 ``NULL``\\이 아니면, ``*error_pos``\\는 성공 시 ``(size_t)-1``\\로 "
"설정되고, 인코딩 에러 시 유효하지 않은 문자의 인덱스로 설정됩니다."

#: ../../c-api/sys.rst:196
msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string "
"back to a wide character string."
msgstr "바이트열을 와이드 문자 문자열로 다시 디코딩하려면 :c:func:`Py_DecodeLocale` 함수를 사용하십시오."

#: ../../c-api/sys.rst:206
msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and "
":c:func:`PyUnicode_EncodeLocale` functions."
msgstr ""
":c:func:`PyUnicode_EncodeFSDefault`\\와 :c:func:`PyUnicode_EncodeLocale` "
"함수."

#: ../../c-api/sys.rst:215
#, fuzzy
msgid ""
"The function now uses the UTF-8 encoding on Windows if "
":c:member:`PyPreConfig.legacy_windows_fs_encoding` is zero."
msgstr ""
"이 함수는 이제 윈도우에서 :c:data:`Py_LegacyWindowsFSEncodingFlag`\\가 0이면 UTF-8 인코딩을"
" 사용합니다;"

#: ../../c-api/sys.rst:223
msgid "System Functions"
msgstr "시스템 함수"

#: ../../c-api/sys.rst:225
msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal "
"thread state structure."
msgstr ""
":mod:`sys` 모듈의 기능을 C 코드에서 액세스 할 수 있게 하는 유틸리티 함수입니다. 모두 내부 스레드 상태 구조체에 포함된"
" 현재 인터프리터 스레드의 :mod:`sys` 모듈의 딕셔너리에 작동합니다."

#: ../../c-api/sys.rst:231
msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it "
"does not exist, without setting an exception."
msgstr ""
":mod:`sys` 모듈에서 객체 *name*\\을 반환하거나, 존재하지 않으면 예외를 설정하지 않고 ``NULL``\\을 "
"반환합니다."

#: ../../c-api/sys.rst:236
msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in "
"which case *name* is deleted from the sys module. Returns ``0`` on "
"success, ``-1`` on error."
msgstr ""
"*v*\\가 *NULL*\\이 아닌 한 :mod:`sys` 모듈의 *name*\\을 *v*\\로 설정합니다. ``NULL``\\이면"
" *name*\\은 sys 모듈에서 삭제됩니다. 성공하면 ``0``, 에러 시 ``-1``\\을 반환합니다."

#: ../../c-api/sys.rst:242
msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be "
"called prior to :c:func:`Py_Initialize`."
msgstr ""
":data:`sys.warnoptions`\\를 빈 리스트로 재설정합니다. 이 함수는 :c:func:`Py_Initialize` "
"이전에 호출할 수 있습니다."

#: ../../c-api/sys.rst:245
msgid "Clear :data:`sys.warnoptions` and :data:`!warnings.filters` instead."
msgstr ""

#: ../../c-api/sys.rst:250
msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr ""
"*format*\\으로 기술되는 출력 문자열을 :data:`sys.stdout`\\에 기록합니다. 잘림이 발생하더라도 예외는 "
"발생하지 않습니다 (아래를 참조하십시오)."

#: ../../c-api/sys.rst:253
#, python-format
msgid ""
"*format* should limit the total size of the formatted output string to "
"1000 bytes or less -- after 1000 bytes, the output string is truncated. "
"In particular, this means that no unrestricted \"%s\" formats should "
"occur; these should be limited using \"%.<N>s\" where <N> is a decimal "
"number calculated so that <N> plus the maximum size of other formatted "
"text does not exceed 1000 bytes.  Also watch out for \"%f\", which can "
"print hundreds of digits for very large numbers."
msgstr ""
"*format*\\은 포맷된 출력 문자열의 총 크기를 1000바이트 이하로 제한해야 합니다 -- 1000바이트 이후에는, 출력 "
"문자열이 잘립니다. 특히, 이것은 무제한 \"%s\" 포맷이 있어서는 안 됨을 의미합니다; \"%.<N>s\"를 사용하여 제한해야 "
"합니다, 여기서 <N>은 <N>에 다른 포맷된 텍스트의 최대 크기를 더할 때 1000바이트를 초과하지 않도록 계산된 십진수입니다. "
"또한 \"%f\"도 주의하십시오, 아주 큰 숫자는 수백 자리를 인쇄할 수 있습니다."

#: ../../c-api/sys.rst:261
msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted "
"message is written to the real (C level) *stdout*."
msgstr ""
"문제가 발생하거나, :data:`sys.stdout`\\가 설정되어 있지 않으면, 포맷된 메시지는 실제(C 수준) "
"*stdout*\\에 기록됩니다."

#: ../../c-api/sys.rst:266
msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or "
"*stderr* instead."
msgstr ""
":c:func:`PySys_WriteStdout`\\과 같지만, 대신 :data:`sys.stderr`\\이나 *stderr*\\에"
" 씁니다."

#: ../../c-api/sys.rst:271
msgid ""
"Function similar to PySys_WriteStdout() but format the message using "
":c:func:`PyUnicode_FromFormatV` and don't truncate the message to an "
"arbitrary length."
msgstr ""
"PySys_WriteStdout()과 유사한 함수이지만, 메시지를 :c:func:`PyUnicode_FromFormatV`\\를 "
"사용하여 포맷하고 메시지를 임의의 길이로 자르지 않습니다."

#: ../../c-api/sys.rst:279
msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or "
"*stderr* instead."
msgstr ""
":c:func:`PySys_FormatStdout`\\과 같지만, 대신 :data:`sys.stderr`\\이나 "
"*stderr*\\에 씁니다."

#: ../../c-api/sys.rst:286
msgid ""
"Return the current dictionary of :option:`-X` options, similarly to "
":data:`sys._xoptions`.  On error, ``NULL`` is returned and an exception "
"is set."
msgstr ""
":data:`sys._xoptions`\\와 유사하게, :option:`-X` 옵션의 현재 딕셔너리를 반환합니다. 에러가 발생하면,"
" ``NULL``\\이 반환되고 예외가 설정됩니다."

#: ../../c-api/sys.rst:295
msgid ""
"Raise an auditing event with any active hooks. Return zero for success "
"and non-zero with an exception set on failure."
msgstr "모든 활성 훅으로 감사 이벤트를 발생시킵니다. 성공 시 0을 반환하고 실패 시 예외를 설정하여 0이 아닌 값을 반환합니다."

#: ../../c-api/sys.rst:298
msgid "The *event* string argument must not be *NULL*."
msgstr ""

#: ../../c-api/sys.rst:300
#, fuzzy
msgid ""
"If any hooks have been added, *format* and other arguments will be used "
"to construct a tuple to pass. Apart from ``N``, the same format "
"characters as used in :c:func:`Py_BuildValue` are available. If the built"
" value is not a tuple, it will be added into a single-element tuple."
msgstr ""
"훅이 추가되었으면, *format*\\과 기타 인자를 사용하여 전달할 튜플을 구성합니다. ``N`` 외에도, "
":c:func:`Py_BuildValue`\\에서 사용된 것과 같은 포맷 문자를 사용할 수 있습니다. 빌드된 값이 튜플이 아니면, "
"단일 요소 튜플에 추가됩니다. (``N`` 포맷 옵션은 참조를 소비하지만, 이 함수에 대한 인자가 소비될지를 알 방법이 없기 "
"때문에, 사용하면 참조 누수가 발생할 수 있습니다.)"

#: ../../c-api/sys.rst:305
msgid ""
"The ``N`` format option must not be used. It consumes a reference, but "
"since there is no way to know whether arguments to this function will be "
"consumed, using it may cause reference leaks."
msgstr ""

#: ../../c-api/sys.rst:309
#, fuzzy
msgid ""
"Note that ``#`` format characters should always be treated as "
":c:type:`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was "
"defined."
msgstr ""
"``PY_SSIZE_T_CLEAN``\\이 정의되었는지와 관계없이, ``#`` 포맷 문자는 항상 ``Py_ssize_t``\\로 "
"처리되어야 합니다."

#: ../../c-api/sys.rst:312
msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit`\\은 파이썬 코드와 동일한 기능을 수행합니다."

#: ../../c-api/sys.rst:314
msgid "See also :c:func:`PySys_AuditTuple`."
msgstr ""

#: ../../c-api/sys.rst:320
#, fuzzy
msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr "``#`` 포맷 문자에 대해 ``Py_ssize_t``\\를 요구합니다. 이전에는, 피할 수 없는 폐지 경고가 발생했습니다."

#: ../../c-api/sys.rst:326
msgid ""
"Similar to :c:func:`PySys_Audit`, but pass arguments as a Python object. "
"*args* must be a :class:`tuple`. To pass no arguments, *args* can be "
"*NULL*."
msgstr ""

#: ../../c-api/sys.rst:334
#, fuzzy
msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return "
"zero on success and non-zero on failure. If the runtime has been "
"initialized, also set an error on failure. Hooks added through this API "
"are called for all interpreters created by the runtime."
msgstr ""
"활성 감사 훅 리스트에 콜러블 *hook*\\을 추가합니다. 성공하면 0을, 실패하면 0이 아닌 값을 반환합니다. 런타임이 "
"초기화되었으면, 실패 시 에러도 설정합니다. 이 API를 통해 추가된 훅은 런타임이 만든 모든 인터프리터에 대해 호출됩니다."

#: ../../c-api/sys.rst:340
msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr ""
"*userData* 포인터는 훅 함수로 전달됩니다. 훅 함수는 다른 런타임에서 호출될 수 있어서, 이 포인터는 파이썬 상태를 직접 "
"참조하면 안 됩니다."

#: ../../c-api/sys.rst:344
msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called"
" after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from "
":class:`Exception` (other errors will not be silenced)."
msgstr ""
"이 함수는 :c:func:`Py_Initialize` 이전에 호출해도 안전합니다. 런타임 초기화 후 호출되면, 기존 감사 훅에 "
"알리고 :class:`Exception`\\에서 서브 클래싱 된 에러를 발생 시켜 조용히 연산을 중단할 수 있습니다 (다른 에러는 "
"억제되지(silenced) 않습니다)."

#: ../../c-api/sys.rst:349
msgid ""
"The hook function is always called with the GIL held by the Python "
"interpreter that raised the event."
msgstr ""

#: ../../c-api/sys.rst:352
msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the "
":ref:`audit events table <audit-events>`. Details are in each function's "
"documentation."
msgstr ""
"감사에 대한 자세한 설명은 :pep:`578`\\을 참조하십시오. 이벤트를 발생시키는 런타임과 표준 라이브러리의 함수는 "
":ref:`감사 이벤트 표 <audit-events>`\\에 나열되어 있습니다. 자세한 내용은 각 함수 설명서에 있습니다."

#: ../../c-api/sys.rst:357 ../../c-api/sys.rst:359
#, fuzzy
msgid ""
"If the interpreter is initialized, this function raises an auditing event"
" ``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added"
" and the exception is cleared. As a result, callers cannot assume that "
"their hook has been added unless they control all existing hooks."
msgstr ""
"인터프리터가 초기화되면, 이 함수는 인자 없이 감사 이벤트 ``sys.addaudithook``\\을 발생시킵니다. 기존 훅이 "
":class:`Exception`\\에서 파생된 예외를 발생시키면, 새 훅이 추가되지 않고 예외가 지워집니다. 결과적으로, 호출자가"
" 기존의 모든 훅을 제어하지 않는 한 훅이 추가되었다고 가정할 수 없습니다."

#: ../../c-api/sys.rst:368
msgid ""
"The type of the hook function. *event* is the C string event argument "
"passed to :c:func:`PySys_Audit` or :c:func:`PySys_AuditTuple`. *args* is "
"guaranteed to be a :c:type:`PyTupleObject`. *userData* is the argument "
"passed to PySys_AddAuditHook()."
msgstr ""

#: ../../c-api/sys.rst:380
msgid "Process Control"
msgstr "프로세스 제어"

#: ../../c-api/sys.rst:387
#, fuzzy
msgid ""
"Print a fatal error message and kill the process.  No cleanup is "
"performed. This function should only be invoked when a condition is "
"detected that would make it dangerous to continue using the Python "
"interpreter; e.g., when the object administration appears to be "
"corrupted.  On Unix, the standard C library function :c:func:`!abort` is "
"called which will attempt to produce a :file:`core` file."
msgstr ""
"치명적인 에러 메시지를 인쇄하고 프로세스를 죽입니다. 아무런 정리도 수행되지 않습니다. 이 함수는 파이썬 인터프리터를 계속 사용하는"
" 것이 위험한 조건이 감지되었을 때만 호출해야 합니다; 예를 들어, 객체 관리가 손상된 것으로 보일 때. 유닉스에서는, 표준 C "
"라이브러리 함수 :c:func:`abort`\\가 호출되어 :file:`core` 파일을 생성하려고 시도합니다."

#: ../../c-api/sys.rst:394
msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
"``Py_LIMITED_API`` 매크로가 정의되어 있지 않은 한, ``Py_FatalError()`` 함수는 현재 함수의 이름을 "
"자동으로 로그 하는 매크로로 대체됩니다."

#: ../../c-api/sys.rst:398
msgid "Log the function name automatically."
msgstr "함수 이름을 자동으로 로그 합니다."

#: ../../c-api/sys.rst:408
msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then "
"calls the standard C library function ``exit(status)``.  If "
":c:func:`Py_FinalizeEx` indicates an error, the exit status is set to "
"120."
msgstr ""
"현재 프로세스를 종료합니다. 이것은 :c:func:`Py_FinalizeEx`\\를 호출한 다음 표준 C 라이브러리 함수 "
"``exit(status)``\\를 호출합니다. :c:func:`Py_FinalizeEx`\\가 에러를 표시하면, 종료 상태는 "
"120으로 설정됩니다."

#: ../../c-api/sys.rst:412
msgid "Errors from finalization no longer ignored."
msgstr "파이널리제이션에서의 에러가 더는 무시되지 않습니다."

#: ../../c-api/sys.rst:422
msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The"
" cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on "
"failure, it returns ``-1``.  The cleanup function registered last is "
"called first. Each cleanup function will be called at most once.  Since "
"Python's internal finalization will have completed before the cleanup "
"function, no Python APIs should be called by *func*."
msgstr ""
":c:func:`Py_FinalizeEx`\\가 호출할 정리 함수를 등록합니다. 정리 함수는 인자 없이 호출되며 값을 반환하지 "
"않아야 합니다. 최대 32개의 정리 함수를 등록할 수 있습니다. 등록이 성공하면, :c:func:`Py_AtExit`\\는 "
"``0``\\을 반환합니다; 실패하면 ``-1``\\을 반환합니다. 마지막에 등록된 정리 함수가 먼저 호출됩니다. 각 정리 함수는 "
"최대 한 번 호출됩니다. 정리 함수 전에 파이썬의 내부 파이널리제이션이 완료되기 때문에, *func*\\에서 파이썬 API를 "
"호출하면 안 됩니다."

#: ../../c-api/sys.rst:432
msgid ":c:func:`PyUnstable_AtExit` for passing a ``void *data`` argument."
msgstr ""

#: ../../c-api/sys.rst:101
msgid "USE_STACKCHECK (C macro)"
msgstr ""

#: ../../c-api/sys.rst:385
msgid "abort (C function)"
msgstr ""

#: ../../c-api/sys.rst:404 ../../c-api/sys.rst:418
msgid "Py_FinalizeEx (C function)"
msgstr ""

#: ../../c-api/sys.rst:404
#, fuzzy
msgid "exit (C function)"
msgstr "시스템 함수"

#: ../../c-api/sys.rst:418
#, fuzzy
msgid "cleanup functions"
msgstr "시스템 함수"

#~ msgid "Encoding, highest priority to lowest priority:"
#~ msgstr "인코딩, 가장 높은 우선순위에서 가장 낮은 우선순위로:"

#~ msgid "``UTF-8`` on macOS, Android, and VxWorks;"
#~ msgstr "``UTF-8``, 맥 OS, 안드로이드 및 VxWorks에서;"

#~ msgid ""
#~ "``UTF-8`` on Windows if "
#~ ":c:data:`Py_LegacyWindowsFSEncodingFlag` is zero;"
#~ msgstr "``UTF-8``, :c:data:`Py_LegacyWindowsFSEncodingFlag`\\이 0일 때 윈도우에서;"

#~ msgid "``UTF-8`` if the Python UTF-8 mode is enabled;"
#~ msgstr "``UTF-8``, 파이썬 UTF-8 모드가 활성화되었을 때;"

#~ msgid ""
#~ "``ASCII`` if the ``LC_CTYPE`` locale is"
#~ " ``\"C\"``, ``nl_langinfo(CODESET)`` returns the"
#~ " ``ASCII`` encoding (or an alias), "
#~ "and :c:func:`mbstowcs` and :c:func:`wcstombs` "
#~ "functions uses the ``ISO-8859-1`` encoding."
#~ msgstr ""
#~ "``ASCII``, ``LC_CTYPE`` 로케일이 ``\"C\"``\\이고, "
#~ "``nl_langinfo(CODESET)``\\이 ``ASCII`` 인코딩(또는 별칭)을"
#~ " 반환하고, :c:func:`mbstowcs`\\와 :c:func:`wcstombs` "
#~ "함수가 ``ISO-8859-1`` 인코딩을 사용할 때."

#~ msgid "the current locale encoding."
#~ msgstr "현재 로케일 인코딩"

#~ msgid "The function now uses the UTF-8 encoding in the UTF-8 mode."
#~ msgstr "이 함수는 이제 UTF-8 모드에서 UTF-8 인코딩을 사용합니다."

#~ msgid ""
#~ "Append *s* to :data:`sys.warnoptions`. This"
#~ " function must be called prior to "
#~ ":c:func:`Py_Initialize` in order to affect "
#~ "the warnings filter list."
#~ msgstr ""
#~ "*s*\\를 :data:`sys.warnoptions`\\에 추가합니다. 경고 필터"
#~ " 리스트에 영향을 주려면 :c:func:`Py_Initialize` 이전에"
#~ " 이 함수를 호출해야 합니다."

#~ msgid "Append *unicode* to :data:`sys.warnoptions`."
#~ msgstr "*unicode*\\를 :data:`sys.warnoptions`\\에 추가합니다."

#~ msgid ""
#~ "Note: this function is not currently "
#~ "usable from outside the CPython "
#~ "implementation, as it must be called "
#~ "prior to the implicit import of "
#~ ":mod:`warnings` in :c:func:`Py_Initialize` to "
#~ "be effective, but can't be called "
#~ "until enough of the runtime has "
#~ "been initialized to permit the creation"
#~ " of Unicode objects."
#~ msgstr ""
#~ "참고: 이 함수는 현재 CPython 구현 외부에서 "
#~ "사용할 수 없습니다. 효과가 있으려면 "
#~ ":c:func:`Py_Initialize`\\에서 :mod:`warnings`\\를 묵시적으로 "
#~ "임포트 하기 전에 호출해야 하지만, 유니코드 객체를 "
#~ "만들도록 허락할 수 있을 만큼 런타임이 충분히 "
#~ "초기화되기 전에는 호출할 수 없기 때문입니다."

#~ msgid ""
#~ "Set :data:`sys.path` to a list object"
#~ " of paths found in *path* which "
#~ "should be a list of paths "
#~ "separated with the platform's search "
#~ "path delimiter (``:`` on Unix, ``;`` "
#~ "on Windows)."
#~ msgstr ""
#~ ":data:`sys.path`\\를 플랫폼의 검색 경로 구분자(유닉스에서는 "
#~ "``:``, 윈도우에서는 ``;``)로 구분된 경로 리스트여야 "
#~ "하는 *path*\\에서 찾은 경로의 리스트 객체로 "
#~ "설정합니다."

#~ msgid ""
#~ "Parse *s* as a set of :option:`-X`"
#~ " options and add them to the "
#~ "current options mapping as returned by"
#~ " :c:func:`PySys_GetXOptions`. This function may"
#~ " be called prior to "
#~ ":c:func:`Py_Initialize`."
#~ msgstr ""
#~ "*s*\\를 :option:`-X` 옵션 집합으로 구문 분석하고 "
#~ ":c:func:`PySys_GetXOptions`\\가 반환하는 현재 옵션 매핑에"
#~ " 추가합니다. 이 함수는 :c:func:`Py_Initialize` 이전에"
#~ " 호출할 수 있습니다."

#~ msgid ""
#~ "The hook function is of type "
#~ ":c:type:`int (*)(const char *event, PyObject"
#~ " *args, void *userData)`, where *args* "
#~ "is guaranteed to be a "
#~ ":c:type:`PyTupleObject`. The hook function is"
#~ " always called with the GIL held "
#~ "by the Python interpreter that raised"
#~ " the event."
#~ msgstr ""
#~ "훅 함수는 :c:type:`int (*)(const char "
#~ "*event, PyObject *args, void *userData)` "
#~ "형입니다. 여기서 *args*\\는 :c:type:`PyTupleObject` 임이"
#~ " 보장됩니다. 훅 함수는 항상 이벤트를 발생시킨 파이썬"
#~ " 인터프리터가 GIL을 잡은 채로 호출됩니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``sys.addaudithook`` with no arguments."
#~ msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys.addaudithook``\\을 발생시킵니다."

