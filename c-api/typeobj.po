# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/typeobj.rst:6
#, fuzzy
msgid "Type Object Structures"
msgstr "비동기 객체 구조체"

#: ../../c-api/typeobj.rst:8
#, fuzzy
msgid ""
"Perhaps one of the most important structures of the Python object system "
"is the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` "
"or ``PyType_*`` functions, but do not offer much that's interesting to "
"most Python applications. These objects are fundamental to how objects "
"behave, so they are very important to the interpreter itself and to any "
"extension module that implements new types."
msgstr ""
"아마도 파이썬 객체 시스템의 가장 중요한 구조체 중 하나는 새로운 형을 정의하는 구조체일 것입니다: "
":c:type:`PyTypeObject` 구조체. :c:func:`PyObject_\\*`\\나 "
":c:func:`PyType_\\*` 함수를 사용하여 형 객체를 처리할 수 있지만, 대부분 파이썬 응용 프로그램이 흥미를 느낄 것은"
" 많이 제공하지 않습니다. 이 객체는 객체의 동작 방식의 기초를 이루므로, 인터프리터 자체와 새로운 형을 구현하는 확장 모듈에 매우"
" 중요합니다."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The"
" reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part"
" of the type's functionality.  The fields of the type object are examined"
" in detail in this section.  The fields will be described in the order in"
" which they occur in the structure."
msgstr ""
"형 객체는 대부분 표준형보다 상당히 큽니다. 크기가 큰 이유는 각 형 객체가 많은 수의 값을 저장하기 때문인데, 주로 C 함수 "
"포인터이고 각기 형의 기능 중 작은 부분을 구현합니다. 이 섹션에서는 형 객체의 필드를 자세히 살펴봅니다. 필드는 구조체에서 "
"나타나는 순서대로 설명됩니다."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples`"
" section provides at-a-glance insight into the meaning and use of "
":c:type:`PyTypeObject`."
msgstr ""
"다음의 간략 참조 외에도, :ref:`typedef-examples` 섹션은 :c:type:`PyTypeObject`\\의 의미와 "
"사용에 대한 통찰을 제공합니다."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "간략 참조"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp 슬롯\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject 슬롯 [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`형 <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "특수 메서드/어트리뷰트"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "정보 [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:416
#, fuzzy
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:346
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:370
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:375
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:368
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:404
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:440
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:381
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:386
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:350
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:429
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:406
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
#, fuzzy
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:412
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:414
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:341 ../../c-api/typeobj.rst:346
#: ../../c-api/typeobj.rst:356 ../../c-api/typeobj.rst:368
#: ../../c-api/typeobj.rst:370 ../../c-api/typeobj.rst:381
#: ../../c-api/typeobj.rst:392 ../../c-api/typeobj.rst:404
#: ../../c-api/typeobj.rst:406 ../../c-api/typeobj.rst:412
#: ../../c-api/typeobj.rst:414 ../../c-api/typeobj.rst:416
#: ../../c-api/typeobj.rst:429 ../../c-api/typeobj.rst:431
#: ../../c-api/typeobj.rst:435 ../../c-api/typeobj.rst:440
#: ../../c-api/typeobj.rst:446
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:392
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:398
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
#, fuzzy
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:362
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:341
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:356
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:348
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:348
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:150
#, fuzzy
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:150
#, fuzzy
msgid "unsigned char"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) "
"deprecated."
msgstr ""

#: ../../c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""

#: ../../c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:162
msgid "**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""

#: ../../c-api/typeobj.rst:164
msgid "Columns:"
msgstr "열:"

#: ../../c-api/typeobj.rst:166
#, fuzzy
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: :c:type:`PyBaseObject_Type`\\에 설정"

#: ../../c-api/typeobj.rst:168
#, fuzzy
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**: :c:type:`PyType_Type`\\에 설정"

#: ../../c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**: 기본값 (슬롯이 ``NULL``\\로 설정된 경우)"

#: ../../c-api/typeobj.rst:172
msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""

#: ../../c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: 상속"

#: ../../c-api/typeobj.rst:182
msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"
msgstr ""

#: ../../c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal "
"attribute lookup chain."
msgstr "일부 슬롯은 일반 어트리뷰트 조회 체인을 통해 효과적으로 상속됨에 유의하십시오."

#: ../../c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "서브 슬롯"

#: ../../c-api/typeobj.rst:201
msgid "Slot"
msgstr "슬롯"

#: ../../c-api/typeobj.rst:201
msgid "special methods"
msgstr "특수 메서드"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:206
#: ../../c-api/typeobj.rst:208 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:246
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:281 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:431
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:210
#, fuzzy
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:210
#, fuzzy
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:229 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:270 ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:285 ../../c-api/typeobj.rst:287
#: ../../c-api/typeobj.rst:289 ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:296 ../../c-api/typeobj.rst:302
#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:322
#: ../../c-api/typeobj.rst:435
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:222
#, fuzzy
msgid "__isub__"
msgstr "__sub__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:232
#, fuzzy
msgid "__imod__"
msgstr "__mod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:240
#, fuzzy
msgid "__ipow__"
msgstr "__pow__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:246
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:255
#, fuzzy
msgid "__ilshift__"
msgstr "__lshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:260
#, fuzzy
msgid "__irshift__"
msgstr "__rshift__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:265
#, fuzzy
msgid "__iand__"
msgstr "__and__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:270
#, fuzzy
msgid "__ixor__"
msgstr "__xor__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:275
#, fuzzy
msgid "__ior__"
msgstr "__or__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:281
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:285
#, fuzzy
msgid "__ifloordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:289
#, fuzzy
msgid "__itruediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:296
#, fuzzy
msgid "__imatmul__"
msgstr "__matmul__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
#: ../../c-api/typeobj.rst:416
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:304 ../../c-api/typeobj.rst:462
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:311
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:313 ../../c-api/typeobj.rst:315
#: ../../c-api/typeobj.rst:324 ../../c-api/typeobj.rst:446
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:451
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:320 ../../c-api/typeobj.rst:457
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:320
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:336
msgid "slot typedefs"
msgstr "슬롯 typedef"

#: ../../c-api/typeobj.rst:339
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:339
msgid "Parameter Types"
msgstr "매개 변수 형"

#: ../../c-api/typeobj.rst:339
msgid "Return Type"
msgstr "반환형"

#: ../../c-api/typeobj.rst:346 ../../c-api/typeobj.rst:348
#: ../../c-api/typeobj.rst:424
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst ../../c-api/typeobj.rst:350
#: ../../c-api/typeobj.rst:362 ../../c-api/typeobj.rst:375
#: ../../c-api/typeobj.rst:386 ../../c-api/typeobj.rst:398
#: ../../c-api/typeobj.rst:418 ../../c-api/typeobj.rst:429
#: ../../c-api/typeobj.rst:451 ../../c-api/typeobj.rst:457
#: ../../c-api/typeobj.rst:462
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:404
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:418
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:424
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:469
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "자세한 내용은 아래 :ref:`slot-typedefs`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:473
msgid "PyTypeObject Definition"
msgstr "PyTypeObject 정의"

#: ../../c-api/typeobj.rst:475
#, fuzzy
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in "
":file:`Include/cpython/object.h`.  For convenience of reference, this "
"repeats the definition found there:"
msgstr ""
":c:type:`PyTypeObject`\\의 구조체 정의는 :file:`Include/object.h`\\에서 찾을 수 있습니다."
" 참조 편의를 위해, 다음에 정의를 반복합니다:"

#: ../../c-api/typeobj.rst:481
#, python-brace-format
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" "
"*/\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python "
"2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    struct PyMethodDef *tp_methods;\n"
"    struct PyMemberDef *tp_members;\n"
"    struct PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static "
"type\n"
"    struct _typeobject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache;\n"
"    PyObject *tp_subclasses;\n"
"    PyObject *tp_weaklist;\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6 */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"} PyTypeObject;\n"
msgstr ""

#: ../../c-api/typeobj.rst:485
msgid "PyObject Slots"
msgstr "PyObject 슬롯"

#: ../../c-api/typeobj.rst:487
#, fuzzy
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. "
"The :c:member:`~PyVarObject.ob_size` field is used for dynamic types "
"(created by :c:func:`!type_new`, usually called from a class statement). "
"Note that :c:data:`PyType_Type` (the metatype) initializes "
":c:member:`~PyTypeObject.tp_itemsize`, which means that its instances "
"(i.e. type objects) *must* have the :c:member:`~PyVarObject.ob_size` "
"field."
msgstr ""
"형 객체 구조체는 :c:type:`PyVarObject` 구조체를 확장합니다. :attr:`ob_size` 필드는 동적 "
"형(:func:`type_new`\\에 의해 만들어집니다, 일반적으로 class 문에서 호출됩니다)에 사용됩니다. "
":c:data:`PyType_Type`\\(메타 형)은 :c:member:`~PyTypeObject.tp_itemsize`\\를 "
"초기화함에 유의하십시오, 인스턴스(즉, 형 객체)는 *반드시* :attr:`ob_size` 필드를 가져야 함을 뜻합니다."

#: ../../c-api/typeobj.rst:496
#, fuzzy
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated "
"type objects <static-types>`, the type's instances (objects whose "
":c:member:`~PyObject.ob_type` points back to the type) do *not* count as "
"references.  But for :ref:`dynamically allocated type objects <heap-"
"types>`, the instances *do* count as references."
msgstr ""
"이것은 ``PyObject_HEAD_INIT`` 매크로에 의해 ``1``\\로 초기화된 형 객체의 참조 횟수입니다. 정적으로 할당된"
" 형 객체의 경우 형의 인스턴스(:attr:`ob_type`\\이 형을 다시 가리키는 객체)는 참조로 카운트되지 *않습니다*. "
"그러나 동적으로 할당된 형 객체의 경우, 인스턴스는 참조로 *카운트됩니다*."

#: ../../c-api/typeobj.rst:503 ../../c-api/typeobj.rst:526
#: ../../c-api/typeobj.rst:543 ../../c-api/typeobj.rst:587
#: ../../c-api/typeobj.rst:665 ../../c-api/typeobj.rst:741
#: ../../c-api/typeobj.rst:782 ../../c-api/typeobj.rst:799
#: ../../c-api/typeobj.rst:816 ../../c-api/typeobj.rst:834
#: ../../c-api/typeobj.rst:858 ../../c-api/typeobj.rst:875
#: ../../c-api/typeobj.rst:887 ../../c-api/typeobj.rst:899
#: ../../c-api/typeobj.rst:932 ../../c-api/typeobj.rst:954
#: ../../c-api/typeobj.rst:974 ../../c-api/typeobj.rst:995
#: ../../c-api/typeobj.rst:1021 ../../c-api/typeobj.rst:1040
#: ../../c-api/typeobj.rst:1056 ../../c-api/typeobj.rst:1095
#: ../../c-api/typeobj.rst:1106 ../../c-api/typeobj.rst:1116
#: ../../c-api/typeobj.rst:1126 ../../c-api/typeobj.rst:1140
#: ../../c-api/typeobj.rst:1158 ../../c-api/typeobj.rst:1181
#: ../../c-api/typeobj.rst:1199 ../../c-api/typeobj.rst:1212
#: ../../c-api/typeobj.rst:1234 ../../c-api/typeobj.rst:1278
#: ../../c-api/typeobj.rst:1299 ../../c-api/typeobj.rst:1318
#: ../../c-api/typeobj.rst:1348 ../../c-api/typeobj.rst:1370
#: ../../c-api/typeobj.rst:1396 ../../c-api/typeobj.rst:1481
#: ../../c-api/typeobj.rst:1555 ../../c-api/typeobj.rst:1616
#: ../../c-api/typeobj.rst:1652 ../../c-api/typeobj.rst:1677
#: ../../c-api/typeobj.rst:1700 ../../c-api/typeobj.rst:1713
#: ../../c-api/typeobj.rst:1728 ../../c-api/typeobj.rst:1742
#: ../../c-api/typeobj.rst:1772 ../../c-api/typeobj.rst:1804
#: ../../c-api/typeobj.rst:1830 ../../c-api/typeobj.rst:1848
#: ../../c-api/typeobj.rst:1877 ../../c-api/typeobj.rst:1921
#: ../../c-api/typeobj.rst:1938 ../../c-api/typeobj.rst:1979
#: ../../c-api/typeobj.rst:2001 ../../c-api/typeobj.rst:2033
#: ../../c-api/typeobj.rst:2061 ../../c-api/typeobj.rst:2074
#: ../../c-api/typeobj.rst:2084 ../../c-api/typeobj.rst:2101
#: ../../c-api/typeobj.rst:2118 ../../c-api/typeobj.rst:2132
#: ../../c-api/typeobj.rst:2165 ../../c-api/typeobj.rst:2188
msgid "**Inheritance:**"
msgstr "**계승:**"

#: ../../c-api/typeobj.rst:505 ../../c-api/typeobj.rst:545
#: ../../c-api/typeobj.rst:589
msgid "This field is not inherited by subtypes."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다."

#: ../../c-api/typeobj.rst:510
msgid ""
"This is the type's type, in other words its metatype.  It is initialized "
"by the argument to the ``PyObject_HEAD_INIT`` macro, and its value should"
" normally be ``&PyType_Type``.  However, for dynamically loadable "
"extension modules that must be usable on Windows (at least), the compiler"
" complains that this is not a valid initializer.  Therefore, the "
"convention is to pass ``NULL`` to the ``PyObject_HEAD_INIT`` macro and to"
" initialize this field explicitly at the start of the module's "
"initialization function, before doing anything else.  This is typically "
"done like this::"
msgstr ""
"이것은 형의 형, 즉 메타 형(metatype)입니다. ``PyObject_HEAD_INIT`` 매크로에 대한 인자로 초기화되며, "
"값은 일반적으로 ``&PyType_Type``\\이어야 합니다. 그러나, (적어도) 윈도우에서 사용 가능해야 하는 동적으로 로드 "
"가능한 확장 모듈의 경우, 컴파일러는 유효한 초기화자가 아니라고 불평합니다. 따라서, 규칙은 ``NULL``\\을 "
"``PyObject_HEAD_INIT`` 매크로로 전달하고, 다른 작업을 수행하기 전에 모듈의 초기화 함수 시작에서 필드를 "
"명시적으로 초기화하는 것입니다. 이것은 일반적으로 다음과 같이 수행됩니다::"

#: ../../c-api/typeobj.rst:519
msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr ""

#: ../../c-api/typeobj.rst:521
#, fuzzy
msgid ""
"This should be done before any instances of the type are created. "
":c:func:`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is "
"``NULL``, and if so, initializes it to the :c:member:`~PyObject.ob_type` "
"field of the base class. :c:func:`PyType_Ready` will not change this "
"field if it is non-zero."
msgstr ""
"형의 인스턴스를 만들기 전에 수행해야 합니다. :c:func:`PyType_Ready`\\는 :attr:`ob_type`\\이 "
"``NULL``\\인지 확인하고, 그렇다면 베이스 클래스의 :attr:`ob_type` 필드로 초기화합니다. "
":c:func:`PyType_Ready`\\는 0이 아니면 이 필드를 변경하지 않습니다."

#: ../../c-api/typeobj.rst:528 ../../c-api/typeobj.rst:743
#: ../../c-api/typeobj.rst:860 ../../c-api/typeobj.rst:956
#: ../../c-api/typeobj.rst:976 ../../c-api/typeobj.rst:1679
#: ../../c-api/typeobj.rst:1702 ../../c-api/typeobj.rst:1832
#: ../../c-api/typeobj.rst:1850 ../../c-api/typeobj.rst:1923
#: ../../c-api/typeobj.rst:2035 ../../c-api/typeobj.rst:2167
msgid "This field is inherited by subtypes."
msgstr "이 필드는 서브 형으로 상속됩니다."

#: ../../c-api/typeobj.rst:532
msgid "PyVarObject Slots"
msgstr "PyVarObject 슬롯"

#: ../../c-api/typeobj.rst:536
#, fuzzy
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should "
"be initialized to zero. For :ref:`dynamically allocated type objects "
"<heap-types>`, this field has a special internal meaning."
msgstr ""
"정적으로 할당된 형 객체의 경우, 0으로 초기화해야 합니다. 동적으로 할당된 형 객체의 경우, 이 필드에는 특별한 내부 의미가 "
"있습니다."

#: ../../c-api/typeobj.rst:540
msgid ""
"This field should be accessed using the :c:func:`Py_SIZE()` and "
":c:func:`Py_SET_SIZE()` macros."
msgstr ""

#: ../../c-api/typeobj.rst:549
msgid "PyTypeObject Slots"
msgstr "PyTypeObject 슬롯"

#: ../../c-api/typeobj.rst:551
#, fuzzy
msgid ""
"Each slot has a section describing inheritance.  If "
":c:func:`PyType_Ready` may set a value when the field is set to ``NULL`` "
"then there will also be a \"Default\" section.  (Note that many fields "
"set on :c:data:`PyBaseObject_Type` and :c:data:`PyType_Type` effectively "
"act as defaults.)"
msgstr ""
"각 슬롯에는 상속을 설명하는 섹션이 있습니다. 필드가 ``NULL``\\로 설정될 때 :c:func:`PyType_Ready`\\가"
" 값을 설정할 수 있으면, \"기본값\" 섹션도 있습니다. (:c:type:`PyBaseObject_Type`\\과 "
":c:type:`PyType_Type`\\에 설정된 많은 필드가 효과적으로 기본값으로 작동함에 유의하십시오.)"

#: ../../c-api/typeobj.rst:558
#, fuzzy
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the "
"full module name, followed by a dot, followed by the type name; for "
"built-in types, it should be just the type name.  If the module is a "
"submodule of a package, the full package name is part of the full module "
"name.  For example, a type named :class:`!T` defined in module :mod:`!M` "
"in subpackage :mod:`!Q` in package :mod:`!P` should have the "
":c:member:`~PyTypeObject.tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"형 이름이 포함된 NUL-종료 문자열을 가리키는 포인터. 모듈 전역으로 액세스 할 수 있는 형의 경우, 문자열은 전체 모듈 이름, "
"그 뒤에 점, 그 뒤에 형 이름이어야 합니다; 내장형의 경우, 단지 형 이름이어야 합니다. 모듈이 패키지의 서브 모듈이면, 전체 "
"패키지 이름은 전체 모듈 이름의 일부입니다. 예를 들어, 패키지 :mod:`P`\\의 서브 패키지 :mod:`Q`\\에 있는 모듈 "
":mod:`M`\\에 정의된 :class:`T`\\라는 형은 :c:member:`~PyTypeObject.tp_name` 초기화자가"
" ``\"P.Q.M.T\"``\\이어야 합니다."

#: ../../c-api/typeobj.rst:566
#, fuzzy
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should "
"just be the type name, and the module name explicitly stored in the type "
"dict as the value for key ``'__module__'``."
msgstr ""
"동적으로 할당된 형 객체의 경우, 단지 형 이름이어야 하며, 모듈 이름은 형 딕셔너리에 키 ``'__module__'``\\의 "
"값으로 명시적으로 저장됩니다."

#: ../../c-api/typeobj.rst:571
#, fuzzy
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the "
"*tp_name* field should contain a dot. Everything before the last dot is "
"made accessible as the :attr:`~type.__module__` attribute, and everything"
" after the last dot is made accessible as the :attr:`~type.__name__` "
"attribute."
msgstr ""
"정적으로 할당된 형 객체의 경우, tp_name 필드에 점이 있어야 합니다. 마지막 점 이전의 모든 것은 "
":attr:`__module__` 어트리뷰트로 액세스 할 수 있으며, 마지막 점 이후의 모든 것은 "
":attr:`~definition.__name__` 어트리뷰트로 액세스 할 수 있습니다."

#: ../../c-api/typeobj.rst:577
#, fuzzy
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field "
"is made accessible as the :attr:`~type.__name__` attribute, and the "
":attr:`~type.__module__` attribute is undefined (unless explicitly set in"
" the dictionary, as explained above).  This means your type will be "
"impossible to pickle.  Additionally, it will not be listed in module "
"documentations created with pydoc."
msgstr ""
"점이 없으면, 전체 :c:member:`~PyTypeObject.tp_name` 필드는 "
":attr:`~definition.__name__` 어트리뷰트로 액세스 할 수 있으며, :attr:`__module__` "
"어트리뷰트는 정의되지 않습니다 (위에서 설명한 대로, 딕셔너리에 명시적으로 설정되지 않는 한). 이것은 여러분의 형을 피클 할 수 "
"없다는 것을 뜻합니다. 또한, pydoc으로 만든 모듈 설명서에 나열되지 않습니다."

#: ../../c-api/typeobj.rst:583
msgid ""
"This field must not be ``NULL``.  It is the only required field in "
":c:func:`PyTypeObject` (other than potentially "
":c:member:`~PyTypeObject.tp_itemsize`)."
msgstr ""
"이 필드는 ``NULL``\\이 아니어야 합니다. :c:func:`PyTypeObject`\\에서 유일하게 필요한 필드입니다 "
"(잠재적인 :c:member:`~PyTypeObject.tp_itemsize`\\를 제외하고)."

#: ../../c-api/typeobj.rst:595
msgid "These fields allow calculating the size in bytes of instances of the type."
msgstr "이 필드를 사용하면 형 인스턴스의 크기를 바이트 단위로 계산할 수 있습니다."

#: ../../c-api/typeobj.rst:597
#, fuzzy
msgid ""
"There are two kinds of types: types with fixed-length instances have a "
"zero :c:member:`!tp_itemsize` field, types with variable-length instances"
" have a non-zero :c:member:`!tp_itemsize` field.  For a type with fixed-"
"length instances, all instances have the same size, given in "
":c:member:`!tp_basicsize`. (Exceptions to this rule can be made using "
":c:func:`PyUnstable_Object_GC_NewWithExtraData`.)"
msgstr ""
"두 가지 종류의 형이 있습니다: 고정 길이 인스턴스의 형은 0 :c:member:`~PyTypeObject.tp_itemsize` "
"필드를 갖고, 가변 길이 인스턴스의 형에는 0이 아닌 :c:member:`~PyTypeObject.tp_itemsize` 필드가 "
"있습니다. 고정 길이 인스턴스의 형의 경우, 모든 인스턴스는 "
":c:member:`~PyTypeObject.tp_basicsize`\\로 지정되는 같은 크기를 갖습니다."

#: ../../c-api/typeobj.rst:604
msgid ""
"For a type with variable-length instances, the instances must have an "
":c:member:`~PyVarObject.ob_size` field, and the instance size is "
":c:member:`!tp_basicsize` plus N times :c:member:`!tp_itemsize`, where N "
"is the \"length\" of the object."
msgstr ""

#: ../../c-api/typeobj.rst:609
msgid ""
"Functions like :c:func:`PyObject_NewVar` will take the value of N as an "
"argument, and store in the instance's :c:member:`~PyVarObject.ob_size` "
"field. Note that the :c:member:`~PyVarObject.ob_size` field may later be "
"used for other purposes. For example, :py:type:`int` instances use the "
"bits of :c:member:`~PyVarObject.ob_size` in an implementation-defined "
"way; the underlying storage and its size should be accessed using "
":c:func:`PyLong_Export`."
msgstr ""

#: ../../c-api/typeobj.rst:619
msgid ""
"The :c:member:`~PyVarObject.ob_size` field should be accessed using the "
":c:func:`Py_SIZE()` and :c:func:`Py_SET_SIZE()` macros."
msgstr ""

#: ../../c-api/typeobj.rst:622
msgid ""
"Also, the presence of an :c:member:`~PyVarObject.ob_size` field in the "
"instance layout doesn't mean that the instance structure is variable-"
"length. For example, the :py:type:`list` type has fixed-length instances,"
" yet those instances have a :c:member:`~PyVarObject.ob_size` field. (As "
"with :py:type:`int`, avoid reading lists' :c:member:`!ob_size` directly. "
"Call :c:func:`PyList_Size` instead.)"
msgstr ""

#: ../../c-api/typeobj.rst:629
msgid ""
"The :c:member:`!tp_basicsize` includes size needed for data of the type's"
" :c:member:`~PyTypeObject.tp_base`, plus any extra data needed by each "
"instance."
msgstr ""

#: ../../c-api/typeobj.rst:633
msgid ""
"The  correct way to set :c:member:`!tp_basicsize` is to use the "
"``sizeof`` operator on the struct used to declare the instance layout. "
"This struct must include the struct used to declare the base type. In "
"other words, :c:member:`!tp_basicsize` must be greater than or equal to "
"the base's :c:member:`!tp_basicsize`."
msgstr ""

#: ../../c-api/typeobj.rst:639
msgid ""
"Since every type is a subtype of :py:type:`object`, this struct must "
"include :c:type:`PyObject` or :c:type:`PyVarObject` (depending on whether"
" :c:member:`~PyVarObject.ob_size` should be included). These are usually "
"defined by the macro :c:macro:`PyObject_HEAD` or "
":c:macro:`PyObject_VAR_HEAD`, respectively."
msgstr ""

#: ../../c-api/typeobj.rst:645
msgid ""
"The basic size does not include the GC header size, as that header is not"
" part of :c:macro:`PyObject_HEAD`."
msgstr ""

#: ../../c-api/typeobj.rst:648
msgid ""
"For cases where struct used to declare the base type is unknown, see "
":c:member:`PyType_Spec.basicsize` and :c:func:`PyType_FromMetaclass`."
msgstr ""

#: ../../c-api/typeobj.rst:651
msgid "Notes about alignment:"
msgstr ""

#: ../../c-api/typeobj.rst:653
msgid ""
":c:member:`!tp_basicsize` must be a multiple of ``_Alignof(PyObject)``. "
"When using ``sizeof`` on a ``struct`` that includes "
":c:macro:`PyObject_HEAD`, as recommended, the compiler ensures this. When"
" not using a C ``struct``, or when using compiler extensions like "
"``__attribute__((packed))``, it is up to you."
msgstr ""

#: ../../c-api/typeobj.rst:658
msgid ""
"If the variable items require a particular alignment, "
":c:member:`!tp_basicsize` and :c:member:`!tp_itemsize` must each be a "
"multiple of that alignment. For example, if a type's variable part stores"
" a ``double``, it is your responsibility that both fields are a multiple "
"of ``_Alignof(double)``."
msgstr ""

#: ../../c-api/typeobj.rst:667
msgid ""
"These fields are inherited separately by subtypes. (That is, if the field"
" is set to zero, :c:func:`PyType_Ready` will copy the value from the base"
" type, indicating that the instances do not need additional storage.)"
msgstr ""

#: ../../c-api/typeobj.rst:672
#, fuzzy
msgid ""
"If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it"
" is generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a "
"different non-zero value in a subtype (though this depends on the "
"implementation of the base type)."
msgstr ""
"이 필드는 서브 형에 의해 별도로 상속됩니다. 베이스형에 0이 아닌 "
":c:member:`~PyTypeObject.tp_itemsize`\\가 있으면, 일반적으로 서브 형에서 "
":c:member:`~PyTypeObject.tp_itemsize`\\를 다른 0이 아닌 값으로 설정하는 것은 안전하지 않습니다 "
"(베이스형의 구현에 따라 다르기는 합니다)."

#: ../../c-api/typeobj.rst:679
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and "
"``Ellipsis``).  The function signature is::"
msgstr ""
"인스턴스 파괴자(destructor) 함수에 대한 포인터. (싱글톤 ``None``\\과 ``Ellipsis``\\의 경우처럼) "
"형이 해당 인스턴스가 할당 해제되지 않도록 보장하지 않는 한, 이 함수를 정의해야 합니다. 함수 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:683
msgid "void tp_dealloc(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:685
#, fuzzy
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and "
":c:func:`Py_XDECREF` macros when the new reference count is zero.  At "
"this point, the instance is still in existence, but there are no "
"references to it.  The destructor function should free all references "
"which the instance owns, free all memory buffers owned by the instance "
"(using the freeing function corresponding to the allocation function used"
" to allocate the buffer), and call the type's "
":c:member:`~PyTypeObject.tp_free` function.  If the type is not "
"subtypable (doesn't have the :c:macro:`Py_TPFLAGS_BASETYPE` flag bit "
"set), it is permissible to call the object deallocator directly instead "
"of via :c:member:`~PyTypeObject.tp_free`.  The object deallocator should "
"be the one used to allocate the instance; this is normally "
":c:func:`PyObject_Del` if the instance was allocated using "
":c:macro:`PyObject_New` or :c:macro:`PyObject_NewVar`, or "
":c:func:`PyObject_GC_Del` if the instance was allocated using "
":c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"파괴자 함수는 새로운 참조 횟수가 0일 때 :c:func:`Py_DECREF`\\와 :c:func:`Py_XDECREF` 매크로에 "
"의해 호출됩니다. 이 시점에, 인스턴스는 여전히 존재하지만, 이에 대한 참조는 없습니다. 파괴자 함수는 인스턴스가 소유한 모든 "
"참조를 해제하고, (버퍼 할당에 사용된 할당 함수에 해당하는 해제 함수를 사용하여) 인스턴스가 소유한 모든 메모리 버퍼를 해제한 "
"다음, 형의 :c:member:`~PyTypeObject.tp_free` 함수를 호출해야 합니다. 형의 서브 형을 만들 수 없는 "
"경우 (:const:`Py_TPFLAGS_BASETYPE` 플래그 비트가 설정되지 않은 경우) "
":c:member:`~PyTypeObject.tp_free`\\를 거치는 대신 객체 할당 해제기(deallocator)를 직접 호출"
" 할 수 있습니다. 객체 할당 해제기는 인스턴스를 할당하는 데 사용된 것이어야 합니다; 인스턴스가 "
":c:func:`PyObject_New`\\나 :c:func:`PyObject_VarNew`\\를 사용하여 할당되었으면 일반적으로 "
":c:func:`PyObject_Del`\\이고, 인스턴스가 :c:func:`PyObject_GC_New`\\나 "
":c:func:`PyObject_GC_NewVar`\\를 사용하여 할당되었으면 "
":c:func:`PyObject_GC_Del`\\입니다."

#: ../../c-api/typeobj.rst:700
msgid ""
"If the type supports garbage collection (has the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit set), the destructor should call "
":c:func:`PyObject_GC_UnTrack` before clearing any member fields."
msgstr ""

#: ../../c-api/typeobj.rst:704
#, python-brace-format
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyObject_GC_UnTrack(self);\n"
"    Py_CLEAR(self->ref);\n"
"    Py_TYPE(self)->tp_free((PyObject *)self);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:712
#, fuzzy
msgid ""
"Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), "
"the deallocator should release the owned reference to its type object "
"(via :c:func:`Py_DECREF`)  after calling the type deallocator. In order "
"to avoid dangling pointers, the recommended way to achieve this is:"
msgstr ""
"마지막으로, 형이 힙 할당(:const:`Py_TPFLAGS_HEAPTYPE`)이면, 할당 해제기는 형 할당 해제기를 호출한 후 "
"해당 형 객체의 참조 횟수를 줄여야 합니다. 매달린(dangling) 포인터를 피하고자, 이렇게 하는 권장 방법은 다음과 같습니다:"

#: ../../c-api/typeobj.rst:718
#, python-brace-format
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"    // free references and buffers here\n"
"    tp->tp_free(self);\n"
"    Py_DECREF(tp);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:729
#, fuzzy
msgid ""
"In a garbage collected Python, :c:member:`!tp_dealloc` may be called from"
" any Python thread, not just the thread which created the object (if the "
"object becomes part of a refcount cycle, that cycle might be collected by"
" a garbage collection on any thread).  This is not a problem for Python "
"API calls, since the thread on which :c:member:`!tp_dealloc` is called "
"will own the Global Interpreter Lock (GIL).  However, if the object being"
" destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the "
"thread which called :c:member:`!tp_dealloc` will not violate any "
"assumptions of the library."
msgstr ""
"또한, 가비지 수집된 파이썬에서, :c:member:`~PyTypeObject.tp_dealloc`\\은 객체를 만든 스레드뿐만 "
"아니라, 모든 파이썬 스레드에서 호출될 수 있습니다 (객체가 참조 횟수 순환의 일부가 되면, 해당 순환은 모든 스레드에서의 가비지 "
"수집으로 수집될 수 있습니다). tp_dealloc이 호출되는 스레드는 GIL(전역 인터프리터 록 - Global "
"Interpreter Lock)을 소유하므로, 파이썬 API 호출에는 문제가 되지 않습니다. 그러나, 파괴되는 중인 객체가 다른 "
"C나 C++ 라이브러리의 객체를 파괴하면, tp_dealloc을 호출한 스레드에서 그 객체를 파괴해도 라이브러리의 가정을 위반하지 "
"않는지 주의해야 합니다."

#: ../../c-api/typeobj.rst:748
msgid ""
"An optional offset to a per-instance function that implements calling the"
" object using the :ref:`vectorcall protocol <vectorcall>`, a more "
"efficient alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"간단한 :c:member:`~PyTypeObject.tp_call`\\의 더 효율적인 대안인 :ref:`벡터콜(vectorcall)"
" 프로토콜 <vectorcall>`\\을 사용하여 객체를 호출하는 것을 구현하는 인스턴스별 함수에 대한 선택적 오프셋입니다."

#: ../../c-api/typeobj.rst:753
#, fuzzy
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`"
" is set. If so, this must be a positive integer containing the offset in "
"the instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"이 필드는 플래그 :const:`Py_TPFLAGS_HAVE_VECTORCALL`\\이 설정되었을 때만 사용됩니다. 그럴 때, "
"이것은 :c:type:`vectorcallfunc` 포인터의 인스턴스에서의 오프셋을 포함하는 양의 정수여야 합니다."

#: ../../c-api/typeobj.rst:757
#, fuzzy
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling "
"the instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"*vectorcallfunc* 포인터는 ``NULL``\\일 수 있으며, 이때 인스턴스는 "
":const:`Py_TPFLAGS_HAVE_VECTORCALL`\\이 설정되지 않은 것처럼 작동합니다: 인스턴스를 호출하면 "
":c:member:`~PyTypeObject.tp_call`\\로 폴백 됩니다."

#: ../../c-api/typeobj.rst:761
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set "
":c:member:`~PyTypeObject.tp_call` and make sure its behaviour is "
"consistent with the *vectorcallfunc* function. This can be done by "
"setting *tp_call* to :c:func:`PyVectorcall_Call`."
msgstr ""
"``Py_TPFLAGS_HAVE_VECTORCALL``\\을 설정하는 모든 클래스는 "
":c:member:`~PyTypeObject.tp_call`\\도 설정해야 하고, 해당 동작이 *vectorcallfunc* 함수와"
" 일관되도록 만들어야 합니다. *tp_call*\\을 :c:func:`PyVectorcall_Call`\\로 설정하면 됩니다:"

#: ../../c-api/typeobj.rst:768
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it "
"was used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"버전 3.8 이전에는, 이 슬롯의 이름이 ``tp_print``\\였습니다. 파이썬 2.x에서는, 파일로 인쇄하는 데 "
"사용되었습니다. 파이썬 3.0에서 3.7까지는, 사용되지 않았습니다."

#: ../../c-api/typeobj.rst:774
#, fuzzy
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets "
":attr:`~object.__call__` in Python code, only *tp_call* is updated, "
"likely making it inconsistent with the vectorcall function. Since 3.12, "
"setting ``__call__`` will disable vectorcall optimization by clearing the"
" :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
":ref:`힙(heap) 형 <heap-types>`\\에 벡터콜 프로토콜을 구현하는 것은 권장하지 않습니다. 사용자가 파이썬 "
"코드에서 :attr:`__call__`\\을 설정하면, *tp_call*\\만 갱신되어 벡터콜 함수와 일치하지 않게 됩니다."

#: ../../c-api/typeobj.rst:784
#, fuzzy
msgid ""
"This field is always inherited. However, the "
":c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If "
"it's not set, then the subclass won't use :ref:`vectorcall <vectorcall>`,"
" except when :c:func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"이 필드는 항상 상속됩니다. 그러나, :const:`Py_TPFLAGS_HAVE_VECTORCALL` 플래그가 항상 상속되는 것은 "
"아닙니다. 그렇지 않으면, :c:func:`PyVectorcall_Call`\\이 명시적으로 호출되었을 때를 제외하고, 서브 "
"클래스는 :ref:`벡터콜(vectorcall) <vectorcall>`\\을 사용하지 않을 것입니다. 특히 `힙 형 <heap "
"types_>`_\\일 때 그렇습니다 (파이썬에서 정의된 서브 클래스를 포함합니다)."

#: ../../c-api/typeobj.rst:793
msgid "An optional pointer to the get-attribute-string function."
msgstr "get-attribute-string 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:795
msgid ""
"This field is deprecated.  When it is defined, it should point to a "
"function that acts the same as the :c:member:`~PyTypeObject.tp_getattro` "
"function, but taking a C string instead of a Python string object to give"
" the attribute name."
msgstr ""
"이 필드는 폐지되었습니다. 정의될 때, :c:member:`~PyTypeObject.tp_getattro` 함수와 같게 작동하지만,"
" 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C 문자열을 받아들이는 함수를 가리켜야 합니다."

#: ../../c-api/typeobj.rst:801 ../../c-api/typeobj.rst:997
#, fuzzy
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, "
":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:803
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_getattro`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_getattro`\\와 함께 서브 형에 의해 상속됩니다: 서브 형은 "
"서브 형의 :c:member:`~PyTypeObject.tp_getattr`\\과 "
":c:member:`~PyTypeObject.tp_getattro`\\가 모두 ``NULL``\\일 때 베이스형에서 "
":c:member:`~PyTypeObject.tp_getattr`\\과 "
":c:member:`~PyTypeObject.tp_getattro`\\를 모두 상속합니다."

#: ../../c-api/typeobj.rst:810 ../../c-api/typeobj.rst:1010
msgid "An optional pointer to the function for setting and deleting attributes."
msgstr "어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:812
msgid ""
"This field is deprecated.  When it is defined, it should point to a "
"function that acts the same as the :c:member:`~PyTypeObject.tp_setattro` "
"function, but taking a C string instead of a Python string object to give"
" the attribute name."
msgstr ""
"이 필드는 폐지되었습니다. 정의될 때, :c:member:`~PyTypeObject.tp_setattro` 함수와 같게 작동하지만,"
" 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C 문자열을 받아들이는 함수를 가리켜야 합니다."

#: ../../c-api/typeobj.rst:818 ../../c-api/typeobj.rst:1023
#, fuzzy
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, "
":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:820
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_setattro`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_setattro`\\와 함께 서브 형에 의해 상속됩니다. 서브 형은 "
"서브 형의 :c:member:`~PyTypeObject.tp_setattr`\\과 "
":c:member:`~PyTypeObject.tp_setattro`\\가 모두 ``NULL``\\일 때 베이스형에서 "
":c:member:`~PyTypeObject.tp_setattr`\\과 "
":c:member:`~PyTypeObject.tp_setattro`\\를 모두 상속합니다."

#: ../../c-api/typeobj.rst:827
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous "
"iterator` protocols at the C-level.  See :ref:`async-structs` for "
"details."
msgstr ""
"C 수준에서 :term:`어웨이터블 <awaitable>`\\과 :term:`비동기 이터레이터 <asynchronous "
"iterator>` 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 자세한 내용은 :ref"
":`async-structs`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:831
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "이전에는 ``tp_compare``\\와 ``tp_reserved``\\라고 했습니다."

#: ../../c-api/typeobj.rst:836
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the"
" contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_async` 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다."

#: ../../c-api/typeobj.rst:844
msgid ""
"An optional pointer to a function that implements the built-in function "
":func:`repr`."
msgstr "내장 함수 :func:`repr`\\을 구현하는 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:847
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "서명은 :c:func:`PyObject_Repr`\\과 같습니다::"

#: ../../c-api/typeobj.rst:849
msgid "PyObject *tp_repr(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:851
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given "
"a suitable environment, returns an object with the same value.  If this "
"is not feasible, it should return a string starting with ``'<'`` and "
"ending with ``'>'`` from which both the type and the value of the object "
"can be deduced."
msgstr ""
"함수는 문자열이나 유니코드 객체를 반환해야 합니다. 이상적으로, 이 함수는 :func:`eval`\\에 전달될 때 적합한 환경이 "
"주어지면 같은 값을 가진 객체를 반환하는 문자열을 반환해야 합니다. 이것이 가능하지 않으면, ``'<'``\\로 시작하고 "
"``'>'``\\로 끝나는 문자열을 반환해야 하는데, 이 문자열에서 객체의 형과 값을 모두 추론할 수 있어야 합니다."

#: ../../c-api/typeobj.rst:862 ../../c-api/typeobj.rst:941
#: ../../c-api/typeobj.rst:978 ../../c-api/typeobj.rst:1003
#: ../../c-api/typeobj.rst:1029 ../../c-api/typeobj.rst:1070
#: ../../c-api/typeobj.rst:1625 ../../c-api/typeobj.rst:1659
#: ../../c-api/typeobj.rst:1776 ../../c-api/typeobj.rst:1809
#: ../../c-api/typeobj.rst:1884 ../../c-api/typeobj.rst:1925
#: ../../c-api/typeobj.rst:1943 ../../c-api/typeobj.rst:1985
#: ../../c-api/typeobj.rst:2006 ../../c-api/typeobj.rst:2037
msgid "**Default:**"
msgstr "**기본값:**"

#: ../../c-api/typeobj.rst:864
#, python-format
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is"
" returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"이 필드를 설정하지 않으면, ``<%s object at %p>`` 형식의 문자열이 반환됩니다. 여기서 ``%s``\\는 형 "
"이름으로, ``%p``\\는 객체의 메모리 주소로 치환됩니다."

#: ../../c-api/typeobj.rst:871
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented"
" in :ref:`number-structs`."
msgstr ""
"숫자 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 :ref:`number-"
"structs`\\에서 설명합니다."

#: ../../c-api/typeobj.rst:877
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but "
"the contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_number` 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다."

#: ../../c-api/typeobj.rst:883
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are "
"documented in :ref:`sequence-structs`."
msgstr ""
"시퀀스 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 :ref:`sequence-"
"structs`\\에서 설명합니다."

#: ../../c-api/typeobj.rst:889
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but "
"the contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_sequence` 필드는 상속되지 않지만, 포함된 필드는 개별적으로 "
"상속됩니다."

#: ../../c-api/typeobj.rst:895
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are "
"documented in :ref:`mapping-structs`."
msgstr ""
"매핑 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 :ref:`mapping-"
"structs`\\에서 설명합니다."

#: ../../c-api/typeobj.rst:901
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but "
"the contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_mapping` 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다."

#: ../../c-api/typeobj.rst:909
msgid ""
"An optional pointer to a function that implements the built-in function "
":func:`hash`."
msgstr "내장 함수 :func:`hash`\\를 구현하는 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:912
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "서명은 :c:func:`PyObject_Hash`\\와 같습니다::"

#: ../../c-api/typeobj.rst:914
msgid "Py_hash_t tp_hash(PyObject *);"
msgstr ""

#: ../../c-api/typeobj.rst:916
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an"
" error occurs during the computation of the hash value, the function "
"should set an exception and return ``-1``."
msgstr ""
"``-1`` 값은 정상적인 반환 값으로 반환되지 않아야 합니다; 해시값을 계산하는 동안 에러가 발생하면 함수는 예외를 설정하고 "
"``-1``\\을 반환해야 합니다."

#: ../../c-api/typeobj.rst:920
#, fuzzy
msgid ""
"When this field is not set (*and* "
":c:member:`~PyTypeObject.tp_richcompare` is not set), an attempt to take "
"the hash of the object raises :exc:`TypeError`. This is the same as "
"setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"이 필드가 설정되지 않으면 (*그리고* :attr:`tp_richcompare`\\가 설정되지 않으면), 객체의 해시를 취하려는 "
"시도는 :exc:`TypeError`\\를 발생시킵니다. 이것은 "
":c:func:`PyObject_HashNotImplemented`\\로 설정하는 것과 같습니다."

#: ../../c-api/typeobj.rst:924
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented`"
" to block inheritance of the hash method from a parent type. This is "
"interpreted as the equivalent of ``__hash__ = None`` at the Python level,"
" causing ``isinstance(o, collections.Hashable)`` to correctly return "
"``False``. Note that the converse is also true - setting ``__hash__ = "
"None`` on a class at the Python level will result in the ``tp_hash`` slot"
" being set to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"이 필드는 부모 형에서 해시 메서드의 상속을 차단하기 위해 :c:func:`PyObject_HashNotImplemented`\\로"
" 명시적으로 설정할 수 있습니다. 이것은 파이썬 수준에서의 ``__hash__ = None``\\과 동등한 것으로 해석되어, "
"``isinstance(o, collections.Hashable)``\\이 ``False``\\를 올바르게 반환하게 합니다. "
"반대의 경우도 마찬가지입니다 - 파이썬 수준의 클래스에서 ``__hash__ = None``\\을 설정하면 ``tp_hash`` "
"슬롯이 :c:func:`PyObject_HashNotImplemented`\\로 설정됩니다."

#: ../../c-api/typeobj.rst:934 ../../c-api/typeobj.rst:1618
#, fuzzy
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, "
":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:936
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_richcompare`: a subtype inherits both of "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash`, when the subtype's "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_richcompare`\\와 함께 서브 형에 의해 상속됩니다: 서브 "
"형의 :c:member:`~PyTypeObject.tp_richcompare`\\와 "
":c:member:`~PyTypeObject.tp_hash`\\가 모두 ``NULL``\\일 때, 서브 형은 "
":c:member:`~PyTypeObject.tp_richcompare`\\와 "
":c:member:`~PyTypeObject.tp_hash`\\를 모두 상속합니다."

#: ../../c-api/typeobj.rst:943
#, fuzzy
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:type:`PyBaseObject_Type`\\은 :c:func:`PyObject_GenericSetAttr`\\을 사용합니다."

#: ../../c-api/typeobj.rst:948
msgid ""
"An optional pointer to a function that implements calling the object.  "
"This should be ``NULL`` if the object is not callable.  The signature is "
"the same as for :c:func:`PyObject_Call`::"
msgstr ""
"객체 호출을 구현하는 함수에 대한 선택적 포인터. 객체가 콜러블이 아니면 ``NULL``\\이어야 합니다. 서명은 "
":c:func:`PyObject_Call`\\과 같습니다::"

#: ../../c-api/typeobj.rst:952
msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr ""

#: ../../c-api/typeobj.rst:961
msgid ""
"An optional pointer to a function that implements the built-in operation "
":func:`str`.  (Note that :class:`str` is a type now, and :func:`str` "
"calls the constructor for that type.  This constructor calls "
":c:func:`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` "
"will call this handler.)"
msgstr ""
"내장 연산 :func:`str`\\을 구현하는 함수에 대한 선택적 포인터. (:class:`str`\\는 이제 형이며, "
":func:`str`\\은 그 형의 생성자를 호출함에 유의하십시오. 이 생성자는 :c:func:`PyObject_Str`\\를 "
"호출하여 실제 작업을 수행하고, :c:func:`PyObject_Str`\\은 이 처리기를 호출합니다.)"

#: ../../c-api/typeobj.rst:966
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "서명은 :c:func:`PyObject_Str`\\과 같습니다::"

#: ../../c-api/typeobj.rst:968
msgid "PyObject *tp_str(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:970
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the "
":func:`print` function."
msgstr ""
"함수는 문자열이나 유니코드 객체를 반환해야 합니다. 다른 것 중에서도, :func:`print` 함수에 의해 사용될 표현이기 "
"때문에, 객체의 \"친숙한\" 문자열 표현이어야 합니다."

#: ../../c-api/typeobj.rst:980
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a"
" string representation."
msgstr "이 필드를 설정하지 않으면, 문자열 표현을 반환하기 위해 :c:func:`PyObject_Repr`\\이 호출됩니다."

#: ../../c-api/typeobj.rst:986
msgid "An optional pointer to the get-attribute function."
msgstr "어트리뷰트 읽기(get-attribute) 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:988
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "서명은 :c:func:`PyObject_GetAttr`\\과 같습니다::"

#: ../../c-api/typeobj.rst:990
msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr ""

#: ../../c-api/typeobj.rst:992
msgid ""
"It is usually convenient to set this field to "
":c:func:`PyObject_GenericGetAttr`, which implements the normal way of "
"looking for object attributes."
msgstr ""
"일반적으로 이 필드를 :c:func:`PyObject_GenericGetAttr`\\로 설정하는 것이 편리합니다, 객체 어트리뷰트를"
" 찾는 일반적인 방법을 구현합니다."

#: ../../c-api/typeobj.rst:999
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_getattr`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and "
":c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_getattr`\\과 함께 서브 형에 의해 상속됩니다: 서브 형의 "
":c:member:`~PyTypeObject.tp_getattr`\\과 "
":c:member:`~PyTypeObject.tp_getattro`\\가 모두 ``NULL``\\일 때 서브 형은 베이스형에서 "
":c:member:`~PyTypeObject.tp_getattr`\\과 "
":c:member:`~PyTypeObject.tp_getattro`\\를 모두 상속합니다."

#: ../../c-api/typeobj.rst:1005
#, fuzzy
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ":c:type:`PyBaseObject_Type`\\은 :c:func:`PyObject_GenericGetAttr`\\을 사용합니다."

#: ../../c-api/typeobj.rst:1012
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "서명은 :c:func:`PyObject_SetAttr`\\과 같습니다::"

#: ../../c-api/typeobj.rst:1014
msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr ""

#: ../../c-api/typeobj.rst:1016
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to "
":c:func:`PyObject_GenericSetAttr`, which implements the normal way of "
"setting object attributes."
msgstr ""
"또한, *value*\\를 ``NULL``\\로 설정하여 어트리뷰트를 삭제하는 것을 반드시 지원해야 합니다. 일반적으로 이 필드를 "
":c:func:`PyObject_GenericSetAttr`\\로 설정하는 것이 편리합니다, 객체 어트리뷰트를 설정하는 일반적인 "
"방법을 구현합니다."

#: ../../c-api/typeobj.rst:1025
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_setattr`: a subtype inherits both "
":c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and "
":c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_setattr`\\과 함께 서브 형에 의해 상속됩니다: 서브 형의 "
":c:member:`~PyTypeObject.tp_setattr`\\과 "
":c:member:`~PyTypeObject.tp_setattro`\\가 모두 ``NULL``\\일 때, 서브 형은 베이스형에서 "
":c:member:`~PyTypeObject.tp_setattr`\\과 "
":c:member:`~PyTypeObject.tp_setattro`\\를 모두 상속합니다."

#: ../../c-api/typeobj.rst:1031
#, fuzzy
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ":c:type:`PyBaseObject_Type`\\은 :c:func:`PyObject_GenericSetAttr`\\을 사용합니다."

#: ../../c-api/typeobj.rst:1036
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are "
"documented in :ref:`buffer-structs`."
msgstr ""
"버퍼 인터페이스를 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 :ref:`buffer-"
"structs`\\에서 설명합니다."

#: ../../c-api/typeobj.rst:1042
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but "
"the contained fields are inherited individually."
msgstr ":c:member:`~PyTypeObject.tp_as_buffer` 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다."

#: ../../c-api/typeobj.rst:1048
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that "
"certain fields in the type object (or in the extension structures "
"referenced via :c:member:`~PyTypeObject.tp_as_number`, "
":c:member:`~PyTypeObject.tp_as_sequence`, "
":c:member:`~PyTypeObject.tp_as_mapping`, and "
":c:member:`~PyTypeObject.tp_as_buffer`) that were historically not always"
" present are valid; if such a flag bit is clear, the type fields it "
"guards must not be accessed and must be considered to have a zero or "
"``NULL`` value instead."
msgstr ""
"이 필드는 다양한 플래그의 비트 마스크입니다. 일부 플래그는 특정 상황에 대한 변형 의미론을 나타냅니다; 다른 것들은 역사적으로 "
"항상 존재하지는 않았던 형 객체(또는 :c:member:`~PyTypeObject.tp_as_number`, "
":c:member:`~PyTypeObject.tp_as_sequence`, "
":c:member:`~PyTypeObject.tp_as_mapping` 및 "
":c:member:`~PyTypeObject.tp_as_buffer`\\를 통해 참조되는 확장 구조체)의 특정 필드가 유효함을 "
"나타내는 데 사용됩니다; 이러한 플래그 비트가 없으면, 이것이 보호하는 형 필드에 액세스하지 말아야 하며 대신 0이나 "
"``NULL`` 값을 갖는 것으로 간주해야 합니다."

#: ../../c-api/typeobj.rst:1058
#, fuzzy
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype "
"inherits this flag bit.  The flag bits that pertain to extension "
"structures are strictly inherited if the extension structure is "
"inherited, i.e. the base type's value of the flag bit is copied into the "
"subtype together with a pointer to the extension structure.  The "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the "
":c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields, i.e. if the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the "
":c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have "
"``NULL`` values. .. XXX are most flag bits *really* inherited "
"individually?"
msgstr ""
"이 필드의 상속은 복잡합니다. 대부분 플래그 비트는 개별적으로 상속됩니다, 즉, 베이스형에 플래그 비트가 설정되어 있으면, 서브 "
"형이 이 플래그 비트를 상속합니다. 확장 구조체와 관련된 플래그 비트는 확장 구조체가 상속되면 엄격하게 상속됩니다, 즉, 플래그 "
"비트의 베이스형의 값이 확장 구조체에 대한 포인터와 함께 서브 형으로 복사됩니다. :const:`Py_TPFLAGS_HAVE_GC`"
" 플래그 비트는 :c:member:`~PyTypeObject.tp_traverse`\\와 "
":c:member:`~PyTypeObject.tp_clear` 필드와 함께 상속됩니다, 즉, 서브 형에서 "
":const:`Py_TPFLAGS_HAVE_GC` 플래그 비트가 설정되지 않고 서브 형의 "
":c:member:`~PyTypeObject.tp_traverse`\\와 "
":c:member:`~PyTypeObject.tp_clear` 필드가 존재하고 ``NULL`` 값을 갖는 경우."

#: ../../c-api/typeobj.rst:1072
#, fuzzy
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:type:`PyBaseObject_Type`\\은 ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``\\을 사용합니다."

#: ../../c-api/typeobj.rst:1075
msgid "**Bit Masks:**"
msgstr "**비트 마스크:**"

#: ../../c-api/typeobj.rst:1079
msgid ""
"The following bit masks are currently defined; these can be ORed together"
" using the ``|`` operator to form the value of the "
":c:member:`~PyTypeObject.tp_flags` field.  The macro "
":c:func:`PyType_HasFeature` takes a type and a flags value, *tp* and *f*,"
" and checks whether ``tp->tp_flags & f`` is non-zero."
msgstr ""
"다음 비트 마스크가 현재 정의되어 있습니다; 이들은 ``|`` 연산자로 함께 OR 하여 "
":c:member:`~PyTypeObject.tp_flags` 필드의 값을 형성할 수 있습니다. 매크로 "
":c:func:`PyType_HasFeature`\\는 형과 플래그 값 *tp*\\와 *f*\\를 취하고 ``tp->tp_flags"
" & f``\\가 0이 아닌지 확인합니다."

#: ../../c-api/typeobj.rst:1086
#, fuzzy
msgid ""
"This bit is set when the type object itself is allocated on the heap, for"
" example, types created dynamically using :c:func:`PyType_FromSpec`.  In "
"this case, the :c:member:`~PyObject.ob_type` field of its instances is "
"considered a reference to the type, and the type object is INCREF'ed when"
" a new instance is created, and DECREF'ed when an instance is destroyed "
"(this does not apply to instances of subtypes; only the type referenced "
"by the instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should"
" also :ref:`support garbage collection <supporting-cycle-detection>` as "
"they can form a reference cycle with their own module object."
msgstr ""
"이 비트는 형 객체 자체가 힙에 할당될 때 설정됩니다, 예를 들어, :c:func:`PyType_FromSpec`\\을 사용하여 "
"동적으로 만들어진 형. 이 경우, 인스턴스의 :attr:`ob_type` 필드는 형에 대한 참조로 간주하며, 새 인스턴스가 만들어질"
" 때 형 객체가 INCREF되고, 인스턴스가 파괴될 때 DECREF됩니다 (이는 서브 형의 인스턴스에 적용되지 않습니다; 인스턴스의"
" ob_type이 참조하는 형만 INCREF나 DECREF 됩니다)."

#: ../../c-api/typeobj.rst:1097 ../../c-api/typeobj.rst:1108
#: ../../c-api/typeobj.rst:1118 ../../c-api/typeobj.rst:1128
#: ../../c-api/typeobj.rst:1160
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1102
msgid ""
"This bit is set when the type can be used as the base type of another "
"type.  If this bit is clear, the type cannot be subtyped (similar to a "
"\"final\" class in Java)."
msgstr ""
"이 비트는 형을 다른 형의 베이스형으로 사용할 수 있을 때 설정됩니다. 이 비트가 설정되지 않으면 이 형으로 서브 형을 만들 수 "
"없습니다 (Java의 \"final\" 클래스와 유사합니다)."

#: ../../c-api/typeobj.rst:1113
msgid ""
"This bit is set when the type object has been fully initialized by "
":c:func:`PyType_Ready`."
msgstr "이 비트는 :c:func:`PyType_Ready`\\에 의해 형 객체가 완전히 초기화될 때 설정됩니다."

#: ../../c-api/typeobj.rst:1123
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr "이 비트는 :c:func:`PyType_Ready`\\가 형 객체를 초기화하는 동안 설정됩니다."

#: ../../c-api/typeobj.rst:1133
#, fuzzy
msgid ""
"This bit is set when the object supports garbage collection.  If this bit"
" is set, instances must be created using :c:macro:`PyObject_GC_New` and "
"destroyed using :c:func:`PyObject_GC_Del`.  More information in section "
":ref:`supporting-cycle-detection`.  This bit also implies that the GC-"
"related fields :c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` are present in the type object."
msgstr ""
"이 비트는 객체가 가비지 수집을 지원할 때 설정됩니다. 이 비트가 설정되면, 인스턴스는 "
":c:func:`PyObject_GC_New`\\를 사용하여 만들어져야 하고 :c:func:`PyObject_GC_Del`\\을 "
"사용하여 파괴되어야 합니다. :ref:`supporting-cycle-detection` 섹션에 추가 정보가 있습니다. 이 비트는 "
"또한 GC 관련 필드 :c:member:`~PyTypeObject.tp_traverse`\\와 "
":c:member:`~PyTypeObject.tp_clear`\\가 형 객체에 있음을 암시합니다."

#: ../../c-api/typeobj.rst:1142 ../../c-api/typeobj.rst:1483
#: ../../c-api/typeobj.rst:1557
#, fuzzy
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, "
":c:member:`~PyTypeObject.tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr "그룹: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"

#: ../../c-api/typeobj.rst:1144
#, fuzzy
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the"
" :c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields, i.e.  if the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the "
":c:member:`~PyTypeObject.tp_traverse` and "
":c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
":const:`Py_TPFLAGS_HAVE_GC` 플래그 비트는 :attr:`tp_traverse`\\와 "
":attr:`tp_clear` 필드와 함께 상속됩니다, 즉, 서브 형에서 :const:`Py_TPFLAGS_HAVE_GC` 플래그 "
"비트가 설정되지 않고 서브 형의 :attr:`tp_traverse`\\와 :attr:`tp_clear` 필드가 존재하고 "
"``NULL`` 값을 갖는 경우."

#: ../../c-api/typeobj.rst:1154
#, fuzzy
msgid ""
"This is a bitmask of all the bits that pertain to the existence of "
"certain fields in the type object and its extension structures. "
"Currently, it includes the following bits: "
":c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"이것은 형 객체와 그 확장 구조체에서 특정 필드의 존재와 관련된 모든 비트의 비트 마스크입니다. 현재, 다음과 같은 필드를 "
"포함합니다: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`, "
":const:`Py_TPFLAGS_HAVE_VERSION_TAG`."

#: ../../c-api/typeobj.rst:1165
msgid "This bit indicates that objects behave like unbound methods."
msgstr "이 비트는 객체가 연결되지 않은 메서드(unbound method)처럼 동작함을 나타냅니다."

#: ../../c-api/typeobj.rst:1167
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "이 플래그가 ``type(meth)``\\에 설정되면:"

#: ../../c-api/typeobj.rst:1169
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be"
" equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)``\\(``obj``\\가 None이 아닐 때)는 "
"``meth(obj, *args, **kwds)``\\와 동등해야 합니다."

#: ../../c-api/typeobj.rst:1172
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)``\\는 ``meth(*args, **kwds)``\\와 "
"동등해야 합니다."

#: ../../c-api/typeobj.rst:1175
msgid ""
"This flag enables an optimization for typical method calls like "
"``obj.meth()``: it avoids creating a temporary \"bound method\" object "
"for ``obj.meth``."
msgstr ""
"이 플래그는 ``obj.meth()``\\와 같은 일반적인 메서드 호출에 대한 최적화를 가능하게 합니다: "
"``obj.meth``\\에 대한 임시 \"연결된 메서드(bound method)\" 객체를 만들지 않습니다."

#: ../../c-api/typeobj.rst:1183
#, fuzzy
msgid ""
"This flag is never inherited by types without the "
":c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is"
" inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"이 플래그는 힙 형에 의해 상속되지 않습니다. 확장형의 경우, "
":c:member:`~PyTypeObject.tp_descr_get`\\이 상속될 때마다 상속됩니다."

#: ../../c-api/typeobj.rst:1189
msgid ""
"This bit indicates that instances of the class have a `~object.__dict__` "
"attribute, and that the space for the dictionary is managed by the VM."
msgstr ""

#: ../../c-api/typeobj.rst:1192
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""

#: ../../c-api/typeobj.rst:1194
msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` "
"and its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""

#: ../../c-api/typeobj.rst:1201
#, fuzzy
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset`"
" field is set in a superclass."
msgstr "이 필드는 폐지되었습니다. 대신 :c:member:`~PyTypeObject.tp_finalize`\\를 사용하십시오."

#: ../../c-api/typeobj.rst:1207
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr ""

#: ../../c-api/typeobj.rst:1214
#, fuzzy
msgid ""
"This flag is inherited unless the "
":c:member:`~PyTypeObject.tp_weaklistoffset` field is set in a superclass."
msgstr "이 필드는 폐지되었습니다. 대신 :c:member:`~PyTypeObject.tp_finalize`\\를 사용하십시오."

#: ../../c-api/typeobj.rst:1220
msgid ""
"Only usable with variable-size types, i.e. ones with non-zero "
":c:member:`~PyTypeObject.tp_itemsize`."
msgstr ""

#: ../../c-api/typeobj.rst:1223
msgid ""
"Indicates that the variable-sized portion of an instance of this type is "
"at the end of the instance's memory area, at an offset of "
"``Py_TYPE(obj)->tp_basicsize`` (which may be different in each subclass)."
msgstr ""

#: ../../c-api/typeobj.rst:1228
msgid ""
"When setting this flag, be sure that all superclasses either use this "
"memory layout, or are not variable-sized. Python does not check this."
msgstr ""

#: ../../c-api/typeobj.rst:1236
#, fuzzy
msgid "This flag is inherited."
msgstr "이 필드는 상속되지 않습니다."

#: ../../c-api/typeobj.rst:1250
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to "
"quickly determine if a type is a subclass of a built-in type; such "
"specific checks are faster than a generic check, like "
":c:func:`PyObject_IsInstance`. Custom types that inherit from built-ins "
"should have their :c:member:`~PyTypeObject.tp_flags` set appropriately, "
"or the code that interacts with such types will behave differently "
"depending on what kind of check is used."
msgstr ""
"이 플래그는 :c:func:`PyLong_Check` 와 같은 함수에서 형이 내장형의 서브 클래스인지 신속하게 판별하는 데 "
"사용됩니다; 이러한 특정 검사는 :c:func:`PyObject_IsInstance`\\와 같은 일반 검사보다 빠릅니다. 내장에서 "
"상속된 사용자 정의 형은 :c:member:`~PyTypeObject.tp_flags`\\를 적절하게 설정해야 합니다, 그렇지 "
"않으면 그러한 형과 상호 작용하는 코드가 사용되는 검사의 유형에 따라 다르게 작동합니다."

#: ../../c-api/typeobj.rst:1261
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr "이 비트는 :c:member:`~PyTypeObject.tp_finalize` 슬롯이 형 구조체에 있을 때 설정됩니다."

#: ../../c-api/typeobj.rst:1266
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the "
":c:member:`~PyTypeObject.tp_finalize` slot is always present in the type "
"structure."
msgstr ""
"인터프리터는 :c:member:`~PyTypeObject.tp_finalize` 슬롯이 항상 형 구조체에 있다고 가정하기 때문에, "
"이 플래그는 더는 필요하지 않습니다."

#: ../../c-api/typeobj.rst:1274
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"이 비트는 클래스가 :ref:`벡터콜 프로토콜 <vectorcall>`\\을 구현할 때 설정됩니다. 자세한 내용은 "
":c:member:`~PyTypeObject.tp_vectorcall_offset`\\을 참조하십시오."

#: ../../c-api/typeobj.rst:1280
#, fuzzy
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also "
"inherited."
msgstr "이 필드는 폐지되었습니다. 대신 :c:member:`~PyTypeObject.tp_finalize`\\를 사용하십시오."

#: ../../c-api/typeobj.rst:1287
msgid ""
"This flag is now removed from a class when the class's "
":py:meth:`~object.__call__` method is reassigned."
msgstr ""

#: ../../c-api/typeobj.rst:1290
#, fuzzy
msgid "This flag can now be inherited by mutable classes."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다."

#: ../../c-api/typeobj.rst:1294
msgid ""
"This bit is set for type objects that are immutable: type attributes "
"cannot be set nor deleted."
msgstr ""

#: ../../c-api/typeobj.rst:1296
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static "
"types <static-types>`."
msgstr ""

#: ../../c-api/typeobj.rst:1301
#, fuzzy
msgid "This flag is not inherited."
msgstr "이 필드는 상속되지 않습니다."

#: ../../c-api/typeobj.rst:1307
msgid ""
"Disallow creating instances of the type: set "
":c:member:`~PyTypeObject.tp_new` to NULL and don't create the ``__new__``"
" key in the type dictionary."
msgstr ""

#: ../../c-api/typeobj.rst:1311
msgid ""
"The flag must be set before creating the type, not after. For example, it"
" must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""

#: ../../c-api/typeobj.rst:1314
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if "
":c:member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and "
":c:member:`~PyTypeObject.tp_new` is NULL."
msgstr ""

#: ../../c-api/typeobj.rst:1320
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is"
" only possible via the C API)."
msgstr ""

#: ../../c-api/typeobj.rst:1327
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this "
"flag. Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for "
"subclasses."
msgstr ""

#: ../../c-api/typeobj.rst:1338
msgid ""
"This bit indicates that instances of the class may match mapping patterns"
" when used as the subject of a :keyword:`match` block. It is "
"automatically set when registering or subclassing "
":class:`collections.abc.Mapping`, and unset when registering "
":class:`collections.abc.Sequence`."
msgstr ""

#: ../../c-api/typeobj.rst:1345 ../../c-api/typeobj.rst:1367
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""

#: ../../c-api/typeobj.rst:1350
msgid ""
"This flag is inherited by types that do not already set "
":c:macro:`Py_TPFLAGS_SEQUENCE`."
msgstr ""

#: ../../c-api/typeobj.rst:1353 ../../c-api/typeobj.rst:1375
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ""

#: ../../c-api/typeobj.rst:1360
msgid ""
"This bit indicates that instances of the class may match sequence "
"patterns when used as the subject of a :keyword:`match` block. It is "
"automatically set when registering or subclassing "
":class:`collections.abc.Sequence`, and unset when registering "
":class:`collections.abc.Mapping`."
msgstr ""

#: ../../c-api/typeobj.rst:1372
msgid ""
"This flag is inherited by types that do not already set "
":c:macro:`Py_TPFLAGS_MAPPING`."
msgstr ""

#: ../../c-api/typeobj.rst:1382
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""

#: ../../c-api/typeobj.rst:1386
msgid ""
"This flag is present in header files, but is not be used. It will be "
"removed in a future version of CPython"
msgstr ""

#: ../../c-api/typeobj.rst:1392
#, fuzzy
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for"
" this type object.  This is exposed as the :attr:`~type.__doc__` "
"attribute on the type and instances of the type."
msgstr ""
"이 형 객체에 대한 독스트링을 제공하는 NUL-종료 C 문자열에 대한 선택적 포인터. 이는 형과 형의 인스턴스에서 "
":attr:`__doc__` 어트리뷰트로 노출됩니다."

#: ../../c-api/typeobj.rst:1398
msgid "This field is *not* inherited by subtypes."
msgstr "이 필드는 서브 형에 의해 상속되지 *않습니다*."

#: ../../c-api/typeobj.rst:1403
#, fuzzy
msgid ""
"An optional pointer to a traversal function for the garbage collector.  "
"This is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  "
"The signature is::"
msgstr ""
"가비지 수집기의 탐색 함수에 대한 선택적 포인터. :const:`Py_TPFLAGS_HAVE_GC` 플래그 비트가 설정된 경우에만 "
"사용됩니다. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:1406
msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr ""

#: ../../c-api/typeobj.rst:1408 ../../c-api/typeobj.rst:1552
msgid ""
"More information about Python's garbage collection scheme can be found in"
" section :ref:`supporting-cycle-detection`."
msgstr ""
"파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 :ref:`supporting-cycle-detection`\\에서 찾을 수 "
"있습니다."

#: ../../c-api/typeobj.rst:1411
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a "
":c:member:`~PyTypeObject.tp_traverse` function simply calls "
":c:func:`Py_VISIT` on each of the instance's members that are Python "
"objects that the instance owns. For example, this is function "
":c:func:`!local_traverse` from the :mod:`!_thread` extension module::"
msgstr ""
":c:member:`~PyTypeObject.tp_traverse` 포인터는 가비지 수집기에서 참조 순환을 감지하는 데 사용됩니다."
" :c:member:`~PyTypeObject.tp_traverse` 함수의 일반적인 구현은 단순히 인스턴스가 소유하는 파이썬 "
"객체인 각 인스턴스 멤버에 대해 :c:func:`Py_VISIT`\\를 호출합니다. 예를 들어, 다음은 :mod:`_thread` "
"확장 모듈의 함수 :c:func:`local_traverse`\\입니다::"

#: ../../c-api/typeobj.rst:1417
#, python-brace-format
msgid ""
"static int\n"
"local_traverse(localobject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:1426
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot "
"be part of a reference cycle."
msgstr ""
":c:func:`Py_VISIT`\\는 참조 순환에 참여할 수 있는 멤버에 대해서만 호출됨에 유의하십시오. ``self->key``"
" 멤버도 있지만, ``NULL``\\이나 파이썬 문자열만 가능해서 참조 순환의 일부가 될 수 없습니다."

#: ../../c-api/typeobj.rst:1430
msgid ""
"On the other hand, even if you know a member can never be part of a "
"cycle, as a debugging aid you may want to visit it anyway just so the "
":mod:`gc` module's :func:`~gc.get_referents` function will include it."
msgstr ""
"반면에, 멤버가 사이클의 일부가 될 수 없다는 것을 알고 있더라도, 디버깅 지원을 위해 :mod:`gc` 모듈의 "
":func:`~gc.get_referents` 함수가 그것을 포함하도록 어쨌거나 방문하고 싶을 수 있습니다."

#: ../../c-api/typeobj.rst:1434
msgid "Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr ""

#: ../../c-api/typeobj.rst:1436
msgid "Py_VISIT(Py_TYPE(self));"
msgstr ""

#: ../../c-api/typeobj.rst:1438
msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this"
" line must be conditional::"
msgstr ""

#: ../../c-api/typeobj.rst:1441
msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""

#: ../../c-api/typeobj.rst:1445
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, the traverse function must call"
" :c:func:`PyObject_VisitManagedDict` like this::"
msgstr ""

#: ../../c-api/typeobj.rst:1449
msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr ""

#: ../../c-api/typeobj.rst:1452
#, fuzzy
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members"
" that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports"
" weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak "
"references to itself (the weakreference list is there to support the weak"
" reference machinery, but the instance has no strong reference to the "
"elements inside it, as they are allowed to be removed even if the "
"instance is still alive)."
msgstr ""
":c:member:`~PyTypeObject.tp_traverse`\\를 구현할 때, 인스턴스가 *소유하는*\\(강한 참조를 "
"유지하는) 멤버만 방문해야 합니다. 예를 들어, 객체가 :c:member:`~PyTypeObject.tp_weaklist` 슬롯을 "
"통해 약한 참조를 지원하면, 인스턴스가 자신에 대한 약한 참조를 직접 소유하지 않기 때문에 링크드 리스트를 지원하는 "
"포인터(*tp_weaklist*\\가 가리키는 것)를 방문해서는 **안됩니다** (약한 참조 리스트는 약한 참조 장치를 지원하기 "
"위해 거기에 있습니다. 하지만 인스턴스가 아직 살아 있어도 제거할 수 있어서, 인스턴스는 그 안의 요소에 대한 강한 참조를 갖지 "
"않습니다)."

#: ../../c-api/typeobj.rst:1463
#, fuzzy
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to"
" :c:func:`!local_traverse` to have these specific names; don't name them "
"just anything."
msgstr ""
":c:func:`Py_VISIT`\\는 :c:func:`local_traverse`\\의 *visit*\\와 *arg* 매개 변수가"
" 이 이름일 것을 요구합니다; 다른 이름을 붙이지 마십시오."

#: ../../c-api/typeobj.rst:1467
#, fuzzy
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to"
" their type. Their traversal function must therefore either visit "
":c:func:`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by "
"calling ``tp_traverse`` of another heap-allocated type (such as a heap-"
"allocated superclass). If they do not, the type object may not be "
"garbage-collected."
msgstr ""
"힙 할당 형(:const:`Py_TPFLAGS_HEAPTYPE`, :c:func:`PyType_FromSpec`\\과 유사한 "
"API로 만들어진 것과 같은)은 그들의 형에 대한 참조를 보유합니다. 따라서 순회 함수는 :c:func:`Py_TYPE(self) "
"<Py_TYPE>`\\를 방문하거나, 다른 힙 할당 형(가령 힙 할당 슈퍼 클래스)의 ``tp_traverse``\\를 호출하여 이"
" 책임을 위임해야 합니다. 그렇지 않으면, 형 객체가 가비지 수거되지 않을 수 있습니다."

#: ../../c-api/typeobj.rst:1476
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 "
"<https://bugs.python.org/issue40217>`_, doing this may lead to crashes in"
" subclasses."
msgstr ""
"힙 할당 형은 ``tp_traverse``\\에서 ``Py_TYPE(self)``\\를 방문할 것으로 기대됩니다. 이전 버전의 "
"파이썬에서는, `버그 40217 <https://bugs.python.org/issue40217>`_\\로 인해, 이렇게 하면 서브"
" 클래스에서 충돌이 발생할 수 있습니다."

#: ../../c-api/typeobj.rst:1485
#, fuzzy
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and "
":c:member:`~PyTypeObject.tp_clear` are all inherited from the base type "
"if they are all zero in the subtype."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_clear`\\와 :const:`Py_TPFLAGS_HAVE_GC` "
"플래그 비트와 함께 서브 형에 의해 상속됩니다: 플래그 비트, :c:member:`~PyTypeObject.tp_traverse` "
"및 :c:member:`~PyTypeObject.tp_clear`\\가 서브 형에서 모두 0이면 모두 베이스형에서 상속됩니다."

#: ../../c-api/typeobj.rst:1493
#, fuzzy
msgid ""
"An optional pointer to a clear function for the garbage collector. This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"가비지 수집기의 정리 함수(clear function)에 대한 선택적 포인터. :const:`Py_TPFLAGS_HAVE_GC` "
"플래그 비트가 설정된 경우에만 사용됩니다. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:1496
msgid "int tp_clear(PyObject *);"
msgstr ""

#: ../../c-api/typeobj.rst:1498
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  "
"Taken together, all :c:member:`~PyTypeObject.tp_clear` functions in the "
"system must combine to break all reference cycles.  This is subtle, and "
"if in any doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  "
"For example, the tuple type does not implement a "
":c:member:`~PyTypeObject.tp_clear` function, because it's possible to "
"prove that no reference cycle can be composed entirely of tuples. "
"Therefore the :c:member:`~PyTypeObject.tp_clear` functions of other types"
" must be sufficient to break any cycle containing a tuple.  This isn't "
"immediately obvious, and there's rarely a good reason to avoid "
"implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 멤버 함수는 가비지 수집기에서 감지한 순환 가비지에서 참조 순환을 "
"끊는 데 사용됩니다. 종합하여, 시스템의 모든 :c:member:`~PyTypeObject.tp_clear` 함수가 결합하여 모든 "
"참조 순환을 끊어야 합니다. 이것은 미묘합니다, 확신이 서지 않으면 :c:member:`~PyTypeObject.tp_clear` "
"함수를 제공하십시오. 예를 들어, 튜플 형은 :c:member:`~PyTypeObject.tp_clear` 함수를 구현하지 "
"않습니다. 튜플만으로는 참조 순환이 구성될 수 없음을 증명할 수 있기 때문입니다. 따라서 다른 형의 "
":c:member:`~PyTypeObject.tp_clear` 함수만으로 튜플을 포함하는 순환을 끊기에 충분해야 합니다. 이것은 "
"그리 자명하지 않으며, :c:member:`~PyTypeObject.tp_clear`\\를 구현하지 않아도 좋을 만한 이유는 거의 "
"없습니다."

#: ../../c-api/typeobj.rst:1508
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects,"
" and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
":c:member:`~PyTypeObject.tp_clear`\\의 구현은 다음 예제와 같이 파이썬 객체일 수 있는 자신의 멤버에 "
"대한 인스턴스의 참조를 삭제하고 해당 멤버에 대한 포인터를 ``NULL``\\로 설정해야 합니다::"

#: ../../c-api/typeobj.rst:1512
#, python-brace-format
msgid ""
"static int\n"
"local_clear(localobject *self)\n"
"{\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:1522
#, fuzzy
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references "
"is delicate:  the reference to the contained object must not be released "
"(via :c:func:`Py_DECREF`) until after the pointer to the contained object"
" is set to ``NULL``.  This is because releasing the reference may cause "
"the contained object to become trash, triggering a chain of reclamation "
"activity that may include invoking arbitrary Python code (due to "
"finalizers, or weakref callbacks, associated with the contained object). "
"If it's possible for such code to reference *self* again, it's important "
"that the pointer to the contained object be ``NULL`` at that time, so "
"that *self* knows the contained object can no longer be used.  The "
":c:func:`Py_CLEAR` macro performs the operations in a safe order."
msgstr ""
"참조 제거는 섬세한 작업이라서 :c:func:`Py_CLEAR` 매크로를 사용해야 합니다: 포함된 객체에 대한 포인터가 "
"``NULL``\\로 설정될 때까지 포함된 객체에 대한 참조를 감소시키지 않아야 합니다. 이는 참조 횟수를 줄이면 포함된 객체가 "
"버려지게 되어 임의의 파이썬 코드 호출을 포함하는 일련의 교정 활동을 촉발할 수 있기 때문입니다 (포함된 객체와 연관된 "
"파이널라이저나 약한 참조 콜백으로 인해). 그러한 코드가 *self*\\를 다시 참조 할 수 있다면, 포함된 객체를 더는 사용할 수"
" 없다는 것을 *self*\\가 알 수 있도록, 포함된 객체에 대한 포인터가 그 시점에 ``NULL``\\이 되는 것이 중요합니다."
" :c:func:`Py_CLEAR` 매크로는 안전한 순서로 작업을 수행합니다."

#: ../../c-api/typeobj.rst:1534
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, the traverse function must call"
" :c:func:`PyObject_ClearManagedDict` like this::"
msgstr ""

#: ../../c-api/typeobj.rst:1538
msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr ""

#: ../../c-api/typeobj.rst:1540
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called "
"before an instance is deallocated. For example, when reference counting "
"is enough to determine that an object is no longer used, the cyclic "
"garbage collector is not involved and "
":c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""

#: ../../c-api/typeobj.rst:1546
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to "
"break reference cycles, it's not necessary to clear contained objects "
"like Python strings or Python integers, which can't participate in "
"reference cycles. On the other hand, it may be convenient to clear all "
"contained Python objects, and write the type's "
":c:member:`~PyTypeObject.tp_dealloc` function to invoke "
":c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 함수의 목표는 참조 순환을 끊는 것이기 때문에, 참조 순환에 참여할 "
"수 없는 파이썬 문자열이나 파이썬 정수와 같은 포함된 객체를 정리할 필요는 없습니다. 반면에, 포함된 모든 파이썬 객체를 정리하고,"
" 형의 :c:member:`~PyTypeObject.tp_dealloc` 함수가 "
":c:member:`~PyTypeObject.tp_clear`\\를 호출하도록 작성하는 것이 편리할 수 있습니다."

#: ../../c-api/typeobj.rst:1559
#, fuzzy
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_traverse` and the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, "
":c:member:`~PyTypeObject.tp_traverse`, and "
":c:member:`~PyTypeObject.tp_clear` are all inherited from the base type "
"if they are all zero in the subtype."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_traverse`\\와 "
":const:`Py_TPFLAGS_HAVE_GC` 플래그 비트와 함께 서브 형에 의해 상속됩니다: 플래그 비트, "
":c:member:`~PyTypeObject.tp_traverse` 및 "
":c:member:`~PyTypeObject.tp_clear`\\가 서브 형에서 모두 0이면 모두 베이스형에서 상속됩니다."

#: ../../c-api/typeobj.rst:1567
msgid "An optional pointer to the rich comparison function, whose signature is::"
msgstr "풍부한 비교 함수(rich comparison function)에 대한 선택적 포인터. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:1569
msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr ""

#: ../../c-api/typeobj.rst:1571
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr "첫 번째 매개 변수는 :c:type:`PyTypeObject`\\에 의해 정의된 형의 인스턴스임이 보장됩니다."

#: ../../c-api/typeobj.rst:1574
msgid ""
"The function should return the result of the comparison (usually "
"``Py_True`` or ``Py_False``).  If the comparison is undefined, it must "
"return ``Py_NotImplemented``, if another error occurred it must return "
"``NULL`` and set an exception condition."
msgstr ""
"이 함수는 비교 결과(일반적으로 ``Py_True``\\나 ``Py_False``)를 반환해야 합니다. 비교가 정의되어 있지 "
"않으면, ``Py_NotImplemented``\\를 반환하고, 다른 에러가 발생하면 ``NULL``\\을 반환하고 예외 조건을 "
"설정해야 합니다."

#: ../../c-api/typeobj.rst:1579
msgid ""
"The following constants are defined to be used as the third argument for "
":c:member:`~PyTypeObject.tp_richcompare` and for "
":c:func:`PyObject_RichCompare`:"
msgstr ""
"다음 상수는 :c:member:`~PyTypeObject.tp_richcompare`\\와 "
":c:func:`PyObject_RichCompare`\\의 세 번째 인자로 사용되도록 정의됩니다:"

#: ../../c-api/typeobj.rst:1585
msgid "Constant"
msgstr "상수"

#: ../../c-api/typeobj.rst:1585
msgid "Comparison"
msgstr "비교"

#: ../../c-api/typeobj.rst:1587
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1589
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1591
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1593
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1595
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1597
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1600
msgid "The following macro is defined to ease writing rich comparison functions:"
msgstr "풍부한 비교 함수를 쉽게 작성할 수 있도록 다음 매크로가 정의됩니다:"

#: ../../c-api/typeobj.rst:1604
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison"
" operators (for example, they may be C ints or floats). The third "
"argument specifies the requested operation, as for "
":c:func:`PyObject_RichCompare`."
msgstr ""
"비교 결과에 따라, 함수에서 ``Py_True``\\나 ``Py_False``\\를 반환합니다. VAL_A\\와 VAL_B는 C "
"비교 연산자로 순서를 정할 수 있어야 합니다 (예를 들어, C int나 float일 수 있습니다). 세 번째 인자는 "
":c:func:`PyObject_RichCompare`\\에서처럼 요청된 연산을 지정합니다."

#: ../../c-api/typeobj.rst:1610
msgid "The returned value is a new :term:`strong reference`."
msgstr ""

#: ../../c-api/typeobj.rst:1612
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "에러가 발생하면, 예외를 설정하고 함수에서 ``NULL``\\을 반환합니다."

#: ../../c-api/typeobj.rst:1620
msgid ""
"This field is inherited by subtypes together with "
":c:member:`~PyTypeObject.tp_hash`: a subtype inherits "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` when the subtype's "
":c:member:`~PyTypeObject.tp_richcompare` and "
":c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_hash`\\와 함께 서브 형에 의해 상속됩니다. 서브 형의 "
":c:member:`~PyTypeObject.tp_richcompare`\\와 "
":c:member:`~PyTypeObject.tp_hash`\\가 모두 ``NULL``\\이면 서브 형은 "
":c:member:`~PyTypeObject.tp_richcompare`\\와 "
":c:member:`~PyTypeObject.tp_hash`\\를 상속합니다."

#: ../../c-api/typeobj.rst:1627
#, fuzzy
msgid ""
":c:data:`PyBaseObject_Type` provides a "
":c:member:`~PyTypeObject.tp_richcompare` implementation, which may be "
"inherited.  However, if only :c:member:`~PyTypeObject.tp_hash` is "
"defined, not even the inherited function is used and instances of the "
"type will not be able to participate in any comparisons."
msgstr ""
":c:type:`PyBaseObject_Type`\\은 상속될 수 있는 :attr:`tp_richcompare` 구현을 제공합니다."
" 그러나, :attr:`tp_hash`\\만 정의하면, 상속된 함수조차 사용되지 않으며 해당 형의 인스턴스는 비교에 참여할 수 "
"없습니다."

#: ../../c-api/typeobj.rst:1636
msgid ""
"While this field is still supported, "
":c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` should be used instead, if at all "
"possible."
msgstr ""

#: ../../c-api/typeobj.rst:1639
#, fuzzy
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of "
"the weak reference list head (ignoring the GC header, if present); this "
"offset is used by :c:func:`PyObject_ClearWeakRefs` and the "
"``PyWeakref_*`` functions.  The instance structure needs to include a "
"field of type :c:expr:`PyObject*` which is initialized to ``NULL``."
msgstr ""
"이 형의 인스턴스가 약하게 참조할 수 있으면, 이 필드는 0보다 크고 약한 참조 리스트 헤드의 인스턴스 구조체에서의 오프셋을 "
"포함합니다 (있다면 GC 헤더를 무시하고); 이 오프셋은 :c:func:`PyObject_ClearWeakRefs`\\와 "
":c:func:`PyWeakref_\\*` 함수에서 사용됩니다. 인스턴스 구조체에는 ``NULL``\\로 초기화되는 "
":c:type:`PyObject*` 형의 필드가 포함되어야 합니다."

#: ../../c-api/typeobj.rst:1646
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; "
"that is the list head for weak references to the type object itself."
msgstr ""
"이 필드를 :c:member:`~PyTypeObject.tp_weaklist`\\와 혼동하지 마십시오; 그것은 형 객체 자체에 대한"
" 약한 참조의 리스트 헤드입니다."

#: ../../c-api/typeobj.rst:1649
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""

#: ../../c-api/typeobj.rst:1654
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list "
"head is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, "
"this should not be a problem."
msgstr ""
"이 필드는 서브 형에 의해 상속되지만, 아래 나열된 규칙을 참조하십시오. 서브 형이 이 오프셋을 재정의할 수 있습니다; 이는 서브 "
"형이 베이스형과 다른 약한 참조 리스트 헤드를 사용함을 의미합니다. 리스트 헤드는 항상 "
":c:member:`~PyTypeObject.tp_weaklistoffset`\\을 통해 발견되므로, 문제가 되지 않습니다."

#: ../../c-api/typeobj.rst:1661
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, then "
":c:member:`~PyTypeObject.tp_weaklistoffset` will be set to a negative "
"value, to indicate that it is unsafe to use this field."
msgstr ""

#: ../../c-api/typeobj.rst:1669
#, fuzzy
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for "
"the object.  Its presence normally signals that the instances of this "
"type are :term:`iterable` (although sequences may be iterable without "
"this function)."
msgstr ""
"객체의 이터레이터를 반환하는 함수에 대한 선택적 포인터. 그 존재는 일반적으로 이 형의 인스턴스가 이터러블이라는 신호입니다 "
"(시퀀스는 이 함수 없이도 이터러블일 수 있지만)."

#: ../../c-api/typeobj.rst:1673
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "이 함수는 :c:func:`PyObject_GetIter`\\와 같은 서명을 갖습니다::"

#: ../../c-api/typeobj.rst:1675
msgid "PyObject *tp_iter(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:1684
#, fuzzy
msgid ""
"An optional pointer to a function that returns the next item in an "
":term:`iterator`. The signature is::"
msgstr "이터레이터의 다음 항목을 반환하는 함수에 대한 선택적 포인터. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:1687
msgid "PyObject *tp_iternext(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:1689
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a "
":exc:`StopIteration` exception may or may not be set.  When another error"
" occurs, it must return ``NULL`` too.  Its presence signals that the "
"instances of this type are iterators."
msgstr ""
"이터레이터가 소진되면 ``NULL``\\을 반환해야 합니다; :exc:`StopIteration` 예외가 설정될 수도, 그렇지 않을"
" 수도 있습니다. 다른 에러가 발생하면, 역시 ``NULL``\\을 반환해야 합니다. 그 존재는 이 형의 인스턴스가 이터레이터라는 "
"신호입니다."

#: ../../c-api/typeobj.rst:1694
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself "
"(not a new iterator instance)."
msgstr ""
"이터레이터 형은 :c:member:`~PyTypeObject.tp_iter` 함수도 정의해야 하며, 해당 함수는 (새 이터레이터 "
"인스턴스가 아닌) 이터레이터 인스턴스 자체를 반환해야 합니다."

#: ../../c-api/typeobj.rst:1698
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "이 함수는 :c:func:`PyIter_Next`\\와 같은 서명을 갖습니다."

#: ../../c-api/typeobj.rst:1707
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"이 형의 일반 메서드를 선언하는 :c:type:`PyMethodDef` 구조체의 정적 ``NULL``-종료 배열에 대한 선택적 "
"포인터."

#: ../../c-api/typeobj.rst:1710
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method "
"descriptor."
msgstr ""
"배열의 항목마다, 메서드 디스크립터를 포함하는 형의 딕셔너리(아래 :c:member:`~PyTypeObject.tp_dict`\\를"
" 참조하십시오)에 항목이 추가됩니다."

#: ../../c-api/typeobj.rst:1715
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다 (메서드는 다른 메커니즘을 통해 상속됩니다)."

#: ../../c-api/typeobj.rst:1721
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyMemberDef` structures, declaring regular data members (fields "
"or slots) of instances of this type."
msgstr ""
"이 형의 인스턴스의 일반 데이터 멤버(필드나 슬롯)를 선언하는 :c:type:`PyMemberDef` 구조체의 정적 "
"``NULL``-종료 배열에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1725
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member "
"descriptor."
msgstr ""
"배열의 항목마다, 멤버 디스크립터를 포함하는 형의 딕셔너리(아래 :c:member:`~PyTypeObject.tp_dict`\\를 "
"참조하십시오)에 항목이 추가됩니다."

#: ../../c-api/typeobj.rst:1730
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다 (멤버는 다른 메커니즘을 통해 상속됩니다)."

#: ../../c-api/typeobj.rst:1736
msgid ""
"An optional pointer to a static ``NULL``-terminated array of "
":c:type:`PyGetSetDef` structures, declaring computed attributes of "
"instances of this type."
msgstr ""
"이 형의 인스턴스의 계산된 어트리뷰트를 선언하는 :c:type:`PyGetSetDef` 구조체의 정적 ``NULL``-종료 배열에 "
"대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1739
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset "
"descriptor."
msgstr ""
"배열의 항목마다, getset 디스크립터를 포함하는 형의 딕셔너리(아래 "
":c:member:`~PyTypeObject.tp_dict`\\를 참조하십시오)에 항목이 추가됩니다."

#: ../../c-api/typeobj.rst:1744
msgid ""
"This field is not inherited by subtypes (computed attributes are "
"inherited through a different mechanism)."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다 (계산된 어트리뷰트는 다른 메커니즘을 통해 상속됩니다)."

#: ../../c-api/typeobj.rst:1750
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple"
" inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"형 속성이 상속되는 베이스형에 대한 선택적 포인터. 이 수준에서는, 단일 상속만 지원됩니다; 다중 상속은 메타 형을 호출하여 형 "
"객체를 동적으로 작성해야 합니다."

#: ../../c-api/typeobj.rst:1758
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function "
"designators like :c:func:`PyType_GenericNew`, with implicit conversion to"
" a pointer, are valid C99 address constants."
msgstr ""
"슬롯 초기화에는 전역 초기화 규칙이 적용됩니다. C99에서는 초기화자가 \"주소 상수(address constants)\"여야 "
"합니다. 포인터로 묵시적으로 변환되는 :c:func:`PyType_GenericNew`\\와 같은 함수 지정자는 유효한 C99 주소"
" 상수입니다."

#: ../../c-api/typeobj.rst:1763
#, fuzzy
msgid ""
"However, the unary '&' operator applied to a non-static variable like "
":c:data:`PyBaseObject_Type` is not required to produce an address "
"constant.  Compilers may support this (gcc does), MSVC does not. Both "
"compilers are strictly standard conforming in this particular behavior."
msgstr ""
"그러나, :c:func:`PyBaseObject_Type`\\과 같은 정적이지 않은 변수에 적용된 단항 '&' 연산자는 주소 상수를"
" 생성할 필요가 없습니다. 컴파일러는 이를 지원할 수 있으며 (gcc는 지원합니다), MSVC는 지원하지 않습니다. 두 컴파일러 "
"모두 이 특정 동작에서 엄격하게 표준을 준수합니다."

#: ../../c-api/typeobj.rst:1769
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr "결과적으로, :c:member:`~PyTypeObject.tp_base`\\는 확장 모듈의 초기화 함수에서 설정되어야 합니다."

#: ../../c-api/typeobj.rst:1774
msgid "This field is not inherited by subtypes (obviously)."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다 (명백히)."

#: ../../c-api/typeobj.rst:1778
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python "
"programmers is known as the type :class:`object`)."
msgstr ""
"이 필드의 기본값은 ``&PyBaseObject_Type``\\입니다 (파이썬 프로그래머에게는 :class:`object` 형으로 "
"알려져 있습니다)."

#: ../../c-api/typeobj.rst:1784
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "형의 딕셔너리는 :c:func:`PyType_Ready`\\에 의해 여기에 저장됩니다."

#: ../../c-api/typeobj.rst:1786
#, fuzzy
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready"
" is called; it may also be initialized to a dictionary containing initial"
" attributes for the type.  Once :c:func:`PyType_Ready` has initialized "
"the type, extra attributes for the type may be added to this dictionary "
"only if they don't correspond to overloaded operations (like "
":meth:`~object.__add__`).  Once initialization for the type has finished,"
" this field should be treated as read-only."
msgstr ""
"이 필드는 일반적으로 PyType_Ready가 호출되기 전에 ``NULL``\\로 초기화되어야 합니다; 형의 초기 어트리뷰트를 "
"포함하는 딕셔너리로 초기화될 수도 있습니다. 일단 :c:func:`PyType_Ready`\\가 형을 초기화하면, 형에 대한 추가 "
"어트리뷰트가 (:meth:`__add__`\\와 같은) 오버로드된 연산에 해당하지 않는 경우에만 이 딕셔너리에 추가될 수 있습니다."

#: ../../c-api/typeobj.rst:1794
msgid ""
"Some types may not store their dictionary in this slot. Use "
":c:func:`PyType_GetDict` to retrieve the dictionary for an arbitrary "
"type."
msgstr ""

#: ../../c-api/typeobj.rst:1800
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use"
" :c:func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""

#: ../../c-api/typeobj.rst:1806
msgid ""
"This field is not inherited by subtypes (though the attributes defined in"
" here are inherited through a different mechanism)."
msgstr "이 필드는 서브 형에 의해 상속되지 않습니다 (여기에 정의된 어트리뷰트는 다른 메커니즘을 통해 상속됩니다)."

#: ../../c-api/typeobj.rst:1811
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr "이 필드가 ``NULL``\\이면, :c:func:`PyType_Ready`\\는 새 딕셔너리를 할당합니다."

#: ../../c-api/typeobj.rst:1816
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify "
":c:member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
":c:func:`PyDict_SetItem`\\을 사용하거나 다른 식으로 딕셔너리 C-API로 "
":c:member:`~PyTypeObject.tp_dict`\\를 수정하는 것은 안전하지 않습니다."

#: ../../c-api/typeobj.rst:1822
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "\"디스크립터 get\" 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1824 ../../c-api/typeobj.rst:1840
#: ../../c-api/typeobj.rst:1904 ../../c-api/typeobj.rst:1934
#: ../../c-api/typeobj.rst:1958
msgid "The function signature is::"
msgstr "함수 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:1826
msgid "PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""

#: ../../c-api/typeobj.rst:1837
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's"
" value."
msgstr "디스크립터 값을 설정하고 삭제하기 위한 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1842
msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr ""

#: ../../c-api/typeobj.rst:1844
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "*value* 인자는 값을 삭제하기 위해 ``NULL``\\로 설정됩니다."

#: ../../c-api/typeobj.rst:1855
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""

#: ../../c-api/typeobj.rst:1858
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the "
"instances of the type of the instance variable dictionary; this offset is"
" used by :c:func:`PyObject_GenericGetAttr`."
msgstr ""
"이 형의 인스턴스에 인스턴스 변수를 포함하는 딕셔너리가 있으면, 이 필드는 0이 아니며 인스턴스 변수 딕셔너리 형의 인스턴스에서의 "
"오프셋을 포함합니다; 이 오프셋은 :c:func:`PyObject_GenericGetAttr`\\에서 사용됩니다."

#: ../../c-api/typeobj.rst:1863
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is"
" the dictionary for attributes of the type object itself."
msgstr ""
"이 필드를 :c:member:`~PyTypeObject.tp_dict`\\와 혼동하지 마십시오; 그것은 형 객체 자체의 어트리뷰트에"
" 대한 딕셔너리입니다."

#: ../../c-api/typeobj.rst:1866
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr ""

#: ../../c-api/typeobj.rst:1868
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call "
":c:func:`PyObject_GenericGetDict`. Calling "
":c:func:`PyObject_GenericGetDict` may need to allocate memory for the "
"dictionary, so it is may be more efficient to call "
":c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""

#: ../../c-api/typeobj.rst:1874
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit and"
" :c:member:`~PyTypeObject.tp_dictoffset`."
msgstr ""

#: ../../c-api/typeobj.rst:1879
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the "
"dictionary at the previous offset. To properly support inheritance, use "
":c:macro:`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""

#: ../../c-api/typeobj.rst:1886
#, fuzzy
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the"
" field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"이 슬롯에는 기본값이 없습니다. 정적 형의 경우, 이 필드가 ``NULL``\\이면 인스턴스에 대해 "
":attr:`__dict__`\\가 만들어지지 않습니다."

#: ../../c-api/typeobj.rst:1889
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the "
":c:member:`~PyTypeObject.tp_flags` field, then "
":c:member:`~PyTypeObject.tp_dictoffset` will be set to ``-1``, to "
"indicate that it is unsafe to use this field."
msgstr ""

#: ../../c-api/typeobj.rst:1897
msgid "An optional pointer to an instance initialization function."
msgstr "인스턴스 초기화 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1899
#, fuzzy
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"이 함수는 클래스의 :meth:`__init__` 메서드에 해당합니다. :meth:`__init__`\\와 마찬가지로, "
":meth:`__init__`\\를 호출하지 않고 인스턴스를 작성할 수 있으며, :meth:`__init__` 메서드를 다시 "
"호출하여 인스턴스를 다시 초기화 할 수 있습니다."

#: ../../c-api/typeobj.rst:1906
msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr ""

#: ../../c-api/typeobj.rst:1908
#, fuzzy
msgid ""
"The self argument is the instance to be initialized; the *args* and "
"*kwds* arguments represent positional and keyword arguments of the call "
"to :meth:`~object.__init__`."
msgstr ""
"self 인자는 초기화될 인스턴스입니다; *args*\\와 *kwds* 인자는 :meth:`__init__` 호출의 위치와 키워드 "
"인자를 나타냅니다."

#: ../../c-api/typeobj.rst:1912
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is "
"called when an instance is created normally by calling its type, after "
"the type's :c:member:`~PyTypeObject.tp_new` function has returned an "
"instance of the type.  If the :c:member:`~PyTypeObject.tp_new` function "
"returns an instance of some other type that is not a subtype of the "
"original type, no :c:member:`~PyTypeObject.tp_init` function is called; "
"if :c:member:`~PyTypeObject.tp_new` returns an instance of a subtype of "
"the original type, the subtype's :c:member:`~PyTypeObject.tp_init` is "
"called."
msgstr ""
"``NULL``\\이 아닐 때, :c:member:`~PyTypeObject.tp_init` 함수는 형을 호출하여 인스턴스를 "
"정상적으로 만들 때, 형의 :c:member:`~PyTypeObject.tp_new` 함수가 형의 인스턴스를 반환한 후 호출됩니다."
" :c:member:`~PyTypeObject.tp_new` 함수가 원래 형의 서브 형이 아닌 다른 형의 인스턴스를 반환하면, "
"아무런 :c:member:`~PyTypeObject.tp_init` 함수도 호출되지 않습니다; "
":c:member:`~PyTypeObject.tp_new`\\가 원래 형의 서브 형 인스턴스를 반환하면, 서브 형의 "
":c:member:`~PyTypeObject.tp_init`\\가 호출됩니다."

#: ../../c-api/typeobj.rst:1919
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr "성공하면 ``0``\\을 반환하고, 에러 시에는 ``-1``\\을 반환하고 예외를 설정합니다."

#: ../../c-api/typeobj.rst:1927
#, fuzzy
msgid "For :ref:`static types <static-types>` this field does not have a default."
msgstr "정적 형의 경우 이 필드에는 기본값이 없습니다."

#: ../../c-api/typeobj.rst:1932
msgid "An optional pointer to an instance allocation function."
msgstr "인스턴스 할당 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1936
msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr ""

#: ../../c-api/typeobj.rst:1940
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr "이 필드는 정적 서브 형에 의해 상속되지만, 동적 서브 형(클래스 문으로 만들어진 서브 형)에는 상속되지 않습니다."

#: ../../c-api/typeobj.rst:1945
msgid ""
"For dynamic subtypes, this field is always set to "
":c:func:`PyType_GenericAlloc`, to force a standard heap allocation "
"strategy."
msgstr ""
"동적 서브 형의 경우, 이 필드는 표준 힙 할당 전략을 강제하기 위해 항상 "
":c:func:`PyType_GenericAlloc`\\으로 설정됩니다."

#: ../../c-api/typeobj.rst:1949
#, fuzzy
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses "
":c:func:`PyType_GenericAlloc`.  That is the recommended value for all "
"statically defined types."
msgstr ""
"정적 서브 형의 경우, :c:type:`PyBaseObject_Type`\\은 "
":c:func:`PyType_GenericAlloc`\\을 사용합니다. 이것이 정적으로 정의된 모든 형에 권장되는 값입니다."

#: ../../c-api/typeobj.rst:1956
msgid "An optional pointer to an instance creation function."
msgstr "인스턴스 생성 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:1960
msgid "PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""

#: ../../c-api/typeobj.rst:1962
msgid ""
"The *subtype* argument is the type of the object being created; the "
"*args* and *kwds* arguments represent positional and keyword arguments of"
" the call to the type.  Note that *subtype* doesn't have to equal the "
"type whose :c:member:`~PyTypeObject.tp_new` function is called; it may be"
" a subtype of that type (but not an unrelated type)."
msgstr ""
"*subtype* 인자는 만들어지고 있는 객체의 형입니다; *args*\\와 *kwds* 인자는 형 호출의 위치와 키워드 인자를 "
"나타냅니다. *subtype*\\이 :c:member:`~PyTypeObject.tp_new` 함수가 호출되는 형과 같을 필요는 "
"없음에 유의하십시오; 이 형의 서브 형일 수 있습니다 (하지만 관련이 없는 형은 아닙니다)."

#: ../../c-api/typeobj.rst:1968
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call "
"``subtype->tp_alloc(subtype, nitems)`` to allocate space for the object, "
"and then do only as much further initialization as is absolutely "
"necessary.  Initialization that can safely be ignored or repeated should "
"be placed in the :c:member:`~PyTypeObject.tp_init` handler.  A good rule "
"of thumb is that for immutable types, all initialization should take "
"place in :c:member:`~PyTypeObject.tp_new`, while for mutable types, most "
"initialization should be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
":c:member:`~PyTypeObject.tp_new` 함수는 객체에 공간을 할당하기 위해 "
"``subtype->tp_alloc(subtype, nitems)``\\를 호출해야 하고, 그런 다음 꼭 필요한 만큼만 추가 "
"초기화를 수행해야 합니다. 안전하게 무시하거나 반복할 수 있는 초기화는 :c:member:`~PyTypeObject.tp_init`"
" 처리기에 배치해야 합니다. 간단한 규칙은, 불변 형의 경우 모든 초기화가 "
":c:member:`~PyTypeObject.tp_new`\\에서 수행되어야 하고, 가변형의 경우 대부분 초기화는 "
":c:member:`~PyTypeObject.tp_init`\\로 미뤄져야 합니다."

#: ../../c-api/typeobj.rst:1976
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""

#: ../../c-api/typeobj.rst:1981
#, fuzzy
msgid ""
"This field is inherited by subtypes, except it is not inherited by "
":ref:`static types <static-types>` whose "
":c:member:`~PyTypeObject.tp_base` is ``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"이 필드는 :c:member:`~PyTypeObject.tp_base`\\가 ``NULL``\\이나 "
"``&PyBaseObject_Type``\\인 정적 형에 의해 상속되지 않는 것을 제외하고 서브 형에 의해 상속됩니다."

#: ../../c-api/typeobj.rst:1987
#, fuzzy
msgid ""
"For :ref:`static types <static-types>` this field has no default. This "
"means if the slot is defined as ``NULL``, the type cannot be called to "
"create new instances; presumably there is some other way to create "
"instances, like a factory function."
msgstr ""
"정적 형의 경우 이 필드에는 기본값이 없습니다. 이는 슬롯이 ``NULL``\\로 정의되었을 때, 새 인스턴스를 만들기 위해 형을 "
"호출할 수 없음을 뜻합니다; 아마도 팩토리 함수와 같은, 인스턴스를 만드는 다른 방법이 있을 것입니다."

#: ../../c-api/typeobj.rst:1995
msgid ""
"An optional pointer to an instance deallocation function.  Its signature "
"is::"
msgstr "인스턴스 할당 해제 함수에 대한 선택적 포인터. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:1997
msgid "void tp_free(void *self);"
msgstr ""

#: ../../c-api/typeobj.rst:1999
msgid ""
"An initializer that is compatible with this signature is "
":c:func:`PyObject_Free`."
msgstr "이 서명과 호환되는 초기화자는 :c:func:`PyObject_Free`\\입니다."

#: ../../c-api/typeobj.rst:2003
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr "이 필드는 정적 서브 형에 의해 상속되지만, 동적 서브 형(클래스 문으로 만들어진 서브 형)에는 상속되지 않습니다."

#: ../../c-api/typeobj.rst:2008
#, fuzzy
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match"
" :c:func:`PyType_GenericAlloc` and the value of the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""
"동적 서브 형에서, 이 필드는 :c:func:`PyType_GenericAlloc`\\과 "
":const:`Py_TPFLAGS_HAVE_GC` 플래그 비트의 값과 일치하기에 적합한 할당 해제기로 설정됩니다."

#: ../../c-api/typeobj.rst:2012
#, fuzzy
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses "
":c:func:`PyObject_Del`."
msgstr "정적 서브 형의 경우, :c:type:`PyBaseObject_Type`\\은 PyObject_Del을 사용합니다."

#: ../../c-api/typeobj.rst:2017
msgid "An optional pointer to a function called by the garbage collector."
msgstr "가비지 수집기에서 호출되는 함수에 대한 선택적 포인터."

#: ../../c-api/typeobj.rst:2019
#, fuzzy
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the "
":c:macro:`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of"
" statically and dynamically allocated instances, and the statically "
"allocated instances are not collectible.  Such types should define this "
"function; it should return ``1`` for a collectible instance, and ``0`` "
"for a non-collectible instance. The signature is::"
msgstr ""
"가비지 수집기는 특정 객체가 수집 가능한지를 알아야 합니다. 일반적으로, 객체 형의 "
":c:member:`~PyTypeObject.tp_flags` 필드를 보고, :const:`Py_TPFLAGS_HAVE_GC` "
"플래그 비트를 확인하면 충분합니다. 그러나 일부 형에는 정적과 동적으로 할당된 인스턴스가 혼합되어 있으며, 정적으로 할당된 "
"인스턴스는 수집할 수 없습니다. 이러한 형은 이 함수를 정의해야 합니다; 수집 가능한 인스턴스이면 ``1``\\을, 수집 불가능한 "
"인스턴스이면 ``0``\\을 반환해야 합니다. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:2027
msgid "int tp_is_gc(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:2029
#, fuzzy
msgid ""
"(The only example of this are types themselves.  The metatype, "
":c:data:`PyType_Type`, defines this function to distinguish between "
"statically and :ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(이것의 유일한 예는 형 자체입니다. 메타 형, :c:data:`PyType_Type`\\은 이 함수를 정의하여 정적으로 할당된 "
"형과 동적으로 할당된 형을 구별합니다.)"

#: ../../c-api/typeobj.rst:2039
#, fuzzy
msgid ""
"This slot has no default.  If this field is ``NULL``, "
":c:macro:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"이 슬롯에는 기본값이 없습니다. 이 필드가 ``NULL``\\이면, :const:`Py_TPFLAGS_HAVE_GC`\\가 기능적 "
"동등물로 사용됩니다."

#: ../../c-api/typeobj.rst:2045
msgid "Tuple of base types."
msgstr "베이스형의 튜플."

#: ../../c-api/typeobj.rst:2047 ../../c-api/typeobj.rst:2071
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python "
"will fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""

#: ../../c-api/typeobj.rst:2050
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of "
":c:func:`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""

#: ../../c-api/typeobj.rst:2057
msgid ""
"Multiple inheritance does not work well for statically defined types. If "
"you set ``tp_bases`` to a tuple, Python will not raise an error, but some"
" slots will only be inherited from the first base."
msgstr ""

#: ../../c-api/typeobj.rst:2063 ../../c-api/typeobj.rst:2086
#: ../../c-api/typeobj.rst:2103 ../../c-api/typeobj.rst:2120
#: ../../c-api/typeobj.rst:2134
msgid "This field is not inherited."
msgstr "이 필드는 상속되지 않습니다."

#: ../../c-api/typeobj.rst:2068
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr "형 자체에서 시작하여 :class:`object`\\로 끝나는 확장된 베이스형 집합을 포함하는 튜플."

#: ../../c-api/typeobj.rst:2076
msgid ""
"This field is not inherited; it is calculated fresh by "
":c:func:`PyType_Ready`."
msgstr "이 필드는 상속되지 않습니다; :c:func:`PyType_Ready`\\에 의해 새로 계산됩니다."

#: ../../c-api/typeobj.rst:2082
msgid "Unused.  Internal use only."
msgstr "사용되지 않습니다. 내부 전용."

#: ../../c-api/typeobj.rst:2091
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid "
"pointer."
msgstr ""

#: ../../c-api/typeobj.rst:2093
msgid ""
"To get a list of subclasses, call the Python method "
":py:meth:`~type.__subclasses__`."
msgstr ""

#: ../../c-api/typeobj.rst:2098
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The"
" type was changed to :c:expr:`void*` to indicate this."
msgstr ""

#: ../../c-api/typeobj.rst:2108
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr "이 형 객체에 대한 약한 참조를 위한 약한 참조 리스트 헤드. 상속되지 않습니다. 내부 전용."

#: ../../c-api/typeobj.rst:2113
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, "
"even if weakrefs are added.  Instead, the weakrefs for each are stored on"
" ``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""

#: ../../c-api/typeobj.rst:2125
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` "
"instead."
msgstr "이 필드는 폐지되었습니다. 대신 :c:member:`~PyTypeObject.tp_finalize`\\를 사용하십시오."

#: ../../c-api/typeobj.rst:2130
msgid "Used to index into the method cache.  Internal use only."
msgstr "메서드 캐시에 인덱싱하는 데 사용됩니다. 내부 전용."

#: ../../c-api/typeobj.rst:2139
msgid ""
"An optional pointer to an instance finalization function.  Its signature "
"is::"
msgstr "인스턴스 파이널리제이션 함수에 대한 선택적 포인터. 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:2141
msgid "void tp_finalize(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:2143
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it"
" once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or "
"just before the object is deallocated.  Either way, it is guaranteed to "
"be called before attempting to break reference cycles, ensuring that it "
"finds the object in a sane state."
msgstr ""
":c:member:`~PyTypeObject.tp_finalize`\\가 설정되면, 인터프리터는 인스턴스를 파이널라이즈 할 때 이를"
" 한 번 호출합니다. 가비지 수집기(인스턴스가 격리된 참조 순환의 일부인 경우)나 객체가 할당 해제되기 직전에 호출됩니다. 어느 "
"쪽이든, 참조 순환을 끊기 전에 호출되어 정상 상태에 있는 객체를 보도록 보장합니다."

#: ../../c-api/typeobj.rst:2150
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize`\\는 현재 예외 상태를 변경하지 않아야 합니다; 따라서 사소하지"
" 않은 파이널라이저를 작성하는 권장 방법은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:2153
#, python-brace-format
msgid ""
"static void\n"
"local_finalize(PyObject *self)\n"
"{\n"
"    /* Save the current exception, if any. */\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    /* ... */\n"
"\n"
"    /* Restore the saved exception. */\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""

#: ../../c-api/typeobj.rst:2173
msgid ""
"Before version 3.8 it was necessary to set the "
":c:macro:`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to "
"be used.  This is no longer required."
msgstr ""

#: ../../c-api/typeobj.rst:2177
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"안전한 객체 파이널리제이션\" (:pep:`442`)"

#: ../../c-api/typeobj.rst:2182
#, fuzzy
msgid ""
"Vectorcall function to use for calls of this type object. In other words,"
" it is used to implement :ref:`vectorcall <vectorcall>` for "
"``type.__call__``. If ``tp_vectorcall`` is ``NULL``, the default call "
"implementation using :meth:`~object.__new__` and :meth:`~object.__init__`"
" is used."
msgstr ""
"이 형 객체의 호출에 사용하는 벡터콜 함수. 즉, ``type.__call__``\\을 위한 :ref:`벡터콜 "
"<vectorcall>`\\을 구현하는 데 사용됩니다. ``tp_vectorcall``\\이 ``NULL``\\이면, "
":attr:`__new__`\\와 :attr:`__init__`\\를 사용하는 기본 호출 구현이 사용됩니다."

#: ../../c-api/typeobj.rst:2190
msgid "This field is never inherited."
msgstr "이 필드는 상속되지 않습니다."

#: ../../c-api/typeobj.rst:2192
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(필드는 3.8부터 존재하지만 3.9부터 사용됩니다)"

#: ../../c-api/typeobj.rst:2197
msgid "Internal. Do not use."
msgstr ""

#: ../../c-api/typeobj.rst:2205
#, fuzzy
msgid "Static Types"
msgstr "기본 정적 형::"

#: ../../c-api/typeobj.rst:2207
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static "
":c:type:`PyTypeObject` structure is defined directly in code and "
"initialized using :c:func:`PyType_Ready`."
msgstr ""
"전통적으로, C 코드에서 정의된 형은 *정적(static)*\\입니다. 즉 정적 :c:type:`PyTypeObject` 구조체는 "
"코드에서 직접 정의되고 :c:func:`PyType_Ready`\\를 사용하여 초기화됩니다."

#: ../../c-api/typeobj.rst:2211
msgid ""
"This results in types that are limited relative to types defined in "
"Python:"
msgstr "결과적으로 파이썬에서 정의된 형에 비해 형이 제한됩니다:"

#: ../../c-api/typeobj.rst:2213
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr "정적 형은 하나의 베이스로 제한됩니다. 즉, 다중 상속을 사용할 수 없습니다."

#: ../../c-api/typeobj.rst:2215
msgid ""
"Static type objects (but not necessarily their instances) are immutable. "
"It is not possible to add or modify the type object's attributes from "
"Python."
msgstr "정적 형 객체(그러나 이들의 인스턴스는 아닙니다)는 불변입니다. 파이썬에서 형 객체의 어트리뷰트를 추가하거나 수정할 수 없습니다."

#: ../../c-api/typeobj.rst:2217
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"정적 형 객체는 :ref:`서브 인터프리터 <sub-interpreter-support>`\\에서 공유되므로, 서브 인터프리터 관련"
" 상태를 포함하지 않아야 합니다."

#: ../../c-api/typeobj.rst:2221
#, fuzzy
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"또한, :c:type:`PyTypeObject`\\는 :ref:`안정 ABI <stable>`\\의 일부가 아니므로, 정적 형을 "
"사용하는 확장 모듈은 특정 파이썬 부 버전(minir version)에 맞게 컴파일해야 합니다."

#: ../../c-api/typeobj.rst:2229
msgid "Heap Types"
msgstr "힙 형"

#: ../../c-api/typeobj.rst:2231
#, fuzzy
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the "
":c:macro:`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"정적 형에 대한 대안은 *힙 할당된 형(heap-allocated types)*, 또는 짧게 *힙 형(heap types)*, 인데"
" 이는 파이썬의 ``class`` 문으로 작성된 클래스와 밀접한 관련이 있습니다."

#: ../../c-api/typeobj.rst:2236
#, fuzzy
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling "
":c:func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, "
":c:func:`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""
":c:type:`PyType_Spec` 구조체를 채우고 :c:func:`PyType_FromSpecWithBases`\\를 호출하면"
" 됩니다."

#: ../../c-api/typeobj.rst:2244
msgid "Number Object Structures"
msgstr "숫자 객체 구조체"

#: ../../c-api/typeobj.rst:2251
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"이 구조체는 객체가 숫자 프로토콜을 구현하는 데 사용하는 함수에 대한 포인터를 담습니다. 각 함수는 :ref:`number` "
"섹션에서 설명하는 유사한 이름의 함수가 사용합니다."

#: ../../c-api/typeobj.rst:2257 ../../c-api/typeobj.rst:2581
msgid "Here is the structure definition::"
msgstr "구조체 정의는 다음과 같습니다::"

#: ../../c-api/typeobj.rst:2259
#, python-brace-format
msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""

#: ../../c-api/typeobj.rst:2304
msgid ""
"Binary and ternary functions must check the type of all their operands, "
"and implement the necessary conversions (at least one of the operands is "
"an instance of the defined type).  If the operation is not defined for "
"the given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return "
"``NULL`` and set an exception."
msgstr ""
"이항과 삼항 함수는 모든 피연산자의 형을 확인하고, 필요한 변환을 구현해야합니다 (적어도 피연산자 중 하나는 정의된 형의 "
"인스턴스입니다). 주어진 피연산자에 대해 연산이 정의되지 않으면, 이항과 삼항 함수는 ``Py_NotImplemented``\\를 "
"반환해야하며, 다른 에러가 발생하면 ``NULL``\\을 반환하고 예외를 설정해야 합니다."

#: ../../c-api/typeobj.rst:2313
#, fuzzy
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed"
" in Python 3.0.1."
msgstr ""
":c:data:`nb_reserved` 필드는 항상 ``NULL``\\이어야 합니다. 이전에는 "
":c:data:`nb_long`\\라고 했으며, 파이썬 3.0.1에서 이름이 바뀌었습니다."

#: ../../c-api/typeobj.rst:2358
msgid "Mapping Object Structures"
msgstr "매핑 객체 구조체"

#: ../../c-api/typeobj.rst:2365
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr "이 구조체에는 객체가 매핑 프로토콜을 구현하는 데 사용하는 함수에 대한 포인터를 담습니다. 세 개의 멤버가 있습니다:"

#: ../../c-api/typeobj.rst:2370
msgid ""
"This function is used by :c:func:`PyMapping_Size` and "
":c:func:`PyObject_Size`, and has the same signature.  This slot may be "
"set to ``NULL`` if the object has no defined length."
msgstr ""
"이 함수는 :c:func:`PyMapping_Size`\\와 :c:func:`PyObject_Size`\\에서 사용되며, 같은 "
"서명을 갖습니다. 객체에 길이가 정의되어 있지 않으면 이 슬롯을 ``NULL``\\로 설정할 수 있습니다."

#: ../../c-api/typeobj.rst:2376
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and "
":c:func:`PySequence_GetSlice`, and has the same signature as "
":c:func:`!PyObject_GetItem`.  This slot must be filled for the "
":c:func:`PyMapping_Check` function to return ``1``, it can be ``NULL`` "
"otherwise."
msgstr ""
"이 함수는 :c:func:`PyObject_GetItem`\\과 :c:func:`PySequence_GetSlice`\\에서 "
"사용되며, :c:func:`!PyObject_GetItem`\\과 같은 서명을 갖습니다. "
":c:func:`PyMapping_Check` 함수가 ``1``\\을 반환하려면, 이 슬롯을 채워야합니다, 그렇지 않으면 "
"``NULL``\\일 수 있습니다."

#: ../../c-api/typeobj.rst:2384
#, fuzzy
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, "
":c:func:`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and "
":c:func:`PySequence_DelSlice`.  It has the same signature as "
":c:func:`!PyObject_SetItem`, but *v* can also be set to ``NULL`` to "
"delete an item.  If this slot is ``NULL``, the object does not support "
"item assignment and deletion."
msgstr ""
"이 함수는 :c:func:`PyObject_SetItem`, :c:func:`PyObject_DelItem`, "
":c:func:`PyObject_SetSlice` 및 :c:func:`PyObject_DelSlice`\\에서 사용됩니다. "
":c:func:`!PyObject_SetItem`\\과 같은 서명을 갖지만, *v*\\를 ``NULL``\\로 설정하여 항목을 "
"삭제할 수도 있습니다. 이 슬롯이 ``NULL``\\이면, 객체는 항목 대입과 삭제를 지원하지 않습니다."

#: ../../c-api/typeobj.rst:2395
msgid "Sequence Object Structures"
msgstr "시퀀스 객체 구조체"

#: ../../c-api/typeobj.rst:2402
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr "이 구조체는 객체가 시퀀스 프로토콜을 구현하는 데 사용하는 함수에 대한 포인터를 담습니다."

#: ../../c-api/typeobj.rst:2407
msgid ""
"This function is used by :c:func:`PySequence_Size` and "
":c:func:`PyObject_Size`, and has the same signature.  It is also used for"
" handling negative indices via the :c:member:`~PySequenceMethods.sq_item`"
" and the :c:member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"이 함수는 :c:func:`PySequence_Size`\\와 :c:func:`PyObject_Size`\\에서 사용되며, 같은 "
"서명을 갖습니다. 또한 :c:member:`~PySequenceMethods.sq_item`\\과 "
":c:member:`~PySequenceMethods.sq_ass_item` 슬롯을 통해 음수 인덱스를 처리하는 데 사용됩니다."

#: ../../c-api/typeobj.rst:2414
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the "
"numeric addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"이 함수는 :c:func:`PySequence_Concat`\\에서 사용되며 같은 서명을 갖습니다. "
":c:member:`~PyNumberMethods.nb_add` 슬롯을 통해 숫자 덧셈을 시도한 후, ``+`` 연산자에서도 "
"사용됩니다."

#: ../../c-api/typeobj.rst:2420
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"이 함수는 :c:func:`PySequence_Repeat`\\에서 사용되며 같은 서명을 갖습니다. "
":c:member:`~PyNumberMethods.nb_multiply` 슬롯을 통해 숫자 곱셈을 시도한 후, ``*`` "
"연산자에서도 사용됩니다."

#: ../../c-api/typeobj.rst:2426
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying "
"the subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot."
" This slot must be filled for the :c:func:`PySequence_Check` function to "
"return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"이 함수는 :c:func:`PySequence_GetItem`\\에서 사용되며 같은 서명을 갖습니다. "
":c:member:`~PyMappingMethods.mp_subscript` 슬롯을 통해 서브스크립션(subscription)을 "
"시도한 후, :c:func:`PyObject_GetItem`\\에서도 사용됩니다. :c:func:`PySequence_Check` "
"함수가 ``1``\\을 반환하려면, 이 슬롯을 채워야합니다, 그렇지 않으면 ``NULL``\\일 수 있습니다."

#: ../../c-api/typeobj.rst:2432
#, fuzzy
msgid ""
"Negative indexes are handled as follows: if the "
":c:member:`~PySequenceMethods.sq_length` slot is filled, it is called and"
" the sequence length is used to compute a positive index which is passed "
"to  :c:member:`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is"
" ``NULL``, the index is passed as is to the function."
msgstr ""
"음의 인덱스는 다음과 같이 처리됩니다: :attr:`sq_length` 슬롯이 채워지면, 이를 호출하고 시퀀스 길이를 사용하여 "
":attr:`sq_item`\\에 전달되는 양의 인덱스를 계산합니다. :attr:`sq_length`\\가 ``NULL``\\이면,"
" 인덱스는 그대로 함수에 전달됩니다."

#: ../../c-api/typeobj.rst:2439
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and "
":c:func:`PyObject_DelItem`, after trying the item assignment and deletion"
" via the :c:member:`~PyMappingMethods.mp_ass_subscript` slot. This slot "
"may be left to ``NULL`` if the object does not support item assignment "
"and deletion."
msgstr ""
"이 함수는 :c:func:`PySequence_SetItem`\\에서 사용되며 같은 서명을 갖습니다. "
":c:member:`~PyMappingMethods.mp_ass_subscript` 슬롯을 통해 항목 대입과 삭제를 시도한 후, "
":c:func:`PyObject_SetItem`\\과 :c:func:`PyObject_DelItem`\\에서도 사용됩니다. 객체가 "
"항목 대입과 삭제를 지원하지 않으면 이 슬롯은 ``NULL``\\로 남겨 둘 수 있습니다."

#: ../../c-api/typeobj.rst:2448
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the "
"same signature.  This slot may be left to ``NULL``, in this case "
":c:func:`!PySequence_Contains` simply traverses the sequence until it "
"finds a match."
msgstr ""
"이 함수는 :c:func:`PySequence_Contains`\\에서 사용될 수 있으며 같은 서명을 갖습니다. 이 슬롯은 "
"``NULL``\\로 남겨 둘 수 있습니다, 이때 :c:func:`!PySequence_Contains`\\는 일치하는 것을 찾을 "
"때까지 시퀀스를 단순히 탐색합니다."

#: ../../c-api/typeobj.rst:2455
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the "
"same signature.  It should modify its first operand, and return it.  This"
" slot may be left to ``NULL``, in this case "
":c:func:`!PySequence_InPlaceConcat` will fall back to "
":c:func:`PySequence_Concat`.  It is also used by the augmented assignment"
" ``+=``, after trying numeric in-place addition via the "
":c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"이 함수는 :c:func:`PySequence_InPlaceConcat`\\에서 사용되며 같은 서명을 갖습니다. 첫 번째 피연산자를"
" 수정하고 그것을 반환해야 합니다. 이 슬롯은 ``NULL``\\로 남겨 둘 수 있으며, 이때 "
":c:func:`!PySequence_InPlaceConcat`\\은 :c:func:`PySequence_Concat`\\으로 폴백"
" 됩니다. :c:member:`~PyNumberMethods.nb_inplace_add` 슬롯을 통해 숫자 제자리 덧셈을 시도한 "
"후, 증분 대입 ``+=``\\에서 사용됩니다."

#: ../../c-api/typeobj.rst:2464
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the "
"same signature.  It should modify its first operand, and return it.  This"
" slot may be left to ``NULL``, in this case "
":c:func:`!PySequence_InPlaceRepeat` will fall back to "
":c:func:`PySequence_Repeat`.  It is also used by the augmented assignment"
" ``*=``, after trying numeric in-place multiplication via the "
":c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"이 함수는 :c:func:`PySequence_InPlaceRepeat`\\에서 사용되며 같은 서명을 갖습니다. 첫 번째 피연산자를"
" 수정하고 그것을 반환해야 합니다. 이 슬롯은 ``NULL``\\로 남겨 둘 수 있으며, 이때 "
":c:func:`!PySequence_InPlaceRepeat`\\는 :c:func:`PySequence_Repeat`\\로 폴백 "
"됩니다. :c:member:`~PyNumberMethods.nb_inplace_multiply` 슬롯을 통해 숫자 제자리 곱셈을 "
"시도한 후, 증분 대입 ``*=``\\에서도 사용됩니다."

#: ../../c-api/typeobj.rst:2475
msgid "Buffer Object Structures"
msgstr "버퍼 객체 구조체"

#: ../../c-api/typeobj.rst:2483
msgid ""
"This structure holds pointers to the functions required by the "
":ref:`Buffer protocol <bufferobjects>`. The protocol defines how an "
"exporter object can expose its internal data to consumer objects."
msgstr ""
"이 구조체는 :ref:`버퍼 프로토콜 <bufferobjects>`\\에 필요한 함수에 대한 포인터를 담습니다. 프로토콜은 "
"제공자(exporter) 객체가 내부 데이터를 소비자 객체에 노출하는 방법을 정의합니다."

#: ../../c-api/typeobj.rst:2489 ../../c-api/typeobj.rst:2538
#: ../../c-api/typeobj.rst:2592 ../../c-api/typeobj.rst:2603
#: ../../c-api/typeobj.rst:2615 ../../c-api/typeobj.rst:2625
msgid "The signature of this function is::"
msgstr "이 함수의 서명은 다음과 같습니다::"

#: ../../c-api/typeobj.rst:2491
msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr ""

#: ../../c-api/typeobj.rst:2493
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*."
" Except for point (3), an implementation of this function MUST take these"
" steps:"
msgstr ""
"*view*\\를 채우기 위해 *exporter*\\에 대한 *flags*\\에 지정된 요청을 처리합니다. 포인트 (3) 을 "
"제외하고, 이 함수의 구현은 다음 단계를 반드시 수행해야 합니다:"

#: ../../c-api/typeobj.rst:2497
#, fuzzy
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set "
":c:expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"요청을 충족할 수 있는지 확인합니다. 그렇지 않으면, :c:data:`PyExc_BufferError`\\를 발생시키고 "
":c:data:`view->obj`\\를 ``NULL``\\로 설정하고 ``-1``\\을 반환합니다."

#: ../../c-api/typeobj.rst:2500
msgid "Fill in the requested fields."
msgstr "요청된 필드를 채웁니다."

#: ../../c-api/typeobj.rst:2502
msgid "Increment an internal counter for the number of exports."
msgstr "내보내기 횟수에 대한 내부 카운터를 증가시킵니다."

#: ../../c-api/typeobj.rst:2504
#, fuzzy
msgid "Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ":c:data:`view->obj`\\를 *exporter*\\로 설정하고 :c:data:`view->obj`\\를 증가시킵니다."

#: ../../c-api/typeobj.rst:2506
msgid "Return ``0``."
msgstr "``0``\\을 반환합니다."

#: ../../c-api/typeobj.rst:2508
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr "*exporter*\\가 버퍼 공급자의 체인이나 트리의 일부이면, 두 가지 주요 체계를 사용할 수 있습니다:"

#: ../../c-api/typeobj.rst:2511
#, fuzzy
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets "
":c:expr:`view->obj` to a new reference to itself."
msgstr ""
"다시 내보내기: 트리의 각 구성원은 제공자 객체의 역할을 하며 :c:data:`view->obj`\\를 자신에 대한 새로운 참조로 "
"설정합니다."

#: ../../c-api/typeobj.rst:2514
#, fuzzy
msgid ""
"Redirect: The buffer request is redirected to the root object of the "
"tree. Here, :c:expr:`view->obj` will be a new reference to the root "
"object."
msgstr ""
"리디렉션: 버퍼 요청이 트리의 루트 객체로 리디렉션됩니다. 여기서, :c:data:`view->obj`\\는 루트 객체에 대한 "
"새로운 참조가 됩니다."

#: ../../c-api/typeobj.rst:2518
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-"
"request-types>`."
msgstr ""
"*view*\\의 개별 필드는 섹션 :ref:`버퍼 구조체 <buffer-structure>`\\에 설명되어 있으며, 제공자가 특정"
" 요청에 응답해야 하는 규칙은 섹션 :ref:`버퍼 요청 유형 <buffer-request-types>`\\에 있습니다."

#: ../../c-api/typeobj.rst:2523
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the"
" exporter and must remain valid until there are no consumers left. "
":c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, "
":c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` and "
":c:member:`~Py_buffer.internal` are read-only for the consumer."
msgstr ""
":c:type:`Py_buffer` 구조체에서 가리키는 모든 메모리는 제공자에게 속하며 남은 소비자가 없어질 때까지 유효해야 "
"합니다. :c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, "
":c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` 및 "
":c:member:`~Py_buffer.internal`\\은 소비자에게는 읽기 전용입니다."

#: ../../c-api/typeobj.rst:2530
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple "
"bytes buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo`\\는 모든 요청 유형을 올바르게 처리하면서 간단한 바이트열 버퍼를 쉽게 노출 할 "
"수 있는 방법을 제공합니다."

#: ../../c-api/typeobj.rst:2533
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps"
" this function."
msgstr ":c:func:`PyObject_GetBuffer`\\는 이 함수를 감싸는 소비자 용 인터페이스입니다."

#: ../../c-api/typeobj.rst:2540
msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr ""

#: ../../c-api/typeobj.rst:2542
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take"
" these optional steps:"
msgstr ""
"버퍼 자원 해제 요청을 처리합니다. 자원을 해제할 필요가 없으면, "
":c:member:`PyBufferProcs.bf_releasebuffer`\\는 ``NULL``\\일 수 있습니다. 그렇지 "
"않으면, 이 함수의 표준 구현은 다음과 같은 선택적 단계를 수행합니다:"

#: ../../c-api/typeobj.rst:2547
msgid "Decrement an internal counter for the number of exports."
msgstr "내보내기 횟수에 대한 내부 카운터를 줄입니다."

#: ../../c-api/typeobj.rst:2549
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "카운터가 ``0``\\이면, *view*\\와 관련된 모든 메모리를 해제합니다."

#: ../../c-api/typeobj.rst:2551
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"제공자는 반드시 :c:member:`~Py_buffer.internal` 필드를 사용하여 버퍼 특정 자원을 추적해야 합니다. 이 "
"필드는 변경되지 않고 유지됨이 보장되지만, 소비자는 원래 버퍼의 사본을 *view* 인자로 전달할 수 있습니다."

#: ../../c-api/typeobj.rst:2557
#, fuzzy
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"이 함수는 :c:func:`PyBuffer_Release`\\에서 자동으로 수행되므로 :c:data:`view->obj`\\를 절대"
" 감소시키지 않아야 합니다 (이 체계는 참조 순환을 끊는 데 유용합니다)."

#: ../../c-api/typeobj.rst:2562
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps "
"this function."
msgstr ":c:func:`PyBuffer_Release`\\는 이 기능을 감싸는 소비자 용 인터페이스입니다."

#: ../../c-api/typeobj.rst:2570
msgid "Async Object Structures"
msgstr "비동기 객체 구조체"

#: ../../c-api/typeobj.rst:2578
msgid ""
"This structure holds pointers to the functions required to implement "
":term:`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"이 구조체는 :term:`어웨이터블 <awaitable>`\\와 :term:`비동기 이터레이터 <asynchronous "
"iterator>` 객체를 구현하는 데 필요한 함수에 대한 포인터를 담습니다."

#: ../../c-api/typeobj.rst:2583
#, python-brace-format
msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""

#: ../../c-api/typeobj.rst:2594
msgid "PyObject *am_await(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:2596
#, fuzzy
msgid ""
"The returned object must be an :term:`iterator`, i.e. "
":c:func:`PyIter_Check` must return ``1`` for it."
msgstr ""
"반환된 객체는 이터레이터여야 합니다, 즉, :c:func:`PyIter_Check`\\는 반환된 객체에 대해 ``1``\\을 "
"반환해야 합니다."

#: ../../c-api/typeobj.rst:2599
msgid "This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr "객체가 :term:`어웨이터블 <awaitable>`\\이 아니면 이 슬롯을 ``NULL``\\로 설정할 수 있습니다."

#: ../../c-api/typeobj.rst:2605
msgid "PyObject *am_aiter(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:2607
#, fuzzy
msgid ""
"Must return an :term:`asynchronous iterator` object. See "
":meth:`~object.__anext__` for details."
msgstr ""
":term:`어웨이터블 <awaitable>` 객체를 반환해야 합니다. 자세한 내용은 :meth:`__anext__`\\를 "
"참조하십시오."

#: ../../c-api/typeobj.rst:2610
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr "객체가 비동기 이터레이션 프로토콜을 구현하지 않으면 이 슬롯은 ``NULL``\\로 설정될 수 있습니다."

#: ../../c-api/typeobj.rst:2617
msgid "PyObject *am_anext(PyObject *self);"
msgstr ""

#: ../../c-api/typeobj.rst:2619
#, fuzzy
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` "
"for details. This slot may be set to ``NULL``."
msgstr ""
":term:`어웨이터블 <awaitable>` 객체를 반환해야 합니다. 자세한 내용은 :meth:`__anext__`\\를 "
"참조하십시오. 이 슬롯은 ``NULL``\\로 설정될 수 있습니다."

#: ../../c-api/typeobj.rst:2627
msgid "PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""

#: ../../c-api/typeobj.rst:2629
#, fuzzy
msgid "See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
":term:`어웨이터블 <awaitable>` 객체를 반환해야 합니다. 자세한 내용은 :meth:`__anext__`\\를 "
"참조하십시오. 이 슬롯은 ``NULL``\\로 설정될 수 있습니다."

#: ../../c-api/typeobj.rst:2638
msgid "Slot Type typedefs"
msgstr "슬롯 형 typedef"

#: ../../c-api/typeobj.rst:2642
#, fuzzy
msgid ""
"The purpose of this function is to separate memory allocation from memory"
" initialization.  It should return a pointer to a block of memory of "
"adequate length for the instance, suitably aligned, and initialized to "
"zeros, but with :c:member:`~PyObject.ob_refcnt` set to ``1`` and "
":c:member:`~PyObject.ob_type` set to the type argument.  If the type's "
":c:member:`~PyTypeObject.tp_itemsize` is non-zero, the object's "
":c:member:`~PyVarObject.ob_size` field should be initialized to *nitems* "
"and the length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be "
":c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"이 함수의 목적은 메모리 초기화에서 메모리 할당을 분리하는 것입니다. 인스턴스에 적합한 길이의, 적절하게 정렬되고, 0으로 "
"초기화되지만, :attr:`ob_refcnt`\\는 ``1``\\로 설정되고 :attr:`ob_type`\\은 형 인자로 설정된 "
"메모리 블록에 대한 포인터를 반환해야 합니다. 형의 :c:member:`~PyTypeObject.tp_itemsize`\\가 0이 "
"아니면, 객체의 :attr:`ob_size` 필드는 *nitems*\\로 초기화되고 할당된 메모리 블록의 길이는 "
"``tp_basicsize + nitems*tp_itemsize`` 여야 하는데, ``sizeof(void*)``\\의 배수로 자리"
" 올림 되어야 합니다; 그렇지 않으면 *nitems*\\가 사용되지 않으며 블록의 길이는 "
":c:member:`~PyTypeObject.tp_basicsize` 여야 합니다."

#: ../../c-api/typeobj.rst:2652
msgid ""
"This function should not do any other instance initialization, not even "
"to allocate additional memory; that should be done by "
":c:member:`~PyTypeObject.tp_new`."
msgstr ""
"이 함수는 다른 인스턴스 초기화를 수행하지 않아야 합니다, 추가 메모리를 할당도 안 됩니다; 그것은 "
":c:member:`~PyTypeObject.tp_new`\\에 의해 수행되어야 합니다."

#: ../../c-api/typeobj.rst:2659
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr ":c:member:`~PyTypeObject.tp_free`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2663
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr ":c:member:`~PyTypeObject.tp_new`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2667
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr ":c:member:`~PyTypeObject.tp_init`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2671
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr ":c:member:`~PyTypeObject.tp_repr`\\을 참조하십시오."

#: ../../c-api/typeobj.rst:2675 ../../c-api/typeobj.rst:2684
msgid "Return the value of the named attribute for the object."
msgstr "객체의 명명된 어트리뷰트 값을 반환합니다."

#: ../../c-api/typeobj.rst:2679 ../../c-api/typeobj.rst:2690
msgid ""
"Set the value of the named attribute for the object. The value argument "
"is set to ``NULL`` to delete the attribute."
msgstr "객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면 value 인자가 ``NULL``\\로 설정됩니다."

#: ../../c-api/typeobj.rst:2686
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr ":c:member:`~PyTypeObject.tp_getattro`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2693
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr ":c:member:`~PyTypeObject.tp_setattro`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2697
#, fuzzy
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr ":c:member:`~PyTypeObject.tp_descrget`\\을 참조하십시오."

#: ../../c-api/typeobj.rst:2701
#, fuzzy
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr ":c:member:`~PyTypeObject.tp_descrset`\\을 참조하십시오."

#: ../../c-api/typeobj.rst:2705
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr ":c:member:`~PyTypeObject.tp_hash`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2709
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr ":c:member:`~PyTypeObject.tp_richcompare`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2713
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr ":c:member:`~PyTypeObject.tp_iter`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2717
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr ":c:member:`~PyTypeObject.tp_iternext`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2731
#, fuzzy
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:2747
msgid "Examples"
msgstr "예"

#: ../../c-api/typeobj.rst:2749
msgid ""
"The following are simple examples of Python type definitions.  They "
"include common usage you may encounter.  Some demonstrate tricky corner "
"cases.  For more examples, practical info, and a tutorial, see :ref"
":`defining-new-types` and :ref:`new-types-topics`."
msgstr ""
"다음은 파이썬 형 정의의 간단한 예입니다. 여기에는 여러분이 만날 수 있는 일반적인 사용법이 포함됩니다. 일부는 까다로운 코너 "
"사례를 보여줍니다. 더 많은 예제, 실용 정보 및 자습서는 :ref:`defining-new-types`\\와 :ref:`new-"
"types-topics`\\를 참조하십시오."

#: ../../c-api/typeobj.rst:2754
#, fuzzy
msgid "A basic :ref:`static type <static-types>`::"
msgstr "기본 정적 형::"

#: ../../c-api/typeobj.rst:2756
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""

#: ../../c-api/typeobj.rst:2771
msgid ""
"You may also find older code (especially in the CPython code base) with a"
" more verbose initializer::"
msgstr "더 상세한 초기화자를 사용하는 이전 코드(특히 CPython 코드 베이스에서)를 찾을 수도 있습니다::"

#: ../../c-api/typeobj.rst:2774
#, python-brace-format
msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""

#: ../../c-api/typeobj.rst:2815
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "약한 참조, 인스턴스 딕셔너리 및 해싱을 지원하는 형::"

#: ../../c-api/typeobj.rst:2817
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""

#: ../../c-api/typeobj.rst:2840
#, fuzzy
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using "
":c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr "서브 클래싱 할 수 없고 인스턴스를 만들기 위해 호출할 수 없는 str 서브 클래스 (예를 들어 별도의 팩토리 함수를 사용합니다)::"

#: ../../c-api/typeobj.rst:2844
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""

#: ../../c-api/typeobj.rst:2859
#, fuzzy
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length "
"instances::"
msgstr "(고정 길이 인스턴스의) 가장 간단한 정적 형::"

#: ../../c-api/typeobj.rst:2861
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""

#: ../../c-api/typeobj.rst:2870
#, fuzzy
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr "(가변 길이 인스턴스의) 가장 간단한 정적 형::"

#: ../../c-api/typeobj.rst:2872
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""

#: ../../c-api/typeobj.rst:842 ../../c-api/typeobj.rst:907
msgid "built-in function"
msgstr ""

#: ../../c-api/typeobj.rst:842
#, fuzzy
msgid "repr"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:907
#, fuzzy
msgid "hash"
msgstr "__hash__"

#~ msgid "Type Objects"
#~ msgstr "형 객체"

#~ msgid "Py_ssize_t"
#~ msgstr "Py_ssize_t"

#~ msgid ""
#~ "A slot name in parentheses indicates "
#~ "it is (effectively) deprecated. Names in"
#~ " angle brackets should be treated as"
#~ " read-only. Names in square brackets"
#~ " are for internal use only. \"<R>\""
#~ " (as a prefix) means the field "
#~ "is required (must be non-``NULL``)."
#~ msgstr ""
#~ "괄호 안의 슬롯 이름은 슬롯이 (효과적으로) 폐지되었음을"
#~ " 나타냅니다. 화살 괄호(angle brackets) 안에 있는"
#~ " 이름은 읽기 전용으로 취급해야 합니다. 대괄호(square "
#~ "brackets) 안의 이름은 내부 전용입니다. (접두사일 "
#~ "때) \"<R>\"는 필드가 필수임을 뜻합니다 (반드시 "
#~ "``NULL``\\이 아니어야 합니다)."

#~ msgid ""
#~ "These fields are only present when "
#~ "the macro ``Py_TRACE_REFS`` is defined. "
#~ "Their initialization to ``NULL`` is "
#~ "taken care of by the "
#~ "``PyObject_HEAD_INIT`` macro.  For statically "
#~ "allocated objects, these fields always "
#~ "remain ``NULL``. For dynamically allocated "
#~ "objects, these two fields are used "
#~ "to link the object into a "
#~ "doubly-linked list of *all* live "
#~ "objects on the heap.  This could "
#~ "be used for various debugging purposes;"
#~ " currently the only use is to "
#~ "print the objects that are still "
#~ "alive at the end of a run "
#~ "when the environment variable "
#~ ":envvar:`PYTHONDUMPREFS` is set."
#~ msgstr ""
#~ "이 필드는 매크로 ``Py_TRACE_REFS``\\가 정의됐을 때만"
#~ " 존재합니다. ``NULL``\\로의 초기화는 ``PyObject_HEAD_INIT``"
#~ " 매크로에 의해 처리됩니다. 정적으로 할당된 객체의 "
#~ "경우, 이 필드는 항상 ``NULL``\\로 유지됩니다. "
#~ "동적으로 할당된 객체의 경우, 이 두 필드는 객체를"
#~ " 힙에 있는 *모든* 라이브 객체의 이중 링크 "
#~ "리스트에 연결하는 데 사용됩니다. 이것은 다양한 디버깅 "
#~ "목적으로 사용될 수 있습니다; 현재 유일한 사용은 "
#~ "환경 변수 :envvar:`PYTHONDUMPREFS` 가 설정될 때"
#~ " 실행이 끝날 때 여전히 존재하는 객체를 인쇄하는 "
#~ "것입니다."

#~ msgid "These fields are not inherited by subtypes."
#~ msgstr "이 필드는 서브 형에 의해 상속되지 않습니다."

#~ msgid ""
#~ "For a type with variable-length "
#~ "instances, the instances must have an"
#~ " :attr:`ob_size` field, and the instance"
#~ " size is :c:member:`~PyTypeObject.tp_basicsize` "
#~ "plus N times :c:member:`~PyTypeObject.tp_itemsize`,"
#~ " where N is the \"length\" of "
#~ "the object.  The value of N is "
#~ "typically stored in the instance's "
#~ ":attr:`ob_size` field.  There are exceptions:"
#~ "  for example, ints use a negative"
#~ " :attr:`ob_size` to indicate a negative "
#~ "number, and N is ``abs(ob_size)`` there."
#~ "  Also, the presence of an "
#~ ":attr:`ob_size` field in the instance "
#~ "layout doesn't mean that the instance"
#~ " structure is variable-length (for "
#~ "example, the structure for the list "
#~ "type has fixed-length instances, yet "
#~ "those instances have a meaningful "
#~ ":attr:`ob_size` field)."
#~ msgstr ""
#~ "가변 길이 인스턴스의 형의 경우, 인스턴스에는 "
#~ ":attr:`ob_size` 필드가 있어야 하며, 인스턴스 크기는 "
#~ ":c:member:`~PyTypeObject.tp_basicsize`\\에 N 곱하기 "
#~ ":c:member:`~PyTypeObject.tp_itemsize`\\를 더한 값입니다. "
#~ "여기서 N은 객체의 \"길이\" 입니다. N값은 일반적으로"
#~ " 인스턴스의 :attr:`ob_size` 필드에 저장됩니다. 예외가 "
#~ "있습니다: 예를 들어, 정수는 음수를 나타내기 위해 "
#~ "음의 :attr:`ob_size`\\를 사용하고, N은 "
#~ "``abs(ob_size)``\\입니다. 또한 인스턴스 배치에 "
#~ ":attr:`ob_size` 필드가 있다고 해서 인스턴스 구조체가 "
#~ "가변 길이라는 뜻은 아닙니다 (예를 들어, 리스트 "
#~ "형의 구조체는 고정 길이 인스턴스를 갖지만, 해당 "
#~ "인스턴스에는 의미 있는 :attr:`ob_size` 필드가 있습니다)."

#~ msgid ""
#~ "The basic size includes the fields "
#~ "in the instance declared by the "
#~ "macro :c:macro:`PyObject_HEAD` or "
#~ ":c:macro:`PyObject_VAR_HEAD` (whichever is used "
#~ "to declare the instance struct) and "
#~ "this in turn includes the "
#~ ":attr:`_ob_prev` and :attr:`_ob_next` fields "
#~ "if they are present.  This means "
#~ "that the only correct way to get"
#~ " an initializer for the "
#~ ":c:member:`~PyTypeObject.tp_basicsize` is to use "
#~ "the ``sizeof`` operator on the struct"
#~ " used to declare the instance layout."
#~ " The basic size does not include "
#~ "the GC header size."
#~ msgstr ""
#~ "기본 크기에는 매크로 :c:macro:`PyObject_HEAD`\\나 "
#~ ":c:macro:`PyObject_VAR_HEAD`\\(인스턴스 구조체를 선언하는 데 "
#~ "사용한 것)에 의해 선언된 인스턴스의 필드가 포함되며, "
#~ "이것은 다시 존재한다면 :attr:`_ob_prev`\\와 "
#~ ":attr:`_ob_next` 필드도 포함됩니다. 이는 "
#~ ":c:member:`~PyTypeObject.tp_basicsize`\\의 초기화자를 얻는 "
#~ "유일하게 올바른 방법은 인스턴스 배치를 선언하는 데 "
#~ "사용되는 구조체에 ``sizeof`` 연산자를 사용하는 것입니다. "
#~ "기본 크기에는 GC 헤더 크기가 포함되지 않습니다."

#~ msgid ""
#~ "A note about alignment: if the "
#~ "variable items require a particular "
#~ "alignment, this should be taken care "
#~ "of by the value of "
#~ ":c:member:`~PyTypeObject.tp_basicsize`.  Example: suppose"
#~ " a type implements an array of "
#~ "``double``. :c:member:`~PyTypeObject.tp_itemsize` is "
#~ "``sizeof(double)``. It is the programmer's "
#~ "responsibility that :c:member:`~PyTypeObject.tp_basicsize`"
#~ " is a multiple of ``sizeof(double)`` "
#~ "(assuming this is the alignment "
#~ "requirement for ``double``)."
#~ msgstr ""
#~ "정렬(alignment)에 대한 참고 사항: 가변 길이 항목에"
#~ " 특정 정렬이 필요하면, "
#~ ":c:member:`~PyTypeObject.tp_basicsize` 값에서 고려되어야 "
#~ "합니다. 예: 형이 ``double`` 배열을 구현하는 형을"
#~ " 가정합시다. :c:member:`~PyTypeObject.tp_itemsize`\\는 "
#~ "``sizeof(double)``\\입니다. "
#~ ":c:member:`~PyTypeObject.tp_basicsize`\\가 ``sizeof(double)``\\의"
#~ " 배수가 되도록 하는 것은 프로그래머의 책임입니다 "
#~ "(이것이 ``double``\\의 정렬 요구 사항이라고 가정합니다)."

#~ msgid ""
#~ "For any type with variable-length "
#~ "instances, this field must not be "
#~ "``NULL``."
#~ msgstr "가변 길이 인스턴스가 있는 모든 형의 경우, 이 필드는 ``NULL``\\이 아니어야 합니다."

#~ msgid ""
#~ "The semantics of the ``tp_vectorcall_offset``"
#~ " slot are provisional and expected to"
#~ " be finalized in Python 3.9. If "
#~ "you use vectorcall, plan for updating"
#~ " your code for Python 3.9."
#~ msgstr ""
#~ "``tp_vectorcall_offset`` 슬롯의 의미론은 잠정적이며 파이썬"
#~ " 3.9에서 완성될 것으로 예상됩니다. 벡터콜을 사용한다면, "
#~ "파이썬 3.9에서 코드를 갱신할 준비를 하십시오."

#~ msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
#~ msgstr "그룹: :attr:`tp_getattr`, :attr:`tp_getattro`"

#~ msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
#~ msgstr "그룹: :attr:`tp_setattr`, :attr:`tp_setattro`"

#~ msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
#~ msgstr "그룹: :attr:`tp_hash`, :attr:`tp_richcompare`"

#~ msgid ""
#~ "This bit is inherited for *static* "
#~ "subtypes if :c:member:`~PyTypeObject.tp_call` is "
#~ "also inherited. `Heap types`_ do not "
#~ "inherit ``Py_TPFLAGS_HAVE_VECTORCALL``."
#~ msgstr ""
#~ "이 비트는 :c:member:`~PyTypeObject.tp_call`\\도 상속되면 "
#~ "*정적(static)* 서브 유형에 대해 상속됩니다. `힙 형"
#~ " <Heap types_>`_\\은 ``Py_TPFLAGS_HAVE_VECTORCALL``\\을"
#~ " 상속하지 않습니다."

#~ msgid ":const:`Py_LT`"
#~ msgstr ":const:`Py_LT`"

#~ msgid ":const:`Py_LE`"
#~ msgstr ":const:`Py_LE`"

#~ msgid ":const:`Py_EQ`"
#~ msgstr ":const:`Py_EQ`"

#~ msgid ":const:`Py_NE`"
#~ msgstr ":const:`Py_NE`"

#~ msgid ":const:`Py_GT`"
#~ msgstr ":const:`Py_GT`"

#~ msgid ":const:`Py_GE`"
#~ msgstr ":const:`Py_GE`"

#~ msgid "The return value's reference count is properly incremented."
#~ msgstr "반환 값의 참조 횟수가 올바르게 증가합니다."

#~ msgid ""
#~ "When a type defined by a class "
#~ "statement has no :attr:`~object.__slots__` "
#~ "declaration, and none of its base "
#~ "types are weakly referenceable, the type"
#~ " is made weakly referenceable by "
#~ "adding a weak reference list head "
#~ "slot to the instance layout and "
#~ "setting the :c:member:`~PyTypeObject.tp_weaklistoffset`"
#~ " of that slot's offset."
#~ msgstr ""
#~ "클래스 문으로 정의된 형에 :attr:`~object.__slots__` "
#~ "선언이 없고, 그것의 베이스형 중 약한 참조 가능한"
#~ " 것이 없으면, 약한 참조 리스트 헤드 슬롯을 "
#~ "인스턴스 배치에 추가하고 해당 슬롯 오프셋의 "
#~ ":c:member:`~PyTypeObject.tp_weaklistoffset`\\을 설정하여 해당 "
#~ "형을 약하게 참조할 수 있게 만듭니다."

#~ msgid ""
#~ "When a type's :attr:`__slots__` declaration"
#~ " contains a slot named :attr:`__weakref__`,"
#~ " that slot becomes the weak reference"
#~ " list head for instances of the "
#~ "type, and the slot's offset is "
#~ "stored in the type's "
#~ ":c:member:`~PyTypeObject.tp_weaklistoffset`."
#~ msgstr ""
#~ "형의 :attr:`__slots__` 선언에 :attr:`__weakref__`\\라는 "
#~ "슬롯이 포함되면, 해당 슬롯은 해당 형의 인스턴스에 "
#~ "대한 약한 참조 리스트 헤드가 되고, 슬롯의 "
#~ "오프셋은 형의 :c:member:`~PyTypeObject.tp_weaklistoffset`\\에 "
#~ "저장됩니다."

#~ msgid ""
#~ "When a type's :attr:`__slots__` declaration"
#~ " does not contain a slot named "
#~ ":attr:`__weakref__`, the type inherits its "
#~ ":c:member:`~PyTypeObject.tp_weaklistoffset` from its "
#~ "base type."
#~ msgstr ""
#~ "형의 :attr:`__slots__` 선언에 :attr:`__weakref__`\\라는 "
#~ "슬롯이 없으면, 형은 베이스형에서 "
#~ ":c:member:`~PyTypeObject.tp_weaklistoffset`\\을 상속합니다."

#~ msgid ""
#~ "If the value of this field is "
#~ "greater than zero, it specifies the "
#~ "offset from the start of the "
#~ "instance structure.  If the value is "
#~ "less than zero, it specifies the "
#~ "offset from the *end* of the "
#~ "instance structure.  A negative offset "
#~ "is more expensive to use, and "
#~ "should only be used when the "
#~ "instance structure contains a variable-"
#~ "length part.  This is used for "
#~ "example to add an instance variable "
#~ "dictionary to subtypes of :class:`str` "
#~ "or :class:`tuple`. Note that the "
#~ ":c:member:`~PyTypeObject.tp_basicsize` field should "
#~ "account for the dictionary added to "
#~ "the end in that case, even though"
#~ " the dictionary is not included in"
#~ " the basic object layout.  On a "
#~ "system with a pointer size of 4"
#~ " bytes, :c:member:`~PyTypeObject.tp_dictoffset` should"
#~ " be set to ``-4`` to indicate "
#~ "that the dictionary is at the very"
#~ " end of the structure."
#~ msgstr ""
#~ "이 필드의 값이 0보다 크면, 인스턴스 구조체의 "
#~ "시작으로부터의 오프셋을 지정합니다. 값이 0보다 작으면, "
#~ "인스턴스 구조체의 *끝*\\으로부터의 오프셋을 지정합니다. 음수 "
#~ "오프셋은 사용하기네 더 비싸며, 인스턴스 구조체에 가변 "
#~ "길이 부분이 포함될 때에만 사용해야 합니다. 예를 "
#~ "들어 인스턴스 변수 딕셔너리를 :class:`str`\\이나 "
#~ ":class:`tuple`\\의 서브 형에 추가하는 데 사용됩니다."
#~ " 딕셔너리가 기본 객체 배치에 포함되어 있지 않더라도,"
#~ " :c:member:`~PyTypeObject.tp_basicsize` 필드는 이 경우"
#~ " 끝에 추가된 딕셔너리를 고려해야 함에 유의하십시오. "
#~ "포인터 크기가 4바이트인 시스템에서, 딕셔너리가 구조체의 맨"
#~ " 끝에 있음을 나타내려면 "
#~ ":c:member:`~PyTypeObject.tp_dictoffset`\\을 ``-4``\\로 설정해야"
#~ " 합니다."

#~ msgid ""
#~ "The real dictionary offset in an "
#~ "instance can be computed from a "
#~ "negative :c:member:`~PyTypeObject.tp_dictoffset` as "
#~ "follows::"
#~ msgstr ""
#~ "인스턴스의 실제 딕셔너리 오프셋은 다음과 같이 음의 "
#~ ":c:member:`~PyTypeObject.tp_dictoffset`\\으로 계산할 수 "
#~ "있습니다::"

#~ msgid ""
#~ "where :c:member:`~PyTypeObject.tp_basicsize`, "
#~ ":c:member:`~PyTypeObject.tp_itemsize` and "
#~ ":c:member:`~PyTypeObject.tp_dictoffset` are taken "
#~ "from the type object, and "
#~ ":attr:`ob_size` is taken from the "
#~ "instance.  The absolute value is taken"
#~ " because ints use the sign of "
#~ ":attr:`ob_size` to store the sign of "
#~ "the number.  (There's never a need "
#~ "to do this calculation yourself; it "
#~ "is done for you by "
#~ ":c:func:`_PyObject_GetDictPtr`.)"
#~ msgstr ""
#~ "여기서 :c:member:`~PyTypeObject.tp_basicsize`, "
#~ ":c:member:`~PyTypeObject.tp_itemsize` 및 "
#~ ":c:member:`~PyTypeObject.tp_dictoffset`\\은 형 객체에서 "
#~ "취하고, :attr:`ob_size`\\는 인스턴스에서 취합니다. 정수는 "
#~ ":attr:`ob_size`\\의 부호를 사용하여 숫자의 부호를 "
#~ "저장하므로 절댓값이 사용됩니다. (이 계산을 직접 수행할"
#~ " 필요는 없습니다; :c:func:`_PyObject_GetDictPtr`\\에서 "
#~ "수행합니다.)"

#~ msgid ""
#~ "This field is inherited by subtypes, "
#~ "but see the rules listed below. A"
#~ " subtype may override this offset; "
#~ "this means that the subtype instances"
#~ " store the dictionary at a difference"
#~ " offset than the base type.  Since"
#~ " the dictionary is always found via"
#~ " :c:member:`~PyTypeObject.tp_dictoffset`, this should"
#~ " not be a problem."
#~ msgstr ""
#~ "이 필드는 서브 형에 의해 상속됩니다. 하지만 아래"
#~ " 나열된 규칙을 참조하십시오. 서브 형이 이 오프셋을"
#~ " 재정의할 수 있습니다; 이는 서브 형 인스턴스가 "
#~ "베이스형과는 다른 오프셋에 딕셔너리를 저장함을 뜻합니다. "
#~ "딕셔너리는 항상 :c:member:`~PyTypeObject.tp_dictoffset`\\을 "
#~ "통해 발견되므로, 문제가 되지 않아야 합니다."

#~ msgid ""
#~ "When a type defined by a class "
#~ "statement has no :attr:`~object.__slots__` "
#~ "declaration, and none of its base "
#~ "types has an instance variable "
#~ "dictionary, a dictionary slot is added"
#~ " to the instance layout and the "
#~ ":c:member:`~PyTypeObject.tp_dictoffset` is set to"
#~ " that slot's offset."
#~ msgstr ""
#~ "클래스 문으로 정의된 형에 :attr:`~object.__slots__` "
#~ "선언이 없고, 인스턴스 변수 딕셔너리를 갖는 베이스형이 "
#~ "없을 때, 딕셔너리 슬롯이 인스턴스 배치에 추가되고 "
#~ ":c:member:`~PyTypeObject.tp_dictoffset`\\은 해당 슬롯의 "
#~ "오프셋으로 설정됩니다."

#~ msgid ""
#~ "When a type defined by a class "
#~ "statement has a :attr:`__slots__` declaration,"
#~ " the type inherits its "
#~ ":c:member:`~PyTypeObject.tp_dictoffset` from its "
#~ "base type."
#~ msgstr ""
#~ "클래스 문으로 정의된 형에 :attr:`__slots__` 선언이 "
#~ "있으면, 형은 베이스형에서 "
#~ ":c:member:`~PyTypeObject.tp_dictoffset`\\을 상속합니다."

#~ msgid ""
#~ "(Adding a slot named :attr:`~object.__dict__`"
#~ " to the :attr:`__slots__` declaration does"
#~ " not have the expected effect, it "
#~ "just causes confusion.  Maybe this "
#~ "should be added as a feature just"
#~ " like :attr:`__weakref__` though.)"
#~ msgstr ""
#~ "(:attr:`__slots__` 선언에 :attr:`~object.__dict__`\\라는 "
#~ "슬롯을 추가해도 기대하는 효과는 없고, 단지 혼란을 "
#~ "초래합니다. 그러나 :attr:`__weakref__`\\처럼 기능으로 추가해야"
#~ " 할 수도 있습니다.)"

#~ msgid ""
#~ "This is set for types created by"
#~ " a class statement.  It should be "
#~ "``NULL`` for statically defined types."
#~ msgstr "이것은 클래스 문으로 만들어진 형에 대해 설정됩니다. 정적으로 정의된 형의 경우 ``NULL``\\이어야 합니다."

#~ msgid "List of weak references to subclasses.  Internal use only."
#~ msgstr "서브 클래스에 대한 약한 참조 리스트. 내부 전용."

#~ msgid ""
#~ "For this field to be taken into"
#~ " account (even through inheritance), you"
#~ " must also set the "
#~ ":const:`Py_TPFLAGS_HAVE_FINALIZE` flags bit."
#~ msgstr ""
#~ "(상속을 통해서도) 이 필드를 고려하려면, "
#~ ":const:`Py_TPFLAGS_HAVE_FINALIZE` 플래그 비트도 설정해야 "
#~ "합니다."

