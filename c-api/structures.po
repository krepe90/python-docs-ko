# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "공통 객체 구조체"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition "
"of object types for Python.  This section describes these structures and "
"how they are used."
msgstr "파이썬의 객체 형 정의에 사용되는 많은 구조체가 있습니다. 이 섹션에서는 이러한 구조체와 사용 방법에 관해 설명합니다."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "기본 객체 형과 매크로"

#: ../../c-api/structures.rst:16
#, fuzzy
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are "
"represented by the :c:type:`PyObject` and :c:type:`PyVarObject` types, "
"which are defined, in turn, by the expansions of some macros also used, "
"whether directly or indirectly, in the definition of all other Python "
"objects.  Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"모든 파이썬 객체는 궁극적으로 객체의 메모리 표현의 처음에서 적은 수의 필드를 공유합니다. 이들은 "
":c:type:`PyObject`\\와 :c:type:`PyVarObject` 형으로 표시되며, 다른 모든 파이썬 객체의 정의에서,"
" 직접 또는 간접적으로, 사용되는 일부 매크로의 확장을 통해 정의됩니다."

#: ../../c-api/structures.rst:26
#, fuzzy
msgid ""
"All object types are extensions of this type.  This is a type which "
"contains the information Python needs to treat a pointer to an object as "
"an object.  In a normal \"release\" build, it contains only the object's "
"reference count and a pointer to the corresponding type object. Nothing "
"is actually declared to be a :c:type:`PyObject`, but every pointer to a "
"Python object can be cast to a :c:expr:`PyObject*`.  Access to the "
"members must be done by using the macros :c:macro:`Py_REFCNT` and "
":c:macro:`Py_TYPE`."
msgstr ""
"모든 객체 형은 이 형의 확장입니다. 이것은 파이썬이 객체에 대한 포인터를 객체로 취급하는 데 필요한 정보를 포함하는 형입니다. "
"일반적인 \"릴리스\" 빌드에는, 객체의 참조 횟수와 해당 형 객체에 대한 포인터만 포함됩니다. 실제로 "
":c:type:`PyObject`\\로 선언된 것은 없지만, 파이썬 객체에 대한 모든 포인터를 "
":c:type:`PyObject*`\\로 캐스트 할 수 있습니다. :c:macro:`Py_REFCNT`\\와 "
":c:macro:`Py_TYPE` 매크로를 사용하여 멤버에 액세스해야 합니다."

#: ../../c-api/structures.rst:38
#, fuzzy
msgid ""
"This is an extension of :c:type:`PyObject` that adds the "
":c:member:`~PyVarObject.ob_size` field.  This is only used for objects "
"that have some notion of *length*. This type does not often appear in the"
" Python/C API. Access to the members must be done by using the macros "
":c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, and :c:macro:`Py_SIZE`."
msgstr ""
"이것은 :attr:`ob_size` 필드를 추가하는 :c:type:`PyObject`\\의 확장입니다. 이것은 *길이*\\라는 "
"개념을 가진 객체에만 사용됩니다. 이 형은 종종 파이썬/C API에 나타나지 않습니다. :c:macro:`Py_REFCNT`, "
":c:macro:`Py_TYPE` 및 :c:macro:`Py_SIZE` 매크로를 사용하여 멤버에 액세스해야 합니다."

#: ../../c-api/structures.rst:47
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"길이가 변하지 않는 객체를 나타내는 새로운 형을 선언할 때 사용되는 매크로입니다. PyObject_HEAD 매크로는 다음과 같이 "
"확장됩니다::"

#: ../../c-api/structures.rst:50
#, fuzzy
msgid "PyObject ob_base;"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:52
msgid "See documentation of :c:type:`PyObject` above."
msgstr "위의 :c:type:`PyObject` 설명서를 참조하십시오."

#: ../../c-api/structures.rst:57
msgid ""
"This is a macro used when declaring new types which represent objects "
"with a length that varies from instance to instance. The "
"PyObject_VAR_HEAD macro expands to::"
msgstr ""
"인스턴스마다 길이가 다른 객체를 나타내는 새로운 형을 선언할 때 사용되는 매크로입니다. PyObject_VAR_HEAD 매크로는 "
"다음과 같이 확장됩니다::"

#: ../../c-api/structures.rst:61
msgid "PyVarObject ob_base;"
msgstr ""

#: ../../c-api/structures.rst:63
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "위의 :c:type:`PyVarObject` 설명서를 참조하십시오."

#: ../../c-api/structures.rst:68
msgid ""
"The base class of all other objects, the same as :class:`object` in "
"Python."
msgstr ""

#: ../../c-api/structures.rst:73
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in "
"Python."
msgstr ""

#: ../../c-api/structures.rst:80
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in"
" Python."
msgstr ""

#: ../../c-api/structures.rst:88
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in"
" Python."
msgstr ""

#: ../../c-api/structures.rst:96
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` "
"in Python."
msgstr ""

#: ../../c-api/structures.rst:104
msgid "Get the type of the Python object *o*."
msgstr ""

#: ../../c-api/structures.rst:106
msgid "Return a :term:`borrowed reference`."
msgstr ""

#: ../../c-api/structures.rst:108
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr ""

#: ../../c-api/structures.rst:110
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The "
"parameter type is no longer :c:expr:`const PyObject*`."
msgstr ""

#: ../../c-api/structures.rst:117
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"객체 *o*\\의 형이 *type*\\이면 0이 아닌 값을 반환합니다. 그렇지 않으면 0을 반환합니다. ``Py_TYPE(o) =="
" type``\\과 동등합니다."

#: ../../c-api/structures.rst:125
msgid "Set the object *o* type to *type*."
msgstr "객체 *o*\\의 형을 *type*\\으로 설정합니다."

#: ../../c-api/structures.rst:132
msgid "Get the size of the Python object *o*."
msgstr ""

#: ../../c-api/structures.rst:134
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr ""

#: ../../c-api/structures.rst:136
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The "
"parameter type is no longer :c:expr:`const PyVarObject*`."
msgstr ""

#: ../../c-api/structures.rst:143
msgid "Set the object *o* size to *size*."
msgstr "객체 *o*\\의 크기를 *size*\\로 설정합니다."

#: ../../c-api/structures.rst:150
msgid ""
"This is a macro which expands to initialization values for a new "
":c:type:`PyObject` type.  This macro expands to::"
msgstr "이것은 새로운 :c:type:`PyObject` 형의 초기화 값으로 확장되는 매크로입니다. 이 매크로는 다음으로 확장됩니다::"

#: ../../c-api/structures.rst:153
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""

#: ../../c-api/structures.rst:159
#, fuzzy
msgid ""
"This is a macro which expands to initialization values for a new "
":c:type:`PyVarObject` type, including the "
":c:member:`~PyVarObject.ob_size` field. This macro expands to::"
msgstr ""
"이것은 :attr:`ob_size` 필드를 포함하여, 새로운 :c:type:`PyVarObject` 형의 초기화 값으로 확장되는 "
"매크로입니다. 이 매크로는 다음으로 확장됩니다::"

#: ../../c-api/structures.rst:163
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""

#: ../../c-api/structures.rst:168
msgid "Implementing functions and methods"
msgstr "함수와 메서드 구현"

#: ../../c-api/structures.rst:172
#, fuzzy
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return"
" one such value.  If the return value is ``NULL``, an exception shall "
"have been set.  If not ``NULL``, the return value is interpreted as the "
"return value of the function as exposed in Python.  The function must "
"return a new reference."
msgstr ""
"대부분 파이썬 콜러블을 C로 구현하는 데 사용되는 함수 형. 이 형의 함수는 두 개의 :c:type:`PyObject*` 매개 "
"변수를 취하고 하나의 값을 반환합니다. 반환 값이 *NULL*\\이면, 예외가 설정되어 있어야 합니다. ``NULL``\\이 "
"아니면, 반환 값은 파이썬에 노출된 함수의 반환 값으로 해석됩니다. 함수는 새로운 참조를 반환해야 합니다."

#: ../../c-api/structures.rst:179
msgid "The function signature is::"
msgstr "함수 서명은 다음과 같습니다::"

#: ../../c-api/structures.rst:181
msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""

#: ../../c-api/structures.rst:186
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"서명이 :const:`METH_VARARGS | METH_KEYWORDS` 인 파이썬 콜러블을 C로 구현하는 데 사용되는 함수 형."
" 함수 서명은 다음과 같습니다::"

#: ../../c-api/structures.rst:190
msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""

#: ../../c-api/structures.rst:197
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"서명이 :const:`METH_FASTCALL` 인 파이썬 콜러블을 C로 구현하는 데 사용되는 함수 형. 함수 서명은 다음과 "
"같습니다::"

#: ../../c-api/structures.rst:201
msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""

#: ../../c-api/structures.rst:207
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"서명이 :const:`METH_FASTCALL | METH_KEYWORDS` 인 파이썬 콜러블을 C로 구현하는 데 사용되는 함수 "
"형. 함수 서명은 다음과 같습니다::"

#: ../../c-api/structures.rst:211
msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""

#: ../../c-api/structures.rst:218
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"서명이 :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS` 인 파이썬 콜러블을 C로 "
"구현하는 데 사용되는 함수 형. 함수 서명은 다음과 같습니다::"

#: ../../c-api/structures.rst:222
msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""

#: ../../c-api/structures.rst:233
msgid ""
"Structure used to describe a method of an extension type.  This structure"
" has four fields:"
msgstr "확장형의 메서드를 기술하는 데 사용되는 구조체. 이 구조체에는 네 개의 필드가 있습니다:"

#: ../../c-api/structures.rst:238
#, fuzzy
msgid "Name of the method."
msgstr "메서드의 이름"

#: ../../c-api/structures.rst:242
#, fuzzy
msgid "Pointer to the C implementation."
msgstr "C 구현에 대한 포인터"

#: ../../c-api/structures.rst:246
#, fuzzy
msgid "Flags bits indicating how the call should be constructed."
msgstr "호출 구성 방법을 나타내는 플래그 비트"

#: ../../c-api/structures.rst:250
#, fuzzy
msgid "Points to the contents of the docstring."
msgstr "독스트링의 내용을 가리킵니다"

#: ../../c-api/structures.rst:252
#, fuzzy
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The "
"functions may be of different types, but they always return "
":c:expr:`PyObject*`.  If the function is not of the "
":c:type:`PyCFunction`, the compiler will require a cast in the method "
"table. Even though :c:type:`PyCFunction` defines the first parameter as "
":c:expr:`PyObject*`, it is common that the method implementation uses the"
" specific C type of the *self* object."
msgstr ""
":attr:`ml_meth`\\는 C 함수 포인터입니다. 함수는 형이 다를 수 있지만, 항상 "
":c:type:`PyObject*`\\를 반환합니다. 함수가 :c:type:`PyCFunction`\\이 아니면, 컴파일러는 메서드"
" 테이블에서 캐스트를 요구합니다. :c:type:`PyCFunction`\\이 첫 번째 매개 변수를 "
":c:type:`PyObject*`\\로 정의하더라도, 일반적으로 메서드 구현은 *self* 객체의 특정 C 형을 사용합니다."

#: ../../c-api/structures.rst:260
#, fuzzy
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can "
"include the following flags. The individual flags indicate either a "
"calling convention or a binding convention."
msgstr ""
":attr:`ml_flags` 필드는 다음 플래그를 포함 할 수 있는 비트 필드입니다. 개별 플래그는 호출 규칙이나 바인딩 규칙을 "
"나타냅니다."

#: ../../c-api/structures.rst:265
msgid "There are these calling conventions:"
msgstr "다음과 같은 호출 규칙이 있습니다:"

#: ../../c-api/structures.rst:269
#, fuzzy
msgid ""
"This is the typical calling convention, where the methods have the type "
":c:type:`PyCFunction`. The function expects two :c:expr:`PyObject*` "
"values. The first one is the *self* object for methods; for module "
"functions, it is the module object.  The second parameter (often called "
"*args*) is a tuple object representing all arguments. This parameter is "
"typically processed using :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_UnpackTuple`."
msgstr ""
"이는 메서드가 :c:type:`PyCFunction` 형인 일반적인 호출 규칙입니다. 함수는 두 개의 "
":c:type:`PyObject*` 값을 기대합니다. 첫 번째는 메서드의 *self* 객체입니다; 모듈 함수의 경우, 모듈 "
"객체입니다. 두 번째 매개 변수(종종 *args*\\라고 합니다)는 모든 인자를 나타내는 튜플 객체입니다. 이 매개 변수는 "
"일반적으로 :c:func:`PyArg_ParseTuple`\\이나 :c:func:`PyArg_UnpackTuple`\\을 사용하여 "
"처리됩니다."

#: ../../c-api/structures.rst:279
msgid ""
"Can only be used in certain combinations with other flags: "
":ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, "
":ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and "
":ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""

#: ../../c-api/structures.rst:287
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ""

#: ../../c-api/structures.rst:288
msgid ""
"Methods with these flags must be of type "
":c:type:`PyCFunctionWithKeywords`. The function expects three parameters:"
" *self*, *args*, *kwargs* where *kwargs* is a dictionary of all the "
"keyword arguments or possibly ``NULL`` if there are no keyword arguments."
"  The parameters are typically processed using "
":c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"이러한 플래그가 있는 메서드는 :c:type:`PyCFunctionWithKeywords` 형이어야 합니다. 이 함수는 세 개의 "
"매개 변수를 기대합니다: *self*, *args*, *kwargs*. 여기서 *kwargs*\\는 모든 키워드 인자의 "
"딕셔너리이거나 키워드 인자가 없으면 ``NULL``\\일 수 있습니다. 매개 변수는 일반적으로 "
":c:func:`PyArg_ParseTupleAndKeywords`\\를 사용하여 처리됩니다."

#: ../../c-api/structures.rst:297
#, fuzzy
msgid ""
"Fast calling convention supporting only positional arguments. The methods"
" have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, "
"the second parameter is a C array of :c:expr:`PyObject*` values "
"indicating the arguments and the third parameter is the number of "
"arguments (the length of the array)."
msgstr ""
"위치 인자만 지원하는 빠른 호출 규칙. 메서드의 형은 :c:type:`_PyCFunctionFast` 입니다. 첫 번째 매개 변수는"
" *self*\\이고, 두 번째 매개 변수는 인자를 나타내는 :c:type:`PyObject*` 값의 C 배열이며, 세 번째 매개 "
"변수는 인자 수(배열의 길이)입니다."

#: ../../c-api/structures.rst:307
#, fuzzy
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr "이것은 :ref:`제한된 API <stable>`\\의 일부가 아닙니다."

#: ../../c-api/structures.rst:312
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ""

#: ../../c-api/structures.rst:313
#, fuzzy
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` "
"parameter which is a tuple representing the names of the keyword "
"arguments (which are guaranteed to be strings) or possibly ``NULL`` if "
"there are no keywords.  The values of the keyword arguments are stored in"
" the *args* array, after the positional arguments."
msgstr ""
":c:type:`_PyCFunctionFastWithKeywords` 형의 메서드를 사용하여, 키워드 인자도 지원하는 "
":const:`METH_FASTCALL`\\의 확장. 키워드 인자는 :ref:`벡터콜(vectorcall) 프로토콜 "
"<vectorcall>`\\과 같은 방식으로 전달됩니다: 추가의 네 번째 :c:type:`PyObject*` 매개 변수가 있는데, "
"키워드 인자의 이름(문자열임이 보장됩니다)을 나타내는 튜플이거나 키워드가 없으면 ``NULL``\\일 수 있습니다. 키워드 인자의 "
"값은 위치 인자 다음에 *args* 배열에 저장됩니다."

#: ../../c-api/structures.rst:328
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD |"
" METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""

#: ../../c-api/structures.rst:334
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ""

#: ../../c-api/structures.rst:335
#, fuzzy
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass"
" of ``Py_TYPE(self)``."
msgstr ""
"*정의하는 클래스(defining class)*, 즉, 문제의 메서드를 포함하는 클래스를 지원하는 "
":const:`METH_FASTCALL | METH_KEYWORDS`\\의 확장. 정의하는 클래스는 "
"``Py_TYPE(self)``\\의 슈퍼 클래스일 수 있습니다."

#: ../../c-api/structures.rst:340
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"메서드는 :c:type:`PyCMethod` 형이어야 하는데, ``self`` 뒤에 ``defining_class`` 인자가 추가된"
" ``METH_FASTCALL | METH_KEYWORDS``\\와 같습니다."

#: ../../c-api/structures.rst:349
#, fuzzy
msgid ""
"Methods without parameters don't need to check whether arguments are "
"given if they are listed with the :c:macro:`METH_NOARGS` flag.  They need"
" to be of type :c:type:`PyCFunction`.  The first parameter is typically "
"named *self* and will hold a reference to the module or object instance."
"  In all cases the second parameter will be ``NULL``."
msgstr ""
"매개 변수가 없는 메서드는 :const:`METH_NOARGS` 플래그로 나열되어 있으면, 인자가 주어졌는지 확인할 필요가 "
"없습니다. :c:type:`PyCFunction` 형이어야 합니다. 첫 번째 매개 변수의 이름은 일반적으로 *self*\\이며 "
"모듈이나 객체 인스턴스에 대한 참조를 보유합니다. 모든 경우에 두 번째 매개 변수는 ``NULL``\\입니다."

#: ../../c-api/structures.rst:355
msgid ""
"The function must have 2 parameters. Since the second parameter is "
"unused, :c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""

#: ../../c-api/structures.rst:361
#, fuzzy
msgid ""
"Methods with a single object argument can be listed with the "
":c:macro:`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` "
"with a ``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with"
" the *self* parameter, and a :c:expr:`PyObject*` parameter representing "
"the single argument."
msgstr ""
"``\"O\"`` 인자로 :c:func:`PyArg_ParseTuple`\\을 호출하는 대신, 단일 객체 인자가 있는 메서드는 "
":const:`METH_O` 플래그로 나열 할 수 있습니다. :c:type:`PyCFunction` 형이고, *self* 매개 "
"변수와 단일 인자를 나타내는 :c:type:`PyObject*` 매개 변수를 갖습니다."

#: ../../c-api/structures.rst:367
msgid ""
"These two constants are not used to indicate the calling convention but "
"the binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for"
" any given method."
msgstr ""
"이 두 상수는 호출 규칙을 나타내는 데 사용되지 않고 클래스의 메서드와 함께 사용할 때 바인딩을 나타냅니다. 모듈에 정의된 함수에는"
" 사용할 수 없습니다. 이러한 플래그 중 최대 하나를 주어진 메서드에 대해 설정할 수 있습니다."

#: ../../c-api/structures.rst:377
msgid ""
"The method will be passed the type object as the first parameter rather "
"than an instance of the type.  This is used to create *class methods*, "
"similar to what is created when using the :func:`classmethod` built-in "
"function."
msgstr ""
"메서드로 형의 인스턴스가 아닌 형 객체가 첫 번째 매개 변수로 전달됩니다. :func:`classmethod` 내장 함수를 사용할 "
"때 만들어지는 것과 유사한 *클래스 메서드(class methods)*\\를 만드는 데 사용됩니다."

#: ../../c-api/structures.rst:387
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar "
"to what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"메서드로 형의 인스턴스가 아닌 ``NULL``\\이 첫 번째 매개 변수로 전달됩니다. :func:`staticmethod` 내장 "
"함수를 사용할 때 만들어지는 것과 유사한 *정적 메서드(static methods)*\\를 만드는 데 사용됩니다."

#: ../../c-api/structures.rst:391
msgid ""
"One other constant controls whether a method is loaded in place of "
"another definition with the same method name."
msgstr "하나의 다른 상수는 같은 메서드 이름을 가진 다른 정의 대신 메서드가 로드되는지를 제어합니다."

#: ../../c-api/structures.rst:397
#, fuzzy
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named "
":meth:`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction "
"will be loaded in place of the wrapper object and will co-exist with the "
"slot.  This is helpful because calls to PyCFunctions are optimized more "
"than wrapper object calls."
msgstr ""
"기존 정의 대신 메서드가 로드됩니다. *METH_COEXIST*\\가 없으면, 기본값은 반복되는 정의를 건너뛰는 것입니다. 슬롯 "
"래퍼가 메서드 테이블 전에 로드되므로, 예를 들어 *sq_contains* 슬롯의 존재는 "
":meth:`__contains__`\\라는 래핑 된 메서드를 생성하고 같은 이름의 해당 PyCFunction을 로드하지 않습니다."
" 플래그가 정의되면, PyCFunction이 래퍼 객체 자리에 로드되고 슬롯과 공존합니다. 이는 PyCFunction에 대한 호출이"
" 래퍼 객체 호출보다 최적화되어 있기 때문에 유용합니다."

#: ../../c-api/structures.rst:409
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure "
"that *ml* outlives the :term:`callable`. Typically, *ml* is defined as a "
"static variable."
msgstr ""

#: ../../c-api/structures.rst:413
msgid ""
"The *self* parameter will be passed as the *self* argument to the C "
"function in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""

#: ../../c-api/structures.rst:417
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from "
"the given *module* argument. *module* should be a Python string, which "
"will be used as name of the module the function is defined in. If "
"unavailable, it can be set to :const:`None` or ``NULL``."
msgstr ""

#: ../../c-api/structures.rst:423
msgid ":attr:`function.__module__`"
msgstr ""

#: ../../c-api/structures.rst:425
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to "
"the C function. Must be set if :c:macro:`METH_METHOD` is set on "
"``ml->ml_flags``."
msgstr ""

#: ../../c-api/structures.rst:434
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr ""

#: ../../c-api/structures.rst:439
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr ""

#: ../../c-api/structures.rst:443
msgid "Accessing attributes of extension types"
msgstr "확장형의 어트리뷰트 액세스"

#: ../../c-api/structures.rst:447
#, fuzzy
msgid ""
"Structure which describes an attribute of a type which corresponds to a C"
" struct member. When defining a class, put a NULL-terminated array of "
"these structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr "C 구조체 멤버에 해당하는 형의 어트리뷰트를 기술하는 구조체. 필드는 다음과 같습니다:"

#: ../../c-api/structures.rst:452
msgid "Its fields are, in order:"
msgstr ""

#: ../../c-api/structures.rst:456
msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` "
"array."
msgstr ""

#: ../../c-api/structures.rst:459
msgid "The string should be static, no copy is made of it."
msgstr ""

#: ../../c-api/structures.rst:463
msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for "
"the possible values."
msgstr ""

#: ../../c-api/structures.rst:468
#, fuzzy
msgid ""
"The offset in bytes that the member is located on the type’s object "
"struct."
msgstr "멤버가 형의 객체 구조체에 위치하는 바이트 단위의 오프셋"

#: ../../c-api/structures.rst:472
msgid "Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""

#: ../../c-api/structures.rst:476
msgid ""
"The docstring, or NULL. The string should be static, no copy is made of "
"it. Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""

#: ../../c-api/structures.rst:480
msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply "
":c:macro:`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy "
":c:macro:`T_OBJECT`) members can be deleted."
msgstr ""

#: ../../c-api/structures.rst:489
#, fuzzy
msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member"
" ``\"__vectorcalloffset__\"``, corresponding to "
":c:member:`~PyTypeObject.tp_vectorcall_offset` in type objects. These "
"must be defined with ``Py_T_PYSSIZET`` and ``Py_READONLY``, for example::"
msgstr ""
"힙 할당형 (:c:func:`PyType_FromSpec`\\이나 유사한 것을 사용하여 만들어진), "
"``PyMemberDef``\\는 형 객체의 :c:member:`~PyTypeObject.tp_dictoffset`, "
":c:member:`~PyTypeObject.tp_weaklistoffset` 및 "
":c:member:`~PyTypeObject.tp_vectorcall_offset`\\에 해당하는 특수 멤버 "
"``__dictoffset__``, ``__weaklistoffset__`` 및 ``__vectorcalloffset__``\\에 "
"대한 정의를 포함할 수 있습니다. ``T_PYSSIZET``\\과 ``READONLY``\\로 정의해야 합니다, 예를 들면::"

#: ../../c-api/structures.rst:495
msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../../c-api/structures.rst:501
msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr ""

#: ../../c-api/structures.rst:503
msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and "
":c:member:`~PyTypeObject.tp_weaklistoffset` can be defined similarly "
"using ``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use "
":c:macro:`Py_TPFLAGS_MANAGED_DICT` and "
":c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""

#: ../../c-api/structures.rst:511
msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""

#: ../../c-api/structures.rst:516
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on "
"error."
msgstr ""

#: ../../c-api/structures.rst:522
msgid ""
"``PyMember_GetOne`` is always available. Previously, it required "
"including ``\"structmember.h\"``."
msgstr ""

#: ../../c-api/structures.rst:527
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""

#: ../../c-api/structures.rst:533
msgid ""
"``PyMember_SetOne`` is always available. Previously, it required "
"including ``\"structmember.h\"``."
msgstr ""

#: ../../c-api/structures.rst:539
msgid "Member flags"
msgstr ""

#: ../../c-api/structures.rst:541
msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr ""

#: ../../c-api/structures.rst:545
msgid "Not writable."
msgstr ""

#: ../../c-api/structures.rst:549
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""

#: ../../c-api/structures.rst:554
msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this "
"``PyMemberDef`` entry indicates an offset from the subclass-specific "
"data, rather than from ``PyObject``."
msgstr ""

#: ../../c-api/structures.rst:558
msgid ""
"Can only be used as part of :c:member:`Py_tp_members "
"<PyTypeObject.tp_members>` :c:type:`slot <PyType_Slot>` when creating a "
"class using negative :c:member:`~PyType_Spec.basicsize`. It is mandatory "
"in that case."
msgstr ""

#: ../../c-api/structures.rst:563
msgid ""
"This flag is only used in :c:type:`PyType_Slot`. When setting "
":c:member:`~PyTypeObject.tp_members` during class creation, Python clears"
" it and sets :c:member:`PyMemberDef.offset` to the offset from the "
"``PyObject`` struct."
msgstr ""

#: ../../c-api/structures.rst:575
msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and "
":c:macro:`!WRITE_RESTRICTED` macros available with ``#include "
"\"structmember.h\"`` are deprecated. :c:macro:`!READ_RESTRICTED` and "
":c:macro:`!RESTRICTED` are equivalent to :c:macro:`Py_AUDIT_READ`; "
":c:macro:`!WRITE_RESTRICTED` does nothing."
msgstr ""

#: ../../c-api/structures.rst:586
msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The"
" :c:macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The"
" new names are now always available. Previously, these required "
"``#include \"structmember.h\"``. The header is still available and it "
"provides the old names."
msgstr ""

#: ../../c-api/structures.rst:595
msgid "Member types"
msgstr ""

#: ../../c-api/structures.rst:597
msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, "
"it will be converted to the equivalent Python type. When it is set from "
"Python, it will be converted back to the C type. If that is not possible,"
" an exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""

#: ../../c-api/structures.rst:605
msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using "
"e.g. :keyword:`del` or :py:func:`delattr`."
msgstr ""

#: ../../c-api/structures.rst:609
msgid "Macro name"
msgstr "매크로 이름"

#: ../../c-api/structures.rst:609
msgid "C type"
msgstr "C 형"

#: ../../c-api/structures.rst:609
msgid "Python type"
msgstr ""

#: ../../c-api/structures.rst:611
msgid ":c:expr:`char`"
msgstr ""

#: ../../c-api/structures.rst:611 ../../c-api/structures.rst:612
#: ../../c-api/structures.rst:613 ../../c-api/structures.rst:614
#: ../../c-api/structures.rst:615 ../../c-api/structures.rst:616
#: ../../c-api/structures.rst:617 ../../c-api/structures.rst:618
#: ../../c-api/structures.rst:619 ../../c-api/structures.rst:620
#: ../../c-api/structures.rst:621
msgid ":py:class:`int`"
msgstr ""

#: ../../c-api/structures.rst:612
msgid ":c:expr:`short`"
msgstr ""

#: ../../c-api/structures.rst:613
msgid ":c:expr:`int`"
msgstr ""

#: ../../c-api/structures.rst:614
msgid ":c:expr:`long`"
msgstr ""

#: ../../c-api/structures.rst:615
#, fuzzy
msgid ":c:expr:`long long`"
msgstr "long long"

#: ../../c-api/structures.rst:616
#, fuzzy
msgid ":c:expr:`unsigned char`"
msgstr "unsigned char"

#: ../../c-api/structures.rst:617
#, fuzzy
msgid ":c:expr:`unsigned int`"
msgstr "unsigned int"

#: ../../c-api/structures.rst:618
#, fuzzy
msgid ":c:expr:`unsigned short`"
msgstr "unsigned short"

#: ../../c-api/structures.rst:619
#, fuzzy
msgid ":c:expr:`unsigned long`"
msgstr "unsigned long"

#: ../../c-api/structures.rst:620
#, fuzzy
msgid ":c:expr:`unsigned long long`"
msgstr "unsigned long long"

#: ../../c-api/structures.rst:621
#, fuzzy
msgid ":c:expr:`Py_ssize_t`"
msgstr "Py_ssize_t"

#: ../../c-api/structures.rst:622
msgid ":c:expr:`float`"
msgstr ""

#: ../../c-api/structures.rst:622 ../../c-api/structures.rst:623
msgid ":py:class:`float`"
msgstr ""

#: ../../c-api/structures.rst:623
msgid ":c:expr:`double`"
msgstr ""

#: ../../c-api/structures.rst:624
msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ""

#: ../../c-api/structures.rst:624
msgid ":py:class:`bool`"
msgstr ""

#: ../../c-api/structures.rst:626
#, fuzzy
msgid ":c:expr:`const char *` (*)"
msgstr "const char \\*"

#: ../../c-api/structures.rst:626 ../../c-api/structures.rst:627
msgid ":py:class:`str` (RO)"
msgstr ""

#: ../../c-api/structures.rst:627
#, fuzzy
msgid ":c:expr:`const char[]` (*)"
msgstr "const char \\*"

#: ../../c-api/structures.rst:628
msgid ":c:expr:`char` (0-127)"
msgstr ""

#: ../../c-api/structures.rst:628
msgid ":py:class:`str` (**)"
msgstr ""

#: ../../c-api/structures.rst:629
#, fuzzy
msgid ":c:expr:`PyObject *`"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:629
msgid ":py:class:`object` (D)"
msgstr ""

#: ../../c-api/structures.rst:632
msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING`"
" the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` "
"the string is stored directly in the structure."
msgstr ""

#: ../../c-api/structures.rst:637
msgid "(**): String of length 1. Only ASCII is accepted."
msgstr ""

#: ../../c-api/structures.rst:639
msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr ""

#: ../../c-api/structures.rst:641
msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. "
"Reading a ``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""

#: ../../c-api/structures.rst:667
msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, "
"along with the following deprecated types:"
msgstr ""

#: ../../c-api/structures.rst:675
msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This "
"results in surprising behavior in Python: deleting the attribute "
"effectively sets it to ``None``."
msgstr ""

#: ../../c-api/structures.rst:681
msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr ""

#: ../../c-api/structures.rst:684
msgid "Defining Getters and Setters"
msgstr ""

#: ../../c-api/structures.rst:688
msgid ""
"Structure to define property-like access for a type. See also description"
" of the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"형에 대한 프로퍼티 같은 액세스를 정의하는 구조체. :c:member:`PyTypeObject.tp_getset` 슬롯에 대한 "
"설명도 참조하십시오."

#: ../../c-api/structures.rst:693
msgid "attribute name"
msgstr "어트리뷰트 이름"

#: ../../c-api/structures.rst:697
#, fuzzy
msgid "C function to get the attribute."
msgstr "어트리뷰트를 얻는 C 함수"

#: ../../c-api/structures.rst:701
#, fuzzy
msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr "어트리뷰트를 설정하거나 삭제하는 선택적 C 함수, 생략되면 어트리뷰트는 읽기 전용입니다"

#: ../../c-api/structures.rst:706
msgid "optional docstring"
msgstr "선택적 독스트링"

#: ../../c-api/structures.rst:710
#, fuzzy
msgid ""
"Optional user data pointer, providing additional data for getter and "
"setter."
msgstr "getter와 setter에 추가 데이터를 제공하는 선택적 함수 포인터"

#: ../../c-api/structures.rst:714
#, fuzzy
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the "
"instance) and a user data pointer (the associated ``closure``):"
msgstr ""
"``get`` 함수는 하나의 :c:type:`PyObject*` 매개 변수(인스턴스)와 함수 포인터(연관된 ``closure``)를"
" 받아들입니다::"

#: ../../c-api/structures.rst:717
msgid ""
"It should return a new reference on success or ``NULL`` with a set "
"exception on failure."
msgstr "성공하면 새 참조를 반환하고, 실패하면 설정된 예외와 함께 ``NULL``\\을 반환해야 합니다."

#: ../../c-api/structures.rst:722
#, fuzzy
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance "
"and the value to be set) and a user data pointer (the associated "
"``closure``):"
msgstr ""
"``set`` 함수는 두 개의 :c:type:`PyObject*` 매개 변수(인스턴스와 설정할 값)와 함수 포인터(연관된 "
"``closure``)를 받아들입니다::"

#: ../../c-api/structures.rst:725
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``."
" Should return ``0`` on success or ``-1`` with a set exception on "
"failure."
msgstr ""
"어트리뷰트를 삭제해야 하는 경우 두 번째 매개 변수는 ``NULL``\\입니다. 성공하면 ``0``\\을, 실패하면 설정된 예외와 "
"함께 ``-1``\\을 반환해야 합니다."

#: ../../c-api/structures.rst:375 ../../c-api/structures.rst:385
msgid "built-in function"
msgstr ""

#: ../../c-api/structures.rst:375
msgid "classmethod"
msgstr ""

#: ../../c-api/structures.rst:385
msgid "staticmethod"
msgstr ""

#: ../../c-api/structures.rst:568
msgid "READ_RESTRICTED (C macro)"
msgstr ""

#: ../../c-api/structures.rst:568
msgid "WRITE_RESTRICTED (C macro)"
msgstr ""

#: ../../c-api/structures.rst:568
msgid "RESTRICTED (C macro)"
msgstr ""

#: ../../c-api/structures.rst:581
msgid "READONLY (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
msgid "T_BYTE (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
msgid "T_SHORT (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
msgid "T_INT (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
msgid "T_LONG (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG"

#: ../../c-api/structures.rst:644
msgid "T_UBYTE (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_USHORT (C macro)"
msgstr "T_USHORT"

#: ../../c-api/structures.rst:644
msgid "T_UINT (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
msgid "T_ULONG (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGLONG"

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET"

#: ../../c-api/structures.rst:644
msgid "T_FLOAT (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE"

#: ../../c-api/structures.rst:644
msgid "T_BOOL (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
msgid "T_CHAR (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_STRING (C macro)"
msgstr "T_STRING"

#: ../../c-api/structures.rst:644
msgid "T_STRING_INPLACE (C macro)"
msgstr ""

#: ../../c-api/structures.rst:644
#, fuzzy
msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX"

#: ../../c-api/structures.rst:644
msgid "structmember.h"
msgstr ""

#~ msgid ""
#~ "This macro is used to access the"
#~ " :attr:`ob_type` member of a Python "
#~ "object. It expands to::"
#~ msgstr "이 매크로는 파이썬 객체의 :attr:`ob_type` 멤버에 액세스하는 데 사용됩니다. 다음으로 확장됩니다::"

#~ msgid ""
#~ "This macro is used to access the"
#~ " :attr:`ob_refcnt` member of a Python "
#~ "object. It expands to::"
#~ msgstr "이 매크로는 파이썬 객체의 :attr:`ob_refcnt` 멤버에 액세스하는 데 사용됩니다. 다음으로 확장됩니다::"

#~ msgid "Set the object *o* reference counter to *refcnt*."
#~ msgstr "객체 *o*\\의 참조 횟수를 *refcnt*\\로 설정합니다."

#~ msgid ""
#~ "This macro is used to access the"
#~ " :attr:`ob_size` member of a Python "
#~ "object. It expands to::"
#~ msgstr "이 매크로는 파이썬 객체의 :attr:`ob_size` 멤버에 액세스하는 데 사용됩니다. 다음으로 확장됩니다::"

#~ msgid "Field"
#~ msgstr "필드"

#~ msgid "C Type"
#~ msgstr "C 형"

#~ msgid "Meaning"
#~ msgstr "의미"

#~ msgid ":attr:`ml_name`"
#~ msgstr ":attr:`ml_name`"

#~ msgid ":attr:`ml_meth`"
#~ msgstr ":attr:`ml_meth`"

#~ msgid "PyCFunction"
#~ msgstr "PyCFunction"

#~ msgid ":attr:`ml_flags`"
#~ msgstr ":attr:`ml_flags`"

#~ msgid "int"
#~ msgstr "int"

#~ msgid ":attr:`ml_doc`"
#~ msgstr ":attr:`ml_doc`"

#~ msgid ":attr:`name`"
#~ msgstr ":attr:`name`"

#~ msgid "name of the member"
#~ msgstr "멤버의 이름"

#~ msgid ":attr:`!type`"
#~ msgstr ":attr:`!type`"

#~ msgid "the type of the member in the C struct"
#~ msgstr "C 구조체에 있는 멤버의 형"

#~ msgid ":attr:`offset`"
#~ msgstr ":attr:`offset`"

#~ msgid ":attr:`flags`"
#~ msgstr ":attr:`flags`"

#~ msgid "flag bits indicating if the field should be read-only or writable"
#~ msgstr "필드가 읽기 전용인지 쓰기 가능한지를 나타내는 플래그 비트"

#~ msgid ":attr:`doc`"
#~ msgstr ":attr:`doc`"

#~ msgid ""
#~ ":attr:`!type` can be one of many "
#~ "``T_`` macros corresponding to various C"
#~ " types.  When the member is accessed"
#~ " in Python, it will be converted "
#~ "to the equivalent Python type."
#~ msgstr ""
#~ ":attr:`!type`\\은 다양한 C 형에 해당하는 많은 "
#~ "``T_`` 매크로 중 하나일 수 있습니다. 멤버가 "
#~ "파이썬에서 액세스 될 때, 동등한 파이썬 형으로 "
#~ "변환됩니다."

#~ msgid "T_SHORT"
#~ msgstr "T_SHORT"

#~ msgid "short"
#~ msgstr "short"

#~ msgid "T_INT"
#~ msgstr "T_INT"

#~ msgid "T_LONG"
#~ msgstr "T_LONG"

#~ msgid "long"
#~ msgstr "long"

#~ msgid "T_FLOAT"
#~ msgstr "T_FLOAT"

#~ msgid "float"
#~ msgstr "float"

#~ msgid "double"
#~ msgstr "double"

#~ msgid "T_OBJECT"
#~ msgstr "T_OBJECT"

#~ msgid "T_CHAR"
#~ msgstr "T_CHAR"

#~ msgid "char"
#~ msgstr "char"

#~ msgid "T_BYTE"
#~ msgstr "T_BYTE"

#~ msgid "T_UBYTE"
#~ msgstr "T_UBYTE"

#~ msgid "T_UINT"
#~ msgstr "T_UINT"

#~ msgid "T_ULONG"
#~ msgstr "T_ULONG"

#~ msgid "T_BOOL"
#~ msgstr "T_BOOL"

#~ msgid ""
#~ ":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` "
#~ "differ in that :c:macro:`T_OBJECT` returns "
#~ "``None`` if the member is ``NULL`` "
#~ "and :c:macro:`T_OBJECT_EX` raises an "
#~ ":exc:`AttributeError`.  Try to use "
#~ ":c:macro:`T_OBJECT_EX` over :c:macro:`T_OBJECT` "
#~ "because :c:macro:`T_OBJECT_EX` handles use of"
#~ " the :keyword:`del` statement on that "
#~ "attribute more correctly than "
#~ ":c:macro:`T_OBJECT`."
#~ msgstr ""
#~ "멤버가 ``NULL``\\일 때 :c:macro:`T_OBJECT`\\는 "
#~ "``None``\\을 반환하고 :c:macro:`T_OBJECT_EX`\\는 "
#~ ":exc:`AttributeError`\\를 발생시킨다는 점에서 "
#~ ":c:macro:`T_OBJECT`\\와 :c:macro:`T_OBJECT_EX`\\가 다릅니다. "
#~ ":c:macro:`T_OBJECT_EX`\\가 :c:macro:`T_OBJECT`\\보다 해당 "
#~ "어트리뷰트에 대한 :keyword:`del` 문 사용을 더 "
#~ "올바르게 처리하므로, :c:macro:`T_OBJECT`\\보다 "
#~ ":c:macro:`T_OBJECT_EX`\\를 사용하십시오."

#~ msgid ""
#~ ":attr:`flags` can be ``0`` for write "
#~ "and read access or :c:macro:`READONLY` "
#~ "for read-only access.  Using "
#~ ":c:macro:`T_STRING` for :attr:`type` implies "
#~ ":c:macro:`READONLY`.  :c:macro:`T_STRING` data is"
#~ " interpreted as UTF-8. Only "
#~ ":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` "
#~ "members can be deleted.  (They are "
#~ "set to ``NULL``)."
#~ msgstr ""
#~ ":attr:`flags`\\는 쓰기와 읽기 액세스를 위해 "
#~ "``0``\\이거나, 읽기 전용 액세스를 위해 "
#~ ":c:macro:`READONLY` 일 수 있습니다. :attr:`type`\\에"
#~ " :c:macro:`T_STRING`\\을 사용한다는 것은 "
#~ ":c:macro:`READONLY`\\를 뜻합니다. :c:macro:`T_STRING` "
#~ "데이터는 UTF-8로 해석됩니다. :c:macro:`T_OBJECT`\\와 "
#~ ":c:macro:`T_OBJECT_EX` 멤버만 삭제될 수 있습니다. "
#~ "(``NULL``\\로 설정됩니다)."

#~ msgid "name"
#~ msgstr "name"

#~ msgid "get"
#~ msgstr "get"

#~ msgid "getter"
#~ msgstr "getter"

#~ msgid "set"
#~ msgstr "set"

#~ msgid "setter"
#~ msgstr "setter"

#~ msgid "doc"
#~ msgstr "doc"

#~ msgid "closure"
#~ msgstr "closure"

#~ msgid "void \\*"
#~ msgstr "void \\*"

