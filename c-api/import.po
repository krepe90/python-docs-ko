# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "모듈 임포트 하기"

#: ../../c-api/import.rst:16
msgid ""
"This is a wrapper around :c:func:`PyImport_Import()` which takes a "
":c:expr:`const char *` as an argument instead of a :c:expr:`PyObject *`."
msgstr ""

#: ../../c-api/import.rst:21
msgid "This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr "이 함수는 :c:func:`PyImport_ImportModule`\\의 폐지된 별칭입니다."

#: ../../c-api/import.rst:23
msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to "
"per-module locks for most purposes, so this function's special behaviour "
"isn't needed anymore."
msgstr ""
"이 기능은 다른 스레드가 임포트 잠금을 보유한 경우 즉시 실패했었습니다. 그러나 파이썬 3.3에서는, 잠금 방식이 대부분의 목적에서"
" 모듈 단위 잠금으로 전환되었기 때문에, 이 함수의 특수한 동작은 더는 필요하지 않습니다."

#: ../../c-api/import.rst:29
#, fuzzy
msgid "Use :c:func:`PyImport_ImportModule` instead."
msgstr ":c:func:`PyImport_ExecCodeModuleWithPathnames`\\도 참조하십시오."

#: ../../c-api/import.rst:37
msgid ""
"Import a module.  This is best described by referring to the built-in "
"Python function :func:`__import__`."
msgstr "모듈을 임포트 합니다. 내장 파이썬 함수 :func:`__import__`\\를 통해 가장 잘 설명할 수 있습니다."

#: ../../c-api/import.rst:40 ../../c-api/import.rst:56
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for "
":func:`__import__`, the return value when a submodule of a package was "
"requested is normally the top-level package, unless a non-empty "
"*fromlist* was given."
msgstr ""
"반환 값은 임포트 된 모듈이나 최상위 패키지에 대한 새로운 참조, 또는 실패 시 예외가 설정된 ``NULL``\\입니다. "
":func:`__import__`\\와 마찬가지로, 비어 있지 않은 *fromlist*\\가 제공되지 않는 한, 패키지의 서브 "
"모듈이 요청되었을 때의 반환 값은 최상위 패키지입니다."

#: ../../c-api/import.rst:46
msgid ""
"Failing imports remove incomplete module objects, like with "
":c:func:`PyImport_ImportModule`."
msgstr "임포트 실패는 :c:func:`PyImport_ImportModule`\\처럼 불완전한 모듈 객체를 제거합니다."

#: ../../c-api/import.rst:52
msgid ""
"Import a module.  This is best described by referring to the built-in "
"Python function :func:`__import__`, as the standard :func:`__import__` "
"function calls this function directly."
msgstr ""
"모듈을 임포트 합니다. 표준 :func:`__import__` 함수가 이 함수를 직접 호출하기 때문에, 내장 파이썬 함수 "
":func:`__import__`\\를 통해 가장 잘 설명할 수 있습니다."

#: ../../c-api/import.rst:66
msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
":c:func:`PyImport_ImportModuleLevelObject`\\와 비슷하지만, name은 유니코드 객체 대신 "
"UTF-8로 인코딩된 문자열입니다."

#: ../../c-api/import.rst:69
msgid "Negative values for *level* are no longer accepted."
msgstr "*level*\\의 음수 값은 더는 허용되지 않습니다."

#: ../../c-api/import.rst:74
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever "
"import hooks are installed in the current environment."
msgstr ""
"이것은 현재 \"임포트 훅 함수\"를 호출하는 고수준 인터페이스입니다 (명시적인 *level* 0을 사용하는데, 절대 임포트를 "
"뜻합니다). 현재 전역의 ``__builtins__``\\에 있는 :func:`__import__` 함수를 호출합니다. 이는 현재 "
"환경에 설치된 임포트 훅을 사용하여 임포트가 수행됨을 의미합니다."

#: ../../c-api/import.rst:80
msgid "This function always uses absolute imports."
msgstr "이 함수는 항상 절대 임포트를 사용합니다."

#: ../../c-api/import.rst:85
msgid ""
"Reload a module.  Return a new reference to the reloaded module, or "
"``NULL`` with an exception set on failure (the module still exists in "
"this case)."
msgstr ""
"모듈을 다시 로드(reload)합니다. 다시 로드된 모듈에 대한 참조를 반환하거나, 실패 시 예외가 설정된 ``NULL``\\을 "
"반환합니다 (이때 모듈은 여전히 존재합니다)."

#: ../../c-api/import.rst:91
msgid "Return the module object corresponding to a module name."
msgstr ""

#: ../../c-api/import.rst:93
#, fuzzy
msgid ""
"The *name* argument may be of the form ``package.module``. First check "
"the modules dictionary if there's one there, and if not, create a new one"
" and insert it in the modules dictionary."
msgstr ""
"모듈 이름에 해당하는 모듈 객체를 반환합니다. *name* 인자는 ``package.module`` 형식일 수 있습니다. 먼저 모듈"
" 딕셔너리에 있는지 확인하고, 없으면 새로 만들어 모듈 딕셔너리에 삽입합니다. 실패 시 예외를 설정하고 ``NULL``\\을 "
"반환합니다."

#: ../../c-api/import.rst:97
#, fuzzy
msgid ""
"Return a :term:`strong reference` to the module on success. Return "
"``NULL`` with an exception set on failure."
msgstr ""
"모듈을 다시 로드(reload)합니다. 다시 로드된 모듈에 대한 참조를 반환하거나, 실패 시 예외가 설정된 ``NULL``\\을 "
"반환합니다 (이때 모듈은 여전히 존재합니다)."

#: ../../c-api/import.rst:100
msgid "The module name *name* is decoded from UTF-8."
msgstr ""

#: ../../c-api/import.rst:102
#, fuzzy
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use "
":c:func:`PyImport_ImportModule` or one of its variants to import a "
"module. Package structures implied by a dotted name for *name* are not "
"created if not already present."
msgstr ""
"이 함수는 모듈을 로드하거나 임포트 하지 않습니다; 모듈이 아직 로드되지 않았으면, 빈 모듈 객체를 얻게 됩니다. 모듈을 임포트 "
"하려면 :c:func:`PyImport_ImportModule`\\이나 그 변형 중 하나를 사용하십시오. *name*\\에서 점으로"
" 구분된 이름으로 암시된 패키지 구조는 이미 존재하지 않는다면 만들어지지 않습니다."

#: ../../c-api/import.rst:113
#, fuzzy
msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference` and *name* is a Python :class:`str` object."
msgstr ""
":c:func:`PyImport_AddModuleObject`\\와 비슷하지만, name은 유니코드 객체 대신 UTF-8로 인코딩된"
" 문자열입니다."

#: ../../c-api/import.rst:121
msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference`."
msgstr ""

#: ../../c-api/import.rst:129
#, fuzzy
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the"
" module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :data:`sys.modules` in error cases, even if *name*"
" was already in :data:`sys.modules` on entry to "
":c:func:`PyImport_ExecCodeModule`.  Leaving incompletely initialized "
"modules in :data:`sys.modules` is dangerous, as imports of such modules "
"have no way to know that the module object is an unknown (and probably "
"damaged with respect to the module author's intents) state."
msgstr ""
"주어진 모듈 이름(name)(``package.module`` 형식일 수 있습니다)과 파이썬 바이트 코드 파일에서 읽거나 내장 함수"
" :func:`compile`\\로 얻은 코드 객체로, 모듈을 로드합니다. 모듈 객체에 대한 새로운 참조를 반환하거나, 또는 에러가"
" 발생하면 예외가 설정된 ``NULL``\\을 반환합니다. 에러가 발생하면 :attr:`sys.modules`\\에서 "
"*name*\\이 제거됩니다, :c:func:`PyImport_ExecCodeModule` 에 진입할 때 *name*\\이 "
":attr:`sys.modules`\\에 이미 있어도 그렇습니다. :attr:`sys.modules`\\에 불완전하게 초기화된 "
"모듈을 남겨 두는 것은 위험합니다, 그러한 모듈을 임포트 할 때 모듈 객체가 알 수 없는 (그리고 아마도 모듈 작성자의 의도에 "
"비추어볼 때 손상된) 상태에 있음을 알 방법이 없기 때문입니다."

#: ../../c-api/import.rst:139
#, fuzzy
msgid ""
"The module's :attr:`~module.__spec__` and :attr:`~module.__loader__` will"
" be set, if not set already, with the appropriate values.  The spec's "
"loader will be set to the module's :attr:`!__loader__` (if set) and to an"
" instance of :class:`~importlib.machinery.SourceFileLoader` otherwise."
msgstr ""
"모듈의 :attr:`__spec__`\\과 :attr:`__loader__`\\는 아직 설정되지 않았다면 적절한 값으로 설정됩니다."
" 스펙의 로더는 모듈의 ``__loader__``\\(설정되었다면)로 설정되고, 그렇지 않으면 "
":class:`SourceFileLoader` 의 인스턴스로 설정됩니다."

#: ../../c-api/import.rst:144
#, fuzzy
msgid ""
"The module's :attr:`~module.__file__` attribute will be set to the code "
"object's :attr:`~codeobject.co_filename`.  If applicable, "
":attr:`~module.__cached__` will also be set."
msgstr ""
"모듈의 :attr:`__file__` 어트리뷰트는 코드 객체의 :c:member:`co_filename`\\으로 설정됩니다. "
"해당한다면, :attr:`__cached__`\\도 설정됩니다."

#: ../../c-api/import.rst:148
msgid ""
"This function will reload the module if it was already imported.  See "
":c:func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"이 함수는 이미 임포트 되었다면 모듈을 다시 로드합니다. 모듈을 다시 로드하는 의도된 방법은 "
":c:func:`PyImport_ReloadModule`\\을 참조하십시오."

#: ../../c-api/import.rst:151
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"*name*\\이 ``package.module`` 형식의 점으로 구분된 이름을 가리키면, 이미 만들어지지 않은 패키지 구조는 "
"여전히 만들어지지 않습니다."

#: ../../c-api/import.rst:154
msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and "
":c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
":c:func:`PyImport_ExecCodeModuleEx`\\와 "
":c:func:`PyImport_ExecCodeModuleWithPathnames`\\도 참조하십시오."

#: ../../c-api/import.rst:157
msgid ""
"The setting of :attr:`~module.__cached__` and :attr:`~module.__loader__` "
"is deprecated. See :class:`~importlib.machinery.ModuleSpec` for "
"alternatives."
msgstr ""

#: ../../c-api/import.rst:165
#, fuzzy
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`~module.__file__` "
"attribute of the module object is set to *pathname* if it is "
"non-``NULL``."
msgstr ""
":c:func:`PyImport_ExecCodeModule`\\과 유사하지만, 모듈 객체의 :attr:`__file__` "
"어트리뷰트는 ``NULL``\\이 아니라면 *pathname*\\으로 설정됩니다."

#: ../../c-api/import.rst:168
msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr ":c:func:`PyImport_ExecCodeModuleWithPathnames`\\도 참조하십시오."

#: ../../c-api/import.rst:173
#, fuzzy
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the "
":attr:`~module.__cached__` attribute of the module object is set to "
"*cpathname* if it is non-``NULL``.  Of the three functions, this is the "
"preferred one to use."
msgstr ""
":c:func:`PyImport_ExecCodeModuleEx`\\와 유사하지만, 모듈 객체의 :attr:`__cached__` "
"어트리뷰트는 ``NULL``\\이 아니라면 *cpathname*\\으로 설정됩니다. 세 가지 함수 중 이것이 선호되는 것입니다."

#: ../../c-api/import.rst:179
msgid ""
"Setting :attr:`~module.__cached__` is deprecated. See "
":class:`~importlib.machinery.ModuleSpec` for alternatives."
msgstr ""

#: ../../c-api/import.rst:186
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure "
"out what the value for *pathname* should be from *cpathname* if the "
"former is set to ``NULL``."
msgstr ""
":c:func:`PyImport_ExecCodeModuleObject`\\와 유사하지만, *name*, *pathname* 및 "
"*cpathname*\\은 UTF-8로 인코딩된 문자열입니다. *pathname*\\의 값이 ``NULL``\\로 설정된 경우 어떤"
" 값이 *cpathname*\\에서 와야하는지 알아내려고 합니다."

#: ../../c-api/import.rst:192
#, fuzzy
msgid ""
"Uses :func:`!imp.source_from_cache` in calculating the source path if "
"only the bytecode path is provided."
msgstr "바이트 코드 경로만 제공되면 소스 경로를 계산할 때 :func:`imp.source_from_cache()`\\를 사용합니다."

#: ../../c-api/import.rst:195
msgid "No longer uses the removed :mod:`!imp` module."
msgstr ""

#: ../../c-api/import.rst:201
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"파이썬 바이트 코드 파일(일명 :file:`.pyc` 파일)의 매직 번호(magic number)를 반환합니다. 매직 번호는 바이트"
" 코드 파일의 처음 4바이트에 리틀 엔디안 바이트 순서로 존재해야 합니다. 에러 시 ``-1``\\을 반환합니다."

#: ../../c-api/import.rst:205
msgid "Return value of ``-1`` upon failure."
msgstr "실패 시 ``-1``\\을 반환합니다."

#: ../../c-api/import.rst:211
msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` "
"is authoritative and should be used instead of this function."
msgstr ""
":pep:`3147` 형식 파이썬 바이트 코드 파일 이름의 매직 태그 문자열을 반환합니다. "
"``sys.implementation.cache_tag``\\의 값은 신뢰할 수 있고 이 함수 대신 사용해야 함에 유의하십시오."

#: ../../c-api/import.rst:219
msgid ""
"Return the dictionary used for the module administration (a.k.a. "
"``sys.modules``).  Note that this is a per-interpreter variable."
msgstr "모듈 관리에 사용되는 딕셔너리(일명 ``sys.modules``)를 반환합니다. 이것은 인터프리터마다 존재하는 변수임에 유의하십시오."

#: ../../c-api/import.rst:224
msgid ""
"Return the already imported module with the given name.  If the module "
"has not been imported yet then returns ``NULL`` but does not set an "
"error.  Returns ``NULL`` and sets an error if the lookup failed."
msgstr ""
"주어진 이름으로 이미 임포트 된 모듈을 반환합니다. 모듈이 아직 임포트 되지 않았다면 ``NULL``\\을 반환하지만 에러는 "
"설정하지 않습니다. 조회에 실패하면 ``NULL``\\을 반환하고 에러를 설정합니다."

#: ../../c-api/import.rst:232
#, fuzzy
msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`!pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a "
"hook is found that can handle the path item.  Return ``None`` if no hook "
"could; this tells our caller that the :term:`path based finder` could not"
" find a finder for this path item. Cache the result in "
":data:`sys.path_importer_cache`. Return a new reference to the finder "
"object."
msgstr ""
":data:`sys.path`/:attr:`pkg.__path__` 항목 *path*\\를 위한 파인더 객체를 반환합니다, "
":data:`sys.path_importer_cache` 딕셔너리에서 꺼낼 수도 있습니다. 아직 캐시 되지 않았으면, 경로 항목을 "
"처리할 수 있는 훅이 발견될 때까지 :data:`sys.path_hooks`\\를 탐색합니다. 훅이 없으면 ``None``\\을 "
"반환합니다; 이것은 호출자에게 :term:`경로 기반 파인더 <path based finder>`\\가 이 경로 항목에 대한 "
"파인더를 찾을 수 없음을 알려줍니다. :data:`sys.path_importer_cache`\\에 결과를 캐시 합니다. 파인더 "
"객체에 대한 새로운 참조를 반환합니다."

#: ../../c-api/import.rst:243
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if "
"the module is not found, and ``-1`` with an exception set if the "
"initialization failed.  To access the imported module on a successful "
"load, use :c:func:`PyImport_ImportModule`.  (Note the misnomer --- this "
"function would reload the module if it was already imported.)"
msgstr ""
"*name*\\이라는 이름의 프로즌 모듈(frozen module)을 로드합니다. 성공하면 ``1``\\을, 모듈을 찾지 못하면 "
"``0``\\을, 초기화에 실패하면 예외를 설정하고 ``-1``\\을 반환합니다. 로드가 성공할 때 임포트 된 모듈에 액세스하려면 "
":c:func:`PyImport_ImportModule`\\을 사용하십시오. (잘못된 이름에 주의하십시오 --- 이 함수는 모듈이 "
"이미 임포트 되었을 때 다시 로드합니다.)"

#: ../../c-api/import.rst:251
msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "``__file__`` 어트리뷰트는 더는 모듈에 설정되지 않습니다."

#: ../../c-api/import.rst:257
msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a"
" UTF-8 encoded string instead of a Unicode object."
msgstr ""
":c:func:`PyImport_ImportFrozenModuleObject`\\와 비슷하지만, name은 유니코드 객체 대신 "
"UTF-8로 인코딩된 문자열입니다."

#: ../../c-api/import.rst:265
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in "
"the Python source distribution).  Its definition, found in "
":file:`Include/import.h`, is::"
msgstr ""
"이것은 :program:`freeze` 유틸리티(파이썬 소스 배포의 :file:`Tools/freeze/`\\를 참조하십시오)가 "
"생성한 프로즌 모듈 디스크립터를 위한 구조체 형 정의입니다. :file:`Include/import.h`\\에 있는 정의는 다음과 "
"같습니다::"

#: ../../c-api/import.rst:270
#, python-brace-format
msgid ""
"struct _frozen {\n"
"    const char *name;\n"
"    const unsigned char *code;\n"
"    int size;\n"
"    bool is_package;\n"
"};"
msgstr ""

#: ../../c-api/import.rst:277
msgid ""
"The new ``is_package`` field indicates whether the module is a package or"
" not. This replaces setting the ``size`` field to a negative value."
msgstr ""

#: ../../c-api/import.rst:283
#, fuzzy
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When "
"a frozen module is imported, it is searched in this table.  Third-party "
"code could play tricks with this to provide a dynamically created "
"collection of frozen modules."
msgstr ""
"이 포인터는 :c:type:`struct _frozen` 레코드의 배열을 가리키도록 초기화되는데, 멤버가 모두 "
"``NULL``\\이나 0인 레코드로 끝납니다. 프로즌 모듈이 임포트 될 때, 이 테이블에서 검색됩니다. 제삼자 코드는 이것을 "
"사용하여 동적으로 생성된 프로즌 모듈 컬렉션을 제공할 수 있습니다."

#: ../../c-api/import.rst:291
msgid ""
"Add a single module to the existing table of built-in modules.  This is a"
" convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be "
"imported by the name *name*, and uses the function *initfunc* as the "
"initialization function called on the first attempted import.  This "
"should be called before :c:func:`Py_Initialize`."
msgstr ""
"기존의 내장 모듈 테이블에 단일 모듈을 추가합니다. 이것은 :c:func:`PyImport_ExtendInittab`\\을 감싸는 "
"편리한 래퍼인데, 테이블을 확장할 수 없으면 ``-1``\\을 반환합니다. 새 모듈은 *name*\\이라는 이름으로 임포트 될 수 "
"있으며, *initfunc* 함수를 처음 시도한 임포트에서 호출되는 초기화 함수로 사용합니다. "
":c:func:`Py_Initialize` 전에 호출해야 합니다."

#: ../../c-api/import.rst:301
#, fuzzy
msgid ""
"Structure describing a single entry in the list of built-in modules. "
"Programs which embed Python may use an array of these structures in "
"conjunction with :c:func:`PyImport_ExtendInittab` to provide additional "
"built-in modules. The structure consists of two members:"
msgstr ""
"내장 모듈 목록에 있는 단일 항목을 기술하는 구조체. 각 구조체는 인터프리터에 내장된 모듈의 이름과 초기화 함수를 제공합니다. "
"이름은 ASCII로 인코딩된 문자열입니다. 파이썬을 내장하는 프로그램은 "
":c:func:`PyImport_ExtendInittab`\\과 함께 이러한 구조체의 배열을 사용하여 추가 내장 모듈을 제공 할 수"
" 있습니다. 구조체는 :file:`Include/import.h`\\에서 다음과 같이 정의됩니다::"

#: ../../c-api/import.rst:309
msgid "The module name, as an ASCII encoded string."
msgstr ""

#: ../../c-api/import.rst:313
msgid "Initialization function for a module built into the interpreter."
msgstr ""

#: ../../c-api/import.rst:318
#, fuzzy
msgid ""
"Add a collection of modules to the table of built-in modules.  The "
"*newtab* array must end with a sentinel entry which contains ``NULL`` for"
" the :c:member:`~_inittab.name` field; failure to provide the sentinel "
"value can result in a memory fault. Returns ``0`` on success or ``-1`` if"
" insufficient memory could be allocated to extend the internal table.  In"
" the event of failure, no modules are added to the internal table.  This "
"must be called before :c:func:`Py_Initialize`."
msgstr ""
"내장 모듈 테이블에 모듈 컬렉션을 추가합니다. *newtab* 배열은 :attr:`name` 필드에 ``NULL``\\을 포함하는 "
"센티넬(sentinel) 항목으로 끝나야 합니다; 센티넬 값을 제공하지 않으면 메모리 오류가 발생할 수 있습니다. 성공하면 "
"``0``\\을, 내부 테이블을 확장하기 위한 메모리가 충분하지 않으면 ``-1``\\을 반환합니다. 실패하면, 내부 테이블에 "
"모듈이 추가되지 않습니다. :c:func:`Py_Initialize` 전에 호출해야 합니다."

#: ../../c-api/import.rst:325
msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab`"
" or :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""

#: ../../c-api/import.rst:11
msgid "package variable"
msgstr ""

#: ../../c-api/import.rst:11
msgid "__all__"
msgstr ""

#: ../../c-api/import.rst:11
msgid "__all__ (package variable)"
msgstr ""

#: ../../c-api/import.rst:11
#, fuzzy
msgid "modules (in module sys)"
msgstr "모듈 임포트 하기"

#: ../../c-api/import.rst:35 ../../c-api/import.rst:127
msgid "built-in function"
msgstr ""

#: ../../c-api/import.rst:35
msgid "__import__"
msgstr ""

#: ../../c-api/import.rst:127
msgid "compile"
msgstr ""

#: ../../c-api/import.rst:263
msgid "freeze utility"
msgstr ""

#~ msgid "Initialize the import mechanism.  For internal use only."
#~ msgstr "임포트 메커니즘을 초기화합니다. 내부 전용입니다."

#~ msgid "Empty the module table.  For internal use only."
#~ msgstr "모듈 테이블을 비웁니다. 내부 전용입니다."

#~ msgid "Finalize the import mechanism.  For internal use only."
#~ msgstr "임포트 메커니즘을 마무리합니다. 내부 전용입니다."

#~ msgid ""
#~ "This is a simplified interface to "
#~ ":c:func:`PyImport_ImportModuleEx` below, leaving the"
#~ " *globals* and *locals* arguments set "
#~ "to ``NULL`` and *level* set to 0."
#~ "  When the *name* argument contains a"
#~ " dot (when it specifies a submodule"
#~ " of a package), the *fromlist* "
#~ "argument is set to the list "
#~ "``['*']`` so that the return value "
#~ "is the named module rather than "
#~ "the top-level package containing it "
#~ "as would otherwise be the case.  "
#~ "(Unfortunately, this has an additional "
#~ "side effect when *name* in fact "
#~ "specifies a subpackage instead of a "
#~ "submodule: the submodules specified in "
#~ "the package's ``__all__`` variable are  "
#~ "loaded.)  Return a new reference to "
#~ "the imported module, or ``NULL`` with"
#~ " an exception set on failure.  A "
#~ "failing import of a module doesn't "
#~ "leave the module in :data:`sys.modules`."
#~ msgstr ""
#~ "이것은 아래 :c:func:`PyImport_ImportModuleEx` 에 대한"
#~ " 단순화된 인터페이스입니다. *globals*\\와 *locals* 인자를"
#~ " ``NULL``\\로 설정하고 *level*\\은 0으로 설정합니다. "
#~ "*name* 인자에 점이 포함되면 (패키지의 서브 모듈을"
#~ " 지정할 때), *fromlist* 인자는 리스트 "
#~ "``['*']``\\로 설정해서 반환 값이 그렇지 않았을 때"
#~ " 반환되는 최상위 수준 패키지 대신에 이름 지정된 "
#~ "모듈이 되도록 합니다. (안타깝게도, *name*\\이 실제로 "
#~ "서브 모듈 대신 서브 패키지를 지정하면 추가적인 "
#~ "부작용이 발생합니다: 패키지의 ``__all__`` 변수에 지정된 "
#~ "서브 모듈들이 로드됩니다.) 임포트 한 모듈에 대한 "
#~ "새로운 참조를 반환하거나 실패 시 예외가 설정된 "
#~ "``NULL``\\을 반환합니다. 모듈을 임포트 하는 데 "
#~ "실패하면 :data:`sys.modules`\\에 모듈을 남기지 않습니다."

