# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/conversion.rst:6
msgid "String conversion and formatting"
msgstr "문자열 변환과 포매팅"

#: ../../c-api/conversion.rst:8
msgid "Functions for number conversion and formatted string output."
msgstr "숫자 변환과 포맷된 문자열 출력을 위한 함수."

#: ../../c-api/conversion.rst:13
msgid ""
"Output not more than *size* bytes to *str* according to the format string"
" *format* and the extra arguments. See the Unix man page "
":manpage:`snprintf(3)`."
msgstr ""
"포맷 문자열 *format* 과 추가 인자에 따라 *size* 바이트를 넘지 않도록 *str*\\로 출력합니다. 유닉스 매뉴얼 "
"페이지 :manpage:`snprintf(3)`\\를 보십시오."

#: ../../c-api/conversion.rst:19
msgid ""
"Output not more than *size* bytes to *str* according to the format string"
" *format* and the variable argument list *va*. Unix man page "
":manpage:`vsnprintf(3)`."
msgstr ""
"포맷 문자열 *format* 과 가변 인자 목록 *va*\\에 따라 *size* 바이트를 넘지 않도록 *str*\\로 출력합니다. "
"유닉스 매뉴얼 페이지 :manpage:`vsnprintf(3)`\\를 보십시오."

#: ../../c-api/conversion.rst:23
msgid ""
":c:func:`PyOS_snprintf` and :c:func:`PyOS_vsnprintf` wrap the Standard C "
"library functions :c:func:`snprintf` and :c:func:`vsnprintf`. Their "
"purpose is to guarantee consistent behavior in corner cases, which the "
"Standard C functions do not."
msgstr ""
":c:func:`PyOS_snprintf`\\와 :c:func:`PyOS_vsnprintf`\\는 표준 C 라이브러리 함수 "
":c:func:`snprintf`\\와 :c:func:`vsnprintf`\\를 감쌉니다. 그들의 목적은 경계 조건에서 표준 C "
"함수가 제공하지 않는 수준의 일관된 동작을 보장하는 것입니다."

#: ../../c-api/conversion.rst:28
msgid ""
"The wrappers ensure that ``str[size-1]`` is always ``'\\0'`` upon return."
" They never write more than *size* bytes (including the trailing "
"``'\\0'``) into str. Both functions require that ``str != NULL``, ``size "
"> 0``, ``format != NULL`` and ``size < INT_MAX``. Note that this means "
"there is no equivalent to the C99 ``n = snprintf(NULL, 0, ...)`` which "
"would determine the necessary buffer size."
msgstr ""
"래퍼는 반환 시 ``str[size-1]``\\이 항상 ``'\\0'``\\이 되도록 합니다. str에 *size* 바이트(후행 "
"``'\\0'`` 포함)를 초과해서 쓰지 않습니다. 두 함수 모두 ``str != NULL``, ``size > 0``, "
"``format != NULL`` 및 ``size < INT_MAX``\\를 요구합니다. 이는 필요한 버퍼 크기를 결정하는 C99 "
"``n = snprintf(NULL, 0, ...)``\\에 해당하는 것이 없다는 뜻임에 유의하십시오."

#: ../../c-api/conversion.rst:34
msgid ""
"The return value (*rv*) for these functions should be interpreted as "
"follows:"
msgstr "이 함수들의 반환 값(*rv*)은 다음과 같이 해석되어야 합니다:"

#: ../../c-api/conversion.rst:36
msgid ""
"When ``0 <= rv < size``, the output conversion was successful and *rv* "
"characters were written to *str* (excluding the trailing ``'\\0'`` byte "
"at ``str[rv]``)."
msgstr ""
"``0 <= rv < size`` 일 때, 출력 변환에 성공했으며 *rv* 문자가 *str*\\에 기록되었습니다 "
"(``str[rv]``\\의 후행 ``'\\0'`` 바이트 제외)."

#: ../../c-api/conversion.rst:40
msgid ""
"When ``rv >= size``, the output conversion was truncated and a buffer "
"with ``rv + 1`` bytes would have been needed to succeed. ``str[size-1]`` "
"is ``'\\0'`` in this case."
msgstr ""
"``rv >= size`` 일 때, 출력 변환이 잘렸고 성공하려면 ``rv + 1`` 바이트의 버퍼가 필요합니다. "
"``str[size-1]``\\은 이때 ``'\\0'``\\입니다."

#: ../../c-api/conversion.rst:44
msgid ""
"When ``rv < 0``, \"something bad happened.\" ``str[size-1]`` is ``'\\0'``"
" in this case too, but the rest of *str* is undefined. The exact cause of"
" the error depends on the underlying platform."
msgstr ""
"``rv < 0`` 일 때, \"뭔가 나쁜 일이 일어났습니다.\" 이때도 ``str[size-1]``\\은 "
"``'\\0'``\\이지만, *str*\\의 나머지는 정의되지 않습니다. 에러의 정확한 원인은 하부 플랫폼에 따라 다릅니다."

#: ../../c-api/conversion.rst:49
msgid ""
"The following functions provide locale-independent string to number "
"conversions."
msgstr "다음 함수는 로케일 독립적인 문자열에서 숫자로의 변환을 제공합니다."

#: ../../c-api/conversion.rst:53
msgid ""
"Convert the initial part of the string in ``str`` to an :c:expr:`unsigned"
" long` value according to the given ``base``, which must be between ``2``"
" and ``36`` inclusive, or be the special value ``0``."
msgstr ""

#: ../../c-api/conversion.rst:57
msgid ""
"Leading white space and case of characters are ignored.  If ``base`` is "
"zero it looks for a leading ``0b``, ``0o`` or ``0x`` to tell which base."
"  If these are absent it defaults to ``10``.  Base must be 0 or between 2"
" and 36 (inclusive).  If ``ptr`` is non-``NULL`` it will contain a "
"pointer to the end of the scan."
msgstr ""

#: ../../c-api/conversion.rst:63
msgid ""
"If the converted value falls out of range of corresponding return type, "
"range error occurs (:c:data:`errno` is set to :c:macro:`!ERANGE`) and "
":c:macro:`!ULONG_MAX` is returned.  If no conversion can be performed, "
"``0`` is returned."
msgstr ""

#: ../../c-api/conversion.rst:68
msgid "See also the Unix man page :manpage:`strtoul(3)`."
msgstr ""

#: ../../c-api/conversion.rst:75
msgid ""
"Convert the initial part of the string in ``str`` to an :c:expr:`long` "
"value according to the given ``base``, which must be between ``2`` and "
"``36`` inclusive, or be the special value ``0``."
msgstr ""

#: ../../c-api/conversion.rst:79
msgid ""
"Same as :c:func:`PyOS_strtoul`, but return a :c:expr:`long` value instead"
" and :c:macro:`LONG_MAX` on overflows."
msgstr ""

#: ../../c-api/conversion.rst:82
msgid "See also the Unix man page :manpage:`strtol(3)`."
msgstr ""

#: ../../c-api/conversion.rst:89
msgid ""
"Convert a string ``s`` to a :c:expr:`double`, raising a Python exception "
"on failure.  The set of accepted strings corresponds to the set of "
"strings accepted by Python's :func:`float` constructor, except that ``s``"
" must not have leading or trailing whitespace. The conversion is "
"independent of the current locale."
msgstr ""
"문자열 ``s``\\를 :c:expr:`double`\\로 변환하고, 실패 시 파이썬 예외를 발생시킵니다. 허용되는 문자열 집합은 "
"``s``\\가 선행이나 후행 공백을 가질 수 없다는 점을 제외하고는 파이썬의 :func:`float` 생성자가 허용하는 문자열 "
"집합에 대응합니다. 변환은 현재 로케일과 독립적입니다."

#: ../../c-api/conversion.rst:95
msgid ""
"If ``endptr`` is ``NULL``, convert the whole string.  Raise "
":exc:`ValueError` and return ``-1.0`` if the string is not a valid "
"representation of a floating-point number."
msgstr ""
"``endptr``\\이 ``NULL``\\이면, 전체 문자열을 변환합니다. 문자열이 부동 소수점 숫자의 유효한 표현이 아니면 "
":exc:`ValueError`\\를 발생시키고 ``-1.0``\\을 반환합니다."

#: ../../c-api/conversion.rst:99
msgid ""
"If endptr is not ``NULL``, convert as much of the string as possible and "
"set ``*endptr`` to point to the first unconverted character.  If no "
"initial segment of the string is the valid representation of a floating-"
"point number, set ``*endptr`` to point to the beginning of the string, "
"raise ValueError, and return ``-1.0``."
msgstr ""
"endptr이 ``NULL``\\이 아니면, 가능한 한 많은 문자열을 변환하고 ``*endptr``\\이 변환되지 않은 첫 번째 "
"문자를 가리키도록 설정합니다. 문자열의 초기 세그먼트가 부동 소수점 숫자의 유효한 표현이 아니면, ``*endptr``\\이 "
"문자열의 시작을 가리키도록 설정하고, ValueError를 발생시키고 ``-1.0``\\을 반환합니다."

#: ../../c-api/conversion.rst:106
msgid ""
"If ``s`` represents a value that is too large to store in a float (for "
"example, ``\"1e500\"`` is such a string on many platforms) then if "
"``overflow_exception`` is ``NULL`` return ``Py_HUGE_VAL`` (with an "
"appropriate sign) and don't set any exception.  Otherwise, "
"``overflow_exception`` must point to a Python exception object; raise "
"that exception and return ``-1.0``.  In both cases, set ``*endptr`` to "
"point to the first character after the converted value."
msgstr ""
"``s``\\가 float에 저장하기에 너무 큰 값을 나타낼 때 (예를 들어, 여러 플랫폼에서 ``\"1e500\"``\\가 그런 "
"문자열입니다), ``overflow_exception``\\가 ``NULL``\\이면 (적절한 부호와 함께) "
"``Py_HUGE_VAL``\\을 반환하고, 어떤 예외도 설정하지 않습니다. 그렇지 않으면, "
"``overflow_exception``\\은 파이썬 예외 객체를 가리켜야 합니다; 그 예외를 발생시키고 ``-1.0``\\를 "
"반환합니다. 두 경우 모두, 변환된 값 다음의 첫 번째 문자를 가리키도록 ``*endptr``\\을 설정합니다."

#: ../../c-api/conversion.rst:114
msgid ""
"If any other error occurs during the conversion (for example an out-of-"
"memory error), set the appropriate Python exception and return ``-1.0``."
msgstr "변환 중 다른 에러가 발생하면 (예를 들어 메모리 부족 에러), 적절한 파이썬 예외를 설정하고 ``-1.0``\\을 반환합니다."

#: ../../c-api/conversion.rst:123
msgid ""
"Convert a :c:expr:`double` *val* to a string using supplied "
"*format_code*, *precision*, and *flags*."
msgstr ""
"제공된 *format_code*, *precision* 및 *flags*\\를 사용하여 :c:expr:`double` "
"*val*\\을 문자열로 변환합니다."

#: ../../c-api/conversion.rst:126
msgid ""
"*format_code* must be one of ``'e'``, ``'E'``, ``'f'``, ``'F'``, ``'g'``,"
" ``'G'`` or ``'r'``.  For ``'r'``, the supplied *precision* must be 0 and"
" is ignored.  The ``'r'`` format code specifies the standard :func:`repr`"
" format."
msgstr ""
"*format_code*\\는 ``'e'``, ``'E'``, ``'f'``, ``'F'``, ``'g'``, ``'G'`` 또는 "
"``'r'`` 중 하나여야 합니다. ``'r'``\\의 경우, 제공된 *precision*\\은 0이어야 하며 무시됩니다. "
"``'r'`` 포맷 코드는 표준 :func:`repr` 형식을 지정합니다."

#: ../../c-api/conversion.rst:131
msgid ""
"*flags* can be zero or more of the values ``Py_DTSF_SIGN``, "
"``Py_DTSF_ADD_DOT_0``, or ``Py_DTSF_ALT``, or-ed together:"
msgstr ""
"*flags*\\는 ``Py_DTSF_SIGN``, ``Py_DTSF_ADD_DOT_0`` 또는 ``Py_DTSF_ALT`` 값을 "
"0개 이상 함께 or 할 수 있습니다:"

#: ../../c-api/conversion.rst:134
msgid ""
"``Py_DTSF_SIGN`` means to always precede the returned string with a sign "
"character, even if *val* is non-negative."
msgstr "``Py_DTSF_SIGN``\\은 *val*\\가 음수가 아닐 때도 항상 반환된 문자열 앞에 부호 문자가 오는 것을 뜻합니다."

#: ../../c-api/conversion.rst:137
msgid ""
"``Py_DTSF_ADD_DOT_0`` means to ensure that the returned string will not "
"look like an integer."
msgstr "``Py_DTSF_ADD_DOT_0``\\은 반환된 문자열이 정수처럼 보이지 않도록 하는 것을 뜻합니다."

#: ../../c-api/conversion.rst:140
msgid ""
"``Py_DTSF_ALT`` means to apply \"alternate\" formatting rules.  See the "
"documentation for the :c:func:`PyOS_snprintf` ``'#'`` specifier for "
"details."
msgstr ""
"``Py_DTSF_ALT``\\는 \"대체\" 포매팅 규칙을 적용하는 것을 뜻합니다. 자세한 내용은 "
":c:func:`PyOS_snprintf` ``'#'`` 지정자에 대한 설명서를 참조하십시오."

#: ../../c-api/conversion.rst:144
msgid ""
"If *ptype* is non-``NULL``, then the value it points to will be set to "
"one of ``Py_DTST_FINITE``, ``Py_DTST_INFINITE``, or ``Py_DTST_NAN``, "
"signifying that *val* is a finite number, an infinite number, or not a "
"number, respectively."
msgstr ""
"*ptype*\\이 ``NULL``\\이 아니면, 포인터가 가리키는 값은 ``Py_DTST_FINITE``, "
"``Py_DTST_INFINITE`` 또는 ``Py_DTST_NAN`` 중 하나로 설정되어, *val*\\가 각각 유한 수, 무한 "
"수 또는 NaN임을 나타냅니다."

#: ../../c-api/conversion.rst:148
msgid ""
"The return value is a pointer to *buffer* with the converted string or "
"``NULL`` if the conversion failed. The caller is responsible for freeing "
"the returned string by calling :c:func:`PyMem_Free`."
msgstr ""
"반환 값은 변환된 문자열이 있는 *buffer*\\에 대한 포인터이거나, 변환에 실패하면 ``NULL``\\입니다. 호출자는 "
":c:func:`PyMem_Free`\\를 호출하여 반환된 문자열을 해제해야 합니다."

#: ../../c-api/conversion.rst:157
msgid ""
"Case insensitive comparison of strings. The function works almost "
"identically to :c:func:`!strcmp` except that it ignores the case."
msgstr ""
"대소 문자 구분 없는 문자열 비교. 이 함수는 대소 문자를 무시한다는 점만 제외하면 :c:func:`!strcmp`\\와 거의 같게"
" 작동합니다."

#: ../../c-api/conversion.rst:163
msgid ""
"Case insensitive comparison of strings. The function works almost "
"identically to :c:func:`!strncmp` except that it ignores the case."
msgstr ""
"대소 문자 구분 없는 문자열 비교. 이 함수는 대소 문자를 무시한다는 점만 제외하면 :c:func:`!strncmp`\\와 거의 "
"같게 작동합니다."

#~ msgid ""
#~ "If the platform doesn't have "
#~ ":c:func:`vsnprintf` and the buffer size "
#~ "needed to avoid truncation exceeds "
#~ "*size* by more than 512 bytes, "
#~ "Python aborts with a :c:func:`Py_FatalError`."
#~ msgstr ""
#~ "플랫폼에 :c:func:`vsnprintf`\\가 없고 잘림을 방지하는 "
#~ "데 필요한 버퍼 크기가 *size*\\를 512바이트보다 더"
#~ " 초과하면, 파이썬은 :c:func:`Py_FatalError`\\로 중단됩니다."

