# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/dict.rst:6
msgid "Dictionary Objects"
msgstr "딕셔너리 객체"

#: ../../c-api/dict.rst:13
msgid "This subtype of :c:type:`PyObject` represents a Python dictionary object."
msgstr "이 :c:type:`PyObject`\\의 서브 형은 파이썬 딕셔너리 객체를 나타냅니다."

#: ../../c-api/dict.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python dictionary "
"type.  This is the same object as :class:`dict` in the Python layer."
msgstr ""
"이 :c:type:`PyTypeObject` 인스턴스는 파이썬 딕셔너리 형을 나타냅니다. 이것은 파이썬 계층의 "
":class:`dict`\\와 같은 객체입니다."

#: ../../c-api/dict.rst:24
msgid ""
"Return true if *p* is a dict object or an instance of a subtype of the "
"dict type.  This function always succeeds."
msgstr "*p*\\가 dict 객체이거나 dict 형의 서브 형의 인스턴스면 참을 반환합니다. 이 함수는 항상 성공합니다."

#: ../../c-api/dict.rst:30
msgid ""
"Return true if *p* is a dict object, but not an instance of a subtype of "
"the dict type.  This function always succeeds."
msgstr "*p*\\가 dict 객체이지만, dict 형의 서브 형의 인스턴스는 아니면 참을 반환합니다. 이 함수는 항상 성공합니다."

#: ../../c-api/dict.rst:36
msgid "Return a new empty dictionary, or ``NULL`` on failure."
msgstr "새로운 빈 딕셔너리를 반환하거나, 실패하면 ``NULL``\\을 반환합니다."

#: ../../c-api/dict.rst:41
msgid ""
"Return a :class:`types.MappingProxyType` object for a mapping which "
"enforces read-only behavior.  This is normally used to create a view to "
"prevent modification of the dictionary for non-dynamic class types."
msgstr ""
"읽기 전용 동작을 강제하는 매핑을 위한 :class:`types.MappingProxyType` 객체를 반환합니다. 이것은 "
"일반적으로 비 동적 클래스 형을 위한 딕셔너리의 수정을 방지하기 위해 뷰를 만드는 데 사용됩니다."

#: ../../c-api/dict.rst:48
msgid "Empty an existing dictionary of all key-value pairs."
msgstr "기존 딕셔너리의 모든 키-값 쌍을 비웁니다."

#: ../../c-api/dict.rst:53
msgid ""
"Determine if dictionary *p* contains *key*.  If an item in *p* is matches"
" *key*, return ``1``, otherwise return ``0``.  On error, return ``-1``. "
"This is equivalent to the Python expression ``key in p``."
msgstr ""
"딕셔너리 *p*\\에 *key*\\가 포함되어 있는지 확인합니다. *p*\\의 항목이 *key*\\와 일치하면 ``1``\\을 "
"반환하고, 그렇지 않으면 ``0``\\을 반환합니다. 에러면 ``-1``\\을 반환합니다. 이는 파이썬 표현식 ``key in "
"p``\\와 동등합니다."

#: ../../c-api/dict.rst:60
msgid ""
"This is the same as :c:func:`PyDict_Contains`, but *key* is specified as "
"a :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"이것은 :c:func:`PyDict_Contains`\\와 같지만, *key*\\가 :c:expr:`PyObject*`\\가 아닌 "
":c:expr:`const char*` UTF-8 인코딩된 바이트 문자열로 지정됩니다."

#: ../../c-api/dict.rst:69
msgid "Return a new dictionary that contains the same key-value pairs as *p*."
msgstr "*p*\\와 같은 키-값 쌍을 포함하는 새 딕셔너리를 반환합니다."

#: ../../c-api/dict.rst:74
msgid ""
"Insert *val* into the dictionary *p* with a key of *key*.  *key* must be "
":term:`hashable`; if it isn't, :exc:`TypeError` will be raised. Return "
"``0`` on success or ``-1`` on failure.  This function *does not* steal a "
"reference to *val*."
msgstr ""
"딕셔너리 *p*\\에 *val*\\을 *key* 키로 삽입합니다. *key*\\는 :term:`해시 가능 "
"<hashable>`\\해야 합니다. 그렇지 않으면 :exc:`TypeError`\\가 발생합니다. 성공하면 ``0``\\을, "
"실패하면 ``-1``\\을 반환합니다. 이 함수는 *val*\\에 대한 참조를 훔치지 *않습니다*."

#: ../../c-api/dict.rst:82
msgid ""
"This is the same as :c:func:`PyDict_SetItem`, but *key* is specified as a"
" :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"이것은 :c:func:`PyDict_SetItem`\\와 같지만, *key*\\가 :c:expr:`PyObject*`\\가 아닌 "
":c:expr:`const char*` UTF-8 인코딩된 바이트 문자열로 지정됩니다."

#: ../../c-api/dict.rst:89
msgid ""
"Remove the entry in dictionary *p* with key *key*. *key* must be "
":term:`hashable`; if it isn't, :exc:`TypeError` is raised. If *key* is "
"not in the dictionary, :exc:`KeyError` is raised. Return ``0`` on success"
" or ``-1`` on failure."
msgstr ""
"딕셔너리 *p*\\에서 키가 *key*\\인 항목을 제거합니다. *key*\\는 :term:`해시 가능 <hashable>`\\해야"
" 합니다. 그렇지 않으면 :exc:`TypeError`\\가 발생합니다. *key*\\가 딕셔너리에 없으면, "
":exc:`KeyError`\\가 발생합니다. 성공하면 ``0``\\을, 실패하면 ``-1``\\을 반환합니다."

#: ../../c-api/dict.rst:97
msgid ""
"This is the same as :c:func:`PyDict_DelItem`, but *key* is specified as a"
" :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"이것은 :c:func:`PyDict_DelItem`\\와 같지만, *key*\\가 :c:expr:`PyObject*`\\가 아닌 "
":c:expr:`const char*` UTF-8 인코딩된 바이트 문자열로 지정됩니다."

#: ../../c-api/dict.rst:104
msgid ""
"Return a new :term:`strong reference` to the object from dictionary *p* "
"which has a key *key*:"
msgstr ""

#: ../../c-api/dict.rst:107
msgid ""
"If the key is present, set *\\*result* to a new :term:`strong reference` "
"to the value and return ``1``."
msgstr ""

#: ../../c-api/dict.rst:109
msgid "If the key is missing, set *\\*result* to ``NULL`` and return ``0``."
msgstr ""

#: ../../c-api/dict.rst:110 ../../c-api/dict.rst:207
msgid "On error, raise an exception and return ``-1``."
msgstr ""

#: ../../c-api/dict.rst:114
msgid "See also the :c:func:`PyObject_GetItem` function."
msgstr ""

#: ../../c-api/dict.rst:119
msgid ""
"Return a :term:`borrowed reference` to the object from dictionary *p* "
"which has a key *key*.  Return ``NULL`` if the key *key* is missing "
"*without* setting an exception."
msgstr ""
"딕셔너리 *p*\\에서 키가 *key*\\인 객체에 대한 :term:`빌린 참조 <borrowed reference>`\\를 "
"반환합니다. *key* 키가 없으면 예외를 설정하지 *않고* ``NULL``\\을 반환합니다."

#: ../../c-api/dict.rst:125
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and "
":meth:`~object.__eq__` methods are silently ignored. Prefer the "
":c:func:`PyDict_GetItemWithError` function instead."
msgstr ""
":meth:`~object.__hash__`\\와 :meth:`~object.__eq__` 메서드를 호출하는 동안 발생하는 예외는 "
"조용히 무시됩니다. 대신 :c:func:`PyDict_GetItemWithError` 함수를 사용하십시오."

#: ../../c-api/dict.rst:129
msgid ""
"Calling this API without :term:`GIL` held had been allowed for historical"
" reason. It is no longer allowed."
msgstr ""

#: ../../c-api/dict.rst:136
msgid ""
"Variant of :c:func:`PyDict_GetItem` that does not suppress exceptions. "
"Return ``NULL`` **with** an exception set if an exception occurred.  "
"Return ``NULL`` **without** an exception set if the key wasn't present."
msgstr ""
"예외를 억제하지 않는 :c:func:`PyDict_GetItem`\\의 변형입니다. 예외가 발생하면 예외를 **설정하고** "
"``NULL``\\을 반환합니다. 키가 없으면 예외를 설정하지 **않고** ``NULL``\\을 반환합니다."

#: ../../c-api/dict.rst:144
msgid ""
"This is the same as :c:func:`PyDict_GetItem`, but *key* is specified as a"
" :c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"이것은 :c:func:`PyDict_GetItem`\\와 같지만, *key*\\가 :c:expr:`PyObject*`\\가 아닌 "
":c:expr:`const char*` UTF-8로 인코딩된 바이트 문자열로 지정됩니다."

#: ../../c-api/dict.rst:150
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and "
":meth:`~object.__eq__` methods or while creating the temporary "
":class:`str` object are silently ignored. Prefer using the "
":c:func:`PyDict_GetItemWithError` function with your own "
":c:func:`PyUnicode_FromString` *key* instead."
msgstr ""
":meth:`~object.__hash__`\\와 :meth:`~object.__eq__` 메서드를 호출하는 동안이나 임시 "
":class:`str` 객체를 만드는 동안 발생하는 예외는 조용히 무시됩니다. 대신 자체 "
":c:func:`PyUnicode_FromString` *key*\\와 함께 "
":c:func:`PyDict_GetItemWithError` 함수를 사용하는 것이 좋습니다."

#: ../../c-api/dict.rst:159
msgid ""
"Similar to :c:func:`PyDict_GetItemRef`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"이것은 :c:func:`PyDict_GetItemRef`\\와 유시하지만, *key*\\가 :c:expr:`PyObject*`\\가"
" 아닌 :c:expr:`const char*` UTF-8로 인코딩된 바이트 문자열로 지정됩니다."

#: ../../c-api/dict.rst:168
msgid ""
"This is the same as the Python-level :meth:`dict.setdefault`.  If "
"present, it returns the value corresponding to *key* from the dictionary "
"*p*.  If the key is not in the dict, it is inserted with value "
"*defaultobj* and *defaultobj* is returned.  This function evaluates the "
"hash function of *key* only once, instead of evaluating it independently "
"for the lookup and the insertion."
msgstr ""
"이것은 파이썬 수준의 :meth:`dict.setdefault`\\와 같습니다. 존재하면, 딕셔너리 *p*\\에서 *key*\\에 "
"해당하는 값을 반환합니다. 키가 dict에 없으면, 값 *defaultobj*\\로 삽입되고, *defaultobj*\\가 "
"반환됩니다. 이 함수는 *key*\\의 해시 함수를 조회 및 삽입을 위해 독립적으로 평가하는 대신 한 번만 평가합니다."

#: ../../c-api/dict.rst:179
msgid ""
"Inserts *default_value* into the dictionary *p* with a key of *key* if "
"the key is not already present in the dictionary. If *result* is not "
"``NULL``, then *\\*result* is set to a :term:`strong reference` to either"
" *default_value*, if the key was not present, or the existing value, if "
"*key* was already present in the dictionary. Returns ``1`` if the key was"
" present and *default_value* was not inserted, or ``0`` if the key was "
"not present and *default_value* was inserted. On failure, returns ``-1``,"
" sets an exception, and sets ``*result`` to ``NULL``."
msgstr ""

#: ../../c-api/dict.rst:189
msgid ""
"For clarity: if you have a strong reference to *default_value* before "
"calling this function, then after it returns, you hold a strong reference"
" to both *default_value* and *\\*result* (if it's not ``NULL``). These "
"may refer to the same object: in that case you hold two separate "
"references to it."
msgstr ""

#: ../../c-api/dict.rst:200
msgid ""
"Remove *key* from dictionary *p* and optionally return the removed value."
" Do not raise :exc:`KeyError` if the key missing."
msgstr ""

#: ../../c-api/dict.rst:203
msgid ""
"If the key is present, set *\\*result* to a new reference to the removed "
"value if *result* is not ``NULL``, and return ``1``."
msgstr ""

#: ../../c-api/dict.rst:205
msgid ""
"If the key is missing, set *\\*result* to ``NULL`` if *result* is not "
"``NULL``, and return ``0``."
msgstr ""

#: ../../c-api/dict.rst:209
msgid ""
"Similar to :meth:`dict.pop`, but without the default value and not "
"raising :exc:`KeyError` if the key missing."
msgstr ""

#: ../../c-api/dict.rst:217
msgid ""
"Similar to :c:func:`PyDict_Pop`, but *key* is specified as a "
":c:expr:`const char*` UTF-8 encoded bytes string, rather than a "
":c:expr:`PyObject*`."
msgstr ""
"이것은 :c:func:`PyDict_Pop`\\와 유사하지만, *key*\\가 :c:expr:`PyObject*`\\가 아닌 "
":c:expr:`const char*` UTF-8로 인코딩된 바이트 문자열로 지정됩니다."

#: ../../c-api/dict.rst:226
msgid ""
"Return a :c:type:`PyListObject` containing all the items from the "
"dictionary."
msgstr "딕셔너리의 모든 항목을 포함하는 :c:type:`PyListObject`\\를 반환합니다."

#: ../../c-api/dict.rst:231
msgid ""
"Return a :c:type:`PyListObject` containing all the keys from the "
"dictionary."
msgstr "딕셔너리의 모든 키를 포함하는 :c:type:`PyListObject`\\를 반환합니다."

#: ../../c-api/dict.rst:236
msgid ""
"Return a :c:type:`PyListObject` containing all the values from the "
"dictionary *p*."
msgstr "딕셔너리 *p*\\의 모든 값을 포함하는 :c:type:`PyListObject`\\를 반환합니다."

#: ../../c-api/dict.rst:244
msgid ""
"Return the number of items in the dictionary.  This is equivalent to "
"``len(p)`` on a dictionary."
msgstr "딕셔너리에 있는 항목의 수를 반환합니다. 이는 딕셔너리에 대한 ``len(p)``\\와 동등합니다."

#: ../../c-api/dict.rst:250
msgid ""
"Iterate over all key-value pairs in the dictionary *p*.  The "
":c:type:`Py_ssize_t` referred to by *ppos* must be initialized to ``0`` "
"prior to the first call to this function to start the iteration; the "
"function returns true for each pair in the dictionary, and false once all"
" pairs have been reported.  The parameters *pkey* and *pvalue* should "
"either point to :c:expr:`PyObject*` variables that will be filled in with"
" each key and value, respectively, or may be ``NULL``.  Any references "
"returned through them are borrowed.  *ppos* should not be altered during "
"iteration. Its value represents offsets within the internal dictionary "
"structure, and since the structure is sparse, the offsets are not "
"consecutive."
msgstr ""
"딕셔너리 *p*\\의 모든 키-값 쌍을 이터레이트 합니다. *ppos*\\에 의해 참조된 "
":c:type:`Py_ssize_t`\\는, 이터레이션을 시작하기 위해 이 함수를 처음 호출하기 전에 ``0``\\으로 초기화되어야"
" 합니다; 이 함수는 딕셔너리의 각 쌍에 대해 참을 반환하고, 모든 쌍이 보고되었으면 거짓을 반환합니다. 매개 변수 "
"*pkey*\\와 *pvalue*\\는 각각 키와 값으로 채울 :c:expr:`PyObject*` 변수를 가리 키거나, "
"``NULL`` 일 수 있습니다. 이들을 통해 반환된 참조는 모두 빌린(borrowed) 것입니다. 이터레이션 중에 "
"*ppos*\\를 변경하면 안 됩니다. 이 값은 내부 딕셔너리 구조 내의 오프셋을 나타내며, 구조가 희박하므로 오프셋이 연속되지 "
"않습니다."

#: ../../c-api/dict.rst:261
msgid "For example::"
msgstr "예를 들면::"

#: ../../c-api/dict.rst:263
#, python-brace-format
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* 값으로 흥미로운 작업을 수행합니다... */\n"
"    ...\n"
"}"

#: ../../c-api/dict.rst:271
msgid ""
"The dictionary *p* should not be mutated during iteration.  It is safe to"
" modify the values of the keys as you iterate over the dictionary, but "
"only so long as the set of keys does not change.  For example::"
msgstr ""
"딕셔너리 *p*\\는 이터레이션 중에 변경해서는 안 됩니다. 딕셔너리를 이터레이트 할 때 값을 변경하는 것은 안전하지만, 키 집합이"
" 변경되지 않는 한만 그렇습니다. 예를 들면::"

#: ../../c-api/dict.rst:275
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"

#: ../../c-api/dict.rst:293
msgid ""
"The function is not thread-safe in the :term:`free-threaded <free "
"threading>` build without external synchronization.  You can use "
":c:macro:`Py_BEGIN_CRITICAL_SECTION` to lock the dictionary while "
"iterating over it::"
msgstr ""

#: ../../c-api/dict.rst:298
#, python-brace-format
msgid ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"Py_BEGIN_CRITICAL_SECTION(self->dict);\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"

#: ../../c-api/dict.rst:307
msgid ""
"Iterate over mapping object *b* adding key-value pairs to dictionary *a*."
" *b* may be a dictionary, or any object supporting "
":c:func:`PyMapping_Keys` and :c:func:`PyObject_GetItem`. If *override* is"
" true, existing pairs in *a* will be replaced if a matching key is found "
"in *b*, otherwise pairs will only be added if there is not a matching key"
" in *a*. Return ``0`` on success or ``-1`` if an exception was raised."
msgstr ""
"매핑 객체 *b*\\를 이터레이트 하면서, 키-값 쌍을 딕셔너리 *a*\\에 추가합니다. *b*\\는 딕셔너리거나 "
":c:func:`PyMapping_Keys`\\와 :c:func:`PyObject_GetItem`\\를 지원하는 모든 객체일 수 "
"있습니다. *override*\\가 참이면, *a*\\에 있는 기존 쌍이 *b*\\에서 일치하는 키가 있으면 교체되고, 그렇지 "
"않으면 *a*\\와 일치하는 키가 없을 때만 쌍이 추가됩니다. 성공하면 ``0``\\을 반환하고, 예외가 발생하면 ``-1``\\을"
" 반환합니다."

#: ../../c-api/dict.rst:317
msgid ""
"This is the same as ``PyDict_Merge(a, b, 1)`` in C, and is similar to "
"``a.update(b)`` in Python except that :c:func:`PyDict_Update` doesn't "
"fall back to the iterating over a sequence of key value pairs if the "
"second argument has no \"keys\" attribute.  Return ``0`` on success or "
"``-1`` if an exception was raised."
msgstr ""
"이는 C에서 ``PyDict_Merge(a, b, 1)``\\와 같고, 두 번째 인자에 \"keys\" 어트리뷰트가 없을 때 "
":c:func:`PyDict_Update`\\가 키-값 쌍의 시퀀스에 대해 이터레이트 하지 않는다는 점만 제외하면, 파이썬에서 "
"``a.update(b)``\\와 유사합니다. 성공하면 ``0``\\을 반환하고, 예외가 발생하면 ``-1``\\을 반환합니다."

#: ../../c-api/dict.rst:326
msgid ""
"Update or merge into dictionary *a*, from the key-value pairs in *seq2*. "
"*seq2* must be an iterable object producing iterable objects of length 2,"
" viewed as key-value pairs.  In case of duplicate keys, the last wins if "
"*override* is true, else the first wins. Return ``0`` on success or "
"``-1`` if an exception was raised. Equivalent Python (except for the "
"return value)::"
msgstr ""
"*seq2*\\의 키-값 쌍으로 딕셔너리 *a*\\를 갱신하거나 병합합니다. *seq2*\\는 키-값 쌍으로 간주하는 길이 2의 "
"이터러블 객체를 생성하는 이터러블 객체여야 합니다. 중복 키가 있으면, *override*\\가 참이면 마지막이 승리하고, 그렇지 "
"않으면 첫 번째가 승리합니다. 성공 시 ``0``\\을 반환하고, 예외가 발생하면 ``-1``\\을 반환합니다. 동등한 파이썬은 "
"이렇습니다(반환 값 제외) ::"

#: ../../c-api/dict.rst:333
msgid ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"
msgstr ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"

#: ../../c-api/dict.rst:340
msgid ""
"Register *callback* as a dictionary watcher. Return a non-negative "
"integer id which must be passed to future calls to "
":c:func:`PyDict_Watch`. In case of error (e.g. no more watcher IDs "
"available), return ``-1`` and set an exception."
msgstr ""

#: ../../c-api/dict.rst:349
msgid ""
"Clear watcher identified by *watcher_id* previously returned from "
":c:func:`PyDict_AddWatcher`. Return ``0`` on success, ``-1`` on error "
"(e.g. if the given *watcher_id* was never registered.)"
msgstr ""

#: ../../c-api/dict.rst:357
msgid ""
"Mark dictionary *dict* as watched. The callback granted *watcher_id* by "
":c:func:`PyDict_AddWatcher` will be called when *dict* is modified or "
"deallocated. Return ``0`` on success or ``-1`` on error."
msgstr ""

#: ../../c-api/dict.rst:365
msgid ""
"Mark dictionary *dict* as no longer watched. The callback granted "
"*watcher_id* by :c:func:`PyDict_AddWatcher` will no longer be called when"
" *dict* is modified or deallocated. The dict must previously have been "
"watched by this watcher. Return ``0`` on success or ``-1`` on error."
msgstr ""

#: ../../c-api/dict.rst:374
msgid ""
"Enumeration of possible dictionary watcher events: "
"``PyDict_EVENT_ADDED``, ``PyDict_EVENT_MODIFIED``, "
"``PyDict_EVENT_DELETED``, ``PyDict_EVENT_CLONED``, "
"``PyDict_EVENT_CLEARED``, or ``PyDict_EVENT_DEALLOCATED``."
msgstr ""

#: ../../c-api/dict.rst:382
msgid "Type of a dict watcher callback function."
msgstr ""

#: ../../c-api/dict.rst:384
msgid ""
"If *event* is ``PyDict_EVENT_CLEARED`` or ``PyDict_EVENT_DEALLOCATED``, "
"both *key* and *new_value* will be ``NULL``. If *event* is "
"``PyDict_EVENT_ADDED`` or ``PyDict_EVENT_MODIFIED``, *new_value* will be "
"the new value for *key*. If *event* is ``PyDict_EVENT_DELETED``, *key* is"
" being deleted from the dictionary and *new_value* will be ``NULL``."
msgstr ""

#: ../../c-api/dict.rst:390
msgid ""
"``PyDict_EVENT_CLONED`` occurs when *dict* was previously empty and "
"another dict is merged into it. To maintain efficiency of this operation,"
" per-key ``PyDict_EVENT_ADDED`` events are not issued in this case; "
"instead a single ``PyDict_EVENT_CLONED`` is issued, and *key* will be the"
" source dictionary."
msgstr ""

#: ../../c-api/dict.rst:396
msgid ""
"The callback may inspect but must not modify *dict*; doing so could have "
"unpredictable effects, including infinite recursion. Do not trigger "
"Python code execution in the callback, as it could modify the dict as a "
"side effect."
msgstr ""

#: ../../c-api/dict.rst:400
msgid ""
"If *event* is ``PyDict_EVENT_DEALLOCATED``, taking a new reference in the"
" callback to the about-to-be-destroyed dictionary will resurrect it and "
"prevent it from being freed at this time. When the resurrected object is "
"destroyed later, any watcher callbacks active at that time will be called"
" again."
msgstr ""

#: ../../c-api/dict.rst:406
msgid ""
"Callbacks occur before the notified modification to *dict* takes place, "
"so the prior state of *dict* can be inspected."
msgstr ""

#: ../../c-api/dict.rst:409
msgid ""
"If the callback sets an exception, it must return ``-1``; this exception "
"will be printed as an unraisable exception using "
":c:func:`PyErr_WriteUnraisable`. Otherwise it should return ``0``."
msgstr ""

#: ../../c-api/dict.rst:413
msgid ""
"There may already be a pending exception set on entry to the callback. In"
" this case, the callback should return ``0`` with the same exception "
"still set. This means the callback may not call any other API that can "
"set an exception unless it saves and clears the exception state first, "
"and restores it before returning."
msgstr ""

#: ../../c-api/dict.rst:8
msgid "object"
msgstr "객체"

#: ../../c-api/dict.rst:8
msgid "dictionary"
msgstr "딕셔너리"

#: ../../c-api/dict.rst:242
msgid "built-in function"
msgstr "내장 함수"

#: ../../c-api/dict.rst:242
msgid "len"
msgstr "len"

#~ msgid ""
#~ "Insert *val* into the dictionary *p* "
#~ "using *key* as a key. *key* should"
#~ " be a :c:type:`const char*`.  The key"
#~ " object is created using "
#~ "``PyUnicode_FromString(key)``.  Return ``0`` on "
#~ "success or ``-1`` on failure.  This "
#~ "function *does not* steal a reference"
#~ " to *val*."
#~ msgstr ""
#~ "*key*\\를 키로 사용하여 딕셔너리 *p*\\에 *val*\\을"
#~ " 삽입합니다. *key*\\는 :c:type:`const char*`\\여야 "
#~ "합니다. 키 객체는 ``PyUnicode_FromString(key)``\\를 "
#~ "사용하여 만듭니다. 성공하면 ``0``\\을, 실패하면 ``-1``\\을"
#~ " 반환합니다. 이 함수는 *val*\\에 대한 참조를 "
#~ "훔치지 *않습니다*."

#~ msgid ""
#~ "Remove the entry in dictionary *p* "
#~ "which has a key specified by the"
#~ " string *key*. If *key* is not "
#~ "in the dictionary, :exc:`KeyError` is "
#~ "raised. Return ``0`` on success or "
#~ "``-1`` on failure."
#~ msgstr ""
#~ "딕셔너리 *p*\\에서 문자열 *key*\\로 지정된 키의 "
#~ "항목을 제거합니다. *key*\\가 딕셔너리에 없으면, "
#~ ":exc:`KeyError`\\가 발생합니다. 성공하면 ``0``\\을, 실패하면"
#~ " ``-1``\\을 반환합니다."

