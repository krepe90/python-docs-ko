# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/codec.rst:4
msgid "Codec registry and support functions"
msgstr "코덱 등록소와 지원 함수"

#: ../../c-api/codec.rst:8
msgid "Register a new codec search function."
msgstr "새로운 코덱 검색 함수를 등록합니다."

#: ../../c-api/codec.rst:10
msgid ""
"As side effect, this tries to load the :mod:`!encodings` package, if not "
"yet done, to make sure that it is always first in the list of search "
"functions."
msgstr ""
"부작용으로, 아직 로드되지 않았다면, :mod:`!encodings` 패키지를 로드하여 항상 검색 함수 목록의 첫 번째 항목이 "
"되도록 합니다."

#: ../../c-api/codec.rst:15
msgid ""
"Unregister a codec search function and clear the registry's cache. If the"
" search function is not registered, do nothing. Return 0 on success. "
"Raise an exception and return -1 on error."
msgstr ""

#: ../../c-api/codec.rst:23
msgid ""
"Return ``1`` or ``0`` depending on whether there is a registered codec "
"for the given *encoding*.  This function always succeeds."
msgstr ""
"지정된 *encoding*\\에 대해 등록된 코덱이 있는지에 따라 ``1`` 이나 ``0``\\을 반환합니다. 이 함수는 항상 "
"성공합니다."

#: ../../c-api/codec.rst:28
msgid "Generic codec based encoding API."
msgstr "일반 코덱 기반 인코딩 API."

#: ../../c-api/codec.rst:30
msgid ""
"*object* is passed through the encoder function found for the given "
"*encoding* using the error handling method defined by *errors*.  *errors*"
" may be ``NULL`` to use the default method defined for the codec.  Raises"
" a :exc:`LookupError` if no encoder can be found."
msgstr ""
"*object*\\는 *errors*\\로 정의된 에러 처리 방법을 사용하여 지정된 *encoding*\\에 대해 발견된 인코더 "
"함수로 전달됩니다. 코덱에 정의된 기본 방법을 사용하기 위해 *errors*\\가 ``NULL`` 일 수 있습니다. 인코더를 찾을 "
"수 없으면 :exc:`LookupError`\\를 발생시킵니다."

#: ../../c-api/codec.rst:37
msgid "Generic codec based decoding API."
msgstr "일반 코덱 기반 디코딩 API."

#: ../../c-api/codec.rst:39
msgid ""
"*object* is passed through the decoder function found for the given "
"*encoding* using the error handling method defined by *errors*.  *errors*"
" may be ``NULL`` to use the default method defined for the codec.  Raises"
" a :exc:`LookupError` if no encoder can be found."
msgstr ""
"*object*\\는 *errors*\\로 정의된 에러 처리 방법을 사용하여 지정된 *encoding*\\에 대해 발견된 디코더 "
"함수로 전달됩니다. 코덱에 정의된 기본 방법을 사용하기 위해 *errors*\\가 ``NULL`` 일 수 있습니다. 인코더를 찾을 "
"수 없으면 :exc:`LookupError`\\를 발생시킵니다."

#: ../../c-api/codec.rst:46
msgid "Codec lookup API"
msgstr "코덱 조회 API"

#: ../../c-api/codec.rst:48
msgid ""
"In the following functions, the *encoding* string is looked up converted "
"to all lower-case characters, which makes encodings looked up through "
"this mechanism effectively case-insensitive.  If no codec is found, a "
":exc:`KeyError` is set and ``NULL`` returned."
msgstr ""
"다음 함수에서, *encoding* 문자열은 모두 소문자로 변환되어 조회되므로, 이 메커니즘을 통한 인코딩 조회는 대소문자를 "
"구분하지 않게 됩니다. 코덱이 없으면, :exc:`KeyError`\\가 설정되고 ``NULL``\\이 반환됩니다."

#: ../../c-api/codec.rst:55
msgid "Get an encoder function for the given *encoding*."
msgstr "주어진 *encoding*\\에 대한 인코더 함수를 가져옵니다."

#: ../../c-api/codec.rst:59
msgid "Get a decoder function for the given *encoding*."
msgstr "주어진 *encoding*\\에 대한 디코더 함수를 가져옵니다."

#: ../../c-api/codec.rst:63
msgid ""
"Get an :class:`~codecs.IncrementalEncoder` object for the given "
"*encoding*."
msgstr "지정된 *encoding*\\에 대한 :class:`~codecs.IncrementalEncoder` 객체를 가져옵니다."

#: ../../c-api/codec.rst:67
msgid ""
"Get an :class:`~codecs.IncrementalDecoder` object for the given "
"*encoding*."
msgstr "지정된 *encoding*\\에 대한 :class:`~codecs.IncrementalDecoder` 객체를 가져옵니다."

#: ../../c-api/codec.rst:71
msgid ""
"Get a :class:`~codecs.StreamReader` factory function for the given "
"*encoding*."
msgstr "지정된 *encoding*\\에 대한 :class:`~codecs.StreamReader` 팩토리 함수를 가져옵니다."

#: ../../c-api/codec.rst:75
msgid ""
"Get a :class:`~codecs.StreamWriter` factory function for the given "
"*encoding*."
msgstr "지정된 *encoding*\\에 대한 :class:`~codecs.StreamWriter` 팩토리 함수를 가져옵니다."

#: ../../c-api/codec.rst:79
msgid "Registry API for Unicode encoding error handlers"
msgstr "유니코드 인코딩 에러 처리기용 등록소 API"

#: ../../c-api/codec.rst:83
msgid ""
"Register the error handling callback function *error* under the given "
"*name*. This callback function will be called by a codec when it "
"encounters unencodable characters/undecodable bytes and *name* is "
"specified as the error parameter in the call to the encode/decode "
"function."
msgstr ""
"지정된 *name* 으로 에러 처리 콜백 함수 *error*\\를 등록합니다. 코덱이 인코딩할 수 없는 문자/디코딩할 수 없는 "
"바이트열을 발견하고, 인코드/디코드 함수를 호출할 때 *name*\\이 error 매개 변수로 지정되었을 때 이 콜백 함수를 "
"호출합니다."

#: ../../c-api/codec.rst:88
msgid ""
"The callback gets a single argument, an instance of "
":exc:`UnicodeEncodeError`, :exc:`UnicodeDecodeError` or "
":exc:`UnicodeTranslateError` that holds information about the problematic"
" sequence of characters or bytes and their offset in the original string "
"(see :ref:`unicodeexceptions` for functions to extract this information)."
"  The callback must either raise the given exception, or return a two-"
"item tuple containing the replacement for the problematic sequence, and "
"an integer giving the offset in the original string at which "
"encoding/decoding should be resumed."
msgstr ""
"콜백은 하나의 인자로 :exc:`UnicodeEncodeError`, :exc:`UnicodeDecodeError` 또는 "
":exc:`UnicodeTranslateError`\\의 인스턴스를 받아들이는데, 문제가 되는 문자나 바이트의 시퀀스와 이들의 원본"
" 문자열에서의 오프셋에 대한 정보를 담고 있습니다 (이 정보를 추출하는 함수는 :ref:`unicodeexceptions`\\를 "
"참조하세요). 콜백은 주어진 예외를 발생시키거나, 문제가 있는 시퀀스의 대체와 원래 문자열에서 인코딩/디코딩을 다시 시작해야 하는 "
"오프셋을 제공하는 정수를 포함하는 두 항목 튜플을 반환해야 합니다."

#: ../../c-api/codec.rst:98
msgid "Return ``0`` on success, ``-1`` on error."
msgstr "성공하면 ``0``\\을, 에러면 ``-1``\\을 반환합니다."

#: ../../c-api/codec.rst:102
msgid ""
"Lookup the error handling callback function registered under *name*.  As "
"a special case ``NULL`` can be passed, in which case the error handling "
"callback for \"strict\" will be returned."
msgstr ""
"*name* 으로 등록된 에러 처리 콜백 함수를 찾습니다. 특수한 경우로 ``NULL``\\이 전달 될 수 있는데, 이때는 "
"\"strict\" 에 대한 에러 처리 콜백이 반환됩니다."

#: ../../c-api/codec.rst:108
msgid "Raise *exc* as an exception."
msgstr "*exc*\\를 예외로 발생시킵니다."

#: ../../c-api/codec.rst:112
msgid "Ignore the unicode error, skipping the faulty input."
msgstr "잘못된 입력을 건너뛰고, 유니코드 에러를 무시합니다."

#: ../../c-api/codec.rst:116
msgid "Replace the unicode encode error with ``?`` or ``U+FFFD``."
msgstr "유니코드 인코딩 에러를 ``?`` 나 ``U+FFFD``\\로 치환합니다."

#: ../../c-api/codec.rst:120
msgid "Replace the unicode encode error with XML character references."
msgstr "유니코드 인코딩 에러를 XML 문자 참조로 치환합니다."

#: ../../c-api/codec.rst:124
msgid ""
"Replace the unicode encode error with backslash escapes (``\\x``, ``\\u``"
" and ``\\U``)."
msgstr "유니코드 인코딩 에러를 백 슬래시 이스케이프(``\\x``, ``\\u`` 및 ``\\U``)로 치환합니다."

#: ../../c-api/codec.rst:129
#, python-brace-format
msgid "Replace the unicode encode error with ``\\N{...}`` escapes."
msgstr "유니코드 인코딩 에러를 ``\\N{...}`` 이스케이프로 치환합니다."

