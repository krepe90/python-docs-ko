# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "프로그래밍 FAQ"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr "목차"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "일반적인 질문"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr "중단점, 단일 스테핑(single-stepping) 등을 포함하는 소스 코드 수준 디버거가 있습니까?"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:58
msgid "Yes."
msgstr "예."

#: ../../faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in "
"function :func:`breakpoint` allows you to drop into any of them."
msgstr ""
"파이썬을 위한 여러 디버거가 아래에 설명되어 있으며, 내장 함수 :func:`breakpoint`\\를 사용하면 이들 중 하나로 "
"들어갈 수 있습니다."

#: ../../faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python."
" It is part of the standard Python library, and is :mod:`documented in "
"the Library Reference Manual <pdb>`. You can also write your own debugger"
" by using the code for pdb as an example."
msgstr ""
"pdb 모듈은 간단하지만 적절한 파이썬 용 콘솔 모드 디버거입니다. 표준 파이썬 라이브러리의 일부이며, :mod:`라이브러리 "
"레퍼런스 매뉴얼에서 설명 <pdb>`\\하고 있습니다. pdb의 코드를 예로 사용하여 자체 디버거를 작성할 수도 있습니다."

#: ../../faq/programming.rst:27
#, fuzzy
msgid ""
"The IDLE interactive development environment, which is part of the "
"standard Python distribution (normally available as `Tools/scripts/idle3 "
"<https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), "
"includes a graphical debugger."
msgstr ""
"표준 파이썬 배포의 일부인 (보통 Tools/scripts/idle에 있습니다) IDLE 대화식 개발 환경에는 그래픽 디버거가 "
"포함되어 있습니다."

#: ../../faq/programming.rst:32
#, fuzzy
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The"
" PythonWin debugger colors breakpoints and has quite a few cool features "
"such as debugging non-PythonWin programs.  PythonWin is available as part"
" of `pywin32 <https://github.com/mhammond/pywin32>`_ project and as a "
"part of the `ActivePython "
"<https://www.activestate.com/products/python/>`_ distribution."
msgstr ""
"PythonWin은 pdb 기반 GUI 디버거를 포함하는 파이썬 IDE입니다. Pythonwin 디버거는 중단점에 색을 입히고 비 "
"Pythonwin 프로그램 디버깅과 같은 멋진 기능을 제공합니다. Pythonwin은 `Python for Windows "
"Extensions <https://sourceforge.net/projects/pywin32/>`__ 프로젝트의 일부와 "
"ActivePython 배포의 일부로 제공됩니다 (https://www.activestate.com/activepython 를 "
"참조하십시오)."

#: ../../faq/programming.rst:39
#, fuzzy
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt "
"and the Scintilla editing component."
msgstr ""
"`Eric <http://eric-ide.python-projects.org/>`_\\은 PyQt와 Scintilla 편집 "
"컴포넌트를 기반으로 하는 IDE입니다."

#: ../../faq/programming.rst:42
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""

#: ../../faq/programming.rst:44
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""

#: ../../faq/programming.rst:47
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr "그래픽 디버거를 포함하는 많은 상용 파이썬 IDE가 있습니다. 다음을 포함합니다:"

#: ../../faq/programming.rst:50
#, fuzzy
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "Wing IDE (https://wingware.com/)"

#: ../../faq/programming.rst:51
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr ""

#: ../../faq/programming.rst:52
#, fuzzy
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "PyCharm (https://www.jetbrains.com/pycharm/)"

#: ../../faq/programming.rst:56
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr "버그를 찾거나 정적 분석을 수행하는 데 도움이 되는 도구가 있습니까?"

#: ../../faq/programming.rst:60
#, fuzzy
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help "
"you catch bugs sooner."
msgstr ""
"`Pylint <https://www.pylint.org/>`_\\와 `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_\\는 버그를 더 빨리 발견하는 데 도움이 되는 기본 검사를 "
"수행합니다."

#: ../../faq/programming.rst:64
#, fuzzy
msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype "
"<https://github.com/google/pytype>`_ can check type hints in Python "
"source code."
msgstr ""
"`Mypy <http://mypy-lang.org/>`_, `Pyre <https://pyre-check.org/>`_ 및 "
"`Pytype <https://github.com/google/pytype>`_\\과 같은 정적 형 검사기는 파이썬 소스 코드에 "
"있는 형 힌트를 검사할 수 있습니다."

#: ../../faq/programming.rst:73
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "파이썬 스크립트로 독립 실행형 바이너리를 만들려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:75
msgid ""
"You don't need the ability to compile Python to C code if all you want is"
" a stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules"
" together with a Python binary to produce a single executable."
msgstr ""
"사용자가 파이썬 배포를 먼저 설치하지 않고도 다운로드하여 실행할 수 있는 독립 실행형 프로그램을 원하는 것이 전부라면 파이썬을 C "
"코드로 컴파일하는 기능이 필요하지는 않습니다. 프로그램에 필요한 모듈 집합을 파악하고 이러한 모듈들을 파이썬 바이너리와 결합하여 "
"단일 실행 파일을 생성하는 많은 도구가 있습니다."

#: ../../faq/programming.rst:81
#, fuzzy
msgid ""
"One is to use the freeze tool, which is included in the Python source "
"tree as `Tools/freeze "
"<https://github.com/python/cpython/tree/main/Tools/freeze>`_. It converts"
" Python byte code to C arrays; with a C compiler you can embed all your "
"modules into a new program, which is then linked with the standard Python"
" modules."
msgstr ""
"그중 하나는 파이썬 소스 트리에 ``Tools/freeze``\\로 포함된 freeze 도구를 사용하는 것입니다. 파이썬 바이트 "
"코드를 C 배열로 변환합니다; C 컴파일러를 사용하면 모든 모듈을 새 프로그램에 내장시킨 다음 표준 파이썬 모듈과 링크할 수 "
"있습니다."

#: ../../faq/programming.rst:87
msgid ""
"It works by scanning your source recursively for import statements (in "
"both forms) and looking for the modules in the standard Python path as "
"well as in the source directory (for built-in modules).  It then turns "
"the bytecode for modules written in Python into C code (array "
"initializers that can be turned into code objects using the marshal "
"module) and creates a custom-made config file that only contains those "
"built-in modules which are actually used in the program.  It then "
"compiles the generated C code and links it with the rest of the Python "
"interpreter to form a self-contained binary which acts exactly like your "
"script."
msgstr ""
"소스를 재귀적으로 검색하여 import 문(두 형식 모두)을 찾고 표준 파이썬 경로뿐만 아니라 소스 디렉터리에서 모듈을 찾습니다 "
"(내장할 모듈을 위해). 그런 다음 파이썬으로 작성된 모듈의 바이트 코드를 C 코드 (marshal 모듈을 사용하여 코드 객체로 "
"변환할 수 있는 배열 초기화기)로 바꾸고 프로그램에서 실제로 사용되는 내장 모듈만 포함하는 특별한 구성 파일을 만듭니다. 그런 다음"
" 생성된 C 코드를 컴파일하고 이를 나머지 파이썬 인터프리터와 링크하여 스크립트와 똑같게 작동하는 자체 포함 바이너리를 형성합니다."

#: ../../faq/programming.rst:96
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""

#: ../../faq/programming.rst:99
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr ""

#: ../../faq/programming.rst:100
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr ""

#: ../../faq/programming.rst:101
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-"
"platform)"
msgstr ""

#: ../../faq/programming.rst:102
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-"
"platform)"
msgstr ""

#: ../../faq/programming.rst:103
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr ""

#: ../../faq/programming.rst:104
#, fuzzy
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "http://www.py2exe.org/"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr "파이썬 프로그램을 위한 코딩 표준이나 스타일 지침서가 있습니까?"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is "
"documented as :pep:`8`."
msgstr "예. 표준 라이브러리 모듈에 요구되는 코딩 스타일은 :pep:`8`\\에서 설명합니다."

#: ../../faq/programming.rst:114
msgid "Core Language"
msgstr "핵심 언어"

#: ../../faq/programming.rst:119
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "변수에 값이 있을 때 UnboundLocalError 가 발생하는 이유는 무엇입니까?"

#: ../../faq/programming.rst:121
#, fuzzy
msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement "
"somewhere in the body of a function."
msgstr "전에는 동작하던 코드에서 함수 본문 어딘가에 대입문을 추가했을 때 UnboundLocalError 가 발생하면 당황할 수 있습니다."

#: ../../faq/programming.rst:125
msgid "This code:"
msgstr "이 코드는:"

#: ../../faq/programming.rst:134
msgid "works, but this code:"
msgstr "작동하지만, 이 코드는:"

#: ../../faq/programming.rst:141
#, fuzzy
msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "UnboundLocalError 가 발생합니다:"

#: ../../faq/programming.rst:148
msgid ""
"This is because when you make an assignment to a variable in a scope, "
"that variable becomes local to that scope and shadows any similarly named"
" variable in the outer scope.  Since the last statement in foo assigns a "
"new value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"이는 스코프에서 변수에 대입할 때, 해당 변수가 그 스코프에 대해 지역(local)이 되고 외부 스코프에서 비슷한 이름의 변수를 "
"가리기 때문입니다. foo의 마지막 문장은 ``x``\\에 새 값을 대입하므로, 컴파일러는 이 값을 지역 변수로 인식합니다. "
"결과적으로 앞의 ``print(x)``\\가 초기화되지 않은 지역 변수를 인쇄하려고 할 때 에러가 발생합니다."

#: ../../faq/programming.rst:155
msgid ""
"In the example above you can access the outer scope variable by declaring"
" it global:"
msgstr "위의 예에서 변수를 전역(global)으로 선언하여 외부 스코프 변수에 액세스 할 수 있습니다:"

#: ../../faq/programming.rst:167
msgid ""
"This explicit declaration is required in order to remind you that (unlike"
" the superficially analogous situation with class and instance variables)"
" you are actually modifying the value of the variable in the outer scope:"
msgstr ""
"이 명시적 선언은 (클래스와 인스턴스 변수의 표면적으로 유사한 상황과 달리) 실제로 외부 스코프에 있는 변수의 값을 수정하고 있음을"
" 상기시키기 위해 필요합니다:"

#: ../../faq/programming.rst:174
msgid ""
"You can do a similar thing in a nested scope using the "
":keyword:`nonlocal` keyword:"
msgstr ":keyword:`nonlocal` 키워드를 사용하여 중첩된 스코프에서 비슷한 일을 할 수 있습니다:"

#: ../../faq/programming.rst:192
msgid "What are the rules for local and global variables in Python?"
msgstr "파이썬에서 지역과 전역 변수에 대한 규칙은 무엇입니까?"

#: ../../faq/programming.rst:194
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the"
" function's body, it's assumed to be a local unless explicitly declared "
"as global."
msgstr ""
"파이썬에서, 함수 내에서 참조되기만 하는 변수는 묵시적으로 전역입니다. 변수가 함수 본문 내 어디에서건 값을 대입하면, 명시적으로 "
"전역으로 선언되지 않는 한 지역으로 간주합니다."

#: ../../faq/programming.rst:198
msgid ""
"Though a bit surprising at first, a moment's consideration explains this."
"  On one hand, requiring :keyword:`global` for assigned variables "
"provides a bar against unintended side-effects.  On the other hand, if "
"``global`` was required for all global references, you'd be using "
"``global`` all the time.  You'd have to declare as global every reference"
" to a built-in function or to a component of an imported module.  This "
"clutter would defeat the usefulness of the ``global`` declaration for "
"identifying side-effects."
msgstr ""
"처음에는 조금 의외지만, 잠시 생각해보면 이해가 됩니다. 한편으로, 대입된 변수에 :keyword:`global`\\을 요구하면 "
"의도하지 않은 부작용에 대한 저지선을 제공합니다. 반면에, 모든 전역 참조에 ``global``\\이 요구된다면, 항상 "
"``global``\\을 사용하게 됩니다. 내장 함수나 임포트 한 모듈의 구성 요소에 대한 모든 참조를 전역으로 선언해야 합니다. "
"이 혼란은 부작용을 식별하기 위한 ``global`` 선언의 유용성을 무효로 합니다."

#: ../../faq/programming.rst:208
msgid ""
"Why do lambdas defined in a loop with different values all return the "
"same result?"
msgstr "다른 값으로 루프에서 정의된 람다는 왜 모두 같은 결과를 반환합니까?"

#: ../../faq/programming.rst:210
msgid ""
"Assume you use a for loop to define a few different lambdas (or even "
"plain functions), e.g.::"
msgstr "for 루프를 사용하여 몇 가지 다른 람다(또는 일반 함수조차)를 정의한다고 가정하십시오, 예를 들어::"

#: ../../faq/programming.rst:213
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"
msgstr ""

#: ../../faq/programming.rst:217
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  "
"You might expect that, when called, they would return, respectively, "
"``0``, ``1``, ``4``, ``9``, and ``16``.  However, when you actually try "
"you will see that they all return ``16``::"
msgstr ""
"이것은 ``x**2``\\를 계산하는 5개의 람다가 포함된 리스트를 제공합니다. 호출되면, 각각 ``0``, ``1``, "
"``4``, ``9`` 및 ``16``\\을 반환할 것으로 예상할 수 있습니다. 그러나, 실제로 시도하면 모두 ``16``\\을 "
"반환한다는 것을 알 수 있습니다::"

#: ../../faq/programming.rst:222
msgid ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"
msgstr ""

#: ../../faq/programming.rst:227
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in"
" the outer scope, and it is accessed when the lambda is called --- not "
"when it is defined.  At the end of the loop, the value of ``x`` is ``4``,"
" so all the functions now return ``4**2``, i.e. ``16``.  You can also "
"verify this by changing the value of ``x`` and see how the results of the"
" lambdas change::"
msgstr ""
"이는 ``x``\\가 람다에 지역(local)이 아니라 외부 스코프에 정의되어 있기 때문에 발생하며, 람다가 호출될 때 액세스 "
"됩니다 --- 정의될 때가 아닙니다. 루프의 끝에서, ``x``\\의 값은 ``4``\\이므로, 모든 함수는 이제 ``4**2``,"
" 즉 ``16``\\을 반환합니다. ``x``\\의 값을 변경하고 람다의 결과가 어떻게 변경되는지 봄으로써 이를 확인할 수도 "
"있습니다::"

#: ../../faq/programming.rst:233
msgid ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"
msgstr ""

#: ../../faq/programming.rst:237
msgid ""
"In order to avoid this, you need to save the values in variables local to"
" the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr "이를 피하려면, 람다에 대해 지역인 변수에 값을 저장하여, 전역 ``x``\\의 값에 의존하지 않도록 할 필요가 있습니다::"

#: ../../faq/programming.rst:240
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"
msgstr ""

#: ../../faq/programming.rst:244
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and "
"computed when the lambda is defined so that it has the same value that "
"``x`` had at that point in the loop.  This means that the value of ``n`` "
"will be ``0`` in the first lambda, ``1`` in the second, ``2`` in the "
"third, and so on. Therefore each lambda will now return the correct "
"result::"
msgstr ""
"여기서 ``n=x``\\는 람다에 지역인 새 변수 ``n``\\을 만들고, 루프의 해당 시점에서 ``x`` 와 같은 값을 갖도록 "
"람다가 정의될 때 계산됩니다. 이는 ``n``\\의 값이 첫 번째 람다에서 ``0``, 두 번째에서 ``1``, 세 번째에서 "
"``2`` 등이 됨을 의미합니다. 따라서 각 람다는 이제 올바른 결과를 반환합니다::"

#: ../../faq/programming.rst:250
msgid ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"
msgstr ""

#: ../../faq/programming.rst:255
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to "
"regular functions too."
msgstr "이 동작은 람다에만 국한된 것이 아니라 일반 함수에도 적용됩니다."

#: ../../faq/programming.rst:260
msgid "How do I share global variables across modules?"
msgstr "모듈 간에 전역 변수를 공유하려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:262
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just"
" import the config module in all modules of your application; the module "
"then becomes available as a global name.  Because there is only one "
"instance of each module, any changes made to the module object get "
"reflected everywhere.  For example:"
msgstr ""
"단일 프로그램 내에서 모듈 간에 정보를 공유하는 규범적인 방법은 특별한 모듈(종종 config나 cfg라고 불립니다)을 만드는 "
"것입니다. 응용 프로그램의 모든 모듈에서 config 모듈을 임포트 하기만 하면 됩니다; 그러면 모듈이 전역 이름으로 사용 "
"가능해집니다. 각 모듈의 인스턴스는 오직 하나이기 때문에, 모듈 객체에 대한 변경 사항은 모든 곳에 반영됩니다. 예를 들면 다음과 "
"같습니다:"

#: ../../faq/programming.rst:268
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:270
msgid "x = 0   # Default value of the 'x' configuration setting"
msgstr ""

#: ../../faq/programming.rst:272
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:274
msgid ""
"import config\n"
"config.x = 1"
msgstr ""

#: ../../faq/programming.rst:277
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:279
msgid ""
"import config\n"
"import mod\n"
"print(config.x)"
msgstr ""

#: ../../faq/programming.rst:283
#, fuzzy
msgid ""
"Note that using a module is also the basis for implementing the singleton"
" design pattern, for the same reason."
msgstr "같은 이유로, 모듈을 사용하는 것도 싱글톤 디자인 패턴 구현을 위한 기초입니다."

#: ../../faq/programming.rst:288
msgid "What are the \"best practices\" for using import in a module?"
msgstr "모듈에서 임포트를 사용하는 \"모범 사례\"는 무엇입니까?"

#: ../../faq/programming.rst:290
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters "
"the importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"일반적으로, ``from modulename import *``\\를 사용하지 마십시오. 그렇게 하면 임포트 하는 곳의 이름 공간이"
" 어수선해지고, 린터(linter)가 정의되지 않은 이름을 감지하기가 훨씬 어려워집니다."

#: ../../faq/programming.rst:294
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module "
"name is in scope. Using one import per line makes it easy to add and "
"delete module imports, but using multiple imports per line uses less "
"screen space."
msgstr ""
"파일 맨 위에서 모듈을 임포트 하십시오. 그렇게 하면 코드에 필요한 다른 모듈을 명확하게 하고 모듈 이름이 스코프에 있는지에 대한 "
"질문을 피할 수 있습니다. 한 줄에 하나의 임포트를 사용하면 모듈 임포트를 쉽게 추가하고 삭제할 수 있지만, 한 줄에 여러 임포트를"
" 사용하면 화면 공간을 덜 사용합니다."

#: ../../faq/programming.rst:299
msgid "It's good practice if you import modules in the following order:"
msgstr "다음 순서로 모듈을 임포트 하는 것이 좋습니다:"

#: ../../faq/programming.rst:301
#, fuzzy
msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, "
":mod:`re`"
msgstr "표준 라이브러리 모듈 -- 예를 들어 ``sys``, ``os``, ``getopt``, ``re``"

#: ../../faq/programming.rst:302
#, fuzzy
msgid ""
"third-party library modules (anything installed in Python's site-packages"
" directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"제삼자 라이브러리 모듈 (파이썬의 site-packages 디렉터리에 설치된 모든 것) -- 예를 들어 mx.DateTime, "
"ZODB, PIL.Image 등."

#: ../../faq/programming.rst:304
#, fuzzy
msgid "locally developed modules"
msgstr "내부에서 개발된 모듈"

#: ../../faq/programming.rst:306
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid"
" problems with circular imports.  Gordon McMillan says:"
msgstr ""
"순환 임포트 관련 문제를 피하고자 임포트를 함수나 클래스로 이동해야 하는 경우가 있습니다. Gordon McMillan은 다음과 "
"같이 말했습니다:"

#: ../../faq/programming.rst:309
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out "
"of the first (\"from module import name\") and the import is at the top "
"level.  That's because names in the 1st are not yet available, because "
"the first module is busy importing the 2nd."
msgstr ""
"두 모듈 모두 \"import <module>\" 형식의 임포트를 사용하면 순환 임포트는 괜찮습니다. 두 번째 모듈이 첫 번째 "
"모듈의 이름(name)을 붙잡으려고 하고 (\"from module import name\") 임포트가 최상위 수준에 있으면 "
"실패합니다. 첫 번째 모듈이 두 번째 모듈을 임포트 하는 중이라서 첫 번째 모듈에 있는 이름을 아직 사용할 수 없기 때문입니다."

#: ../../faq/programming.rst:315
msgid ""
"In this case, if the second module is only used in one function, then the"
" import can easily be moved into that function.  By the time the import "
"is called, the first module will have finished initializing, and the "
"second module can do its import."
msgstr ""
"이 경우, 두 번째 모듈이 하나의 함수에서만 사용된다면, 임포트를 해당 함수로 쉽게 이동할 수 있습니다. 임포트가 호출될 때, 첫 "
"번째 모듈의 초기화가 완료되었고, 두 번째 모듈은 임포트를 수행할 수 있습니다."

#: ../../faq/programming.rst:320
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even"
" be possible to import all of the modules at the top of the file.  In "
"this case, importing the correct modules in the corresponding platform-"
"specific code is a good option."
msgstr ""
"일부 모듈이 플랫폼 특정이면 임포트를 코드의 최상위 수준에서 다른 곳으로 이동해야 할 수도 있습니다. 이 경우, 파일 맨 위에서 "
"모든 모듈을 임포트 하는 것이 가능하지 않을 수도 있습니다. 이 경우, 해당 플랫폼 특정 코드에서 올바른 모듈을 임포트 하는 것이 "
"좋은 선택입니다."

#: ../../faq/programming.rst:325
msgid ""
"Only move imports into a local scope, such as inside a function "
"definition, if it's necessary to solve a problem such as avoiding a "
"circular import or are trying to reduce the initialization time of a "
"module.  This technique is especially helpful if many of the imports are "
"unnecessary depending on how the program executes.  You may also want to "
"move imports into a function if the modules are only ever used in that "
"function.  Note that loading a module the first time may be expensive "
"because of the one time initialization of the module, but loading a "
"module multiple times is virtually free, costing only a couple of "
"dictionary lookups.  Even if the module name has gone out of scope, the "
"module is probably available in :data:`sys.modules`."
msgstr ""
"순환 임포트를 피하거나 모듈의 초기화 시간을 줄이려는 등의 문제를 해결하는 데 필요할 때만, 함수 정의 내부와 같은 지역 스코프로 "
"임포트를 옮기십시오. 이 기법은 프로그램 실행 방법에 따라 많은 임포트가 필요하지 않을 때 특히 유용합니다. 모듈이 해당 함수에서만"
" 사용될 때 임포트를 함수로 옮기고 싶을 수도 있습니다. 모듈의 일회성 초기화 때문에 모듈을 처음 로드하는 데 비용이 많이들 수 "
"있지만, 모듈을 여러 번 로드하는 것은 사실상 무료임에 유의하십시오, 두 번의 딕셔너리 조회만 발생합니다. 모듈 이름이 스코프를 "
"벗어난 경우에도, 모듈은 아마도 :data:`sys.modules`\\에 있을 겁니다."

#: ../../faq/programming.rst:338
msgid "Why are default values shared between objects?"
msgstr "객체 간에 기본값이 공유되는 이유는 무엇입니까?"

#: ../../faq/programming.rst:340
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr "이 유형의 버그는 흔히 신참 프로그래머들을 깨뭅니다. 이 함수를 생각해보십시오::"

#: ../../faq/programming.rst:342
#, python-brace-format
msgid ""
"def foo(mydict={}):  # Danger: shared reference to one dict for all calls"
"\n"
"    ... compute something ...\n"
"    mydict[key] = value\n"
"    return mydict"
msgstr ""

#: ../../faq/programming.rst:347
msgid ""
"The first time you call this function, ``mydict`` contains a single item."
"  The second time, ``mydict`` contains two items because when ``foo()`` "
"begins executing, ``mydict`` starts out with an item already in it."
msgstr ""
"이 함수를 처음 호출하면, ``mydict``\\에 단일 항목이 포함됩니다. 두 번째는, ``foo()``\\가 실행되기 시작할 "
"때, ``mydict``\\가 이미 항목에 들어 있는 상태로 시작하기 때문에, ``mydict``\\가 두 개의 항목을 포함합니다."

#: ../../faq/programming.rst:351
msgid ""
"It is often expected that a function call creates new objects for default"
" values. This is not what happens. Default values are created exactly "
"once, when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer "
"to this changed object."
msgstr ""
"종종 함수 호출이 기본값으로 새 객체를 만들 것으로 기대합니다. 그렇게 되지 않습니다. 함수가 정의될 때, 기본값은 정확히 한 번 "
"만들어집니다. 이 예제의 딕셔너리와 같이, 해당 객체가 변경되면, 함수에 대한 후속 호출은 이 변경된 객체를 참조합니다."

#: ../../faq/programming.rst:356
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"정의에 따라, 숫자, 문자열, 튜플 및 ``None``\\과 같은 불변 객체는 변경에 안전합니다. 딕셔너리, 리스트 및 클래스 "
"인스턴스와 같은 가변 객체를 변경하면 혼란스러울 수 있습니다."

#: ../../faq/programming.rst:360
msgid ""
"Because of this feature, it is good programming practice to not use "
"mutable objects as default values.  Instead, use ``None`` as the default "
"value and inside the function, check if the parameter is ``None`` and "
"create a new list/dictionary/whatever if it is.  For example, don't "
"write::"
msgstr ""
"이 기능으로 인해, 가변 객체를 기본값으로 사용하지 않는 것이 좋습니다. 대신, ``None``\\을 기본값으로 사용하고 함수 "
"내부에서 매개변수가 ``None``\\인지 확인한 다음 새 리스트/딕셔너리/무엇이든 새로 만드십시오. 예를 들어, 다음과 같이 쓰지"
" 마십시오::"

#: ../../faq/programming.rst:365
#, python-brace-format
msgid ""
"def foo(mydict={}):\n"
"    ..."
msgstr ""

#: ../../faq/programming.rst:368
msgid "but::"
msgstr "대신 이렇게 쓰십시오::"

#: ../../faq/programming.rst:370
#, python-brace-format
msgid ""
"def foo(mydict=None):\n"
"    if mydict is None:\n"
"        mydict = {}  # create a new dict for local namespace"
msgstr ""

#: ../../faq/programming.rst:374
msgid ""
"This feature can be useful.  When you have a function that's time-"
"consuming to compute, a common technique is to cache the parameters and "
"the resulting value of each call to the function, and return the cached "
"value if the same value is requested again.  This is called "
"\"memoizing\", and can be implemented like this::"
msgstr ""
"이 기능은 유용할 수 있습니다. 계산하는 데 시간이 걸리는 함수가 있을 때, 일반적인 기법은 각 함수 호출의 매개변수와 결괏값을 "
"캐시하고, 같은 값이 다시 요청되면 캐시 된 값을 반환하는 것입니다. 이것을 \"memoizing\" 이라고 하며, 다음과 같이 "
"구현할 수 있습니다::"

#: ../../faq/programming.rst:379
#, python-brace-format
msgid ""
"# Callers can only provide two parameters and optionally pass _cache by "
"keyword\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Calculate the value\n"
"    result = ... expensive computation ...\n"
"    _cache[(arg1, arg2)] = result           # Store result in the cache\n"
"    return result"
msgstr ""

#: ../../faq/programming.rst:389
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr "기본값 대신 딕셔너리를 포함하는 전역 변수를 사용할 수 있습니다; 취향의 문제입니다."

#: ../../faq/programming.rst:394
msgid ""
"How can I pass optional or keyword parameters from one function to "
"another?"
msgstr "한 함수에서 다른 함수로 선택적이나 키워드 매개변수를 전달하려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:396
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these"
" arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"함수의 매개변수 목록에 ``*``\\와 ``**`` 지정자를 사용하여 인자를 수집하십시오; 이것은 위치 인자를 튜플로, 키워드 "
"인자를 딕셔너리로 제공합니다. 그런 다음 ``*``\\와 ``**``\\를 사용하여 다른 함수를 호출할 때 이러한 인자를 전달할 수"
" 있습니다::"

#: ../../faq/programming.rst:401
msgid ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['width'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"
msgstr ""

#: ../../faq/programming.rst:415
msgid "What is the difference between arguments and parameters?"
msgstr "인자와 매개변수의 차이점은 무엇입니까?"

#: ../../faq/programming.rst:417
#, fuzzy
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what "
":term:`kind of arguments <parameter>` a function can accept.  For "
"example, given the function definition::"
msgstr ""
":term:`매개변수 <parameter>`\\는 함수 정의에 나타나는 이름으로 정의되는 반면, :term:`인자 "
"<argument>`\\는 함수를 호출할 때 실제로 함수에 전달되는 값입니다. 매개변수는 함수가 받아들일 수 있는 인자 형을 "
"정의합니다. 예를 들어, 다음과 같은 함수 정의가 주어졌을 때::"

#: ../../faq/programming.rst:423
msgid ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"
msgstr ""

#: ../../faq/programming.rst:426
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when "
"calling ``func``, for example::"
msgstr ""
"*foo*, *bar* 및 *kwargs*\\는 ``func``\\의 매개변수입니다. 그러나, ``func``\\를 호출할 때, "
"예를 들면::"

#: ../../faq/programming.rst:429
msgid "func(42, bar=314, extra=somevar)"
msgstr ""

#: ../../faq/programming.rst:431
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "``42``, ``314`` 및 ``somevar`` 값은 인자입니다."

#: ../../faq/programming.rst:435
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "리스트 'y'를 변경할 때 리스트 'x'도 변경되는 이유는 무엇입니까?"

#: ../../faq/programming.rst:437
msgid "If you wrote code like::"
msgstr "다음과 같은 코드를 작성하면::"

#: ../../faq/programming.rst:439
msgid ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"
msgstr ""

#: ../../faq/programming.rst:447
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` "
"too."
msgstr "``y``\\에 요소를 추가하면 ``x``\\도 변경되는 이유가 궁금할 것입니다."

#: ../../faq/programming.rst:449
msgid "There are two factors that produce this result:"
msgstr "이 결과를 만드는 두 가지 요소가 있습니다:"

#: ../../faq/programming.rst:451
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` "
"doesn't create a copy of the list -- it creates a new variable ``y`` that"
" refers to the same object ``x`` refers to.  This means that there is "
"only one object (the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"변수는 단순히 객체를 가리키는 이름입니다. ``y = x``\\를 수행하면 리스트의 사본을 만들지 않습니다 -- ``x``\\가 "
"참조하는 것과 같은 객체를 참조하는 새 변수 ``y``\\를 만듭니다. 이는 하나의 객체(리스트)만 있고, ``x`` 와 ``y``"
" 모두 그 객체를 참조함을 의미합니다."

#: ../../faq/programming.rst:455
msgid "Lists are :term:`mutable`, which means that you can change their content."
msgstr "리스트는 :term:`가변 <mutable>`\\입니다, 내용을 변경할 수 있다는 뜻입니다."

#: ../../faq/programming.rst:457
#, fuzzy
msgid ""
"After the call to :meth:`!append`, the content of the mutable object has "
"changed from ``[]`` to ``[10]``.  Since both the variables refer to the "
"same object, using either name accesses the modified value ``[10]``."
msgstr ""
":meth:`~list.append`\\를 호출한 후, 가변 객체의 내용이 ``[]``\\에서 ``[10]`` 으로 변경되었습니다."
" 두 변수가 모두 동일한 객체를 참조하기 때문에, 두 이름 중 어느 것을 사용하더라도 수정된 값 ``[10]`` 에 액세스합니다."

#: ../../faq/programming.rst:461
msgid "If we instead assign an immutable object to ``x``::"
msgstr "대신 불변 객체를 ``x``\\에 대입하면::"

#: ../../faq/programming.rst:463
msgid ""
">>> x = 5  # ints are immutable\n"
">>> y = x\n"
">>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n"
">>> x\n"
"6\n"
">>> y\n"
"5"
msgstr ""

#: ../../faq/programming.rst:471
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This"
" is because integers are :term:`immutable`, and when we do ``x = x + 1`` "
"we are not mutating the int ``5`` by incrementing its value; instead, we "
"are creating a new object (the int ``6``) and assigning it to ``x`` (that"
" is, changing which object ``x`` refers to).  After this assignment we "
"have two objects (the ints ``6`` and ``5``) and two variables that refer "
"to them (``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"이 경우 ``x`` 와 ``y``\\가 더는 같지 않다는 것을 알 수 있습니다. 이는 정수가 :term:`불변 "
"<immutable>`\\이기 때문이고, ``x = x + 1``\\을 수행할 때 값을 증가시켜서 정수 ``5``\\를 변경하는 "
"것이 아닙니다; 대신 새 객체(정수 ``6``)를 만들어 ``x``\\에 대입합니다 (즉, ``x``\\가 참조하는 객체를 "
"바꿉니다). 이 대입 후에는 두 개의 객체(정수 ``6``\\과 ``5``)와 이를 참조하는 두 개의 변수를 갖게 됩니다 "
"(``x``\\는 이제 ``6``\\을 참조하지만, ``y``\\는 여전히 ``5``\\를 참조합니다)."

#: ../../faq/programming.rst:479
#, fuzzy
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate "
"the object, whereas superficially similar operations (for example ``y = y"
" + [10]`` and :func:`sorted(y) <sorted>`) create a new object.  In "
"general in Python (and in all cases in the standard library) a method "
"that mutates an object will return ``None`` to help avoid getting the two"
" types of operations confused.  So if you mistakenly write ``y.sort()`` "
"thinking it will give you a sorted copy of ``y``, you'll instead end up "
"with ``None``, which will likely cause your program to generate an easily"
" diagnosed error."
msgstr ""
"일부 연산(예를 들어 ``y.append(10)``\\과 ``y.sort()``)은 객체를 변경하지만, 표면적으로 유사한 연산(예를"
" 들어 ``y = y + [10]`` 과 ``sorted(y)``)은 새 객체를 만듭니다. 일반적으로 파이썬에서 (그리고 표준 "
"라이브러리의 모든 경우에서) 객체를 변경하는 메서드는 ``None``\\을 반환하여 두 가지 유형의 연산이 혼동되지 않도록 합니다."
" 따라서 실수로 ``y.sort()``\\라고 작성하고 ``y``\\의 정렬된 사본을 얻을 수 있다고 생각하면, 대신 "
"``None``\\을 얻어서 프로그램에서 쉽게 진단되는 에러가 발생하도록 합니다."

#: ../../faq/programming.rst:488
msgid ""
"However, there is one class of operations where the same operation "
"sometimes has different behaviors with different types:  the augmented "
"assignment operators.  For example, ``+=`` mutates lists but not tuples "
"or ints (``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, "
"3])`` and mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and "
"``some_int += 1`` create new objects)."
msgstr ""
"그러나, 같은 연산이 때때로 형에 따라 다른 동작을 갖는 한 가지 연산 클래스가 있습니다: 증분 대입 연산자. 예를 들어, "
"``+=``\\는 리스트를 변경하지만, 튜플이나 정수는 변경하지 않습니다 (``a_list += [1, 2, 3]``\\은 "
"``a_list.extend([1, 2, 3])``\\과 동등하고 ``a_list``\\를  변경하지만, ``some_tuple "
"+= (1, 2, 3)``\\과 ``some_int += 1``\\은 새 객체를 만듭니다)."

#: ../../faq/programming.rst:495
msgid "In other words:"
msgstr "달리 표현하면:"

#: ../../faq/programming.rst:497
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"가변 객체(:class:`list`, :class:`dict`, :class:`set` 등)가 있으면, 일부 특정 연산을 사용하여 "
"객체를 변경하면 해당 객체를 참조하는 모든 변수가 변경을 보게 됩니다."

#: ../../faq/programming.rst:500
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, "
":class:`tuple`, etc.), all the variables that refer to it will always see"
" the same value, but operations that transform that value into a new "
"value always return a new object."
msgstr ""
"불변 객체(:class:`str`, :class:`int`, :class:`tuple` 등)가 있으면, 이를 참조하는 모든 변수는 "
"항상 같은 값을 보게 되지만, 해당 값을 새로운 값으로 변환하는 연산은 항상 새로운 객체를 반환합니다."

#: ../../faq/programming.rst:505
msgid ""
"If you want to know if two variables refer to the same object or not, you"
" can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"두 변수가 같은 객체를 참조하는지를 알고 싶다면, :keyword:`is` 연산자나 내장 함수 :func:`id`\\를 사용할 수 "
"있습니다."

#: ../../faq/programming.rst:510
msgid "How do I write a function with output parameters (call by reference)?"
msgstr "출력 매개변수가 있는 함수를 작성하려면 어떻게 해야 합니까 (참조에 의한 호출)?"

#: ../../faq/programming.rst:512
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between "
"an argument name in the caller and callee, and so no call-by-reference "
"per se.  You can achieve the desired effect in a number of ways."
msgstr ""
"파이썬에서 인자는 대입으로 전달됨을 기억하십시오. 대입은 단지 객체에 대한 참조를 만들기 때문에, 호출자와 피호출자의 인자 이름 "
"간에 에일리어스가 없고, 참조에 의한 호출도 없습니다. 여러 가지 방법으로 원하는 효과를 얻을 수 있습니다."

#: ../../faq/programming.rst:517
msgid "By returning a tuple of the results::"
msgstr "결과의 튜플을 반환하여::"

#: ../../faq/programming.rst:519
msgid ""
">>> def func1(a, b):\n"
"...     a = 'new-value'        # a and b are local names\n"
"...     b = b + 1              # assigned to new objects\n"
"...     return a, b            # return new values\n"
"...\n"
">>> x, y = 'old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"
msgstr ""

#: ../../faq/programming.rst:528
msgid "This is almost always the clearest solution."
msgstr "이것은 거의 항상 가장 명확한 해법입니다."

#: ../../faq/programming.rst:530
msgid ""
"By using global variables.  This isn't thread-safe, and is not "
"recommended."
msgstr "전역 변수를 사용하여. 이것은 스레드 안전하지 않고, 권장하지 않습니다."

#: ../../faq/programming.rst:532
msgid "By passing a mutable (changeable in-place) object::"
msgstr "가변 (제자리에서 변경할 수 있는) 객체를 전달하여::"

#: ../../faq/programming.rst:534
msgid ""
">>> def func2(a):\n"
"...     a[0] = 'new-value'     # 'a' references a mutable list\n"
"...     a[1] = a[1] + 1        # changes a shared object\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"
msgstr ""

#: ../../faq/programming.rst:543
msgid "By passing in a dictionary that gets mutated::"
msgstr "변경되는 딕셔너리를 전달하여::"

#: ../../faq/programming.rst:545
#, python-brace-format
msgid ""
">>> def func3(args):\n"
"...     args['a'] = 'new-value'     # args is a mutable dictionary\n"
"...     args['b'] = args['b'] + 1   # change it in-place\n"
"...\n"
">>> args = {'a': 'old-value', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""

#: ../../faq/programming.rst:554
msgid "Or bundle up values in a class instance::"
msgstr "또는 클래스 인스턴스에 값을 묶어서::"

#: ../../faq/programming.rst:556
#, python-brace-format
msgid ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'new-value'        # args is a mutable Namespace\n"
"...     args.b = args.b + 1         # change object in-place\n"
"...\n"
">>> args = Namespace(a='old-value', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""

#: ../../faq/programming.rst:571
msgid "There's almost never a good reason to get this complicated."
msgstr "이렇게 복잡하게 만들어야 할 좋은 이유는 거의 없습니다."

#: ../../faq/programming.rst:573
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr "최선의 선택은 여러 결과가 포함된 튜플을 반환하는 것입니다."

#: ../../faq/programming.rst:577
msgid "How do you make a higher order function in Python?"
msgstr "파이썬에서 고차 함수(higher order function)를 어떻게 만드나요?"

#: ../../faq/programming.rst:579
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using "
"nested scopes::"
msgstr ""
"두 가지 선택이 있습니다: 중첩된 스코프를 사용하거나 콜러블 객체를 사용할 수 있습니다. 예를 들어, 값 ``a*x+b``\\를 "
"계산하는 함수 ``f(x)``\\를 반환하는 ``linear(a,b)``\\를 정의하려고 한다고 가정하십시오. 중첩된 스코프를 "
"사용해서::"

#: ../../faq/programming.rst:583
msgid ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"
msgstr ""

#: ../../faq/programming.rst:588
msgid "Or using a callable object::"
msgstr "또는 콜러블 객체를 사용해서::"

#: ../../faq/programming.rst:590
msgid ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"
msgstr ""

#: ../../faq/programming.rst:598
msgid "In both cases, ::"
msgstr "두 경우 모두, ::"

#: ../../faq/programming.rst:600
msgid "taxes = linear(0.3, 2)"
msgstr ""

#: ../../faq/programming.rst:602
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "``taxes(10e6) == 0.3 * 10e6 + 2``\\가 되도록 하는 콜러블 객체를 제공합니다."

#: ../../faq/programming.rst:604
msgid ""
"The callable object approach has the disadvantage that it is a bit slower"
" and results in slightly longer code.  However, note that a collection of"
" callables can share their signature via inheritance::"
msgstr ""
"콜러블 객체 접근 방식은 약간 느리고 코드가 약간 길어진다는 단점이 있습니다. 그러나, 콜러블 컬렉션은 상속을 통해 서명을 공유할 "
"수 있습니다::"

#: ../../faq/programming.rst:608
msgid ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"
msgstr ""

#: ../../faq/programming.rst:613
msgid "Object can encapsulate state for several methods::"
msgstr "객체는 여러 메서드의 상태를 캡슐화 할 수 있습니다::"

#: ../../faq/programming.rst:615
msgid ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"
msgstr ""

#: ../../faq/programming.rst:631
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share "
"the same counting variable."
msgstr "여기서 ``inc()``, ``dec()`` 및 ``reset()``\\은 같은 계수 변수를 공유하는 함수처럼 작동합니다."

#: ../../faq/programming.rst:636
msgid "How do I copy an object in Python?"
msgstr "파이썬에서 객체를 어떻게 복사합니까?"

#: ../../faq/programming.rst:638
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the "
"general case. Not all objects can be copied, but most can."
msgstr ""
"일반적으로, 일반적일 때 :func:`copy.copy`\\나 :func:`copy.deepcopy`\\를 시도하십시오. 모든 "
"객체를 복사할 수는 없지만, 대부분 가능합니다."

#: ../../faq/programming.rst:641
msgid ""
"Some objects can be copied more easily.  Dictionaries have a "
":meth:`~dict.copy` method::"
msgstr "일부 객체는 더 쉽게 복사할 수 있습니다. 딕셔너리에는 :meth:`~dict.copy` 메서드가 있습니다::"

#: ../../faq/programming.rst:644
msgid "newdict = olddict.copy()"
msgstr ""

#: ../../faq/programming.rst:646
msgid "Sequences can be copied by slicing::"
msgstr "시퀀스는 슬라이싱으로 복사할 수 있습니다::"

#: ../../faq/programming.rst:648
msgid "new_l = l[:]"
msgstr ""

#: ../../faq/programming.rst:652
msgid "How can I find the methods or attributes of an object?"
msgstr "객체의 메서드나 어트리뷰트를 어떻게 찾을 수 있습니까?"

#: ../../faq/programming.rst:654
#, fuzzy
msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` "
"returns an alphabetized list of the names containing the instance "
"attributes and methods and attributes defined by its class."
msgstr ""
"사용자 정의 클래스의 인스턴스 x에 대해, ``dir(x)``\\는 인스턴스 어트리뷰트와 메서드 및 해당 클래스에 의해 정의된 "
"어트리뷰트를 포함하는 알파벳순의 이름 리스트를 반환합니다."

#: ../../faq/programming.rst:660
msgid "How can my code discover the name of an object?"
msgstr "코드에서 객체 이름을 어떻게 찾을 수 있습니까?"

#: ../../faq/programming.rst:662
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true "
"of ``def`` and ``class`` statements, but in that case the value is a "
"callable. Consider the following code::"
msgstr ""
"일반적으로 말하자면, 객체에는 실제로 이름이 없기 때문에 그럴 수 없습니다. 기본적으로, 대입은 항상 이름을 값에 연결합니다; "
"``def``\\와 ``class`` 문의 경우도 마찬가지이지만, 이 경우 값은 콜러블입니다. 다음 코드를 고려하십시오::"

#: ../../faq/programming.rst:667
msgid ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"
msgstr ""

#: ../../faq/programming.rst:678
#, fuzzy
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as "
"an instance of class ``A``.  However, it is impossible to say whether the"
" instance's name is ``a`` or ``b``, since both names are bound to the "
"same value."
msgstr ""
"분명히 클래스는 이름이 있습니다: 설사 이것이 두 가지 이름에 연결되어 있고 이름 B를 통해 호출되었더라도 만들어진 인스턴스는 "
"여전히 클래스 A의 인스턴스로 보고됩니다. 그러나, 두 이름이 같은 값에 연결되기 때문에, 인스턴스 이름이 a인지 b인지는 말할 수"
" 없습니다."

#: ../../faq/programming.rst:683
msgid ""
"Generally speaking it should not be necessary for your code to \"know the"
" names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"일반적으로 말해 코드가 특정 값의 \"이름을 알아야\" 할 필요는 없습니다. 의도적으로 내성적인(introspective) "
"프로그램을 작성하지 않는 한, 이는 일반적으로 접근 방식의 변경이 도움이 될 수 있다는 신호입니다."

#: ../../faq/programming.rst:688
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in "
"answer to this question:"
msgstr "comp.lang.python에서, Fredrik Lundh는 언젠가 이 질문에 대해 훌륭한 비유를 했습니다:"

#: ../../faq/programming.rst:691
msgid ""
"The same way as you get the name of that cat you found on your porch: the"
" cat (object) itself cannot tell you its name, and it doesn't really care"
" -- so the only way to find out what it's called is to ask all your "
"neighbours (namespaces) if it's their cat (object)..."
msgstr ""
"여러분이 현관에서 발견한 고양이의 이름을 얻는 것과 같은 방법: 고양이(객체) 자체는 여러분에게 자신의 이름을 말할 수 없고, 전혀"
" 신경 쓰지도 않습니다 -- 따라서 그것이 어떻게 불리는지 알아내는 유일한 방법은 여러분 이웃 모두(이름 공간)에게 자신의 "
"고양이(객체)인지 묻는 것입니다..."

#: ../../faq/programming.rst:696
msgid ""
"....and don't be surprised if you'll find that it's known by many names, "
"or no name at all!"
msgstr ".... 여러 이름으로 알려져 있거나 전혀 이름이 없다는 것을 알게 되더라도 놀라지 마십시오!"

#: ../../faq/programming.rst:701
msgid "What's up with the comma operator's precedence?"
msgstr "쉼표 연산자의 우선순위는 어떻게 되나요?"

#: ../../faq/programming.rst:703
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "쉼표는 파이썬에서 연산자가 아닙니다. 이 세션을 고려하십시오::"

#: ../../faq/programming.rst:705
msgid ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"
msgstr ""

#: ../../faq/programming.rst:708
msgid ""
"Since the comma is not an operator, but a separator between expressions "
"the above is evaluated as if you had entered::"
msgstr "쉼표는 연산자가 아니라 표현식 사이의 구분자이기 때문에 위는 다음과 같이 입력한 것처럼 평가됩니다::"

#: ../../faq/programming.rst:711
msgid "(\"a\" in \"b\"), \"a\""
msgstr ""

#: ../../faq/programming.rst:713
msgid "not::"
msgstr "다음과 같이 평가되지 않습니다::"

#: ../../faq/programming.rst:715
msgid "\"a\" in (\"b\", \"a\")"
msgstr ""

#: ../../faq/programming.rst:717
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc)."
"  They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr "다양한 대입 연산자(``=``, ``+=`` 등)도 마찬가지입니다. 이들은 실제로 연산자가 아니라 대입 문의 문법 구분자입니다."

#: ../../faq/programming.rst:722
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "C의 \"?:\" 삼항 연산자와 동등한 것이 있습니까?"

#: ../../faq/programming.rst:724
msgid "Yes, there is. The syntax is as follows::"
msgstr "예, 있습니다. 문법은 다음과 같습니다::"

#: ../../faq/programming.rst:726
msgid ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"
msgstr ""

#: ../../faq/programming.rst:731
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to "
"use logical operators::"
msgstr "이 문법이 파이썬 2.5에서 소개되기 전에, 일반적인 관용구는 논리 연산자를 사용하는 것이었습니다::"

#: ../../faq/programming.rst:734
msgid "[expression] and [on_true] or [on_false]"
msgstr ""

#: ../../faq/programming.rst:736
msgid ""
"However, this idiom is unsafe, as it can give wrong results when "
"*on_true* has a false boolean value.  Therefore, it is always better to "
"use the ``... if ... else ...`` form."
msgstr ""
"그러나, 이 관용구는 안전하지 않습니다. *on_true*\\가 거짓 불리언 값을 가질 때 잘못된 결과가 나올 수 있습니다. "
"따라서, 항상 ``... if ... else ...`` 형식을 사용하는 것이 좋습니다."

#: ../../faq/programming.rst:742
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "파이썬에서 난독화된 한 줄 코드를 작성할 수 있습니까?"

#: ../../faq/programming.rst:744
#, fuzzy
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within "
":keyword:`!lambda`.  See the following three examples, slightly adapted "
"from Ulf Bartelt::"
msgstr ""
"예. 일반적으로 :keyword:`!lambda` 내에 :keyword:`lambda`\\를 중첩하여 수행됩니다. Ulf "
"Bartelt가 제공한, 다음 세 가지 예를 참조하십시오::"

#: ../../faq/programming.rst:747
#, python-format
msgid ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda"
" y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"
msgstr ""

#: ../../faq/programming.rst:771
msgid "Don't try this at home, kids!"
msgstr "집에서 이것을 시도하지 마십시오, 어린이들!"

#: ../../faq/programming.rst:777
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "함수의 매개변수 목록에서 슬래시(/)는 무엇을 의미합니까?"

#: ../../faq/programming.rst:779
#, fuzzy
msgid ""
"A slash in the argument list of a function denotes that the parameters "
"prior to it are positional-only.  Positional-only parameters are the ones"
" without an externally usable name.  Upon calling a function that accepts"
" positional-only parameters, arguments are mapped to parameters based "
"solely on their position. For example, :func:`divmod` is a function that "
"accepts positional-only parameters. Its documentation looks like this::"
msgstr ""
"함수의 인자 목록에서 슬래시는 그 앞에 있는 매개변수가 위치 전용임을 나타냅니다. 위치 전용 매개변수는 외부에서 사용할 수 있는 "
"이름이 없는 매개변수입니다. 위치 전용 매개변수를 받아들이는 함수를 호출하면, 인자는 해당 위치만을 기준으로 매개변수에 매핑됩니다."
" 예를 들어, :func:`divmod`\\는 위치 전용 매개변수를 받아들이는 함수입니다. 설명서는 다음과 같습니다::"

#: ../../faq/programming.rst:786
msgid ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."
msgstr ""

#: ../../faq/programming.rst:792
msgid ""
"The slash at the end of the parameter list means that both parameters are"
" positional-only. Thus, calling :func:`divmod` with keyword arguments "
"would lead to an error::"
msgstr ""
"매개변수 목록 끝의 슬래시는 두 매개변수가 위치 전용임을 의미합니다. 따라서, 키워드 인자로 :func:`divmod`\\를 "
"호출하면 에러가 발생합니다::"

#: ../../faq/programming.rst:796
msgid ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"
msgstr ""

#: ../../faq/programming.rst:803
msgid "Numbers and strings"
msgstr "숫자와 문자열"

#: ../../faq/programming.rst:806
msgid "How do I specify hexadecimal and octal integers?"
msgstr "16진수와 8진수 정수는 어떻게 지정합니까?"

#: ../../faq/programming.rst:808
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then "
"a lower or uppercase \"o\".  For example, to set the variable \"a\" to "
"the octal value \"10\" (8 in decimal), type::"
msgstr ""
"8진수를 지정하려면, 8진수 값 앞에 0을 붙이고, 소문자나 대문자 \"o\"를 붙입니다. 예를 들어, 변수 \"a\"를 8진수 값"
" \"10\"(10진수 8)으로 설정하려면, 이렇게 입력하십시오::"

#: ../../faq/programming.rst:812
msgid ""
">>> a = 0o10\n"
">>> a\n"
"8"
msgstr ""

#: ../../faq/programming.rst:816
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with "
"a zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python "
"interpreter::"
msgstr ""
"16진수도 쉽습니다. 16진수 앞에 0을 붙이고, 소문자나 대문자 \"x\"를 붙이기만 하면 됩니다. 16진 숫자는 소문자나 "
"대문자로 지정할 수 있습니다. 예를 들어, 파이썬 인터프리터에서::"

#: ../../faq/programming.rst:820
msgid ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"
msgstr ""

#: ../../faq/programming.rst:829
msgid "Why does -22 // 10 return -3?"
msgstr "왜 -22 // 10 이 -3을 반환합니까?"

#: ../../faq/programming.rst:831
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"주로 ``i % j``\\가 ``j``\\와 같은 부호를 갖도록 하려는 것입니다. 여러분이 이것을 원하고, 다음과 같은 것도 "
"원한다면::"

#: ../../faq/programming.rst:834
msgid "i == (i // j) * j + (i % j)"
msgstr ""

#: ../../faq/programming.rst:836
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to "
"make ``i % j`` have the same sign as ``i``."
msgstr ""
"정수 나누기는 floor를 반환해야 합니다. C 또한 이 항등식을 만족하도록 요구하고, ``i // j``\\를 "
"자르는(truncate) 컴파일러는 ``i % j``\\가 ``i`` 와 같은 부호를 갖도록 할 필요가 있습니다."

#: ../../faq/programming.rst:840
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more"
" useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did"
" it say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == "
"-10`` is a bug waiting to bite."
msgstr ""
"``j``\\가 음수인 경우 ``i % j``\\에 대한 실제 사용 사례는 거의 없습니다. ``j``\\가 양수이면, 많은 사례가 "
"있으며, 사실상 모든 경우에 ``i % j``\\가 ``>= 0``\\인 것이 더 유용합니다. 시계가 지금 10을 가리킨다면, "
"200시간 전에는 어디를 가리키겠습니까? ``-190 % 12 == 2``\\가 유용합니다; ``-190 % 12 == "
"-10``\\은 물기를 기다리는 버그입니다."

#: ../../faq/programming.rst:848
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr ""

#: ../../faq/programming.rst:850
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives "
"a :exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr ""

#: ../../faq/programming.rst:853
msgid ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"
msgstr ""

#: ../../faq/programming.rst:859
msgid ""
"The solution is to separate the literal from the period with either a "
"space or parentheses."
msgstr ""

#: ../../faq/programming.rst:869
msgid "How do I convert a string to a number?"
msgstr "문자열을 숫자로 어떻게 변환합니까?"

#: ../../faq/programming.rst:871
#, fuzzy
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to a floating-"
"point number, e.g. ``float('144') == 144.0``."
msgstr ""
"정수의 경우, 내장 :func:`int` 형 생성자를 사용하십시오, 예를 들어 ``int('144') == 144``. 마찬가지로,"
" :func:`float`\\는 부동 소수점으로 변환합니다, 예를 들어 ``float('144') == 144.0``."

#: ../../faq/programming.rst:875
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') "
"== 144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional"
" argument, so ``int( '0x144', 16) == 324``.  If the base is specified as "
"0, the number is interpreted using Python's rules: a leading '0o' "
"indicates octal, and '0x' indicates a hex number."
msgstr ""
"기본적으로 이것은 숫자를 심진수로 해석합니다. 그래서 ``int('0144') == 144``\\는 참이고 "
"``int('0x144')``\\는 :exc:`ValueError`\\를 발생시킵니다. ``int(string, base)``\\는"
" 두 번째 선택적 인자로 변환에 사용할 진수(base)를 받아들여서, ``int( '0x144', 16) == 324``\\입니다."
" base가 0으로 지정되면, 숫자는 파이썬의 규칙을 사용하여 해석됩니다: 선행 '0o'는 8진수를 나타내고, '0x'는 16진수를"
" 나타냅니다."

#: ../../faq/programming.rst:882
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to "
"convert strings to numbers.  :func:`eval` will be significantly slower "
"and it presents a security risk: someone could pass you a Python "
"expression that might have unwanted side effects.  For example, someone "
"could pass ``__import__('os').system(\"rm -rf $HOME\")`` which would "
"erase your home directory."
msgstr ""
"필요한 것이 문자열을 숫자로 변환하는 것뿐이라면 내장 함수 :func:`eval`\\을 사용하지 마십시오. "
":func:`eval`\\은 상당히 느리며 보안 위험을 초래할 수 있습니다: 누군가 원하지 않는 부작용이 있는 파이썬 표현식을 "
"전달할 수 있습니다. 예를 들어, 누군가 여러분의 홈 디렉터리를 지우는 ``__import__('os').system(\"rm "
"-rf $HOME\")``\\을 전달할 수 있습니다."

#: ../../faq/programming.rst:889
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because "
"Python does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval`\\은 또한 숫자를 파이썬 표현식으로 해석하는 효과가 있어서, 예를 들어 ``eval('09')``\\는 "
"파이썬이 ('0'을 제외한 )십진수에서 선행 '0'을 허용하지 않기 때문에 구문 에러가 발생합니다."

#: ../../faq/programming.rst:895
msgid "How do I convert a number to a string?"
msgstr "숫자를 문자열로 어떻게 변환합니까?"

#: ../../faq/programming.rst:897
#, fuzzy, python-brace-format
msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the "
"built-in type constructor :func:`str`.  If you want a hexadecimal or "
"octal representation, use the built-in functions :func:`hex` or "
":func:`oct`.  For fancy formatting, see the :ref:`f-strings` and "
":ref:`formatstrings` sections, e.g. ``\"{:04d}\".format(144)`` yields "
"``'0144'`` and ``\"{:.3f}\".format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"예를 들어 숫자 144를 문자열 '144'로 변환하려면, 내장형 생성자 :func:`str`\\을 사용하십시오. 16진수나 8진수 "
"표현을 원하면, 내장 함수 :func:`hex`\\나 :func:`oct`\\를 사용하십시오. 멋진 포매팅이 필요하면, "
":ref:`f-strings`\\과 :ref:`formatstrings` 섹션을 참조하십시오, 예를 들어 "
"``\"{:04d}\".format(144)``\\는 ``'0144'``\\를 산출하고 "
"``\"{:.3f}\".format(1.0/3.0)``\\은 ``'0.333'``\\을 산출합니다."

#: ../../faq/programming.rst:906
msgid "How do I modify a string in place?"
msgstr "제자리에서 문자열을 어떻게 수정합니까?"

#: ../../faq/programming.rst:908
msgid ""
"You can't, because strings are immutable.  In most situations, you should"
" simply construct a new string from the various parts you want to "
"assemble it from.  However, if you need an object with the ability to "
"modify in-place unicode data, try using an :class:`io.StringIO` object or"
" the :mod:`array` module::"
msgstr ""
"그럴 수 없습니다. 문자열은 불변이기 때문입니다. 대부분의 경우, 조립하려는 다양한 부분으로 새 문자열을 구성해야 합니다. 그러나 "
"제자리에서 유니코드 데이터를 수정할 수 있는 객체가 필요하면, :class:`io.StringIO` 객체나 :mod:`array` "
"모듈을 사용해보십시오::"

#: ../../faq/programming.rst:914
msgid ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"
msgstr ""

#: ../../faq/programming.rst:938
msgid "How do I use strings to call functions/methods?"
msgstr "문자열을 사용하여 어떻게 함수/메서드를 호출합니까?"

#: ../../faq/programming.rst:940
msgid "There are various techniques."
msgstr "다양한 기법이 있습니다."

#: ../../faq/programming.rst:942
msgid ""
"The best is to use a dictionary that maps strings to functions.  The "
"primary advantage of this technique is that the strings do not need to "
"match the names of the functions.  This is also the primary technique "
"used to emulate a case construct::"
msgstr ""
"문자열을 함수로 매핑하는 딕셔너리를 사용하는 것이 가장 좋습니다. 이 기법의 주요 장점은 문자열이 함수 이름과 일치할 필요가 없다는"
" 것입니다. 이것은 또한 case 구문을 흉내 내는 데 사용되는 기본 기법입니다::"

#: ../../faq/programming.rst:947
#, python-brace-format
msgid ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\n"
"\n"
"dispatch[get_input()]()  # Note trailing parens to call function"
msgstr ""

#: ../../faq/programming.rst:957
msgid "Use the built-in function :func:`getattr`::"
msgstr "내장 함수 :func:`getattr`\\을 사용하십시오::"

#: ../../faq/programming.rst:959
msgid ""
"import foo\n"
"getattr(foo, 'bar')()"
msgstr ""

#: ../../faq/programming.rst:962
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ":func:`getattr`\\은 클래스, 클래스 인스턴스, 모듈 등을 포함하는 모든 객체에서 작동함에 유의하십시오."

#: ../../faq/programming.rst:965
msgid "This is used in several places in the standard library, like this::"
msgstr "이것은 다음과 같이 표준 라이브러리의 여러 곳에서 사용됩니다::"

#: ../../faq/programming.rst:967
msgid ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"
msgstr ""

#: ../../faq/programming.rst:978
msgid "Use :func:`locals` to resolve the function name::"
msgstr "함수 이름을 해석(resolve)하려면 :func:`locals`\\를 사용하십시오::"

#: ../../faq/programming.rst:980
msgid ""
"def myFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"
msgstr ""

#: ../../faq/programming.rst:990
#, fuzzy
msgid ""
"Is there an equivalent to Perl's ``chomp()`` for removing trailing "
"newlines from strings?"
msgstr "문자열에서 후행 줄 바꿈을 제거하는 Perl의 chomp()와 동등한 것이 있습니까?"

#: ../../faq/programming.rst:992
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any "
"line terminator from the end of the string ``S`` without removing other "
"trailing whitespace.  If the string ``S`` represents more than one line, "
"with several empty lines at the end, the line terminators for all the "
"blank lines will be removed::"
msgstr ""
"``S.rstrip(\"\\r\\n\")``\\을 사용하면 다른 후행 공백을 제거하지 않고 문자열 ``S``\\의 끝에 있는 모든 "
"줄 종결자를 제거 할 수 있습니다. 문자열 ``S``\\가 끝에 빈 줄이 여러 개 붙어 한 줄 이상을 나타내면, 모든 빈 줄의 줄 "
"종결자가 제거됩니다::"

#: ../../faq/programming.rst:998
msgid ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"
msgstr ""

#: ../../faq/programming.rst:1004
msgid ""
"Since this is typically only desired when reading text one line at a "
"time, using ``S.rstrip()`` this way works well."
msgstr ""
"일반적으로 한 번에 한 줄씩 텍스트를 읽을 때만 필요하기 때문에, ``S.rstrip()``\\을 이런 식으로 사용하면 잘 "
"작동합니다."

#: ../../faq/programming.rst:1009
#, fuzzy
msgid "Is there a ``scanf()`` or ``sscanf()`` equivalent?"
msgstr "scanf()나 sscanf()에 해당하는 것이 있습니까?"

#: ../../faq/programming.rst:1011
msgid "Not as such."
msgstr "그런 식으로는 없습니다."

#: ../../faq/programming.rst:1013
#, fuzzy
msgid ""
"For simple input parsing, the easiest approach is usually to split the "
"line into whitespace-delimited words using the :meth:`~str.split` method "
"of string objects and then convert decimal strings to numeric values "
"using :func:`int` or :func:`float`.  :meth:`!split` supports an optional "
"\"sep\" parameter which is useful if the line uses something other than "
"whitespace as a separator."
msgstr ""
"간단한 입력 구문 분석의 경우, 가장 쉬운 방법은 보통 문자열 객체의 :meth:`~str.split` 메서드를 사용하여 줄을 "
"공백으로 구분된 단어로 분할한 다음 :func:`int`\\나 :func:`float`\\를 사용하여 십진수 문자열을 숫자 값으로 "
"변환하는 것입니다. ``split()``\\는 선택적 \"sep\" 매개변수를 지원합니다. 이 매개변수는 줄이 공백 이외의 문자를 "
"구분자로 사용하는 경우에 유용합니다."

#: ../../faq/programming.rst:1019
#, fuzzy
msgid ""
"For more complicated input parsing, regular expressions are more powerful"
" than C's ``sscanf`` and better suited for the task."
msgstr "더 복잡한 입력 구문 분석의 경우, 정규식은 C의 :c:func:`sscanf`\\보다 강력하며 작업에 더 적합합니다."

#: ../../faq/programming.rst:1024
#, fuzzy
msgid "What does ``UnicodeDecodeError`` or ``UnicodeEncodeError`` error mean?"
msgstr "'UnicodeDecodeError'나 'UnicodeEncodeError' 에러는 무엇을 의미합니까?"

#: ../../faq/programming.rst:1026
msgid "See the :ref:`unicode-howto`."
msgstr ":ref:`unicode-howto`\\를 참조하십시오."

#: ../../faq/programming.rst:1032
msgid "Can I end a raw string with an odd number of backslashes?"
msgstr ""

#: ../../faq/programming.rst:1034
msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr ""

#: ../../faq/programming.rst:1036
msgid ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"
msgstr ""

#: ../../faq/programming.rst:1042
msgid ""
"There are several workarounds for this. One is to use regular strings and"
" double the backslashes::"
msgstr ""

#: ../../faq/programming.rst:1045
msgid ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""

#: ../../faq/programming.rst:1048
msgid ""
"Another is to concatenate a regular string containing an escaped "
"backslash to the raw string::"
msgstr ""

#: ../../faq/programming.rst:1051
msgid ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""

#: ../../faq/programming.rst:1054
msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr ""

#: ../../faq/programming.rst:1056
msgid ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""

#: ../../faq/programming.rst:1059
msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when "
"interpreting the value of the raw string. That is, the backslash remains "
"present in the value of the raw string::"
msgstr ""

#: ../../faq/programming.rst:1064
msgid ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""
msgstr ""

#: ../../faq/programming.rst:1067
msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr ""

#: ../../faq/programming.rst:1070
msgid "Performance"
msgstr "성능"

#: ../../faq/programming.rst:1073
msgid "My program is too slow. How do I speed it up?"
msgstr "내 프로그램이 너무 느립니다. 속도를 높이려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:1075
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr "그것은 일반적으로 힘든 일입니다. 먼저, 더 뛰어들기 전에 기억해야 할 사항이 있습니다:"

#: ../../faq/programming.rst:1078
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ"
" focuses on :term:`CPython`."
msgstr "성능 특성은 파이썬 구현마다 다릅니다. 이 FAQ는 :term:`CPython`\\에 중점을 둡니다."

#: ../../faq/programming.rst:1080
msgid ""
"Behaviour can vary across operating systems, especially when talking "
"about I/O or multi-threading."
msgstr "동작은 운영 체제마다 다를 수 있습니다, 특히 I/O 나 다중 스레드에 관해 이야기할 때 그렇습니다."

#: ../../faq/programming.rst:1082
msgid ""
"You should always find the hot spots in your program *before* attempting "
"to optimize any code (see the :mod:`profile` module)."
msgstr "코드를 최적화하려고 시도하기 *전에* 프로그램에서 항상 핫스팟을 찾아야 합니다 (:mod:`profile` 모듈을 참조하십시오)."

#: ../../faq/programming.rst:1084
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when "
"searching for improvements (see the :mod:`timeit` module)."
msgstr "벤치마크 스크립트를 작성하면 개선 사항을 탐색할 때 빠르게 반복할 수 있습니다 (:mod:`timeit` 모듈 참조)."

#: ../../faq/programming.rst:1086
msgid ""
"It is highly recommended to have good code coverage (through unit testing"
" or any other technique) before potentially introducing regressions "
"hidden in sophisticated optimizations."
msgstr ""
"정교한 최적화에 숨겨진 회귀(regressions)를 잠재적으로 도입하기 전에 (단위 테스트나 기타 기법을 통해) 우수한 코드 "
"커버리지를 갖는 것이 좋습니다."

#: ../../faq/programming.rst:1090
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are"
" some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"이것을 전제로, 파이썬 코드 속도를 높이는 많은 트릭이 있습니다. 다음은 수용 가능한 성능 수준에 도달하기 위해 먼 길을 갈 때 "
"도움이 되는 몇 가지 일반적인 원칙입니다:"

#: ../../faq/programming.rst:1094
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much"
" larger benefits than trying to sprinkle micro-optimization tricks all "
"over your code."
msgstr ""
"알고리즘을 더 빠르게 만들면 (또는 더 빠른 알고리즘으로 변경하면) 코드 전체에 미세 최적화 트릭을 뿌리는 것보다 훨씬 큰 이점을 "
"얻을 수 있습니다."

#: ../../faq/programming.rst:1098
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"올바른 데이터 구조를 사용하십시오. :ref:`bltin-types`\\과 :mod:`collections` 모듈에 대한 설명서를 "
"연구하십시오."

#: ../../faq/programming.rst:1101
msgid ""
"When the standard library provides a primitive for doing something, it is"
" likely (although not guaranteed) to be faster than any alternative you "
"may come up with.  This is doubly true for primitives written in C, such "
"as builtins and some extension types.  For example, be sure to use either"
" the :meth:`list.sort` built-in method or the related :func:`sorted` "
"function to do sorting (and see the :ref:`sortinghowto` for examples of "
"moderately advanced usage)."
msgstr ""
"표준 라이브러리가 무언가를 하기 위한 프리미티브를 제공할 때, 여러분이 떠올린 다른 대안보다 빠를 가능성이 높습니다 (보장되지는 "
"않습니다). 이것은 내장과 일부 확장형과 같이 C로 작성된 프리미티브의 경우에는 두 배로 그렇습니다. 예를 들어, 정렬하려면 "
":meth:`list.sort` 내장 메서드나 관련 :func:`sorted` 함수를 사용하십시오 (그리고 약간 고급 사용법의 예는"
" :ref:`sortinghowto`\\를 참조하십시오)."

#: ../../faq/programming.rst:1109
msgid ""
"Abstractions tend to create indirections and force the interpreter to "
"work more.  If the levels of indirection outweigh the amount of useful "
"work done, your program will be slower.  You should avoid excessive "
"abstraction, especially under the form of tiny functions or methods "
"(which are also often detrimental to readability)."
msgstr ""
"추상화는 간접(indirections)을 만드는 경향이 있고 인터프리터가 더 많은 일을 하도록 강요합니다. 간접의 수준이 유용한 "
"작업의 양을 초과하면, 프로그램 속도가 느려집니다. 과도한 추상화를 피해야 합니다, 특히 작은 함수나 메서드의 형태에서 그렇습니다 "
"(종종 가독성에도 해롭습니다)."

#: ../../faq/programming.rst:1115
#, fuzzy
msgid ""
"If you have reached the limit of what pure Python can allow, there are "
"tools to take you further away.  For example, `Cython "
"<https://cython.org>`_ can compile a slightly modified version of Python "
"code into a C extension, and can be used on many different platforms.  "
"Cython can take advantage of compilation (and optional type annotations) "
"to make your code significantly faster than when interpreted.  If you are"
" confident in your C programming skills, you can also :ref:`write a C "
"extension module <extending-index>` yourself."
msgstr ""
"순수 파이썬이 허용할 수 있는 한도에 도달했다면, 더 멀리 갈 수 있는 도구가 있습니다. 예를 들어, `Cython "
"<http://cython.org>`_\\은 약간 수정된 버전의 파이썬 코드를 C 확장으로 컴파일 할 수 있으며, 여러 플랫폼에서 "
"사용할 수 있습니다. Cython은 컴파일(과 선택적 형 어노테이션)을 활용하여 코드를 인터프리트 할 때 보다 훨씬 빠르게 만들 수"
" 있습니다. C 프로그래밍 기술에 확신이 있다면, 직접 :ref:`C 확장 모듈을 작성할 <extending-index>` 수도 "
"있습니다."

#: ../../faq/programming.rst:1125
msgid ""
"The wiki page devoted to `performance tips "
"<https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_."
msgstr ""
"`성능 팁 <https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_\\에 할당된"
" 위키 페이지."

#: ../../faq/programming.rst:1131
msgid "What is the most efficient way to concatenate many strings together?"
msgstr "많은 문자열을 함께 이어붙이는 가장 효율적인 방법은 무엇입니까?"

#: ../../faq/programming.rst:1133
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
":class:`str`\\과 :class:`bytes` 객체는 불변이므로, 많은 문자열을 함께 이어붙이면 각 이어붙이기가 새 객체를"
" 생성하기 때문에 비효율적입니다. 일반적일 때, 총 실행 시간 비용은 전체 문자열 길이의 제곱에 비례합니다."

#: ../../faq/programming.rst:1138
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to "
"place them into a list and call :meth:`str.join` at the end::"
msgstr ""
"많은 :class:`str` 객체를 누적하기 위해, 권장되는 관용구는 객체를 리스트에 배치하고 마지막에 "
":meth:`str.join`\\을 호출하는 것입니다::"

#: ../../faq/programming.rst:1141
msgid ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"
msgstr ""

#: ../../faq/programming.rst:1146
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr "(또 다른 합리적으로 효율적인 관용구는 :class:`io.StringIO`\\를 사용하는 것입니다)"

#: ../../faq/programming.rst:1148
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the "
"``+=`` operator)::"
msgstr ""
"많은 :class:`bytes` 객체를 누적하기 위해, 권장되는 관용구는 제자리 이어붙이기(``+=`` 연산자)을 사용하여 "
":class:`bytearray` 객체를 확장하는 것입니다::"

#: ../../faq/programming.rst:1151
msgid ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"
msgstr ""

#: ../../faq/programming.rst:1157
msgid "Sequences (Tuples/Lists)"
msgstr "시퀀스 (튜플/리스트)"

#: ../../faq/programming.rst:1160
msgid "How do I convert between tuples and lists?"
msgstr "튜플과 리스트를 어떻게 변환합니까?"

#: ../../faq/programming.rst:1162
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"형 생성자 ``tuple(seq)``\\는 임의의 시퀀스(실제로는, 모든 이터러블)를 같은 순서로 같은 항목을 가진 튜플로 "
"변환합니다."

#: ../../faq/programming.rst:1165
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and "
"``tuple('abc')`` yields ``('a', 'b', 'c')``.  If the argument is a tuple,"
" it does not make a copy but returns the same object, so it is cheap to "
"call :func:`tuple` when you aren't sure that an object is already a "
"tuple."
msgstr ""
"예를 들어, ``tuple([1, 2, 3])``\\은 ``(1, 2, 3)``\\을 산출하고 ``tuple('abc')``\\는 "
"``('a', 'b', 'c')``\\를 산출합니다. 인자가 튜플이면 사본을 만들지 않고 같은 객체를 반환하므로, 객체가 이미 "
"튜플인지 확실하지 않을 때 :func:`tuple`\\을 호출하는 것이 저렴합니다."

#: ../../faq/programming.rst:1170
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into"
" a list with the same items in the same order.  For example, ``list((1, "
"2, 3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', "
"'c']``.  If the argument is a list, it makes a copy just like ``seq[:]`` "
"would."
msgstr ""
"형 생성자 ``list(seq)``\\는 임의의 시퀀스나 이터러블을 같은 순서로 같은 항목이 있는 리스트로 변환합니다. 예를 들어,"
" ``list((1, 2, 3))``\\은 ``[1, 2, 3]``\\을 산출하고 ``list('abc')``\\는 ``['a', "
"'b', 'c']``\\를 산출합니다. 인자가 리스트이면, ``seq[:]``\\와 같이 사본을 만듭니다."

#: ../../faq/programming.rst:1177
msgid "What's a negative index?"
msgstr "음수 인덱스는 무엇입니까?"

#: ../../faq/programming.rst:1179
msgid ""
"Python sequences are indexed with positive numbers and negative numbers."
"  For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the "
"penultimate (next to last) index and so forth.  Think of ``seq[-n]`` as "
"the same as ``seq[len(seq)-n]``."
msgstr ""
"파이썬 시퀀스는 양수와 음수로 인덱싱됩니다. 양수의 경우 0은 첫 번째 인덱스이고 1은 두 번째 인덱스이고 이런 식으로 계속됩니다."
" 음수 인덱스의 경우 -1은 마지막 인덱스이고 -2는 끝에서 두 번째 인덱스이고 이런 식으로 계속됩니다. ``seq[-n]``\\을"
" ``seq[len(seq)-n]``\\과 같다고 생각하십시오."

#: ../../faq/programming.rst:1184
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is"
" all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"음수 인덱스를 사용하면 매우 편리할 수 있습니다. 예를 들어 ``S[:-1]``\\은 마지막 문자를 제외한 문자열의 모든 것인데, "
"문자열에서 후행 줄 바꿈을 제거하는 데 유용합니다."

#: ../../faq/programming.rst:1190
msgid "How do I iterate over a sequence in reverse order?"
msgstr "시퀀스를 역순으로 이터레이트 하려면 어떻게 합니까?"

#: ../../faq/programming.rst:1192
msgid "Use the :func:`reversed` built-in function::"
msgstr ":func:`reversed` 내장 함수를 사용하십시오::"

#: ../../faq/programming.rst:1194
msgid ""
"for x in reversed(sequence):\n"
"    ...  # do something with x ..."
msgstr ""

#: ../../faq/programming.rst:1197
msgid ""
"This won't touch your original sequence, but build a new copy with "
"reversed order to iterate over."
msgstr "이것은 원본 시퀀스에는 영향을 미치지 않지만, 이터레이트 할 뒤집힌 순서의 새 사본을 만듭니다."

#: ../../faq/programming.rst:1202
msgid "How do you remove duplicates from a list?"
msgstr "리스트에서 중복을 어떻게 제거합니까?"

#: ../../faq/programming.rst:1204
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr "이 작업을 수행하는 여러 가지 방법에 대한 긴 논의는 파이썬 요리책을 참조하십시오:"

#: ../../faq/programming.rst:1206
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1208
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end"
" of the list, deleting duplicates as you go::"
msgstr "리스트 순서를 바꿔도 상관없다면, 리스트를 정렬한 다음 리스트 끝에서 스캔하면서 중복 항목을 삭제하십시오::"

#: ../../faq/programming.rst:1211
msgid ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"
msgstr ""

#: ../../faq/programming.rst:1220
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all "
":term:`hashable`) this is often faster ::"
msgstr ""
"리스트의 모든 요소가 집합 키로 사용될 수 있다면 (즉, 모두 :term:`해시 가능 <hashable>`\\이면) 이것이 종종 더"
" 빠릅니다 ::"

#: ../../faq/programming.rst:1223
msgid "mylist = list(set(mylist))"
msgstr ""

#: ../../faq/programming.rst:1225
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr "이것은 리스트를 집합으로 변환하여, 중복을 제거한 다음, 리스트로 되돌립니다."

#: ../../faq/programming.rst:1230
msgid "How do you remove multiple items from a list"
msgstr "리스트에서 여러 항목을 어떻게 제거합니까?"

#: ../../faq/programming.rst:1232
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a "
"delete condition is one possibility.  However, it is easier and faster to"
" use slice replacement with an implicit or explicit forward iteration. "
"Here are three variations.::"
msgstr ""
"중복 제거와 마찬가지로, 삭제 조건을 사용하여 명시적으로 역순으로 이터레이션 하는 것도 한 가지 가능성입니다. 그러나, 묵시적이나 "
"명시적 순방향 이터레이션으로 슬라이스 치환을 사용하기가 더 쉽고 빠릅니다. 다음은 세 가지 변형입니다.::"

#: ../../faq/programming.rst:1237
msgid ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"
msgstr ""

#: ../../faq/programming.rst:1241
msgid "The list comprehension may be fastest."
msgstr "리스트 컴프리헨션이 아마 가장 빠릅니다."

#: ../../faq/programming.rst:1245
msgid "How do you make an array in Python?"
msgstr "파이썬에서 어떻게 배열을 만드나요?"

#: ../../faq/programming.rst:1247
msgid "Use a list::"
msgstr "리스트를 사용하십시오::"

#: ../../faq/programming.rst:1249
msgid "[\"this\", 1, \"is\", \"an\", \"array\"]"
msgstr ""

#: ../../faq/programming.rst:1251
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"리스트는 시간 복잡성 면에서 C나 파스칼(Pascal) 배열과 동등합니다; 가장 큰 차이점은 파이썬 리스트에 다양한 형의 객체가 "
"포함될 수 있다는 것입니다."

#: ../../faq/programming.rst:1254
#, fuzzy
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that `NumPy <https://numpy.org/>`_ and other third "
"party packages define array-like structures with various characteristics "
"as well."
msgstr ""
"``array`` 모듈은 또한 간결한 표현으로 고정형의 배열을 만드는 메서드를 제공하지만, 리스트보다 인덱싱하는 속도가 느립니다. "
"또한 Numeric 확장과 기타의 것들은 다양한 특성을 가진 배열과 유사한 구조를 정의함에 유의하십시오."

#: ../../faq/programming.rst:1260
#, fuzzy
msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using "
"tuples::"
msgstr ""
"리스프(Lisp) 스타일의 링크드 리스트(linked lists)를 얻으려면, 튜플을 사용하여 콘스 셀(cons cells)을 흉내"
" 낼 수 있습니다::"

#: ../../faq/programming.rst:1262
msgid "lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )"
msgstr ""

#: ../../faq/programming.rst:1264
#, fuzzy
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here "
"the analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of "
"*cdr* is ``lisp_list[1]``.  Only do this if you're sure you really need "
"to, because it's usually a lot slower than using Python lists."
msgstr ""
"가변성이 필요하면, 튜플 대신 리스트를 사용할 수 있습니다. 여기서 리스프 car에 해당하는 것은 "
"``lisp_list[0]``\\이고 cdr에 해당하는 것은 ``lisp_list[1]``\\입니다. 일반적으로 파이썬 리스트를 "
"사용하는 것보다 속도가 느리기 때문에, 꼭 필요하다고 확신할 때만 이렇게 하십시오."

#: ../../faq/programming.rst:1273
msgid "How do I create a multidimensional list?"
msgstr "다차원 리스트를 어떻게 만듭니까?"

#: ../../faq/programming.rst:1275
msgid "You probably tried to make a multidimensional array like this::"
msgstr "다음과 같이 다차원 배열을 만들려고 했을 것입니다::"

#: ../../faq/programming.rst:1277
msgid ">>> A = [[None] * 2] * 3"
msgstr ""

#: ../../faq/programming.rst:1279
msgid "This looks correct if you print it:"
msgstr "인쇄하면 올바르게 보입니다:"

#: ../../faq/programming.rst:1285
msgid ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"
msgstr ""

#: ../../faq/programming.rst:1290
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "그러나 값을 대입하면, 여러 위치에 나타납니다:"

#: ../../faq/programming.rst:1296
msgid ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"
msgstr ""

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, "
"it only creates references to the existing objects.  The ``*3`` creates a"
" list containing 3 references to the same list of length two.  Changes to"
" one row will show in all rows, which is almost certainly not what you "
"want."
msgstr ""
"그 이유는 ``*``\\로 리스트를 복제해도 복사본을 만들지 않고 기존 객체에 대한 참조만 만들기 때문입니다. ``*3``\\은 "
"길이 2의 같은 리스트에 대한 3개의 참조를 포함하는 리스트를 만듭니다. 한 행에 대한 변경 사항은 모든 행에 나타나는데, 거의 "
"확실히 여러분이 원하는 것은 아닙니다."

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first "
"and then fill in each element with a newly created list::"
msgstr "제안된 방법은 원하는 길이의 리스트를 먼저 만든 다음 새로 만든 리스트로 각 요소를 채우는 것입니다::"

#: ../../faq/programming.rst:1310
msgid ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"
msgstr ""

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You "
"can also use a list comprehension::"
msgstr "그러면 길이가 2인 3개의 다른 리스트를 포함하는 리스트가 생성됩니다. 리스트 컴프리헨션도 사용할 수 있습니다::"

#: ../../faq/programming.rst:1317
msgid ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"
msgstr ""

#: ../../faq/programming.rst:1320
#, fuzzy
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"또는, 행렬 데이터형을 제공하는 확장을 사용할 수 있습니다. `NumPy <http://www.numpy.org/>`_\\가 가장 "
"잘 알려져 있습니다."

#: ../../faq/programming.rst:1325
#, fuzzy
msgid "How do I apply a method or function to a sequence of objects?"
msgstr "객체의 시퀀스에 메서드를 어떻게 적용합니까?"

#: ../../faq/programming.rst:1327
msgid ""
"To call a method or function and accumulate the return values is a list, "
"a :term:`list comprehension` is an elegant solution::"
msgstr ""

#: ../../faq/programming.rst:1330
msgid ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"
msgstr ""

#: ../../faq/programming.rst:1334
msgid ""
"To just run the method or function without saving the return values, a "
"plain :keyword:`for` loop will suffice::"
msgstr ""

#: ../../faq/programming.rst:1337
msgid ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"
msgstr ""

#: ../../faq/programming.rst:1346
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition "
"works?"
msgstr "덧셈은 작동하는데, 왜 a_tuple[i] += ['item']이 예외를 일으킵니까?"

#: ../../faq/programming.rst:1348
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable "
"and immutable objects in Python."
msgstr "이는 증분 대입 연산자가 *대입* 연산자라는 사실과 파이썬에서 가변 객체와 불변 객체의 차이점이 결합하기 때문입니다."

#: ../../faq/programming.rst:1352
msgid ""
"This discussion applies in general when augmented assignment operators "
"are applied to elements of a tuple that point to mutable objects, but "
"we'll use a ``list`` and ``+=`` as our exemplar."
msgstr ""
"이 논의는 증분 대입 연산자가 가변 객체를 가리키는 튜플의 요소에 적용될 때 일반적으로 적용되지만, 우리는 ``list``\\와 "
"``+=``\\를 예제로 사용합니다."

#: ../../faq/programming.rst:1356
msgid "If you wrote::"
msgstr "다음과 같이 작성한다면::"

#: ../../faq/programming.rst:1358
msgid ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""

#: ../../faq/programming.rst:1364
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added "
"to the object ``a_tuple[0]`` points to (``1``), producing the result "
"object, ``2``, but when we attempt to assign the result of the "
"computation, ``2``, to element ``0`` of the tuple, we get an error "
"because we can't change what an element of a tuple points to."
msgstr ""
"예외의 이유는 명확합니다: ``1``\\이 ``a_tuple[0]``\\이 가리키는 객체(``1``)에 더해져서, 결과 객체 "
"``2``\\를 생성하지만, 계산 결과 ``2``\\를 튜플의 요소 ``0``\\에 대입하려고 하면, 튜플의 요소가 가리키는 것을 "
"변경할 수 없기 때문에 에러가 발생합니다."

#: ../../faq/programming.rst:1370
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr "수면 아래에서, 이 증분 대입문이 하는 일은 대략 다음과 같습니다::"

#: ../../faq/programming.rst:1373
msgid ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""

#: ../../faq/programming.rst:1379
msgid ""
"It is the assignment part of the operation that produces the error, since"
" a tuple is immutable."
msgstr "튜플은 불변이므로, 연산의 대입 부분이 에러를 발생시킵니다."

#: ../../faq/programming.rst:1382
msgid "When you write something like::"
msgstr "다음과 같이 작성하면::"

#: ../../faq/programming.rst:1384
msgid ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""

#: ../../faq/programming.rst:1390
msgid ""
"The exception is a bit more surprising, and even more surprising is the "
"fact that even though there was an error, the append worked::"
msgstr "예외는 조금 더 놀랍습니다, 더 놀라운 것은 에러가 있었지만 더하기가 동작했다는 사실입니다::"

#: ../../faq/programming.rst:1393
msgid ""
">>> a_tuple[0]\n"
"['foo', 'item']"
msgstr ""

#: ../../faq/programming.rst:1396
#, fuzzy
msgid ""
"To see why this happens, you need to know that (a) if an object "
"implements an :meth:`~object.__iadd__` magic method, it gets called when "
"the ``+=`` augmented assignment is executed, and its return value is what"
" gets used in the assignment statement; and (b) for lists, "
":meth:`!__iadd__` is equivalent to calling :meth:`!extend` on the list "
"and returning the list.  That's why we say that for lists, ``+=`` is a "
"\"shorthand\" for :meth:`!list.extend`::"
msgstr ""
"왜 이런 일이 일어나는지 알려면, 이런 것들을 알 필요가 있습니다. (a) 객체가 ``__iadd__`` 매직 메서드를 구현하면, "
"``+=`` 증분 대입이 실행될 때 이것이 호출되고 반환 값이 대입문에 사용되는 값입니다; (b) 리스트의 경우, "
"``__iadd__``\\는 리스트의 ``extend``\\를 호출하고 리스트를 반환하는 것과 동등합니다. 이것이 우리가 리스트에서"
" ``+=``\\가 ``list.extend``\\의 \"줄임 표현\"이라고 말하는 이유입니다::"

#: ../../faq/programming.rst:1404
msgid ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"
msgstr ""

#: ../../faq/programming.rst:1409
msgid "This is equivalent to::"
msgstr "이것은 다음과 동등합니다::"

#: ../../faq/programming.rst:1411
msgid ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"
msgstr ""

#: ../../faq/programming.rst:1414
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"a_list가 가리키는 객체가 변경되었고, 변경된 객체에 대한 포인터가 다시 ``a_list``\\에 대입됩니다. 대입의 최종 "
"결과는 no-op인데, ``a_list``\\가 이전에 가리키고 있던 것과 같은 객체에 대한 포인터이기 때문입니다, 하지만 대입은 "
"여전히 일어납니다."

#: ../../faq/programming.rst:1419
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "따라서, 우리의 튜플 예제에서 일어나는 일은 다음과 동등합니다::"

#: ../../faq/programming.rst:1421
msgid ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""

#: ../../faq/programming.rst:1427
#, fuzzy
msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because "
"tuples are immutable."
msgstr ""
"``__iadd__``\\는 성공하고, 따라서 리스트는 확장됩니다. 하지만, ``result``\\가 "
"``a_tuple[0]``\\이 이미 가리키는 것과 같은 객체를 가리키더라도, 튜플은 불변이므로, 최종 대입은 여전히 에러를 "
"발생시킵니다."

#: ../../faq/programming.rst:1433
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr "복잡한 정렬을 하고 싶습니다: 파이썬에서 Schwartzian 변환을 할 수 있습니까?"

#: ../../faq/programming.rst:1435
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts"
" the elements of a list by a metric which maps each element to its \"sort"
" value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"Perl 커뮤니티의 Randal Schwartz에 의한 이 기법은 리스트의 각 요소를 각 요소를 \"정렬 값\"에 매핑하는 "
"메트릭으로 정렬합니다. 파이썬에서는, :meth:`list.sort` 메서드의 ``key`` 인자를 사용하십시오::"

#: ../../faq/programming.rst:1439
msgid ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"
msgstr ""

#: ../../faq/programming.rst:1444
msgid "How can I sort one list by values from another list?"
msgstr "한 리스트를 다른 리스트의 값으로 정렬하려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:1446
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr "그것들을 튜플의 이터레이터로 병합하고, 결과 리스트를 정렬한 다음, 원하는 요소를 선택하십시오. ::"

#: ../../faq/programming.rst:1449
msgid ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', "
"'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"
msgstr ""

#: ../../faq/programming.rst:1461
msgid "Objects"
msgstr "객체"

#: ../../faq/programming.rst:1464
msgid "What is a class?"
msgstr "클래스는 무엇입니까?"

#: ../../faq/programming.rst:1466
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance "
"objects, which embody both the data (attributes) and code (methods) "
"specific to a datatype."
msgstr ""
"클래스는 class 문을 실행하여 만든 특정 객체 형입니다. 클래스 객체는 인스턴스 객체를 만들기 위한 주형으로 사용되며, "
"데이터형과 관련된 데이터(어트리뷰트)와 코드(메서드)를 모두 내장합니다."

#: ../../faq/programming.rst:1470
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base "
"classes. This allows an object model to be successively refined by "
"inheritance.  You might have a generic ``Mailbox`` class that provides "
"basic accessor methods for a mailbox, and subclasses such as "
"``MboxMailbox``, ``MaildirMailbox``, ``OutlookMailbox`` that handle "
"various specific mailbox formats."
msgstr ""
"클래스는 베이스 클래스라고 하는 하나 이상의 다른 클래스를 기반으로 할 수 있습니다. 그러면 베이스 클래스의 어트리뷰트와 메서드를 "
"상속합니다. 이는 상속을 통해 객체 모델을 점진적으로 재정의할 수 있도록 합니다. 우편함에 대한 기본 접근자 메서드를 제공하는 일반"
" ``Mailbox`` 클래스와 다양한 특정 사서함 형식을 처리하는 ``MboxMailbox``, "
"``MaildirMailbox``, ``OutlookMailbox``\\와 같은 서브 클래스가 있을 수 있습니다."

#: ../../faq/programming.rst:1479
msgid "What is a method?"
msgstr "메서드는 무엇입니까?"

#: ../../faq/programming.rst:1481
msgid ""
"A method is a function on some object ``x`` that you normally call as "
"``x.name(arguments...)``.  Methods are defined as functions inside the "
"class definition::"
msgstr ""
"메서드는 일반적으로 ``x.name(arguments...)``\\로 호출하는 어떤 객체 ``x``\\의 함수입니다. 메서드는 "
"클래스 정의 내에서 함수로 정의됩니다::"

#: ../../faq/programming.rst:1485
msgid ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"
msgstr ""

#: ../../faq/programming.rst:1491
msgid "What is self?"
msgstr "self는 무엇입니까?"

#: ../../faq/programming.rst:1493
msgid ""
"Self is merely a conventional name for the first argument of a method.  A"
" method defined as ``meth(self, a, b, c)`` should be called as "
"``x.meth(a, b, c)`` for some instance ``x`` of the class in which the "
"definition occurs; the called method will think it is called as ``meth(x,"
" a, b, c)``."
msgstr ""
"self는 단지 메서드의 첫 번째 인자를 위한 관례적 이름입니다. ``meth(self, a, b, c)``\\로 정의된 메서드는 "
"정의가 등장한 클래스의 어떤 인스턴스 ``x``\\에 대해 ``x.meth(a, b, c)``\\로 호출되어야 합니다; 호출된 "
"메서드는 ``meth(x, a, b, c)``\\처럼 호출되었다고 생각합니다."

#: ../../faq/programming.rst:1498
msgid "See also :ref:`why-self`."
msgstr ":ref:`why-self` 도 참조하십시오."

#: ../../faq/programming.rst:1502
msgid ""
"How do I check if an object is an instance of a given class or of a "
"subclass of it?"
msgstr "객체가 주어진 클래스나 그 서브 클래스의 인스턴스인지 어떻게 확인합니까?"

#: ../../faq/programming.rst:1504
#, fuzzy
msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You"
" can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, "
"(class1, class2, ...))``, and can also check whether an object is one of "
"Python's built-in types, e.g. ``isinstance(obj, str)`` or "
"``isinstance(obj, (int, float, complex))``."
msgstr ""
"내장 함수 ``isinstance(obj, cls)``\\를 사용하십시오. 단일 클래스 대신 튜플을 제공하여 객체가 여러 클래스 중"
" 어느 하나의 인스턴스인지를 확인할 수 있으며 (예를 들어 ``isinstance(obj, (class1, class2, "
"...))``), 객체가 파이썬의 내장형 중 하나인지 확인할 수도 있습니다 (예를 들어 ``isinstance(obj, "
"str)``\\나 ``isinstance(obj, (int, float, complex))``)."

#: ../../faq/programming.rst:1511
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an "
":term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it."
"  To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""

#: ../../faq/programming.rst:1516
msgid ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"
msgstr ""

#: ../../faq/programming.rst:1528
msgid ""
">>> c = C()\n"
">>> isinstance(c, C)        # direct\n"
"True\n"
">>> isinstance(c, P)        # indirect\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Actual inheritance chain\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Test for \"true inheritance\"\n"
">>> Mapping in type(c).__mro__\n"
"False"
msgstr ""

#: ../../faq/programming.rst:1546
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's "
"class and doing a different thing based on what class it is.  For "
"example, if you have a function that does something::"
msgstr ""
"대부분의 프로그램은 사용자 정의 클래스에서 :func:`isinstance`\\를 자주 사용하지 않음에 유의하십시오. 클래스를 직접"
" 개발하고 있다면, 더 적절한 객체 지향 스타일은 객체의 클래스를 확인하고 클래스에 따라 다른 작업을 수행하는 대신 특정 동작을 "
"캡슐화하는 클래스의 메서드를 정의하는 것입니다. 예를 들어, 무언가를 수행하는 함수가 있다면::"

#: ../../faq/programming.rst:1553
msgid ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # code to search a mailbox\n"
"    elif isinstance(obj, Document):\n"
"        ...  # code to search a document\n"
"    elif ..."
msgstr ""

#: ../../faq/programming.rst:1560
msgid ""
"A better approach is to define a ``search()`` method on all the classes "
"and just call it::"
msgstr "더 나은 접근법은 모든 클래스에서 ``search()`` 메서드를 정의하고 단지 그것을 호출하는 것입니다::"

#: ../../faq/programming.rst:1563
msgid ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # code to search a mailbox\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # code to search a document\n"
"\n"
"obj.search()"
msgstr ""

#: ../../faq/programming.rst:1575
msgid "What is delegation?"
msgstr "위임이란 무엇입니까?"

#: ../../faq/programming.rst:1577
msgid ""
"Delegation is an object oriented technique (also called a design "
"pattern). Let's say you have an object ``x`` and want to change the "
"behaviour of just one of its methods.  You can create a new class that "
"provides a new implementation of the method you're interested in changing"
" and delegates all other methods to the corresponding method of ``x``."
msgstr ""
"위임(delegation)은 객체 지향 기법(디자인 패턴이라고도 합니다)입니다. ``x`` 객체가 있고 메서드 중 하나의 동작을 "
"변경하고 싶다고 가정해 봅시다. 변경하려는 메서드의 새로운 구현을 제공하고 다른 모든 메서드를 ``x``\\의 해당 메서드에 "
"위임하는 새 클래스를 만들 수 있습니다."

#: ../../faq/programming.rst:1583
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts "
"all written data to uppercase::"
msgstr ""
"파이썬 프로그래머는 쉽게 위임을 구현할 수 있습니다. 예를 들어, 다음 클래스는 파일처럼 동작하지만, 기록되는 모든 데이터를 "
"대문자로 변환하는 클래스를 구현합니다::"

#: ../../faq/programming.rst:1587
msgid ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"
msgstr ""

#: ../../faq/programming.rst:1598
#, fuzzy
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert "
"the argument string to uppercase before calling the underlying "
"``self._outfile.write()`` method.  All other methods are delegated to the"
" underlying ``self._outfile`` object.  The delegation is accomplished via"
" the :meth:`~object.__getattr__` method; consult :ref:`the language "
"reference <attribute-access>` for more information about controlling "
"attribute access."
msgstr ""
"여기서 ``UpperOut`` 클래스는 ``write()`` 메서드를 재정의하여 하부 ``self._outfile.write()``"
" 메서드를 호출하기 전에 인자 문자열을 대문자로 변환합니다. 다른 모든 메서드는 하부 ``self._outfile`` 객체에 "
"위임됩니다. 위임은 ``__getattr__`` 메서드를 통해 수행됩니다; 어트리뷰트 액세스 제어에 대한 자세한 정보는 "
":ref:`언어 레퍼런스 <attribute-access>`\\를 참조하십시오."

#: ../../faq/programming.rst:1605
#, fuzzy
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a "
":meth:`~object.__setattr__` method too, and it must do so carefully.  The"
" basic implementation of :meth:`!__setattr__` is roughly equivalent to "
"the following::"
msgstr ""
"더 일반적이면 위임이 까다로울 수 있음에 유의하십시오. 어트리뷰트가 조회될 뿐만 아니라 설정되어야 할 때, 클래스는 "
":meth:`__setattr__` 메서드도 정의해야 하며, 아주 신중하게 수행되어야 합니다. "
":meth:`__setattr__`\\의 기본 구현은 다음과 대략 동등합니다::"

#: ../../faq/programming.rst:1610
msgid ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."
msgstr ""

#: ../../faq/programming.rst:1616
#, fuzzy
msgid ""
"Many :meth:`~object.__setattr__` implementations call "
":meth:`!object.__setattr__` to set an attribute on self without causing "
"infinite recursion::"
msgstr ""
"대부분의 :meth:`__setattr__` 구현은 무한 재귀를 일으키지 않고 self의 지역 상태를 저장하기 위해 "
"``self.__dict__``\\를 수정해야 합니다."

#: ../../faq/programming.rst:1619
msgid ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Custom logic here...\n"
"        object.__setattr__(self, name, value)"
msgstr ""

#: ../../faq/programming.rst:1624
msgid ""
"Alternatively, it is possible to set attributes by inserting entries into"
" :attr:`self.__dict__ <object.__dict__>` directly."
msgstr ""

#: ../../faq/programming.rst:1629
#, fuzzy
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr "메서드를 재정의하는 파생 클래스에서 베이스 클래스에 정의된 해당 메서드를 어떻게 호출합니까?"

#: ../../faq/programming.rst:1631
msgid "Use the built-in :func:`super` function::"
msgstr "내장 :func:`super` 함수를 사용하십시오::"

#: ../../faq/programming.rst:1633
msgid ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # calls Base.meth"
msgstr ""

#: ../../faq/programming.rst:1637
msgid ""
"In the example, :func:`super` will automatically determine the instance "
"from which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next "
"in line after ``Derived`` in the MRO: ``Base``."
msgstr ""

#: ../../faq/programming.rst:1644
msgid "How can I organize my code to make it easier to change the base class?"
msgstr "베이스 클래스를 쉽게 변경할 수 있도록 코드를 구성하려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:1646
msgid ""
"You could assign the base class to an alias and derive from the alias.  "
"Then all you have to change is the value assigned to the alias.  "
"Incidentally, this trick is also handy if you want to decide dynamically "
"(e.g. depending on availability of resources) which base class to use.  "
"Example::"
msgstr ""
"베이스 클래스를 별칭에 대입하고 별칭에서 파생할 수 있습니다. 그러면 별칭에 대입된 값만 변경하면 됩니다. 또한 이 트릭은 사용할 "
"베이스 클래스를 동적으로 (예를 들어 자원의 가용성에 따라) 결정하려는 경우에도 유용합니다. 예::"

#: ../../faq/programming.rst:1651
msgid ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."
msgstr ""

#: ../../faq/programming.rst:1661
msgid "How do I create static class data and static class methods?"
msgstr "정적 클래스 데이터와 정적 클래스 메서드를 만들려면 어떻게 해야 합니까?"

#: ../../faq/programming.rst:1663
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr "(C++나 Java의 의미에서) 정적 데이터와 정적 메서드 모두 파이썬에서 지원됩니다."

#: ../../faq/programming.rst:1666
msgid ""
"For static data, simply define a class attribute.  To assign a new value "
"to the attribute, you have to explicitly use the class name in the "
"assignment::"
msgstr ""
"정적 데이터의 경우, 단순히 클래스 어트리뷰트를 정의하십시오. 어트리뷰트에 새 값을 대입하려면, 대입에서 클래스 이름을 명시적으로 "
"사용해야 합니다::"

#: ../../faq/programming.rst:1669
msgid ""
"class C:\n"
"    count = 0   # number of times C.__init__ called\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count  # or return self.count"
msgstr ""

#: ../../faq/programming.rst:1678
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c`` 자체나 ``c.__class__``\\에서 ``C``\\로 돌아가는 베이스 클래스 검색 경로에 놓인 일부 클래스에 의해 "
"재정의되지 않는 한, ``c.count``\\는 ``isinstance(c, C)``\\가 성립하는 모든 ``c``\\에 대해 "
"``C.count``\\를 참조합니다."

#: ../../faq/programming.rst:1682
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the "
"class whether inside a method or not::"
msgstr ""
"주의: C의 메서드 내에서, ``self.count = 42``\\와 같은 대입은 ``self``\\의 자체 딕셔너리에 "
"\"count\"라는 새롭고 관련이 없는 인스턴스를 만듭니다. 클래스 정적 데이터 이름의 재연결은 항상 메서드 내부에 있는지에 "
"관계없이 클래스를 지정해야 합니다::"

#: ../../faq/programming.rst:1687
msgid "C.count = 314"
msgstr ""

#: ../../faq/programming.rst:1689
msgid "Static methods are possible::"
msgstr "정적 메서드도 가능합니다::"

#: ../../faq/programming.rst:1691
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # No 'self' parameter!\n"
"        ..."
msgstr ""

#: ../../faq/programming.rst:1697
msgid ""
"However, a far more straightforward way to get the effect of a static "
"method is via a simple module-level function::"
msgstr "그러나, 정적 메서드의 효과를 얻는 훨씬 간단한 방법은 단순한 모듈 수준 함수를 사용하는 것입니다::"

#: ../../faq/programming.rst:1700
msgid ""
"def getcount():\n"
"    return C.count"
msgstr ""

#: ../../faq/programming.rst:1703
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"여러분의 코드가 모듈 당 하나의 클래스 (또는 밀접하게 관련된 클래스 계층 구조)를 정의하도록 구조화되었다면, 이것이 원하는 "
"캡슐화를 제공합니다."

#: ../../faq/programming.rst:1708
msgid "How can I overload constructors (or methods) in Python?"
msgstr "파이썬에서 생성자(또는 메서드)를 어떻게 재정의할 수 있습니까?"

#: ../../faq/programming.rst:1710
msgid ""
"This answer actually applies to all methods, but the question usually "
"comes up first in the context of constructors."
msgstr "이 답변은 실제로 모든 메서드에 적용되지만, 질문은 일반적으로 생성자 문맥에서 가장 먼저 나옵니다."

#: ../../faq/programming.rst:1713
msgid "In C++ you'd write"
msgstr "C++에서는 다음과 같이 작성합니다"

#: ../../faq/programming.rst:1715
msgid ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"
msgstr ""

#: ../../faq/programming.rst:1722
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr "파이썬에서는 기본 인자를 사용하여 모든 경우를 다루는 단일 생성자를 작성해야 합니다. 예를 들면::"

#: ../../faq/programming.rst:1725
msgid ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"
msgstr ""

#: ../../faq/programming.rst:1732
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "이것은 완전히 동등하지는 않지만, 실제로는 아주 가깝습니다."

#: ../../faq/programming.rst:1734
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr "가변 길이 인자 목록을 시도할 수도 있습니다, 예를 들어::"

#: ../../faq/programming.rst:1736
msgid ""
"def __init__(self, *args):\n"
"    ..."
msgstr ""

#: ../../faq/programming.rst:1739
msgid "The same approach works for all method definitions."
msgstr "같은 접근법이 모든 메서드 정의에서도 동작합니다."

#: ../../faq/programming.rst:1743
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr "__spam을 사용하려고 하는데 _SomeClassName__spam에 대한 에러가 발생합니다."

#: ../../faq/programming.rst:1745
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide"
" a simple but effective way to define class private variables.  Any "
"identifier of the form ``__spam`` (at least two leading underscores, at "
"most one trailing underscore) is textually replaced with "
"``_classname__spam``, where ``classname`` is the current class name with "
"any leading underscores stripped."
msgstr ""
"이중 선행 밑줄이 있는 변수 이름은 클래스 비공개(private) 변수를 정의하는 간단하지만, 효과적인 방법을 제공하기 위해 "
"\"뒤섞입니다(mangled)\". ``__spam`` 형식(적어도 두 개의 선행 밑줄, 최대 하나의 후행 밑줄)의 모든 식별자는 "
"``_classname__spam``\\으로 텍스트 대체되는데, 여기서 ``classname`` 은 모든 선행 밑줄이 제거된 현재 "
"클래스 이름입니다."

#: ../../faq/programming.rst:1751
msgid ""
"The identifier can be used unchanged within the class, but to access it "
"outside the class, the mangled name must be used:"
msgstr ""

#: ../../faq/programming.rst:1754
msgid ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"
msgstr ""

#: ../../faq/programming.rst:1768
#, fuzzy
msgid ""
"In particular, this does not guarantee privacy since an outside user can "
"still deliberately access the private attribute; many Python programmers "
"never bother to use private variable names at all."
msgstr ""
"이것은 비공개를 보장하지 않습니다: 외부 사용자는 여전히 \"_classname__spam\" 어트리뷰트에 의도적으로 액세스할 수 "
"있으며, 비공개 값은 객체의 ``__dict__``\\에 나타납니다. 많은 파이썬 프로그래머는 비공개 변수 이름을 전혀 사용하지 "
"않습니다."

#: ../../faq/programming.rst:1774
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` "
"for details and special cases."
msgstr ""

#: ../../faq/programming.rst:1778
msgid "My class defines __del__ but it is not called when I delete the object."
msgstr "내 클래스는 __del__을 정의하지만 객체를 삭제할 때 호출되지 않습니다."

#: ../../faq/programming.rst:1780
msgid "There are several possible reasons for this."
msgstr "몇 가지 가능한 이유가 있습니다."

#: ../../faq/programming.rst:1782
#, fuzzy
msgid ""
"The :keyword:`del` statement does not necessarily call "
":meth:`~object.__del__` -- it simply decrements the object's reference "
"count, and if this reaches zero :meth:`!__del__` is called."
msgstr ""
"del 문이 반드시 :meth:`__del__`\\을 호출할 필요는 없습니다 -- 단순히 객체의 참조 횟수를 감소시키고, 이것이 "
"0에 도달하면 :meth:`__del__`\\이 호출됩니다."

#: ../../faq/programming.rst:1786
#, fuzzy
msgid ""
"If your data structures contain circular links (e.g. a tree where each "
"child has a parent reference and each parent has a list of children) the "
"reference counts will never go back to zero.  Once in a while Python runs"
" an algorithm to detect such cycles, but the garbage collector might run "
"some time after the last reference to your data structure vanishes, so "
"your :meth:`!__del__` method may be called at an inconvenient and random "
"time. This is inconvenient if you're trying to reproduce a problem. "
"Worse, the order in which object's :meth:`!__del__` methods are executed "
"is arbitrary.  You can run :func:`gc.collect` to force a collection, but "
"there *are* pathological cases where objects will never be collected."
msgstr ""
"여러분의 자료 구조가 순환 링크를 포함하면 (예를 들어 각 자식이 부모 참조를 갖고 각 부모에 자식 리스트가 있는 트리), 참조 "
"횟수는 절대 0으로 돌아가지 않습니다. 가끔 파이썬은 이러한 순환을 감지하기 위해 알고리즘을 실행하지만, 가비지 수거기는 여러분의 "
"자료 구조에 대한 마지막 참조가 사라진 후 얼마 후에 실행될 수 있어서, :meth:`__del__` 메서드는 불편한 임의의 시간에"
" 호출될 수 있습니다. 문제를 재현하려고 한다면 불편합니다. 더 나쁘게도, 객체의 :meth:`__del__` 메서드가 실행되는 "
"순서가 임의적입니다. :func:`gc.collect`\\를 실행하여 수거를 강제할 수 있지만, 객체가 수거되지 않는 병리학적 "
"사례가 *있습니다*."

#: ../../faq/programming.rst:1797
#, fuzzy
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit"
" ``close()`` method on objects to be called whenever you're done with "
"them.  The ``close()`` method can then remove attributes that refer to "
"subobjects.  Don't call :meth:`!__del__` directly -- :meth:`!__del__` "
"should call ``close()`` and ``close()`` should make sure that it can be "
"called more than once for the same object."
msgstr ""
"순환 수거기에도 불구하고, 완료될 때마다 호출될 객체의 명시적인 ``close()`` 메서드를 정의하는 것이 좋습니다. 그러면 "
"``close()`` 메서드는 서브 객체를 참조하는 어트리뷰트를 제거할 수 있습니다. :meth:`__del__`\\을 직접 "
"호출하지 마십시오 -- :meth:`__del__`\\은 ``close()``\\를 호출해야 하며 ``close()``\\는 같은 "
"객체에 대해 두 번 이상 호출될 수 있어야 합니다."

#: ../../faq/programming.rst:1804
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"순환 참조를 피하는 또 다른 방법은 :mod:`weakref` 모듈을 사용하는 것입니다. 이 모듈은 참조 횟수를 늘리지 않고 객체를"
" 가리킬 수 있도록 합니다. 예를 들어, 트리 자료 구조는 부모와 형제 참조에 대해 약한 참조를 사용해야 합니다 (이런 것들이 "
"필요하다면!)."

#: ../../faq/programming.rst:1817
#, fuzzy
msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"마지막으로, :meth:`__del__` 메서드에서 예외가 발생하면, 경고 메시지가 :data:`sys.stderr`\\로 "
"인쇄됩니다."

#: ../../faq/programming.rst:1822
msgid "How do I get a list of all instances of a given class?"
msgstr "주어진 클래스의 모든 인스턴스 목록을 어떻게 얻습니까?"

#: ../../faq/programming.rst:1824
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"파이썬은 클래스(또는 내장형)의 모든 인스턴스를 추적하지 않습니다. 클래스 생성자가 각 인스턴스에 대한 약한 참조 리스트를 유지하여"
" 모든 인스턴스를 추적하도록 프로그래밍 할 수 있습니다."

#: ../../faq/programming.rst:1830
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "``id()``\\의 결과가 고유하지 않은 것처럼 보이는 이유는 무엇입니까?"

#: ../../faq/programming.rst:1832
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique"
" during the lifetime of the object.  Since in CPython, this is the "
"object's memory address, it happens frequently that after an object is "
"deleted from memory, the next freshly created object is allocated at the "
"same position in memory.  This is illustrated by this example:"
msgstr ""
":func:`id` 내장은 객체 수명 동안 고유하도록 보장되는 정수를 반환합니다. CPython에서는 이것이 객체의 메모리 "
"주소이므로, 객체가 메모리에서 삭제된 후 새로 만들어진 다음 객체가 메모리의 같은 위치에 할당되는 경우가 자주 발생합니다. 다음과 "
"같이 예시할 수 있습니다:"

#: ../../faq/programming.rst:1843
msgid ""
"The two ids belong to different integer objects that are created before, "
"and deleted immediately after execution of the ``id()`` call.  To be sure"
" that objects whose id you want to examine are still alive, create "
"another reference to the object:"
msgstr ""
"두 개의 id는 다른 정수 객체에 속하는데, ``id()`` 호출 실행 앞에 만들어지고, 호출 직후 삭제됩니다. id를 검사하려는 "
"객체가 여전히 살아 있도록 하려면, 그 객체에 대한 다른 참조를 만드십시오:"

#: ../../faq/programming.rst:1856
msgid "When can I rely on identity tests with the *is* operator?"
msgstr "*is* 연산자를 사용한 아이덴티티 검사는 언제 신뢰할 수 있습니까?"

#: ../../faq/programming.rst:1858
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr "``is`` 연산자는 객체 아이덴티티를 검사합니다. 검사 ``a is b``\\는 ``id(a) == id(b)``\\와 동등합니다."

#: ../../faq/programming.rst:1861
msgid ""
"The most important property of an identity test is that an object is "
"always identical to itself, ``a is a`` always returns ``True``.  Identity"
" tests are usually faster than equality tests.  And unlike equality "
"tests, identity tests are guaranteed to return a boolean ``True`` or "
"``False``."
msgstr ""
"아이덴티티 검사의 가장 중요한 속성은 객체가 항상 자신과 동일하고 ``a is a``\\는 항상 ``True``\\를 반환한다는 "
"것입니다. 아이덴티티 검사는 일반적으로 동등성 검사보다 빠릅니다. 동등성 검사와 달리, 아이덴티티 테스트는 불리언 "
"``True``\\나 ``False``\\를 반환함이 보장됩니다."

#: ../../faq/programming.rst:1866
msgid ""
"However, identity tests can *only* be substituted for equality tests when"
" object identity is assured.  Generally, there are three circumstances "
"where identity is guaranteed:"
msgstr ""
"그러나, 객체 아이덴티티가 보장될 때 아이덴티티 검사가 동등성 검사를 대체할 수 있습니다. 일반적으로, 아이덴티티가 보장되는 세 "
"가지 상황이 있습니다:"

#: ../../faq/programming.rst:1870
#, fuzzy
msgid ""
"Assignments create new names but do not change object identity.  After "
"the assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"1) 대입은 새 이름을 만들지 만 객체 아이덴티티를 변경하지는 않습니다. 대입 ``new = old`` 후에, ``new is "
"old``\\임이 보장됩니다."

#: ../../faq/programming.rst:1873
#, fuzzy
msgid ""
"Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"2) 객체 참조를 저장하는 컨테이너에 객체를 넣어도 객체 아이덴티티가 변경되지 않습니다. 리스트 대입 ``s[0] = x`` 후에,"
" ``s[0] is x``\\임이 보장됩니다."

#: ../../faq/programming.rst:1877
#, fuzzy
msgid ""
"If an object is a singleton, it means that only one instance of that "
"object can exist.  After the assignments ``a = None`` and ``b = None``, "
"it is guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"3) 객체가 싱글톤이면, 해당 객체의 인스턴스가 하나만 존재할 수 있음을 의미합니다. ``a = None`` 과 ``b = "
"None`` 대입 후에 ``None``\\은 싱글톤이므로 ``a is b``\\임이 보장됩니다."

#: ../../faq/programming.rst:1881
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to"
" check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"대부분의 다른 상황에서는 아이덴티티 검사가 권장되지 않으며 동등성 테스트가 선호됩니다. 특히, 싱글톤이 보장되지 않는 "
":class:`int`\\와 :class:`str`\\과 같은 상수를 확인하는 데 아이덴티티 검사를 사용해서는 안 됩니다::"

#: ../../faq/programming.rst:1886
msgid ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"
msgstr ""

#: ../../faq/programming.rst:1898
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr "마찬가지로, 가변 컨테이너의 새 인스턴스는 절대 동일하지 않습니다::"

#: ../../faq/programming.rst:1900
msgid ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"
msgstr ""

#: ../../faq/programming.rst:1905
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr "표준 라이브러리 코드에서, 아이덴티티 검사를 올바르게 사용하는 몇 가지 일반적인 패턴을 볼 수 있습니다:"

#: ../../faq/programming.rst:1908
#, fuzzy
msgid ""
"As recommended by :pep:`8`, an identity test is the preferred way to "
"check for ``None``.  This reads like plain English in code and avoids "
"confusion with other objects that may have boolean values that evaluate "
"to false."
msgstr ""
"1) :pep:`8`\\에서 권장하는 대로, 아이덴티티 검사는 ``None``\\을 확인하는 데 선호되는 방법입니다. 이것은 "
"코드에서 일반 영어처럼 읽히고 거짓으로 평가되는 불리언 값을 가질 수 있는 다른 객체와의 혼동을 방지합니다."

#: ../../faq/programming.rst:1912
#, fuzzy
msgid ""
"Detecting optional arguments can be tricky when ``None`` is a valid input"
" value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how "
"to implement a method that behaves like :meth:`dict.pop`:"
msgstr ""
"2) ``None``\\이 유효한 입력값일 때 선택적 인자를 감지하는 것이 까다로울 수 있습니다. 이러한 상황에서, 다른 객체와 "
"구별되는 싱글톤 센티넬 객체를 만들 수 있습니다. 예를 들어, 다음은 :meth:`dict.pop`\\처럼 작동하는 메서드를 "
"구현하는 방법입니다::"

#: ../../faq/programming.rst:1917
msgid ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"
msgstr ""

#: ../../faq/programming.rst:1930
#, fuzzy
msgid ""
"Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects "
"such as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"3) 컨테이너 구현은 때때로 아이덴티티 검사로 동등성 검사를 강화해야 합니다. 이것은 자신과 같지 않은 "
"``float('NaN')``\\과 같은 객체에 의해 코드가 혼동되는 것을 방지합니다."

#: ../../faq/programming.rst:1934
#, fuzzy
msgid ""
"For example, here is the implementation of "
":meth:`!collections.abc.Sequence.__contains__`::"
msgstr "예를 들어, 다음은 :meth:`collections.abc.Sequence.__contains__`\\의 구현입니다::"

#: ../../faq/programming.rst:1937
msgid ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"
msgstr ""

#: ../../faq/programming.rst:1945
msgid "How can a subclass control what data is stored in an immutable instance?"
msgstr ""

#: ../../faq/programming.rst:1947
msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only "
"runs *after* an instance is created, which is too late to alter data in "
"an immutable instance."
msgstr ""

#: ../../faq/programming.rst:1952
msgid ""
"All of these immutable classes have a different signature than their "
"parent class:"
msgstr ""

#: ../../faq/programming.rst:1955
#, python-brace-format
msgid ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"
msgstr ""

#: ../../faq/programming.rst:1978
msgid "The classes can be used like this:"
msgstr ""

#: ../../faq/programming.rst:1980
msgid ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"
msgstr ""

#: ../../faq/programming.rst:1995
#, fuzzy
msgid "How do I cache method calls?"
msgstr "다차원 리스트를 어떻게 만듭니까?"

#: ../../faq/programming.rst:1997
msgid ""
"The two principal tools for caching methods are "
":func:`functools.cached_property` and :func:`functools.lru_cache`.  The "
"former stores results at the instance level and the latter at the class "
"level."
msgstr ""

#: ../../faq/programming.rst:2002
msgid ""
"The *cached_property* approach only works with methods that do not take "
"any arguments.  It does not create a reference to the instance.  The "
"cached method result will be kept only as long as the instance is alive."
msgstr ""

#: ../../faq/programming.rst:2006
msgid ""
"The advantage is that when an instance is no longer used, the cached "
"method result will be released right away.  The disadvantage is that if "
"instances accumulate, so too will the accumulated method results.  They "
"can grow without bound."
msgstr ""

#: ../../faq/programming.rst:2011
msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts"
" are made to pass in weak references."
msgstr ""

#: ../../faq/programming.rst:2015
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances "
"are kept alive until they age out of the cache or until the cache is "
"cleared."
msgstr ""

#: ../../faq/programming.rst:2020
#, fuzzy
msgid "This example shows the various techniques::"
msgstr "다양한 기법이 있습니다."

#: ../../faq/programming.rst:2022
msgid ""
"class Weather:\n"
"    \"Lookup weather information on a government website\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # The _station_id is private and immutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # Do not cache this because old results\n"
"        # can be out of date.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Return the longitude/latitude coordinates of the station\"\n"
"        # Result only depends on the station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Rainfall on a given date\"\n"
"        # Depends on the station_id, date, and units."
msgstr ""

#: ../../faq/programming.rst:2044
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""

#: ../../faq/programming.rst:2049
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, "
"the class needs to define the :meth:`~object.__eq__` and "
":meth:`~object.__hash__` methods so that the cache can detect relevant "
"attribute updates::"
msgstr ""

#: ../../faq/programming.rst:2053
msgid ""
"class Weather:\n"
"    \"Example with a mutable station identifier\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Rainfall on a given date'\n"
"        # Depends on the station_id, date, and units."
msgstr ""

#: ../../faq/programming.rst:2075
msgid "Modules"
msgstr "모듈"

#: ../../faq/programming.rst:2078
msgid "How do I create a .pyc file?"
msgstr ".pyc 파일을 어떻게 만듭니까?"

#: ../../faq/programming.rst:2080
msgid ""
"When a module is imported for the first time (or when the source file has"
" changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the"
" particular ``python`` binary that created it.  (See :pep:`3147` for "
"details.)"
msgstr ""
"모듈이 처음 임포트 될 때 (또는 현재 컴파일된 파일이 만들어진 후 소스 파일이 변경되었을 때) 컴파일된 코드를 포함하는 "
"``.pyc`` 파일은 ``.py`` 파일을 포함하는 디렉터리의 ``__pycache__`` 서브 디렉터리에 만들어져야 합니다. "
"``.pyc`` 파일은 ``.py`` 파일과 같은 이름으로 시작하고, ``.pyc``\\로 끝나며, 파일을 만든 특정 "
"``python`` 바이너리 파일에 종속되는 중간 구성 요소를 갖는 파일명을 갖습니다. (자세한 내용은 :pep:`3147`\\을 "
"참조하십시오.)"

#: ../../faq/programming.rst:2088
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions "
"problem with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you "
"are testing with a web server."
msgstr ""
"``.pyc`` 파일이 만들어지지 않을 수 있는 한 가지 이유는 소스 파일이 포함된 디렉터리의 권한 문제입니다. 즉, "
"``__pycache__`` 서브 디렉터리를 만들 수 없다는 뜻입니다. 예를 들어, 한 사용자로 개발했지만 다른 사용자로 실행하는 "
"경우에 이런 일이 일어날 수 있습니다, 가령 웹 서버로 테스트하고 있을 때입니다."

#: ../../faq/programming.rst:2093
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set,"
" creation of a .pyc file is automatic if you're importing a module and "
"Python has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
":envvar:`PYTHONDONTWRITEBYTECODE` 환경 변수가 설정되어 있지 않은 한, 모듈을 임포트 하고 파이썬이 "
"``__pycache__`` 서브 디렉터리를 만들고 컴파일된 모듈을 그 서브 디렉터리에 쓸 수 있는 능력(권한, 여유 공간 등)이 "
"있으면 .pyc 파일의 생성은 자동입니다."

#: ../../faq/programming.rst:2098
msgid ""
"Running Python on a top level script is not considered an import and no "
"``.pyc`` will be created.  For example, if you have a top-level module "
"``foo.py`` that imports another module ``xyz.py``, when you run ``foo`` "
"(by typing ``python foo.py`` as a shell command), a ``.pyc`` will be "
"created for ``xyz`` because ``xyz`` is imported, but no ``.pyc`` file "
"will be created for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"최상위 스크립트에서 파이썬을 실행하는 것은 임포트로 간주하지 않으며 ``.pyc``\\가 만들어지지 않습니다. 예를 들어, 다른 "
"모듈 ``xyz.py``\\를 임포트 하는 최상위 모듈 ``foo.py``\\가 있을 때, (``python foo.py``\\를 "
"셸 명령으로 입력하여) ``foo``\\를 실행하면, ``xyz``\\를 임포트 하기 때문에 ``xyz``\\에 대해 "
"``.pyc``\\가 만들어지지만, ``foo.py``\\를 임포트 하지 않기 때문에 ``foo``\\에 대해서는 ``.pyc`` "
"파일이 만들어지지 않습니다."

#: ../../faq/programming.rst:2105
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a"
" ``.pyc`` file for a module that is not imported -- you can, using the "
":mod:`py_compile` and :mod:`compileall` modules."
msgstr ""
"``foo``\\에 대한 ``.pyc`` 파일을 만들 필요가 있으면 -- 즉, 임포트 되지 않는 모듈에 대한 ``.pyc`` 파일을"
" 만들려면 -- :mod:`py_compile`\\과 :mod:`compileall` 모듈을 사용할 수 있습니다."

#: ../../faq/programming.rst:2109
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is"
" to use the ``compile()`` function in that module interactively::"
msgstr ""
":mod:`py_compile` 모듈은 임의의 모듈을 수동으로 컴파일할 수 있습니다. 한 가지 방법은 해당 모듈에서 "
"``compile()`` 함수를 대화식으로 사용하는 것입니다::"

#: ../../faq/programming.rst:2112
msgid ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"
msgstr ""

#: ../../faq/programming.rst:2115
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the "
"same location as ``foo.py`` (or you can override that with the optional "
"parameter ``cfile``)."
msgstr ""
"이것은 ``.pyc``\\를 ``foo.py``\\와 같은 위치에 있는 ``__pycache__`` 서브 디렉터리에 기록합니다 "
"(또는 선택적 매개변수 ``cfile``\\로 이를 재정의할 수 있습니다)."

#: ../../faq/programming.rst:2119
msgid ""
"You can also automatically compile all files in a directory or "
"directories using the :mod:`compileall` module.  You can do it from the "
"shell prompt by running ``compileall.py`` and providing the path of a "
"directory containing Python files to compile::"
msgstr ""
":mod:`compileall` 모듈을 사용하여 디렉터리의 모든 파일을 자동으로 컴파일할 수도 있습니다. "
"``compileall.py``\\를 실행하고 컴파일할 파이썬 파일이 포함된 디렉터리의 경로를 제공하여 셸 프롬프트에서 이를 수행할"
" 수 있습니다::"

#: ../../faq/programming.rst:2124
msgid "python -m compileall ."
msgstr ""

#: ../../faq/programming.rst:2128
msgid "How do I find the current module name?"
msgstr "현재 모듈 이름을 어떻게 찾습니까?"

#: ../../faq/programming.rst:2130
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"모듈은 사전 정의된 전역 변수 ``__name__``\\을 봄으로써 모듈 자신의 이름을 찾을 수 있습니다. 값이 "
"``'__main__'``\\이면, 프로그램이 스크립트로 실행 중입니다. 일반적으로 모듈을 임포트 해서 사용하는 많은 모듈은 명령 "
"줄 인터페이스나 자체 테스트를 제공하며, ``__name__``\\을 확인한 후에 만 이 코드를 실행합니다::"

#: ../../faq/programming.rst:2136
msgid ""
"def main():\n"
"    print('Running test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../faq/programming.rst:2145
msgid "How can I have modules that mutually import each other?"
msgstr "서로 임포트 하는 모듈을 어떻게 만들 수 있습니까?"

#: ../../faq/programming.rst:2147
msgid "Suppose you have the following modules:"
msgstr "다음 모듈이 있다고 가정하십시오:"

#: ../../faq/programming.rst:2149
#, fuzzy
msgid ":file:`foo.py`::"
msgstr "foo.py::"

#: ../../faq/programming.rst:2151
msgid ""
"from bar import bar_var\n"
"foo_var = 1"
msgstr ""

#: ../../faq/programming.rst:2154
#, fuzzy
msgid ":file:`bar.py`::"
msgstr "bar.py::"

#: ../../faq/programming.rst:2156
msgid ""
"from foo import foo_var\n"
"bar_var = 2"
msgstr ""

#: ../../faq/programming.rst:2159
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "문제는 인터프리터가 다음 단계를 수행한다는 것입니다:"

#: ../../faq/programming.rst:2161
#, fuzzy
msgid "main imports ``foo``"
msgstr "main이 foo를 임포트 합니다"

#: ../../faq/programming.rst:2162
#, fuzzy
msgid "Empty globals for ``foo`` are created"
msgstr "foo에 대한 빈 전역이 만들어집니다"

#: ../../faq/programming.rst:2163
#, fuzzy
msgid "``foo`` is compiled and starts executing"
msgstr "foo가 컴파일되고 실행되기 시작합니다"

#: ../../faq/programming.rst:2164
#, fuzzy
msgid "``foo`` imports ``bar``"
msgstr "foo가 bar를 임포트 합니다"

#: ../../faq/programming.rst:2165
#, fuzzy
msgid "Empty globals for ``bar`` are created"
msgstr "bar에 대한 빈 전역이 만들어집니다"

#: ../../faq/programming.rst:2166
#, fuzzy
msgid "``bar`` is compiled and starts executing"
msgstr "바가 컴파일되고 실행되기 시작합니다"

#: ../../faq/programming.rst:2167
#, fuzzy
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module"
" named ``foo``)"
msgstr "bar가 foo를 임포트 합니다 (이미 foo라는 모듈이 있어서 no-op입니다)"

#: ../../faq/programming.rst:2168
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to "
"set ``bar.foo_var = foo.foo_var``"
msgstr ""

#: ../../faq/programming.rst:2170
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` "
"yet and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"마지막 단계가 실패합니다. 파이썬이 아직 ``foo``\\를 인터프리트 하는 것을 완료하지 않았고 ``foo``\\의 전역 기호 "
"딕셔너리가 여전히 비어 있기 때문입니다."

#: ../../faq/programming.rst:2173
msgid ""
"The same thing happens when you use ``import foo``, and then try to "
"access ``foo.foo_var`` in global code."
msgstr "``import foo``\\를 사용하고 전역 코드에서 ``foo.foo_var``\\에 액세스하려고 할 때도 같은 일이 일어납니다."

#: ../../faq/programming.rst:2176
msgid "There are (at least) three possible workarounds for this problem."
msgstr "이 문제에 대해 가능한 (최소한) 세 가지 해결 방법이 있습니다."

#: ../../faq/programming.rst:2178
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import "
"...``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum은 ``from <module> import ...``\\을 아예 사용하지 말고, 모든 코드를 함수 "
"내에 배치할 것을 권장합니다. 전역 변수와 클래스 변수의 초기화는 상수나 내장 함수만 사용해야 합니다. 이것은 임포트 된 모듈의 "
"모든 것이 ``<module>.<name>``\\으로 참조됨을 의미합니다."

#: ../../faq/programming.rst:2183
msgid ""
"Jim Roskind suggests performing steps in the following order in each "
"module:"
msgstr "Jim Roskind는 각 모듈에서 다음 순서로 단계를 수행할 것을 제안합니다:"

#: ../../faq/programming.rst:2185
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr "내보내기 (전역, 함수 및 베이스 클래스를 임포트 할 필요가 없는 클래스)"

#: ../../faq/programming.rst:2187
msgid "``import`` statements"
msgstr "``import`` 문"

#: ../../faq/programming.rst:2188
msgid "active code (including globals that are initialized from imported values)."
msgstr "활성 코드 (임포트 된 값에서 초기화된 전역 포함)."

#: ../../faq/programming.rst:2190
#, fuzzy
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in "
"a strange place, but it does work."
msgstr "van Rossum은 임포트가 이상한 곳에 나타나기 때문에 이 방법을 많이 좋아하지 않지만, 작동합니다."

#: ../../faq/programming.rst:2193
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive"
" import is not necessary in the first place."
msgstr "Matthias Urlichs는 처음부터 재귀 임포트가 필요하지 않도록 코드를 재구성할 것을 권합니다."

#: ../../faq/programming.rst:2196
msgid "These solutions are not mutually exclusive."
msgstr "이 해결 방법들은 상호 배타적이지 않습니다."

#: ../../faq/programming.rst:2200
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z')는 <module 'x'>를 반환합니다; z를 어떻게 얻습니까?"

#: ../../faq/programming.rst:2202
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
":mod:`importlib`\\의 편의 함수 :func:`~importlib.import_module`\\을 대신 사용하는 곳을 "
"고려하십시오::"

#: ../../faq/programming.rst:2205
msgid "z = importlib.import_module('x.y.z')"
msgstr ""

#: ../../faq/programming.rst:2209
msgid ""
"When I edit an imported module and reimport it, the changes don't show "
"up.  Why does this happen?"
msgstr "임포트 된 모듈을 편집하고 다시 임포트 할 때, 변경 사항이 표시되지 않습니다. 왜 이런 일이 발생합니까?"

#: ../../faq/programming.rst:2211
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To "
"force re-reading of a changed module, do this::"
msgstr ""
"효율성뿐만 아니라 일관성의 이유로, 파이썬은 모듈을 처음 임포트 할 때만 모듈 파일을 읽습니다. 그렇지 않으면, 각 모듈이 같은 "
"기본 모듈을 임포트 하는 많은 모듈로 구성된 프로그램에서, 기본 모듈을 여러 번 구문 분석하고 다시 구문 분석하게 됩니다. 변경된 "
"모듈을 강제로 다시 읽으려면, 다음과 같이 하십시오::"

#: ../../faq/programming.rst:2217
msgid ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"
msgstr ""

#: ../../faq/programming.rst:2221
#, python-format
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr "경고: 이 기법은 100% 확실하지 않습니다. 특히, 다음과 같은 문장을 포함하는 모듈은 ::"

#: ../../faq/programming.rst:2224
msgid "from modname import some_objects"
msgstr ""

#: ../../faq/programming.rst:2226
msgid ""
"will continue to work with the old version of the imported objects.  If "
"the module contains class definitions, existing class instances will "
"*not* be updated to use the new class definition.  This can result in the"
" following paradoxical behaviour::"
msgstr ""
"임포트 된 객체의 이전 버전으로 계속 작업합니다. 모듈에 클래스 정의가 포함되면, 새 클래스 정의를 사용하도록 기존 클래스 "
"인스턴스가 갱신되지 *않습니다*. 이것은 다음과 같은 역설적인 동작으로 이어집니다::"

#: ../../faq/programming.rst:2231
msgid ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"
msgstr ""

#: ../../faq/programming.rst:2239
msgid ""
"The nature of the problem is made clear if you print out the \"identity\""
" of the class objects::"
msgstr "클래스 객체의 \"아이덴티티\"를 인쇄하면 문제의 본질이 분명해집니다::"

#: ../../faq/programming.rst:2242
msgid ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"
msgstr ""

#: ../../faq/programming.rst:408
msgid "argument"
msgstr ""

#: ../../faq/programming.rst:408
msgid "difference from parameter"
msgstr ""

#: ../../faq/programming.rst:408
msgid "parameter"
msgstr ""

#: ../../faq/programming.rst:408
msgid "difference from argument"
msgstr ""

#~ msgid ""
#~ "Pydb is a version of the standard"
#~ " Python debugger pdb, modified for "
#~ "use with DDD (Data Display Debugger),"
#~ " a popular graphical debugger front "
#~ "end.  Pydb can be found at "
#~ "http://bashdb.sourceforge.net/pydb/ and DDD can "
#~ "be found at https://www.gnu.org/software/ddd."
#~ msgstr ""
#~ "Pydb는 널리 사용되는 그래픽 디버거 프런트 엔드인 "
#~ "DDD(Data Display Debugger)와 함께 사용하도록 수정된"
#~ " 표준 파이썬 디버거 pdb의 버전입니다. Pydb는 "
#~ "http://bashdb.sourceforge.net/pydb/ 에서 찾을 수 있고"
#~ " DDD는 https://www.gnu.org/software/ddd 에서 찾을 "
#~ "수 있습니다."

#~ msgid "Komodo IDE (https://komodoide.com/)"
#~ msgstr "Komodo IDE (https://komodoide.com/)"

#~ msgid ""
#~ "Obviously, freeze requires a C compiler."
#~ "  There are several other utilities "
#~ "which don't. One is Thomas Heller's "
#~ "py2exe (Windows only) at"
#~ msgstr ""
#~ "명백히, freeze는 C 컴파일러를 요구합니다. 그렇지 않은"
#~ " 다른 유틸리티가 몇 가지 있습니다. 그중 하나는 "
#~ "Thomas Heller의 py2exe(윈도우 전용)이고, 다음에서 찾을"
#~ " 수 있습니다."

#~ msgid ""
#~ "Another tool is Anthony Tuininga's "
#~ "`cx_Freeze <https://anthony-"
#~ "tuininga.github.io/cx_Freeze/>`_."
#~ msgstr ""
#~ "또 다른 도구는 Anthony Tuininga의 `cx_Freeze"
#~ " <https://anthony-tuininga.github.io/cx_Freeze/>`_\\입니다."

#~ msgid "Use a list comprehension::"
#~ msgstr "리스트 컴프리헨션을 사용하십시오::"

#~ msgid ""
#~ "For version prior to 3.0, you may"
#~ " be using classic classes: For a "
#~ "class definition such as ``class "
#~ "Derived(Base): ...`` you can call method"
#~ " ``meth()`` defined in ``Base`` (or "
#~ "one of ``Base``'s base classes) as "
#~ "``Base.meth(self, arguments...)``.  Here, "
#~ "``Base.meth`` is an unbound method, so"
#~ " you need to provide the ``self`` "
#~ "argument."
#~ msgstr ""
#~ "3.0 이전 버전의 경우, 클래식 클래스를 사용 "
#~ "중일 수 있습니다: ``class Derived(Base): "
#~ "...``\\와 같은 클래스 정의의 경우 ``Base``\\(또는 "
#~ "``Base``\\의 베이스 클래스 중 하나)에 정의된 "
#~ "``meth()`` 메서드를 ``Base.meth(self, arguments...)``\\로"
#~ " 호출할 수 있습니다. 여기서, ``Base.meth``\\는 "
#~ "연결되지 않은 메서드이므로, ``self`` 인자를 제공해야 "
#~ "합니다."

#~ msgid "bar.foo_var = foo.foo_var"
#~ msgstr "bar.foo_var = foo.foo_var"

