# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kang-min Kim <kokomong0831@naver.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../faq/windows.rst:9
msgid "Python on Windows FAQ"
msgstr "윈도우 파이썬 FAQ"

#: ../../faq/windows.rst:12
msgid "Contents"
msgstr "목차"

#: ../../faq/windows.rst:22
msgid "How do I run a Python program under Windows?"
msgstr "윈도우에서 파이썬 프로그램을 실행하려면 어떻게 해야 합니까?"

#: ../../faq/windows.rst:24
msgid ""
"This is not necessarily a straightforward question. If you are already "
"familiar with running programs from the Windows command line then "
"everything will seem obvious; otherwise, you might need a little more "
"guidance."
msgstr ""
"이 질문은 명확한 질문이 아닙니다. 이미 윈도우 명령 줄에서 프로그램을 실행하는 것에 익숙 하다면 이 모든 것이 분명할 것입니다. "
"그렇지 않으면, 좀 더 지침이 필요할 수 있습니다."

#: ../../faq/windows.rst:28
msgid ""
"Unless you use some sort of integrated development environment, you will "
"end up *typing* Windows commands into what is referred to as a \"Command "
"prompt window\".  Usually you can create such a window from your search "
"bar by searching for ``cmd``.  You should be able to recognize when you "
"have started such a window because you will see a Windows \"command "
"prompt\", which usually looks like this:"
msgstr ""
"당신이 어떤 통합 개발 환경을 쓰지 않는 이상, 결국 \"명령 프롬프트 창\"이라 불리는 것에 윈도우 명령어를 *입력* 할 "
"것입니다. 보통 윈도우 검색 창에서 ``cmd`` 를 입력하여 이 창을 띄울 수 있습니다. 일반적으로 다음과 같은 윈도우의 \"명령"
" 프롬프트\"가 표시되기 때문에 이러한 창이 언제 시작했는지 인지할 수 있어야 합니다:"

#: ../../faq/windows.rst:35
msgid "C:\\>"
msgstr "C:\\>"

#: ../../faq/windows.rst:39
msgid ""
"The letter may be different, and there might be other things after it, so"
" you might just as easily see something like:"
msgstr "아마 글자가 다르고, 그 뒤에 다른 것들이 있을 수 있습니다. 그러므로 다음과 같은 것을 쉽게 볼 수 있습니다:"

#: ../../faq/windows.rst:42
msgid "D:\\YourName\\Projects\\Python>"
msgstr "D:\\YourName\\Projects\\Python>"

#: ../../faq/windows.rst:46
msgid ""
"depending on how your computer has been set up and what else you have "
"recently done with it.  Once you have started such a window, you are well"
" on the way to running Python programs."
msgstr ""
"컴퓨터 설정 방법과 최근에 끝낸 그 밖의 것에 의존적입니다. 일단 이런 창을 시작했다면, 파이썬 프로그램을 실행할 준비가 된 "
"것입니다."

#: ../../faq/windows.rst:50
msgid ""
"You need to realize that your Python scripts have to be processed by "
"another program called the Python *interpreter*.  The interpreter reads "
"your script, compiles it into bytecodes, and then executes the bytecodes "
"to run your program. So, how do you arrange for the interpreter to handle"
" your Python?"
msgstr ""
"파이썬 스크립트는 파이썬 *인터프리터* 라는 다른 프로그램에서 진행할 필요가 있다는 것을 알고 있어야 합니다. 인터프리터는 "
"스크립트를 읽고, 바이트 코드로 컴파일하고, 바이트 코드를 실행하여 프로그램을 구동합니다. 그렇다면, 인터프리터를 통해 파이썬을 "
"처리하려면 어떻게 준비해야 하겠습니까?"

#: ../../faq/windows.rst:55
msgid ""
"First, you need to make sure that your command window recognises the word"
" \"py\" as an instruction to start the interpreter.  If you have opened a"
" command window, you should try entering the command ``py`` and hitting "
"return:"
msgstr ""
"먼저, 명령 창이 \"py\"라는 단어를 해석기를 시작하는 지시로 인식하는지 확인해야합니다. 명령 창을 열고 있으면, 명령 "
"``py`` 를 입력하고 return 키를 눌러야 합니다:"

#: ../../faq/windows.rst:60
msgid "C:\\Users\\YourName> py"
msgstr "C:\\Users\\YourName> py"

#: ../../faq/windows.rst:64
msgid "You should then see something like:"
msgstr "다음과 같이 표시됩니다:"

#: ../../faq/windows.rst:66
msgid ""
"Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit "
"(Intel)] on win32\n"
"Type \"help\", \"copyright\", \"credits\" or \"license\" for more "
"information.\n"
">>>"
msgstr ""
"Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit "
"(Intel)] on win32\n"
"Type \"help\", \"copyright\", \"credits\" or \"license\" for more "
"information.\n"
">>>"

#: ../../faq/windows.rst:72
msgid ""
"You have started the interpreter in \"interactive mode\". That means you "
"can enter Python statements or expressions interactively and have them "
"executed or evaluated while you wait.  This is one of Python's strongest "
"features.  Check it by entering a few expressions of your choice and "
"seeing the results:"
msgstr ""
"인터프리터를 \"대화형 모드\"로 시작했습니다. 즉, 파이썬 문장이나 표현식을 대화식으로 입력하여 대기하는 중에 실행 혹은 평가시킬"
" 수 있습니다. 이것은 파이썬의 가장 강력한 기능 중 하나입니다. 선택한 몇 가지 수식을 입력하여 확인하고 그 결과를 확인하십시오:"

#: ../../faq/windows.rst:77
msgid ""
">>> print(\"Hello\")\n"
"Hello\n"
">>> \"Hello\" * 3\n"
"'HelloHelloHello'"
msgstr ""
">>> print(\"Hello\")\n"
"Hello\n"
">>> \"Hello\" * 3\n"
"'HelloHelloHello'"

#: ../../faq/windows.rst:84
msgid ""
"Many people use the interactive mode as a convenient yet highly "
"programmable calculator.  When you want to end your interactive Python "
"session, call the :func:`exit` function or hold the :kbd:`Ctrl` key down "
"while you enter a :kbd:`Z`, then hit the \":kbd:`Enter`\" key to get back"
" to your Windows command prompt."
msgstr ""
"많은 사람이 대화형 모드를 편리하면서도 프로그래밍이 가능한 계산기로 사용합니다. 대화형 파이썬 세션을 종료하려면, "
":func:`exit` 함수를 호출하거나 :kbd:`Z` 를 입력하면서 :kbd:`Ctrl` 키를 누르고 나서 "
"\":kbd:`Enter`\" 키를 눌러 윈도우 명령 프롬프트로 돌아갑니다."

#: ../../faq/windows.rst:90
msgid ""
"You may also find that you have a Start-menu entry such as "
":menuselection:`Start --> Programs --> Python 3.x --> Python (command "
"line)` that results in you seeing the ``>>>`` prompt in a new window.  If"
" so, the window will disappear after you call the :func:`exit` function "
"or enter the :kbd:`Ctrl-Z` character; Windows is running a single "
"\"python\" command in the window, and closes it when you terminate the "
"interpreter."
msgstr ""
"또한, :menuselection:`시작 --> 프로그램 --> Python 3.x --> Python(명령 줄)` 메뉴 선택과 "
"같은 시작 메뉴 항목을 찾아볼 수 있으며, 그 결과 새 창에서 ``>>>`` 프롬프트를 볼 수 있습니다. 이 경우, "
":func:`exit` 함수를 호출하거나 :kbd:`Ctrl-Z` 를 입력하면 창이 사라집니다. 윈도우에서 단일 \"python\""
" 명령을 실행하는 중이고, 인터프리터를 종료하면 창을 닫습니다."

#: ../../faq/windows.rst:97
msgid ""
"Now that we know the ``py`` command is recognized, you can give your "
"Python script to it. You'll have to give either an absolute or a relative"
" path to the Python script. Let's say your Python script is located in "
"your desktop and is named ``hello.py``, and your command prompt is nicely"
" opened in your home directory so you're seeing something similar to::"
msgstr ""
"이제 ``py`` 명령이 인식되었으므로, 당신은 당신의 파이썬 스크립트를 줄 수 있습니다. 파이썬 스크립트에 절대 경로나 상대 "
"경로를 지정해야 할 것입니다. 당신의 파이썬 스크립트가 ``hello.py`` 라는 이름으로 당신의 데스크톱에 위치한다고 하면, "
"명령 프롬프트가 홈 디렉토리에 잘 열려있으므로 다음과 같이 내용이 표시됩니다::"

#: ../../faq/windows.rst:104
msgid "C:\\Users\\YourName>"
msgstr "C:\\Users\\YourName>"

#: ../../faq/windows.rst:106
msgid ""
"So now you'll ask the ``py`` command to give your script to Python by "
"typing ``py`` followed by your script path::"
msgstr "그래서 이제 스크립트 경로 뒤에 ``py`` 를 입력하여 파이썬 스크립트를 제공하기 위해 ``py`` 명령을 요청할 것입니다::"

#: ../../faq/windows.rst:110
msgid ""
"C:\\Users\\YourName> py Desktop\\hello.py\n"
"hello"
msgstr ""
"C:\\Users\\YourName> py Desktop\\hello.py\n"
"hello"

#: ../../faq/windows.rst:114
msgid "How do I make Python scripts executable?"
msgstr "파이썬 스크립트 실행 파일로 만들려면 어떻게 해야 합니까?"

#: ../../faq/windows.rst:116
#, qt-format
msgid ""
"On Windows, the standard Python installer already associates the .py "
"extension with a file type (Python.File) and gives that file type an open"
" command that runs the interpreter (``D:\\Program "
"Files\\Python\\python.exe \"%1\" %*``).  This is enough to make scripts "
"executable from the command prompt as 'foo.py'.  If you'd rather be able "
"to execute the script by simple typing 'foo' with no extension you need "
"to add .py to the PATHEXT environment variable."
msgstr ""
"윈도우에서 표준 파이썬 설치관리자는 이미 .py 확장자와 파일 유형(Python.File)을 연결했고, "
"인터프리터(``D:\\Program Files\\Python\\python.exe \"%1\" %*``)를 실행하는 open 명령의"
" 파일 유형을 제공합니다. 이것은 명령 프롬프트에서 'foo.py' 과 같은 스크립트 실행파일을 만들기에 충분합니다. 확장자명 없이"
" 'foo' 를 입력하여 스크립트를 실행하려면 PATHEXT 환경 변수에 .py를 추가해야 합니다."

#: ../../faq/windows.rst:124
msgid "Why does Python sometimes take so long to start?"
msgstr "왜 때때로 파이썬은 시작하는 데 시간이 오래 걸립니까?"

#: ../../faq/windows.rst:126
msgid ""
"Usually Python starts very quickly on Windows, but occasionally there are"
" bug reports that Python suddenly begins to take a long time to start up."
"  This is made even more puzzling because Python will work fine on other "
"Windows systems which appear to be configured identically."
msgstr ""
"일반적으로 파이썬은 윈도우에서 매우 빠르게 시작되지만, 때때로 파이썬을 시작하는 데 갑자기 오랜 시간이 걸린다는 버그 보고서가 "
"있습니다. 이러한 것은 파이썬이 동일하게 구성된 것으로 보이는 다른 윈도우 시스템에서 잘 작동하기 때문에 더욱 더 곤혹스럽게 "
"만듭니다."

#: ../../faq/windows.rst:131
msgid ""
"The problem may be caused by a misconfiguration of virus checking "
"software on the problem machine.  Some virus scanners have been known to "
"introduce startup overhead of two orders of magnitude when the scanner is"
" configured to monitor all reads from the filesystem.  Try checking the "
"configuration of virus scanning software on your systems to ensure that "
"they are indeed configured identically. McAfee, when configured to scan "
"all file system read activity, is a particular offender."
msgstr ""
"이 문제는 해당 컴퓨터의 바이러스 검사 소프트웨어의 잘못된 설정으로 발생하는 것일 수 있습니다. 일부 바이러스 스캐너는 파일 "
"시스템으로부터 읽은 모든 것을 모니터링하도록 스캐너를 구성할 때 두 자릿수 규모의 시동 오버헤드를 도입하는 것으로 알려져 있습니다."
" 시스템에서 바이러스 검사 소프트웨어의 구성을 확인하여 실제로 동일하게 구성되었는지 확인하십시오. 모든 파일 시스템 읽기 작업을 "
"검색하도록 구성된 경우, McAfee는 특히 문제를 일으킵니다."

#: ../../faq/windows.rst:141
msgid "How do I make an executable from a Python script?"
msgstr "파이썬 스크립트에서 실행 파일을 만드는 방법은 무엇입니까?"

#: ../../faq/windows.rst:143
msgid ""
"See :ref:`faq-create-standalone-binary` for a list of tools that can be "
"used to make executables."
msgstr ""

#: ../../faq/windows.rst:148
msgid "Is a ``*.pyd`` file the same as a DLL?"
msgstr "``*.pyd`` 파일은 DLL과 동일합니까?"

#: ../../faq/windows.rst:150
msgid ""
"Yes, .pyd files are dll's, but there are a few differences.  If you have "
"a DLL named ``foo.pyd``, then it must have a function ``PyInit_foo()``.  "
"You can then write Python \"import foo\", and Python will search for "
"foo.pyd (as well as foo.py, foo.pyc) and if it finds it, will attempt to "
"call ``PyInit_foo()`` to initialize it.  You do not link your .exe with "
"foo.lib, as that would cause Windows to require the DLL to be present."
msgstr ""
"예, .pyd 파일은 dll 이지만, 몇 가지 차이점이 있습니다. 만약 당신이 ``foo.pyd`` 라는 이름의 DLL을 가지고 "
"있다면, ``PyInit_foo()`` 함수를 반드시 가지고 있어야 합니다. 당신은 파이썬 \"import foo\"를 쓸 수 "
"있으며, 파이썬은 (foo.py, foo.pyc 뿐만 아니라) foo.pyd 를 검색할 것이고, 이를 발견하면 초기화하기 위해 "
"``PyInit_foo()`` 호출을 시도할 것입니다. 윈도우에서 DLL 의 존재를 요구할 것이기 때문에 .exe를 foo.lib와"
" 링크하면 안 됩니다."

#: ../../faq/windows.rst:157
msgid ""
"Note that the search path for foo.pyd is PYTHONPATH, not the same as the "
"path that Windows uses to search for foo.dll.  Also, foo.pyd need not be "
"present to run your program, whereas if you linked your program with a "
"dll, the dll is required.  Of course, foo.pyd is required if you want to "
"say ``import foo``.  In a DLL, linkage is declared in the source code "
"with ``__declspec(dllexport)``. In a .pyd, linkage is defined in a list "
"of available functions."
msgstr ""
"foo.pyd에 대한 검색 경로는 윈도우에서 foo.dll을 검색하는 데 사용하는 경로가 아닌 PYTHONPATH임을 유의하십시오."
" 또한, 프로그램을 실행하기 위해 foo.pyd가 있을 필요는 없지만, 프로그램을 dll과 링크한 경우에는 dll이 필요합니다. "
"물론, ``import foo`` 를 하기 위해서는 foo.pyd가 필요합니다. DLL에서 링키지는 소스 코드에서 "
"``__declspec(dllexport)`` 로 선언됩니다. .pyd에서 링키지는 사용 가능한 함수 목록에 정의됩니다."

#: ../../faq/windows.rst:166
msgid "How can I embed Python into a Windows application?"
msgstr "윈도우 응용프로그램에 파이썬을 포함하려면 어떻게 해야 합니까?"

#: ../../faq/windows.rst:168
msgid ""
"Embedding the Python interpreter in a Windows app can be summarized as "
"follows:"
msgstr "윈도우 앱에서 파이썬 인터프리터를 포함하려면 다음과 같이 요약할 수 있습니다:"

#: ../../faq/windows.rst:170
#, python-brace-format
msgid ""
"Do **not** build Python into your .exe file directly.  On Windows, Python"
" must be a DLL to handle importing modules that are themselves DLL's.  "
"(This is the first key undocumented fact.)  Instead, link to "
":file:`python{NN}.dll`; it is typically installed in "
"``C:\\Windows\\System``.  *NN* is the Python version, a number such as "
"\"33\" for Python 3.3."
msgstr ""
".exe 파일에 직접 파이썬을 빌드하면 **안** 됩니다. 윈도우에서 파이썬은 그 자신이 DLL인 모듈의 임포트를 처리하기 위해서는"
" DLL이어야 합니다. (이것이 문서화되지 않은 첫 번째 사실입니다) 대신에, :file:`python{NN}.dll` 에 링크하면"
" 됩니다. 일반적으로 ``C:\\Windows\\System`` 에 설치됩니다. *NN*\\은 파이썬 버전이고, Python "
"3.3의 경우 \"33\"과 같은 숫자입니다."

#: ../../faq/windows.rst:176
#, python-brace-format
msgid ""
"You can link to Python in two different ways.  Load-time linking means "
"linking against :file:`python{NN}.lib`, while run-time linking means "
"linking against :file:`python{NN}.dll`.  (General note: "
":file:`python{NN}.lib` is the so-called \"import lib\" corresponding to "
":file:`python{NN}.dll`.  It merely defines symbols for the linker.)"
msgstr ""
"두 가지 방법으로 파이썬에 링크할 수 있습니다. 로드 타임 링크는 :file:`python{NN}.lib` 에 대한 링크를 "
"의미하고, 런타임 링크는 :file:`python{NN}.dll` 에 대한 링크를 의미합니다. (일반 참고: "
":file:`python{NN}.lib` 는 :file:`python{NN}.dll` 에 해당하는 소위 \"import "
"lib\"입니다. 오직 링커를 위해 기호만 정의합니다)"

#: ../../faq/windows.rst:182
#, python-brace-format
msgid ""
"Run-time linking greatly simplifies link options; everything happens at "
"run time.  Your code must load :file:`python{NN}.dll` using the Windows "
"``LoadLibraryEx()`` routine.  The code must also use access routines and "
"data in :file:`python{NN}.dll` (that is, Python's C API's) using pointers"
" obtained by the Windows ``GetProcAddress()`` routine.  Macros can make "
"using these pointers transparent to any C code that calls routines in "
"Python's C API."
msgstr ""
"런타임 링크는 링크 옵션을 크게 단순화합니다. 모든 것은 런타임 중에 발생합니다. 당신의 코드는 윈도우 "
"``LoadLibraryEx()`` 루틴을 사용하여 :file:`python{NN}.dll` 을 로드해야 합니다. 그 코드는 윈도우"
" ``GetProcAddress()`` 루틴에서 얻은 포인터를 사용하여 :file:`python{NN}.dll` (파이썬의 C "
"API)의 엑세스 루틴 및 데이터를 사용해야 합니다. 매크로는 이러한 포인터를 파이썬 C API에서 루틴을 호출하는 모든 C 코드에"
" 투명하게 사용할 수 있습니다."

#: ../../faq/windows.rst:191
msgid ""
"If you use SWIG, it is easy to create a Python \"extension module\" that "
"will make the app's data and methods available to Python.  SWIG will "
"handle just about all the grungy details for you.  The result is C code "
"that you link *into* your .exe file (!)  You do **not** have to create a "
"DLL file, and this also simplifies linking."
msgstr ""
"SWIG를 사용할 경우, 앱의 데이터와 메서드를 파이썬에서 사용할 수 있게 만드는 파이썬 \"확장 모듈\"을 생성하는 것이 "
"쉽습니다. SWIG는 당신을 위해 모든 성가신 세부사항들을 처리할 것입니다. 그 결과로 .exe 파일에 링크한 C 코드가 "
"생성됩니다! DLL 파일을 만들 필요가 **없으며**, 만들지 않으면 링크하는 것도 간단해집니다."

#: ../../faq/windows.rst:197
msgid ""
"SWIG will create an init function (a C function) whose name depends on "
"the name of the extension module.  For example, if the name of the module"
" is leo, the init function will be called initleo().  If you use SWIG "
"shadow classes, as you should, the init function will be called "
"initleoc().  This initializes a mostly hidden helper class used by the "
"shadow class."
msgstr ""
"SWIG는 확장 모듈의 이름에 따라 이름이 달라지는 초기화 함수(C 함수)를 생성합니다. 예를 들어, 모듈의 이름이 leo인 경우,"
" 초기화 함수를 initleo()로 합니다. SWIG 섀도 클래스를 사용하면 initleoc()로 합니다. 이것은 섀도 클래스가 "
"사용하는 대부분 숨겨진 조력자 클래스를 초기화합니다."

#: ../../faq/windows.rst:203
msgid ""
"The reason you can link the C code in step 2 into your .exe file is that "
"calling the initialization function is equivalent to importing the module"
" into Python! (This is the second key undocumented fact.)"
msgstr ""
"2단계에서 C 코드를 .exe 파일에 링크할 수 있는 이유는 초기화 함수를 호출하는 것이 모듈을 파이썬으로 임포트하는 것과 동일하기"
" 때문입니다! (이것이 문서화되지 않은 두 번째 사실입니다)"

#: ../../faq/windows.rst:207
msgid ""
"In short, you can use the following code to initialize the Python "
"interpreter with your extension module."
msgstr "간단히 말해서, 당신은 당신의 확장 모듈로 파이썬 인터프리터를 초기화하기 위해 다음 코드를 사용할 수 있습니다."

#: ../../faq/windows.rst:210
msgid ""
"#include <Python.h>\n"
"...\n"
"Py_Initialize();  // Initialize Python.\n"
"initmyAppc();  // Initialize (import) the helper class.\n"
"PyRun_SimpleString(\"import myApp\");  // Import the shadow class."
msgstr ""
"#include <Python.h>\n"
"...\n"
"Py_Initialize();  // 파이썬을 초기화합니다.\n"
"initmyAppc();  // 헬퍼 클래스를 초기화(임포트)합니다.\n"
"PyRun_SimpleString(\"import myApp\");  // 섀도 클래스를 임포트합니다."

#: ../../faq/windows.rst:218
msgid ""
"There are two problems with Python's C API which will become apparent if "
"you use a compiler other than MSVC, the compiler used to build "
"pythonNN.dll."
msgstr ""
"파이썬의 C API에는 두 가지 문제가 있는데, 이것은 당신이 PythonNN.dll을 만드는 데 사용되는 컴파일러인 MSVC "
"이외의 컴파일러를 사용하면 명백해집니다."

#: ../../faq/windows.rst:221
msgid ""
"Problem 1: The so-called \"Very High Level\" functions that take ``FILE "
"*`` arguments will not work in a multi-compiler environment because each "
"compiler's notion of a ``struct FILE`` will be different.  From an "
"implementation standpoint these are very low level functions."
msgstr ""
"문제 1: ``FILE *`` 인자를 취하는 소위 \"매우 높은 수준\"의 함수는 각 컴파일러의 구조체 FILE 개념이 다르기 "
"때문에 멀티 컴파일러 환경에서는 작동하지 않습니다. 구현 관점에서 볼 때 이들은 매우 낮은 수준의 함수입니다."

#: ../../faq/windows.rst:226
msgid ""
"Problem 2: SWIG generates the following code when generating wrappers to "
"void functions:"
msgstr "문제 2: 반환값이 void인 C 함수의 래퍼를 생성할 때 SWIG는 다음과 같은 코드를 생성합니다:"

#: ../../faq/windows.rst:229
msgid ""
"Py_INCREF(Py_None);\n"
"_resultobj = Py_None;\n"
"return _resultobj;"
msgstr ""
"Py_INCREF(Py_None);\n"
"_resultobj = Py_None;\n"
"return _resultobj;"

#: ../../faq/windows.rst:235
msgid ""
"Alas, Py_None is a macro that expands to a reference to a complex data "
"structure called _Py_NoneStruct inside pythonNN.dll.  Again, this code "
"will fail in a mult-compiler environment.  Replace such code by:"
msgstr ""
"아아, Py_None은 pythonNN.dll 내부의 _Py_NoneStruct라는 복잡한 데이터 구조에 대한 참조로 확장하는 "
"매크로입니다. 다시 말하자면, 이 코드는 멀티 컴파일러 환경에서 실패할 것입니다. 다음과 같은 코드로 바꾸십시오:"

#: ../../faq/windows.rst:239
msgid "return Py_BuildValue(\"\");"
msgstr "return Py_BuildValue(\"\");"

#: ../../faq/windows.rst:243
msgid ""
"It may be possible to use SWIG's ``%typemap`` command to make the change "
"automatically, though I have not been able to get this to work (I'm a "
"complete SWIG newbie)."
msgstr ""
"저는 이것을 작동시키지는 못했지만, SWIG의 ``%typemap`` 명령을 사용하여 자동으로 변경하는 것이 가능할지도 "
"모릅니다(저는 완전 SWIG 초보자입니다)."

#: ../../faq/windows.rst:247
msgid ""
"Using a Python shell script to put up a Python interpreter window from "
"inside your Windows app is not a good idea; the resulting window will be "
"independent of your app's windowing system.  Rather, you (or the "
"wxPythonWindow class) should create a \"native\" interpreter window.  It "
"is easy to connect that window to the Python interpreter.  You can "
"redirect Python's i/o to _any_ object that supports read and write, so "
"all you need is a Python object (defined in your extension module) that "
"contains read() and write() methods."
msgstr ""
"윈도우 앱 내부에서 파이썬 셸 스크립트를 사용하여 파이썬 인터프리터 창을 설치하는 것은 좋은 생각이 아닙니다. 결과 창은 앱의 창 "
"시스템과는 독립적일 것입니다. 오히려, 당신(또는 wxPythonWindow 클래스)은 \"native\" 인터프리터 창을 만들어야"
" 합니다. 이 창은 파이썬 인터프리터와 연결하기 쉽습니다. 당신은 파이썬의 i/o를 읽기 및 쓰기를 지원하는 모든 객체로 리디렉션할"
" 수 있으므로 read() 와 write() 메서드를 포함하는 파이썬 객체(확장 모듈에 정의됨)만 있으면 됩니다."

#: ../../faq/windows.rst:256
msgid "How do I keep editors from inserting tabs into my Python source?"
msgstr "편집기가 내 파이썬 소스에 탭을 삽입하지 않도록 하려면 어떻게 해야 합니까?"

#: ../../faq/windows.rst:258
msgid ""
"The FAQ does not recommend using tabs, and the Python style guide, "
":pep:`8`, recommends 4 spaces for distributed Python code; this is also "
"the Emacs python-mode default."
msgstr ""
"FAQ는 탭을 사용하는 것을 권장하지 않으며, 파이썬 스타일 안내서( :pep:`8` )는 분산된 파이썬 코드에 대해 4 개의 "
"스페이스를 권장합니다. 이 또한 Emacs python-mode의 기본값입니다."

#: ../../faq/windows.rst:262
msgid ""
"Under any editor, mixing tabs and spaces is a bad idea.  MSVC is no "
"different in this respect, and is easily configured to use spaces: Take "
":menuselection:`Tools --> Options --> Tabs`, and for file type "
"\"Default\" set \"Tab size\" and \"Indent size\" to 4, and select the "
"\"Insert spaces\" radio button."
msgstr ""
"모든 편집기에서 탭과 스페이스를 혼용하는 것은 좋은 생각이 아닙니다. 이 점에서 MSVC는 다르지 않으며 스페이스를 사용하기 쉽게 "
"구성됩니다: 다음 행동을 따라 해보십시오 :menuselection:`Tools --> Options --> Tabs`, 그리고 "
"파일 유형은 \"\"Default\"로 하고 \"Tab size\"와 \"Indent size\"는 4로 설정하고, \"Insert"
" spaces\"를 라디오 버튼으로 선택합니다."

#: ../../faq/windows.rst:267
msgid ""
"Python raises :exc:`IndentationError` or :exc:`TabError` if mixed tabs "
"and spaces are causing problems in leading whitespace. You may also run "
"the :mod:`tabnanny` module to check a directory tree in batch mode."
msgstr ""
"만일 혼용된 탭과 스페이스로 인해 선행 공백에 문제가 발생하는 경우, 파이썬이 :exc:`IndentationError` 나 "
":exc:`TabError` 를 발생시킵니다. 또한, :mod:`tabnanny` 모듈을 실행하여 배치 모드에서 디렉터리 트리를 "
"확인할 수도 있습니다."

#: ../../faq/windows.rst:274
msgid "How do I check for a keypress without blocking?"
msgstr "블로킹 없이 키 입력을 확인하려면 어떻게 해야 합니까?"

#: ../../faq/windows.rst:276
msgid ""
"Use the :mod:`msvcrt` module.  This is a standard Windows-specific "
"extension module. It defines a function ``kbhit()`` which checks whether "
"a keyboard hit is present, and ``getch()`` which gets one character "
"without echoing it."
msgstr ""
":mod:`msvcrt` 모듈을 사용합니다. 이것은 표준 윈도우-특정 확장 모듈입니다. 이것은 키보드 히트가 존재하는지를 확인하는 "
"``kbhit()`` 와 에코 없이 문자를 얻는 ``getch()`` 를 정의합니다."

#: ../../faq/windows.rst:281
msgid "How do I solve the missing api-ms-win-crt-runtime-l1-1-0.dll error?"
msgstr ""

#: ../../faq/windows.rst:283
msgid ""
"This can occur on Python 3.5 and later when using Windows 8.1 or earlier "
"without all updates having been installed. First ensure your operating "
"system is supported and is up to date, and if that does not resolve the "
"issue, visit the `Microsoft support page <https://support.microsoft.com"
"/en-us/help/3118401/>`_ for guidance on manually installing the C Runtime"
" update."
msgstr ""

#~ msgid ""
#~ "See `cx_Freeze <https://cx-"
#~ "freeze.readthedocs.io/en/latest/>`_ for a distutils"
#~ " extension that allows you to create"
#~ " console and GUI executables from "
#~ "Python code. `py2exe <http://www.py2exe.org/>`_, "
#~ "the most popular extension for building"
#~ " Python 2.x-based executables, does not "
#~ "yet support Python 3 but a version"
#~ " that does is in development."
#~ msgstr ""
#~ "파이썬 코드에서 콘솔 및 GUI 실행 파일을 만들"
#~ " 수 있는 distutils 확장을 위해 `cx_Freeze "
#~ "<https://cx-freeze.readthedocs.io/en/latest/>`_ 를 "
#~ "참고하시면 됩니다. Python 2.x 기반 실행 파일을"
#~ " 만드는 데 가장 인기 있는 확장인 `py2exe "
#~ "<http://www.py2exe.org/>`_ 는 파이썬 3 버전이 "
#~ "개발중에 있어 아직 파이썬 3을 지원하지 않습니다."

#~ msgid ""
#~ "Borland note: convert :file:`python{NN}.lib` "
#~ "to OMF format using Coff2Omf.exe first."
#~ msgstr ""
#~ "Borland 참고 : 먼저 Coff2Omf.exe를 사용하여 "
#~ ":file:`python{NN}.lib` 를 OMF 형식으로 변환합니다."

