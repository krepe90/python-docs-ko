# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../faq/extending.rst:3
msgid "Extending/Embedding FAQ"
msgstr "확장/내장 FAQ"

#: ../../faq/extending.rst:6
msgid "Contents"
msgstr "목차"

#: ../../faq/extending.rst:16
msgid "Can I create my own functions in C?"
msgstr "C로 나만의 함수를 만들 수 있습니까?"

#: ../../faq/extending.rst:18
msgid ""
"Yes, you can create built-in modules containing functions, variables, "
"exceptions and even new types in C.  This is explained in the document "
":ref:`extending-index`."
msgstr ""
"그렇습니다. 함수, 변수, 예외 및 심지어 새로운 형을 포함하는 내장 모듈을 C로 만들 수 있습니다. :ref:`extending-"
"index` 문서에 설명되어 있습니다."

#: ../../faq/extending.rst:22
msgid "Most intermediate or advanced Python books will also cover this topic."
msgstr "대부분의 중급이나 고급 파이썬 서적에서도 이 주제를 다룰 것입니다."

#: ../../faq/extending.rst:26
msgid "Can I create my own functions in C++?"
msgstr "C++로 나만의 함수를 만들 수 있습니까?"

#: ../../faq/extending.rst:28
#, python-brace-format
msgid ""
"Yes, using the C compatibility features found in C++.  Place ``extern "
"\"C\" { ... }`` around the Python include files and put ``extern \"C\"`` "
"before each function that is going to be called by the Python "
"interpreter.  Global or static C++ objects with constructors are probably"
" not a good idea."
msgstr ""
"그렇습니다, C++에 있는 C 호환성 기능을 사용합니다. 파이썬 인클루드(include) 파일 주위에 ``extern \"C\" {"
" ... }``\\를 배치하고 파이썬 인터프리터가 호출할 각 함수 앞에 ``extern \"C\"``\\를 배치하십시오. 생성자를 "
"가진 전역이나 정적(static) C++ 객체는 대개 좋은 생각이 아닙니다."

#: ../../faq/extending.rst:37
msgid "Writing C is hard; are there any alternatives?"
msgstr "C를 쓰는 것은 어렵습니다; 대안이 있습니까?"

#: ../../faq/extending.rst:39
msgid ""
"There are a number of alternatives to writing your own C extensions, "
"depending on what you're trying to do."
msgstr "수행하려는 작업에 따라, 여러분 만의 C 확장을 작성하는 여러 가지 대안이 있습니다."

#: ../../faq/extending.rst:44
msgid ""
"`Cython <https://cython.org>`_ and its relative `Pyrex "
"<https://www.csse.canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ are "
"compilers that accept a slightly modified form of Python and generate the"
" corresponding C code.  Cython and Pyrex make it possible to write an "
"extension without having to learn Python's C API."
msgstr ""
"`Cython <https://cython.org>`_\\과 관련 `Pyrex "
"<https://www.csse.canterbury.ac.nz/greg.ewing/python/Pyrex/>`_\\는 약간 수정된 "
"파이썬 형식을 받아들이고 해당 C 코드를 생성하는 컴파일러입니다. Cython과 Pyrex를 사용하면 파이썬의 C API를 배우지 "
"않고도 확장을 작성할 수 있습니다."

#: ../../faq/extending.rst:50
msgid ""
"If you need to interface to some C or C++ library for which no Python "
"extension currently exists, you can try wrapping the library's data types"
" and functions with a tool such as `SWIG <https://www.swig.org>`_.  `SIP "
"<https://github.com/Python-SIP/sip>`__, `CXX "
"<https://cxx.sourceforge.net/>`_ `Boost "
"<https://www.boost.org/libs/python/doc/index.html>`_, or `Weave "
"<https://github.com/scipy/weave>`_ are also alternatives for wrapping C++"
" libraries."
msgstr ""
"현재 파이썬 확장이 없는 일부 C나 C++ 라이브러리에 대한 인터페이스가 필요하면, 라이브러리의 데이터형과 함수를 `SWIG "
"<https://www.swig.org>`_\\과 같은 도구로 래핑할 수 있습니다. `SIP <https://github.com"
"/Python-SIP/sip>`__, `CXX <https://cxx.sourceforge.net/>`_, `Boost "
"<https://www.boost.org/libs/python/doc/index.html>`_ 또는 `Weave "
"<https://github.com/scipy/weave>`_\\도 C++ 라이브러리 래핑의 대안입니다."

#: ../../faq/extending.rst:61
msgid "How can I execute arbitrary Python statements from C?"
msgstr "C에서 임의의 파이썬 문장을 어떻게 실행할 수 있습니까?"

#: ../../faq/extending.rst:63
msgid ""
"The highest-level function to do this is :c:func:`PyRun_SimpleString` "
"which takes a single string argument to be executed in the context of the"
" module ``__main__`` and returns ``0`` for success and ``-1`` when an "
"exception occurred (including :exc:`SyntaxError`).  If you want more "
"control, use :c:func:`PyRun_String`; see the source for "
":c:func:`PyRun_SimpleString` in ``Python/pythonrun.c``."
msgstr ""
"이를 수행하는 최상위 수준 함수는 :c:func:`PyRun_SimpleString`\\이며, 이는 모듈 "
"``__main__``\\의 컨텍스트에서 실행될 단일 문자열 인자를 취하고 성공하면 ``0``\\을 반환하고 "
"(:exc:`SyntaxError`\\를 포함하는) 예외가 발생하면 ``-1``\\을 반환합니다. 더 많은 제어를 원하면, "
":c:func:`PyRun_String`\\을 사용하십시오; ``Python/pythonrun.c``\\에 있는 "
":c:func:`PyRun_SimpleString` 소스를 참조하십시오."

#: ../../faq/extending.rst:72
msgid "How can I evaluate an arbitrary Python expression from C?"
msgstr "C에서 임의의 파이썬 표현식을 어떻게 평가할 수 있습니까?"

#: ../../faq/extending.rst:74
msgid ""
"Call the function :c:func:`PyRun_String` from the previous question with "
"the start symbol :c:data:`Py_eval_input`; it parses an expression, "
"evaluates it and returns its value."
msgstr ""
"이전 질문에서 나온 :c:func:`PyRun_String` 함수를 start 기호 :c:data:`Py_eval_input`\\을"
" 사용하여 호출하십시오; 표현식을 구문 분석하고, 평가하고 값을 반환합니다."

#: ../../faq/extending.rst:80
msgid "How do I extract C values from a Python object?"
msgstr "파이썬 객체에서 C값을 어떻게 추출합니까?"

#: ../../faq/extending.rst:82
msgid ""
"That depends on the object's type.  If it's a tuple, "
":c:func:`PyTuple_Size` returns its length and :c:func:`PyTuple_GetItem` "
"returns the item at a specified index.  Lists have similar functions, "
":c:func:`PyList_Size` and :c:func:`PyList_GetItem`."
msgstr ""
"이는 객체의 형에 따라 다릅니다. 튜플이면, :c:func:`PyTuple_Size`\\는 길이를 반환하고 "
":c:func:`PyTuple_GetItem`\\은 지정된 인덱스의 항목을 반환합니다. 리스트는 비슷한 함수를 가지고 있습니다, "
":c:func:`PyList_Size`\\와 :c:func:`PyList_GetItem`."

#: ../../faq/extending.rst:87
msgid ""
"For bytes, :c:func:`PyBytes_Size` returns its length and "
":c:func:`PyBytes_AsStringAndSize` provides a pointer to its value and its"
" length.  Note that Python bytes objects may contain null bytes so C's "
":c:func:`!strlen` should not be used."
msgstr ""
"바이트열에서는, :c:func:`PyBytes_Size`\\는 길이를 반환하고 "
":c:func:`PyBytes_AsStringAndSize`\\는 값과 길이에 대한 포인터를 제공합니다. 파이썬 바이트열 객체는 "
"널(null) 바이트를 포함할 수 있어서 C의 :c:func:`!strlen`\\을 사용할 수 없음에 유의하십시오."

#: ../../faq/extending.rst:92
msgid ""
"To test the type of an object, first make sure it isn't ``NULL``, and "
"then use :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, "
":c:func:`PyList_Check`, etc."
msgstr ""
"객체의 형을 검사하려면, 먼저 ``NULL``\\이 아닌지 확인한 다음 :c:func:`PyBytes_Check`, "
":c:func:`PyTuple_Check`, :c:func:`PyList_Check` 등을 사용하십시오."

#: ../../faq/extending.rst:95
msgid ""
"There is also a high-level API to Python objects which is provided by the"
" so-called 'abstract' interface -- read ``Include/abstract.h`` for "
"further details.  It allows interfacing with any kind of Python sequence "
"using calls like :c:func:`PySequence_Length`, "
":c:func:`PySequence_GetItem`, etc. as well as many other useful protocols"
" such as numbers (:c:func:`PyNumber_Index` et al.) and mappings in the "
"PyMapping APIs."
msgstr ""
"소위 '추상' 인터페이스가 제공하는 파이썬 객체에 대한 고수준 API도 있습니다 -- 자세한 내용은 "
"``Include/abstract.h``\\를 읽으십시오. :c:func:`PySequence_Length`, "
":c:func:`PySequence_GetItem` 등과 같은 호출로 모든 종류의 파이썬 시퀀스와 인터페이스 할 수 있을 뿐만 "
"아니라 숫자(:c:func:`PyNumber_Index` 등)와 PyMapping API의 매핑과 같은 다른 많은 유용한 프로토콜을"
" 지원합니다."

#: ../../faq/extending.rst:104
msgid "How do I use Py_BuildValue() to create a tuple of arbitrary length?"
msgstr "Py_BuildValue()를 사용하여 임의 길이의 튜플을 만드는 방법은 무엇입니까?"

#: ../../faq/extending.rst:106
msgid "You can't.  Use :c:func:`PyTuple_Pack` instead."
msgstr "그럴 수 없습니다. 대신 :c:func:`PyTuple_Pack`\\을 사용하십시오."

#: ../../faq/extending.rst:110
msgid "How do I call an object's method from C?"
msgstr "C에서 객체의 메서드를 어떻게 호출합니까?"

#: ../../faq/extending.rst:112
msgid ""
"The :c:func:`PyObject_CallMethod` function can be used to call an "
"arbitrary method of an object.  The parameters are the object, the name "
"of the method to call, a format string like that used with "
":c:func:`Py_BuildValue`, and the argument values::"
msgstr ""
":c:func:`PyObject_CallMethod` 함수는 객체의 임의의 메서드를 호출하는 데 사용할 수 있습니다. 매개 변수는 "
"객체, 호출할 메서드의 이름, :c:func:`Py_BuildValue`\\에 사용되는 것과 같은 포맷 문자열 및 인자 값입니다::"

#: ../../faq/extending.rst:117
msgid ""
"PyObject *\n"
"PyObject_CallMethod(PyObject *object, const char *method_name,\n"
"                    const char *arg_format, ...);"
msgstr ""
"PyObject *\n"
"PyObject_CallMethod(PyObject *object, const char *method_name,\n"
"                    const char *arg_format, ...);"

#: ../../faq/extending.rst:121
msgid ""
"This works for any object that has methods -- whether built-in or user-"
"defined. You are responsible for eventually :c:func:`Py_DECREF`\\ 'ing "
"the return value."
msgstr ""
"메서드가 있는 모든 객체에서 작동합니다 -- 내장이나 사용자 정의 모두 작동합니다. 반환 값을 "
":c:func:`Py_DECREF`\\할 책임은 여러분에게 있습니다."

#: ../../faq/extending.rst:124
msgid ""
"To call, e.g., a file object's \"seek\" method with arguments 10, 0 "
"(assuming the file object pointer is \"f\")::"
msgstr "예를 들어, 인자 10, 0으로 파일 객체의 \"seek\" 메서드를 호출하려면 (파일 객체 포인터가 \"f\"라고 가정합니다)::"

#: ../../faq/extending.rst:127
#, python-brace-format
msgid ""
"res = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\n"
"if (res == NULL) {\n"
"        ... an exception occurred ...\n"
"}\n"
"else {\n"
"        Py_DECREF(res);\n"
"}"
msgstr ""
"res = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\n"
"if (res == NULL) {\n"
"        ... an exception occurred ...\n"
"}\n"
"else {\n"
"        Py_DECREF(res);\n"
"}"

#: ../../faq/extending.rst:135
msgid ""
"Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for "
"the argument list, to call a function without arguments, pass \"()\" for "
"the format, and to call a function with one argument, surround the "
"argument in parentheses, e.g. \"(i)\"."
msgstr ""
":c:func:`PyObject_CallObject`\\는 *항상* 인자 목록에 대한 튜플을 원하므로, 인자 없이 함수를 "
"호출하려면, format으로 \"()\"를 전달하고, 하나의 인자로 함수를 호출하려면, 인자를 괄호로 묶습니다, 예를 들어 "
"\"(i)\"."

#: ../../faq/extending.rst:142
msgid ""
"How do I catch the output from PyErr_Print() (or anything that prints to "
"stdout/stderr)?"
msgstr "PyErr_Print()의 출력(또는 stdout/stderr로 인쇄되는 모든 것)을 어떻게 잡습니까?"

#: ../../faq/extending.rst:144
msgid ""
"In Python code, define an object that supports the ``write()`` method.  "
"Assign this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call "
"print_error, or just allow the standard traceback mechanism to work. "
"Then, the output will go wherever your ``write()`` method sends it."
msgstr ""
"파이썬 코드에서, ``write()`` 메서드를 지원하는 객체를 정의하십시오. 이 객체를 :data:`sys.stdout`\\과 "
":data:`sys.stderr`\\에 대입하십시오. print_error를 호출하거나 표준 트레이스백 메커니즘이 작동하도록 "
"두십시오. 그러면 출력은 여러분의 ``write()`` 메서드가 보내는 곳으로 갑니다."

#: ../../faq/extending.rst:149
msgid "The easiest way to do this is to use the :class:`io.StringIO` class:"
msgstr "이렇게 하는 가장 쉬운 방법은 :class:`io.StringIO` 클래스를 사용하는 것입니다:"

#: ../../faq/extending.rst:151
msgid ""
">>> import io, sys\n"
">>> sys.stdout = io.StringIO()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(sys.stdout.getvalue())\n"
"foo\n"
"hello world!"
msgstr ""
">>> import io, sys\n"
">>> sys.stdout = io.StringIO()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(sys.stdout.getvalue())\n"
"foo\n"
"hello world!"

#: ../../faq/extending.rst:161
msgid "A custom object to do the same would look like this:"
msgstr "같은 작업을 수행하는 사용자 정의 객체는 다음과 같습니다:"

#: ../../faq/extending.rst:163
msgid ""
">>> import io, sys\n"
">>> class StdoutCatcher(io.TextIOBase):\n"
"...     def __init__(self):\n"
"...         self.data = []\n"
"...     def write(self, stuff):\n"
"...         self.data.append(stuff)\n"
"...\n"
">>> import sys\n"
">>> sys.stdout = StdoutCatcher()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(''.join(sys.stdout.data))\n"
"foo\n"
"hello world!"
msgstr ""
">>> import io, sys\n"
">>> class StdoutCatcher(io.TextIOBase):\n"
"...     def __init__(self):\n"
"...         self.data = []\n"
"...     def write(self, stuff):\n"
"...         self.data.append(stuff)\n"
"...\n"
">>> import sys\n"
">>> sys.stdout = StdoutCatcher()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(''.join(sys.stdout.data))\n"
"foo\n"
"hello world!"

#: ../../faq/extending.rst:182
msgid "How do I access a module written in Python from C?"
msgstr "C에서 파이썬으로 작성된 모듈에 어떻게 액세스합니까?"

#: ../../faq/extending.rst:184
msgid "You can get a pointer to the module object as follows::"
msgstr "다음과 같이 모듈 객체에 대한 포인터를 얻을 수 있습니다::"

#: ../../faq/extending.rst:186
msgid "module = PyImport_ImportModule(\"<modulename>\");"
msgstr "module = PyImport_ImportModule(\"<modulename>\");"

#: ../../faq/extending.rst:188
msgid ""
"If the module hasn't been imported yet (i.e. it is not yet present in "
":data:`sys.modules`), this initializes the module; otherwise it simply "
"returns the value of ``sys.modules[\"<modulename>\"]``.  Note that it "
"doesn't enter the module into any namespace -- it only ensures it has "
"been initialized and is stored in :data:`sys.modules`."
msgstr ""
"모듈을 아직 임포트 하지 않았으면 (즉, :data:`sys.modules`\\에 아직 없으면), 이것은 모듈을 초기화합니다; "
"그렇지 않으면 단순히 ``sys.modules[\"<modulename>\"]``\\의 값을 반환합니다. 이것은 모듈을 어떤 이름 "
"공간에도 넣지 않음에 유의하십시오 -- 단지 초기화되도록 하고 :data:`sys.modules`\\에 저장되도록 합니다."

#: ../../faq/extending.rst:194
msgid ""
"You can then access the module's attributes (i.e. any name defined in the"
" module) as follows::"
msgstr "그런 다음, 다음과 같이 모듈의 어트리뷰트(즉 모듈에 정의된 모든 이름)에 액세스할 수 있습니다::"

#: ../../faq/extending.rst:197
msgid "attr = PyObject_GetAttrString(module, \"<attrname>\");"
msgstr "attr = PyObject_GetAttrString(module, \"<attrname>\");"

#: ../../faq/extending.rst:199
msgid ""
"Calling :c:func:`PyObject_SetAttrString` to assign to variables in the "
"module also works."
msgstr "모듈에 있는 변수에 대입하기 위해 :c:func:`PyObject_SetAttrString`\\을 호출하는 것도 작동합니다."

#: ../../faq/extending.rst:204
msgid "How do I interface to C++ objects from Python?"
msgstr "파이썬에서 C++ 객체에 어떻게 인터페이스 합니까?"

#: ../../faq/extending.rst:206
msgid ""
"Depending on your requirements, there are many approaches.  To do this "
"manually, begin by reading :ref:`the \"Extending and Embedding\" document"
" <extending-index>`.  Realize that for the Python run-time system, there "
"isn't a whole lot of difference between C and C++ -- so the strategy of "
"building a new Python type around a C structure (pointer) type will also "
"work for C++ objects."
msgstr ""
"요구 사항에 따라 여러 가지 접근 방식이 있습니다. 이 작업을 수동으로 수행하려면, :ref:`\"확장 및 내장\" 문서 "
"<extending-index>`\\를 읽는 것으로 시작하십시오. 파이썬 런타임 시스템의 경우 C와 C++ 사이에는 큰 차이가 "
"없다는 것을 상기하십시오 -- 따라서 C 구조체 (포인터) 형을 중심으로 새로운 파이썬 형을 작성하는 전략이 C++ 객체에도 "
"적용됩니다."

#: ../../faq/extending.rst:212
msgid "For C++ libraries, see :ref:`c-wrapper-software`."
msgstr "C++ 라이브러리의 경우, :ref:`c-wrapper-software`\\를 참조하십시오."

#: ../../faq/extending.rst:216
msgid "I added a module using the Setup file and the make fails; why?"
msgstr "Setup 파일을 사용하여 모듈을 추가했는데 make가 실패합니다; 왜 그렇습니까?"

#: ../../faq/extending.rst:218
msgid ""
"Setup must end in a newline, if there is no newline there, the build "
"process fails.  (Fixing this requires some ugly shell script hackery, and"
" this bug is so minor that it doesn't seem worth the effort.)"
msgstr ""
"Setup은 개행으로 끝나야 하며, 개행이 없으면 빌드 프로세스가 실패합니다. (이 문제를 해결하려면 지저분한 셸 스크립트 해킹이 "
"필요하며, 이 버그는 너무 사소해서 그런 노력을 들일만 한 가치가 없는 것 같습니다.)"

#: ../../faq/extending.rst:224
msgid "How do I debug an extension?"
msgstr "확장을 어떻게 디버깅합니까?"

#: ../../faq/extending.rst:226
msgid ""
"When using GDB with dynamically loaded extensions, you can't set a "
"breakpoint in your extension until your extension is loaded."
msgstr "동적으로 로드된 확장에 GDB를 사용할 때, 확장이 로드될 때까지 확장에 중단점을 설정할 수 없습니다."

#: ../../faq/extending.rst:229
msgid "In your ``.gdbinit`` file (or interactively), add the command:"
msgstr "``.gdbinit`` 파일에서 (또는 대화식으로) 다음 명령을 추가하십시오:"

#: ../../faq/extending.rst:231
msgid "br _PyImport_LoadDynamicModule"
msgstr "br _PyImport_LoadDynamicModule"

#: ../../faq/extending.rst:235
msgid "Then, when you run GDB:"
msgstr "그런 다음, GDB를 실행할 때:"

#: ../../faq/extending.rst:237
msgid ""
"$ gdb /local/bin/python\n"
"gdb) run myscript.py\n"
"gdb) continue # repeat until your extension is loaded\n"
"gdb) finish   # so that your extension is loaded\n"
"gdb) br myfunction.c:50\n"
"gdb) continue"
msgstr ""
"$ gdb /local/bin/python\n"
"gdb) run myscript.py\n"
"gdb) continue # repeat until your extension is loaded\n"
"gdb) finish   # so that your extension is loaded\n"
"gdb) br myfunction.c:50\n"
"gdb) continue"

#: ../../faq/extending.rst:247
msgid ""
"I want to compile a Python module on my Linux system, but some files are "
"missing. Why?"
msgstr "리눅스 시스템에서 파이썬 모듈을 컴파일하고 싶지만, 일부 파일이 없습니다. 왜 그렇습니까?"

#: ../../faq/extending.rst:249
msgid ""
"Most packaged versions of Python omit some files required for compiling "
"Python extensions."
msgstr "대부분의 포장된 버전의 파이썬은 파이썬 확장을 컴파일하는 데 필요한 일부 파일을 생략하고 있습니다."

#: ../../faq/extending.rst:252
msgid "For Red Hat, install the python3-devel RPM to get the necessary files."
msgstr "레드햇의 경우, 필요한 파일을 얻으려면 python3-devel RPM을 설치하십시오."

#: ../../faq/extending.rst:254
msgid "For Debian, run ``apt-get install python3-dev``."
msgstr "데비안의 경우, ``apt-get install python3-dev``\\를 실행하십시오."

#: ../../faq/extending.rst:257
msgid "How do I tell \"incomplete input\" from \"invalid input\"?"
msgstr "\"잘못된 입력\"과 \"불완전한 입력\"을 어떻게 구별할 수 있습니까?"

#: ../../faq/extending.rst:259
msgid ""
"Sometimes you want to emulate the Python interactive interpreter's "
"behavior, where it gives you a continuation prompt when the input is "
"incomplete (e.g. you typed the start of an \"if\" statement or you didn't"
" close your parentheses or triple string quotes), but it gives you a "
"syntax error message immediately when the input is invalid."
msgstr ""
"때로 파이썬 대화식 인터프리터의 동작을 흉내 내고 싶을 때가 있습니다. 이것은 입력이 불완전할 때 (예를 들어, \"if\" 문의 "
"시작을 입력했거나 괄호나 삼중 문자열 따옴표를 닫지 않았을 때) 계속 프롬프트를 표시하지만, 입력이 유효하지 않으면 즉시 문법 에러"
" 메시지를 표시합니다."

#: ../../faq/extending.rst:265
msgid ""
"In Python you can use the :mod:`codeop` module, which approximates the "
"parser's behavior sufficiently.  IDLE uses this, for example."
msgstr ""
"파이썬에서는 :mod:`codeop` 모듈을 사용할 수 있습니다. 이 모듈은 구문 분석기의 동작을 충분히 근사합니다. 예를 들어, "
"IDLE은 이것을 사용합니다."

#: ../../faq/extending.rst:268
msgid ""
"The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` "
"(perhaps in a separate thread) and let the Python interpreter handle the "
"input for you. You can also set the "
":c:func:`PyOS_ReadlineFunctionPointer` to point at your custom input "
"function. See ``Modules/readline.c`` and ``Parser/myreadline.c`` for more"
" hints."
msgstr ""
"C에서 이렇게 하는 가장 쉬운 방법은 :c:func:`PyRun_InteractiveLoop`\\를 호출하고 (아마 별도의 "
"스레드에서), 파이썬 인터프리터가 입력을 처리하도록 하는 것입니다. "
":c:func:`PyOS_ReadlineFunctionPointer` 가 여러분의 사용자 정의 입력 함수를 가리 키도록 설정할 수도"
" 있습니다. 자세한 힌트는 ``Modules/readline.c``\\와 ``Parser/myreadline.c``\\를 "
"참조하십시오."

#: ../../faq/extending.rst:275
msgid "How do I find undefined g++ symbols __builtin_new or __pure_virtual?"
msgstr "정의되지 않은 g++ 기호 __builtin_new나 __pure_virtual을 어떻게 찾을 수 있습니까?"

#: ../../faq/extending.rst:277
msgid ""
"To dynamically load g++ extension modules, you must recompile Python, "
"relink it using g++ (change LINKCC in the Python Modules Makefile), and "
"link your extension module using g++ (e.g., ``g++ -shared -o mymodule.so "
"mymodule.o``)."
msgstr ""
"g++ 확장 모듈을 동적으로 로드하려면, 파이썬을 다시 컴파일하고, g++를 사용하여 다시 링크하고 (파이썬 Modules "
"Makefile에서 LINKCC를 변경하십시오), g++를 사용하여 여러분의 확장 모듈을 링크해야 합니다 (예를 들어, ``g++ "
"-shared -o mymodule.so mymodule.o``)."

#: ../../faq/extending.rst:283
msgid ""
"Can I create an object class with some methods implemented in C and "
"others in Python (e.g. through inheritance)?"
msgstr "일부 메서드는 C로 구현되고 그 밖의 것은 파이썬으로 구현된 (예를 들어 상속을 통해) 객체 클래스를 만들 수 있습니까?"

#: ../../faq/extending.rst:285
msgid ""
"Yes, you can inherit from built-in classes such as :class:`int`, "
":class:`list`, :class:`dict`, etc."
msgstr ""
"그렇습니다, :class:`int`, :class:`list`, :class:`dict` 등과 같은 내장 클래스를 상속할 수 "
"있습니다."

#: ../../faq/extending.rst:288
msgid ""
"The Boost Python Library (BPL, "
"https://www.boost.org/libs/python/doc/index.html) provides a way of doing"
" this from C++ (i.e. you can inherit from an extension class written in "
"C++ using the BPL)."
msgstr ""
"Boost 파이썬 라이브러리(BPL, https://www.boost.org/libs/python/doc/index.html)는 "
"C++에서 이를 수행하는 방법을 제공합니다 (즉, BPL을 사용하여 C++로 작성된 확장 클래스를 상속할 수 있습니다)."

