# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../faq/library.rst:5
msgid "Library and Extension FAQ"
msgstr "라이브러리와 확장 FAQ"

#: ../../faq/library.rst:8
msgid "Contents"
msgstr "목차"

#: ../../faq/library.rst:12
msgid "General Library Questions"
msgstr "일반 라이브러리 관련 질문"

#: ../../faq/library.rst:15
msgid "How do I find a module or application to perform task X?"
msgstr "작업 X를 수행할 모듈이나 응용 프로그램을 어떻게 찾습니까?"

#: ../../faq/library.rst:17
msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the"
" standard library and will be able to skip this step.)"
msgstr ""
"관련 표준 라이브러리 모듈이 있는지 :ref:`라이브러리 레퍼런스 <library-index>`\\를 확인하십시오. (결국에는 표준"
" 라이브러리에 있는 내용을 배우고 이 단계를 건너뛸 수 있게 됩니다.)"

#: ../../faq/library.rst:21
msgid ""
"For third-party packages, search the `Python Package Index "
"<https://pypi.org>`_ or try `Google <https://www.google.com>`_ or another"
" web search engine.  Searching for \"Python\" plus a keyword or two for "
"your topic of interest will usually find something helpful."
msgstr ""
"제삼자 패키지의 경우 `파이썬 패키지 색인 <https://pypi.org>`_\\을 검색하거나 `구글 "
"<https://www.google.com>`_ 또는 다른 웹 검색 엔진을 사용해보십시오. \"Python\"에 관심 있는 주제에 "
"관한 한두 개의 키워드를 더해 검색하면 보통 도움이 될만한 것을 찾게 될 것입니다."

#: ../../faq/library.rst:28
msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "math.py (socket.py, regex.py 등) 소스 파일은 어디에 있습니까?"

#: ../../faq/library.rst:30
msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled "
"language. In this case you may not have the source file or it may be "
"something like :file:`mathmodule.c`, somewhere in a C source directory "
"(not on the Python Path)."
msgstr ""
"모듈의 소스 파일을 찾을 수 없으면 C, C++ 또는 기타 컴파일된 언어로 구현된 내장이나 동적으로 로드된 모듈일 수 있습니다. 이"
" 경우 소스 파일이 없거나 C 소스 디렉터리(파이썬 경로에 없는)의 :file:`mathmodule.c`\\와 같은 파일일 수 "
"있습니다."

#: ../../faq/library.rst:35
msgid "There are (at least) three kinds of modules in Python:"
msgstr "파이썬에는 (적어도) 세 가지 종류의 모듈이 있습니다:"

#: ../../faq/library.rst:37
msgid "modules written in Python (.py);"
msgstr "파이썬으로 작성된 모듈 (.py);"

#: ../../faq/library.rst:38
msgid "modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr "C로 작성되고 동적으로 로드되는 모듈 (.dll, .pyd, .so, .sl 등);"

#: ../../faq/library.rst:39
msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr "C로 작성되고 인터프리터와 링크된 모듈; 이 목록을 얻으려면, 다음을 입력하십시오::"

#: ../../faq/library.rst:42
msgid ""
"import sys\n"
"print(sys.builtin_module_names)"
msgstr ""
"import sys\n"
"print(sys.builtin_module_names)"

#: ../../faq/library.rst:47
msgid "How do I make a Python script executable on Unix?"
msgstr "유닉스에서 파이썬 스크립트를 실행 파일로 만들려면 어떻게 해야 합니까?"

#: ../../faq/library.rst:49
msgid ""
"You need to do two things: the script file's mode must be executable and "
"the first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"두 가지를 해야 합니다: 스크립트 파일의 모드는 실행 가능해야 하고 첫 번째 줄은 ``#!``\\로 시작하고 그 뒤에 파이썬 "
"인터프리터 경로가 있어야 합니다."

#: ../../faq/library.rst:53
msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod"
" 755 scriptfile``."
msgstr ""
"첫 번째는 ``chmod +x scriptfile``\\이나 아마도 ``chmod 755 scriptfile``\\을 실행하여 "
"수행됩니다."

#: ../../faq/library.rst:56
msgid ""
"The second can be done in a number of ways.  The most straightforward way"
" is to write ::"
msgstr "두 번째는 여러 가지 방법으로 수행 할 수 있습니다. 가장 간단한 방법은 다음과 같은 줄을 ::"

#: ../../faq/library.rst:59
msgid "#!/usr/local/bin/python"
msgstr "#!/usr/local/bin/python"

#: ../../faq/library.rst:61
msgid ""
"as the very first line of your file, using the pathname for where the "
"Python interpreter is installed on your platform."
msgstr "파이썬 인터프리터가 플랫폼에 설치된 경로 이름을 사용하여 파일의 첫 번째 줄로 작성하는 것입니다."

#: ../../faq/library.rst:64
msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all "
"Unix variants support the following, assuming the Python interpreter is "
"in a directory on the user's :envvar:`PATH`::"
msgstr ""
"스크립트가 파이썬 인터프리터가 있는 위치와 독립적으로 되도록 하려면, :program:`env` 프로그램을 사용할 수 있습니다. "
"파이썬 인터프리터가 사용자 :envvar:`PATH`\\의 디렉터리에 있다고 가정하면, 거의 모든 유닉스 변형이 다음을 "
"지원합니다::"

#: ../../faq/library.rst:69
msgid "#!/usr/bin/env python"
msgstr "#!/usr/bin/env python"

#: ../../faq/library.rst:71
msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"이것을 CGI 스크립트에 적용하지 *마십시오*. CGI 스크립트의 :envvar:`PATH` 변수는 종종 최소한이라서, 인터프리터의"
" 실제 절대 경로명을 사용해야 합니다."

#: ../../faq/library.rst:75
msgid ""
"Occasionally, a user's environment is so full that the "
":program:`/usr/bin/env` program fails; or there's no env program at all."
"  In that case, you can try the following hack (due to Alex Rezinsky):"
msgstr ""
"때때로, 사용자 환경이 가득 차서 :program:`/usr/bin/env` 프로그램이 실패합니다; 또는 env 프로그램이 아예 "
"없습니다. 이 경우, 다음과 같은 핵을 시도할 수 있습니다 (Alex Rezinsky의 기법입니다):"

#: ../../faq/library.rst:79
#, python-brace-format
msgid ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exec python $0 ${1+\"$@\"}\n"
"\"\"\""
msgstr ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exec python $0 ${1+\"$@\"}\n"
"\"\"\""

#: ../../faq/library.rst:86
msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr "작은 단점은 이것이 스크립트의 __doc__ 문자열을 정의한다는 것입니다. 그러나, 다음을 추가하여 문제를 해결할 수 있습니다 ::"

#: ../../faq/library.rst:89
msgid "__doc__ = \"\"\"...Whatever...\"\"\""
msgstr "__doc__ = \"\"\"...Whatever...\"\"\""

#: ../../faq/library.rst:94
msgid "Is there a curses/termcap package for Python?"
msgstr "파이썬 용 curses/termcap 패키지가 있습니까?"

#: ../../faq/library.rst:98
msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"유닉스 변형의 경우: 표준 파이썬 소스 배포판은 기본적으로 컴파일되지는 않지만, :source:`Modules` 서브 디렉터리에 "
"curses 모듈을 포함합니다. (윈도우 배포판에서는 사용할 수 없습니다 -- 윈도우용 curses 모듈은 없습니다.)"

#: ../../faq/library.rst:103
msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means "
"the module isn't compatible with operating systems that only have BSD "
"curses, but there don't seem to be any currently maintained OSes that "
"fall into this category."
msgstr ""
":mod:`curses` 모듈은 기본 curses 기능뿐만 아니라 색상, 대체 문자 집합 지원, 패드 및 마우스 지원과 같은 "
"ncurses와 SYSV curses의 많은 추가 기능을 지원합니다. 이는 모듈이 BSD curses만 있는 운영 체제와 호환되지 "
"않음을 뜻하지만, 현재 유지 보수되는 OS들은 어느 것도 이 범주에 속하지 않는 것 같습니다."

#: ../../faq/library.rst:111
msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "파이썬에 C의 onexit()와 동등한 것이 있습니까?"

#: ../../faq/library.rst:113
msgid ""
"The :mod:`atexit` module provides a register function that is similar to "
"C's :c:func:`!onexit`."
msgstr ":mod:`atexit` 모듈은 C의 :c:func:`!onexit`\\와 유사한 등록 함수를 제공합니다."

#: ../../faq/library.rst:118
msgid "Why don't my signal handlers work?"
msgstr "시그널 처리기가 작동하지 않는 이유는 무엇입니까?"

#: ../../faq/library.rst:120
msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr "가장 흔한 문제점은 시그널 처리기가 잘못된 인자 목록으로 선언되는 것입니다. 이렇게 호출됩니다 ::"

#: ../../faq/library.rst:123
msgid "handler(signum, frame)"
msgstr "handler(signum, frame)"

#: ../../faq/library.rst:125
msgid "so it should be declared with two parameters::"
msgstr "따라서 두 개의 매개 변수로 선언해야 합니다::"

#: ../../faq/library.rst:127
msgid ""
"def handler(signum, frame):\n"
"    ..."
msgstr ""
"def handler(signum, frame):\n"
"    ..."

#: ../../faq/library.rst:132
msgid "Common tasks"
msgstr "일반적인 작업"

#: ../../faq/library.rst:135
msgid "How do I test a Python program or component?"
msgstr "파이썬 프로그램이나 컴포넌트를 어떻게 테스트합니까?"

#: ../../faq/library.rst:137
msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module "
"finds examples in the docstrings for a module and runs them, comparing "
"the output with the expected output given in the docstring."
msgstr ""
"파이썬에는 두 가지 테스트 프레임워크가 있습니다. :mod:`doctest` 모듈은 모듈의 독스트링에 있는 예제를 찾고 실행한 후,"
" 출력을 독스트링에 제공된 예상 출력과 비교합니다."

#: ../../faq/library.rst:141
msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on "
"Java and Smalltalk testing frameworks."
msgstr ":mod:`unittest` 모듈은 Java와 Smalltalk 테스트 프레임 워크에서 모델링 된 더 멋진 테스트 프레임워크입니다."

#: ../../faq/library.rst:144
msgid ""
"To make testing easier, you should use good modular design in your "
"program. Your program should have almost all functionality encapsulated "
"in either functions or class methods -- and this sometimes has the "
"surprising and delightful effect of making the program run faster "
"(because local variable accesses are faster than global accesses).  "
"Furthermore the program should avoid depending on mutating global "
"variables, since this makes testing much more difficult to do."
msgstr ""
"테스트를 더 쉽게 하려면, 여러분의 프로그램에 좋은 모듈식 디자인을 사용해야 합니다. 프로그램은 거의 모든 기능을 함수나 클래스 "
"메서드로 캡슐화해야 합니다 -- 그리고 이는 때로 프로그램을 더 빠르게 실행하는 놀라운 효과가 있습니다 (지역 변수 액세스가 전역 "
"액세스보다 빠르기 때문에). 또한 프로그램은 전역 변수를 변경하는 것에 의존하지 않아야 합니다, 이렇게 하면 테스트하기가 훨씬 "
"어렵기 때문입니다."

#: ../../faq/library.rst:152
msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr "프로그램의 \"전역 메인 논리\"는 다음과 같은 코드를 ::"

#: ../../faq/library.rst:154
msgid ""
"if __name__ == \"__main__\":\n"
"    main_logic()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    main_logic()"

#: ../../faq/library.rst:157
msgid "at the bottom of the main module of your program."
msgstr "프로그램의 메인 모듈 하단에 넣는 것처럼 간단할 수 있습니다."

#: ../../faq/library.rst:159
msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make "
"coding much more pleasant and fun by writing your test functions in "
"parallel with the \"production code\", since this makes it easy to find "
"bugs and even design flaws earlier."
msgstr ""
"일단 프로그램이 다루기 쉬운 함수와 클래스 동작의 모음으로 구성되면, 이 동작을 검사하는 테스트 함수를 작성해야 합니다. 일련의 "
"테스트를 자동화하는 테스트 스위트는 각 모듈과 연관될 수 있습니다. 이것은 많은 작업처럼 들리지만, 파이썬이 아주 간결하고 유연하기"
" 때문에 놀랍도록 쉽습니다. \"프로덕션 코드\"와 함께 테스트 함수를 작성하여 코딩을 훨씬 더 즐겁고 재미있게 만들 수 있습니다."
" 버그를 쉽게 찾고 결함을 조기에 발견할 수 있기 때문입니다."

#: ../../faq/library.rst:167
msgid ""
"\"Support modules\" that are not intended to be the main module of a "
"program may include a self-test of the module. ::"
msgstr "프로그램의 메인 모듈이 아닌 \"지원 모듈\"에는 모듈의 자체 테스트가 포함될 수 있습니다. ::"

#: ../../faq/library.rst:170
msgid ""
"if __name__ == \"__main__\":\n"
"    self_test()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    self_test()"

#: ../../faq/library.rst:173
msgid ""
"Even programs that interact with complex external interfaces may be "
"tested when the external interfaces are unavailable by using \"fake\" "
"interfaces implemented in Python."
msgstr ""
"복잡한 외부 인터페이스와 상호 작용하는 프로그램조차도 파이썬으로 구현된 \"가짜\" 인터페이스를 사용하여 외부 인터페이스를 사용할 "
"수 없을 때 테스트할 수 있습니다."

#: ../../faq/library.rst:179
msgid "How do I create documentation from doc strings?"
msgstr "독스트링으로 설명서를 어떻게 만듭니까?"

#: ../../faq/library.rst:181
msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your "
"Python source code.  An alternative for creating API documentation purely"
" from docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx"
" <https://www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""
":mod:`pydoc` 모듈은 파이썬 소스 코드의 독스트링에서 HTML을 만들 수 있습니다. 순수하게 독스트링에서 API 설명서를 "
"만드는 대안은 `epydoc <https://epydoc.sourceforge.net/>`_\\입니다. `Sphinx "
"<https://www.sphinx-doc.org>`_\\도 독스트링 내용을 포함할 수 있습니다."

#: ../../faq/library.rst:188
msgid "How do I get a single keypress at a time?"
msgstr "한 번에 하나의 키 입력을 받는 방법은 무엇입니까?"

#: ../../faq/library.rst:190
msgid ""
"For Unix variants there are several solutions.  It's straightforward to "
"do this using curses, but curses is a fairly large module to learn."
msgstr ""
"유닉스 변형에는 몇 가지 해결책이 있습니다. curses를 사용하여 이 작업을 수행하는 것은 간단하지만, curses는 배우기에 "
"상당히 큰 모듈입니다."

#: ../../faq/library.rst:234
msgid "Threads"
msgstr "스레드"

#: ../../faq/library.rst:237
msgid "How do I program using threads?"
msgstr "스레드를 사용하여 어떻게 프로그래밍합니까?"

#: ../../faq/library.rst:239
msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top"
" of the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
":mod:`_thread` 모듈이 아닌 :mod:`threading` 모듈을 사용하십시오. :mod:`threading` 모듈은 "
":mod:`_thread` 모듈이 제공하는 저수준 프리미티브 위에 편리한 추상화를 구축합니다."

#: ../../faq/library.rst:245
msgid "None of my threads seem to run: why?"
msgstr "제 스레드가 아무것도 실행되지 않는 것 같습니다: 왜 그런가요?"

#: ../../faq/library.rst:247
msgid ""
"As soon as the main thread exits, all threads are killed.  Your main "
"thread is running too quickly, giving the threads no time to do any work."
msgstr "메인 스레드가 종료되자마자, 모든 스레드가 죽습니다. 메인 스레드가 너무 빨리 실행되어, 스레드가 작업을 수행할 시간이 없습니다."

#: ../../faq/library.rst:250
msgid ""
"A simple fix is to add a sleep to the end of the program that's long "
"enough for all the threads to finish::"
msgstr "간단한 수정은 프로그램 끝에 모든 스레드가 완료될 만큼 충분히 긴 휴면을 추가하는 것입니다::"

#: ../../faq/library.rst:253
msgid ""
"import threading, time\n"
"\n"
"def thread_task(name, n):\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)  # <---------------------------!"
msgstr ""
"import threading, time\n"
"\n"
"def thread_task(name, n):\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)  # <---------------------------!"

#: ../../faq/library.rst:265
msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear"
" to run sequentially, one at a time!  The reason is that the OS thread "
"scheduler doesn't start a new thread until the previous thread is "
"blocked."
msgstr ""
"그러나 이제 (많은 플랫폼에서) 스레드는 병렬로 실행되지 않고, 한 번에 하나씩 순차적으로 실행되는 것처럼 보입니다! 그 이유는 "
"OS 스레드 스케줄러가 이전 스레드가 블록 될 때까지 새 스레드를 시작하지 않기 때문입니다."

#: ../../faq/library.rst:269
msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr "간단한 수정은 실행 함수의 시작 부분에 작은 휴면을 추가하는 것입니다::"

#: ../../faq/library.rst:271
msgid ""
"def thread_task(name, n):\n"
"    time.sleep(0.001)  # <--------------------!\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)"
msgstr ""
"def thread_task(name, n):\n"
"    time.sleep(0.001)  # <--------------------!\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)"

#: ../../faq/library.rst:282
msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, "
"it's better to use some kind of semaphore mechanism.  One idea is to use "
"the :mod:`queue` module to create a queue object, let each thread append "
"a token to the queue when it finishes, and let the main thread read as "
"many tokens from the queue as there are threads."
msgstr ""
":func:`time.sleep`\\을 위한 좋은 지연 값을 추측하는 대신, 일종의 세마포어 메커니즘을 사용하는 것이 좋습니다. 한"
" 가지 아이디어는 :mod:`queue` 모듈을 사용하여 큐 객체를 만들고, 각 스레드가 완료될 때 큐에 토큰을 추가하게 하고, "
"메인 스레드가 스레드 수 만큼의 토큰을 읽도록 하는 것입니다."

#: ../../faq/library.rst:290
msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "여러 작업자 스레드 간에 작업을 어떻게 배달합니까?"

#: ../../faq/library.rst:292
msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, "
"especially the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"가장 쉬운 방법은 :mod:`concurrent.futures` 모듈, 특히 "
":mod:`~concurrent.futures.ThreadPoolExecutor` 클래스를 사용하는 것입니다."

#: ../../faq/library.rst:295
msgid ""
"Or, if you want fine control over the dispatching algorithm, you can "
"write your own logic manually.  Use the :mod:`queue` module to create a "
"queue containing a list of jobs.  The :class:`~queue.Queue` class "
"maintains a list of objects and has a ``.put(obj)`` method that adds "
"items to the queue and a ``.get()`` method to return them.  The class "
"will take care of the locking necessary to ensure that each job is handed"
" out exactly once."
msgstr ""
"또는, 디스패치 알고리즘을 세밀하게 제어하려면, 직접 논리를 작성할 수 있습니다. :mod:`queue` 모듈을 사용하여 작업 "
"목록을 포함하는 큐를 만드십시오. :class:`~queue.Queue` 클래스는 객체 목록을 유지하고 큐에 항목을 추가하는 "
"``.put(obj)`` 메서드와 이를 반환하는 ``.get()`` 메서드를 갖습니다. 클래스는 각 작업이 정확히 한 번만 "
"전달되도록 하는 데 필요한 록을 관리합니다."

#: ../../faq/library.rst:302
msgid "Here's a trivial example::"
msgstr "간단한 예를 들면 다음과 같습니다::"

#: ../../faq/library.rst:304
#, python-format
msgid ""
"import threading, queue, time\n"
"\n"
"# The worker thread gets jobs off the queue.  When the queue is empty, it"
"\n"
"# assumes there will be no more work and exits.\n"
"# (Realistically workers will run until terminated.)\n"
"def worker():\n"
"    print('Running worker')\n"
"    time.sleep(0.1)\n"
"    while True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('queue empty')\n"
"            break\n"
"        else:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('running with argument', arg)\n"
"            time.sleep(0.5)\n"
"\n"
"# Create queue\n"
"q = queue.Queue()\n"
"\n"
"# Start a pool of 5 workers\n"
"for i in range(5):\n"
"    t = threading.Thread(target=worker, name='worker %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Begin adding work to the queue\n"
"for i in range(50):\n"
"    q.put(i)\n"
"\n"
"# Give threads time to run\n"
"print('Main thread sleeping')\n"
"time.sleep(5)"
msgstr ""
"import threading, queue, time\n"
"\n"
"# 작업자 스레드는 큐에서 작업을 가져옵니다.\n"
"# 큐가 비어 있으면, 더는 작업이 없다고 가정하고 종료합니다.\n"
"# (실제 상황에서는 작업자가 종료할 때까지 실행합니다.)\n"
"def worker():\n"
"    print('Running worker')\n"
"    time.sleep(0.1)\n"
"    while True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('queue empty')\n"
"            break\n"
"        else:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('running with argument', arg)\n"
"            time.sleep(0.5)\n"
"\n"
"# 큐를 만듭니다\n"
"q = queue.Queue()\n"
"\n"
"# 5 작업자의 풀을 시작합니다\n"
"for i in range(5):\n"
"    t = threading.Thread(target=worker, name='worker %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# 큐에 작업을 추가하기 시작합니다\n"
"for i in range(50):\n"
"    q.put(i)\n"
"\n"
"# 스레드가 실행할 시간을 줍니다\n"
"print('Main thread sleeping')\n"
"time.sleep(5)"

#: ../../faq/library.rst:340
msgid "When run, this will produce the following output:"
msgstr "실행하면 다음과 같은 출력이 생성됩니다:"

#: ../../faq/library.rst:342
msgid ""
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Main thread sleeping\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument "
"0\n"
"Worker <Thread(worker 2, started 130283824404752)> running with argument "
"1\n"
"Worker <Thread(worker 3, started 130283816012048)> running with argument "
"2\n"
"Worker <Thread(worker 4, started 130283807619344)> running with argument "
"3\n"
"Worker <Thread(worker 5, started 130283799226640)> running with argument "
"4\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument "
"5\n"
"..."
msgstr ""
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Main thread sleeping\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument "
"0\n"
"Worker <Thread(worker 2, started 130283824404752)> running with argument "
"1\n"
"Worker <Thread(worker 3, started 130283816012048)> running with argument "
"2\n"
"Worker <Thread(worker 4, started 130283807619344)> running with argument "
"3\n"
"Worker <Thread(worker 5, started 130283799226640)> running with argument "
"4\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument "
"5\n"
"..."

#: ../../faq/library.rst:358
msgid ""
"Consult the module's documentation for more details; the "
":class:`~queue.Queue` class provides a featureful interface."
msgstr "자세한 내용은 모듈 설명서를 참조하십시오. :class:`~queue.Queue` 클래스는 기능이 풍부한 인터페이스를 제공합니다."

#: ../../faq/library.rst:363
msgid "What kinds of global value mutation are thread-safe?"
msgstr "어떤 종류의 전역 값 변경이 스레드 안전합니까?"

#: ../../faq/library.rst:365
msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that"
" only one thread runs in the Python VM at a time.  In general, Python "
"offers to switch among threads only between bytecode instructions; how "
"frequently it switches can be set via :func:`sys.setswitchinterval`.  "
"Each bytecode instruction and therefore all the C implementation code "
"reached from each instruction is therefore atomic from the point of view "
"of a Python program."
msgstr ""
"내부적으로 :term:`전역 인터프리터 록 <global interpreter lock>`\\(GIL)이 사용되어 한 번에 하나의 "
"스레드 만 파이썬 VM에서 실행되도록 합니다. 일반적으로, 파이썬은 바이트 코드 명령어들 사이에서만 스레드 간 전환을 제공합니다; "
":func:`sys.setswitchinterval`\\을 통해 얼마나 자주 전환할지를 설정할 수 있습니다. 따라서 각 바이트 코드"
" 명령어와 각 명령어에서 도달하는 모든 C 구현 코드는 파이썬 프로그램의 관점에서 원자 적입니다."

#: ../../faq/library.rst:372
msgid ""
"In theory, this means an exact accounting requires an exact understanding"
" of the PVM bytecode implementation.  In practice, it means that "
"operations on shared variables of built-in data types (ints, lists, "
"dicts, etc) that \"look atomic\" really are."
msgstr ""
"이론적으로, 이것은 정확하게 따지기 위해서는 PVM 바이트 코드 구현에 대한 정확한 이해가 필요하다는 것을 의미합니다. "
"경험적으로는, 이것은 \"원자 적으로 보이는\" 내장 데이터형(정수, 리스트, 딕셔너리 등)의 공유 변수에 대한 조작이 실제로 원자"
" 적임을 의미합니다."

#: ../../faq/library.rst:377
msgid ""
"For example, the following operations are all atomic (L, L1, L2 are "
"lists, D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"예를 들어, 다음 연산은 모두 원자 적입니다 (L, L1, L2는 리스트, D, D1, D2는 딕셔너리, x, y는 객체, i, "
"j는 정수입니다)::"

#: ../../faq/library.rst:380
msgid ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.field = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.keys()"
msgstr ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.field = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.keys()"

#: ../../faq/library.rst:392
msgid "These aren't::"
msgstr "이것들은 아닙니다::"

#: ../../faq/library.rst:394
msgid ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"
msgstr ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"

#: ../../faq/library.rst:399
msgid ""
"Operations that replace other objects may invoke those other objects' "
":meth:`~object.__del__` method when their reference count reaches zero, "
"and that can affect things.  This is especially true for the mass updates"
" to dictionaries and lists.  When in doubt, use a mutex!"
msgstr ""
"다른 객체를 대체하는 연산은 객체의 참조 횟수가 0에 도달할 때 그들의 :meth:`~object.__del__` 메서드를 호출할 "
"수 있으며, 이는 영향을 줄 수 있습니다. 이것은 딕셔너리와 리스트의 대량 갱신 때 특히 그렇습니다. 의심스러우면, 뮤텍스를 "
"사용하십시오!"

#: ../../faq/library.rst:406
msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "전역 인터프리터 록을 제거할 수 없습니까?"

#: ../../faq/library.rst:408
msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to"
" Python's deployment on high-end multiprocessor server machines, because "
"a multi-threaded Python program effectively only uses one CPU, due to the"
" insistence that (almost) all Python code can only run while the GIL is "
"held."
msgstr ""
":term:`전역 인터프리터 록 <global interpreter lock>`\\(GIL)은 종종 하이 엔드 다중 프로세서 서버 "
"기계에 파이썬을 배치하는 데 방해가 된다고 여겨집니다, (거의) 모든 파이썬 코드가 GIL을 잡고 있는 동안에만 실행하려고 해서, "
"다중 스레드 파이썬 프로그램이 사실상 오직 하나의 CPU만 사용하기 때문입니다."

#: ../../faq/library.rst:413
msgid ""
"With the approval of :pep:`703` work is now underway to remove the GIL "
"from the CPython implementation of Python.  Initially it will be "
"implemented as an optional compiler flag when building the interpreter, "
"and so separate builds will be available with and without the GIL.  Long-"
"term, the hope is to settle on a single build, once the performance "
"implications of removing the GIL are fully understood.  Python 3.13 is "
"likely to be the first release containing this work, although it may not "
"be completely functional in this release."
msgstr ""

#: ../../faq/library.rst:422
#, python-format
msgid ""
"The current work to remove the GIL is based on a `fork of Python 3.9 with"
" the GIL removed <https://github.com/colesbury/nogil>`_ by Sam Gross. "
"Prior to that, in the days of Python 1.5, Greg Stein actually implemented"
" a comprehensive patch set (the \"free threading\" patches) that removed "
"the GIL and replaced it with fine-grained locking.  Adam Olsen did a "
"similar experiment in his `python-safethread "
"<https://code.google.com/archive/p/python-safethread>`_ project.  "
"Unfortunately, both of these earlier experiments exhibited a sharp drop "
"in single-thread performance (at least 30% slower), due to the amount of "
"fine-grained locking necessary to compensate for the removal of the GIL."
"  The Python 3.9 fork is the first attempt at removing the GIL with an "
"acceptable performance impact."
msgstr ""
"현재 GIL을 제거하는 작업은 Sam Gross의 `GIL이 제거된 파이썬 3.9 포크 "
"<https://github.ckom/colesbury/nogil>`_\\를 기반으로 합니다. 그 이전에는, 파이썬 1.5 시절에,"
" Greg Stein은 실제로 GIL을 제거하고 세밀한 록으로 대체한 포괄적인 패치 모음(\"자유로운 스레딩\" 패치)을 "
"구현했습니다. Adam Olsen은 그의 `python-safethread "
"<https://code.google.com/archive/p/python-safethread>`_ 프로젝트에서 유사한 실험을 "
"수행했습니다. 불행히도, 이 두 초기 실험 모두 GIL 제거를 보상하는 데 필요한 세밀한 록의 양으로 인해 단일 스레드 성능이 "
"급격히 떨어졌습니다 (적어도 30% 더 느립니다). 파이썬 3.9 포크는 성능에 영향을 미치지 않으면서 GIL을 제거하려는 첫 번째"
" 시도입니다."

#: ../../faq/library.rst:437
msgid ""
"The presence of the GIL in current Python releases doesn't mean that you "
"can't make good use of Python on multi-CPU machines! You just have to be "
"creative with dividing the work up between multiple *processes* rather "
"than multiple *threads*.  The "
":class:`~concurrent.futures.ProcessPoolExecutor` class in the new "
":mod:`concurrent.futures` module provides an easy way of doing so; the "
":mod:`multiprocessing` module provides a lower-level API in case you want"
" more control over dispatching of tasks."
msgstr ""
"현재 파이썬 배포판에 GIL이 있다는 것이 다중 CPU 기계에서 파이썬을 제대로 사용할 수는 없다는 뜻은 아닙니다! 여러 *스레드*"
" 대신에 여러 *프로세스*\\로 작업을 분할하는 창의력을 발휘해야 합니다. 새로운 :mod:`concurrent.futures` "
"모듈의 :class:`~concurrent.futures.ProcessPoolExecutor` 클래스는 그렇게 하는 쉬운 방법을 "
"제공합니다; :mod:`multiprocessing` 모듈은 작업 디스패치에 대한 제어를 더 원할 때를 위한 저수준 API를 "
"제공합니다."

#: ../../faq/library.rst:446
msgid ""
"Judicious use of C extensions will also help; if you use a C extension to"
" perform a time-consuming task, the extension can release the GIL while "
"the thread of execution is in the C code and allow other threads to get "
"some work done.  Some standard library modules such as :mod:`zlib` and "
":mod:`hashlib` already do this."
msgstr ""
"C 확장을 신중하게 사용하는 것도 도움이 됩니다; C 확장을 사용하여 시간이 오래 걸리는 작업을 수행하면, 확장은 실행 스레드가 C"
" 코드에 있는 동안 GIL을 해제하고 다른 스레드가 어떤 작업을 수행할 수 있도록 할 수 있습니다. :mod:`zlib`\\와 "
":mod:`hashlib`\\와 같은 일부 표준 라이브러리 모듈은 이미 이렇게 합니다."

#: ../../faq/library.rst:452
msgid ""
"An alternative approach to reducing the impact of the GIL is to make the "
"GIL a per-interpreter-state lock rather than truly global. This was "
":ref:`first implemented in Python 3.12 <whatsnew312-pep684>` and is "
"available in the C API. A Python interface to it is expected in Python "
"3.13. The main limitation to it at the moment is likely to be 3rd party "
"extension modules, since these must be written with multiple interpreters"
" in mind in order to be usable, so many older extension modules will not "
"be usable."
msgstr ""

#: ../../faq/library.rst:462
msgid "Input and Output"
msgstr "입력과 출력"

#: ../../faq/library.rst:465
msgid "How do I delete a file? (And other file questions...)"
msgstr "파일을 어떻게 삭제합니까? (그리고 다른 파일 질문들...)"

#: ../../faq/library.rst:467
msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for "
"documentation, see the :mod:`os` module.  The two functions are "
"identical; :func:`~os.unlink` is simply the name of the Unix system call "
"for this function."
msgstr ""
"``os.remove(filename)``\\이나 ``os.unlink(filename)``\\을 사용하십시오; 설명서는 "
":mod:`os` 모듈을 참조하십시오. 두 함수는 동일합니다; :func:`~os.unlink`\\는 단순히 이 함수에 대한 유닉스"
" 시스템 호출의 이름입니다."

#: ../../faq/library.rst:471
msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to "
"create one. ``os.makedirs(path)`` will create any intermediate "
"directories in ``path`` that don't exist. ``os.removedirs(path)`` will "
"remove intermediate directories as long as they're empty; if you want to "
"delete an entire directory tree and its contents, use "
":func:`shutil.rmtree`."
msgstr ""
"디렉터리를 제거하려면, :func:`os.rmdir`\\을 사용하십시오; 만들려면 :func:`os.mkdir`\\을 사용하십시오."
" ``os.makedirs(path)``\\는 존재하지 않는 ``path``\\의 중간 디렉터리를 만듭니다. "
"``os.removedirs(path)``\\는 비어있는 한, 중간 디렉터리를 제거합니다; 전체 디렉터리 트리와 그 내용을 "
"삭제하려면 :func:`shutil.rmtree`\\를 사용하십시오."

#: ../../faq/library.rst:477
msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr "파일 이름을 바꾸려면 ``os.rename(old_path, new_path)``\\를 사용하십시오."

#: ../../faq/library.rst:479
msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and "
"use ``f.truncate(offset)``; offset defaults to the current seek position."
"  There's also ``os.ftruncate(fd, offset)`` for files opened with "
":func:`os.open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"파일을 자르려면, ``f = open(filename, \"rb+\")``\\를 사용하여 열고 "
"``f.truncate(offset)``\\을 사용하십시오; offset의 기본값은 현재 탐색(seek) 위치입니다. "
":func:`os.open`\\으로 열린 파일의 경우 ``os.ftruncate(fd, offset)``\\도 있습니다. 여기서 "
"*fd*\\는 파일 기술자(작은 정수)입니다."

#: ../../faq/library.rst:484
msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and "
":func:`~shutil.rmtree`."
msgstr ""
":mod:`shutil` 모듈에도 :func:`~shutil.copyfile`, :func:`~shutil.copytree` 및 "
":func:`~shutil.rmtree`\\를 포함한 파일에서 작동하는 많은 함수가 포함되어 있습니다."

#: ../../faq/library.rst:490
msgid "How do I copy a file?"
msgstr "파일을 어떻게 복사합니까?"

#: ../../faq/library.rst:492
msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. "
"Note that on Windows NTFS volumes, it does not copy `alternate data "
"streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS"
" HFS+ volumes, though both are now rarely used. It also doesn't copy file"
" permissions and metadata, though using :func:`shutil.copy2` instead will"
" preserve most (though not all) of it."
msgstr ""

#: ../../faq/library.rst:503
msgid "How do I read (or write) binary data?"
msgstr "바이너리 데이터를 읽는 (또는 쓰는) 방법은 무엇입니까?"

#: ../../faq/library.rst:505
msgid ""
"To read or write complex binary data formats, it's best to use the "
":mod:`struct` module.  It allows you to take a string containing binary "
"data (usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"복잡한 바이너리 데이터 형식을 읽거나 쓰려면, :mod:`struct` 모듈을 사용하는 것이 가장 좋습니다. 바이너리 데이터(보통 "
"숫자)를 포함하는 문자열을 취해서 파이썬 객체로 변환할 수 있도록 합니다; 그리고 그 반대도 가능합니다."

#: ../../faq/library.rst:509
msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr "예를 들어, 다음 코드는 파일에서 빅 엔디안 형식의 두 개의 2-바이트 정수와 하나의 4-바이트 정수를 읽습니다::"

#: ../../faq/library.rst:512
msgid ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"
msgstr ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"

#: ../../faq/library.rst:518
msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads"
" one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"포맷 문자열의 '>'는 빅 엔디안 데이터를 강제합니다; 문자 'h'는 하나의 \"짧은(short) 정수\"(2바이트)를 읽고, "
"'l'은 문자열에서 하나의 \"긴(long) 정수\"(4바이트)를 읽습니다."

#: ../../faq/library.rst:522
msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or "
"floats), you can also use the :mod:`array` module."
msgstr "더욱 규칙적인 데이터(예를 들어 int나 float의 동종 리스트)의 경우, :mod:`array` 모듈을 사용할 수도 있습니다."

#: ../../faq/library.rst:527
msgid ""
"To read and write binary data, it is mandatory to open the file in binary"
" mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and "
"``f.read()`` will return :class:`str` objects rather than :class:`bytes` "
"objects."
msgstr ""
"바이너리 데이터를 읽고 쓰려면, 바이너리 모드로 파일을 열어야 합니다 (여기서는, ``\"rb\"``\\를 "
":func:`open`\\으로 전달합니다). 대신 ``\"r\"``\\(기본값)을 사용하면, 파일이 텍스트 모드로 열리고 "
"``f.read()``\\는 :class:`bytes` 객체 대신 :class:`str` 객체를 반환합니다."

#: ../../faq/library.rst:535
msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr "os.popen()으로 만든 파이프에서 os.read()를 사용할 수 없는 것처럼 보입니다; 왜입니까?"

#: ../../faq/library.rst:537
msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a "
"high-level file object, the same type returned by the built-in "
":func:`open` function. Thus, to read *n* bytes from a pipe *p* created "
"with :func:`os.popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read`\\는 열린 파일을 나타내는 작은 정수인 파일 기술자를 취하는 저수준 함수입니다. "
":func:`os.popen`\\은 내장 :func:`open` 함수에서 반환하는 것과 같은 형의 고수준 파일 객체를 만듭니다. "
"따라서, :func:`os.popen`\\으로 만들어진 파이프 *p*\\에서 *n* 바이트를 읽으려면, "
"``p.read(n)``\\을 사용해야 합니다."

#: ../../faq/library.rst:623
msgid "How do I access the serial (RS232) port?"
msgstr "직렬 (RS232) 포트에 어떻게 액세스합니까?"

#: ../../faq/library.rst:625
msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr "Win32, OSX, Linux, BSD, Jython, IronPython의 경우:"

#: ../../faq/library.rst:627
msgid ":pypi:`pyserial`"
msgstr ":pypi:`pyserial`"

#: ../../faq/library.rst:629
msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "유닉스의 경우, Mitch Chapman의 유즈넷 게시물을 참조하십시오:"

#: ../../faq/library.rst:631
msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

#: ../../faq/library.rst:635
msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr "왜 sys.stdout(stdin, stderr)을 닫아도 닫히지 않습니까?"

#: ../../faq/library.rst:637
msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr "파이썬 :term:`파일 객체 <file object>`\\는 저수준 C 파일 기술자의 고수준 추상화 계층입니다."

#: ../../faq/library.rst:640
msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from"
" Python's point of view, and also arranges to close the underlying C file"
" descriptor.  This also happens automatically in ``f``'s destructor, when"
" ``f`` becomes garbage."
msgstr ""
"내장 :func:`open` 함수를 통해 파이썬에서 만드는 대부분 파일 객체의 경우, ``f.close()``\\는 파이썬 파일 "
"객체를 파이썬의 관점에서 닫은 것으로 표시하고 하부 C 파일 기술자를 닫도록 합니다. 이것은 ``f``\\가 가비지가 될 때 "
"``f``\\의 파괴자에서 자동으로 일어나기도 합니다."

#: ../../faq/library.rst:646
msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of "
"the special status also given to them by C.  Running "
"``sys.stdout.close()`` marks the Python-level file object as being "
"closed, but does *not* close the associated C file descriptor."
msgstr ""
"그러나 stdin, stdout 및 stderr은 파이썬에서 특별하게 처리되는데, C 역시 이들에게 특수한 상태를 부여하기 "
"때문입니다. ``sys.stdout.close()``\\를 실행하면 파이썬 수준 파일 객체가 닫힌 것으로 표시되지만, 연관된 C "
"파일 기술자를 닫지 *않습니다*."

#: ../../faq/library.rst:651
msgid ""
"To close the underlying C file descriptor for one of these three, you "
"should first be sure that's what you really want to do (e.g., you may "
"confuse extension modules trying to do I/O).  If it is, use "
":func:`os.close`::"
msgstr ""
"이 세 가지 중 하나에 대한 하부 C 파일 기술자를 닫으려면, 먼저 이것이 정말로 여러분이 하고 싶은 것인지 확인해야 합니다 (예를"
" 들어, I/O를 수행하려는 확장 모듈이 혼동할 수 있습니다). 그렇다면, :func:`os.close`\\를 사용하십시오::"

#: ../../faq/library.rst:655
msgid ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"
msgstr ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"

#: ../../faq/library.rst:659
msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "또는 숫자 상수 0, 1 및 2를 각각 사용할 수 있습니다."

#: ../../faq/library.rst:663
msgid "Network/Internet Programming"
msgstr "네트워크/인터넷 프로그래밍"

#: ../../faq/library.rst:666
msgid "What WWW tools are there for Python?"
msgstr "파이썬에는 어떤 WWW 도구가 있습니까?"

#: ../../faq/library.rst:668
msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library"
" Reference Manual.  Python has many modules that will help you build "
"server-side and client-side web systems."
msgstr ""
"라이브러리 레퍼런스 매뉴얼의 :ref:`internet`\\과 :ref:`netdata` 장을 참조하십시오. 파이썬에는 서버 측과 "
"클라이언트 측 웹 시스템을 구축하는 데 도움이 되는 많은 모듈이 있습니다."

#: ../../faq/library.rst:674
msgid ""
"A summary of available frameworks is maintained by Paul Boddie at "
"https://wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"사용 가능한 프레임워크 요약은 Paul Boddie가 "
"https://wiki.python.org/moin/WebProgramming\\ 에서 유지 관리합니다."

#: ../../faq/library.rst:679
msgid "What module should I use to help with generating HTML?"
msgstr "HTML 생성을 위해 어떤 모듈을 사용해야 합니까?"

#: ../../faq/library.rst:683
msgid ""
"You can find a collection of useful links on the `Web Programming wiki "
"page <https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"`Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_\\에서 유용한 링크 모음을 찾을 수 있습니다."

#: ../../faq/library.rst:688
msgid "How do I send mail from a Python script?"
msgstr "파이썬 스크립트에서 메일을 보내려면 어떻게 해야 합니까?"

#: ../../faq/library.rst:690
msgid "Use the standard library module :mod:`smtplib`."
msgstr "표준 라이브러리 모듈 :mod:`smtplib`\\를 사용하십시오."

#: ../../faq/library.rst:692
msgid ""
"Here's a very simple interactive mail sender that uses it.  This method "
"will work on any host that supports an SMTP listener. ::"
msgstr "다음은 이를 사용하는 매우 간단한 대화식 메일 발신기입니다. 이 방법은 SMTP 리스너를 지원하는 모든 호스트에서 작동합니다. ::"

#: ../../faq/library.rst:695
msgid ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# The actual mail send\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"
msgstr ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# 실제 우편 전송\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"

#: ../../faq/library.rst:712
msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail "
"program varies between systems; sometimes it is ``/usr/lib/sendmail``, "
"sometimes ``/usr/sbin/sendmail``.  The sendmail manual page will help you"
" out.  Here's some sample code::"
msgstr ""
"유닉스 전용 대안은 sendmail을 사용합니다. sendmail 프로그램의 위치는 시스템마다 다릅니다; 때로는 "
"``/usr/lib/sendmail``, 때로는 ``/usr/sbin/sendmail``. sendmail 매뉴얼 페이지가 도움이 "
"될 것입니다. 샘플 코드는 다음과 같습니다::"

#: ../../faq/library.rst:717
#, python-format
msgid ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # sendmail location\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: test\\n\")\n"
"p.write(\"\\n\")  # blank line separating headers from body\n"
"p.write(\"Some text\\n\")\n"
"p.write(\"some more text\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Sendmail exit status\", sts)"
msgstr ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # sendmail location\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: test\\n\")\n"
"p.write(\"\\n\")  # 헤더와 본문을 구분하는 빈 줄\n"
"p.write(\"Some text\\n\")\n"
"p.write(\"some more text\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Sendmail exit status\", sts)"

#: ../../faq/library.rst:732
msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "소켓의 connect() 메서드에서 블로킹을 피하려면 어떻게 해야 합니까?"

#: ../../faq/library.rst:734
msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O "
"on sockets."
msgstr ":mod:`select` 모듈이 소켓의 비동기 I/O를 지원하는 데 흔히 사용됩니다."

#: ../../faq/library.rst:737
msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`~socket.socket.connect`, you "
"will either connect immediately (unlikely) or get an exception that "
"contains the error number as ``.errno``. ``errno.EINPROGRESS`` indicates "
"that the connection is in progress, but hasn't finished yet.  Different "
"OSes will return different values, so you're going to have to check "
"what's returned on your system."
msgstr ""
"TCP 연결이 블록 되지 않도록 하기 위해, 소켓을 비 블로킹 모드로 설정할 수 있습니다. 그런 다음 "
":meth:`~socket.socket.connect`\\를 수행하면, 즉시 연결되거나 (그다지 가능성이 없습니다) 에러 번호를 "
"``.errno``\\에 포함하는 예외가 발생합니다. ``errno.EINPROGRESS``\\는 연결이 진행 중이지만, 아직 "
"완료되지 않았음을 나타냅니다. OS마다 다른 값을 반환해서, 여러분의 시스템에서 무엇이 반환되는지 확인해야 합니다."

#: ../../faq/library.rst:745
msgid ""
"You can use the :meth:`~socket.socket.connect_ex` method to avoid "
"creating an exception. It will just return the errno value. To poll, you "
"can call :meth:`~socket.socket.connect_ex` again later -- ``0`` or "
"``errno.EISCONN`` indicate that you're connected -- or you can pass this "
"socket to :meth:`select.select` to check if it's writable."
msgstr ""
"예외를 피하려면 :meth:`~socket.socket.connect_ex` 메서드를 사용할 수 있습니다. errno 값만 "
"반환합니다. 폴링하려면, 나중에 :meth:`~socket.socket.connect_ex`\\를 다시 호출할 수 있습니다 -- "
"``0``\\이나 ``errno.EISCONN``\\은 연결되었음을 나타냅니다 -- 또는 이 소켓을 "
":meth:`select.select`\\로 전달하여 쓸 수 있는지 확인할 수 있습니다."

#: ../../faq/library.rst:753
msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-"
"blocking network code. The third-party `Twisted <https://twisted.org/>`_ "
"library is a popular and feature-rich alternative."
msgstr ""
":mod:`asyncio` 모듈은 비 블로킹 네트워크 코드를 작성하는 데 사용할 수 있는 범용 단일 스레드 및 동시성 비동기 "
"라이브러리를 제공합니다. 제삼자 `Twisted <https://twisted.org/>`_ 라이브러리는 널리 사용되는 기능이 "
"풍부한 대안입니다."

#: ../../faq/library.rst:761
msgid "Databases"
msgstr "데이터베이스"

#: ../../faq/library.rst:764
msgid "Are there any interfaces to database packages in Python?"
msgstr "파이썬에 데이터베이스 패키지에 대한 인터페이스가 있습니까?"

#: ../../faq/library.rst:766
msgid "Yes."
msgstr "예."

#: ../../faq/library.rst:768
msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and "
":mod:`GDBM <dbm.gnu>` are also included with standard Python.  There is "
"also the :mod:`sqlite3` module, which provides a lightweight disk-based "
"relational database."
msgstr ""
":mod:`DBM <dbm.ndbm>`\\과 :mod:`GDBM <dbm.gnu>`\\같은 디스크 기반 해시에 대한 인터페이스도 "
"표준 파이썬에 포함되어 있습니다. 경량 디스크 기반 관계형 데이터베이스를 제공하는 :mod:`sqlite3` 모듈도 있습니다."

#: ../../faq/library.rst:773
msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page "
"<https://wiki.python.org/moin/DatabaseProgramming>`_ for details."
msgstr ""
"대부분 관계형 데이터베이스에 대한 지원이 제공됩니다. 자세한 내용은 `DatabaseProgramming wiki page "
"<https://wiki.python.org/moin/DatabaseProgramming>`_\\를 참조하십시오."

#: ../../faq/library.rst:779
msgid "How do you implement persistent objects in Python?"
msgstr "파이썬에서 영속 객체를 어떻게 구현합니까?"

#: ../../faq/library.rst:781
msgid ""
"The :mod:`pickle` library module solves this in a very general way "
"(though you still can't store things like open files, sockets or "
"windows), and the :mod:`shelve` library module uses pickle and (g)dbm to "
"create persistent mappings containing arbitrary Python objects."
msgstr ""
":mod:`pickle` 라이브러리 모듈은 이것을 매우 일반적인 방식으로 해결하고 (여전히 열린 파일, 소켓 또는 창과 같은 것을 "
"저장할 수는 없지만), :mod:`shelve` 라이브러리 모듈은 pickle과 (g)dbm을 사용하여 임의의 파이썬 객체를 "
"포함하는 영속적(persistent) 매핑을 만듭니다."

#: ../../faq/library.rst:788
msgid "Mathematics and Numerics"
msgstr "수학과 숫자"

#: ../../faq/library.rst:791
msgid "How do I generate random numbers in Python?"
msgstr "파이썬에서 난수를 어떻게 생성합니까?"

#: ../../faq/library.rst:793
msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr "표준 모듈 :mod:`random`\\은 난수 생성기를 구현합니다. 사용법은 간단합니다::"

#: ../../faq/library.rst:796
msgid ""
"import random\n"
"random.random()"
msgstr ""
"import random\n"
"random.random()"

#: ../../faq/library.rst:799
msgid "This returns a random floating-point number in the range [0, 1)."
msgstr "이것은 [0, 1) 범위의 무작위 부동 소수점 숫자를 반환합니다."

#: ../../faq/library.rst:801
msgid "There are also many other specialized generators in this module, such as:"
msgstr "이 모듈에는 다른 많은 특수 생성기가 있습니다, 가령:"

#: ../../faq/library.rst:803
msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)``\\는 [a, b) 범위의 정수를 선택합니다."

#: ../../faq/library.rst:804
msgid "``uniform(a, b)`` chooses a floating-point number in the range [a, b)."
msgstr "``uniform(a, b)``\\는 [a, b) 범위의 부동 소수점 숫자를 선택합니다."

#: ../../faq/library.rst:805
msgid "``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr "``normalvariate(mean, sdev)``\\는 정규 (가우시안) 분포를 샘플링합니다."

#: ../../faq/library.rst:807
msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr "일부 고수준 함수는 시퀀스에서 직접 작동합니다, 가령:"

#: ../../faq/library.rst:809
msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr "``choice(S)``\\는 주어진 시퀀스에서 무작위 요소 하나를 선택합니다."

#: ../../faq/library.rst:810
msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr "``shuffle(L)``\\은 리스트를 제자리에서 섞습니다, 즉 무작위로 순서를 바꿉니다."

#: ../../faq/library.rst:812
msgid ""
"There's also a ``Random`` class you can instantiate to create independent"
" multiple random number generators."
msgstr "독립적인 여러 개의 난수 생성기를 만들기 위해 인스턴스 화 할 수 있는 ``Random`` 클래스도 있습니다."

#~ msgid ""
#~ "For Windows: use `the consolelib module"
#~ " <http://effbot.org/zone/console-index.htm>`_."
#~ msgstr ""
#~ "윈도우의 경우: `consolelib 모듈 "
#~ "<http://effbot.org/zone/console-index.htm>`_\\을 사용하십시오."

#~ msgid ""
#~ "Aahz has a set of slides from "
#~ "his threading tutorial that are helpful;"
#~ " see http://www.pythoncraft.com/OSCON2001/."
#~ msgstr ""
#~ "Aahz가 자신의 threading 자습서에서 유용한 슬라이드 "
#~ "모음을 제공합니다; http://www.pythoncraft.com/OSCON2001/ 을"
#~ " 참조하십시오."

#~ msgid ""
#~ "It has been suggested that the GIL"
#~ " should be a per-interpreter-state"
#~ " lock rather than truly global; "
#~ "interpreters then wouldn't be able to"
#~ " share objects. Unfortunately, this isn't"
#~ " likely to happen either.  It would"
#~ " be a tremendous amount of work, "
#~ "because many object implementations currently"
#~ " have global state. For example, "
#~ "small integers and short strings are "
#~ "cached; these caches would have to "
#~ "be moved to the interpreter state.  "
#~ "Other object types have their own "
#~ "free list; these free lists would "
#~ "have to be moved to the "
#~ "interpreter state. And so on."
#~ msgstr ""
#~ "GIL은 진정한 전역이 아니라 인터프리터별 상태 록이어야"
#~ " 한다고 제안되었습니다; 그러면 인터프리터가 객체를 공유할 "
#~ "수 없습니다. 불행히도, 이것도 일어날 가능성이 없습니다."
#~ " 많은 객체 구현이 현재 전역 상태를 가지고 "
#~ "있기 때문에, 엄청난 양의 작업이 될 것입니다. "
#~ "예를 들어, 작은 정수와 짧은 문자열이 캐시 "
#~ "됩니다; 이러한 캐시는 인터프리터 상태로 이동해야 합니다."
#~ " 다른 객체 형에는 자체 자유 목록(free list)이"
#~ " 있습니다; 이 자유 목록은 인터프리터 상태로 이동해야"
#~ " 합니다. 이런 식으로 계속됩니다."

#~ msgid ""
#~ "And I doubt that it can even "
#~ "be done in finite time, because "
#~ "the same problem exists for 3rd "
#~ "party extensions.  It is likely that "
#~ "3rd party extensions are being written"
#~ " at a faster rate than you can"
#~ " convert them to store all their "
#~ "global state in the interpreter state."
#~ msgstr ""
#~ "그리고 제삼자 확장에도 같은 문제가 있기 때문에, "
#~ "유한한 시간 안에 할 수 있는지도 의심스럽습니다. "
#~ "제삼자 확장은 여러분이 그들의 전체 전역 상태를 "
#~ "인터프리터 상태에 저장하도록 변환할 수 있는 것보다 "
#~ "빠른 속도로 작성되고 있을 가능성이 높습니다."

#~ msgid ""
#~ "And finally, once you have multiple "
#~ "interpreters not sharing any state, what"
#~ " have you gained over running each"
#~ " interpreter in a separate process?"
#~ msgstr ""
#~ "그리고 마지막으로, 일단 상태를 공유하지 않는 다중 "
#~ "인터프리터를 갖게 된다면, 각 인터프리터를 별도의 프로세스로"
#~ " 실행하는 것에 비해 얻은 이점은 무엇입니까?"

#~ msgid ""
#~ "The :mod:`shutil` module contains a "
#~ ":func:`~shutil.copyfile` function.  Note that "
#~ "on MacOS 9 it doesn't copy the "
#~ "resource fork and Finder info."
#~ msgstr ""
#~ ":mod:`shutil` 모듈에는 :func:`~shutil.copyfile` 함수가 "
#~ "포함되어 있습니다. MacOS 9에서 리소스 포크(resource "
#~ "fork)와 파인더(Finder)_ 정보를 복사하지 않음에 유의하십시오."

#~ msgid "http://pyserial.sourceforge.net"
#~ msgstr "http://pyserial.sourceforge.net"

#~ msgid ""
#~ "Cameron Laird maintains a useful set "
#~ "of pages about Python web technologies"
#~ " at http://phaseit.net/claird/comp.lang.python/web_python."
#~ msgstr ""
#~ "Cameron Laird는 "
#~ "http://phaseit.net/claird/comp.lang.python/web_python\\ 에서 "
#~ "파이썬 웹 기술에 관한 유용한 페이지 모음을 유지"
#~ " 관리합니다."

#~ msgid "How can I mimic CGI form submission (METHOD=POST)?"
#~ msgstr "CGI 폼 제출을 어떻게 흉내 낼 수 있습니까 (METHOD=POST)?"

#~ msgid ""
#~ "I would like to retrieve web pages"
#~ " that are the result of POSTing "
#~ "a form. Is there existing code "
#~ "that would let me do this easily?"
#~ msgstr "폼을 POST 한 결과 웹 페이지를 가져오고 싶습니다. 이 작업을 쉽게 수행할 수 있도록 하는 기존 코드가 있습니까?"

#~ msgid "Yes. Here's a simple example that uses :mod:`urllib.request`::"
#~ msgstr "예. 다음은 :mod:`urllib.request`\\를 사용하는 간단한 예입니다::"

#~ msgid ""
#~ "Note that in general for percent-"
#~ "encoded POST operations, query strings "
#~ "must be quoted using "
#~ ":func:`urllib.parse.urlencode`.  For example, to "
#~ "send ``name=Guy Steele, Jr.``::"
#~ msgstr ""
#~ "일반적으로 퍼센트 인코딩된 POST 연산의 경우, 쿼리 "
#~ "문자열은 :func:`urllib.parse.urlencode`\\를 사용하여 인용해야 "
#~ "함에 유의하십시오. 예를 들어, ``name=Guy Steele, "
#~ "Jr.`` 를 보내려면::"

#~ msgid ":ref:`urllib-howto` for extensive examples."
#~ msgstr "광범위한 예는 :ref:`urllib-howto`\\을 참조하십시오."

