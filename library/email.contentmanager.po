# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/email.contentmanager.rst:2
#, fuzzy
msgid ":mod:`!email.contentmanager`: Managing MIME Content"
msgstr ":mod:`email.contentmanager`: MIME 콘텐츠 관리"

#: ../../library/email.contentmanager.rst:10
msgid "**Source code:** :source:`Lib/email/contentmanager.py`"
msgstr "**소스 코드:** :source:`Lib/email/contentmanager.py`"

#: ../../library/email.contentmanager.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.contentmanager.rst:19
msgid ""
"Base class for content managers.  Provides the standard registry "
"mechanisms to register converters between MIME content and other "
"representations, as well as the ``get_content`` and ``set_content`` "
"dispatch methods."
msgstr ""
"콘텐츠 관리자를 위한 베이스 클래스. ``get_content``\\와 ``set_content`` 디스패치 메서드뿐만 아니라 "
"MIME 콘텐츠와 다른 표현 간의 변환기를 등록하는 표준 등록소 메커니즘을 제공합니다."

#: ../../library/email.contentmanager.rst:26
msgid ""
"Look up a handler function based on the ``mimetype`` of *msg* (see next "
"paragraph), call it, passing through all arguments, and return the result"
" of the call.  The expectation is that the handler will extract the "
"payload from *msg* and return an object that encodes information about "
"the extracted data."
msgstr ""
"*msg*\\의 ``mimetype``\\을 기반으로 처리기 함수를 찾고 (다음 단락을 참조하십시오), 모든 인자를 전달하여 그것을"
" 호출하고, 이 호출의 결과를 반환합니다. 처리기가 *msg*\\에서 페이 로드를 추출하고 추출된 데이터에 대한 정보를 인코딩하는 "
"객체를 반환할 것으로 기대합니다."

#: ../../library/email.contentmanager.rst:32
msgid ""
"To find the handler, look for the following keys in the registry, "
"stopping with the first one found:"
msgstr "처리기를 찾으려면, 등록소에서 다음 키를 찾는데, 처음 발견되는 것에서 멈춥니다:"

#: ../../library/email.contentmanager.rst:35
msgid "the string representing the full MIME type (``maintype/subtype``)"
msgstr "전체 MIME 유형을 나타내는 문자열 (``maintype/subtype``)"

#: ../../library/email.contentmanager.rst:36
msgid "the string representing the ``maintype``"
msgstr "``maintype``\\을 나타내는 문자열"

#: ../../library/email.contentmanager.rst:37
msgid "the empty string"
msgstr "빈 문자열"

#: ../../library/email.contentmanager.rst:39
msgid ""
"If none of these keys produce a handler, raise a :exc:`KeyError` for the "
"full MIME type."
msgstr "이러한 키 중 아무것도 이러한 처리기를 생성하지 않으면, 전체 MIME 유형에 대해 :exc:`KeyError`\\를 발생시킵니다."

#: ../../library/email.contentmanager.rst:45
msgid ""
"If the ``maintype`` is ``multipart``, raise a :exc:`TypeError`; otherwise"
" look up a handler function based on the type of *obj* (see next "
"paragraph), call :meth:`~email.message.EmailMessage.clear_content` on the"
" *msg*, and call the handler function, passing through all arguments.  "
"The expectation is that the handler will transform and store *obj* into "
"*msg*, possibly making other changes to *msg* as well, such as adding "
"various MIME headers to encode information needed to interpret the stored"
" data."
msgstr ""
"``maintype``\\이 ``multipart``\\이면, :exc:`TypeError`\\를 발생시킵니다; 그렇지 않으면 "
"*obj*\\의 형을 기반으로 처리기 함수를 찾고 (다음 단락을 참조하십시오), *msg*\\에서 "
":meth:`~email.message.EmailMessage.clear_content`\\를 호출한 다음, 모든 인자를 전달해서 "
"처리기 함수를 호출합니다. 처리기가 *obj*\\를 *msg*\\로 변환하고 저장할 것으로 기대하는데, 저장된 데이터를 해석하는 데"
" 필요한 정보를 인코딩하기 위해 다양한 MIME 헤더를 추가하는 등 *msg*\\에 다른 변경을 가할 수 있습니다."

#: ../../library/email.contentmanager.rst:54
msgid ""
"To find the handler, obtain the type of *obj* (``typ = type(obj)``), and "
"look for the following keys in the registry, stopping with the first one "
"found:"
msgstr ""
"처리기를 찾으려면, *obj*\\의 형을 얻고 (``typ = type(obj)``), 등록소에서 다음 키를 찾는데 처음 발견되는 "
"것에서 멈춥니다:"

#: ../../library/email.contentmanager.rst:58
msgid "the type itself (``typ``)"
msgstr "형 자체 (``typ``)"

#: ../../library/email.contentmanager.rst:59
msgid ""
"the type's fully qualified name (``typ.__module__ + '.' + "
"typ.__qualname__``)."
msgstr "형의 완전히 정규화된 이름 (``typ.__module__ + '.' + typ.__qualname__``)."

#: ../../library/email.contentmanager.rst:61
#, fuzzy
msgid "the type's :attr:`qualname <type.__qualname__>` (``typ.__qualname__``)"
msgstr "형의 qualname (``typ.__qualname__``)"

#: ../../library/email.contentmanager.rst:62
#, fuzzy
msgid "the type's :attr:`name <type.__name__>` (``typ.__name__``)."
msgstr "형의 이름 (``typ.__name__``)."

#: ../../library/email.contentmanager.rst:64
#, fuzzy
msgid ""
"If none of the above match, repeat all of the checks above for each of "
"the types in the :term:`MRO` (:attr:`typ.__mro__ <type.__mro__>`). "
"Finally, if no other key yields a handler, check for a handler for the "
"key ``None``.  If there is no handler for ``None``, raise a "
":exc:`KeyError` for the fully qualified name of the type."
msgstr ""
"이 중 아무것도 일치하지 않으면, :term:`MRO`\\(``typ.__mro__``)의 각 형에 대해 위의 모든 검사를 "
"반복합니다. 마지막으로, 다른 키가 처리기를 생성하지 않으면, ``None`` 키의 처리기를 확인합니다. ``None``\\에 대한"
" 처리기가 없으면, 형의 완전히 정규화된 이름으로 :exc:`KeyError`\\를 발생시킵니다."

#: ../../library/email.contentmanager.rst:71
msgid ""
"Also add a :mailheader:`MIME-Version` header if one is not present (see "
"also :class:`.MIMEPart`)."
msgstr ":mailheader:`MIME-Version` 헤더가 없으면 추가합니다 (:class:`.MIMEPart`\\를 참조하십시오)."

#: ../../library/email.contentmanager.rst:77
msgid ""
"Record the function *handler* as the handler for *key*.  For the possible"
" values of *key*, see :meth:`get_content`."
msgstr ""
"함수 *handler*\\를 *key*\\의 처리기로 기록합니다. 가능한 *key* 값은 :meth:`get_content`\\를 "
"참조하십시오."

#: ../../library/email.contentmanager.rst:83
msgid ""
"Record *handler* as the function to call when an object of a type "
"matching *typekey* is passed to :meth:`set_content`.  For the possible "
"values of *typekey*, see :meth:`set_content`."
msgstr ""
"*typekey*\\와 일치하는 형의 객체가 :meth:`set_content`\\에 전달될 때 호출할 함수로 "
"*handler*\\를 기록합니다. 가능한 *typekey* 값은 :meth:`set_content`\\를 참조하십시오."

#: ../../library/email.contentmanager.rst:89
msgid "Content Manager Instances"
msgstr "콘텐츠 관리자 인스턴스"

#: ../../library/email.contentmanager.rst:91
msgid ""
"Currently the email package provides only one concrete content manager, "
":data:`raw_data_manager`, although more may be added in the future. "
":data:`raw_data_manager` is the "
":attr:`~email.policy.EmailPolicy.content_manager` provided by "
":attr:`~email.policy.EmailPolicy` and its derivatives."
msgstr ""
"현재 email 패키지는 하나의 구상 콘텐츠 관리자 :data:`raw_data_manager`\\만 제공하지만, 향후에는 더 "
"추가될 수 있습니다. :data:`raw_data_manager`\\는 "
":attr:`~email.policy.EmailPolicy`\\와 그 파생물에 의해 제공되는 "
":attr:`~email.policy.EmailPolicy.content_manager`\\입니다."

#: ../../library/email.contentmanager.rst:100
msgid ""
"This content manager provides only a minimum interface beyond that "
"provided by :class:`~email.message.Message` itself:  it deals only with "
"text, raw byte strings, and :class:`~email.message.Message` objects.  "
"Nevertheless, it provides significant advantages compared to the base "
"API: ``get_content`` on a text part will return a unicode string without "
"the application needing to manually decode it, ``set_content`` provides a"
" rich set of options for controlling the headers added to a part and "
"controlling the content transfer encoding, and it enables the use of the "
"various ``add_`` methods, thereby simplifying the creation of multipart "
"messages."
msgstr ""
"이 콘텐츠 관리자는 :class:`~email.message.Message` 자체에서 제공하는 것 외에는 최소 인터페이스 만 "
"제공합니다: 텍스트, 날 바이트열 및 :class:`~email.message.Message` 객체만 다룹니다. 그런데도 기본 "
"API와 비교할 때 상당한 이점을 제공합니다: 텍스트 파트에 대한 ``get_content``\\는 응용 프로그램이 수동으로 "
"디코딩할 필요 없이 유니코드 문자열을 반환하고, ``set_content``\\는 파트에 추가된 헤더를 제어하고 콘텐츠 전송 "
"인코딩을 제어하기 위한 다양한 옵션을 제공하고, 다양한 ``add_`` 메서드를 사용할 수 있도록 해서, 멀티 파트 메시지 작성을 "
"단순화합니다."

#: ../../library/email.contentmanager.rst:112
msgid ""
"Return the payload of the part as either a string (for ``text`` parts), "
"an :class:`~email.message.EmailMessage` object (for ``message/rfc822`` "
"parts), or a ``bytes`` object (for all other non-multipart types).  Raise"
" a :exc:`KeyError` if called on a ``multipart``.  If the part is a "
"``text`` part and *errors* is specified, use it as the error handler when"
" decoding the payload to unicode.  The default error handler is "
"``replace``."
msgstr ""
"파트의 페이 로드를 문자열(``text`` 파트의 경우), :class:`~email.message.EmailMessage` 객체 "
"(``message/rfc822`` 파트의 경우) 또는 ``bytes`` 객체 (다른 모든 비 멀티 파트 유형의 경우)로 "
"반환합니다. ``multipart``\\에서 호출되면 :exc:`KeyError`\\를 발생시킵니다. 파트가 ``text`` "
"파트이고 *errors*\\가 지정되면, 페이 로드를 유니코드로 디코딩할 때 에러 처리기로 사용합니다. 기본 에러 처리기는 "
"``replace``\\입니다."

#: ../../library/email.contentmanager.rst:131
msgid "Add headers and payload to *msg*:"
msgstr "*msg*\\에 헤더와 페이 로드를 추가합니다:"

#: ../../library/email.contentmanager.rst:133
msgid "Add a :mailheader:`Content-Type` header with a ``maintype/subtype`` value."
msgstr "``maintype/subtype`` 값으로 :mailheader:`Content-Type` 헤더를 추가합니다."

#: ../../library/email.contentmanager.rst:136
msgid ""
"For ``str``, set the MIME ``maintype`` to ``text``, and set the subtype "
"to *subtype* if it is specified, or ``plain`` if it is not."
msgstr ""
"``str``\\의 경우, MIME ``maintype``\\을 ``text``\\로 설정하고, 서브 유형은 지정되었으면 "
"*subtype*\\으로 설정하고, 지정되지 않았으면 ``plain``\\으로 설정합니다."

#: ../../library/email.contentmanager.rst:138
msgid ""
"For ``bytes``, use the specified *maintype* and *subtype*, or raise a "
":exc:`TypeError` if they are not specified."
msgstr ""
"``bytes``\\의 경우, 지정된 *maintype*\\과 *subtype*\\을 사용하거나, 지정되지 않았으면 "
":exc:`TypeError`\\를 발생시킵니다."

#: ../../library/email.contentmanager.rst:140
msgid ""
"For :class:`~email.message.EmailMessage` objects, set the maintype to "
"``message``, and set the subtype to *subtype* if it is specified or "
"``rfc822`` if it is not.  If *subtype* is ``partial``, raise an error "
"(``bytes`` objects must be used to construct ``message/partial`` parts)."
msgstr ""
":class:`~email.message.EmailMessage` 객체의 경우, 메인 유형을 ``message``\\로 설정하고, "
"서브 유형은 지정되었으면 *subtype*\\으로 설정하고, 지정되지 않았으면 ``rfc822``\\로 설정합니다. "
"*subtype*\\이 ``partial``\\이면 에러를 발생시킵니다 (``bytes`` 객체를 사용하여 "
"``message/partial`` 파트를 구성해야 합니다)."

#: ../../library/email.contentmanager.rst:146
msgid ""
"If *charset* is provided (which is valid only for ``str``), encode the "
"string to bytes using the specified character set.  The default is "
"``utf-8``.  If the specified *charset* is a known alias for a standard "
"MIME charset name, use the standard charset instead."
msgstr ""
"*charset*\\이 제공되면 (``str``\\에만 유효합니다), 지정된 문자 집합을 사용하여 문자열을 바이트열로 인코딩합니다."
" 기본값은 ``utf-8``\\입니다. 지정된 *charset*\\이 표준 MIME 문자 집합 이름의 알려진 별칭이면, 표준 문자 "
"집합을 대신 사용합니다."

#: ../../library/email.contentmanager.rst:151
msgid ""
"If *cte* is set, encode the payload using the specified content transfer "
"encoding, and set the :mailheader:`Content-Transfer-Encoding` header to "
"that value.  Possible values for *cte* are ``quoted-printable``, "
"``base64``, ``7bit``, ``8bit``, and ``binary``.  If the input cannot be "
"encoded in the specified encoding (for example, specifying a *cte* of "
"``7bit`` for an input that contains non-ASCII values), raise a "
":exc:`ValueError`."
msgstr ""
"*cte*\\가 설정되면, 지정된 콘텐츠 전송 인코딩을 사용하여 페이 로드를 인코딩하고, :mailheader:`Content-"
"Transfer-Encoding` 헤더를 해당 값으로 설정합니다. *cte*\\의 가능한 값은 ``quoted-"
"printable``, ``base64``, ``7bit``, ``8bit`` 및 ``binary``\\입니다. 지정된 인코딩으로 "
"입력을 인코딩할 수 없으면 (예를 들어, 비 ASCII 값을 포함하는 입력에 대해 *cte*\\를 ``7bit``\\로 "
"지정합니다), :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/email.contentmanager.rst:159
msgid ""
"For ``str`` objects, if *cte* is not set use heuristics to determine the "
"most compact encoding.  Prior to encoding, :meth:`str.splitlines` is used"
" to normalize all line boundaries, ensuring that each line of the payload"
" is terminated by the current policy's "
":data:`~email.policy.Policy.linesep` property (even if the original "
"string did not end with one)."
msgstr ""

#: ../../library/email.contentmanager.rst:165
msgid ""
"For ``bytes`` objects, *cte* is taken to be base64 if not set, and the "
"aforementioned newline translation is not performed."
msgstr ""

#: ../../library/email.contentmanager.rst:167
msgid ""
"For :class:`~email.message.EmailMessage`, per :rfc:`2046`, raise an error"
" if a *cte* of ``quoted-printable`` or ``base64`` is requested for "
"*subtype* ``rfc822``, and for any *cte* other than ``7bit`` for *subtype*"
" ``external-body``.  For ``message/rfc822``, use ``8bit`` if *cte* is not"
" specified.  For all other values of *subtype*, use ``7bit``."
msgstr ""
":class:`~email.message.EmailMessage`\\의 경우, :rfc:`2046`\\에 따라, *subtype* "
"``rfc822``\\에 대해 ``quoted-printable``\\이나 ``base64``\\의 *cte*\\가 요청되거나, "
"*subtype* ``external-body``\\에 대해 ``7bit`` 이외의 *cte*\\에 대해 에러를 발생시킵니다. "
"``message/rfc822``\\의 경우, *cte*\\가 지정되지 않으면 ``8bit``\\를 사용합니다. "
"*subtype*\\의 다른 모든 값에는 ``7bit``\\를 사용합니다."

#: ../../library/email.contentmanager.rst:174
msgid ""
"A *cte* of ``binary`` does not actually work correctly yet. The "
"``EmailMessage`` object as modified by ``set_content`` is correct, but "
":class:`~email.generator.BytesGenerator` does not serialize it correctly."
msgstr ""
"``binary``\\의 *cte*\\는 실제로 아직 제대로 작동하지 않습니다. ``set_content``\\에 의해 수정된 "
"``EmailMessage`` 객체는 올바르지만, :class:`~email.generator.BytesGenerator`\\는 "
"이것을 올바르게 직렬화하지 않습니다."

#: ../../library/email.contentmanager.rst:179
msgid ""
"If *disposition* is set, use it as the value of the :mailheader:`Content-"
"Disposition` header.  If not specified, and *filename* is specified, add "
"the header with the value ``attachment``. If *disposition* is not "
"specified and *filename* is also not specified, do not add the header.  "
"The only valid values for *disposition* are ``attachment`` and "
"``inline``."
msgstr ""
"*disposition*\\이 설정되면, 이를 :mailheader:`Content-Disposition` 헤더의 값으로 "
"사용합니다. 지정되지 않고 *filename*\\이 지정되면, 값이 ``attachment``\\인 헤더를 추가합니다. "
"*disposition*\\이 지정되지 않고 *filename*\\도 지정되지 않으면, 헤더를 추가하지 않습니다. "
"*disposition*\\에 유효한 값은 ``attachment``\\와 ``inline``\\뿐 입니다."

#: ../../library/email.contentmanager.rst:186
msgid ""
"If *filename* is specified, use it as the value of the ``filename`` "
"parameter of the :mailheader:`Content-Disposition` header."
msgstr ""
"*filename*\\이 지정되면, 이를 :mailheader:`Content-Disposition` 헤더의 ``filename``"
" 파라미터의 값으로 사용합니다."

#: ../../library/email.contentmanager.rst:189
msgid ""
"If *cid* is specified, add a :mailheader:`Content-ID` header with *cid* "
"as its value."
msgstr "*cid*\\가 지정되면, *cid*\\를 값으로 사용하여 :mailheader:`Content-ID` 헤더를 추가합니다."

#: ../../library/email.contentmanager.rst:192
msgid ""
"If *params* is specified, iterate its ``items`` method and use the "
"resulting ``(key, value)`` pairs to set additional parameters on the "
":mailheader:`Content-Type` header."
msgstr ""
"*params*\\가 지정되면, 그것의 ``items`` 메서드를 이터레이트하고 결과 ``(key, value)`` 쌍을 사용하여 "
":mailheader:`Content-Type` 헤더에 추가 파라미터를 설정합니다."

#: ../../library/email.contentmanager.rst:196
msgid ""
"If *headers* is specified and is a list of strings of the form "
"``headername: headervalue`` or a list of ``header`` objects "
"(distinguished from strings by having a ``name`` attribute), add the "
"headers to *msg*."
msgstr ""
"*headers*\\가 지정되고 ``headername: headervalue`` 형식의 문자열 리스트나 ``header`` 객체"
"  (``name`` 어트리뷰트를 가진 것으로 문자열과 구별됩니다) 리스트면, 헤더를 *msg*\\에 추가합니다."

#: ../../library/email.contentmanager.rst:203
msgid "Footnotes"
msgstr "각주"

#: ../../library/email.contentmanager.rst:204
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`"
msgstr "원래 3.4에서 :term:`잠정적 모듈 <provisional package>`\\로 추가되었습니다."

#~ msgid ""
#~ "For ``str`` objects, if *cte* is "
#~ "not set use heuristics to determine "
#~ "the most compact encoding."
#~ msgstr "``str`` 객체의 경우, *cte*\\가 설정되지 않으면 휴리스틱을 사용하여 가장 간결한 인코딩을 결정합니다."

