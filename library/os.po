# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/os.rst:2
#, fuzzy
msgid ":mod:`!os` --- Miscellaneous operating system interfaces"
msgstr ":mod:`os` --- 기타 운영 체제 인터페이스"

#: ../../library/os.rst:7
msgid "**Source code:** :source:`Lib/os.py`"
msgstr "**소스 코드:** :source:`Lib/os.py`"

#: ../../library/os.rst:11
msgid ""
"This module provides a portable way of using operating system dependent "
"functionality.  If you just want to read or write a file see "
":func:`open`, if you want to manipulate paths, see the :mod:`os.path` "
"module, and if you want to read all the lines in all the files on the "
"command line see the :mod:`fileinput` module.  For creating temporary "
"files and directories see the :mod:`tempfile` module, and for high-level "
"file and directory handling see the :mod:`shutil` module."
msgstr ""
"이 모듈은 운영 체제 종속 기능을 사용하는 이식성 있는 방법을 제공합니다. 파일을 읽거나 쓰고 싶으면 :func:`open`\\을 "
"보세요, 경로를 조작하려면 :mod:`os.path` 모듈을 보시고, 명령 줄에서 주어진 모든 파일의 모든 줄을 읽으려면 "
":mod:`fileinput` 모듈을 보십시오. 임시 파일과 디렉터리를 만들려면 :mod:`tempfile` 모듈을 보시고, "
"고수준의 파일과 디렉터리 처리는 :mod:`shutil` 모듈을 보십시오."

#: ../../library/os.rst:19
msgid "Notes on the availability of these functions:"
msgstr "이러한 기능의 가용성에 대한 참고 사항:"

#: ../../library/os.rst:21
msgid ""
"The design of all built-in operating system dependent modules of Python "
"is such that as long as the same functionality is available, it uses the "
"same interface; for example, the function ``os.stat(path)`` returns stat "
"information about *path* in the same format (which happens to have "
"originated with the POSIX interface)."
msgstr ""
"내장된 모든 운영 체제 종속적인 파이썬 모듈의 설계는, 같은 기능을 사용할 수 있는 한, 같은 인터페이스를 사용합니다; 예를 들어,"
" 함수 ``os.stat(path)``\\는 *path* 에 대한 stat 정보를 같은 (POSIX 인터페이스에서 기원한) 형식으로"
" 반환합니다."

#: ../../library/os.rst:27
msgid ""
"Extensions peculiar to a particular operating system are also available "
"through the :mod:`os` module, but using them is of course a threat to "
"portability."
msgstr ""
"특정 운영 체제에 고유한 확장도 :mod:`os` 모듈을 통해서 사용할 수 있지만, 이러한 기능을 사용하는 것은 물론 이식성에 대한"
" 위협입니다."

#: ../../library/os.rst:31
msgid ""
"All functions accepting path or file names accept both bytes and string "
"objects, and result in an object of the same type, if a path or file name"
" is returned."
msgstr ""
"경로 또는 파일명을 받아들이는 모든 함수는 바이트열과 문자열 객체를 모두 허용하며, 경로나 파일명이 반환되면 같은 형의 객체를 "
"반환합니다."

#: ../../library/os.rst:35
#, fuzzy
msgid "On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported."
msgstr "VxWorks에서 os.fork, os.execv 및 os.spawn*p*\\는 지원되지 않습니다."

#: ../../library/os.rst:37
msgid ""
"On WebAssembly platforms, Android and iOS, large parts of the :mod:`os` "
"module are not available or behave differently. APIs related to processes"
" (e.g. :func:`~os.fork`, :func:`~os.execve`) and resources (e.g. "
":func:`~os.nice`) are not available. Others like :func:`~os.getuid` and "
":func:`~os.getpid` are emulated or stubs. WebAssembly platforms also lack"
" support for signals (e.g. :func:`~os.kill`, :func:`~os.wait`)."
msgstr ""

#: ../../library/os.rst:47
msgid ""
"All functions in this module raise :exc:`OSError` (or subclasses thereof)"
" in the case of invalid or inaccessible file names and paths, or other "
"arguments that have the correct type, but are not accepted by the "
"operating system."
msgstr ""
"이 모듈의 모든 함수는, 올바르지 않거나 액세스할 수 없는 파일명과 경로일 때, 또는 올바른 형의 인자이지만, 운영 체제에서 "
"허용하지 않으면 :exc:`OSError`\\(또는 이것의 서브 클래스)를 발생시킵니다."

#: ../../library/os.rst:53
msgid "An alias for the built-in :exc:`OSError` exception."
msgstr "내장 :exc:`OSError` 예외의 별칭."

#: ../../library/os.rst:58
msgid ""
"The name of the operating system dependent module imported.  The "
"following names have currently been registered: ``'posix'``, ``'nt'``, "
"``'java'``."
msgstr ""
"임포트 된 운영 체제 종속 모듈의 이름. 다음과 같은 이름이 현재 등록되어있습니다: ``'posix'``, ``'nt'``, "
"``'java'``."

#: ../../library/os.rst:63
#, fuzzy
msgid ""
":data:`sys.platform` has a finer granularity.  :func:`os.uname` gives "
"system-dependent version information."
msgstr ""
":attr:`sys.platform`\\는 더 세분되어 있습니다. :func:`os.uname`\\은 시스템 종속 버전 정보를 "
"제공합니다."

#: ../../library/os.rst:66
msgid ""
"The :mod:`platform` module provides detailed checks for the system's "
"identity."
msgstr ":mod:`platform` 모듈은 시스템의 아이덴티티에 대한 자세한 검사를 제공합니다."

#: ../../library/os.rst:74
msgid "File Names, Command Line Arguments, and Environment Variables"
msgstr "파일명, 명령 줄 인자 및 환경 변수"

#: ../../library/os.rst:76
#, fuzzy
msgid ""
"In Python, file names, command line arguments, and environment variables "
"are represented using the string type. On some systems, decoding these "
"strings to and from bytes is necessary before passing them to the "
"operating system. Python uses the :term:`filesystem encoding and error "
"handler` to perform this conversion (see "
":func:`sys.getfilesystemencoding`)."
msgstr ""
"파이썬에서는, 파일명, 명령 줄 인자 및 환경 변수가 문자열형을 사용하여 표시됩니다. 일부 시스템에서는, 운영 체제에 전달하기 전에"
" 이러한 문자열을 바이트열로 인코딩하는 것이 필요합니다. 파이썬은 파일 시스템 인코딩을 사용하여 이 변환을 수행합니다 "
"(:func:`sys.getfilesystemencoding`\\을 참조하세요)."

#: ../../library/os.rst:82
msgid ""
"The :term:`filesystem encoding and error handler` are configured at "
"Python startup by the :c:func:`PyConfig_Read` function: see "
":c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""

#: ../../library/os.rst:87
#, fuzzy
msgid ""
"On some systems, conversion using the file system encoding may fail. In "
"this case, Python uses the :ref:`surrogateescape encoding error handler "
"<surrogateescape>`, which means that undecodable bytes are replaced by a "
"Unicode character U+DC\\ *xx* on decoding, and these are again translated"
" to the original byte on encoding."
msgstr ""
"일부 시스템에서는, 파일 시스템 인코딩을 사용한 변환이 실패할 수 있습니다. 이때, 파이썬은 :ref:`surrogateescape"
" 인코딩 에러 처리기 <surrogateescape>`\\를 사용하는데, 디코딩할 때 디코딩 할 수 없는 바이트가 유니코드 문자 "
"U+DCxx로 치환되고, 다시 인코딩할 때 원래 바이트로 변환됩니다."

#: ../../library/os.rst:95
#, fuzzy
msgid ""
"The :term:`file system encoding <filesystem encoding and error handler>` "
"must guarantee to successfully decode all bytes below 128. If the file "
"system encoding fails to provide this guarantee, API functions can raise "
":exc:`UnicodeError`."
msgstr ""
"파일 시스템 인코딩은 128보다 작은 모든 바이트를 성공적으로 디코딩함을 보장해야 합니다. 파일 시스템 인코딩이 이 보장을 제공하지"
" 못하면, API 함수가 UnicodeError를 발생시킬 수 있습니다."

#: ../../library/os.rst:100
msgid "See also the :term:`locale encoding`."
msgstr ""

#: ../../library/os.rst:106
msgid "Python UTF-8 Mode"
msgstr ""

#: ../../library/os.rst:108
msgid "See :pep:`540` for more details."
msgstr ""

#: ../../library/os.rst:111
msgid ""
"The Python UTF-8 Mode ignores the :term:`locale encoding` and forces the "
"usage of the UTF-8 encoding:"
msgstr ""

#: ../../library/os.rst:114
msgid ""
"Use UTF-8 as the :term:`filesystem encoding <filesystem encoding and "
"error handler>`."
msgstr ""

#: ../../library/os.rst:116
msgid ":func:`sys.getfilesystemencoding` returns ``'utf-8'``."
msgstr ""

#: ../../library/os.rst:117
msgid ""
":func:`locale.getpreferredencoding` returns ``'utf-8'`` (the "
"*do_setlocale* argument has no effect)."
msgstr ""

#: ../../library/os.rst:119
msgid ""
":data:`sys.stdin`, :data:`sys.stdout`, and :data:`sys.stderr` all use "
"UTF-8 as their text encoding, with the ``surrogateescape`` :ref:`error "
"handler <error-handlers>` being enabled for :data:`sys.stdin` and "
":data:`sys.stdout` (:data:`sys.stderr` continues to use "
"``backslashreplace`` as it does in the default locale-aware mode)"
msgstr ""

#: ../../library/os.rst:124
msgid ""
"On Unix, :func:`os.device_encoding` returns ``'utf-8'`` rather than the "
"device encoding."
msgstr ""

#: ../../library/os.rst:127
msgid ""
"Note that the standard stream settings in UTF-8 mode can be overridden by"
" :envvar:`PYTHONIOENCODING` (just as they can be in the default locale-"
"aware mode)."
msgstr ""

#: ../../library/os.rst:131
msgid ""
"As a consequence of the changes in those lower level APIs, other higher "
"level APIs also exhibit different default behaviours:"
msgstr ""

#: ../../library/os.rst:134
msgid ""
"Command line arguments, environment variables and filenames are decoded "
"to text using the UTF-8 encoding."
msgstr ""

#: ../../library/os.rst:136
msgid ":func:`os.fsdecode` and :func:`os.fsencode` use the UTF-8 encoding."
msgstr ""

#: ../../library/os.rst:137
msgid ""
":func:`open`, :func:`io.open`, and :func:`codecs.open` use the UTF-8 "
"encoding by default. However, they still use the strict error handler by "
"default so that attempting to open a binary file in text mode is likely "
"to raise an exception rather than producing nonsense data."
msgstr ""

#: ../../library/os.rst:142
msgid ""
"The :ref:`Python UTF-8 Mode <utf8-mode>` is enabled if the LC_CTYPE "
"locale is ``C`` or ``POSIX`` at Python startup (see the "
":c:func:`PyConfig_Read` function)."
msgstr ""

#: ../../library/os.rst:146
msgid ""
"It can be enabled or disabled using the :option:`-X utf8 <-X>` command "
"line option and the :envvar:`PYTHONUTF8` environment variable."
msgstr ""

#: ../../library/os.rst:149
msgid ""
"If the :envvar:`PYTHONUTF8` environment variable is not set at all, then "
"the interpreter defaults to using the current locale settings, *unless* "
"the current locale is identified as a legacy ASCII-based locale (as "
"described for :envvar:`PYTHONCOERCECLOCALE`), and locale coercion is "
"either disabled or fails. In such legacy locales, the interpreter will "
"default to enabling UTF-8 mode unless explicitly instructed not to do so."
msgstr ""

#: ../../library/os.rst:156
msgid ""
"The Python UTF-8 Mode can only be enabled at the Python startup. Its "
"value can be read from :data:`sys.flags.utf8_mode <sys.flags>`."
msgstr ""

#: ../../library/os.rst:159
msgid ""
"See also the :ref:`UTF-8 mode on Windows <win-utf8-mode>` and the "
":term:`filesystem encoding and error handler`."
msgstr ""

#: ../../library/os.rst:164
msgid ":pep:`686`"
msgstr ""

#: ../../library/os.rst:165
msgid "Python 3.15 will make :ref:`utf8-mode` default."
msgstr ""

#: ../../library/os.rst:171
msgid "Process Parameters"
msgstr "프로세스 매개 변수"

#: ../../library/os.rst:173
msgid ""
"These functions and data items provide information and operate on the "
"current process and user."
msgstr "이 함수들과 데이터 항목은 현재 프로세스와 사용자에 관한 정보와 관련 연산을 제공합니다."

#: ../../library/os.rst:179
msgid ""
"Return the filename corresponding to the controlling terminal of the "
"process."
msgstr "프로세스의 제어 터미널에 해당하는 파일명을 반환합니다."

#: ../../library/os.rst:181 ../../library/os.rst:323 ../../library/os.rst:338
#: ../../library/os.rst:359 ../../library/os.rst:368 ../../library/os.rst:377
#: ../../library/os.rst:390 ../../library/os.rst:399 ../../library/os.rst:427
#: ../../library/os.rst:435 ../../library/os.rst:443 ../../library/os.rst:463
#: ../../library/os.rst:481 ../../library/os.rst:492 ../../library/os.rst:504
#: ../../library/os.rst:513 ../../library/os.rst:523 ../../library/os.rst:534
#: ../../library/os.rst:546 ../../library/os.rst:580 ../../library/os.rst:587
#: ../../library/os.rst:594 ../../library/os.rst:603 ../../library/os.rst:640
#: ../../library/os.rst:653 ../../library/os.rst:662 ../../library/os.rst:679
#: ../../library/os.rst:688 ../../library/os.rst:695 ../../library/os.rst:704
#: ../../library/os.rst:713 ../../library/os.rst:720 ../../library/os.rst:727
#: ../../library/os.rst:736 ../../library/os.rst:793 ../../library/os.rst:832
#: ../../library/os.rst:954 ../../library/os.rst:980 ../../library/os.rst:993
#: ../../library/os.rst:1010 ../../library/os.rst:1028
#: ../../library/os.rst:1039 ../../library/os.rst:1062
#: ../../library/os.rst:1083 ../../library/os.rst:1095
#: ../../library/os.rst:1106 ../../library/os.rst:1119
#: ../../library/os.rst:1140 ../../library/os.rst:1161
#: ../../library/os.rst:1173 ../../library/os.rst:1184
#: ../../library/os.rst:1245 ../../library/os.rst:1368
#: ../../library/os.rst:1380 ../../library/os.rst:1394
#: ../../library/os.rst:1404 ../../library/os.rst:1419
#: ../../library/os.rst:1434 ../../library/os.rst:1447
#: ../../library/os.rst:1464 ../../library/os.rst:1490
#: ../../library/os.rst:1507 ../../library/os.rst:1521
#: ../../library/os.rst:1536 ../../library/os.rst:1548
#: ../../library/os.rst:1575 ../../library/os.rst:1587
#: ../../library/os.rst:1597 ../../library/os.rst:1611
#: ../../library/os.rst:1663 ../../library/os.rst:1683
#: ../../library/os.rst:1692 ../../library/os.rst:1704
#: ../../library/os.rst:1739 ../../library/os.rst:1763
#: ../../library/os.rst:1773 ../../library/os.rst:1781
#: ../../library/os.rst:1790 ../../library/os.rst:1801
#: ../../library/os.rst:1838 ../../library/os.rst:1865
#: ../../library/os.rst:1916 ../../library/os.rst:1922
#: ../../library/os.rst:2088 ../../library/os.rst:2165
#: ../../library/os.rst:2182 ../../library/os.rst:2196
#: ../../library/os.rst:2222 ../../library/os.rst:2240
#: ../../library/os.rst:2256 ../../library/os.rst:2272
#: ../../library/os.rst:2335 ../../library/os.rst:2359
#: ../../library/os.rst:2379 ../../library/os.rst:2515
#: ../../library/os.rst:2537 ../../library/os.rst:2581
#: ../../library/os.rst:2593 ../../library/os.rst:2615
#: ../../library/os.rst:3323 ../../library/os.rst:3457
#: ../../library/os.rst:3480 ../../library/os.rst:3494
#: ../../library/os.rst:3714 ../../library/os.rst:3739
#: ../../library/os.rst:3764 ../../library/os.rst:3818
#: ../../library/os.rst:3827 ../../library/os.rst:3836
#: ../../library/os.rst:3844 ../../library/os.rst:3853
#: ../../library/os.rst:3862 ../../library/os.rst:3934
#: ../../library/os.rst:3997 ../../library/os.rst:4007
#: ../../library/os.rst:4025 ../../library/os.rst:4034
#: ../../library/os.rst:4044 ../../library/os.rst:4054
#: ../../library/os.rst:4064 ../../library/os.rst:4075
#: ../../library/os.rst:4220 ../../library/os.rst:4289
#: ../../library/os.rst:4324 ../../library/os.rst:4332
#: ../../library/os.rst:4339 ../../library/os.rst:4346
#: ../../library/os.rst:4353 ../../library/os.rst:4360
#: ../../library/os.rst:4367 ../../library/os.rst:4374
#: ../../library/os.rst:4382 ../../library/os.rst:4390
#: ../../library/os.rst:4397 ../../library/os.rst:4404
#: ../../library/os.rst:4413 ../../library/os.rst:4421
#: ../../library/os.rst:4429 ../../library/os.rst:4436
#: ../../library/os.rst:4443 ../../library/os.rst:4492
#: ../../library/os.rst:4519 ../../library/os.rst:4542
#: ../../library/os.rst:4558 ../../library/os.rst:4565
#: ../../library/os.rst:4576 ../../library/os.rst:4586
#: ../../library/os.rst:4595 ../../library/os.rst:4627
#: ../../library/os.rst:4735 ../../library/os.rst:4751
#: ../../library/os.rst:4784 ../../library/os.rst:4853
#: ../../library/os.rst:4872 ../../library/os.rst:4883
#: ../../library/os.rst:4895 ../../library/os.rst:4940
#: ../../library/os.rst:4977 ../../library/os.rst:5000
#: ../../library/os.rst:5021 ../../library/os.rst:5055
#: ../../library/os.rst:5096 ../../library/os.rst:5116
#: ../../library/os.rst:5130 ../../library/os.rst:5147
#: ../../library/os.rst:5162 ../../library/os.rst:5173
#: ../../library/os.rst:5185 ../../library/os.rst:5198
#: ../../library/os.rst:5207 ../../library/os.rst:5217
#: ../../library/os.rst:5230 ../../library/os.rst:5265
#: ../../library/os.rst:5281 ../../library/os.rst:5292
#: ../../library/os.rst:5304 ../../library/os.rst:5311
#: ../../library/os.rst:5320 ../../library/os.rst:5329
#: ../../library/os.rst:5338 ../../library/os.rst:5347
#: ../../library/os.rst:5499 ../../library/os.rst:5508
#: ../../library/os.rst:5532 ../../library/os.rst:5559
#: ../../library/os.rst:5568 ../../library/os.rst:5691
msgid "Availability"
msgstr ""

#: ../../library/os.rst:186
#, fuzzy
msgid ""
"A :term:`mapping` object where keys and values are strings that represent"
" the process environment.  For example, ``environ['HOME']`` is the "
"pathname of your home directory (on some platforms), and is equivalent to"
" ``getenv(\"HOME\")`` in C."
msgstr ""
"문자열 환경을 나타내는 :term:`매핑 <mapping>` 객체입니다. 예를 들어, ``environ['HOME']``\\은 홈 "
"디렉터리의 경로명이며 (일부 플랫폼에서), C의 ``getenv(\"HOME\")``\\과 같습니다."

#: ../../library/os.rst:191
#, fuzzy
msgid ""
"This mapping is captured the first time the :mod:`os` module is imported,"
" typically during Python startup as part of processing :file:`site.py`.  "
"Changes to the environment made after this time are not reflected in "
":data:`os.environ`, except for changes made by modifying "
":data:`os.environ` directly."
msgstr ""
"이 매핑은 :mod:`os` 모듈을 처음으로 임포트 할 때, 일반적으로 파이썬을 시작할 때 :file:`site.py`\\를 "
"처리하는 과정에서, 캡처됩니다. 이 시각 이후 변경된 환경은 ``os.environ``\\을 직접 수정하여 변경한 경우를 제외하고는"
" ``os.environ``\\에 반영되지 않습니다."

#: ../../library/os.rst:196
msgid ""
"This mapping may be used to modify the environment as well as query the "
"environment.  :func:`putenv` will be called automatically when the "
"mapping is modified."
msgstr ""
"이 매핑은 환경을 조회하는 것뿐 아니라 환경을 수정하는 데도 사용될 수 있습니다. 매핑이 수정될 때 :func:`putenv`\\가"
" 자동으로 호출됩니다."

#: ../../library/os.rst:200
msgid ""
"On Unix, keys and values use :func:`sys.getfilesystemencoding` and "
"``'surrogateescape'`` error handler. Use :data:`environb` if you would "
"like to use a different encoding."
msgstr ""
"유닉스에서, 키와 값은 :func:`sys.getfilesystemencoding` 과 ``'surrogateescape'`` 에러"
" 처리기를 사용합니다. 다른 인코딩을 사용하려면 :data:`environb`\\를 사용하십시오."

#: ../../library/os.rst:204
msgid ""
"On Windows, the keys are converted to uppercase. This also applies when "
"getting, setting, or deleting an item. For example, ``environ['monty'] = "
"'python'`` maps the key ``'MONTY'`` to the value ``'python'``."
msgstr ""

#: ../../library/os.rst:211
#, fuzzy
msgid ""
"Calling :func:`putenv` directly does not change :data:`os.environ`, so "
"it's better to modify :data:`os.environ`."
msgstr ""
":func:`putenv`\\를 직접 호출해도 ``os.environ``\\은 변경되지 않으므로, ``os.environ``\\을 "
"수정하는 것이 좋습니다."

#: ../../library/os.rst:216
#, fuzzy
msgid ""
"On some platforms, including FreeBSD and macOS, setting ``environ`` may "
"cause memory leaks.  Refer to the system documentation for "
":c:func:`!putenv`."
msgstr ""
"FreeBSD 및 맥 OS X를 포함한 일부 플랫폼에서, ``environ``\\을 설정하면 메모리 누수가 발생할 수 있습니다. "
":c:func:`putenv`\\에 대한 시스템 설명서를 참조하십시오."

#: ../../library/os.rst:220
#, fuzzy
msgid ""
"You can delete items in this mapping to unset environment variables. "
":func:`unsetenv` will be called automatically when an item is deleted "
"from :data:`os.environ`, and when one of the :meth:`pop` or :meth:`clear`"
" methods is called."
msgstr ""
"이 매핑에서 항목을 삭제하여 환경 변수를 설정 해제할 수 있습니다. ``os.environ``\\에서 항목이 삭제될 때, 그리고 "
":meth:`pop`\\이나 :meth:`clear` 메서드 중 하나가 호출될 때 :func:`unsetenv`\\가 자동으로 "
"호출됩니다."

#: ../../library/os.rst:225 ../../library/os.rst:241
msgid ""
"Updated to support :pep:`584`'s merge (``|``) and update (``|=``) "
"operators."
msgstr ":pep:`584`\\의 병합(``|``)과 업데이트(``|=``) 연산자를 지원하도록 갱신되었습니다."

#: ../../library/os.rst:231
#, fuzzy
msgid ""
"Bytes version of :data:`environ`: a :term:`mapping` object where both "
"keys and values are :class:`bytes` objects representing the process "
"environment. :data:`environ` and :data:`environb` are synchronized "
"(modifying :data:`environb` updates :data:`environ`, and vice versa)."
msgstr ""
":data:`environ`\\의 바이트열 버전: 환경을 바이트열로 나타내는 :term:`매핑 <mapping>` 객체입니다. "
":data:`environ`\\과 :data:`environb`\\는 동기화됩니다 (:data:`environb`\\를 수정하면 "
":data:`environ`\\이 갱신되고, 그 반대도 마찬가지입니다)."

#: ../../library/os.rst:236
#, fuzzy
msgid ""
":data:`environb` is only available if :const:`supports_bytes_environ` is "
"``True``."
msgstr ""
":data:`environb`\\는 :data:`supports_bytes_environ`\\이 ``True``\\인 경우에만 "
"사용할 수 있습니다."

#: ../../library/os.rst:250
msgid "These functions are described in :ref:`os-file-dir`."
msgstr "이 함수는 :ref:`os-file-dir`\\에 설명되어 있습니다."

#: ../../library/os.rst:255
#, fuzzy
msgid ""
"Encode :term:`path-like <path-like object>` *filename* to the "
":term:`filesystem encoding and error handler`; return :class:`bytes` "
"unchanged."
msgstr ""
"``'surrogateescape'`` 에러 처리기를, 또는 윈도우에서는 ``'strict'``\\를, 사용하여 파일 시스템 "
"인코딩으로 :term:`경로류 <path-like object>` *filename* 을 인코딩합니다; "
":class:`bytes`\\를 변경하지 않고 반환합니다."

#: ../../library/os.rst:259
msgid ":func:`fsdecode` is the reverse function."
msgstr ":func:`fsdecode`\\는 역 함수입니다."

#: ../../library/os.rst:263 ../../library/os.rst:278
msgid ""
"Support added to accept objects implementing the :class:`os.PathLike` "
"interface."
msgstr ":class:`os.PathLike` 인터페이스를 구현하는 객체를 받아들이도록 지원이 추가되었습니다."

#: ../../library/os.rst:270
#, fuzzy
msgid ""
"Decode the :term:`path-like <path-like object>` *filename* from the "
":term:`filesystem encoding and error handler`; return :class:`str` "
"unchanged."
msgstr ""
"``'surrogateescape'`` 에러 처리기를, 또는 윈도우에서는 ``'strict'``\\를, 사용하여 파일 시스템 "
"인코딩으로 :term:`경로류 <path-like object>` *filename* 을 디코딩합니다; :class:`str`\\을"
" 변경하지 않고 반환합니다."

#: ../../library/os.rst:274
msgid ":func:`fsencode` is the reverse function."
msgstr ":func:`fsencode`\\는 역 함수입니다."

#: ../../library/os.rst:285
msgid "Return the file system representation of the path."
msgstr "경로의 파일 시스템 표현을 돌려줍니다."

#: ../../library/os.rst:287
msgid ""
"If :class:`str` or :class:`bytes` is passed in, it is returned unchanged."
" Otherwise :meth:`~os.PathLike.__fspath__` is called and its value is "
"returned as long as it is a :class:`str` or :class:`bytes` object. In all"
" other cases, :exc:`TypeError` is raised."
msgstr ""
":class:`str`\\이나 :class:`bytes`\\가 전달되면, 변경되지 않은 상태로 반환됩니다. 그렇지 않으면 "
":meth:`~os.PathLike.__fspath__`\\가 호출되고, 해당 값이 :class:`str`\\이나 "
":class:`bytes` 객체인 한 그 값이 반환됩니다. 다른 모든 경우에는 :exc:`TypeError`\\가 발생합니다."

#: ../../library/os.rst:297
msgid ""
"An :term:`abstract base class` for objects representing a file system "
"path, e.g. :class:`pathlib.PurePath`."
msgstr ""
"파일 시스템 경로를 나타내는 객체(예를 들어 :class:`pathlib.PurePath`)의 :term:`추상 베이스 클래스 "
"<abstract base class>`\\입니다."

#: ../../library/os.rst:305
msgid "Return the file system path representation of the object."
msgstr "객체의 파일 시스템 경로 표현을 돌려줍니다."

#: ../../library/os.rst:307
msgid ""
"The method should only return a :class:`str` or :class:`bytes` object, "
"with the preference being for :class:`str`."
msgstr "이 메서드는 :class:`str`\\이나 :class:`bytes` 객체만 반환해야 하며, :class:`str`\\을 선호합니다."

#: ../../library/os.rst:313
msgid ""
"Return the value of the environment variable *key* as a string if it "
"exists, or *default* if it doesn't. *key* is a string. Note that since "
":func:`getenv` uses :data:`os.environ`, the mapping of :func:`getenv` is "
"similarly also captured on import, and the function may not reflect "
"future environment changes."
msgstr ""

#: ../../library/os.rst:319
msgid ""
"On Unix, keys and values are decoded with "
":func:`sys.getfilesystemencoding` and ``'surrogateescape'`` error "
"handler. Use :func:`os.getenvb` if you would like to use a different "
"encoding."
msgstr ""
"유닉스에서, 키와 값은 :func:`sys.getfilesystemencoding` 과 ``'surrogateescape'`` 에러"
" 처리기로 디코딩됩니다. 다른 인코딩을 사용하려면 :func:`os.getenvb`\\를 사용하십시오."

#: ../../library/os.rst:328
msgid ""
"Return the value of the environment variable *key* as bytes if it exists,"
" or *default* if it doesn't. *key* must be bytes. Note that since "
":func:`getenvb` uses :data:`os.environb`, the mapping of :func:`getenvb` "
"is similarly also captured on import, and the function may not reflect "
"future environment changes."
msgstr ""

#: ../../library/os.rst:335
#, fuzzy
msgid ""
":func:`getenvb` is only available if :const:`supports_bytes_environ` is "
"``True``."
msgstr ""
":func:`getenvb`\\는 :data:`supports_bytes_environ`\\이 ``True``\\인 경우에만 사용할"
" 수 있습니다."

#: ../../library/os.rst:345
msgid ""
"Returns the list of directories that will be searched for a named "
"executable, similar to a shell, when launching a process. *env*, when "
"specified, should be an environment variable dictionary to lookup the "
"PATH in. By default, when *env* is ``None``, :data:`environ` is used."
msgstr ""
"셸과 비슷하게, 프로세스를 시작할 때 지정된 이름의 실행 파일을 검색할 디렉터리 리스트를 반환합니다. (지정된다면) *env* 는 "
"PATH를 조회할 환경 변수 딕셔너리 여야 합니다. 기본적으로, *env* 가 ``None``\\이면, "
":data:`environ`\\이 사용됩니다."

#: ../../library/os.rst:356
msgid ""
"Return the effective group id of the current process.  This corresponds "
"to the \"set id\" bit on the file being executed in the current process."
msgstr ""
"현재 프로세스의 유효(effective) 그룹 ID를 반환합니다. 이것은 현재 프로세스에서 실행 중인 파일의 \"set id\" "
"비트에 해당합니다."

#: ../../library/os.rst:366
msgid "Return the current process's effective user id."
msgstr "현재 프로세스의 유효(effective) 사용자 ID를 반환합니다."

#: ../../library/os.rst:375
msgid "Return the real group id of the current process."
msgstr "현재 프로세스의 실제(real) 그룹 ID를 반환합니다."

#: ../../library/os.rst:379 ../../library/os.rst:452 ../../library/os.rst:536
#: ../../library/os.rst:759
msgid ""
"The function is a stub on WASI, see :ref:`wasm-availability` for more "
"information."
msgstr ""

#: ../../library/os.rst:385
#, fuzzy
msgid ""
"Return list of group ids that *user* belongs to. If *group* is not in the"
" list, it is included; typically, *group* is specified as the group ID "
"field from the password record for *user*, because that group ID will "
"otherwise be potentially omitted."
msgstr ""
"*user*\\가 속한 그룹 ID의 목록을 돌려줍니다. *group* 이 목록에 없으면 포함됩니다; 일반적으로 *group* 은 "
"*user* 의 암호 레코드에서 그룹 ID 필드로 지정됩니다."

#: ../../library/os.rst:397
msgid "Return list of supplemental group ids associated with the current process."
msgstr "현재 프로세스와 관련된 보충(supplemental) 그룹 ID 목록을 반환합니다."

#: ../../library/os.rst:403
#, fuzzy
msgid ""
"On macOS, :func:`getgroups` behavior differs somewhat from other Unix "
"platforms. If the Python interpreter was built with a deployment target "
"of ``10.5`` or earlier, :func:`getgroups` returns the list of effective "
"group ids associated with the current user process; this list is limited "
"to a system-defined number of entries, typically 16, and may be modified "
"by calls to :func:`setgroups` if suitably privileged. If built with a "
"deployment target greater than ``10.5``, :func:`getgroups` returns the "
"current group access list for the user associated with the effective user"
" id of the process; the group access list may change over the lifetime of"
" the process, it is not affected by calls to :func:`setgroups`, and its "
"length is not limited to 16.  The deployment target value, "
":const:`MACOSX_DEPLOYMENT_TARGET`, can be obtained with "
":func:`sysconfig.get_config_var`."
msgstr ""
"맥 OS X에서, :func:`getgroups` 동작은 다른 유닉스 플랫폼과 약간 다릅니다. 파이썬 인터프리터가 "
":const:`10.5` 또는 이전 버전의 배포 대상으로 빌드되면, :func:`getgroups`\\는 현재 사용자 프로세스와 "
"관련된 유효 그룹 ID 목록을 반환합니다; 이 목록은 시스템 정의된 항목 수(일반적으로 16)로 제한되며, 적절하게 권한이 부여된 "
"경우 :func:`setgroups`\\를 호출하여 수정할 수 있습니다. :const:`10.5`\\보다 큰 배포 대상으로 "
"빌드되면, :func:`getgroups`\\는 프로세스의 유효 사용자 ID와 연관된 사용자에 대한 현재 그룹 액세스 목록을 "
"반환합니다; 그룹 액세스 목록은 프로세스 수명 동안 변경될 수 있으며, :func:`setgroups` 호출의 영향을 받지 않고, "
"길이도 16개로 제한되지 않습니다. 배포 대상 값(:const:`MACOSX_DEPLOYMENT_TARGET`)은 "
":func:`sysconfig.get_config_var`\\를 통해 얻을 수 있습니다."

#: ../../library/os.rst:420
msgid ""
"Return the name of the user logged in on the controlling terminal of the "
"process.  For most purposes, it is more useful to use "
":func:`getpass.getuser` since the latter checks the environment variables"
" :envvar:`LOGNAME` or :envvar:`USERNAME` to find out who the user is, and"
" falls back to ``pwd.getpwuid(os.getuid())[0]`` to get the login name of "
"the current real user id."
msgstr ""
"프로세스의 제어 터미널에 로그인한 사용자의 이름을 반환합니다. 대부분 목적에서, :func:`getpass.getuser`\\를 "
"사용하는 것이 더 유용한데, 이 함수는 환경 변수 :envvar:`LOGNAME` 이나 :envvar:`USERNAME`\\을 "
"검사하여 사용자가 누구인지 알아내고, 현재 실제 사용자 ID의 로그인 이름을 얻기 위해 "
"``pwd.getpwuid(os.getuid())[0]``\\로 폴백 하기 때문입니다."

#: ../../library/os.rst:432
msgid ""
"Return the process group id of the process with process id *pid*. If "
"*pid* is 0, the process group id of the current process is returned."
msgstr ""
"프로세스 ID *pid* 를 갖는 프로세스의 프로세스 그룹 ID를 반환합니다. *pid* 가 0이면, 현재 프로세스의 프로세스 그룹"
" id가 반환됩니다."

#: ../../library/os.rst:441
msgid "Return the id of the current process group."
msgstr "현재 프로세스 그룹의 ID를 반환합니다."

#: ../../library/os.rst:450
msgid "Return the current process id."
msgstr "현재의 프로세스 ID를 반환합니다."

#: ../../library/os.rst:459
msgid ""
"Return the parent's process id.  When the parent process has exited, on "
"Unix the id returned is the one of the init process (1), on Windows it is"
" still the same id, which may be already reused by another process."
msgstr ""
"부모의 프로세스 ID를 반환합니다. 부모 프로세스가 종료했으면, 유닉스에서 반환된 id는 init 프로세스 (1) 중 하나이며, "
"윈도우에서는 여전히 같은 id인데, 다른 프로세스에서 이미 재사용했을 수 있습니다."

#: ../../library/os.rst:465
msgid "Added support for Windows."
msgstr "윈도우에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:473
msgid ""
"Get program scheduling priority.  The value *which* is one of "
":const:`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and "
"*who* is interpreted relative to *which* (a process identifier for "
":const:`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, "
"and a user ID for :const:`PRIO_USER`).  A zero value for *who* denotes "
"(respectively) the calling process, the process group of the calling "
"process, or the real user ID of the calling process."
msgstr ""
"프로그램 스케줄 우선순위를 얻습니다. *which* 값은 :const:`PRIO_PROCESS`, :const:`PRIO_PGRP`"
" 또는 :const:`PRIO_USER` 중 하나이고, *who*\\는 *which* 에 상대적으로 해석됩니다 "
"(:const:`PRIO_PROCESS` 면 프로세스 식별자, :const:`PRIO_PGRP` 면 프로세스 그룹 식별자, "
":const:`PRIO_USER` 면 사용자 ID). 0 값의 *who*\\는 (각각) 호출하는 프로세스, 호출하는 프로세스의 "
"프로세스 그룹, 호출하는 프로세스의 실제 사용자 ID를 나타냅니다."

#: ../../library/os.rst:490 ../../library/os.rst:502
msgid "Parameters for the :func:`getpriority` and :func:`setpriority` functions."
msgstr ":func:`getpriority` 와 :func:`setpriority` 함수의 매개 변숫값"

#: ../../library/os.rst:510
msgid ""
"Return a tuple (ruid, euid, suid) denoting the current process's real, "
"effective, and saved user ids."
msgstr ""
"현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 사용자 ID를 나타내는 튜플 (ruid, "
"euid, suid)를 반환합니다."

#: ../../library/os.rst:520
msgid ""
"Return a tuple (rgid, egid, sgid) denoting the current process's real, "
"effective, and saved group ids."
msgstr ""
"현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 그룹 ID를 나타내는 튜플 (rgid, egid,"
" sgid)를 반환합니다."

#: ../../library/os.rst:532
msgid "Return the current process's real user id."
msgstr "현재 프로세스의 실제(real) 사용자 ID를 반환합니다."

#: ../../library/os.rst:542
msgid ""
"Call the system initgroups() to initialize the group access list with all"
" of the groups of which the specified username is a member, plus the "
"specified group id."
msgstr ""
"지정된 사용자 이름이 구성원인 모든 그룹과 지정된 그룹 ID로 구성된 그룹 액세스 목록을 초기화하기 위해 시스템 "
"initgroups()를 호출합니다."

#: ../../library/os.rst:555
msgid ""
"Set the environment variable named *key* to the string *value*.  Such "
"changes to the environment affect subprocesses started with "
":func:`os.system`, :func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"*key* 라는 환경 변수를 문자열 *value* 로 설정합니다. 이러한 환경의 변화는 :func:`os.system`, "
":func:`popen` 또는 :func:`fork` 및 :func:`execv`\\로 시작된 자식 프로세스에 영향을 줍니다."

#: ../../library/os.rst:559
#, fuzzy
msgid ""
"Assignments to items in :data:`os.environ` are automatically translated "
"into corresponding calls to :func:`putenv`; however, calls to "
":func:`putenv` don't update :data:`os.environ`, so it is actually "
"preferable to assign to items of :data:`os.environ`. This also applies to"
" :func:`getenv` and :func:`getenvb`, which respectively use "
":data:`os.environ` and :data:`os.environb` in their implementations."
msgstr ""
"``os.environ``\\의 항목에 대한 대입은 :func:`putenv`\\에 대한 해당 호출로 자동 변환됩니다; 그러나, "
":func:`putenv`\\에 대한 호출은 ``os.environ``\\을 업데이트하지 않아서, 실제로 "
"``os.environ``\\의 항목에 대입하는 것이 좋습니다."

#: ../../library/os.rst:567
#, fuzzy
msgid ""
"On some platforms, including FreeBSD and macOS, setting ``environ`` may "
"cause memory leaks. Refer to the system documentation for "
":c:func:`!putenv`."
msgstr ""
"FreeBSD 및 맥 OS X를 포함한 일부 플랫폼에서, ``environ``\\을 설정하면 메모리 누수가 발생할 수 있습니다. "
":c:func:`putenv`\\에 대한 시스템 설명서를 참조하십시오."

#: ../../library/os.rst:570
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.putenv`` with arguments "
"``key``, ``value``."
msgstr ""
"``key``, ``value``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.putenv``\\를 발생시킵니다."

#: ../../library/os.rst:572
msgid "The function is now always available."
msgstr "이 함수는 이제 항상 사용할 수 있습니다."

#: ../../library/os.rst:578
msgid "Set the current process's effective group id."
msgstr "현재 프로세스의 유효 그룹 ID를 설정합니다."

#: ../../library/os.rst:585
msgid "Set the current process's effective user id."
msgstr "현재 프로세스의 유효 사용자 ID를 설정합니다."

#: ../../library/os.rst:592
msgid "Set the current process' group id."
msgstr "현재 프로세스의 그룹 ID를 설정합니다."

#: ../../library/os.rst:599
msgid ""
"Set the list of supplemental group ids associated with the current "
"process to *groups*. *groups* must be a sequence, and each element must "
"be an integer identifying a group. This operation is typically available "
"only to the superuser."
msgstr ""
"현재 프로세스와 연관된 보충(supplemental) 그룹 ID의 목록을 *groups*\\로 설정합니다. *groups* 는 "
"시퀀스 여야 하며, 각 요소는 그룹을 식별하는 정수여야 합니다. 이 연산은 대개 슈퍼 유저만 사용할 수 있습니다."

#: ../../library/os.rst:605
#, fuzzy
msgid ""
"On macOS, the length of *groups* may not exceed the system-defined "
"maximum number of effective group ids, typically 16. See the "
"documentation for :func:`getgroups` for cases where it may not return the"
" same group list set by calling setgroups()."
msgstr ""
"맥 OS X에서 *groups* 의 길이는 시스템이 정의한 최대 유효 그룹 ID 수(일반적으로 16)를 초과할 수 없습니다. "
"setgroups()를 호출해서 설정한 것과 같은 그룹 목록을 반환하지 않는 경우에 관해서는 :func:`getgroups` "
"설명서를 참조하십시오."

#: ../../library/os.rst:612
msgid ""
"Reassociate the current thread with a Linux namespace. See the "
":manpage:`setns(2)` and :manpage:`namespaces(7)` man pages for more "
"details."
msgstr ""

#: ../../library/os.rst:616
#, python-brace-format
msgid ""
"If *fd* refers to a :file:`/proc/{pid}/ns/` link, ``setns()`` "
"reassociates the calling thread with the namespace associated with that "
"link, and *nstype* may be set to one of the :ref:`CLONE_NEW* constants "
"<os-unshare-clone-flags>` to impose constraints on the operation (``0`` "
"means no constraints)."
msgstr ""

#: ../../library/os.rst:623
msgid ""
"Since Linux 5.8, *fd* may refer to a PID file descriptor obtained from "
":func:`~os.pidfd_open`. In this case, ``setns()`` reassociates the "
"calling thread into one or more of the same namespaces as the thread "
"referred to by *fd*. This is subject to any constraints imposed by "
"*nstype*, which is a bit mask combining one or more of the "
":ref:`CLONE_NEW* constants <os-unshare-clone-flags>`, e.g. ``setns(fd, "
"os.CLONE_NEWUTS | os.CLONE_NEWPID)``. The caller's memberships in "
"unspecified namespaces are left unchanged."
msgstr ""

#: ../../library/os.rst:632
msgid ""
"*fd* can be any object with a :meth:`~io.IOBase.fileno` method, or a raw "
"file descriptor."
msgstr ""

#: ../../library/os.rst:634
msgid ""
"This example reassociates the thread with the ``init`` process's network "
"namespace::"
msgstr ""

#: ../../library/os.rst:636
msgid ""
"fd = os.open(\"/proc/1/ns/net\", os.O_RDONLY)\n"
"os.setns(fd, os.CLONE_NEWNET)\n"
"os.close(fd)"
msgstr ""

#: ../../library/os.rst:646
#, fuzzy
msgid "The :func:`~os.unshare` function."
msgstr ":func:`.stat` 함수."

#: ../../library/os.rst:650
#, fuzzy
msgid ""
"Call the system call :c:func:`!setpgrp` or ``setpgrp(0, 0)`` depending on"
" which version is implemented (if any).  See the Unix manual for the "
"semantics."
msgstr ""
"구현된 (있기는 하다면) 버전에 따라 시스템 호출 :c:func:`setpgrp` 나 ``setpgrp(0, 0)``\\을 "
"호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../../library/os.rst:658
#, fuzzy
msgid ""
"Call the system call :c:func:`!setpgid` to set the process group id of "
"the process with id *pid* to the process group with id *pgrp*.  See the "
"Unix manual for the semantics."
msgstr ""
"프로세스 ID가 *pid* 인 프로세스의 프로세스 그룹 ID를 *pgrp* 로 설정하기 위해 시스템 호출 "
":c:func:`setpgid`\\를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../../library/os.rst:669
msgid ""
"Set program scheduling priority. The value *which* is one of "
":const:`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and "
"*who* is interpreted relative to *which* (a process identifier for "
":const:`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, "
"and a user ID for :const:`PRIO_USER`). A zero value for *who* denotes "
"(respectively) the calling process, the process group of the calling "
"process, or the real user ID of the calling process. *priority* is a "
"value in the range -20 to 19. The default priority is 0; lower priorities"
" cause more favorable scheduling."
msgstr ""
"프로그램 스케줄 우선순위를 설정합니다. *which* 값은 :const:`PRIO_PROCESS`, "
":const:`PRIO_PGRP` 또는 :const:`PRIO_USER` 중 하나이고, *who*\\는 *which* 에 상대적으로"
" 해석됩니다 (:const:`PRIO_PROCESS` 면 프로세스 식별자, :const:`PRIO_PGRP` 면 프로세스 그룹 "
"식별자, :const:`PRIO_USER` 면 사용자 ID). 0 값의 *who*\\는 (각각) 호출하는 프로세스, 호출하는 "
"프로세스의 프로세스 그룹, 호출하는 프로세스의 실제 사용자 ID를 나타냅니다. *priority* 는 -20에서 19 사이의 "
"값입니다. 기본 우선순위는 0입니다; 우선순위가 낮으면 더 유리하게 스케줄 됩니다."

#: ../../library/os.rst:686
msgid "Set the current process's real and effective group ids."
msgstr "현재 프로세스의 실제(real) 및 유효한(effective) 그룹 ID를 설정합니다."

#: ../../library/os.rst:693
msgid "Set the current process's real, effective, and saved group ids."
msgstr "현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 그룹 ID를 설정합니다."

#: ../../library/os.rst:702
msgid "Set the current process's real, effective, and saved user ids."
msgstr "현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 사용자 ID를 설정합니다."

#: ../../library/os.rst:711
msgid "Set the current process's real and effective user ids."
msgstr "현재 프로세스의 실제(real) 및 유효(effective) 사용자 ID를 설정합니다."

#: ../../library/os.rst:718
#, fuzzy
msgid ""
"Call the system call :c:func:`!getsid`.  See the Unix manual for the "
"semantics."
msgstr "시스템 호출 :c:func:`getsid`\\를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../../library/os.rst:725
#, fuzzy
msgid ""
"Call the system call :c:func:`!setsid`.  See the Unix manual for the "
"semantics."
msgstr "시스템 호출 :c:func:`setsid`\\를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../../library/os.rst:734
msgid "Set the current process's user id."
msgstr "현재 프로세스의 사용자 ID를 설정합니다."

#: ../../library/os.rst:742
#, fuzzy
msgid ""
"Return the error message corresponding to the error code in *code*. On "
"platforms where :c:func:`!strerror` returns ``NULL`` when given an "
"unknown error number, :exc:`ValueError` is raised."
msgstr ""
"에러 코드 *code*\\에 해당하는 에러 메시지를 반환합니다. 알 수 없는 에러 코드가 주어질 때 "
":c:func:`strerror`\\가 ``NULL``\\을 반환하는 플랫폼에서, :exc:`ValueError`\\가 발생합니다."

#: ../../library/os.rst:749
msgid ""
"``True`` if the native OS type of the environment is bytes (eg. ``False``"
" on Windows)."
msgstr "환경의 원시 OS 형이 바이트열이면 ``True`` (예를 들어, 윈도우에서는 ``False``)."

#: ../../library/os.rst:757
msgid "Set the current numeric umask and return the previous umask."
msgstr "현재 숫자 umask를 설정하고 이전 umask를 반환합니다."

#: ../../library/os.rst:769
msgid ""
"Returns information identifying the current operating system. The return "
"value is an object with five attributes:"
msgstr "현재 운영 체제를 식별하는 정보를 반환합니다. 반환 값은 5가지 어트리뷰트를 가진 객체입니다:"

#: ../../library/os.rst:772
msgid ":attr:`sysname` - operating system name"
msgstr ":attr:`sysname` - 운영 체제 이름"

#: ../../library/os.rst:773
msgid ":attr:`nodename` - name of machine on network (implementation-defined)"
msgstr ":attr:`nodename` - 네트워크상의 기계 이름 (구현이 정의)"

#: ../../library/os.rst:774
msgid ":attr:`release` - operating system release"
msgstr ":attr:`release` - 운영 체제 릴리스"

#: ../../library/os.rst:775
msgid ":attr:`version` - operating system version"
msgstr ":attr:`version` - 운영 체제 버전"

#: ../../library/os.rst:776
msgid ":attr:`machine` - hardware identifier"
msgstr ":attr:`machine` - 하드웨어 식별자"

#: ../../library/os.rst:778
msgid ""
"For backwards compatibility, this object is also iterable, behaving like "
"a five-tuple containing :attr:`sysname`, :attr:`nodename`, "
":attr:`release`, :attr:`version`, and :attr:`machine` in that order."
msgstr ""
"하위 호환성을 위해, 이 객체는 이터러블이기도 해서, :attr:`sysname`, :attr:`nodename`, "
":attr:`release`, :attr:`version` 및 :attr:`machine`\\이 이 순서로 포함된 5-튜플처럼 "
"작동합니다."

#: ../../library/os.rst:783
msgid ""
"Some systems truncate :attr:`nodename` to 8 characters or to the leading "
"component; a better way to get the hostname is :func:`socket.gethostname`"
"  or even ``socket.gethostbyaddr(socket.gethostname())``."
msgstr ""
"일부 시스템에서는 :attr:`nodename`\\을 8자나 선행 구성 요소로 자릅니다; 호스트 이름을 얻는 더 좋은 방법은 "
":func:`socket.gethostname` 또는 더 나아가 "
"``socket.gethostbyaddr(socket.gethostname())``\\입니다."

#: ../../library/os.rst:788
msgid ""
"On macOS, iOS and Android, this returns the *kernel* name and version "
"(i.e., ``'Darwin'`` on macOS and iOS; ``'Linux'`` on Android). "
":func:`platform.uname` can be used to get the user-facing operating "
"system name and version on iOS and Android."
msgstr ""

#: ../../library/os.rst:795 ../../library/os.rst:5002
msgid ""
"Return type changed from a tuple to a tuple-like object with named "
"attributes."
msgstr "반환형이 튜플에서 이름이 지정된 어트리뷰트를 가진 튜플류 객체로 변경되었습니다."

#: ../../library/os.rst:804
msgid ""
"Unset (delete) the environment variable named *key*. Such changes to the "
"environment affect subprocesses started with :func:`os.system`, "
":func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"*key* 라는 이름의 환경 변수를 삭제합니다. 이러한 환경 변화는 :func:`os.system`, :func:`popen` 또는"
" :func:`fork` 및 :func:`execv`\\로 시작된 자식 프로세스에 영향을 줍니다."

#: ../../library/os.rst:808
#, fuzzy
msgid ""
"Deletion of items in :data:`os.environ` is automatically translated into "
"a corresponding call to :func:`unsetenv`; however, calls to "
":func:`unsetenv` don't update :data:`os.environ`, so it is actually "
"preferable to delete items of :data:`os.environ`."
msgstr ""
"``os.environ``\\에서의 항목 삭제는 :func:`unsetenv`\\에 대한 해당 호출로 자동 변환됩니다; 그러나, "
":func:`unsetenv`\\에 대한 호출은 ``os.environ``\\을 갱신하지 않아서, 실제로 "
"``os.environ``\\의 항목을 삭제하는 것이 좋습니다."

#: ../../library/os.rst:813
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.unsetenv`` with argument "
"``key``."
msgstr ""
"``key``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.unsetenv``\\를 발생시킵니다."

#: ../../library/os.rst:815
msgid "The function is now always available and is also available on Windows."
msgstr "이 함수는 이제 항상 사용할 수 있고 윈도우에서도 사용할 수 있습니다."

#: ../../library/os.rst:821
msgid ""
"Disassociate parts of the process execution context, and move them into a"
" newly created namespace. See the :manpage:`unshare(2)` man page for more"
" details. The *flags* argument is a bit mask, combining zero or more of "
"the :ref:`CLONE_* constants <os-unshare-clone-flags>`, that specifies "
"which parts of the execution context should be unshared from their "
"existing associations and moved to a new namespace. If the *flags* "
"argument is ``0``, no changes are made to the calling process's execution"
" context."
msgstr ""

#: ../../library/os.rst:838
#, fuzzy
msgid "The :func:`~os.setns` function."
msgstr ":func:`.stat` 함수."

#: ../../library/os.rst:842
msgid ""
"Flags to the :func:`unshare` function, if the implementation supports "
"them. See :manpage:`unshare(2)` in the Linux manual for their exact "
"effect and availability."
msgstr ""

#: ../../library/os.rst:865
msgid "File Object Creation"
msgstr "파일 객체 생성"

#: ../../library/os.rst:867
msgid ""
"These functions create new :term:`file objects <file object>`.  (See also"
" :func:`~os.open` for opening file descriptors.)"
msgstr ""
"이 함수들은 새로운 :term:`파일 객체 <file object>`\\를 만듭니다. (파일 기술자를 여는 것에 관해서는 "
":func:`~os.open`\\를 참조하십시오.)"

#: ../../library/os.rst:873
msgid ""
"Return an open file object connected to the file descriptor *fd*.  This "
"is an alias of the :func:`open` built-in function and accepts the same "
"arguments. The only difference is that the first argument of "
":func:`fdopen` must always be an integer."
msgstr ""
"파일 기술자 *fd에* 연결된 열린 파일 객체를 반환합니다. 이것은 :func:`open` 내장 함수의 별칭이며 같은 인자를 "
"받아들입니다. 유일한 차이점은 :func:`fdopen`\\의 첫 번째 인자는 항상 정수여야 한다는 것입니다."

#: ../../library/os.rst:882
msgid "File Descriptor Operations"
msgstr "파일 기술자 연산"

#: ../../library/os.rst:884
msgid "These functions operate on I/O streams referenced using file descriptors."
msgstr "이 함수들은 파일 기술자를 사용하여 참조된 I/O 스트림에 작용합니다."

#: ../../library/os.rst:886
msgid ""
"File descriptors are small integers corresponding to a file that has been"
" opened by the current process.  For example, standard input is usually "
"file descriptor 0, standard output is 1, and standard error is 2.  "
"Further files opened by a process will then be assigned 3, 4, 5, and so "
"forth.  The name \"file descriptor\" is slightly deceptive; on Unix "
"platforms, sockets and pipes are also referenced by file descriptors."
msgstr ""
"파일 기술자는 현재 프로세스에 의해 열린 파일에 대응하는 작은 정수입니다. 예를 들어, 표준 입력은 보통 파일 기술자 0이고, 표준"
" 출력은 1이며, 표준 에러는 2입니다. 프로세스에 의해 열린 추가 파일은 3, 4, 5 등으로 지정됩니다. \"파일 기술자\"라는"
" 이름은 약간 기만적입니다; 유닉스 플랫폼에서, 소켓과 파이프도 파일 기술자에 의해 참조됩니다."

#: ../../library/os.rst:893
msgid ""
"The :meth:`~io.IOBase.fileno` method can be used to obtain the file "
"descriptor associated with a :term:`file object` when required.  Note "
"that using the file descriptor directly will bypass the file object "
"methods, ignoring aspects such as internal buffering of data."
msgstr ""
":meth:`~io.IOBase.fileno` 메서드는 필요할 때 :term:`파일 객체 <file object>`\\와 연관된 "
"파일 기술자를 얻는 데 사용될 수 있습니다. 파일 기술자를 직접 사용하면 파일 객체 메서드를 거치지 않아서, 데이터의 내부 버퍼링과"
" 같은 측면을 무시하게 되는 것에 유의하십시오."

#: ../../library/os.rst:901
msgid "Close file descriptor *fd*."
msgstr "파일 기술자 *fd*\\를 닫습니다."

#: ../../library/os.rst:905
msgid ""
"This function is intended for low-level I/O and must be applied to a file"
" descriptor as returned by :func:`os.open` or :func:`pipe`.  To close a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, use its :meth:`~io.IOBase.close` method."
msgstr ""
"이 함수는 저수준 I/O를 위한 것이며, :func:`os.open` 또는 :func:`pipe`\\에 의해 반환된 파일 기술자에 "
"적용되어야 합니다. 내장 함수 :func:`open` 나 :func:`popen` 또는 :func:`fdopen`\\에 의해 반환된"
" \"파일 객체\"를 닫으려면, :meth:`~io.IOBase.close` 메서드를 사용하십시오."

#: ../../library/os.rst:913
msgid ""
"Close all file descriptors from *fd_low* (inclusive) to *fd_high* "
"(exclusive), ignoring errors. Equivalent to (but much faster than)::"
msgstr ""
"에러는 무시하면서, *fd_low*\\(포함)부터 *fd_high*\\(제외)까지 모든 파일 기술자를 닫습니다. 다음과 동등합니다 "
"(하지만 훨씬 빠릅니다)::"

#: ../../library/os.rst:916
msgid ""
"for fd in range(fd_low, fd_high):\n"
"    try:\n"
"        os.close(fd)\n"
"    except OSError:\n"
"        pass"
msgstr ""

#: ../../library/os.rst:925
#, fuzzy
msgid ""
"Copy *count* bytes from file descriptor *src*, starting from offset "
"*offset_src*, to file descriptor *dst*, starting from offset "
"*offset_dst*. If *offset_src* is ``None``, then *src* is read from the "
"current position; respectively for *offset_dst*."
msgstr ""
"*count* 바이트를 파일 기술자 *src*\\(오프셋 *offset_src*\\에서 시작하여)에서 파일 기술자 "
"*dst*\\(오프셋 *offset_dst*\\에서 시작하여)로 복사합니다. *offset_src*\\가 None이면, 현재 "
"위치에서 *src*\\를 읽습니다; *offset_dst*\\도 마찬가지입니다. *src*\\와 *dst*\\가 가리키는 파일은 "
"같은 파일 시스템에 있어야 합니다, 그렇지 않으면 :data:`errno.EXDEV`\\로 설정된 "
":attr:`~OSError.errno`\\로 :exc:`OSError`\\가 발생합니다."

#: ../../library/os.rst:930
msgid ""
"In Linux kernel older than 5.3, the files pointed to by *src* and *dst* "
"must reside in the same filesystem, otherwise an :exc:`OSError` is raised"
" with :attr:`~OSError.errno` set to :const:`errno.EXDEV`."
msgstr ""

#: ../../library/os.rst:934
#, fuzzy
msgid ""
"This copy is done without the additional cost of transferring data from "
"the kernel to user space and then back into the kernel. Additionally, "
"some filesystems could implement extra optimizations, such as the use of "
"reflinks (i.e., two or more inodes that share pointers to the same copy-"
"on-write disk blocks; supported file systems include btrfs and XFS) and "
"server-side copy (in the case of NFS)."
msgstr ""
"이 복사는 커널에서 사용자 공간으로 데이터를 전송한 다음 다시 커널로 전송하는 추가 비용 없이 수행됩니다. 또한, 일부 파일 "
"시스템은 추가 최적화를 구현할 수 있습니다. 두 파일이 바이너리로 열린 것처럼 복사가 수행됩니다."

#: ../../library/os.rst:941
msgid ""
"The function copies bytes between two file descriptors. Text options, "
"like the encoding and the line ending, are ignored."
msgstr ""

#: ../../library/os.rst:944
msgid ""
"The return value is the amount of bytes copied. This could be less than "
"the amount requested."
msgstr "반환 값은 복사된 바이트의 양입니다. 이것은 요구된 양보다 적을 수 있습니다."

#: ../../library/os.rst:949
msgid ""
"On Linux, :func:`os.copy_file_range` should not be used for copying a "
"range of a pseudo file from a special filesystem like procfs and sysfs. "
"It will always copy no bytes and return 0 as if the file was empty "
"because of a known Linux kernel issue."
msgstr ""

#: ../../library/os.rst:961
msgid ""
"Return a string describing the encoding of the device associated with "
"*fd* if it is connected to a terminal; else return :const:`None`."
msgstr ""
"*fd* 와 연관된 장치가 터미널에 연결되어 있을 때 인코딩을 설명하는 문자열을 반환합니다; 그렇지 않으면 "
":const:`None`\\을 반환합니다."

#: ../../library/os.rst:964
msgid ""
"On Unix, if the :ref:`Python UTF-8 Mode <utf8-mode>` is enabled, return "
"``'UTF-8'`` rather than the device encoding."
msgstr ""

#: ../../library/os.rst:967
msgid "On Unix, the function now implements the Python UTF-8 Mode."
msgstr ""

#: ../../library/os.rst:973
msgid ""
"Return a duplicate of file descriptor *fd*. The new file descriptor is "
":ref:`non-inheritable <fd_inheritance>`."
msgstr "파일 기술자 *fd* 의 복사본을 반환합니다. 새 파일 기술자는 :ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/os.rst:976
msgid ""
"On Windows, when duplicating a standard stream (0: stdin, 1: stdout, 2: "
"stderr), the new file descriptor is :ref:`inheritable <fd_inheritance>`."
msgstr ""
"윈도우에서는, 표준 스트림(0: stdin, 1: stdout, 2: stderr)을 복제할 때, 새 파일 기술자가 :ref:`상속"
" 가능 <fd_inheritance>`\\합니다."

#: ../../library/os.rst:982 ../../library/os.rst:1267
msgid "The new file descriptor is now non-inheritable."
msgstr "새로운 파일 기술자는 이제 상속 불가능합니다."

#: ../../library/os.rst:988
msgid ""
"Duplicate file descriptor *fd* to *fd2*, closing the latter first if "
"necessary. Return *fd2*. The new file descriptor is :ref:`inheritable "
"<fd_inheritance>` by default or non-inheritable if *inheritable* is "
"``False``."
msgstr ""
"파일 기술자 *fd* 를 *fd2*\\에 복제하고, 필요하면 먼저 후자를 닫습니다. *fd2*\\를 반환합니다. 새로운 파일 "
"기술자는 기본적으로 :ref:`상속 가능 <fd_inheritance>`\\하고, *inheritable* 이 "
"``False``\\면 상속 불가능합니다."

#: ../../library/os.rst:995
msgid "Add the optional *inheritable* parameter."
msgstr "선택적 *inheritable* 매개 변수를 추가했습니다."

#: ../../library/os.rst:998
msgid "Return *fd2* on success. Previously, ``None`` was always returned."
msgstr "성공하면 *fd2* 를 반환합니다. 이전에는 항상 ``None``\\을 반환했습니다."

#: ../../library/os.rst:1004
msgid ""
"Change the mode of the file given by *fd* to the numeric *mode*.  See the"
" docs for :func:`chmod` for possible values of *mode*.  As of Python 3.3,"
" this is equivalent to ``os.chmod(fd, mode)``."
msgstr ""
"*fd* 에 의해 주어진 파일의 모드를 숫자 *mode* 로 변경합니다. *mode*\\의 가능한 값은 :func:`chmod` "
"문서를 참조하십시오. 파이썬 3.3부터는, ``os.chmod(fd, mode)``\\와 같습니다."

#: ../../library/os.rst:1008 ../../library/os.rst:2137
#: ../../library/os.rst:2238
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chmod`` with arguments "
"``path``, ``mode``, ``dir_fd``."
msgstr ""
"``path``, ``mode``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``os.chmod``\\를 발생시킵니다."

#: ../../library/os.rst:1012 ../../library/os.rst:1030
#: ../../library/os.rst:1121 ../../library/os.rst:1706
#: ../../library/os.rst:2134 ../../library/os.rst:2167
#: ../../library/os.rst:3459
msgid ""
"The function is limited on WASI, see :ref:`wasm-availability` for more "
"information."
msgstr ""

#: ../../library/os.rst:1015 ../../library/os.rst:2245
#, fuzzy
msgid "Added support on Windows."
msgstr "윈도우에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:1021
msgid ""
"Change the owner and group id of the file given by *fd* to the numeric "
"*uid* and *gid*.  To leave one of the ids unchanged, set it to -1.  See "
":func:`chown`.  As of Python 3.3, this is equivalent to ``os.chown(fd, "
"uid, gid)``."
msgstr ""
"*fd* 에 의해 주어진 파일의 소유자와 그룹 id를 숫자 *uid* 와 *gid*\\로 변경합니다. ID 중 하나를 변경하지 "
"않으려면, 그것을 -1로 설정하십시오. :func:`chown`\\를 참조하십시오. 파이썬 3.3부터는, ``os.chown(fd,"
" uid, gid)``\\와 같습니다."

#: ../../library/os.rst:1026 ../../library/os.rst:2163
#: ../../library/os.rst:2254
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chown`` with arguments "
"``path``, ``uid``, ``gid``, ``dir_fd``."
msgstr ""
"``path``, ``uid``, ``gid``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing "
"event) <auditing>` ``os.chown``\\을 발생시킵니다."

#: ../../library/os.rst:1036
msgid ""
"Force write of file with filedescriptor *fd* to disk. Does not force "
"update of metadata."
msgstr "파일 기술자 *fd* 로 주어진 파일을 디스크에 쓰도록 강제합니다. 메타 데이터를 갱신하도록 강제하지 않습니다."

#: ../../library/os.rst:1042
msgid "This function is not available on MacOS."
msgstr "이 함수는 MacOS에서는 사용할 수 없습니다."

#: ../../library/os.rst:1047
msgid ""
"Return system configuration information relevant to an open file. *name* "
"specifies the configuration value to retrieve; it may be a string which "
"is the name of a defined system value; these names are specified in a "
"number of standards (POSIX.1, Unix 95, Unix 98, and others).  Some "
"platforms define additional names as well.  The names known to the host "
"operating system are given in the ``pathconf_names`` dictionary.  For "
"configuration variables not included in that mapping, passing an integer "
"for *name* is also accepted."
msgstr ""
"열린 파일과 관련된 시스템 구성 정보를 반환합니다. *name* 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 "
"문자열일 수 있습니다; 이 이름은 여러 표준(POSIX.1, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 "
"추가 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 ``pathconf_names`` 딕셔너리에서 제공됩니다. 이 매핑에 "
"포함되지 않은 구성 변수의 경우, *name*\\에 정수를 전달하는 것도 허용됩니다."

#: ../../library/os.rst:1055 ../../library/os.rst:2573
msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If "
"a specific value for *name* is not supported by the host system, even if "
"it is included in ``pathconf_names``, an :exc:`OSError` is raised with "
":const:`errno.EINVAL` for the error number."
msgstr ""
"*name* 이 문자열이고 알 수 없으면, :exc:`ValueError`\\가 발생합니다. *name*\\에 대한 특정 값이 "
"호스트 시스템에서 지원되지 않으면, ``pathconf_names``\\에 포함되어 있어도, 에러 번호가 "
":const:`errno.EINVAL`\\인 :exc:`OSError`\\가 발생합니다."

#: ../../library/os.rst:1060
msgid "As of Python 3.3, this is equivalent to ``os.pathconf(fd, name)``."
msgstr "파이썬 3.3부터, ``os.pathconf(fd, name)``\\과 같습니다."

#: ../../library/os.rst:1067
msgid ""
"Get the status of the file descriptor *fd*. Return a :class:`stat_result`"
" object."
msgstr "파일 기술자 *fd* 의 상태를 가져옵니다. :class:`stat_result` 객체를 반환합니다."

#: ../../library/os.rst:1070
msgid "As of Python 3.3, this is equivalent to ``os.stat(fd)``."
msgstr "파이썬 3.3부터는, ``os.stat(fd)``\\와 같습니다."

#: ../../library/os.rst:1074 ../../library/os.rst:2401
msgid "The :func:`.stat` function."
msgstr ":func:`.stat` 함수."

#: ../../library/os.rst:1079
msgid ""
"Return information about the filesystem containing the file associated "
"with file descriptor *fd*, like :func:`statvfs`.  As of Python 3.3, this "
"is equivalent to ``os.statvfs(fd)``."
msgstr ""
":func:`statvfs` 처럼, 파일 기술자 *fd* 와 연관된 파일을 포함하는 파일 시스템에 대한 정보를 반환합니다. 파이썬 "
"3.3부터는, ``os.statvfs(fd)``\\와 같습니다."

#: ../../library/os.rst:1088
#, fuzzy
msgid ""
"Force write of file with filedescriptor *fd* to disk.  On Unix, this "
"calls the native :c:func:`!fsync` function; on Windows, the MS "
":c:func:`!_commit` function."
msgstr ""
"파일 기술자 *fd* 의 파일을 디스크에 쓰도록 강제합니다. 유닉스에서는, 네이티브 :c:func:`fsync` 함수를 호출합니다;"
" 윈도우에서는, MS :c:func:`_commit` 함수."

#: ../../library/os.rst:1091
msgid ""
"If you're starting with a buffered Python :term:`file object` *f*, first "
"do ``f.flush()``, and then do ``os.fsync(f.fileno())``, to ensure that "
"all internal buffers associated with *f* are written to disk."
msgstr ""
"버퍼링 된 파이썬 :term:`파일 객체 <file object>` *f*\\로 시작하는 경우, *f* 와 연관된 모든 내부 버퍼가"
" 디스크에 기록되게 하려면, 먼저 ``f.flush()``\\를 수행한 다음 ``os.fsync(f.fileno())``\\를 "
"하십시오."

#: ../../library/os.rst:1100
msgid ""
"Truncate the file corresponding to file descriptor *fd*, so that it is at"
" most *length* bytes in size.  As of Python 3.3, this is equivalent to "
"``os.truncate(fd, length)``."
msgstr ""
"파일 기술자 *fd*\\에 해당하는 파일을 잘라내어 최대 *length* 바이트가 되도록 만듭니다. 파이썬 3.3부터는, "
"``os.truncate(fd, length)``\\와 같습니다."

#: ../../library/os.rst:1104
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.truncate`` with arguments"
" ``fd``, ``length``."
msgstr ""
"``fd``, ``length``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.truncate``\\를 발생시킵니다."

#: ../../library/os.rst:1108 ../../library/os.rst:3498
msgid "Added support for Windows"
msgstr "윈도우 지원 추가"

#: ../../library/os.rst:1114
msgid ""
"Get the blocking mode of the file descriptor: ``False`` if the "
":data:`O_NONBLOCK` flag is set, ``True`` if the flag is cleared."
msgstr ""
"파일 기술자의 블로킹 모드를 얻어옵니다: :data:`O_NONBLOCK` 플래그가 설정되었으면 ``False``, 플래그가 "
"지워졌으면 ``True``."

#: ../../library/os.rst:1117
msgid "See also :func:`set_blocking` and :meth:`socket.socket.setblocking`."
msgstr ":func:`set_blocking` 및 :meth:`socket.socket.setblocking`\\도 참조하십시오."

#: ../../library/os.rst:1124 ../../library/os.rst:1709
msgid "On Windows, this function is limited to pipes."
msgstr ""

#: ../../library/os.rst:1128 ../../library/os.rst:1713
#, fuzzy
msgid "Added support for pipes on Windows."
msgstr "윈도우에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:1134
msgid ""
"Grant access to the slave pseudo-terminal device associated with the "
"master pseudo-terminal device to which the file descriptor *fd* refers. "
"The file descriptor *fd* is not closed upon failure."
msgstr ""

#: ../../library/os.rst:1138
msgid "Calls the C standard library function :c:func:`grantpt`."
msgstr ""

#: ../../library/os.rst:1147
msgid ""
"Return ``True`` if the file descriptor *fd* is open and connected to a "
"tty(-like) device, else ``False``."
msgstr ""
"파일 기술자 *fd* 가 열려 있고 tty(류의) 장치에 연결되어 있으면 ``True``\\를 반환하고, 그렇지 않으면 "
"``False``\\를 반환합니다."

#: ../../library/os.rst:1153
msgid ""
"Apply, test or remove a POSIX lock on an open file descriptor. *fd* is an"
" open file descriptor. *cmd* specifies the command to use - one of "
":data:`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` or :data:`F_TEST`. *len*"
" specifies the section of the file to lock."
msgstr ""
"열린 파일 기술자에 POSIX 록을 적용, 검사 또는 제거합니다. *fd* 는 열린 파일 기술자입니다. *cmd* 는 사용할 명령을"
" 지정합니다 - :data:`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` 또는 "
":data:`F_TEST` 중 하나. *len* 은 잠글 파일의 영역을 지정합니다."

#: ../../library/os.rst:1159
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.lockf`` with arguments "
"``fd``, ``cmd``, ``len``."
msgstr ""
"``fd``, ``cmd``, ``len``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.lockf``\\를 발생시킵니다."

#: ../../library/os.rst:1171
msgid "Flags that specify what action :func:`lockf` will take."
msgstr ":func:`lockf`\\가 취할 조치를 지정하는 플래그."

#: ../../library/os.rst:1180
msgid ""
"Prepare the tty of which fd is a file descriptor for a new login session."
" Make the calling process a session leader; make the tty the controlling "
"tty, the stdin, the stdout, and the stderr of the calling process; close "
"fd."
msgstr ""

#: ../../library/os.rst:1191
msgid ""
"Set the current position of file descriptor *fd* to position *pos*, "
"modified by *whence*, and return the new position in bytes relative to "
"the start of the file. Valid values for *whence* are:"
msgstr ""

#: ../../library/os.rst:1196
msgid ""
":const:`SEEK_SET` or ``0`` -- set *pos* relative to the beginning of the "
"file"
msgstr ""

#: ../../library/os.rst:1197
msgid ""
":const:`SEEK_CUR` or ``1`` -- set *pos* relative to the current file "
"position"
msgstr ""

#: ../../library/os.rst:1198
msgid ":const:`SEEK_END` or ``2`` -- set *pos* relative to the end of the file"
msgstr ""

#: ../../library/os.rst:1199
msgid ""
":const:`SEEK_HOLE` -- set *pos* to the next data location, relative to "
"*pos*"
msgstr ""

#: ../../library/os.rst:1200
msgid ":const:`SEEK_DATA` -- set *pos* to the next data hole, relative to *pos*"
msgstr ""

#: ../../library/os.rst:1204
msgid "Add support for :const:`!SEEK_HOLE` and :const:`!SEEK_DATA`."
msgstr ""

#: ../../library/os.rst:1211
msgid ""
"Parameters to the :func:`lseek` function and the :meth:`~io.IOBase.seek` "
"method on :term:`file-like objects <file object>`, for whence to adjust "
"the file position indicator."
msgstr ""

#: ../../library/os.rst:1215
msgid ":const:`SEEK_SET`"
msgstr ""

#: ../../library/os.rst:1216
msgid "Adjust the file position relative to the beginning of the file."
msgstr ""

#: ../../library/os.rst:1217
msgid ":const:`SEEK_CUR`"
msgstr ""

#: ../../library/os.rst:1218
msgid "Adjust the file position relative to the current file position."
msgstr ""

#: ../../library/os.rst:1219
msgid ":const:`SEEK_END`"
msgstr ""

#: ../../library/os.rst:1220
msgid "Adjust the file position relative to the end of the file."
msgstr ""

#: ../../library/os.rst:1222
#, fuzzy
msgid "Their values are 0, 1, and 2, respectively."
msgstr ":func:`lseek` 함수의 매개 변수. 값은 각각 0, 1, 2입니다."

#: ../../library/os.rst:1228
msgid ""
"Parameters to the :func:`lseek` function and the :meth:`~io.IOBase.seek` "
"method on :term:`file-like objects <file object>`, for seeking file data "
"and holes on sparsely allocated files."
msgstr ""

#: ../../library/os.rst:1232
#, fuzzy
msgid ":data:`!SEEK_DATA`"
msgstr ":data:`RWF_NOWAIT`"

#: ../../library/os.rst:1233
msgid ""
"Adjust the file offset to the next location containing data, relative to "
"the seek position."
msgstr ""

#: ../../library/os.rst:1236
#, fuzzy
msgid ":data:`!SEEK_HOLE`"
msgstr ":data:`stat.UF_OPAQUE`"

#: ../../library/os.rst:1237
msgid ""
"Adjust the file offset to the next location containing a hole, relative "
"to the seek position. A hole is defined as a sequence of zeros."
msgstr ""

#: ../../library/os.rst:1243
msgid "These operations only make sense for filesystems that support them."
msgstr ""

#: ../../library/os.rst:1252
msgid ""
"Open the file *path* and set various flags according to *flags* and "
"possibly its mode according to *mode*.  When computing *mode*, the "
"current umask value is first masked out.  Return the file descriptor for "
"the newly opened file. The new file descriptor is :ref:`non-inheritable "
"<fd_inheritance>`."
msgstr ""
"파일 *path*\\를 열고 *flags* 에 따른 다양한 플래그와 때로 *mode* 따른 모드를 설정합니다. *mode*\\를 "
"계산할 때, 현재 umask 값으로 먼저 마스킹합니다. 새롭게 열린 파일의 파일 기술자를 돌려줍니다. 새 파일 기술자는 "
":ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/os.rst:1257
msgid ""
"For a description of the flag and mode values, see the C run-time "
"documentation; flag constants (like :const:`O_RDONLY` and "
":const:`O_WRONLY`) are defined in the :mod:`os` module.  In particular, "
"on Windows adding :const:`O_BINARY` is needed to open files in binary "
"mode."
msgstr ""
"플래그와 모드 값에 대한 설명은, C 런타임 설명서를 참조하십시오; 플래그 상수(:const:`O_RDONLY` 와 "
":const:`O_WRONLY`\\와 같은)는 :mod:`os` 모듈에 정의되어 있습니다. 특히, 윈도우에서 바이너리 모드로 파일을"
" 열려면 :const:`O_BINARY`\\를 추가해야 합니다."

#: ../../library/os.rst:1262
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>` with the *dir_fd* parameter."
msgstr "이 함수는 *dir_fd* 매개 변수로 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 지원할 수 있습니다."

#: ../../library/os.rst:1265
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments "
"``path``, ``mode``, ``flags``."
msgstr ""
"``path``, ``mode``, ``flags``\\를 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``open``\\을 발생시킵니다."

#: ../../library/os.rst:1272
msgid ""
"This function is intended for low-level I/O.  For normal usage, use the "
"built-in function :func:`open`, which returns a :term:`file object` with "
":meth:`~file.read` and :meth:`~file.write` methods (and many more).  To "
"wrap a file descriptor in a file object, use :func:`fdopen`."
msgstr ""
"이 함수는 저수준 I/O를 위한 것입니다. 일반적인 사용을 위해서는 내장 함수 :func:`open`\\을 사용하십시오, 이 함수는"
" :meth:`~file.read` 및 :meth:`~file.write` 메서드(와 더 많은 메서드)가있는 :term:`파일 객체"
" <file object>`\\를 반환합니다. 파일 기술자를 파일 객체로 싸려면, :func:`fdopen`\\을 사용하십시오."

#: ../../library/os.rst:1277 ../../library/os.rst:2406
#: ../../library/os.rst:2446 ../../library/os.rst:2517
#: ../../library/os.rst:2539 ../../library/os.rst:2620
#: ../../library/os.rst:2650 ../../library/os.rst:2757
#: ../../library/os.rst:3514
msgid "Added the *dir_fd* parameter."
msgstr "*dir_fd* 매개 변수가 추가되었습니다."

#: ../../library/os.rst:1280 ../../library/os.rst:1631
#: ../../library/os.rst:1820 ../../library/os.rst:5098
msgid ""
"If the system call is interrupted and the signal handler does not raise "
"an exception, the function now retries the system call instead of raising"
" an :exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 함수는 이제 :exc:`InterruptedError` "
"예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 :pep:`475`\\를 참조하세요)."

#: ../../library/os.rst:1285 ../../library/os.rst:2030
#: ../../library/os.rst:2062 ../../library/os.rst:2093
#: ../../library/os.rst:2143 ../../library/os.rst:2184
#: ../../library/os.rst:2224 ../../library/os.rst:2242
#: ../../library/os.rst:2258 ../../library/os.rst:2317
#: ../../library/os.rst:2409 ../../library/os.rst:2449
#: ../../library/os.rst:2493 ../../library/os.rst:2520
#: ../../library/os.rst:2542 ../../library/os.rst:2583
#: ../../library/os.rst:2653 ../../library/os.rst:2672
#: ../../library/os.rst:2760 ../../library/os.rst:3050
#: ../../library/os.rst:3337 ../../library/os.rst:3501
#: ../../library/os.rst:3517 ../../library/os.rst:3557
#: ../../library/os.rst:3657 ../../library/os.rst:3718
#: ../../library/os.rst:4115 ../../library/os.rst:4295
#: ../../library/os.rst:4860
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/os.rst:1288
msgid ""
"The following constants are options for the *flags* parameter to the "
":func:`~os.open` function.  They can be combined using the bitwise OR "
"operator ``|``.  Some of them are not available on all platforms.  For "
"descriptions of their availability and use, consult the "
":manpage:`open(2)` manual page on Unix or `the MSDN "
"<https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx>`_ on Windows."
msgstr ""
"다음 상수는 :func:`~os.open` 함수에 대한 *flags* 매개 변수의 옵션입니다. 비트별 OR 연산자 ``|``\\를 "
"사용하여 결합할 수 있습니다. 일부는 모든 플랫폼에서 사용할 수는 없습니다. 가용성과 사용에 대한 설명은 유닉스의 "
":manpage:`open(2)` 매뉴얼 페이지 또는 윈도우의 `MSDN <https://msdn.microsoft.com/en-"
"us/library/z0kc8e3z.aspx>`_\\을 참조하십시오."

#: ../../library/os.rst:1303
msgid "The above constants are available on Unix and Windows."
msgstr "위의 상수는 유닉스 및 윈도우에서 사용할 수 있습니다."

#: ../../library/os.rst:1314
msgid "The above constants are only available on Unix."
msgstr "위의 상수는 유닉스에서만 사용할 수 있습니다."

#: ../../library/os.rst:1316
msgid "Add :data:`O_CLOEXEC` constant."
msgstr ":data:`O_CLOEXEC` 상수를 추가합니다."

#: ../../library/os.rst:1327
msgid "The above constants are only available on Windows."
msgstr "위의 상수는 윈도우에서만 사용할 수 있습니다."

#: ../../library/os.rst:1334
#, fuzzy
msgid "The above constants are only available on macOS."
msgstr "위의 상수는 윈도우에서만 사용할 수 있습니다."

#: ../../library/os.rst:1336
msgid ""
"Add :data:`O_EVTONLY`, :data:`O_FSYNC`, :data:`O_SYMLINK` and "
":data:`O_NOFOLLOW_ANY` constants."
msgstr ""

#: ../../library/os.rst:1350
msgid ""
"The above constants are extensions and not present if they are not "
"defined by the C library."
msgstr "위의 상수는 확장이며 C 라이브러리에서 정의하지 않으면 존재하지 않습니다."

#: ../../library/os.rst:1353
msgid ""
"Add :data:`O_PATH` on systems that support it. Add :data:`O_TMPFILE`, "
"only available on Linux Kernel 3.11   or newer."
msgstr ""
"지원하는 시스템에 :data:`O_PATH`\\를 추가합니다. 리눅스 커널 3.11 이상에서만 사용 가능한 "
":data:`O_TMPFILE`\\를 추가합니다."

#: ../../library/os.rst:1363
msgid ""
"Open a new pseudo-terminal pair. Return a pair of file descriptors "
"``(master, slave)`` for the pty and the tty, respectively. The new file "
"descriptors are :ref:`non-inheritable <fd_inheritance>`. For a (slightly)"
" more portable approach, use the :mod:`pty` module."
msgstr ""
"새로운 의사 터미널 쌍을 엽니다. 파일 기술자의 쌍 ``(master, slave)`` 를 반환하는데, 각각 pty와 tty "
"입니다. 새 파일 기술자는 :ref:`상속 불가능 <fd_inheritance>`\\합니다. (약간) 더 이식성 있는 접근 방식을 "
"사용하려면, :mod:`pty` 모듈을 사용하십시오."

#: ../../library/os.rst:1370 ../../library/os.rst:1382
msgid "The new file descriptors are now non-inheritable."
msgstr "새로운 파일 기술자는 이제 상속 불가능합니다."

#: ../../library/os.rst:1376
msgid ""
"Create a pipe.  Return a pair of file descriptors ``(r, w)`` usable for "
"reading and writing, respectively. The new file descriptor is :ref:`non-"
"inheritable <fd_inheritance>`."
msgstr ""
"파이프를 만듭니다. 파일 기술자 쌍 ``(r, w)`` 를 반환하는데, 각각 읽기와 쓰기에 사용할 수 있습니다. 새 파일 기술자는 "
":ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/os.rst:1388
msgid ""
"Create a pipe with *flags* set atomically. *flags* can be constructed by "
"ORing together one or more of these values: :data:`O_NONBLOCK`, "
":data:`O_CLOEXEC`. Return a pair of file descriptors ``(r, w)`` usable "
"for reading and writing, respectively."
msgstr ""
"*flags* 가 원자적으로 설정된 파이프를 만듭니다. *flags* 는 다음과 같은 값들을 하나 이상 OR 해서 만들 수 "
"있습니다: :data:`O_NONBLOCK`, :data:`O_CLOEXEC`. 파일 기술자 쌍 ``(r, w)`` 를 반환하는데,"
" 각각 읽기와 쓰기에 사용할 수 있습니다."

#: ../../library/os.rst:1401
msgid ""
"Ensures that enough disk space is allocated for the file specified by "
"*fd* starting from *offset* and continuing for *len* bytes."
msgstr "*fd*\\로 지정된 파일이 *offset* 에서 시작하여 *len* 바이트 동안 계속되도록 충분한 디스크 공간을 할당합니다."

#: ../../library/os.rst:1411
msgid ""
"Announces an intention to access data in a specific pattern thus allowing"
" the kernel to make optimizations. The advice applies to the region of "
"the file specified by *fd* starting at *offset* and continuing for *len* "
"bytes. *advice* is one of :data:`POSIX_FADV_NORMAL`, "
":data:`POSIX_FADV_SEQUENTIAL`, :data:`POSIX_FADV_RANDOM`, "
":data:`POSIX_FADV_NOREUSE`, :data:`POSIX_FADV_WILLNEED` or "
":data:`POSIX_FADV_DONTNEED`."
msgstr ""
"특정 패턴으로 데이터에 액세스하려는 의도를 알려 커널이 최적화할 수 있도록 합니다. 조언(advice)은 *fd에* 의해 지정된 "
"파일의 *offset* 에서 시작하여 *len* 바이트 동안 계속되는 영역에 적용됩니다. *advice*\\는 "
":data:`POSIX_FADV_NORMAL`, :data:`POSIX_FADV_SEQUENTIAL`, "
":data:`POSIX_FADV_RANDOM`, :data:`POSIX_FADV_NOREUSE`, "
":data:`POSIX_FADV_WILLNEED` 또는 :data:`POSIX_FADV_DONTNEED` 중 하나입니다."

#: ../../library/os.rst:1431
msgid ""
"Flags that can be used in *advice* in :func:`posix_fadvise` that specify "
"the access pattern that is likely to be used."
msgstr "사용 가능성이 큰 액세스 패턴을 지정하는 :func:`posix_fadvise`\\의 *advice* 에 사용될 수 있는 플래그."

#: ../../library/os.rst:1441
msgid ""
"Read at most *n* bytes from file descriptor *fd* at a position of "
"*offset*, leaving the file offset unchanged."
msgstr ""
"파일 기술자 *fd*\\에서 *offset* 의 위치부터 최대 *n* 바이트를 읽어 들이고, 파일 오프셋은 변경되지 않은 채로 남겨"
" 둡니다."

#: ../../library/os.rst:1444 ../../library/os.rst:1620
msgid ""
"Return a bytestring containing the bytes read. If the end of the file "
"referred to by *fd* has been reached, an empty bytes object is returned."
msgstr "읽어 들인 바이트를 포함하는 바이트열을 돌려줍니다. *fd* 에 의해 참조된 파일의 끝에 도달하면, 빈 바이트열 객체가 반환됩니다."

#: ../../library/os.rst:1454
msgid "Open and return a file descriptor for a master pseudo-terminal device."
msgstr ""

#: ../../library/os.rst:1456
msgid ""
"Calls the C standard library function :c:func:`posix_openpt`. The *oflag*"
" argument is used to set file status flags and file access modes as "
"specified in the manual page of :c:func:`posix_openpt` of your system."
msgstr ""

#: ../../library/os.rst:1460
msgid ""
"The returned file descriptor is :ref:`non-inheritable <fd_inheritance>`. "
"If the value :data:`O_CLOEXEC` is available on the system, it is added to"
" *oflag*."
msgstr ""

#: ../../library/os.rst:1471
msgid ""
"Read from a file descriptor *fd* at a position of *offset* into mutable "
":term:`bytes-like objects <bytes-like object>` *buffers*, leaving the "
"file offset unchanged.  Transfer data into each buffer until it is full "
"and then move on to the next buffer in the sequence to hold the rest of "
"the data."
msgstr ""
"파일 기술자 *fd*\\에서 *offset* 위치부터 가변 :term:`바이트열류 객체들 <bytes-like object>` "
"*buffers* 로 읽어 들이고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다. 데이터가 가득 찰 때까지 각 버퍼로 데이터를 "
"전송한 다음 나머지 데이터를 보관하기 위해 시퀀스의 다음 버퍼로 이동합니다."

#: ../../library/os.rst:1476 ../../library/os.rst:1561
msgid ""
"The flags argument contains a bitwise OR of zero or more of the following"
" flags:"
msgstr "flags 인자는 다음 플래그 중 0개 이상의 비트별 OR를 포함합니다:"

#: ../../library/os.rst:1479
msgid ":data:`RWF_HIPRI`"
msgstr ":data:`RWF_HIPRI`"

#: ../../library/os.rst:1480
msgid ":data:`RWF_NOWAIT`"
msgstr ":data:`RWF_NOWAIT`"

#: ../../library/os.rst:1482 ../../library/os.rst:1757
msgid ""
"Return the total number of bytes actually read which can be less than the"
" total capacity of all the objects."
msgstr "실제로 읽힌 총 바이트 수를 반환합니다. 이 값은 모든 객체의 총 용량보다 작을 수 있습니다."

#: ../../library/os.rst:1485 ../../library/os.rst:1570
#: ../../library/os.rst:1760 ../../library/os.rst:1835
msgid ""
"The operating system may set a limit (:func:`sysconf` value "
"``'SC_IOV_MAX'``) on the number of buffers that can be used."
msgstr "운영 체제는 사용할 수 있는 버퍼 수에 한계(:func:`sysconf` 값 ``'SC_IOV_MAX'``)를 설정할 수 있습니다."

#: ../../library/os.rst:1488
msgid "Combine the functionality of :func:`os.readv` and :func:`os.pread`."
msgstr ":func:`os.readv` 와 :func:`os.pread`\\의 기능을 결합합니다."

#: ../../library/os.rst:1492 ../../library/os.rst:1577
msgid "Using flags requires Linux >= 4.6."
msgstr ""

#: ../../library/os.rst:1499
msgid ""
"Do not wait for data which is not immediately available. If this flag is "
"specified, the system call will return instantly if it would have to read"
" data from the backing storage or wait for a lock."
msgstr ""
"즉시 사용할 수 없는 데이터를 기다리지 않습니다. 이 플래그를 지정하면, 하부 저장 장치에서 데이터를 읽어야 하거나 록을 기다려야 "
"할 때 즉시 시스템 호출이 반환됩니다."

#: ../../library/os.rst:1503
#, fuzzy
msgid ""
"If some data was successfully read, it will return the number of bytes "
"read. If no bytes were read, it will return ``-1`` and set errno to "
":const:`errno.EAGAIN`."
msgstr ""
"일부 데이터가 성공적으로 읽히면, 읽은 바이트 수를 반환합니다. 읽은 바이트가 없으면, ``-1``\\을 반환하고 errno를 "
":data:`errno.EAGAIN`\\로 설정합니다."

#: ../../library/os.rst:1514
msgid ""
"High priority read/write. Allows block-based filesystems to use polling "
"of the device, which provides lower latency, but may use additional "
"resources."
msgstr ""
"우선순위가 높은 읽기/쓰기. 블록 기반 파일 시스템이 장치의 폴링을 사용할 수 있게 하여, 지연은 짧아 지지만, 추가 자원을 사용할"
" 수 있습니다."

#: ../../library/os.rst:1518
msgid ""
"Currently, on Linux, this feature is usable only on a file descriptor "
"opened using the :data:`O_DIRECT` flag."
msgstr "현재, 리눅스에서, 이 기능은 :data:`O_DIRECT` 플래그를 사용하여 열린 파일 기술자에만 사용할 수 있습니다."

#: ../../library/os.rst:1528
msgid ""
"Return the name of the slave pseudo-terminal device associated with the "
"master pseudo-terminal device to which the file descriptor *fd* refers. "
"The file descriptor *fd* is not closed upon failure."
msgstr ""

#: ../../library/os.rst:1532
msgid ""
"Calls the reentrant C standard library function :c:func:`ptsname_r` if it"
" is available; otherwise, the C standard library function "
":c:func:`ptsname`, which is not guaranteed to be thread-safe, is called."
msgstr ""

#: ../../library/os.rst:1543
msgid ""
"Write the bytestring in *str* to file descriptor *fd* at position of "
"*offset*, leaving the file offset unchanged."
msgstr "파일 기술자 *fd*\\의 *offset* 위치에 *str* 바이트열을 쓰고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다."

#: ../../library/os.rst:1546 ../../library/os.rst:1810
msgid "Return the number of bytes actually written."
msgstr "실제로 쓴 바이트 수를 반환합니다."

#: ../../library/os.rst:1555
#, fuzzy
msgid ""
"Write the *buffers* contents to file descriptor *fd* at an offset "
"*offset*, leaving the file offset unchanged.  *buffers* must be a "
"sequence of :term:`bytes-like objects <bytes-like object>`. Buffers are "
"processed in array order. Entire contents of the first buffer is written "
"before proceeding to the second, and so on."
msgstr ""
"*buffers* 내용을 파일 기술자 *fd*\\의 오프셋 *offset* 에 쓰고, 파일 오프셋은 변경되지 않은 채로 남겨 "
"둡니다. *buffers* 는 :term:`바이트열류 객체 <bytes-like object>`\\의 시퀀스 여야 합니다. 버퍼는 "
"배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 전에 기록되고, 같은 식으로 계속 진행합니다."

#: ../../library/os.rst:1564
msgid ":data:`RWF_DSYNC`"
msgstr ":data:`RWF_DSYNC`"

#: ../../library/os.rst:1565
msgid ":data:`RWF_SYNC`"
msgstr ":data:`RWF_SYNC`"

#: ../../library/os.rst:1566
#, fuzzy
msgid ":data:`RWF_APPEND`"
msgstr ":data:`stat.UF_APPEND`"

#: ../../library/os.rst:1568
msgid "Return the total number of bytes actually written."
msgstr "실제로 쓴 총 바이트 수를 반환합니다."

#: ../../library/os.rst:1573
msgid "Combine the functionality of :func:`os.writev` and :func:`os.pwrite`."
msgstr ":func:`os.writev` 와 :func:`os.pwrite`\\의 기능을 결합합니다."

#: ../../library/os.rst:1584
#, fuzzy
msgid ""
"Provide a per-write equivalent of the :data:`O_DSYNC` :func:`os.open` "
"flag. This flag effect applies only to the data range written by the "
"system call."
msgstr ""
":data:`O_DSYNC` ``open(2)`` 플래그의 쓰기마다 지정할 수 있는 버전을 제공합니다. 이 플래그 효과는 시스템 "
"호출로 기록된 데이터 범위에만 적용됩니다."

#: ../../library/os.rst:1594
#, fuzzy
msgid ""
"Provide a per-write equivalent of the :data:`O_SYNC` :func:`os.open` "
"flag. This flag effect applies only to the data range written by the "
"system call."
msgstr ""
":data:`O_SYNC` ``open(2)`` 플래그의 쓰기마다 지정할 수 있는 버전을 제공합니다. 이 플래그 효과는 시스템 "
"호출로 기록된 데이터 범위에만 적용됩니다."

#: ../../library/os.rst:1604
msgid ""
"Provide a per-write equivalent of the :data:`O_APPEND` :func:`os.open` "
"flag. This flag is meaningful only for :func:`os.pwritev`, and its effect"
" applies only to the data range written by the system call. The *offset* "
"argument does not affect the write operation; the data is always appended"
" to the end of the file. However, if the *offset* argument is ``-1``, the"
" current file *offset* is updated."
msgstr ""

#: ../../library/os.rst:1618
msgid "Read at most *n* bytes from file descriptor *fd*."
msgstr "파일 기술자 *fd*\\에서 최대 *n* 바이트를 읽습니다."

#: ../../library/os.rst:1625
msgid ""
"This function is intended for low-level I/O and must be applied to a file"
" descriptor as returned by :func:`os.open` or :func:`pipe`.  To read a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, or :data:`sys.stdin`, use its "
":meth:`~file.read` or :meth:`~file.readline` methods."
msgstr ""
"이 함수는 저수준 I/O를 위한 것이며 :func:`os.open` 이나 :func:`pipe`\\에 의해 반환된 파일 기술자에 "
"적용되어야 합니다. 내장 함수 :func:`open` 이나 :func:`popen` 또는 :func:`fdopen`\\에 의해 "
"반환된 \"파일 객체\"나 :data:`sys.stdin`\\을 읽으려면, 그것의 :meth:`~file.read` 나 "
":meth:`~file.readline` 메서드를 사용하십시오."

#: ../../library/os.rst:1640
msgid ""
"Copy *count* bytes from file descriptor *in_fd* to file descriptor "
"*out_fd* starting at *offset*. Return the number of bytes sent. When EOF "
"is reached return ``0``."
msgstr ""
"파일 기술자 *in_fd*\\에서 파일 기술자 *out_fd* 로 *offset*\\에서 시작하여 *count* 바이트를 "
"복사합니다. 전송된 바이트 수를 반환합니다. EOF에 도달하면 ``0``\\을 반환합니다."

#: ../../library/os.rst:1644
msgid ""
"The first function notation is supported by all platforms that define "
":func:`sendfile`."
msgstr "첫 번째 함수 서명은 :func:`sendfile`\\를 정의하는 모든 플랫폼에서 지원됩니다."

#: ../../library/os.rst:1647
msgid ""
"On Linux, if *offset* is given as ``None``, the bytes are read from the "
"current position of *in_fd* and the position of *in_fd* is updated."
msgstr ""
"리눅스에서, *offset*\\이 ``None``\\으로 주어지면, *in_fd*\\의 현재 위치에서 바이트를 읽고 "
"*in_fd*\\의 위치가 갱신됩니다."

#: ../../library/os.rst:1650
#, fuzzy
msgid ""
"The second case may be used on macOS and FreeBSD where *headers* and "
"*trailers* are arbitrary sequences of buffers that are written before and"
" after the data from *in_fd* is written. It returns the same as the first"
" case."
msgstr ""
"두 번째 경우는 맥 OS X와 FreeBSD 에 사용될 수 있는데, *headers* 와 *trailers* 는 *in_fd* 의 "
"데이터가 기록되는 전후에 기록되는 버퍼의 임의의 시퀀스입니다. 첫 번째 경우와 같은 결과를 반환합니다."

#: ../../library/os.rst:1654
#, fuzzy
msgid ""
"On macOS and FreeBSD, a value of ``0`` for *count* specifies to send "
"until the end of *in_fd* is reached."
msgstr "맥 OS X 및 FreeBSD 에서, *count* 의 값 ``0``\\은 *in_fd* 의 끝에 도달할 때까지 보내도록 지정합니다."

#: ../../library/os.rst:1657
msgid ""
"All platforms support sockets as *out_fd* file descriptor, and some "
"platforms allow other types (e.g. regular file, pipe) as well."
msgstr ""
"모든 플랫폼은 *out_fd* 파일 기술자로 소켓을 지원하고, 일부 플랫폼은 다른 유형(예를 들어 일반 파일, 파이프)들도 "
"허락합니다."

#: ../../library/os.rst:1660
msgid ""
"Cross-platform applications should not use *headers*, *trailers* and "
"*flags* arguments."
msgstr "이기종 플랫폼 응용 프로그램은 *headers*, *trailers* 및 *flags* 인자를 사용해서는 안 됩니다."

#: ../../library/os.rst:1667
msgid ""
"For a higher-level wrapper of :func:`sendfile`, see "
":meth:`socket.socket.sendfile`."
msgstr ":func:`sendfile`\\의 고수준 래퍼는, :meth:`socket.socket.sendfile`\\을 보십시오."

#: ../../library/os.rst:1672
msgid "Parameters *out* and *in* was renamed to *out_fd* and *in_fd*."
msgstr "매개 변수 *out*\\과 *in*\\의 이름이 *out_fd*\\와 *in_fd*\\로 변경되었습니다."

#: ../../library/os.rst:1680
msgid ""
"Parameters to the :func:`sendfile` function, if the implementation "
"supports them."
msgstr "구현이 지원하는 경우, :func:`sendfile` 함수에 대한 매개 변수입니다."

#: ../../library/os.rst:1689
#, fuzzy
msgid ""
"Parameter to the :func:`sendfile` function, if the implementation "
"supports it. The data won't be cached in the virtual memory and will be "
"freed afterwards."
msgstr "구현이 지원하는 경우, :func:`sendfile` 함수에 대한 매개 변수입니다."

#: ../../library/os.rst:1699
msgid ""
"Set the blocking mode of the specified file descriptor. Set the "
":data:`O_NONBLOCK` flag if blocking is ``False``, clear the flag "
"otherwise."
msgstr ""
"지정된 파일 기술자의 블로킹 모드를 설정합니다. blocking이 ``False``\\면 :data:`O_NONBLOCK` 플래그를"
" 설정하고, 그렇지 않으면 플래그를 지웁니다."

#: ../../library/os.rst:1702
msgid "See also :func:`get_blocking` and :meth:`socket.socket.setblocking`."
msgstr ":func:`get_blocking`\\과 :meth:`socket.socket.setblocking`\\도 참조하십시오."

#: ../../library/os.rst:1719
#, fuzzy
msgid ""
"Transfer *count* bytes from file descriptor *src*, starting from offset "
"*offset_src*, to file descriptor *dst*, starting from offset "
"*offset_dst*. At least one of the file descriptors must refer to a pipe. "
"If *offset_src* is ``None``, then *src* is read from the current "
"position; respectively for *offset_dst*. The offset associated to the "
"file descriptor that refers to a pipe must be ``None``. The files pointed"
" to by *src* and *dst* must reside in the same filesystem, otherwise an "
":exc:`OSError` is raised with :attr:`~OSError.errno` set to "
":const:`errno.EXDEV`."
msgstr ""
"*count* 바이트를 파일 기술자 *src*\\(오프셋 *offset_src*\\에서 시작하여)에서 파일 기술자 "
"*dst*\\(오프셋 *offset_dst*\\에서 시작하여)로 복사합니다. *offset_src*\\가 None이면, 현재 "
"위치에서 *src*\\를 읽습니다; *offset_dst*\\도 마찬가지입니다. *src*\\와 *dst*\\가 가리키는 파일은 "
"같은 파일 시스템에 있어야 합니다, 그렇지 않으면 :data:`errno.EXDEV`\\로 설정된 "
":attr:`~OSError.errno`\\로 :exc:`OSError`\\가 발생합니다."

#: ../../library/os.rst:1728
msgid ""
"This copy is done without the additional cost of transferring data from "
"the kernel to user space and then back into the kernel. Additionally, "
"some filesystems could implement extra optimizations. The copy is done as"
" if both files are opened as binary."
msgstr ""
"이 복사는 커널에서 사용자 공간으로 데이터를 전송한 다음 다시 커널로 전송하는 추가 비용 없이 수행됩니다. 또한, 일부 파일 "
"시스템은 추가 최적화를 구현할 수 있습니다. 두 파일이 바이너리로 열린 것처럼 복사가 수행됩니다."

#: ../../library/os.rst:1733
msgid ""
"Upon successful completion, returns the number of bytes spliced to or "
"from the pipe. A return value of 0 means end of input. If *src* refers to"
" a pipe, then this means that there was no data to transfer, and it would"
" not make sense to block because there are no writers connected to the "
"write end of the pipe."
msgstr ""

#: ../../library/os.rst:1752
msgid ""
"Read from a file descriptor *fd* into a number of mutable :term:`bytes-"
"like objects <bytes-like object>` *buffers*. Transfer data into each "
"buffer until it is full and then move on to the next buffer in the "
"sequence to hold the rest of the data."
msgstr ""
"파일 기술자 *fd*\\에서 여러 가변 :term:`바이트열류 객체 <bytes-like object>` *buffers*\\로 "
"읽어 들입니다. 데이터가 가득 찰 때까지 각 버퍼로 데이터를 전송한 다음 나머지 데이터를 보관하기 위해 시퀀스의 다음 버퍼로 "
"이동합니다."

#: ../../library/os.rst:1770
msgid ""
"Return the process group associated with the terminal given by *fd* (an "
"open file descriptor as returned by :func:`os.open`)."
msgstr ""
"*fd*\\(:func:`os.open`\\에 의해 반환된 것과 같은 열린 파일 기술자)에 의해 주어진 터미널과 관련된 프로세스 "
"그룹을 반환합니다."

#: ../../library/os.rst:1778
msgid ""
"Set the process group associated with the terminal given by *fd* (an open"
" file descriptor as returned by :func:`os.open`) to *pg*."
msgstr ""
"*fd*\\(:func:`os.open`\\에 의해 반환된 것과 같은 열린 파일 기술자)에 의해 주어진 터미널과 관련된 프로세스 "
"그룹을 *pg*\\로 설정합니다."

#: ../../library/os.rst:1786
msgid ""
"Return a string which specifies the terminal device associated with file "
"descriptor *fd*.  If *fd* is not associated with a terminal device, an "
"exception is raised."
msgstr ""
"파일 기술자 *fd*\\와 관련된 터미널 장치를 나타내는 문자열을 돌려줍니다. *fd* 가 터미널 장치와 연관되어 있지 않으면, "
"예외가 발생합니다."

#: ../../library/os.rst:1795
msgid ""
"Unlock the slave pseudo-terminal device associated with the master "
"pseudo-terminal device to which the file descriptor *fd* refers. The file"
" descriptor *fd* is not closed upon failure."
msgstr ""

#: ../../library/os.rst:1799
msgid "Calls the C standard library function :c:func:`unlockpt`."
msgstr ""

#: ../../library/os.rst:1808
msgid "Write the bytestring in *str* to file descriptor *fd*."
msgstr "*str* 바이트열을 파일 기술자 *fd* 에 씁니다."

#: ../../library/os.rst:1814
msgid ""
"This function is intended for low-level I/O and must be applied to a file"
" descriptor as returned by :func:`os.open` or :func:`pipe`.  To write a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, or :data:`sys.stdout` or "
":data:`sys.stderr`, use its :meth:`~file.write` method."
msgstr ""
"이 함수는 저수준 I/O를 위한 것이며 :func:`os.open` 이나 :func:`pipe`\\에 의해 반환된 파일 기술자에 "
"적용되어야 합니다. 내장 함수 :func:`open` 이나 :func:`popen` 또는 :func:`fdopen`\\에 의해 "
"반환된 \"파일 객체\"나 :data:`sys.stdout` 또는 :data:`sys.stderr`\\에 쓰려면, 그것의 "
":meth:`~file.write` 메서드를 사용하십시오."

#: ../../library/os.rst:1828
msgid ""
"Write the contents of *buffers* to file descriptor *fd*. *buffers* must "
"be a sequence of :term:`bytes-like objects <bytes-like object>`. Buffers "
"are processed in array order. Entire contents of the first buffer is "
"written before proceeding to the second, and so on."
msgstr ""
"*buffers* 내용을 파일 기술자 *fd*\\에 씁니다. *buffers* 는 :term:`바이트열류 객체 <bytes-like"
" object>`\\의 시퀀스 여야 합니다. 버퍼는 배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 "
"전에 기록되고, 같은 식으로 계속 진행합니다."

#: ../../library/os.rst:1833
msgid "Returns the total number of bytes actually written."
msgstr "실제로 쓴 총 바이트 수를 반환합니다."

#: ../../library/os.rst:1846
msgid "Querying the size of a terminal"
msgstr "터미널의 크기 조회하기"

#: ../../library/os.rst:1852
msgid ""
"Return the size of the terminal window as ``(columns, lines)``, tuple of "
"type :class:`terminal_size`."
msgstr "터미널 창의 크기를 ``(columns, lines)`` 로 반환하는데, :class:`terminal_size` 형의 튜플입니다."

#: ../../library/os.rst:1855
msgid ""
"The optional argument ``fd`` (default ``STDOUT_FILENO``, or standard "
"output) specifies which file descriptor should be queried."
msgstr "선택적 인자 ``fd``\\(기본값 ``STDOUT_FILENO``, 즉 표준 출력)는 조회할 파일 기술자를 지정합니다."

#: ../../library/os.rst:1858
msgid ""
"If the file descriptor is not connected to a terminal, an :exc:`OSError` "
"is raised."
msgstr "파일 기술자가 터미널에 연결되어 있지 않으면, :exc:`OSError`\\가 발생합니다."

#: ../../library/os.rst:1861
msgid ""
":func:`shutil.get_terminal_size` is the high-level function which should "
"normally be used, ``os.get_terminal_size`` is the low-level "
"implementation."
msgstr ""
":func:`shutil.get_terminal_size`\\가 일반적으로 사용해야 하는 고수준 함수이며, "
"``os.get_terminal_size``\\는 저수준 구현입니다."

#: ../../library/os.rst:1869
msgid ""
"A subclass of tuple, holding ``(columns, lines)`` of the terminal window "
"size."
msgstr "터미널 창 크기 ``(columns, lines)``\\를 저장하는 튜플의 서브 클래스."

#: ../../library/os.rst:1873
msgid "Width of the terminal window in characters."
msgstr "문자 단위의 터미널 창의 너비."

#: ../../library/os.rst:1877
msgid "Height of the terminal window in characters."
msgstr "문자 단위의 터미널 창의 높이."

#: ../../library/os.rst:1883
msgid "Inheritance of File Descriptors"
msgstr "파일 기술자의 상속"

#: ../../library/os.rst:1887
msgid ""
"A file descriptor has an \"inheritable\" flag which indicates if the file"
" descriptor can be inherited by child processes.  Since Python 3.4, file "
"descriptors created by Python are non-inheritable by default."
msgstr ""
"파일 기술자는 자식 프로세스가 파일 기술자를 상속받을 수 있는지를 나타내는 \"상속 가능\" 플래그를 가지고 있습니다. 파이썬 "
"3.4부터, 파이썬에 의해 생성된 파일 기술자는 기본적으로 상속 불가능합니다."

#: ../../library/os.rst:1891
msgid ""
"On UNIX, non-inheritable file descriptors are closed in child processes "
"at the execution of a new program, other file descriptors are inherited."
msgstr "유닉스에서는, 상속 불가능한 파일 기술자는 새 프로그램 실행 시 자식 프로세스에서 닫히고, 다른 파일 기술자는 상속됩니다."

#: ../../library/os.rst:1894
msgid ""
"On Windows, non-inheritable handles and file descriptors are closed in "
"child processes, except for standard streams (file descriptors 0, 1 and "
"2: stdin, stdout and stderr), which are always inherited.  Using "
":func:`spawn\\* <spawnl>` functions, all inheritable handles and all "
"inheritable file descriptors are inherited. Using the :mod:`subprocess` "
"module, all file descriptors except standard streams are closed, and "
"inheritable handles are only inherited if the *close_fds* parameter is "
"``False``."
msgstr ""
"윈도우에서는, 항상 상속되는 표준 스트림(파일 기술자 0, 1, 2: stdin, stdout, stderr)을 제외하고, 상속 "
"불가능한 핸들 및 파일 기술자는 자식 프로세스에서 닫힙니다. :func:`spawn\\* <spawnl>` 함수를 사용하면, 상속 "
"가능한 모든 핸들과 상속 가능한 모든 파일 기술자가 상속됩니다. :mod:`subprocess` 모듈을 사용하면, 표준 스트림을 "
"제외한 모든 파일 기술자가 닫히고, 상속 가능한 핸들은 *close_fds* 매개 변수가 ``False`` 일 때만 상속됩니다."

#: ../../library/os.rst:1902
msgid "On WebAssembly platforms, the file descriptor cannot be modified."
msgstr ""

#: ../../library/os.rst:1906
msgid "Get the \"inheritable\" flag of the specified file descriptor (a boolean)."
msgstr "지정된 파일 기술자의 \"상속 가능\" 플래그를 가져옵니다 (논릿값)."

#: ../../library/os.rst:1910
msgid "Set the \"inheritable\" flag of the specified file descriptor."
msgstr "지정된 파일 기술자의 \"상속 가능(inheritable)\" 플래그를 설정합니다."

#: ../../library/os.rst:1914
msgid "Get the \"inheritable\" flag of the specified handle (a boolean)."
msgstr "지정된 핸들의 \"상속 가능\" 플래그를 가져옵니다 (논릿값)."

#: ../../library/os.rst:1920
msgid "Set the \"inheritable\" flag of the specified handle."
msgstr "지정된 핸들의 \"상속 가능(inheritable)\" 플래그를 설정합니다."

#: ../../library/os.rst:1928
msgid "Files and Directories"
msgstr "파일과 디렉터리"

#: ../../library/os.rst:1930
msgid ""
"On some Unix platforms, many of these functions support one or more of "
"these features:"
msgstr "일부 유닉스 플랫폼에서, 이 함수 중 많은 것들이 다음 기능 중 하나 이상을 지원합니다:"

#: ../../library/os.rst:1935
msgid ""
"**specifying a file descriptor:** Normally the *path* argument provided "
"to functions in the :mod:`os` module must be a string specifying a file "
"path.  However, some functions now alternatively accept an open file "
"descriptor for their *path* argument. The function will then operate on "
"the file referred to by the descriptor. (For POSIX systems, Python will "
"call the variant of the function prefixed with ``f`` (e.g. call "
"``fchdir`` instead of ``chdir``).)"
msgstr ""
"**파일 기술자 지정:** 일반적으로 :mod:`os` 모듈에 있는 함수에 제공되는 *path* 인자는 파일 경로를 지정하는 "
"문자열이어야 합니다. 하지만, 일부 함수는 이제 *path* 인자로 열린 파일 기술자를 대신 받아들입니다. 그러면 그 함수는 "
"기술자가 참조하는 파일에서 작동합니다. (POSIX 시스템에서, 파이썬은 함수의 ``f`` 접두어가 붙은 함수의 변종을 호출합니다 "
"(예를 들어, ``chdir`` 대신 ``fchdir``).)"

#: ../../library/os.rst:1943
msgid ""
"You can check whether or not *path* can be specified as a file descriptor"
" for a particular function on your platform using :data:`os.supports_fd`."
" If this functionality is unavailable, using it will raise a "
":exc:`NotImplementedError`."
msgstr ""
":data:`os.supports_fd`\\를 사용하여, 여러분의 플랫폼에서 특정 함수에 파일 기술자로 *path*\\를 지정할 수"
" 있는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/os.rst:1948
msgid ""
"If the function also supports *dir_fd* or *follow_symlinks* arguments, "
"it's an error to specify one of those when supplying *path* as a file "
"descriptor."
msgstr ""
"함수가 *dir_fd* 나 *follow_symlinks* 인자도 지원하면, *path* 에 파일 기술자를 제공할 때, 이 중 "
"하나를 지정하는 것은 에러입니다."

#: ../../library/os.rst:1953
msgid ""
"**paths relative to directory descriptors:** If *dir_fd* is not ``None``,"
" it should be a file descriptor referring to a directory, and the path to"
" operate on should be relative; path will then be relative to that "
"directory.  If the path is absolute, *dir_fd* is ignored.  (For POSIX "
"systems, Python will call the variant of the function with an ``at`` "
"suffix and possibly prefixed with ``f`` (e.g. call ``faccessat`` instead "
"of ``access``)."
msgstr ""
"**디렉터리 기술자에 상대적인 경로:** *dir_fd* 가 ``None``\\이 아니면, 디렉터리를 가리키는 파일 기술자여야 "
"하며, 대상 경로는 상대 경로여야 합니다; 그러면 경로는 그 디렉터리에 상대적입니다. 절대 경로이면, *dir_fd* 는 "
"무시됩니다. (POSIX 시스템에서, 파이썬은 ``at`` 접미사를 붙이거나 어쩌면 ``f`` 접두사도 붙인 함수의 변종을 "
"호출합니다. 예를 들어, ``access`` 대신 ``faccessat``\\를 호출합니다)"

#: ../../library/os.rst:1960
msgid ""
"You can check whether or not *dir_fd* is supported for a particular "
"function on your platform using :data:`os.supports_dir_fd`.  If it's "
"unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
":data:`os.supports_dir_fd`\\를 사용하여, 여러분의 플랫폼에서 특정 함수에 *dir_fd*\\가 지원되는지를 "
"확인할 수 있습니다. 사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/os.rst:1966
msgid ""
"**not following symlinks:** If *follow_symlinks* is ``False``, and the "
"last element of the path to operate on is a symbolic link, the function "
"will operate on the symbolic link itself rather than the file pointed to "
"by the link.  (For POSIX systems, Python will call the ``l...`` variant "
"of the function.)"
msgstr ""
"**심볼릭 링크를 따르지 않음:** *follow_symlinks* 가 ``False``\\고, 대상 경로의 마지막 요소가 심볼릭 "
"링크면, 함수는 링크가 가리키는 파일 대신 심볼릭 링크 자체에 대해 작동합니다. (POSIX 시스템에서, 파이썬은 함수의 "
"``l...`` 변종을 호출합니다.)"

#: ../../library/os.rst:1972
msgid ""
"You can check whether or not *follow_symlinks* is supported for a "
"particular function on your platform using "
":data:`os.supports_follow_symlinks`. If it's unavailable, using it will "
"raise a :exc:`NotImplementedError`."
msgstr ""
":data:`os.supports_follow_symlinks`\\를 사용하여, 여러분의 플랫폼에서 특정 함수에 "
"*follow_symlinks*\\가 지원되는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 "
":exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/os.rst:1980
msgid ""
"Use the real uid/gid to test for access to *path*.  Note that most "
"operations will use the effective uid/gid, therefore this routine can be "
"used in a suid/sgid environment to test if the invoking user has the "
"specified access to *path*.  *mode* should be :const:`F_OK` to test the "
"existence of *path*, or it can be the inclusive OR of one or more of "
":const:`R_OK`, :const:`W_OK`, and :const:`X_OK` to test permissions.  "
"Return :const:`True` if access is allowed, :const:`False` if not. See the"
" Unix man page :manpage:`access(2)` for more information."
msgstr ""
"실제(real) uid/gid를 사용해서 *path*\\를 액세스할 수 있는지 검사합니다. 대부분의 연산은 "
"유효한(effective) uid/gid를 사용할 것이므로, 이 함수는 suid/sgid 환경에서 호출하는 사용자가 지정된 "
"*path* 에 대한 액세스 권한이 있는지 검사하는데 사용할 수 있습니다. *path*\\가 존재하는지를 검사하려면 *mode* 는"
" :const:`F_OK` 여야 하며, 권한을 검사하려면 하나 이상의 :const:`R_OK`, :const:`W_OK` 및 "
":const:`X_OK`\\를 OR 값일 수 있습니다. 액세스가 허용되면 :const:`True`\\를 반환하고, 그렇지 않으면 "
":const:`False`\\를 반환합니다. 더 자세한 정보는 유닉스 매뉴얼 페이지 :manpage:`access(2)`\\를 "
"참조하십시오."

#: ../../library/os.rst:1989
msgid ""
"This function can support specifying :ref:`paths relative to directory "
"descriptors <dir_fd>` and :ref:`not following symlinks "
"<follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>` 와 :ref:`심볼릭 링크를 따르지 않음 "
"<follow_symlinks>`\\을 지원할 수 있습니다."

#: ../../library/os.rst:1992
msgid ""
"If *effective_ids* is ``True``, :func:`access` will perform its access "
"checks using the effective uid/gid instead of the real uid/gid. "
"*effective_ids* may not be supported on your platform; you can check "
"whether or not it is available using :data:`os.supports_effective_ids`.  "
"If it is unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
"*effective_ids* 가 ``True``\\면, :func:`access`\\는 실제(real) uid/gid 대신 "
"유효한(effective) uid/gid를 사용하여 액세스 검사를 수행합니다. *effective_ids* 는 플랫폼에서 지원되지 "
"않을 수 있습니다; :data:`os.supports_effective_ids`\\를 사용하여, 사용할 수 있는지를 확인할 수 "
"있습니다. 사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/os.rst:2000
msgid ""
"Using :func:`access` to check if a user is authorized to e.g. open a file"
" before actually doing so using :func:`open` creates a security hole, "
"because the user might exploit the short time interval between checking "
"and opening the file to manipulate it. It's preferable to use "
":term:`EAFP` techniques. For example::"
msgstr ""
"예를 들어, 실제로 :func:`open`\\를 사용하여 파일을 열기 전에, :func:`access`\\를 사용하여 파일을 여는 "
"권한이 있는지 확인하는 것은 보안 구멍을 만듭니다. 사용자가 파일을 확인하고 조작을 위해 열기 사이의 짧은 시간 간격을 악용할 수 "
"있기 때문입니다. :term:`EAFP` 기법을 사용하는 것이 좋습니다. 예를 들면::"

#: ../../library/os.rst:2006
msgid ""
"if os.access(\"myfile\", os.R_OK):\n"
"    with open(\"myfile\") as fp:\n"
"        return fp.read()\n"
"return \"some default data\""
msgstr ""

#: ../../library/os.rst:2011
msgid "is better written as::"
msgstr "는 다음과 같이 쓰는 것이 더 좋습니다::"

#: ../../library/os.rst:2013
msgid ""
"try:\n"
"    fp = open(\"myfile\")\n"
"except PermissionError:\n"
"    return \"some default data\"\n"
"else:\n"
"    with fp:\n"
"        return fp.read()"
msgstr ""

#: ../../library/os.rst:2023
msgid ""
"I/O operations may fail even when :func:`access` indicates that they "
"would succeed, particularly for operations on network filesystems which "
"may have permissions semantics beyond the usual POSIX permission-bit "
"model."
msgstr ""
":func:`access`\\가 성공할 것임을 알릴 때도, I/O 연산이 실패할 수 있습니다. 특히 일반적인 POSIX 권한 비트 "
"모델을 넘어서는 권한 의미가 있을 수 있는 네트워크 파일 시스템에 대한 연산에서 그럴 수 있습니다."

#: ../../library/os.rst:2027
msgid "Added the *dir_fd*, *effective_ids*, and *follow_symlinks* parameters."
msgstr "*dir_fd*, *effective_ids* 및 *follow_symlinks* 매개 변수를 추가했습니다."

#: ../../library/os.rst:2039
msgid ""
"Values to pass as the *mode* parameter of :func:`access` to test the "
"existence, readability, writability and executability of *path*, "
"respectively."
msgstr ""
"*path* 의 존재 여부, 읽기 가능성, 쓰기 가능성 및 실행 가능성을 검사하기 위해, :func:`access`\\의 "
"*mode* 매개 변수로 전달할 값입니다."

#: ../../library/os.rst:2048
msgid "Change the current working directory to *path*."
msgstr "현재 작업 디렉터리를 *path*\\로 변경합니다."

#: ../../library/os.rst:2050
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`."
"  The descriptor must refer to an opened directory, not an open file."
msgstr ""
"이 함수는 :ref:`파일 기술자 지정 <path_fd>`\\을 지원할 수 있습니다. 기술자는 열려있는 파일이 아니라, 열려있는 "
"디렉터리를 참조해야 합니다."

#: ../../library/os.rst:2053
msgid ""
"This function can raise :exc:`OSError` and subclasses such as "
":exc:`FileNotFoundError`, :exc:`PermissionError`, and "
":exc:`NotADirectoryError`."
msgstr ""
"이 함수는 :exc:`OSError`\\와 :exc:`FileNotFoundError`, :exc:`PermissionError` "
"및 :exc:`NotADirectoryError`\\와 같은 서브 클래스를 발생시킬 수 있습니다."

#: ../../library/os.rst:2056 ../../library/os.rst:2194
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chdir`` with argument "
"``path``."
msgstr ""
"``path``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` ``os.chdir``\\을 "
"발생시킵니다."

#: ../../library/os.rst:2058
msgid ""
"Added support for specifying *path* as a file descriptor on some "
"platforms."
msgstr "일부 플랫폼에서 *path* 를 파일 기술자로 지정하는 지원이 추가되었습니다."

#: ../../library/os.rst:2068
msgid ""
"Set the flags of *path* to the numeric *flags*. *flags* may take a "
"combination (bitwise OR) of the following values (as defined in the "
":mod:`stat` module):"
msgstr ""
"*path* 의 플래그를 숫자 *flags*\\로 설정합니다. *flags*\\는 다음 값들(:mod:`stat` 모듈에 정의된 "
"대로)의 조합(비트별 OR)을 취할 수 있습니다:"

#: ../../library/os.rst:2071
#, fuzzy
msgid ":const:`stat.UF_NODUMP`"
msgstr ":data:`stat.UF_NODUMP`"

#: ../../library/os.rst:2072
#, fuzzy
msgid ":const:`stat.UF_IMMUTABLE`"
msgstr ":data:`stat.UF_IMMUTABLE`"

#: ../../library/os.rst:2073
#, fuzzy
msgid ":const:`stat.UF_APPEND`"
msgstr ":data:`stat.UF_APPEND`"

#: ../../library/os.rst:2074
#, fuzzy
msgid ":const:`stat.UF_OPAQUE`"
msgstr ":data:`stat.UF_OPAQUE`"

#: ../../library/os.rst:2075
#, fuzzy
msgid ":const:`stat.UF_NOUNLINK`"
msgstr ":data:`stat.UF_NOUNLINK`"

#: ../../library/os.rst:2076
#, fuzzy
msgid ":const:`stat.UF_COMPRESSED`"
msgstr ":data:`stat.UF_COMPRESSED`"

#: ../../library/os.rst:2077
#, fuzzy
msgid ":const:`stat.UF_HIDDEN`"
msgstr ":data:`stat.UF_HIDDEN`"

#: ../../library/os.rst:2078
#, fuzzy
msgid ":const:`stat.SF_ARCHIVED`"
msgstr ":data:`stat.SF_ARCHIVED`"

#: ../../library/os.rst:2079
#, fuzzy
msgid ":const:`stat.SF_IMMUTABLE`"
msgstr ":data:`stat.SF_IMMUTABLE`"

#: ../../library/os.rst:2080
#, fuzzy
msgid ":const:`stat.SF_APPEND`"
msgstr ":data:`stat.SF_APPEND`"

#: ../../library/os.rst:2081
#, fuzzy
msgid ":const:`stat.SF_NOUNLINK`"
msgstr ":data:`stat.SF_NOUNLINK`"

#: ../../library/os.rst:2082
#, fuzzy
msgid ":const:`stat.SF_SNAPSHOT`"
msgstr ":data:`stat.SF_SNAPSHOT`"

#: ../../library/os.rst:2084
msgid "This function can support :ref:`not following symlinks <follow_symlinks>`."
msgstr "이 함수는 :ref:`심볼릭 링크를 따르지 않음 <follow_symlinks>`\\을 지원할 수 있습니다."

#: ../../library/os.rst:2086 ../../library/os.rst:2220
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.chflags`` with arguments "
"``path``, ``flags``."
msgstr ""
"``path``, ``flags``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.chflags``\\를 발생시킵니다."

#: ../../library/os.rst:2090
#, fuzzy
msgid "Added the *follow_symlinks* parameter."
msgstr "*follow_symlinks* 인자."

#: ../../library/os.rst:2099
msgid ""
"Change the mode of *path* to the numeric *mode*. *mode* may take one of "
"the following values (as defined in the :mod:`stat` module) or bitwise "
"ORed combinations of them:"
msgstr ""
"*path*\\의 모드를 숫자 *mode*\\로 변경합니다. *mode* 는 다음 값들(:mod:`stat` 모듈에 정의된 "
"대로)이나 이들의 비트별 OR 조합을 취할 수 있습니다:"

#: ../../library/os.rst:2103
#, fuzzy
msgid ":const:`stat.S_ISUID`"
msgstr ":data:`stat.S_ISUID`"

#: ../../library/os.rst:2104
#, fuzzy
msgid ":const:`stat.S_ISGID`"
msgstr ":data:`stat.S_ISGID`"

#: ../../library/os.rst:2105
#, fuzzy
msgid ":const:`stat.S_ENFMT`"
msgstr ":data:`stat.S_ENFMT`"

#: ../../library/os.rst:2106
#, fuzzy
msgid ":const:`stat.S_ISVTX`"
msgstr ":data:`stat.S_ISVTX`"

#: ../../library/os.rst:2107
#, fuzzy
msgid ":const:`stat.S_IREAD`"
msgstr ":data:`stat.S_IREAD`"

#: ../../library/os.rst:2108
#, fuzzy
msgid ":const:`stat.S_IWRITE`"
msgstr ":data:`stat.S_IWRITE`"

#: ../../library/os.rst:2109
#, fuzzy
msgid ":const:`stat.S_IEXEC`"
msgstr ":data:`stat.S_IEXEC`"

#: ../../library/os.rst:2110
#, fuzzy
msgid ":const:`stat.S_IRWXU`"
msgstr ":data:`stat.S_IRWXU`"

#: ../../library/os.rst:2111
#, fuzzy
msgid ":const:`stat.S_IRUSR`"
msgstr ":data:`stat.S_IRUSR`"

#: ../../library/os.rst:2112
#, fuzzy
msgid ":const:`stat.S_IWUSR`"
msgstr ":data:`stat.S_IWUSR`"

#: ../../library/os.rst:2113
#, fuzzy
msgid ":const:`stat.S_IXUSR`"
msgstr ":data:`stat.S_IXUSR`"

#: ../../library/os.rst:2114
#, fuzzy
msgid ":const:`stat.S_IRWXG`"
msgstr ":data:`stat.S_IRWXG`"

#: ../../library/os.rst:2115
#, fuzzy
msgid ":const:`stat.S_IRGRP`"
msgstr ":data:`stat.S_IRGRP`"

#: ../../library/os.rst:2116
#, fuzzy
msgid ":const:`stat.S_IWGRP`"
msgstr ":data:`stat.S_IWGRP`"

#: ../../library/os.rst:2117
#, fuzzy
msgid ":const:`stat.S_IXGRP`"
msgstr ":data:`stat.S_IXGRP`"

#: ../../library/os.rst:2118
#, fuzzy
msgid ":const:`stat.S_IRWXO`"
msgstr ":data:`stat.S_IRWXO`"

#: ../../library/os.rst:2119
#, fuzzy
msgid ":const:`stat.S_IROTH`"
msgstr ":data:`stat.S_IROTH`"

#: ../../library/os.rst:2120
#, fuzzy
msgid ":const:`stat.S_IWOTH`"
msgstr ":data:`stat.S_IWOTH`"

#: ../../library/os.rst:2121
#, fuzzy
msgid ":const:`stat.S_IXOTH`"
msgstr ":data:`stat.S_IXOTH`"

#: ../../library/os.rst:2123 ../../library/os.rst:2156
#: ../../library/os.rst:3547
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`, "
":ref:`paths relative to directory descriptors <dir_fd>` and :ref:`not "
"following symlinks <follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`파일 기술자 지정 <path_fd>`, :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>` 및 "
":ref:`심볼릭 링크를 따르지 않음 <follow_symlinks>`\\을 지원할 수 있습니다."

#: ../../library/os.rst:2129
#, fuzzy
msgid ""
"Although Windows supports :func:`chmod`, you can only set the file's "
"read-only flag with it (via the ``stat.S_IWRITE`` and ``stat.S_IREAD`` "
"constants or a corresponding integer value).  All other bits are ignored."
" The default value of *follow_symlinks* is ``False`` on Windows."
msgstr ""
"윈도우가 :func:`chmod`\\를 지원하더라도, (``stat.S_IWRITE`` 와 ``stat.S_IREAD`` 상수나 "
"해당 정숫값을 통해) 파일의 읽기 전용 플래그만 설정할 수 있습니다. 다른 모든 비트는 무시됩니다."

#: ../../library/os.rst:2139 ../../library/os.rst:2170
msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd* and *follow_symlinks* arguments."
msgstr "*path*\\를 열린 파일 기술자로 지정하는 지원과 *dir_fd* 및 *follow_symlinks* 인자가 추가되었습니다."

#: ../../library/os.rst:2146
#, fuzzy
msgid ""
"Added support for a file descriptor and the *follow_symlinks* argument on"
" Windows."
msgstr "*path*\\를 열린 파일 기술자로 지정하는 지원과 *dir_fd* 및 *follow_symlinks* 인자가 추가되었습니다."

#: ../../library/os.rst:2153
msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  "
"To leave one of the ids unchanged, set it to -1."
msgstr ""
"*path* 의 소유자와 그룹 ID를 숫자 *uid* 와 *gid*\\로 변경합니다. ID 중 하나를 변경하지 않으려면, 그것을 "
"-1로 설정하십시오."

#: ../../library/os.rst:2160
msgid ""
"See :func:`shutil.chown` for a higher-level function that accepts names "
"in addition to numeric ids."
msgstr "숫자 ID 이외에 이름을 허용하는 고수준 함수는 :func:`shutil.chown`\\를 참조하십시오."

#: ../../library/os.rst:2174
msgid "Supports a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 지원합니다."

#: ../../library/os.rst:2180
msgid "Change the root directory of the current process to *path*."
msgstr "현재 프로세스의 루트 디렉터리를 *path*\\로 변경합니다."

#: ../../library/os.rst:2190
msgid ""
"Change the current working directory to the directory represented by the "
"file descriptor *fd*.  The descriptor must refer to an opened directory, "
"not an open file.  As of Python 3.3, this is equivalent to "
"``os.chdir(fd)``."
msgstr ""
"현재 작업 디렉터리를 파일 기술자 *fd*\\가 나타내는 디렉터리로 변경합니다. 기술자는 열려있는 파일이 아니라 열려있는 디렉터리를"
" 참조해야 합니다. 파이썬 3.3부터는, ``os.chdir(fd)``\\와 같습니다."

#: ../../library/os.rst:2201
msgid "Return a string representing the current working directory."
msgstr "현재 작업 디렉터리를 나타내는 문자열을 반환합니다."

#: ../../library/os.rst:2206
msgid "Return a bytestring representing the current working directory."
msgstr "현재 작업 디렉터리를 나타내는 바이트열을 반환합니다."

#: ../../library/os.rst:2208
msgid ""
"The function now uses the UTF-8 encoding on Windows, rather than the ANSI"
" code page: see :pep:`529` for the rationale. The function is no longer "
"deprecated on Windows."
msgstr ""
"이 함수는 이제 윈도우에서 ANSI 코드 페이지가 아닌 UTF-8 인코딩을 사용합니다: 이유는 :pep:`529`\\를 "
"참조하십시오. 이 함수는 윈도우에서 더는 폐지되지 않습니다."

#: ../../library/os.rst:2216
msgid ""
"Set the flags of *path* to the numeric *flags*, like :func:`chflags`, but"
" do not follow symbolic links.  As of Python 3.3, this is equivalent to "
"``os.chflags(path, flags, follow_symlinks=False)``."
msgstr ""
"*path* 의 플래그를, :func:`chflags` 처럼, 숫자 *flags*\\로 설정하지만, 심볼릭 링크를 따르지 않습니다."
" 파이썬 3.3부터는, ``os.chflags(path, flags, follow_symlinks=False)``\\와 같습니다."

#: ../../library/os.rst:2230
msgid ""
"Change the mode of *path* to the numeric *mode*. If path is a symlink, "
"this affects the symlink rather than the target.  See the docs for "
":func:`chmod` for possible values of *mode*.  As of Python 3.3, this is "
"equivalent to ``os.chmod(path, mode, follow_symlinks=False)``."
msgstr ""
"*path* 모드를 숫자 *mode*\\로 변경합니다. path가 심볼릭 링크면, 이 함수는 타깃이 아닌 심볼릭 링크에 영향을 "
"미칩니다. *mode*\\의 가능한 값은 :func:`chmod` 문서를 참조하십시오. 파이썬 3.3부터는, "
"``os.chmod(path, mode, follow_symlinks=False)``\\와 같습니다."

#: ../../library/os.rst:2235
msgid ""
"``lchmod()`` is not part of POSIX, but Unix implementations may have it "
"if changing the mode of symbolic links is supported."
msgstr ""

#: ../../library/os.rst:2250
msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  "
"This function will not follow symbolic links.  As of Python 3.3, this is "
"equivalent to ``os.chown(path, uid, gid, follow_symlinks=False)``."
msgstr ""
"*path* 의 소유자와 그룹 ID를 숫자 *uid* 와 *gid*\\로 변경합니다. 이 함수는 심볼릭 링크를 따르지 않습니다. "
"파이썬 3.3부터는, ``os.chown(path, uid, gid, follow_symlinks=False)``\\와 같습니다."

#: ../../library/os.rst:2264
msgid "Create a hard link pointing to *src* named *dst*."
msgstr "*src*\\를 가리키는 *dst* 라는 이름의 하드 링크를 만듭니다."

#: ../../library/os.rst:2266
msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`, and "
":ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 제공하기 위해 *src_dir_fd* 와/나 "
"*dst_dir_fd* 를 지정하는 것과, :ref:`심볼릭 링크를 따르지 않음 <follow_symlinks>`\\을 지원할 수 "
"있습니다."

#: ../../library/os.rst:2270
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.link`` with arguments "
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``."
msgstr ""
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``\\를 인자로 :ref:`감사 "
"이벤트(auditing event) <auditing>` ``os.link``\\를 발생시킵니다."

#: ../../library/os.rst:2274 ../../library/os.rst:4544
msgid "Added Windows support."
msgstr "윈도우 지원이 추가되었습니다."

#: ../../library/os.rst:2277
#, fuzzy
msgid "Added the *src_dir_fd*, *dst_dir_fd*, and *follow_symlinks* parameters."
msgstr "*src_dir_fd* , *dst_dir_fd* 및 *follow_symlinks* 인자를 추가했습니다."

#: ../../library/os.rst:2280 ../../library/os.rst:2704
#: ../../library/os.rst:2741 ../../library/os.rst:3469
msgid "Accepts a :term:`path-like object` for *src* and *dst*."
msgstr "*src* 및 *dst*\\로 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/os.rst:2286
msgid ""
"Return a list containing the names of the entries in the directory given "
"by *path*.  The list is in arbitrary order, and does not include the "
"special entries ``'.'`` and ``'..'`` even if they are present in the "
"directory. If a file is removed from or added to the directory during the"
" call of this function, whether a name for that file be included is "
"unspecified."
msgstr ""
"*path*\\에 의해 주어진 디렉터리에 있는 항목들의 이름을 담고 있는 리스트를 반환합니다. 리스트는 임의의 순서로 나열되며, "
"디렉터리에 존재하더라도 특수 항목 ``'.'`` 과 ``'..'``\\는 포함하지 않습니다. 이 함수 호출 중에 디렉터리에서 파일이"
" 제거되거나 추가되면, 해당 파일의 이름이 포함되는지는 지정되지 않습니다."

#: ../../library/os.rst:2292
msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes``"
" (directly or indirectly through the :class:`PathLike` interface), the "
"filenames returned will also be of type ``bytes``; in all other "
"circumstances, they will be of type ``str``."
msgstr ""
"*path*\\는 :term:`경로류 객체 <path-like object>` 일 수 있습니다. *path* 가 ``bytes`` "
"형이면 (직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로), 반환되는 파일명도 ``bytes`` 형입니다; "
"다른 모든 상황에서는 형 ``str``\\이 됩니다."

#: ../../library/os.rst:2297 ../../library/os.rst:2789
msgid ""
"This function can also support :ref:`specifying a file descriptor "
"<path_fd>`; the file descriptor must refer to a directory."
msgstr "이 함수는 또한 :ref:`파일 기술자 지정 <path_fd>`\\을 지원할 수 있습니다; 파일 기술자는 디렉터리를 참조해야 합니다."

#: ../../library/os.rst:2300
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listdir`` with argument "
"``path``."
msgstr ""
"``path``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.listdir``\\을 발생시킵니다."

#: ../../library/os.rst:2303
msgid "To encode ``str`` filenames to ``bytes``, use :func:`~os.fsencode`."
msgstr "``str`` 파일명을 ``bytes``\\로 인코딩하려면, :func:`~os.fsencode`\\를 사용하십시오."

#: ../../library/os.rst:2307
msgid ""
"The :func:`scandir` function returns directory entries along with file "
"attribute information, giving better performance for many common use "
"cases."
msgstr ""
":func:`scandir` 함수는 파일 어트리뷰트 정보와 함께 디렉터리 항목을 반환하므로, 많은 일반적인 사용 사례에서 더 나은 "
"성능을 제공합니다."

#: ../../library/os.rst:2311
msgid "The *path* parameter became optional."
msgstr "*path* 매개 변수는 선택 사항이 되었습니다."

#: ../../library/os.rst:2314 ../../library/os.rst:3328
msgid "Added support for specifying *path* as an open file descriptor."
msgstr "*path*\\에 열린 파일 기술자를 지정하는 지원이 추가되었습니다."

#: ../../library/os.rst:2323
msgid "Return a list containing the names of drives on a Windows system."
msgstr ""

#: ../../library/os.rst:2325
msgid ""
"A drive name typically looks like ``'C:\\\\'``. Not every drive name will"
" be associated with a volume, and some may be inaccessible for a variety "
"of reasons, including permissions, network connectivity or missing media."
" This function does not test for access."
msgstr ""

#: ../../library/os.rst:2330
msgid "May raise :exc:`OSError` if an error occurs collecting the drive names."
msgstr ""

#: ../../library/os.rst:2333
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listdrives`` with no "
"arguments."
msgstr "인자 없이 :ref:`감사 이벤트(auditing event) <auditing>` ``os.fork``\\를 발생시킵니다."

#: ../../library/os.rst:2342
msgid ""
"Return a list containing the mount points for a volume on a Windows "
"system."
msgstr ""

#: ../../library/os.rst:2345
msgid ""
"*volume* must be represented as a GUID path, like those returned by "
":func:`os.listvolumes`. Volumes may be mounted in multiple locations or "
"not at all. In the latter case, the list will be empty. Mount points that"
" are not associated with a volume will not be returned by this function."
msgstr ""

#: ../../library/os.rst:2351
msgid ""
"The mount points return by this function will be absolute paths, and may "
"be longer than the drive name."
msgstr ""

#: ../../library/os.rst:2354
msgid ""
"Raises :exc:`OSError` if the volume is not recognized or if an error "
"occurs collecting the paths."
msgstr ""

#: ../../library/os.rst:2357
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listmounts`` with "
"argument ``volume``."
msgstr ""
"``command``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.system``\\을 발생시킵니다."

#: ../../library/os.rst:2366
msgid "Return a list containing the volumes in the system."
msgstr ""

#: ../../library/os.rst:2368
#, python-brace-format
msgid ""
"Volumes are typically represented as a GUID path that looks like "
"``\\\\?\\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\\``. Files can "
"usually be accessed through a GUID path, permissions allowing. However, "
"users are generally not familiar with them, and so the recommended use of"
" this function is to retrieve mount points using :func:`os.listmounts`."
msgstr ""

#: ../../library/os.rst:2375
msgid "May raise :exc:`OSError` if an error occurs collecting the volumes."
msgstr ""

#: ../../library/os.rst:2377
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listvolumes`` with no "
"arguments."
msgstr "인자 없이 :ref:`감사 이벤트(auditing event) <auditing>` ``os.fork``\\를 발생시킵니다."

#: ../../library/os.rst:2386
#, fuzzy
msgid ""
"Perform the equivalent of an :c:func:`!lstat` system call on the given "
"path. Similar to :func:`~os.stat`, but does not follow symbolic links. "
"Return a :class:`stat_result` object."
msgstr ""
"주어진 경로에 대해 :c:func:`lstat` 시스템 호출과 동등한 작업을 수행합니다. :func:`~os.stat`\\와 "
"유사하지만, 심볼릭 링크를 따르지 않습니다. :class:`stat_result` 객체를 반환합니다."

#: ../../library/os.rst:2390
msgid ""
"On platforms that do not support symbolic links, this is an alias for "
":func:`~os.stat`."
msgstr "심볼릭 링크를 지원하지 않는 플랫폼에서, 이 함수는 :func:`~os.stat`\\의 별칭입니다."

#: ../../library/os.rst:2393
msgid ""
"As of Python 3.3, this is equivalent to ``os.stat(path, dir_fd=dir_fd, "
"follow_symlinks=False)``."
msgstr ""
"파이썬 3.3부터는, ``os.stat(path, dir_fd=dir_fd, follow_symlinks=False)``\\와 "
"같습니다."

#: ../../library/os.rst:2396 ../../library/os.rst:2438
#: ../../library/os.rst:2506 ../../library/os.rst:2534
#: ../../library/os.rst:2608
msgid ""
"This function can also support :ref:`paths relative to directory "
"descriptors <dir_fd>`."
msgstr "이 기능은 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\도 지원할 수 있습니다."

#: ../../library/os.rst:2403 ../../library/os.rst:2617
#: ../../library/os.rst:3462
msgid "Added support for Windows 6.0 (Vista) symbolic links."
msgstr "윈도우 6.0 (Vista) 심볼릭 링크에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:2412
msgid ""
"On Windows, now opens reparse points that represent another path (name "
"surrogates), including symbolic links and directory junctions. Other "
"kinds of reparse points are resolved by the operating system as for "
":func:`~os.stat`."
msgstr ""
"윈도우에서, 이제 심볼릭 링크와 디렉터리 정션(directory junction)을 포함하는 다른 경로를 나타내는 재해석 "
"지점(reparse point, 이름 서로게이트)을 엽니다. 다른 유형의 재해석 지점은 운영 체제에서 "
":func:`~os.stat`\\에서 처럼 결정됩니다."

#: ../../library/os.rst:2421
msgid "Create a directory named *path* with numeric mode *mode*."
msgstr "숫자 모드 *mode*\\로 *path* 라는 디렉터리를 만듭니다."

#: ../../library/os.rst:2423
#, fuzzy
msgid ""
"If the directory already exists, :exc:`FileExistsError` is raised. If a "
"parent directory in the path does not exist, :exc:`FileNotFoundError` is "
"raised."
msgstr "디렉터리가 이미 존재하면, :exc:`FileExistsError`\\가 발생합니다."

#: ../../library/os.rst:2428
msgid ""
"On some systems, *mode* is ignored.  Where it is used, the current umask "
"value is first masked out.  If bits other than the last 9 (i.e. the last "
"3 digits of the octal representation of the *mode*) are set, their "
"meaning is platform-dependent.  On some platforms, they are ignored and "
"you should call :func:`chmod` explicitly to set them."
msgstr ""
"일부 시스템에서는, *mode*\\가 무시됩니다. 모드가 사용될 때, 현재 umask 값으로 먼저 마스킹합니다. 마지막 9비트 "
"(즉, *mode* 의 8진 표현의 마지막 3자리 수) 이외의 비트가 설정되면, 그 의미는 플랫폼에 따라 다릅니다. 일부 "
"플랫폼에서는, 이것들이 무시되며, 설정하려면 명시적으로 :func:`chmod`\\를 호출해야 합니다."

#: ../../library/os.rst:2434
msgid ""
"On Windows, a *mode* of ``0o700`` is specifically handled to apply access"
" control to the new directory such that only the current user and "
"administrators have access. Other values of *mode* are ignored."
msgstr ""

#: ../../library/os.rst:2441
msgid ""
"It is also possible to create temporary directories; see the "
":mod:`tempfile` module's :func:`tempfile.mkdtemp` function."
msgstr ""
"임시 디렉터리를 만들 수도 있습니다; :mod:`tempfile` 모듈의 :func:`tempfile.mkdtemp` 함수를 "
"참조하십시오."

#: ../../library/os.rst:2444 ../../library/os.rst:2481
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.mkdir`` with arguments "
"``path``, ``mode``, ``dir_fd``."
msgstr ""
"``path``, ``mode``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``os.mkdir``\\을 발생시킵니다."

#: ../../library/os.rst:2452
msgid "Windows now handles a *mode* of ``0o700``."
msgstr ""

#: ../../library/os.rst:2462
msgid ""
"Recursive directory creation function.  Like :func:`mkdir`, but makes all"
" intermediate-level directories needed to contain the leaf directory."
msgstr ""
"재귀적 디렉터리 생성 함수. :func:`mkdir`\\와 비슷하지만, 말단 디렉터리를 포함하는 데 필요한 모든 중간 수준 "
"디렉터리들을 만듭니다."

#: ../../library/os.rst:2465
#, fuzzy
msgid ""
"The *mode* parameter is passed to :func:`mkdir` for creating the leaf "
"directory; see :ref:`the mkdir() description <mkdir_modebits>` for how it"
" is interpreted.  To set the file permission bits of any newly created "
"parent directories you can set the umask before invoking "
":func:`makedirs`.  The file permission bits of existing parent "
"directories are not changed."
msgstr ""
"*mode* 매개 변수는 말단 디렉터리를 만들기 위해 :func:`mkdir`\\로 전달됩니다; 이것이 어떻게 해석되는지는 "
":ref:`mkdir() 설명 <mkdir_modebits>`\\을 보십시오. 새로 만들어지는 부모 디렉터리들의 파일 권한 비트를 "
"설정하려면, :func:`makedirs`\\를 호출하기 전에 umask를 설정할 수 있습니다. 이미 존재하는 부모 디렉터리의 파일"
" 권한 비트는 변경되지 않습니다."

#: ../../library/os.rst:2471
#, fuzzy
msgid ""
"If *exist_ok* is ``False`` (the default), a :exc:`FileExistsError` is "
"raised if the target directory already exists."
msgstr ""
"*exist_ok* 가 ``False``\\(기본값)면, 대상 디렉터리가 이미 있을 때 "
":exc:`FileExistsError`\\가 발생합니다."

#: ../../library/os.rst:2476
msgid ""
":func:`makedirs` will become confused if the path elements to create "
"include :data:`pardir` (eg. \"..\" on UNIX systems)."
msgstr ""
":func:`makedirs`\\는 생성할 경로 요소에 :data:`pardir`\\(예를 들어, 유닉스 시스템의 경우 "
"\"..\")이 포함되어 있으면 혼란해 할 수 있습니다."

#: ../../library/os.rst:2479
msgid "This function handles UNC paths correctly."
msgstr "이 함수는 UNC 경로를 올바르게 처리합니다."

#: ../../library/os.rst:2483
#, fuzzy
msgid "Added the *exist_ok* parameter."
msgstr "*exist_ok* 매개 변수."

#: ../../library/os.rst:2488
msgid ""
"Before Python 3.4.1, if *exist_ok* was ``True`` and the directory "
"existed, :func:`makedirs` would still raise an error if *mode* did not "
"match the mode of the existing directory. Since this behavior was "
"impossible to implement safely, it was removed in Python 3.4.1. See "
":issue:`21082`."
msgstr ""
"파이썬 3.4.1 이전에는, *exist_ok* 가 ``True``\\이고 디렉터리가 존재한다면, *mode* 가 기존 디렉터리의 "
"모드와 일치하지 않을 때, :func:`makedirs`\\는 여전히 에러를 발생시킵니다. 이 동작은 안전하게 구현할 수 없으므로,"
" 파이썬 3.4.1에서 제거되었습니다. :issue:`21082`\\를 참조하십시오."

#: ../../library/os.rst:2496
#, fuzzy
msgid ""
"The *mode* argument no longer affects the file permission bits of newly "
"created intermediate-level directories."
msgstr "*mode* 인자는 더는 새로 만들어지는 중간 수준 디렉터리의 파일 권한 비트에 영향을 주지 않습니다."

#: ../../library/os.rst:2503
msgid ""
"Create a FIFO (a named pipe) named *path* with numeric mode *mode*. The "
"current umask value is first masked out from the mode."
msgstr ""
"숫자 모드 *mode*\\로 *path* 라는 이름의 FIFO(이름있는 파이프)를 만듭니다. 현재 umask 값으로 먼저 모드를 "
"마스킹합니다."

#: ../../library/os.rst:2509
msgid ""
"FIFOs are pipes that can be accessed like regular files.  FIFOs exist "
"until they are deleted (for example with :func:`os.unlink`). Generally, "
"FIFOs are used as rendezvous between \"client\" and \"server\" type "
"processes: the server opens the FIFO for reading, and the client opens it"
" for writing.  Note that :func:`mkfifo` doesn't open the FIFO --- it just"
" creates the rendezvous point."
msgstr ""
"FIFO는 일반 파일처럼 액세스할 수 있는 파이프입니다. FIFO는 삭제될 때까지 존재합니다 (예를 들어 "
":func:`os.unlink`\\로). 일반적으로, FIFO는 \"클라이언트\"와 \"서버\" 유형 프로세스 사이에서 랑데부로 "
"사용됩니다: 서버는 FIFO를 읽기 용도로 열고, 클라이언트는 쓰기 용도로 엽니다. :func:`mkfifo`\\가 FIFO를 "
"열지는 않는다는 점에 유의하십시오 --- 단지 랑데부 포인트를 생성합니다."

#: ../../library/os.rst:2526
msgid ""
"Create a filesystem node (file, device special file or named pipe) named "
"*path*. *mode* specifies both the permissions to use and the type of node"
" to be created, being combined (bitwise OR) with one of ``stat.S_IFREG``,"
" ``stat.S_IFCHR``, ``stat.S_IFBLK``, and ``stat.S_IFIFO`` (those "
"constants are available in :mod:`stat`).  For ``stat.S_IFCHR`` and "
"``stat.S_IFBLK``, *device* defines the newly created device special file "
"(probably using :func:`os.makedev`), otherwise it is ignored."
msgstr ""
"*path* 라는 이름의 파일 시스템 노드(파일, 장치 특수 파일 또는 이름있는 파이프)를 만듭니다. *mode* 는 사용 권한과 "
"생성될 노드의 유형을 모두 지정하며, ``stat.S_IFREG``, ``stat.S_IFCHR``, ``stat.S_IFBLK``"
" 및 ``stat.S_IFIFO`` 중 하나와 결합(비트별 OR)합니다 (이 상수들은 :mod:`stat`\\에 있습니다). "
"``stat.S_IFCHR``\\와 ``stat.S_IFBLK``\\의 경우, *device* 는 새로 만들어지는 장치 특수 "
"파일(아마도 :func:`os.makedev`\\를 사용해서)을 정의합니다, 그렇지 않으면 무시됩니다."

#: ../../library/os.rst:2548
#, fuzzy
msgid ""
"Extract the device major number from a raw device number (usually the "
":attr:`st_dev` or :attr:`st_rdev` field from :c:struct:`stat`)."
msgstr ""
"원시 장치 번호(보통 :c:type:`stat`\\의 :attr:`st_dev` 이나 :attr:`st_rdev` 어트리뷰트)에서 "
"장치 주 번호를 추출합니다."

#: ../../library/os.rst:2554
#, fuzzy
msgid ""
"Extract the device minor number from a raw device number (usually the "
":attr:`st_dev` or :attr:`st_rdev` field from :c:struct:`stat`)."
msgstr ""
"원시 장치 번호(보통 :c:type:`stat`\\의 :attr:`st_dev` 이나 :attr:`st_rdev` 어트리뷰트)에서 "
"장치 부 번호를 추출합니다."

#: ../../library/os.rst:2560
msgid "Compose a raw device number from the major and minor device numbers."
msgstr "주 장치 번호와 부 장치 번호로 원시 장치 번호를 조립합니다."

#: ../../library/os.rst:2565
msgid ""
"Return system configuration information relevant to a named file. *name* "
"specifies the configuration value to retrieve; it may be a string which "
"is the name of a defined system value; these names are specified in a "
"number of standards (POSIX.1, Unix 95, Unix 98, and others).  Some "
"platforms define additional names as well.  The names known to the host "
"operating system are given in the ``pathconf_names`` dictionary.  For "
"configuration variables not included in that mapping, passing an integer "
"for *name* is also accepted."
msgstr ""
"이름있는 파일과 관련된 시스템 구성 정보를 반환합니다. *name* 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 "
"문자열일 수 있습니다; 이 이름은 여러 표준(POSIX.1, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 "
"추가적인 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 ``pathconf_names`` 딕셔너리에서 제공됩니다. 이 매핑에"
" 포함되지 않은 구성 변수를 위해, *name*\\에 정수를 전달하는 것도 허용됩니다."

#: ../../library/os.rst:2578 ../../library/os.rst:3321
#: ../../library/os.rst:3490
msgid "This function can support :ref:`specifying a file descriptor <path_fd>`."
msgstr "이 함수는 :ref:`파일 기술자 지정 <path_fd>`\\을 지원할 수 있습니다."

#: ../../library/os.rst:2589
msgid ""
"Dictionary mapping names accepted by :func:`pathconf` and "
":func:`fpathconf` to the integer values defined for those names by the "
"host operating system.  This can be used to determine the set of names "
"known to the system."
msgstr ""
":func:`pathconf`\\와 :func:`fpathconf`\\가 받아들이는 이름을 호스트 운영 체제에서 해당 이름에 대해 "
"정의된 정숫값으로 매핑하는 딕셔너리. 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다."

#: ../../library/os.rst:2598
msgid ""
"Return a string representing the path to which the symbolic link points."
"  The result may be either an absolute or relative pathname; if it is "
"relative, it may be converted to an absolute pathname using "
"``os.path.join(os.path.dirname(path), result)``."
msgstr ""
"심볼릭 링크가 가리키는 경로를 나타내는 문자열을 반환합니다. 결과는 절대 또는 상대 경로명일 수 있습니다; 상대 경로이면 "
"``os.path.join(os.path.dirname(path), result)``\\를 사용하여 절대 경로명으로 변환할 수 "
"있습니다."

#: ../../library/os.rst:2603
msgid ""
"If the *path* is a string object (directly or indirectly through a "
":class:`PathLike` interface), the result will also be a string object, "
"and the call may raise a UnicodeDecodeError. If the *path* is a bytes "
"object (direct or indirectly), the result will be a bytes object."
msgstr ""
"*path* 가 (직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로) 문자열 객체면, 결과도 문자열 객체가 "
"되고, 호출은 UnicodeDecodeError를 발생시킬 수 있습니다. *path* 가 (직접 또는 간접적으로) 바이트열 객체면,"
" 결과는 바이트열 객체가 됩니다."

#: ../../library/os.rst:2611
msgid ""
"When trying to resolve a path that may contain links, use "
":func:`~os.path.realpath` to properly handle recursion and platform "
"differences."
msgstr ""
"링크를 포함할 수 있는 경로를 결정(resolve)하려고 할 때, :func:`~os.path.realpath`\\를 사용하여 "
"재귀와 플랫폼 차이를 올바르게 처리하십시오."

#: ../../library/os.rst:2623
msgid "Accepts a :term:`path-like object` on Unix."
msgstr "유닉스에서 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/os.rst:2626
msgid "Accepts a :term:`path-like object` and a bytes object on Windows."
msgstr "윈도우에서 :term:`경로류 객체 <path-like object>`\\와 바이트열 객체를 받아들입니다."

#: ../../library/os.rst:2629
msgid ""
"Added support for directory junctions, and changed to return the "
"substitution path (which typically includes ``\\\\?\\`` prefix) rather "
"than the optional \"print name\" field that was previously returned."
msgstr ""
"디렉터리 정션(directory junction)에 대한 지원이 추가되었고, 이전에 반환되던 선택적 \"print name\" 필드"
" 대신 치환 경로(일반적으로 ``\\\\?\\`` 접두사를 포함합니다)를 반환하도록 변경되었습니다."

#: ../../library/os.rst:2635
#, fuzzy
msgid ""
"Remove (delete) the file *path*.  If *path* is a directory, an "
":exc:`OSError` is raised.  Use :func:`rmdir` to remove directories. If "
"the file does not exist, a :exc:`FileNotFoundError` is raised."
msgstr ""
"파일 *path*\\를 제거(삭제)합니다. *path* 가 디렉터리면, :exc:`IsADirectoryError`\\가 "
"발생합니다. 디렉터리를 제거하려면 :func:`rmdir`\\를 사용하십시오."

#: ../../library/os.rst:2639 ../../library/os.rst:2752
#: ../../library/os.rst:3441
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr "이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 지원할 수 있습니다."

#: ../../library/os.rst:2642
msgid ""
"On Windows, attempting to remove a file that is in use causes an "
"exception to be raised; on Unix, the directory entry is removed but the "
"storage allocated to the file is not made available until the original "
"file is no longer in use."
msgstr ""
"윈도우에서, 사용 중인 파일을 제거하려고 시도하면 예외가 발생합니다; 유닉스에서는 디렉터리 항목이 제거되지만, 원본 파일이 더는 "
"사용되지 않을 때까지 파일에 할당된 저장 공간을 사용할 수 없습니다."

#: ../../library/os.rst:2646
msgid "This function is semantically identical to :func:`unlink`."
msgstr "이 함수는 의미 적으로 :func:`unlink`\\와 같습니다."

#: ../../library/os.rst:2648 ../../library/os.rst:2670
#: ../../library/os.rst:3512
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.remove`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"``path``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.remove``\\를 발생시킵니다."

#: ../../library/os.rst:2661
msgid ""
"Remove directories recursively.  Works like :func:`rmdir` except that, if"
" the leaf directory is successfully removed, :func:`removedirs`  tries to"
" successively remove every parent directory mentioned in  *path* until an"
" error is raised (which is ignored, because it generally means that a "
"parent directory is not empty). For example, "
"``os.removedirs('foo/bar/baz')`` will first remove the directory "
"``'foo/bar/baz'``, and then remove ``'foo/bar'`` and ``'foo'`` if they "
"are empty. Raises :exc:`OSError` if the leaf directory could not be "
"successfully removed."
msgstr ""
"재귀적으로 디렉터리를 제거합니다. :func:`rmdir` 처럼 동작하는데 다음과 같은 차이가 있습니다. 말단 디렉터리가 성공적으로"
" 제거되면, :func:`removedirs`\\는 에러가 발생할 때까지 *path*\\에 언급된 모든 상위 디렉터리를 연속적으로 "
"제거하려고 합니다 (에러는 무시되는데, 이는 일반적으로 부모 디렉터리가 비어 있음을 뜻하기 때문입니다). 예를 들어, "
"``os.removedirs('foo/bar/baz')``\\는 먼저 ``'foo/bar/baz'`` 디렉터리를 제거한 다음, "
"``'foo/bar'`` 및 ``'foo'``\\가 비어 있으면 제거합니다. 말단 디렉터리를 성공적으로 제거할 수 없으면, "
":exc:`OSError`\\를 발생시킵니다."

#: ../../library/os.rst:2678
msgid ""
"Rename the file or directory *src* to *dst*. If *dst* exists, the "
"operation will fail with an :exc:`OSError` subclass in a number of cases:"
msgstr ""
"파일 또는 디렉터리 *src*\\의 이름을 *dst*\\로 바꿉니다. *dst*\\가 존재하면, 많은 경우에 "
":exc:`OSError` 서브 클래스로 연산이 실패합니다:"

#: ../../library/os.rst:2681
msgid ""
"On Windows, if *dst* exists a :exc:`FileExistsError` is always raised. "
"The operation may fail if *src* and *dst* are on different filesystems. "
"Use :func:`shutil.move` to support moves to a different filesystem."
msgstr ""

#: ../../library/os.rst:2685
#, fuzzy
msgid ""
"On Unix, if *src* is a file and *dst* is a directory or vice-versa, an "
":exc:`IsADirectoryError` or a :exc:`NotADirectoryError` will be raised "
"respectively.  If both are directories and *dst* is empty, *dst* will be "
"silently replaced.  If *dst* is a non-empty directory, an :exc:`OSError` "
"is raised. If both are files, *dst* will be replaced silently if the user"
" has permission.  The operation may fail on some Unix flavors if *src* "
"and *dst* are on different filesystems.  If successful, the renaming will"
" be an atomic operation (this is a POSIX requirement)."
msgstr ""
"유닉스에서, *src*\\가 파일이고 *dst*\\가 디렉터리이거나 그 반대면, :exc:`IsADirectoryError`\\나 "
":exc:`NotADirectoryError`\\가 각각 발생합니다. 둘 다 디렉터리이고 *dst*\\가 비어 있으면, "
"*dst*\\는 조용히 대체됩니다. *dst*\\가 비어 있지 않은 디렉터리면, :exc:`OSError`\\가 발생합니다. 둘 다"
" 파일이면, *dst*\\는 사용자에게 권한이 있을 때 자동으로 대체됩니다. *src* 와 *dst* 가 다른 파일 시스템에 있을 "
"때, 일부 유닉스 환경에서 작업이 실패할 수 있습니다. 성공하면, 이름 바꾸기는 원자적 연산이 됩니다 (이것은 POSIX 요구 "
"사항입니다)."

#: ../../library/os.rst:2694 ../../library/os.rst:2734
msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`."
msgstr ""
"이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 제공하도록 *src_dir_fd* 와/나 "
"*dst_dir_fd* 를 지정하는 것을 지원할 수 있습니다."

#: ../../library/os.rst:2697
msgid ""
"If you want cross-platform overwriting of the destination, use "
":func:`replace`."
msgstr "플랫폼에 무관하게 대상을 덮어쓰길 원하면, :func:`replace`\\를 사용하십시오."

#: ../../library/os.rst:2699 ../../library/os.rst:2720
#: ../../library/os.rst:2737
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.rename`` with arguments "
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``."
msgstr ""
"``src``, ``dst``, ``src_dir_fd``, ``dst_dir_fd``\\를 인자로 :ref:`감사 "
"이벤트(auditing event) <auditing>` ``os.rename``\\을 발생시킵니다."

#: ../../library/os.rst:2701
#, fuzzy
msgid "Added the *src_dir_fd* and *dst_dir_fd* parameters."
msgstr "*src_dir_fd* 및 *dst_dir_fd* 인자"

#: ../../library/os.rst:2710
msgid ""
"Recursive directory or file renaming function. Works like :func:`rename`,"
" except creation of any intermediate directories needed to make the new "
"pathname good is attempted first. After the rename, directories "
"corresponding to rightmost path segments of the old name will be pruned "
"away using :func:`removedirs`."
msgstr ""
"재귀적 디렉터리 또는 파일 이름 바꾸기 함수. :func:`rename`\\처럼 작동하지만, 새 경로명이 유효하도록 만들기 위해 "
"먼저 필요한 중간 디렉터리를 만드는 점이 다릅니다. 이름을 변경한 후에는, 이전 이름의 가장 오른쪽 경로 세그먼트에 해당하는 "
"디렉터리를 :func:`removedirs`\\를 사용하여 제거합니다."

#: ../../library/os.rst:2717
msgid ""
"This function can fail with the new directory structure made if you lack "
"permissions needed to remove the leaf directory or file."
msgstr "이 함수는 말단 디렉터리나 파일을 제거하는 데 필요한 권한이 없을 때, 새 디렉터리 구조를 만든 상태에서 실패할 수 있습니다."

#: ../../library/os.rst:2722
msgid "Accepts a :term:`path-like object` for *old* and *new*."
msgstr "*old* 와 *new* 에 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/os.rst:2728
#, fuzzy
msgid ""
"Rename the file or directory *src* to *dst*.  If *dst* is a non-empty "
"directory, :exc:`OSError` will be raised.  If *dst* exists and is a file,"
" it will be replaced silently if the user has permission.  The operation "
"may fail if *src* and *dst* are on different filesystems.  If successful,"
" the renaming will be an atomic operation (this is a POSIX requirement)."
msgstr ""
"파일 또는 디렉터리 *src*\\의 이름을 *dst*\\로 바꿉니다. *dst* 가 디렉터리면, :exc:`OSError`\\가 "
"발생합니다. *dst* 가 존재하고 파일이면, 사용자에게 권한이 있을 때 자동으로 대체됩니다. *src* 와 *dst* 가 다른 "
"파일 시스템에 있으면, 작업이 실패할 수 있습니다. 성공하면, 이름 바꾸기는 원자적 연산이 됩니다 (이것은 POSIX 요구 "
"사항입니다)."

#: ../../library/os.rst:2747
#, fuzzy
msgid ""
"Remove (delete) the directory *path*.  If the directory does not exist or"
" is not empty, a :exc:`FileNotFoundError` or an :exc:`OSError` is raised "
"respectively.  In order to remove whole directory trees, "
":func:`shutil.rmtree` can be used."
msgstr ""
"디렉터리 *path*\\를 제거(삭제)합니다. 디렉터리가 존재하지 않거나 비어 있지 않으면, "
":exc:`FileNotFoundError`\\나 :exc:`OSError`\\가 각각 발생합니다. 전체 디렉터리 트리를 "
"제거하려면, :func:`shutil.rmtree`\\를 사용할 수 있습니다."

#: ../../library/os.rst:2755
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.rmdir`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"``path``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.rmdir``\\을 발생시킵니다."

#: ../../library/os.rst:2766
msgid ""
"Return an iterator of :class:`os.DirEntry` objects corresponding to the "
"entries in the directory given by *path*. The entries are yielded in "
"arbitrary order, and the special entries ``'.'`` and ``'..'`` are not "
"included.  If a file is removed from or added to the directory after "
"creating the iterator, whether an entry for that file be included is "
"unspecified."
msgstr ""
"*path*\\로 지정된 디렉터리 내의 항목에 대응하는 :class:`os.DirEntry` 객체의 이터레이터를 돌려줍니다. 항목은"
" 임의의 순서로 제공되며, 특수 항목 ``'.'`` 및 ``'..'``\\는 포함되지 않습니다. 이터레이터를 만든 후에 디렉터리에서"
" 파일이 제거되거나 추가되면, 해당 파일의 항목이 포함되는지는 지정되지 않습니다."

#: ../../library/os.rst:2773
msgid ""
"Using :func:`scandir` instead of :func:`listdir` can significantly "
"increase the performance of code that also needs file type or file "
"attribute information, because :class:`os.DirEntry` objects expose this "
"information if the operating system provides it when scanning a "
"directory. All :class:`os.DirEntry` methods may perform a system call, "
"but :func:`~os.DirEntry.is_dir` and :func:`~os.DirEntry.is_file` usually "
"only require a system call for symbolic links; :func:`os.DirEntry.stat` "
"always requires a system call on Unix but only requires one for symbolic "
"links on Windows."
msgstr ""
":func:`listdir` 대신 :func:`scandir`\\를 사용하면, 디렉터리를 검색할 때 운영 체제가 제공한다면 "
":class:`os.DirEntry` 객체가 파일 유형과 파일 어트리뷰트 정보를 제공하기 때문에, 이것들이 필요한 코드의 성능을 "
"크게 개선할 수 있습니다. 모든 :class:`os.DirEntry` 메서드가 시스템 호출을 수행할 수 있지만, 일반적으로 "
":func:`~os.DirEntry.is_dir` 및 :func:`~os.DirEntry.is_file`\\는 심볼릭 링크에 "
"대해서만 시스템 호출을 요구합니다; :func:`os.DirEntry.stat`\\는 유닉스에서 항상 시스템 호출을 요구하지만 "
"윈도우에서는 심볼릭 링크에 대해서만 시스템 호출을 요구합니다."

#: ../../library/os.rst:2783
msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes``"
" (directly or indirectly through the :class:`PathLike` interface), the "
"type of the :attr:`~os.DirEntry.name` and :attr:`~os.DirEntry.path` "
"attributes of each :class:`os.DirEntry` will be ``bytes``; in all other "
"circumstances, they will be of type ``str``."
msgstr ""
"*path* 는 :term:`경로류 객체 <path-like object>` 일 수 있습니다. *path* 가 (직접 또는 "
":class:`PathLike` 인터페이스를 통해 간접적으로) ``bytes`` 형이면, 각 "
":class:`os.DirEntry`\\의 :attr:`~os.DirEntry.name` 및 "
":attr:`~os.DirEntry.path` 어트리뷰트의 형은 ``bytes``\\입니다. 다른 모든 상황에서는 형 "
"``str``\\이 됩니다."

#: ../../library/os.rst:2792
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.scandir`` with argument "
"``path``."
msgstr ""
"``path``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.scandir``\\을 발생시킵니다."

#: ../../library/os.rst:2794
msgid ""
"The :func:`scandir` iterator supports the :term:`context manager` "
"protocol and has the following method:"
msgstr ""
":func:`scandir` 이터레이터는 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원하고 다음과 "
"같은 메서드를 제공합니다:"

#: ../../library/os.rst:2799
msgid "Close the iterator and free acquired resources."
msgstr "이터레이터를 닫고 확보한 자원을 반납합니다."

#: ../../library/os.rst:2801
msgid ""
"This is called automatically when the iterator is exhausted or garbage "
"collected, or when an error happens during iterating.  However it is "
"advisable to call it explicitly or use the :keyword:`with` statement."
msgstr ""
"이터레이터가 소진되거나 가비지 수집될 때 또는 이터레이션 중에 에러가 발생하면 자동으로 호출됩니다. 하지만 명시적으로 호출하거나 "
":keyword:`with` 문을 사용하는 것이 좋습니다."

#: ../../library/os.rst:2808
msgid ""
"The following example shows a simple use of :func:`scandir` to display "
"all the files (excluding directories) in the given *path* that don't "
"start with ``'.'``. The ``entry.is_file()`` call will generally not make "
"an additional system call::"
msgstr ""
"다음 예제는 주어진 *path*\\의 ``'.'``\\로 시작하지 않는 모든 파일(디렉터리 제외)을 표시하기 위한 "
":func:`scandir`\\의 간단한 사용을 보여줍니다. ``entry.is_file()`` 호출은 일반적으로 추가 시스템 "
"호출을 하지 않습니다::"

#: ../../library/os.rst:2813
msgid ""
"with os.scandir(path) as it:\n"
"    for entry in it:\n"
"        if not entry.name.startswith('.') and entry.is_file():\n"
"            print(entry.name)"
msgstr ""

#: ../../library/os.rst:2820
#, fuzzy
msgid ""
"On Unix-based systems, :func:`scandir` uses the system's `opendir() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_"
" and `readdir() "
"<https://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html>`_"
" functions. On Windows, it uses the Win32 `FindFirstFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364418(v=vs.85).aspx>`_ and `FindNextFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364428(v=vs.85).aspx>`_ functions."
msgstr ""
"유닉스 기반 시스템에서, :func:`scandir`\\은 시스템의 `opendir() "
"<http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_"
" 과 `readdir() "
"<http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html>`_"
" 함수를 사용합니다. 윈도우에서는, Win32 `FindFirstFileW <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364418(v=vs.85).aspx>`_ 와 `FindNextFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364428(v=vs.85).aspx>`_ 함수를 사용합니다."

#: ../../library/os.rst:2832
#, fuzzy
msgid ""
"Added support for the :term:`context manager` protocol and the "
":func:`~scandir.close` method.  If a :func:`scandir` iterator is neither "
"exhausted nor explicitly closed a :exc:`ResourceWarning` will be emitted "
"in its destructor."
msgstr ""
":term:`컨텍스트 관리자 <context manager>` 프로토콜과 :func:`~scandir.close()` 메서드 대한 "
"지원이 추가되었습니다. :func:`scandir` 이터레이터가 모두 소진되거나 명시적으로 닫히지 않으면 "
":exc:`ResourceWarning`\\가 파괴자에서 방출됩니다."

#: ../../library/os.rst:2838
msgid "The function accepts a :term:`path-like object`."
msgstr "이 함수는 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/os.rst:2840
msgid "Added support for :ref:`file descriptors <path_fd>` on Unix."
msgstr "유닉스에서 :ref:`파일 기술자 <path_fd>`\\에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:2846
msgid ""
"Object yielded by :func:`scandir` to expose the file path and other file "
"attributes of a directory entry."
msgstr "디렉터리 항목의 파일 경로와 다른 파일 어트리뷰트를 노출하기 위해 :func:`scandir`\\에 의해 산출되는 객체."

#: ../../library/os.rst:2849
msgid ""
":func:`scandir` will provide as much of this information as possible "
"without making additional system calls. When a ``stat()`` or ``lstat()`` "
"system call is made, the ``os.DirEntry`` object will cache the result."
msgstr ""
":func:`scandir`\\는 추가 시스템 호출 없이 가능한 많은 정보를 제공합니다. ``stat()`` 또는 "
"``lstat()`` 시스템 호출이 이루어지면, ``os.DirEntry`` 객체는 결과를 캐시 합니다."

#: ../../library/os.rst:2853
msgid ""
"``os.DirEntry`` instances are not intended to be stored in long-lived "
"data structures; if you know the file metadata has changed or if a long "
"time has elapsed since calling :func:`scandir`, call "
"``os.stat(entry.path)`` to fetch up-to-date information."
msgstr ""
"``os.DirEntry`` 인스턴스는 수명이 긴 데이터 구조에 저장하는 용도가 아닙니다; 파일 메타 데이터가 변경되었거나 "
":func:`scandir`\\를 호출한 후 오랜 시간이 지났음을 안다면, ``os.stat(entry.path)``\\를 호출하여"
" 최신 정보를 가져오십시오."

#: ../../library/os.rst:2858
msgid ""
"Because the ``os.DirEntry`` methods can make operating system calls, they"
" may also raise :exc:`OSError`. If you need very fine-grained control "
"over errors, you can catch :exc:`OSError` when calling one of the "
"``os.DirEntry`` methods and handle as appropriate."
msgstr ""
"``os.DirEntry`` 메서드는 운영 체제 시스템 호출을 할 수 있으므로, :exc:`OSError`\\를 일으킬 수도 "
"있습니다. 에러에 대해 매우 세부적인 제어가 필요하면, ``os.DirEntry`` 메서드 중 하나를 호출할 때 "
":exc:`OSError`\\를 잡은 후 적절하게 처리할 수 있습니다."

#: ../../library/os.rst:2863
msgid ""
"To be directly usable as a :term:`path-like object`, ``os.DirEntry`` "
"implements the :class:`PathLike` interface."
msgstr ""
":term:`경로류 객체 <path-like object>`\\로 직접 사용할 수 있도록, ``os.DirEntry``\\는 "
":class:`PathLike` 인터페이스를 구현합니다."

#: ../../library/os.rst:2866
msgid "Attributes and methods on a ``os.DirEntry`` instance are as follows:"
msgstr "``os.DirEntry`` 인스턴스의 어트리뷰트 및 메서드는 다음과 같습니다:"

#: ../../library/os.rst:2870
msgid ""
"The entry's base filename, relative to the :func:`scandir` *path* "
"argument."
msgstr ":func:`scandir` *path* 인자에 상대적인, 항목의 기본(base) 파일명."

#: ../../library/os.rst:2873
msgid ""
"The :attr:`name` attribute will be ``bytes`` if the :func:`scandir` "
"*path* argument is of type ``bytes`` and ``str`` otherwise.  Use "
":func:`~os.fsdecode` to decode byte filenames."
msgstr ""
":attr:`name` 어트리뷰트는 :func:`scandir` *path* 인자가 ``bytes`` 형이면 ``bytes`` 고,"
" 그렇지 않으면 ``str`` 입니다. 바이트열 파일명을 디코딩하려면 :func:`~os.fsdecode`\\를 사용하십시오."

#: ../../library/os.rst:2879
msgid ""
"The entry's full path name: equivalent to ``os.path.join(scandir_path, "
"entry.name)`` where *scandir_path* is the :func:`scandir` *path* "
"argument.  The path is only absolute if the :func:`scandir` *path* "
"argument was absolute.  If the :func:`scandir` *path* argument was a "
":ref:`file descriptor <path_fd>`, the :attr:`path` attribute is the same "
"as the :attr:`name` attribute."
msgstr ""
"항목의 전체 경로명: ``os.path.join(scandir_path, entry.name)``\\과 같습니다. 여기서 "
"*scandir_path* 는 :func:`scandir` *path* 인자입니다. 경로는 :func:`scandir` *path*"
" 인자가 절대 경로일 때만 절대 경로입니다. :func:`scandir` *path* 인자가 :ref:`파일 기술자 "
"<path_fd>`\\면, :attr:`path` 어트리뷰트는 :attr:`name` 어트리뷰트와 같습니다."

#: ../../library/os.rst:2886
msgid ""
"The :attr:`path` attribute will be ``bytes`` if the :func:`scandir` "
"*path* argument is of type ``bytes`` and ``str`` otherwise.  Use "
":func:`~os.fsdecode` to decode byte filenames."
msgstr ""
":attr:`path` 어트리뷰트는 :func:`scandir` *path* 인자가 ``bytes`` 형이면 "
"``bytes``\\고, 그렇지 않으면 ``str`` 입니다. 바이트열 파일명을 디코딩하려면 "
":func:`~os.fsdecode`\\를 사용하십시오."

#: ../../library/os.rst:2892
msgid "Return the inode number of the entry."
msgstr "항목의 아이노드(inode) 번호를 반환합니다."

#: ../../library/os.rst:2894
msgid ""
"The result is cached on the ``os.DirEntry`` object. Use "
"``os.stat(entry.path, follow_symlinks=False).st_ino`` to fetch up-to-date"
" information."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 최신 정보를 가져오려면 ``os.stat(entry.path, "
"follow_symlinks=False).st_ino``\\를 사용하십시오."

#: ../../library/os.rst:2898
msgid ""
"On the first, uncached call, a system call is required on Windows but not"
" on Unix."
msgstr "최초의 캐시 되지 않은 호출에서, 윈도우 에서는 시스템 호출이 필요하지만, 유닉스에서는 그렇지 않습니다."

#: ../../library/os.rst:2903
msgid ""
"Return ``True`` if this entry is a directory or a symbolic link pointing "
"to a directory; return ``False`` if the entry is or points to any other "
"kind of file, or if it doesn't exist anymore."
msgstr ""
"이 항목이 디렉터리 또는 디렉터리를 가리키는 심볼릭 링크면 ``True``\\를 반환합니다; 항목이 다른 종류의 파일이거나 다른 "
"종류의 파일을 가리키면, 또는 더는 존재하지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:2907
msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is "
"a directory (without following symlinks); return ``False`` if the entry "
"is any other kind of file or if it doesn't exist anymore."
msgstr ""
"*follow_symlinks* 가 ``False``\\면, 이 항목이 디렉터리일 때만 (심볼릭 링크를 따르지 않고) "
"``True``\\를 반환합니다; 항목이 다른 종류의 파일이거나 더는 존재하지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:2911
msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache"
" for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` along"
" with :func:`stat.S_ISDIR` to fetch up-to-date information."
msgstr ""
"결과는 *follow_symlinks* 가 ``True`` 및 ``False``\\일 때에 대해 별도로 ``os.DirEntry``"
" 객체에 캐시 됩니다. 최신 정보를 가져오려면, :func:`stat.S_ISDIR`\\로 :func:`os.stat`\\을 "
"호출하십시오."

#: ../../library/os.rst:2915
msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, for non-symlinks, neither Windows or Unix require a system "
"call, except on certain Unix file systems, such as network file systems, "
"that return ``dirent.d_type == DT_UNKNOWN``. If the entry is a symlink, a"
" system call will be required to follow the symlink unless "
"*follow_symlinks* is ``False``."
msgstr ""
"최초의 캐시 되지 않은 호출에서, 대부분 시스템 호출이 필요하지 않습니다. 특히, 심볼릭 링크가 아니면, 윈도우나 유닉스 모두 "
"시스템 호출이 필요하지 않은데, 네트워크 파일 시스템과 같이 ``dirent.d_type == DT_UNKNOWN``\\를 반환하는"
" 특정 유닉스 파일 시스템은 예외입니다. 항목이 심볼릭 링크면, *follow_symlinks* 가 ``False``\\가 아닌 "
"이상, 심볼릭 링크를 따르기 위해 시스템 호출이 필요합니다."

#: ../../library/os.rst:2922 ../../library/os.rst:2952
msgid ""
"This method can raise :exc:`OSError`, such as :exc:`PermissionError`, but"
" :exc:`FileNotFoundError` is caught and not raised."
msgstr ""
"이 메서드는, :exc:`PermissionError`\\와 같은, :exc:`OSError`\\를 발생시킬 수 있지만, "
":exc:`FileNotFoundError`\\는 잡혀서 발생하지 않습니다."

#: ../../library/os.rst:2927
msgid ""
"Return ``True`` if this entry is a file or a symbolic link pointing to a "
"file; return ``False`` if the entry is or points to a directory or other "
"non-file entry, or if it doesn't exist anymore."
msgstr ""
"이 항목이 파일이나 파일을 가리키는 심볼릭 링크면 ``True``\\를 반환합니다; 항목이 디렉터리 또는 다른 비 파일 항목이거나,"
" 그런 것을 가리키거나, 더는 존재하지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:2931
msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is "
"a file (without following symlinks); return ``False`` if the entry is a "
"directory or other non-file entry, or if it doesn't exist anymore."
msgstr ""
"*follow_symlinks* 가 ``False``\\면, 이 항목이 파일일 때만 (심볼릭 링크를 따르지 않고) "
"``True``\\를 반환합니다; 항목이 디렉터리 나 다른 비 파일 항목이거나 더는 존재하지 않으면 ``False``\\를 "
"반환합니다."

#: ../../library/os.rst:2935
msgid ""
"The result is cached on the ``os.DirEntry`` object. Caching, system calls"
" made, and exceptions raised are as per :func:`~os.DirEntry.is_dir`."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 캐싱, 시스템 호출, 예외 발생은 "
":func:`~os.DirEntry.is_dir`\\과 같습니다."

#: ../../library/os.rst:2940
msgid ""
"Return ``True`` if this entry is a symbolic link (even if broken); return"
" ``False`` if the entry points to a directory or any kind of file, or if "
"it doesn't exist anymore."
msgstr ""
"이 항목이 심볼릭 링크면 (망가졌다 하더라도) ``True``\\를 반환합니다; 항목이 디렉터리 나 어떤 종류의 파일이거나 더는 "
"존재하지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:2944
msgid ""
"The result is cached on the ``os.DirEntry`` object. Call "
":func:`os.path.islink` to fetch up-to-date information."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 최신 정보를 가져오려면 :func:`os.path.islink`\\를 "
"호출하십시오."

#: ../../library/os.rst:2947
msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, neither Windows or Unix require a system call, except on "
"certain Unix file systems, such as network file systems, that return "
"``dirent.d_type == DT_UNKNOWN``."
msgstr ""
"첫 번째, 캐시 되지 않은 호출에서는 시스템 호출이 필요하지 않습니다. 특히 윈도우 나 유닉스는 ``dirent.d_type == "
"DT_UNKNOWN``\\를 반환하는 특정 유닉스 파일 시스템 (예 : 네트워크 파일 시스템)을 제외하고는 시스템 호출이 필요하지 "
"않습니다."

#: ../../library/os.rst:2957
#, fuzzy
msgid ""
"Return ``True`` if this entry is a junction (even if broken); return "
"``False`` if the entry points to a regular directory, any kind of file, a"
" symlink, or if it doesn't exist anymore."
msgstr ""
"이 항목이 심볼릭 링크면 (망가졌다 하더라도) ``True``\\를 반환합니다; 항목이 디렉터리 나 어떤 종류의 파일이거나 더는 "
"존재하지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:2961
#, fuzzy
msgid ""
"The result is cached on the ``os.DirEntry`` object. Call "
":func:`os.path.isjunction` to fetch up-to-date information."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 최신 정보를 가져오려면 :func:`os.path.islink`\\를 "
"호출하십시오."

#: ../../library/os.rst:2968
msgid ""
"Return a :class:`stat_result` object for this entry. This method follows "
"symbolic links by default; to stat a symbolic link add the "
"``follow_symlinks=False`` argument."
msgstr ""
"이 항목의 :class:`stat_result` 객체를 돌려줍니다. 이 메서드는 기본적으로 심볼릭 링크를 따릅니다; 심볼릭 링크를 "
"stat 하려면, ``follow_symlinks=False`` 인자를 추가하십시오."

#: ../../library/os.rst:2972
msgid ""
"On Unix, this method always requires a system call. On Windows, it only "
"requires a system call if *follow_symlinks* is ``True`` and the entry is "
"a reparse point (for example, a symbolic link or directory junction)."
msgstr ""
"유닉스에서, 이 메서드는 항상 시스템 호출을 요구합니다. 윈도우에서, *follow_symlinks* 가 ``True``\\이고 "
"항목이 재해석 지점(reparse point, 예를 들어, 심볼릭 링크나 디렉터리 정션(directory junction))일 때만"
" 시스템 호출이 필요합니다."

#: ../../library/os.rst:2977
msgid ""
"On Windows, the ``st_ino``, ``st_dev`` and ``st_nlink`` attributes of the"
" :class:`stat_result` are always set to zero. Call :func:`os.stat` to get"
" these attributes."
msgstr ""
"윈도우에서, :class:`stat_result`\\의 ``st_ino``, ``st_dev`` 및 ``st_nlink`` "
"어트리뷰트는 항상 0으로 설정됩니다. 이러한 어트리뷰트를 얻으려면 :func:`os.stat`\\을 호출하십시오."

#: ../../library/os.rst:2981
msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache"
" for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` to "
"fetch up-to-date information."
msgstr ""
"결과는 *follow_symlinks* 가 ``True`` 및 ``False``\\일 때에 대해 별도로 ``os.DirEntry``"
" 객체에 캐시 됩니다. 최신 정보를 가져오려면, :func:`os.stat`\\을 호출하십시오."

#: ../../library/os.rst:2985
#, fuzzy
msgid ""
"Note that there is a nice correspondence between several attributes and "
"methods of ``os.DirEntry`` and of :class:`pathlib.Path`.  In particular, "
"the ``name`` attribute has the same meaning, as do the ``is_dir()``, "
"``is_file()``, ``is_symlink()``, ``is_junction()``, and ``stat()`` "
"methods."
msgstr ""
"``os.DirEntry``\\와 :class:`pathlib.Path`\\의 여러 어트리뷰트와 메서드 사이에는 좋은 일치가 있음에"
" 유의하십시오. 특히, ``name`` 어트리뷰트는 ``is_dir()``, ``is_file()``, "
"``is_symlink()`` 및 ``stat()`` 메서드와 같은 의미가 있습니다."

#: ../../library/os.rst:2993
msgid ""
"Added support for the :class:`~os.PathLike` interface.  Added support for"
" :class:`bytes` paths on Windows."
msgstr ""
":class:`~os.PathLike` 인터페이스에 대한 지원이 추가되었습니다. 윈도우에서 :class:`bytes` 경로에 대한 "
"지원이 추가되었습니다."

#: ../../library/os.rst:2997
msgid ""
"The ``st_ctime`` attribute of a stat result is deprecated on Windows. The"
" file creation time is properly available as ``st_birthtime``, and in the"
" future ``st_ctime`` may be changed to return zero or the metadata change"
" time, if available."
msgstr ""

#: ../../library/os.rst:3006
msgid ""
"Get the status of a file or a file descriptor. Perform the equivalent of "
"a :c:func:`stat` system call on the given path. *path* may be specified "
"as either a string or bytes -- directly or indirectly through the "
":class:`PathLike` interface -- or as an open file descriptor. Return a "
":class:`stat_result` object."
msgstr ""
"파일 또는 파일 기술자의 상태를 가져옵니다. 주어진 경로에 대해 :c:func:`stat` 시스템 호출과 같은 작업을 수행합니다. "
"*path* 는 문자열이나 바이트열 -- 직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로 -- 또는 열린 "
"파일 기술자로 지정될 수 있습니다. :class:`stat_result` 객체를 반환합니다."

#: ../../library/os.rst:3012
msgid ""
"This function normally follows symlinks; to stat a symlink add the "
"argument ``follow_symlinks=False``, or use :func:`lstat`."
msgstr ""
"이 함수는 일반적으로 심볼릭 링크를 따릅니다; 심볼릭 링크를 stat 하려면, 인자 "
"``follow_symlinks=False``\\를 추가하거나 :func:`lstat`\\를 사용하십시오."

#: ../../library/os.rst:3015 ../../library/os.rst:4094
#: ../../library/os.rst:4110 ../../library/os.rst:4126
#: ../../library/os.rst:4146
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>` "
"and :ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`파일 기술자 지정 <path_fd>` 및 :ref:`심볼릭 링크를 따르지 않음 "
"<follow_symlinks>`\\을 지원할 수 있습니다."

#: ../../library/os.rst:3018
msgid ""
"On Windows, passing ``follow_symlinks=False`` will disable following all "
"name-surrogate reparse points, which includes symlinks and directory "
"junctions. Other types of reparse points that do not resemble links or "
"that the operating system is unable to follow will be opened directly. "
"When following a chain of multiple links, this may result in the original"
" link being returned instead of the non-link that prevented full "
"traversal. To obtain stat results for the final path in this case, use "
"the :func:`os.path.realpath` function to resolve the path name as far as "
"possible and call :func:`lstat` on the result. This does not apply to "
"dangling symlinks or junction points, which will raise the usual "
"exceptions."
msgstr ""
"윈도우에서, ``follow_symlinks=False``\\를 전달하면 심볼릭 링크와 디렉터리 정션(directory "
"junction)을 포함하는 모든 이름 서로게이트(name-surrogate) 재해석 지점(reparse point)을 따라가지 "
"않습니다. 링크처럼 보이지 않거나 운영 체제에서 따라갈 수 없는 다른 유형의 재해석 지점은 직접 열립니다. 여러 링크 체인을 따라갈"
" 때, 전체 탐색을 방해하는 비 링크 대신 원래 링크가 반환될 수 있습니다. 이 경우 최종 경로에 대한 stat 결과를 얻으려면, "
":func:`os.path.realpath` 함수를 사용하여 가능한 한 멀리 간 경로 이름을 확인한 다음 드 결과에 대해 "
":func:`lstat`\\을 호출하십시오. 매달린(dangling) 심볼릭 링크나 정션 지점에는 적용되지 않고, 일반적인 예외가 "
"발생합니다."

#: ../../library/os.rst:3031 ../../library/os.rst:3801
msgid "Example::"
msgstr "예::"

#: ../../library/os.rst:3033
msgid ""
">>> import os\n"
">>> statinfo = os.stat('somefile.txt')\n"
">>> statinfo\n"
"os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,\n"
"st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,\n"
"st_mtime=1297230027, st_ctime=1297230027)\n"
">>> statinfo.st_size\n"
"264"
msgstr ""

#: ../../library/os.rst:3044
msgid ":func:`fstat` and :func:`lstat` functions."
msgstr ":func:`fstat` 및 :func:`lstat` 함수."

#: ../../library/os.rst:3046
#, fuzzy
msgid ""
"Added the *dir_fd* and *follow_symlinks* parameters, specifying a file "
"descriptor instead of a path."
msgstr "*dir_fd* 및 *follow_symlinks* 인자와 경로 대신 파일 기술자를 지정하는 것을 추가했습니다."

#: ../../library/os.rst:3053
msgid ""
"On Windows, all reparse points that can be resolved by the operating "
"system are now followed, and passing ``follow_symlinks=False`` disables "
"following all name surrogate reparse points. If the operating system "
"reaches a reparse point that it is not able to follow, *stat* now returns"
" the information for the original path as if ``follow_symlinks=False`` "
"had been specified instead of raising an error."
msgstr ""
"윈도우에서, 이제 운영 체제가 결정할 수 있는 모든 재해석 지점을 따라가고, ``follow_symlinks=False``\\를 "
"전달하면 모든 이름 서로게이트 재해석 지점을 따라가지 않습니다. 운영 체제가 따라갈 수 없는 재해석 지점에 도달하면, "
"*stat*\\은 이제 에러를 발생시키는 대신 ``follow_symlinks=False``\\가 지정된 것처럼 원래 경로에 대한 "
"정보를 반환합니다."

#: ../../library/os.rst:3064
#, fuzzy
msgid ""
"Object whose attributes correspond roughly to the members of the "
":c:struct:`stat` structure. It is used for the result of :func:`os.stat`,"
" :func:`os.fstat` and :func:`os.lstat`."
msgstr ""
"어트리뷰트가 :c:type:`stat` 구조체의 멤버와 대략 일치하는 객체. :func:`os.stat`, "
":func:`os.fstat` 및 :func:`os.lstat`\\의 결과로 사용됩니다."

#: ../../library/os.rst:3068
msgid "Attributes:"
msgstr "어트리뷰트:"

#: ../../library/os.rst:3072
msgid "File mode: file type and file mode bits (permissions)."
msgstr "파일 모드: 파일 유형 및 파일 모드 비트 (사용 권한)."

#: ../../library/os.rst:3076
msgid ""
"Platform dependent, but if non-zero, uniquely identifies the file for a "
"given value of ``st_dev``. Typically:"
msgstr "플랫폼에 따라 다르지만, 0이 아니면, 지정된 값의 ``st_dev``\\은 파일을 고유하게 식별합니다. 일반적으로:"

#: ../../library/os.rst:3079
msgid "the inode number on Unix,"
msgstr "유닉스의 아이노드 번호,"

#: ../../library/os.rst:3080
msgid ""
"the `file index <https://msdn.microsoft.com/en-us/library/aa363788>`_ on "
"Windows"
msgstr "윈도우의 `파일 인덱스 <https://msdn.microsoft.com/en-us/library/aa363788>`_"

#: ../../library/os.rst:3086
msgid "Identifier of the device on which this file resides."
msgstr "이 파일이 있는 장치의 식별자."

#: ../../library/os.rst:3090
msgid "Number of hard links."
msgstr "하드 링크 수."

#: ../../library/os.rst:3094
msgid "User identifier of the file owner."
msgstr "파일 소유자의 사용자 식별자."

#: ../../library/os.rst:3098
msgid "Group identifier of the file owner."
msgstr "파일 소유자의 그룹 식별자."

#: ../../library/os.rst:3102
msgid ""
"Size of the file in bytes, if it is a regular file or a symbolic link. "
"The size of a symbolic link is the length of the pathname it contains, "
"without a terminating null byte."
msgstr ""
"일반 파일 또는 심볼릭 링크면, 바이트 단위의 파일의 크기. 심볼릭 링크의 크기는 포함하고 있는 경로명의 길이이며, 끝나는 널 "
"바이트는 포함하지 않습니다."

#: ../../library/os.rst:3106
msgid "Timestamps:"
msgstr "타임스탬프:"

#: ../../library/os.rst:3110
msgid "Time of most recent access expressed in seconds."
msgstr "초 단위의 가장 최근의 액세스 시간."

#: ../../library/os.rst:3114
msgid "Time of most recent content modification expressed in seconds."
msgstr "초 단위의 가장 최근의 내용 수정 시간."

#: ../../library/os.rst:3118
#, fuzzy
msgid "Time of most recent metadata change expressed in seconds."
msgstr "초 단위의 가장 최근의 액세스 시간."

#: ../../library/os.rst:3120
msgid ""
"``st_ctime`` is deprecated on Windows. Use ``st_birthtime`` for the file "
"creation time. In the future, ``st_ctime`` will contain the time of the "
"most recent metadata change, as for other platforms."
msgstr ""

#: ../../library/os.rst:3127
msgid "Time of most recent access expressed in nanoseconds as an integer."
msgstr "나노초 정수 단위의 가장 최근의 액세스 시간."

#: ../../library/os.rst:3133
msgid ""
"Time of most recent content modification expressed in nanoseconds as an "
"integer."
msgstr "나노초 정수 단위의 가장 최근의 내용 수정 시간."

#: ../../library/os.rst:3140
#, fuzzy
msgid ""
"Time of most recent metadata change expressed in nanoseconds as an "
"integer."
msgstr "나노초 정수 단위의 가장 최근의 액세스 시간."

#: ../../library/os.rst:3145
msgid ""
"``st_ctime_ns`` is deprecated on Windows. Use ``st_birthtime_ns`` for the"
" file creation time. In the future, ``st_ctime`` will contain the time of"
" the most recent metadata change, as for other platforms."
msgstr ""

#: ../../library/os.rst:3152
msgid ""
"Time of file creation expressed in seconds. This attribute is not always "
"available, and may raise :exc:`AttributeError`."
msgstr ""

#: ../../library/os.rst:3155
#, fuzzy
msgid "``st_birthtime`` is now available on Windows."
msgstr "이 함수는 MacOS에서는 사용할 수 없습니다."

#: ../../library/os.rst:3160
msgid ""
"Time of file creation expressed in nanoseconds as an integer. This "
"attribute is not always available, and may raise :exc:`AttributeError`."
msgstr ""

#: ../../library/os.rst:3168
#, fuzzy
msgid ""
"The exact meaning and resolution of the :attr:`st_atime`, "
":attr:`st_mtime`, :attr:`st_ctime` and :attr:`st_birthtime` attributes "
"depend on the operating system and the file system. For example, on "
"Windows systems using the FAT32 file systems, :attr:`st_mtime` has "
"2-second resolution, and :attr:`st_atime` has only 1-day resolution. See "
"your operating system documentation for details."
msgstr ""
":attr:`st_atime`, :attr:`st_mtime` 및 :attr:`st_ctime` 어트리뷰트의 정확한 의미와 해상도는"
" 운영 체제와 파일 시스템에 따라 다릅니다. 예를 들어, FAT 또는 FAT32 파일 시스템을 사용하는 윈도우 시스템에서, "
":attr:`st_mtime`\\은 2초 해상도를, :attr:`st_atime`\\는 단지 1일 해상도를 갖습니다. 자세한 내용은"
" 운영 체제 설명서를 참조하십시오."

#: ../../library/os.rst:3175
#, fuzzy
msgid ""
"Similarly, although :attr:`st_atime_ns`, :attr:`st_mtime_ns`, "
":attr:`st_ctime_ns` and :attr:`st_birthtime_ns` are always expressed in "
"nanoseconds, many systems do not provide nanosecond precision.  On "
"systems that do provide nanosecond precision, the floating-point object "
"used to store :attr:`st_atime`, :attr:`st_mtime`, :attr:`st_ctime` and "
":attr:`st_birthtime` cannot preserve all of it, and as such will be "
"slightly inexact. If you need the exact timestamps you should always use "
":attr:`st_atime_ns`, :attr:`st_mtime_ns`, :attr:`st_ctime_ns` and "
":attr:`st_birthtime_ns`."
msgstr ""
"마찬가지로, :attr:`st_atime_ns`, :attr:`st_mtime_ns` 및 :attr:`st_ctime_ns`\\가 "
"항상 나노초 단위로 표시되지만, 많은 시스템은 나노초 정밀도를 제공하지 않습니다. 나노초 정밀도를 제공하는 시스템에서, "
":attr:`st_atime`, :attr:`st_mtime` 및 :attr:`st_ctime`\\를 저장하는 데 사용되는 부동 "
"소수점 객체는, 이 값을 모두 보존할 수 없으므로, 약간 부정확합니다. 정확한 타임스탬프가 필요하면, 항상 "
":attr:`st_atime_ns`, :attr:`st_mtime_ns` 및 :attr:`st_ctime_ns`\\를 사용해야 "
"합니다."

#: ../../library/os.rst:3185
msgid ""
"On some Unix systems (such as Linux), the following attributes may also "
"be available:"
msgstr "(리눅스와 같은) 일부 유닉스 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../../library/os.rst:3190
msgid ""
"Number of 512-byte blocks allocated for file. This may be smaller than "
":attr:`st_size`/512 when the file has holes."
msgstr "파일에 할당된 512-바이트 블록 수. 파일에 구멍이 있으면 :attr:`st_size`/512보다 작을 수 있습니다."

#: ../../library/os.rst:3195
msgid ""
"\"Preferred\" blocksize for efficient file system I/O. Writing to a file "
"in smaller chunks may cause an inefficient read-modify-rewrite."
msgstr ""
"효율적인 파일 시스템 I/O를 위해 \"선호되는\" 블록 크기. 더 작은 크기로 파일에 기록하면 비효율적인 읽기-수정-다시 쓰기가 "
"발생할 수 있습니다."

#: ../../library/os.rst:3200
msgid "Type of device if an inode device."
msgstr "아이노드 장치면 장치 유형."

#: ../../library/os.rst:3204
msgid "User defined flags for file."
msgstr "파일에 대한 사용자 정의 플래그."

#: ../../library/os.rst:3206
msgid ""
"On other Unix systems (such as FreeBSD), the following attributes may be "
"available (but may be only filled out if root tries to use them):"
msgstr ""
"(FreeBSD와 같은) 다른 유닉스 시스템에서는, 다음 어트리뷰트를 사용할 수 있습니다 (그러나 root가 사용하려고 할 때만 "
"채워질 수 있습니다):"

#: ../../library/os.rst:3211
msgid "File generation number."
msgstr "파일 생성 번호."

#: ../../library/os.rst:3213
msgid ""
"On Solaris and derivatives, the following attributes may also be "
"available:"
msgstr "Solaris 및 파생 상품에서, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../../library/os.rst:3218
msgid ""
"String that uniquely identifies the type of the filesystem that contains "
"the file."
msgstr "파일을 포함하는 파일 시스템의 유형을 고유하게 식별하는 문자열."

#: ../../library/os.rst:3221
#, fuzzy
msgid "On macOS systems, the following attributes may also be available:"
msgstr "맥 OS 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../../library/os.rst:3225
msgid "Real size of the file."
msgstr "파일의 실제 크기."

#: ../../library/os.rst:3229
msgid "Creator of the file."
msgstr "파일의 생성자."

#: ../../library/os.rst:3233
msgid "File type."
msgstr "파일 유형."

#: ../../library/os.rst:3235
msgid "On Windows systems, the following attributes are also available:"
msgstr "윈도우 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../../library/os.rst:3239
#, fuzzy
msgid ""
"Windows file attributes: ``dwFileAttributes`` member of the "
"``BY_HANDLE_FILE_INFORMATION`` structure returned by "
":c:func:`!GetFileInformationByHandle`. See the :const:`!FILE_ATTRIBUTE_* "
"<stat.FILE_ATTRIBUTE_ARCHIVE>` constants in the :mod:`stat` module."
msgstr ""
"윈도우 파일 어트리뷰트: :c:func:`GetFileInformationByHandle`\\에 의해 반환된 "
"``BY_HANDLE_FILE_INFORMATION`` 구조체의 ``dwFileAttributes`` 멤버. :mod:`stat` "
"모듈의 ``FILE_ATTRIBUTE_*`` 상수를 참조하십시오."

#: ../../library/os.rst:3249
#, fuzzy
msgid ""
"When :attr:`st_file_attributes` has the "
":const:`~stat.FILE_ATTRIBUTE_REPARSE_POINT` set, this field contains the "
"tag identifying the type of reparse point. See the "
":const:`IO_REPARSE_TAG_* <stat.IO_REPARSE_TAG_SYMLINK>` constants in the "
":mod:`stat` module."
msgstr ""
":attr:`st_file_attributes`\\에 ``FILE_ATTRIBUTE_REPARSE_POINT``\\가 설정되면, 이"
" 필드에는 재해석 지점의 유형을 식별하는 태그가 포함됩니다. :mod:`stat` 모듈의 ``IO_REPARSE_TAG_*`` "
"상수를 참조하십시오."

#: ../../library/os.rst:3254
#, fuzzy
msgid ""
"The standard module :mod:`stat` defines functions and constants that are "
"useful for extracting information from a :c:struct:`stat` structure. (On "
"Windows, some items are filled with dummy values.)"
msgstr ""
"표준 모듈 :mod:`stat`\\는 :c:type:`stat` 구조체에서 정보를 추출하는 데 유용한 함수와 상수를 정의합니다. "
"(윈도우에서는, 일부 항목에 더미 값이 채워집니다.)"

#: ../../library/os.rst:3258
#, fuzzy
msgid ""
"For backward compatibility, a :class:`stat_result` instance is also "
"accessible as a tuple of at least 10 integers giving the most important "
"(and portable) members of the :c:struct:`stat` structure, in the order "
":attr:`st_mode`, :attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`, "
":attr:`st_uid`, :attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`, "
":attr:`st_mtime`, :attr:`st_ctime`. More items may be added at the end by"
" some implementations. For compatibility with older Python versions, "
"accessing :class:`stat_result` as a tuple always returns integers."
msgstr ""
"이전 버전과의 호환성을 위해, :class:`stat_result` 인스턴스는 :c:type:`stat` 구조체의 가장 중요한 "
"(그리고 이식성 있는) 멤버를 제공하는 최소 10개의 정수로 구성된 튜플로 액세스할 수도 있는데, :attr:`st_mode`, "
":attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`, :attr:`st_uid`, "
":attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`, :attr:`st_mtime`, "
":attr:`st_ctime` 순서입니다. 일부 구현에서는 끝에 더 많은 항목을 추가 할 수 있습니다. 이전 버전의 파이썬과의 "
"호환성을 위해, :class:`stat_result`\\에 튜플로 액세스하면 항상 정수가 반환됩니다."

#: ../../library/os.rst:3267
msgid "Windows now returns the file index as :attr:`st_ino` when available."
msgstr "윈도우는 이제 사용 가능할 때 파일 인덱스를 :attr:`st_ino`\\로 반환합니다."

#: ../../library/os.rst:3271
msgid "Added the :attr:`st_fstype` member to Solaris/derivatives."
msgstr "Solaris/파생 제품에 :attr:`st_fstype` 멤버를 추가했습니다."

#: ../../library/os.rst:3274
msgid "Added the :attr:`st_reparse_tag` member on Windows."
msgstr "윈도우에서 :attr:`st_reparse_tag` 멤버를 추가했습니다."

#: ../../library/os.rst:3277
msgid ""
"On Windows, the :attr:`st_mode` member now identifies special files as "
":const:`S_IFCHR`, :const:`S_IFIFO` or :const:`S_IFBLK` as appropriate."
msgstr ""
"윈도우에서, :attr:`st_mode` 멤버는 이제 특수 파일을 :const:`S_IFCHR`, :const:`S_IFIFO` "
"또는 :const:`S_IFBLK`\\로 적절히 식별합니다."

#: ../../library/os.rst:3282
msgid ""
"On Windows, :attr:`st_ctime` is deprecated. Eventually, it will contain "
"the last metadata change time, for consistency with other platforms, but "
"for now still contains creation time. Use :attr:`st_birthtime` for the "
"creation time."
msgstr ""

#: ../../library/os.rst:3288
msgid ""
"On Windows, :attr:`st_ino` may now be up to 128 bits, depending on the "
"file system. Previously it would not be above 64 bits, and larger file "
"identifiers would be arbitrarily packed."
msgstr ""

#: ../../library/os.rst:3292
msgid ""
"On Windows, :attr:`st_rdev` no longer returns a value. Previously it "
"would contain the same as :attr:`st_dev`, which was incorrect."
msgstr ""

#: ../../library/os.rst:3295
#, fuzzy
msgid "Added the :attr:`st_birthtime` member on Windows."
msgstr "윈도우에서 :attr:`st_reparse_tag` 멤버를 추가했습니다."

#: ../../library/os.rst:3300
#, fuzzy
msgid ""
"Perform a :c:func:`!statvfs` system call on the given path.  The return "
"value is an object whose attributes describe the filesystem on the given "
"path, and correspond to the members of the :c:struct:`statvfs` structure,"
" namely: :attr:`f_bsize`, :attr:`f_frsize`, :attr:`f_blocks`, "
":attr:`f_bfree`, :attr:`f_bavail`, :attr:`f_files`, :attr:`f_ffree`, "
":attr:`f_favail`, :attr:`f_flag`, :attr:`f_namemax`, :attr:`f_fsid`."
msgstr ""
"주어진 경로에 대해 :c:func:`statvfs` 시스템 호출을 수행합니다. 반환 값은 주어진 경로의 파일 시스템을 설명하는 "
"객체인데, 어트리뷰트가 :c:type:`statvfs` 구조체의 멤버인 :attr:`f_bsize`, "
":attr:`f_frsize`, :attr:`f_blocks`, :attr:`f_bfree`, :attr:`f_bavail`, "
":attr:`f_files`, :attr:`f_ffree`, :attr:`f_favail`, :attr:`f_flag`, "
":attr:`f_namemax`, :attr:`f_fsid`\\에 해당합니다."

#: ../../library/os.rst:3307
msgid ""
"Two module-level constants are defined for the :attr:`f_flag` attribute's"
" bit-flags: if :const:`ST_RDONLY` is set, the filesystem is mounted read-"
"only, and if :const:`ST_NOSUID` is set, the semantics of setuid/setgid "
"bits are disabled or not supported."
msgstr ""
":attr:`f_flag` 어트리뷰트의 비트 플래그에 대해 두 개의 모듈 수준 상수가 정의됩니다: "
":const:`ST_RDONLY`\\가 설정되면, 파일 시스템은 읽기 전용으로 마운트되었고, :const:`ST_NOSUID`\\가"
" 설정되면, setuid/setgid 비트의 의미가 비활성화되었거나 지원되지 않습니다."

#: ../../library/os.rst:3312
msgid ""
"Additional module-level constants are defined for GNU/glibc based "
"systems. These are :const:`ST_NODEV` (disallow access to device special "
"files), :const:`ST_NOEXEC` (disallow program execution), "
":const:`ST_SYNCHRONOUS` (writes are synced at once), :const:`ST_MANDLOCK`"
" (allow mandatory locks on an FS), :const:`ST_WRITE` (write on "
"file/directory/symlink), :const:`ST_APPEND` (append-only file), "
":const:`ST_IMMUTABLE` (immutable file), :const:`ST_NOATIME` (do not "
"update access times), :const:`ST_NODIRATIME` (do not update directory "
"access times), :const:`ST_RELATIME` (update atime relative to "
"mtime/ctime)."
msgstr ""
"추가적인 모듈 수준 상수가 GNU/glibc 기반 시스템에 대해 정의됩니다. 이들은 :const:`ST_NODEV` (장치 특수 "
"파일에 대한 액세스 금지), :const:`ST_NOEXEC` (프로그램 실행 금지), :const:`ST_SYNCHRONOUS` "
"(한 번에 쓰기 동기화), :const:`ST_MANDLOCK` (FS에 필수 잠금 허용), :const:`ST_WRITE` "
"(파일/디렉터리/심볼릭 링크 쓰기), :const:`ST_APPEND` (덧붙이기 전용 파일), "
":const:`ST_IMMUTABLE` (불변 파일), :const:`ST_NOATIME` (액세스 시간을 갱신하지 않음), "
":const:`ST_NODIRATIME` (디렉터리 액세스 시간을 갱신하지 않음), :const:`ST_RELATIME` "
"(mtime/ctime에 상대적으로 atime을 갱신)."

#: ../../library/os.rst:3325
msgid "The :const:`ST_RDONLY` and :const:`ST_NOSUID` constants were added."
msgstr ":const:`ST_RDONLY` 및 :const:`ST_NOSUID` 상수가 추가되었습니다."

#: ../../library/os.rst:3331
msgid ""
"The :const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, "
":const:`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, "
":const:`ST_IMMUTABLE`, :const:`ST_NOATIME`, :const:`ST_NODIRATIME`, and "
":const:`ST_RELATIME` constants were added."
msgstr ""
":const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, "
":const:`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, "
":const:`ST_IMMUTABLE`, :const:`ST_NOATIME`, :const:`ST_NODIRATIME` 및 "
":const:`ST_RELATIME` 상수가 추가되었습니다."

#: ../../library/os.rst:3340
#, fuzzy
msgid "Added the :attr:`f_fsid` attribute."
msgstr ":attr:`f_fsid` 추가."

#: ../../library/os.rst:3346
msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"accept an open file descriptor for their *dir_fd* parameter. Different "
"platforms provide different features, and the underlying functionality "
"Python uses to implement the *dir_fd* parameter is not available on all "
"platforms Python supports.  For consistency's sake, functions that may "
"support *dir_fd* always allow specifying the parameter, but will throw an"
" exception if the functionality is used when it's not locally available. "
"(Specifying ``None`` for *dir_fd* is always supported on all platforms.)"
msgstr ""
":mod:`os` 모듈의 어떤 함수가 *dir_fd* 매개 변수로 열린 파일 기술자를 받아들이는지를 나타내는 :class:`set`"
" 객체. 플랫폼마다 다른 기능을 제공하며, 파이썬이 *dir_fd* 매개 변수를 구현하는 데 사용하는 하부 기능이 파이썬이 지원하는"
" 모든 플랫폼에서 제공되지는 않습니다. 일관성을 위해, *dir_fd* 를 지원할 수도 있는 함수는 항상 매개 변수를 지정할 수 "
"있도록 하지만, 로컬에서 사용할 수 없을 때, 기능을 사용하면 예외를 발생시킵니다. (*dir_fd*\\에 ``None``\\을 "
"지정하는 것은 모든 플랫폼에서 항상 지원됩니다.)"

#: ../../library/os.rst:3356
msgid ""
"To check whether a particular function accepts an open file descriptor "
"for its *dir_fd* parameter, use the ``in`` operator on "
"``supports_dir_fd``. As an example, this expression evaluates to ``True``"
" if :func:`os.stat` accepts open file descriptors for *dir_fd* on the "
"local platform::"
msgstr ""
"특정 함수가 *dir_fd* 매개 변수로 열린 파일 기술자를 받아들이는지 확인하려면, ``supports_dir_fd``\\에 "
"``in`` 연산자를 사용하십시오. 예를 들어, 이 표현식은 로컬 플랫폼에서 :func:`os.stat`\\이 *dir_fd* 매개"
" 변수로 열린 파일 기술자를 받아들이면 ``True``\\로 평가됩니다::"

#: ../../library/os.rst:3361
msgid "os.stat in os.supports_dir_fd"
msgstr ""

#: ../../library/os.rst:3363
msgid ""
"Currently *dir_fd* parameters only work on Unix platforms; none of them "
"work on Windows."
msgstr "현재 *dir_fd* 매개 변수는 유닉스 플랫폼에서만 작동합니다; 어느 것도 윈도우에서 작동하지 않습니다."

#: ../../library/os.rst:3371
msgid ""
"A :class:`set` object indicating whether :func:`os.access` permits "
"specifying ``True`` for its *effective_ids* parameter on the local "
"platform. (Specifying ``False`` for *effective_ids* is always supported "
"on all platforms.)  If the local platform supports it, the collection "
"will contain :func:`os.access`; otherwise it will be empty."
msgstr ""
":func:`os.access`\\가 로컬 플랫폼에서 *effective_ids* 매개 변수에 ``True``\\를 지정하는 것을 "
"허용하는지를 나타내는 :class:`set` 객체. (*effective_ids*\\에 ``False``\\를 지정하는 것은 모든 "
"플랫폼에서 항상 지원됩니다.) 로컬 플랫폼이 지원하면, 컬렉션에 :func:`os.access`\\가 포함됩니다; 그렇지 않으면 "
"비어있게 됩니다."

#: ../../library/os.rst:3377
msgid ""
"This expression evaluates to ``True`` if :func:`os.access` supports "
"``effective_ids=True`` on the local platform::"
msgstr ""
"이 표현식은 로컬 플랫폼에서 :func:`os.access`\\가 ``effective_ids=True``\\를 지원하면 "
"``True``\\로 평가됩니다::"

#: ../../library/os.rst:3380
msgid "os.access in os.supports_effective_ids"
msgstr ""

#: ../../library/os.rst:3382
msgid ""
"Currently *effective_ids* is only supported on Unix platforms; it does "
"not work on Windows."
msgstr "현재 *effective_ids* 는 유닉스 플랫폼에서만 지원됩니다; 윈도우에서는 작동하지 않습니다."

#: ../../library/os.rst:3390
msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"permit specifying their *path* parameter as an open file descriptor on "
"the local platform.  Different platforms provide different features, and "
"the underlying functionality Python uses to accept open file descriptors "
"as *path* arguments is not available on all platforms Python supports."
msgstr ""
":mod:`os` 모듈의 어떤 함수가 로컬 플랫폼에서 자신의 *path* 매개 변수에 열린 파일 기술자를 지정하는 것을 허용하는지를"
" 나타내는 :class:`set` 객체. 플랫폼마다 다른 기능을 제공하며, 파이썬이 *path*\\로 열린 파일 기술자를 받아들이는"
" 데 사용하는 하부 기능이 파이썬이 지원하는 모든 플랫폼에서 제공되지는 않습니다."

#: ../../library/os.rst:3397
msgid ""
"To determine whether a particular function permits specifying an open "
"file descriptor for its *path* parameter, use the ``in`` operator on "
"``supports_fd``. As an example, this expression evaluates to ``True`` if "
":func:`os.chdir` accepts open file descriptors for *path* on your local "
"platform::"
msgstr ""
"특정 함수가 *path* 매개 변수에 열린 파일 기술자를 지정할 수 있도록 허용하는지를 판단하려면, "
"``supports_fd``\\에 ``in`` 연산자를 사용하십시오. 예를 들어, 이 표현식은 로컬 플랫폼에서 "
":func:`os.chdir`\\가 *path*\\로 열린 파일 기술자를 받아들이면 ``True``\\로 평가됩니다::"

#: ../../library/os.rst:3403
msgid "os.chdir in os.supports_fd"
msgstr ""

#: ../../library/os.rst:3410
msgid ""
"A :class:`set` object indicating which functions in the :mod:`os` module "
"accept ``False`` for their *follow_symlinks* parameter on the local "
"platform. Different platforms provide different features, and the "
"underlying functionality Python uses to implement *follow_symlinks* is "
"not available on all platforms Python supports.  For consistency's sake, "
"functions that may support *follow_symlinks* always allow specifying the "
"parameter, but will throw an exception if the functionality is used when "
"it's not locally available.  (Specifying ``True`` for *follow_symlinks* "
"is always supported on all platforms.)"
msgstr ""
":mod:`os` 모듈의 어떤 함수가 *follow_symlinks* 매개 변수로 ``False``\\를 받아들이는지를 나타내는 "
":class:`set` 객체. 플랫폼마다 다른 기능을 제공하며, 파이썬이 *follow_symlinks*\\를 구현하는 데 사용하는"
" 하부 기능이 파이썬이 지원하는 모든 플랫폼에서 제공되지는 않습니다. 일관성을 위해, *follow_symlinks* 를 지원할 "
"수도 있는 함수는 항상 매개 변수를 지정할 수 있도록 하지만, 로컬에서 사용할 수 없을 때, 기능이 사용되면 예외를 발생시킵니다. "
"(*follow_symlinks*\\에 ``None``\\을 지정하는 것은 모든 플랫폼에서 항상 지원됩니다.)"

#: ../../library/os.rst:3420
msgid ""
"To check whether a particular function accepts ``False`` for its "
"*follow_symlinks* parameter, use the ``in`` operator on "
"``supports_follow_symlinks``.  As an example, this expression evaluates "
"to ``True`` if you may specify ``follow_symlinks=False`` when calling "
":func:`os.stat` on the local platform::"
msgstr ""
"특정 함수가 *follow_symlinks* 매개 변수로 ``False``\\를 받아들이는지 확인하려면, "
"``supports_follow_symlinks``\\에 ``in`` 연산자를 사용하십시오. 예를 들어, 이 표현식은 로컬 "
"플랫폼에서 :func:`os.stat`\\을 호출할 때 ``follow_symlinks=False``\\를 지정할 수 있으면 "
"``True``\\로 평가됩니다::"

#: ../../library/os.rst:3426
msgid "os.stat in os.supports_follow_symlinks"
msgstr ""

#: ../../library/os.rst:3433
msgid "Create a symbolic link pointing to *src* named *dst*."
msgstr "*src를* 가리키는 *dst* 라는 이름의 심볼릭 링크를 만듭니다."

#: ../../library/os.rst:3435
msgid ""
"On Windows, a symlink represents either a file or a directory, and does "
"not morph to the target dynamically.  If the target is present, the type "
"of the symlink will be created to match. Otherwise, the symlink will be "
"created as a directory if *target_is_directory* is ``True`` or a file "
"symlink (the default) otherwise.  On non-Windows platforms, "
"*target_is_directory* is ignored."
msgstr ""
"윈도우에서, 심볼릭 링크는 파일이나 디렉터리를 나타내며, 동적으로 대상에 맞춰 변형되지 않습니다. 대상이 있으면, 일치하도록 심볼릭"
" 링크의 유형이 만들어집니다. 그렇지 않으면, *target_is_directory* 가 ``True`` 면 심볼릭 링크가 "
"디렉터리로 만들어지고, 그렇지 않으면 파일 심볼릭 링크(기본값)가 만들어집니다. 비 윈도우 플랫폼에서는 "
"*target_is_directory* 가 무시됩니다."

#: ../../library/os.rst:3446
msgid ""
"On newer versions of Windows 10, unprivileged accounts can create "
"symlinks if Developer Mode is enabled. When Developer Mode is not "
"available/enabled, the *SeCreateSymbolicLinkPrivilege* privilege is "
"required, or the process must be run as an administrator."
msgstr ""
"최신 버전의 윈도우 10에서, 개발자 모드가 활성화되면, 권한이 없는 계정이 심볼릭 링크를 만들 수 있습니다. 개발자 모드를 사용할"
" 수 없거나 활성화되어 있지 않으면, *SeCreateSymbolicLinkPrivilege* 권한이 필요하거나, 프로세스를 "
"관리자로 실행해야 합니다."

#: ../../library/os.rst:3452
msgid ""
":exc:`OSError` is raised when the function is called by an unprivileged "
"user."
msgstr "권한이 없는 사용자가 함수를 호출하면 :exc:`OSError`\\가 발생합니다."

#: ../../library/os.rst:3455
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.symlink`` with arguments "
"``src``, ``dst``, ``dir_fd``."
msgstr ""
"``src``, ``dst``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``os.symlink``\\를 발생시킵니다."

#: ../../library/os.rst:3465
#, fuzzy
msgid ""
"Added the *dir_fd* parameter, and now allow *target_is_directory* on non-"
"Windows platforms."
msgstr "*dir_fd* 인자를 추가했으며, 이제 비 윈도우 플랫폼에서 *target_is_directory* 를 허용합니다."

#: ../../library/os.rst:3472
msgid "Added support for unelevated symlinks on Windows with Developer Mode."
msgstr "개발자 모드가 있는 윈도우에서 권한 상승 없는(unelevated) 심볼릭 링크에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:3478
msgid "Force write of everything to disk."
msgstr "디스크에 모든 것을 쓰도록 강제합니다."

#: ../../library/os.rst:3487
msgid ""
"Truncate the file corresponding to *path*, so that it is at most *length*"
" bytes in size."
msgstr "최대 *length* 바이트가 되도록 *path*\\에 해당하는 파일을 자릅니다."

#: ../../library/os.rst:3492
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.truncate`` with arguments"
" ``path``, ``length``."
msgstr ""
"``path``, ``length``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.truncate``\\를 발생시킵니다."

#: ../../library/os.rst:3507
msgid ""
"Remove (delete) the file *path*.  This function is semantically identical"
" to :func:`remove`; the ``unlink`` name is its traditional Unix name.  "
"Please see the documentation for :func:`remove` for further information."
msgstr ""
"파일 *path*\\를 제거(삭제)합니다. 이 함수는 의미상 :func:`remove`\\와 같습니다; ``unlink`` 라는 "
"이름은 전통적인 유닉스 이름입니다. 자세한 내용은 :func:`remove` 설명서를 참조하십시오."

#: ../../library/os.rst:3523
msgid "Set the access and modified times of the file specified by *path*."
msgstr "*path*\\로 지정된 파일의 액세스 및 수정 시간을 설정합니다."

#: ../../library/os.rst:3525
msgid ""
":func:`utime` takes two optional parameters, *times* and *ns*. These "
"specify the times set on *path* and are used as follows:"
msgstr ""
":func:`utime`\\은 *times* 과 *ns* 라는 두 개의 선택적 매개 변수를 취합니다. *path*\\에 설정할 "
"시간을 지정하며 다음과 같이 사용됩니다:"

#: ../../library/os.rst:3528
msgid ""
"If *ns* is specified, it must be a 2-tuple of the form ``(atime_ns, "
"mtime_ns)`` where each member is an int expressing nanoseconds."
msgstr ""
"*ns* 가 지정되면, ``(atime_ns, mtime_ns)`` 형식의 2-튜플이어야 하며, 각 멤버는 나노초를 나타내는 "
"int입니다."

#: ../../library/os.rst:3531
msgid ""
"If *times* is not ``None``, it must be a 2-tuple of the form ``(atime, "
"mtime)`` where each member is an int or float expressing seconds."
msgstr ""
"*times* 가 ``None``\\이 아니면, ``(atime, mtime)`` 형식의 2-튜플이어야 하며, 각 멤버는 초를 "
"나타내는 int 또는 float입니다."

#: ../../library/os.rst:3534
msgid ""
"If *times* is ``None`` and *ns* is unspecified, this is equivalent to "
"specifying ``ns=(atime_ns, mtime_ns)`` where both times are the current "
"time."
msgstr ""
"*times* 가 ``None``\\이고 *ns* 가 지정되지 않으면, ``ns=(atime_ns, mtime_ns)``\\를 "
"지정하는 것과 같은데, 두 시간 모두 현재 시각입니다."

#: ../../library/os.rst:3538
msgid "It is an error to specify tuples for both *times* and *ns*."
msgstr "*times* 와 *ns*\\에 모두 튜플을 지정하는 것은 에러입니다."

#: ../../library/os.rst:3540
#, fuzzy
msgid ""
"Note that the exact times you set here may not be returned by a "
"subsequent :func:`~os.stat` call, depending on the resolution with which "
"your operating system records access and modification times; see "
":func:`~os.stat`. The best way to preserve exact times is to use the "
"*st_atime_ns* and *st_mtime_ns* fields from the :func:`os.stat` result "
"object with the *ns* parameter to :func:`utime`."
msgstr ""
"여기서 설정한 정확한 시간은 운영 체제가 액세스 및 수정 시간을 기록하는 해상도에 따라 뒤따르는 :func:`~os.stat` "
"호출에서 반환되지 않을 수 있음에 주의해야 합니다; :func:`~os.stat`\\를 참조하세요. 정확한 시간을 보존하는 가장 "
"좋은 방법은 `utime` 의 *ns* 매개 변수에 :func:`os.stat` 결과 객체의 *st_atime_ns* 및 "
"*st_mtime_ns* 필드를 사용하는 것입니다."

#: ../../library/os.rst:3551
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.utime`` with arguments "
"``path``, ``times``, ``ns``, ``dir_fd``."
msgstr ""
"``path``, ``times``, ``ns``, ``dir_fd``\\를 인자로 :ref:`감사 이벤트(auditing "
"event) <auditing>` ``os.utime``\\을 발생시킵니다."

#: ../../library/os.rst:3553
msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd*, *follow_symlinks*, and *ns* parameters."
msgstr ""
"*path*\\에 열린 파일 기술자를 지정하는 것과 *dir_fd* , *follow_symlinks* 및 *ns* 매개 변수 "
"지원이 추가되었습니다."

#: ../../library/os.rst:3567
msgid ""
"Generate the file names in a directory tree by walking the tree either "
"top-down or bottom-up. For each directory in the tree rooted at directory"
" *top* (including *top* itself), it yields a 3-tuple ``(dirpath, "
"dirnames, filenames)``."
msgstr ""
"트리를 하향식 또는 상향식으로 탐색하여 디렉터리 트리에 있는 파일명을 생성합니다. 디렉터리 *top*\\을 루트로 하는 트리의 "
"디렉터리(*top* 자체를 포함합니다)마다, 3-튜플 ``(dirpath, dirnames, filenames)``\\를 "
"산출합니다."

#: ../../library/os.rst:3572
#, fuzzy
msgid ""
"*dirpath* is a string, the path to the directory.  *dirnames* is a list "
"of the names of the subdirectories in *dirpath* (including symlinks to "
"directories, and excluding ``'.'`` and ``'..'``). *filenames* is a list "
"of the names of the non-directory files in *dirpath*. Note that the names"
" in the lists contain no path components.  To get a full path (which "
"begins with *top*) to a file or directory in *dirpath*, do "
"``os.path.join(dirpath, name)``.  Whether or not the lists are sorted "
"depends on the file system.  If a file is removed from or added to the "
"*dirpath* directory during generating the lists, whether a name for that "
"file be included is unspecified."
msgstr ""
"*dirpath* 는 디렉터리 경로인 문자열입니다. *dirnames* 는 *dirpath* 의 하위 디렉터리 이름 리스트입니다 "
"(``'.'`` 및 ``'..'`` 제외). *filenames* 는 *dirpath*\\에 있는 디렉터리가 아닌 파일의 이름 "
"리스트입니다. 리스트에 들어있는 이름에는 경로 구성 요소가 들어 있지 않음에 유의하십시오. *dirpath* 에 있는 파일이나 "
"디렉터리에 대한 전체 경로(*top*\\으로 시작하는)를 얻으려면, ``os.path.join(dirpath, name)``\\을 "
"수행하십시오. 리스트가 정렬되는지는 파일 시스템에 따라 다릅니다. 리스트를 생성하는 동안 *dirpath* 디렉터리에서 파일이 "
"제거되거나 추가되면, 해당 파일의 이름이 포함되는지는 지정되지 않습니다."

#: ../../library/os.rst:3583
msgid ""
"If optional argument *topdown* is ``True`` or not specified, the triple "
"for a directory is generated before the triples for any of its "
"subdirectories (directories are generated top-down).  If *topdown* is "
"``False``, the triple for a directory is generated after the triples for "
"all of its subdirectories (directories are generated bottom-up). No "
"matter the value of *topdown*, the list of subdirectories is retrieved "
"before the tuples for the directory and its subdirectories are generated."
msgstr ""
"선택적 인자 *topdown* 이 ``True``\\이거나 지정되지 않으면, 디렉터리에 대한 3-튜플은 하위 디렉터리에 대한 "
"3-튜플이 생성되기 전에 생성됩니다 (디렉터리는 하향식으로 생성됩니다). *topdown* 이 ``False``\\면, 모든 하위 "
"디렉터리에 대한 3-튜플 다음에 디렉터리에 대한 3-튜플이 생성됩니다 (디렉터리가 상향식으로 생성됨). *topdown* 의 값에 "
"상관없이, 디렉터리와 해당 하위 디렉터리의 튜플이 생성되기 전에 하위 디렉터리 목록이 조회됩니다."

#: ../../library/os.rst:3591
msgid ""
"When *topdown* is ``True``, the caller can modify the *dirnames* list in-"
"place (perhaps using :keyword:`del` or slice assignment), and "
":func:`walk` will only recurse into the subdirectories whose names remain"
" in *dirnames*; this can be used to prune the search, impose a specific "
"order of visiting, or even to inform :func:`walk` about directories the "
"caller creates or renames before it resumes :func:`walk` again.  "
"Modifying *dirnames* when *topdown* is ``False`` has no effect on the "
"behavior of the walk, because in bottom-up mode the directories in "
"*dirnames* are generated before *dirpath* itself is generated."
msgstr ""
"*topdown* 이 ``True`` 일 때, 호출자는 (아마도 :keyword:`del` 또는 슬라이스 대입을 사용하여) "
"*dirnames* 리스트를 수정할 수 있으며, :func:`walk`\\는 이름이 *dirnames* 남아있는 하위 디렉터리로만 "
"재귀합니다; 검색을 가지치기하거나, 특정 방문 순서를 지정하거나, 심지어 :func:`walk`\\가 다시 시작하기 전에 호출자가 "
"새로 만들거나 이름을 바꾼 디렉터리에 대해 :func:`walk`\\에 알릴 때도 사용할 수 있습니다. *topdown* 이 "
"``False``\\일 때 *dirnames*\\를 수정하는 것은 walk의 동작에 영향을 주지 못하는데, 상향식 모드에서 "
"*dirnames*\\의 디렉터리는 *dirpath* 자체가 생성되기 전에 생성되기 때문입니다."

#: ../../library/os.rst:3600
msgid ""
"By default, errors from the :func:`scandir` call are ignored.  If "
"optional argument *onerror* is specified, it should be a function; it "
"will be called with one argument, an :exc:`OSError` instance.  It can "
"report the error to continue with the walk, or raise the exception to "
"abort the walk.  Note that the filename is available as the ``filename`` "
"attribute of the exception object."
msgstr ""
"기본적으로, :func:`scandir` 호출의 에러는 무시됩니다. 선택적 인자 *onerror* 가 지정되면, 함수여야 합니다; "
"하나의 인자 :exc:`OSError` 인스턴스로 호출됩니다. 에러를 보고하고 walk를 계속하도록 하거나, 예외를 발생시켜 "
"walk를 중단할 수 있습니다. 파일명은 예외 객체의 ``filename`` 어트리뷰트로 제공됩니다."

#: ../../library/os.rst:3606
msgid ""
"By default, :func:`walk` will not walk down into symbolic links that "
"resolve to directories. Set *followlinks* to ``True`` to visit "
"directories pointed to by symlinks, on systems that support them."
msgstr ""
"기본적으로, :func:`walk`\\는 디렉터리로 해석되는 심볼릭 링크로 이동하지 않습니다. 지원하는 시스템에서, 심볼릭 링크가 "
"가리키는 디렉터리를 방문하려면, *followlinks*\\를 ``True``\\로 설정하십시오."

#: ../../library/os.rst:3612
msgid ""
"Be aware that setting *followlinks* to ``True`` can lead to infinite "
"recursion if a link points to a parent directory of itself. :func:`walk` "
"does not keep track of the directories it visited already."
msgstr ""
"심볼릭 링크가 자신의 부모 디렉터리를 가리킬 때, *followlinks*\\를 ``True``\\로 설정하면 무한 재귀가 발생할 "
"수 있음에 주의해야 합니다. :func:`walk`\\는 이미 방문한 디렉터리를 추적하지 않습니다."

#: ../../library/os.rst:3618
msgid ""
"If you pass a relative pathname, don't change the current working "
"directory between resumptions of :func:`walk`.  :func:`walk` never "
"changes the current directory, and assumes that its caller doesn't "
"either."
msgstr ""
"상대 경로명을 전달할 때는, :func:`walk`\\가 실행되는 도중 현재 작업 디렉터리를 변경하지 마십시오. "
":func:`walk`\\는 현재 디렉터리를 절대로 변경하지 않으며, 호출자도 마찬가지라고 가정합니다."

#: ../../library/os.rst:3622 ../../library/os.rst:3684
#, fuzzy
msgid ""
"This example displays the number of bytes taken by non-directory files in"
" each directory under the starting directory, except that it doesn't look"
" under any ``__pycache__`` subdirectory::"
msgstr ""
"이 예는 시작 디렉터리 아래의 각 디렉터리에 있는 비 디렉터리 파일이 차지한 바이트 수를 표시합니다. 단, CVS 하위 디렉터리 "
"아래는 보지 않습니다::"

#: ../../library/os.rst:3626
msgid ""
"import os\n"
"from os.path import join, getsize\n"
"for root, dirs, files in os.walk('python/Lib/xml'):\n"
"    print(root, \"consumes\", end=\" \")\n"
"    print(sum(getsize(join(root, name)) for name in files), end=\" \")\n"
"    print(\"bytes in\", len(files), \"non-directory files\")\n"
"    if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')  # don't visit __pycache__ directories"
msgstr ""

#: ../../library/os.rst:3635
msgid ""
"In the next example (simple implementation of :func:`shutil.rmtree`), "
"walking the tree bottom-up is essential, :func:`rmdir` doesn't allow "
"deleting a directory before the directory is empty::"
msgstr ""
"다음 예(:func:`shutil.rmtree`\\의 간단한 구현)에서는, 트리를 상향식으로 탐색하는 것이 필수적입니다, "
":func:`rmdir`\\는 비어 있지 않은 디렉터리를 삭제할 수 없습니다::"

#: ../../library/os.rst:3639
msgid ""
"# Delete everything reachable from the directory named in \"top\",\n"
"# assuming there are no symbolic links.\n"
"# CAUTION:  This is dangerous!  For example, if top == '/', it\n"
"# could delete all your disk files.\n"
"import os\n"
"for root, dirs, files in os.walk(top, topdown=False):\n"
"    for name in files:\n"
"        os.remove(os.path.join(root, name))\n"
"    for name in dirs:\n"
"        os.rmdir(os.path.join(root, name))\n"
"os.rmdir(top)"
msgstr ""

#: ../../library/os.rst:3651
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.walk`` with arguments "
"``top``, ``topdown``, ``onerror``, ``followlinks``."
msgstr ""
"``top``, ``topdown``, ``onerror``, ``followlinks``\\를 인자로 :ref:`감사 "
"이벤트(auditing event) <auditing>` ``os.walk``\\를 발생시킵니다."

#: ../../library/os.rst:3653
msgid ""
"This function now calls :func:`os.scandir` instead of :func:`os.listdir`,"
" making it faster by reducing the number of calls to :func:`os.stat`."
msgstr ""
"이 함수는 이제 :func:`os.listdir` 대신 :func:`os.scandir`\\를 호출하기 때문에, "
":func:`os.stat` 호출 수를 줄여 더 빨라졌습니다."

#: ../../library/os.rst:3667
msgid ""
"This behaves exactly like :func:`walk`, except that it yields a 4-tuple "
"``(dirpath, dirnames, filenames, dirfd)``, and it supports ``dir_fd``."
msgstr ""
"이 함수는 :func:`walk`\\와 똑같이 동작합니다. 단, 4-튜플 ``(dirpath, dirnames, filenames,"
" dirfd)``\\를 산출하고 ``dir_fd``\\를 지원합니다."

#: ../../library/os.rst:3670
msgid ""
"*dirpath*, *dirnames* and *filenames* are identical to :func:`walk` "
"output, and *dirfd* is a file descriptor referring to the directory "
"*dirpath*."
msgstr ""
"*dirpath* , *dirnames* 및 *filenames* 은 :func:`walk` 출력과 같고, *dirfd* 는 "
"*dirpath* 디렉터리를 가리키는 파일 기술자입니다."

#: ../../library/os.rst:3673
msgid ""
"This function always supports :ref:`paths relative to directory "
"descriptors <dir_fd>` and :ref:`not following symlinks "
"<follow_symlinks>`.  Note however that, unlike other functions, the "
":func:`fwalk` default value for *follow_symlinks* is ``False``."
msgstr ""
"이 함수는 항상 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>` 및 :ref:`심볼릭 링크를 따르지 않음 "
"<follow_symlinks>`\\을 지원합니다. 하지만, 다른 함수와는 달리, *follow_symlinks*\\에 대한 "
":func:`fwalk`\\의 기본값은 ``False``\\임에 주의하십시오."

#: ../../library/os.rst:3680
msgid ""
"Since :func:`fwalk` yields file descriptors, those are only valid until "
"the next iteration step, so you should duplicate them (e.g. with "
":func:`dup`) if you want to keep them longer."
msgstr ""
":func:`fwalk`\\는 다음 이터레이션 단계까지만 유효한 파일 기술자를 산출하기 때문에, 더 오래 유지하려면 복제해야 합니다"
" (예를 들어, :func:`dup`\\로)."

#: ../../library/os.rst:3688
msgid ""
"import os\n"
"for root, dirs, files, rootfd in os.fwalk('python/Lib/xml'):\n"
"    print(root, \"consumes\", end=\"\")\n"
"    print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),\n"
"          end=\"\")\n"
"    print(\"bytes in\", len(files), \"non-directory files\")\n"
"    if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')  # don't visit __pycache__ directories"
msgstr ""

#: ../../library/os.rst:3697
msgid ""
"In the next example, walking the tree bottom-up is essential: "
":func:`rmdir` doesn't allow deleting a directory before the directory is "
"empty::"
msgstr ""
"다음 예에서는, 트리를 상향식으로 탐색하는 것이 필수적입니다: :func:`rmdir`\\는 비어 있지 않은 디렉터리를 삭제할 수 "
"없습니다::"

#: ../../library/os.rst:3701
msgid ""
"# Delete everything reachable from the directory named in \"top\",\n"
"# assuming there are no symbolic links.\n"
"# CAUTION:  This is dangerous!  For example, if top == '/', it\n"
"# could delete all your disk files.\n"
"import os\n"
"for root, dirs, files, rootfd in os.fwalk(top, topdown=False):\n"
"    for name in files:\n"
"        os.unlink(name, dir_fd=rootfd)\n"
"    for name in dirs:\n"
"        os.rmdir(name, dir_fd=rootfd)"
msgstr ""

#: ../../library/os.rst:3712
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.fwalk`` with arguments "
"``top``, ``topdown``, ``onerror``, ``follow_symlinks``, ``dir_fd``."
msgstr ""
"``top``, ``topdown``, ``onerror``, ``follow_symlinks``, ``dir_fd``\\를 인자로"
" :ref:`감사 이벤트(auditing event) <auditing>` ``os.fwalk``\\를 발생시킵니다."

#: ../../library/os.rst:3721
msgid "Added support for :class:`bytes` paths."
msgstr ":class:`bytes` 경로에 대한 지원이 추가되었습니다."

#: ../../library/os.rst:3727
msgid ""
"Create an anonymous file and return a file descriptor that refers to it. "
"*flags* must be one of the ``os.MFD_*`` constants available on the system"
" (or a bitwise ORed combination of them).  By default, the new file "
"descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"익명 파일을 만들고 이를 가리키는 파일 기술자를 반환합니다. *flags*\\는 시스템에서 사용할 수 있는 ``os.MFD_*`` "
"상수(또는 이들의 비트별 OR 조합) 중 하나여야 합니다. 기본적으로, 새 파일 기술자는 :ref:`상속 불가능 "
"<fd_inheritance>`\\합니다."

#: ../../library/os.rst:3732
msgid ""
"The name supplied in *name* is used as a filename and will be displayed "
"as the target of the corresponding symbolic link in the directory "
"``/proc/self/fd/``. The displayed name is always prefixed with ``memfd:``"
" and serves only for debugging purposes. Names do not affect the behavior"
" of the file descriptor, and as such multiple files can have the same "
"name without any side effects."
msgstr ""
"*name*\\에 제공된 이름은 파일명으로 사용되며 해당 심볼릭 링크의 대상으로 ``/proc/self/fd/`` 디렉터리에 "
"표시됩니다. 표시된 이름에는 항상 ``memfd:`` 접두어가 붙으며 디버깅 목적으로만 사용됩니다. 이름은 파일 기술자의 동작에 "
"영향을 미치지 않고, 여러 파일이 부작용 없이 같은 이름을 가질 수 있습니다."

#: ../../library/os.rst:3762
msgid "These flags can be passed to :func:`memfd_create`."
msgstr "이 플래그들은 :func:`memfd_create`\\로 전달될 수 있습니다."

#: ../../library/os.rst:3766
#, fuzzy
msgid "The ``MFD_HUGE*`` flags are only available since Linux 4.14."
msgstr "이 함수들은 모두 리눅스에서만 사용 가능합니다."

#: ../../library/os.rst:3773
msgid ""
"Create and return an event file descriptor. The file descriptors supports"
" raw :func:`read` and :func:`write` with a buffer size of 8, "
":func:`~select.select`, :func:`~select.poll` and similar. See man page "
":manpage:`eventfd(2)` for more information.  By default, the new file "
"descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""

#: ../../library/os.rst:3779
msgid ""
"*initval* is the initial value of the event counter. The initial value "
"must be a 32 bit unsigned integer. Please note that the initial value is "
"limited to a 32 bit unsigned int although the event counter is an "
"unsigned 64 bit integer with a maximum value of 2\\ :sup:`64`\\ -\\ 2."
msgstr ""

#: ../../library/os.rst:3784
msgid ""
"*flags* can be constructed from :const:`EFD_CLOEXEC`, "
":const:`EFD_NONBLOCK`, and :const:`EFD_SEMAPHORE`."
msgstr ""

#: ../../library/os.rst:3787
msgid ""
"If :const:`EFD_SEMAPHORE` is specified and the event counter is non-zero,"
" :func:`eventfd_read` returns 1 and decrements the counter by one."
msgstr ""

#: ../../library/os.rst:3790
msgid ""
"If :const:`EFD_SEMAPHORE` is not specified and the event counter is non-"
"zero, :func:`eventfd_read` returns the current event counter value and "
"resets the counter to zero."
msgstr ""

#: ../../library/os.rst:3794
msgid ""
"If the event counter is zero and :const:`EFD_NONBLOCK` is not specified, "
":func:`eventfd_read` blocks."
msgstr ""

#: ../../library/os.rst:3797
msgid ""
":func:`eventfd_write` increments the event counter. Write blocks if the "
"write operation would increment the counter to a value larger than 2\\ "
":sup:`64`\\ -\\ 2."
msgstr ""

#: ../../library/os.rst:3803
msgid ""
"import os\n"
"\n"
"# semaphore with start value '1'\n"
"fd = os.eventfd(1, os.EFD_SEMAPHORE | os.EFC_CLOEXEC)\n"
"try:\n"
"    # acquire semaphore\n"
"    v = os.eventfd_read(fd)\n"
"    try:\n"
"        do_work()\n"
"    finally:\n"
"        # release semaphore\n"
"        os.eventfd_write(fd, v)\n"
"finally:\n"
"    os.close(fd)"
msgstr ""

#: ../../library/os.rst:3824
msgid ""
"Read value from an :func:`eventfd` file descriptor and return a 64 bit "
"unsigned int. The function does not verify that *fd* is an "
":func:`eventfd`."
msgstr ""

#: ../../library/os.rst:3833
msgid ""
"Add value to an :func:`eventfd` file descriptor. *value* must be a 64 bit"
" unsigned int. The function does not verify that *fd* is an "
":func:`eventfd`."
msgstr ""

#: ../../library/os.rst:3842
msgid "Set close-on-exec flag for new :func:`eventfd` file descriptor."
msgstr ""

#: ../../library/os.rst:3850
msgid ""
"Set :const:`O_NONBLOCK` status flag for new :func:`eventfd` file "
"descriptor."
msgstr ""

#: ../../library/os.rst:3859
msgid ""
"Provide semaphore-like semantics for reads from an :func:`eventfd` file "
"descriptor. On read the internal counter is decremented by one."
msgstr ""

#: ../../library/os.rst:3870
#, fuzzy
msgid "Timer File Descriptors"
msgstr "파일 기술자의 상속"

#: ../../library/os.rst:3874
msgid ""
"These functions provide support for Linux's *timer file descriptor* API. "
"Naturally, they are all only available on Linux."
msgstr ""

#: ../../library/os.rst:3879
#, fuzzy
msgid "Create and return a timer file descriptor (*timerfd*)."
msgstr "파일 기술자 *fd*\\에서 최대 *n* 바이트를 읽습니다."

#: ../../library/os.rst:3881
msgid "The file descriptor returned by :func:`timerfd_create` supports:"
msgstr ""

#: ../../library/os.rst:3883
msgid ":func:`read`"
msgstr ""

#: ../../library/os.rst:3884
msgid ":func:`~select.select`"
msgstr ""

#: ../../library/os.rst:3885
msgid ":func:`~select.poll`"
msgstr ""

#: ../../library/os.rst:3887
msgid ""
"The file descriptor's :func:`read` method can be called with a buffer "
"size of 8. If the timer has already expired one or more times, "
":func:`read` returns the number of expirations with the host's "
"endianness, which may be converted to an :class:`int` by "
"``int.from_bytes(x, byteorder=sys.byteorder)``."
msgstr ""

#: ../../library/os.rst:3892
msgid ""
":func:`~select.select` and :func:`~select.poll` can be used to wait until"
" timer expires and the file descriptor is readable."
msgstr ""

#: ../../library/os.rst:3895
msgid ""
"*clockid* must be a valid :ref:`clock ID <time-clock-id-constants>`, as "
"defined in the :py:mod:`time` module:"
msgstr ""

#: ../../library/os.rst:3898
msgid ":const:`time.CLOCK_REALTIME`"
msgstr ""

#: ../../library/os.rst:3899
msgid ":const:`time.CLOCK_MONOTONIC`"
msgstr ""

#: ../../library/os.rst:3900
msgid ":const:`time.CLOCK_BOOTTIME` (Since Linux 3.15 for timerfd_create)"
msgstr ""

#: ../../library/os.rst:3902
msgid ""
"If *clockid* is :const:`time.CLOCK_REALTIME`, a settable system-wide "
"real-time clock is used. If system clock is changed, timer setting need "
"to be updated. To cancel timer when system clock is changed, see "
":const:`TFD_TIMER_CANCEL_ON_SET`."
msgstr ""

#: ../../library/os.rst:3907
msgid ""
"If *clockid* is :const:`time.CLOCK_MONOTONIC`, a non-settable "
"monotonically increasing clock is used. Even if the system clock is "
"changed, the timer setting will not be affected."
msgstr ""

#: ../../library/os.rst:3911
msgid ""
"If *clockid* is :const:`time.CLOCK_BOOTTIME`, same as "
":const:`time.CLOCK_MONOTONIC` except it includes any time that the system"
" is suspended."
msgstr ""

#: ../../library/os.rst:3914
msgid ""
"The file descriptor's behaviour can be modified by specifying a *flags* "
"value. Any of the following variables may used, combined using bitwise OR"
" (the ``|`` operator):"
msgstr ""

#: ../../library/os.rst:3918
msgid ":const:`TFD_NONBLOCK`"
msgstr ""

#: ../../library/os.rst:3919
msgid ":const:`TFD_CLOEXEC`"
msgstr ""

#: ../../library/os.rst:3921
msgid ""
"If :const:`TFD_NONBLOCK` is not set as a flag, :func:`read` blocks until "
"the timer expires. If it is set as a flag, :func:`read` doesn't block, "
"but If there hasn't been an expiration since the last call to read, "
":func:`read` raises :class:`OSError` with ``errno`` is set to "
":const:`errno.EAGAIN`."
msgstr ""

#: ../../library/os.rst:3927
msgid ":const:`TFD_CLOEXEC` is always set by Python automatically."
msgstr ""

#: ../../library/os.rst:3929
msgid ""
"The file descriptor must be closed with :func:`os.close` when it is no "
"longer needed, or else the file descriptor will be leaked."
msgstr ""

#: ../../library/os.rst:3932
#, fuzzy
msgid "The :manpage:`timerfd_create(2)` man page."
msgstr "자세한 내용은 :manpage:`pidfd_open(2)` 매뉴얼 페이지를 참조하십시오."

#: ../../library/os.rst:3941
msgid ""
"Alter a timer file descriptor's internal timer. This function operates "
"the same interval timer as :func:`timerfd_settime_ns`."
msgstr ""

#: ../../library/os.rst:3944
msgid "*fd* must be a valid timer file descriptor."
msgstr ""

#: ../../library/os.rst:3946
msgid ""
"The timer's behaviour can be modified by specifying a *flags* value. Any "
"of the following variables may used, combined using bitwise OR (the ``|``"
" operator):"
msgstr ""

#: ../../library/os.rst:3950
msgid ":const:`TFD_TIMER_ABSTIME`"
msgstr ""

#: ../../library/os.rst:3951
msgid ":const:`TFD_TIMER_CANCEL_ON_SET`"
msgstr ""

#: ../../library/os.rst:3953
msgid ""
"The timer is disabled by setting *initial* to zero (``0``). If *initial* "
"is equal to or greater than zero, the timer is enabled. If *initial* is "
"less than zero, it raises an :class:`OSError` exception with ``errno`` "
"set to :const:`errno.EINVAL`"
msgstr ""

#: ../../library/os.rst:3958
msgid ""
"By default the timer will fire when *initial* seconds have elapsed. (If "
"*initial* is zero, timer will fire immediately.)"
msgstr ""

#: ../../library/os.rst:3961
msgid ""
"However, if the :const:`TFD_TIMER_ABSTIME` flag is set, the timer will "
"fire when the timer's clock (set by *clockid* in :func:`timerfd_create`) "
"reaches *initial* seconds."
msgstr ""

#: ../../library/os.rst:3965
msgid ""
"The timer's interval is set by the *interval* :py:class:`float`. If "
"*interval* is zero, the timer only fires once, on the initial expiration."
" If *interval* is greater than zero, the timer fires every time "
"*interval* seconds have elapsed since the previous expiration. If "
"*interval* is less than zero, it raises :class:`OSError` with ``errno`` "
"set to :const:`errno.EINVAL`"
msgstr ""

#: ../../library/os.rst:3972
msgid ""
"If the :const:`TFD_TIMER_CANCEL_ON_SET` flag is set along with "
":const:`TFD_TIMER_ABSTIME` and the clock for this timer is "
":const:`time.CLOCK_REALTIME`, the timer is marked as cancelable if the "
"real-time clock is changed discontinuously. Reading the descriptor is "
"aborted with the error ECANCELED."
msgstr ""

#: ../../library/os.rst:3978
msgid ""
"Linux manages system clock as UTC. A daylight-savings time transition is "
"done by changing time offset only and doesn't cause discontinuous system "
"clock change."
msgstr ""

#: ../../library/os.rst:3982
msgid "Discontinuous system clock change will be caused by the following events:"
msgstr ""

#: ../../library/os.rst:3984
msgid "``settimeofday``"
msgstr ""

#: ../../library/os.rst:3985
msgid "``clock_settime``"
msgstr ""

#: ../../library/os.rst:3986
msgid "set the system date and time by ``date`` command"
msgstr ""

#: ../../library/os.rst:3988
msgid ""
"Return a two-item tuple of (``next_expiration``, ``interval``) from the "
"previous timer state, before this function executed."
msgstr ""

#: ../../library/os.rst:3993
msgid ""
":manpage:`timerfd_create(2)`, :manpage:`timerfd_settime(2)`, "
":manpage:`settimeofday(2)`, :manpage:`clock_settime(2)`, and "
":manpage:`date(1)`."
msgstr ""

#: ../../library/os.rst:4004
msgid ""
"Similar to :func:`timerfd_settime`, but use time as nanoseconds. This "
"function operates the same interval timer as :func:`timerfd_settime`."
msgstr ""

#: ../../library/os.rst:4014
msgid "Return a two-item tuple of floats (``next_expiration``, ``interval``)."
msgstr ""

#: ../../library/os.rst:4016
msgid ""
"``next_expiration`` denotes the relative time until next the timer next "
"fires, regardless of if the :const:`TFD_TIMER_ABSTIME` flag is set."
msgstr ""

#: ../../library/os.rst:4019
msgid ""
"``interval`` denotes the timer's interval. If zero, the timer will only "
"fire once, after ``next_expiration`` seconds have elapsed."
msgstr ""

#: ../../library/os.rst:4023
msgid ":manpage:`timerfd_gettime(2)`"
msgstr ""

#: ../../library/os.rst:4032
msgid "Similar to :func:`timerfd_gettime`, but return time as nanoseconds."
msgstr ""

#: ../../library/os.rst:4040
msgid ""
"A flag for the :func:`timerfd_create` function, which sets the "
":const:`O_NONBLOCK` status flag for the new timer file descriptor. If "
":const:`TFD_NONBLOCK` is not set as a flag, :func:`read` blocks."
msgstr ""

#: ../../library/os.rst:4050
msgid ""
"A flag for the :func:`timerfd_create` function, If :const:`TFD_CLOEXEC` "
"is set as a flag, set close-on-exec flag for new file descriptor."
msgstr ""

#: ../../library/os.rst:4060
msgid ""
"A flag for the :func:`timerfd_settime` and :func:`timerfd_settime_ns` "
"functions. If this flag is set, *initial* is interpreted as an absolute "
"value on the timer's clock (in UTC seconds or nanoseconds since the Unix "
"Epoch)."
msgstr ""

#: ../../library/os.rst:4070
msgid ""
"A flag for the :func:`timerfd_settime` and :func:`timerfd_settime_ns` "
"functions along with :const:`TFD_TIMER_ABSTIME`. The timer is cancelled "
"when the time of the underlying clock changes discontinuously."
msgstr ""

#: ../../library/os.rst:4081
msgid "Linux extended attributes"
msgstr "리눅스 확장 어트리뷰트"

#: ../../library/os.rst:4085
msgid "These functions are all available on Linux only."
msgstr "이 함수들은 모두 리눅스에서만 사용 가능합니다."

#: ../../library/os.rst:4089
msgid ""
"Return the value of the extended filesystem attribute *attribute* for "
"*path*. *attribute* can be bytes or str (directly or indirectly through "
"the :class:`PathLike` interface). If it is str, it is encoded with the "
"filesystem encoding."
msgstr ""
"*path*\\의 확장 파일 시스템 어트리뷰트 *attribute*\\의 값을 반환합니다. *attribute* 는 bytes 또는"
" str(직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로)일 수 있습니다. str이면, 파일 시스템 "
"인코딩으로 인코딩됩니다."

#: ../../library/os.rst:4097
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.getxattr`` with arguments"
" ``path``, ``attribute``."
msgstr ""
"``path``, ``attribute``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.getxattr``\\을 발생시킵니다."

#: ../../library/os.rst:4099 ../../library/os.rst:4131
#: ../../library/os.rst:4156
msgid "Accepts a :term:`path-like object` for *path* and *attribute*."
msgstr "*path* 및 *attribute*\\에 대해 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/os.rst:4105
msgid ""
"Return a list of the extended filesystem attributes on *path*.  The "
"attributes in the list are represented as strings decoded with the "
"filesystem encoding.  If *path* is ``None``, :func:`listxattr` will "
"examine the current directory."
msgstr ""
"*path* 의 확장 파일 시스템 어트리뷰트 목록을 반환합니다. 목록의 어트리뷰트는 파일 시스템 인코딩으로 디코딩된 문자열로 "
"표시됩니다. *path* 가 ``None``\\이면, :func:`listxattr`\\는 현재 디렉터리를 검사합니다."

#: ../../library/os.rst:4113
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.listxattr`` with argument"
" ``path``."
msgstr ""
"``path``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.listxattr``\\을 발생시킵니다."

#: ../../library/os.rst:4121
#, fuzzy
msgid ""
"Removes the extended filesystem attribute *attribute* from *path*. "
"*attribute* should be bytes or str (directly or indirectly through the "
":class:`PathLike` interface). If it is a string, it is encoded with the "
":term:`filesystem encoding and error handler`."
msgstr ""
"*path* 에서 확장 파일 시스템 어트리뷰트 *attribute* 을 제거합니다. *attribute* 는 bytes 또는 "
"str(직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로)이어야합니다. 문자열이면, 파일 시스템 인코딩으로 "
"인코딩됩니다."

#: ../../library/os.rst:4129
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.removexattr`` with "
"arguments ``path``, ``attribute``."
msgstr ""
"``path``, ``attribute``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.removexattr``\\을 발생시킵니다."

#: ../../library/os.rst:4137
#, fuzzy
msgid ""
"Set the extended filesystem attribute *attribute* on *path* to *value*. "
"*attribute* must be a bytes or str with no embedded NULs (directly or "
"indirectly through the :class:`PathLike` interface). If it is a str, it "
"is encoded with the :term:`filesystem encoding and error handler`.  "
"*flags* may be :data:`XATTR_REPLACE` or :data:`XATTR_CREATE`. If "
":data:`XATTR_REPLACE` is given and the attribute does not exist, "
"``ENODATA`` will be raised. If :data:`XATTR_CREATE` is given and the "
"attribute already exists, the attribute will not be created and "
"``EEXISTS`` will be raised."
msgstr ""
"*path* 에 있는 확장 파일 시스템 어트리뷰트 *attribute*\\를 *value*\\로 설정합니다. *attribute* "
"는 내장된 NUL이 없는 bytes 또는 str(직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로)이어야 "
"합니다. str이면, 파일 시스템 인코딩으로 인코딩됩니다. *flags* 는 :data:`XATTR_REPLACE` 또는 "
":data:`XATTR_CREATE` 일 수 있습니다. :data:`XATTR_REPLACE`\\가 주어지고 어트리뷰트가 존재하지 "
"않으면, ``EEXISTS``\\가 발생합니다. :data:`XATTR_CREATE`\\가 주어지고 어트리뷰트가 이미 존재하면, "
"어트리뷰트는 만들어지지 않고 ``ENODATA``\\가 발생합니다."

#: ../../library/os.rst:4151
msgid ""
"A bug in Linux kernel versions less than 2.6.39 caused the flags argument"
" to be ignored on some filesystems."
msgstr "리눅스 커널 버전 2.6.39 미만의 버그로 인해 flags 인자가 일부 파일 시스템에서 무시되었습니다."

#: ../../library/os.rst:4154
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.setxattr`` with arguments"
" ``path``, ``attribute``, ``value``, ``flags``."
msgstr ""
"``path``, ``attribute``, ``value``, ``flags``\\를 인자로 :ref:`감사 "
"이벤트(auditing event) <auditing>` ``os.setxattr``\\을 발생시킵니다."

#: ../../library/os.rst:4162
msgid ""
"The maximum size the value of an extended attribute can be. Currently, "
"this is 64 KiB on Linux."
msgstr "확장 어트리뷰트 값의 최대 크기입니다. 현재, 리눅스에서 64 KiB입니다."

#: ../../library/os.rst:4168
msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must create an attribute."
msgstr ""
"이것은 :func:`setxattr`\\의 flags 인자를 위한 값입니다. 연산이 반드시 어트리뷰트를 새로 만들어야 함을 "
"나타냅니다."

#: ../../library/os.rst:4174
msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must replace an existing attribute."
msgstr ""
"이것은 :func:`setxattr`\\의 flags 인자를 위한 값입니다. 연산이 반드시 기존 어트리뷰트를 대체해야 함을 "
"나타냅니다."

#: ../../library/os.rst:4181
msgid "Process Management"
msgstr "프로세스 관리"

#: ../../library/os.rst:4183
msgid "These functions may be used to create and manage processes."
msgstr "이 함수들은 프로세스를 만들고 관리하는데 사용될 수 있습니다."

#: ../../library/os.rst:4185
msgid ""
"The various :func:`exec\\* <execl>` functions take a list of arguments "
"for the new program loaded into the process.  In each case, the first of "
"these arguments is passed to the new program as its own name rather than "
"as an argument a user may have typed on a command line.  For the C "
"programmer, this is the ``argv[0]`` passed to a program's :c:func:`main`."
"  For example, ``os.execv('/bin/echo', ['foo', 'bar'])`` will only print "
"``bar`` on standard output; ``foo`` will seem to be ignored."
msgstr ""
"다양한 :func:`exec\\* <execl>` 함수는 프로세스로 로드되는 새 프로그램에 대한 인자 목록을 받아들입니다. 각각의 "
"경우에, 첫 번째 인자는 사용자가 명령 줄에 입력할 수 있는 인자가 아닌 프로그램 자체의 이름으로 새 프로그램에 전달됩니다. C "
"프로그래머에게, 이것은 프로그램의 :c:func:`main`\\에 전달된 ``argv[0]``\\입니다. 예를 들어, "
"``os.execv('/bin/echo', ['foo', 'bar'])``\\는 표준 출력에 ``bar``\\만 인쇄합니다; "
"``foo``\\는 무시되는 것처럼 보이게 됩니다."

#: ../../library/os.rst:4196
msgid ""
"Generate a :const:`SIGABRT` signal to the current process.  On Unix, the "
"default behavior is to produce a core dump; on Windows, the process "
"immediately returns an exit code of ``3``.  Be aware that calling this "
"function will not call the Python signal handler registered for "
":const:`SIGABRT` with :func:`signal.signal`."
msgstr ""
"현재 프로세스에 :const:`SIGABRT` 시그널을 생성합니다. 유닉스에서, 기본 동작은 코어 덤프를 생성하는 것입니다; "
"윈도우에서, 프로세스는 즉시 종료 코드 ``3``\\을 반환합니다. 이 함수를 호출하면 :func:`signal.signal`\\를"
" 사용하여 :const:`SIGABRT`\\에 등록된 파이썬 시그널 처리기를 호출하지 않게 됨에 주의하시기 바랍니다."

#: ../../library/os.rst:4205
msgid "Add a path to the DLL search path."
msgstr "DLL 검색 경로에 path를 추가합니다."

#: ../../library/os.rst:4207
#, fuzzy
msgid ""
"This search path is used when resolving dependencies for imported "
"extension modules (the module itself is resolved through "
":data:`sys.path`), and also by :mod:`ctypes`."
msgstr ""
"이 검색 경로는 임포트 된 확장 모듈의 종속성을 해결할 때 사용됩니다 (모듈 자체는 sys.path를 통해 결정됩니다). 또한 "
":mod:`ctypes`\\에서도 사용됩니다."

#: ../../library/os.rst:4211
msgid ""
"Remove the directory by calling **close()** on the returned object or "
"using it in a :keyword:`with` statement."
msgstr ""
"반환된 객체의 **close()**\\를 호출하거나 반환된 객체를 :keyword:`with` 문에서 사용하여 디렉터리를 "
"제거하십시오."

#: ../../library/os.rst:4214
msgid ""
"See the `Microsoft documentation "
"<https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5>`_ for "
"more information about how DLLs are loaded."
msgstr ""
"DLL이 로드되는 방법에 대한 자세한 내용은 `마이크로소프트 설명서 "
"<https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5>`_\\를 "
"참조하십시오."

#: ../../library/os.rst:4218
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.add_dll_directory`` with "
"argument ``path``."
msgstr ""
"``path``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.add_dll_directory``\\를 발생시킵니다."

#: ../../library/os.rst:4222
msgid ""
"Previous versions of CPython would resolve DLLs using the default "
"behavior for the current process. This led to inconsistencies, such as "
"only sometimes searching :envvar:`PATH` or the current working directory,"
" and OS functions such as ``AddDllDirectory`` having no effect."
msgstr ""
"이전 버전의 CPython은 현재 프로세스의 기본 동작을 사용하여 DLL을 해결(resolve)합니다. 이로 인해 때때로 "
":envvar:`PATH`\\나 현재 작업 디렉터리를 검색하거나, ``AddDllDirectory``\\와 같은 OS 함수가 효과가"
" 없게 되는 것과 같은 일관성 없는 결과를 낳습니다."

#: ../../library/os.rst:4229
msgid ""
"In 3.8, the two primary ways DLLs are loaded now explicitly override the "
"process-wide behavior to ensure consistency. See the :ref:`porting notes "
"<bpo-36085-whatsnew>` for information on updating libraries."
msgstr ""
"3.8에서는, 일관성을 보장하기 위해 이제 DLL이 로드되는 두 가지 기본 방법이 프로세스 전반의 동작을 명시적으로 재정의합니다. "
"라이브러리 갱신에 대한 정보는 :ref:`이식 주의 사항 <bpo-36085-whatsnew>`\\을 참조하십시오."

#: ../../library/os.rst:4244
msgid ""
"These functions all execute a new program, replacing the current process;"
" they do not return.  On Unix, the new executable is loaded into the "
"current process, and will have the same process id as the caller.  Errors"
" will be reported as :exc:`OSError` exceptions."
msgstr ""
"이 함수들은 모두 현재 프로세스를 대체해서 새로운 프로그램을 실행합니다; 반환되지 않습니다. 유닉스에서, 새로운 실행 파일이 현재 "
"프로세스에 로드되고, 호출자와 같은 프로세스 ID를 갖게 됩니다. 에러는 :exc:`OSError` 예외로 보고됩니다."

#: ../../library/os.rst:4249
msgid ""
"The current process is replaced immediately. Open file objects and "
"descriptors are not flushed, so if there may be data buffered on these "
"open files, you should flush them using :func:`sys.stdout.flush` or "
":func:`os.fsync` before calling an :func:`exec\\* <execl>` function."
msgstr ""
"현재 프로세스가 즉시 교체됩니다. 열린 파일 객체와 기술자는 플러시 되지 않으므로, 이러한 열린 파일에 버퍼링 된 데이터가 있으면,"
" :func:`exec\\* <execl>` 함수를 호출하기 전에 :func:`sys.stdout.flush` 또는 "
":func:`os.fsync`\\를 사용하여 플러시 해야 합니다."

#: ../../library/os.rst:4255
#, fuzzy
msgid ""
"The \"l\" and \"v\" variants of the :func:`exec\\* <execl>` functions "
"differ in how command-line arguments are passed.  The \"l\" variants are "
"perhaps the easiest to work with if the number of parameters is fixed "
"when the code is written; the individual parameters simply become "
"additional parameters to the :func:`!execl\\*` functions.  The \"v\" "
"variants are good when the number of parameters is variable, with the "
"arguments being passed in a list or tuple as the *args* parameter.  In "
"either case, the arguments to the child process should start with the "
"name of the command being run, but this is not enforced."
msgstr ""
":func:`exec\\* <execl>` 함수의 \"l\" 및 \"v\" 변형은 명령 줄 인자가 전달되는 방식이 다릅니다. "
"\"l\" 변형은 아마도 코드가 작성될 때 매개 변수의 수가 고정되어 있다면 가장 작업하기 쉬운 것입니다; 개별 매개 변수는 단순히"
" :func:`execl\\*` 함수에 대한 추가 매개 변수가 됩니다. \"v\" 변형은 매개 변수의 개수가 가변적일 때 좋으며, "
"리스트나 튜플에 들어있는 인자가 *args* 매개 변수로 전달됩니다. 두 경우 모두, 자식 프로세스에 대한 인자는 실행 중인 명령의"
" 이름으로 시작해야 하지만, 강제되지는 않습니다."

#: ../../library/os.rst:4264
#, fuzzy
msgid ""
"The variants which include a \"p\" near the end (:func:`execlp`, "
":func:`execlpe`, :func:`execvp`, and :func:`execvpe`) will use the "
":envvar:`PATH` environment variable to locate the program *file*.  When "
"the environment is being replaced (using one of the :func:`exec\\*e "
"<execl>` variants, discussed in the next paragraph), the new environment "
"is used as the source of the :envvar:`PATH` variable. The other variants,"
" :func:`execl`, :func:`execle`, :func:`execv`, and :func:`execve`, will "
"not use the :envvar:`PATH` variable to locate the executable; *path* must"
" contain an appropriate absolute or relative path. Relative paths must "
"include at least one slash, even on Windows, as plain names will not be "
"resolved."
msgstr ""
"끝 근처에 \"p\"가 포함된 변형(:func:`execlp`, :func:`execlpe`, :func:`execvp` 및 "
":func:`execvpe`)은 :envvar:`PATH` 환경 변수를 사용하여 프로그램 *file* 을 찾습니다. 환경이 대체 될"
" 때 (다음 단락에서 설명할 :func:`exec\\*e <execl>` 변형 중 하나를 사용하여), 새 환경이 "
":envvar:`PATH` 변수의 소스로 사용됩니다. 다른 변형 :func:`execl`, :func:`execle`, "
":func:`execv` 및 :func:`execve`\\는 :envvar:`PATH` 변수를 사용하여 실행 파일을 찾지 않습니다;"
" *path* 에는 반드시 적절한 절대 또는 상대 경로가 있어야 합니다."

#: ../../library/os.rst:4275
msgid ""
"For :func:`execle`, :func:`execlpe`, :func:`execve`, and :func:`execvpe` "
"(note that these all end in \"e\"), the *env* parameter must be a mapping"
" which is used to define the environment variables for the new process "
"(these are used instead of the current process' environment); the "
"functions :func:`execl`, :func:`execlp`, :func:`execv`, and "
":func:`execvp` all cause the new process to inherit the environment of "
"the current process."
msgstr ""
":func:`execle`, :func:`execlpe`, :func:`execve`, :func:`execvpe`\\의 경우 "
"(모두 \"e\"로 끝납니다), *env* 매개 변수는 새 프로세스의 환경 변수를 정의하는 데 사용되는 매핑이어야 합니다 (이것이 "
"현재 프로세스의 환경 대신 사용됩니다); 함수 :func:`execl`, :func:`execlp`, :func:`execv` 및 "
":func:`execvp`\\는 모두 새 프로세스가 현재 프로세스의 환경을 상속하게 합니다."

#: ../../library/os.rst:4282
msgid ""
"For :func:`execve` on some platforms, *path* may also be specified as an "
"open file descriptor.  This functionality may not be supported on your "
"platform; you can check whether or not it is available using "
":data:`os.supports_fd`. If it is unavailable, using it will raise a "
":exc:`NotImplementedError`."
msgstr ""
"일부 플랫폼에서 :func:`execve`\\의 경우, *path* 는 열린 파일 기술자로도 지정될 수 있습니다. 이 기능은 "
"여러분의 플랫폼에서 지원되지 않을 수 있습니다; :data:`os.supports_fd`\\를 사용하여 사용할 수 있는지를 확인할 "
"수 있습니다. 사용할 수 없을 때, 이를 사용하면 :exc:`NotImplementedError`\\가 발생합니다."

#: ../../library/os.rst:4287
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.exec`` with arguments "
"``path``, ``args``, ``env``."
msgstr ""
"``path``, ``args``, ``env``\\를 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``os.exec``\\를 발생시킵니다."

#: ../../library/os.rst:4291
msgid ""
"Added support for specifying *path* as an open file descriptor for "
":func:`execve`."
msgstr ":func:`execve`\\의 *path*\\에 열린 파일 기술자를 지정하는 지원이 추가되었습니다."

#: ../../library/os.rst:4300
msgid ""
"Exit the process with status *n*, without calling cleanup handlers, "
"flushing stdio buffers, etc."
msgstr "상태 *n*\\으로 프로세스를 종료합니다. 클린업 처리기를 호출하거나, stdio 버퍼를 플러시 하거나 등등은 수행하지 않습니다."

#: ../../library/os.rst:4305
#, fuzzy
msgid ""
"The standard way to exit is :func:`sys.exit(n) <sys.exit>`.  "
":func:`!_exit` should normally only be used in the child process after a "
":func:`fork`."
msgstr ""
"종료하는 표준 방법은 ``sys.exit(n)``\\입니다. :func:`_exit`\\는 일반적으로 :func:`fork` 이후의"
" 자식 프로세스에서만 사용해야 합니다."

#: ../../library/os.rst:4308
msgid ""
"The following exit codes are defined and can be used with :func:`_exit`, "
"although they are not required.  These are typically used for system "
"programs written in Python, such as a mail server's external command "
"delivery program."
msgstr ""
"필수 조건은 아니지만, 다음 종료 코드가 정의되어 있으며 :func:`_exit`\\와 함께 사용할 수 있습니다. 이것은 메일 "
"서버의 외부 명령 배달 프로그램과 같이 파이썬으로 작성된 시스템 프로그램에서 일반적으로 사용됩니다."

#: ../../library/os.rst:4314
msgid ""
"Some of these may not be available on all Unix platforms, since there is "
"some variation.  These constants are defined where they are defined by "
"the underlying platform."
msgstr ""
"약간의 차이점이 있어서, 이들 중 일부는 모든 유닉스 플랫폼에서 사용하지는 못할 수 있습니다. 이 상수는 하부 플랫폼에서 정의될 "
"때만 정의됩니다."

#: ../../library/os.rst:4321
msgid ""
"Exit code that means no error occurred. May be taken from the defined "
"value of ``EXIT_SUCCESS`` on some platforms. Generally has a value of "
"zero."
msgstr ""

#: ../../library/os.rst:4329
msgid ""
"Exit code that means the command was used incorrectly, such as when the "
"wrong number of arguments are given."
msgstr "잘못된 개수의 인자가 제공된 경우처럼, 명령이 잘못 사용되었음을 나타내는 종료 코드."

#: ../../library/os.rst:4337
msgid "Exit code that means the input data was incorrect."
msgstr "입력 데이터가 잘못되었음을 나타내는 종료 코드."

#: ../../library/os.rst:4344
msgid "Exit code that means an input file did not exist or was not readable."
msgstr "입력 파일이 없거나 읽을 수 없음을 나타내는 종료 코드."

#: ../../library/os.rst:4351
msgid "Exit code that means a specified user did not exist."
msgstr "지정된 사용자가 존재하지 않음을 나타내는 종료 코드."

#: ../../library/os.rst:4358
msgid "Exit code that means a specified host did not exist."
msgstr "지정된 호스트가 존재하지 않음을 나타내는 종료 코드."

#: ../../library/os.rst:4365
msgid "Exit code that means that a required service is unavailable."
msgstr "필수 서비스를 사용할 수 없음을 나타내는 종료 코드."

#: ../../library/os.rst:4372
msgid "Exit code that means an internal software error was detected."
msgstr "내부 소프트웨어 에러가 감지되었음을 나타내는 종료 코드."

#: ../../library/os.rst:4379
msgid ""
"Exit code that means an operating system error was detected, such as the "
"inability to fork or create a pipe."
msgstr "포크 하거나 파이프를 만들 수 없는 등, 운영 체제 에러가 감지되었음을 나타내는 종료 코드."

#: ../../library/os.rst:4387
msgid ""
"Exit code that means some system file did not exist, could not be opened,"
" or had some other kind of error."
msgstr "일부 시스템 파일이 없거나, 열 수 없거나, 다른 에러가 있음을 나타내는 종료 코드."

#: ../../library/os.rst:4395
msgid "Exit code that means a user specified output file could not be created."
msgstr "사용자가 지정한 출력 파일을 만들 수 없음을 나타내는 종료 코드."

#: ../../library/os.rst:4402
msgid "Exit code that means that an error occurred while doing I/O on some file."
msgstr "일부 파일에서 I/O를 수행하는 동안 에러가 발생했음을 나타내는 종료 코드."

#: ../../library/os.rst:4409
msgid ""
"Exit code that means a temporary failure occurred.  This indicates "
"something that may not really be an error, such as a network connection "
"that couldn't be made during a retryable operation."
msgstr ""
"임시 에러가 발생했음을 나타내는 종료 코드. 이는 재시도 가능한 작업 중에 만들 수 없었던 네트워크 연결과 같이 실제로는 에러가 "
"아닐 수 있는 것을 나타냅니다."

#: ../../library/os.rst:4418
msgid ""
"Exit code that means that a protocol exchange was illegal, invalid, or "
"not understood."
msgstr "프로토콜 교환이 불법이거나 유효하지 않거나 이해되지 않았음을 나타내는 종료 코드."

#: ../../library/os.rst:4426
msgid ""
"Exit code that means that there were insufficient permissions to perform "
"the operation (but not intended for file system problems)."
msgstr "작업을 수행할 수 있는 권한이 충분하지 않음을 나타내는 종료 코드 (파일 시스템 문제에는 사용하지 않습니다)."

#: ../../library/os.rst:4434
msgid "Exit code that means that some kind of configuration error occurred."
msgstr "어떤 종류의 구성 에러가 발생했음을 나타내는 종료 코드."

#: ../../library/os.rst:4441
msgid "Exit code that means something like \"an entry was not found\"."
msgstr "\"항목을 찾을 수 없습니다\" 와 같은 것을 의미하는 종료 코드."

#: ../../library/os.rst:4448
msgid ""
"Fork a child process.  Return ``0`` in the child and the child's process "
"id in the parent.  If an error occurs :exc:`OSError` is raised."
msgstr ""
"자식 프로세스를 포크 합니다. 자식에서는 ``0``\\을 반환하고, 부모에서는 자식의 프로세스 ID를 반환합니다. 에러가 발생하면 "
":exc:`OSError`\\를 일으킵니다."

#: ../../library/os.rst:4451
msgid ""
"Note that some platforms including FreeBSD <= 6.3 and Cygwin have known "
"issues when using ``fork()`` from a thread."
msgstr ""
"FreeBSD <= 6.3 및 Cygwin을 포함한 일부 플랫폼은 스레드에서 ``fork()``\\를 사용할 때 알려진 문제점이 "
"있습니다."

#: ../../library/os.rst:4454
msgid "Raises an :ref:`auditing event <auditing>` ``os.fork`` with no arguments."
msgstr "인자 없이 :ref:`감사 이벤트(auditing event) <auditing>` ``os.fork``\\를 발생시킵니다."

#: ../../library/os.rst:4458
msgid ""
"If you use TLS sockets in an application calling ``fork()``, see the "
"warning in the :mod:`ssl` documentation."
msgstr ""

#: ../../library/os.rst:4463 ../../library/os.rst:4507
msgid ""
"On macOS the use of this function is unsafe when mixed with using higher-"
"level system APIs, and that includes using :mod:`urllib.request`."
msgstr ""

#: ../../library/os.rst:4466
msgid ""
"Calling ``fork()`` in a subinterpreter is no longer supported "
"(:exc:`RuntimeError` is raised)."
msgstr ""
"서브 인터프리터에서 ``fork()``\\를 호출하는 것은 더는 지원되지 않습니다 (:exc:`RuntimeError`\\가 "
"발생합니다)."

#: ../../library/os.rst:4470
msgid ""
"If Python is able to detect that your process has multiple threads, "
":func:`os.fork` now raises a :exc:`DeprecationWarning`."
msgstr ""

#: ../../library/os.rst:4474
msgid ""
"We chose to surface this as a warning, when detectable, to better inform "
"developers of a design problem that the POSIX platform specifically notes"
" as not supported. Even in code that *appears* to work, it has never been"
" safe to mix threading with :func:`os.fork` on POSIX platforms. The "
"CPython runtime itself has always made API calls that are not safe for "
"use in the child process when threads existed in the parent (such as "
"``malloc`` and ``free``)."
msgstr ""

#: ../../library/os.rst:4483
msgid ""
"Users of macOS or users of libc or malloc implementations other than "
"those typically found in glibc to date are among those already more "
"likely to experience deadlocks running such code."
msgstr ""

#: ../../library/os.rst:4487
msgid ""
"See `this discussion on fork being incompatible with threads "
"<https://discuss.python.org/t/33555>`_ for technical details of why we're"
" surfacing this longstanding platform compatibility problem to "
"developers."
msgstr ""

#: ../../library/os.rst:4497
msgid ""
"Fork a child process, using a new pseudo-terminal as the child's "
"controlling terminal. Return a pair of ``(pid, fd)``, where *pid* is "
"``0`` in the child, the new child's process id in the parent, and *fd* is"
" the file descriptor of the master end of the pseudo-terminal.  For a "
"more portable approach, use the :mod:`pty` module.  If an error occurs "
":exc:`OSError` is raised."
msgstr ""
"새 의사 터미널을 자식의 제어 터미널로 사용하여 자식 프로세스를 포크 합니다. ``(pid, fd)`` 쌍을 반환하는데, 여기서 "
"*pid* 는 자식에서 ``0``\\이고, 부모에서는 새 자식의 프로세스 ID이고, *fd* 는 의사 터미널의 마스터 단의 파일 "
"기술자입니다. 좀 더 이식성 있는 접근법을 사용하려면, :mod:`pty` 모듈을 사용하십시오. 에러가 발생하면 "
":exc:`OSError`\\를 일으킵니다."

#: ../../library/os.rst:4503
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.forkpty`` with no "
"arguments."
msgstr "인자 없이 :ref:`감사 이벤트(auditing event) <auditing>` ``os.forkpty``\\를 발생시킵니다."

#: ../../library/os.rst:4510
msgid ""
"Calling ``forkpty()`` in a subinterpreter is no longer supported "
"(:exc:`RuntimeError` is raised)."
msgstr ""
"서브 인터프리터에서 ``forkpty()``\\를 호출하는 것은 더는 지원되지 않습니다 (:exc:`RuntimeError`\\가 "
"발생합니다)."

#: ../../library/os.rst:4514
msgid ""
"If Python is able to detect that your process has multiple threads, this "
"now raises a :exc:`DeprecationWarning`. See the longer explanation on "
":func:`os.fork`."
msgstr ""

#: ../../library/os.rst:4528
msgid ""
"Send signal *sig* to the process *pid*.  Constants for the specific "
"signals available on the host platform are defined in the :mod:`signal` "
"module."
msgstr ""
"프로세스 *pid*\\에 시그널 *sig*\\를 보냅니다. 호스트 플랫폼에서 사용할 수 있는 구체적인 시그널에 대한 상수는 "
":mod:`signal` 모듈에 정의되어 있습니다."

#: ../../library/os.rst:4531
#, fuzzy
msgid ""
"Windows: The :const:`signal.CTRL_C_EVENT` and "
":const:`signal.CTRL_BREAK_EVENT` signals are special signals which can "
"only be sent to console processes which share a common console window, "
"e.g., some subprocesses. Any other value for *sig* will cause the process"
" to be unconditionally killed by the TerminateProcess API, and the exit "
"code will be set to *sig*."
msgstr ""
"윈도우: :data:`signal.CTRL_C_EVENT` 및 :data:`signal.CTRL_BREAK_EVENT` 시그널은 "
"같은 콘솔 창을 공유하는 콘솔 프로세스(예를 들어, 일부 자식 프로세스)로만 보낼 수 있는 특수 시그널입니다. *sig*\\에 대한"
" 다른 값은, 프로세스가 TerminateProcess API에 의해 무조건 종료되게 하고, 종료 코드는 *sig* 로 설정됩니다."
" 윈도우 버전의 :func:`kill`\\은 종료시킬 프로세스 핸들도 받아들입니다."

#: ../../library/os.rst:4538
msgid "See also :func:`signal.pthread_kill`."
msgstr ":func:`signal.pthread_kill`\\도 참조하십시오."

#: ../../library/os.rst:4540
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.kill`` with arguments "
"``pid``, ``sig``."
msgstr ""
"``pid``, ``sig``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.kill``\\을 발생시킵니다."

#: ../../library/os.rst:4554
msgid "Send the signal *sig* to the process group *pgid*."
msgstr "시그널 *sig* 를 프로세스 그룹 *pgid* 로 보냅니다."

#: ../../library/os.rst:4556
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.killpg`` with arguments "
"``pgid``, ``sig``."
msgstr ""
"``pgid``, ``sig``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.killpg``\\를 발생시킵니다."

#: ../../library/os.rst:4563
msgid "Add *increment* to the process's \"niceness\".  Return the new niceness."
msgstr "프로세스의 \"우선도(niceness)\"에 *increment* 를 추가합니다. 새로운 우선도를 반환합니다."

#: ../../library/os.rst:4570
#, fuzzy
msgid ""
"Return a file descriptor referring to the process *pid* with *flags* set."
" This descriptor can be used to perform process management without races "
"and signals."
msgstr ""
"프로세스 *pid*\\를 참조하는 파일 기술자를 반환합니다. 이 기술자는 경쟁과 시그널 없이 프로세스 관리를 수행하는 데 사용될 수"
" 있습니다. *flags* 인자는 향후 확장을 위해 제공됩니다; 현재는 아무런 플래그 값도 정의되어 있지 않습니다."

#: ../../library/os.rst:4574
msgid "See the :manpage:`pidfd_open(2)` man page for more details."
msgstr "자세한 내용은 :manpage:`pidfd_open(2)` 매뉴얼 페이지를 참조하십시오."

#: ../../library/os.rst:4581
msgid ""
"This flag indicates that the file descriptor will be non-blocking. If the"
" process referred to by the file descriptor has not yet terminated, then "
"an attempt to wait on the file descriptor using :manpage:`waitid(2)` will"
" immediately return the error :const:`~errno.EAGAIN` rather than "
"blocking."
msgstr ""

#: ../../library/os.rst:4592
msgid ""
"Lock program segments into memory.  The value of *op* (defined in "
"``<sys/lock.h>``) determines which segments are locked."
msgstr "프로그램 세그먼트를 메모리에 잠급니다. (``<sys/lock.h>``\\에서 정의된) *op* 값은 잠기는 세그먼트를 판별합니다."

#: ../../library/os.rst:4600
#, fuzzy
msgid ""
"Open a pipe to or from command *cmd*. The return value is an open file "
"object connected to the pipe, which can be read or written depending on "
"whether *mode* is ``'r'`` (default) or ``'w'``. The *buffering* argument "
"have the same meaning as the corresponding argument to the built-in "
":func:`open` function. The returned file object reads or writes text "
"strings rather than bytes."
msgstr ""
"명령 *cmd*\\와의 파이프 연결을 엽니다. 반환 값은 파이프에 연결된 열린 파일 객체이며, *mode* 가 "
"``'r'``\\(기본값)인지 ``'w'``\\인지에 따라 읽거나 쓸 수 있습니다. *buffering* 인자는 내장 "
":func:`open` 함수에서와 같은 의미가 있습니다. 반환된 파일 객체는 바이트열이 아닌 텍스트 문자열을 읽거나 씁니다."

#: ../../library/os.rst:4608
msgid ""
"The ``close`` method returns :const:`None` if the subprocess exited "
"successfully, or the subprocess's return code if there was an error. On "
"POSIX systems, if the return code is positive it represents the return "
"value of the process left-shifted by one byte.  If the return code is "
"negative, the process was terminated by the signal given by the negated "
"value of the return code.  (For example, the return value might be ``- "
"signal.SIGKILL`` if the subprocess was killed.)  On Windows systems, the "
"return value contains the signed integer return code from the child "
"process."
msgstr ""
"``close`` 메서드는 자식 프로세스가 성공적으로 종료되면 :const:`None`\\을 반환하고, 에러가 있으면 자식 "
"프로세스가 반환한 코드를 반환합니다. POSIX 시스템에서, 반환 코드가 양수면, 프로세스의 반환 값을 1바이트 왼쪽으로 시프트 한"
" 값을 나타냅니다. 반환 코드가 음수면, 음의 반환 코드로 주어진 시그널에 의해 강제 종료된 것입니다. 예를 들어, 자식 프로세스가"
" 죽었을(kill) 때 반환 값은 ``- signal.SIGKILL`` 일 수 있습니다. 윈도우 시스템에서, 반환 값은 자식 "
"프로세스의 부호 있는 정수 반환 코드를 포함합니다."

#: ../../library/os.rst:4618
msgid ""
"On Unix, :func:`waitstatus_to_exitcode` can be used to convert the "
"``close`` method result (exit status) into an exit code if it is not "
"``None``. On Windows, the ``close`` method result is directly the exit "
"code (or ``None``)."
msgstr ""
"유닉스에서, :func:`waitstatus_to_exitcode`\\는 ``None``\\이 아닐 때 ``close`` 메서드 "
"결과(종료 상태)를 종료 코드로 변환하는 데 사용할 수 있습니다. 윈도우에서, ``close`` 메서드 결과는 직접 종료 코드(또는"
" ``None``)입니다."

#: ../../library/os.rst:4623
msgid ""
"This is implemented using :class:`subprocess.Popen`; see that class's "
"documentation for more powerful ways to manage and communicate with "
"subprocesses."
msgstr ""
"이것은 :class:`subprocess.Popen`\\를 사용하여 구현됩니다; 자식 프로세스를 관리하고 통신하는 보다 강력한 "
"방법에 대해서는 이 클래스의 설명서를 참조하십시오."

#: ../../library/os.rst:4630
msgid ""
"The :ref:`Python UTF-8 Mode <utf8-mode>` affects encodings used for *cmd*"
" and pipe contents."
msgstr ""

#: ../../library/os.rst:4633
msgid ""
":func:`popen` is a simple wrapper around :class:`subprocess.Popen`. Use "
":class:`subprocess.Popen` or :func:`subprocess.run` to control options "
"like encodings."
msgstr ""

#: ../../library/os.rst:4642
#, fuzzy
msgid "Wraps the :c:func:`!posix_spawn` C library API for use from Python."
msgstr "파이썬에서 사용하기 위해 :c:func:`posix_spawn` C 라이브러리 API를 감쌉니다."

#: ../../library/os.rst:4644
msgid ""
"Most users should use :func:`subprocess.run` instead of "
":func:`posix_spawn`."
msgstr "대부분 사용자는 :func:`posix_spawn` 대신 :func:`subprocess.run`\\을 사용해야 합니다."

#: ../../library/os.rst:4646
#, fuzzy
msgid ""
"The positional-only arguments *path*, *args*, and *env* are similar to "
":func:`execve`. *env* is allowed to be ``None``, in which case current "
"process' environment is used."
msgstr "위치 전용 인자 *path*, *args* 및 *env*\\는 :func:`execve`\\와 유사합니다."

#: ../../library/os.rst:4650
msgid ""
"The *path* parameter is the path to the executable file.  The *path* "
"should contain a directory.  Use :func:`posix_spawnp` to pass an "
"executable file without directory."
msgstr ""
"*path* 매개 변수는 실행 파일의 경로입니다. *path*\\에는 디렉터리가 있어야 합니다. 디렉터리 없이 실행 파일을 "
"전달하려면 :func:`posix_spawnp`\\를 사용하십시오."

#: ../../library/os.rst:4654
msgid ""
"The *file_actions* argument may be a sequence of tuples describing "
"actions to take on specific file descriptors in the child process between"
" the C library implementation's :c:func:`fork` and :c:func:`exec` steps. "
"The first item in each tuple must be one of the three type indicator "
"listed below describing the remaining tuple elements:"
msgstr ""
"*file_actions* 인자는 C 라이브러리 구현의 :c:func:`fork`\\와 :c:func:`exec` 단계 사이의 자식"
" 프로세스에서 특정 파일 기술자에 취할 동작을 설명하는 튜플의 시퀀스 일 수 있습니다. 각 튜플의 첫 번째 항목은 나머지 튜플 "
"요소를 설명하는, 아래에 나열된 세 가지 형 지시자 중 하나여야 합니다:"

#: ../../library/os.rst:4662
msgid "(``os.POSIX_SPAWN_OPEN``, *fd*, *path*, *flags*, *mode*)"
msgstr "(``os.POSIX_SPAWN_OPEN``, *fd*, *path*, *flags*, *mode*)"

#: ../../library/os.rst:4664
msgid "Performs ``os.dup2(os.open(path, flags, mode), fd)``."
msgstr "``os.dup2(os.open(path, flags, mode), fd)``\\를 수행합니다."

#: ../../library/os.rst:4668
msgid "(``os.POSIX_SPAWN_CLOSE``, *fd*)"
msgstr "(``os.POSIX_SPAWN_CLOSE``, *fd*)"

#: ../../library/os.rst:4670
msgid "Performs ``os.close(fd)``."
msgstr "``os.close(fd)``\\를 수행합니다."

#: ../../library/os.rst:4674
msgid "(``os.POSIX_SPAWN_DUP2``, *fd*, *new_fd*)"
msgstr "(``os.POSIX_SPAWN_DUP2``, *fd*, *new_fd*)"

#: ../../library/os.rst:4676
msgid "Performs ``os.dup2(fd, new_fd)``."
msgstr "``os.dup2(fd, new_fd)``\\를 수행합니다."

#: ../../library/os.rst:4680
#, fuzzy
msgid "(``os.POSIX_SPAWN_CLOSEFROM``, *fd*)"
msgstr "(``os.POSIX_SPAWN_CLOSE``, *fd*)"

#: ../../library/os.rst:4682
#, fuzzy
msgid "Performs ``os.closerange(fd, INF)``."
msgstr "``os.close(fd)``\\를 수행합니다."

#: ../../library/os.rst:4684
#, fuzzy
msgid ""
"These tuples correspond to the C library "
":c:func:`!posix_spawn_file_actions_addopen`, "
":c:func:`!posix_spawn_file_actions_addclose`, "
":c:func:`!posix_spawn_file_actions_adddup2`, and "
":c:func:`!posix_spawn_file_actions_addclosefrom_np` API calls used to "
"prepare for the :c:func:`!posix_spawn` call itself."
msgstr ""
"이 튜플은 :c:func:`posix_spawn` 호출 자체를 준비하는 데 사용되는 C 라이브러리 "
":c:func:`posix_spawn_file_actions_addopen`, "
":c:func:`posix_spawn_file_actions_addclose` 및 "
":c:func:`posix_spawn_file_actions_adddup2` API 호출에 해당합니다."

#: ../../library/os.rst:4691
#, fuzzy
msgid ""
"The *setpgroup* argument will set the process group of the child to the "
"value specified. If the value specified is 0, the child's process group "
"ID will be made the same as its process ID. If the value of *setpgroup* "
"is not set, the child will inherit the parent's process group ID. This "
"argument corresponds to the C library :c:macro:`!POSIX_SPAWN_SETPGROUP` "
"flag."
msgstr ""
"*setpgroup* 인자는 자식의 프로세스 그룹을 지정한 값으로 설정합니다. 지정된 값이 0이면, 자식의 프로세스 그룹 ID가 "
"프로세스 ID와 같아집니다. *setpgroup* 값을 설정하지 않으면, 자식 프로세스는 부모의 프로세스 그룹 ID를 상속받습니다."
" 이 인자는 C 라이브러리 :c:data:`POSIX_SPAWN_SETPGROUP` 플래그에 해당합니다."

#: ../../library/os.rst:4697
#, fuzzy
msgid ""
"If the *resetids* argument is ``True`` it will reset the effective UID "
"and GID of the child to the real UID and GID of the parent process. If "
"the argument is ``False``, then the child retains the effective UID and "
"GID of the parent. In either case, if the set-user-ID and set-group-ID "
"permission bits are enabled on the executable file, their effect will "
"override the setting of the effective UID and GID. This argument "
"corresponds to the C library :c:macro:`!POSIX_SPAWN_RESETIDS` flag."
msgstr ""
"*resetids* 인자가 ``True``\\이면, 자식 프로세스의 유효한(effective) UID와 GID를 부모 프로세스의 "
"실제(real) UID와 GID로 재설정합니다. 이 인자가 ``False``\\이면, 자식은 부모의 유효한(effective) "
"UID와 GID를 유지합니다. 두 경우 모두, 실행 파일에서 set-user-ID와 set-group-ID 권한 비트가 "
"활성화되었으면, 해당 효과가 유효한(effective) UID와 GID 설정보다 우선 적용됩니다. 이 인자는 C 라이브러리 "
":c:data:`POSIX_SPAWN_RESETIDS` 플래그에 해당합니다."

#: ../../library/os.rst:4705
#, fuzzy
msgid ""
"If the *setsid* argument is ``True``, it will create a new session ID for"
" ``posix_spawn``. *setsid* requires :c:macro:`!POSIX_SPAWN_SETSID` or "
":c:macro:`!POSIX_SPAWN_SETSID_NP` flag. Otherwise, "
":exc:`NotImplementedError` is raised."
msgstr ""
"*setsid* 인자가 ``True``\\이면, `posix_spawn`\\을 위한 새 세션 ID를 만듭니다. *setsid*\\는"
" :c:data:`POSIX_SPAWN_SETSID`\\나 :c:data:`POSIX_SPAWN_SETSID_NP` 플래그를 "
"요구합니다. 그렇지 않으면, :exc:`NotImplementedError`\\가 발생합니다."

#: ../../library/os.rst:4710
#, fuzzy
msgid ""
"The *setsigmask* argument will set the signal mask to the signal set "
"specified. If the parameter is not used, then the child inherits the "
"parent's signal mask. This argument corresponds to the C library "
":c:macro:`!POSIX_SPAWN_SETSIGMASK` flag."
msgstr ""
"*setsigmask* 인자는 시그널 마스크를 지정된 시그널 집합으로 설정합니다. 매개 변수가 사용되지 않으면, 자식은 부모의 "
"시그널 마스크를 상속받습니다. 이 인자는 C 라이브러리 :c:data:`POSIX_SPAWN_SETSIGMASK` 플래그에 "
"해당합니다."

#: ../../library/os.rst:4715
#, fuzzy
msgid ""
"The *sigdef* argument will reset the disposition of all signals in the "
"set specified. This argument corresponds to the C library "
":c:macro:`!POSIX_SPAWN_SETSIGDEF` flag."
msgstr ""
"*sigdef* 인자는 지정된 집합에 있는 모든 시그널의 처리를 재설정합니다. 이 인자는 C 라이브러리 "
":c:data:`POSIX_SPAWN_SETSIGDEF` 플래그에 해당합니다."

#: ../../library/os.rst:4719
#, fuzzy
msgid ""
"The *scheduler* argument must be a tuple containing the (optional) "
"scheduler policy and an instance of :class:`sched_param` with the "
"scheduler parameters. A value of ``None`` in the place of the scheduler "
"policy indicates that is not being provided. This argument is a "
"combination of the C library :c:macro:`!POSIX_SPAWN_SETSCHEDPARAM` and "
":c:macro:`!POSIX_SPAWN_SETSCHEDULER` flags."
msgstr ""
"*scheduler* 인자는 (선택적) 스케줄러 정책과 스케줄러 매개 변수가 있는 :class:`sched_param` 인스턴스를 "
"포함하는 튜플이어야 합니다. 스케줄러 정책 자리의 ``None`` 값은 제공되지 않음을 나타냅니다. 이 인자는 C 라이브러리 "
":c:data:`POSIX_SPAWN_SETSCHEDPARAM`\\과 :c:data:`POSIX_SPAWN_SETSCHEDULER`"
" 플래그의 조합입니다."

#: ../../library/os.rst:4726 ../../library/os.rst:4747
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.posix_spawn`` with "
"arguments ``path``, ``argv``, ``env``."
msgstr ""
"``path``, ``argv``, ``env``\\를 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``os.posix_spawn``\\을 발생시킵니다."

#: ../../library/os.rst:4730
msgid ""
"*env* parameter accepts ``None``. ``os.POSIX_SPAWN_CLOSEFROM`` is "
"available on platforms where "
":c:func:`!posix_spawn_file_actions_addclosefrom_np` exists."
msgstr ""

#: ../../library/os.rst:4741
#, fuzzy
msgid "Wraps the :c:func:`!posix_spawnp` C library API for use from Python."
msgstr "파이썬에서 사용할 :c:func:`posix_spawnp` C 라이브러리 API를 감쌉니다."

#: ../../library/os.rst:4743
msgid ""
"Similar to :func:`posix_spawn` except that the system searches for the "
"*executable* file in the list of directories specified by the "
":envvar:`PATH` environment variable (in the same way as for "
"``execvp(3)``)."
msgstr ""
"시스템이 (``execvp(3)``\\과 같은 방식으로) :envvar:`PATH` 환경 변수에 의해 지정된 디렉터리 목록에서 "
"*실행* 파일을 검색한다는 점을 제외하고는 :func:`posix_spawn`\\과 유사합니다."

#: ../../library/os.rst:4753
#, fuzzy
msgid "See :func:`posix_spawn` documentation."
msgstr ":ref:`가용성 <availability>`: :func:`posix_spawn` 설명서를 참조하십시오."

#: ../../library/os.rst:4759
msgid ""
"Register callables to be executed when a new child process is forked "
"using :func:`os.fork` or similar process cloning APIs. The parameters are"
" optional and keyword-only. Each specifies a different call point."
msgstr ""
":func:`os.fork` 또는 유사한 프로세스 복제 API를 사용하여 새 자식 프로세스가 포크 될 때 실행될 콜러블들을 "
"등록합니다. 매개 변수는 선택적이며 키워드 전용입니다. 각각은 다른 호출 지점을 지정합니다."

#: ../../library/os.rst:4764
msgid "*before* is a function called before forking a child process."
msgstr "*before* 는 자식 프로세스를 포크 하기 전에 호출되는 함수입니다."

#: ../../library/os.rst:4765
msgid ""
"*after_in_parent* is a function called from the parent process after "
"forking a child process."
msgstr "*after_in_parent* 는 자식 프로세스를 포크 한 후에 부모 프로세스에서 호출되는 함수입니다."

#: ../../library/os.rst:4767
msgid "*after_in_child* is a function called from the child process."
msgstr "*after_in_child* 는 자식 프로세스에서 호출되는 함수입니다."

#: ../../library/os.rst:4769
msgid ""
"These calls are only made if control is expected to return to the Python "
"interpreter.  A typical :mod:`subprocess` launch will not trigger them as"
" the child is not going to re-enter the interpreter."
msgstr ""
"이러한 호출은 제거가 파이썬 인터프리터로 반환될 것으로 예상되는 경우에만 수행됩니다. 일반적인 :mod:`subprocess` "
"실행은 자식이 인터프리터로 재진입하지 않기 때문에, 이 호출들이 일어나지 않습니다."

#: ../../library/os.rst:4773
msgid ""
"Functions registered for execution before forking are called in reverse "
"registration order.  Functions registered for execution after forking "
"(either in the parent or in the child) are called in registration order."
msgstr ""
"포크 이전에 실행되도록 등록된 함수는 등록 역순으로 실행됩니다. 포크 후에 실행되도록 등록된 함수(부모나 자식 모두)는 등록 순서로"
" 호출됩니다."

#: ../../library/os.rst:4778
msgid ""
"Note that :c:func:`fork` calls made by third-party C code may not call "
"those functions, unless it explicitly calls :c:func:`PyOS_BeforeFork`, "
":c:func:`PyOS_AfterFork_Parent` and :c:func:`PyOS_AfterFork_Child`."
msgstr ""
"제삼자 C 코드에 의한 :c:func:`fork` 호출은, 그것이 명시적으로 :c:func:`PyOS_BeforeFork`, "
":c:func:`PyOS_AfterFork_Parent` 및 :c:func:`PyOS_AfterFork_Child`\\를 호출하지 "
"않는 한, 이 함수들을 호출하지 않습니다."

#: ../../library/os.rst:4782
msgid "There is no way to unregister a function."
msgstr "함수 등록을 취소할 방법은 없습니다."

#: ../../library/os.rst:4798
msgid "Execute the program *path* in a new process."
msgstr "새 프로세스에서 프로그램 *path* 를 실행합니다."

#: ../../library/os.rst:4800
msgid ""
"(Note that the :mod:`subprocess` module provides more powerful facilities"
" for spawning new processes and retrieving their results; using that "
"module is preferable to using these functions.  Check especially the :ref"
":`subprocess-replacements` section.)"
msgstr ""
"(:mod:`subprocess` 모듈은 새 프로세스를 생성하고 결과를 조회하는데, 더욱 강력한 기능을 제공합니다; 이 모듈을 "
"사용하는 것이 이 함수들을 사용하는 것보다 더 바람직합니다. 특히 :ref:`subprocess-replacements` 섹션을 "
"확인하십시오.)"

#: ../../library/os.rst:4805
msgid ""
"If *mode* is :const:`P_NOWAIT`, this function returns the process id of "
"the new process; if *mode* is :const:`P_WAIT`, returns the process's exit"
" code if it exits normally, or ``-signal``, where *signal* is the signal "
"that killed the process.  On Windows, the process id will actually be the"
" process handle, so can be used with the :func:`waitpid` function."
msgstr ""
"*mode* 가 :const:`P_NOWAIT`\\면, 이 함수는 새 프로세스의 프로세스 ID를 반환합니다; *mode*\\가 "
":const:`P_WAIT`\\면, 종료 코드(정상적으로 종료했을 때)나 ``-signal``\\(*signal*\\은 프로세스를 "
"죽인 시그널입니다)을 반환합니다. 윈도우에서, 프로세스 ID는 실제로 프로세스 핸들이므로, :func:`waitpid` 함수에 "
"사용할 수 있습니다."

#: ../../library/os.rst:4811
msgid ""
"Note on VxWorks, this function doesn't return ``-signal`` when the new "
"process is killed. Instead it raises OSError exception."
msgstr ""
"VxWorks에서, 이 함수는 새로운 프로세스가 죽을(kill) 때 ``-signal``\\을 반환하지 않습니다. 대신 "
"OSError 예외가 발생합니다."

#: ../../library/os.rst:4814
#, fuzzy
msgid ""
"The \"l\" and \"v\" variants of the :func:`spawn\\* <spawnl>` functions "
"differ in how command-line arguments are passed.  The \"l\" variants are "
"perhaps the easiest to work with if the number of parameters is fixed "
"when the code is written; the individual parameters simply become "
"additional parameters to the :func:`!spawnl\\*` functions.  The \"v\" "
"variants are good when the number of parameters is variable, with the "
"arguments being passed in a list or tuple as the *args* parameter.  In "
"either case, the arguments to the child process must start with the name "
"of the command being run."
msgstr ""
":func:`spawn\\* <spawnl>` 함수의 \"l\" 및 \"v\" 변형은 명령 줄 인자가 전달되는 방식이 다릅니다. "
"\"l\" 변형은 아마도 코드가 작성될 때 매개 변수의 수가 고정되어 있다면 가장 작업하기 쉬운 것입니다; 개별 매개 변수는 단순히"
" :func:`spawnl\\*` 함수에 대한 추가 매개 변수가 됩니다. \"v\" 변형은 매개 변수의 개수가 가변적일 때 좋으며,"
" 리스트나 튜플에 들어있는 인자가 *args* 매개 변수로 전달됩니다. 두 경우 모두, 자식 프로세스에 대한 인자는 반드시 실행 "
"중인 명령의 이름으로 시작해야 합니다."

#: ../../library/os.rst:4823
msgid ""
"The variants which include a second \"p\" near the end (:func:`spawnlp`, "
":func:`spawnlpe`, :func:`spawnvp`, and :func:`spawnvpe`) will use the "
":envvar:`PATH` environment variable to locate the program *file*.  When "
"the environment is being replaced (using one of the :func:`spawn\\*e "
"<spawnl>` variants, discussed in the next paragraph), the new environment"
" is used as the source of the :envvar:`PATH` variable.  The other "
"variants, :func:`spawnl`, :func:`spawnle`, :func:`spawnv`, and "
":func:`spawnve`, will not use the :envvar:`PATH` variable to locate the "
"executable; *path* must contain an appropriate absolute or relative path."
msgstr ""
"끝 근처에 두 번째 \"p\"가 포함된 변형(:func:`spawnlp`, :func:`spawnlpe`, "
":func:`spawnvp` 및 :func:`spawnvpe`)은 :envvar:`PATH` 환경 변수를 사용하여 프로그램 "
"*file* 을 찾습니다. 환경이 대체 될 때 (다음 단락에서 설명할 :func:`spawn\\*e <spawnl>` 변형 중 "
"하나를 사용하여), 새 환경이 :envvar:`PATH` 변수의 소스로 사용됩니다. 다른 변형 :func:`spawnl`, "
":func:`spawnle`, :func:`spawnv` 및 :func:`spawnve`\\는 :envvar:`PATH` 변수를 "
"사용하여 실행 파일을 찾지 않습니다; *path* 에는 반드시 적절한 절대 또는 상대 경로가 있어야 합니다."

#: ../../library/os.rst:4833
msgid ""
"For :func:`spawnle`, :func:`spawnlpe`, :func:`spawnve`, and "
":func:`spawnvpe` (note that these all end in \"e\"), the *env* parameter "
"must be a mapping which is used to define the environment variables for "
"the new process (they are used instead of the current process' "
"environment); the functions :func:`spawnl`, :func:`spawnlp`, "
":func:`spawnv`, and :func:`spawnvp` all cause the new process to inherit "
"the environment of the current process.  Note that keys and values in the"
" *env* dictionary must be strings; invalid keys or values will cause the "
"function to fail, with a return value of ``127``."
msgstr ""
":func:`spawnle`, :func:`spawnlpe`, :func:`spawnve` 및 :func:`spawnvpe`\\의 "
"경우 (모두 \"e\"로 끝납니다), *env* 매개 변수는 새 프로세스의 환경 변수를 정의하는 데 사용되는 매핑이어야 합니다 "
"(이것이 현재 프로세스의 환경 대신 사용됩니다); 함수 :func:`spawnl`, :func:`spawnlp`, "
":func:`spawnv` 및 :func:`spawnvp`\\는 모두 새 프로세스가 현재 프로세스의 환경을 상속하게 합니다. "
"*env* 딕셔너리의 키와 값은 반드시 문자열이어야 함에 주의하십시오; 잘못된 키나 값은 반환 값 ``127``\\로 함수가 "
"실패하게 합니다."

#: ../../library/os.rst:4842
msgid ""
"As an example, the following calls to :func:`spawnlp` and "
":func:`spawnvpe` are equivalent::"
msgstr "예를 들어, :func:`spawnlp` 및 :func:`spawnvpe`\\에 대한 다음 호출은 동등합니다::"

#: ../../library/os.rst:4845
msgid ""
"import os\n"
"os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n"
"\n"
"L = ['cp', 'index.html', '/dev/null']\n"
"os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)"
msgstr ""

#: ../../library/os.rst:4851
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.spawn`` with arguments "
"``mode``, ``path``, ``args``, ``env``."
msgstr ""
"``mode``, ``path``, ``args``, ``env``\\를 인자로 :ref:`감사 이벤트(auditing event)"
" <auditing>` ``os.spawn``\\을 발생시킵니다."

#: ../../library/os.rst:4855
#, fuzzy
msgid ""
":func:`spawnlp`, :func:`spawnlpe`, :func:`spawnvp` and :func:`spawnvpe` "
"are not available on Windows.  :func:`spawnle` and :func:`spawnve` are "
"not thread-safe on Windows; we advise you to use the :mod:`subprocess` "
"module instead."
msgstr ""
":ref:`가용성 <availability>`: 유닉스, 윈도우. :func:`spawnlp`, :func:`spawnlpe`, "
":func:`spawnvp`, :func:`spawnvpe`\\는 윈도우에서 사용할 수 없습니다. :func:`spawnle`\\와"
" :func:`spawnve`\\는 윈도우에서 스레드 안전하지 않습니다; 대신 :mod:`subprocess` 모듈을 사용하도록 "
"권고합니다."

#: ../../library/os.rst:4867
#, fuzzy
msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>`"
" family of functions.  If either of these values is given, the "
":func:`spawn\\* <spawnl>` functions will return as soon as the new "
"process has been created, with the process id as the return value."
msgstr ""
":func:`spawn\\* <spawnl>` 계열 함수의 *mode* 매개 변수에 사용할 수 있는 값. 이 값 중 하나가 "
"주어지면, :func:`spawn\\*` 함수는 새로운 프로세스가 생성되자마자 프로세스 ID를 반환 값으로 사용하여 반환됩니다."

#: ../../library/os.rst:4877
#, fuzzy
msgid ""
"Possible value for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  If this is given as *mode*, the :func:`spawn\\* "
"<spawnl>` functions will not return until the new process has run to "
"completion and will return the exit code of the process the run is "
"successful, or ``-signal`` if a signal kills the process."
msgstr ""
":func:`spawn\\* <spawnl>` 계열 함수의 *mode* 매개 변수에 사용할 수 있는 값. 이것이 *mode* 로 "
"주어지면, :func:`spawn\\*` 함수는 새 프로세스가 완료될 때까지 반환되지 않고, 실행이 성공한 프로세스의 종료 코드를 "
"반환하거나, 시그널이 프로세스를 죽이면 ``-signal``\\을 반환합니다."

#: ../../library/os.rst:4889
msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>`"
" family of functions.  These are less portable than those listed above. "
":const:`P_DETACH` is similar to :const:`P_NOWAIT`, but the new process is"
" detached from the console of the calling process. If :const:`P_OVERLAY` "
"is used, the current process will be replaced; the :func:`spawn\\* "
"<spawnl>` function will not return."
msgstr ""
":func:`spawn\\* <spawnl>` 계열 함수의 *mode* 매개 변수에 사용할 수 있는 값. 이들은 위에 나열된 것보다"
" 이식성이 낮습니다. :const:`P_DETACH`\\는 :const:`P_NOWAIT`\\와 비슷하지만, 새 프로세스는 호출 "
"프로세스의 콘솔에서 분리됩니다. :const:`P_OVERLAY`\\가 사용되면, 현재 프로세스가 대체됩니다; "
":func:`spawn\\* <spawnl>` 함수가 반환되지 않습니다."

#: ../../library/os.rst:4900
msgid "Start a file with its associated application."
msgstr "연관된 응용 프로그램으로 파일을 시작합니다."

#: ../../library/os.rst:4902
#, fuzzy
msgid ""
"When *operation* is not specified, this acts like double-clicking the "
"file in Windows Explorer, or giving the file name as an argument to the "
":program:`start` command from the interactive command shell: the file is "
"opened with whatever application (if any) its extension is associated."
msgstr ""
"*operation* 이 지정되지 않았거나 ``'open'``\\이면, 윈도우 탐색기에서 파일을 두 번 클릭하거나, 대화형 명령 "
"셸에서 :program:`start` 명령에 인자로 파일명을 지정하는 것과 같은 역할을 합니다: 파일의 확장자와 연관된 (있다면) "
"응용 프로그램으로 파일이 열립니다."

#: ../../library/os.rst:4907
#, fuzzy
msgid ""
"When another *operation* is given, it must be a \"command verb\" that "
"specifies what should be done with the file. Common verbs documented by "
"Microsoft are ``'open'``, ``'print'`` and  ``'edit'`` (to be used on "
"files) as well as ``'explore'`` and ``'find'`` (to be used on "
"directories)."
msgstr ""
"다른 *operation* 이 주어지면, 파일로 수행해야 할 작업을 지정하는 \"명령 동사\"여야 합니다. 마이크로소프트에서 문서화"
" 한 일반적인 동사는 ``'print'`` 와 ``'edit'`` (파일에 사용됨) 및 ``'explore'`` 와 "
"``'find'`` (디렉터리에 사용됨)입니다."

#: ../../library/os.rst:4912
msgid ""
"When launching an application, specify *arguments* to be passed as a "
"single string. This argument may have no effect when using this function "
"to launch a document."
msgstr ""

#: ../../library/os.rst:4916
msgid ""
"The default working directory is inherited, but may be overridden by the "
"*cwd* argument. This should be an absolute path. A relative *path* will "
"be resolved against this argument."
msgstr ""

#: ../../library/os.rst:4920
msgid ""
"Use *show_cmd* to override the default window style. Whether this has any"
" effect will depend on the application being launched. Values are "
"integers as supported by the Win32 :c:func:`!ShellExecute` function."
msgstr ""

#: ../../library/os.rst:4924
#, fuzzy
msgid ""
":func:`startfile` returns as soon as the associated application is "
"launched. There is no option to wait for the application to close, and no"
" way to retrieve the application's exit status.  The *path* parameter is "
"relative to the current directory or *cwd*.  If you want to use an "
"absolute path, make sure the first character is not a slash (``'/'``)  "
"Use :mod:`pathlib` or the :func:`os.path.normpath` function to ensure "
"that paths are properly encoded for Win32."
msgstr ""
":func:`startfile`\\는 연관된 응용 프로그램이 시작되자마자 반환합니다. 응용 프로그램이 닫히기를 기다리는 옵션과 응용"
" 프로그램의 종료 상태를 검색할 방법이 없습니다. *path* 매개 변수는 현재 디렉터리에 상대적입니다. 절대 경로를 사용하려면 첫"
" 번째 문자가 슬래시 (``'/'``)가 아닌지 확인하십시오; 하부 Win32 :c:func:`ShellExecute` 함수는 첫 "
"번째 문자가 슬래시면 작동하지 않습니다. :func:`os.path.normpath` 함수를 사용하여 경로가 Win32 용으로 "
"올바르게 인코딩되도록 하십시오."

#: ../../library/os.rst:4932
#, fuzzy
msgid ""
"To reduce interpreter startup overhead, the Win32 :c:func:`!ShellExecute`"
" function is not resolved until this function is first called.  If the "
"function cannot be resolved, :exc:`NotImplementedError` will be raised."
msgstr ""
"인터프리터 시작 오버헤드를 줄이기 위해, Win32 :c:func:`ShellExecute` 함수는 이 함수가 처음 호출될 때까지 "
"결정(resolve)되지 않습니다. 함수를 결정할 수 없으면 :exc:`NotImplementedError`\\가 발생합니다."

#: ../../library/os.rst:4936
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.startfile`` with "
"arguments ``path``, ``operation``."
msgstr ""
"``path``, ``operation``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.startfile``\\을 발생시킵니다."

#: ../../library/os.rst:4938
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.startfile/2`` with "
"arguments ``path``, ``operation``, ``arguments``, ``cwd``, ``show_cmd``."
msgstr ""
"``path``, ``operation``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.startfile``\\을 발생시킵니다."

#: ../../library/os.rst:4942
msgid ""
"Added the *arguments*, *cwd* and *show_cmd* arguments, and the "
"``os.startfile/2`` audit event."
msgstr ""

#: ../../library/os.rst:4949
#, fuzzy
msgid ""
"Execute the command (a string) in a subshell.  This is implemented by "
"calling the Standard C function :c:func:`system`, and has the same "
"limitations. Changes to :data:`sys.stdin`, etc. are not reflected in the "
"environment of the executed command. If *command* generates any output, "
"it will be sent to the interpreter standard output stream. The C standard"
" does not specify the meaning of the return value of the C function, so "
"the return value of the Python function is system-dependent."
msgstr ""
"서브 셸에서 명령(문자열)을 실행합니다. 이것은 표준 C 함수 :c:func:`system`\\를 호출하여 구현되며, 같은 제한이 "
"있습니다. :data:`sys.stdin` 등의 변경 사항은 실행된 명령의 환경에 반영되지 않습니다. *command*\\가 출력을"
" 생성하면, 인터프리터 표준 출력 스트림으로 전송됩니다."

#: ../../library/os.rst:4957
msgid ""
"On Unix, the return value is the exit status of the process encoded in "
"the format specified for :func:`wait`."
msgstr ""

#: ../../library/os.rst:4960
msgid ""
"On Windows, the return value is that returned by the system shell after "
"running *command*.  The shell is given by the Windows environment "
"variable :envvar:`COMSPEC`: it is usually :program:`cmd.exe`, which "
"returns the exit status of the command run; on systems using a non-native"
" shell, consult your shell documentation."
msgstr ""
"윈도우에서, 반환 값은 *command*\\를 실행한 후 시스템 셸에서 반환한 값입니다. 셸은 윈도우 환경 변수 "
":envvar:`COMSPEC`\\에 의해 제공됩니다: 보통 :program:`cmd.exe`\\인데, 명령 실행의 종료 상태를 "
"반환합니다; 기본이 아닌 셸을 사용하는 시스템에서는 셸 설명서를 참조하십시오."

#: ../../library/os.rst:4966
msgid ""
"The :mod:`subprocess` module provides more powerful facilities for "
"spawning new processes and retrieving their results; using that module is"
" preferable to using this function.  See the :ref:`subprocess-"
"replacements` section in the :mod:`subprocess` documentation for some "
"helpful recipes."
msgstr ""
":mod:`subprocess` 모듈은 새 프로세스를 생성하고 결과를 조회하는데, 더욱 강력한 기능을 제공합니다; 이 모듈을 "
"사용하는 것이 이 함수들을 사용하는 것보다 더 바람직합니다. :mod:`subprocess` 설명서의 :ref"
":`subprocess-replacements` 섹션에서 유용한 조리법을 확인하십시오."

#: ../../library/os.rst:4971
msgid ""
"On Unix, :func:`waitstatus_to_exitcode` can be used to convert the result"
" (exit status) into an exit code. On Windows, the result is directly the "
"exit code."
msgstr ""
"유닉스에서, :func:`waitstatus_to_exitcode`\\를 사용하여 결과(종료 상태)를 종료 코드로 변환할 수 "
"있습니다. 윈도우에서, 결과는 직접 종료 코드입니다."

#: ../../library/os.rst:4975
msgid ""
"Raises an :ref:`auditing event <auditing>` ``os.system`` with argument "
"``command``."
msgstr ""
"``command``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``os.system``\\을 발생시킵니다."

#: ../../library/os.rst:4982
msgid ""
"Returns the current global process times. The return value is an object "
"with five attributes:"
msgstr "현재 전역 프로세스 시간을 반환합니다. 반환 값은 5가지 어트리뷰트를 가진 객체입니다:"

#: ../../library/os.rst:4985
#, fuzzy
msgid ":attr:`!user` - user time"
msgstr ":attr:`user` - 사용자 시간"

#: ../../library/os.rst:4986
#, fuzzy
msgid ":attr:`!system` - system time"
msgstr ":attr:`system` - 시스템 시간"

#: ../../library/os.rst:4987
#, fuzzy
msgid ":attr:`!children_user` - user time of all child processes"
msgstr ":attr:`children_user` - 모든 자식 프로세스의 사용자 시간"

#: ../../library/os.rst:4988
#, fuzzy
msgid ":attr:`!children_system` - system time of all child processes"
msgstr ":attr:`children_system` - 모든 자식 프로세스의 시스템 시간"

#: ../../library/os.rst:4989
#, fuzzy
msgid ":attr:`!elapsed` - elapsed real time since a fixed point in the past"
msgstr ":attr:`elapsed` - 과거의 고정된 시점 이후 실제 경과 시간"

#: ../../library/os.rst:4991
#, fuzzy
msgid ""
"For backwards compatibility, this object also behaves like a five-tuple "
"containing :attr:`!user`, :attr:`!system`, :attr:`!children_user`, "
":attr:`!children_system`, and :attr:`!elapsed` in that order."
msgstr ""
"과거 호환성을 위해, 이 객체는 :attr:`user`, :attr:`system`, :attr:`children_user`, "
":attr:`children_system` 및 :attr:`elapsed`\\가 이 순서로 포함된 5-튜플처럼 작동합니다."

#: ../../library/os.rst:4995
#, fuzzy
msgid ""
"See the Unix manual page :manpage:`times(2)` and `times(3) "
"<https://man.freebsd.org/cgi/man.cgi?time(3)>`_ manual page on Unix or "
"`the GetProcessTimes MSDN "
"<https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-"
"processthreadsapi-getprocesstimes>`_ on Windows. On Windows, only "
":attr:`!user` and :attr:`!system` are known; the other attributes are "
"zero."
msgstr ""
"유닉스 매뉴얼 페이지 :manpage:`times(2)`\\와 유닉스에서는 :manpage:`times(3)` 매뉴얼 페이지 또는 "
"윈도우에서는 `the GetProcessTimes MSDN "
"<https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-"
"processthreadsapi-getprocesstimes>`_\\을 참조하십시오. 윈도우에서는, :attr:`user` 및 "
":attr:`system` 만 알려져 있습니다; 다른 어트리뷰트는 0입니다."

#: ../../library/os.rst:5009
msgid ""
"Wait for completion of a child process, and return a tuple containing its"
" pid and exit status indication: a 16-bit number, whose low byte is the "
"signal number that killed the process, and whose high byte is the exit "
"status (if the signal number is zero); the high bit of the low byte is "
"set if a core file was produced."
msgstr ""
"자식 프로세스가 완료될 때까지 기다렸다가, pid 및 종료 상태 표시를 포함하는 튜플을 반환합니다: 종료 상태 표시는 16비트 "
"숫자인데, 하위 바이트가 프로세스를 죽인 시그널 번호이고, 상위 바이트가 종료 상태(시그널 번호가 0이면)입니다; 코어 파일이 "
"생성되면 하위 바이트의 상위 비트가 설정됩니다."

#: ../../library/os.rst:5015
msgid ""
"If there are no children that could be waited for, "
":exc:`ChildProcessError` is raised."
msgstr ""

#: ../../library/os.rst:5018 ../../library/os.rst:5093
msgid ""
":func:`waitstatus_to_exitcode` can be used to convert the exit status "
"into an exit code."
msgstr ":func:`waitstatus_to_exitcode`\\를 사용하여 종료 상태를 종료 코드로 변환할 수 있습니다."

#: ../../library/os.rst:5025
#, fuzzy
msgid ""
"The other :func:`!wait*` functions documented below can be used to wait "
"for the completion of a specific child process and have more options. "
":func:`waitpid` is the only one also available on Windows."
msgstr ":func:`waitpid`\\는 특정 자식 프로세스가 완료될 때까지 기다리는데 사용될 수 있으며 더 많은 옵션이 있습니다."

#: ../../library/os.rst:5032
msgid "Wait for the completion of a child process."
msgstr ""

#: ../../library/os.rst:5034
msgid ""
"*idtype* can be :data:`P_PID`, :data:`P_PGID`, :data:`P_ALL`, or (on "
"Linux) :data:`P_PIDFD`. The interpretation of *id* depends on it; see "
"their individual descriptions."
msgstr ""

#: ../../library/os.rst:5037
msgid ""
"*options* is an OR combination of flags.  At least one of "
":data:`WEXITED`, :data:`WSTOPPED` or :data:`WCONTINUED` is required; "
":data:`WNOHANG` and :data:`WNOWAIT` are additional optional flags."
msgstr ""

#: ../../library/os.rst:5041
msgid ""
"The return value is an object representing the data contained in the "
":c:type:`siginfo_t` structure with the following attributes:"
msgstr ""

#: ../../library/os.rst:5044
msgid ":attr:`!si_pid` (process ID)"
msgstr ""

#: ../../library/os.rst:5045
msgid ":attr:`!si_uid` (real user ID of the child)"
msgstr ""

#: ../../library/os.rst:5046
msgid ":attr:`!si_signo` (always :const:`~signal.SIGCHLD`)"
msgstr ""

#: ../../library/os.rst:5047
msgid ""
":attr:`!si_status` (the exit status or signal number, depending on "
":attr:`!si_code`)"
msgstr ""

#: ../../library/os.rst:5048
msgid ":attr:`!si_code` (see :data:`CLD_EXITED` for possible values)"
msgstr ""

#: ../../library/os.rst:5050
msgid ""
"If :data:`WNOHANG` is specified and there are no matching children in the"
" requested state, ``None`` is returned. Otherwise, if there are no "
"matching children that could be waited for, :exc:`ChildProcessError` is "
"raised."
msgstr ""

#: ../../library/os.rst:5059
#, fuzzy
msgid "This function is now available on macOS as well."
msgstr "이 함수는 MacOS에서는 사용할 수 없습니다."

#: ../../library/os.rst:5065
msgid "The details of this function differ on Unix and Windows."
msgstr "이 함수의 세부 사항은 유닉스 및 윈도우에서 다릅니다."

#: ../../library/os.rst:5067
msgid ""
"On Unix: Wait for completion of a child process given by process id "
"*pid*, and return a tuple containing its process id and exit status "
"indication (encoded as for :func:`wait`).  The semantics of the call are "
"affected by the value of the integer *options*, which should be ``0`` for"
" normal operation."
msgstr ""
"유닉스에서: 프로세스 ID *pid*\\에 의해 주어진 자식 프로세스의 완료를 기다리고, 프로세스 ID와 종료 상태 "
"표시(:func:`wait`\\처럼 인코딩됨)를 포함하는 튜플을 반환합니다. 호출의 의미는 정수 *options* 의 값에 영향을 "
"받는데, 일반 작업의 경우 ``0`` 이어야 합니다."

#: ../../library/os.rst:5072
msgid ""
"If *pid* is greater than ``0``, :func:`waitpid` requests status "
"information for that specific process.  If *pid* is ``0``, the request is"
" for the status of any child in the process group of the current process."
"  If *pid* is ``-1``, the request pertains to any child of the current "
"process.  If *pid* is less than ``-1``, status is requested for any "
"process in the process group ``-pid`` (the absolute value of *pid*)."
msgstr ""
"*pid* 가 ``0``\\보다 크면, :func:`waitpid`\\는 해당 프로세스에 대한 상태 정보를 요청합니다. *pid* "
"가 ``0``\\이면, 현재 프로세스의 프로세스 그룹에 있는 모든 자식의 상태를 요청합니다. *pid* 가 ``-1``\\이면, "
"현재 프로세스의 모든 자식의 상태를 요청합니다. *pid* 가 ``-1``\\보다 작으면, 프로세스 그룹 "
"``-pid``\\(*pid* 의 절댓값)에 있는 모든 프로세스의 상태를 요청합니다."

#: ../../library/os.rst:5079
msgid ""
"*options* is an OR combination of flags.  If it contains :data:`WNOHANG` "
"and there are no matching children in the requested state, ``(0, 0)`` is "
"returned.  Otherwise, if there are no matching children that could be "
"waited for, :exc:`ChildProcessError` is raised.  Other options that can "
"be used are :data:`WUNTRACED` and :data:`WCONTINUED`."
msgstr ""

#: ../../library/os.rst:5085
msgid ""
"On Windows: Wait for completion of a process given by process handle "
"*pid*, and return a tuple containing *pid*, and its exit status shifted "
"left by 8 bits (shifting makes cross-platform use of the function "
"easier). A *pid* less than or equal to ``0`` has no special meaning on "
"Windows, and raises an exception. The value of integer *options* has no "
"effect. *pid* can refer to any process whose id is known, not necessarily"
" a child process. The :func:`spawn\\* <spawnl>` functions called with "
":const:`P_NOWAIT` return suitable process handles."
msgstr ""
"윈도우에서: 프로세스 핸들 *pid*\\로 지정된 프로세스가 완료될 때까지 기다리고, *pid*\\와 종료 상태를 8비트 왼쪽으로 "
"시프트 한 값을 포함하는 튜플을 반환합니다 (시프팅이 함수를 더 이식성 있게 만듭니다). ``0``\\보다 작거나 같은 *pid* "
"는 윈도우에서 특별한 의미가 없고 예외가 발생합니다. 정수 *options* 의 값은 아무 효과가 없습니다. *pid* 는 id가 "
"알려진 모든 프로세스를 가리킬 수 있습니다, 반드시 자식 프로세스일 필요는 없습니다. :const:`P_NOWAIT`\\로 호출된 "
":func:`spawn\\* <spawnl>` 함수는 적절한 프로세스 핸들을 반환합니다."

#: ../../library/os.rst:5106
#, fuzzy
msgid ""
"Similar to :func:`waitpid`, except no process id argument is given and a "
"3-element tuple containing the child's process id, exit status "
"indication, and resource usage information is returned.  Refer to "
":func:`resource.getrusage` for details on resource usage information.  "
"The *options* argument is the same as that provided to :func:`waitpid` "
"and :func:`wait4`."
msgstr ""
":func:`waitpid`\\와 비슷하지만, 프로세스 ID 인자가 제공되지 않고 자식 프로세스 ID, 종료 상태 표시 및 자원 "
"사용 정보가 포함된 3-요소 튜플이 반환된다는 점이 다릅니다. 자원 사용 정보에 대한 자세한 내용은 "
":mod:`resource`.\\ :func:`~resource.getrusage`\\를 참조하십시오. 옵션 인자는 "
":func:`waitpid` 및 :func:`wait4`\\에 제공된 인자와 같습니다."

#: ../../library/os.rst:5113 ../../library/os.rst:5127
msgid ""
":func:`waitstatus_to_exitcode` can be used to convert the exit status "
"into an exitcode."
msgstr ":func:`waitstatus_to_exitcode`\\를 사용하여 종료 상태를 종료 코드로 변환할 수 있습니다."

#: ../../library/os.rst:5121
#, fuzzy
msgid ""
"Similar to :func:`waitpid`, except a 3-element tuple, containing the "
"child's process id, exit status indication, and resource usage "
"information is returned.  Refer to :func:`resource.getrusage` for details"
" on resource usage information.  The arguments to :func:`wait4` are the "
"same as those provided to :func:`waitpid`."
msgstr ""
":func:`waitpid`\\와 비슷하지만, 자식 프로세스 ID, 종료 상태 표시 및 자원 사용 정보가 포함된 3-요소 튜플이 "
"반환된다는 점이 다릅니다. 자원 사용 정보에 대한 자세한 내용은 :mod:`resource`.\\ "
":func:`~resource.getrusage`\\를 참조하십시오. :func:`wait4`\\의 인자는 "
":func:`waitpid`\\와 같습니다."

#: ../../library/os.rst:5138
#, fuzzy
msgid ""
"These are the possible values for *idtype* in :func:`waitid`. They affect"
" how *id* is interpreted:"
msgstr "이것들은 :func:`waitid`\\의 *idtype* 에 사용 가능한 값입니다. *id* 가 어떻게 해석되는지에 영향을 미칩니다."

#: ../../library/os.rst:5141
msgid ":data:`!P_PID` - wait for the child whose PID is *id*."
msgstr ""

#: ../../library/os.rst:5142
msgid ":data:`!P_PGID` - wait for any child whose progress group ID is *id*."
msgstr ""

#: ../../library/os.rst:5143
msgid ":data:`!P_ALL` - wait for any child; *id* is ignored."
msgstr ""

#: ../../library/os.rst:5144
msgid ""
":data:`!P_PIDFD` - wait for the child identified by the file descriptor "
"*id* (a process file descriptor created with :func:`pidfd_open`)."
msgstr ""

#: ../../library/os.rst:5149
msgid ":data:`!P_PIDFD` is only available on Linux >= 5.4."
msgstr ""

#: ../../library/os.rst:5152
#, fuzzy
msgid "The :data:`!P_PIDFD` constant."
msgstr ":data:`O_CLOEXEC` 상수를 추가합니다."

#: ../../library/os.rst:5158
#, fuzzy
msgid ""
"This *options* flag for :func:`waitpid`, :func:`wait3`, :func:`wait4`, "
"and :func:`waitid` causes child processes to be reported if they have "
"been continued from a job control stop since they were last reported."
msgstr "이 옵션은 자식 프로세스의 상태가 마지막으로 보고된 이후에 작업 제어 중지에서 재개한 경우 보고되도록 합니다."

#: ../../library/os.rst:5167
msgid ""
"This *options* flag for :func:`waitid` causes child processes that have "
"terminated to be reported."
msgstr ""

#: ../../library/os.rst:5170
msgid ""
"The other ``wait*`` functions always report children that have "
"terminated, so this option is not available for them."
msgstr ""

#: ../../library/os.rst:5180
msgid ""
"This *options* flag for :func:`waitid` causes child processes that have "
"been stopped by the delivery of a signal to be reported."
msgstr ""

#: ../../library/os.rst:5183 ../../library/os.rst:5215
#, fuzzy
msgid "This option is not available for the other ``wait*`` functions."
msgstr "이 함수는 MacOS에서는 사용할 수 없습니다."

#: ../../library/os.rst:5192
#, fuzzy
msgid ""
"This *options* flag for :func:`waitpid`, :func:`wait3`, and :func:`wait4`"
" causes child processes to also be reported if they have been stopped but"
" their current state has not been reported since they were stopped."
msgstr "이 옵션은 자식 프로세스가 중지되었지만, 현재 상태가 중지된 이후 보고되지 않았으면 보고되게 합니다."

#: ../../library/os.rst:5196
#, fuzzy
msgid "This option is not available for :func:`waitid`."
msgstr "이 함수는 MacOS에서는 사용할 수 없습니다."

#: ../../library/os.rst:5203
msgid ""
"This *options* flag causes :func:`waitpid`, :func:`wait3`, :func:`wait4`,"
" and :func:`waitid` to return right away if no child process status is "
"available immediately."
msgstr ""

#: ../../library/os.rst:5212
msgid ""
"This *options* flag causes :func:`waitid` to leave the child in a "
"waitable state, so that a later :func:`!wait*` call can be used to "
"retrieve the child status information again."
msgstr ""

#: ../../library/os.rst:5227
#, fuzzy
msgid ""
"These are the possible values for :attr:`!si_code` in the result returned"
" by :func:`waitid`."
msgstr "이것은 :func:`waitid`\\에 의해 반환된 결과에서 :attr:`si_code`\\의 가능한 값입니다."

#: ../../library/os.rst:5234
msgid "Added :data:`CLD_KILLED` and :data:`CLD_STOPPED` values."
msgstr ":data:`CLD_KILLED`\\와 :data:`CLD_STOPPED` 값을 추가했습니다."

#: ../../library/os.rst:5240
msgid "Convert a wait status to an exit code."
msgstr "대기 상태(wait status)를 종료 코드로 변환합니다."

#: ../../library/os.rst:5242
msgid "On Unix:"
msgstr "유닉스에서:"

#: ../../library/os.rst:5244
msgid ""
"If the process exited normally (if ``WIFEXITED(status)`` is true), return"
" the process exit status (return ``WEXITSTATUS(status)``): result greater"
" than or equal to 0."
msgstr ""
"프로세스가 정상적으로 종료되면 (``WIFEXITED(status)``\\가 참이면), 프로세스 종료 상태를 반환합니다 "
"(``WEXITSTATUS(status)``\\를 반환합니다): 결과는 0보다 크거나 같습니다."

#: ../../library/os.rst:5247
msgid ""
"If the process was terminated by a signal (if ``WIFSIGNALED(status)`` is "
"true), return ``-signum`` where *signum* is the number of the signal that"
" caused the process to terminate (return ``-WTERMSIG(status)``): result "
"less than 0."
msgstr ""
"프로세스가 시그널에 의해 종료되면 (``WIFSIGNALED(status)``\\가 참이면), ``-signum``\\을 "
"반환합니다, 여기서 *signum*\\은 프로세스를 종료시킨 시그널 번호입니다 (``-WTERMSIG(status)``\\를 "
"반환합니다): 결과는 0보다 작습니다."

#: ../../library/os.rst:5251
msgid "Otherwise, raise a :exc:`ValueError`."
msgstr "그렇지 않으면, :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/os.rst:5253
msgid "On Windows, return *status* shifted right by 8 bits."
msgstr "윈도우에서, 8비트만큼 오른쪽으로 시프트된 *status*\\를 반환합니다."

#: ../../library/os.rst:5255
msgid ""
"On Unix, if the process is being traced or if :func:`waitpid` was called "
"with :data:`WUNTRACED` option, the caller must first check if "
"``WIFSTOPPED(status)`` is true. This function must not be called if "
"``WIFSTOPPED(status)`` is true."
msgstr ""
"유닉스에서, 프로세스가 추적되고 있거나 :func:`waitpid`\\가 :data:`WUNTRACED` 옵션으로 호출되었으면, "
"호출자는 먼저 ``WIFSTOPPED(status)``\\가 참인지 확인해야 합니다. ``WIFSTOPPED(status)``\\가"
" 참이면 이 함수를 호출하면 안 됩니다."

#: ../../library/os.rst:5262
msgid ""
":func:`WIFEXITED`, :func:`WEXITSTATUS`, :func:`WIFSIGNALED`, "
":func:`WTERMSIG`, :func:`WIFSTOPPED`, :func:`WSTOPSIG` functions."
msgstr ""
":func:`WIFEXITED`, :func:`WEXITSTATUS`, :func:`WIFSIGNALED`, "
":func:`WTERMSIG`, :func:`WIFSTOPPED`, :func:`WSTOPSIG` 함수."

#: ../../library/os.rst:5270
msgid ""
"The following functions take a process status code as returned by "
":func:`system`, :func:`wait`, or :func:`waitpid` as a parameter.  They "
"may be used to determine the disposition of a process."
msgstr ""
"다음 함수들은 :func:`system`, :func:`wait` 또는 :func:`waitpid`\\에 의해 반환된 프로세스 상태"
" 코드를 매개 변수로 받아들입니다. 이것들은 프로세스의 처리를 결정하는 데 사용될 수 있습니다."

#: ../../library/os.rst:5276
msgid ""
"Return ``True`` if a core dump was generated for the process, otherwise "
"return ``False``."
msgstr "프로세스에 대해 코어 덤프가 생성되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:5279 ../../library/os.rst:5345
msgid "This function should be employed only if :func:`WIFSIGNALED` is true."
msgstr "이 함수는 :func:`WIFSIGNALED`\\가 참일 때만 사용해야 합니다."

#: ../../library/os.rst:5286
#, fuzzy
msgid ""
"Return ``True`` if a stopped child has been resumed by delivery of "
":const:`~signal.SIGCONT` (if the process has been continued from a job "
"control stop), otherwise return ``False``."
msgstr ""
"중지된 자식이 :data:`~signal.SIGCONT` 의 전달로 인해 재개했으면 (작업 제어 중지에서 프로세스가 재개했으면) "
"``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:5290
msgid "See :data:`WCONTINUED` option."
msgstr ":data:`WCONTINUED` 옵션을 참조하십시오."

#: ../../library/os.rst:5297
msgid ""
"Return ``True`` if the process was stopped by delivery of a signal, "
"otherwise return ``False``."
msgstr "시그널의 전달로 인해 프로세스가 중지되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:5300
msgid ""
":func:`WIFSTOPPED` only returns ``True`` if the :func:`waitpid` call was "
"done using :data:`WUNTRACED` option or when the process is being traced "
"(see :manpage:`ptrace(2)`)."
msgstr ""
":func:`WIFSTOPPED`\\는 :data:`WUNTRACED` 옵션을 사용하여 :func:`waitpid`\\을 호출했거나"
" 프로세스가 추적되고 있을 때만 ``True``\\를 반환합니다 (:manpage:`ptrace(2)`\\를 참조하십시오)."

#: ../../library/os.rst:5308
msgid ""
"Return ``True`` if the process was terminated by a signal, otherwise "
"return ``False``."
msgstr "시그널로 인해 프로세스가 종료되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:5316
msgid ""
"Return ``True`` if the process exited terminated normally, that is, by "
"calling ``exit()`` or ``_exit()``, or by returning from ``main()``; "
"otherwise return ``False``."
msgstr ""
"프로세스가 정상 종료했으면 ``True``\\를 반환합니다, 즉 ``exit()``\\나 ``_exit()``\\를 호출했거나, "
"``main()``\\에서 반환하여; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/os.rst:5325
msgid "Return the process exit status."
msgstr "프로세스 종료 상태를 반환합니다."

#: ../../library/os.rst:5327
msgid "This function should be employed only if :func:`WIFEXITED` is true."
msgstr "이 함수는 :func:`WIFEXITED`\\가 참일 때만 사용해야 합니다."

#: ../../library/os.rst:5334
msgid "Return the signal which caused the process to stop."
msgstr "프로세스를 멈추게 한 시그널을 반환합니다."

#: ../../library/os.rst:5336
msgid "This function should be employed only if :func:`WIFSTOPPED` is true."
msgstr "이 함수는 :func:`WIFSTOPPED`\\가 참일 때만 사용해야 합니다."

#: ../../library/os.rst:5343
msgid "Return the number of the signal that caused the process to terminate."
msgstr "프로세스를 종료시킨 시그널의 번호를 반환합니다."

#: ../../library/os.rst:5351
msgid "Interface to the scheduler"
msgstr "스케줄러에 대한 인터페이스"

#: ../../library/os.rst:5353
msgid ""
"These functions control how a process is allocated CPU time by the "
"operating system. They are only available on some Unix platforms. For "
"more detailed information, consult your Unix manpages."
msgstr ""
"이 함수들은 운영 체제가 프로세스에 CPU 시간을 할당하는 방법을 제어합니다. 일부 유닉스 플랫폼에서만 사용할 수 있습니다. 자세한"
" 내용은 유닉스 매뉴얼 페이지를 참조하십시오."

#: ../../library/os.rst:5359
msgid ""
"The following scheduling policies are exposed if they are supported by "
"the operating system."
msgstr "다음 스케줄 정책은 운영 체제에서 지원하는 경우 공개됩니다."

#: ../../library/os.rst:5366
msgid "The default scheduling policy."
msgstr "기본 스케줄 정책."

#: ../../library/os.rst:5370
msgid ""
"Scheduling policy for CPU-intensive processes that tries to preserve "
"interactivity on the rest of the computer."
msgstr "컴퓨터의 나머지 부분에서 반응성을 유지하려고 하는 CPU 집약적인 프로세스를 위한 스케줄 정책."

#: ../../library/os.rst:5375
msgid "Scheduling policy for extremely low priority background tasks."
msgstr "매우 낮은 우선순위의 배경 작업에 대한 스케줄 정책."

#: ../../library/os.rst:5379
msgid "Scheduling policy for sporadic server programs."
msgstr "간헐적인 서버 프로그램을 위한 스케줄 정책."

#: ../../library/os.rst:5383
msgid "A First In First Out scheduling policy."
msgstr "선입 선출 (First In First Out) 스케줄 정책."

#: ../../library/os.rst:5387
msgid "A round-robin scheduling policy."
msgstr "라운드 로빈 스케줄 정책."

#: ../../library/os.rst:5391
msgid ""
"This flag can be OR'ed with any other scheduling policy. When a process "
"with this flag set forks, its child's scheduling policy and priority are "
"reset to the default."
msgstr ""
"이 플래그는 다른 스케줄 정책과 OR 될 수 있습니다. 이 플래그가 설정되어있는 프로세스가 포크 할 때, 자식의 스케줄링 정책 및 "
"우선순위가 기본값으로 재설정됩니다."

#: ../../library/os.rst:5398
msgid ""
"This class represents tunable scheduling parameters used in "
":func:`sched_setparam`, :func:`sched_setscheduler`, and "
":func:`sched_getparam`. It is immutable."
msgstr ""
"이 클래스는 :func:`sched_setparam`, :func:`sched_setscheduler`, 및 "
":func:`sched_getparam`\\에서 사용되는 튜닝 가능한 스케줄 파라미터를 나타냅니다. 불변입니다."

#: ../../library/os.rst:5402
msgid "At the moment, there is only one possible parameter:"
msgstr "현재, 가능한 매개 변수는 하나뿐입니다:"

#: ../../library/os.rst:5406
msgid "The scheduling priority for a scheduling policy."
msgstr "스케줄 정책의 스케줄 우선순위."

#: ../../library/os.rst:5411
msgid ""
"Get the minimum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr "*policy*\\의 최소 우선순위 값을 가져옵니다. *policy* 는 위의 스케줄 정책 상수 중 하나입니다."

#: ../../library/os.rst:5417
msgid ""
"Get the maximum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr "*policy*\\의 최대 우선순위 값을 가져옵니다. *policy* 는 위의 스케줄 정책 상수 중 하나입니다."

#: ../../library/os.rst:5423
msgid ""
"Set the scheduling policy for the process with PID *pid*. A *pid* of 0 "
"means the calling process. *policy* is one of the scheduling policy "
"constants above. *param* is a :class:`sched_param` instance."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 정책을 설정합니다. *pid* 가 0이면, 호출하는 프로세스를 의미합니다. "
"*policy* 는 위의 스케줄 정책 상수 중 하나입니다. *param* 은 :class:`sched_param` 인스턴스입니다."

#: ../../library/os.rst:5430
msgid ""
"Return the scheduling policy for the process with PID *pid*. A *pid* of 0"
" means the calling process. The result is one of the scheduling policy "
"constants above."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 정책을 반환합니다. *pid* 가 0이면, 호출하는 프로세스를 의미합니다. 결과는 위의 "
"스케줄 정책 상수 중 하나입니다."

#: ../../library/os.rst:5437
#, fuzzy
msgid ""
"Set the scheduling parameters for the process with PID *pid*. A *pid* of "
"0 means the calling process. *param* is a :class:`sched_param` instance."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 매개 변수를 설정합니다. *pid* 가 0이면 호출하는 프로세스를 의미합니다. "
"*param* 은 :class:`sched_param` 인스턴스입니다."

#: ../../library/os.rst:5443
msgid ""
"Return the scheduling parameters as a :class:`sched_param` instance for "
"the process with PID *pid*. A *pid* of 0 means the calling process."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 매개 변수를 :class:`sched_param` 인스턴스로 반환합니다. *pid* 가 "
"0이면 호출하는 프로세스를 의미합니다."

#: ../../library/os.rst:5449
msgid ""
"Return the round-robin quantum in seconds for the process with PID *pid*."
" A *pid* of 0 means the calling process."
msgstr "PID가 *pid*\\인 프로세스의 라운드 로빈 퀀텀을 초 단위로 반환합니다. *pid* 가 0이면 호출하는 프로세스를 의미합니다."

#: ../../library/os.rst:5455
msgid "Voluntarily relinquish the CPU. See :manpage:`sched_yield(2)` for details."
msgstr ""

#: ../../library/os.rst:5460
msgid ""
"Restrict the process with PID *pid* (or the current process if zero) to a"
" set of CPUs.  *mask* is an iterable of integers representing the set of "
"CPUs to which the process should be restricted."
msgstr ""
"PID가 *pid*\\인 프로세스(또는 0이면 현재 프로세스)를 CPU 집합으로 제한합니다. *mask* 는 프로세스가 제한되어야 "
"하는 CPU 집합을 나타내는 정수의 이터러블입니다."

#: ../../library/os.rst:5467
#, fuzzy
msgid "Return the set of CPUs the process with PID *pid* is restricted to."
msgstr "PID가 *pid*\\인 프로세스(또는 0이면 현재 프로세스)가 제한되는 CPU 집합을 반환합니다."

#: ../../library/os.rst:5469
#, fuzzy
msgid ""
"If *pid* is zero, return the set of CPUs the calling thread of the "
"current process is restricted to."
msgstr "PID가 *pid*\\인 프로세스(또는 0이면 현재 프로세스)가 제한되는 CPU 집합을 반환합니다."

#: ../../library/os.rst:5472
#, fuzzy
msgid "See also the :func:`process_cpu_count` function."
msgstr ":func:`.stat` 함수."

#: ../../library/os.rst:5478
msgid "Miscellaneous System Information"
msgstr "기타 시스템 정보"

#: ../../library/os.rst:5483
msgid ""
"Return string-valued system configuration values. *name* specifies the "
"configuration value to retrieve; it may be a string which is the name of "
"a defined system value; these names are specified in a number of "
"standards (POSIX, Unix 95, Unix 98, and others).  Some platforms define "
"additional names as well. The names known to the host operating system "
"are given as the keys of the ``confstr_names`` dictionary.  For "
"configuration variables not included in that mapping, passing an integer "
"for *name* is also accepted."
msgstr ""
"문자열 값 시스템 구성 값을 반환합니다. *name* 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 문자열일 수 "
"있습니다; 이 이름은 여러 표준(POSIX, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 추가 이름도 "
"정의합니다. 호스트 운영 체제에 알려진 이름은 ``confstr_names`` 딕셔너리의 키로 제공됩니다. 해당 매핑에 포함되지 "
"않은 구성 변수를 위해, *name*\\에 정수를 전달하는 것도 허용됩니다."

#: ../../library/os.rst:5491
msgid ""
"If the configuration value specified by *name* isn't defined, ``None`` is"
" returned."
msgstr "*name* 으로 지정된 구성 값이 정의되어 있지 않으면, ``None``\\이 반환됩니다."

#: ../../library/os.rst:5494
msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If "
"a specific value for *name* is not supported by the host system, even if "
"it is included in ``confstr_names``, an :exc:`OSError` is raised with "
":const:`errno.EINVAL` for the error number."
msgstr ""
"*name* 이 문자열이고 알 수 없으면, :exc:`ValueError`\\가 발생합니다. *name*\\에 대한 특정 값이 "
"호스트 시스템에서 지원되지 않으면, ``confstr_names``\\에 포함되어 있어도, 에러 번호 "
":const:`errno.EINVAL`\\로 :exc:`OSError`\\가 발생합니다."

#: ../../library/os.rst:5504
msgid ""
"Dictionary mapping names accepted by :func:`confstr` to the integer "
"values defined for those names by the host operating system. This can be "
"used to determine the set of names known to the system."
msgstr ""
":func:`confstr`\\에서 허용하는 이름을 호스트 운영 체제가 해당 이름에 대해 정의한 정숫값으로 매핑하는 딕셔너리입니다."
" 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다."

#: ../../library/os.rst:5513
#, fuzzy
msgid ""
"Return the number of logical CPUs in the **system**. Returns ``None`` if "
"undetermined."
msgstr "시스템의 CPU 수를 반환합니다. 파악할 수 없으면, ``None``\\을 반환합니다."

#: ../../library/os.rst:5516
msgid ""
"The :func:`process_cpu_count` function can be used to get the number of "
"logical CPUs usable by the calling thread of the **current process**."
msgstr ""

#: ../../library/os.rst:5521
msgid ""
"If :option:`-X cpu_count <-X>` is given or :envvar:`PYTHON_CPU_COUNT` is "
"set, :func:`cpu_count` returns the overridden value *n*."
msgstr ""

#: ../../library/os.rst:5528
msgid ""
"Return the number of processes in the system run queue averaged over the "
"last 1, 5, and 15 minutes or raises :exc:`OSError` if the load average "
"was unobtainable."
msgstr ""
"마지막 1, 5, 15분에 걸쳐 평균한 시스템 실행 대기열의 프로세스 수를 반환하거나, 로드 평균을 얻을 수 없으면, "
":exc:`OSError`\\를 발생시킵니다."

#: ../../library/os.rst:5537
msgid ""
"Get the number of logical CPUs usable by the calling thread of the "
"**current process**. Returns ``None`` if undetermined. It can be less "
"than :func:`cpu_count` depending on the CPU affinity."
msgstr ""

#: ../../library/os.rst:5541
msgid ""
"The :func:`cpu_count` function can be used to get the number of logical "
"CPUs in the **system**."
msgstr ""

#: ../../library/os.rst:5544
msgid ""
"If :option:`-X cpu_count <-X>` is given or :envvar:`PYTHON_CPU_COUNT` is "
"set, :func:`process_cpu_count` returns the overridden value *n*."
msgstr ""

#: ../../library/os.rst:5547
#, fuzzy
msgid "See also the :func:`sched_getaffinity` function."
msgstr ":func:`.stat` 함수."

#: ../../library/os.rst:5554
msgid ""
"Return integer-valued system configuration values. If the configuration "
"value specified by *name* isn't defined, ``-1`` is returned.  The "
"comments regarding the *name* parameter for :func:`confstr` apply here as"
" well; the dictionary that provides information on the known names is "
"given by ``sysconf_names``."
msgstr ""
"정숫값 시스템 구성 값을 반환합니다. *name* 으로 지정된 구성 값이 정의되어 있지 않으면, ``-1``\\이 반환됩니다. "
":func:`confstr`\\의 *name* 매개 변수에 관한 주석은 여기에도 적용됩니다; 알려진 이름에 대한 정보를 제공하는 "
"딕셔너리는 ``sysconf_names``\\에 의해 제공됩니다."

#: ../../library/os.rst:5564
msgid ""
"Dictionary mapping names accepted by :func:`sysconf` to the integer "
"values defined for those names by the host operating system. This can be "
"used to determine the set of names known to the system."
msgstr ""
":func:`sysconf`\\에서 허용하는 이름을 호스트 운영 체제가 해당 이름에 대해 정의한 정숫값으로 매핑하는 딕셔너리입니다."
" 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다."

#: ../../library/os.rst:5570
msgid "Add ``'SC_MINSIGSTKSZ'`` name."
msgstr ""

#: ../../library/os.rst:5573
msgid ""
"The following data values are used to support path manipulation "
"operations.  These are defined for all platforms."
msgstr "다음 데이터값들은 경로 조작 연산을 지원하는 데 사용됩니다. 이는 모든 플랫폼에서 정의됩니다."

#: ../../library/os.rst:5576
msgid ""
"Higher-level operations on pathnames are defined in the :mod:`os.path` "
"module."
msgstr "경로명에 대한 고수준 연산은 :mod:`os.path` 모듈에서 정의됩니다."

#: ../../library/os.rst:5582
msgid ""
"The constant string used by the operating system to refer to the current "
"directory. This is ``'.'`` for Windows and POSIX. Also available via "
":mod:`os.path`."
msgstr ""
"현재 디렉터리를 가리키기 위해 운영 체제에서 사용하는 상수 문자열. 이것은 윈도우 및 POSIX의 경우 ``'.'``\\입니다. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5590
msgid ""
"The constant string used by the operating system to refer to the parent "
"directory. This is ``'..'`` for Windows and POSIX. Also available via "
":mod:`os.path`."
msgstr ""
"부모 디렉터리를 가리키기 위해 운영 체제에서 사용하는 상수 문자열입니다. 이것은 윈도우 및 POSIX의 경우 "
"``'..'``\\입니다. :mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5599
msgid ""
"The character used by the operating system to separate pathname "
"components. This is ``'/'`` for POSIX and ``'\\\\'`` for Windows.  Note "
"that knowing this is not sufficient to be able to parse or concatenate "
"pathnames --- use :func:`os.path.split` and :func:`os.path.join` --- but "
"it is occasionally useful. Also available via :mod:`os.path`."
msgstr ""
"경로명 구성 요소를 분리하기 위해 운영 체제에서 사용하는 문자. 이것은 POSIX의 경우 ``'/'``\\이고, 윈도우의 경우 "
"``'\\\\'``\\입니다. 이것을 아는 것만으로는 경로명을 구문 분석하거나 이어붙일 수는 없습니다만 --- "
":func:`os.path.split`\\와 :func:`os.path.join`\\를 사용하세요 --- 가끔 유용합니다. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5609
msgid ""
"An alternative character used by the operating system to separate "
"pathname components, or ``None`` if only one separator character exists."
"  This is set to ``'/'`` on Windows systems where ``sep`` is a backslash."
" Also available via :mod:`os.path`."
msgstr ""
"경로명 구성 요소를 분리하기 위해 운영 체제에서 사용하는 대체 문자이거나, 단 하나의 구분 문자만 있는 경우 "
"``None``\\입니다. ``sep``\\가 백 슬래시인 윈도우 시스템에서는 ``'/'``\\로 설정됩니다. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5618
msgid ""
"The character which separates the base filename from the extension; for "
"example, the ``'.'`` in :file:`os.py`. Also available via :mod:`os.path`."
msgstr ""
"기본 파일명과 확장자를 구분하는 문자; 예를 들어, :file:`os.py`\\에서 ``'.'``. :mod:`os.path`\\를"
" 통해서도 제공됩니다."

#: ../../library/os.rst:5626
msgid ""
"The character conventionally used by the operating system to separate "
"search path components (as in :envvar:`PATH`), such as ``':'`` for POSIX "
"or ``';'`` for Windows. Also available via :mod:`os.path`."
msgstr ""
"검색 경로 구성 요소(:envvar:`PATH`\\에서와 같이)를 분리하기 위해 운영 체제에서 관습적으로 사용하는 문자, 가령 "
"POSIX의 ``':'`` 또는 윈도우의 ``';'``. :mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5633
msgid ""
"The default search path used by :func:`exec\\*p\\* <execl>` and "
":func:`spawn\\*p\\* <spawnl>` if the environment doesn't have a "
"``'PATH'`` key. Also available via :mod:`os.path`."
msgstr ""
"환경에 ``'PATH'`` 키가 없을 때, :func:`exec\\*p\\* <execl>` 및 :func:`spawn\\*p\\*"
" <spawnl>`\\에서 사용하는 기본 검색 경로. :mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5640
msgid ""
"The string used to separate (or, rather, terminate) lines on the current "
"platform.  This may be a single character, such as ``'\\n'`` for POSIX, "
"or multiple characters, for example, ``'\\r\\n'`` for Windows. Do not use"
" *os.linesep* as a line terminator when writing files opened in text mode"
" (the default); use a single ``'\\n'`` instead, on all platforms."
msgstr ""
"현재 플랫폼에서 행을 분리(또는 종료)하는 데 사용되는 문자열. 이는 POSIX의 ``'\\n'``\\와 같은 단일 문자이거나, "
"윈도우의 ``'\\r\\n'``\\와 같은 여러 문자일 수 있습니다. 텍스트 모드로 열린(기본값) 파일에 쓸 때 줄 종결자로 "
"*os.linesep*\\를 사용하지 마십시오; 대신 모든 플랫폼에서 단일 ``'\\n'``\\를 사용하십시오."

#: ../../library/os.rst:5649
msgid ""
"The file path of the null device. For example: ``'/dev/null'`` for POSIX,"
" ``'nul'`` for Windows.  Also available via :mod:`os.path`."
msgstr ""
"널(null) 장치의 파일 경로. 예를 들어: POSIX의 경우 ``'/dev/null'``, 윈도우의 경우 ``'nul'``. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../../library/os.rst:5660
msgid ""
"Flags for use with the :func:`~sys.setdlopenflags` and "
":func:`~sys.getdlopenflags` functions.  See the Unix manual page "
":manpage:`dlopen(3)` for what the different flags mean."
msgstr ""
":func:`~sys.setdlopenflags` 및 :func:`~sys.getdlopenflags` 함수에 사용하는 플래그. 각"
" 플래그가 의미하는 바는 유닉스 매뉴얼 페이지 :manpage:`dlopen(3)`\\를 참조하십시오."

#: ../../library/os.rst:5668
msgid "Random numbers"
msgstr "난수"

#: ../../library/os.rst:5673
msgid ""
"Get up to *size* random bytes. The function can return less bytes than "
"requested."
msgstr "최대 *size* 크기의 난수 바이트열을 업습니다. 이 함수는 요청한 것보다 짧은 바이트열를 반환할 수 있습니다."

#: ../../library/os.rst:5676
msgid ""
"These bytes can be used to seed user-space random number generators or "
"for cryptographic purposes."
msgstr "이 바이트열은 사용자 공간 난수 발생기를 시드 하거나 암호화 목적으로 사용할 수 있습니다."

#: ../../library/os.rst:5679
msgid ""
"``getrandom()`` relies on entropy gathered from device drivers and other "
"sources of environmental noise. Unnecessarily reading large quantities of"
" data will have a negative impact on  other users  of the ``/dev/random``"
" and ``/dev/urandom`` devices."
msgstr ""
"``getrandom()``\\는 장치 드라이버 및 기타 환경 소음원에서 수집한 엔트로피에 의존합니다. 대량의 데이터를 불필요하게 "
"읽는 것은 ``/dev/random`` 및 ``/dev/urandom`` 장치의 다른 사용자에게 부정적인 영향을 미칩니다."

#: ../../library/os.rst:5684
#, fuzzy
msgid ""
"The flags argument is a bit mask that can contain zero or more of the "
"following values ORed together: :py:const:`os.GRND_RANDOM` and "
":py:data:`GRND_NONBLOCK`."
msgstr ""
"flags 인자는 다음 값 중 0개 이상의 값들과 함께 OR 될 수 있는 비트 마스크입니다: "
":py:data:`os.GRND_RANDOM` 및 :py:data:`GRND_NONBLOCK`."

#: ../../library/os.rst:5688
#, fuzzy
msgid ""
"See also the `Linux getrandom() manual page <https://man7.org/linux/man-"
"pages/man2/getrandom.2.html>`_."
msgstr ""
"`리눅스 getrandom() 매뉴얼 페이지 <http://man7.org/linux/man-"
"pages/man2/getrandom.2.html>`_\\도 참조하십시오."

#: ../../library/os.rst:5697
#, fuzzy
msgid "Return a bytestring of *size* random bytes suitable for cryptographic use."
msgstr "암호화에 적합한 *size* 크기의 난수 바이트열을 돌려줍니다."

#: ../../library/os.rst:5699
msgid ""
"This function returns random bytes from an OS-specific randomness source."
"  The returned data should be unpredictable enough for cryptographic "
"applications, though its exact quality depends on the OS implementation."
msgstr ""
"이 함수는 OS 종속적인 임의성 소스에서 난수 바이트열을 반환합니다. 반환된 데이터는 암호화 응용에 충분하도록 예측할 수 없어야 "
"하지만, 정확한 품질은 OS 구현에 따라 달라집니다."

#: ../../library/os.rst:5703
msgid ""
"On Linux, if the ``getrandom()`` syscall is available, it is used in "
"blocking mode: block until the system urandom entropy pool is initialized"
" (128 bits of entropy are collected by the kernel). See the :pep:`524` "
"for the rationale. On Linux, the :func:`getrandom` function can be used "
"to get random bytes in non-blocking mode (using the :data:`GRND_NONBLOCK`"
" flag) or to poll until the system urandom entropy pool is initialized."
msgstr ""
"리눅스에서, ``getrandom()`` 시스템 호출을 사용할 수 있으면, 블로킹 모드로 사용됩니다: 시스템의 urandom "
"엔트로피 풀이 초기화될 때까지 블록 됩니다 (커널이 128비트의 엔트로피를 수집합니다). 이유는 :pep:`524`\\를 "
"참조하십시오. 리눅스에서, :func:`getrandom` 함수는 (:data:`GRND_NONBLOCK` 플래그를 사용하여) 비 "
"블로킹 모드로 난수 바이트열을 얻거나, 시스템 urandom 엔트로피 풀이 초기화될 때까지 폴링 할 수 있습니다."

#: ../../library/os.rst:5710
msgid ""
"On a Unix-like system, random bytes are read from the ``/dev/urandom`` "
"device. If the ``/dev/urandom`` device is not available or not readable, "
"the :exc:`NotImplementedError` exception is raised."
msgstr ""
"유닉스류 시스템에서, ``/dev/urandom`` 장치에서 난수 바이트열을 읽습니다. ``/dev/urandom`` 장치를 사용할"
" 수 없거나 읽을 수 없으면, :exc:`NotImplementedError` 예외가 발생합니다."

#: ../../library/os.rst:5714
#, fuzzy
msgid "On Windows, it will use ``BCryptGenRandom()``."
msgstr "윈도우에서, ``CryptGenRandom()``\\을 사용합니다."

#: ../../library/os.rst:5717
msgid ""
"The :mod:`secrets` module provides higher level functions. For an easy-"
"to-use interface to the random number generator provided by your "
"platform, please see :class:`random.SystemRandom`."
msgstr ""
":mod:`secrets` 모듈은 고수준 함수를 제공합니다. 플랫폼에서 제공되는 난수 발생기에 대한 사용하기 쉬운 인터페이스는 "
":class:`random.SystemRandom`\\를 참조하십시오."

#: ../../library/os.rst:5721
msgid ""
"On Linux 3.17 and newer, the ``getrandom()`` syscall is now used when "
"available.  On OpenBSD 5.6 and newer, the C ``getentropy()`` function is "
"now used. These functions avoid the usage of an internal file descriptor."
msgstr ""
"리눅스 3.17 및 이후 버전에서, 이제 ``getrandom()`` 시스템 호출을 사용할 수 있으면 사용합니다. OpenBSD "
"5.6 이상에서, C ``getentropy()`` 함수가 이제 사용됩니다. 이 함수들은 내부 파일 기술자의 사용을 피합니다."

#: ../../library/os.rst:5727
msgid ""
"On Linux, if the ``getrandom()`` syscall blocks (the urandom entropy pool"
" is not initialized yet), fall back on reading ``/dev/urandom``."
msgstr ""
"리눅스에서, ``getrandom()`` 시스템 호출이 블록 하면 (urandom 엔트로피 풀이 아직 초기화되지 않았으면), "
"``/dev/urandom``\\을 읽는 것으로 대체됩니다."

#: ../../library/os.rst:5731
msgid ""
"On Linux, ``getrandom()`` is now used in blocking mode to increase the "
"security."
msgstr "리눅스에서, ``getrandom()``\\은 이제 보안을 강화하기 위해 블로킹 모드로 사용됩니다."

#: ../../library/os.rst:5735
msgid ""
"On Windows, ``BCryptGenRandom()`` is used instead of ``CryptGenRandom()``"
" which is deprecated."
msgstr ""

#: ../../library/os.rst:5741
msgid ""
"By  default, when reading from ``/dev/random``, :func:`getrandom` blocks "
"if no random bytes are available, and when reading from ``/dev/urandom``,"
" it blocks if the entropy pool has not yet been initialized."
msgstr ""
"기본적으로, ``/dev/random``\\에서 읽을 때, :func:`getrandom`\\는 사용할 수 있는 난수 바이트열이 "
"없으면 블록 하고, ``/dev/urandom``\\에서 읽을 때는, 엔트로피 풀이 아직 초기화되지 않았으면 블록 합니다."

#: ../../library/os.rst:5745
msgid ""
"If the :py:data:`GRND_NONBLOCK` flag is set, then :func:`getrandom` does "
"not block in these cases, but instead immediately raises "
":exc:`BlockingIOError`."
msgstr ""
":py:data:`GRND_NONBLOCK` 플래그가 설정되면, :func:`getrandom`\\는 이럴 때 블록 하지 않고, "
"대신 즉시 :exc:`BlockingIOError`\\를 발생시킵니다."

#: ../../library/os.rst:5752
msgid ""
"If  this  bit  is  set,  then  random bytes are drawn from the "
"``/dev/random`` pool instead of the ``/dev/urandom`` pool."
msgstr "이 비트가 설정되면, ``/dev/urandom`` 풀 대신 ``/dev/random`` 풀에서 난수 바이트열을 얻습니다."

#: ../../library/os.rst:364 ../../library/os.rst:530 ../../library/os.rst:732
msgid "user"
msgstr ""

#: ../../library/os.rst:364
msgid "effective id"
msgstr ""

#: ../../library/os.rst:373 ../../library/os.rst:439 ../../library/os.rst:448
#: ../../library/os.rst:457 ../../library/os.rst:471 ../../library/os.rst:667
#: ../../library/os.rst:4524 ../../library/os.rst:4550
msgid "process"
msgstr ""

#: ../../library/os.rst:373 ../../library/os.rst:439
msgid "group"
msgstr ""

#: ../../library/os.rst:448 ../../library/os.rst:530
msgid "id"
msgstr ""

#: ../../library/os.rst:457
msgid "id of parent"
msgstr ""

#: ../../library/os.rst:471 ../../library/os.rst:667
#, fuzzy
msgid "scheduling priority"
msgstr "기본 스케줄 정책."

#: ../../library/os.rst:553 ../../library/os.rst:802
msgid "environment variables"
msgstr ""

#: ../../library/os.rst:553
msgid "setting"
msgstr ""

#: ../../library/os.rst:732
msgid "id, setting"
msgstr ""

#: ../../library/os.rst:765
msgid "gethostname() (in module socket)"
msgstr ""

#: ../../library/os.rst:765
msgid "gethostbyaddr() (in module socket)"
msgstr ""

#: ../../library/os.rst:802 ../../library/os.rst:2659
msgid "deleting"
msgstr ""

#: ../../library/os.rst:1361 ../../library/os.rst:3029
msgid "module"
msgstr ""

#: ../../library/os.rst:1361
msgid "pty"
msgstr ""

#: ../../library/os.rst:2046 ../../library/os.rst:2458
#: ../../library/os.rst:2659 ../../library/os.rst:3563
#: ../../library/os.rst:3663
msgid "directory"
msgstr ""

#: ../../library/os.rst:2046
msgid "changing"
msgstr ""

#: ../../library/os.rst:2458
msgid "creating"
msgstr ""

#: ../../library/os.rst:2458
msgid "UNC paths"
msgstr ""

#: ../../library/os.rst:2458
msgid "and os.makedirs()"
msgstr ""

#: ../../library/os.rst:3029
msgid "stat"
msgstr ""

#: ../../library/os.rst:3563 ../../library/os.rst:3663
msgid "walking"
msgstr ""

#: ../../library/os.rst:3563 ../../library/os.rst:3663
msgid "traversal"
msgstr ""

#: ../../library/os.rst:4524 ../../library/os.rst:4550
msgid "killing"
msgstr ""

#: ../../library/os.rst:4524 ../../library/os.rst:4550
msgid "signalling"
msgstr ""

#: ../../library/os.rst:5579 ../../library/os.rst:5615
msgid ". (dot)"
msgstr ""

#: ../../library/os.rst:5579 ../../library/os.rst:5587
#: ../../library/os.rst:5595 ../../library/os.rst:5606
#: ../../library/os.rst:5615
msgid "in pathnames"
msgstr ""

#: ../../library/os.rst:5587
msgid ".."
msgstr ""

#: ../../library/os.rst:5595 ../../library/os.rst:5606
msgid "/ (slash)"
msgstr ""

#: ../../library/os.rst:5596
msgid "\\ (backslash)"
msgstr ""

#: ../../library/os.rst:5596
msgid "in pathnames (Windows)"
msgstr ""

#: ../../library/os.rst:5622
msgid ": (colon)"
msgstr ""

#: ../../library/os.rst:5622
msgid "path separator (POSIX)"
msgstr ""

#: ../../library/os.rst:5622
msgid "; (semicolon)"
msgstr ""

#~ msgid ":ref:`Availability <availability>`: Unix."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스."

#~ msgid ""
#~ "Return the value of the environment "
#~ "variable *key* if it exists, or "
#~ "*default* if it doesn't. *key*, "
#~ "*default* and the result are str."
#~ msgstr ""
#~ "존재하면 환경 변수 *key* 의 값을 반환하고, "
#~ "그렇지 않으면 *default* 를 반환합니다. *key*, "
#~ "*default* 및 결과는 str입니다."

#~ msgid ":ref:`Availability <availability>`: most flavors of Unix, Windows."
#~ msgstr ":ref:`가용성 <availability>`: 대부분의 유닉스, 윈도우."

#~ msgid ""
#~ "Return the value of the environment "
#~ "variable *key* if it exists, or "
#~ "*default* if it doesn't. *key*, "
#~ "*default* and the result are bytes."
#~ msgstr ""
#~ "존재하면 환경 변수 *key* 의 값을 반환하고, "
#~ "그렇지 않으면 *default* 를 반환합니다. *key*, "
#~ "*default* 및 결과는 bytes입니다."

#~ msgid ":ref:`Availability <availability>`: most flavors of Unix."
#~ msgstr ":ref:`가용성 <availability>`: 대부분의 유닉스."

#~ msgid ":ref:`Availability <availability>`: Unix, Windows."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스, 윈도우."

#~ msgid ":ref:`Availability <availability>`: recent flavors of Unix."
#~ msgstr ":ref:`가용성 <availability>`: 최근 유닉스."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Linux kernel "
#~ ">= 4.5 or glibc >= 2.27."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 커널 >= 4.5 또는 glibc >= 2.27."

#~ msgid ""
#~ "Set the current position of file "
#~ "descriptor *fd* to position *pos*, "
#~ "modified by *how*: :const:`SEEK_SET` or "
#~ "``0`` to set the position relative "
#~ "to the beginning of the file; "
#~ ":const:`SEEK_CUR` or ``1`` to set it "
#~ "relative to the current position; "
#~ ":const:`SEEK_END` or ``2`` to set it "
#~ "relative to the end of the file."
#~ " Return the new cursor position in"
#~ " bytes, starting from the beginning."
#~ msgstr ""
#~ "파일 기술자 *fd* 의 현재 위치를 *how* 에"
#~ " 따라 달리 해석되는 위치 *pos*\\로 설정합니다: "
#~ ":const:`SEEK_SET` 이나 ``0`` 이면 파일의 시작 "
#~ "부분을 기준으로 위치를 설정합니다; :const:`SEEK_CUR`\\이나 "
#~ "``1`` 이면 현재 위치를 기준으로 설정합니다; "
#~ ":const:`SEEK_END` 나 ``2`` 면 파일의 끝을 "
#~ "기준으로 설정합니다. 새 커서 위치를 파일의 시작에서 "
#~ "따진 바이트로 반환합니다."

#~ msgid ""
#~ "Some operating systems could support "
#~ "additional values, like :data:`os.SEEK_HOLE` "
#~ "or :data:`os.SEEK_DATA`."
#~ msgstr ""
#~ "일부 운영 체제는 :data:`os.SEEK_HOLE` 이나 "
#~ ":data:`os.SEEK_DATA`\\와 같은 추가 값을 지원할 수"
#~ " 있습니다."

#~ msgid "The *dir_fd* argument."
#~ msgstr "*dir_fd* 인자"

#~ msgid ":ref:`Availability <availability>`: some flavors of Unix."
#~ msgstr ":ref:`가용성 <availability>`: 일부 유닉스."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Linux 2.6.30 "
#~ "and newer, FreeBSD 6.0 and newer, "
#~ "OpenBSD 2.7 and newer, AIX 7.1 and"
#~ " newer. Using flags requires Linux "
#~ "4.6 or newer."
#~ msgstr ""
#~ ":ref:`가용성 <availability>`: 리눅스 2.6.30 이상, "
#~ "FreeBSD 6.0 이상, OpenBSD 2.7 이상, "
#~ "AIX 7.1 이상. flags를 사용하려면 리눅스 4.6"
#~ " 이상이 필요합니다."

#~ msgid ":ref:`Availability <availability>`: Linux 4.14 and newer."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 4.14 이상."

#~ msgid ":ref:`Availability <availability>`: Linux 4.6 and newer."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 4.6 이상."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Linux 2.6.30 "
#~ "and newer, FreeBSD 6.0 and newer, "
#~ "OpenBSD 2.7 and newer, AIX 7.1 and"
#~ " newer. Using flags requires Linux "
#~ "4.7 or newer."
#~ msgstr ""
#~ ":ref:`가용성 <availability>`: 리눅스 2.6.30 이상, "
#~ "FreeBSD 6.0 이상, OpenBSD 2.7 이상, "
#~ "AIX 7.1 이상. flags를 사용하려면 리눅스 4.7"
#~ " 이상이 필요합니다."

#~ msgid ":ref:`Availability <availability>`: Linux 4.7 and newer."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 4.7 이상."

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우."

#~ msgid "On Windows, if *dst* exists a :exc:`FileExistsError` is always raised."
#~ msgstr "윈도우에서, *dst*\\가 존재하면 항상 :exc:`FileExistsError`\\가 발생합니다."

#~ msgid "The *dir_fd* parameter."
#~ msgstr "*dir_fd* 매개 변수"

#~ msgid "Platform dependent:"
#~ msgstr "플랫폼에 따라 다릅니다:"

#~ msgid "the time of most recent metadata change on Unix,"
#~ msgstr "유닉스에서 가장 최근의 메타 데이터 변경 시간,"

#~ msgid "the time of creation on Windows, expressed in seconds."
#~ msgstr "윈도우에서 생성 시간, 단위는 초."

#~ msgid ""
#~ "the time of creation on Windows, "
#~ "expressed in nanoseconds as an integer."
#~ msgstr "윈도우에서 생성 시간, 단위는 나노초 정수."

#~ msgid "Time of file creation."
#~ msgstr "파일 생성 시간."

#~ msgid ""
#~ "Added the :attr:`st_atime_ns`, :attr:`st_mtime_ns`,"
#~ " and :attr:`st_ctime_ns` members."
#~ msgstr ""
#~ ":attr:`st_atime_ns`, :attr:`st_mtime_ns` 및 "
#~ ":attr:`st_ctime_ns` 멤버가 추가되었습니다."

#~ msgid "Added the :attr:`st_file_attributes` member on Windows."
#~ msgstr "윈도우에서 :attr:`st_file_attributes` 멤버를 추가했습니다."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Linux 3.17 "
#~ "or newer with glibc 2.27 or newer."
#~ msgstr ":ref:`가용성 <availability>`: glibc 2.27 이상을 사용하는 리눅스 3.17 이상."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Linux 3.17 "
#~ "or newer with glibc 2.27 or newer."
#~ "  The ``MFD_HUGE*`` flags are only "
#~ "available since Linux 4.14."
#~ msgstr ""
#~ ":ref:`가용성 <availability>`: glibc 2.27 이상을 "
#~ "사용하는 리눅스 3.17 이상. ``MFD_HUGE*`` 플래그는 "
#~ "리눅스 4.14 이후에만 사용 가능합니다."

#~ msgid "Exit code that means no error occurred."
#~ msgstr "에러가 발생하지 않았음을 나타내는 종료 코드."

#~ msgid "See :mod:`ssl` for applications that use the SSL module with fork()."
#~ msgstr "fork()와 함께 SSL 모듈을 사용하는 응용 프로그램의 경우 :mod:`ssl`\\를 참조하십시오."

#~ msgid "Windows support."
#~ msgstr "윈도우 지원."

#~ msgid ":ref:`Availability <availability>`: Linux 5.3+"
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 5.3+"

#~ msgid ""
#~ "On Unix, the return value is the"
#~ " exit status of the process encoded"
#~ " in the format specified for "
#~ ":func:`wait`.  Note that POSIX does not"
#~ " specify the meaning of the return"
#~ " value of the C :c:func:`system` "
#~ "function, so the return value of "
#~ "the Python function is system-dependent."
#~ msgstr ""
#~ "유닉스에서, 반환 값은 :func:`wait`\\에 지정된 형식으로"
#~ " 인코딩된 프로세스의 종료 상태입니다. POSIX는 C "
#~ ":c:func:`system` 함수의 반환 값의 의미를 지정하지 "
#~ "않으므로, 파이썬 함수의 반환 값은 시스템 종속적입니다."

#~ msgid ""
#~ "Wait for the completion of one or"
#~ " more child processes. *idtype* can "
#~ "be :data:`P_PID`, :data:`P_PGID`, :data:`P_ALL`, "
#~ "or :data:`P_PIDFD` on Linux. *id* "
#~ "specifies the pid to wait on. "
#~ "*options* is constructed from the ORing"
#~ " of one or more of :data:`WEXITED`,"
#~ " :data:`WSTOPPED` or :data:`WCONTINUED` and "
#~ "additionally may be ORed with "
#~ ":data:`WNOHANG` or :data:`WNOWAIT`. The return"
#~ " value is an object representing the"
#~ " data contained in the :c:type:`siginfo_t`"
#~ " structure, namely: :attr:`si_pid`, "
#~ ":attr:`si_uid`, :attr:`si_signo`, :attr:`si_status`, "
#~ ":attr:`si_code` or ``None`` if :data:`WNOHANG`"
#~ " is specified and there are no "
#~ "children in a waitable state."
#~ msgstr ""
#~ "하나 이상의 자식 프로세스가 완료될 때까지 기다립니다. "
#~ "*idtype* 은 :data:`P_PID`, :data:`P_PGID`, "
#~ ":data:`P_ALL` 또는 리눅스에서 :data:`P_PIDFD`\\가 될"
#~ " 수 있습니다. *id* 는 기다릴 pid를 지정합니다."
#~ " *options*\\는 하나 이상의 :data:`WEXITED`, "
#~ ":data:`WSTOPPED` 또는 :data:`WCONTINUED`\\의 OR로 "
#~ "구성되며, 추가로 :data:`WNOHANG` 또는 "
#~ ":data:`WNOWAIT`\\와 OR 될 수 있습니다. 반환 "
#~ "값은 :c:type:`siginfo_t` 구조체에 포함된 데이터(즉, "
#~ ":attr:`si_pid`, :attr:`si_uid`, :attr:`si_signo`, "
#~ ":attr:`si_status`, :attr:`si_code`)를 나타내는 객체이거나, "
#~ ":data:`WNOHANG`\\가 지정되고 대기 가능한 상태의 자식이"
#~ " 없으면 ``None``\\입니다."

#~ msgid ""
#~ "This is a Linux-specific *idtype* "
#~ "that indicates that *id* is a file"
#~ " descriptor that refers to a process."
#~ msgstr "이것은 *id*\\가 프로세스를 참조하는 파일 기술자임을 나타내는 리눅스 특정 *idtype*\\입니다."

#~ msgid ":ref:`Availability <availability>`: Linux 5.4+"
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 5.4+"

#~ msgid ""
#~ "Flags that can be used in "
#~ "*options* in :func:`waitid` that specify "
#~ "what child signal to wait for."
#~ msgstr "기다릴 자식 시그널을 지정하는, :func:`waitid`\\의 *options* 에서 사용할 수 있는 플래그."

#~ msgid ""
#~ "An :exc:`OSError` is raised with the "
#~ "value of errno when the syscall "
#~ "returns -1."
#~ msgstr "시스템 호출이 -1을 반환하면, :exc:`OSError`\\가 errno 값으로 발생합니다."

#~ msgid ""
#~ "The option for :func:`waitpid` to return"
#~ " immediately if no child process "
#~ "status is available immediately. The "
#~ "function returns ``(0, 0)`` in this "
#~ "case."
#~ msgstr ""
#~ "자식 프로세스 상태를 즉시 사용할 수 없으면, "
#~ ":func:`waitpid`\\가 즉시 반환하는 옵션입니다. 이 경우"
#~ " 이 함수는 ``(0, 0)``\\를 반환합니다."

#~ msgid ":ref:`Availability <availability>`: some Unix systems."
#~ msgstr ":ref:`가용성 <availability>`: 일부 유닉스 시스템."

#~ msgid "Voluntarily relinquish the CPU."
#~ msgstr "자발적으로 CPU를 양도합니다."

#~ msgid ""
#~ "This number is not equivalent to "
#~ "the number of CPUs the current "
#~ "process can use.  The number of "
#~ "usable CPUs can be obtained with "
#~ "``len(os.sched_getaffinity(0))``"
#~ msgstr ""
#~ "이 숫자는 현재 프로세스에서 사용할 수 있는 CPU"
#~ " 수와 같지 않습니다. 사용 가능한 CPU 수는 "
#~ "``len(os.sched_getaffinity(0))``\\로 얻을 수 있습니다."

#~ msgid ":ref:`Availability <availability>`: Linux 3.17 and newer."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 3.17 이상."

