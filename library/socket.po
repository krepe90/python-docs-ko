# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/socket.rst:2
#, fuzzy
msgid ":mod:`!socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- 저수준 네트워킹 인터페이스"

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**소스 코드:** :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is "
"available on all modern Unix systems, Windows, MacOS, and probably "
"additional platforms."
msgstr ""
"이 모듈은 BSD *socket* 인터페이스에 대한 액세스를 제공합니다. 모든 현대 유닉스 시스템, 윈도우, MacOS, 그리고 "
"아마 추가 플랫폼에서 사용할 수 있습니다."

#: ../../library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr "호출이 운영 체제 소켓 API로 이루어지기 때문에, 일부 동작은 플랫폼에 따라 다를 수 있습니다."

#: ../../includes/wasm-notavail.rst:3 ../../library/socket.rst:176
#: ../../library/socket.rst:186 ../../library/socket.rst:214
#: ../../library/socket.rst:221 ../../library/socket.rst:238
#: ../../library/socket.rst:388 ../../library/socket.rst:466
#: ../../library/socket.rst:480 ../../library/socket.rst:495
#: ../../library/socket.rst:506 ../../library/socket.rst:515
#: ../../library/socket.rst:524 ../../library/socket.rst:535
#: ../../library/socket.rst:547 ../../library/socket.rst:558
#: ../../library/socket.rst:571 ../../library/socket.rst:599
#: ../../library/socket.rst:611 ../../library/socket.rst:617
#: ../../library/socket.rst:647 ../../library/socket.rst:662
#: ../../library/socket.rst:671 ../../library/socket.rst:688
#: ../../library/socket.rst:703 ../../library/socket.rst:713
#: ../../library/socket.rst:902 ../../library/socket.rst:1027
#: ../../library/socket.rst:1043 ../../library/socket.rst:1056
#: ../../library/socket.rst:1071 ../../library/socket.rst:1088
#: ../../library/socket.rst:1099 ../../library/socket.rst:1110
#: ../../library/socket.rst:1121 ../../library/socket.rst:1210
#: ../../library/socket.rst:1230 ../../library/socket.rst:1256
#: ../../library/socket.rst:1279 ../../library/socket.rst:1308
#: ../../library/socket.rst:1319 ../../library/socket.rst:1346
#: ../../library/socket.rst:1363 ../../library/socket.rst:1380
#: ../../library/socket.rst:1394 ../../library/socket.rst:1445
#: ../../library/socket.rst:1492 ../../library/socket.rst:1506
#: ../../library/socket.rst:1526 ../../library/socket.rst:1573
#: ../../library/socket.rst:1618 ../../library/socket.rst:1743
#: ../../library/socket.rst:1787 ../../library/socket.rst:1895
#: ../../library/socket.rst:1913 ../../library/socket.rst:1997
#: ../../library/socket.rst:2007 ../../library/socket.rst:2019
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/socket.rst:24
#, fuzzy
msgid ""
"The Python interface is a straightforward transliteration of the Unix "
"system call and library interface for sockets to Python's object-oriented"
" style: the :func:`~socket.socket` function returns a :dfn:`socket "
"object` whose methods implement the various socket system calls.  "
"Parameter types are somewhat higher-level than in the C interface: as "
"with :meth:`read` and :meth:`write` operations on Python files, buffer "
"allocation on receive operations is automatic, and buffer length is "
"implicit on send operations."
msgstr ""
"파이썬 인터페이스는 유닉스 시스템 호출과 소켓을 위한 라이브러리 인터페이스를 파이썬의 객체 지향 스타일로 직역한 것입니다: "
":func:`.socket` 함수는 :dfn:`소켓 객체 (socket object)`\\를 반환하고, 이것의 메서드는 다양한 소켓"
" 시스템 호출을 구현합니다. 매개 변수 형은 C 인터페이스보다 다소 고수준입니다: 파이썬 파일에 대한 :meth:`read` 와 "
":meth:`write` 연산처럼, 수신 연산의 버퍼 할당은 자동이고 전송 연산에서 버퍼 길이는 묵시적입니다."

#: ../../library/socket.rst:35
msgid "Module :mod:`socketserver`"
msgstr "모듈 :mod:`socketserver`"

#: ../../library/socket.rst:36
msgid "Classes that simplify writing network servers."
msgstr "네트워크 서버 작성을 단순화하는 클래스."

#: ../../library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr "모듈 :mod:`ssl`"

#: ../../library/socket.rst:39
msgid "A TLS/SSL wrapper for socket objects."
msgstr "소켓 객체용 TLS/SSL 래퍼."

#: ../../library/socket.rst:43
msgid "Socket families"
msgstr "소켓 패밀리"

#: ../../library/socket.rst:45
msgid ""
"Depending on the system and the build options, various socket families "
"are supported by this module."
msgstr "시스템과 빌드 옵션에 따라, 다양한 소켓 패밀리가 이 모듈에서 지원됩니다."

#: ../../library/socket.rst:48
msgid ""
"The address format required by a particular socket object is "
"automatically selected based on the address family specified when the "
"socket object was created.  Socket addresses are represented as follows:"
msgstr ""
"특정 소켓 객체가 요구하는 주소 형식은 소켓 객체를 만들 때 지정된 주소 패밀리에 따라 자동으로 선택됩니다. 소켓 주소는 다음과 "
"같이 표현됩니다:"

#: ../../library/socket.rst:52
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in "
"Linux's abstract namespace is returned as a :term:`bytes-like object` "
"with an initial null byte; note that sockets in this namespace can "
"communicate with normal file system sockets, so programs intended to run "
"on Linux may need to deal with both types of address.  A string or bytes-"
"like object can be used for either type of address when passing it as an "
"argument."
msgstr ""
"파일 시스템 노드에 바인드 된 :const:`AF_UNIX` 소켓의 주소는 파일 시스템 인코딩과 "
"``'surrogateescape'`` 에러 처리기(:pep:`383`\\을 참조하세요)를 사용하는 문자열로 표현됩니다. 리눅스의 "
"추상 이름 공간(abstract namespace)에 있는 주소는 처음에 널 바이트가 있는 :term:`바이트열류 객체 "
"<bytes-like object>`\\로 반환됩니다; 이 이름 공간의 소켓은 일반 파일 시스템 소켓과 통신 할 수 있으므로, "
"리눅스에서 실행하려는 프로그램은 두 가지 유형의 주소를 모두 다뤄야 할 수도 있습니다. 문자열이나 바이트열류 객체는 인자로 전달할 "
"때 두 가지 유형의 주소에 모두 사용할 수 있습니다."

#: ../../library/socket.rst:62
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 "
"encoding."
msgstr "이전에는, :const:`AF_UNIX` 소켓 경로가 UTF-8 인코딩을 사용한다고 가정했습니다."

#: ../../library/socket.rst:66 ../../library/socket.rst:1193
#: ../../library/socket.rst:1235 ../../library/socket.rst:1991
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "이제 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>`\\를 받아들입니다."

#: ../../library/socket.rst:71
#, fuzzy
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet "
"domain notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"쌍 ``(host, port)``\\가 :const:`AF_INET` 주소 패밀리에 사용됩니다. 여기서 *host*\\는 "
"``'daring.cwi.nl'``\\과 같은 인터넷 도메인 표기법의 호스트 명이나 ``'100.50.200.5'``\\와 같은 "
"IPv4 주소를 나타내는 문자열이고, *port*\\는 정수입니다."

#: ../../library/socket.rst:76
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to "
"all interfaces, and the string ``'<broadcast>'`` represents "
":const:`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, "
"therefore, you may want to avoid these if you intend to support IPv6 with"
" your Python programs."
msgstr ""
"IPv4 주소의 경우, 호스트 주소 대신 두 개의 특수 형식이 허용됩니다: ``''``\\는 모든 인터페이스에 바인딩하는 데 "
"사용되는 :const:`INADDR_ANY`\\를 나타내며 ``'<broadcast>'`` 문자열은 "
":const:`INADDR_BROADCAST`\\를 나타냅니다. 이 동작은 IPv6와 호환되지 않으므로, 여러분의 파이썬 "
"프로그램에서 IPv6를 지원하려는 경우에는 이것들을 사용하지 않을 수 있습니다."

#: ../../library/socket.rst:83
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, "
"flowinfo, scope_id)`` is used, where *flowinfo* and *scope_id* represent "
"the ``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, "
"however, omission of *scope_id* can cause problems in manipulating scoped"
" IPv6 addresses."
msgstr ""
":const:`AF_INET6` 주소 패밀리의 경우, 4-튜플 ``(host, port, flowinfo, "
"scope_id)``\\가 사용됩니다. 여기서 *flowinfo* 와 *scope_id*\\는 C에서 :const:`struct "
"sockaddr_in6`\\의 ``sin6_flowinfo`` 와 ``sin6_scope_id`` 멤버를 나타냅니다. "
":mod:`socket` 모듈 메서드의 경우, *flowinfo* 와 *scope_id*\\는 이전 버전과의 호환성을 위해 생략할 "
"수 있습니다. 그러나, *scope_id*\\를 생략하면 스코프가 지정된(scoped) IPv6 주소를 조작하는 데 문제가 발생할 "
"수 있습니다."

#: ../../library/socket.rst:90
#, python-format
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is "
"superfluous and may be safely omitted (recommended)."
msgstr ""
"멀티캐스트 주소(의미 있는 *scope_id*\\를 가진)의 경우, *address*\\에는 ``%scope_id`` (또는 "
"``zone id``) 부분이 포함될 수 없습니다. 이 정보는 불필요하므로 안전하게 생략할 수 있습니다 (권장 사항)."

#: ../../library/socket.rst:95
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` 소켓은 ``(pid, groups)`` 쌍으로 표현됩니다."

#: ../../library/socket.rst:97
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` "
"address family.  TIPC is an open, non-IP based networked protocol "
"designed for use in clustered computer environments.  Addresses are "
"represented by a tuple, and the fields depend on the address type. The "
"general tuple form is ``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"TIPC에 대한 리눅스 전용 지원은 :const:`AF_TIPC` 주소 패밀리를 사용하여 사용할 수 있습니다. TIPC는 클러스터 "
"된 컴퓨터 환경에서 사용하도록 설계된 개방형 비 IP 기반 네트워크 프로토콜입니다. 주소는 튜플로 표현되며 필드는 주소 유형에 따라"
" 다릅니다. 일반적인 튜플 형식은 ``(addr_type, v1, v2, v3 [, scope])``\\입니다. 이때:"

#: ../../library/socket.rst:103
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, "
":const:`TIPC_ADDR_NAME`, or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type*\\은 :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME` 또는 "
":const:`TIPC_ADDR_ID` 중 하나입니다."

#: ../../library/socket.rst:105
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope*\\는 :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE` 또는 "
":const:`TIPC_NODE_SCOPE` 중 하나입니다."

#: ../../library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"*addr_type*\\이 :const:`TIPC_ADDR_NAME`\\이면, *v1*\\은 서버 유형이고, *v2*\\는 포트 "
"식별자이며, *v3*\\은 0이어야 합니다."

#: ../../library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server "
"type, *v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"*addr_type*\\이 :const:`TIPC_ADDR_NAMESEQ`\\면, *v1*\\은 서버 유형이고, *v2*\\는 하위"
" 포트 번호이며, *v3*\\는 상위 포트 번호입니다."

#: ../../library/socket.rst:113
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is "
"the reference, and *v3* should be set to 0."
msgstr ""
"*addr_type*\\이 :const:`TIPC_ADDR_ID`\\면, *v1*\\은 노드이고, *v2*\\는 참조이며, "
"*v3*\\는 0으로 설정되어야 합니다."

#: ../../library/socket.rst:116
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family,"
" where *interface* is a string representing a network interface name like"
" ``'can0'``. The network interface name ``''`` can be used to receive "
"packets from all network interfaces of this family."
msgstr ""
"튜플 ``(interface, )``\\가 :const:`AF_CAN` 주소 패밀리에 사용됩니다. 여기서 *interface*\\는"
" ``'can0'``\\과 같은 네트워크 인터페이스 이름을 나타내는 문자열입니다. 네트워크 인터페이스 이름 ``''``\\는 이 "
"패밀리의 모든 네트워크 인터페이스에서 패킷을 수신하는 데 사용할 수 있습니다."

#: ../../library/socket.rst:121
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer "
"that represent a CAN identifier (standard or extended)."
msgstr ""
":const:`CAN_ISOTP` 프로토콜은 튜플 ``(interface, rx_addr, tx_addr)``\\를 요구하는데, 두"
" 개의 추가 매개 변수는 모두 CAN 식별자(표준 또는 확장)를 나타내는 부호 없는 long 정수입니다."

#: ../../library/socket.rst:124
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, "
"addr)`` where additional parameters are 64-bit unsigned integer "
"representing the ECU name, a 32-bit unsigned integer representing the "
"Parameter Group Number (PGN), and an 8-bit integer representing the "
"address."
msgstr ""
":const:`CAN_J1939` 프로토콜에는 ``(interface, name, pgn, addr)``\\가 필요한데, 여기서 "
"추가 파라미터는 ECU 이름을 나타내는 64 비트 부호 없는 정수, PGN(Parameter Group Number)을 나타내는 "
"32비트 부호 없는 정수 및 주소를 나타내는 8비트 정수입니다."

#: ../../library/socket.rst:129
#, fuzzy
msgid ""
"A string or a tuple ``(id, unit)`` is used for the "
":const:`SYSPROTO_CONTROL` protocol of the :const:`PF_SYSTEM` family. The "
"string is the name of a kernel control using a dynamically assigned ID. "
"The tuple can be used if ID and unit number of the kernel control are "
"known or if a registered ID is used."
msgstr ""
"문자열이나 튜플 ``(id, unit)``\\는 :const:`PF_SYSTEM` 패밀리의 "
":const:`SYSPROTO_CONTROL` 프로토콜에 사용됩니다. 문자열은 동적으로 할당된 ID를 사용하는 커널 컨트롤의 "
"이름입니다. 튜플은 커널 컨트롤의 ID와 유닛 번호가 알려져 있거나 등록된 ID가 사용될 때 사용할 수 있습니다."

#: ../../library/socket.rst:137
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address "
"formats:"
msgstr ":const:`AF_BLUETOOTH`\\는 다음 프로토콜 및 주소 형식을 지원합니다:"

#: ../../library/socket.rst:140
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP`\\는 ``(bdaddr, psm)``\\를 받아들입니다. 여기서 ``bdaddr``\\은 "
"문자열 블루투스 주소이고 ``psm``\\은 정수입니다."

#: ../../library/socket.rst:143
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is"
" the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM`\\은 ``(bdaddr, channel)``\\를 받아들입니다. 여기서 "
"``bdaddr``\\은 문자열 블루투스 주소이고 ``channel``\\은 정수입니다."

#: ../../library/socket.rst:146
msgid ":const:`BTPROTO_HCI` accepts a format that depends on your OS."
msgstr ""

#: ../../library/socket.rst:148
msgid ""
"On Linux it accepts a tuple ``(device_id,)`` where ``device_id`` is an "
"integer specifying the number of the Bluetooth device."
msgstr ""

#: ../../library/socket.rst:150
#, fuzzy
msgid ""
"On FreeBSD, NetBSD and DragonFly BSD it accepts ``bdaddr`` where "
"``bdaddr`` is the Bluetooth address as a string."
msgstr ""
":const:`BTPROTO_L2CAP`\\는 ``(bdaddr, psm)``\\를 받아들입니다. 여기서 ``bdaddr``\\은 "
"문자열 블루투스 주소이고 ``psm``\\은 정수입니다."

#: ../../library/socket.rst:153
msgid "NetBSD and DragonFlyBSD support added."
msgstr "NetBSD 및 DragonFlyBSD 지원이 추가되었습니다."

#: ../../library/socket.rst:156
#, fuzzy
msgid "FreeBSD support added."
msgstr "윈도우 지원이 추가되었습니다."

#: ../../library/socket.rst:159
#, fuzzy
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is the Bluetooth"
" address as a string or a :class:`bytes` object. (ex. "
"``'12:23:34:45:56:67'`` or ``b'12:23:34:45:56:67'``) This protocol is not"
" supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO`\\는 ``bdaddr``\\를 받아들입니다. 여기서 ``bdaddr``\\는 블루투스 주소의 "
"문자열 형식이 포함된 :class:`bytes` 객체입니다. (예, ``b'12:23:34:45:56:67'``) 이 프로토콜은 "
"FreeBSD에서 지원되지 않습니다."

#: ../../library/socket.rst:164
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to "
"four elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG`\\는 커널 암호 인터페이스에 기반한 리눅스 전용 소켓입니다. 알고리즘 소켓은 2~4개의 요소를 갖는 "
"``(type, name [, feat [, mask]])`` 튜플로 구성됩니다. 여기서:"

#: ../../library/socket.rst:168
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type*\\은 문자열의 알고리즘 유형입니다, 예를 들어, ``aead``, ``hash``, ``skcipher`` 또는 "
"``rng``."

#: ../../library/socket.rst:171
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. "
"``sha256``, ``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name*\\은 알고리즘 이름과 연산 모드 문자열입니다, 예를 들어, ``sha256``, ``hmac(sha256)``, "
"``cbc(aes)`` 또는 ``drbg_nopr_ctr_aes256``."

#: ../../library/socket.rst:174
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* 과 *mask*\\는 부호 없는 32비트 정수입니다."

#: ../../library/socket.rst:178
msgid "Some algorithm types require more recent Kernels."
msgstr ""

#: ../../library/socket.rst:182
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their"
" hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK`\\은 가상 기계와 호스트가 통신할 수 있게 합니다. 소켓은 ``(CID, port)`` 튜플로 "
"표현되는데, 컨텍스트 ID 또는 CID와 port는 정수입니다."

#: ../../library/socket.rst:188
msgid "See :manpage:`vsock(7)`"
msgstr ""

#: ../../library/socket.rst:192
#, fuzzy
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. "
"The addresses are represented by the tuple ``(ifname, proto[, pkttype[, "
"hatype[, addr]]])`` where:"
msgstr ""
":const:`AF_PACKET`\\은 네트워크 장치에 직접 연결된 저수준 인터페이스입니다. 패킷은 튜플 ``(ifname, "
"proto[, pkttype[, hatype[, addr]]])``\\로 표현됩니다. 여기서:"

#: ../../library/socket.rst:196
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - 장치 이름을 지정하는 문자열"

#: ../../library/socket.rst:197
msgid ""
"*proto* - The Ethernet protocol number. May be :data:`ETH_P_ALL` to "
"capture all protocols, one of the :ref:`ETHERTYPE_* constants <socket-"
"ethernet-types>` or any other Ethernet protocol number."
msgstr ""

#: ../../library/socket.rst:201
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - 패킷 유형을 지정하는 선택적 정수.:"

#: ../../library/socket.rst:203
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr "``PACKET_HOST`` (기본값) - 로컬 호스트로 향하는 패킷."

#: ../../library/socket.rst:204
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - 물리 계층 브로드캐스트 패킷."

#: ../../library/socket.rst:205
#, fuzzy
msgid "``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr "``PACKET_MULTIHOST`` - 물리 계층 멀티캐스트 주소로 전송된 패킷."

#: ../../library/socket.rst:206
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by "
"a device driver in promiscuous mode."
msgstr "``PACKET_OTHERHOST`` - 무차별 모드의 장치 관리자에 의해 포착된 다른 호스트로 향하는 패킷."

#: ../../library/socket.rst:208
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is "
"looped back to a packet socket."
msgstr "``PACKET_OUTGOING`` - 패킷 소켓으로 루프 백 된 로컬 호스트에서 시작된 패킷."

#: ../../library/socket.rst:210
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr "*hatype* - ARP 하드웨어 주소 유형을 지정하는 선택적 정수."

#: ../../library/socket.rst:211
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr "*addr* - 하드웨어 물리 주소를 지정하는 선택적 바이트열류 객체, 해석은 장치에 따라 다릅니다."

#: ../../library/socket.rst:216
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for "
"communicating with services running on co-processors in Qualcomm "
"platforms. The address family is represented as a ``(node, port)`` tuple "
"where the *node* and *port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR`\\는 Qualcomm 플랫폼의 코 프로세서에서 실행되는 서비스와 통신하기 위한 리눅스 전용 소켓"
" 기반 인터페이스입니다. 주소 패밀리는 ``(node, port)`` 튜플로 표현되는데, *node*\\와 *port*\\는 음수가"
" 아닌 정수입니다."

#: ../../library/socket.rst:225
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket"
" options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing "
"packets are covered by the checksum and "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` will "
"filter out packets which cover too little of their data. In both cases "
"``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE`\\는 UDP의 변형으로, 체크섬으로 커버되는 패킷 부분을 지정할 수 있습니다. 변경할 "
"수 있는 두 개의 소켓 옵션이 추가되었습니다. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)``\\는 체크섬으로 커버되는 나가는 패킷 부분을 변경하고 "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)``\\는 너무 적은"
" 데이터를 커버하는 패킷을 걸러냅니다. 두 경우 모두 ``length``\\는 ``range(8, 2**16, 8)``\\에 "
"있어야합니다."

#: ../../library/socket.rst:234
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"이러한 소켓은 IPv4의 경우 ``socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE)`` 또는 "
"IPv6의 경우 ``socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE)``\\로 구성되어야 합니다."

#: ../../library/socket.rst:242
#, fuzzy
msgid ""
":const:`AF_HYPERV` is a Windows-only socket based interface for "
"communicating with Hyper-V hosts and guests. The address family is "
"represented as a ``(vm_id, service_id)`` tuple where the ``vm_id`` and "
"``service_id`` are UUID strings."
msgstr ""
":const:`AF_QIPCRTR`\\는 Qualcomm 플랫폼의 코 프로세서에서 실행되는 서비스와 통신하기 위한 리눅스 전용 소켓"
" 기반 인터페이스입니다. 주소 패밀리는 ``(node, port)`` 튜플로 표현되는데, *node*\\와 *port*\\는 음수가"
" 아닌 정수입니다."

#: ../../library/socket.rst:247
msgid ""
"The ``vm_id`` is the virtual machine identifier or a set of known VMID "
"values if the target is not a specific virtual machine. Known VMID "
"constants defined on ``socket`` are:"
msgstr ""

#: ../../library/socket.rst:251
msgid "``HV_GUID_ZERO``"
msgstr ""

#: ../../library/socket.rst:252
msgid "``HV_GUID_BROADCAST``"
msgstr ""

#: ../../library/socket.rst:253
msgid ""
"``HV_GUID_WILDCARD`` - Used to bind on itself and accept connections from"
" all partitions."
msgstr ""

#: ../../library/socket.rst:255
msgid ""
"``HV_GUID_CHILDREN`` - Used to bind on itself and accept connection from "
"child partitions."
msgstr ""

#: ../../library/socket.rst:257
msgid "``HV_GUID_LOOPBACK`` - Used as a target to itself."
msgstr ""

#: ../../library/socket.rst:258
msgid ""
"``HV_GUID_PARENT`` - When used as a bind accepts connection from the "
"parent partition. When used as an address target it will connect to the "
"parent partition."
msgstr ""

#: ../../library/socket.rst:261
msgid "The ``service_id`` is the service identifier of the registered service."
msgstr ""

#: ../../library/socket.rst:265
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, "
"the program may show a nondeterministic behavior, as Python uses the "
"first address returned from the DNS resolution.  The socket address will "
"be resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"IPv4/v6 소켓 주소의 *host* 부분에 호스트 명을 사용하면, 파이썬이 DNS 결정에서 반환된 첫 번째 주소를 사용하기 "
"때문에, 프로그램은 비결정적인 동작을 보일 수 있습니다. 소켓 주소는 DNS 결정 결과 및/또는 호스트 구성에 따라 실제 "
"IPv4/v6 주소로 다르게 결정됩니다. 결정론적 동작을 위해서는 *host* 부분에 숫자 주소를 사용하십시오."

#: ../../library/socket.rst:272
#, fuzzy
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to "
"socket or address semantics raise :exc:`OSError` or one of its "
"subclasses."
msgstr ""
"모든 에러는 예외를 발생시킵니다. 잘못된 인자 형과 메모리 부족 조건에 대한 일반적인 예외가 발생할 수 있습니다. 파이썬 "
"3.3부터, 소켓이나 주소 의미와 관련된 에러는 :exc:`OSError` 나 그 서브 클래스 중 하나를 발생시킵니다 (예전에는 "
":exc:`socket.error`\\를 발생시켰습니다)."

#: ../../library/socket.rst:277
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through "
":meth:`~socket.settimeout`."
msgstr ""
"비 블로킹 모드는 :meth:`~socket.setblocking`\\을 통해 지원됩니다. 시간제한을 기반으로 하는 일반화는 "
":meth:`~socket.settimeout`\\을 통해 지원됩니다."

#: ../../library/socket.rst:283
msgid "Module contents"
msgstr "모듈 내용"

#: ../../library/socket.rst:285
msgid "The module :mod:`socket` exports the following elements."
msgstr "모듈 :mod:`socket`\\은 다음 요소를 노출합니다."

#: ../../library/socket.rst:289
msgid "Exceptions"
msgstr "예외"

#: ../../library/socket.rst:293
msgid "A deprecated alias of :exc:`OSError`."
msgstr ":exc:`OSError`\\의 폐지된 별칭."

#: ../../library/socket.rst:295
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ":pep:`3151`\\을 따라, 이 클래스는 :exc:`OSError`\\의 별칭이 되었습니다."

#: ../../library/socket.rst:301
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-"
"related errors, i.e. for functions that use *h_errno* in the POSIX C API,"
" including :func:`gethostbyname_ex` and :func:`gethostbyaddr`. The "
"accompanying value is a pair ``(h_errno, string)`` representing an error "
"returned by a library call.  *h_errno* is a numeric value, while *string*"
" represents the description of *h_errno*, as returned by the "
":c:func:`hstrerror` C function."
msgstr ""
":exc:`OSError`\\의 서브 클래스, 이 예외는 주소 관련 에러에서 발생합니다. 즉 "
":func:`gethostbyname_ex`\\와 :func:`gethostbyaddr`\\를 포함하는 POSIX C API의 "
"*h_errno*\\를 사용하는 함수들. 수반되는 값은 라이브러리 호출이 반환한 에러를 나타내는 ``(h_errno, "
"string)`` 쌍입니다. *h_errno*\\는 숫자 값이고, *string*\\은 :c:func:`hstrerror` C "
"함수에 의해 반환된 *h_errno*\\의 설명을 나타냅니다."

#: ../../library/socket.rst:309 ../../library/socket.rst:322
#: ../../library/socket.rst:335
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "이 클래스는 :exc:`OSError`\\의 서브 클래스가 되었습니다."

#: ../../library/socket.rst:314
#, fuzzy
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-"
"related errors by :func:`getaddrinfo` and :func:`getnameinfo`. The "
"accompanying value is a pair ``(error, string)`` representing an error "
"returned by a library call.  *string* represents the description of "
"*error*, as returned by the :c:func:`gai_strerror` C function.  The "
"numeric *error* value will match one of the :const:`!EAI_\\*` constants "
"defined in this module."
msgstr ""
":exc:`OSError`\\의 서브 클래스, 이 예외는 :func:`getaddrinfo` 와 "
":func:`getnameinfo`\\에 의한 주소 관련 에러에서 발생합니다. 수반되는 값은 라이브러리 호출이 반환한 에러를 "
"나타내는 ``(error, string)`` 쌍입니다. *string*\\은 :c:func:`gai_strerror` C 함수가 "
"반환한 *error*\\의 설명을 나타냅니다. 숫자 *error* 값은 이 모듈에 정의된 :const:`EAI_\\*` 상수 중 "
"하나와 일치합니다."

#: ../../library/socket.rst:327
#, fuzzy
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr ":exc:`OSError`\\의 폐지된 별칭."

#: ../../library/socket.rst:329
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout "
"occurs on a socket which has had timeouts enabled via a prior call to "
":meth:`~socket.settimeout` (or implicitly through "
":func:`~socket.setdefaulttimeout`).  The accompanying value is a string "
"whose value is currently always \"timed out\"."
msgstr ""
":exc:`OSError`\\의 서브 클래스, 이 예외는 앞서 :meth:`~socket.settimeout` 호출을 통해 (또는 "
"묵시적으로 :func:`~socket.setdefaulttimeout`\\를 통해) 시간제한이 활성화된 소켓에서 시간 초과가 일어날"
" 때 발생합니다. 수반되는 값은 현재는 항상 \"timed out\" 값을 갖는 문자열입니다."

#: ../../library/socket.rst:338
#, fuzzy
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "이 클래스는 :exc:`OSError`\\의 서브 클래스가 되었습니다."

#: ../../library/socket.rst:343
msgid "Constants"
msgstr "상수"

#: ../../library/socket.rst:345
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and "
":class:`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"AF_* 와 SOCK_* 상수는 이제 :class:`AddressFamily` 와 :class:`SocketKind` "
":class:`.IntEnum` 컬렉션입니다."

#: ../../library/socket.rst:354
#, fuzzy
msgid ""
"These constants represent the address (and protocol) families, used for "
"the first argument to :func:`~socket.socket`.  If the :const:`AF_UNIX` "
"constant is not defined then this protocol is unsupported.  More "
"constants may be available depending on the system."
msgstr ""
"이 상수는 :func:`.socket`\\의 첫 번째 인자에 사용되는 주소 (및 프로토콜) 패밀리를 나타냅니다. "
":const:`AF_UNIX` 상수가 정의되지 않으면 이 프로토콜은 지원되지 않습니다. 시스템에 따라 더 많은 상수를 사용할 수 "
"있습니다."

#: ../../library/socket.rst:361
msgid ""
":const:`AF_UNSPEC` means that :func:`getaddrinfo` should return socket "
"addresses for any address family (either IPv4, IPv6, or any other) that "
"can be used."
msgstr ""

#: ../../library/socket.rst:371
#, fuzzy
msgid ""
"These constants represent the socket types, used for the second argument "
"to :func:`~socket.socket`.  More constants may be available depending on "
"the system. (Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to "
"be generally useful.)"
msgstr ""
"이 상수는 :func:`.socket`\\의 두 번째 인자에 사용되는 소켓 유형을 나타냅니다. 시스템에 따라 더 많은 상수를 사용할"
" 수 있습니다. (:const:`SOCK_STREAM`\\과 :const:`SOCK_DGRAM` 만 일반적으로 유용합니다.)"

#: ../../library/socket.rst:379
msgid ""
"These two constants, if defined, can be combined with the socket types "
"and allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"이 두 상수는, 정의되었다면, 소켓 유형과 결합하여 일부 플래그를 원자 적으로 설정할 수 있도록 합니다 (따라서 경쟁 조건의 "
"가능성과 별도 호출의 필요성을 피할 수 있습니다)."

#: ../../library/socket.rst:385
#, fuzzy
msgid ""
"`Secure File Descriptor Handling "
"<https://udrepper.livejournal.com/20407.html>`_ for a more thorough "
"explanation."
msgstr ""
"좀 더 철저한 설명은 `Secure File Descriptor Handling "
"<http://udrepper.livejournal.com/20407.html>`_."

#: ../../library/socket.rst:409
#, fuzzy
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. "
"They are generally used in arguments to the :meth:`~socket.setsockopt` "
"and :meth:`~socket.getsockopt` methods of socket objects.  In most cases,"
" only those symbols that are defined in the Unix header files are "
"defined; for a few symbols, default values are provided."
msgstr ""
"소켓 및/또는 IP 프로토콜에 대한 유닉스 설명서에서 설명된 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다. 일반적으로 "
"소켓 객체의 :meth:`setsockopt` 와 :meth:`getsockopt` 메서드 인자에 사용됩니다. 대부분 유닉스 헤더 "
"파일에 정의된 기호만 정의됩니다; 몇 가지 기호는 기본값이 제공됩니다."

#: ../../library/socket.rst:416
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION``\\가 추가되었습니다."

#: ../../library/socket.rst:420
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr "윈도우에서, 런타임 윈도우가 지원하면 ``TCP_FASTOPEN``, ``TCP_KEEPCNT``\\가 나타납니다."

#: ../../library/socket.rst:424
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT``\\가 추가되었습니다."

#: ../../library/socket.rst:427
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time "
"Windows supports."
msgstr "윈도우에서, 런타임 윈도우가 지원하면 ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL``\\가 나타납니다."

#: ../../library/socket.rst:430
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this "
"constant can be used in the same  way that ``TCP_KEEPIDLE`` is used on "
"Linux."
msgstr ""

#: ../../library/socket.rst:435
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""

#: ../../library/socket.rst:439
msgid ""
"Added ``SO_RTABLE`` and ``SO_USER_COOKIE``. On OpenBSD and FreeBSD "
"respectively those constants can be used in the same way that ``SO_MARK``"
" is used on Linux. Also added missing TCP socket options from Linux: "
"``TCP_MD5SIG``, ``TCP_THIN_LINEAR_TIMEOUTS``, ``TCP_THIN_DUPACK``, "
"``TCP_REPAIR``, ``TCP_REPAIR_QUEUE``, ``TCP_QUEUE_SEQ``, "
"``TCP_REPAIR_OPTIONS``, ``TCP_TIMESTAMP``, ``TCP_CC_INFO``, "
"``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, ``TCP_REPAIR_WINDOW``, "
"``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, ``TCP_MD5SIG_EXT``, "
"``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, "
"``TCP_ZEROCOPY_RECEIVE``, ``TCP_INQ``, ``TCP_TX_DELAY``. Added "
"``IP_PKTINFO``, ``IP_UNBLOCK_SOURCE``, ``IP_BLOCK_SOURCE``, "
"``IP_ADD_SOURCE_MEMBERSHIP``, ``IP_DROP_SOURCE_MEMBERSHIP``."
msgstr ""

#: ../../library/socket.rst:453
msgid ""
"Added ``SO_BINDTOIFINDEX``. On Linux this constant can be used in the "
"same way that ``SO_BINDTODEVICE`` is used, but with the index of a "
"network interface instead of its name."
msgstr ""

#: ../../library/socket.rst:463 ../../library/socket.rst:544
#: ../../library/socket.rst:568
msgid ""
"Many constants of these forms, documented in the Linux documentation, are"
" also defined in the socket module."
msgstr "리눅스 설명서에 설명되어있는 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다."

#: ../../library/socket.rst:470
#, fuzzy
msgid "NetBSD support was added."
msgstr "윈도우 지원이 추가되었습니다."

#: ../../library/socket.rst:476
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN 프로토콜 패밀리에서 CAN_BCM은 브로드캐스트 관리자 (Broadcast Manager, BCM) 프로토콜입니다. 리눅스 "
"설명서에서 설명된 브로드캐스트 관리자 상수도 소켓 모듈에 정의되어 있습니다."

#: ../../library/socket.rst:483
msgid "The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ":data:`CAN_BCM_CAN_FD_FRAME` 플래그는 리눅스 >= 4.8 에서만 사용 가능합니다."

#: ../../library/socket.rst:489
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however,"
" you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"CAN_RAW 소켓에서 CAN FD 지원을 활성화합니다. 기본적으로 비활성화되어 있습니다. 여러분의 응용 프로그램이 CAN과 CAN"
" FD 프레임을 모두 보낼 수 있도록 합니다; 그러나 소켓에서 읽을 때 CAN과 CAN FD 프레임을 모두 받아들여야 합니다."

#: ../../library/socket.rst:493 ../../library/socket.rst:504
msgid "This constant is documented in the Linux documentation."
msgstr "이 상수는 리눅스 설명서에 설명되어 있습니다."

#: ../../library/socket.rst:501
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all "
"given CAN filters are passed to user space."
msgstr "주어진 모든 CAN 필터와 일치하는 CAN 프레임 만 사용자 공간으로 전달되도록 적용된 CAN 필터를 결합합니다."

#: ../../library/socket.rst:512
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) "
"protocol. ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN 프로토콜 패밀리의 CAN_ISOTP는 ISO-TP (ISO 15765-2) 프로토콜입니다. ISO-TP 상수는 리눅스 "
"설명서에 설명되어 있습니다."

#: ../../library/socket.rst:521
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr "CAN 프로토콜 패밀리의 CAN_J1939는 SAE J1939 프로토콜입니다. J1939 상수는 리눅스 설명서에 설명되어 있습니다."

#: ../../library/socket.rst:532
#, fuzzy
msgid ""
"These two constants, documented in the FreeBSD divert(4) manual page, are"
" also defined in the socket module."
msgstr "리눅스 설명서에 설명되어있는 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다."

#: ../../library/socket.rst:552
msgid ""
":data:`!ETH_P_ALL` can be used in the :class:`~socket.socket` constructor"
" as *proto* for the :const:`AF_PACKET` family in order to capture every "
"packet, regardless of protocol."
msgstr ""

#: ../../library/socket.rst:556
msgid "For more information, see the :manpage:`packet(7)` manpage."
msgstr ""

#: ../../library/socket.rst:581
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to"
" the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"윈도우 WSAIoctl()용 상수. 이 상수는 소켓 객체의 :meth:`~socket.socket.ioctl` 메서드에 대한 인자로"
" 사용됩니다."

#: ../../library/socket.rst:584 ../../library/socket.rst:1608
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH``\\가 추가되었습니다."

#: ../../library/socket.rst:590
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. "
"See the TIPC documentation for more information."
msgstr "TIPC 관련 상수. C 소켓 API에서 내보낸 것과 일치합니다. 자세한 정보는 TIPC 설명서를 참조하십시오."

#: ../../library/socket.rst:597
msgid "Constants for Linux Kernel cryptography."
msgstr "리눅스 커널 암호화용 상수."

#: ../../library/socket.rst:609
msgid "Constants for Linux host/guest communication."
msgstr "리눅스 호스트/게스트 통신용 상수."

#: ../../library/socket.rst:623
msgid ""
"This constant contains a boolean value which indicates if IPv6 is "
"supported on this platform."
msgstr "이 상수는 이 플랫폼에서 IPv6가 지원되는지를 나타내는 논릿값을 포함합니다."

#: ../../library/socket.rst:629
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"이들은 특수한 의미를 지닌 블루투스 주소를 포함하는 문자열 상수입니다. 예를 들어, :const:`BDADDR_ANY`\\는 바인딩"
" 소켓을 :const:`BTPROTO_RFCOMM`\\로 지정할 때 임의의(any) 주소를 나타내는 데 사용할 수 있습니다."

#: ../../library/socket.rst:638
#, fuzzy
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`!HCI_FILTER` is only available"
" on Linux and FreeBSD. :const:`!HCI_TIME_STAMP` and "
":const:`!HCI_DATA_DIR` are only available on Linux."
msgstr ""
":const:`BTPROTO_HCI`\\와 함께 사용하십시오. NetBSD 나 DragonFlyBSD에서는 "
":const:`HCI_FILTER`\\를 사용할 수 없습니다. :const:`HCI_TIME_STAMP`\\와 "
":const:`HCI_DATA_DIR`\\는 FreeBSD, NetBSD 또는 DragonFlyBSD에서 사용할 수 없습니다."

#: ../../library/socket.rst:644
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr "원격 프로세서를 제공하는 서비스와 통신하는 데 사용되는 Qualcomm의 IPC 라우터 프로토콜용 상수."

#: ../../library/socket.rst:653
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""

#: ../../library/socket.rst:666
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with "
":data:`SO_REUSEPORT`."
msgstr ""

#: ../../library/socket.rst:686
#, fuzzy
msgid "Constants for Windows Hyper-V sockets for host/guest communications."
msgstr "리눅스 호스트/게스트 통신용 상수."

#: ../../library/socket.rst:699
msgid ""
"`IEEE 802.3 protocol number "
"<https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.txt>`_."
" constants."
msgstr ""

#: ../../library/socket.rst:711
#, fuzzy
msgid ""
"These constants are used by the :meth:`~socket.socket.shutdown` method of"
" socket objects."
msgstr ""
"윈도우 WSAIoctl()용 상수. 이 상수는 소켓 객체의 :meth:`~socket.socket.ioctl` 메서드에 대한 인자로"
" 사용됩니다."

#: ../../library/socket.rst:716
msgid "Functions"
msgstr "함수"

#: ../../library/socket.rst:719
msgid "Creating sockets"
msgstr "소켓 만들기"

#: ../../library/socket.rst:721
msgid "The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "다음 함수는 모두 :ref:`소켓 객체 <socket-objects>`\\를 만듭니다."

#: ../../library/socket.rst:726
msgid ""
"Create a new socket using the given address family, socket type and "
"protocol number.  The address family should be :const:`AF_INET` (the "
"default), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, "
":const:`AF_PACKET`, or :const:`AF_RDS`. The socket type should be "
":const:`SOCK_STREAM` (the default), :const:`SOCK_DGRAM`, "
":const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` constants. The "
"protocol number is usually zero and may be omitted or in the case where "
"the address family is :const:`AF_CAN` the protocol should be one of "
":const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or "
":const:`CAN_J1939`."
msgstr ""
"지정된 주소 패밀리, 소켓 유형, 및 프로토콜 번호를 사용하여 새로운 소켓을 만듭니다. 주소 패밀리는 :const:`AF_INET`"
" (기본값), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, "
":const:`AF_PACKET` 또는 :const:`AF_RDS` 여야 합니다. 소켓 유형은 :const:`SOCK_STREAM`"
" (기본값), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` 또는 기타 ``SOCK_`` 상수 중 하나여야 "
"합니다. 프로토콜 번호는 일반적으로 0이며 생략될 수도 있고, 주소 패밀리가 :const:`AF_CAN` 일 때 프로토콜은 "
":const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` 또는 "
":const:`CAN_J1939` 중 하나여야 합니다."

#: ../../library/socket.rst:736
#, fuzzy
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* "
"are auto-detected from the specified file descriptor.  Auto-detection can"
" be overruled by calling the function with explicit *family*, *type*, or "
"*proto* arguments.  This only affects how Python represents e.g. the "
"return value of :meth:`socket.getpeername` but not the actual OS "
"resource.  Unlike :func:`socket.fromfd`, *fileno* will return the same "
"socket and not a duplicate. This may help close a detached socket using "
":meth:`socket.close`."
msgstr ""
"*fileno*\\를 지정하면, *family*, *type* 및 *proto* 값이 지정된 파일 기술자에서 자동 감지됩니다. "
"명시적 *family*, *type* 또는 *proto* 인자를 사용하여 함수를 호출하면 자동 감지가 무효화 될 수 있습니다. 이는"
" 파이썬이 :meth:`socket.getpeername`\\의 반환 값을 나타내는 방식에 영향을 미치지만, 실제 OS 자원에는 "
"영향을 주지 않습니다. :func:`socket.fromfd`\\와는 달리, *fileno*\\는 복제본이 아니라 같은 소켓을 "
"반환합니다. 이렇게 하면 :meth:`socket.close()`\\를 사용하여 분리된 소켓을 닫을 수 있습니다."

#: ../../library/socket.rst:745 ../../library/socket.rst:891
#: ../../library/socket.rst:1427 ../../library/socket.rst:1521
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "새로 만들어진 소켓은 :ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/socket.rst:747
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with "
"arguments ``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"``self``, ``family``, ``type``, ``protocol``\\를 인자로 :ref:`감사 이벤트(auditing"
" event) <auditing>` ``socket.__new__``\\를 발생시킵니다."

#: ../../library/socket.rst:749
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "AF_CAN 패밀리가 추가되었습니다. AF_RDS 패밀리가 추가되었습니다."

#: ../../library/socket.rst:753
msgid "The CAN_BCM protocol was added."
msgstr "CAN_BCM 프로토콜이 추가되었습니다."

#: ../../library/socket.rst:756 ../../library/socket.rst:893
msgid "The returned socket is now non-inheritable."
msgstr "반환된 소켓은 이제 상속 불가능합니다."

#: ../../library/socket.rst:759
msgid "The CAN_ISOTP protocol was added."
msgstr "CAN_ISOTP 프로토콜이 추가되었습니다."

#: ../../library/socket.rst:762
#, fuzzy
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are "
"applied to *type* they are cleared, and :attr:`socket.type` will not "
"reflect them.  They are still passed to the underlying system "
"``socket()`` call.  Therefore,"
msgstr ""
":const:`SOCK_NONBLOCK` 이나 :const:`SOCK_CLOEXEC` 비트 플래그가 *type*\\에 적용되면, "
"이것들은 지워지고, :attr:`socket.type`\\는 이를 반영하지 않습니다. 이것들은 여전히 하부 시스템 "
"`socket()` 호출로 전달됩니다. 따라서,"

#: ../../library/socket.rst:770
msgid ""
"sock = socket.socket(\n"
"    socket.AF_INET,\n"
"    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)"
msgstr ""

#: ../../library/socket.rst:774
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to "
"``socket.SOCK_STREAM``."
msgstr ""
"는 여전히 ``SOCK_NONBLOCK``\\를 지원하는 OS에서 비 블로킹 소켓을 만들지만, ``sock.type``\\은 "
"``socket.SOCK_STREAM``\\로 설정됩니다."

#: ../../library/socket.rst:778
msgid "The CAN_J1939 protocol was added."
msgstr "CAN_J1939 프로토콜이 추가되었습니다."

#: ../../library/socket.rst:781
#, fuzzy
msgid "The IPPROTO_MPTCP protocol was added."
msgstr "CAN_ISOTP 프로토콜이 추가되었습니다."

#: ../../library/socket.rst:786
#, fuzzy
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and "
"protocol number are as for the :func:`~socket.socket` function above. The"
" default family is :const:`AF_UNIX` if defined on the platform; "
"otherwise, the default is :const:`AF_INET`."
msgstr ""
"제공된 주소 패밀리, 소켓 유형 및 프로토콜 번호를 사용하여 연결된 소켓 객체 쌍을 만듭니다. 주소 패밀리, 소켓 유형 및 프로토콜"
" 번호는 위의 :func:`.socket` 함수와 같습니다. 플랫폼에서 정의되어 있으면 기본 패밀리는 "
":const:`AF_UNIX`\\입니다; 그렇지 않으면 기본값은 :const:`AF_INET`\\입니다."

#: ../../library/socket.rst:791
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "새로 만들어진 소켓은 :ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/socket.rst:793
msgid ""
"The returned socket objects now support the whole socket API, rather than"
" a subset."
msgstr "반환된 소켓 객체는 이제 부분 집합이 아닌 전체 소켓 API를 지원합니다."

#: ../../library/socket.rst:797
msgid "The returned sockets are now non-inheritable."
msgstr "반환된 소켓은 이제 상속 불가능합니다."

#: ../../library/socket.rst:800
msgid "Windows support added."
msgstr "윈도우 지원이 추가되었습니다."

#: ../../library/socket.rst:806
#, fuzzy
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric "
"hostname, it will try to resolve it for both :data:`AF_INET` and "
":data:`AF_INET6`, and then try to connect to all possible addresses in "
"turn until a connection succeeds.  This makes it easy to write clients "
"that are compatible to both IPv4 and IPv6."
msgstr ""
"인터넷 *address*\\(2-튜플 ``(host, port)``)에서 리스닝하는 TCP 서비스에 연결하고 소켓 객체를 "
"반환합니다. 이것은 :meth:`socket.connect` 보다 고수준 함수입니다: *host*\\가 숫자가 아닌 호스트 명이면,"
" :data:`AF_INET`\\과 :data:`AF_INET6` 모두로 결정하려고 시도한 다음, 연결이 성공할 때까지 차례대로 "
"모든 가능한 주소로 연결을 시도합니다. 이것은 IPv4 및 IPv6 모두에 호환되는 클라이언트를 쉽게 작성할 수 있도록 합니다."

#: ../../library/socket.rst:814
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the "
"socket instance before attempting to connect.  If no *timeout* is "
"supplied, the global default timeout setting returned by "
":func:`getdefaulttimeout` is used."
msgstr ""
"선택적 *timeout* 매개 변수를 전달하면 연결을 시도하기 전에 소켓 인스턴스의 시간제한을 설정합니다. *timeout*\\이 "
"제공되지 않으면, :func:`getdefaulttimeout`\\에 의해 반환된 전역 기본 시간제한 설정이 사용됩니다."

#: ../../library/socket.rst:819
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or "
"port are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"제공되면, *source_address*\\는 연결하기 전에 소켓이 소스 주소로 바인드 할 2-튜플 ``(host, port)`` "
"여야 합니다. 호스트나 포트가 각각 '' 나 0이면 OS 기본 동작이 사용됩니다."

#: ../../library/socket.rst:823
msgid ""
"When a connection cannot be created, an exception is raised. By default, "
"it is the exception from the last address in the list. If *all_errors* is"
" ``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""

#: ../../library/socket.rst:828
msgid "*source_address* was added."
msgstr "*source_address*\\가 추가되었습니다."

#: ../../library/socket.rst:831
#, fuzzy
msgid "*all_errors* was added."
msgstr "*source_address*\\가 추가되었습니다."

#: ../../library/socket.rst:837
#, fuzzy
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a "
"2-tuple ``(host, port)``) and returns the socket object."
msgstr "*address*\\(2-튜플 ``(host, port)``)에 바인드 된 TCP 소켓을 만들고 소켓 객체를 반환하는 편리 함수."

#: ../../library/socket.rst:840
#, fuzzy
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* "
"is the queue size passed to :meth:`socket.listen`; if not specified , a "
"default reasonable value is chosen. *reuse_port* dictates whether to set "
"the :data:`SO_REUSEPORT` socket option."
msgstr ""
"*family*\\는 :data:`AF_INET`\\이나 :data:`AF_INET6`\\여야 합니다. *backlog*\\는 "
":meth:`socket.listen`\\에 전달된 대기열 크기입니다; ``0``\\이면 기본값으로 합리적인 값이 선택됩니다. "
"*reuse_port*\\는 :data:`SO_REUSEPORT` 소켓 옵션을 설정할지를 나타냅니다."

#: ../../library/socket.rst:845
#, fuzzy
msgid ""
"If *dualstack_ipv6* is true, *family* is :data:`AF_INET6` and the "
"platform supports it the socket will be able to accept both IPv4 and IPv6"
" connections, else it will raise :exc:`ValueError`. Most POSIX platforms "
"and Windows are supposed to support this functionality. When this "
"functionality is enabled the address returned by "
":meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6"
" address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* "
"is false it will explicitly disable this functionality on platforms that "
"enable it by default (e.g. Linux). This parameter can be used in "
"conjunction with :func:`has_dualstack_ipv6`:"
msgstr ""
"*dualstack_ipv6*\\가 참이고 플랫폼이 이를 지원하면, 소켓은 IPv4와 IPv6 연결을 모두 받아들일 수 있습니다, "
"그렇지 않으면 :exc:`ValueError`\\가 발생합니다. 대부분의 POSIX 플랫폼과 윈도우는 이 기능을 지원한다고 "
"여겨집니다. 이 기능이 활성화되면, IPv4 연결이 이루어질 때 :meth:`socket.getpeername`\\이 반환하는 "
"주소는 IPv4-매핑된 IPv6 주소로 표현된 IPv6 주소가 됩니다. *dualstack_ipv6*\\가 거짓이면, 기본적으로 이"
" 기능을 활성화하는 플랫폼에서 (예를 들어, 리눅스), 이 기능을 명시적으로 비활성화합니다. 이 매개 변수는 "
":func:`has_dualstack_ipv6`\\와 함께 사용할 수 있습니다:"

#: ../../library/socket.rst:858
msgid ""
"import socket\n"
"\n"
"addr = (\"\", 8080)  # all interfaces, port 8080\n"
"if socket.has_dualstack_ipv6():\n"
"    s = socket.create_server(addr, family=socket.AF_INET6, "
"dualstack_ipv6=True)\n"
"else:\n"
"    s = socket.create_server(addr)"
msgstr ""

#: ../../library/socket.rst:867
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order"
" to immediately reuse previous sockets which were bound on the same "
"*address* and remained in TIME_WAIT state."
msgstr ""
"POSIX 플랫폼에서 :data:`SO_REUSEADDR` 소켓 옵션은 같은 *address*\\에 바인드 되었고 TIME_WAIT"
" 상태로 남아 있던 이전 소켓을 즉시 재사용하기 위해 설정됩니다."

#: ../../library/socket.rst:875
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr "플랫폼이 IPv4와 IPv6 연결을 모두 처리할 수 있는 TCP 소켓을 만드는 것을 지원하면 ``True``\\를 반환합니다."

#: ../../library/socket.rst:882
#, fuzzy
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`~io.IOBase.fileno` method) and build a socket object from"
" the result.  Address family, socket type and protocol number are as for "
"the :func:`~socket.socket` function above. The file descriptor should "
"refer to a socket, but this is not checked --- subsequent operations on "
"the object may fail if the file descriptor is invalid. This function is "
"rarely needed, but can be used to get or set socket options on a socket "
"passed to a program as standard input or output (such as a server started"
" by the Unix inet daemon).  The socket is assumed to be in blocking mode."
msgstr ""
"파일 기술자 *fd*\\(파일 객체의 :meth:`fileno` 메서드에서 반환된 정수)를 복제하고 결과로 소켓 객체를 만듭니다. "
"주소 패밀리, 소켓 유형 및 프로토콜 번호는 위의 :func:`.socket` 함수와 같습니다. 파일 기술자는 소켓을 참조해야 "
"하지만, 검사하지는 않습니다 --- 파일 기술자가 유효하지 않으면 객체에 대한 후속 연산이 실패할 수 있습니다. 이 함수는 거의 "
"필요하지 않지만, 프로그램에 표준 입력이나 출력으로 프로그램에 전달된 (가령 유닉스 inet 데몬으로 시작한 서버) 소켓의 소켓 "
"옵션을 가져오거나 설정하는 데 사용할 수 있습니다. 소켓은 블로킹 모드로 간주합니다."

#: ../../library/socket.rst:899
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ":meth:`socket.share` 메서드에서 얻은 데이터로 소켓의 인스턴스를 만듭니다. 소켓은 블로킹 모드로 간주합니다."

#: ../../library/socket.rst:909
msgid ""
"This is a Python type object that represents the socket object type. It "
"is the same as ``type(socket(...))``."
msgstr "이것은 소켓 객체 형을 나타내는 파이썬 형 객체입니다. ``type(socket(...))``\\과 같습니다."

#: ../../library/socket.rst:914
msgid "Other functions"
msgstr "기타 함수"

#: ../../library/socket.rst:916
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ":mod:`socket` 모듈은 또한 다양한 네트워크 관련 서비스를 제공합니다:"

#: ../../library/socket.rst:921
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` "
"does not work for socket file descriptors."
msgstr ""
"소켓 파일 기술자를 닫습니다. 이것은 :func:`os.close`\\와 비슷하지만, 소켓 용입니다. 일부 플랫폼(가장 눈에 띄는 "
"것은 윈도우)에서는 :func:`os.close`\\가 소켓 파일 기술자에 대해 작동하지 않습니다."

#: ../../library/socket.rst:929
msgid ""
"This function wraps the C function ``getaddrinfo`` of the underlying "
"system."
msgstr ""

#: ../../library/socket.rst:931
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to "
"that service. *host* is a domain name, a string representation of an "
"IPv4/v6 address or ``None``. *port* is a string service name such as "
"``'http'``, a numeric port number or ``None``.  By passing ``None`` as "
"the value of *host* and *port*, you can pass ``NULL`` to the underlying C"
" API."
msgstr ""
"*host*/*port* 인자를 해당 서비스에 연결된 소켓을 만드는 데 필요한 모든 인자가 들어있는 5-튜플의 시퀀스로 변환합니다."
" *host*\\는 도메인 이름, IPv4/v6 주소의 문자열 표현 또는 ``None``\\입니다. *port*\\는 "
"``'http'``\\와 같은 문자열 서비스 이름, 숫자 포트 번호 또는 ``None``\\입니다. ``None``\\을 "
"*host* 와 *port*\\의 값으로 전달해서, ``NULL``\\을 하부 C API에 전달할 수 있습니다."

#: ../../library/socket.rst:938
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in"
" order to provide options and limit the list of addresses returned. Pass "
"their default values (:data:`AF_UNSPEC`, 0, and 0, respectively) to not "
"limit the results. See the note below for details."
msgstr ""

#: ../../library/socket.rst:943
#, fuzzy
msgid ""
"The *flags* argument can be one or several of the ``AI_*`` constants, and"
" will influence how results are computed and returned. For example, "
":const:`AI_NUMERICHOST` will disable domain name resolution and will "
"raise an error if *host* is a domain name."
msgstr ""
"*family*, *type* 및 *proto* 인자는 선택적으로 지정되어 반환된 주소 목록을 축소합니다. 이 인자 각각에 대한 "
"값으로 0을 전달하면 전체 결과 범위가 선택됩니다. *flags* 인자는 ``AI_*`` 상수 중 하나 또는 여러 개일 수 있으며,"
" 결과가 계산되고 반환되는 방식에 영향을 줍니다. 예를 들어, :const:`AI_NUMERICHOST`\\는 도메인 이름 결정을 "
"비활성화하고, *host*\\가 도메인 이름이면 에러를 발생시킵니다."

#: ../../library/socket.rst:948
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "이 함수는 다음과 같은 구조의 5-튜플의 리스트를 반환합니다:"

#: ../../library/socket.rst:950
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:952
#, fuzzy
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant"
" to be passed to the :func:`~socket.socket` function.  *canonname* will "
"be a string representing the canonical name of the *host* if "
":const:`AI_CANONNAME` is part of the *flags* argument; else *canonname* "
"will be empty.  *sockaddr* is a tuple describing a socket address, whose "
"format depends on the returned *family* (a ``(address, port)`` 2-tuple "
"for :const:`AF_INET`, a ``(address, port, flowinfo, scope_id)`` 4-tuple "
"for :const:`AF_INET6`), and is meant to be passed to the "
":meth:`socket.connect` method."
msgstr ""
"이 튜플에서, *family*, *type*, *proto*\\는 모두 정수이며 :func:`.socket` 함수로 전달됩니다. "
"*canonname*\\은 :const:`AI_CANONNAME`\\가 *flags* 인자의 일부일 때 *host*\\의 "
"규범적(canonical) 이름을 나타내는 문자열입니다; 그렇지 않으면 *canonname*\\가 비어 있습니다. "
"*sockaddr*\\은 반환된 *family*\\에 따라 형식이 달라지는, 소켓 주소를 설명하는 튜플이며 "
"(:const:`AF_INET`\\이면 ``(address, port)`` 2-튜플, :const:`AF_INET6`\\이면 "
"``(address, port, flowinfo, scope_id)`` 4-튜플), :meth:`socket.connect` "
"메서드로 전달됩니다."

#: ../../library/socket.rst:964
msgid ""
"If you intend to use results from :func:`!getaddrinfo` to create a socket"
" (rather than, for example, retrieve *canonname*), consider limiting the "
"results by *type* (e.g. :data:`SOCK_STREAM` or :data:`SOCK_DGRAM`) and/or"
" *proto* (e.g. :data:`IPPROTO_TCP` or :data:`IPPROTO_UDP`) that your "
"application can handle."
msgstr ""

#: ../../library/socket.rst:970
msgid ""
"The behavior with default values of *family*, *type*, *proto* and *flags*"
" is system-specific."
msgstr ""

#: ../../library/socket.rst:973
msgid ""
"Many systems (for example, most Linux configurations) will return a "
"sorted list of all matching addresses. These addresses should generally "
"be tried in order until a connection succeeds (possibly tried in "
"parallel, for example, using a `Happy Eyeballs`_ algorithm). In these "
"cases, limiting the *type* and/or *proto* can help eliminate unsuccessful"
" or unusable connection attempts."
msgstr ""

#: ../../library/socket.rst:980
msgid ""
"Some systems will, however, only return a single address. (For example, "
"this was reported on Solaris and AIX configurations.) On these systems, "
"limiting the *type* and/or *proto* helps ensure that this address is "
"usable."
msgstr ""

#: ../../library/socket.rst:985
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"``host``, ``port``, ``family``, ``type``, ``protocol``\\을 인자로 :ref:`감사 "
"이벤트(auditing event) <auditing>` ``socket.getaddrinfo``\\를 발생시킵니다."

#: ../../library/socket.rst:987
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your "
"system if IPv6 isn't enabled)::"
msgstr ""
"다음 예제는 ``example.org``\\의 포트 80으로 가는 가상의 TCP 연결에 대한 주소 정보를 가져옵니다 (IPv6가 "
"활성화되지 않았으면 여러분의 시스템에서는 결과가 다를 수 있습니다)::"

#: ../../library/socket.rst:991
msgid ""
">>> socket.getaddrinfo(\"example.org\", 80, proto=socket.IPPROTO_TCP)\n"
"[(socket.AF_INET6, socket.SOCK_STREAM,\n"
" 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),\n"
" (socket.AF_INET, socket.SOCK_STREAM,\n"
" 6, '', ('93.184.216.34', 80))]"
msgstr ""

#: ../../library/socket.rst:997
msgid "parameters can now be passed using keyword arguments."
msgstr "매개 변수는 이제 키워드 인자를 사용하여 전달할 수 있습니다."

#: ../../library/socket.rst:1000
#, python-format
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr "IPv6 멀티캐스트 주소의 경우, 주소를 나타내는 문자열에는 ``%scope_id`` 부분이 포함되지 않습니다."

#: ../../library/socket.rst:1008
#, fuzzy
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed"
" by aliases for the host, if available.  The first name which includes a "
"period is selected.  In case no fully qualified domain name is available "
"and *name* was provided, it is returned unchanged.  If *name* was empty "
"or equal to ``'0.0.0.0'``, the hostname from :func:`gethostname` is "
"returned."
msgstr ""
"*name*\\의 완전히 정규화된 도메인 이름을 반환합니다. *name*\\이 생략되거나 비어 있으면, 지역 호스트로 해석됩니다. "
"완전히 정규화된 이름을 찾기 위해, :func:`gethostbyaddr`\\에 의해 반환된 호스트 이름이 검사되고, 있다면 그 "
"호스트의 별칭이 뒤따릅니다. 마침표가 포함된 첫 번째 이름이 선택됩니다. 완전히 정규화된 도메인 이름이 없으면, "
":func:`gethostname`\\에서 반환된 호스트 이름이 반환됩니다."

#: ../../library/socket.rst:1019
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is "
"returned as a string, such as  ``'100.50.200.5'``.  If the host name is "
"an IPv4 address itself it is returned unchanged.  See "
":func:`gethostbyname_ex` for a more complete interface. "
":func:`gethostbyname` does not support IPv6 name resolution, and "
":func:`getaddrinfo` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"호스트 이름을 IPv4 주소 형식으로 변환합니다. IPv4 주소는 ``'100.50.200.5'``\\와 같은 문자열로 반환됩니다."
" 호스트 이름이 IPv4 주소면 변경되지 않고 반환됩니다. 더욱 완전한 인터페이스는 "
":func:`gethostbyname_ex`\\를 참조하십시오. :func:`gethostbyname`\\는 IPv6 이름 결정을 "
"지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 :func:`getaddrinfo`\\를 사용해야 합니다."

#: ../../library/socket.rst:1025 ../../library/socket.rst:1041
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"``hostname``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.gethostbyname``\\을 발생시킵니다."

#: ../../library/socket.rst:1032
#, fuzzy
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return "
"a 3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the "
"host's primary host name, *aliaslist* is a (possibly empty) list of "
"alternative host names for the same address, and *ipaddrlist* is a list "
"of IPv4 addresses for the same interface on the same host (often but not "
"always a single address). :func:`gethostbyname_ex` does not support IPv6 "
"name resolution, and :func:`getaddrinfo` should be used instead for "
"IPv4/v6 dual stack support."
msgstr ""
"호스트 이름을 IPv4 주소 형식으로 변환합니다, 확장 인터페이스. 트리플 ``(hostname, aliaslist, "
"ipaddrlist)``\\를 반환합니다. 여기서 *hostname*\\은 지정된 *ip_address*\\에 응답하는 기본 호스트"
" 이름이고, *aliaslist*\\는 같은 주소에 대한 대안 호스트 이름의 리스트(비어있을 수 있습니다)이며, "
"*ipaddrlist*\\는 같은 호스트의 같은 인터페이스에 대한 IPv4 주소 리스트입니다 (항상 그렇지는 않지만, 종종 단일 "
"주소). :func:`gethostbyname_ex`\\는 IPv6 이름 결정을 지원하지 않으며, IPv4/v6 이중 스택 지원을 "
"위해서는 대신 :func:`getaddrinfo`\\를 사용해야 합니다."

#: ../../library/socket.rst:1048
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr "파이썬 인터프리터가 현재 실행 중인 기계의 호스트 명을 포함한 문자열을 반환합니다."

#: ../../library/socket.rst:1051
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no"
" arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트(auditing event) <auditing>` ``socket.gethostname``\\을 "
"발생시킵니다."

#: ../../library/socket.rst:1053
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified "
"domain name; use :func:`getfqdn` for that."
msgstr ""
"참고: :func:`gethostname`\\은 항상 완전히 정규화된 도메인 이름을 반환하지는 않습니다; 원한다면 "
":func:`getfqdn`\\을 사용하십시오."

#: ../../library/socket.rst:1061
#, fuzzy
msgid ""
"Return a 3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* "
"is the primary host name responding to the given *ip_address*, "
"*aliaslist* is a (possibly empty) list of alternative host names for the "
"same address, and *ipaddrlist* is a list of IPv4/v6 addresses for the "
"same interface on the same host (most likely containing only a single "
"address). To find the fully qualified domain name, use the function "
":func:`getfqdn`. :func:`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"트리플 ``(hostname, aliaslist, ipaddrlist)``\\를 반환합니다. 여기서 *hostname*\\는 지정된"
" *ip_address*\\에 응답하는 기본 호스트 이름이고, *aliaslist*\\는 같은 주소에 대한 대체 호스트 이름의 "
"(비어있을 수 있는) 리스트이며, *ipaddrlist*\\는 같은 호스트의 같은 인터페이스에 대한 IPv4/v6 주소 리스트입니다"
" (대개 단일 주소만 포함합니다). 완전히 정규화된 도메인 이름을 찾으려면, :func:`getfqdn` 함수를 사용하십시오. "
":func:`gethostbyaddr`\\는 IPv4와 IPv6를 모두 지원합니다."

#: ../../library/socket.rst:1069
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"``ip_address``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.gethostbyaddr``\\을 발생시킵니다."

#: ../../library/socket.rst:1076
#, fuzzy
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port "
"number."
msgstr ""
"소켓 주소 *sockaddr*\\를 2-튜플 ``(host, port)``\\로 변환합니다. *flags*\\의 설정에 따라, "
"결과의 *host*\\에 완전히 정규화된 도메인 이름이나 숫자 주소 표현이 포함될 수 있습니다. 마찬가지로, *port*\\에는 "
"문자열 포트 이름이나 숫자 포트 번호가 포함될 수 있습니다."

#: ../../library/socket.rst:1081
#, python-format
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if "
"*sockaddr* contains meaningful *scope_id*. Usually this happens for "
"multicast addresses."
msgstr ""
"IPv6 주소의 경우, *sockaddr*\\에 의미 있는 *scope_id*\\가 있으면 ``%scope_id``\\를 host "
"부분에 덧붙입니다. 보통 이것은 멀티캐스트 주소에서 일어납니다."

#: ../../library/socket.rst:1084
msgid ""
"For more information about *flags* you can consult "
":manpage:`getnameinfo(3)`."
msgstr "*flags*\\에 대한 자세한 내용은 :manpage:`getnameinfo(3)`\\을 참조하십시오."

#: ../../library/socket.rst:1086
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"``sockaddr``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.getnameinfo``\\를 발생시킵니다."

#: ../../library/socket.rst:1093
#, fuzzy
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a "
"constant suitable for passing as the (optional) third argument to the "
":func:`~socket.socket` function.  This is usually only needed for sockets"
" opened in \"raw\" mode (:const:`SOCK_RAW`); for the normal socket modes,"
" the correct protocol is chosen automatically if the protocol is omitted "
"or zero."
msgstr ""
"인터넷 프로토콜 이름(예를 들어, ``'icmp'``)을 :func:`.socket` 함수의 (선택적인) 세 번째 인자로 전달하기에"
" 적합한 상수로 변환합니다. 이것은 일반적으로 \"원시\" 모드(:const:`SOCK_RAW`)로 열린 소켓에만 필요합니다; 일반"
" 소켓 모드에서는, 프로토콜이 생략되거나 0이면 올바른 프로토콜이 자동으로 선택됩니다."

#: ../../library/socket.rst:1104
#, fuzzy
msgid ""
"Translate an internet service name and protocol name to a port number for"
" that service.  The optional protocol name, if given, should be ``'tcp'``"
" or ``'udp'``, otherwise any protocol will match."
msgstr ""
"인터넷 서비스 이름과 프로토콜 이름을 해당 서비스의 포트 번호로 변환합니다. 선택적 프로토콜 이름은, 주어진다면, ``'tcp'``"
" 나 ``'udp'`` 여야 합니다, 그렇지 않으면 모든 프로토콜과 일치합니다."

#: ../../library/socket.rst:1108
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"``servicename``, ``protocolname``\\을 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``socket.getservbyname``\\을 발생시킵니다."

#: ../../library/socket.rst:1115
#, fuzzy
msgid ""
"Translate an internet port number and protocol name to a service name for"
" that service.  The optional protocol name, if given, should be ``'tcp'``"
" or ``'udp'``, otherwise any protocol will match."
msgstr ""
"인터넷 포트 번호와 프로토콜 이름을 해당 서비스의 서비스 이름으로 변환합니다. 선택적 프로토콜 이름은, 주어진다면, "
"``'tcp'`` 나 ``'udp'`` 여야 합니다, 그렇지 않으면 모든 프로토콜과 일치합니다."

#: ../../library/socket.rst:1119
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"``port``, ``protocolname``\\을 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``socket.getservbyport``\\를 발생시킵니다."

#: ../../library/socket.rst:1126
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, "
"this is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"32비트 양의 정수를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 "
"시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 4바이트 스와프 연산을 수행합니다."

#: ../../library/socket.rst:1133
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, "
"this is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"16비트 양의 정수를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 "
"시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 2바이트 스와프 연산을 수행합니다."

#: ../../library/socket.rst:1137 ../../library/socket.rst:1155
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned "
"integer."
msgstr ""

#: ../../library/socket.rst:1144
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, "
"this is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"32비트 양의 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 "
"시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 4바이트 스와프 연산을 수행합니다."

#: ../../library/socket.rst:1151
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, "
"this is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"16비트 양의 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 "
"시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 2바이트 스와프 연산을 수행합니다."

#: ../../library/socket.rst:1162
#, fuzzy
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that"
" uses the standard C library and needs objects of type "
":c:struct:`in_addr`, which is the C type for the 32-bit packed binary "
"this function returns."
msgstr ""
"IPv4 주소를 점 분리 쿼드 문자열 형식(예를 들어, '123.45.67.89')에서 길이가 4자인 바이트열 객체로 32비트 압축"
" 바이너리 형식으로 변환합니다. 이 함수는 표준 C 라이브러리를 사용하고 :c:type:`struct in_addr` 형(이 함수가"
" 반환하는 32비트 압축 바이너리의 C형입니다)의 객체를 요구하는 프로그램과 대화할 때 유용합니다."

#: ../../library/socket.rst:1168
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the"
" Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton`\\는 3점 미만의 문자열도 허용합니다; 자세한 내용은 유닉스 매뉴얼 페이지 "
":manpage:`inet(3)`\\을 참조하십시오."

#: ../../library/socket.rst:1171
msgid ""
"If the IPv4 address string passed to this function is invalid, "
":exc:`OSError` will be raised. Note that exactly what is valid depends on"
" the underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"이 함수에 전달된 IPv4 주소 문자열이 유효하지 않으면, :exc:`OSError`\\가 발생합니다. 정확히 무엇이 유효한지는 "
":c:func:`inet_aton`\\의 하부 C 구현에 따라 달라짐에 유의하십시오."

#: ../../library/socket.rst:1175
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton`\\은 IPv6를 지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 "
":func:`inet_pton`\\를 사용해야 합니다."

#: ../../library/socket.rst:1181
#, fuzzy
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four "
"bytes in length) to its standard dotted-quad string representation (for "
"example, '123.45.67.89').  This is useful when conversing with a program "
"that uses the standard C library and needs objects of type "
":c:struct:`in_addr`, which is the C type for the 32-bit packed binary "
"data this function takes as an argument."
msgstr ""
"32비트 압축 IPv4 주소(길이가 4바이트인 :term:`바이트열 객체 <bytes-like object>`)를 표준 점선 분리 "
"쿼드 문자열 표현(예를 들어, '123.45.67.89')으로 변환합니다. 이 함수는 표준 C 라이브러리를 사용하고 "
":c:type:`struct in_addr` 형(이 함수가 인자로 받아들이는 32비트 압축 바이너리 데이터의 C형입니다)의 객체를 "
"요구하는 프로그램과 대화할 때 유용합니다."

#: ../../library/socket.rst:1188
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support"
" IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"이 함수에 전달된 바이트 시퀀스가 정확히 4바이트 길이가 아니면, :exc:`OSError`\\가 발생합니다. "
":func:`inet_ntoa`\\는 IPv6를 지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 "
":func:`inet_ntop`\\를 사용해야 합니다."

#: ../../library/socket.rst:1199
#, fuzzy
msgid ""
"Convert an IP address from its family-specific string format to a packed,"
" binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to "
":func:`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"패밀리 특정 문자열 형식의 IP 주소를 압축 바이너리 형식으로 변환합니다. :func:`inet_pton`\\는 라이브러리나 "
"네트워크 프로토콜이 :c:type:`struct in_addr` 형(:func:`inet_aton`\\과 유사)이나 "
":c:type:`struct in6_addr` 형의 객체로 호출할 때 유용합니다."

#: ../../library/socket.rst:1204
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the IP address string *ip_string* is invalid, "
":exc:`OSError` will be raised. Note that exactly what is valid depends on"
" both the value of *address_family* and the underlying implementation of "
":c:func:`inet_pton`."
msgstr ""
"*address_family*\\에 대해 지원되는 값은 현재 :const:`AF_INET`\\과 "
":const:`AF_INET6`\\입니다. IP 주소 문자열 *ip_string*\\가 유효하지 않으면, "
":exc:`OSError`\\가 발생합니다. 정확히 무엇이 유효한지는 *address_family*\\의 값과 "
":c:func:`inet_pton`\\의 하부 구현에 따라 달라집니다."

#: ../../library/socket.rst:1212 ../../library/socket.rst:1232
msgid "Windows support added"
msgstr "윈도우 지원이 추가되었습니다"

#: ../../library/socket.rst:1218
#, fuzzy
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number "
"of bytes) to its standard, family-specific string representation (for "
"example, ``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful"
" when a library or network protocol returns an object of type "
":c:struct:`in_addr` (similar to :func:`inet_ntoa`) or "
":c:struct:`in6_addr`."
msgstr ""
"압축 IP 주소(일정 길이의 :term:`바이트열 객체 <bytes-like object>`)를 그것의 표준 패밀리 특정 문자열 "
"표현(예를 들어, ``'7.10.0.5'`` 나 ``'5aef:2b::8'``)으로 변환합니다. "
":func:`inet_ntop`\\는 라이브러리나 네트워크 프로토콜이 :c:type:`struct in_addr` "
"형(:func:`inet_ntoa`\\와 유사)이나 :c:type:`struct in6_addr` 형의 객체를 반환할 때 "
"유용합니다."

#: ../../library/socket.rst:1225
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and "
":const:`AF_INET6`. If the bytes object *packed_ip* is not the correct "
"length for the specified address family, :exc:`ValueError` will be "
"raised. :exc:`OSError` is raised for errors from the call to "
":func:`inet_ntop`."
msgstr ""
"*address_family*\\에 대해 지원되는 값은 현재 :const:`AF_INET`\\과 "
":const:`AF_INET6`\\입니다. 바이트열 객체 *packed_ip*\\가 지정된 주소 패밀리의 올바른 길이가 아니면, "
":exc:`ValueError`\\가 발생합니다. :func:`inet_ntop` 호출로 인한 에러에는 "
":exc:`OSError`\\가 발생합니다."

#: ../../library/socket.rst:1247
msgid ""
"Return the total length, without trailing padding, of an ancillary data "
"item with associated data of the given *length*.  This value can often be"
" used as the buffer size for :meth:`~socket.recvmsg` to receive a single "
"item of ancillary data, but :rfc:`3542` requires portable applications to"
" use :func:`CMSG_SPACE` and thus include space for padding, even when the"
" item will be the last in the buffer.  Raises :exc:`OverflowError` if "
"*length* is outside the permissible range of values."
msgstr ""
"주어진 *length*\\의 연관된 데이터가 있는 보조(ancillary) 데이터 항목의 (후행 패딩을 제외한) 총 길이를 "
"반환합니다. 이 값은 :meth:`~socket.recvmsg`\\가 보조 데이터의 단일 항목을 수신하기 위한 버퍼 크기로 종종 "
"사용될 수 있지만, :rfc:`3542`\\는 이식성 있는 응용 프로그램에서 :func:`CMSG_SPACE`\\를 사용하도록 "
"요구하는데, 항목이 버퍼의 마지막 부분일 때도 패딩을 위한 공간을 포함합니다. *length*\\가 허용되는 값 범위를 벗어나면 "
":exc:`OverflowError`\\를 발생시킵니다."

#: ../../library/socket.rst:1258 ../../library/socket.rst:1745
#: ../../library/socket.rst:1789 ../../library/socket.rst:1897
msgid "Most Unix platforms."
msgstr ""

#: ../../library/socket.rst:1265
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along "
"with any trailing padding.  The buffer space needed to receive multiple "
"items is the sum of the :func:`CMSG_SPACE` values for their associated "
"data lengths.  Raises :exc:`OverflowError` if *length* is outside the "
"permissible range of values."
msgstr ""
"주어진 *length*\\의 연관된 데이터가 있는 보조(ancillary) 데이터 항목을 수신하기 위해 "
":meth:`~socket.recvmsg`\\에 필요한 버퍼 크기를 반환하는데, 후행 패딩을 포함합니다. 여러 항목을 수신하는 데 "
"필요한 버퍼 공간은 연관된 데이터 길이에 대한 :func:`CMSG_SPACE` 값의 합입니다. *length*\\가 허용되는 값 "
"범위를 벗어나면 :exc:`OverflowError`\\를 발생시킵니다."

#: ../../library/socket.rst:1273
msgid ""
"Note that some systems might support ancillary data without providing "
"this function.  Also note that setting the buffer size using the results "
"of this function may not precisely limit the amount of ancillary data "
"that can be received, since additional data may be able to fit into the "
"padding area."
msgstr ""
"일부 시스템에서는 이 함수를 제공하지 않으면서 보조(ancillary) 데이터를 지원할 수 있음에 유의하십시오. 또한, 이 함수의 "
"결과를 사용하여 버퍼 크기를 설정하면 수신할 수 있는 보조 데이터의 양이 정확하게 제한되지 않을 수 있음에도 유의하십시오. 추가 "
"데이터가 패딩 영역에 들어갈 수 있기 때문입니다."

#: ../../library/socket.rst:1281
msgid "most Unix platforms."
msgstr ""

#: ../../library/socket.rst:1288
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When"
" the socket module is first imported, the default is ``None``."
msgstr ""
"새로운 소켓 객체의 기본 시간제한을 초 단위로 (float) 반환합니다. ``None`` 값은 새 소켓 객체가 시간제한이 없음을 "
"나타냅니다. 소켓 모듈을 처음 임포트 할 때 기본값은 ``None``\\입니다."

#: ../../library/socket.rst:1295
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When "
"the socket module is first imported, the default is ``None``.  See "
":meth:`~socket.settimeout` for possible values and their respective "
"meanings."
msgstr ""
"새 소켓 객체의 기본 시간제한을 초 단위로 (float) 설정합니다. 소켓 모듈을 처음 임포트 할 때 기본값은 "
"``None``\\입니다. 가능한 값과 해당 의미는 :meth:`~socket.settimeout`\\을 참조하십시오."

#: ../../library/socket.rst:1303
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` "
"if you don't have enough rights."
msgstr "기계의 호스트 명을 *name*\\으로 설정합니다. 충분한 권한이 없으면 :exc:`OSError`\\가 발생합니다."

#: ../../library/socket.rst:1306
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"``name``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.sethostname``\\을 발생시킵니다."

#: ../../library/socket.rst:1315
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"네트워크 인터페이스 정보 (인덱스 정수, 이름 문자열) 튜플의 리스트를 반환합니다. 시스템 호출이 실패하면 "
":exc:`OSError`."

#: ../../library/socket.rst:1323 ../../library/socket.rst:1350
#: ../../library/socket.rst:1367
msgid "Windows support was added."
msgstr "윈도우 지원이 추가되었습니다."

#: ../../library/socket.rst:1328
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr "윈도우에서 네트워크 인터페이스는 다른 문맥에서 다른 이름을 갖습니다 (모든 이름은 예입니다):"

#: ../../library/socket.rst:1331
#, python-brace-format
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../../library/socket.rst:1332
msgid "name: ``ethernet_32770``"
msgstr "이름: ``ethernet_32770``"

#: ../../library/socket.rst:1333
msgid "friendly name: ``vEthernet (nat)``"
msgstr "친숙한 이름: ``vEthernet (nat)``"

#: ../../library/socket.rst:1334
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "설명: ``Hyper-V Virtual Ethernet Adapter``"

#: ../../library/socket.rst:1336
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr "이 함수는 목록에서 두 번째 형식의 이름을 반환합니다, 이 예의 경우 ``ethernet_32770``."

#: ../../library/socket.rst:1342
msgid ""
"Return a network interface index number corresponding to an interface "
"name. :exc:`OSError` if no interface with the given name exists."
msgstr ""
"인터페이스 이름에 대응하는 네트워크 인터페이스 인덱스 번호를 반환합니다. 주어진 이름을 가진 인터페이스가 없으면 "
":exc:`OSError`."

#: ../../library/socket.rst:1354 ../../library/socket.rst:1371
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr "\"인터페이스 이름\"은 :func:`if_nameindex`\\에 설명된 이름입니다."

#: ../../library/socket.rst:1359
msgid ""
"Return a network interface name corresponding to an interface index "
"number. :exc:`OSError` if no interface with the given index exists."
msgstr ""
"인터페이스 인덱스 번호에 해당하는 네트워크 인터페이스 이름을 반환합니다. 지정된 인덱스의 인터페이스가 없으면 "
":exc:`OSError`."

#: ../../library/socket.rst:1376
#, fuzzy
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult "
":meth:`~socket.sendmsg` for the documentation of these parameters."
msgstr ""
":const:`AF_UNIX` 소켓을 통해 파일 기술자의 리스트 *fds*\\를 전송합니다. *fds* 매개 변수는 파일 "
"디스크립터의 시퀀스입니다. 이 매개 변수에 대한 설명서는 :meth:`sendmsg`\\를 참조하십시오."

#: ../../library/socket.rst:1382 ../../library/socket.rst:1396
#, fuzzy
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS`"
" mechanism."
msgstr ""
":ref:`가용성 <availability>`: :meth:`~socket.sendmsg`\\와 :const:`SCM_RIGHTS`"
" 메커니즘을 지원하는 유닉스."

#: ../../library/socket.rst:1390
#, fuzzy
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult "
":meth:`~socket.recvmsg` for the documentation of these parameters."
msgstr ""
"최대 *maxfds* 파일 기술자를 수신합니다. ``(msg, list(fds), flags, addr)``\\를 반환합니다. 이 "
"매개 변수에 대한 설명서는 :meth:`recvmsg`\\를 참조하십시오."

#: ../../library/socket.rst:1403
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "파일 기술자 리스트 끝에 있는 모든 잘린 정수."

#: ../../library/socket.rst:1409
msgid "Socket Objects"
msgstr "소켓 객체"

#: ../../library/socket.rst:1411
msgid ""
"Socket objects have the following methods.  Except for "
":meth:`~socket.makefile`, these correspond to Unix system calls "
"applicable to sockets."
msgstr ""
"소켓 객체에는 다음과 같은 메서드가 있습니다. :meth:`~socket.makefile`\\를 제외하고, 이것들은 소켓에 적용할 "
"수 있는 유닉스 시스템 호출에 해당합니다."

#: ../../library/socket.rst:1415
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
":term:`컨텍스트 관리자 <context manager>` 프로토콜 지원이 추가되었습니다. 컨텍스트 관리자를 빠져나가는 것은 "
":meth:`~socket.close`\\를 호출하는 것과 동등합니다."

#: ../../library/socket.rst:1422
msgid ""
"Accept a connection. The socket must be bound to an address and listening"
" for connections. The return value is a pair ``(conn, address)`` where "
"*conn* is a *new* socket object usable to send and receive data on the "
"connection, and *address* is the address bound to the socket on the other"
" end of the connection."
msgstr ""
"연결을 받아들입니다. 소켓은 주소에 바인드되어 연결을 리스닝하고 있어야 합니다. 반환 값은 ``(conn, address)`` "
"쌍입니다. 여기서 *conn*\\는 연결에서 데이터를 보내고 받을 수 있는 *새로운* 소켓 객체이고, *address*\\는 연결의"
" 다른 끝에 있는 소켓에 바인드 된 주소입니다."

#: ../../library/socket.rst:1429 ../../library/socket.rst:1523
msgid "The socket is now non-inheritable."
msgstr "소켓은 이제 상속 불가능합니다."

#: ../../library/socket.rst:1432 ../../library/socket.rst:1658
#: ../../library/socket.rst:1672 ../../library/socket.rst:1749
#: ../../library/socket.rst:1822 ../../library/socket.rst:1841
#: ../../library/socket.rst:1858 ../../library/socket.rst:1903
msgid ""
"If the system call is interrupted and the signal handler does not raise "
"an exception, the method now retries the system call instead of raising "
"an :exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 :exc:`InterruptedError` "
"예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 :pep:`475`\\를 참조하십시오)."

#: ../../library/socket.rst:1440
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The"
" format of *address* depends on the address family --- see above.)"
msgstr ""
"소켓을 *address*\\에 바인드 합니다. 소켓은 이미 바인드 되어 있으면 안 됩니다. (*address*\\의 형식은 주소 "
"패밀리에 따라 다릅니다 --- 위를 보십시오.)"

#: ../../library/socket.rst:1443
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments"
" ``self``, ``address``."
msgstr ""
"``self``, ``address``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.bind``\\를 발생시킵니다."

#: ../../library/socket.rst:1450
#, fuzzy
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile` "
"are closed.  Once that happens, all future operations on the socket "
"object will fail. The remote end will receive no more data (after queued "
"data is flushed)."
msgstr ""
"소켓을 닫힌 상태로 표시합니다. 하부 시스템 자원(예를 들어, 파일 기술자)도 :meth:`makefile()`\\로 만든 모든 "
"파일 객체가 닫힐 때 닫힙니다. 일단 닫히면, 소켓 객체에 대한 이후의 모든 연산이 실패합니다. 원격 끝은 더는 데이터를 수신하지 "
"않게 됩니다 (계류 중인 데이터가 플러시 된 후에)."

#: ../../library/socket.rst:1456
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it "
"is recommended to :meth:`close` them explicitly, or to use a "
":keyword:`with` statement around them."
msgstr ""
"소켓은 가비지 수집될 때 자동으로 닫히지만, 명시적으로 :meth:`close`\\하거나 :keyword:`with` 문을 사용하는"
" 것이 좋습니다."

#: ../../library/socket.rst:1460
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying "
":c:func:`close` call is made."
msgstr "하부 :c:func:`close` 호출이 수행될 때 에러가 발생하면 이제 :exc:`OSError`\\가 발생합니다."

#: ../../library/socket.rst:1466
#, fuzzy
msgid ""
":meth:`close` releases the resource associated with a connection but does"
" not necessarily close the connection immediately.  If you want to close "
"the connection in a timely fashion, call :meth:`shutdown` before "
":meth:`close`."
msgstr ""
":meth:`close()`\\는 연결과 관련된 자원을 해제하지만, 반드시 연결을 즉시 닫을 필요는 없습니다. 적시에 연결을 "
"닫으려면, :meth:`close()` 전에 :meth:`shutdown()`\\을 호출하십시오."

#: ../../library/socket.rst:1474
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends"
" on the address family --- see above.)"
msgstr ""
"*address*\\에 있는 원격 소켓에 연결합니다. (*address*\\의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 "
"보십시오.)"

#: ../../library/socket.rst:1477
#, fuzzy
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or "
"has a timeout. For non-blocking sockets, the method raises an "
":exc:`InterruptedError` exception if the connection is interrupted by a "
"signal (or the exception raised by the signal handler)."
msgstr ""
"시그널로 연결이 인터럽트 되면, 메서드는 연결이 완료될 때까지 대기하거나, 시그널 처리기가 예외를 발생시키지 않고 소켓이 "
"블로킹하거나 시간제한이 있으면 :exc:`socket.timeout`\\을 발생시킵니다. 비 블로킹 소켓의 경우, 이 메서드는 "
"시그널로 연결이 인터럽트 되면 :exc:`InterruptedError` 예외(또는 시그널 처리기에서 발생한 예외)를 발생시킵니다."

#: ../../library/socket.rst:1484 ../../library/socket.rst:1504
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with "
"arguments ``self``, ``address``."
msgstr ""
"``self``, ``address``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.connect``\\를 발생시킵니다."

#: ../../library/socket.rst:1486
msgid ""
"The method now waits until the connection completes instead of raising an"
" :exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"연결이 시그널에 의해 인터럽트 되고, 시그널 처리기가 예외를 발생시키지 않고, 소켓이 블로킹하거나 시간제한을 가지면, 이 메서드는 "
"이제 :exc:`InterruptedError` 예외를 발생시키는 대신 연결이 완료될 때까지 대기합니다 (이유는 "
":pep:`475`\\를 참조하십시오)."

#: ../../library/socket.rst:1497
msgid ""
"Like ``connect(address)``, but return an error indicator instead of "
"raising an exception for errors returned by the C-level :c:func:`connect`"
" call (other problems, such as \"host not found,\" can still raise "
"exceptions).  The error indicator is ``0`` if the operation succeeded, "
"otherwise the value of the :c:data:`errno` variable.  This is useful to "
"support, for example, asynchronous connects."
msgstr ""
"``connect(address)``\\와 비슷하지만, C 수준의 :c:func:`connect` 호출로 반환된 에러에 대한 예외를"
" 발생시키는 대신 에러 표시기를 반환합니다 (\"호스트를 찾을 수 없음\"과 같은 다른 문제는 여전히 예외를 발생시킬 수 "
"있습니다). 연산이 성공하면 에러 표시기는 ``0``\\이고, 그렇지 않으면 :c:data:`errno` 변수의 값입니다. 예를 "
"들어 비동기 연결을 지원하는 데 유용합니다."

#: ../../library/socket.rst:1510
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"하부 파일 기술자를 실제로 닫지 않으면서 소켓 객체를 닫힌 상태로 만듭니다. 파일 기술자가 반환되고, 다른 용도로 재사용 될 수 "
"있습니다."

#: ../../library/socket.rst:1519
msgid "Duplicate the socket."
msgstr "소켓을 복제합니다."

#: ../../library/socket.rst:1531
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"소켓의 파일 기술자(작은 정수)를 반환하거나, 실패하면 -1을 반환합니다. 이것은 :func:`select.select`\\에서 "
"유용합니다."

#: ../../library/socket.rst:1534
msgid ""
"Under Windows the small integer returned by this method cannot be used "
"where a file descriptor can be used (such as :func:`os.fdopen`).  Unix "
"does not have this limitation."
msgstr ""
"윈도우에서, 이 메서드가 돌려주는 작은 정수는 파일 기술자를 사용할 수 있는 곳(가령 :func:`os.fdopen`)에 사용할 수"
" 없습니다. 유닉스에는 이러한 제한이 없습니다."

#: ../../library/socket.rst:1540
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in"
" child processes, ``False`` if it cannot."
msgstr ""
"소켓의 파일 기술자나 소켓 핸들의 :ref:`상속 가능 플래그 <fd_inheritance>`\\를 가져옵니다: 소켓이 자식 "
"프로세스에서 상속될 수 있으면 ``True``, 그렇지 않으면 ``False``."

#: ../../library/socket.rst:1549
msgid ""
"Return the remote address to which the socket is connected.  This is "
"useful to find out the port number of a remote IPv4/v6 socket, for "
"instance. (The format of the address returned depends on the address "
"family --- see above.)  On some systems this function is not supported."
msgstr ""
"소켓이 연결된 원격 주소를 반환합니다. 이것은 예를 들어, 원격 IPv4/v6 소켓의 포트 번호를 찾는 데 유용합니다. (반환되는 "
"주소의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.) 일부 시스템에서는 이 함수가 지원되지 않습니다."

#: ../../library/socket.rst:1557
msgid ""
"Return the socket's own address.  This is useful to find out the port "
"number of an IPv4/v6 socket, for instance. (The format of the address "
"returned depends on the address family --- see above.)"
msgstr ""
"소켓 자신의 주소를 반환합니다. 이것은 예를 들어 IPv4/v6 소켓의 포트 번호를 찾는 데 유용합니다. (반환되는 주소의 형식은 "
"주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)"

#: ../../library/socket.rst:1564
#, fuzzy
msgid ""
"Return the value of the given socket option (see the Unix man page "
":manpage:`getsockopt(2)`).  The needed symbolic constants (:ref:`SO_\\* "
"etc. <socket-unix-constants>`) are defined in this module.  If *buflen* "
"is absent, an integer option is assumed and its integer value is returned"
" by the function.  If *buflen* is present, it specifies the maximum "
"length of the buffer used to receive the option in, and this buffer is "
"returned as a bytes object.  It is up to the caller to decode the "
"contents of the buffer (see the optional built-in module :mod:`struct` "
"for a way to decode C structures encoded as byte strings)."
msgstr ""
"주어진 소켓 옵션의 값을 반환합니다 (유닉스 매뉴얼 페이지 :manpage:`getsockopt(2)`\\를 보십시오). 필요한 "
"기호 상수(:const:`SO_\\*` 등)는 이 모듈에서 정의됩니다. *buflen*\\이 없으면, 정수 옵션을 가정하고 해당 "
"정숫값이 함수에서 반환됩니다. *buflen*\\이 있으면, 옵션을 수신하는 데 사용되는 버퍼의 최대 길이를 지정하고, 이 버퍼가 "
"바이트열 객체로 반환됩니다. 버퍼의 내용을 디코딩하는 것은 호출자의 책임입니다 (바이트열로 인코딩된 C 구조체를 디코딩하는 방법은 "
"선택적 내장 모듈 :mod:`struct`\\를 참조하십시오)."

#: ../../library/socket.rst:1578
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-"
"blocking."
msgstr "소켓이 블로킹 모드면 ``True``\\를 반환하고, 비 블로킹이면 ``False``\\를 반환합니다."

#: ../../library/socket.rst:1581
#, fuzzy
msgid "This is equivalent to checking ``socket.gettimeout() != 0``."
msgstr "이것은 ``socket.gettimeout() == 0``\\를 검사하는 것과 동등합니다."

#: ../../library/socket.rst:1588
msgid ""
"Return the timeout in seconds (float) associated with socket operations, "
"or ``None`` if no timeout is set.  This reflects the last call to "
":meth:`setblocking` or :meth:`settimeout`."
msgstr ""
"소켓 연산에 관련한 시간제한을 초(float)로 돌려줍니다. 시간제한이 설정되어 있지 않으면 ``None``\\를 돌려줍니다. "
"이것은 :meth:`setblocking` 이나 :meth:`settimeout`\\에 대한 마지막 호출을 반영합니다."

#: ../../library/socket.rst
msgid "platform"
msgstr "플랫폼"

#: ../../library/socket.rst:1595
msgid "Windows"
msgstr "윈도우"

#: ../../library/socket.rst:1597
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ for"
" more information."
msgstr ""
":meth:`ioctl` 메서드는 WSAIoctl 시스템 인터페이스에 대한 제한된 인터페이스입니다. 자세한 내용은 `Win32 "
"설명서 <https://msdn.microsoft.com/en-"
"us/library/ms741621%28VS.85%29.aspx>`_\\를 참조하십시오."

#: ../../library/socket.rst:1602
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and "
":func:`fcntl.ioctl` functions may be used; they accept a socket object as"
" their first argument."
msgstr ""
"다른 플랫폼에서는, 범용 :func:`fcntl.fcntl` 과 :func:`fcntl.ioctl` 함수를 사용할 수 있습니다; 첫"
" 번째 인자로 소켓 객체를 받아들입니다."

#: ../../library/socket.rst:1605
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``,"
" ``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"현재 다음 제어 코드만 지원됩니다: ``SIO_RCVALL``, ``SIO_KEEPALIVE_VALS`` 및 "
"``SIO_LOOPBACK_FAST_PATH``."

#: ../../library/socket.rst:1613
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it "
"must be at least 0 (if it is lower, it is set to 0); it specifies the "
"number of unaccepted connections that the system will allow before "
"refusing new connections. If not specified, a default reasonable value is"
" chosen."
msgstr ""
"서버가 연결을 수락하도록 합니다. *backlog*\\가 지정되면, 0 이상이어야 합니다 (더 낮으면 0으로 설정됩니다); 새로운 "
"연결을 거부하기 전에 시스템이 허락할 수락되지 않은 연결 수를 지정합니다. 지정하지 않으면, 기본값으로 적당한 값이 선택됩니다."

#: ../../library/socket.rst:1620
msgid "The *backlog* parameter is now optional."
msgstr "이제 *backlog* 매개 변수가 선택적입니다."

#: ../../library/socket.rst:1629
#, fuzzy
msgid ""
"Return a :term:`file object` associated with the socket.  The exact "
"returned type depends on the arguments given to :meth:`makefile`.  These "
"arguments are interpreted the same way as by the built-in :func:`open` "
"function, except the only supported *mode* values are ``'r'`` (default), "
"``'w'``, ``'b'``, or a combination of those."
msgstr ""
"소켓과 결합한 :term:`파일 객체 <file object>`\\를 돌려줍니다. 정확한 반환형은 "
":meth:`makefile`\\에 주어진 인자에 따라 다릅니다. 이 인자는 내장 :func:`open` 함수와 같은 방식으로 "
"해석됩니다. 단, 지원되는 *mode* 값은 ``'r'`` (기본값), ``'w'`` 및 ``'b'`` 뿐입니다."

#: ../../library/socket.rst:1635
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout"
" occurs."
msgstr ""
"소켓은 블로킹 모드 여야 합니다; 시간제한을 가질 수 있지만, 시간 초과가 발생하면 파일 객체의 내부 버퍼가 일관성없는 상태로 끝날"
" 수 있습니다."

#: ../../library/socket.rst:1639
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and "
":meth:`socket.close` has been called on the socket object."
msgstr ""
":meth:`makefile`\\에 의해 반환된 파일 객체를 닫는 것은, 다른 모든 파일 객체가 닫혔고 소켓 객체에서 "
":meth:`socket.close`\\가 호출되었지 않은 한 원래 소켓을 닫지는 않습니다."

#: ../../library/socket.rst:1645
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be "
"used where a file object with a file descriptor is expected, such as the "
"stream arguments of :meth:`subprocess.Popen`."
msgstr ""
"윈도우에서, :meth:`makefile`\\로 만든 파일류 객체는 파일 기술자가 있는 파일 객체가 필요한 곳에서는 사용할 수 "
"없습니다, 가령 :meth:`subprocess.Popen`\\의 stream 인자."

#: ../../library/socket.rst:1652
#, fuzzy
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be "
"received at once is specified by *bufsize*. A returned empty bytes object"
" indicates that the client has disconnected. See the Unix manual page "
":manpage:`recv(2)` for the meaning of the optional argument *flags*; it "
"defaults to zero."
msgstr ""
"소켓에서 데이터를 수신합니다. 반환 값은 수신된 데이터를 나타내는 바이트열 객체입니다. 한 번에 수신할 수 있는 최대 데이터양은 "
"*bufsize*\\에 의해 지정됩니다. 선택적 인자 *flags*\\의 의미는 유닉스 매뉴얼 페이지 "
":manpage:`recv(2)`\\를 보십시오; 기본값은 0입니다."

#: ../../library/socket.rst:1666
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received"
" and *address* is the address of the socket sending the data.  See the "
"Unix manual page :manpage:`recv(2)` for the meaning of the optional "
"argument *flags*; it defaults to zero. (The format of *address* depends "
"on the address family --- see above.)"
msgstr ""
"소켓에서 데이터를 수신합니다. 반환 값은 ``(bytes, address)`` 쌍입니다. 여기서 *bytes*\\는 수신한 데이터를"
" 나타내는 바이트열 객체이고, *address*\\는 데이터를 보내는 소켓의 주소입니다. 선택적 인자 *flags*\\의 의미는 "
"유닉스 매뉴얼 페이지 :manpage:`recv(2)`\\를 보십시오; 기본값은 0입니다. (*address*\\의 형식은 주소 "
"패밀리에 따라 다릅니다 --- 위를 보십시오.)"

#: ../../library/socket.rst:1677
#, python-format
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use "
":func:`getnameinfo`."
msgstr ""
"멀티캐스트 IPv6 주소의 경우, *address*\\의 첫 번째 항목에는 ``%scope_id`` 부분이 더는 포함되지 않습니다."
" 전체 IPv6 주소를 얻으려면 :func:`getnameinfo`\\를 사용하십시오."

#: ../../library/socket.rst:1684
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal"
" buffer used to receive the ancillary data; it defaults to 0, meaning "
"that no ancillary data will be received.  Appropriate buffer sizes for "
"ancillary data can be calculated using :func:`CMSG_SPACE` or "
":func:`CMSG_LEN`, and items which do not fit into the buffer might be "
"truncated or discarded.  The *flags* argument defaults to 0 and has the "
"same meaning as for :meth:`recv`."
msgstr ""
"일반 데이터(최대 *bufsize* 바이트)와 보조(ancillary) 데이터를 소켓에서 수신합니다. *ancbufsize* 인자는"
" 보조 데이터 수신에 사용되는 내부 버퍼의 크기를 바이트 단위로 설정합니다; 기본값은 0이며 보조 데이터가 수신되지 않는다는 "
"뜻입니다. 보조 데이터를 위한 적절한 버퍼 크기는 :func:`CMSG_SPACE` 나 :func:`CMSG_LEN`\\를 사용하여"
" 계산할 수 있으며, 버퍼에 들어가지 않는 항목은 잘리거나 삭제될 수 있습니다. *flags* 인자의 기본값은 0이고 "
":meth:`recv`\\와 같은 의미입니다."

#: ../../library/socket.rst:1694
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  "
"The *data* item is a :class:`bytes` object holding the non-ancillary data"
" received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, "
"and *cmsg_data* is a :class:`bytes` object holding the associated data.  "
"The *msg_flags* item is the bitwise OR of various flags indicating "
"conditions on the received message; see your system documentation for "
"details. If the receiving socket is unconnected, *address* is the address"
" of the sending socket, if available; otherwise, its value is "
"unspecified."
msgstr ""
"반환 값은 4-튜플입니다: ``(data, ancdata, msg_flags, address)``. *data* 항목은 일반 "
"데이터를 담은 :class:`bytes` 객체입니다. *ancdata* 항목은 수신된 보조 데이터(제어 메시지)를 나타내는 0개 "
"이상의 튜플 ``(cmsg_level, cmsg_type, cmsg_data)``\\의 리스트입니다: *cmsg_level* 와 "
"*cmsg_type*\\는 각각 프로토콜 수준과 프로토콜 특정 형을 지정하는 정수이고, *cmsg_data*\\는 연결된 데이터를 "
"담은 :class:`bytes` 객체입니다. *msg_flags* 항목은 수신된 메시지의 조건을 나타내는 다양한 플래그의 비트별 "
"OR입니다; 자세한 내용은 시스템 설명서를 참조하십시오. 수신 소켓이 연결되어있지 않으면, *address*\\는 송신 소켓의 "
"주소입니다, (사용 가능하다면); 그렇지 않으면 값은 지정되지 않습니다."

#: ../../library/socket.rst:1708
#, fuzzy
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When"
" this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of "
"the form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is "
"a :class:`bytes` object representing the new file descriptors as a binary"
" array of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an "
"exception after the system call returns, it will first attempt to close "
"any file descriptors received via this mechanism."
msgstr ""
"일부 시스템에서는, :meth:`sendmsg`\\와 :meth:`recvmsg`\\를 사용하여 :const:`AF_UNIX` "
"소켓을 통해 프로세스 간에 파일 기술자를 전달할 수 있습니다. 이 기능을 사용하면 (:const:`SOCK_STREAM` 소켓으로 "
"제한되는 경우가 많습니다), :meth:`recvmsg`\\는 보조 데이터에서 ``(socket.SOL_SOCKET, "
"socket.SCM_RIGHTS, fds)`` 형식의 항목을 반환합니다. 여기서 *fds*\\는 새 파일 기술자를 네이티브 C "
":c:type:`int` 형의 바이너리 배열로 나타내는 :class:`bytes` 객체입니다. :meth:`recvmsg`\\가 "
"시스템 호출이 반환된 후에 예외를 발생시키면, 먼저 이 메커니즘을 통해 수신된 모든 파일 기술자를 닫으려고 시도합니다."

#: ../../library/socket.rst:1719
msgid ""
"Some systems do not indicate the truncated length of ancillary data items"
" which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a "
":exc:`RuntimeWarning`, and will return the part of it which is inside the"
" buffer provided it has not been truncated before the start of its "
"associated data."
msgstr ""
"일부 시스템은 부분적으로만 수신된 보조 데이터 항목의 절단 길이를 나타내지 않습니다. 항목이 버퍼의 끝을 넘어 확장된 것처럼 "
"보이면, :meth:`recvmsg`\\는 :exc:`RuntimeWarning`\\를 발생시키고, 관련 데이터의 시작 전에 "
"절단되지 않은 버퍼 내에 있는 부분을 반환합니다."

#: ../../library/socket.rst:1726
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following"
" function will receive up to *maxfds* file descriptors, returning the "
"message data and a list containing the descriptors (while ignoring "
"unexpected conditions such as unrelated control messages being received)."
"  See also :meth:`sendmsg`. ::"
msgstr ""
":const:`SCM_RIGHTS` 메커니즘을 지원하는 시스템에서, 다음 함수는 최대 *maxfds* 파일 기술자를 수신하여, "
"메시지 데이터와 기술자를 담은 리스트를 반환합니다 (관련 없는 수신되는 제어 메시지와 같은 예기치 않은 조건은 무시하면서). "
":meth:`sendmsg`\\를 참조하십시오. ::"

#: ../../library/socket.rst:1732
#, python-format
msgid ""
"import socket, array\n"
"\n"
"def recv_fds(sock, msglen, maxfds):\n"
"    fds = array.array(\"i\")   # Array of ints\n"
"    msg, ancdata, flags, addr = sock.recvmsg(msglen, "
"socket.CMSG_LEN(maxfds * fds.itemsize))\n"
"    for cmsg_level, cmsg_type, cmsg_data in ancdata:\n"
"        if cmsg_level == socket.SOL_SOCKET and cmsg_type == "
"socket.SCM_RIGHTS:\n"
"            # Append data, ignoring any truncated integers at the end.\n"
"            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % "
"fds.itemsize)])\n"
"    return msg, list(fds)"
msgstr ""

#: ../../library/socket.rst:1757
msgid ""
"Receive normal data and ancillary data from the socket, behaving as "
":meth:`recvmsg` would, but scatter the non-ancillary data into a series "
"of buffers instead of returning a new bytes object.  The *buffers* "
"argument must be an iterable of objects that export writable buffers "
"(e.g. :class:`bytearray` objects); these will be filled with successive "
"chunks of the non-ancillary data until it has all been written or there "
"are no more buffers.  The operating system may set a limit "
"(:func:`~os.sysconf` value ``SC_IOV_MAX``) on the number of buffers that "
"can be used.  The *ancbufsize* and *flags* arguments have the same "
"meaning as for :meth:`recvmsg`."
msgstr ""
":meth:`recvmsg`\\처럼 동작해서, 일반 데이터와 보조 데이터를 소켓에서 수신하지만, 새로운 바이트열 객체를 반환하는 "
"대신 일반 데이터를 일련의 버퍼로 분산시킵니다. *buffers* 인자는 쓰기 가능한 버퍼(예를 들어, "
":class:`bytearray` 객체)를 내보내는 객체의 이터러블이어야 합니다; 이것들은 모두 기록되었거나 버퍼가 더는 없을 "
"때까지 일반 데이터의 연속적인 덩어리로 채워질 것입니다. 운영 체제는 사용할 수 있는 버퍼 수에 "
"제한(:func:`~os.sysconf` 값 ``SC_IOV_MAX``)을 설정할 수 있습니다. *ancbufsize* 와 "
"*flags* 인자는 :meth:`recvmsg`\\와 같은 의미가 있습니다."

#: ../../library/socket.rst:1768
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``,"
" where *nbytes* is the total number of bytes of non-ancillary data "
"written into the buffers, and *ancdata*, *msg_flags* and *address* are "
"the same as for :meth:`recvmsg`."
msgstr ""
"반환 값은 4-튜플입니다: ``(nbytes, ancdata, msg_flags, address)``. 여기서 *nbytes*\\는"
" 버퍼에 기록된 일반 데이터의 총 바이트 수이며, *ancdata*, *msg_flags* 및 *address*\\는 "
":meth:`recvmsg`\\와 같습니다."

#: ../../library/socket.rst:1773
msgid "Example::"
msgstr "예제::"

#: ../../library/socket.rst:1775
msgid ""
">>> import socket\n"
">>> s1, s2 = socket.socketpair()\n"
">>> b1 = bytearray(b'----')\n"
">>> b2 = bytearray(b'0123456789')\n"
">>> b3 = bytearray(b'--------------')\n"
">>> s1.send(b'Mary had a little lamb')\n"
"22\n"
">>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])\n"
"(22, [], 0, None)\n"
">>> [b1, b2, b3]\n"
"[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little "
"lamb---')]"
msgstr ""

#: ../../library/socket.rst:1796
msgid ""
"Receive data from the socket, writing it into *buffer* instead of "
"creating a new bytestring.  The return value is a pair ``(nbytes, "
"address)`` where *nbytes* is the number of bytes received and *address* "
"is the address of the socket sending the data.  See the Unix manual page "
":manpage:`recv(2)` for the meaning of the optional argument *flags*; it "
"defaults to zero.  (The format of *address* depends on the address family"
" --- see above.)"
msgstr ""
"소켓에서 데이터를 수신하는데, 새로운 바이트열을 만드는 대신 *buffer*\\에 씁니다. 반환 값은 쌍 ``(nbytes, "
"address)``\\입니다. 여기서 *nbytes*\\는 수신 된 바이트 수이고, *address*\\는 데이터를 보내는 소켓의 "
"주소입니다. 선택적 인자 *flags*\\의 의미에 대해서는 유닉스 매뉴얼 페이지 :manpage:`recv(2)`\\를 보십시오;"
" 기본값은 0입니다. (*address*\\의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)"

#: ../../library/socket.rst:1806
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a "
"buffer rather than creating a new bytestring.  If *nbytes* is not "
"specified (or 0), receive up to the size available in the given buffer.  "
"Returns the number of bytes received.  See the Unix manual page "
":manpage:`recv(2)` for the meaning of the optional argument *flags*; it "
"defaults to zero."
msgstr ""
"소켓에서 최대 *nbytes* 바이트까지 수신하는데, 새 바이트열을 만드는 대신 데이터를 버퍼에 저장합니다. *nbytes*\\가 "
"지정되지 않으면 (또는 0), 지정된 버퍼에서 사용 가능한 크기까지 수신합니다. 수신 한 바이트 수를 반환합니다. 선택적 인자 "
"*flags*\\의 의미에 대해서는 유닉스 매뉴얼 페이지 :manpage:`recv(2)`\\를 보십시오; 기본값은 0입니다."

#: ../../library/socket.rst:1815
msgid ""
"Send data to the socket.  The socket must be connected to a remote "
"socket.  The optional *flags* argument has the same meaning as for "
":meth:`recv` above. Returns the number of bytes sent. Applications are "
"responsible for checking that all data has been sent; if only some of the"
" data was transmitted, the application needs to attempt delivery of the "
"remaining data. For further information on this topic, consult the :ref"
":`socket-howto`."
msgstr ""
"소켓에 데이터를 보냅니다. 소켓은 원격 소켓에 연결되어야 합니다. 선택적 *flags* 인자는 위의 :meth:`recv`\\와 "
"같은 의미입니다. 전송된 바이트 수를 반환합니다. 응용 프로그램은 모든 데이터가 전송되었는지 확인해야 합니다; 일부 데이터만 "
"전송되었으면, 응용 프로그램은 나머지 데이터의 전달을 시도해야 합니다. 이 주제에 대한 자세한 정보는, :ref:`socket-"
"howto`\\를 참조하십시오."

#: ../../library/socket.rst:1830
msgid ""
"Send data to the socket.  The socket must be connected to a remote "
"socket.  The optional *flags* argument has the same meaning as for "
":meth:`recv` above. Unlike :meth:`send`, this method continues to send "
"data from *bytes* until either all data has been sent or an error occurs."
"  ``None`` is returned on success.  On error, an exception is raised, and"
" there is no way to determine how much data, if any, was successfully "
"sent."
msgstr ""
"소켓에 데이터를 보냅니다. 소켓은 원격 소켓에 연결되어야 합니다. 선택적 *flags* 인자는 위의 :meth:`recv`\\와 "
"같은 의미입니다. :meth:`send`\\와 달리, 이 메서드는 모든 데이터가 전송되거나 에러가 발생할 때까지 *bytes*\\의"
" 데이터를 계속 전송합니다. 성공하면 ``None``\\이 반환됩니다. 에러가 발생하면, 예외가 발생하는데, 성공적으로 전송된 "
"데이터양을 (있기는 하다면) 확인하는 방법은 없습니다."

#: ../../library/socket.rst:1837
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time data is sent "
"successfully. The socket timeout is now the maximum total duration to "
"send all data."
msgstr ""
"소켓 시간제한은 데이터가 성공적으로 전송될 때마다 더는 재설정되지 않습니다. 소켓 시간제한은 이제 모든 데이터를 전송할 수 있는 "
"최대 총 지속 시간입니다."

#: ../../library/socket.rst:1850
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above."
"  Return the number of bytes sent. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"소켓에 데이터를 보냅니다. 대상 소켓이 *address*\\로 지정되므로, 소켓은 원격 소켓에 연결되지 않아야 합니다. 선택적 "
"*flags* 인자는 위의 :meth:`recv`\\와 같은 의미가 있습니다. 전송된 바이트 수를 반환합니다. "
"(*address*\\의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)"

#: ../../library/socket.rst:1856
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with "
"arguments ``self``, ``address``."
msgstr ""
"``self``, ``address``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.sendto``\\를 발생시킵니다."

#: ../../library/socket.rst:1866
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary"
" data from a series of buffers and concatenating it into a single "
"message.  The *buffers* argument specifies the non-ancillary data as an "
"iterable of :term:`bytes-like objects <bytes-like object>` (e.g. "
":class:`bytes` objects); the operating system may set a limit "
"(:func:`~os.sysconf` value ``SC_IOV_MAX``) on the number of buffers that "
"can be used.  The *ancdata* argument specifies the ancillary data "
"(control messages) as an iterable of zero or more tuples ``(cmsg_level, "
"cmsg_type, cmsg_data)``, where *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, "
"and *cmsg_data* is a bytes-like object holding the associated data.  Note"
" that some systems (in particular, systems without :func:`CMSG_SPACE`) "
"might support sending only one control message per call.  The *flags* "
"argument defaults to 0 and has the same meaning as for :meth:`send`.  If "
"*address* is supplied and not ``None``, it sets a destination address for"
" the message.  The return value is the number of bytes of non-ancillary "
"data sent."
msgstr ""
"소켓에 일반과 보조 데이터를 보는데, 일련의 버퍼에서 일반 데이터를 모아서 단일 메시지로 연결합니다. *buffers* 인자는 일반"
" 데이터를 :term:`바이트열류 객체 <bytes-like object>`\\의 이터러블로 지정합니다 (예를 들어, "
":class:`bytes` 객체); 운영 체제는 사용할 수 있는 버퍼 수에 제한(:func:`~os.sysconf` 값 "
"``SC_IOV_MAX``)을 설정할 수 있습니다. *ancdata* 인자는 보조 데이터 (제어 메시지)를 0개 이상의 튜플 "
"``(cmsg_level, cmsg_type, cmsg_data)``\\의 이터러블로 지정합니다. 여기서 *cmsg_level* 와"
" *cmsg_type*\\는 각각 프로토콜 수준과 프로토콜 특정 형을 지정하는 정수이고, *cmsg_data*\\는 연결된 데이터를"
" 담은 바이트열류 객체입니다. 일부 시스템(특히, :func:`CMSG_SPACE`\\가 없는 시스템)은 호출 당 하나의 제어 "
"메시지를 송신하는 것만 지원할 수 있습니다. *flags* 인자의 기본값은 0이고 :meth:`send`\\와 같은 의미입니다. "
"*address*\\가 제공되고 ``None``\\이 아니면, 메시지의 대상 주소를 설정합니다. 반환 값은 전송된 일반 데이터의 "
"바이트 수입니다."

#: ../../library/socket.rst:1886
msgid ""
"The following function sends the list of file descriptors *fds* over an "
":const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS`"
" mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"다음 함수는 :const:`SCM_RIGHTS` 메커니즘을 지원하는 시스템에서, :const:`AF_UNIX` 소켓을 통해 파일 "
"기술자 리스트 *fds*\\를 보냅니다. :meth:`recvmsg`\\도 참조하세요. ::"

#: ../../library/socket.rst:1890
msgid ""
"import socket, array\n"
"\n"
"def send_fds(sock, msg, fds):\n"
"    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, "
"array.array(\"i\", fds))])"
msgstr ""

#: ../../library/socket.rst:1899
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with "
"arguments ``self``, ``address``."
msgstr ""
"``self``, ``address``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``socket.sendmsg``\\를 발생시킵니다."

#: ../../library/socket.rst:1910
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` "
"socket. Set mode, IV, AEAD associated data length and flags for "
":const:`AF_ALG` socket."
msgstr ""
":const:`AF_ALG` 소켓용, :meth:`~socket.sendmsg`\\의 특수한 버전. :const:`AF_ALG` "
"소켓에 대한 모드, IV, AEAD 관련 데이터 길이 및 플래그를 설정합니다."

#: ../../library/socket.rst:1919
msgid ""
"Send a file until EOF is reached by using high-performance "
":mod:`os.sendfile` and return the total number of bytes which were sent. "
"*file* must be a regular file object opened in binary mode. If "
":mod:`os.sendfile` is not available (e.g. Windows) or *file* is not a "
"regular file :meth:`send` will be used instead. *offset* tells from where"
" to start reading the file. If specified, *count* is the total number of "
"bytes to transmit as opposed to sending the file until EOF is reached. "
"File position is updated on return or also in case of error in which case"
" :meth:`file.tell() <io.IOBase.tell>` can be used to figure out the "
"number of bytes which were sent. The socket must be of "
":const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"고성능 :mod:`os.sendfile`\\을 사용하여 EOF에 도달할 때까지 파일을 보내고, 보낸 총 바이트 수를 반환합니다. "
"*file*\\은 바이너리 모드로 열린 일반 파일 객체여야 합니다. :mod:`os.sendfile`\\을 사용할 수 없거나 (예를"
" 들어, 윈도우) *file*\\가 일반 파일이 아니면, :meth:`send`\\가 대신 사용됩니다. *offset*\\은 파일 "
"읽기 시작할 위치를 알려줍니다. 지정되면, *count*\\는 EOF에 도달할 때까지 파일을 전송하는 대신 전송할 총 바이트 "
"수입니다. 파일 위치는 반환하거나 에러가 발생했을 때 갱신됩니다. 이때 :meth:`file.tell() "
"<io.IOBase.tell>`\\을 사용하여 전송된 바이트 수를 계산할 수 있습니다. 소켓은 :const:`SOCK_STREAM`"
" 유형이어야 합니다. 비 블로킹 소켓은 지원되지 않습니다."

#: ../../library/socket.rst:1935
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr "소켓의 파일 기술자나 소켓 핸들의 :ref:`상속 가능 플래그 <fd_inheritance>`\\를 설정합니다."

#: ../../library/socket.rst:1943
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"소켓의 블로킹이나 비 블로킹 모드를 설정합니다. *flag*\\가 거짓이면, 소켓은 비 블로킹으로 설정되고, 그렇지 않으면 블로킹 "
"모드로 설정됩니다."

#: ../../library/socket.rst:1946
msgid "This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "이 메서드는 특정 :meth:`~socket.settimeout` 호출의 줄인 표현입니다:"

#: ../../library/socket.rst:1948
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)``\\는 ``sock.settimeout(None)``\\와 동등합니다"

#: ../../library/socket.rst:1950
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)``\\는 ``sock.settimeout(0.0)``\\와 동등합니다"

#: ../../library/socket.rst:1952
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on "
":attr:`socket.type`."
msgstr "이 메서드는 더는 :attr:`socket.type`\\에 :const:`SOCK_NONBLOCK` 플래그를 적용하지 않습니다."

#: ../../library/socket.rst:1959
#, fuzzy
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be"
" a nonnegative floating-point number expressing seconds, or ``None``. If "
"a non-zero value is given, subsequent socket operations will raise a "
":exc:`timeout` exception if the timeout period *value* has elapsed before"
" the operation has completed.  If zero is given, the socket is put in "
"non-blocking mode. If ``None`` is given, the socket is put in blocking "
"mode."
msgstr ""
"블로킹 소켓 연산에 시간제한을 설정합니다. *value* 인자는 초로 표현된 음수가 아닌 부동 소수점 수나 ``None`` 일 수 "
"있습니다. 0이 아닌 값을 주면, 후속 소켓 연산에서, 연산이 완료되기 전에 시간제한 기간 *value*\\가 지나면 "
":exc:`timeout` 예외를 발생시킵니다. 0을 지정하면, 소켓은 비 블로킹 모드가 됩니다. ``None``\\이 주어지면, "
"소켓은 블로킹 모드가 됩니다."

#: ../../library/socket.rst:1966
msgid ""
"For further information, please consult the :ref:`notes on socket "
"timeouts <socket-timeouts>`."
msgstr "자세한 내용은, :ref:`소켓 시간제한에 대한 참고 사항 <socket-timeouts>`\\을 보십시오."

#: ../../library/socket.rst:1968
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on "
":attr:`socket.type`."
msgstr "이 메서드는 더는 :attr:`socket.type`\\의 :const:`SOCK_NONBLOCK` 플래그를 토글하지 않습니다."

#: ../../library/socket.rst:1981
#, fuzzy
msgid ""
"Set the value of the given socket option (see the Unix manual page "
":manpage:`setsockopt(2)`).  The needed symbolic constants are defined in "
"this module (:ref:`!SO_\\* etc. <socket-unix-constants>`).  The value can"
" be an integer, ``None`` or a :term:`bytes-like object` representing a "
"buffer. In the later case it is up to the caller to ensure that the "
"bytestring contains the proper bits (see the optional built-in module "
":mod:`struct` for a way to encode C structures as bytestrings). When "
"*value* is set to ``None``, *optlen* argument is required. It's "
"equivalent to call :c:func:`setsockopt` C function with ``optval=NULL`` "
"and ``optlen=optlen``."
msgstr ""
"주어진 소켓 옵션의 값을 설정합니다 (유닉스 매뉴얼 페이지 :manpage:`setsockopt(2)`\\를 보십시오). 필요한 "
"기호 상수는 :mod:`socket` 모듈에 정의되어 있습니다 (:const:`SO_\\*` 등). 값은 정수, ``None`` "
"또는 버퍼를 나타내는 :term:`바이트열류 객체 <bytes-like object>` 일 수 있습니다. 후자의 경우, 호출자는 "
"바이트열에 적절한 비트가 들어 있는지 확인해야 합니다 (C 구조체를 바이트열로 인코딩하는 방법에 대해서는 선택적 내장 모듈 "
":mod:`struct`\\를 참조하십시오). *value*\\를 ``None``\\으로 설정하면, *optlen* 인자가 "
"필요합니다. ``optval=NULL``\\과 ``optlen=optlen`` 으로 :c:func:`setsockopt` C 함수를"
" 호출하는 것과 동등합니다."

#: ../../library/socket.rst:1994
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "setsockopt(level, optname, None, optlen: int) 형식이 추가되었습니다."

#: ../../library/socket.rst:2002
msgid ""
"Shut down one or both halves of the connection.  If *how* is "
":const:`SHUT_RD`, further receives are disallowed.  If *how* is "
":const:`SHUT_WR`, further sends are disallowed.  If *how* is "
":const:`SHUT_RDWR`, further sends and receives are disallowed."
msgstr ""
"연결의 한쪽 또는 양쪽 절반을 닫습니다. *how*\\가 :const:`SHUT_RD`\\면, 추가 수신이 허용되지 않습니다. "
"*how*\\가 :const:`SHUT_WR`\\이면, 추가 전송이 허용되지 않습니다. *how*\\가 "
":const:`SHUT_RDWR`\\이면, 추가 송수신이 허용되지 않습니다."

#: ../../library/socket.rst:2012
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The"
" target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using "
":func:`fromshare`. Once this method has been called, it is safe to close "
"the socket since the operating system has already duplicated it for the "
"target process."
msgstr ""
"소켓을 복제하고 대상 프로세스와 공유할 수 있도록 준비합니다. 대상 프로세스는 *process_id*\\로 제공되어야 합니다. 결과"
" 바이트열 객체는 어떤 프로세스 간 통신의 형태를 사용하여 대상 프로세스로 전달될 수 있으며 그곳에서 "
":func:`fromshare`\\를 사용하여 소켓을 다시 만들 수 있습니다. 일단, 이 메서드가 호출되면, 운영 체제가 이미 대상"
" 프로세스를 위해 이를 복제 했으므로 소켓을 닫아도 안전합니다."

#: ../../library/socket.rst:2024
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use "
":meth:`~socket.recv` and :meth:`~socket.send` without *flags* argument "
"instead."
msgstr ""
"메서드 :meth:`read` 나 :meth:`write`\\가 없다는 점에 유의하십시오; 대신 "
":meth:`~socket.recv` 와 :meth:`~socket.send`\\를 *flags* 인자 없이 사용하십시오."

#: ../../library/socket.rst:2027
msgid ""
"Socket objects also have these (read-only) attributes that correspond to "
"the values given to the :class:`~socket.socket` constructor."
msgstr ""
"소켓 객체는 또한 :class:`~socket.socket` 생성자에 지정된 값에 대응하는 다음과 같은 (읽기 전용) 어트리뷰트를 "
"가집니다."

#: ../../library/socket.rst:2033
msgid "The socket family."
msgstr "소켓 패밀리."

#: ../../library/socket.rst:2038
msgid "The socket type."
msgstr "소켓 유형."

#: ../../library/socket.rst:2043
msgid "The socket protocol."
msgstr "소켓 프로토콜."

#: ../../library/socket.rst:2050
msgid "Notes on socket timeouts"
msgstr "소켓 시간제한에 대한 참고 사항"

#: ../../library/socket.rst:2052
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but "
"this can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"소켓 객체는 세 가지 모드 중 하나일 수 있습니다: 블로킹, 비 블로킹, 또는 시간제한. 소켓은 기본적으로 항상 블로킹 모드로 "
"생성되지만, 이는 :func:`setdefaulttimeout`\\를 호출하여 변경할 수 있습니다."

#: ../../library/socket.rst:2056
msgid ""
"In *blocking mode*, operations block until complete or the system returns"
" an error (such as connection timed out)."
msgstr "*블로킹 모드*\\에서, 연산은 완료되거나 시스템에서 에러(가령 연결 시간 초과)를 반환할 때까지 블록합니다."

#: ../../library/socket.rst:2059
#, fuzzy
msgid ""
"In *non-blocking mode*, operations fail (with an error that is "
"unfortunately system-dependent) if they cannot be completed immediately: "
"functions from the :mod:`select` module can be used to know when and "
"whether a socket is available for reading or writing."
msgstr ""
"*비 블로킹 모드*\\에서, 연산은 즉시 완료할 수 없으면 실패합니다 (불행히도 시스템 종속적인 에러로): "
":mod:`select`\\의 함수를 사용하여 소켓이 읽기나 쓰기가 가능한 시기를 알 수 있습니다."

#: ../../library/socket.rst:2064
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the"
" timeout specified for the socket (they raise a :exc:`timeout` exception)"
" or if the system returns an error."
msgstr ""
"*시간제한 모드*\\에서, 연산은 소켓에 대해 지정된 제한 시간 내에 완료할 수 없거나 (:exc:`timeout` 예외 발생), "
"시스템이 에러를 반환하면 실패합니다."

#: ../../library/socket.rst:2069
#, fuzzy
msgid ""
"At the operating system level, sockets in *timeout mode* are internally "
"set in non-blocking mode.  Also, the blocking and timeout modes are "
"shared between file descriptors and socket objects that refer to the same"
" network endpoint. This implementation detail can have visible "
"consequences if e.g. you decide to use the :meth:`~socket.fileno` of a "
"socket."
msgstr ""
"운영 체제 수준에서, *시간제한 모드*\\의 소켓은 내부적으로 비 블로킹 모드로 설정됩니다. 또한, 블로킹과 시간제한 모드는 같은 "
"네트워크 끝점을 가리키는 파일 기술자와 소켓 객체 간에 공유됩니다. 이 구현 세부 사항은 가시적인 결과를 가져올 수 있습니다, 예를"
" 들어, 소켓의 :meth:`~socket.fileno()`\\를 사용하기로 한 경우가 그렇습니다."

#: ../../library/socket.rst:2076
msgid "Timeouts and the ``connect`` method"
msgstr "시간제한과 ``connect`` 메서드"

#: ../../library/socket.rst:2078
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call "
":meth:`~socket.settimeout` before calling :meth:`~socket.connect` or pass"
" a timeout parameter to :meth:`create_connection`.  However, the system "
"network stack may also return a connection timeout error of its own "
"regardless of any Python socket timeout setting."
msgstr ""
":meth:`~socket.connect` 연산도 시간제한 설정의 영향을 받으며, 일반적으로 "
":meth:`~socket.connect`\\를 호출하기 전에 :meth:`~socket.settimeout`\\를 호출하거나 "
":meth:`create_connection`\\에 timeout 매개 변수를 전달하는 것이 좋습니다. 그러나, 시스템 네트워크 "
"스택은 파이썬 소켓 시간제한 설정과 관계없이 자체의 연결 시간제한 에러를 반환할 수 있습니다."

#: ../../library/socket.rst:2086
msgid "Timeouts and the ``accept`` method"
msgstr "시간제한과 ``accept`` 메서드"

#: ../../library/socket.rst:2088
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by "
"the :meth:`~socket.accept` method inherit that timeout.  Otherwise, the "
"behaviour depends on settings of the listening socket:"
msgstr ""
":func:`getdefaulttimeout`\\가 :const:`None`\\이 아니면, :meth:`~socket.accept`"
" 메서드에서 반환된 소켓은 그 시간제한을 상속합니다. 그렇지 않으면, 동작은 리스닝 소켓의 설정에 따라 다릅니다:"

#: ../../library/socket.rst:2092
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"리스닝 소켓이 *블로킹 모드* 나 *시간제한 모드*\\에 있으면, :meth:`~socket.accept`\\에 의해 반환된 소켓은"
" *블로킹 모드*\\에 있습니다."

#: ../../library/socket.rst:2095
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is"
" operating system-dependent.  If you want to ensure cross-platform "
"behaviour, it is recommended you manually override this setting."
msgstr ""
"리스닝 소켓이 *비 블로킹 모드*\\에 있으면, :meth:`~socket.accept`\\에 의해 반환된 소켓이 블로킹 모드인지 "
"비 블로킹 모드인지는 운영 체제에 따라 다릅니다. 플랫폼 간 동작을 보장하려면, 이 설정을 직접 재정의하는 것이 좋습니다."

#: ../../library/socket.rst:2104
msgid "Example"
msgstr "예제"

#: ../../library/socket.rst:2106
#, fuzzy
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a "
"server that echoes all data that it receives back (servicing only one "
"client), and a client using it.  Note that a server must perform the "
"sequence :func:`~socket.socket`, :meth:`~socket.bind`, "
":meth:`~socket.listen`, :meth:`~socket.accept` (possibly repeating the "
":meth:`~socket.accept` to service more than one client), while a client "
"only needs the sequence :func:`~socket.socket`, :meth:`~socket.connect`."
"  Also note that the server does not "
":meth:`~socket.sendall`/:meth:`~socket.recv` on the socket it is "
"listening on but on the new socket returned by :meth:`~socket.accept`."
msgstr ""
"다음은 TCP/IP 프로토콜을 사용하는 4가지 최소 예제 프로그램입니다: (하나의 클라이언트만 서비스하는) 수신한 모든 데이터를 "
"반향하는 서버와, 이를 사용하는 클라이언트. 서버는 :func:`.socket`, :meth:`~socket.bind`, "
":meth:`~socket.listen`, :meth:`~socket.accept` (두 개 이상의 클라이언트에 서비스를 제공하기 "
"위해 :meth:`~socket.accept`\\를 반복할 수 있습니다) 절차를 수행해야 하지만, 클라이언트는 "
":func:`.socket`, :meth:`~socket.connect` 절차만 요구함에 유의하십시오. 또한, 서버는 수신 대기 "
"중인 소켓이 아니라 :meth:`~socket.accept`\\가 반환한 새 소켓에 대해서 "
":meth:`~socket.sendall`/:meth:`~socket.recv`\\를 한다는 것에도 유의하십시오."

#: ../../library/socket.rst:2116
msgid "The first two examples support IPv4 only. ::"
msgstr "처음 두 예제는 IPv4만 지원합니다. ::"

#: ../../library/socket.rst:2118
msgid ""
"# Echo server program\n"
"import socket\n"
"\n"
"HOST = ''                 # Symbolic name meaning all available "
"interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.bind((HOST, PORT))\n"
"    s.listen(1)\n"
"    conn, addr = s.accept()\n"
"    with conn:\n"
"        print('Connected by', addr)\n"
"        while True:\n"
"            data = conn.recv(1024)\n"
"            if not data: break\n"
"            conn.sendall(data)"
msgstr ""

#: ../../library/socket.rst:2136
msgid ""
"# Echo client program\n"
"import socket\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.connect((HOST, PORT))\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"
msgstr ""

#: ../../library/socket.rst:2147
#, fuzzy
msgid ""
"The next two examples are identical to the above two, but support both "
"IPv4 and IPv6. The server side will listen to the first address family "
"available (it should listen to both instead). On most of IPv6-ready "
"systems, IPv6 will take precedence and the server may not accept IPv4 "
"traffic. The client side will try to connect to all the addresses "
"returned as a result of the name resolution, and sends traffic to the "
"first one connected successfully. ::"
msgstr ""
"다음 두 예제는 위의 두 예제와 같지만, IPv4와 IPv6를 모두 지원합니다. 서버 측은 사용 가능한 첫 번째 주소 패밀리를 "
"리슨합니다 (대신 두 주소를 모두 리슨 해야 합니다). 대부분 IPv6 지원 시스템에서, IPv6가 우선하며 서버가 IPv4 "
"트래픽을 허용하지 않을 수 있습니다. 클라이언트 측은 이름 결정의 결과로 반환된 모든 주소에 연결을 시도하고 성공적으로 연결된 첫 "
"번째 주소로 트래픽을 보냅니다. ::"

#: ../../library/socket.rst:2154
msgid ""
"# Echo server program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = None               # Symbolic name meaning all available "
"interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n"
"                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.bind(sa)\n"
"        s.listen(1)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"conn, addr = s.accept()\n"
"with conn:\n"
"    print('Connected by', addr)\n"
"    while True:\n"
"        data = conn.recv(1024)\n"
"        if not data: break\n"
"        conn.send(data)"
msgstr ""

#: ../../library/socket.rst:2190
msgid ""
"# Echo client program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, "
"socket.SOCK_STREAM):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.connect(sa)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"with s:\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"
msgstr ""

#: ../../library/socket.rst:2219
msgid ""
"The next example shows how to write a very simple network sniffer with "
"raw sockets on Windows. The example requires administrator privileges to "
"modify the interface::"
msgstr ""
"다음 예제는 윈도우에서 원시(raw) 소켓으로 매우 간단한 네트워크 스니퍼를 작성하는 방법을 보여줍니다. 이 예제는 인터페이스를 "
"수정하기 위해 관리자 권한이 필요합니다::"

#: ../../library/socket.rst:2223
msgid ""
"import socket\n"
"\n"
"# the public network interface\n"
"HOST = socket.gethostbyname(socket.gethostname())\n"
"\n"
"# create a raw socket and bind it to the public interface\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\n"
"s.bind((HOST, 0))\n"
"\n"
"# Include IP headers\n"
"s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n"
"\n"
"# receive all packets\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n"
"\n"
"# receive a packet\n"
"print(s.recvfrom(65565))\n"
"\n"
"# disabled promiscuous mode\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)"
msgstr ""

#: ../../library/socket.rst:2244
msgid ""
"The next example shows how to use the socket interface to communicate to "
"a CAN network using the raw socket protocol. To use CAN with the "
"broadcast manager protocol instead, open a socket with::"
msgstr ""
"다음 예제는 원시(raw) 소켓 프로토콜을 사용하여, 소켓 인터페이스를 사용하여 CAN 네트워크와 통신하는 방법을 보여줍니다. 대신"
" 브로드캐스트 관리자 프로토콜로 CAN을 사용하려면, 소켓을 이렇게 여십시오::"

#: ../../library/socket.rst:2248
msgid "socket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_BCM)"
msgstr ""

#: ../../library/socket.rst:2250
#, fuzzy
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send` and :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"소켓을 바인드(:const:`CAN_RAW`)하거나 연결(:const:`CAN_BCM`)한 후, :meth:`socket.send`"
" 와 :meth:`socket.recv` 연산(과 대응 연산)을 소켓 객체에 평소와 같이 사용할 수 있습니다."

#: ../../library/socket.rst:2254
msgid "This last example might require special privileges::"
msgstr "이 마지막 예제는 특별한 권한이 필요할 수 있습니다::"

#: ../../library/socket.rst:2256
#, python-format
msgid ""
"import socket\n"
"import struct\n"
"\n"
"\n"
"# CAN frame packing/unpacking (see 'struct can_frame' in <linux/can.h>)\n"
"\n"
"can_frame_fmt = \"=IB3x8s\"\n"
"can_frame_size = struct.calcsize(can_frame_fmt)\n"
"\n"
"def build_can_frame(can_id, data):\n"
"    can_dlc = len(data)\n"
"    data = data.ljust(8, b'\\x00')\n"
"    return struct.pack(can_frame_fmt, can_id, can_dlc, data)\n"
"\n"
"def dissect_can_frame(frame):\n"
"    can_id, can_dlc, data = struct.unpack(can_frame_fmt, frame)\n"
"    return (can_id, can_dlc, data[:can_dlc])\n"
"\n"
"\n"
"# create a raw socket and bind it to the 'vcan0' interface\n"
"s = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n"
"s.bind(('vcan0',))\n"
"\n"
"while True:\n"
"    cf, addr = s.recvfrom(can_frame_size)\n"
"\n"
"    print('Received: can_id=%x, can_dlc=%x, data=%s' % "
"dissect_can_frame(cf))\n"
"\n"
"    try:\n"
"        s.send(cf)\n"
"    except OSError:\n"
"        print('Error sending CAN frame')\n"
"\n"
"    try:\n"
"        s.send(build_can_frame(0x01, b'\\x01\\x02\\x03'))\n"
"    except OSError:\n"
"        print('Error sending CAN frame')"
msgstr ""

#: ../../library/socket.rst:2294
msgid ""
"Running an example several times with too small delay between executions,"
" could lead to this error::"
msgstr "실행 간격이 너무 짧게 여러 번 예제를 실행하면 이 에러가 발생할 수 있습니다::"

#: ../../library/socket.rst:2297
msgid "OSError: [Errno 98] Address already in use"
msgstr ""

#: ../../library/socket.rst:2299
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr "이것은 이전 실행이 소켓을 ``TIME_WAIT`` 상태로 남겨 두었고, 즉시 재사용할 수 없기 때문입니다."

#: ../../library/socket.rst:2302
#, fuzzy
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, "
":const:`socket.SO_REUSEADDR`::"
msgstr ""
"이것을 방지하기 위해서 설정할 수 있는 :mod:`socket` 플래그 :data:`socket.SO_REUSEADDR`\\가 "
"있습니다::"

#: ../../library/socket.rst:2305
msgid ""
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n"
"s.bind((HOST, PORT))"
msgstr ""

#: ../../library/socket.rst:2309
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in"
" ``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
":data:`SO_REUSEADDR` 플래그는 자연스러운 시간제한이 만료되기를 기다리지 않고 ``TIME_WAIT`` 상태의 지역 "
"소켓을 재사용하도록 커널에 알립니다."

#: ../../library/socket.rst:2315
msgid ""
"For an introduction to socket programming (in C), see the following "
"papers:"
msgstr "(C로 하는) 소켓 프로그래밍에 대한 소개는 다음 논문을 참조하십시오:"

#: ../../library/socket.rst:2317
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, Stuart "
"Sechrest 저"

#: ../../library/socket.rst:2319
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, Samuel J. "
"Leffler 외 저,"

#: ../../library/socket.rst:2322
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections"
" PS1:7 and PS1:8).  The platform-specific reference material for the "
"various socket-related system calls are also a valuable source of "
"information on the details of socket semantics.  For Unix, refer to the "
"manual pages; for Windows, see the WinSock (or Winsock 2) specification."
"  For IPv6-ready APIs, readers may want to refer to :rfc:`3493` titled "
"Basic Socket Interface Extensions for IPv6."
msgstr ""
"둘 다 유닉스 프로그래머 매뉴얼, 보충 문서 1 (섹션 PS1:7과 PS1:8)에 있습니다. 다양한 소켓 관련 시스템 호출에 대한 "
"플랫폼별 레퍼런스 자료는 소켓 의미의 세부 정보에 대한 중요한 소스입니다. 유닉스에서는 매뉴얼 페이지를 참조하십시오; 윈도우에서는,"
" WinSock (또는 Winsock 2) 명세를 참조하십시오. IPv6 지원 API의 경우, 독자는 Basic Socket "
"Interface Extensions for IPv6라는 제목의 :rfc:`3493`\\를 참조하고 싶을 겁니다."

#: ../../library/socket.rst:22
#, fuzzy
msgid "object"
msgstr "소켓 객체"

#: ../../library/socket.rst:22
#, fuzzy
msgid "socket"
msgstr "소켓 객체"

#: ../../library/socket.rst:1627
msgid "I/O control"
msgstr ""

#: ../../library/socket.rst:1627
msgid "buffering"
msgstr ""

#: ../../library/socket.rst:1979
msgid "module"
msgstr ""

#: ../../library/socket.rst:1979
msgid "struct"
msgstr ""

#~ msgid ""
#~ ":const:`BTPROTO_HCI` accepts ``(device_id,)`` where"
#~ " ``device_id`` is either an integer "
#~ "or a string with the Bluetooth "
#~ "address of the interface. (This depends"
#~ " on your OS; NetBSD and DragonFlyBSD"
#~ " expect a Bluetooth address while "
#~ "everything else expects an integer.)"
#~ msgstr ""
#~ ":const:`BTPROTO_HCI`\\는 ``(device_id,)``\\를 받아들입니다. "
#~ "여기서 ``device_id``\\는 정수나 인터페이스의 블루투스 주소인"
#~ " 문자열입니다. (이것은 여러분의 OS에 따라 다릅니다; "
#~ "NetBSD와 FreeBSD는 블루투스 주소를 기대하지만 다른 "
#~ "모든 것은 정수를 기대합니다.)"

#~ msgid ""
#~ "*proto* - An in network-byte-order"
#~ " integer specifying the Ethernet protocol"
#~ " number."
#~ msgstr "*proto* - 이더넷 프로토콜 번호를 지정하는 네트워크 바이트 순서 정수."

#~ msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 >= 2.6.27."

#~ msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
#~ msgstr ":ref:`가용성 <availability>` : 리눅스 >= 2.6.25."

#~ msgid ":ref:`Availability <availability>`: Linux >= 3.6."
#~ msgstr ":ref:`가용성 <availability>` : 리눅스 >= 3.6."

#~ msgid ":ref:`Availability <availability>`: Linux >= 4.1."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 >= 4.1."

#~ msgid ":ref:`Availability <availability>`: Linux >= 5.4."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 >= 5.4."

#~ msgid ":ref:`Availability <availability>`: Linux >= 2.2."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 >= 2.2."

#~ msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 >= 2.6.30."

#~ msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
#~ msgstr ":ref:`가용성 <availability>` : 리눅스 >= 2.6.38."

#~ msgid ":ref:`Availability <availability>`: Linux >= 4.8."
#~ msgstr ":ref:`가용성 <availability>` : 리눅스 >= 4.8."

#~ msgid ":ref:`Availability <availability>`: BSD, OSX."
#~ msgstr ":ref:`가용성 <availability>` : BSD, OSX."

#~ msgid ":ref:`Availability <availability>`: Linux >= 4.7."
#~ msgstr ":ref:`가용성 <availability>`: 리눅스 >= 4.7."

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우."

#~ msgid ""
#~ "In case *x* does not fit in "
#~ "16-bit unsigned integer, but does fit"
#~ " in a positive C int, it is "
#~ "silently truncated to 16-bit unsigned "
#~ "integer. This silent truncation feature "
#~ "is deprecated, and will raise an "
#~ "exception in future versions of Python."
#~ msgstr ""
#~ "*x*\\가 16비트 부호 없는 정수에 맞지 않지만, "
#~ "양의 C int에 맞으면, 16비트 부호 없는 "
#~ "정수로 자동 절단됩니다. 이 자동 절단 기능은 "
#~ "폐지되었으며, 미래 버전의 파이썬에서는 예외가 발생할 "
#~ "것입니다."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Unix (maybe "
#~ "not all platforms), Windows."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스(모든 플랫폼이 아닐 수도 있음), 윈도우."

#~ msgid ""
#~ ":ref:`Availability <availability>`: most Unix "
#~ "platforms, possibly others."
#~ msgstr ":ref:`가용성 <availability>`: 대부분 유닉스 플랫폼, 다른 것들도 가능합니다."

#~ msgid ":ref:`Availability <availability>`: Unix."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스."

#~ msgid ":ref:`Availability <availability>`: Unix, Windows."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스, 윈도우."

#~ msgid ""
#~ "For best match with hardware and "
#~ "network realities, the value of  "
#~ "*bufsize* should be a relatively small"
#~ " power of 2, for example, 4096."
#~ msgstr ""
#~ "하드웨어와 네트워크 현실과 가장 잘 일치하려면, "
#~ "*bufsize*\\의 값은 2의 비교적 작은 거듭제곱이어야 "
#~ "합니다, 예를 들어 4096."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Unix supporting"
#~ " :meth:`~socket.recvmsg` and :const:`SCM_RIGHTS` "
#~ "mechanism."
#~ msgstr ""
#~ ":ref:`가용성 <availability>`: :meth:`~socket.recvmsg`\\와 "
#~ ":const:`SCM_RIGHTS` 메커니즘을 지원하는 유닉스."

