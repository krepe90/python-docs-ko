# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/pkgutil.rst:2
msgid ":mod:`!pkgutil` --- Package extension utility"
msgstr ":mod:`!pkgutil` --- 패키지 확장 유틸리티"

#: ../../library/pkgutil.rst:7
msgid "**Source code:** :source:`Lib/pkgutil.py`"
msgstr "**소스 코드:** :source:`Lib/pkgutil.py`"

#: ../../library/pkgutil.rst:11
msgid ""
"This module provides utilities for the import system, in particular "
"package support."
msgstr "이 모듈은 임포트 시스템, 특히 패키지 지원을 위한 유틸리티를 제공합니다."

#: ../../library/pkgutil.rst:16
msgid "A namedtuple that holds a brief summary of a module's info."
msgstr "모듈 정보에 대한 간략한 요약을 담고 있는 네임드 튜플."

#: ../../library/pkgutil.rst:22
msgid ""
"Extend the search path for the modules which comprise a package.  "
"Intended use is to place the following code in a package's "
":file:`__init__.py`::"
msgstr ""
"패키지를 구성하는 모듈의 검색 경로를 확장합니다. 의도된 사용법은 패키지의 :file:`__init__.py`\\에 다음 코드를 "
"삽입하는 것입니다::"

#: ../../library/pkgutil.rst:25
msgid ""
"from pkgutil import extend_path\n"
"__path__ = extend_path(__path__, __name__)"
msgstr ""
"from pkgutil import extend_path\n"
"__path__ = extend_path(__path__, __name__)"

#: ../../library/pkgutil.rst:28
msgid ""
"For each directory on :data:`sys.path` that has a subdirectory that "
"matches the package name, add the subdirectory to the package's "
":attr:`~module.__path__`. This is useful if one wants to distribute "
"different parts of a single logical package as multiple directories."
msgstr ""
":data:`sys.path`\\에 있는 디렉터리들의 모든 서브 디렉터리 중, 패키지의 이름과 일치하는 것들을 패키지의 "
":attr:`~module.__path__`\\에 추가합니다. 이것은 하나의 논리적 패키지의 부분들을 여러 디렉터리로 분배하려고 할"
" 때 유용합니다."

#: ../../library/pkgutil.rst:34
msgid ""
"It also looks for :file:`\\*.pkg` files beginning where ``*`` matches the"
" *name* argument.  This feature is similar to :file:`\\*.pth` files (see "
"the :mod:`site` module for more information), except that it doesn't "
"special-case lines starting with ``import``.  A :file:`\\*.pkg` file is "
"trusted at face value: apart from skipping blank lines and ignoring "
"comments, all entries found in a :file:`\\*.pkg` file are added to the "
"path, regardless of whether they exist on the filesystem (this is a "
"feature)."
msgstr ""
"``*``\\가 *name* 인자와 일치하는 :file:`\\*.pkg` 파일도 찾습니다. 이 기능은 ``import``\\로 "
"시작하는 줄을 특수하게 다루지 않는다는 점을 제외하면, :file:`\\*.pth` 파일과 유사합니다 (자세한 내용은 "
":mod:`site` 모듈을 참조하십시오). :file:`\\*.pkg` 파일을 액면 그대로 신뢰합니다: 빈 줄을 건너뛰고 주석을 "
"무시하지만, :file:`\\*.pkg` 파일에 있는 모든 항목은 파일 시스템에 있는지에 관계없이 경로에 추가됩니다. (이것은 "
"기능입니다.)"

#: ../../library/pkgutil.rst:42
msgid ""
"If the input path is not a list (as is the case for frozen packages) it "
"is returned unchanged.  The input path is not modified; an extended copy "
"is returned.  Items are only appended to the copy at the end."
msgstr ""
"입력 경로가 리스트가 아니면 (프로즌 패키지의 경우처럼) 변경되지 않은 상태로 반환됩니다. 입력 경로는 수정되지 않습니다; 확장한 "
"사본이 반환됩니다. 항목은 사본의 끝에 추가되기만 합니다."

#: ../../library/pkgutil.rst:46
msgid ""
"It is assumed that :data:`sys.path` is a sequence.  Items of "
":data:`sys.path` that are not strings referring to existing directories "
"are ignored. Unicode items on :data:`sys.path` that cause errors when "
"used as filenames may cause this function to raise an exception (in line "
"with :func:`os.path.isdir` behavior)."
msgstr ""
":data:`sys.path`\\기 시퀀스라고 가정합니다. 존재하는 디렉터리를 참조하는 문자열이 아닌 :data:`sys.path`"
" 항목은 무시됩니다. 파일명으로 사용될 때 에러를 일으키는 :data:`sys.path`\\의 유니코드 항목은 이 함수가 예외를 "
"발생시키도록 할 수 있습니다 (:func:`os.path.isdir` 동작과 일치합니다)."

#: ../../library/pkgutil.rst:54
msgid "Retrieve a module :term:`loader` for the given *fullname*."
msgstr "주어진 *fullname*\\에 대한 모듈 :term:`로더 <loader>`\\를 가져옵니다."

#: ../../library/pkgutil.rst:56
msgid ""
"This is a backwards compatibility wrapper around "
":func:`importlib.util.find_spec` that converts most failures to "
":exc:`ImportError` and only returns the loader rather than the full "
":class:`importlib.machinery.ModuleSpec`."
msgstr ""
"이것은 :func:`importlib.util.find_spec`\\을 감싸는 하위 호환성 래퍼인데, 대부분의 실패를 "
":exc:`ImportError`\\로 변환하고 전체 :class:`importlib.machinery.ModuleSpec`\\이 "
"아닌 로더만 반환합니다."

#: ../../library/pkgutil.rst:61 ../../library/pkgutil.rst:82
#: ../../library/pkgutil.rst:97 ../../library/pkgutil.rst:121
#: ../../library/pkgutil.rst:142 ../../library/pkgutil.rst:181
msgid ""
"Updated to be based directly on :mod:`importlib` rather than relying on "
"the package internal :pep:`302` import emulation."
msgstr ""
"패키지 내부 :pep:`302` 임포트 에뮬레이션에 의존하는 대신, :mod:`importlib`\\에 직접 기반하도록 "
"갱신되었습니다."

#: ../../library/pkgutil.rst:65 ../../library/pkgutil.rst:101
msgid "Updated to be based on :pep:`451`"
msgstr ":pep:`451`\\에 기반하도록 갱신되었습니다"

#: ../../library/pkgutil.rst:68 ../../library/pkgutil.rst:104
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "대신 :func:`importlib.util.find_spec`\\을 사용하세요."

#: ../../library/pkgutil.rst:74
msgid "Retrieve a :term:`finder` for the given *path_item*."
msgstr "주어진 *path_item*\\에 대한 :term:`파인더 <finder>`\\를 가져옵니다."

#: ../../library/pkgutil.rst:76
msgid ""
"The returned finder is cached in :data:`sys.path_importer_cache` if it "
"was newly created by a path hook."
msgstr "반환된 파인더는 경로 훅 때문에 새로 만들어지면 :data:`sys.path_importer_cache`\\에 캐시 됩니다."

#: ../../library/pkgutil.rst:79
msgid ""
"The cache (or part of it) can be cleared manually if a rescan of "
":data:`sys.path_hooks` is necessary."
msgstr ":data:`sys.path_hooks`\\의 재검색이 필요하면, 캐시(또는 그 일부)를 수동으로 지울 수 있습니다."

#: ../../library/pkgutil.rst:89
msgid "Get a :term:`loader` object for *module_or_name*."
msgstr "*module_or_name*\\에 대한 :term:`로더 <loader>` 객체를 가져옵니다."

#: ../../library/pkgutil.rst:91
msgid ""
"If the module or package is accessible via the normal import mechanism, a"
" wrapper around the relevant part of that machinery is returned.  Returns"
" ``None`` if the module cannot be found or imported.  If the named module"
" is not already imported, its containing package (if any) is imported, in"
" order to establish the package ``__path__``."
msgstr ""
"모듈이나 패키지가 일반 임포트 메커니즘을 통해 액세스할 수 있으면, 그 장치의 관련 부분을 감싸는 래퍼가 반환됩니다. 모듈을 찾거나"
" 임포트 할 수 없으면 ``None``\\을 반환합니다. 명명된 모듈이 아직 임포트 되지 않았다면, 패키지 "
"``__path__``\\를 구성하기 위해 포함하는 패키지(있다면))를 임포트 합니다."

#: ../../library/pkgutil.rst:110
msgid "Yield :term:`finder` objects for the given module name."
msgstr "주어진 모듈 이름에 대해 :term:`파인더 <finder>` 객체를 산출(yield)합니다."

#: ../../library/pkgutil.rst:112
msgid ""
"If fullname contains a ``'.'``, the finders will be for the package "
"containing fullname, otherwise they will be all registered top level "
"finders (i.e. those on both :data:`sys.meta_path` and "
":data:`sys.path_hooks`)."
msgstr ""
"fullname에 ``'.'``\\이 포함되어 있으면, 파인더는 fullname을 포함하는 패키지를 위한 것입니다, 그렇지 않으면,"
" 등록된 모든 최상위 수준 파인더입니다 (즉, :data:`sys.meta_path` 와 "
":data:`sys.path_hooks`\\에 있는 것들)."

#: ../../library/pkgutil.rst:116
msgid ""
"If the named module is in a package, that package is imported as a side "
"effect of invoking this function."
msgstr "명명된 모듈이 패키지에 있으면, 이 함수를 호출하는 부작용으로 그 패키지를 임포트 합니다."

#: ../../library/pkgutil.rst:119
msgid "If no module name is specified, all top level finders are produced."
msgstr "모듈 이름을 지정하지 않으면, 모든 최상위 수준 파인더가 생성됩니다."

#: ../../library/pkgutil.rst:128
msgid ""
"Yields :class:`ModuleInfo` for all submodules on *path*, or, if *path* is"
" ``None``, all top-level modules on :data:`sys.path`."
msgstr ""
"*path*\\의 모든 서브 모듈에 대한 :class:`ModuleInfo`\\를, 또는 *path*\\가 ``None``\\이면,"
" :data:`sys.path`\\에 있는 모든 최상위 모듈을 산출(yield)합니다."

#: ../../library/pkgutil.rst:131 ../../library/pkgutil.rst:152
msgid ""
"*path* should be either ``None`` or a list of paths to look for modules "
"in."
msgstr "*path*\\는 ``None``\\이거나 모듈을 찾을 경로의 리스트이어야 합니다."

#: ../../library/pkgutil.rst:133 ../../library/pkgutil.rst:154
msgid ""
"*prefix* is a string to output on the front of every module name on "
"output."
msgstr "*prefix*\\는 출력 시 모든 모듈 이름 앞에 출력할 문자열입니다."

#: ../../library/pkgutil.rst:137 ../../library/pkgutil.rst:176
msgid ""
"Only works for a :term:`finder` which defines an ``iter_modules()`` "
"method. This interface is non-standard, so the module also provides "
"implementations for :class:`importlib.machinery.FileFinder` and "
":class:`zipimport.zipimporter`."
msgstr ""
"``iter_modules()`` 메서드를 정의하는 :term:`파인더 <finder>`\\에서만 작동합니다. 이 인터페이스는 "
"비표준이므로, 모듈은 :class:`importlib.machinery.FileFinder`\\와 "
":class:`zipimport.zipimporter`\\에 대한 구현도 제공합니다."

#: ../../library/pkgutil.rst:149
msgid ""
"Yields :class:`ModuleInfo` for all modules recursively on *path*, or, if "
"*path* is ``None``, all accessible modules."
msgstr ""
"*path*\\에 재귀적으로 포함된 모든 모듈이나, *path*\\가 ``None``\\이면 모든 액세스할 수 있는 모듈에 대한 "
":class:`ModuleInfo`\\를 산출(yield)합니다."

#: ../../library/pkgutil.rst:156
msgid ""
"Note that this function must import all *packages* (*not* all modules!) "
"on the given *path*, in order to access the ``__path__`` attribute to "
"find submodules."
msgstr ""
"서브 모듈 검색을 위한 ``__path__`` 어트리뷰트에 액세스하기 위해, 이 함수는 주어진 *path*\\에 있는 모든 "
"*패키지*\\(모든 모듈이 *아닙니다*!)를 임포트 해야 함에 유의하십시오."

#: ../../library/pkgutil.rst:160
msgid ""
"*onerror* is a function which gets called with one argument (the name of "
"the package which was being imported) if any exception occurs while "
"trying to import a package.  If no *onerror* function is supplied, "
":exc:`ImportError`\\s are caught and ignored, while all other exceptions "
"are propagated, terminating the search."
msgstr ""
"*onerror*\\는 패키지 임포트를 시도하는 동안 예외가 발생하면 하나의 인자(임포트 하려는 패키지의 이름)로 호출되는 "
"함수입니다. *onerror* 함수가 제공되지 않으면, :exc:`ImportError`\\는 잡아서 무시하고, 다른 모든 예외는 "
"전파되어 검색이 종료됩니다."

#: ../../library/pkgutil.rst:166
msgid "Examples::"
msgstr "예제::"

#: ../../library/pkgutil.rst:168
msgid ""
"# list all modules python can access\n"
"walk_packages()\n"
"\n"
"# list all submodules of ctypes\n"
"walk_packages(ctypes.__path__, ctypes.__name__ + '.')"
msgstr ""
"# 파이썬이 액세스할 수 있는 모든 모듈을 나열합니다\n"
"walk_packages()\n"
"\n"
"# ctypes의 모든 서브 모듈을 나열합니다\n"
"walk_packages(ctypes.__path__, ctypes.__name__ + '.')"

#: ../../library/pkgutil.rst:188
msgid "Get a resource from a package."
msgstr "패키지에서 리소스를 가져옵니다."

#: ../../library/pkgutil.rst:190
msgid ""
"This is a wrapper for the :term:`loader` :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>` API.  The *package* argument "
"should be the name of a package, in standard module format (``foo.bar``)."
"  The *resource* argument should be in the form of a relative filename, "
"using ``/`` as the path separator.  The parent directory name ``..`` is "
"not allowed, and nor is a rooted name (starting with a ``/``)."
msgstr ""
"이것은 :term:`로더 <loader>` :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>` API에 대한 래퍼입니다. *package* 인자는 표준 "
"모듈 형식(``foo.bar``)의 패키지 이름이어야 합니다. *resource* 인자는 ``/``\\를 경로 분리자로 사용하는 "
"상대 파일명의 형식이어야 합니다. 상위 디렉터리 이름 ``..``\\는 허용되지 않으며, 루트에서 시작하는(``/``\\로 "
"시작하는) 이름도 허용되지 않습니다."

#: ../../library/pkgutil.rst:197
msgid ""
"The function returns a binary string that is the contents of the "
"specified resource."
msgstr "이 함수는 지정된 리소스의 내용인 바이트열을 반환합니다."

#: ../../library/pkgutil.rst:200
msgid ""
"For packages located in the filesystem, which have already been imported,"
" this is the rough equivalent of::"
msgstr "파일시스템에 있는 패키지(이미 임포트 되었습니다)의 경우, 이것은 대략 다음과 동등합니다::"

#: ../../library/pkgutil.rst:203
msgid ""
"d = os.path.dirname(sys.modules[package].__file__)\n"
"data = open(os.path.join(d, resource), 'rb').read()"
msgstr ""
"d = os.path.dirname(sys.modules[package].__file__)\n"
"data = open(os.path.join(d, resource), 'rb').read()"

#: ../../library/pkgutil.rst:206
msgid ""
"If the package cannot be located or loaded, or it uses a :term:`loader` "
"which does not support :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`, then ``None`` is returned.  In "
"particular, the :term:`loader` for :term:`namespace packages <namespace "
"package>` does not support :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`."
msgstr ""
"패키지를 찾거나 로드 할 수 없거나, 패키지가 :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`\\를 지원하지 않는 :term:`로더 "
"<loader>`\\를 사용하면, ``None``\\이 반환됩니다. 특히, :term:`이름 공간 패키지 <namespace "
"package>`\\를 위한 :term:`로더 <loader>`\\는 :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`\\를 지원하지 않습니다."

#: ../../library/pkgutil.rst:215
msgid "Resolve a name to an object."
msgstr "이름을 객체로 해석합니다."

#: ../../library/pkgutil.rst:217
msgid ""
"This functionality is used in numerous places in the standard library "
"(see :issue:`12915`) - and equivalent functionality is also in widely "
"used third-party packages such as setuptools, Django and Pyramid."
msgstr ""
"이 기능은 표준 라이브러리의 여러 곳에서 사용됩니다 (:issue:`12915`\\를 참조하십시오) - 그리고 동등한 기능이 "
"setuptools, Django 및 Pyramid와 같은 널리 사용되는 제삼자 패키지에도 있습니다."

#: ../../library/pkgutil.rst:221
msgid ""
"It is expected that *name* will be a string in one of the following "
"formats, where W is shorthand for a valid Python identifier and dot "
"stands for a literal period in these pseudo-regexes:"
msgstr ""
"*name*\\은 다음 형식 중 하나의 문자열 일 것으로 기대됩니다, 여기서 W는 유효한 파이썬 식별자를 나타내는 줄임 표현이며 "
"점은 이러한 의사 정규식에서 리터럴 마침표를 나타냅니다:"

#: ../../library/pkgutil.rst:225
msgid "``W(.W)*``"
msgstr "``W(.W)*``"

#: ../../library/pkgutil.rst:226
msgid "``W(.W)*:(W(.W)*)?``"
msgstr "``W(.W)*:(W(.W)*)?``"

#: ../../library/pkgutil.rst:228
msgid ""
"The first form is intended for backward compatibility only. It assumes "
"that some part of the dotted name is a package, and the rest is an object"
" somewhere within that package, possibly nested inside other objects. "
"Because the place where the package stops and the object hierarchy starts"
" can't be inferred by inspection, repeated attempts to import must be "
"done with this form."
msgstr ""
"첫 번째 형식은 이전 버전과의 호환성을 위해서만 사용됩니다. 점으로 구분된 이름의 일부는 패키지이고, 나머지는 패키지 내의 어딘가에"
" 있는 객체이며, 다른 객체 안에 중첩되었을 수 있습니다. 패키지가 멈추고 객체 계층 구조가 시작되는 위치는 보는 것 만으로는 "
"유추할 수 없습니다, 이 형식으로는 임포트 시도를 반복해서 수행해야합니다."

#: ../../library/pkgutil.rst:235
msgid ""
"In the second form, the caller makes the division point clear through the"
" provision of a single colon: the dotted name to the left of the colon is"
" a package to be imported, and the dotted name to the right is the object"
" hierarchy within that package. Only one import is needed in this form. "
"If it ends with the colon, then a module object is returned."
msgstr ""
"두 번째 형식에서, 호출자는 단일 콜론을 제공하여 구분 지점을 명확하게 만듭니다: 콜론 왼쪽의 점으로 구분된 이름은 임포트할 "
"패키지이고, 오른쪽의 점으로 구분된 이름은 해당 패키지 내의 객체 계층 구조입니다. 이 형식에서는 한 번의 임포트만 필요합니다. "
"콜론으로 끝나면, 모듈 객체가 반환됩니다."

#: ../../library/pkgutil.rst:241
msgid ""
"The function will return an object (which might be a module), or raise "
"one of the following exceptions:"
msgstr "이 함수는 객체(모듈일 수 있습니다)를 반환하거나, 다음 예외 중 하나를 발생시킵니다:"

#: ../../library/pkgutil.rst:244
msgid ":exc:`ValueError` -- if *name* isn't in a recognised format."
msgstr ":exc:`ValueError` -- *name*\\이 인식되는 형식이 아니면."

#: ../../library/pkgutil.rst:246
msgid ":exc:`ImportError` -- if an import failed when it shouldn't have."
msgstr ":exc:`ImportError` -- 그러지 말아야할 때 임포트가 실패하면."

#: ../../library/pkgutil.rst:248
msgid ""
":exc:`AttributeError` -- If a failure occurred when traversing the object"
" hierarchy within the imported package to get to the desired object."
msgstr ""
":exc:`AttributeError` -- 임포트한 패키지 내에서 객체 계층 구조를 탐색하여 원하는 객체에 도달하는 도중 실패가 "
"발생할 때."

