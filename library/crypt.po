# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/crypt.rst:2
#, fuzzy
msgid ":mod:`!crypt` --- Function to check Unix passwords"
msgstr ":mod:`crypt` --- 유닉스 비밀번호 확인 함수"

#: ../../library/crypt.rst:10
msgid ""
"This module is no longer part of the Python standard library. It was "
":ref:`removed in Python 3.13 <whatsnew313-pep594>` after being deprecated"
" in Python 3.11.  The removal was decided in :pep:`594`."
msgstr ""

#: ../../library/crypt.rst:14
msgid ""
"Applications can use the :mod:`hashlib` module from the standard library."
" Other possible replacements are third-party libraries from PyPI: "
":pypi:`legacycrypt`, :pypi:`bcrypt`, :pypi:`argon2-cffi`, or "
":pypi:`passlib`. These are not supported or maintained by the Python core"
" team."
msgstr ""

#: ../../library/crypt.rst:19
msgid ""
"The last version of Python that provided the :mod:`!crypt` module was "
"`Python 3.12 <https://docs.python.org/3.12/library/crypt.html>`_."
msgstr ""

#~ msgid "**Source code:** :source:`Lib/crypt.py`"
#~ msgstr "**소스 코드:** :source:`Lib/crypt.py`"

#~ msgid ""
#~ "This module implements an interface to"
#~ " the :manpage:`crypt(3)` routine, which is"
#~ " a one-way hash function based "
#~ "upon a modified DES algorithm; see "
#~ "the Unix man page for further "
#~ "details.  Possible uses include storing "
#~ "hashed passwords so you can check "
#~ "passwords without storing the actual "
#~ "password, or attempting to crack Unix"
#~ " passwords with a dictionary."
#~ msgstr ""
#~ "이 모듈은 수정된 DES 알고리즘을 기반으로 하는 "
#~ "단방향 해시 함수인 :manpage:`crypt(3)` 루틴에 대한"
#~ " 인터페이스를 구현합니다; 자세한 내용은 유닉스 매뉴얼 "
#~ "페이지를 참조하십시오. 가능한 용도는 실제 암호를 저장하지"
#~ " 않고 암호를 확인하기 위해 해시 된 암호를 "
#~ "저장하거나 사전으로 유닉스 암호를 해독하려고 시도하는 것을"
#~ " 포함합니다."

#~ msgid ""
#~ "Notice that the behavior of this "
#~ "module depends on the actual "
#~ "implementation  of the :manpage:`crypt(3)` "
#~ "routine in the running system.  "
#~ "Therefore, any extensions available on "
#~ "the current implementation will also  be"
#~ " available on this module."
#~ msgstr ""
#~ "이 모듈의 동작은 실행 중인 시스템의 "
#~ ":manpage:`crypt(3)` 루틴의 실제 구현에 따라 달라집니다."
#~ " 따라서, 현재 구현에서 사용할 수 있는 모든 "
#~ "확장을 이 모듈에서도 사용할 수 있습니다."

#~ msgid ":ref:`Availability <availability>`: Unix. Not available on VxWorks."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스. VxWorks에서는 사용할 수 없습니다."

#~ msgid "Hashing Methods"
#~ msgstr "해싱 방법"

#~ msgid ""
#~ "The :mod:`crypt` module defines the list"
#~ " of hashing methods (not all methods"
#~ " are available on all platforms):"
#~ msgstr ":mod:`crypt` 모듈은 해싱 방법 목록을 정의합니다 (모든 플랫폼에서 모든 방법을 사용할 수 있는 것은 아닙니다):"

#~ msgid ""
#~ "A Modular Crypt Format method with "
#~ "16 character salt and 86 character "
#~ "hash based on the SHA-512 hash "
#~ "function.  This is the strongest method."
#~ msgstr ""
#~ "SHA-512 해시 함수를 기반으로 16문자의 솔트(salt)와 "
#~ "86문자의 해시를 사용하는 모듈형 암호 형식(Modular "
#~ "Crypt Format) 방법. 이것은 가장 강력한 "
#~ "방법입니다."

#~ msgid ""
#~ "Another Modular Crypt Format method with"
#~ " 16 character salt and 43 character"
#~ " hash based on the SHA-256 hash "
#~ "function."
#~ msgstr "SHA-256 해시 함수를 기반으로 16자의 솔트와 43자의 해시를 사용하는 또 다른 모듈형 암호 형식 방법."

#~ msgid ""
#~ "Another Modular Crypt Format method with"
#~ " 22 character salt and 31 character"
#~ " hash based on the Blowfish cipher."
#~ msgstr "Blowfish 암호를 기반으로 22문자의 솔트와 31문자의 해시를 사용하는 또 다른 모듈형 암호 형식 방법."

#~ msgid ""
#~ "Another Modular Crypt Format method with"
#~ " 8 character salt and 22 character"
#~ " hash based on the MD5 hash "
#~ "function."
#~ msgstr "MD5 해시 함수를 기반으로 8자의 솔트와 22자의 해시를 사용하는 또 다른 모듈형 암호 형식 방법."

#~ msgid ""
#~ "The traditional method with a 2 "
#~ "character salt and 13 characters of "
#~ "hash.  This is the weakest method."
#~ msgstr "2문자의 솔트와 13문자의 해시를 사용하는 전통적인 방법. 이것은 가장 약한 방법입니다."

#~ msgid "Module Attributes"
#~ msgstr "모듈 어트리뷰트"

#~ msgid ""
#~ "A list of available password hashing "
#~ "algorithms, as ``crypt.METHOD_*`` objects.  "
#~ "This list is sorted from strongest "
#~ "to weakest."
#~ msgstr ""
#~ "사용 가능한 비밀번호 해싱 알고리즘 리스트, "
#~ "``crypt.METHOD_*`` 객체들. 이 리스트는 가장 강한 "
#~ "것부터 가장 약한 것 순으로 정렬됩니다."

#~ msgid "Module Functions"
#~ msgstr "모듈 함수"

#~ msgid "The :mod:`crypt` module defines the following functions:"
#~ msgstr ":mod:`crypt` 모듈은 다음 함수를 정의합니다:"

#~ msgid ""
#~ "*word* will usually be a user's "
#~ "password as typed at a prompt or"
#~ "  in a graphical interface.  The "
#~ "optional *salt* is either a string "
#~ "as returned from :func:`mksalt`, one of"
#~ " the ``crypt.METHOD_*`` values (though not"
#~ " all may be available on all "
#~ "platforms), or a full encrypted password"
#~ " including salt, as returned by this"
#~ " function.  If *salt* is not "
#~ "provided, the strongest method will be"
#~ " used (as returned by :func:`methods`)."
#~ msgstr ""
#~ "*word*\\는 대개 프롬프트나 그래픽 인터페이스에서 입력한 "
#~ "사용자의 비밀번호입니다. 선택적 *salt*\\는 :func:`mksalt`\\에서"
#~ " 반환된 문자열, ``crypt.METHOD_*`` 값 중 "
#~ "하나(모든 플랫폼에서 모든 것을 사용할 수 있는 "
#~ "것은 아니지만), 또는 이 함수가 반환하는 솔트를 "
#~ "포함한 전체 암호화된 비밀번호입니다. *salt*\\가 제공되지 "
#~ "않으면, (:func:`methods`\\에서 반환되는) 가장 강력한 "
#~ "방법이 사용됩니다."

#~ msgid ""
#~ "Checking a password is usually done "
#~ "by passing the plain-text password "
#~ "as *word* and the full results of"
#~ " a previous :func:`crypt` call, which "
#~ "should be the same as the results"
#~ " of this call."
#~ msgstr ""
#~ "비밀번호 확인은 일반적으로 *word*\\로 평문 비밀번호를 "
#~ "전달하는 것으로 수행됩니다. 이전 :func:`crypt` 호출의 "
#~ "전체 결과와 이 호출의 결과가 같아야 합니다."

#~ msgid ""
#~ "*salt* (either a random 2 or 16"
#~ " character string, possibly prefixed with"
#~ " ``$digit$`` to indicate the method) "
#~ "which will be used to perturb the"
#~ " encryption algorithm.  The characters in"
#~ " *salt* must be in the set "
#~ "``[./a-zA-Z0-9]``, with the exception of "
#~ "Modular Crypt Format which prefixes a"
#~ " ``$digit$``."
#~ msgstr ""
#~ "*salt*\\(무작위의 2자나 16자 문자열, 방법을 가리키기 "
#~ "위해 앞에 ``$digit$``\\가 붙을 수 있음)는 암호화"
#~ " 알고리즘을 교란하는 데 사용됩니다. *salt*\\의 문자는"
#~ " ``$digit$``\\를 앞에 붙이는 모듈형 암호 형식을 "
#~ "제외하고는 ``[./a-zA-Z0-9]`` 집합에 있어야 합니다."

#~ msgid ""
#~ "Returns the hashed password as a "
#~ "string, which will be composed of "
#~ "characters from the same alphabet as "
#~ "the salt."
#~ msgstr "해시 된 비밀번호를 문자열로 반환합니다. 이 문자열은 솔트와 같은 알파벳의 문자로 구성됩니다."

#~ msgid ""
#~ "Since a few :manpage:`crypt(3)` extensions "
#~ "allow different values, with different "
#~ "sizes in the *salt*, it is "
#~ "recommended to use  the full crypted "
#~ "password as salt when checking for "
#~ "a password."
#~ msgstr ""
#~ "몇 가지 :manpage:`crypt(3)` 확장이 *salt*\\에 "
#~ "다른 크기의 다른 값을 허용하기 때문에, 암호를 "
#~ "확인할 때 전체 암호화된 비밀번호를 솔트로 사용하는 "
#~ "것이 좋습니다."

#~ msgid "Accept ``crypt.METHOD_*`` values in addition to strings for *salt*."
#~ msgstr "*salt*\\에 대한 문자열 외에 ``crypt.METHOD_*`` 값을 받아들입니다."

#~ msgid ""
#~ "Return a randomly generated salt of "
#~ "the specified method.  If no *method*"
#~ " is given, the strongest method "
#~ "available as returned by :func:`methods` "
#~ "is used."
#~ msgstr ""
#~ "지정된 방법의 무작위로 생성된 솔트를 반환합니다. "
#~ "*method*\\가 주어지지 않으면, :func:`methods`\\에 의해"
#~ " 반환된 가장 강력한 방법이 사용됩니다."

#~ msgid ""
#~ "The return value is a string "
#~ "suitable for passing as the *salt* "
#~ "argument to :func:`crypt`."
#~ msgstr "반환 값은 *salt* 인자로 :func:`crypt`\\에 전달하기에 적합한 문자열입니다."

#~ msgid ""
#~ "*rounds* specifies the number of rounds"
#~ " for ``METHOD_SHA256``, ``METHOD_SHA512`` and "
#~ "``METHOD_BLOWFISH``. For ``METHOD_SHA256`` and "
#~ "``METHOD_SHA512`` it must be an integer"
#~ " between ``1000`` and ``999_999_999``, the"
#~ " default is ``5000``.  For "
#~ "``METHOD_BLOWFISH`` it must be a power"
#~ " of two between ``16`` (2\\ :sup:`4`)"
#~ " and ``2_147_483_648`` (2\\ :sup:`31`), the"
#~ " default is ``4096`` (2\\ :sup:`12`)."
#~ msgstr ""
#~ "*rounds*\\는 ``METHOD_SHA256``, ``METHOD_SHA512`` 및"
#~ " ``METHOD_BLOWFISH``\\에 대한 라운드 수를 지정합니다."
#~ " ``METHOD_SHA256`` 과 ``METHOD_SHA512``\\의 경우 "
#~ "``1000``\\와 ``999_999_999`` 사이의 정수여야 하며, "
#~ "기본값은 ``5000``\\입니다. ``METHOD_BLOWFISH``\\의 경우 "
#~ "``16``\\(2\\ :sup:`4`)과 ``2_147_483_648``\\(2\\ "
#~ ":sup:`31`) 사이의 2의 거듭제곱이어야 하며, 기본값은 "
#~ "``4096``\\(2\\ :sup:`12`)입니다."

#~ msgid "Added the *rounds* parameter."
#~ msgstr "*rounds* 매개 변수가 추가되었습니다."

#~ msgid "Examples"
#~ msgstr "예제"

#~ msgid ""
#~ "A simple example illustrating typical "
#~ "use (a constant-time comparison "
#~ "operation is needed to limit exposure"
#~ " to timing attacks. :func:`hmac.compare_digest`"
#~ " is suitable for this purpose)::"
#~ msgstr ""
#~ "일반적인 사용법을 보여주는 간단한 예제 (타이밍 공격에 "
#~ "대한 노출을 제한하기 위해서는 상수 시간 비교 "
#~ "연산이 필요합니다. :func:`hmac.compare_digest`\\가 이 "
#~ "목적에 적합합니다)::"

#~ msgid ""
#~ "To generate a hash of a password"
#~ " using the strongest available method "
#~ "and check it against the original::"
#~ msgstr "가장 강력한 방법을 사용하여 비밀번호의 해시를 생성하고, 원본과 비교하여 확인하려면 이렇게 합니다::"

