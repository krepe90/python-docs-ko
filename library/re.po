# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/re.rst:2
#, fuzzy
msgid ":mod:`!re` --- Regular expression operations"
msgstr ":mod:`re` --- 정규식 연산"

#: ../../library/re.rst:10
#, fuzzy
msgid "**Source code:** :source:`Lib/re/`"
msgstr "**소스 코드:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to "
"those found in Perl."
msgstr "이 모듈은 Perl에 있는 것과 유사한 정규식 일치 연산을 제공합니다."

#: ../../library/re.rst:17
#, fuzzy
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, "
"Unicode strings and 8-bit strings cannot be mixed: that is, you cannot "
"match a Unicode string with a bytes pattern or vice-versa; similarly, "
"when asking for a substitution, the replacement string must be of the "
"same type as both the pattern and the search string."
msgstr ""
"패턴과 검색 할 문자열은 모두 유니코드 문자열(:class:`str`)과 8비트 문자열(:class:`bytes`)이 될 수 "
"있습니다. 그러나, 유니코드 문자열과 8비트 문자열은 혼합될 수 없습니다: 즉, 유니코드 문자열을 바이트열 패턴과 일치시킬 수 "
"없으며 그 반대도 마찬가지입니다; 마찬가지로, 치환을 요청할 때, 치환 문자열은 패턴과 검색 문자열과 같은 형이어야 합니다."

#: ../../library/re.rst:24
#, fuzzy
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match "
"a literal backslash, one might have to write ``'\\\\\\\\'`` as the "
"pattern string, because the regular expression must be ``\\\\``, and each"
" backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal. Also, please note that any invalid escape sequences in Python's "
"usage of the backslash in string literals now generate a "
":exc:`SyntaxWarning` and in the future this will become a "
":exc:`SyntaxError`. This behaviour will happen even if it is a valid "
"escape sequence for a regular expression."
msgstr ""
"정규식은 역 슬래시 문자(``'\\'``)를 사용하여 특수 형식을 나타내거나 특별한 의미를 갖지 않고 특수 문자를 사용할 수 있게 "
"합니다. 이것은 문자열 리터럴에서 같은 목적을 위해 같은 문자를 사용하는 파이썬과 충돌합니다; 예를 들어, 리터럴 역 슬래시와 "
"일치시키려면 ``'\\\\\\\\'``\\를 패턴 문자열로 작성해야 하는데, 정규식은 ``\\\\`` 여야하고, 각 역 슬래시는 "
"일반 파이썬 문자열 리터럴 내에서 ``\\\\``\\로 표현되어야 하기 때문입니다. 또한, 파이썬의 문자열 리터럴에서 역 슬래시가 "
"사용될 때 유효하지 않은 이스케이프 시퀀스는 이제 :exc:`DeprecationWarning`\\을 생성하고 앞으로는 "
":exc:`SyntaxError`\\가 될 것이라는 점에 유의하십시오. 이 동작은 정규식에서 유효한 이스케이프 시퀀스인 경우에도 "
"발생합니다."

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular "
"expression patterns; backslashes are not handled in any special way in a "
"string literal prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character"
" string containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-"
"character string containing a newline.  Usually patterns will be "
"expressed in Python code using this raw string notation."
msgstr ""
"해결책은 정규식 패턴에 파이썬의 날 문자열(raw string) 표기법을 사용하는 것입니다; 역 슬래시는 ``'r'`` 접두어가 "
"붙은 문자열 리터럴에서 특별한 방법으로 처리되지 않습니다. 따라서 ``r\"\\n\"``\\은 ``'\\'``\\와 "
"``'n'``\\을 포함하는 두 글자 문자열이고, ``\"\\n\"``\\은 개행을 포함하는 한 글자 문자열입니다. 일반적으로 "
"패턴은, 이 날 문자열 표기법을 사용하여 파이썬 코드로 표현됩니다."

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular"
" expressions <re-objects>`.  The functions are shortcuts that don't "
"require you to compile a regex object first, but miss some fine-tuning "
"parameters."
msgstr ""
"대부분 정규식 연산은 모듈 수준 함수와 :ref:`컴파일된 정규식 <re-objects>`\\의 메서드로 사용할 수 있다는 점에 "
"유의해야 합니다. 함수는 정규식 객체를 먼저 컴파일할 필요가 없도록 하는 바로 가기이지만, 일부 미세 조정 매개 변수가 "
"빠져있습니다."

#: ../../library/re.rst:51
#, fuzzy
msgid ""
"The third-party :pypi:`regex` module, which has an API compatible with "
"the standard library :mod:`re` module, but offers additional "
"functionality and a more thorough Unicode support."
msgstr ""
"제삼자 `regex <https://pypi.org/project/regex/>`_ 모듈은 표준 라이브러리 :mod:`re` 모듈과"
" 호환되는 API를 가지고 있지만, 추가 기능과 더 철저한 유니코드 지원을 제공합니다."

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "정규식 문법"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; "
"the functions in this module let you check if a particular string matches"
" a given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"정규식(또는 RE)은 일치하는 문자열 집합을 지정합니다; 이 모듈의 함수는 특정 문자열이 주어진 정규식과 일치하는지 확인할 수 "
"있도록 합니다 (또는 주어진 정규식이 특정 문자열과 일치하는지, 결국 같은 결과를 줍니다)."

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; "
"if *A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string "
"*q* matches *B*, the string *pq* will match AB.  This holds unless *A* or"
" *B* contain low precedence operations; boundary conditions between *A* "
"and *B*; or have numbered group references.  Thus, complex expressions "
"can easily be constructed from simpler primitive expressions like the "
"ones described here.  For details of the theory and implementation of "
"regular expressions, consult the Friedl book [Frie09]_, or almost any "
"textbook about compiler construction."
msgstr ""
"정규식을 이어붙여서 새로운 정규식을 만들 수 있습니다; *A*\\와 *B*\\가 모두 정규식이면 *AB*\\도 정규식입니다. "
"일반적으로 문자열 *p*\\가 *A*\\와 일치하고 다른 문자열 *q*\\가 *B*\\와 일치하면 문자열 *pq*\\가 AB와 "
"일치합니다. 이것은 *A*\\나 *B*\\가 우선순위가 낮은 연산, *A*\\와 *B* 사이의 경계 조건 또는 숫자 그룹 참조를 "
"포함하지 않는 한 성립합니다. 따라서, 복잡한 정규식은 여기에 설명된 것과 같은 더 단순한 기본 정규식으로 쉽게 구성할 수 "
"있습니다. 정규식의 이론과 구현에 관한 자세한 내용은 Friedl 책 [Frie09]_, 또는 컴파일러 작성에 관한 거의 모든 "
"교과서를 참조하십시오."

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"정규식의 형식에 대한 간단한 설명이 이어집니다. 더 자세한 정보와 더 친절한 소개는 :ref:`regex-howto`\\를 "
"참조하십시오."

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. "
"Most ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the "
"simplest regular expressions; they simply match themselves.  You can "
"concatenate ordinary characters, so ``last`` matches the string "
"``'last'``.  (In the rest of this section, we'll write RE's in ``this "
"special style``, usually without quotes, and strings to be matched ``'in "
"single quotes'``.)"
msgstr ""
"정규식은 특수 문자와 일반 문자를 모두 포함 할 수 있습니다. ``'A'``, ``'a'`` 또는 ``'0'``\\과 같은 대부분의"
" 일반 문자는 가장 단순한 정규식입니다; 그들은 단순히 자신과 일치합니다. 일반 문자를 이어 붙일 수 있어서, ``last``\\는"
" ``'last'`` 문자열과 일치합니다. (이 절의 나머지 부분에서는, RE를 (보통 따옴표 없이) ``이런 특별한 "
"스타일``\\로, 일치할 문자열은 ``'작은따옴표 안에'`` 씁니다.)"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters"
" either stand for classes of ordinary characters, or affect how the "
"regular expressions around them are interpreted."
msgstr ""
"``'|'``\\나 ``'('``\\와 같은 일부 문자는 특수합니다. 특수 문자는 일반 문자의 클래스를 나타내거나, 그 주변의 "
"정규식이 해석되는 방식에 영향을 줍니다."

#: ../../library/re.rst:90
#, fuzzy, python-brace-format
msgid ""
"Repetition operators or quantifiers (``*``, ``+``, ``?``, ``{m,n}``, etc)"
" cannot be directly nested. This avoids ambiguity with the non-greedy "
"modifier suffix ``?``, and with other modifiers in other implementations."
" To apply a second repetition to an inner repetition, parentheses may be "
"used. For example, the expression ``(?:a{6})*`` matches any multiple of "
"six ``'a'`` characters."
msgstr ""
"반복 한정자(``*``, ``+``, ``?``, ``{m,n}`` 등)는 직접 중첩될 수 없습니다. 이렇게 하면 비 탐욕적인 "
"수정자 접미사인 ``?``\\와 다른 구현의 다른 수정자와의 모호함을 피할 수 있습니다. 내부 반복에 두 번째 반복을 적용하려면 "
"괄호를 사용할 수 있습니다. 예를 들어, 정규식 ``(?:a{6})*``\\는 여섯 개의 ``'a'`` 문자가 임의로 반복되는 것과"
" 일치합니다."

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "특수 문자는 다음과 같습니다:"

#: ../../library/re.rst:101 ../../library/re.rst:1658
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
#, fuzzy
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline."
"  If the :const:`DOTALL` flag has been specified, this matches any "
"character including a newline.  ``(?s:.)`` matches any character "
"regardless of flags."
msgstr ""
"(점.) 기본 모드에서, 이것은 개행 문자를 제외한 모든 문자와 일치합니다. :const:`DOTALL` 플래그가 지정되면, 개행 "
"문자를 포함한 모든 문자와 일치합니다."

#: ../../library/re.rst:108
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode"
" also matches immediately after each newline."
msgstr "(캐럿.) 문자열의 시작과 일치하고, :const:`MULTILINE` 모드에서는 각 개행 직후에도 일치합니다."

#: ../../library/re.rst:114
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of "
"the string, and in :const:`MULTILINE` mode also matches before a newline."
"  ``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$``"
" in ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` "
"will find two (empty) matches: one just before the newline, and one at "
"the end of the string."
msgstr ""
"문자열의 끝이나 문자열 끝의 개행 문자 바로 직전과 일치하고, :const:`MULTILINE` 모드에서는 개행 문자 앞에서도 "
"일치합니다. ``foo``\\는 'foo'와 'foobar'를 모두 일치시키는 반면, 정규식 ``foo$``\\는 'foo' 만 "
"일치합니다. 흥미롭게도, ``'foo1\\nfoo2\\n'``\\에서 ``foo.$``\\를 검색하면 'foo2' 는 정상적으로 "
"일치되지만, 'foo1'은 :const:`MULTILINE` 모드에서 검색됩니다; ``'foo\\n'``\\에서 단일 "
"``$``\\를 검색하면 두 개의 (빈) 일치가 발견됩니다: 하나는 개행 직전에, 다른 하나는 문자열 끝에."

#: ../../library/re.rst:125
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding "
"RE, as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', "
"or 'a' followed by any number of 'b's."
msgstr ""
"결과 RE가 선행 RE의 가능한 한 많은 0회 이상의 반복과 일치하도록 합니다. ``ab*``\\는 'a', 'ab' 또는 'a' "
"다음에 임의의 수의 'b'가 오는 것과 일치합니다."

#: ../../library/re.rst:132
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding "
"RE. ``ab+`` will match 'a' followed by any non-zero number of 'b's; it "
"will not match just 'a'."
msgstr ""
"결과 RE가 선행 RE의 1회 이상의 반복과 일치하도록 합니다. ``ab+``\\는 'a' 다음에 하나 이상의 'b'가 오는 것과 "
"일치합니다; 단지 'a'와는 일치하지 않습니다."

#: ../../library/re.rst:139
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr "결과 RE가 선행 RE의 0 또는 1 반복과 일치하도록 합니다. ``ab?``\\는 'a'나 'ab'와 일치합니다."

#: ../../library/re.rst:148
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
#, fuzzy
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` quantifiers are all :dfn:`greedy`; they"
" match as much text as possible.  Sometimes this behaviour isn't desired;"
" if the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the"
" entire string, and not just ``'<a>'``.  Adding ``?`` after the "
"quantifier makes it perform the match in :dfn:`non-greedy` or "
":dfn:`minimal` fashion; as *few* characters as possible will be matched."
"  Using the RE ``<.*?>`` will match only ``'<a>'``."
msgstr ""
"``'*'``, ``'+'`` 및 ``'?'`` 한정자는 모두 :dfn:`탐욕적 (greedy)`\\입니다; 가능한 한 많은 "
"텍스트와 일치합니다. 때로는 이 동작이 바람직하지 않습니다; RE ``<.*>``\\를 ``'<a> b <c>'``\\와 "
"일치시키면, ``'<a>'``\\가 아닌 전체 문자열과 일치합니다. 한정자 뒤에 ``?``\\를 추가하면 :dfn:`비 탐욕적 "
"(non-greedy)` 또는 :dfn:`최소 (minimal)` 방식으로 일치를 수행합니다; 가능하면 *적은* 문자가 일치합니다."
" RE ``<.*?>``\\를 사용하면 ``'<a>'`` 만 일치합니다."

#: ../../library/re.rst:162
#, fuzzy
msgid "``*+``, ``++``, ``?+``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:163
msgid ""
"Like the ``'*'``, ``'+'``, and ``'?'`` quantifiers, those where ``'+'`` "
"is appended also match as many times as possible. However, unlike the "
"true greedy quantifiers, these do not allow back-tracking when the "
"expression following it fails to match. These are known as "
":dfn:`possessive` quantifiers. For example, ``a*a`` will match ``'aaaa'``"
" because the ``a*`` will match all 4 ``'a'``\\ s, but, when the final "
"``'a'`` is encountered, the expression is backtracked so that in the end "
"the ``a*`` ends up matching 3 ``'a'``\\ s total, and the fourth ``'a'`` "
"is matched by the final ``'a'``. However, when ``a*+a`` is used to match "
"``'aaaa'``, the ``a*+`` will match all 4 ``'a'``, but when the final "
"``'a'`` fails to find any more characters to match, the expression cannot"
" be backtracked and will thus fail to match. ``x*+``, ``x++`` and ``x?+``"
" are equivalent to ``(?>x*)``, ``(?>x+)`` and ``(?>x?)`` correspondingly."
msgstr ""

#: ../../library/re.rst:184
#, python-brace-format
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:185
#, python-brace-format
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` "
"will match exactly six ``'a'`` characters, but not five."
msgstr ""
"선행 RE의 정확히 *m* 복사가 일치하도록 지정합니다; 적은 횟수의 일치는 전체 RE가 일치하지 않게 됩니다. 예를 들어, "
"``a{6}``\\는 정확히 6개의 ``'a'`` 문자와 일치하지만, 5개의 문자와는 일치하지 않습니다."

#: ../../library/re.rst:189
#, python-brace-format
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:190
#, python-brace-format
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting "
"*m* specifies a lower bound of zero,  and omitting *n* specifies an "
"infinite upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` "
"or a thousand ``'a'`` characters followed by a ``'b'``, but not "
"``'aaab'``. The comma may not be omitted or the modifier would be "
"confused with the previously described form."
msgstr ""
"결과 RE를 선행 RE의 *m*\\에서 *n* 사이의 최대한 많은 반복과 일치하도록 합니다. 예를 들어, ``a{3,5}``\\는 "
"3에서 5개의 ``'a'`` 문자와 일치합니다. *m*\\을 생략하면 하한값 0이 지정되고, *n*\\을 생략하면 무한한 상한이 "
"지정됩니다. 예를 들어, ``a{4,}b``\\는 ``'aaaab'`` 나 1000개의 ``'a'`` 문자와 ``'b'``\\가 "
"일치하지만, ``'aaab'``\\는 일치하지 않습니다. 콤마는 생략할 수 없습니다, 그렇지 않으면 한정자가 앞에서 설명한 형식과 "
"혼동될 수 있습니다."

#: ../../library/re.rst:198
#, python-brace-format
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:199
#, fuzzy, python-brace-format
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This"
" is the non-greedy version of the previous quantifier.  For example, on "
"the 6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` "
"characters, while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"결과 RE를 선행 RE의 *m*\\에서 *n* 사이의 가능한 한 *적은* 반복과 일치하도록 합니다. 이것은 이전 한정자의 비 탐욕적"
" 버전입니다. 예를 들어, 6문자 문자열 ``'aaaaaa'``\\에서, ``a{3,5}``\\는 5개의 ``'a'`` 문자와 "
"일치하고, ``a{3,5}?``\\는 3개의 문자만 일치합니다."

#: ../../library/re.rst:205
#, fuzzy, python-brace-format
msgid "``{m,n}+``"
msgstr "``{m,n}``"

#: ../../library/re.rst:206
#, fuzzy, python-brace-format
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible "
"*without* establishing any backtracking points. This is the possessive "
"version of the quantifier above. For example, on the 6-character string "
"``'aaaaaa'``, ``a{3,5}+aa`` attempt to match 5 ``'a'`` characters, then, "
"requiring 2 more ``'a'``\\ s, will need more characters than available "
"and thus fail, while ``a{3,5}aa`` will match with ``a{3,5}`` capturing 5,"
" then 4 ``'a'``\\ s by backtracking and then the final 2 ``'a'``\\ s are "
"matched by the final ``aa`` in the pattern. ``x{m,n}+`` is equivalent to "
"``(?>x{m,n})``."
msgstr ""
"결과 RE를 선행 RE의 *m*\\에서 *n* 사이의 가능한 한 *적은* 반복과 일치하도록 합니다. 이것은 이전 한정자의 비 탐욕적"
" 버전입니다. 예를 들어, 6문자 문자열 ``'aaaaaa'``\\에서, ``a{3,5}``\\는 5개의 ``'a'`` 문자와 "
"일치하고, ``a{3,5}?``\\는 3개의 문자만 일치합니다."

#: ../../library/re.rst:222
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:223
msgid ""
"Either escapes special characters (permitting you to match characters "
"like ``'*'``, ``'?'``, and so forth), or signals a special sequence; "
"special sequences are discussed below."
msgstr ""
"특수 문자를 이스케이프 하거나 (``'*'``, ``'?'`` 등의 문자를 일치시킬 수 있도록 합니다), 특수 시퀀스를 알립니다; "
"특수 시퀀스는 아래에서 설명합니다."

#: ../../library/re.rst:227
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; "
"if the escape sequence isn't recognized by Python's parser, the backslash"
" and subsequent character are included in the resulting string.  However,"
" if Python would recognize the resulting sequence, the backslash should "
"be repeated twice.  This is complicated and hard to understand, so it's "
"highly recommended that you use raw strings for all but the simplest "
"expressions."
msgstr ""
"날 문자열을 사용하여 패턴을 표현하지 않는다면, 파이썬이 문자열 리터럴에서 이스케이프 시퀀스로 역 슬래시를 사용한다는 것을 "
"기억하십시오; 이스케이프 시퀀스가 파이썬의 구문 분석기에 의해 인식되지 않으면, 역 슬래시와 후속 문자가 결과 문자열에 포함됩니다."
" 그러나 파이썬이 결과 시퀀스를 인식한다면 역 슬래시는 두 번 반복되어야 합니다. 이것은 복잡하고 이해하기 어렵기 때문에, 가장 "
"단순한 표현 이외에는 날 문자열을 사용하는 것이 좋습니다."

#: ../../library/re.rst:238
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:239
msgid "Used to indicate a set of characters.  In a set:"
msgstr "문자 집합을 나타내는 데 사용됩니다. 집합 안에서:"

#: ../../library/re.rst:241
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``,"
" ``'m'``, or ``'k'``."
msgstr ""
"문자는 개별적으로 나열 할 수 있습니다, 예를 들어 ``[amk]``\\는 ``'a'``, ``'m'`` 또는 ``'k'``\\와 "
"일치합니다."

#: ../../library/re.rst:246
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any "
"lowercase ASCII letter, ``[0-5][0-9]`` will match all the two-digits "
"numbers from ``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any "
"hexadecimal digit.  If ``-`` is escaped (e.g. ``[a\\-z]``) or if it's "
"placed as the first or last character (e.g. ``[-a]`` or ``[a-]``), it "
"will match a literal ``'-'``."
msgstr ""
"문자의 범위는 ``'-'``\\로 구분된 두 문자를 주고는 것으로 나타낼 수 있습니다, 예를 들어 ``[a-z]``\\는 모든 "
"소문자 ASCII 문자와 일치하고, ``[0-5][0-9]``\\는 ``00``\\에서 ``59``\\까지의 모든 두 자리 숫자와 "
"일치하며, ``[0-9A-Fa-f]``\\는 모든 16진수와 일치합니다. ``-``\\가 이스케이프 처리되거나 (예를 들어 "
"``[a\\-z]``) 첫 번째나 마지막 문자로 배치되면 (예를 들어 ``[-a]``\\나 ``[a-]``) 리터럴 "
"``'-'``\\와 일치합니다."

#: ../../library/re.rst:253
#, fuzzy
msgid ""
"Special characters except backslash lose their special meaning inside "
"sets. For example, ``[(+*)]`` will match any of the literal characters "
"``'('``, ``'+'``, ``'*'``, or ``')'``."
msgstr ""
"특수 문자는 집합 내에서 특별한 의미를 상실합니다. 예를 들어, ``[(+*)]``\\는 리터럴 문자 ``'('``, "
"``'+'``, ``'*'`` 또는 ``')'``\\와 일치합니다."

#: ../../library/re.rst:260
msgid ""
"Backslash either escapes characters which have special meaning in a set "
"such as ``'-'``, ``']'``, ``'^'`` and ``'\\\\'`` itself or signals a "
"special sequence which represents a single character such as ``\\xa0`` or"
" ``\\n`` or a character class such as ``\\w`` or ``\\S`` (defined below)."
" Note that ``\\b`` represents a single \"backspace\" character, not a "
"word boundary as outside a set, and numeric escapes such as ``\\1`` are "
"always octal escapes, not group references. Special sequences which do "
"not match a single character such as ``\\A`` and ``\\Z`` are not allowed."
msgstr ""

#: ../../library/re.rst:273
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is "
"``'^'``, all the characters that are *not* in the set will be matched.  "
"For example, ``[^5]`` will match any character except ``'5'``, and "
"``[^^]`` will match any character except ``'^'``.  ``^`` has no special "
"meaning if it's not the first character in the set."
msgstr ""
"범위 내에 있지 않은 문자는 :dfn:`여집합(complementing)`\\을 만들어 일치할 수 있습니다. 집합의 첫 번째 문자가"
" ``'^'``\\이면, 집합에 속하지 *않은* 모든 문자가 일치합니다. 예를 들어, ``[^5]``\\는 ``'5'``\\를 "
"제외한 모든 문자와 일치하며, ``[^^]``\\는 ``'^'``\\를 제외한 모든 문자와 일치합니다. ``^``\\는 집합의 첫 "
"번째 문자가 아닐 때 특별한 의미가 없습니다."

#: ../../library/re.rst:280
#, fuzzy, python-brace-format
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` "
"and ``[]()[{}]`` will match a right bracket, as well as left bracket, "
"braces, and parentheses."
msgstr ""
"집합 내에서 리터럴 ``']'``\\를 일치시키려면, 앞에 역 슬래시를 붙이거나, 집합의 시작 부분에 배치하십시오. 예를 들어, "
"``[()[\\]{}]``\\와 ``[]()[{}]``\\는 둘 다 괄호와 일치합니다."

#: ../../library/re.rst:290
msgid ""
"Support of nested sets and set operations as in `Unicode Technical "
"Standard #18`_ might be added in the future.  This would change the "
"syntax, so to facilitate this change a :exc:`FutureWarning` will be "
"raised in ambiguous cases for the time being. That includes sets starting"
" with a literal ``'['`` or containing literal character sequences "
"``'--'``, ``'&&'``, ``'~~'``, and ``'||'``.  To avoid a warning escape "
"them with a backslash."
msgstr ""
"`유니코드 기술 표준 #18 <Unicode Technical Standard #18_>`_ 에서 정의하는 중첩 집합과 집합 연산의"
" 지원이 다음에 추가될 수 있습니다. 이것은 문법을 변경하므로, 이 변경을 용이하게 하기 위해 당분간 "
":exc:`FutureWarning`\\이 모호한 경우에 발생합니다. 여기에는 리터럴 ``'['``\\로 시작하거나 리터럴 문자 "
"시퀀스 ``'--'``, ``'&&'``, ``'~~'`` 및 ``'||'``\\가 포함된 집합이 포함됩니다. 경고를 피하려면 역 "
"슬래시로 이스케이프 처리하십시오."

#: ../../library/re.rst:300
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs "
"that will change semantically in the future."
msgstr "문자 집합이 미래에 의미가 변할 구조를 포함하고 있다면 :exc:`FutureWarning`\\이 발생합니다."

#: ../../library/re.rst:306
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:307
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs"
" can be separated by the ``'|'`` in this way.  This can be used inside "
"groups (see below) as well.  As the target string is scanned, REs "
"separated by ``'|'`` are tried from left to right. When one pattern "
"completely matches, that branch is accepted. This means that once *A* "
"matches, *B* will not be tested further, even if it would produce a "
"longer overall match.  In other words, the ``'|'`` operator is never "
"greedy.  To match a literal ``'|'``, use ``\\|``, or enclose it inside a "
"character class, as in ``[|]``."
msgstr ""
"``A|B``\\(여기서 *A*\\와 *B*\\는 임의의 RE일 수 있습니다)는 *A*\\나 *B*\\와 일치하는 정규식을 "
"만듭니다. 이러한 방식으로 임의의 수의 RE를 ``'|'``\\로 분리 할 수 있습니다. 이것은 그룹(아래를 참조하세요)에서도 "
"사용할 수 있습니다. 대상 문자열이 스캔 될 때 ``'|'``\\로 구분된 RE는 왼쪽에서 오른쪽으로 시도됩니다. 한 패턴이 완전히"
" 일치하면, 해당 분기가 받아들여집니다. 이는 일단 *A*\\가 일치하면, *B*\\는 전체적으로 더 긴 일치를 생성하더라도 더 "
"검사되지 않는다는 것을 뜻합니다. 즉, ``'|'`` 연산자는 절대로 탐욕적이지 않습니다. 리터럴 ``'|'``\\와 일치시키려면,"
" ``\\|``\\를 사용하거나, ``[|]``\\처럼 문자 클래스 안에 넣으십시오."

#: ../../library/re.rst:320
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:321
msgid ""
"Matches whatever regular expression is inside the parentheses, and "
"indicates the start and end of a group; the contents of a group can be "
"retrieved after a match has been performed, and can be matched later in "
"the string with the ``\\number`` special sequence, described below.  To "
"match the literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose"
" them inside a character class: ``[(]``, ``[)]``."
msgstr ""
"괄호 안에 있는 정규식과 일치하며, 그룹의 시작과 끝을 나타냅니다; 그룹의 내용은 일치가 수행된 후 조회할 수 있으며, 나중에 "
"문자열에서 ``\\number`` 특수 시퀀스로 일치시킬 수 있습니다 (아래에서 설명됩니다). 리터럴 ``'('``\\나 "
"``')'``\\를 일치시키려면, ``\\(``\\나 ``\\)``\\를 사용하거나, 문자 클래스 안에 넣으십시오: ``[(]``,"
" ``[)]``."

#: ../../library/re.rst:329
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:330
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions "
"usually do not create a new group; ``(?P<name>...)`` is the only "
"exception to this rule. Following are the currently supported extensions."
msgstr ""
"이것은 확장 표기법입니다 (그렇지 않으면 ``'('`` 다음에 오는 ``'?'``는 의미가 없습니다). ``'?'`` 다음의 첫 "
"번째 문자는 확장의 의미와 이후의 문법을 결정합니다. 확장은 대개 새 그룹을 만들지 않습니다; 이 규칙에 대한 유일한 예외는 "
"``(?P<name>...)``\\입니다. 다음은 현재 지원되는 확장입니다."

#: ../../library/re.rst:336
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:337
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) The group matches the empty string; the "
"letters set the corresponding flags for the entire regular expression:"
msgstr ""

#: ../../library/re.rst:342 ../../library/re.rst:374
msgid ":const:`re.A` (ASCII-only matching)"
msgstr ""

#: ../../library/re.rst:343 ../../library/re.rst:375
msgid ":const:`re.I` (ignore case)"
msgstr ""

#: ../../library/re.rst:344 ../../library/re.rst:376
msgid ":const:`re.L` (locale dependent)"
msgstr ""

#: ../../library/re.rst:345 ../../library/re.rst:377
msgid ":const:`re.M` (multi-line)"
msgstr ""

#: ../../library/re.rst:346 ../../library/re.rst:378
msgid ":const:`re.S` (dot matches all)"
msgstr ""

#: ../../library/re.rst:347 ../../library/re.rst:379
msgid ":const:`re.U` (Unicode matching)"
msgstr ""

#: ../../library/re.rst:348 ../../library/re.rst:380
msgid ":const:`re.X` (verbose)"
msgstr ""

#: ../../library/re.rst:350
msgid ""
"(The flags are described in :ref:`contents-of-module-re`.) This is useful"
" if you wish to include the flags as part of the regular expression, "
"instead of passing a *flag* argument to the :func:`re.compile` function. "
"Flags should be used first in the expression string."
msgstr ""

#: ../../library/re.rst:356
msgid "This construction can only be used at the start of the expression."
msgstr ""

#: ../../library/re.rst:361
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:362
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular"
" expression is inside the parentheses, but the substring matched by the "
"group *cannot* be retrieved after performing a match or referenced later "
"in the pattern."
msgstr ""
"일반 괄호의 비 포착 버전. 괄호 안의 정규식과 일치하지만, 그룹과 일치하는 부분 문자열은 일치를 수행한 후 조회하거나 나중에 "
"패턴에서 참조할 수 *없습니다*."

#: ../../library/re.rst:367
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:368
#, fuzzy
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one"
" or more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The "
"letters set or remove the corresponding flags for the part of the "
"expression:"
msgstr ""
"(집합 ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, ``'u'``, ``'x'``\\의 문자 중"
" 0개 이상, 선택적으로 ``'-'``\\와 그 뒤에 ``'i'``, ``'m'``, ``'s'``, ``'x'`` 중 하나 이상의"
" 문자가 따라옵니다.) 문자는 해당 플래그를 정규식의 일부에 대해 설정하거나 제거합니다: :const:`re.A` (ASCII만 "
"일치), :const:`re.I` (케이스 무시), :const:`re.L` (로케일 종속), :const:`re.M` (여러 "
"줄), :const:`re.S` (점이 모든 문자와 일치), :const:`re.U` (유니코드 일치) 및 :const:`re.X`"
" (상세 모드). (플래그는 :ref:`contents-of-module-re`\\에 설명되어 있습니다.)"

#: ../../library/re.rst:382
msgid "(The flags are described in :ref:`contents-of-module-re`.)"
msgstr ""

#: ../../library/re.rst:384
#, fuzzy
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used"
" as inline flags, so they can't be combined or follow ``'-'``.  Instead, "
"when one of them appears in an inline group, it overrides the matching "
"mode in the enclosing group.  In Unicode patterns ``(?a:...)`` switches "
"to ASCII-only matching, and ``(?u:...)`` switches to Unicode matching "
"(default).  In bytes patterns ``(?L:...)`` switches to locale dependent "
"matching, and ``(?a:...)`` switches to ASCII-only matching (default). "
"This override is only in effect for the narrow inline group, and the "
"original matching mode is restored outside of the group."
msgstr ""
"문자 ``'a'``, ``'L'`` 및 ``'u'``\\는 인라인 플래그로 사용될 때 상호 배타적이므로, ``'-'``\\와 "
"결합하거나 그 뒤에 올 수 없습니다. 대신, 이 중 하나가 인라인 그룹에 나타나면, 그것은 둘러싸는 그룹의 일치 모드를 "
"재정의합니다. 유니코드 패턴에서 ``(?a:...)``\\는 ASCII 전용 일치로 전환하고, ``(?u:...)``\\는 유니코드"
" 일치(기본값)로 전환합니다. 바이트열 패턴에서 ``(?L:...)``\\는 로케일 종속 일치로 전환하고, "
"``(?a:...)``\\는 ASCII 전용 일치(기본값)로 전환합니다. 이 재정의는 좁은 인라인 그룹에 대해서만 적용되며, 원래의"
" 일치 모드는 그룹 밖에서 복원됩니다."

#: ../../library/re.rst:396
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "문자 ``'a'``, ``'L'`` 및 ``'u'``\\도 그룹에서 사용할 수 있습니다."

#: ../../library/re.rst:399
#, fuzzy
msgid "``(?>...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:400
msgid ""
"Attempts to match ``...`` as if it was a separate regular expression, and"
" if successful, continues to match the rest of the pattern following it. "
"If the subsequent pattern fails to match, the stack can only be unwound "
"to a point *before* the ``(?>...)`` because once exited, the expression, "
"known as an :dfn:`atomic group`, has thrown away all stack points within "
"itself. Thus, ``(?>.*).`` would never match anything because first the "
"``.*`` would match all characters possible, then, having nothing left to "
"match, the final ``.`` would fail to match. Since there are no stack "
"points saved in the Atomic Group, and there is no stack point before it, "
"the entire expression would thus fail to match."
msgstr ""

#: ../../library/re.rst:416
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:417
#, fuzzy
msgid ""
"Similar to regular parentheses, but the substring matched by the group is"
" accessible via the symbolic group name *name*.  Group names must be "
"valid Python identifiers, and in :class:`bytes` patterns they can only "
"contain bytes in the ASCII range.  Each group name must be defined only "
"once within a regular expression.  A symbolic group is also a numbered "
"group, just as if the group were not named."
msgstr ""
"일반 괄호와 유사하지만, 그룹과 일치하는 부분 문자열은 기호 그룹 이름 *name*\\을 통해 액세스 할 수 있습니다. 그룹 이름은"
" 유효한 파이썬 식별자여야 하며, 각 그룹 이름은 정규식 내에서 한 번만 정의해야 합니다. 기호 그룹은 번호 그룹이기도 합니다, "
"마치 그룹이 이름 붙지 않은 것처럼."

#: ../../library/re.rst:424
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with "
"either single or double quotes):"
msgstr ""
"이름 있는 그룹은 세 가지 문맥에서 참조될 수 있습니다. 패턴이 ``(?P<quote>['\"]).*?(?P=quote)``\\면 "
"(즉, 작은따옴표나 큰따옴표로 인용된 문자열과 일치):"

#: ../../library/re.rst:429
msgid "Context of reference to group \"quote\""
msgstr "그룹 \"quote\"에 대한 참조 문맥"

#: ../../library/re.rst:429
msgid "Ways to reference it"
msgstr "참조하는 방법"

#: ../../library/re.rst:431
msgid "in the same pattern itself"
msgstr "같은 패턴 자체에서"

#: ../../library/re.rst:431
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (보이는 대로)"

#: ../../library/re.rst:432 ../../library/re.rst:439
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:434
msgid "when processing match object *m*"
msgstr "일치 객체 *m*\\을 처리할 때"

#: ../../library/re.rst:434
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:435
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (등)"

#: ../../library/re.rst:437
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "``re.sub()``\\의 *repl* 인자로 전달되는 문자열에서"

#: ../../library/re.rst:437
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:438
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:442
msgid ""
"In :class:`bytes` patterns, group *name* can only contain bytes in the "
"ASCII range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""

#: ../../library/re.rst:448
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:449
msgid ""
"A backreference to a named group; it matches whatever text was matched by"
" the earlier group named *name*."
msgstr "이름있는 그룹에 대한 역참조; *name*\\이라는 이름의 앞선 그룹과 일치하는 텍스트와 일치합니다."

#: ../../library/re.rst:454
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:455
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "주석; 괄호의 내용은 단순히 무시됩니다."

#: ../../library/re.rst:459
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:460
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by "
"``'Asimov'``."
msgstr ""
"``...``\\가 다음과 일치하면 일치하지만, 문자열을 소비하지는 않습니다. 이를 :dfn:`미리 보기 어서션 (lookahead"
" assertion)`\\이라고 합니다. 예를 들어, ``Isaac (?=Asimov)``\\는 ``'Asimov'``\\가 뒤따를"
" 때만 ``'Isaac '``\\과 일치합니다."

#: ../../library/re.rst:466
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:467
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative "
"lookahead assertion`. For example, ``Isaac (?!Asimov)`` will match "
"``'Isaac '`` only if it's *not* followed by ``'Asimov'``."
msgstr ""
"``...``\\가 다음과 일치하지 않으면 일치합니다. 이것은 :dfn:`부정적인 미리 보기 어서션 (negative "
"lookahead assertion)`\\입니다. 예를 들어, ``Isaac (?!Asimov)``\\는 "
"``'Asimov'``\\가 뒤따르지 *않을* 때 만 ``'Isaac '``\\과 일치합니다."

#: ../../library/re.rst:473
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:474
#, python-brace-format
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a "
":dfn:`positive lookbehind assertion`. ``(?<=abc)def`` will find a match "
"in ``'abcdef'``, since the lookbehind will back up 3 characters and check"
" if the contained pattern matches. The contained pattern must only match "
"strings of some fixed length, meaning that ``abc`` or ``a|b`` are "
"allowed, but ``a*`` and ``a{3,4}`` are not.  Note that patterns which "
"start with positive lookbehind assertions will not match at the beginning"
" of the string being searched; you will most likely want to use the "
":func:`search` function rather than the :func:`match` function:"
msgstr ""
"문자열의 현재 위치 앞에 현재 위치에서 끝나는 ``...``\\와의 일치가 있으면 일치합니다. 이를 :dfn:`긍정적인 되돌아보기 "
"어서션 (positive lookbehind assertion)`\\이라고 합니다. 되돌아보기가 3문자를 백업하고 포함된 패턴이 "
"일치하는지 확인하기 때문에 ``(?<=abc)def``\\는 ``'abcdef'``\\에서 일치를 찾습니다. 포함된 패턴은 고정 "
"길이의 문자열과 일치해야 합니다, 즉, ``abc``\\나 ``a|b``\\는 허용되지만, ``a*``\\와 "
"``a{3,4}``\\는 허용되지 않습니다. 긍정적인 되돌아보기 어서션으로 시작하는 패턴은 검색되는 문자열의 시작 부분에서 일치하지"
" 않음에 유의하십시오; :func:`match` 함수보다는 :func:`search` 함수를 사용하기를 원할 것입니다:"

#: ../../library/re.rst:489
msgid "This example looks for a word following a hyphen:"
msgstr "이 예에서는 하이픈 다음의 단어를 찾습니다:"

#: ../../library/re.rst:495
msgid "Added support for group references of fixed length."
msgstr "고정 길이의 그룹 참조에 대한 지원이 추가되었습니다."

#: ../../library/re.rst:500
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:501
msgid ""
"Matches if the current position in the string is not preceded by a match "
"for ``...``.  This is called a :dfn:`negative lookbehind assertion`.  "
"Similar to positive lookbehind assertions, the contained pattern must "
"only match strings of some fixed length.  Patterns which start with "
"negative lookbehind assertions may match at the beginning of the string "
"being searched."
msgstr ""
"문자열의 현재 위치 앞에 ``...``\\와의 일치가 없으면 일치합니다. 이를 :dfn:`부정적인 뒤돌아보기 어서션 "
"(negative lookbehind assertion)`\\이라고 합니다. 긍정적인 뒤돌아보기 어서션과 마찬가지로, 포함된 패턴은"
" 고정 길이의 문자열과 일치해야 합니다. 부정적인 뒤돌아보기 어서션으로 시작하는 패턴은 검색되는 문자열의 시작 부분에서 일치 할 수"
" 있습니다."

#: ../../library/re.rst:510
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:511
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching "
"pattern, which will match with ``'<user@host.com>'`` as well as "
"``'user@host.com'``, but not with ``'<user@host.com'`` nor "
"``'user@host.com>'``."
msgstr ""
"주어진 *id*\\나 *name*\\의 그룹이 있으면 ``yes-pattern``\\과, 그렇지 않으면 ``no-"
"pattern``\\과 일치하려고 시도합니다. ``no-pattern``\\은 선택적이며 생략될 수 있습니다. 예를 들어, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)``\\는 정교하지 않은 전자 메일 일치 패턴인데, "
"``'<user@host.com>'`` 및 ``'user@host.com'``\\과 일치하지만, "
"``'<user@host.com'``\\이나 ``'user@host.com>'``\\과는 일치하지 않습니다."

#: ../../library/re.rst:518
msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` patterns, "
"group *name* can only contain bytes in the ASCII range "
"(``b'\\x00'``-``b'\\x7f'``)."
msgstr ""

#: ../../library/re.rst:526
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII "
"letter, then the resulting RE will match the second character.  For "
"example, ``\\$`` matches the character ``'$'``."
msgstr ""
"특수 시퀀스는 ``'\\'``\\와 아래 목록의 문자로 구성됩니다. 일반 문자가 ASCII 숫자나 ASCII 글자가 아니면, 결과 "
"RE는 두 번째 문자와 일치합니다. 예를 들어, ``\\$``\\는 문자 ``'$'``\\와 일치합니다."

#: ../../library/re.rst:533
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:534
msgid ""
"Matches the contents of the group of the same number.  Groups are "
"numbered starting from 1.  For example, ``(.+) \\1`` matches ``'the "
"the'`` or ``'55 55'``, but not ``'thethe'`` (note the space after the "
"group).  This special sequence can only be used to match one of the first"
" 99 groups.  If the first digit of *number* is 0, or *number* is 3 octal "
"digits long, it will not be interpreted as a group match, but as the "
"character with octal value *number*. Inside the ``'['`` and ``']'`` of a "
"character class, all numeric escapes are treated as characters."
msgstr ""
"같은 번호의 그룹 내용과 일치합니다. 그룹은 1부터 번호가 매겨집니다. 예를 들어, ``(.+) \\1``\\은 ``'the "
"the'``\\나 ``'55 55'``\\와 일치하지만, ``'thethe'``\\와는 일치하지 않습니다 (그룹 뒤의 공백에 "
"유의하십시오). 이 특수 시퀀스는 첫 99개 그룹 중 하나와 일치하는 데에만 사용될 수 있습니다. *number*\\의 첫 자릿수가"
" 0이거나, *number*\\가 3 자릿수면, 그룹 일치로 해석되지 않고, 8진수 값 *number*\\를 갖는 문자로 "
"해석됩니다. 문자 클래스의 ``'['``\\와 ``']'`` 안에서는, 모든 숫자 이스케이프가 문자로 처리됩니다."

#: ../../library/re.rst:545
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:546
msgid "Matches only at the start of the string."
msgstr "문자열의 시작 부분에서만 일치합니다."

#: ../../library/re.rst:550
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:551
#, fuzzy
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A "
"word is defined as a sequence of word characters. Note that formally, "
"``\\b`` is defined as the boundary between a ``\\w`` and a ``\\W`` "
"character (or vice versa), or between ``\\w`` and the beginning or end of"
" the string. This means that ``r'\\bat\\b'`` matches ``'at'``, ``'at.'``,"
" ``'(at)'``, and ``'as at ay'`` but not ``'attempt'`` or ``'atlas'``."
msgstr ""
"빈 문자열과 일치하지만, 단어의 처음이나 끝에만 일치합니다. 단어는 단어 문자의 시퀀스로 정의됩니다. 형식적으로, "
"``\\b``\\는 ``\\w``\\와 ``\\W`` 문자 사이의 (또는 그 반대), 또는 ``\\w``\\와 문자열 시작/끝 "
"사이의 경계로 정의됩니다. 즉, ``r'\\bfoo\\b'``\\는 ``'foo'``, ``'foo.'``, ``'(foo)'``,"
" ``'bar foo baz'``\\와는 일치하지만, ``'foobar'``\\나 ``'foo3'``\\와는 일치하지 않습니다."

#: ../../library/re.rst:559
#, fuzzy
msgid ""
"The default word characters in Unicode (str) patterns are Unicode "
"alphanumerics and the underscore, but this can be changed by using the "
":py:const:`~re.ASCII` flag. Word boundaries are determined by the current"
" locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"기본적으로 유니코드 영숫자가 유니코드 패턴에서 사용되는 것이지만, :const:`ASCII` 플래그를 사용하여 변경할 수 있습니다."
" :const:`LOCALE` 플래그가 사용되면, 단어 경계는 현재 로케일에 의해 결정됩니다. 문자 범위 내에서, 파이썬의 문자열 "
"리터럴과의 호환성을 위해, ``\\b``\\는 백스페이스 문자를 나타냅니다."

#: ../../library/re.rst:567
msgid ""
"Inside a character range, ``\\b`` represents the backspace character, for"
" compatibility with Python's string literals."
msgstr ""

#: ../../library/re.rst:572
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:573
#, fuzzy
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or "
"end of a word. This means that ``r'at\\B'`` matches ``'athens'``, "
"``'atom'``, ``'attorney'``, but not ``'at'``, ``'at.'``, or ``'at!'``. "
"``\\B`` is the opposite of ``\\b``, so word characters in Unicode (str) "
"patterns are Unicode alphanumerics or the underscore, although this can "
"be changed by using the :py:const:`~re.ASCII` flag. Word boundaries are "
"determined by the current locale if the :py:const:`~re.LOCALE` flag is "
"used."
msgstr ""
"단어의 시작이나 끝에 있지 *않을* 때만 빈 문자열과 일치합니다. 즉, ``r'py\\B'``\\는 ``'python'``, "
"``'py3'``, ``'py2'``\\와 일치하지만, ``'py'``, ``'py.'`` 또는 ``'py!'``\\와는 일치하지 "
"않습니다. ``\\B``\\는 단지 ``\\b``\\의 반대이므로, 유니코드 패턴의 단어 문자는 유니코드 영숫자나 밑줄입니다. "
":const:`ASCII` 플래그를 사용하여 변경할 수 있습니다. :const:`LOCALE` 플래그가 사용되면 단어 경계는 현재 "
"로케일에 의해 결정됩니다."

#: ../../library/re.rst:586
msgid ""
"Note that ``\\B`` does not match an empty string, which differs from RE "
"implementations in other programming languages such as Perl. This "
"behavior is kept for compatibility reasons."
msgstr ""

#: ../../library/re.rst:592
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:593 ../../library/re.rst:617 ../../library/re.rst:639
msgid "For Unicode (str) patterns:"
msgstr "유니코드 (str) 패턴일 때:"

#: ../../library/re.rst:594
#, fuzzy
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category `[Nd]`__). This includes ``[0-9]``, and also many "
"other digit characters."
msgstr ""
"모든 유니코드 십진 숫자(즉, 유니코드 문자 범주 [Nd]의 모든 문자)와 일치합니다. 여기에는 ``[0-9]`` 및 다른 많은 "
"숫자가 포함됩니다. :const:`ASCII` 플래그가 사용되면 ``[0-9]``\\만 일치합니다."

#: ../../library/re.rst:598
msgid "Matches ``[0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:602 ../../library/re.rst:624 ../../library/re.rst:647
msgid "For 8-bit (bytes) patterns:"
msgstr "8비트 (bytes) 패턴일 때:"

#: ../../library/re.rst:603
#, fuzzy
msgid ""
"Matches any decimal digit in the ASCII character set; this is equivalent "
"to ``[0-9]``."
msgstr "모든 십진 숫자와 일치합니다; 이것은 ``[0-9]``\\와 동등합니다."

#: ../../library/re.rst:608
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:609
#, fuzzy
msgid ""
"Matches any character which is not a decimal digit. This is the opposite "
"of ``\\d``."
msgstr ""
"십진 숫자가 아닌 모든 문자와 일치합니다. 이것은 ``\\d``\\의 반대입니다. :const:`ASCII` 플래그를 사용하면 "
"``[^0-9]``\\와 동등합니다."

#: ../../library/re.rst:612
msgid "Matches ``[^0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:616
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:618
#, fuzzy
msgid ""
"Matches Unicode whitespace characters (as defined by "
":py:meth:`str.isspace`). This includes ``[ \\t\\n\\r\\f\\v]``, and also "
"many other characters, for example the non-breaking spaces mandated by "
"typography rules in many languages."
msgstr ""
"유니코드 공백 문자(``[ \\t\\n\\r\\f\\v]``\\와 많은 다른 문자들, 예를 들어 많은 언어에서 타이포그래피 규칙에 "
"의해 강제된 분리할 수 없는 스페이스(non-breaking spaces))와 일치합니다. :const:`ASCII` 플래그가 "
"사용되면, ``[ \\t\\n\\r\\f\\v]``\\만 일치합니다."

#: ../../library/re.rst:622
msgid "Matches ``[ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:625
msgid ""
"Matches characters considered whitespace in the ASCII character set; this"
" is equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr "ASCII 문자 집합에서 공백으로 간주하는 문자와 일치합니다; 이것은 ``[ \\t\\n\\r\\f\\v]``\\와 동등합니다."

#: ../../library/re.rst:630
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:631
#, fuzzy
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``."
msgstr ""
"공백 문자가 아닌 모든 문자와 일치합니다. 이것은 ``\\s``\\의 반대입니다. :const:`ASCII` 플래그를 사용하면 "
"``[^ \\t\\n\\r\\f\\v]``\\와 동등합니다."

#: ../../library/re.rst:634
msgid "Matches ``[^ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:638
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:640
msgid ""
"Matches Unicode word characters; this includes all Unicode alphanumeric "
"characters (as defined by :py:meth:`str.isalnum`), as well as the "
"underscore (``_``)."
msgstr ""

#: ../../library/re.rst:645
msgid "Matches ``[a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:648
#, fuzzy
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; "
"this is equivalent to ``[a-zA-Z0-9_]``. If the :py:const:`~re.LOCALE` "
"flag is used, matches characters considered alphanumeric in the current "
"locale and the underscore."
msgstr ""
"ASCII 문자 집합에서 영숫자로 간주하는 문자와 일치합니다; 이것은 ``[a-zA-Z0-9_]``\\와 동등합니다. "
":const:`LOCALE` 플래그를 사용하면, 현재 로케일에서 영숫자로 간주하는 문자와 밑줄에 일치합니다."

#: ../../library/re.rst:655
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:656
msgid ""
"Matches any character which is not a word character. This is the opposite"
" of ``\\w``. By default, matches non-underscore (``_``) characters for "
"which :py:meth:`str.isalnum` returns ``False``."
msgstr ""

#: ../../library/re.rst:661
msgid "Matches ``[^a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""

#: ../../library/re.rst:663
#, fuzzy
msgid ""
"If the :py:const:`~re.LOCALE` flag is used, matches characters which are "
"neither alphanumeric in the current locale nor the underscore."
msgstr ""
"ASCII 문자 집합에서 영숫자로 간주하는 문자와 일치합니다; 이것은 ``[a-zA-Z0-9_]``\\와 동등합니다. "
":const:`LOCALE` 플래그를 사용하면, 현재 로케일에서 영숫자로 간주하는 문자와 밑줄에 일치합니다."

#: ../../library/re.rst:669
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:670
msgid "Matches only at the end of the string."
msgstr "문자열 끝에만 일치합니다."

#: ../../library/re.rst:686
#, fuzzy
msgid ""
"Most of the :ref:`escape sequences <escape-sequences>` supported by "
"Python string literals are also accepted by the regular expression "
"parser::"
msgstr "파이썬 문자열 리터럴이 지원하는 대부분의 표준 이스케이프는 정규식 구문 분석기도 받아들입니다::"

#: ../../library/re.rst:689
msgid ""
"\\a      \\b      \\f      \\n\n"
"\\N      \\r      \\t      \\u\n"
"\\U      \\v      \\x      \\\\"
msgstr ""

#: ../../library/re.rst:693
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "(``\\b``\\는 단어 경계를 나타내는 데 사용되며, 문자 클래스 내에서만 \"백스페이스\"를 의미함에 유의하십시오.)"

#: ../../library/re.rst:696
#, fuzzy
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized "
"in Unicode (str) patterns. In bytes patterns they are errors. Unknown "
"escapes of ASCII letters are reserved for future use and treated as "
"errors."
msgstr ""
"``'\\u'``, ``'\\U'`` 및 ``'\\N'`` 이스케이프 시퀀스는 유니코드 패턴에서만 인식됩니다. 바이트열 패턴에서는 "
"에러입니다. 알 수 없는 ASCII 문자 이스케이프는 나중에 사용하기 위해 예약되어 있으며 에러로 처리됩니다."

#: ../../library/re.rst:702
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0,"
" or if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal "
"escapes are always at most three digits in length."
msgstr ""
"8진수 이스케이프는 제한된 형식으로 포함됩니다. 첫 번째 숫자가 0이거나, 3개의 8진수가 있으면, 8진수 이스케이프로 간주합니다."
" 그렇지 않으면, 그룹 참조입니다. 문자열 리터럴과 마찬가지로, 8진수 이스케이프 길이는 항상 최대 3자리입니다."

#: ../../library/re.rst:707
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "``'\\u'``\\와 ``'\\U'`` 이스케이프 시퀀스가 추가되었습니다."

#: ../../library/re.rst:710
msgid "Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "``'\\'``\\와 ASCII 글자로 구성된 알 수 없는 이스케이프는 이제 에러입니다."

#: ../../library/re.rst:713
#, fuzzy, python-brace-format
msgid ""
"The :samp:`'\\\\N\\\\{{name}\\\\}'` escape sequence has been added. As in"
" string literals, it expands to the named Unicode character (e.g. "
"``'\\N{EM DASH}'``)."
msgstr ""
"``'\\N{name}'`` 이스케이프 시퀀스가 추가되었습니다. 문자열 리터럴과 마찬가지로, 이름 있는 유니코드 문자(예를 들어 "
"``'\\N{EM DASH}'``)로 확장됩니다."

#: ../../library/re.rst:721
msgid "Module Contents"
msgstr "모듈 내용"

#: ../../library/re.rst:723
msgid ""
"The module defines several functions, constants, and an exception. Some "
"of the functions are simplified versions of the full featured methods for"
" compiled regular expressions.  Most non-trivial applications always use "
"the compiled form."
msgstr ""
"모듈은 몇 가지 함수, 상수 및 예외를 정의합니다. 함수 중 일부는 컴파일된 정규식의 모든 기능을 갖춘 메서드의 단순화된 "
"버전입니다. 대부분의 사소하지 않은 응용 프로그램은 항상 컴파일된 형식을 사용합니다."

#: ../../library/re.rst:730
msgid "Flags"
msgstr ""

#: ../../library/re.rst:732
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a "
"subclass of :class:`enum.IntFlag`."
msgstr "플래그 상수는 이제 :class:`enum.IntFlag`\\의 서브 클래스인 :class:`RegexFlag`\\의 인스턴스입니다."

#: ../../library/re.rst:739
msgid "An :class:`enum.IntFlag` class containing the regex options listed below."
msgstr ""

#: ../../library/re.rst:741
msgid "- added to ``__all__``"
msgstr ""

#: ../../library/re.rst:746
#, fuzzy
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  "
"This is only meaningful for Unicode (str) patterns, and is ignored for "
"bytes patterns."
msgstr ""
"``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` 및 "
"``\\S``\\가 전체 유니코드 일치 대신 ASCII 전용 일치를 수행하도록 합니다. 유니코드 패턴에만 의미가 있으며 바이트열 "
"패턴에서는 무시됩니다. 인라인 플래그 ``(?a)``\\에 해당합니다."

#: ../../library/re.rst:750
#, fuzzy
msgid "Corresponds to the inline flag ``(?a)``."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:754
msgid ""
"The :py:const:`~re.U` flag still exists for backward compatibility, but "
"is redundant in Python 3 since matches are Unicode by default for ``str``"
" patterns, and Unicode matching isn't allowed for bytes patterns. "
":py:const:`~re.UNICODE` and the inline flag ``(?u)`` are similarly "
"redundant."
msgstr ""

#: ../../library/re.rst:763
#, fuzzy
msgid "Display debug information about compiled expression."
msgstr "컴파일된 정규식에 대한 디버그 정보를 표시합니다. 해당하는 인라인 플래그가 없습니다."

#: ../../library/re.rst:765
#, fuzzy
msgid "No corresponding inline flag."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:771
#, fuzzy
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also  "
"match lowercase letters. Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :py:const:`~re.ASCII` flag is used to "
"disable non-ASCII matches. The current locale does not change the effect "
"of this flag unless the :py:const:`~re.LOCALE` flag is also used."
msgstr ""
"대/소문자를 구분하지 않는 일치를 수행합니다; ``[A-Z]``\\와 같은 정규식은 소문자와도 일치합니다. "
":const:`re.ASCII` 플래그가 비 ASCII 일치를 비활성화하지 않는 한 전체 유니코드 일치(가령 ``Ü``\\가 "
"``ü``\\와 일치)가 작동합니다. :const:`re.LOCALE` 플래그도 사용되지 않는 한, 현재 로케일은 이 플래그의 "
"효과를 변경하지 않습니다. 인라인 플래그 ``(?i)`` 에 해당합니다."

#: ../../library/re.rst:779
#, fuzzy
msgid "Corresponds to the inline flag ``(?i)``."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:781
#, fuzzy
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 "
"ASCII letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin "
"capital letter I with dot above), 'ı' (U+0131, Latin small letter dotless"
" i), 'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin "
"sign). If the :py:const:`~re.ASCII` flag is used, only letters 'a' to 'z'"
" and 'A' to 'Z' are matched."
msgstr ""
"유니코드 패턴 ``[a-z]``\\나 ``[A-Z]``\\가 :const:`IGNORECASE` 플래그와 함께 사용되면, 52개의 "
"ASCII 글자와 4개의 추가 비 ASCII 문자와 일치합니다: 'İ' (U+0130, Latin capital letter I "
"with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' (U+017F,"
" Latin small letter long s) 및 'K' (U+212A, Kelvin sign). :const:`ASCII` "
"플래그가 사용되면, 문자 'a' 에서 'z'와 'A' 에서 'Z' 만 일치합니다."

#: ../../library/re.rst:792
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale. This flag can be used only with bytes "
"patterns."
msgstr ""

#: ../../library/re.rst:796
#, fuzzy
msgid "Corresponds to the inline flag ``(?L)``."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:800
#, fuzzy
msgid ""
"This flag is discouraged; consider Unicode matching instead. The locale "
"mechanism is very unreliable as it only handles one \"culture\" at a time"
" and only works with 8-bit locales. Unicode matching is enabled by "
"default for Unicode (str) patterns and it is able to handle different "
"locales and languages."
msgstr ""
"``\\w``, ``\\W``, ``\\b``, ``\\B`` 및 대소 문자를 구분하지 않는 일치를 현재 로케일에 의존하도록 "
"만듭니다. 이 플래그는 바이트열 패턴에서만 사용할 수 있습니다. 로케일 메커니즘은 신뢰성이 부족하고, 한 번에 하나의 "
"\"컬처(culture)\" 만 처리하며, 8비트 로케일에서만 동작하므로, 이 플래그의 사용은 권장하지 않습니다. 파이썬 3에서, "
"유니코드 (str) 패턴에 대해서 유니코드 일치가 기본적으로 이미 활성화되어 있으며 다른 로케일/언어를 처리할 수 있습니다. 인라인"
" 플래그 ``(?L)`` 에 해당합니다."

#: ../../library/re.rst:807
#, fuzzy
msgid ""
":py:const:`~re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :py:const:`~re.ASCII`."
msgstr ":const:`re.LOCALE`\\은 바이트열 패턴에만 사용할 수 있으며 :const:`re.ASCII`\\와 호환되지 않습니다."

#: ../../library/re.rst:811
#, fuzzy
msgid ""
"Compiled regular expression objects with the :py:const:`~re.LOCALE` flag "
"no longer depend on the locale at compile time. Only the locale at "
"matching time affects the result of matching."
msgstr ""
":const:`re.LOCALE` 플래그로 컴파일된 정규식 객체는 더는 컴파일 타임의 로케일에 의존하지 않습니다. 일치하는 시점의 "
"로케일 만 일치 결과에 영향을 줍니다."

#: ../../library/re.rst:820
#, fuzzy
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of"
" the string and at the beginning of each line (immediately following each"
" newline); and the pattern character ``'$'`` matches at the end of the "
"string and at the end of each line (immediately preceding each newline)."
"  By default, ``'^'`` matches only at the beginning of the string, and "
"``'$'`` only at the end of the string and immediately before the newline "
"(if any) at the end of the string."
msgstr ""
"지정될 때, 패턴 문자 ``'^'``\\는 문자열 시작과 각 줄의 시작(각 줄 바꿈 바로 다음)에서 일치합니다; 패턴 문자 "
"``'$'``\\는 문자열의 끝과 각 줄의 끝(각 줄 바꿈 직전)에서 일치합니다. 기본적으로, ``'^'``\\는 문자열의 시작 "
"부분에서만 일치하고, ``'$'``\\는 문자열 끝과 문자열 끝에 있는 (있다면) 줄 바꿈 바로 앞에서 일치합니다. 인라인 플래그 "
"``(?m)`` 에 해당합니다."

#: ../../library/re.rst:827
#, fuzzy
msgid "Corresponds to the inline flag ``(?m)``."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:831
msgid ""
"Indicates no flag being applied, the value is ``0``.  This flag may be "
"used as a default value for a function keyword argument or as a base "
"value that will be conditionally ORed with other flags.  Example of use "
"as a default value::"
msgstr ""

#: ../../library/re.rst:836
msgid ""
"def myfunc(text, flag=re.NOFLAG):\n"
"    return re.match(text, flag)"
msgstr ""

#: ../../library/re.rst:844
#, fuzzy
msgid ""
"Make the ``'.'`` special character match any character at all, including "
"a newline; without this flag, ``'.'`` will match anything *except* a "
"newline."
msgstr ""
"``'.'`` 특수 문자가 줄 넘김을 포함하여 모든 문자와 일치하도록 합니다; 이 플래그가 없으면, ``'.'``\\는 줄 넘김을 "
"*제외한* 모든 문자와 일치합니다. 인라인 플래그 ``(?s)``\\에 해당합니다."

#: ../../library/re.rst:847
#, fuzzy
msgid "Corresponds to the inline flag ``(?s)``."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:853
msgid ""
"In Python 3, Unicode characters are matched by default for ``str`` "
"patterns. This flag is therefore redundant with **no effect** and is only"
" kept for backward compatibility."
msgstr ""

#: ../../library/re.rst:858
msgid ""
"See :py:const:`~re.ASCII` to restrict matching to ASCII characters "
"instead."
msgstr ""

#: ../../library/re.rst:865
#, fuzzy
msgid ""
"This flag allows you to write regular expressions that look nicer and are"
" more readable by allowing you to visually separate logical sections of "
"the pattern and add comments. Whitespace within the pattern is ignored, "
"except when in a character class, or when preceded by an unescaped "
"backslash, or within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For "
"example, ``(? :`` and ``* ?`` are not allowed. When a line contains a "
"``#`` that is not in a character class and is not preceded by an "
"unescaped backslash, all characters from the leftmost such ``#`` through "
"the end of the line are ignored."
msgstr ""
"이 플래그를 사용하면 패턴의 논리 섹션을 시각적으로 분리하고 주석을 추가해서 더 멋지게 보이고 읽기 쉬운 정규식을 작성할 수 "
"있습니다. 패턴 내의 공백은 무시되는데, 캐릭터 클래스에 있을 때나 이스케이프 되지 않은 역 슬래시가 앞에 있거나, ``*?``, "
"``(?:`` 또는 ``(?P<...>``\\와 같은 토큰 내에 있을 때는 예외입니다. 문자 클래스에 들어 있지 않고 이스케이프 "
"처리되지 않은 역 슬래시가 없는 ``#``\\가 줄에 포함되어 있으면, 가장 왼쪽의 그런 ``#``\\에서 줄 끝까지의 모든 문자가"
" 무시됩니다."

#: ../../library/re.rst:875
msgid ""
"This means that the two following regular expression objects that match a"
" decimal number are functionally equal::"
msgstr "이것은 십진수와 일치하는 다음 두 정규식 객체는 기능적으로 같음을 뜻합니다::"

#: ../../library/re.rst:878
msgid ""
"a = re.compile(r\"\"\"\\d +  # the integral part\n"
"                   \\.    # the decimal point\n"
"                   \\d *  # some fractional digits\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"
msgstr ""

#: ../../library/re.rst:883
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "인라인 플래그 ``(?x)`` 에 해당합니다."

#: ../../library/re.rst:887
msgid "Functions"
msgstr ""

#: ../../library/re.rst:891
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression "
"object <re-objects>`, which can be used for matching using its "
":func:`~Pattern.match`, :func:`~Pattern.search` and other methods, "
"described below."
msgstr ""
"정규식 패턴을 :ref:`정규식 객체 <re-objects>`\\로 컴파일합니다. 정규식 객체는 아래에 설명되는 "
":func:`~Pattern.match`, :func:`~Pattern.search` 및 기타 메서드를 일치시키는 데 사용할 수 "
"있습니다."

#: ../../library/re.rst:896 ../../library/re.rst:928 ../../library/re.rst:946
#: ../../library/re.rst:957 ../../library/re.rst:1003 ../../library/re.rst:1037
#: ../../library/re.rst:1052 ../../library/re.rst:1111
#: ../../library/re.rst:1147
#, fuzzy
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value."
" Values can be any of the `flags`_ variables, combined using bitwise OR "
"(the ``|`` operator)."
msgstr ""
"정규식의 동작은 *flags* 값을 지정하여 수정할 수 있습니다. 값은 비트별 OR(``|`` 연산자)를 사용하여 다음 변수들을 "
"결합할 수 있습니다."

#: ../../library/re.rst:900
msgid "The sequence ::"
msgstr "시퀀스 ::"

#: ../../library/re.rst:902
msgid ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"
msgstr ""

#: ../../library/re.rst:905
msgid "is equivalent to ::"
msgstr "는 다음과 동등합니다 ::"

#: ../../library/re.rst:907
msgid "result = re.match(pattern, string)"
msgstr ""

#: ../../library/re.rst:909
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used "
"several times in a single program."
msgstr ""
"하지만 정규식이 단일 프로그램에서 여러 번 사용될 때, :func:`re.compile`\\을 사용하고 결과 정규식 객체를 저장하여"
" 재사용하는 것이 더 효율적입니다."

#: ../../library/re.rst:915
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so"
" programs that use only a few regular expressions at a time needn't worry"
" about compiling regular expressions."
msgstr ""
":func:`re.compile`\\과 모듈 수준 일치 함수에 전달된 가장 최근 패턴의 컴파일된 버전이 캐시 되므로, 한 번에 몇 "
"가지 정규식만 사용하는 프로그램은 정규식 컴파일에 대해 신경 쓸 필요가 없습니다."

#: ../../library/re.rst:923
#, fuzzy
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":class:`~re.Match`. Return ``None`` if no position in the string matches "
"the pattern; note that this is different from finding a zero-length match"
" at some point in the string."
msgstr ""
"*string*\\을 통해 스캔하여 정규식 *pattern*\\이 일치하는 첫 번째 위치를 찾고, 대응하는 :ref:`일치 객체 "
"<match-objects>`\\를 반환합니다. 문자열의 어느 위치도 패턴과 일치하지 않으면 ``None``\\을 반환합니다; "
"이것은 문자열의 어떤 지점에서 길이가 0인 일치를 찾는 것과는 다르다는 것에 유의하십시오."

#: ../../library/re.rst:935
#, fuzzy
msgid ""
"If zero or more characters at the beginning of *string* match the regular"
" expression *pattern*, return a corresponding :class:`~re.Match`.  Return"
" ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"*string* 시작 부분에서 0개 이상의 문자가 정규식 *pattern*\\과 일치하면, 해당 :ref:`일치 객체 <match-"
"objects>`\\를 반환합니다. 문자열이 패턴과 일치하지 않으면 ``None``\\을 반환합니다; 이것은 길이가 0인 일치와는 "
"다르다는 것에 유의하십시오."

#: ../../library/re.rst:940
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only "
"match at the beginning of the string and not at the beginning of each "
"line."
msgstr ""
":const:`MULTILINE` 모드에서도, :func:`re.match`\\는 각 줄의 시작 부분이 아니라 문자열의 시작 "
"부분에서만 일치함에 유의하십시오."

#: ../../library/re.rst:943
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string*\\의 모든 위치에서 일치를 찾으려면, 대신 :func:`search`\\를 사용하십시오 (:ref:`search-"
"vs-match`\\도 참조하십시오)."

#: ../../library/re.rst:953
#, fuzzy
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not"
" match the pattern; note that this is different from a zero-length match."
msgstr ""
"전체 *string*\\이 정규식 *pattern*\\과 일치하면, 해당하는 :ref:`일치 객체 <match-"
"objects>`\\를 반환합니다. 문자열이 패턴과 일치하지 않으면 ``None``\\을 반환합니다; 이것은 길이가 0인 일치와는 "
"다르다는 것에 유의하십시오."

#: ../../library/re.rst:966
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses"
" are used in *pattern*, then the text of all groups in the pattern are "
"also returned as part of the resulting list. If *maxsplit* is nonzero, at"
" most *maxsplit* splits occur, and the remainder of the string is "
"returned as the final element of the list. ::"
msgstr ""
"*string*\\을 *pattern*\\으로 나눕니다. *pattern*\\에서 포착하는 괄호가 사용되면 패턴의 모든 그룹 "
"텍스트도 결과 리스트의 일부로 반환됩니다. *maxsplit*\\이 0이 아니면, 최대 *maxsplit* 분할이 발생하고, 나머지"
" 문자열이 리스트의 마지막 요소로 반환됩니다. ::"

#: ../../library/re.rst:972
msgid ""
">>> re.split(r'\\W+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'(\\W+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'\\W+', 'Words, words, words.', maxsplit=1)\n"
"['Words', 'words, words.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"
msgstr ""

#: ../../library/re.rst:981
msgid ""
"If there are capturing groups in the separator and it matches at the "
"start of the string, the result will start with an empty string.  The "
"same holds for the end of the string::"
msgstr ""
"구분자에 포착하는 그룹이 있고 문자열 시작 부분에서 일치하면, 결과는 빈 문자열로 시작됩니다. 문자열의 끝에 대해서도 "
"마찬가지입니다::"

#: ../../library/re.rst:985
msgid ""
">>> re.split(r'(\\W+)', '...words, words...')\n"
"['', '...', 'words', ', ', 'words', '...', '']"
msgstr ""

#: ../../library/re.rst:988
msgid ""
"That way, separator components are always found at the same relative "
"indices within the result list."
msgstr "그런 식으로, 구분자 구성 요소는 항상 결과 리스트 내의 같은 상대 인덱스에서 발견됩니다."

#: ../../library/re.rst:991
msgid ""
"Empty matches for the pattern split the string only when not adjacent to "
"a previous empty match."
msgstr "패턴에 대한 빈(empty) 일치는 이전의 빈 일치와 인접하지 않을 때만 문자열을 분할합니다."

#: ../../library/re.rst:994
msgid ""
">>> re.split(r'\\b', 'Words, words, words.')\n"
"['', 'Words', ', ', 'words', ', ', 'words', '.']\n"
">>> re.split(r'\\W*', '...words...')\n"
"['', '', 'w', 'o', 'r', 'd', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...words...')\n"
"['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', "
"'', '']"
msgstr ""

#: ../../library/re.rst:1007 ../../library/re.rst:1115
msgid "Added the optional flags argument."
msgstr "선택적 flags 인자를 추가했습니다."

#: ../../library/re.rst:1010
msgid "Added support of splitting on a pattern that could match an empty string."
msgstr "빈 문자열과 일치 할 수 있는 패턴으로 분할하는 지원을 추가했습니다."

#: ../../library/re.rst:1013
msgid ""
"Passing *maxsplit* and *flags* as positional arguments is deprecated. In "
"future Python versions they will be :ref:`keyword-only parameters "
"<keyword-only_parameter>`."
msgstr ""

#: ../../library/re.rst:1021
#, fuzzy
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of"
" strings or tuples.  The *string* is scanned left-to-right, and matches "
"are returned in the order found.  Empty matches are included in the "
"result."
msgstr ""
"*string*\\에서 겹치지 않는 RE *pattern*\\의 모든 일치를 :ref:`일치 객체 <match-"
"objects>`\\를 산출하는 :term:`이터레이터 <iterator>`\\로 반환합니다. *string*\\은 왼쪽에서 "
"오른쪽으로 스캔 되고, 일치는 찾은 순서대로 반환됩니다. 빈 일치가 결과에 포함됩니다."

#: ../../library/re.rst:1025
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern."
"  If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of "
"strings matching the groups.  Non-capturing groups do not affect the form"
" of the result."
msgstr ""

#: ../../library/re.rst:1041 ../../library/re.rst:1056
msgid "Non-empty matches can now start just after a previous empty match."
msgstr "비어 있지 않은 일치는 이제 이전의 비어 있는 일치 직후에 시작할 수 있습니다."

#: ../../library/re.rst:1047
#, fuzzy
msgid ""
"Return an :term:`iterator` yielding :class:`~re.Match` objects over all "
"non-overlapping matches for the RE *pattern* in *string*.  The *string* "
"is scanned left-to-right, and matches are returned in the order found.  "
"Empty matches are included in the result."
msgstr ""
"*string*\\에서 겹치지 않는 RE *pattern*\\의 모든 일치를 :ref:`일치 객체 <match-"
"objects>`\\를 산출하는 :term:`이터레이터 <iterator>`\\로 반환합니다. *string*\\은 왼쪽에서 "
"오른쪽으로 스캔 되고, 일치는 찾은 순서대로 반환됩니다. 빈 일치가 결과에 포함됩니다."

#: ../../library/re.rst:1062
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a "
"string or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes"
" of ASCII letters are reserved for future use and treated as errors.  "
"Other unknown escapes such as ``\\&`` are left alone. Backreferences, "
"such as ``\\6``, are replaced with the substring matched by group 6 in "
"the pattern. For example::"
msgstr ""
"*string*\\에서 겹치지 않는 *pattern*\\의 가장 왼쪽 일치를 *repl*\\로 치환하여 얻은 문자열을 반환합니다. "
"패턴을 찾지 못하면, *string*\\이 변경되지 않고 반환됩니다. *repl*\\은 문자열이나 함수가 될 수 있습니다; "
"문자열이면 모든 역 슬래시 이스케이프가 처리됩니다. 즉, ``\\n``\\은 단일 개행 문자로 변환되고, ``\\r``\\는 캐리지"
" 리턴으로 변환되고, 등등. 알 수 없는 ASCII 글자 이스케이프는 나중에 사용하기 위해 예약되어 있으며 에러로 처리됩니다. "
"``\\&``\\와 같은 다른 알려지지 않은 이스케이프는 그대로 있습니다. ``\\6``\\과 같은 역참조는 패턴에서 그룹 6과 "
"일치하는 부분 문자열로 치환됩니다. 예를 들면::"

#: ../../library/re.rst:1073
msgid ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"...        r'static PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'static PyObject*\\npy_myfunc(void)\\n{'"
msgstr ""

#: ../../library/re.rst:1078
#, fuzzy
msgid ""
"If *repl* is a function, it is called for every non-overlapping "
"occurrence of *pattern*.  The function takes a single :class:`~re.Match` "
"argument, and returns the replacement string.  For example::"
msgstr ""
"*repl*\\이 함수면, *pattern*\\의 겹치지 않는 모든 일치마다 호출됩니다. 이 함수는 단일 :ref:`일치 객체 "
"<match-objects>` 인자를 취하고, 치환 문자열을 반환합니다. 예를 들면::"

#: ../../library/re.rst:1082
#, python-brace-format
msgid ""
">>> def dashrepl(matchobj):\n"
"...     if matchobj.group(0) == '-': return ' '\n"
"...     else: return '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')\n"
"'pro--gram files'\n"
">>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', "
"flags=re.IGNORECASE)\n"
"'Baked Beans & Spam'"
msgstr ""

#: ../../library/re.rst:1091
#, fuzzy
msgid "The pattern may be a string or a :class:`~re.Pattern`."
msgstr "패턴은 문자열 또는 :ref:`패턴 객체 <re-objects>`\\일 수 있습니다."

#: ../../library/re.rst:1093
msgid ""
"The optional argument *count* is the maximum number of pattern "
"occurrences to be replaced; *count* must be a non-negative integer.  If "
"omitted or zero, all occurrences will be replaced. Empty matches for the "
"pattern are replaced only when not adjacent to a previous empty match, so"
" ``sub('x*', '-', 'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"선택적 인자 *count*\\는 치환될 패턴 발생의 최대 수입니다; *count*\\는 음수가 아닌 정수여야 합니다. 생략되거나 "
"0이면, 모든 발생이 치환됩니다. 패턴에 대한 빈 일치는 이전의 빈 일치와 인접하지 않을 때만 치환되므로, ``sub('x*', "
"'-', 'abxd')``\\는 ``'-a-b--d-'``\\를 반환합니다."

#: ../../library/re.rst:1101
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and"
" backreferences described above, ``\\g<name>`` will use the substring "
"matched by the group named ``name``, as defined by the ``(?P<name>...)`` "
"syntax. ``\\g<number>`` uses the corresponding group number; ``\\g<2>`` "
"is therefore equivalent to ``\\2``, but isn't ambiguous in a replacement "
"such as ``\\g<2>0``.  ``\\20`` would be interpreted as a reference to "
"group 20, not a reference to group 2 followed by the literal character "
"``'0'``.  The backreference ``\\g<0>`` substitutes in the entire "
"substring matched by the RE."
msgstr ""
"문자열형 *repl* 인자에서, 위에 설명된 문자 이스케이프와 역참조 외에, ``\\g<name>``\\는 "
"``(?P<name>...)`` 문법으로 정의한 ``name``\\이라는 그룹에 일치하는 부분 문자열을 사용합니다. "
"``\\g<number>``\\는 해당 그룹 번호를 사용합니다; 따라서 ``\\g<2>``\\는 ``\\2``\\와 동등하지만, "
"``\\g<2>0``\\와 같은 치환에서 모호하지 않습니다. ``\\20``\\은 그룹 2에 대한 참조에 리터럴 문자 "
"``'0'``\\이 뒤에 오는 것이 아니라, 그룹 20에 대한 참조로 해석됩니다. 역참조 ``\\g<0>``\\은 RE와 일치하는 "
"전체 부분 문자열을 치환합니다."

#: ../../library/re.rst:1118 ../../library/re.rst:1396
msgid "Unmatched groups are replaced with an empty string."
msgstr "일치하지 않는 그룹은 빈 문자열로 치환됩니다."

#: ../../library/re.rst:1121
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter "
"now are errors."
msgstr "*pattern*\\의 ``'\\'``\\와 ASCII 글자(letter)로 구성된 알 수 없는 이스케이프는 이제 에러입니다."

#: ../../library/re.rst:1125
#, fuzzy
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now "
"are errors. Empty matches for the pattern are replaced when adjacent to a"
" previous non-empty match."
msgstr "패턴에 대한 빈 일치는 이전의 비어 있지 않은 일치와 인접 할 때 치환됩니다."

#: ../../library/re.rst:1131
msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` replacement "
"strings, group *name* can only contain bytes in the ASCII range "
"(``b'\\x00'``-``b'\\x7f'``)."
msgstr ""

#: ../../library/re.rst:1136
msgid ""
"Passing *count* and *flags* as positional arguments is deprecated. In "
"future Python versions they will be :ref:`keyword-only parameters "
"<keyword-only_parameter>`."
msgstr ""

#: ../../library/re.rst:1144
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple "
"``(new_string, number_of_subs_made)``."
msgstr ""
":func:`sub`\\와 같은 연산을 수행하지만, 튜플 ``(new_string, number_of_subs_made)``\\를 "
"반환합니다."

#: ../../library/re.rst:1154
msgid ""
"Escape special characters in *pattern*. This is useful if you want to "
"match an arbitrary literal string that may have regular expression "
"metacharacters in it.  For example::"
msgstr ""
"*pattern*\\에서 특수 문자를 이스케이프 처리합니다. 이것은 정규식 메타 문자가 포함되어있을 수 있는 임의의 리터럴 문자열을"
" 일치시키려는 경우에 유용합니다. 예를 들면::"

#: ../../library/re.rst:1158
#, python-format
msgid ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = string.ascii_lowercase + string.digits + "
"\"!#$%&'*+-.^_`|~:\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+"
"\n"
"\n"
">>> operators = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"
msgstr ""

#: ../../library/re.rst:1169
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"이 함수는 :func:`sub`\\와 :func:`subn`\\의 치환 문자열에 사용하면 안 되며, 역 슬래시만 이스케이프 해야 "
"합니다. 예를 들면::"

#: ../../library/re.rst:1172
msgid ""
">>> digits_re = r'\\d+'\n"
">>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ errors, \\d+ warnings"
msgstr ""

#: ../../library/re.rst:1177
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` 문자는 더는 이스케이프 되지 않습니다."

#: ../../library/re.rst:1180
msgid ""
"Only characters that can have special meaning in a regular expression are"
" escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and "
"``\"`\"`` are no longer escaped."
msgstr ""
"정규식에서 특별한 의미를 가질 수 있는 문자만 이스케이프 됩니다. 결과적으로, ``'!'``, ``'\"'``, ``'%'``, "
"``\"'\"``, ``','``, ``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``,"
" ``'@'`` 및 '`\"`\\'는 더는 이스케이프 되지 않습니다."

#: ../../library/re.rst:1189
msgid "Clear the regular expression cache."
msgstr "정규식 캐시를 지웁니다."

#: ../../library/re.rst:1193
msgid "Exceptions"
msgstr ""

#: ../../library/re.rst:1197
#, fuzzy
msgid ""
"Exception raised when a string passed to one of the functions here is not"
" a valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The ``PatternError`` instance has the following additional "
"attributes:"
msgstr ""
"여기에 있는 함수 중 하나에 전달된 문자열이 유효한 정규식이 아니거나 (예를 들어, 쌍을 이루지 않는 괄호가 들어있을 수 있습니다)"
" 컴파일이나 일치 중에 다른 에러가 발생할 때 발생하는 예외. 문자열에 패턴과의 일치가 포함되지 않을 때 에러가 발생하지는 "
"않습니다. 에러 인스턴스에는 다음과 같은 추가 어트리뷰트가 있습니다:"

#: ../../library/re.rst:1205
msgid "The unformatted error message."
msgstr "포맷되지 않은 에러 메시지."

#: ../../library/re.rst:1209
msgid "The regular expression pattern."
msgstr "정규식 패턴."

#: ../../library/re.rst:1213
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "컴파일이 실패한 위치를 가리키는 *pattern*\\의 인덱스 (``None``\\일 수 있습니다)."

#: ../../library/re.rst:1217
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "*pos*\\에 해당하는 줄 (``None``\\일 수 있습니다)."

#: ../../library/re.rst:1221
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "*pos*\\에 해당하는 열 (``None``\\일 수 있습니다)."

#: ../../library/re.rst:1223
msgid "Added additional attributes."
msgstr "추가 어트리뷰트가 추가되었습니다."

#: ../../library/re.rst:1226
msgid ""
"``PatternError`` was originally named ``error``; the latter is kept as an"
" alias for backward compatibility."
msgstr ""

#: ../../library/re.rst:1233
msgid "Regular Expression Objects"
msgstr "정규식 객체"

#: ../../library/re.rst:1237
msgid "Compiled regular expression object returned by :func:`re.compile`."
msgstr ""

#: ../../library/re.rst:1239
msgid ""
":py:class:`re.Pattern` supports ``[]`` to indicate a Unicode (str) or "
"bytes pattern. See :ref:`types-genericalias`."
msgstr ""

#: ../../library/re.rst:1245
#, fuzzy
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding "
":class:`~re.Match`. Return ``None`` if no position in the string matches "
"the pattern; note that this is different from finding a zero-length match"
" at some point in the string."
msgstr ""
"*string*\\을 통해 스캔하여 이 정규식이 일치하는 첫 번째 위치를 찾고, 대응하는 :ref:`일치 객체 <match-"
"objects>`\\를 반환합니다. 문자열의 어느 위치도 패턴과 일치하지 않으면 ``None``\\을 반환합니다; 이것은 문자열의 "
"어떤 지점에서 길이가 0인 일치를 찾는 것과는 다르다는 것에 유의하십시오."

#: ../../library/re.rst:1250
msgid ""
"The optional second parameter *pos* gives an index in the string where "
"the search is to start; it defaults to ``0``.  This is not completely "
"equivalent to slicing the string; the ``'^'`` pattern character matches "
"at the real beginning of the string and at positions just after a "
"newline, but not necessarily at the index where the search is to start."
msgstr ""
"선택적 두 번째 매개 변수 *pos*\\는 검색을 시작할 문자열의 인덱스를 제공합니다; 기본값은 ``0``\\입니다. 이것은 "
"문자열을 슬라이싱하는 것과 완전히 동등하지는 않습니다; ``'^'`` 패턴 문자는 문자열의 실제 시작 부분과 개행 직후의 위치에서 "
"일치하지만, 검색을 시작할 색인에서 반드시 일치하지는 않습니다."

#: ../../library/re.rst:1256
msgid ""
"The optional parameter *endpos* limits how far the string will be "
"searched; it will be as if the string is *endpos* characters long, so "
"only the characters from *pos* to ``endpos - 1`` will be searched for a "
"match.  If *endpos* is less than *pos*, no match will be found; "
"otherwise, if *rx* is a compiled regular expression object, "
"``rx.search(string, 0, 50)`` is equivalent to ``rx.search(string[:50], "
"0)``. ::"
msgstr ""
"선택적 매개 변수 *endpos*\\는 문자열을 어디까지 검색할지를 제한합니다; 문자열이 *endpos* 문자 길이인 것처럼 "
"취급되어, 일치를 찾기 위해 *pos*\\에서 ``endpos - 1``\\까지의 문자만 검색됩니다. *endpos*\\가 "
"*pos*\\보다 작으면 일치는 없습니다; 그렇지 않으면, *rx*\\가 컴파일된 정규식 객체일 때, "
"``rx.search(string, 0, 50)``\\는 ``rx.search(string[:50], 0)``\\와 동등합니다. "
"::"

#: ../../library/re.rst:1263
msgid ""
">>> pattern = re.compile(\"d\")\n"
">>> pattern.search(\"dog\")     # Match at index 0\n"
"<re.Match object; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1)  # No match; search doesn't include the "
"\"d\""
msgstr ""

#: ../../library/re.rst:1271
#, fuzzy
msgid ""
"If zero or more characters at the *beginning* of *string* match this "
"regular expression, return a corresponding :class:`~re.Match`. Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"*string*\\의 *처음*\\에서 0개 이상의 문자가 이 정규식과 일치하면, 해당하는 :ref:`일치 객체 <match-"
"objects>`\\를 반환합니다. 문자열이 패턴과 일치하지 않으면 ``None``\\을 반환합니다; 이것은 길이가 0인 일치와는 "
"다릅니다."

#: ../../library/re.rst:1276 ../../library/re.rst:1294
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for "
"the :meth:`~Pattern.search` method. ::"
msgstr "선택적 *pos*\\와 *endpos* 매개 변수는 :meth:`~Pattern.search` 메서드에서와 같은 의미입니다. ::"

#: ../../library/re.rst:1279
msgid ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # No match as \"o\" is not at the start "
"of \"dog\".\n"
">>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of "
"\"dog\".\n"
"<re.Match object; span=(1, 2), match='o'>"
msgstr ""

#: ../../library/re.rst:1284
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~Pattern.search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"*string*\\의 임의 위치에서 일치를 찾으려면, 대신 :meth:`~Pattern.search`\\를 사용하십시오 (:ref"
":`search-vs-match`\\도 참조하십시오)."

#: ../../library/re.rst:1290
#, fuzzy
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not"
" match the pattern; note that this is different from a zero-length match."
msgstr ""
"전체 *string*\\이 이 정규식과 일치하면, 해당하는 :ref:`일치 객체 <match-objects>`\\를 반환합니다. "
"문자열이 패턴과 일치하지 않으면 ``None``\\을 반환합니다; 이것은 길이가 0인 일치와는 다릅니다."

#: ../../library/re.rst:1297
msgid ""
">>> pattern = re.compile(\"o[gh]\")\n"
">>> pattern.fullmatch(\"dog\")      # No match as \"o\" is not at the "
"start of \"dog\".\n"
">>> pattern.fullmatch(\"ogre\")     # No match as not the full string "
"matches.\n"
">>> pattern.fullmatch(\"doggie\", 1, 3)   # Matches within given limits.\n"
"<re.Match object; span=(1, 3), match='og'>"
msgstr ""

#: ../../library/re.rst:1308
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ":func:`split` 함수와 같은데, 컴파일된 패턴을 사용합니다."

#: ../../library/re.rst:1313
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search"
" region like for :meth:`search`."
msgstr ""
":func:`findall` 함수와 유사한데, 컴파일된 패턴을 사용합니다. 하지만, :meth:`search`\\처럼 검색 영역을 "
"제한하는 선택적 *pos*\\와 *endpos* 매개 변수도 받아들입니다."

#: ../../library/re.rst:1320
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but"
" also accepts optional *pos* and *endpos* parameters that limit the "
"search region like for :meth:`search`."
msgstr ""
":func:`finditer` 함수와 유사한데, 컴파일된 패턴을 사용합니다. 하지만, :meth:`search`\\처럼 검색 영역을"
" 제한하는 선택적 *pos*\\와 *endpos* 매개 변수도 받아들입니다."

#: ../../library/re.rst:1327
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ":func:`sub` 함수와 같은데, 컴파일된 패턴을 사용합니다."

#: ../../library/re.rst:1332
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ":func:`subn` 함수와 같은데, 컴파일된 패턴을 사용합니다."

#: ../../library/re.rst:1337
#, fuzzy
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and "
"implicit flags such as :py:const:`~re.UNICODE` if the pattern is a "
"Unicode string."
msgstr ""
"정규식 일치 플래그. 이것은 :func:`.compile`\\에 주어진 플래그, 패턴의 모든 ``(?...)`` 인라인 플래그 및 "
"패턴이 유니코드 문자열일 때 :data:`UNICODE`\\와 같은 묵시적 플래그의 조합입니다."

#: ../../library/re.rst:1344
msgid "The number of capturing groups in the pattern."
msgstr "패턴에 있는 포착 그룹 수."

#: ../../library/re.rst:1349
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used "
"in the pattern."
msgstr ""
"``(?P<id>)``\\로 정의된 기호 그룹 이름을 그룹 번호에 매핑하는 딕셔너리. 패턴에 기호 그룹이 사용되지 않으면 딕셔너리는"
" 비어 있습니다."

#: ../../library/re.rst:1356
msgid "The pattern string from which the pattern object was compiled."
msgstr "패턴 객체가 컴파일된 패턴 문자열."

#: ../../library/re.rst:1359
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
":func:`copy.copy`\\와 :func:`copy.deepcopy` 지원이 추가되었습니다. 컴파일된 정규식 객체는 "
"원자적이라고 간주합니다."

#: ../../library/re.rst:1367
msgid "Match Objects"
msgstr "일치 객체"

#: ../../library/re.rst:1369
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~Pattern.match` and :meth:`~Pattern.search` return ``None`` when "
"there is no match, you can test whether there was a match with a simple "
"``if`` statement::"
msgstr ""
"일치 객체는 항상 불리언 값 ``True``\\를 가집니다. :meth:`~Pattern.match`\\와 "
":meth:`~Pattern.search`\\는 일치가 없을 때 ``None``\\을 반환하기 때문에, 간단한 ``if`` 문으로 "
"일치가 있는지 검사할 수 있습니다::"

#: ../../library/re.rst:1374
msgid ""
"match = re.search(pattern, string)\n"
"if match:\n"
"    process(match)"
msgstr ""

#: ../../library/re.rst:1380
msgid "Match object returned by successful ``match``\\ es and ``search``\\ es."
msgstr ""

#: ../../library/re.rst:1382
msgid ""
":py:class:`re.Match` supports ``[]`` to indicate a Unicode (str) or bytes"
" match. See :ref:`types-genericalias`."
msgstr ""

#: ../../library/re.rst:1388
#, fuzzy
msgid ""
"Return the string obtained by doing backslash substitution on the "
"template string *template*, as done by the :meth:`~Pattern.sub` method. "
"Escapes such as ``\\n`` are converted to the appropriate characters, and "
"numeric backreferences (``\\1``, ``\\2``) and named backreferences "
"(``\\g<1>``, ``\\g<name>``) are replaced by the contents of the "
"corresponding group. The backreference ``\\g<0>`` will be replaced by the"
" entire match."
msgstr ""
":meth:`~Pattern.sub` 메서드에서 수행되는 것처럼, 템플릿 문자열 *template*\\에 역 슬래시 치환을 수행하여"
" 얻은 문자열을 반환합니다. ``\\n``\\과 같은 이스케이프는 적절한 문자로 변환되고, 숫자 역참조(``\\1``, "
"``\\2``)와 이름 있는 역참조(``\\g<1>``, ``\\g<name>``)는 해당 그룹의 내용으로 치환됩니다."

#: ../../library/re.rst:1401
msgid ""
"Returns one or more subgroups of the match.  If there is a single "
"argument, the result is a single string; if there are multiple arguments,"
" the result is a tuple with one item per argument. Without arguments, "
"*group1* defaults to zero (the whole match is returned). If a *groupN* "
"argument is zero, the corresponding return value is the entire matching "
"string; if it is in the inclusive range [1..99], it is the string "
"matching the corresponding parenthesized group.  If a group number is "
"negative or larger than the number of groups defined in the pattern, an "
":exc:`IndexError` exception is raised. If a group is contained in a part "
"of the pattern that did not match, the corresponding result is ``None``. "
"If a group is contained in a part of the pattern that matched multiple "
"times, the last match is returned. ::"
msgstr ""
"일치의 하나 이상의 서브 그룹을 반환합니다. 단일 인자가 있으면, 결과는 단일 문자열입니다; 인자가 여러 개면, 결과는 인자당 "
"하나의 항목이 있는 튜플입니다. 인자가 없으면, *group1*\\의 기본값은 0입니다 (전체 일치가 반환됩니다). *groupN*"
" 인자가 0이면, 해당 반환 값은 전체 일치 문자열입니다; 경계를 포함하는 범위 [1..99]에 있으면, 해당 괄호로 묶은 그룹과 "
"일치하는 문자열입니다. 그룹 번호가 음수이거나 패턴에 정의된 그룹 수보다 크면, :exc:`IndexError` 예외가 발생합니다."
" 패턴이 일치하지 않는 부분에 그룹이 포함되어 있으면, 해당 결과는 ``None``\\입니다. 그룹이 여러 번 일치하는 패턴의 "
"일부에 포함되어 있으면, 마지막 일치가 반환됩니다. ::"

#: ../../library/re.rst:1413
msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m.group(0)       # The entire match\n"
"'Isaac Newton'\n"
">>> m.group(1)       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m.group(2)       # The second parenthesized subgroup.\n"
"'Newton'\n"
">>> m.group(1, 2)    # Multiple arguments give us a tuple.\n"
"('Isaac', 'Newton')"
msgstr ""

#: ../../library/re.rst:1423
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN*"
" arguments may also be strings identifying groups by their group name.  "
"If a string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""
"정규식이 ``(?P<name>...)`` 문법을 사용하면, *groupN* 인자는 그룹 이름으로 그룹을 식별하는 문자열일 수도 "
"있습니다. 문자열 인자가 패턴의 그룹 이름으로 사용되지 않으면, :exc:`IndexError` 예외가 발생합니다."

#: ../../library/re.rst:1428
msgid "A moderately complicated example::"
msgstr "적당히 복잡한 예::"

#: ../../library/re.rst:1430
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm"
" Reynolds\")\n"
">>> m.group('first_name')\n"
"'Malcolm'\n"
">>> m.group('last_name')\n"
"'Reynolds'"
msgstr ""

#: ../../library/re.rst:1436
msgid "Named groups can also be referred to by their index::"
msgstr "이름있는 그룹은 인덱스로 참조할 수도 있습니다::"

#: ../../library/re.rst:1438
msgid ""
">>> m.group(1)\n"
"'Malcolm'\n"
">>> m.group(2)\n"
"'Reynolds'"
msgstr ""

#: ../../library/re.rst:1443
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr "그룹이 여러 번 일치하면, 마지막 일치만 액세스 할 수 있습니다::"

#: ../../library/re.rst:1445
msgid ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Matches 3 times.\n"
">>> m.group(1)                        # Returns only the last match.\n"
"'c3'"
msgstr ""

#: ../../library/re.rst:1452
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr "이것은 ``m.group(g)``\\와 같습니다. 일치에서 개별 그룹에 더 쉽게 액세스 할 수 있게 합니다::"

#: ../../library/re.rst:1455
msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m[0]       # The entire match\n"
"'Isaac Newton'\n"
">>> m[1]       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m[2]       # The second parenthesized subgroup.\n"
"'Newton'"
msgstr ""

#: ../../library/re.rst:1463
msgid "Named groups are supported as well::"
msgstr ""

#: ../../library/re.rst:1465
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Isaac "
"Newton\")\n"
">>> m['first_name']\n"
"'Isaac'\n"
">>> m['last_name']\n"
"'Newton'"
msgstr ""

#: ../../library/re.rst:1476
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used "
"for groups that did not participate in the match; it defaults to "
"``None``."
msgstr ""
"1에서 패턴에 있는 그룹의 수까지, 일치의 모든 서브 그룹을 포함하는 튜플을 반환합니다. *default* 인자는 일치에 참여하지 "
"않은 그룹에 사용됩니다; 기본값은 ``None``\\입니다."

#: ../../library/re.rst:1480 ../../library/re.rst:1705
msgid "For example::"
msgstr "예를 들면::"

#: ../../library/re.rst:1482
msgid ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n"
">>> m.groups()\n"
"('24', '1632')"
msgstr ""

#: ../../library/re.rst:1486
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"우리가 소수점과 그 이후의 모든 것을 선택적으로 만들면, 모든 그룹이 일치에 참여하지 않을 수 있습니다. 이 그룹은 "
"*default* 인자가 주어지지 않는 한 기본값 ``None``\\이 됩니다::"

#: ../../library/re.rst:1490
msgid ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups()      # Second group defaults to None.\n"
"('24', None)\n"
">>> m.groups('0')   # Now, the second group defaults to '0'.\n"
"('24', '0')"
msgstr ""

#: ../../library/re.rst:1499
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, "
"keyed by the subgroup name.  The *default* argument is used for groups "
"that did not participate in the match; it defaults to ``None``.  For "
"example::"
msgstr ""
"일치의 모든 *이름 있는* 서브 그룹을 포함하고, 서브 그룹의 이름을 키로 사용하는 딕셔너리를 반환합니다. *default* 인자는"
" 일치에 참여하지 않은 그룹에 사용됩니다; 기본값은 ``None``\\입니다. 예를 들면::"

#: ../../library/re.rst:1503
#, python-brace-format
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm"
" Reynolds\")\n"
">>> m.groupdict()\n"
"{'first_name': 'Malcolm', 'last_name': 'Reynolds'}"
msgstr ""

#: ../../library/re.rst:1511
msgid ""
"Return the indices of the start and end of the substring matched by "
"*group*; *group* defaults to zero (meaning the whole matched substring). "
"Return ``-1`` if *group* exists but did not contribute to the match.  For"
" a match object *m*, and a group *g* that did contribute to the match, "
"the substring matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"*group*\\과 일치하는 부분 문자열의 시작과 끝 인덱스를 반환합니다; *group*\\의 기본값은 0입니다 (전체 일치 "
"문자열을 뜻합니다). *group*\\이 있지만, 일치에 기여하지 않으면, ``-1``\\을 반환합니다. 일치 객체 *m*\\과 "
"일치에 기여한 그룹 *g*\\에서, 그룹 *g*\\와 일치하는 부분 문자열(``m.group(g)``\\와 동등합니다)은 다음과 "
"같습니다 ::"

#: ../../library/re.rst:1517
msgid "m.string[m.start(g):m.end(g)]"
msgstr ""

#: ../../library/re.rst:1519
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* "
"matched a null string.  For example, after ``m = re.search('b(c?)', "
"'cba')``, ``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and "
"``m.end(1)`` are both 2, and ``m.start(2)`` raises an :exc:`IndexError` "
"exception."
msgstr ""
"*group*\\이 널 문자열과 일치하면 ``m.start(group)``\\은 ``m.end(group)``\\와 같음에 "
"유의하십시오. 예를 들어, ``m = re.search('b(c?)', 'cba')`` 이후에, ``m.start(0)``\\은 "
"1이고, ``m.end(0)``\\은 2이며, ``m.start(1)``\\과 ``m.end(1)``\\은 모두 2이고, "
"``m.start(2)``\\는 :exc:`IndexError` 예외를 발생시킵니다."

#: ../../library/re.rst:1524
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "전자 메일 주소에서 *remove_this*\\를 제거하는 예::"

#: ../../library/re.rst:1526
msgid ""
">>> email = \"tony@tiremove_thisger.net\"\n"
">>> m = re.search(\"remove_this\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"
msgstr ""

#: ../../library/re.rst:1534
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. "
"Note that if *group* did not contribute to the match, this is ``(-1, "
"-1)``. *group* defaults to zero, the entire match."
msgstr ""
"일치가 *m*\\일 때, 2-튜플 ``(m.start(group), m.end(group))``\\를 반환합니다. "
"*group*\\이 일치에 기여하지 않으면, 이것은 ``(-1, -1)``\\임에 유의하십시오. *group*\\의 기본값은 "
"0으로, 전체 일치입니다."

#: ../../library/re.rst:1541
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  "
"This is the index into the string at which the RE engine started looking "
"for a match."
msgstr ""
":ref:`정규식 객체 <re-objects>`\\의 :meth:`~Pattern.search`\\나 "
":meth:`~Pattern.match` 메서드에 전달된 *pos* 값. 이것은 RE 엔진이 일치를 찾기 시작한 string에 대한"
" 인덱스입니다."

#: ../../library/re.rst:1548
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  "
"This is the index into the string beyond which the RE engine will not go."
msgstr ""
":ref:`정규식 객체 <re-objects>`\\의 :meth:`~Pattern.search`\\나 "
":meth:`~Pattern.match` 메서드에 전달된 *endpos* 값. 이것은 RE 엔진이 넘어가지 않을 string에 대한"
" 인덱스입니다."

#: ../../library/re.rst:1555
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to "
"the string ``'ab'``, while the expression ``(a)(b)`` will have "
"``lastindex == 2``, if applied to the same string."
msgstr ""
"마지막으로 일치하는 포착 그룹의 정수 인덱스, 또는 그룹이 전혀 일치하지 않으면 ``None``. 예를 들어, 정규식 "
"``(a)b``, ``((a)(b))`` 및 ``((ab))``\\는 문자열 ``'ab'``\\에 적용될 경우 ``lastindex"
" == 1``\\이 되지만, ``(a)(b)`` 정규식은 같은 문자열에 적용될 때 ``lastindex == 2``\\가 됩니다."

#: ../../library/re.rst:1564
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr "마지막으로 일치하는 포착 그룹의 이름, 또는 그룹에 이름이 없거나, 그룹이 전혀 일치하지 않으면 ``None``."

#: ../../library/re.rst:1570
msgid ""
"The :ref:`regular expression object <re-objects>` whose "
":meth:`~Pattern.match` or :meth:`~Pattern.search` method produced this "
"match instance."
msgstr ""
":meth:`~Pattern.match`\\나 :meth:`~Pattern.search` 메서드가 이 일치 인스턴스를 생성한 "
":ref:`정규식 객체 <re-objects>`."

#: ../../library/re.rst:1576
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ":meth:`~Pattern.match`\\나 :meth:`~Pattern.search`\\에 전달된 문자열."

#: ../../library/re.rst:1579
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match "
"objects are considered atomic."
msgstr ""
":func:`copy.copy`\\와 :func:`copy.deepcopy` 지원이 추가되었습니다. 일치 객체는 원자적이라고 "
"간주합니다."

#: ../../library/re.rst:1587
msgid "Regular Expression Examples"
msgstr "정규식 예제"

#: ../../library/re.rst:1591
msgid "Checking for a Pair"
msgstr "쌍 검사하기"

#: ../../library/re.rst:1593
msgid ""
"In this example, we'll use the following helper function to display match"
" objects a little more gracefully::"
msgstr "이 예제에서는, 다음과 같은 도우미 함수를 사용하여 좀 더 세련되게 일치 객체를 표시합니다::"

#: ../../library/re.rst:1596
#, python-format
msgid ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"
msgstr ""

#: ../../library/re.rst:1601
msgid ""
"Suppose you are writing a poker program where a player's hand is "
"represented as a 5-character string with each character representing a "
"card, \"a\" for ace, \"k\" for king, \"q\" for queen, \"j\" for jack, "
"\"t\" for 10, and \"2\" through \"9\" representing the card with that "
"value."
msgstr ""
"플레이어의 패를 5문자 문자열로 나타내는 포커 프로그램을 작성하고 있다고 가정해봅시다. \"a\"는 에이스, \"k\"는 킹, "
"\"q\"는 퀸, \"j\"는 잭, \"t\"는 10, \"2\"에서 \"9\"는 그 값의 카드를 나타냅니다."

#: ../../library/re.rst:1606
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr "주어진 문자열이 유효한 패인지 보려면, 다음과 같이 할 수 있습니다::"

#: ../../library/re.rst:1608
#, python-brace-format
msgid ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Valid.\n"
"\"<Match: 'akt5q', groups=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Invalid.\n"
">>> displaymatch(valid.match(\"akt\"))    # Invalid.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Valid.\n"
"\"<Match: '727ak', groups=()>\""
msgstr ""

#: ../../library/re.rst:1616
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same "
"valued cards. To match this with a regular expression, one could use "
"backreferences as such::"
msgstr ""
"마지막 패 ``\"727ak\"``\\는 페어, 즉 같은 값의 카드 두 장을 포함합니다. 이것을 정규식과 일치시키려면, 역참조를 "
"다음과 같이 사용할 수 있습니다::"

#: ../../library/re.rst:1619
msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(pair.match(\"717ak\"))     # Pair of 7s.\n"
"\"<Match: '717', groups=('7',)>\"\n"
">>> displaymatch(pair.match(\"718ak\"))     # No pairs.\n"
">>> displaymatch(pair.match(\"354aa\"))     # Pair of aces.\n"
"\"<Match: '354aa', groups=('a',)>\""
msgstr ""

#: ../../library/re.rst:1626
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~Match.group` method of the match object in the following manner::"
msgstr ""
"페어가 어떤 카드로 구성되어 있는지 알아내려면, 다음과 같이 일치 객체의 :meth:`~Match.group` 메서드를 사용할 수 "
"있습니다::"

#: ../../library/re.rst:1629
msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Error because re.match() returns None, which doesn't have a group() "
"method:\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"
msgstr ""

#: ../../library/re.rst:1645
msgid "Simulating scanf()"
msgstr "scanf() 시뮬레이션"

#: ../../library/re.rst:1649
#, fuzzy
msgid ""
"Python does not currently have an equivalent to :c:func:`!scanf`.  "
"Regular expressions are generally more powerful, though also more "
"verbose, than :c:func:`!scanf` format strings.  The table below offers "
"some more-or-less equivalent mappings between :c:func:`!scanf` format "
"tokens and regular expressions."
msgstr ""
"파이썬에는 현재 :c:func:`scanf`\\에 해당하는 것이 없습니다. 정규식은 일반적으로 :c:func:`scanf` 포맷 "
"문자열보다 강력하지만, 더 장황하기도 합니다. 아래 표는 :c:func:`scanf` 포맷 토큰과 정규식 간의 다소 비슷한 매핑을 "
"제공합니다."

#: ../../library/re.rst:1656
#, fuzzy
msgid ":c:func:`!scanf` Token"
msgstr ":c:func:`scanf` 토큰"

#: ../../library/re.rst:1656
msgid "Regular Expression"
msgstr "정규식"

#: ../../library/re.rst:1658
#, python-format
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1660
#, python-format
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1660
#, python-brace-format
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1662
#, python-format
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1662
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1664
#, python-format
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1664
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1666
#, python-format
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1666
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1668
#, python-format
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1668
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1670
#, python-format
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1670
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1672
#, python-format
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1672
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1674
#, python-format
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1674
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1677
msgid "To extract the filename and numbers from a string like ::"
msgstr "다음과 같은 문자열에서 파일명과 숫자를 추출하려면 ::"

#: ../../library/re.rst:1679
msgid "/usr/sbin/sendmail - 0 errors, 4 warnings"
msgstr ""

#: ../../library/re.rst:1681
#, fuzzy
msgid "you would use a :c:func:`!scanf` format like ::"
msgstr "여러분은 다음과 같은 :c:func:`scanf` 포맷을 사용할 것입니다 ::"

#: ../../library/re.rst:1683
#, python-format
msgid "%s - %d errors, %d warnings"
msgstr ""

#: ../../library/re.rst:1685
msgid "The equivalent regular expression would be ::"
msgstr "동등한 정규식은 다음과 같습니다 ::"

#: ../../library/re.rst:1687
msgid "(\\S+) - (\\d+) errors, (\\d+) warnings"
msgstr ""

#: ../../library/re.rst:1693
msgid "search() vs. match()"
msgstr "search() 대 match()"

#: ../../library/re.rst:1697
msgid "Python offers different primitive operations based on regular expressions:"
msgstr ""

#: ../../library/re.rst:1699
#, fuzzy
msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr "문자열 끝에만 일치합니다."

#: ../../library/re.rst:1700
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what"
" Perl does by default)"
msgstr ""

#: ../../library/re.rst:1702
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ""

#: ../../library/re.rst:1707
msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"c\", \"abcdef\")   # Match\n"
"<re.Match object; span=(2, 3), match='c'>\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Match\n"
"<re.Match object; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # No match"
msgstr ""

#: ../../library/re.rst:1714
msgid ""
"Regular expressions beginning with ``'^'`` can be used with "
":func:`search` to restrict the match at the beginning of the string::"
msgstr ""
"``'^'``\\로 시작하는 정규식은 :func:`search`\\와 함께 사용하여 문자열 시작 부분의 일치로 제한 할 수 "
"있습니다::"

#: ../../library/re.rst:1717
msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"^c\", \"abcdef\")  # No match\n"
">>> re.search(\"^a\", \"abcdef\")  # Match\n"
"<re.Match object; span=(0, 1), match='a'>"
msgstr ""

#: ../../library/re.rst:1722
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches "
"at the beginning of the string, whereas using :func:`search` with a "
"regular expression beginning with ``'^'`` will match at the beginning of "
"each line. ::"
msgstr ""
"그러나 :const:`MULTILINE` 모드에서 :func:`match`\\는 문자열 시작 부분에서만 일치하지만, "
"``'^'``\\로 시작하는 정규식을 :func:`search`\\에 사용하면 각 줄의 시작 부분에서 일치합니다. ::"

#: ../../library/re.rst:1726
msgid ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE)  # No match\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE)  # Match\n"
"<re.Match object; span=(4, 5), match='X'>"
msgstr ""

#: ../../library/re.rst:1732
msgid "Making a Phonebook"
msgstr "전화번호부 만들기"

#: ../../library/re.rst:1734
msgid ""
":func:`split` splits a string into a list delimited by the passed "
"pattern.  The method is invaluable for converting textual data into data "
"structures that can be easily read and modified by Python as demonstrated"
" in the following example that creates a phonebook."
msgstr ""
":func:`split`\\는 문자열을, 전달된 패턴으로 구분된 리스트로 분할합니다. 이 메서드는 전화번호부를 만드는 다음 예제에서"
" 보이듯이 텍스트 데이터를 파이썬에서 쉽게 읽고 수정할 수 있는 데이터 구조로 변환하는 데 매우 중요합니다."

#: ../../library/re.rst:1739
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr "먼저, 여기 입력이 있습니다. 보통 파일에서 올 수 있습니다만, 여기서는 삼중 따옴표로 묶인 문자열 문법을 사용합니다."

#: ../../library/re.rst:1742
msgid ""
">>> text = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""
msgstr ""

#: ../../library/re.rst:1752
msgid ""
"The entries are separated by one or more newlines. Now we convert the "
"string into a list with each nonempty line having its own entry:"
msgstr "항목은 하나 이상의 개행으로 구분됩니다. 이제 비어있지 않은 각 줄이 항목이 되도록 문자열을 리스트로 변환합니다:"

#: ../../library/re.rst:1755
msgid ""
">>> entries = re.split(\"\\n+\", text)\n"
">>> entries\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"
msgstr ""

#: ../../library/re.rst:1765
msgid ""
"Finally, split each entry into a list with first name, last name, "
"telephone number, and address.  We use the ``maxsplit`` parameter of "
":func:`split` because the address has spaces, our splitting pattern, in "
"it:"
msgstr ""
"마지막으로, 각 항목을 이름, 성, 전화번호 및 주소로 구성된 리스트로 분할합니다. 주소에 우리의 분할 패턴인 스페이스가 들어있기 "
"때문에, :func:`split`\\의 ``maxsplit`` 매개 변수를 사용합니다:"

#: ../../library/re.rst:1769
msgid ""
">>> [re.split(\":? \", entry, maxsplit=3) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"
msgstr ""

#: ../../library/re.rst:1778
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does"
" not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"``:?`` 패턴은 결과 리스트에 나타나지 않도록, 성 뒤의 콜론과 일치합니다. ``maxsplit``\\로 ``4``\\를 "
"사용하면, 번지수를 거리 이름과 분리 할 수 있습니다:"

#: ../../library/re.rst:1782
msgid ""
">>> [re.split(\":? \", entry, maxsplit=4) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"
msgstr ""

#: ../../library/re.rst:1793
msgid "Text Munging"
msgstr "텍스트 뒤섞기"

#: ../../library/re.rst:1795
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a"
" function to \"munge\" text, or randomize the order of all the characters"
" in each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub`\\는 패턴의 모든 일치를 문자열이나 함수의 결과로 치환합니다. 이 예제는 :func:`sub`\\에 텍스트를 "
"\"뒤섞는\", 즉 문장의 각 단어에서 첫 번째 문자와 마지막 문자를 제외한 모든 문자의 순서를 무작위로 바꾸는 함수를 사용하는 "
"방법을 보여줍니다::"

#: ../../library/re.rst:1800
msgid ""
">>> def repl(m):\n"
"...     inner_word = list(m.group(2))\n"
"...     random.shuffle(inner_word)\n"
"...     return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Abdolmalek, please report your absences "
"promptly.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"
msgstr ""

#: ../../library/re.rst:1813
msgid "Finding all Adverbs"
msgstr "모든 부사 찾기"

#: ../../library/re.rst:1815
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the "
"first one as :func:`search` does.  For example, if a writer wanted to "
"find all of the adverbs in some text, they might use :func:`findall` in "
"the following manner::"
msgstr ""
":func:`findall`\\은 :func:`search`\\처럼 첫 번째 등장뿐만 아니라, 패턴의 *모든* 등장과 일치합니다. "
"예를 들어, 작가가 어떤 텍스트에서 부사를 모두 찾고 싶으면, 다음과 같은 방식으로 :func:`findall`\\을 사용할 수 "
"있습니다::"

#: ../../library/re.rst:1820
msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\""
"\n"
">>> re.findall(r\"\\w+ly\\b\", text)\n"
"['carefully', 'quickly']"
msgstr ""

#: ../../library/re.rst:1826
msgid "Finding all Adverbs and their Positions"
msgstr "모든 부사와 그 위치 찾기"

#: ../../library/re.rst:1828
#, fuzzy
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides "
":class:`~re.Match` objects instead of strings.  Continuing with the "
"previous example, if a writer wanted to find all of the adverbs *and "
"their positions* in some text, they would use :func:`finditer` in the "
"following manner::"
msgstr ""
"일치하는 텍스트보다 패턴의 모든 일치에 대한 자세한 정보가 필요하면, :func:`finditer`\\는 문자열 대신 "
":ref:`일치 객체 <match-objects>`\\를 제공하므로 유용합니다. 이전 예에서 계속해서, 작가가 어떤 텍스트에서 "
"부사\\ *와 그 위치*\\를 모두 찾고 싶으면, 다음과 같은 방식으로 :func:`finditer`\\를 사용합니다::"

#: ../../library/re.rst:1834
#, python-format
msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\""
"\n"
">>> for m in re.finditer(r\"\\w+ly\\b\", text):\n"
"...     print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"07-16: carefully\n"
"40-47: quickly"
msgstr ""

#: ../../library/re.rst:1842
msgid "Raw String Notation"
msgstr "날 문자열 표기법"

#: ../../library/re.rst:1844
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  "
"Without it, every backslash (``'\\'``) in a regular expression would have"
" to be prefixed with another one to escape it.  For example, the two "
"following lines of code are functionally identical::"
msgstr ""
"날 문자열 표기법(``r\"text\"``)은 정규식을 합리적인 상태로 유지합니다. 이것 없이는, 정규식의 모든 역 "
"슬래시(``'\\'``)를 이스케이프 하기 위해 그 앞에 또 하나의 역 슬래시를 붙여야 합니다. 예를 들어, 다음 두 코드 줄은 "
"기능상으로 같습니다::"

#: ../../library/re.rst:1849
msgid ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>"
msgstr ""

#: ../../library/re.rst:1854
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``."
"  Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"리터럴 역 슬래시와 일치시키려면, 정규식에서 이스케이프 되어야 합니다. 날 문자열 표기법을 사용하면, ``r\"\\\\\"``\\이"
" 됩니다. 날 문자열 표기법을 사용하지 않으면, ``\"\\\\\\\\\"``\\를 사용해야 하는데, 다음 코드 줄들은 기능적으로 "
"같습니다::"

#: ../../library/re.rst:1859
msgid ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>"
msgstr ""

#: ../../library/re.rst:1866
msgid "Writing a Tokenizer"
msgstr "토크나이저 작성하기"

#: ../../library/re.rst:1868
msgid ""
"A `tokenizer or scanner "
"<https://en.wikipedia.org/wiki/Lexical_analysis>`_ analyzes a string to "
"categorize groups of characters.  This is a useful first step in writing "
"a compiler or interpreter."
msgstr ""
"`토크나이저나 스캐너 <https://en.wikipedia.org/wiki/Lexical_analysis>`_\\는 문자열을 "
"분석하여 문자 그룹을 분류합니다. 이것은 컴파일러나 인터프리터를 작성하는 데 유용한 첫 번째 단계입니다."

#: ../../library/re.rst:1872
msgid ""
"The text categories are specified with regular expressions.  The "
"technique is to combine those into a single master regular expression and"
" to loop over successive matches::"
msgstr "텍스트 범주는 정규식으로 지정됩니다. 이 기법은 이들을 하나의 마스터 정규식으로 결합하고 연속적인 일치를 반복하는 것입니다::"

#: ../../library/re.rst:1876
#, python-brace-format, python-format
msgid ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Integer or decimal number\n"
"        ('ASSIGN',   r':='),           # Assignment operator\n"
"        ('END',      r';'),            # Statement terminator\n"
"        ('ID',       r'[A-Za-z]+'),    # Identifiers\n"
"        ('OP',       r'[+\\-*/]'),      # Arithmetic operators\n"
"        ('NEWLINE',  r'\\n'),           # Line endings\n"
"        ('SKIP',     r'[ \\t]+'),       # Skip over spaces and tabs\n"
"        ('MISMATCH', r'.'),            # Any other character\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line "
"{line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"
msgstr ""

#: ../../library/re.rst:1928
msgid "The tokenizer produces the following output::"
msgstr "토크나이저는 다음과 같은 출력을 생성합니다::"

#: ../../library/re.rst:1930
msgid ""
"Token(type='IF', value='IF', line=2, column=4)\n"
"Token(type='ID', value='quantity', line=2, column=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(type='ID', value='total', line=3, column=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(type='ID', value='total', line=3, column=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(type='ID', value='price', line=3, column=25)\n"
"Token(type='OP', value='*', line=3, column=31)\n"
"Token(type='ID', value='quantity', line=3, column=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', line=4, column=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(type='ID', value='price', line=4, column=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(type='NUMBER', value=0.05, line=4, column=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(type='END', value=';', line=5, column=9)"
msgstr ""

#: ../../library/re.rst:1951
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but "
"the first edition covered writing good regular expression patterns in "
"great detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. 이 책의 세 번째 판은 더는 파이썬을 다루지 않지만, 초판은 훌륭한 정규식 패턴 작성을 아주 자세하게 다루었습니다."

#: ../../library/re.rst:99
msgid ". (dot)"
msgstr ""

#: ../../library/re.rst:99 ../../library/re.rst:106 ../../library/re.rst:112
#: ../../library/re.rst:123 ../../library/re.rst:130 ../../library/re.rst:137
#: ../../library/re.rst:143 ../../library/re.rst:157 ../../library/re.rst:181
#: ../../library/re.rst:220 ../../library/re.rst:235 ../../library/re.rst:244
#: ../../library/re.rst:258 ../../library/re.rst:271 ../../library/re.rst:304
#: ../../library/re.rst:317 ../../library/re.rst:327 ../../library/re.rst:359
#: ../../library/re.rst:414 ../../library/re.rst:446 ../../library/re.rst:452
#: ../../library/re.rst:457 ../../library/re.rst:464 ../../library/re.rst:471
#: ../../library/re.rst:498 ../../library/re.rst:508 ../../library/re.rst:531
#: ../../library/re.rst:543 ../../library/re.rst:548 ../../library/re.rst:570
#: ../../library/re.rst:590 ../../library/re.rst:606 ../../library/re.rst:614
#: ../../library/re.rst:628 ../../library/re.rst:636 ../../library/re.rst:653
#: ../../library/re.rst:667 ../../library/re.rst:672 ../../library/re.rst:863
#: ../../library/re.rst:1099
#, fuzzy
msgid "in regular expressions"
msgstr "정규식"

#: ../../library/re.rst:106 ../../library/re.rst:271
msgid "^ (caret)"
msgstr ""

#: ../../library/re.rst:112
msgid "$ (dollar)"
msgstr ""

#: ../../library/re.rst:123
msgid "* (asterisk)"
msgstr ""

#: ../../library/re.rst:130
msgid "+ (plus)"
msgstr ""

#: ../../library/re.rst:137
msgid "? (question mark)"
msgstr ""

#: ../../library/re.rst:143
msgid "*?"
msgstr ""

#: ../../library/re.rst:143
msgid "+?"
msgstr ""

#: ../../library/re.rst:143
msgid "??"
msgstr ""

#: ../../library/re.rst:157
msgid "*+"
msgstr ""

#: ../../library/re.rst:157
msgid "++"
msgstr ""

#: ../../library/re.rst:157
msgid "?+"
msgstr ""

#: ../../library/re.rst:181
#, python-brace-format
msgid "{} (curly brackets)"
msgstr ""

#: ../../library/re.rst:220 ../../library/re.rst:258 ../../library/re.rst:531
msgid "\\ (backslash)"
msgstr ""

#: ../../library/re.rst:235
msgid "[] (square brackets)"
msgstr ""

#: ../../library/re.rst:244
msgid "- (minus)"
msgstr ""

#: ../../library/re.rst:304
msgid "| (vertical bar)"
msgstr ""

#: ../../library/re.rst:317
msgid "() (parentheses)"
msgstr ""

#: ../../library/re.rst:327
msgid "(?"
msgstr ""

#: ../../library/re.rst:359
msgid "(?:"
msgstr ""

#: ../../library/re.rst:414
msgid "(?P<"
msgstr ""

#: ../../library/re.rst:446
msgid "(?P="
msgstr ""

#: ../../library/re.rst:452
msgid "(?#"
msgstr ""

#: ../../library/re.rst:457
msgid "(?="
msgstr ""

#: ../../library/re.rst:464
msgid "(?!"
msgstr ""

#: ../../library/re.rst:471
msgid "(?<="
msgstr ""

#: ../../library/re.rst:498
msgid "(?<!"
msgstr ""

#: ../../library/re.rst:508
msgid "(?("
msgstr ""

#: ../../library/re.rst:543
msgid "\\A"
msgstr ""

#: ../../library/re.rst:548 ../../library/re.rst:672
msgid "\\b"
msgstr ""

#: ../../library/re.rst:570
msgid "\\B"
msgstr ""

#: ../../library/re.rst:590
msgid "\\d"
msgstr ""

#: ../../library/re.rst:606
msgid "\\D"
msgstr ""

#: ../../library/re.rst:614
msgid "\\s"
msgstr ""

#: ../../library/re.rst:628
msgid "\\S"
msgstr ""

#: ../../library/re.rst:636
msgid "\\w"
msgstr ""

#: ../../library/re.rst:653
msgid "\\W"
msgstr ""

#: ../../library/re.rst:667
msgid "\\Z"
msgstr ""

#: ../../library/re.rst:672
msgid "\\a"
msgstr ""

#: ../../library/re.rst:672
msgid "\\f"
msgstr ""

#: ../../library/re.rst:672
msgid "\\n"
msgstr ""

#: ../../library/re.rst:672
msgid "\\N"
msgstr ""

#: ../../library/re.rst:672
msgid "\\r"
msgstr ""

#: ../../library/re.rst:672
msgid "\\t"
msgstr ""

#: ../../library/re.rst:672
msgid "\\u"
msgstr ""

#: ../../library/re.rst:672
msgid "\\U"
msgstr ""

#: ../../library/re.rst:672
msgid "\\v"
msgstr ""

#: ../../library/re.rst:672
msgid "\\x"
msgstr ""

#: ../../library/re.rst:672
msgid "\\\\"
msgstr ""

#: ../../library/re.rst:863
msgid "# (hash)"
msgstr ""

#: ../../library/re.rst:1099
msgid "\\g"
msgstr ""

#: ../../library/re.rst:1647
msgid "scanf (C function)"
msgstr ""

#~ msgid ""
#~ "Character classes such as ``\\w`` or "
#~ "``\\S`` (defined below) are also "
#~ "accepted inside a set, although the "
#~ "characters they match depends on whether"
#~ " :const:`ASCII` or :const:`LOCALE` mode is"
#~ " in force."
#~ msgstr ""
#~ "``\\w`` 나 ``\\S``\\(아래에서 정의됩니다)와 같은 문자"
#~ " 클래스도 집합 내에서 허용되지만, 일치하는 문자는 "
#~ ":const:`ASCII`\\나 :const:`LOCALE` 모드가 유효한지에 따라"
#~ " 다릅니다."

#~ msgid ""
#~ "(One or more letters from the set"
#~ " ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
#~ "``'s'``, ``'u'``, ``'x'``.)  The group "
#~ "matches the empty string; the letters"
#~ " set the corresponding flags: :const:`re.A`"
#~ " (ASCII-only matching), :const:`re.I` "
#~ "(ignore case), :const:`re.L` (locale "
#~ "dependent), :const:`re.M` (multi-line), "
#~ ":const:`re.S` (dot matches all), :const:`re.U`"
#~ " (Unicode matching), and :const:`re.X` "
#~ "(verbose), for the entire regular "
#~ "expression. (The flags are described in"
#~ " :ref:`contents-of-module-re`.) This "
#~ "is useful if you wish to include"
#~ " the flags as part of the "
#~ "regular expression, instead of passing a"
#~ " *flag* argument to the :func:`re.compile`"
#~ " function.  Flags should be used "
#~ "first in the expression string."
#~ msgstr ""
#~ "(집합 ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
#~ "``'s'``, ``'u'``, ``'x'``\\의 문자 중 하나 "
#~ "이상.) 그룹은 빈 문자열과 일치합니다; 문자는 해당 "
#~ "플래그를 전체 정규식에 대해 설정합니다: :const:`re.A` "
#~ "(ASCII만 일치), :const:`re.I` (케이스 무시), "
#~ ":const:`re.L` (로케일 종속), :const:`re.M` (여러 "
#~ "줄), :const:`re.S` (점이 모든 문자와 일치), "
#~ ":const:`re.U` (유니코드 일치) 및 :const:`re.X` "
#~ "(상세 모드). (플래그는 :ref:`contents-of-"
#~ "module-re`\\에 설명되어 있습니다.) :func:`re.compile` "
#~ "함수에 *flag* 인자를 전달하는 대신, 정규식의 일부로"
#~ " 플래그를 포함하려는 경우에 유용합니다. 플래그는 정규식 "
#~ "문자열에서 처음에 사용해야 합니다."

#~ msgid ""
#~ "Matches Unicode word characters; this "
#~ "includes most characters that can be "
#~ "part of a word in any language,"
#~ " as well as numbers and the "
#~ "underscore. If the :const:`ASCII` flag "
#~ "is used, only ``[a-zA-Z0-9_]`` is "
#~ "matched."
#~ msgstr ""
#~ "유니코드 단어 문자와 일치합니다; 여기에는 숫자와 밑줄뿐만"
#~ " 아니라, 모든 언어에서 단어의 일부가 될 수 "
#~ "있는 대부분의 문자가 포함됩니다. :const:`ASCII` 플래그가"
#~ " 사용되면 ``[a-zA-Z0-9_]``\\만 일치합니다."

#~ msgid ""
#~ "Matches any character which is not "
#~ "a word character. This is the "
#~ "opposite of ``\\w``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^a-zA-Z0-9_]``.  If"
#~ " the :const:`LOCALE` flag is used, "
#~ "matches characters which are neither "
#~ "alphanumeric in the current locale nor"
#~ " the underscore."
#~ msgstr ""
#~ "단어 문자가 아닌 모든 문자와 일치합니다. 이것은 "
#~ "``\\w``\\의 반대입니다. :const:`ASCII` 플래그가 사용되면 "
#~ "``[^a-zA-Z0-9_]``\\와 동등하게 됩니다. :const:`LOCALE` "
#~ "플래그를 사용하면, 현재 로케일에서 영숫자로 간주하는 문자와"
#~ " 밑줄을 제외한 것과 일치합니다."

#~ msgid ""
#~ "Note that for backward compatibility, "
#~ "the :const:`re.U` flag still exists (as"
#~ " well as its synonym :const:`re.UNICODE`"
#~ " and its embedded counterpart ``(?u)``),"
#~ " but these are redundant in Python"
#~ " 3 since matches are Unicode by "
#~ "default for strings (and Unicode "
#~ "matching isn't allowed for bytes)."
#~ msgstr ""
#~ "이전 버전과의 호환성을 위해, :const:`re.U` 플래그는 "
#~ "(동의어 :const:`re.UNICODE`\\와 내장 대응 버전 "
#~ "``(?u)``\\도) 여전히 존재하지만, 파이썬 3에서는 문자열에"
#~ " 대한 일치가 기본적으로 유니코드이므로 (그리고 유니코드 "
#~ "일치는 바이트열에는 허용되지 않습니다) 필요 없습니다."

#~ msgid ""
#~ "Return all non-overlapping matches of"
#~ " *pattern* in *string*, as a list "
#~ "of strings.  The *string* is scanned "
#~ "left-to-right, and matches are "
#~ "returned in the order found.  If "
#~ "one or more groups are present in"
#~ " the pattern, return a list of "
#~ "groups; this will be a list of "
#~ "tuples if the pattern has more "
#~ "than one group.  Empty matches are "
#~ "included in the result."
#~ msgstr ""
#~ "*string*\\에서 겹치지 않는 *pattern*\\의 모든 일치를"
#~ " 문자열 리스트로 반환합니다. *string*\\은 왼쪽에서 "
#~ "오른쪽으로 스캔 되고, 일치는 찾은 순서대로 반환됩니다."
#~ " 하나 이상의 그룹이 패턴에 있으면, 그룹 리스트를"
#~ " 반환합니다; 패턴에 두 개 이상의 그룹이 있으면 "
#~ "튜플의 리스트가 됩니다. 빈 일치가 결과에 포함됩니다."

#~ msgid ""
#~ "Unknown escapes in *repl* consisting of"
#~ " ``'\\'`` and an ASCII letter now "
#~ "are errors."
#~ msgstr "*repl*\\의 ``'\\'``\\와 ASCII 글자(letter)로 구성된 알 수 없는 이스케이프는 이제 에러입니다."

#~ msgid ""
#~ "Compiled regular expression objects support"
#~ " the following methods and attributes:"
#~ msgstr "컴파일된 정규식 객체는 다음 메서드와 어트리뷰트를 지원합니다:"

#~ msgid "Match objects support the following methods and attributes:"
#~ msgstr "일치 객체는 다음 메서드와 어트리뷰트를 지원합니다:"

#~ msgid ""
#~ "Python offers two different primitive "
#~ "operations based on regular expressions: "
#~ ":func:`re.match` checks for a match only"
#~ " at the beginning of the string, "
#~ "while :func:`re.search` checks for a "
#~ "match anywhere in the string (this "
#~ "is what Perl does by default)."
#~ msgstr ""
#~ "파이썬은 정규식에 기반한 두 가지 기본 연산을 "
#~ "제공합니다: :func:`re.match`\\는 문자열의 시작 부분에서만 "
#~ "일치를 검사하는 반면, :func:`re.search`\\는 문자열의 "
#~ "아무 곳에서나 일치하는지 확인합니다 (이것이 Perl이 "
#~ "기본적으로 수행하는 것입니다)."

