# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/http.client.rst:2
#, fuzzy
msgid ":mod:`!http.client` --- HTTP protocol client"
msgstr ":mod:`http.client` --- HTTP 프로토콜 클라이언트"

#: ../../library/http.client.rst:7
msgid "**Source code:** :source:`Lib/http/client.py`"
msgstr "**소스 코드:** :source:`Lib/http/client.py`"

#: ../../library/http.client.rst:17
#, fuzzy
msgid ""
"This module defines classes that implement the client side of the HTTP "
"and HTTPS protocols.  It is normally not used directly --- the module "
":mod:`urllib.request` uses it to handle URLs that use HTTP and HTTPS."
msgstr ""
"이 모듈은 HTTP 및 HTTPS 프로토콜의 클라이언트 측을 구현하는 클래스를 정의합니다. 일반적으로 직접 사용되지 않습니다 ---"
" :mod:`urllib.request` 모듈은 이를 사용하여 HTTP와 HTTPS를 사용하는 URL을 처리합니다."

#: ../../library/http.client.rst:23
#, fuzzy
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/latest/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"더 고수준 HTTP 클라이언트 인터페이스로 `Requests 패키지 "
"<https://requests.readthedocs.io/en/master/>`_\\를 권장합니다."

#: ../../library/http.client.rst:28
msgid ""
"HTTPS support is only available if Python was compiled with SSL support "
"(through the :mod:`ssl` module)."
msgstr "HTTPS 지원은 파이썬이 SSL 지원으로 컴파일된 경우에만 사용 가능합니다 (:mod:`ssl` 모듈을 통해)."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/http.client.rst:33
msgid "The module provides the following classes:"
msgstr "이 모듈은 다음과 같은 클래스를 제공합니다:"

#: ../../library/http.client.rst:39
#, fuzzy
msgid ""
"An :class:`HTTPConnection` instance represents one transaction with an "
"HTTP server.  It should be instantiated by passing it a host and optional"
" port number.  If no port number is passed, the port is extracted from "
"the host string if it has the form ``host:port``, else the default HTTP "
"port (80) is used.  If the optional *timeout* parameter is given, "
"blocking operations (like connection attempts) will timeout after that "
"many seconds (if it is not given, the global default timeout setting is "
"used). The optional *source_address* parameter may be a tuple of a (host,"
" port) to use as the source address the HTTP connection is made from. The"
" optional *blocksize* parameter sets the buffer size in bytes for sending"
" a file-like message body."
msgstr ""
":class:`HTTPConnection` 인스턴스는 HTTP 서버와의 하나의 트랜잭션을 나타냅니다. 호스트와 선택적 포트 번호를 "
"전달하여 인스턴스화해야 합니다. 포트 번호가 전달되지 않으면, host 문자열이 ``host:port`` 형식이면 여기에서 포트가 "
"추출됩니다, 그렇지 않으면 기본 HTTP 포트(80)가 사용됩니다. 선택적 *timeout* 매개 변수가 제공되면, 블로킹 "
"연산(연결 시도와 같은)이 지정된 초 후에 시간제한으로 종료됩니다 (제공되지 않으면, 전역 기본 시간제한 설정이 사용됩니다). "
"선택적 *source_address* 매개 변수는 HTTP 연결의 소스 주소로 사용할 (호스트, 포트)의 튜플일 수 있습니다. "
"선택적 *blocksize* 매개 변수는 파일류 메시지 바디를 보내는 데 필요한 버퍼 크기를 바이트 단위로 설정합니다."

#: ../../library/http.client.rst:51
msgid ""
"For example, the following calls all create instances that connect to the"
" server at the same host and port::"
msgstr "예를 들어, 다음 호출은 모두 같은 호스트와 포트에 있는 서버에 연결하는 인스턴스를 만듭니다::"

#: ../../library/http.client.rst:54
msgid ""
">>> h1 = http.client.HTTPConnection('www.python.org')\n"
">>> h2 = http.client.HTTPConnection('www.python.org:80')\n"
">>> h3 = http.client.HTTPConnection('www.python.org', 80)\n"
">>> h4 = http.client.HTTPConnection('www.python.org', 80, timeout=10)"
msgstr ""

#: ../../library/http.client.rst:59
msgid "*source_address* was added."
msgstr "*source_address*\\가 추가되었습니다."

#: ../../library/http.client.rst:62
#, fuzzy
msgid ""
"The  *strict* parameter was removed. HTTP 0.9-style \"Simple Responses\" "
"are no longer supported."
msgstr "*strict* 매개 변수가 제거되었습니다. HTTP 0.9 스타일 \"간단한 응답\"은 더는 지원되지 않습니다."

#: ../../library/http.client.rst:66
msgid "*blocksize* parameter was added."
msgstr "*blocksize* 매개 변수가 추가되었습니다."

#: ../../library/http.client.rst:74
msgid ""
"A subclass of :class:`HTTPConnection` that uses SSL for communication "
"with secure servers.  Default port is ``443``.  If *context* is "
"specified, it must be a :class:`ssl.SSLContext` instance describing the "
"various SSL options."
msgstr ""
"보안 서버와의 통신에 SSL을 사용하는 :class:`HTTPConnection`\\의 서브 클래스. 기본 포트는 "
"``443``\\입니다. *context*\\가 지정되면, 다양한 SSL 옵션을 기술하는 :class:`ssl.SSLContext`"
" 인스턴스여야 합니다."

#: ../../library/http.client.rst:79
msgid "Please read :ref:`ssl-security` for more information on best practices."
msgstr "모범 사례에 대한 자세한 내용은 :ref:`ssl-security`\\을 참조하십시오."

#: ../../library/http.client.rst:81
msgid "*source_address*, *context* and *check_hostname* were added."
msgstr "*source_address*, *context* 및 *check_hostname*\\이 추가되었습니다."

#: ../../library/http.client.rst:84
#, fuzzy
msgid ""
"This class now supports HTTPS virtual hosts if possible (that is, if "
":const:`ssl.HAS_SNI` is true)."
msgstr "이 클래스는 이제 가능하면 (즉, :data:`ssl.HAS_SNI`\\가 참이면) HTTPS 가상 호스트를 지원합니다."

#: ../../library/http.client.rst:88
msgid ""
"The *strict* parameter was removed. HTTP 0.9-style \"Simple Responses\" "
"are no longer supported."
msgstr "*strict* 매개 변수가 제거되었습니다. HTTP 0.9 스타일 \"간단한 응답\"은 더는 지원되지 않습니다."

#: ../../library/http.client.rst:92
#, fuzzy
msgid ""
"This class now performs all the necessary certificate and hostname checks"
" by default. To revert to the previous, unverified, behavior "
":func:`!ssl._create_unverified_context` can be passed to the *context* "
"parameter."
msgstr ""
"이 클래스는 이제 기본적으로 필요한 모든 인증서와 호스트 이름 검사를 수행합니다. 이전의 검사하지 않는 동작으로 되돌리려면 "
":func:`ssl._create_unverified_context`\\를 *context* 매개 변수로 전달할 수 있습니다."

#: ../../library/http.client.rst:98
msgid ""
"This class now enables TLS 1.3 :attr:`ssl.SSLContext.post_handshake_auth`"
" for the default *context* or when *cert_file* is passed with a custom "
"*context*."
msgstr ""
"이 클래스는 이제 기본 *context*\\나 *cert_file*\\이 사용자 정의 *context*\\와 함께 전달될 때 TLS"
" 1.3 :attr:`ssl.SSLContext.post_handshake_auth`\\를 활성화합니다."

#: ../../library/http.client.rst:103
msgid ""
"This class now sends an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN"
" protocols with :meth:`~ssl.SSLContext.set_alpn_protocols`."
msgstr ""

#: ../../library/http.client.rst:108
msgid ""
"The deprecated *key_file*, *cert_file* and *check_hostname* parameters "
"have been removed."
msgstr ""

#: ../../library/http.client.rst:115
msgid ""
"Class whose instances are returned upon successful connection.  Not "
"instantiated directly by user."
msgstr "성공적으로 연결되면 반환되는 인스턴스의 클래스. 사용자가 직접 인스턴스화 하지 않습니다."

#: ../../library/http.client.rst:118
msgid ""
"The *strict* parameter was removed. HTTP 0.9 style \"Simple Responses\" "
"are no longer supported."
msgstr "*strict* 매개 변수가 제거되었습니다. HTTP 0.9 스타일 \"간단한 응답\"은 더는 지원되지 않습니다."

#: ../../library/http.client.rst:122
msgid "This module provides the following function:"
msgstr "이 모듈은 다음 함수를 제공합니다:"

#: ../../library/http.client.rst:126
#, fuzzy
msgid ""
"Parse the headers from a file pointer *fp* representing a HTTP "
"request/response. The file has to be a :class:`~io.BufferedIOBase` reader"
" (i.e. not text) and must provide a valid :rfc:`2822` style header."
msgstr ""
"HTTP 요청/응답을 나타내는 파일 포인터 *fp*\\에서 헤더를 구문 분석합니다. 파일은 "
":class:`BufferedIOBase` 판독기(reader)여야 하며 (즉 텍스트가 아닙니다) 유효한 :rfc:`2822` "
"스타일 헤더를 제공해야 합니다."

#: ../../library/http.client.rst:130
msgid ""
"This function returns an instance of :class:`http.client.HTTPMessage` "
"that holds the header fields, but no payload (the same as "
":attr:`HTTPResponse.msg` and "
":attr:`http.server.BaseHTTPRequestHandler.headers`). After returning, the"
" file pointer *fp* is ready to read the HTTP body."
msgstr ""
"이 함수는 헤더 필드를 담은 :class:`http.client.HTTPMessage` 인스턴스를 반환하지만, 페이 로드는 반환하지"
" 않습니다 (:attr:`HTTPResponse.msg`\\와 "
":attr:`http.server.BaseHTTPRequestHandler.headers`\\와 같습니다). 반환 후, 파일 포인터"
" *fp*\\는 HTTP 바디를 읽을 준비가 되었습니다."

#: ../../library/http.client.rst:137
msgid ""
":meth:`parse_headers` does not parse the start-line of a HTTP message; it"
" only parses the ``Name: value`` lines. The file has to be ready to read "
"these field lines, so the first line should already be consumed before "
"calling the function."
msgstr ""
":meth:`parse_headers`\\는 HTTP 메시지의 시작 줄을 구문 분석하지 않습니다; ``Name: value`` 줄만"
" 구문 분석합니다. 파일은 이러한 필드 줄을 읽을 준비가 되어 있어야 해서, 함수를 호출하기 전에 첫 번째 줄이 이미 소비되었어야 "
"합니다."

#: ../../library/http.client.rst:142
msgid "The following exceptions are raised as appropriate:"
msgstr "다음과 같은 예외가 적절하게 발생합니다:"

#: ../../library/http.client.rst:147
msgid ""
"The base class of the other exceptions in this module.  It is a subclass "
"of :exc:`Exception`."
msgstr "이 모듈에 있는 다른 예외의 베이스 클래스입니다. :exc:`Exception`\\의 서브 클래스입니다."

#: ../../library/http.client.rst:153 ../../library/http.client.rst:164
#: ../../library/http.client.rst:169 ../../library/http.client.rst:174
#: ../../library/http.client.rst:179 ../../library/http.client.rst:184
msgid "A subclass of :exc:`HTTPException`."
msgstr ":exc:`HTTPException`\\의 서브 클래스."

#: ../../library/http.client.rst:158
msgid ""
"A subclass of :exc:`HTTPException`, raised if a port is given and is "
"either non-numeric or empty."
msgstr "포트가 제공되고 숫자가 아니거나 비어있을 때 발생하는 :exc:`HTTPException`\\의 서브 클래스."

#: ../../library/http.client.rst:189 ../../library/http.client.rst:194
#: ../../library/http.client.rst:199
msgid "A subclass of :exc:`ImproperConnectionState`."
msgstr ":exc:`ImproperConnectionState`\\의 서브 클래스."

#: ../../library/http.client.rst:204
msgid ""
"A subclass of :exc:`HTTPException`.  Raised if a server responds with a "
"HTTP status code that we don't understand."
msgstr ":exc:`HTTPException`\\의 서브 클래스. 이해하지 못하는 HTTP 상태 코드로 서버가 응답하면 발생합니다."

#: ../../library/http.client.rst:210
msgid ""
"A subclass of :exc:`HTTPException`.  Raised if an excessively long line "
"is received in the HTTP protocol from the server."
msgstr ":exc:`HTTPException`\\의 서브 클래스. 서버에서 HTTP 프로토콜로 너무 긴 줄이 수신되면 발생합니다."

#: ../../library/http.client.rst:216
msgid ""
"A subclass of :exc:`ConnectionResetError` and :exc:`BadStatusLine`.  "
"Raised by :meth:`HTTPConnection.getresponse` when the attempt to read the"
" response results in no data read from the connection, indicating that "
"the remote end has closed the connection."
msgstr ""
":exc:`ConnectionResetError`\\와 :exc:`BadStatusLine`\\의 서브 클래스. "
":meth:`HTTPConnection.getresponse`\\가 응답을 읽으려고 시도할 때 연결에서 아무런 데이터를 읽지 "
"못하여, 원격 끝이 연결을 닫았음을 표시하면 발생합니다."

#: ../../library/http.client.rst:221
msgid "Previously, :exc:`BadStatusLine`\\ ``('')`` was raised."
msgstr "이전에는, :exc:`BadStatusLine`\\ ``('')``\\가 발생했습니다."

#: ../../library/http.client.rst:225
msgid "The constants defined in this module are:"
msgstr "이 모듈에 정의된 상수는 다음과 같습니다:"

#: ../../library/http.client.rst:229
msgid "The default port for the HTTP protocol (always ``80``)."
msgstr "HTTP 프로토콜의 기본 포트 (항상 ``80``)."

#: ../../library/http.client.rst:233
msgid "The default port for the HTTPS protocol (always ``443``)."
msgstr "HTTPS 프로토콜의 기본 포트 (항상 ``443``)."

#: ../../library/http.client.rst:237
msgid "This dictionary maps the HTTP 1.1 status codes to the W3C names."
msgstr "이 딕셔너리는 HTTP 1.1 상태 코드를 W3C 이름으로 매핑합니다."

#: ../../library/http.client.rst:239
msgid ""
"Example: ``http.client.responses[http.client.NOT_FOUND]`` is ``'Not "
"Found'``."
msgstr ""
"예: ``http.client.responses[http.client.NOT_FOUND]``\\는 ``'Not "
"Found'``\\입니다."

#: ../../library/http.client.rst:241
msgid ""
"See :ref:`http-status-codes` for a list of HTTP status codes that are "
"available in this module as constants."
msgstr "이 모듈에서 상수로 사용 가능한 HTTP 상태 코드 목록은 :ref:`http-status-codes`\\를 참조하십시오."

#: ../../library/http.client.rst:248
msgid "HTTPConnection Objects"
msgstr "HTTPConnection 객체"

#: ../../library/http.client.rst:250
msgid ":class:`HTTPConnection` instances have the following methods:"
msgstr ":class:`HTTPConnection` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/http.client.rst:256
msgid ""
"This will send a request to the server using the HTTP request method "
"*method* and the request URI *url*. The provided *url* must be an "
"absolute path to conform with :rfc:`RFC 2616 §5.1.2 <2616#section-5.1.2>`"
" (unless connecting to an HTTP proxy server or using the ``OPTIONS`` or "
"``CONNECT`` methods)."
msgstr ""

#: ../../library/http.client.rst:262
msgid ""
"If *body* is specified, the specified data is sent after the headers are "
"finished.  It may be a :class:`str`, a :term:`bytes-like object`, an open"
" :term:`file object`, or an iterable of :class:`bytes`.  If *body* is a "
"string, it is encoded as ISO-8859-1, the default for HTTP.  If it is a "
"bytes-like object, the bytes are sent as is.  If it is a :term:`file "
"object`, the contents of the file is sent; this file object should "
"support at least the ``read()`` method.  If the file object is an "
"instance of :class:`io.TextIOBase`, the data returned by the ``read()`` "
"method will be encoded as ISO-8859-1, otherwise the data returned by "
"``read()`` is sent as is.  If *body* is an iterable, the elements of the "
"iterable are sent as is until the iterable is exhausted."
msgstr ""
"*body*\\가 지정되면, 헤더가 완료된 후 지정된 데이터가 전송됩니다. :class:`str`, :term:`바이트열류 객체 "
"<bytes-like object>`, 열린 :term:`파일 객체 <file object>` 또는 :class:`bytes`\\의"
" 이터러블일 수 있습니다. *body*\\가 문자열이면, HTTP의 기본값인 ISO-8859-1로 인코딩됩니다. 바이트열류 "
"객체이면, 바이트열은 그대로 전송됩니다. :term:`파일 객체 <file object>`\\이면, 파일의 내용이 전송됩니다; 이 "
"파일 객체는 최소한 ``read()`` 메서드를 지원해야 합니다. 파일 객체가 :class:`io.TextIOBase`\\의 "
"인스턴스이면, ``read()`` 메서드에서 반환된 데이터는 ISO-8859-1로 인코딩되고, 그렇지 않으면 "
"``read()``\\에서 반환된 데이터가 그대로 전송됩니다. *body*\\가 이터러블이면, 이터러블이 소진될 때까지 이터러블의 "
"요소가 그대로 전송됩니다."

#: ../../library/http.client.rst:274
msgid ""
"The *headers* argument should be a mapping of extra HTTP headers to send "
"with the request. A :rfc:`Host header <2616#section-14.23>` must be "
"provided to conform with :rfc:`RFC 2616 §5.1.2 <2616#section-5.1.2>` "
"(unless connecting to an HTTP proxy server or using the ``OPTIONS`` or "
"``CONNECT`` methods)."
msgstr ""

#: ../../library/http.client.rst:280
msgid ""
"If *headers* contains neither Content-Length nor Transfer-Encoding, but "
"there is a request body, one of those header fields will be added "
"automatically.  If *body* is ``None``, the Content-Length header is set "
"to ``0`` for methods that expect a body (``PUT``, ``POST``, and "
"``PATCH``).  If *body* is a string or a bytes-like object that is not "
"also a :term:`file <file object>`, the Content-Length header is set to "
"its length.  Any other type of *body* (files and iterables in general) "
"will be chunk-encoded, and the Transfer-Encoding header will "
"automatically be set instead of Content-Length."
msgstr ""
"*headers*\\에 Content-Length도 Transfer-Encoding도 없지만, 요청 바디가 있으면, 이 헤더 필드 "
"중 하나가 자동으로 추가됩니다. *body*\\가 ``None``\\이면, 바디를 기대하는 메서드(``PUT``, ``POST`` "
"및 ``PATCH``)의 경우 Content-Length 헤더가 ``0``\\으로 설정됩니다. *body*\\가 문자열이거나 "
":term:`파일 <file object>`\\이 아닌 바이트열류 객체이면, Content-Length 헤더가 그것의 길이로 "
"설정됩니다. 다른 모든 형의 *body*\\(파일과 이터러블 일반)는 청크 인코딩되며 Content-Length 대신 "
"Transfer-Encoding 헤더가 자동으로 설정됩니다."

#: ../../library/http.client.rst:292
msgid ""
"The *encode_chunked* argument is only relevant if Transfer-Encoding is "
"specified in *headers*.  If *encode_chunked* is ``False``, the "
"HTTPConnection object assumes that all encoding is handled by the calling"
" code.  If it is ``True``, the body will be chunk-encoded."
msgstr ""
"*encode_chunked* 인자는 Transfer-Encoding이 *headers*\\에 지정된 경우에만 유효합니다. "
"*encode_chunked*\\가 ``False``\\이면, HTTPConnection 객체는 모든 인코딩이 호출하는 코드에서 "
"처리된다고 가정합니다. ``True``\\이면, 바디가 청크 인코딩됩니다."

#: ../../library/http.client.rst:297
msgid ""
"For example, to perform a ``GET`` request to "
"``https://docs.python.org/3/``::"
msgstr ""

#: ../../library/http.client.rst:299
#, python-brace-format
msgid ""
">>> import http.client\n"
">>> host = \"docs.python.org\"\n"
">>> conn = http.client.HTTPSConnection(host)\n"
">>> conn.request(\"GET\", \"/3/\", headers={\"Host\": host})\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"200 OK"
msgstr ""

#: ../../library/http.client.rst:308
msgid ""
"Chunked transfer encoding has been added to the HTTP protocol version "
"1.1.  Unless the HTTP server is known to handle HTTP 1.1, the caller must"
" either specify the Content-Length, or must pass a :class:`str` or bytes-"
"like object that is not also a file as the body representation."
msgstr ""
"청크 전송 인코딩은 HTTP 프로토콜 버전 1.1에 추가되었습니다. HTTP 서버가 HTTP 1.1을 처리하는 것으로 알려지지 않은"
" 한, 호출자는 Content-Length를 지정하거나, 바디 표현으로 :class:`str`\\이나 파일이 아닌 바이트열류 객체를"
" 전달해야 합니다."

#: ../../library/http.client.rst:314
msgid "*body* can now be an iterable."
msgstr "*body*\\는 이제 이터러블일 수 있습니다."

#: ../../library/http.client.rst:317
msgid ""
"If neither Content-Length nor Transfer-Encoding are set in *headers*, "
"file and iterable *body* objects are now chunk-encoded. The "
"*encode_chunked* argument was added. No attempt is made to determine the "
"Content-Length for file objects."
msgstr ""
"Content-Length도 Transfer-Encoding도 *headers*\\에 설정되지 않으면, 파일과 이터러블 *body*"
" 객체는 이제 청크 인코딩됩니다. *encode_chunked* 인자가 추가되었습니다. 파일 객체의 Content-Length를 "
"결정하려는 시도는 없습니다."

#: ../../library/http.client.rst:326
msgid ""
"Should be called after a request is sent to get the response from the "
"server. Returns an :class:`HTTPResponse` instance."
msgstr "요청을 보낸 후에 서버에서 응답을 받기 위해 호출해야 합니다. :class:`HTTPResponse` 인스턴스를 반환합니다."

#: ../../library/http.client.rst:331
msgid ""
"Note that you must have read the whole response before you can send a new"
" request to the server."
msgstr "서버에 새 요청을 보내기 전에 전체 응답을 읽어야 함에 유의하십시오."

#: ../../library/http.client.rst:334
msgid ""
"If a :exc:`ConnectionError` or subclass is raised, the "
":class:`HTTPConnection` object will be ready to reconnect when a new "
"request is sent."
msgstr ""
":exc:`ConnectionError`\\나 서브 클래스가 발생하면, 새 요청이 전송될 때 "
":class:`HTTPConnection` 객체는 다시 연결할 준비가 됩니다."

#: ../../library/http.client.rst:342
msgid ""
"Set the debugging level.  The default debug level is ``0``, meaning no "
"debugging output is printed.  Any value greater than ``0`` will cause all"
" currently defined debug output to be printed to stdout.  The "
"``debuglevel`` is passed to any new :class:`HTTPResponse` objects that "
"are created."
msgstr ""
"디버깅 수준을 설정합니다. 기본 디버그 수준은 ``0``\\이며, 디버깅 출력이 인쇄되지 않음을 의미합니다. ``0``\\보다 큰 "
"값을 지정하면 현재 정의된 모든 디버그 출력이 표준 출력으로 인쇄됩니다. ``debuglevel``\\은 만들어지는 모든 새로운 "
":class:`HTTPResponse` 객체로 전달됩니다."

#: ../../library/http.client.rst:352
msgid ""
"Set the host and the port for HTTP Connect Tunnelling. This allows "
"running the connection through a proxy server."
msgstr ""
"HTTP Connect 터널링(tunnelling)을 위한 host와 및 port를 설정합니다. 프락시 서버를 통해 연결을 실행할 "
"수 있도록 합니다."

#: ../../library/http.client.rst:355
#, fuzzy
msgid ""
"The *host* and *port* arguments specify the endpoint of the tunneled "
"connection (i.e. the address included in the CONNECT request, *not* the "
"address of the proxy server)."
msgstr ""
"host와 port 인자는 터널링 된 연결의 말단(즉 CONNECT 요청에 포함되는 주소, 프락시 서버의 주소가 *아닙니다*)을 "
"지정합니다."

#: ../../library/http.client.rst:359
#, fuzzy
msgid ""
"The *headers* argument should be a mapping of extra HTTP headers to send "
"with the CONNECT request."
msgstr "headers 인자는 CONNECT 요청과 함께 보낼 추가 HTTP 헤더의 매핑이어야 합니다."

#: ../../library/http.client.rst:362
msgid ""
"As HTTP/1.1 is used for HTTP CONNECT tunnelling request, `as per the RFC "
"<https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6>`_, a HTTP "
"``Host:`` header must be provided, matching the authority-form of the "
"request target provided as the destination for the CONNECT request. If a "
"HTTP ``Host:`` header is not provided via the headers argument, one is "
"generated and transmitted automatically."
msgstr ""

#: ../../library/http.client.rst:369
msgid ""
"For example, to tunnel through a HTTPS proxy server running locally on "
"port 8080, we would pass the address of the proxy to the "
":class:`HTTPSConnection` constructor, and the address of the host that we"
" eventually want to reach to the :meth:`~HTTPConnection.set_tunnel` "
"method::"
msgstr ""
"예를 들어, 포트 8080에서 로컬로 실행되는 HTTPS 프락시 서버를 통해 터널링 하려면, 프락시 주소를 "
":class:`HTTPSConnection` 생성자에 전달하고, 최종적으로 "
":meth:`~HTTPConnection.set_tunnel` 메서드에 도달하려는 호스트 주소를 전달합니다::"

#: ../../library/http.client.rst:374
msgid ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"localhost\", 8080)\n"
">>> conn.set_tunnel(\"www.python.org\")\n"
">>> conn.request(\"HEAD\",\"/index.html\")"
msgstr ""

#: ../../library/http.client.rst:381
msgid ""
"HTTP CONNECT tunnelling requests use protocol HTTP/1.1, upgraded from "
"protocol HTTP/1.0. ``Host:`` HTTP headers are mandatory for HTTP/1.1, so "
"one will be automatically generated and transmitted if not provided in "
"the headers argument."
msgstr ""

#: ../../library/http.client.rst:390
msgid ""
"Returns a dictionary with the headers of the response received from the "
"proxy server to the CONNECT request."
msgstr ""

#: ../../library/http.client.rst:393
msgid "If the CONNECT request was not sent, the method returns ``None``."
msgstr ""

#: ../../library/http.client.rst:400
msgid ""
"Connect to the server specified when the object was created.  By default,"
" this is called automatically when making a request if the client does "
"not already have a connection."
msgstr "객체가 만들어질 때 지정된 서버에 연결합니다. 기본적으로, 클라이언트가 이미 연결되지 않았다면 요청 시 자동으로 호출됩니다."

#: ../../library/http.client.rst:404
msgid ""
"Raises an :ref:`auditing event <auditing>` ``http.client.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""

#: ../../library/http.client.rst:409
msgid "Close the connection to the server."
msgstr "서버로의 연결을 닫습니다."

#: ../../library/http.client.rst:414
msgid "Buffer size in bytes for sending a file-like message body."
msgstr "파일류 메시지 바디를 보내기 위한 바이트 단위의 버퍼 크기."

#: ../../library/http.client.rst:419
#, fuzzy
msgid ""
"As an alternative to using the :meth:`~HTTPConnection.request` method "
"described above, you can also send your request step by step, by using "
"the four functions below."
msgstr ""
"위에서 설명한 :meth:`request` 메서드를 사용하는 대신, 아래 네 가지 함수를 사용하여 단계별로 요청을 보낼 수도 "
"있습니다."

#: ../../library/http.client.rst:426
msgid ""
"This should be the first call after the connection to the server has been"
" made. It sends a line to the server consisting of the *method* string, "
"the *url* string, and the HTTP version (``HTTP/1.1``).  To disable "
"automatic sending of ``Host:`` or ``Accept-Encoding:`` headers (for "
"example to accept additional content encodings), specify *skip_host* or "
"*skip_accept_encoding* with non-False values."
msgstr ""
"서버에 연결한 후 첫 번째 호출이어야 합니다. *method* 문자열, *url* 문자열 및 HTTP "
"버전(``HTTP/1.1``)으로 구성된 줄을 서버로 보냅니다. ``Host:``\\나 ``Accept-Encoding:`` 헤더의"
" 자동 전송을 비활성화하려면 (예를 들어 추가 콘텐츠 인코딩을 허용하려면), False가 아닌 값으로 *skip_host*\\나 "
"*skip_accept_encoding*\\을 지정하십시오."

#: ../../library/http.client.rst:436
msgid ""
"Send an :rfc:`822`\\ -style header to the server.  It sends a line to the"
" server consisting of the header, a colon and a space, and the first "
"argument.  If more arguments are given, continuation lines are sent, each"
" consisting of a tab and an argument."
msgstr ""
":rfc:`822` 스타일 헤더를 서버에 보냅니다. header, 콜론과 공백 및 첫 번째 인자로 구성된 줄을 서버로 보냅니다. 더"
" 많은 인자가 제공되면, 탭과 인자로 구성된 연속 줄(continuation lines)이 전송됩니다."

#: ../../library/http.client.rst:444
msgid ""
"Send a blank line to the server, signalling the end of the headers. The "
"optional *message_body* argument can be used to pass a message body "
"associated with the request."
msgstr ""
"헤더의 끝을 알리는 빈 줄을 서버에 보냅니다. 선택적 *message_body* 인자를 사용하여 요청과 연관된 메시지 바디를 전달할"
" 수 있습니다."

#: ../../library/http.client.rst:448
msgid ""
"If *encode_chunked* is ``True``, the result of each iteration of "
"*message_body* will be chunk-encoded as specified in :rfc:`7230`, Section"
" 3.3.1.  How the data is encoded is dependent on the type of "
"*message_body*.  If *message_body* implements the :ref:`buffer interface "
"<bufferobjects>` the encoding will result in a single chunk. If "
"*message_body* is a :class:`collections.abc.Iterable`, each iteration of "
"*message_body* will result in a chunk.  If *message_body* is a "
":term:`file object`, each call to ``.read()`` will result in a chunk. The"
" method automatically signals the end of the chunk-encoded data "
"immediately after *message_body*."
msgstr ""
"*encode_chunked*\\가 ``True``\\이면, *message_body*\\의 각 이터레이션 결과는 "
":rfc:`7230`, 섹션 3.3.1에 지정된 대로 청크 인코딩됩니다. 데이터의 인코딩 방식은 *message_body*\\의 "
"형에 따라 다릅니다. *message_body*\\가 :ref:`버퍼 인터페이스 <bufferobjects>`\\를 구현하면, "
"인코딩은 단일 청크를 만듭니다. *message_body*\\가 "
":class:`collections.abc.Iterable`\\이면, *message_body*\\의 각 이터레이션이 청크가 "
"됩니다. *message_body*\\가 :term:`파일 객체 <file object>`\\이면, 각 ``.read()`` "
"호출마다 청크가 됩니다. 이 메서드는 *message_body* 직후에 청크 인코딩된 데이터의 끝을 자동으로 알립니다."

#: ../../library/http.client.rst:459
msgid ""
"Due to the chunked encoding specification, empty chunks yielded by an "
"iterator body will be ignored by the chunk-encoder. This is to avoid "
"premature termination of the read of the request by the target server due"
" to malformed encoding."
msgstr ""
"청크 인코딩 명세로 인해, 이터레이터 바디에서 산출된 빈 청크는 청크 인코더에서 무시됩니다. 이는 형식이 잘못된 인코딩으로 인해 "
"대상 서버의 요청 읽기가 조기에 종료되지 않도록 하려는 것입니다."

#: ../../library/http.client.rst:464
#, fuzzy
msgid "Added chunked encoding support and the *encode_chunked* parameter."
msgstr "청크 인코딩 지원. *encode_chunked* 매개 변수가 추가되었습니다."

#: ../../library/http.client.rst:470
msgid ""
"Send data to the server.  This should be used directly only after the "
":meth:`endheaders` method has been called and before :meth:`getresponse` "
"is called."
msgstr ""
"서버로 data를 보냅니다. 이것은 :meth:`endheaders` 메서드가 호출된 후, 그리고 "
":meth:`getresponse`\\가 호출되기 전에만 직접 사용해야 합니다."

#: ../../library/http.client.rst:474
msgid ""
"Raises an :ref:`auditing event <auditing>` ``http.client.send`` with "
"arguments ``self``, ``data``."
msgstr ""

#: ../../library/http.client.rst:480
msgid "HTTPResponse Objects"
msgstr "HTTPResponse 객체"

#: ../../library/http.client.rst:482
msgid ""
"An :class:`HTTPResponse` instance wraps the HTTP response from the "
"server.  It provides access to the request headers and the entity body.  "
"The response is an iterable object and can be used in a with statement."
msgstr ""
":class:`HTTPResponse` 인스턴스는 서버의 HTTP 응답을 감쌉니다. 요청 헤더와 엔티티 바디에 대한 액세스를 "
"제공합니다. 응답은 이터러블 객체이며 with 문에서 사용할 수 있습니다."

#: ../../library/http.client.rst:487
msgid ""
"The :class:`io.BufferedIOBase` interface is now implemented and all of "
"its reader operations are supported."
msgstr ":class:`io.BufferedIOBase` 인터페이스가 이제 구현되었으며 이것의 모든 판독기(reader) 연산이 지원됩니다."

#: ../../library/http.client.rst:494
msgid "Reads and returns the response body, or up to the next *amt* bytes."
msgstr "응답 바디나 다음 최대 *amt* 바이트를 읽고 반환합니다."

#: ../../library/http.client.rst:498
msgid ""
"Reads up to the next len(b) bytes of the response body into the buffer "
"*b*. Returns the number of bytes read."
msgstr "응답 바디의 다음 최대 len(b) 바이트를 버퍼 *b*\\로 읽습니다. 읽은 바이트 수를 반환합니다."

#: ../../library/http.client.rst:505
#, fuzzy
msgid ""
"Return the value of the header *name*, or *default* if there is no header"
" matching *name*.  If there is more than one  header with the name "
"*name*, return all of the values joined by ', '.  If *default* is any "
"iterable other than a single string, its elements are similarly returned "
"joined by commas."
msgstr ""
"헤더 *name*\\의 값을 반환하거나, *name*\\과 일치하는 헤더가 없으면 *default*\\를 반환합니다. 이름이 "
"*name*\\인 헤더가 둘 이상 있으면, ','로 연결한 모든 값을 반환합니다. 'default'가 단일 문자열 이외의 "
"이터러블이면, 해당 요소들도 마찬가지로 쉼표로 연결되어 반환됩니다."

#: ../../library/http.client.rst:512
msgid "Return a list of (header, value) tuples."
msgstr "(헤더, 값) 튜플의 리스트를 반환합니다."

#: ../../library/http.client.rst:516
msgid "Return the ``fileno`` of the underlying socket."
msgstr "하부 소켓의 ``fileno``\\를 반환합니다."

#: ../../library/http.client.rst:520
msgid ""
"A :class:`http.client.HTTPMessage` instance containing the response "
"headers.  :class:`http.client.HTTPMessage` is a subclass of "
":class:`email.message.Message`."
msgstr ""
"응답 헤더를 포함하는 :class:`http.client.HTTPMessage` 인스턴스. "
":class:`http.client.HTTPMessage`\\는 :class:`email.message.Message`\\의 서브 "
"클래스입니다."

#: ../../library/http.client.rst:526
msgid "HTTP protocol version used by server.  10 for HTTP/1.0, 11 for HTTP/1.1."
msgstr "서버가 사용하는 HTTP 프로토콜 버전. HTTP/1.0의 경우 10, HTTP/1.1의 경우 11."

#: ../../library/http.client.rst:530
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect "
"was followed."
msgstr "가져온 자원의 URL, 일반적으로 리디렉션을 따라갔는지 판별하는 데 사용됩니다."

#: ../../library/http.client.rst:534
msgid ""
"Headers of the response in the form of an "
":class:`email.message.EmailMessage` instance."
msgstr ":class:`email.message.EmailMessage` 인스턴스 형식의 응답 헤더."

#: ../../library/http.client.rst:538
msgid "Status code returned by server."
msgstr "서버가 반환한 상태 코드."

#: ../../library/http.client.rst:542
msgid "Reason phrase returned by server."
msgstr "서버가 반환한 이유 문구."

#: ../../library/http.client.rst:546
msgid ""
"A debugging hook.  If :attr:`debuglevel` is greater than zero, messages "
"will be printed to stdout as the response is read and parsed."
msgstr "디버깅 훅. :attr:`debuglevel`\\이 0보다 크면, 응답을 읽고 구문 분석할 때 메시지가 표준 출력으로 인쇄됩니다."

#: ../../library/http.client.rst:551
msgid "Is ``True`` if the stream is closed."
msgstr "스트림이 닫혔으면 ``True``\\입니다."

#: ../../library/http.client.rst:555
msgid "Deprecated in favor of :attr:`~HTTPResponse.url`."
msgstr "폐지되었고 :attr:`~HTTPResponse.url`\\로 대체되었습니다."

#: ../../library/http.client.rst:560
msgid "Deprecated in favor of :attr:`~HTTPResponse.headers`."
msgstr "폐지되었고 :attr:`~HTTPResponse.headers`\\로 대체되었습니다."

#: ../../library/http.client.rst:565
msgid "Deprecated in favor of :attr:`~HTTPResponse.status`."
msgstr "폐지되었고 :attr:`~HTTPResponse.status`\\로 대체되었습니다."

#: ../../library/http.client.rst:569
msgid "Examples"
msgstr "예"

#: ../../library/http.client.rst:571
msgid "Here is an example session that uses the ``GET`` method::"
msgstr "``GET`` 메서드를 사용하는 예제 세션은 다음과 같습니다::"

#: ../../library/http.client.rst:573
msgid ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"www.python.org\")\n"
">>> conn.request(\"GET\", \"/\")\n"
">>> r1 = conn.getresponse()\n"
">>> print(r1.status, r1.reason)\n"
"200 OK\n"
">>> data1 = r1.read()  # This will return entire content.\n"
">>> # The following example demonstrates reading data in chunks.\n"
">>> conn.request(\"GET\", \"/\")\n"
">>> r1 = conn.getresponse()\n"
">>> while chunk := r1.read(200):\n"
"...     print(repr(chunk))\n"
"b'<!doctype html>\\n<!--[if\"...\n"
"...\n"
">>> # Example of an invalid request\n"
">>> conn = http.client.HTTPSConnection(\"docs.python.org\")\n"
">>> conn.request(\"GET\", \"/parrot.spam\")\n"
">>> r2 = conn.getresponse()\n"
">>> print(r2.status, r2.reason)\n"
"404 Not Found\n"
">>> data2 = r2.read()\n"
">>> conn.close()"
msgstr ""

#: ../../library/http.client.rst:596
msgid ""
"Here is an example session that uses the ``HEAD`` method.  Note that the "
"``HEAD`` method never returns any data. ::"
msgstr "다음은 ``HEAD`` 메서드를 사용하는 예제 세션입니다. ``HEAD`` 메서드는 어떤 데이터도 반환하지 않음에 유의하십시오. ::"

#: ../../library/http.client.rst:599
msgid ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"www.python.org\")\n"
">>> conn.request(\"HEAD\", \"/\")\n"
">>> res = conn.getresponse()\n"
">>> print(res.status, res.reason)\n"
"200 OK\n"
">>> data = res.read()\n"
">>> print(len(data))\n"
"0\n"
">>> data == b''\n"
"True"
msgstr ""

#: ../../library/http.client.rst:611
#, fuzzy
msgid "Here is an example session that uses the ``POST`` method::"
msgstr "``GET`` 메서드를 사용하는 예제 세션은 다음과 같습니다::"

#: ../../library/http.client.rst:613
#, python-brace-format
msgid ""
">>> import http.client, urllib.parse\n"
">>> params = urllib.parse.urlencode({'@number': 12524, '@type': 'issue', "
"'@action': 'show'})\n"
">>> headers = {\"Content-type\": \"application/x-www-form-urlencoded\",\n"
"...            \"Accept\": \"text/plain\"}\n"
">>> conn = http.client.HTTPConnection(\"bugs.python.org\")\n"
">>> conn.request(\"POST\", \"\", params, headers)\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"302 Found\n"
">>> data = response.read()\n"
">>> data\n"
"b'Redirecting to <a "
"href=\"https://bugs.python.org/issue12524\">https://bugs.python.org/issue12524</a>'"
"\n"
">>> conn.close()"
msgstr ""

#: ../../library/http.client.rst:627
#, fuzzy
msgid ""
"Client side HTTP ``PUT`` requests are very similar to ``POST`` requests. "
"The difference lies only on the server side where HTTP servers will allow"
" resources to be created via ``PUT`` requests. It should be noted that "
"custom HTTP methods are also handled in :class:`urllib.request.Request` "
"by setting the appropriate method attribute. Here is an example session "
"that uses the ``PUT`` method::"
msgstr ""
"클라이언트 측 ``HTTP PUT`` 요청은 ``POST`` 요청과 매우 유사합니다. 차이점은 HTTP 서버가 ``PUT`` 요청을"
" 통해 리소스를 만들도록 허락하는 서버 측에만 있습니다. 사용자 정의 HTTP 메서드는 적절한 method 어트리뷰트를 설정함으로써"
" :class:`urllib.request.Request`\\에서도 처리된다는 점에 주목해야 합니다. 다음은 http.client를"
" 사용하여 ``PUT`` 요청을 보내는 방법을 보여주는 예제 세션입니다::"

#: ../../library/http.client.rst:633
msgid ""
">>> # This creates an HTTP request\n"
">>> # with the content of BODY as the enclosed representation\n"
">>> # for the resource http://localhost:8080/file\n"
"...\n"
">>> import http.client\n"
">>> BODY = \"***filecontents***\"\n"
">>> conn = http.client.HTTPConnection(\"localhost\", 8080)\n"
">>> conn.request(\"PUT\", \"/file\", BODY)\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"200, OK"
msgstr ""

#: ../../library/http.client.rst:648
msgid "HTTPMessage Objects"
msgstr "HTTPMessage 객체"

#: ../../library/http.client.rst:652
msgid ""
"An :class:`http.client.HTTPMessage` instance holds the headers from an "
"HTTP response.  It is implemented using the "
":class:`email.message.Message` class."
msgstr ""
":class:`http.client.HTTPMessage` 인스턴스는 HTTP 응답의 헤더를 보유합니다. "
":class:`email.message.Message` 클래스를 사용하여 구현됩니다."

#: ../../library/http.client.rst:9
msgid "HTTP"
msgstr ""

#: ../../library/http.client.rst:9
msgid "protocol"
msgstr ""

#: ../../library/http.client.rst:9
msgid "http.client (standard module)"
msgstr ""

#: ../../library/http.client.rst:13
msgid "module"
msgstr ""

#: ../../library/http.client.rst:13
msgid "urllib.request"
msgstr ""

#~ msgid ""
#~ "*key_file* and *cert_file* are deprecated "
#~ "in favor of *context*. Please use "
#~ ":meth:`ssl.SSLContext.load_cert_chain` instead, or "
#~ "let :func:`ssl.create_default_context` select the"
#~ " system's trusted CA certificates for "
#~ "you."
#~ msgstr ""
#~ "*key_file*\\과 *cert_file*\\은 폐지되어 *context*\\로 "
#~ "대체되었습니다. 대신 :meth:`ssl.SSLContext.load_cert_chain`\\을 "
#~ "사용하거나, :func:`ssl.create_default_context`\\가 시스템의 "
#~ "신뢰할 수 있는 CA 인증서를 선택하도록 하십시오."

#~ msgid ""
#~ "The *check_hostname* parameter is also "
#~ "deprecated; the :attr:`ssl.SSLContext.check_hostname` "
#~ "attribute of *context* should be used"
#~ " instead."
#~ msgstr ""
#~ "*check_hostname* 매개 변수도 폐지되었습니다; 대신 "
#~ "*context*\\의 :attr:`ssl.SSLContext.check_hostname` 어트리뷰트를"
#~ " 사용해야 합니다."

#~ msgid ""
#~ "This will send a request to the"
#~ " server using the HTTP request method"
#~ " *method* and the selector *url*."
#~ msgstr "HTTP 요청 메서드 *method*\\와 선택기(selector) *url*\\을 사용하여 서버로 요청을 보냅니다."

#~ msgid ""
#~ "The *headers* argument should be a "
#~ "mapping of extra HTTP headers to "
#~ "send with the request."
#~ msgstr "*headers* 인자는 요청과 함께 보낼 추가 HTTP 헤더의 매핑이어야 합니다."

#~ msgid "Here is an example session that shows how to ``POST`` requests::"
#~ msgstr "다음은 요청을 ``POST`` 하는 방법을 보여주는 예제 세션입니다::"

