# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- :keyword:`!import`\\의 구현"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "소개"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr ""

#: ../../library/importlib.rst:22
#, fuzzy
msgid ""
"One is to provide the implementation of the :keyword:`import` statement "
"(and thus, by extension, the :func:`__import__` function) in Python "
"source code. This provides an implementation of :keyword:`!import` which "
"is portable to any Python interpreter. This also provides an "
"implementation which is easier to comprehend than one implemented in a "
"programming language other than Python."
msgstr ""
":mod:`importlib` 패키지의 목적은 두 가지입니다. 하나는 파이썬 소스 코드에서 :keyword:`import` "
"문(그리고, 확장하면 :func:`__import__` 함수)의 구현을 제공하는 것입니다. 이것은 모든 파이썬 인터프리터에 이식할 "
"수 있는 :keyword:`!import`\\의 구현을 제공합니다. 또한 파이썬 이외의 프로그래밍 언어로 구현된 것보다 이해하기 "
"쉬운 구현을 제공합니다."

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"둘째, :keyword:`import`\\를 구현하는 구성 요소가 이 패키지에서 노출되어, 사용자가 임포트 프로세스에 참여하기 위해"
" 자신의 사용자 지정 객체(일반적으로 :term:`임포터 <importer>`\\라고 합니다)를 쉽게 만들 수 있도록 합니다."

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for"
" managing aspects of Python packages:"
msgstr ""

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""

#: ../../library/importlib.rst:43
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` 문의 언어 레퍼런스."

#: ../../library/importlib.rst:46
msgid "`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`패키지 명세 <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the"
" writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"패키지의 원래 명세. 이 문서를 작성한 이후로 일부 의미가 변경되었습니다 (예를 들어 :data:`sys.modules`\\의 "
"``None``\\을 기반으로 하는 리디렉션)."

#: ../../library/importlib.rst:51
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` 함수"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` 문은 이 함수의 편의 문법입니다."

#: ../../library/importlib.rst:54
msgid ":ref:`sys-path-init`"
msgstr ""

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr ""

#: ../../library/importlib.rst:57
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "대소 문자를 구분하지 않는 플랫폼에서의 임포트"

#: ../../library/importlib.rst:60
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "파이썬 소스 코드 인코딩 정의"

#: ../../library/importlib.rst:63
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "새로운 임포트 훅"

#: ../../library/importlib.rst:66
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "임포트: 다중 줄과 절대/상대"

#: ../../library/importlib.rst:69
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "메인 모듈 명시적 상대 임포트"

#: ../../library/importlib.rst:72
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "묵시적 이름 공간 패키지"

#: ../../library/importlib.rst:75
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "임포트 시스템을 위한 ModuleSpec 형"

#: ../../library/importlib.rst:78
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "PYO 파일 제거"

#: ../../library/importlib.rst:81
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "다단계 확장 모듈 초기화"

#: ../../library/importlib.rst:84
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "결정론적 pyc"

#: ../../library/importlib.rst:87
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "UTF-8을 기본 소스 인코딩으로 사용하기"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "PYC 저장소 디렉터리"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "함수"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "내장 :func:`__import__` 함수의 구현."

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` "
"instead of this function."
msgstr "프로그래밍 방식으로 모듈을 임포트 하려면 이 함수 대신 :func:`import_module`\\을 사용해야 합니다."

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the"
" name is specified in relative terms, then the *package* argument must be"
" set to the name of the package which is to act as the anchor for "
"resolving the package name (e.g. ``import_module('..mod', 'pkg.subpkg')``"
" will import ``pkg.mod``)."
msgstr ""
"모듈을 임포트 합니다. *name* 인자는 절대나 상대적인 항으로 임포트 할 모듈을 지정합니다 (예를 들어 "
"``pkg.mod``\\나 ``..mod``). 이름이 상대적인 항으로 지정되면, *package* 인자는 패키지 이름을 결정하기 "
"위한 앵커 역할을 하는 패키지 이름으로 설정해야 합니다 (예를 들어 ``import_module('..mod', "
"'pkg.subpkg')``\\는 ``pkg.mod``\\를 임포트 합니다)."

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function "
"are derived from :func:`importlib.__import__`. The most important "
"difference between these two functions is that :func:`import_module` "
"returns the specified package or module (e.g. ``pkg.mod``), while "
":func:`__import__` returns the top-level package or module (e.g. "
"``pkg``)."
msgstr ""
":func:`import_module` 함수는 :func:`importlib.__import__` 주위를 감싸는 단순화 래퍼 역할을"
" 합니다. 이는 함수의 모든 의미가 :func:`importlib.__import__`\\에서 파생됨을 뜻합니다. 이 두 함수의 "
"가장 중요한 차이점은 :func:`import_module`\\이 지정된 패키지나 모듈(예를 들어 ``pkg.mod``)을 반환하는"
" 반면, :func:`__import__`\\는 최상위 패키지나 모듈(예를 들어 ``pkg``)을 반환한다는 것입니다."

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may"
" need to call :func:`invalidate_caches` in order for the new module to be"
" noticed by the import system."
msgstr ""
"인터프리터가 실행을 시작한 이후 만들어진 모듈(예를 들어, 파이썬 소스 파일을 만들면)을 동적으로 임포트 하는 경우, 임포트 "
"시스템에서 새 모듈을 알 수 있도록 :func:`invalidate_caches`\\를 호출해야 할 수 있습니다."

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "부모 패키지는 자동으로 임포트 됩니다."

#: ../../library/importlib.rst:132
msgid ""
"Invalidate the internal caches of finders stored at "
":data:`sys.meta_path`. If a finder implements ``invalidate_caches()`` "
"then it will be called to perform the invalidation.  This function should"
" be called if any modules are created/installed while your program is "
"running to guarantee all finders will notice the new module's existence."
msgstr ""
":data:`sys.meta_path`\\에 저장된 파인더의 내부 캐시를 무효로 합니다. 파인더가 "
"``invalidate_caches()``\\를 구현하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알"
" 수 있도록 프로그램이 실행되는 동안 모듈이 만들어진/설치된 경우 이 함수를 호출해야 합니다."

#: ../../library/importlib.rst:140
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""

#: ../../library/importlib.rst:146
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is "
"useful if you have edited the module source file using an external editor"
" and want to try out the new version without leaving the Python "
"interpreter.  The return value is the module object (which can be "
"different if re-importing causes a different object to be placed in "
":data:`sys.modules`)."
msgstr ""
"이전에 임포트 한 *module*\\을 다시 로드합니다. 인자는 모듈 객체여야 해서, 이전에 성공적으로 임포트 됐어야 합니다. 외부"
" 편집기를 사용하여 모듈 소스 파일을 편집했고 파이썬 인터프리터를 떠나지 않고 새 버전을 시험해보고 싶을 때 유용합니다. 반환 값은"
" 모듈 객체입니다 (재 임포트로 인해 다른 객체가 :data:`sys.modules`\\에 배치되면 다를 수 있습니다)."

#: ../../library/importlib.rst:153
msgid "When :func:`reload` is executed:"
msgstr ":func:`reload`\\가 실행될 때:"

#: ../../library/importlib.rst:155
msgid ""
"Python module's code is recompiled and the module-level code re-executed,"
" defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"파이썬 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행되어, 원래 모듈을 로드한 :term:`로더 <loader>`\\를"
" 재사용하여 모듈 딕셔너리에 있는 이름에 연결되는 새로운 객체 집합을 정의합니다. 확장 모듈의 ``init`` 함수는 두 번째에는 "
"호출되지 않습니다."

#: ../../library/importlib.rst:161
msgid ""
"As with all other objects in Python the old objects are only reclaimed "
"after their reference counts drop to zero."
msgstr "파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에만 자원이 회수됩니다."

#: ../../library/importlib.rst:164
msgid ""
"The names in the module namespace are updated to point to any new or "
"changed objects."
msgstr "모듈 이름 공간의 이름은 새로운 객체나 변경된 객체를 가리키도록 갱신됩니다."

#: ../../library/importlib.rst:167
msgid ""
"Other references to the old objects (such as names external to the "
"module) are not rebound to refer to the new objects and must be updated "
"in each namespace where they occur if that is desired."
msgstr ""
"이전 객체에 대한 다른 참조(가령 모듈 외부의 이름)는 새 객체를 참조하기 위해 다시 연결되지 않으며 필요하다면 그들이 등장하는 각"
" 이름 공간에서 갱신되어야 합니다."

#: ../../library/importlib.rst:171
msgid "There are a number of other caveats:"
msgstr "다른 여러 가지 경고가 있습니다:"

#: ../../library/importlib.rst:173
msgid ""
"When a module is reloaded, its dictionary (containing the module's global"
" variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a"
" module does not define a name that was defined by the old version, the "
"old definition remains.  This feature can be used to the module's "
"advantage if it maintains a global table or cache of objects --- with a "
":keyword:`try` statement it can test for the table's presence and skip "
"its initialization if desired::"
msgstr ""
"모듈을 다시 로드할 때, 그것의 (모듈의 전역 변수를 포함하는) 딕셔너리가 유지됩니다. 이름을 재정의하면 이전 정의를 대체해서, "
"일반적으로 문제가 되지 않습니다. 새 버전의 모듈이 이전 버전이 정의한 이름을 정의하지 않으면, 이전 정의가 그대로 남습니다. 이 "
"기능은 객체의 전역 테이블이나 캐시를 유지한다면 모듈의 이점으로 사용될 수 있습니다 --- :keyword:`try` 문으로 "
"테이블의 존재를 검사하고 필요하다면 초기화를 건너뛸 수 있습니다::"

#: ../../library/importlib.rst:182
#, python-brace-format
msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""

#: ../../library/importlib.rst:187
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and "
"other key modules is not recommended.  In many cases extension modules "
"are not designed to be initialized more than once, and may fail in "
"arbitrary ways when reloaded."
msgstr ""
"일반적으로 내장이나 동적으로 로드된 모듈을 다시 로드하는 것은 그리 유용하지 않습니다. :mod:`sys`, "
":mod:`__main__`, :mod:`builtins` 및 기타 주요 모듈을 다시 로드하지 않는 것이 좋습니다. 많은 경우 확장"
" 모듈은 두 번 이상 초기화되도록 설계되지 않았으며, 다시 로드할 때 임의의 방식으로 실패할 수 있습니다."

#: ../../library/importlib.rst:193
msgid ""
"If a module imports objects from another module using :keyword:`from` ..."
" :keyword:`import` ..., calling :func:`reload` for the other module does "
"not redefine the objects imported from it --- one way around this is to "
"re-execute the :keyword:`!from` statement, another is to use "
":keyword:`!import` and qualified names (*module.name*) instead."
msgstr ""
"모듈이 :keyword:`from` ... :keyword:`import` ...를 사용하여 다른 모듈에서 객체를 임포트 하면, "
"다른 모듈에 대해 :func:`reload`\\를 호출해도 그것에서 임포트 한 객체를 재정의하지 않습니다 --- 이것을 피하는 한 "
"가지 방법은 :keyword:`!from` 문을 다시 실행하는 것입니다, 다른 방법은 대신 :keyword:`!import`\\와 "
"정규화된 이름(*module.name*)을 사용하는 것입니다."

#: ../../library/importlib.rst:199
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances"
" --- they continue to use the old class definition.  The same is true for"
" derived classes."
msgstr ""
"모듈이 클래스의 인스턴스를 인스턴스 화하면, 클래스를 정의하는 모듈을 다시 로드해도 인스턴스의 메서드 정의에는 영향을 미치지 "
"않습니다 --- 이전 클래스 정의를 계속 사용합니다. 파생 클래스의 경우도 마찬가지입니다."

#: ../../library/importlib.rst:205
#, fuzzy
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks"
" a :class:`~importlib.machinery.ModuleSpec`."
msgstr "다시 로드되는 모듈에 :class:`ModuleSpec`\\이 없으면 :exc:`ModuleNotFoundError` 가 발생합니다."

#: ../../library/importlib.rst:211
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- import와 관련된 추상 베이스 클래스"

#: ../../library/importlib.rst:216
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:221
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract "
"base classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` 모듈에는 :keyword:`import`\\에서 사용하는 모든 핵심 추상 베이스 클래스가 "
"포함되어 있습니다. 핵심 ABC 구현에 도움이 되도록 핵심 추상 베이스 클래스의 일부 서브 클래스도 제공됩니다."

#: ../../library/importlib.rst:225
msgid "ABC hierarchy::"
msgstr "ABC 계층::"

#: ../../library/importlib.rst:227
msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""

#: ../../library/importlib.rst:240
#, fuzzy
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr ":term:`파인더 <finder>`\\를 나타내는 추상 베이스 클래스."

#: ../../library/importlib.rst:244 ../../library/importlib.rst:280
msgid "No longer a subclass of :class:`!Finder`."
msgstr ""

#: ../../library/importlib.rst:249
#, fuzzy
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be "
"``None``.  Otherwise, this is a search for a subpackage or module and "
"*path* will be the value of :attr:`~module.__path__` from the parent "
"package. If a spec cannot be found, ``None`` is returned. When passed in,"
" ``target`` is a module object that the finder may use to make a more "
"educated guess about what spec to return. "
":func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``MetaPathFinders``."
msgstr ""
"지정된 모듈의 :term:`스펙 <module spec>`\\을 찾는 추상 메서드. 최상위 임포트 인 경우, *path*\\는 "
"``None``\\입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, *path*\\는 부모 패키지의 "
":attr:`__path__` 값입니다. 스펙을 찾을 수 없으면, ``None``\\이 반환됩니다. 전달될 때, "
"``target``\\은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. "
":func:`importlib.util.spec_from_loader`\\는 구상 ``MetaPathFinders``\\를 구현하는"
" 데 유용할 수 있습니다."

#: ../../library/importlib.rst:263
msgid ""
"An optional method which, when called, should invalidate any internal "
"cache used by the finder. Used by :func:`importlib.invalidate_caches` "
"when invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. :data:`sys.meta_path`\\에서 모든 "
"파인더의 캐시를 무효로 할 때 :func:`importlib.invalidate_caches`\\에서 사용합니다."

#: ../../library/importlib.rst:267
#, fuzzy
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr "호출될 때 ``NotImplemented`` 대신 ``None``\\을 반환합니다."

#: ../../library/importlib.rst:273
#, fuzzy
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though "
"it bears some similarities to :class:`MetaPathFinder`, "
"``PathEntryFinder`` is meant for use only within the path-based import "
"subsystem provided by :class:`importlib.machinery.PathFinder`."
msgstr ""
":term:`경로 엔트리 파인더 <path entry finder>`\\를 나타내는 추상 베이스 클래스. "
":class:`MetaPathFinder`\\와 일부 유사하지만, ``PathEntryFinder``\\는 "
":class:`PathFinder`\\가 제공하는 경로 기반 임포트 서브 시스템 내에서만 사용하려는 것입니다. 이 ABC는 호환성을"
" 위해서만 :class:`Finder`\\의 서브 클래스입니다."

#: ../../library/importlib.rst:285
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that"
" the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``PathEntryFinders``."
msgstr ""
"지정된 모듈의 :term:`스펙 <module spec>`\\을 찾는 추상 메서드. 파인더는 할당된 :term:`경로 엔트리 "
"<path entry>` 내에서만 모듈을 검색합니다. 스펙을 찾을 수 없으면, ``None``\\이 반환됩니다. 전달될 때, "
"``target``\\은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. "
":func:`importlib.util.spec_from_loader`\\는 구상 ``PathEntryFinders``\\를 "
"구현하는 데 유용할 수 있습니다."

#: ../../library/importlib.rst:297
#, fuzzy
msgid ""
"An optional method which, when called, should invalidate any internal "
"cache used by the finder. Used by "
":meth:`importlib.machinery.PathFinder.invalidate_caches` when "
"invalidating the caches of all cached finders."
msgstr ""
"호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. 모든 캐시 된 파인더의 캐시를 무효화 할 때 "
":meth:`PathFinder.invalidate_caches`\\에서 사용합니다."

#: ../../library/importlib.rst:305
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact"
" definition for a loader."
msgstr ":term:`로더 <loader>`\\의 추상 베이스 클래스. 로더에 대한 정확한 정의는 :pep:`302`\\를 참조하십시오."

#: ../../library/importlib.rst:308
#, fuzzy
msgid ""
"Loaders that wish to support resource reading should implement a "
":meth:`get_resource_reader` method as specified by "
":class:`importlib.resources.abc.ResourceReader`."
msgstr ""
"리소스 읽기를 지원하려는 로더는 :class:`importlib.abc.ResourceReader`\\에 지정된 대로 "
"``get_resource_reader(fullname)`` 메서드를 구현해야 합니다."

#: ../../library/importlib.rst:312
#, fuzzy
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "선택적 ``get_resource_reader()`` 메서드를 도입했습니다."

#: ../../library/importlib.rst:317
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"모듈을 임포트 할 때 사용할 모듈 객체를 반환하는 메서드. 이 메서드는 ``None``\\을 반환해서 기본 모듈 생성 시맨틱이 "
"적용되어야 함을 나타낼 수 있습니다."

#: ../../library/importlib.rst:323
#, fuzzy
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr "파이썬 3.6부터는, :meth:`exec_module`\\이 정의될 때 이 메서드는 선택 사항이 아닙니다."

#: ../../library/importlib.rst:329
#, fuzzy
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized"
" when :meth:`exec_module` is called.  When this method exists, "
":meth:`create_module` must be defined."
msgstr ""
"모듈을 임포트 하거나 다시 로드할 때 자체 이름 공간에서 모듈을 실행하는 추상 메서드. ``exec_module()``\\이 호출될"
" 때 모듈이 이미 초기화되어 있어야 합니다. 이 메서드가 존재하면, "
":meth:`~importlib.abc.Loader.create_module`\\을 정의해야 합니다."

#: ../../library/importlib.rst:336
#, fuzzy
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`~importlib.abc.Loader.create_module`\\도 정의해야 합니다."

#: ../../library/importlib.rst:341
#, fuzzy
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"모듈을 로드하는 레거시 메서드. 모듈을 로드할 수 없으면, :exc:`ImportError`\\가 발생하고, 그렇지 않으면 로드된 "
"모듈이 반환됩니다."

#: ../../library/importlib.rst:345
#, fuzzy
msgid ""
"If the requested module already exists in :data:`sys.modules`, that "
"module should be used and reloaded. Otherwise the loader should create a "
"new module and insert it into :data:`sys.modules` before any loading "
"begins, to prevent recursion from the import.  If the loader inserted a "
"module and the load fails, it must be removed by the loader from "
":data:`sys.modules`; modules already in :data:`sys.modules` before the "
"loader began execution should be left alone."
msgstr ""
"요청된 모듈이 :data:`sys.modules`\\에 이미 존재하면, 해당 모듈이 사용되고 다시 로드되어야 합니다. 그렇지 않으면"
" 로더는 임포트에서 재귀를 방지하기 위해 로드를 시작하기 전에 새 모듈을 만들어 :data:`sys.modules`\\에 삽입해야 "
"합니다. 로더가 모듈을 삽입했는데 로드에 실패하면, 로더가 :data:`sys.modules`\\에서 모듈을 제거해야 합니다; "
"로더가 실행을 시작하기 전에 이미 :data:`sys.modules`\\에 있었던 모듈은 그대로 두어야 합니다 "
"(:func:`importlib.util.module_for_loader`\\를 참조하십시오)."

#: ../../library/importlib.rst:354
#, fuzzy
msgid ""
"The loader should set several attributes on the module (note that some of"
" these attributes can change when a module is reloaded):"
msgstr "로더는 모듈에서 여러 어트리뷰트를 설정해야 합니다. (이러한 어트리뷰트 중 일부는 모듈을 다시 로드할 때 변경될 수 있습니다):"

#: ../../library/importlib.rst:358
#, fuzzy
msgid ":attr:`module.__name__`"
msgstr ":attr:`__name__`"

#: ../../library/importlib.rst:359
#, fuzzy
msgid ":attr:`module.__file__`"
msgstr ":attr:`__file__`"

#: ../../library/importlib.rst:360
#, fuzzy
msgid ":attr:`module.__cached__` *(deprecated)*"
msgstr ":attr:`__cached__`"

#: ../../library/importlib.rst:361
#, fuzzy
msgid ":attr:`module.__path__`"
msgstr ":attr:`__path__`"

#: ../../library/importlib.rst:362
#, fuzzy
msgid ":attr:`module.__package__` *(deprecated)*"
msgstr ":attr:`__package__`"

#: ../../library/importlib.rst:363
#, fuzzy
msgid ":attr:`module.__loader__` *(deprecated)*"
msgstr ":attr:`__loader__`"

#: ../../library/importlib.rst:365
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ":meth:`exec_module`\\을 사용할 수 있으면 이전 버전과 호환되는 기능이 제공됩니다."

#: ../../library/importlib.rst:368
#, fuzzy
msgid ""
"Raise :exc:`ImportError` when called instead of "
":exc:`NotImplementedError`.  Functionality provided when "
":meth:`exec_module` is available."
msgstr ""
"호출될 때 :exc:`NotImplementedError` 대신 :exc:`ImportError`\\를 발생시킵니다. "
":meth:`exec_module`\\을 사용할 수 있을 때 제공되는 기능."

#: ../../library/importlib.rst:373
#, fuzzy
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
":meth:`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"모듈 로드에 권장되는 API는 :meth:`exec_module`\\(및 :meth:`create_module`)입니다. 로더는 "
"load_module() 대신 이것을 구현해야 합니다. 임포트 절차는 exec_module()이 구현될 때 "
"load_module()의 다른 모든 책임을 처리합니다."

#: ../../library/importlib.rst:383 ../../library/importlib.rst:636
#, fuzzy
msgid "*Superseded by TraversableResources*"
msgstr "*TraversableReader로 대체되었습니다*"

#: ../../library/importlib.rst:385
msgid ""
"An abstract base class for a :term:`loader` which implements the optional"
" :pep:`302` protocol for loading arbitrary resources from the storage "
"back-end."
msgstr ""
"스토리지 백 엔드에서 임의의 리소스를 로드하기 위한 선택적 :pep:`302` 프로토콜을 구현하는 :term:`로더 "
"<loader>`\\의 추상 베이스 클래스."

#: ../../library/importlib.rst:389
#, fuzzy
msgid ""
"This ABC is deprecated in favour of supporting resource loading through "
":class:`importlib.resources.abc.TraversableResources`."
msgstr ""
"이 ABC는 폐지되었고 :class:`importlib.abc.ResourceReader`\\를 통한 리소스 로드 지원으로 "
"대체되었습니다."

#: ../../library/importlib.rst:396
#, fuzzy
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing "
"arbitrary data can implement this abstract method to give direct access "
"to the data stored. :exc:`OSError` is to be raised if the *path* cannot "
"be found. The *path* is expected to be constructed using a module's "
":attr:`~module.__file__` attribute or an item from a package's "
":attr:`~module.__path__`."
msgstr ""
"*path*\\에 있는 데이터를 바이트열로 반환하는 추상 메서드. 임의의 데이터를 저장할 수 있는 파일류 스토리지 백 엔드가 있는 "
"로더는 이 추상 메서드를 구현하여 저장된 데이터에 직접 액세스하도록 할 수 있습니다. *path*\\를 찾을 수 없으면 "
":exc:`OSError`\\가 발생합니다. *path*\\는 모듈의 :attr:`__file__` 어트리뷰트나 패키지의 "
":attr:`__path__`\\에서 온 항목을 사용하여 구성될 것으로 기대됩니다."

#: ../../library/importlib.rst:405
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/importlib.rst:411
msgid ""
"An abstract base class for a :term:`loader` which implements the optional"
" :pep:`302` protocol for loaders that inspect modules."
msgstr ""
"모듈을 검사(inspect)하는 로더를 위한 선택적 :pep:`302` 프로토콜을 구현하는 :term:`로더 <loader>`\\의"
" 추상 베이스 클래스."

#: ../../library/importlib.rst:416
msgid ""
"Return the code object for a module, or ``None`` if the module does not "
"have a code object (as would be the case, for example, for a built-in "
"module).  Raise an :exc:`ImportError` if loader cannot find the requested"
" module."
msgstr ""
"모듈에 대한 코드 객체나, 모듈에 코드 객체가 없으면 (예를 들어, 내장 모듈이 이런 경우입니다) ``None``\\을 반환합니다."
" 로더가 요청한 모듈을 찾을 수 없으면 :exc:`ImportError`\\가 발생합니다."

#: ../../library/importlib.rst:422
msgid ""
"While the method has a default implementation, it is suggested that it be"
" overridden if possible for performance."
msgstr "이 메서드에는 기본 구현이 있지만, 가능하다면 성능을 위해 재정의하는 것이 좋습니다."

#: ../../library/importlib.rst:428
msgid "No longer abstract and a concrete implementation is provided."
msgstr "더는 추상적이지 않고 구상 구현이 제공됩니다."

#: ../../library/importlib.rst:434
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source"
" is available (e.g. a built-in module). Raises :exc:`ImportError` if the "
"loader cannot find the module specified."
msgstr ""
"모듈의 소스를 반환하는 추상 메서드. 인식된 모든 줄 구분자를 ``'\\n'`` 문자로 변환하는 :term:`유니버설 줄 넘김 "
"<universal newlines>`\\을 사용하여 텍스트 문자열로 반환됩니다. 사용 가능한 소스가 없으면 (예를 들어, 내장 "
"모듈) ``None``\\을 반환합니다. 로더가 지정된 모듈을 찾을 수 없으면 :exc:`ImportError`\\를 발생시킵니다."

#: ../../library/importlib.rst:440 ../../library/importlib.rst:449
#: ../../library/importlib.rst:500
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` 대신 :exc:`ImportError`\\를 발생시킵니다."

#: ../../library/importlib.rst:445
#, fuzzy
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader`"
" cannot find the module."
msgstr ""
"모듈이 패키지이면 참값을 반환하고, 그렇지 않으면 거짓 값을 반환하는 추상 메서드. :term:`로더 <loader>`\\가 모듈을"
" 찾을 수 없으면 :exc:`ImportError`\\가 발생합니다."

#: ../../library/importlib.rst:454
msgid "Create a code object from Python source."
msgstr "파이썬 소스에서 코드 객체를 만듭니다."

#: ../../library/importlib.rst:456
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports"
" (i.e. string or bytes). The *path* argument should be the \"path\" to "
"where the source code originated from, which can be an abstract concept "
"(e.g. location in a zip file)."
msgstr ""
"*data* 인자는 :func:`compile` 함수가 지원하는 것은 무엇이든 될 수 있습니다 (즉 문자열이나 바이트열). "
"*path* 인자는 소스 코드가 온 곳의 \"경로\"여야 하며, 추상 개념(예를 들어 zip 파일에서의 위치)일 수 있습니다."

#: ../../library/importlib.rst:461
msgid ""
"With the subsequent code object one can execute it in a module by running"
" ``exec(code, module.__dict__)``."
msgstr ""
"후속 코드 객체를 사용하면 ``exec(code, module.__dict__)``\\를 실행하여 그 코드를 모듈에서 실행할 수 "
"있습니다."

#: ../../library/importlib.rst:466
msgid "Made the method static."
msgstr "메서드를 정적(static)으로 만들었습니다."

#: ../../library/importlib.rst:471
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module`\\의 구현."

#: ../../library/importlib.rst:477
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module`\\의 구현."

#: ../../library/importlib.rst:479
msgid "use :meth:`exec_module` instead."
msgstr "대신 :meth:`exec_module`\\을 사용하십시오."

#: ../../library/importlib.rst:485
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, "
"when implemented, helps a module to be executed as a script. The ABC "
"represents an optional :pep:`302` protocol."
msgstr ""
"구현될 때, 모듈이 스크립트로 실행되도록 돕는 :class:`InspectLoader`\\에서 상속되는 추상 베이스 클래스. "
"ABC는 선택적 :pep:`302` 프로토콜을 표현합니다."

#: ../../library/importlib.rst:492
#, fuzzy
msgid ""
"An abstract method that is to return the value of "
":attr:`~module.__file__` for the specified module. If no path is "
"available, :exc:`ImportError` is raised."
msgstr ""
"지정된 모듈의 :attr:`__file__` 값을 반환하는 추상 메서드. 사용 가능한 경로가 없으면 "
":exc:`ImportError`\\가 발생합니다."

#: ../../library/importlib.rst:496
msgid ""
"If source code is available, then the method should return the path to "
"the source file, regardless of whether a bytecode was used to load the "
"module."
msgstr "소스 코드를 사용할 수 있으면, 메서드는 모듈을 로드하는 데 바이트 코드를 사용했는지와 관계없이 소스 파일의 경로를 반환해야 합니다."

#: ../../library/importlib.rst:506
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
":class:`ResourceLoader`\\와 :class:`ExecutionLoader`\\를 상속하고 "
":meth:`ResourceLoader.get_data`\\와 "
":meth:`ExecutionLoader.get_filename`\\의 구상 구현을 제공하는 추상 베이스 클래스."

#: ../../library/importlib.rst:510
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader"
" is to handle. The *path* argument is the path to the file for the "
"module."
msgstr ""
"*fullname* 인자는 로더가 처리해야 하는 모듈의 완전히 결정된(resolved) 이름입니다. *path* 인자는 모듈의 파일"
" 경로입니다."

#: ../../library/importlib.rst:517
msgid "The name of the module the loader can handle."
msgstr "로더가 처리할 수 있는 모듈의 이름."

#: ../../library/importlib.rst:521
msgid "Path to the file of the module."
msgstr "모듈 파일의 경로."

#: ../../library/importlib.rst:525
msgid "Calls super's ``load_module()``."
msgstr "super의 ``load_module()``\\을 호출합니다."

#: ../../library/importlib.rst:527
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "대신 :meth:`Loader.exec_module`\\을 사용하십시오."

#: ../../library/importlib.rst:533 ../../library/importlib.rst:1140
msgid "Returns :attr:`path`."
msgstr ":attr:`path`\\를 반환합니다."

#: ../../library/importlib.rst:538
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "*path*\\를 바이너리 파일로 읽고 그것의 바이트열을 반환합니다."

#: ../../library/importlib.rst:543
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"소스 (및 선택적으로 바이트 코드) 파일 로드를 구현하기 위한 추상 베이스 클래스. 이 클래스는 "
":class:`ResourceLoader`\\와 :class:`ExecutionLoader`\\를 모두 상속하며, 다음을 구현해야 "
"합니다:"

#: ../../library/importlib.rst:547
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:548
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:549
msgid ""
"Should only return the path to the source file; sourceless loading is not"
" supported."
msgstr "소스 파일의 경로만 반환해야 합니다; 소스 없는 로딩은 지원되지 않습니다."

#: ../../library/importlib.rst:552
msgid ""
"The abstract methods defined by this class are to add optional bytecode "
"file support. Not implementing these optional methods (or causing them to"
" raise :exc:`NotImplementedError`) causes the loader to only work with "
"source code. Implementing the methods allows the loader to work with "
"source *and* bytecode files; it does not allow for *sourceless* loading "
"where only bytecode is provided.  Bytecode files are an optimization to "
"speed up loading by removing the parsing step of Python's compiler, and "
"so no bytecode-specific API is exposed."
msgstr ""
"이 클래스에 의해 정의된 추상 메서드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이러한 선택적 메서드를 구현하지 않으면 "
"(또는 그들이 :exc:`NotImplementedError`\\를 발생시키도록 하면) 로더가 소스 코드에 대해서만 작동하도록 "
"만듭니다. 메서드를 구현하면 로더가 소스\\*와* 바이트 코드 파일 모두에 대해 작동하게 할 수 있습니다; 바이트 코드만 제공되는 "
"*소스 없는* 로드는 허용하지 않습니다. 바이트 코드 파일은 파이썬 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기 위한 "
"최적화라서, 바이트 코드 전용 API는 노출되지 않습니다."

#: ../../library/importlib.rst:563
msgid ""
"Optional abstract method which returns a :class:`dict` containing "
"metadata about the specified path.  Supported dictionary keys are:"
msgstr ""
"지정된 경로에 대한 메타 데이터를 포함하는 :class:`dict`\\를 반환하는 선택적 추상 메서드. 지원되는 딕셔너리 키는 "
"다음과 같습니다:"

#: ../../library/importlib.rst:566
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing"
" the modification time of the source code;"
msgstr "``'mtime'`` (필수): 소스 코드의 수정 시간을 나타내는 정수나 부동 소수점 숫자;"

#: ../../library/importlib.rst:568
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (선택): 바이트 단위의 소스 코드의 크기."

#: ../../library/importlib.rst:570
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr "향후 확장을 위해, 딕셔너리의 다른 키는 무시됩니다. 경로를 처리할 수 없으면, :exc:`OSError`\\가 발생합니다."

#: ../../library/importlib.rst:575 ../../library/importlib.rst:588
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/importlib.rst:580
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드."

#: ../../library/importlib.rst:583
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't "
"have to implement it, but it is still available for compatibility "
"purposes. Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"이 메서드는 폐지되었고 :meth:`path_stats`\\로 대체되었습니다. 구현할 필요는 없지만, 호환성을 위해 여전히 "
"제공됩니다. 경로를 처리할 수 없으면 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/importlib.rst:593
msgid ""
"Optional abstract method which writes the specified bytes to a file path."
" Any intermediate directories which do not exist are to be created "
"automatically."
msgstr "지정된 바이트열을 파일 경로에 쓰는 선택적 추상 메서드. 존재하지 않는 중간 디렉터리는 자동으로 만들어집니다."

#: ../../library/importlib.rst:597
#, fuzzy
msgid ""
"When writing to the path fails because the path is read-only "
"(:const:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""
"경로가 읽기 전용(:attr:`errno.EACCES`/:exc:`PermissionError`)이라서 경로에 쓰지 못할 때 예외를"
" 전파하지 않습니다."

#: ../../library/importlib.rst:601
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "호출할 때 더는 :exc:`NotImplementedError`\\를 발생시키지 않습니다."

#: ../../library/importlib.rst:606
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ":meth:`InspectLoader.get_code`\\의 구상 구현."

#: ../../library/importlib.rst:610
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module`\\의 구상 구현."

#: ../../library/importlib.rst:616
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module`\\의 구상 구현."

#: ../../library/importlib.rst:618
msgid "Use :meth:`exec_module` instead."
msgstr "대신 :meth:`exec_module`\\을 사용하십시오."

#: ../../library/importlib.rst:623
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ":meth:`InspectLoader.get_source`\\의 구상 구현."

#: ../../library/importlib.rst:627
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when "
"the file extension is removed **and** the module name itself does not end"
" in ``__init__``."
msgstr ""
":meth:`InspectLoader.is_package`\\의 구상 구현. "
"(:meth:`ExecutionLoader.get_filename`\\에서 제공되는) 파일 경로가 파일 확장자를 제거했을 때 "
"``__init__``\\라는 이름의 파일이고 *동시에* 모듈 이름 자체가 ``__init__``\\로 끝나지 않으면 모듈은 "
"패키지로 결정됩니다."

#: ../../library/importlib.rst:638
msgid "An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""
"*리소스(resources)*\\를 읽을 수 있는 기능을 제공하는 :term:`추상 베이스 클래스 <abstract base "
"class>`."

#: ../../library/importlib.rst:641
#, fuzzy
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that "
"is shipped within a package. Typically this is something like a data file"
" that lives next to the ``__init__.py`` file of the package. The purpose "
"of this class is to help abstract out the accessing of such data files so"
" that it does not matter if the package and its data file(s) are stored "
"e.g. in a zip file versus on the file system."
msgstr ""
"이 ABC의 관점에서, *리소스(resource)*\\는 패키지 내에 제공되는 바이너리 아티팩트(artifact)입니다. 일반적으로"
" 이것은 패키지의 ``__init__.py`` 파일 옆에 있는 데이터 파일 같은 것입니다. 이 클래스의 목적은 이러한 데이터 파일에"
" 대한 액세스를 추상화하여 패키지와 해당 데이터 파일이 예를 들어 zip 파일에 있는지 파일 시스템에 저장되어 있는지가 중요하지 "
"않도록 만드는 것입니다."

#: ../../library/importlib.rst:649
msgid ""
"For any of methods of this class, a *resource* argument is expected to be"
" a :term:`path-like object` which represents conceptually just a file "
"name. This means that no subdirectory paths should be included in the "
"*resource* argument. This is because the location of the package the "
"reader is for, acts as the \"directory\". Hence the metaphor for "
"directories and file names is packages and resources, respectively. This "
"is also why instances of this class are expected to directly correlate to"
" a specific package (instead of potentially representing multiple "
"packages or a module)."
msgstr ""
"이 클래스의 모든 메서드에서, *resource* 인자는 개념적으로 단지 파일 이름을 나타내는 :term:`경로류 객체 <path-"
"like object>`\\가 될 것으로 기대됩니다. 이는 *resource* 인자에 서브 디렉터리 경로가 포함되지 않아야 함을 "
"의미합니다. 판독기(reader)가 읽으려는 패키지의 위치가 \"디렉터리\"의 역할을 하기 때문입니다. 따라서 디렉터리와 파일 "
"이름에 대한 은유는 각각 패키지와 리소스입니다. 이것은 또한 이 클래스의 인스턴스가 (잠재적으로 여러 패키지나 모듈을 나타내는 "
"대신) 특정 패키지와 직접적으로 연관될 것으로 기대되는 이유입니다."

#: ../../library/importlib.rst:660
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is"
" not a package, this method should return :const:`None`. An object "
"compatible with this ABC should only be returned when the specified "
"module is a package."
msgstr ""
"리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체를 반환하는 "
"``get_resource_reader(fullname)``\\이라는 메서드를 제공해야 합니다. fullname으로 지정된 모듈이 "
"패키지가 아니면, 이 메서드는 :const:`None`\\을 반환해야 합니다. 이 ABC와 호환되는 객체는 지정된 모듈이 패키지일 "
"때만 반환해야 합니다."

#: ../../library/importlib.rst:669 ../../library/importlib.rst:789
#, fuzzy
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr "대신 :meth:`importlib.abc.Loader.exec_module`\\을 사용하십시오."

#: ../../library/importlib.rst:675
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr "*resource*\\의 바이너리 읽기를 위해 열린 :term:`파일류 객체 <file-like object>`\\를 반환합니다."

#: ../../library/importlib.rst:678
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "리소스를 찾을 수 없으면, :exc:`FileNotFoundError` 가 발생합니다."

#: ../../library/importlib.rst:684
msgid "Returns the file system path to the *resource*."
msgstr "*resource*\\에 대한 파일 시스템 경로를 반환합니다."

#: ../../library/importlib.rst:686
msgid ""
"If the resource does not concretely exist on the file system, raise "
":exc:`FileNotFoundError`."
msgstr "리소스가 파일 시스템에 구체적으로 존재하지 않으면, :exc:`FileNotFoundError` 가 발생합니다."

#: ../../library/importlib.rst:692
msgid ""
"Returns ``True`` if the named *name* is considered a resource. "
":exc:`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"명명된 *name*\\을 리소스로 간주하면 ``True``\\를 반환합니다. *name*\\이 없으면, "
":exc:`FileNotFoundError` 가 발생합니다."

#: ../../library/importlib.rst:698
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. "
"Do note that it is not required that all names returned by the iterator "
"be actual resources, e.g. it is acceptable to return names for which "
":meth:`is_resource` would be false."
msgstr ""
"패키지 내용에 대한 문자열의 :term:`이터러블 <iterable>`\\을 반환합니다. 이터레이터가 반환한 모든 이름이 실제 "
"리소스일 필요는 없음에 유의하십시오, 예를 들어 :meth:`is_resource`\\가 거짓인 이름을 반환하는 것이 허용됩니다."

#: ../../library/importlib.rst:704
msgid ""
"Allowing non-resource names to be returned is to allow for situations "
"where how a package and its resources are stored are known a priori and "
"the non-resource names would be useful. For instance, returning "
"subdirectory names is allowed so that when it is known that the package "
"and resources are stored on the file system then those subdirectory names"
" can be used directly."
msgstr ""
"리소스가 아닌 이름이 반환되도록 하는 것은 패키지와 그것의 리소스가 저장되는 방법이 사전에 알려졌고 리소스가 아닌 이름이 유용한 "
"상황을 허용하기 위함입니다. 예를 들어, 패키지와 리소스가 파일 시스템에 저장되어있는 것으로 알려졌을 때 해당 서브 디렉터리 이름을"
" 직접 사용할 수 있도록 서브 디렉터리 이름 반환이 허용됩니다."

#: ../../library/importlib.rst:712
msgid "The abstract method returns an iterable of no items."
msgstr "추상 메서드는 항목이 없는 이터러블을 반환합니다."

#: ../../library/importlib.rst:717
#, fuzzy
msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr "디렉터리를 탐색하고 파일을 여는 데 적합한 pathlib.Path 메서드의 부분집합이 있는 객체."

#: ../../library/importlib.rst:720
msgid ""
"For a representation of the object on the file-system, use "
":meth:`importlib.resources.as_file`."
msgstr ""

#: ../../library/importlib.rst:725
#, fuzzy
msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr "대신 :meth:`importlib.abc.Loader.exec_module`\\을 사용하십시오."

#: ../../library/importlib.rst:730
msgid "Abstract. The base name of this object without any parent references."
msgstr ""

#: ../../library/importlib.rst:735
msgid "Yield ``Traversable`` objects in ``self``."
msgstr ""

#: ../../library/importlib.rst:740
msgid "Return ``True`` if ``self`` is a directory."
msgstr ""

#: ../../library/importlib.rst:745
msgid "Return ``True`` if ``self`` is a file."
msgstr ""

#: ../../library/importlib.rst:750
msgid "Return Traversable child in ``self``."
msgstr ""

#: ../../library/importlib.rst:755
msgid "Return ``Traversable`` child in ``self``."
msgstr ""

#: ../../library/importlib.rst:760
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""

#: ../../library/importlib.rst:763
msgid ""
"When opening as text, accepts encoding parameters such as those accepted "
"by :class:`io.TextIOWrapper`."
msgstr ""

#: ../../library/importlib.rst:768
msgid "Read contents of ``self`` as bytes."
msgstr ""

#: ../../library/importlib.rst:772
msgid "Read contents of ``self`` as text."
msgstr ""

#: ../../library/importlib.rst:777
#, fuzzy
msgid ""
"An abstract base class for resource readers capable of serving the "
":meth:`importlib.resources.files` interface. Subclasses "
":class:`importlib.resources.abc.ResourceReader` and provides concrete "
"implementations of the :class:`importlib.resources.abc.ResourceReader`'s "
"abstract methods. Therefore, any loader supplying "
":class:`importlib.abc.TraversableResources` also supplies ResourceReader."
msgstr ""
"``files`` 인터페이스를 제공할 수 있는 리소스 리더를 위한 추상 베이스 클래스. ResourceReader를 서브 클래싱하고"
" ResourceReader의 추상 메서드의 구상 구현을 제공합니다. 따라서, TraversableReader를 제공하는 모든 "
"로더는 ResourceReader도 제공합니다."

#: ../../library/importlib.rst:784
msgid ""
"Loaders that wish to support resource reading are expected to implement "
"this interface."
msgstr ""

#: ../../library/importlib.rst:795
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the "
"loaded package."
msgstr ""

#: ../../library/importlib.rst:801
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- 임포터와 경로 훅"

#: ../../library/importlib.rst:806
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:810
msgid ""
"This module contains the various objects that help :keyword:`import` find"
" and load modules."
msgstr "이 모듈에는 :keyword:`import`\\가 모듈을 찾고 로드하는 데 도움이 되는 다양한 객체가 포함되어 있습니다."

#: ../../library/importlib.rst:815
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr "소스 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트."

#: ../../library/importlib.rst:822
msgid ""
"A list of strings representing the file suffixes for non-optimized "
"bytecode modules."
msgstr "최적화되지 않은 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트."

#: ../../library/importlib.rst:827 ../../library/importlib.rst:837
#, fuzzy
msgid "Use :const:`BYTECODE_SUFFIXES` instead."
msgstr "대신 :attr:`BYTECODE_SUFFIXES`\\를 사용하십시오."

#: ../../library/importlib.rst:832
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr "최적화된 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트."

#: ../../library/importlib.rst:842
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr "바이트 코드 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트 (앞의 점을 포함합니다)."

#: ../../library/importlib.rst:847
msgid "The value is no longer dependent on ``__debug__``."
msgstr "이 값은 더는 ``__debug__``\\에 의존하지 않습니다."

#: ../../library/importlib.rst:852
msgid ""
"A list of strings representing the recognized file suffixes for extension"
" modules."
msgstr "확장 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트."

#: ../../library/importlib.rst:859
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for"
" code which simply needs to know if a filesystem path potentially refers "
"to a module without needing any details on the kind of module (for "
"example, :func:`inspect.getmodulename`)."
msgstr ""
"표준 임포트 절차가 인식하는 모듈의 모든 파일 접미사를 나타내는 문자열의 결합한 리스트를 반환합니다. 이것은 모듈 종류에 대한 세부"
" 정보 없이 파일 시스템 경로가 잠재적으로 모듈을 참조하는지를 알아야 하는 코드(예를 들어, "
":func:`inspect.getmodulename`)를 위한 도우미입니다."

#: ../../library/importlib.rst:870
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"내장 모듈용 :term:`임포터 <importer>`. 알려진 모든 내장 모듈은 "
":data:`sys.builtin_module_names`\\에 나열되어 있습니다. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder`\\와 "
":class:`importlib.abc.InspectLoader` ABC를 구현합니다."

#: ../../library/importlib.rst:875 ../../library/importlib.rst:889
#: ../../library/importlib.rst:902 ../../library/importlib.rst:917
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr "이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다."

#: ../../library/importlib.rst:878
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
":pep:`489`\\의 일부로, 내장 임포터는 이제 :meth:`Loader.create_module`\\과 "
":meth:`Loader.exec_module`\\을 구현합니다."

#: ../../library/importlib.rst:885
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"프로즌(frozen) 모듈용 :term:`임포터 <importer>`. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder`\\와 "
":class:`importlib.abc.InspectLoader` ABC를 구현합니다."

#: ../../library/importlib.rst:892
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` "
"methods."
msgstr ":meth:`Loader.create_module`\\과 :meth:`Loader.exec_module` 메서드를 얻었습니다."

#: ../../library/importlib.rst:899
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  "
"This class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
"윈도우 레지스트리에 선언된 모듈용 :term:`파인더 <finder>`. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder` ABC를 구현합니다."

#: ../../library/importlib.rst:907
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr "대신 :mod:`site` 구성을 사용하십시오. 이후 버전의 파이썬은 기본적으로 이 파인더를 활성화하지 않을 수 있습니다."

#: ../../library/importlib.rst:914
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the "
":class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":data:`sys.path`\\와 패키지 ``__path__`` 어트리뷰트용 :term:`파인더 <finder>`. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder` ABC를 구현합니다."

#: ../../library/importlib.rst:922
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is "
"found then it is used as the :term:`path entry finder` to look for the "
"module being searched for. If no entry is found in "
":data:`sys.path_importer_cache`, then :data:`sys.path_hooks` is searched "
"for a finder for the path entry and, if found, is stored in "
":data:`sys.path_importer_cache` along with being queried about the "
"module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
":data:`sys.path` 또는, 정의되었다면, *path*\\에서 *fullname*\\에 의해 지정된 모듈에 대한 "
":term:`스펙 <module spec>`\\을 찾으려고 시도하는 클래스 메서드. 검색된 각 경로 엔트리에 대해, "
":data:`sys.path_importer_cache`\\가 확인됩니다. 거짓이 아닌 객체를 찾으면 검색 중인 모듈을 찾기 위한 "
":term:`경로 엔트리 파인더 <path entry finder>`\\로 사용됩니다. "
":data:`sys.path_importer_cache`\\에 엔트리가 없으면, :data:`sys.path_hooks`\\에서 "
"경로 엔트리를 위한 파인더를 검색하고, 발견되면, 모듈에 대해 조회되는 것과 동시에 "
":data:`sys.path_importer_cache`\\에 저장됩니다. 파인더가 아예 발견되지 않으면 ``None``\\이 "
"캐시에 저장되고 반환됩니다."

#: ../../library/importlib.rst:936
msgid ""
"If the current working directory -- represented by an empty string -- is "
"no longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"현재 작업 디렉터리 -- 빈 문자열로 표현됩니다 -- 가 더는 유효하지 않으면 ``None``\\이 반환되지만 "
":data:`sys.path_importer_cache`\\에 값이 캐시 되지는 않습니다."

#: ../../library/importlib.rst:943
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all "
"finders stored in :data:`sys.path_importer_cache` that define the method."
" Otherwise entries in :data:`sys.path_importer_cache` set to ``None`` are"
" deleted."
msgstr ""
"메서드를 정의하는 :data:`sys.path_importer_cache`\\에 저장된 모든 파인더에 대해 "
":meth:`importlib.abc.PathEntryFinder.invalidate_caches`\\를 호출합니다. "
":data:`sys.path_importer_cache`\\에 ``None``\\으로 설정된 엔트리가 삭제됩니다."

#: ../../library/importlib.rst:948
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ":data:`sys.path_importer_cache`\\에서 ``None``\\의 엔트리가 삭제됩니다."

#: ../../library/importlib.rst:951
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working "
"directory for ``''`` (i.e. the empty string)."
msgstr "``''``\\(즉 빈 문자열)에 대해서는 현재 작업 디렉터리로 :data:`sys.path_hooks`\\의 객체를 호출합니다."

#: ../../library/importlib.rst:958
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which"
" caches results from the file system."
msgstr "파일 시스템에서의 결과를 캐시 하는 :class:`importlib.abc.PathEntryFinder` 의 구상 구현."

#: ../../library/importlib.rst:961
msgid ""
"The *path* argument is the directory for which the finder is in charge of"
" searching."
msgstr "*path* 인자는 파인더가 검색을 담당하는 디렉터리입니다."

#: ../../library/importlib.rst:964
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader "
"recognizes. The loaders are expected to be callables which accept two "
"arguments of the module's name and the path to the file found."
msgstr ""
"*loader_details* 인자는 각각 로더와 로더가 인식하는 파일 접미사의 시퀀스를 포함하는 가변 개수의 2개 항목 "
"튜플입니다. 로더는 모듈 이름과 찾은 파일의 경로로 구성되는 두 인자를 받아들이는 콜러블일 것으로 기대됩니다."

#: ../../library/importlib.rst:969
msgid ""
"The finder will cache the directory contents as necessary, making stat "
"calls for each module search to verify the cache is not outdated. Because"
" cache staleness relies upon the granularity of the operating system's "
"state information of the file system, there is a potential race condition"
" of searching for a module, creating a new file, and then searching for "
"the module the new file represents. If the operations happen fast enough "
"to fit within the granularity of stat calls, then the module search will "
"fail. To prevent this from happening, when you create a module "
"dynamically, make sure to call :func:`importlib.invalidate_caches`."
msgstr ""
"파인더는 필요에 따라 디렉터리 내용을 캐시 하여, 각 모듈 검색에서 stat 호출을 수행하여 캐시가 시효가 지나지 않았는지 "
"확인합니다. 캐시 만료는 파일 시스템의 운영 체제 상태 정보의 세분성에 의존하기 때문에, 모듈 검색, 새 파일 생성 및 새 파일이 "
"나타내는 모듈 검색의 잠재적 경쟁 조건이 있습니다. stat 호출의 세분성 이하로 연산이 아주 빠르게 수행되면, 모듈 검색이 "
"실패합니다. 이를 방지하려면, 모듈을 동적으로 만들 때, :func:`importlib.invalidate_caches`\\를 "
"호출해야 합니다."

#: ../../library/importlib.rst:983
msgid "The path the finder will search in."
msgstr "파인더가 검색할 경로."

#: ../../library/importlib.rst:987
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` 내에서 *fullname*\\을 처리할 스펙을 찾으려고 합니다."

#: ../../library/importlib.rst:993
msgid "Clear out the internal cache."
msgstr "내부 캐시를 지웁니다."

#: ../../library/importlib.rst:997
#, fuzzy
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`."
" An instance of :class:`FileFinder` is returned by the closure using the "
"path argument given to the closure directly and *loader_details* "
"indirectly."
msgstr ""
":attr:`sys.path_hooks`\\에 사용할 클로저를 반환하는 클래스 메서드. :class:`FileFinder`\\의 "
"인스턴스는 클로저에 직접 제공된 경로 인자와 *loader_details*\\를 간접적으로 사용하여 클로저에 의해 반환됩니다."

#: ../../library/importlib.rst:1002
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr "클로저에 대한 인자가 기존 디렉터리가 아니면, :exc:`ImportError`\\가 발생합니다."

#: ../../library/importlib.rst:1008
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete"
" implementations of other methods."
msgstr ""
":class:`importlib.abc.FileLoader`\\를 서브 클래싱하고 다른 메서드의 구상 구현을 제공하는 "
":class:`importlib.abc.SourceLoader`\\의 구상 구현."

#: ../../library/importlib.rst:1016
msgid "The name of the module that this loader will handle."
msgstr "이 로더가 처리할 모듈의 이름."

#: ../../library/importlib.rst:1020
msgid "The path to the source file."
msgstr "소스 파일의 경로."

#: ../../library/importlib.rst:1024
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr ":attr:`path`\\가 패키지에 대한 것으로 드러나면 ``True``\\를 반환합니다."

#: ../../library/importlib.rst:1028
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ":meth:`importlib.abc.SourceLoader.path_stats`\\의 구상 구현."

#: ../../library/importlib.rst:1032
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ":meth:`importlib.abc.SourceLoader.set_data`\\의 구상 구현."

#: ../../library/importlib.rst:1036 ../../library/importlib.rst:1079
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where"
" specifying the name of the module to load is optional."
msgstr "로드할 모듈 이름을 지정하는 것이 선택적인 :meth:`importlib.abc.Loader.load_module`\\의 구상 구현."

#: ../../library/importlib.rst:1041 ../../library/importlib.rst:1084
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "대신 :meth:`importlib.abc.Loader.exec_module`\\을 사용하십시오."

#: ../../library/importlib.rst:1046
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"바이트 코드 파일을 (즉, 소스 코드 파일 없이) 임포트 할 수 있는 "
":class:`importlib.abc.FileLoader`\\의 구상 구현."

#: ../../library/importlib.rst:1049
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python "
"implementations or new versions of Python which change the bytecode "
"format."
msgstr ""
"바이트 코드 파일(그래서 소스 코드 파일이 아닌)을 직접 사용하면 모든 파이썬 구현이나 바이트 코드 형식을 변경하는 새 버전의 "
"파이썬에서 모듈을 사용할 수 없게 됨에 유의하십시오."

#: ../../library/importlib.rst:1058
msgid "The name of the module the loader will handle."
msgstr "로더가 처리할 모듈의 이름."

#: ../../library/importlib.rst:1062
msgid "The path to the bytecode file."
msgstr "바이트 코드 파일의 경로."

#: ../../library/importlib.rst:1066
msgid "Determines if the module is a package based on :attr:`path`."
msgstr ":attr:`path`\\를 기반으로 모듈이 패키지인지 판단합니다."

#: ../../library/importlib.rst:1070
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ":attr:`path`\\에서 만들어진 :attr:`name`\\의 코드 객체를 반환합니다."

#: ../../library/importlib.rst:1074
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is "
"used."
msgstr "이 로더가 사용될 때는 바이트 코드 파일에 소스가 없어서 ``None``\\을 반환합니다."

#: ../../library/importlib.rst:1089
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr "확장 모듈을 위한 :class:`importlib.abc.ExecutionLoader`\\의 구상 구현."

#: ../../library/importlib.rst:1092
msgid ""
"The *fullname* argument specifies the name of the module the loader is to"
" support. The *path* argument is the path to the extension module's file."
msgstr "*fullname* 인자는 로더가 지원할 모듈의 이름을 지정합니다. *path* 인자는 확장 모듈 파일의 경로입니다."

#: ../../library/importlib.rst:1095
msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see "
":pep:`489`), even if it would otherwise import successfully."
msgstr ""

#: ../../library/importlib.rst:1101
msgid "Multi-phase init is now required for use in subinterpreters."
msgstr ""

#: ../../library/importlib.rst:1106 ../../library/importlib.rst:1292
msgid "Name of the module the loader supports."
msgstr "로더가 지원하는 모듈의 이름."

#: ../../library/importlib.rst:1110
msgid "Path to the extension module."
msgstr "확장 모듈의 경로."

#: ../../library/importlib.rst:1114
msgid ""
"Creates the module object from the given specification in accordance with"
" :pep:`489`."
msgstr ":pep:`489`\\에 따라 지정된 명세에서 모듈 객체를 만듭니다."

#: ../../library/importlib.rst:1121
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr ":pep:`489`\\에 따라 주어진 모듈 객체를 초기화합니다."

#: ../../library/importlib.rst:1127
#, fuzzy
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` "
"module based on :const:`EXTENSION_SUFFIXES`."
msgstr ""
":attr:`EXTENSION_SUFFIXES`\\에 기반해서 파일 경로가 패키지의 ``__init__`` 모듈을 가리키면 "
"``True``\\를 반환합니다."

#: ../../library/importlib.rst:1132
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "확장 모듈에는 코드 객체가 없어서 ``None``\\을 반환합니다."

#: ../../library/importlib.rst:1136
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "확장 모듈에는 소스 코드가 없어서 ``None``\\을 반환합니다."

#: ../../library/importlib.rst:1147
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only "
"made public for introspecting the ``__loader__`` attribute on namespace "
"packages::"
msgstr ""

#: ../../library/importlib.rst:1152
msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""

#: ../../library/importlib.rst:1165
#, fuzzy
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`~module.__spec__` attribute.  "
"Many of these attributes are also available directly on a module: for "
"example, ``module.__spec__.origin == module.__file__``.  Note, however, "
"that while the *values* are usually equivalent, they can differ since "
"there is no synchronization between the two objects.  For example, it is "
"possible to update the module's :attr:`~module.__file__` at runtime and "
"this will not be automatically reflected in the module's "
":attr:`__spec__.origin <ModuleSpec.origin>`, and vice versa."
msgstr ""
"모듈의 임포트 시스템 관련 상태에 대한 명세. 이것은 일반적으로 모듈의 ``__spec__`` 어트리뷰트로 노출됩니다. 아래 "
"설명에서, 괄호 안의 이름은 모듈 객체에서 직접 사용 가능한 해당 어트리뷰트를 제공합니다. 예를 들어: "
"``module.__spec__.origin == module.__file__``. 그러나 *values*\\는 일반적으로 "
"동등하지만, 두 객체 간에 동기화가 없기 때문에 다를 수 있음에 유의하십시오. 따라서 실행 시간에 모듈의 "
"``__path__``\\를 갱신할 수 있으며, 이는 ``__spec__.submodule_search_locations``\\에 "
"자동으로 반영되지 않습니다."

#: ../../library/importlib.rst:1179
msgid ""
"The module's fully qualified name (see :attr:`module.__name__`). The "
":term:`finder` should always set this attribute to a non-empty string."
msgstr ""

#: ../../library/importlib.rst:1184
#, fuzzy
msgid ""
"The :term:`loader` used to load the module (see "
":attr:`module.__loader__`). The :term:`finder` should always set this "
"attribute."
msgstr ""
"모듈을 로드할 때 사용해야 하는 :term:`로더 <loader>`. :term:`파인더 <finder>`\\는 항상 이것을 "
"설정해야 합니다."

#: ../../library/importlib.rst:1189
msgid ""
"The location the :term:`loader` should use to load the module (see "
":attr:`module.__file__`). For example, for modules loaded from a ``.py`` "
"file this is the filename. The :term:`finder` should always set this "
"attribute to a meaningful value for the :term:`loader` to use.  In the "
"uncommon case that there is not one (like for namespace packages), it "
"should be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1198
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"in which a package's submodules will be found (see "
":attr:`module.__path__`). Most of the time there will only be a single "
"directory in this list."
msgstr ""

#: ../../library/importlib.rst:1203
msgid ""
"The :term:`finder` should set this attribute to a sequence, even an empty"
" one, to indicate to the import system that the module is a package.  It "
"should be set to ``None`` for non-package modules.  It is set "
"automatically later to a special object for namespace packages."
msgstr ""

#: ../../library/importlib.rst:1211
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  "
"Otherwise it should be set to ``None``."
msgstr ""

#: ../../library/importlib.rst:1217
msgid ""
"The filename of a compiled version of the module's code (see "
":attr:`module.__cached__`). The :term:`finder` should always set this "
"attribute but it may be ``None`` for modules that do not need compiled "
"code stored."
msgstr ""

#: ../../library/importlib.rst:1224
#, fuzzy
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or "
"the empty string for a top-level module). See :attr:`module.__package__`."
" If the module is a package then this is the same as :attr:`name`."
msgstr ""
"(읽기 전용) 모듈이 서브 모듈로 로드되어야 하는 패키지의 정규화된 이름 (또는 최상위 수준 모듈의 경우 빈 문자열). 패키지의 "
"경우, :attr:`__name__`\\과 같습니다."

#: ../../library/importlib.rst:1231
msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`!origin` is "
"interpreted and how the module's :attr:`~module.__file__` is populated."
msgstr ""

#: ../../library/importlib.rst:1238
#, fuzzy
msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that"
" is able to load extension modules in Framework format."
msgstr "확장 모듈을 위한 :class:`importlib.abc.ExecutionLoader`\\의 구상 구현."

#: ../../library/importlib.rst:1241
msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS "
"app must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There "
"can be only a single binary per framework, and there can be no executable"
" binary material outside the Frameworks folder."
msgstr ""

#: ../../library/importlib.rst:1247
msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this "
"loader is be registered against the ``.fwork`` file extension, with a "
"``.fwork`` file acting as a placeholder in the original location of the "
"binary on ``sys.path``. The ``.fwork`` file contains the path of the "
"actual binary in the ``Frameworks`` folder, relative to the app bundle. "
"To allow for resolving a framework-packaged binary back to the original "
"location, the framework is expected to contain a ``.origin`` file that "
"contains the location of the ``.fwork`` file, relative to the app bundle."
msgstr ""

#: ../../library/importlib.rst:1258
msgid ""
"For example, consider the case of an import ``from foo.bar import "
"_whiz``, where ``_whiz`` is implemented with the binary module "
"``sources/foo/bar/_whiz.abi3.so``, with ``sources`` being the location "
"registered on ``sys.path``, relative to the application bundle. This "
"module *must* be distributed as "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (creating the "
"framework name from the full import path of the module), with an "
"``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented "
"in the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` "
"marker file, containing the path "
"``Frameworks/foo.bar._whiz/foo.bar._whiz``. The framework would also "
"contain ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, "
"containing the path to the ``.fwork`` file."
msgstr ""

#: ../../library/importlib.rst:1272
msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module"
" will report as the location of the ``.fwork`` file. This allows code to "
"use the ``__file__`` of a  module as an anchor for file system traveral. "
"However, the spec origin will reference the location of the *actual* "
"binary in the ``.framework`` folder."
msgstr ""

#: ../../library/importlib.rst:1278
msgid ""
"The Xcode project building the app is responsible for converting any "
"``.so`` files from wherever they exist in the ``PYTHONPATH`` into "
"frameworks in the ``Frameworks`` folder (including stripping extensions "
"from the module file, the addition of framework metadata, and signing the"
" resulting framework), and creating the ``.fwork`` and ``.origin`` files."
" This will usually be done with a build step in the Xcode project; see "
"the iOS documentation for details on how to construct this build step."
msgstr ""

#: ../../library/importlib.rst:1288
msgid "Availability"
msgstr "가용성"

#: ../../library/importlib.rst:1296
#, fuzzy
msgid "Path to the ``.fwork`` file for the extension module."
msgstr "모듈 파일의 경로."

#: ../../library/importlib.rst:1300
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- 임포터를 위한 유틸리티 코드"

#: ../../library/importlib.rst:1306
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1310
msgid ""
"This module contains the various objects that help in the construction of"
" an :term:`importer`."
msgstr "이 모듈에는 :term:`임포터 <importer>` 구성에 도움이 되는 다양한 객체가 포함되어 있습니다."

#: ../../library/importlib.rst:1315
msgid ""
"The bytes which represent the bytecode version number. If you need help "
"with loading/writing bytecode then consider "
":class:`importlib.abc.SourceLoader`."
msgstr ""
"바이트 코드 버전 번호를 나타내는 바이트열. 바이트 코드의 로드/쓰기에 도움이 필요하면 "
":class:`importlib.abc.SourceLoader`\\를 고려하십시오."

#: ../../library/importlib.rst:1322
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file "
"associated with the source *path*.  For example, if *path* is "
"``/foo/bar/baz.py`` the return value would be "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. The "
"``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined "
"then :exc:`NotImplementedError` will be raised)."
msgstr ""
"소스 *path*\\와 연관된 바이트 컴파일된 파일의 :pep:`3147`/:pep:`488` 경로를 반환합니다. 예를 들어, "
"*path*\\가 ``/foo/bar/baz.py``\\이면 반환값은 파이썬 3.2의 경우 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``\\입니다. ``cpython-32`` 문자열은 현재 "
"매직 태그에서 온 것입니다 (:func:`get_tag`\\를 참조하십시오; "
":attr:`sys.implementation.cache_tag`\\가 정의되지 않으면 "
":exc:`NotImplementedError` 가 발생합니다)."

#: ../../library/importlib.rst:1329
msgid ""
"The *optimization* parameter is used to specify the optimization level of"
" the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpreter's optimization level to be used. Any other value's"
" string representation is used, so ``/foo/bar/baz.py`` with an "
"*optimization* of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string "
"representation of *optimization* can only be alphanumeric, else "
":exc:`ValueError` is raised."
msgstr ""
"*optimization* 매개 변수는 바이트 코드 파일의 최적화 수준을 지정하는 데 사용됩니다. 빈 문자열은 최적화하지 않음을 "
"나타내므로, *optimization*\\이 ``''`` 인 ``/foo/bar/baz.py``\\는 바이트 코드 경로가 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``\\가 됩니다. ``None``\\은 인터프리터의 "
"최적화 수준이 사용되도록 합니다. 다른 값의 문자열 표현은 사용되므로, *optimization*\\이 ``2``\\인 "
"``/foo/bar/baz.py``\\는 바이트 코드 경로가 "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``\\가 됩니다. "
"*optimization*\\의 문자열 표현은 영숫자만 가능하며, 그렇지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/importlib.rst:1339
msgid ""
"The *debug_override* parameter is deprecated and can be used to override "
"the system's value for ``__debug__``. A ``True`` value is the equivalent "
"of setting *optimization* to the empty string. A ``False`` value is the "
"same as setting *optimization* to ``1``. If both *debug_override* an "
"*optimization* are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* 매개 변수는 폐지되었고 ``__debug__``\\의 시스템값을 대체하는 데 사용할 수 있습니다. "
"``True`` 값은 *optimization*\\을 빈 문자열로 설정하는 것과 등등합니다. ``False`` 값은 "
"*optimization*\\을 ``1``\\로 설정하는 것과 같습니다. *debug_override*\\와 "
"*optimization*\\이 모두 ``None``\\이 아니면 :exc:`TypeError`\\가 발생합니다."

#: ../../library/importlib.rst:1347
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter"
" was deprecated."
msgstr "*optimization* 매개 변수가 추가되었고 *debug_override* 매개 변수는 폐지되었습니다."

#: ../../library/importlib.rst:1351 ../../library/importlib.rst:1367
#: ../../library/importlib.rst:1456
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/importlib.rst:1357
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source"
" code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not "
"conform to :pep:`3147` or :pep:`488` format, a :exc:`ValueError` is "
"raised. If :attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
"*path*\\에 :pep:`3147` 파일 이름이 주어지면, 연관된 소스 코드 파일 경로를 반환합니다. 예를 들어, "
"*path*\\가 ``/foo/bar/__pycache__/baz.cpython-32.pyc``\\이면 반환된 경로는 "
"``/foo/bar/baz.py``\\입니다. *path*\\는 존재할 필요는 없지만, :pep:`3147`\\이나 "
":pep:`488` 형식을 준수하지 않으면, :exc:`ValueError`\\가 발생합니다. "
":attr:`sys.implementation.cache_tag`\\가 정의되지 않으면, "
":exc:`NotImplementedError` 가 발생합니다."

#: ../../library/importlib.rst:1372
msgid ""
"Decode the given bytes representing source code and return it as a string"
" with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"소스 코드를 나타내는 주어진 바이트열을 디코딩하고 유니버설 줄 넘김이 적용된 문자열로 반환합니다 "
"(:meth:`importlib.abc.InspectLoader.get_source`\\에 필요한 대로)."

#: ../../library/importlib.rst:1380
msgid "Resolve a relative module name to an absolute one."
msgstr "상대 모듈 이름을 절대 이름으로 결정합니다."

#: ../../library/importlib.rst:1382
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` without doing a check to see if the **package** "
"argument is needed."
msgstr ""
"**name** 선두에 점이 없으면, **name**\\이 단순히 반환됩니다. 이를 통해 **package** 인자가 필요한지 "
"확인하지 않고 ``importlib.util.resolve_name('sys', __spec__.parent)``\\와 같은 사용이"
" 가능합니다."

#: ../../library/importlib.rst:1387
#, fuzzy
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). "
":exc:`ImportError` is also raised if a relative name would escape its "
"containing package (e.g. requesting ``..bacon`` from within the ``spam`` "
"package)."
msgstr ""
"**name**\\이 상대 모듈 이름이지만 **package**\\가 거짓 값(예를 들어 ``None``\\이나 빈 문자열)이면 "
":exc:`ImportError`\\가 발생합니다. :exc:`ImportError`\\는 또한 상대 이름이 그것을 포함하는 "
"패키지를 벗어날 것 같으면 발생합니다 (예를 들어 ``spam`` 패키지 내에서 ``..bacon``\\을 요청하는 것)."

#: ../../library/importlib.rst:1395
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"import 문과의 일관성을 개선하기 위해, 잘못된 상대 임포트 시도에 대해 :exc:`ValueError` 대신 "
":exc:`ImportError`\\를 발생시킵니다."

#: ../../library/importlib.rst:1402
#, fuzzy
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to "
"the specified **package** name. If the module is in :data:`sys.modules`, "
"then ``sys.modules[name].__spec__`` is returned (unless the spec would be"
" ``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is "
"returned if no spec is found."
msgstr ""
"선택적으로 지정된 **package** 이름에 상대적으로, 모듈의 :term:`스펙 <module spec>`\\을 찾습니다. "
"모듈이 :attr:`sys.modules`\\에 있으면, ``sys.modules[name].__spec__``\\이 반환됩니다 "
"(스펙이 ``None``\\이 되거나 설정되지 않지 않은 한, 그럴 경우는 :exc:`ValueError`\\가 발생합니다). "
"그렇지 않으면 :attr:`sys.meta_path`\\를 사용한 검색이 수행됩니다. 스펙을 찾지 못하면 ``None``\\이 "
"반환됩니다."

#: ../../library/importlib.rst:1409
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr "**name**\\이 서브 모듈에 관한 것이면 (점을 포함하면), 부모 모듈은 자동으로 임포트 됩니다."

#: ../../library/importlib.rst:1412
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name**\\과 **package**\\는 :func:`import_module`\\과 같게 작동합니다."

#: ../../library/importlib.rst:1416
#, fuzzy
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a "
":attr:`~module.__path__` attribute)."
msgstr ""
"**package**\\가 실제로 패키지가 아니면 (즉 :attr:`__path__` 어트리뷰트가 없으면) "
":exc:`AttributeError` 대신 :exc:`ModuleNotFoundError`\\를 발생시킵니다."

#: ../../library/importlib.rst:1423
msgid ""
"Create a new module based on **spec** and "
":meth:`spec.loader.create_module <importlib.abc.Loader.create_module>`."
msgstr ""
"**spec**\\과 :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`\\을 기반으로 새 모듈을 만듭니다."

#: ../../library/importlib.rst:1426
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>`"
" does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
":meth:`spec.loader.create_module <importlib.abc.Loader.create_module>`\\이"
" ``None``\\을 반환하지 않으면, 어떤 기존 어트리뷰트도 재설정되지 않습니다. 또한 **spec**\\에 액세스하거나 "
"모듈에서 어트리뷰트를 설정하는 동안 트리거 되면 :exc:`AttributeError`\\가 발생하지 않습니다."

#: ../../library/importlib.rst:1431
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create"
" a new module as **spec** is used to set as many import-controlled "
"attributes on the module as possible."
msgstr ""
"**spec**\\은 모듈에서 가능한 많은 임포트 제어 어트리뷰트를 설정하는 데 사용되므로 새 모듈을 작성하는 데 "
":class:`types.ModuleType`\\을 사용하는 것보다 이 함수가 선호됩니다."

#: ../../library/importlib.rst:1439
#, fuzzy
msgid ""
"A factory function for creating a "
":class:`~importlib.machinery.ModuleSpec` instance based on a loader.  The"
" parameters have the same meaning as they do for ModuleSpec.  The "
"function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on "
"the spec."
msgstr ""
"로더(loader)를 기반으로 :class:`ModuleSpec` 인스턴스를 만들기 위한 팩토리 함수. 매개 변수는 "
"ModuleSpec에서와 같은 의미입니다. 이 함수는 :meth:`InspectLoader.is_package`\\와 같은 사용 "
"가능한 :term:`로더 <loader>` API를 사용하여 스펙에 빠진 정보를 채웁니다."

#: ../../library/importlib.rst:1449
#, fuzzy
msgid ""
"A factory function for creating a "
":class:`~importlib.machinery.ModuleSpec` instance based on the path to a "
"file.  Missing information will be filled in on the spec by making use of"
" loader APIs and by the implication that the module will be file-based."
msgstr ""
"파일 경로를 기반으로 :class:`ModuleSpec` 인스턴스를 만드는 팩토리 함수. 로더 API를 사용하고 모듈이 파일 기반일"
" 것이라는 것이 뜻하는 것으로 누락된 정보가 스펙에 채워집니다."

#: ../../library/importlib.rst:1461
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's "
"contents in its header."
msgstr ""
"*source_bytes*\\의 해시를 바이트열로 반환합니다. 해시 기반 ``.pyc`` 파일은 해당 소스 파일 내용의 "
":func:`source_hash`\\를 헤더에 포함합니다."

#: ../../library/importlib.rst:1469
msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also "
"fail for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""

#: ../../library/importlib.rst:1476
msgid ""
"Note that this function is meant to accommodate an unusual case; one "
"which is likely to eventually go away.  There's is a pretty good chance "
"this is not what you were looking for."
msgstr ""

#: ../../library/importlib.rst:1480
msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr ""

#: ../../library/importlib.rst:1485
msgid ""
"Using this function to disable the check can lead to unexpected behavior "
"and even crashes.  It should only be used during extension module "
"development."
msgstr ""

#: ../../library/importlib.rst:1493
msgid ""
"A class which postpones the execution of the loader of a module until the"
" module has an attribute accessed."
msgstr "모듈이 어트리뷰트에 액세스할 때까지 모듈 로더의 실행을 연기하는 클래스."

#: ../../library/importlib.rst:1496
#, fuzzy
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module "
"type is used for the module is required. For those same reasons, the "
"loader's :meth:`~importlib.abc.Loader.create_module` method must return "
"``None`` or a type for which its ``__class__`` attribute can be mutated "
"along with not using :term:`slots <__slots__>`. Finally, modules which "
"substitute the object placed into :data:`sys.modules` will not work as "
"there is no way to properly replace the module references throughout the "
"interpreter safely; :exc:`ValueError` is raised if such a substitution is"
" detected."
msgstr ""
"이 클래스는 필요한 모듈 형에 대한 제어로 :meth:`~importlib.abc.Loader.exec_module`\\을 정의하는"
" 로더\\**에서만** 작동합니다. 같은 이유로, 로더의 "
":meth:`~importlib.abc.Loader.create_module` 메서드는 ``None``\\을 반환하거나, "
":term:`슬롯 <__slots__>`\\을 사용하지 않고 ``__class__`` 어트리뷰트가 변경될 수 있는 형을 반환해야 "
"합니다. 마지막으로, :attr:`sys.modules`\\에 배치된 객체를 치환하는 모듈은 인터프리터 전체에서 모듈 참조를 "
"안전하게 대체할 방법이 없어서 작동하지 않습니다; 이러한 치환이 감지되면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/importlib.rst:1507
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. "
"For projects where startup time is not essential then use of this class "
"is **heavily** discouraged due to error messages created during loading "
"being postponed and thus occurring out of context."
msgstr ""
"시작 시간이 중요한 프로젝트의 경우, 이 클래스를 사용하면 사용하지 않을 모듈을 로드하는 데 드는 비용을 최소화할 수 있습니다. "
"시작 시간이 핵심이 아닌 프로젝트의 경우 로딩이 지연되는 동안 만들어진, 따라서 문맥을 벗어난 에러 메시지 때문에, 이 클래스를 "
"사용하지 말 것을 **강하게** 권고합니다."

#: ../../library/importlib.rst:1515
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` "
"and :class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
":class:`importlib.machinery.BuiltinImporter`\\와 "
":class:`importlib.machinery.ExtensionFileLoader` 에 대한 호환성 경고를 제거하고, "
":meth:`~importlib.abc.Loader.create_module`\\을 호출하기 시작했습니다."

#: ../../library/importlib.rst:1522
#, fuzzy
msgid ""
"A class method which returns a callable that creates a lazy loader. This "
"is meant to be used in situations where the loader is passed by class "
"instead of by instance. ::"
msgstr ""
"지연된 로더(lazy loader)를 만드는 콜러블을 반환하는 정적 메서드. 이것은 로더가 인스턴스가 아닌 클래스로 전달되는 "
"상황에서 사용하려는 것입니다. ::"

#: ../../library/importlib.rst:1527
msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""

#: ../../library/importlib.rst:1535
msgid "Examples"
msgstr "예"

#: ../../library/importlib.rst:1538
msgid "Importing programmatically"
msgstr "프로그래밍 방식으로 임포트 하기"

#: ../../library/importlib.rst:1540
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`."
" ::"
msgstr "프로그래밍 방식으로 모듈을 임포트 하려면, :func:`importlib.import_module`\\을 사용하십시오. ::"

#: ../../library/importlib.rst:1543
msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""

#: ../../library/importlib.rst:1549
msgid "Checking if a module can be imported"
msgstr "모듈을 임포트 할 수 있는지 확인하기"

#: ../../library/importlib.rst:1551
#, fuzzy
msgid ""
"If you need to find out if a module can be imported without actually "
"doing the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"실제로 임포트를 수행하지 않고 모듈을 임포트 할 수 있는지 확인해야 하면, "
":func:`importlib.util.find_spec`\\을 사용해야 합니다. ::"

#: ../../library/importlib.rst:1554
msgid ""
"Note that if ``name`` is a submodule (contains a dot), "
":func:`importlib.util.find_spec` will import the parent module. ::"
msgstr ""

#: ../../library/importlib.rst:1558
#, python-brace-format
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""

#: ../../library/importlib.rst:1577
msgid "Importing a source file directly"
msgstr "소스 파일을 직접 임포트 하기"

#: ../../library/importlib.rst:1579
msgid ""
"This recipe should be used with caution: it is an approximation of an "
"import statement where the file path is specified directly, rather than "
":data:`sys.path` being searched. Alternatives should first be considered "
"first, such as modifying :data:`sys.path` when a proper module is "
"required, or using :func:`runpy.run_path` when the global namespace "
"resulting from running a Python file is appropriate."
msgstr ""

#: ../../library/importlib.rst:1586
#, fuzzy
msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr "파이썬 소스 파일을 직접 임포트 하려면, 다음 조리법을 사용하십시오 (파이썬 3.5 이상)::"

#: ../../library/importlib.rst:1588
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)"
"\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""

#: ../../library/importlib.rst:1610
msgid "Implementing lazy imports"
msgstr ""

#: ../../library/importlib.rst:1612
msgid "The example below shows how to implement lazy imports::"
msgstr ""

#: ../../library/importlib.rst:1614
msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""

#: ../../library/importlib.rst:1633
msgid "Setting up an importer"
msgstr "임포터 설정하기"

#: ../../library/importlib.rst:1635
#, fuzzy
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to "
"choose from depending on your needs: a :term:`meta path finder` or a "
":term:`path entry finder`. The former is what you would put on "
":data:`sys.meta_path` while the latter is what you create using a "
":term:`path entry hook` on :data:`sys.path_hooks` which works with "
":data:`sys.path` entries to potentially create a finder. This example "
"will show you how to register your own importers so that import will use "
"them (for creating an importer for yourself, read the documentation for "
"the appropriate classes defined within this package)::"
msgstr ""
"임포트의 심층 사용자 정의를 위해서는, 일반적으로 :term:`임포터 <importer>`\\를 구현하려고 합니다. 이는 "
":term:`파인더 <finder>`\\와 :term:`로더 <loader>` 측면을 모두 관리한다는 의미입니다. 파인더에는 필요에"
" 따라 두 가지 종류가 있습니다: :term:`메타 경로 파인더 <meta path finder>`\\나 :term:`경로 엔트리 "
"파인더 <path entry finder>`. 전자는 :attr:`sys.meta_path`\\에 배치하는 것이고 후자는 "
":attr:`sys.path_hooks`\\에서 :term:`경로 엔트리 훅 <path entry hook>`\\을 사용하여 만드는"
" 것으로 :attr:`sys.path` 항목과 함께 작동하여 파인더를 만듭니다. 이 예제는 임포트가 임포터를 사용할 수 있도록 "
"임포터를 등록하는 방법을 보여줍니다 (임포터를 직접 만들려면, 이 패키지에 정의된 적절한 클래스의 설명서를 읽으십시오)::"

#: ../../library/importlib.rst:1646
msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms"
" of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""

#: ../../library/importlib.rst:1667
msgid "Approximating :func:`importlib.import_module`"
msgstr ":func:`importlib.import_module` 근사하기"

#: ../../library/importlib.rst:1669
#, fuzzy
msgid ""
"Import itself is implemented in Python code, making it possible to expose"
" most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"임포트 자체는 파이썬 코드로 구현되므로, importlib를 통해 대부분의 임포트 절차를 노출할 수 있습니다. 다음은 "
":func:`importlib.import_module`\\의 근사적인(approximate) 구현을 제공하여 importlib가 "
"노출하는 다양한 API를 설명하는 데 도움을 줍니다 (importlib 사용법에 대해서는 파이썬 3.4 이상, 코드의 다른 부분에 "
"대해서는 파이썬 3.6 이상). ::"

#: ../../library/importlib.rst:1675
#, python-brace-format
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""

#: ../../library/importlib.rst:425
msgid "universal newlines"
msgstr ""

#: ../../library/importlib.rst:425
msgid "importlib.abc.InspectLoader.get_source method"
msgstr ""

#~ msgid ""
#~ "Find the loader for a module, "
#~ "optionally within the specified *path*. "
#~ "If the module is in :attr:`sys.modules`,"
#~ " then ``sys.modules[name].__loader__`` is "
#~ "returned (unless the loader would be "
#~ "``None`` or is not set, in which"
#~ " case :exc:`ValueError` is raised). "
#~ "Otherwise a search using :attr:`sys.meta_path`"
#~ " is done. ``None`` is returned if "
#~ "no loader is found."
#~ msgstr ""
#~ "선택적으로 지정된 *path* 내에서, 모듈의 로더를 "
#~ "찾습니다. 모듈이 :attr:`sys.modules`\\에 있으면, "
#~ "``sys.modules[name].__loader__``\\가 반환됩니다 (로더가 "
#~ "``None``\\이 되거나 설정되지 않지 않은 한, 그런"
#~ " 경우 :exc:`ValueError`\\가 발생합니다). 그렇지 않으면"
#~ " :attr:`sys.meta_path`\\를 사용한 검색이 수행됩니다. "
#~ "로더가 발견되지 않으면 ``None``\\이 반환됩니다."

#~ msgid ""
#~ "A dotted name does not have its"
#~ " parents implicitly imported as that "
#~ "requires loading them and that may "
#~ "not be desired. To properly import "
#~ "a submodule you will need to "
#~ "import all parent packages of the "
#~ "submodule and use the correct argument"
#~ " to *path*."
#~ msgstr ""
#~ "점으로 구분된 이름은 부모를 묵시적으로 임포트 되게 "
#~ "하지 않습니다, 그렇게 하려면 로드가 필요하고 이것이 "
#~ "바람직하지 않을 수 있기 때문입니다. 서브 모듈을 "
#~ "올바르게 임포트 하려면 서브 모듈의 모든 부모 "
#~ "패키지를 임포트 하고 *path*\\에 올바른 인자를 사용해야"
#~ " 합니다."

#~ msgid ""
#~ "If ``__loader__`` is not set, raise "
#~ ":exc:`ValueError`, just like when the "
#~ "attribute is set to ``None``."
#~ msgstr ""
#~ "``__loader__``\\가 설정되지 않으면, 어트리뷰트가 "
#~ "``None``\\으로 설정되었을 때와 마찬가지로 "
#~ ":exc:`ValueError`\\를 발생시킵니다."

#~ msgid "Use :func:`importlib.util.find_spec` instead."
#~ msgstr "대신 :func:`importlib.util.find_spec`\\을 사용하십시오."

#~ msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
#~ msgstr "대신 :class:`MetaPathFinder`\\나 :class:`PathEntryFinder`\\를 사용하십시오."

#~ msgid ""
#~ "An abstract method for finding a "
#~ ":term:`loader` for the specified module.  "
#~ "Originally specified in :pep:`302`, this "
#~ "method was meant for use in "
#~ ":data:`sys.meta_path` and in the path-"
#~ "based import subsystem."
#~ msgstr ""
#~ "지정된 모듈의 :term:`로더 <loader>`\\를 찾는 추상 "
#~ "메서드. 원래 :pep:`302`\\에 지정된, 이 메서드는 "
#~ ":data:`sys.meta_path`\\와 경로 기반 임포트 서브 "
#~ "시스템에서 사용하기 위한 것입니다."

#~ msgid ""
#~ "Returns ``None`` when called instead of"
#~ " raising :exc:`NotImplementedError`."
#~ msgstr "호출하면 :exc:`NotImplementedError`\\를 발생시키는 대신 ``None``\\을 반환합니다."

#~ msgid ""
#~ "An abstract base class representing a"
#~ " :term:`meta path finder`. For "
#~ "compatibility, this is a subclass of "
#~ ":class:`Finder`."
#~ msgstr ""
#~ ":term:`메타 경로 파인더 <meta path finder>`\\를"
#~ " 나타내는 추상 베이스 클래스. 호환성을 위해, "
#~ ":class:`Finder`\\의 서브 클래스입니다."

#~ msgid ""
#~ "A legacy method for finding a "
#~ ":term:`loader` for the specified module.  "
#~ "If this is a top-level import, "
#~ "*path* will be ``None``. Otherwise, this"
#~ " is a search for a subpackage "
#~ "or module and *path* will be the"
#~ " value of :attr:`__path__` from the "
#~ "parent package. If a loader cannot "
#~ "be found, ``None`` is returned."
#~ msgstr ""
#~ "지정된 모듈에 대한 :term:`로더 <loader>`\\를 찾기 "
#~ "위한 레거시 메서드. 최상위 임포트 인 경우, "
#~ "*path*\\는 ``None``\\입니다. 그렇지 않으면, 이것은 서브"
#~ " 패키지나 모듈의 검색이 되고, *path*\\는 부모 "
#~ "패키지의 :attr:`__path__` 값입니다. 로더를 찾을 수 "
#~ "없으면, ``None``\\이 반환됩니다."

#~ msgid ""
#~ "If :meth:`find_spec` is defined, backwards-"
#~ "compatible functionality is provided."
#~ msgstr ":meth:`find_spec`\\이 정의되면, 이전 버전과 호환되는 기능이 제공됩니다."

#~ msgid ""
#~ "Returns ``None`` when called instead of"
#~ " raising :exc:`NotImplementedError`. Can use "
#~ ":meth:`find_spec` to provide functionality."
#~ msgstr ""
#~ "호출하면 :exc:`NotImplementedError`\\를 발생시키는 대신 "
#~ "``None``\\을 반환합니다. :meth:`find_spec`\\을 사용하여 "
#~ "기능을 제공할 수 있습니다."

#~ msgid "Use :meth:`find_spec` instead."
#~ msgstr "대신 :meth:`find_spec`\\을 사용하십시오."

#~ msgid ""
#~ "A legacy method for finding a "
#~ ":term:`loader` for the specified module.  "
#~ "Returns a 2-tuple of ``(loader, "
#~ "portion)`` where ``portion`` is a "
#~ "sequence of file system locations "
#~ "contributing to part of a namespace "
#~ "package. The loader may be ``None`` "
#~ "while specifying ``portion`` to signify "
#~ "the contribution of the file system "
#~ "locations to a namespace package. An "
#~ "empty list can be used for "
#~ "``portion`` to signify the loader is "
#~ "not part of a namespace package. "
#~ "If ``loader`` is ``None`` and "
#~ "``portion`` is the empty list then "
#~ "no loader or location for a "
#~ "namespace package were found (i.e. "
#~ "failure to find anything for the "
#~ "module)."
#~ msgstr ""
#~ "지정된 모듈에 대한 :term:`로더 <loader>`\\를 찾기 "
#~ "위한 레거시 메서드. ``(loader, portion)``\\의 "
#~ "2-튜플을 반환하는데, ``portion``\\은 이름 공간 패키지의"
#~ " 일부에 기여하는 파일 시스템 위치의 시퀀스입니다. 파일"
#~ " 시스템 위치가 이름 공간 패키지에 기여함을 나타내도록"
#~ " ``portion``\\을 지정하는 동안 로더는 ``None``\\일 "
#~ "수 있습니다. 로더가 이름 공간 패키지의 일부가 "
#~ "아님을 표시하기 위해 ``portion``\\에 빈 리스트를 "
#~ "사용할 수 있습니다. ``loader``\\가 ``None``\\이고 "
#~ "``portion``\\이 빈 리스트이면 이름 공간 패키지의 "
#~ "로더나 위치가 발견되지 않은 것입니다 (즉 모듈에 "
#~ "대해 아무것도 찾지 못했습니다)."

#~ msgid ""
#~ "If :meth:`find_spec` is defined then "
#~ "backwards-compatible functionality is provided."
#~ msgstr ":meth:`find_spec`\\이 정의되면 이전 버전과 호환되는 기능이 제공됩니다."

#~ msgid ""
#~ "Returns ``(None, [])`` instead of "
#~ "raising :exc:`NotImplementedError`. Uses "
#~ ":meth:`find_spec` when available to provide"
#~ " functionality."
#~ msgstr ""
#~ ":exc:`NotImplementedError`\\를 발생시키는 대신 ``(None, "
#~ "[])``\\를 반환합니다. 가능하다면 기능을 제공하기 위해 "
#~ ":meth:`find_spec`\\을 사용하십시오."

#~ msgid ""
#~ "A concrete implementation of "
#~ ":meth:`Finder.find_module` which is equivalent "
#~ "to ``self.find_loader(fullname)[0]``."
#~ msgstr ""
#~ "``self.find_loader(fullname)[0]``\\과 동등한 "
#~ ":meth:`Finder.find_module`\\의 구상 구현."

#~ msgid "The name of the module."
#~ msgstr "모듈의 이름"

#~ msgid ""
#~ "The path to where the module data"
#~ " is stored (not set for built-"
#~ "in modules)."
#~ msgstr "모듈 데이터가 저장되는 경로입니다 (내장 모듈에는 설정되지 않습니다)."

#~ msgid ""
#~ "The path to where a compiled "
#~ "version of the module is/should be "
#~ "stored (not set when the attribute "
#~ "would be inappropriate)."
#~ msgstr "모듈의 컴파일 된 버전이 저장되는/저장되어야 하는 경로 (어트리뷰트가 부적절하면 설정되지 않습니다)."

#~ msgid ""
#~ "A list of strings specifying the "
#~ "search path within a package. This "
#~ "attribute is not set on modules."
#~ msgstr "패키지 내에서 검색 경로를 지정하는 문자열 리스트. 이 어트리뷰트는 모듈에는 설정되지 않습니다."

#~ msgid ""
#~ "The fully-qualified name of the "
#~ "package under which the module was "
#~ "loaded as a submodule (or the "
#~ "empty string for top-level modules). "
#~ "For packages, it is the same as"
#~ " :attr:`__name__`.  The "
#~ ":func:`importlib.util.module_for_loader` decorator can "
#~ "handle the details for :attr:`__package__`."
#~ msgstr ""
#~ "모듈이 서브 모듈로 로드된 패키지의 완전히 정규화된 "
#~ "이름 (또는 최상위 수준 모듈의 경우 빈 문자열)."
#~ " 패키지의 경우, :attr:`__name__`\\과 같습니다. "
#~ ":func:`importlib.util.module_for_loader` 데코레이터는 "
#~ ":attr:`__package__`\\의 세부 사항을 처리할 수 "
#~ "있습니다."

#~ msgid ""
#~ "The loader used to load the "
#~ "module. The :func:`importlib.util.module_for_loader` "
#~ "decorator can handle the details for "
#~ ":attr:`__package__`."
#~ msgstr ""
#~ "모듈을 로드하는 데 사용되는 로더. "
#~ ":func:`importlib.util.module_for_loader` 데코레이터는 "
#~ ":attr:`__package__`\\의 세부 사항을 처리 할 수 "
#~ "있습니다."

#~ msgid ""
#~ "A legacy method which when implemented"
#~ " calculates and returns the given "
#~ "module's repr, as a string. The "
#~ "module type's default repr() will use"
#~ " the result of this method as "
#~ "appropriate."
#~ msgstr ""
#~ "구현될 때 지정된 모듈의 repr을 문자열로 계산하고 "
#~ "반환하는 레거시 메서드. 모듈 형의 기본 repr()은 "
#~ "이 메서드의 결과를 적절하게 사용합니다."

#~ msgid "Made optional instead of an abstractmethod."
#~ msgstr "abstractmethod 대신에 선택 사항으로 만들어졌습니다."

#~ msgid "The import machinery now takes care of this automatically."
#~ msgstr "임포트 절차는 이제 이것을 자동으로 처리합니다."

#~ msgid ":mod:`importlib.resources` -- Resources"
#~ msgstr ":mod:`importlib.resources` -- 리소스"

#~ msgid "**Source code:** :source:`Lib/importlib/resources.py`"
#~ msgstr "**소스 코드:** :source:`Lib/importlib/resources.py`"

#~ msgid ""
#~ "This module leverages Python's import "
#~ "system to provide access to *resources*"
#~ " within *packages*.  If you can "
#~ "import a package, you can access "
#~ "resources within that package.  Resources "
#~ "can be opened or read, in either"
#~ " binary or text mode."
#~ msgstr ""
#~ "이 모듈은 파이썬의 임포트 시스템을 활용하여 "
#~ "*패키지(packages)* 안에 있는 *리소스(resources)*\\에 대한"
#~ " 액세스를 제공합니다. 패키지를 임포트 할 수 있으면,"
#~ " 해당 패키지 내의 리소스에 액세스 할 수 "
#~ "있습니다. 바이너리나 텍스트 모드로 리소스를 열거나 읽을"
#~ " 수 있습니다."

#~ msgid ""
#~ "Resources are roughly akin to files "
#~ "inside directories, though it's important "
#~ "to keep in mind that this is "
#~ "just a metaphor.  Resources and packages"
#~ " **do not** have to exist as "
#~ "physical files and directories on the"
#~ " file system."
#~ msgstr ""
#~ "리소스는 디렉터리 내의 파일과 거의 비슷하지만, 이것은 "
#~ "단지 은유라는 점을 명심해야 합니다. 리소스와 패키지가 "
#~ "파일 시스템에 실제 파일과 디렉터리로 존재할 필요는 "
#~ "**없습니다**."

#~ msgid ""
#~ "This module provides functionality similar "
#~ "to `pkg_resources "
#~ "<https://setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ "
#~ "`Basic Resource Access "
#~ "<http://setuptools.readthedocs.io/en/latest/pkg_resources.html"
#~ "#basic-resource-access>`_ without the "
#~ "performance overhead of that package.  "
#~ "This makes reading resources included in"
#~ " packages easier, with more stable "
#~ "and consistent semantics."
#~ msgstr ""
#~ "이 모듈은 `pkg_resources "
#~ "<https://setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ "
#~ "`Basic Resource Access "
#~ "<http://setuptools.readthedocs.io/en/latest/pkg_resources.html"
#~ "#basic-resource-access>`_\\와 유사한 기능을 "
#~ "제공합니다만, 이 패키지의 성능 오버헤드가 없습니다. 이는"
#~ " 더 안정적이고 일관된 의미론으로, 패키지에 포함된 "
#~ "리소스를 더 쉽게 읽을 수 있도록 합니다."

#~ msgid ""
#~ "The standalone backport of this module"
#~ " provides more information on `using "
#~ "importlib.resources <http://importlib-"
#~ "resources.readthedocs.io/en/latest/using.html>`_ and "
#~ "`migrating from pkg_resources to "
#~ "importlib.resources <http://importlib-"
#~ "resources.readthedocs.io/en/latest/migration.html>`_."
#~ msgstr ""
#~ "이 모듈의 독립형 역 이식은 `using "
#~ "importlib.resources <http://importlib-"
#~ "resources.readthedocs.io/en/latest/using.html>`_\\와 `migrating"
#~ " from pkg_resources to importlib.resources "
#~ "<http://importlib-"
#~ "resources.readthedocs.io/en/latest/migration.html>`_\\에서 자세한 "
#~ "정보를 제공합니다."

#~ msgid "The following types are defined."
#~ msgstr "다음과 같은 형이 정의됩니다."

#~ msgid ""
#~ "The ``Package`` type is defined as "
#~ "``Union[str, ModuleType]``.  This means that"
#~ " where the function describes accepting "
#~ "a ``Package``, you can pass in "
#~ "either a string or a module.  "
#~ "Module objects must have a resolvable"
#~ " ``__spec__.submodule_search_locations`` that is "
#~ "not ``None``."
#~ msgstr ""
#~ "``Package`` 형은 ``Union[str, ModuleType]``\\으로 "
#~ "정의됩니다. 이는 함수가 ``Package``\\를 받아들인다고 설명하는"
#~ " 위치에 문자열이나 모듈을 전달할 수 있음을 의미합니다."
#~ " 모듈 객체는 ``None``\\이 아닌 해석할 수 있는"
#~ " ``__spec__.submodule_search_locations``\\를 가져야 합니다."

#~ msgid ""
#~ "This type describes the resource names"
#~ " passed into the various functions in"
#~ " this package.  This is defined as"
#~ " ``Union[str, os.PathLike]``."
#~ msgstr ""
#~ "이 형은 이 패키지의 다양한 함수에 전달된 리소스"
#~ " 이름을 기술합니다. 이것은 ``Union[str, "
#~ "os.PathLike]``\\으로 정의됩니다."

#~ msgid "The following functions are available."
#~ msgstr "다음과 같은 함수를 사용할 수 있습니다."

#~ msgid ""
#~ "Returns an :class:`importlib.resources.abc.Traversable`"
#~ " object representing the resource container"
#~ " for the package (think directory) "
#~ "and its resources (think files). A "
#~ "Traversable may contain other containers "
#~ "(think subdirectories)."
#~ msgstr ""
#~ "패키지의 리소스 컨테이너(디렉터리를 생각하십시오)와 그것의 리소스(파일을"
#~ " 생각하십시오)를 나타내는 "
#~ ":class:`importlib.resources.abc.Traversable` 객체를 반환합니다."
#~ " Traversable은 다른 컨테이너를 포함할 수 있습니다 "
#~ "(서브 디렉터리를 생각하십시오)."

#~ msgid ""
#~ "*package* is either a name or a"
#~ " module object which conforms to the"
#~ " ``Package`` requirements."
#~ msgstr "*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다."

#~ msgid ""
#~ "Given a :class:`importlib.resources.abc.Traversable` "
#~ "object representing a file, typically "
#~ "from :func:`importlib.resources.files`, return a "
#~ "context manager for use in a "
#~ ":keyword:`with` statement. The context manager"
#~ " provides a :class:`pathlib.Path` object."
#~ msgstr ""
#~ "일반적으로 :func:`importlib.resources.files`\\에서, 파일을 "
#~ "나타내는 :class:`importlib.resources.abc.Traversable` 객체를 "
#~ "주면 :keyword:`with` 문에서 사용할 컨텍스트 관리자를 "
#~ "반환합니다. 컨텍스트 관리자는 :class:`pathlib.Path` 객체를 "
#~ "제공합니다."

#~ msgid ""
#~ "Exiting the context manager cleans up"
#~ " any temporary file created when the"
#~ " resource was extracted from e.g. a"
#~ " zip file."
#~ msgstr "컨텍스트 관리자를 종료하면 예를 들어 zip 파일에서 리소스가 추출될 때 만들어진 임시 파일이 정리됩니다."

#~ msgid ""
#~ "Use ``as_file`` when the Traversable "
#~ "methods (``read_text``, etc) are insufficient"
#~ " and an actual file on the file"
#~ " system is required."
#~ msgstr ""
#~ "Traversable 메서드(``read_text`` 등)가 충분하지 않고 "
#~ "파일 시스템의 실제 파일이 필요하면 ``as_file``\\을 "
#~ "사용하십시오."

#~ msgid "Open for binary reading the *resource* within *package*."
#~ msgstr "*package* 내에서 *resource*\\를 바이너리 읽기로 엽니다."

#~ msgid ""
#~ "*package* is either a name or a"
#~ " module object which conforms to the"
#~ " ``Package`` requirements.  *resource* is "
#~ "the name of the resource to open"
#~ " within *package*; it may not contain"
#~ " path separators and it may not "
#~ "have sub-resources (i.e. it cannot "
#~ "be a directory).  This function returns"
#~ " a ``typing.BinaryIO`` instance, a binary"
#~ " I/O stream open for reading."
#~ msgstr ""
#~ "*package*\\는 ``Package`` 요구 사항을 준수하는 "
#~ "이름이나 모듈 객체입니다. *resource*\\는 *package* "
#~ "내에서 열 리소스의 이름입니다; 경로 구분 기호를 "
#~ "포함하지 않아야 하고 서브 리소스를 가질 수도 "
#~ "없습니다 (즉, 디렉터리가 될 수 없습니다). 이 "
#~ "함수는 읽기 위해 열린 바이너리 I/O 스트림인 "
#~ "``typing.BinaryIO`` 인스턴스를 반환합니다."

#~ msgid ""
#~ "Open for text reading the *resource* "
#~ "within *package*.  By default, the "
#~ "resource is opened for reading as "
#~ "UTF-8."
#~ msgstr "*package* 내에서 *resource*\\를 텍스트 읽기로 엽니다. 기본적으로, 리소스는 UTF-8로 읽도록 열립니다."

#~ msgid ""
#~ "*package* is either a name or a"
#~ " module object which conforms to the"
#~ " ``Package`` requirements.  *resource* is "
#~ "the name of the resource to open"
#~ " within *package*; it may not contain"
#~ " path separators and it may not "
#~ "have sub-resources (i.e. it cannot "
#~ "be a directory).  *encoding* and "
#~ "*errors* have the same meaning as "
#~ "with built-in :func:`open`."
#~ msgstr ""
#~ "*package*\\는 ``Package`` 요구 사항을 준수하는 "
#~ "이름이나 모듈 객체입니다. *resource*\\는 *package* "
#~ "내에서 열 리소스의 이름입니다; 경로 구분 기호를 "
#~ "포함하지 않아야 하고 서브 리소스를 가질 수도 "
#~ "없습니다 (즉, 디렉터리가 될 수 없습니다). "
#~ "*encoding*\\과 *errors*\\는 내장 :func:`open`\\과 "
#~ "같은 의미입니다."

#~ msgid ""
#~ "This function returns a ``typing.TextIO`` "
#~ "instance, a text I/O stream open "
#~ "for reading."
#~ msgstr "이 함수는 읽기 위해 열린 텍스트 I/O 스트림인 ``typing.TextIO`` 인스턴스를 반환합니다."

#~ msgid ""
#~ "Read and return the contents of "
#~ "the *resource* within *package* as "
#~ "``bytes``."
#~ msgstr "*package* 내에서 *resource*\\의 내용을 읽고 ``bytes``\\로 반환합니다."

#~ msgid ""
#~ "*package* is either a name or a"
#~ " module object which conforms to the"
#~ " ``Package`` requirements.  *resource* is "
#~ "the name of the resource to open"
#~ " within *package*; it may not contain"
#~ " path separators and it may not "
#~ "have sub-resources (i.e. it cannot "
#~ "be a directory).  This function returns"
#~ " the contents of the resource as "
#~ ":class:`bytes`."
#~ msgstr ""
#~ "*package*\\는 ``Package`` 요구 사항을 준수하는 "
#~ "이름이나 모듈 객체입니다. *resource*\\는 *package* "
#~ "내에서 열 리소스의 이름입니다; 경로 구분 기호를 "
#~ "포함하지 않아야 하고 서브 리소스를 가질 수도 "
#~ "없습니다 (즉, 디렉터리가 될 수 없습니다). 이 "
#~ "함수는 리소스의 내용을 :class:`bytes`\\로 반환합니다."

#~ msgid ""
#~ "Read and return the contents of "
#~ "*resource* within *package* as a "
#~ "``str``. By default, the contents are"
#~ " read as strict UTF-8."
#~ msgstr ""
#~ "*package* 내에서 *resource*\\의 내용을 읽고 "
#~ "``str``\\로 반환합니다. 기본적으로, 내용은 엄격한(strict) "
#~ "UTF-8로 읽습니다."

#~ msgid ""
#~ "*package* is either a name or a"
#~ " module object which conforms to the"
#~ " ``Package`` requirements.  *resource* is "
#~ "the name of the resource to open"
#~ " within *package*; it may not contain"
#~ " path separators and it may not "
#~ "have sub-resources (i.e. it cannot "
#~ "be a directory).  *encoding* and "
#~ "*errors* have the same meaning as "
#~ "with built-in :func:`open`.  This "
#~ "function returns the contents of the "
#~ "resource as :class:`str`."
#~ msgstr ""
#~ "*package*\\는 ``Package`` 요구 사항을 준수하는 "
#~ "이름이나 모듈 객체입니다. *resource*\\는 *package* "
#~ "내에서 열 리소스의 이름입니다; 경로 구분 기호를 "
#~ "포함하지 않아야 하고 서브 리소스를 가질 수도 "
#~ "없습니다 (즉, 디렉터리가 될 수 없습니다). "
#~ "*encoding*\\과 *errors*\\는 내장 :func:`open`\\과 "
#~ "같은 의미입니다. 이 함수는 리소스의 내용을 "
#~ ":class:`str`\\로 반환합니다."

#~ msgid ""
#~ "Return the path to the *resource* "
#~ "as an actual file system path.  "
#~ "This function returns a context manager"
#~ " for use in a :keyword:`with` "
#~ "statement. The context manager provides "
#~ "a :class:`pathlib.Path` object."
#~ msgstr ""
#~ "*resource*\\에 대한 경로를 실제 파일 시스템 경로로"
#~ " 반환합니다. 이 함수는 :keyword:`with` 문에서 사용할"
#~ " 컨텍스트 관리자를 반환합니다. 컨텍스트 관리자는 "
#~ ":class:`pathlib.Path` 객체를 제공합니다."

#~ msgid ""
#~ "Exiting the context manager cleans up"
#~ " any temporary file created when the"
#~ " resource needs to be extracted from"
#~ " e.g. a zip file."
#~ msgstr "컨텍스트 관리자를 종료하면 리소스를 예를 들어 zip 파일에서 추출해야 할 때 만들어진 임시 파일이 정리됩니다."

#~ msgid ""
#~ "*package* is either a name or a"
#~ " module object which conforms to the"
#~ " ``Package`` requirements.  *resource* is "
#~ "the name of the resource to open"
#~ " within *package*; it may not contain"
#~ " path separators and it may not "
#~ "have sub-resources (i.e. it cannot "
#~ "be a directory)."
#~ msgstr ""
#~ "*package*\\는 ``Package`` 요구 사항을 준수하는 "
#~ "이름이나 모듈 객체입니다. *resource*\\는 *package* "
#~ "내에서 열 리소스의 이름입니다; 경로 구분 기호를 "
#~ "포함하지 않아야 하고 서브 리소스를 가질 수도 "
#~ "없습니다 (즉, 디렉터리가 될 수 없습니다)."

#~ msgid ""
#~ "Return ``True`` if there is a "
#~ "resource named *name* in the package,"
#~ " otherwise ``False``.  Remember that "
#~ "directories are *not* resources! *package* "
#~ "is either a name or a module "
#~ "object which conforms to the ``Package``"
#~ " requirements."
#~ msgstr ""
#~ "패키지에 *name*\\이라는 리소스가 있으면 ``True``\\를, "
#~ "그렇지 않으면 ``False``\\를 반환합니다. 디렉터리는 리소스가"
#~ " *아니라는* 것을 기억하십시오! *package*\\는 ``Package``"
#~ " 요구 사항을 준수하는 이름이나 모듈 객체입니다."

#~ msgid ""
#~ "Return an iterable over the named "
#~ "items within the package.  The iterable"
#~ " returns :class:`str` resources (e.g. "
#~ "files) and non-resources (e.g. "
#~ "directories).  The iterable does not "
#~ "recurse into subdirectories."
#~ msgstr ""
#~ "패키지 내에서 이름이 있는 항목에 대한 이터러블을 "
#~ "반환합니다. 이터러블은 :class:`str` 리소스(예를 들어 파일)와"
#~ " 리소스가 아닌 것(예를 들어 디렉터리)을 반환합니다. "
#~ "이터러블은 서브 디렉터리로 재귀하지 않습니다."

#~ msgid "A legacy wrapper around :meth:`find_spec`."
#~ msgstr ":meth:`find_spec`\\을 감싸는 레거시 래퍼."

#~ msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
#~ msgstr ":attr:`path` 내에서 *fullname*\\을 처리할 로더를 찾으려고 합니다."

#~ msgid "(``__name__``)"
#~ msgstr "(``__name__``)"

#~ msgid "A string for the fully-qualified name of the module."
#~ msgstr "정규화된 모듈 이름의 문자열."

#~ msgid "(``__loader__``)"
#~ msgstr "(``__loader__``)"

#~ msgid "(``__file__``)"
#~ msgstr "(``__file__``)"

#~ msgid ""
#~ "Name of the place from which the"
#~ " module is loaded, e.g. \"builtin\" "
#~ "for built-in modules and the "
#~ "filename for modules loaded from source."
#~ " Normally \"origin\" should be set, "
#~ "but it may be ``None`` (the "
#~ "default) which indicates it is "
#~ "unspecified (e.g. for namespace packages)."
#~ msgstr ""
#~ "모듈이 로드된 장소의 이름, 예를 들어, 내장 "
#~ "모듈의 경우 \"builtin\"이고 소스에서 로드한 모듈의 "
#~ "경우 파일명. 일반적으로 \"origin\"을 설정해야 하지만, "
#~ "지정되지 않았음을 나타내는 ``None``\\(기본값)일 수 있습니다"
#~ " (예를 들어 이름 공간 패키지)."

#~ msgid "(``__path__``)"
#~ msgstr "(``__path__``)"

#~ msgid ""
#~ "List of strings for where to find"
#~ " submodules, if a package (``None`` "
#~ "otherwise)."
#~ msgstr "패키지이면, 서브 모듈을 찾을 수 있는 문자열 리스트 (그렇지 않으면 ``None``)."

#~ msgid ""
#~ "Container of extra module-specific data"
#~ " for use during loading (or "
#~ "``None``)."
#~ msgstr "로드 중 사용하기 위한 추가 모듈 특정 데이터의 컨테이너 (또는 ``None``)."

#~ msgid "(``__cached__``)"
#~ msgstr "(``__cached__``)"

#~ msgid "String for where the compiled module should be stored (or ``None``)."
#~ msgstr "컴파일된 모듈을 저장해야 하는 장소의 문자열 (또는 ``None``)."

#~ msgid "(``__package__``)"
#~ msgstr "(``__package__``)"

#~ msgid ""
#~ "Boolean indicating whether or not the"
#~ " module's \"origin\" attribute refers to"
#~ " a loadable location."
#~ msgstr "모듈의 \"origin\" 어트리뷰트가 로드 가능한 위치를 나타내는지를 나타내는 불리언."

#~ msgid ""
#~ "A :term:`decorator` for "
#~ ":meth:`importlib.abc.Loader.load_module` to handle "
#~ "selecting the proper module object to"
#~ " load with. The decorated method is"
#~ " expected to have a call signature"
#~ " taking two positional arguments (e.g. "
#~ "``load_module(self, module)``) for which the"
#~ " second argument will be the module"
#~ " **object** to be used by the "
#~ "loader. Note that the decorator will "
#~ "not work on static methods because "
#~ "of the assumption of two arguments."
#~ msgstr ""
#~ "로드할 적절한 모듈 객체 선택을 처리하기 위한 "
#~ ":meth:`importlib.abc.Loader.load_module` 용 :term:`데코레이터"
#~ " <decorator>`. 데코레이팅 된 메서드에는 두 개의 "
#~ "위치 인자를 취하는 호출 서명을 가질 것으로 "
#~ "기대됩니다 (예를 들어 ``load_module(self, module)``),"
#~ " 두 번째 인자는 로더가 사용할 모듈 "
#~ "**객체**\\입니다. 데코레이터는 두 개의 인자를 가정하기 "
#~ "때문에 정적 메서드에서 작동하지 않음에 유의하십시오."

#~ msgid ""
#~ "The decorated method will take in "
#~ "the **name** of the module to be"
#~ " loaded as expected for a "
#~ ":term:`loader`. If the module is not "
#~ "found in :data:`sys.modules` then a new"
#~ " one is constructed. Regardless of "
#~ "where the module came from, "
#~ ":attr:`__loader__` set to **self** and "
#~ ":attr:`__package__` is set based on what"
#~ " :meth:`importlib.abc.InspectLoader.is_package` returns "
#~ "(if available). These attributes are set"
#~ " unconditionally to support reloading."
#~ msgstr ""
#~ "데코레이팅 된 메서드는 :term:`로더 <loader>`\\에 대해"
#~ " 로드될 모듈 **이름**\\을 취합니다. "
#~ ":data:`sys.modules`\\에 모듈이 없으면 새로운 모듈이 "
#~ "구성됩니다. 모듈의 출처와 관계없이, :attr:`__loader__`\\는 "
#~ "**self**\\로 설정되고 :attr:`__package__`\\는 "
#~ ":meth:`importlib.abc.InspectLoader.is_package`\\가 반환하는 것에"
#~ " 따라 설정됩니다 (사용 가능하다면). 이러한 어트리뷰트는 "
#~ "재로드를 지원하도록 무조건 설정됩니다."

#~ msgid ""
#~ "If an exception is raised by the"
#~ " decorated method and a module was"
#~ " added to :data:`sys.modules`, then the "
#~ "module will be removed to prevent "
#~ "a partially initialized module from "
#~ "being in left in :data:`sys.modules`. If"
#~ " the module was already in "
#~ ":data:`sys.modules` then it is left "
#~ "alone."
#~ msgstr ""
#~ "데코레이트 된 메서드가 예외를 발생시키고 "
#~ ":data:`sys.modules`\\에 모듈이 추가되었으면, 부분적으로 초기화된"
#~ " 모듈이 :data:`sys.modules`\\에 남아 있지 않도록 "
#~ "모듈이 제거됩니다. 모듈이 이미 :data:`sys.modules`\\에 "
#~ "있었다면 모듈은 그대로 유지됩니다."

#~ msgid ""
#~ ":attr:`__loader__` and :attr:`__package__` are "
#~ "automatically set (when possible)."
#~ msgstr ":attr:`__loader__`\\와 :attr:`__package__`\\는 자동으로 설정됩니다 (가능하면)."

#~ msgid ""
#~ "Set :attr:`__name__`, :attr:`__loader__` "
#~ ":attr:`__package__` unconditionally to support "
#~ "reloading."
#~ msgstr ""
#~ "재로드를 지원하기 위해 :attr:`__name__`, "
#~ ":attr:`__loader__` :attr:`__package__`\\를 무조건 설정합니다."

#~ msgid ""
#~ "The import machinery now directly "
#~ "performs all the functionality provided "
#~ "by this function."
#~ msgstr "임포트 절차는 이제 이 함수가 제공하는 모든 기능을 직접 수행합니다."

#~ msgid ""
#~ "A :term:`decorator` for "
#~ ":meth:`importlib.abc.Loader.load_module` to set the"
#~ " :attr:`__loader__` attribute on the "
#~ "returned module. If the attribute is "
#~ "already set the decorator does nothing."
#~ " It is assumed that the first "
#~ "positional argument to the wrapped "
#~ "method (i.e. ``self``) is what "
#~ ":attr:`__loader__` should be set to."
#~ msgstr ""
#~ "반환된 모듈에서 :attr:`__loader__` 어트리뷰트를 설정하기 "
#~ "위한 :meth:`importlib.abc.Loader.load_module` 용 "
#~ ":term:`데코레이터 <decorator>`. 어트리뷰트가 이미 설정되어 "
#~ "있으면 데코레이터는 아무것도 하지 않습니다. 래핑 된 "
#~ "메서드에 대한 첫 번째 위치 인자(즉, ``self``)가"
#~ " :attr:`__loader__`\\가 설정되어야 하는 것으로 가정합니다."

#~ msgid ""
#~ "Set ``__loader__`` if set to ``None``,"
#~ " as if the attribute does not "
#~ "exist."
#~ msgstr "어트리뷰트가 존재하지 않는 것처럼, ``None``\\으로 설정되었으면 ``__loader__``\\를 설정합니다."

#~ msgid "The import machinery takes care of this automatically."
#~ msgstr "임포트 절차는 이것을 자동으로 처리합니다."

#~ msgid ""
#~ "A :term:`decorator` for "
#~ ":meth:`importlib.abc.Loader.load_module` to set the"
#~ " :attr:`__package__` attribute on the "
#~ "returned module. If :attr:`__package__` is "
#~ "set and has a value other than "
#~ "``None`` it will not be changed."
#~ msgstr ""
#~ "반환된 모듈에서 :attr:`__package__` 어트리뷰트를 설정하기 "
#~ "위한 :meth:`importlib.abc.Loader.load_module` 용 "
#~ ":term:`데코레이터 <decorator>`. :attr:`__package__`\\가 "
#~ "설정되었고 ``None`` 이외의 값을 가지면 변경되지 "
#~ "않습니다."

