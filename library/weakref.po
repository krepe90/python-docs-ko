# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/weakref.rst:4
msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- 약한 참조"

#: ../../library/weakref.rst:14
msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**소스 코드:** :source:`Lib/weakref.py`"

#: ../../library/weakref.rst:18
msgid ""
"The :mod:`weakref` module allows the Python programmer to create "
":dfn:`weak references` to objects."
msgstr ""
":mod:`weakref` 모듈은 파이썬 프로그래머가 객체에 대한 :dfn:`약한 참조 (weak references)`\\를 만들"
" 수 있도록 합니다."

#: ../../library/weakref.rst:24
msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr "이하에서, 용어 :dfn:`참조대상(referent)`\\은 약한 참조로 참조되는 객체를 의미합니다."

#: ../../library/weakref.rst:27
msgid ""
"A weak reference to an object is not enough to keep the object alive: "
"when the only remaining references to a referent are weak references, "
":term:`garbage collection` is free to destroy the referent and reuse its "
"memory for something else.  However, until the object is actually "
"destroyed the weak reference may return the object even if there are no "
"strong references to it."
msgstr ""
"객체에 대한 약한 참조만으로는 객체를 살아있게 유지할 수 없습니다: 참조대상에 대한 유일한 남은 참조가 약한 참조면, "
":term:`가비지 수거 <garbage collection>`\\는 자유롭게 참조대상을 파괴하고 메모리를 다른 용도로 재사용할 수"
" 있습니다. 그러나 객체가 실제로 파괴될 때까지 약한 참조는 강한 참조가 없어도 객체를 반환할 수 있습니다."

#: ../../library/weakref.rst:33
msgid ""
"A primary use for weak references is to implement caches or mappings "
"holding large objects, where it's desired that a large object not be kept"
" alive solely because it appears in a cache or mapping."
msgstr ""
"약한 참조의 주요 용도는 큰 객체를 보유하는 캐시나 매핑을 구현하는 것입니다. 큰 객체는 캐시나 매핑에 등장한다는 이유만으로 살아 "
"있지 않아야 합니다."

#: ../../library/weakref.rst:37
msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to "
"map names to images, or images to names, the image objects would remain "
"alive just because they appeared as values or keys in the dictionaries.  "
"The :class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes "
"supplied by the :mod:`weakref` module are an alternative, using weak "
"references to construct mappings that don't keep objects alive solely "
"because they appear in the mapping objects.  If, for example, an image "
"object is a value in a :class:`WeakValueDictionary`, then when the last "
"remaining references to that image object are the weak references held by"
" weak mappings, garbage collection can reclaim the object, and its "
"corresponding entries in weak mappings are simply deleted."
msgstr ""
"예를 들어, 큰 바이너리 이미지 객체가 여러 개 있을 때, 이름을 각 객체와 연관 지을 수 있습니다. 파이썬 딕셔너리를 사용하여 "
"이름을 이미지에 매핑하거나 이미지를 이름에 매핑하면, 이미지 객체는 딕셔너리에 값이나 키로 등장하기 때문에 계속 살아있게 됩니다. "
":mod:`weakref` 모듈에서 제공하는 :class:`WeakKeyDictionary`\\와 "
":class:`WeakValueDictionary` 클래스는 대안이며, 약한 참조를 사용하여 매핑을 구축하기 때문에 매핑 객체에 "
"등장한다는 이유만으로 객체를 살려두지 않습니다. 예를 들어 이미지 객체가 :class:`WeakValueDictionary` 의 "
"값이면, 해당 이미지 객체에 대한 마지막 남은 참조가 약한 매핑에 들어 있는 약한 참조이면, 가비지 수거는 객체를 회수할 수 "
"있으며, 약한 매핑의 해당 항목은 간단히 삭제됩니다."

#: ../../library/weakref.rst:50
msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has"
" been reclaimed by garbage collection.  :class:`WeakSet` implements the "
":class:`set` interface, but keeps weak references to its elements, just "
"like a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary`\\와 :class:`WeakValueDictionary`\\는 구현에 약한 참조를 "
"사용하여, 가비지 수거에서 키나 값이 회수될 때, 약한 딕셔너리에 알리는 약한 참조에 대한 콜백 함수를 설정합니다. "
":class:`WeakSet`\\은 :class:`set` 인터페이스를 구현하지만, :class:`WeakKeyDictionary`"
" 처럼 원소에 대한 약한 참조를 유지합니다."

#: ../../library/weakref.rst:57
msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is "
"simpler to use than setting up a callback function on a raw weak "
"reference, since the module automatically ensures that the finalizer "
"remains alive until the object is collected."
msgstr ""
":class:`finalize`\\는 객체가 가비지 수거될 때 호출될 정리 함수를 등록하는 간단한 방법을 제공합니다. 이 모듈은 "
"원시 약한 참조에 콜백 함수를 설정하는 것보다 사용하기가 더 쉽습니다. 모듈은 객체가 수거될 때까지 자동으로 파이널라이저가 활성 "
"상태로 유지되도록 하기 때문입니다."

#: ../../library/weakref.rst:63
msgid ""
"Most programs should find that using one of these weak container types or"
" :class:`finalize` is all they need -- it's not usually necessary to "
"create your own weak references directly.  The low-level machinery is "
"exposed by the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"대부분의 프로그램은 이러한 약한 컨테이너형이나 :class:`finalize`\\를 사용하는 것으로 충분합니다 -- 일반적으로 "
"여러분 스스로 약한 참조를 직접 만들 필요는 없습니다. 저수준 장치는 고급 용도를 위해 :mod:`weakref` 모듈이 "
"노출합니다."

#: ../../library/weakref.rst:68
msgid ""
"Not all objects can be weakly referenced. Objects which support weak "
"references include class instances, functions written in Python (but not "
"in C), instance methods, sets, frozensets, some :term:`file objects <file"
" object>`, :term:`generators <generator>`, type objects, sockets, arrays,"
" deques, regular expression pattern objects, and code objects."
msgstr ""
"모든 객체를 약하게 참조할 수 있는 것은 아닙니다. 약한 참조를 지원하는 객체에는 클래스 인스턴스, 파이썬으로 작성된 함수 (C로 "
"작성된 함수는 아닙니다), 인스턴스 메서드, 집합, 불변 집합(frozenset), 일부 :term:`파일 객체 <file "
"object>`, :term:`제너레이터 <generator>`, 형 객체, 소켓, 배열, 데크(deque), 정규식 패턴 객체 및"
" 코드 객체가 포함됩니다."

#: ../../library/weakref.rst:74
msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "thread.lock, threading.Lock 및 코드 객체에 대한 지원이 추가되었습니다."

#: ../../library/weakref.rst:77
msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through "
"subclassing::"
msgstr ""
":class:`list`\\와 :class:`dict`\\와 같은 여러 내장형은 약한 참조를 직접 지원하지 않지만, 서브 클래싱을 "
"통해 지원을 추가할 수 있습니다::"

#: ../../library/weakref.rst:80
msgid ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # this object is weak referenceable"
msgstr ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # 이 객체는 약한 참조할 수 있습니다"

#: ../../library/weakref.rst:87
msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not "
"support weak references even when subclassed."
msgstr ":class:`tuple`\\과 :class:`int`\\와 같은 다른 내장형은 서브 클래싱 될 때도 약한 참조를 지원하지 않습니다."

#: ../../library/weakref.rst:90
msgid ""
"Extension types can easily be made to support weak references; see :ref"
":`weakref-support`."
msgstr "확장형은 쉽게 약한 참조를 지원하도록 만들 수 있습니다; :ref:`weakref-support`\\을 참조하십시오."

#: ../../library/weakref.rst:93
msgid ""
"When ``__slots__`` are defined for a given type, weak reference support "
"is disabled unless a ``'__weakref__'`` string is also present in the "
"sequence of strings in the ``__slots__`` declaration. See :ref:`__slots__"
" documentation <slots>` for details."
msgstr ""

#: ../../library/weakref.rst:100
msgid ""
"Return a weak reference to *object*.  The original object can be "
"retrieved by calling the reference object if the referent is still alive;"
" if the referent is no longer alive, calling the reference object will "
"cause :const:`None` to be returned.  If *callback* is provided and not "
":const:`None`, and the returned weakref object is still alive, the "
"callback will be called when the object is about to be finalized; the "
"weak reference object will be passed as the only parameter to the "
"callback; the referent will no longer be available."
msgstr ""
"*object*\\에 대한 약한 참조를 반환합니다. 참조대상이 아직 살아있으면 참조 객체를 호출하여 원래 객체를 얻을 수 있습니다."
" 참조대상이 더는 존재하지 않으면 참조 객체를 호출할 때 :const:`None`\\이 반환됩니다. :const:`None`\\이 "
"아닌 *callback*\\이 제공되고, 반환된 약한 참조 객체가 여전히 살아있으면, 객체가 파이널라이즈 되려고 할 때 콜백이 "
"호출됩니다; 약한 참조 객체는 콜백에 유일한 매개 변수로 전달됩니다; 참조대상은 더는 사용할 수 없습니다."

#: ../../library/weakref.rst:108
msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from "
"the most recently registered callback to the oldest registered callback."
msgstr ""
"같은 객체에 대해 여러 개의 약한 참조를 구성할 수 있습니다. 각 약한 참조에 등록된 콜백은 가장 최근에 등록된 콜백에서 가장 "
"오래전에 등록된 콜백 순으로 호출됩니다."

#: ../../library/weakref.rst:112
msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same "
"way as exceptions raised from an object's :meth:`~object.__del__` method."
msgstr ""
"콜백에 의해 발생한 예외는 표준 에러 출력에 표시되지만, 전파될 수는 없습니다; 객체의 :meth:`~object.__del__` "
"메서드에서 발생한 예외와 정확히 같은 방식으로 처리됩니다."

#: ../../library/weakref.rst:116
msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They "
"will maintain their hash value even after the *object* was deleted.  If "
":func:`hash` is called the first time only after the *object* was "
"deleted, the call will raise :exc:`TypeError`."
msgstr ""
"약한 참조는 *object*\\가 해시 가능하면 :term:`해시 가능 <hashable>`\\입니다. *object*\\가 삭제된"
" 후에도 해시값을 유지합니다. 오직 *object*\\가 삭제된 후에 :func:`hash`\\를 처음 호출하면, 호출은 "
":exc:`TypeError`\\를 발생시킵니다."

#: ../../library/weakref.rst:121
msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If "
"either referent has been deleted, the references are equal only if the "
"reference objects are the same object."
msgstr ""
"약한 참조는 동등 검사를 지원하지만, 순서는 지원하지 않습니다. 참조대상이 여전히 살아 있다면, 두 참조는 "
"(*callback*\\과 관계없이) 참조대상과 같은 동등 관계를 갖습니다. 참조대상이 삭제되었으면, 참조 객체가 같은 객체일 때만"
" 참조가 같습니다."

#: ../../library/weakref.rst:126
msgid "This is a subclassable type rather than a factory function."
msgstr "이것은 팩토리 함수가 아니라 서브 클래싱 할 수 있는 형입니다."

#: ../../library/weakref.rst:130
msgid ""
"This read-only attribute returns the callback currently associated to the"
" weakref.  If there is no callback or if the referent of the weakref is "
"no longer alive then this attribute will have value ``None``."
msgstr ""
"이 읽기 전용 어트리뷰트는 현재 약한 참조와 연관된 콜백을 반환합니다. 콜백이 없거나 약한 참조의 참조대상이 더는 살아있지 않으면 "
"이 어트리뷰트의 값은 ``None``\\이 됩니다."

#: ../../library/weakref.rst:134
msgid "Added the :attr:`__callback__` attribute."
msgstr ":attr:`__callback__` 어트리뷰트를 추가했습니다."

#: ../../library/weakref.rst:140
msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports "
"use of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will"
" have a type of either ``ProxyType`` or ``CallableProxyType``, depending "
"on whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevents their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the "
":func:`ref` function."
msgstr ""
"*object*\\로의 약한 참조를 사용하는 프락시를 반환합니다. 이는 약한 참조 객체에서 사용되는 명시적 역참조를 요구하는 대신 "
"대부분의 문맥에서 프락시의 사용을 지원합니다. 반환된 객체는 *object*\\가 콜러블인지에 따라 ``ProxyType``\\이나"
" ``CallableProxyType`` 형을 갖습니다. 프락시 객체는 참조대상에 관계없이 :term:`해시 가능 "
"<hashable>`\\하지 않습니다; 이것은 그들의 근본적인 가변 특성과 관련된 여러 가지 문제를 피하고, 딕셔너리 키로 사용하는"
" 것을 방지합니다. *callback*\\은 :func:`ref` 함수의 같은 이름의 매개 변수와 같습니다."

#: ../../library/weakref.rst:149
msgid ""
"Accessing an attribute of the proxy object after the referent is garbage "
"collected raises :exc:`ReferenceError`."
msgstr ""

#: ../../library/weakref.rst:152
msgid ""
"Extended the operator support on proxy objects to include the matrix "
"multiplication operators ``@`` and ``@=``."
msgstr "행렬 곱셈 연산자 ``@``\\와 ``@=``\\을 포함하도록 프락시 객체에 대한 연산자 지원을 확장했습니다."

#: ../../library/weakref.rst:159
msgid "Return the number of weak references and proxies which refer to *object*."
msgstr "*object*\\를 참조하는 약한 참조와 프락시의 개수를 반환합니다."

#: ../../library/weakref.rst:164
msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr "*object*\\를 참조하는 모든 약한 참조와 프락시 객체의 리스트를 반환합니다."

#: ../../library/weakref.rst:169
msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary "
"will be discarded when there is no longer a strong reference to the key."
"  This can be used to associate additional data with an object owned by "
"other parts of an application without adding attributes to those objects."
"  This can be especially useful with objects that override attribute "
"accesses."
msgstr ""
"키를 약하게 참조하는 매핑 클래스. 더는 키에 대한 강한 참조가 없으면 딕셔너리의 항목이 삭제됩니다. 이것은 응용 프로그램의 다른 "
"부분이 소유한 객체에 어트리뷰트를 추가하지 않고도 추가 데이터를 연결하는 데 사용될 수 있습니다. 어트리뷰트 액세스를 재정의하는 "
"객체에 특히 유용할 수 있습니다."

#: ../../library/weakref.rst:175
msgid ""
"Note that when a key with equal value to an existing key (but not equal "
"identity) is inserted into the dictionary, it replaces the value but does"
" not replace the existing key. Due to this, when the reference to the "
"original key is deleted, it also deletes the entry in the dictionary::"
msgstr ""

#: ../../library/weakref.rst:180
#, python-brace-format
msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"

#: ../../library/weakref.rst:188
msgid "A workaround would be to remove the key prior to reassignment::"
msgstr ""

#: ../../library/weakref.rst:190
#, python-brace-format
msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"

#: ../../library/weakref.rst:199 ../../library/weakref.rst:220
msgid "Added support for ``|`` and ``|=`` operators, as specified in :pep:`584`."
msgstr ":pep:`584`\\에 지정된 대로, ``|``\\와 ``|=`` 연산자에 대한 지원이 추가되었습니다."

#: ../../library/weakref.rst:202
msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes"
" the internal references directly.  The references are not guaranteed to "
"be \"live\" at the time they are used, so the result of calling the "
"references needs to be checked before being used.  This can be used to "
"avoid creating references that will cause the garbage collector to keep "
"the keys around longer than needed."
msgstr ""
":class:`WeakKeyDictionary` 객체에는 내부 참조를 직접 노출하는 추가 메서드가 있습니다. 참조는 사용되는 시점에"
" \"살아있다고\" 보장되지 않아서, 참조를 호출한 결과를 사용하기 전에 확인해야 합니다. 가비지 수거기가 키를 필요 이상으로 길게"
" 유지하도록 하는 참조를 만들지 않도록 하는 데 사용할 수 있습니다."

#: ../../library/weakref.rst:212
msgid "Return an iterable of the weak references to the keys."
msgstr "키에 대한 약한 참조의 이터러블을 반환합니다."

#: ../../library/weakref.rst:217
msgid ""
"Mapping class that references values weakly.  Entries in the dictionary "
"will be discarded when no strong reference to the value exists any more."
msgstr "값을 약하게 참조하는 매핑 클래스. 값에 대한 강한 참조가 더는 존재하지 않을 때 딕셔너리의 항목이 삭제됩니다."

#: ../../library/weakref.rst:223
msgid ""
":class:`WeakValueDictionary` objects have an additional method that has "
"the same issues as the :meth:`WeakKeyDictionary.keyrefs` method."
msgstr ""
":class:`WeakValueDictionary` 객체에는 :class:`WeakKeyDictionary.keyrefs` 메서드와"
" 같은 문제가 있는 추가 메서드가 있습니다."

#: ../../library/weakref.rst:229
msgid "Return an iterable of the weak references to the values."
msgstr "값에 대한 약한 참조의 이터러블을 반환합니다."

#: ../../library/weakref.rst:234
msgid ""
"Set class that keeps weak references to its elements.  An element will be"
" discarded when no strong reference to it exists any more."
msgstr "원소에 대한 약한 참조를 유지하는 집합 클래스. 원소에 대한 강한 참조가 더는 존재하지 않을 때 원소가 삭제됩니다."

#: ../../library/weakref.rst:240
msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a "
"bound method (i.e., a method defined on a class and looked up on an "
"instance). Since a bound method is ephemeral, a standard weak reference "
"cannot keep hold of it.  :class:`WeakMethod` has special code to recreate"
" the bound method until either the object or the original function dies::"
msgstr ""
"연결된 메서드(즉, 클래스에 정의되고 인스턴스에서 조회된 메서드)에 대한 약한 참조를 시뮬레이트 하는 사용자 지정 "
":class:`ref` 서브 클래스. 연결된 메서드는 일시적이므로, 표준 약한 참조는 유지할 수 없습니다. "
":class:`WeakMethod`\\에는 객체나 원래 함수가 죽을 때까지 연결된 메서드를 다시 만드는 특별한 코드가 있습니다::"

#: ../../library/weakref.rst:246
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"

#: ../../library/weakref.rst:264
msgid ""
"*callback* is the same as the parameter of the same name to the "
":func:`ref` function."
msgstr ""

#: ../../library/weakref.rst:270
msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly "
"simplifying lifecycle management."
msgstr ""
"*obj*\\가 가비지 수거될 때 호출되는 콜러블 파이널라이저 객체를 반환합니다. 일반적인 약한 참조와 달리, 파이널라이저는 참조 "
"객체가 수집될 때까지 항상 생존하므로, 수명 주기 관리가 크게 간소화됩니다."

#: ../../library/weakref.rst:275
msgid ""
"A finalizer is considered *alive* until it is called (either explicitly "
"or at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, "
"whereas calling a dead finalizer returns :const:`None`."
msgstr ""
"파이널라이저는 (명시적으로나 가비지 수거에서) 호출될 때까지 *살아있다고* 간주하며, 그 후 *죽습니다*. 살아있는 파이널라이저를 "
"호출하면 ``func(*arg, **kwargs)``\\를 평가한 결과가 반환되고, 죽은 파이널라이저를 호출하면 "
":const:`None`\\이 반환됩니다."

#: ../../library/weakref.rst:280
msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will "
"be shown on the standard error output, but cannot be propagated.  They "
"are handled in the same way as exceptions raised from an object's "
":meth:`~object.__del__` method or a weak reference's callback."
msgstr ""
"가비지 수거 중에 파이널라이저 콜백에서 발생한 예외는 표준 에러 출력에 표시되지만, 전파할 수는 없습니다. 객체의 "
":meth:`~object.__del__` 메서드나 약한 참조의 콜백에서 발생하는 예외와 같은 방식으로 처리됩니다."

#: ../../library/weakref.rst:286
msgid ""
"When the program exits, each remaining live finalizer is called unless "
"its :attr:`atexit` attribute has been set to false.  They are called in "
"reverse order of creation."
msgstr ""
"프로그램이 종료될 때, :attr:`atexit` 어트리뷰트가 거짓으로 설정되지 않은 한 각 남은 살아있는 파이널라이저가 "
"호출됩니다. 만들어진 순서와 반대 순서로 호출됩니다."

#: ../../library/weakref.rst:290
msgid ""
"A finalizer will never invoke its callback during the later part of the "
":term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr ""
"모듈 전역이 :const:`None`\\으로 교체된 경우 :term:`인터프리터 종료 <interpreter "
"shutdown>`\\의 후반 동안에는 파이널라이저가 콜백을 호출하지 않습니다."

#: ../../library/weakref.rst:296
msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"*self*\\가 살아 있으면 이를 죽은 것으로 표시하고 ``func(*args, **kwargs)`` 호출 결과를 반환합니다. "
"*self*\\가 죽었으면 :const:`None`\\을 반환합니다."

#: ../../library/weakref.rst:302
msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, "
"func, args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"*self*\\가 살아 있으면 이를 죽은 것으로 표시하고 튜플 ``(obj, func, args, kwargs)``\\를 "
"반환합니다. *self*\\가 죽었으면 :const:`None`\\을 반환합니다."

#: ../../library/weakref.rst:308
msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  "
"If *self* is dead then return :const:`None`."
msgstr ""
"*self*\\가 살아 있으면 튜플 ``(obj, func, args, kwargs)``\\를 반환합니다. *self*\\가 "
"죽었으면 :const:`None`\\을 반환합니다."

#: ../../library/weakref.rst:313
msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr "파이널라이저가 살아 있으면 참이고, 그렇지 않으면 거짓인 프로퍼티."

#: ../../library/weakref.rst:317
msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` "
"is true.  They are called in reverse order of creation."
msgstr ""
"기본값이 참인, 쓰기 가능한 불리언 프로퍼티. 프로그램이 종료할 때, :attr:`.atexit`\\가 참인 남은 모든 살아있는 "
"파이널라이저를 호출합니다. 그것들은 만들어진 순서와 반대 순서로 호출됩니다."

#: ../../library/weakref.rst:324
msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any"
" references to *obj*, either directly or indirectly, since otherwise "
"*obj* will never be garbage collected.  In particular, *func* should not "
"be a bound method of *obj*."
msgstr ""
"*func*, *args* 및 *kwargs*\\가 직접이나 간접적으로 *obj*\\에 대한 참조를 소유하지 않는 것이 중요합니다."
" 그렇지 않으면 *obj*\\는 가비지 수거되지 않습니다. 특히, *func*\\는 *obj*\\의 연결된 메서드가 아니어야 "
"합니다."

#: ../../library/weakref.rst:334
msgid "The type object for weak references objects."
msgstr "약한 참조 객체의 형 객체."

#: ../../library/weakref.rst:339
msgid "The type object for proxies of objects which are not callable."
msgstr "콜러블이 아닌 객체의 프락시를 위한 형 객체."

#: ../../library/weakref.rst:344
msgid "The type object for proxies of callable objects."
msgstr "콜러블 객체의 프락시를 위한 형 객체."

#: ../../library/weakref.rst:349
msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming"
" both proxy types."
msgstr ""
"프락시의 모든 형 객체를 포함하는 시퀀스. 이것은 두 프락시 형 모두의 이름 지정에 의존하지 않고 객체가 프락시인지 검사하기 더 "
"쉽게 만들 수 있습니다."

#: ../../library/weakref.rst:356
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 약한 참조"

#: ../../library/weakref.rst:357
msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other "
"languages."
msgstr "이전 구현에 대한 링크와 다른 언어의 유사한 기능에 대한 정보를 포함하는, 이 기능에 대한 제안과 근거."

#: ../../library/weakref.rst:364
msgid "Weak Reference Objects"
msgstr "약한 참조 객체"

#: ../../library/weakref.rst:366
msgid ""
"Weak reference objects have no methods and no attributes besides "
":attr:`ref.__callback__`. A weak reference object allows the referent to "
"be obtained, if it still exists, by calling it:"
msgstr ""
"약한 참조 객체에는 :attr:`ref.__callback__` 외에 메서드와 어트리뷰트가 없습니다. 약한 참조 객체는 참조대상이 "
"아직 존재한다면 호출함으로써 얻을 수 있도록 합니다:"

#: ../../library/weakref.rst:380
msgid ""
"If the referent no longer exists, calling the reference object returns "
":const:`None`:"
msgstr "참조대상이 더는 존재하지 않을 때, 참조 객체를 호출하면 :const:`None`\\을 반환합니다:"

#: ../../library/weakref.rst:387
msgid ""
"Testing that a weak reference object is still live should be done using "
"the expression ``ref() is not None``.  Normally, application code that "
"needs to use a reference object should follow this pattern::"
msgstr ""
"약한 참조 객체가 여전히 살아있는지를 검사하는 것은 ``ref() is not None`` 표현식을 사용하여 수행해야 합니다. "
"일반적으로, 참조 객체를 사용할 필요가 있는 응용 프로그램 코드는 다음 패턴을 따라야 합니다::"

#: ../../library/weakref.rst:391
msgid ""
"# r is a weak reference object\n"
"o = r()\n"
"if o is None:\n"
"    # referent has been garbage collected\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"
msgstr ""
"# r은 약한 참조 객체입니다\n"
"o = r()\n"
"if o is None:\n"
"    # 참조대상이 가비지 수거되었습니다\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"

#: ../../library/weakref.rst:400
msgid ""
"Using a separate test for \"liveness\" creates race conditions in "
"threaded applications; another thread can cause a weak reference to "
"become invalidated before the weak reference is called; the idiom shown "
"above is safe in threaded applications as well as single-threaded "
"applications."
msgstr ""
"\"생존\"에 대해 별도의 검사를 사용하면 스레드 응용 프로그램에서 경쟁 조건이 발생합니다; 약한 참조가 호출되기 전에 다른 "
"스레드가 약한 참조를 무효화 할 수 있습니다; 위에 표시된 관용구는 단일 스레드 응용 프로그램뿐만 아니라 다중 스레드 응용 "
"프로그램에서도 안전합니다."

#: ../../library/weakref.rst:405
msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the "
":class:`WeakValueDictionary` to reduce the memory overhead for each entry"
" in the mapping.  This may be most useful to associate additional "
"information with a reference, but could also be used to insert additional"
" processing on calls to retrieve the referent."
msgstr ""
"서브 클래싱을 통해 :class:`ref` 객체의 특수한 버전을 만들 수 있습니다. 이는 "
":class:`WeakValueDictionary` 구현에 사용되어 매핑의 각 항목에 대한 메모리 오버헤드를 줄입니다. 이는 추가 "
"정보를 참조와 연관시키는 데 가장 유용 할 수 있지만, 참조대상을 꺼내기 위한 호출에 추가 처리를 삽입하는 데 사용될 수도 "
"있습니다."

#: ../../library/weakref.rst:411
msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's "
"returned when the referent is accessed::"
msgstr ""
"이 예제는 :class:`ref`\\의 서브 클래스를 사용하여 객체에 대한 추가 정보를 저장하고 참조대상에 액세스할 때 반환되는 "
"값에 영향을 주는 방법을 보여줍니다::"

#: ../../library/weakref.rst:415
msgid ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"Return a pair containing the referent and the number of\n"
"        times the reference has been called.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"
msgstr ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"참조대상과 참조가 호출된 횟수를 포함하는 쌍을 반환합니다.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"

#: ../../library/weakref.rst:438
msgid "Example"
msgstr "예"

#: ../../library/weakref.rst:440
msgid ""
"This simple example shows how an application can use object IDs to "
"retrieve objects that it has seen before.  The IDs of the objects can "
"then be used in other data structures without forcing the objects to "
"remain alive, but the objects can still be retrieved by ID if they do."
msgstr ""
"이 간단한 예제는 응용 프로그램이 객체 ID를 사용하여 이전에 본 객체를 조회하는 방법을 보여줍니다. 그런 다음 객체를 강제로 "
"살아있도록 하지 않으면서 다른 자료 구조에서 객체의 ID를 사용할 수 있지만, 살아있다면 객체를 여전히 ID로 조회할 수 있습니다."

#: ../../library/weakref.rst:449
msgid ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"
msgstr ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"

#: ../../library/weakref.rst:465
msgid "Finalizer Objects"
msgstr "파이널라이저 객체"

#: ../../library/weakref.rst:467
msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to"
" register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr ""
":class:`finalize`\\를 사용해서 얻을 수 있는 주요 이점은 반환된 파이널라이저 객체를 보존할 필요 없이 콜백을 "
"간단하게 등록할 수 있다는 것입니다. 예를 들어"

#: ../../library/weakref.rst:481
msgid ""
"The finalizer can be called directly as well.  However the finalizer will"
" invoke the callback at most once."
msgstr "파이널라이저를 직접 호출할 수도 있습니다. 그러나 파이널라이저는 콜백을 최대 한 번 호출합니다."

#: ../../library/weakref.rst:497
msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method."
"  This kills the finalizer and returns the arguments passed to the "
"constructor when it was created."
msgstr ""
":meth:`~finalize.detach` 메서드를 사용하여 파이널라이저를 등록 취소할 수 있습니다. 그러면 파이널라이저를 죽이고"
" 만들어질 때 생성자에 전달된 인자가 반환됩니다."

#: ../../library/weakref.rst:511
msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, "
"a finalizer will be called when the program exits if it is still alive.  "
"For instance"
msgstr ""
":attr:`~finalize.atexit` 어트리뷰트를 :const:`False`\\로 설정하지 않는 한, 파이널라이저가 "
"살아있다면 프로그램이 종료될 때 호출됩니다. 예를 들어"

#: ../../library/weakref.rst:515
msgid ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"
msgstr ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"

#: ../../library/weakref.rst:526
msgid "Comparing finalizers with :meth:`~object.__del__` methods"
msgstr "파이널라이저와 :meth:`~object.__del__` 메서드의 비교"

#: ../../library/weakref.rst:528
msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when "
"the first of the following events occurs:"
msgstr ""
"인스턴스가 임시 디렉터리를 나타내는 클래스를 만들고 싶다고 가정하십시오. 다음 이벤트 중 첫 번째 것이 발생할 때 디렉터리는 내용과"
" 함께 삭제되어야 합니다:"

#: ../../library/weakref.rst:532
msgid "the object is garbage collected,"
msgstr "객체가 가비지 수거됩니다,"

#: ../../library/weakref.rst:533
msgid "the object's :meth:`!remove` method is called, or"
msgstr "객체의 :meth:`!remove` 메서드가 호출됩니다, 또는"

#: ../../library/weakref.rst:534
msgid "the program exits."
msgstr "프로그램이 종료합니다."

#: ../../library/weakref.rst:536
msgid ""
"We might try to implement the class using a :meth:`~object.__del__` "
"method as follows::"
msgstr "다음과 같이 :meth:`~object.__del__` 메서드를 사용하여 클래스를 구현하려고 시도할 수 있습니다::"

#: ../../library/weakref.rst:539
msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"

#: ../../library/weakref.rst:555
msgid ""
"Starting with Python 3.4, :meth:`~object.__del__` methods no longer "
"prevent reference cycles from being garbage collected, and module globals"
" are no longer forced to :const:`None` during :term:`interpreter "
"shutdown`. So this code should work without any issues on CPython."
msgstr ""
"파이썬 3.4부터, :meth:`~object.__del__` 메서드는 더는 참조 순환이 가비지 수거되는 것을 막지 않으며, "
":term:`인터프리터 종료 <interpreter shutdown>` 중에 모듈 전역이 더는 :const:`None`\\으로 "
"강제되지 않습니다. 따라서 이 코드는 CPython에서 아무런 문제 없이 작동해야 합니다."

#: ../../library/weakref.rst:560
msgid ""
"However, handling of :meth:`~object.__del__` methods is notoriously "
"implementation specific, since it depends on internal details of the "
"interpreter's garbage collector implementation."
msgstr ""
"그러나, :meth:`~object.__del__` 메서드의 처리는 인터프리터의 가비지 수거기 구현에 대한 내부 세부 사항에 "
"의존하기 때문에 구현에 따라 다르기로 악명 높습니다."

#: ../../library/weakref.rst:564
msgid ""
"A more robust alternative can be to define a finalizer which only "
"references the specific functions and objects that it needs, rather than "
"having access to the full state of the object::"
msgstr "더욱 강인한 대안은 객체의 전체 상태에 액세스하기보다 필요한 특정 함수와 객체만 참조하는 파이널라이저를 정의하는 것일 수 있습니다::"

#: ../../library/weakref.rst:568
msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, "
"self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, "
"self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"

#: ../../library/weakref.rst:580
msgid ""
"Defined like this, our finalizer only receives a reference to the details"
" it needs to clean up the directory appropriately. If the object never "
"gets garbage collected the finalizer will still be called at exit."
msgstr ""
"이처럼 정의된 파이널라이저는 디렉터리를 적절히 정리하는 데 필요한 세부 사항에 대한 참조만 받습니다. 객체가 가비지 수거되지 않으면"
" 종료 시에 파이널라이저는 여전히 호출됩니다."

#: ../../library/weakref.rst:584
msgid ""
"The other advantage of weakref based finalizers is that they can be used "
"to register finalizers for classes where the definition is controlled by "
"a third party, such as running code when a module is unloaded::"
msgstr ""
"약한 참조 기반 파이널라이저의 다른 장점은 제삼자가 정의를 제어하는 클래스에 대해 파이널라이저를 등록하는 데 사용할 수 있다는 "
"것입니다, 가령 모듈이 언로드 될 때 코드 실행하기::"

#: ../../library/weakref.rst:588
msgid ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # implicit reference to the module globals from the function body\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"
msgstr ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # 함수 바디에서 모듈 전역으로의 묵시적 참조\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"

#: ../../library/weakref.rst:596
msgid ""
"If you create a finalizer object in a daemonic thread just as the program"
" exits then there is the possibility that the finalizer does not get "
"called at exit.  However, in a daemonic thread :func:`atexit.register`, "
"``try: ... finally: ...`` and ``with: ...`` do not guarantee that cleanup"
" occurs either."
msgstr ""
"프로그램이 종료될 때 데몬 스레드에서 파이널라이저 객체를 만들면 종료 시에 파이널라이저가 호출되지 않을 가능성이 있습니다. 그러나,"
" 데몬 스레드 :func:`atexit.register`\\에서, ``try: ... finally: ...``\\와 ``with:"
" ...``\\는 정리가 발생한다고 보장하지 않습니다."

#~ msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
#~ msgstr ":pep:`584`\\에 지정된, ``|``\\와 ``|=`` 연산자에 대한 지원이 추가되었습니다."

