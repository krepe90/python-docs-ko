# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/operator.rst:2
msgid ":mod:`!operator` --- Standard operators as functions"
msgstr ":mod:`!operator` --- 함수로서의 표준 연산자"

#: ../../library/operator.rst:9
msgid "**Source code:** :source:`Lib/operator.py`"
msgstr "**소스 코드:** :source:`Lib/operator.py`"

#: ../../library/operator.rst:18
msgid ""
"The :mod:`operator` module exports a set of efficient functions "
"corresponding to the intrinsic operators of Python.  For example, "
"``operator.add(x, y)`` is equivalent to the expression ``x+y``. Many "
"function names are those used for special methods, without the double "
"underscores.  For backward compatibility, many of these have a variant "
"with the double underscores kept. The variants without the double "
"underscores are preferred for clarity."
msgstr ""
":mod:`operator` 모듈은 파이썬의 내장 연산자에 해당하는 효율적인 함수 집합을 내보냅니다. 예를 들어, "
"``operator.add(x, y)``\\는 ``x+y`` 표현식과 동등합니다. 많은 함수 이름은 특수 메서드에 사용되는 "
"이름인데, 이중 밑줄이 없습니다. 이전 버전과의 호환성을 위해, 이들 중 많은 것은 이중 밑줄이 있는 변형을 가집니다. 이중 밑줄이"
" 없는 변형이 명확성을 위해 선호됩니다."

#: ../../library/operator.rst:25
msgid ""
"The functions fall into categories that perform object comparisons, "
"logical operations, mathematical operations and sequence operations."
msgstr "함수는 객체 비교, 논리 연산, 수학 연산 및 시퀀스 연산을 수행하는 범주로 분류됩니다."

#: ../../library/operator.rst:28
msgid ""
"The object comparison functions are useful for all objects, and are named"
" after the rich comparison operators they support:"
msgstr "객체 비교 함수는 모든 객체에 유용하며, 이들이 지원하는 풍부한 비교(rich comparison) 연산자의 이름을 따릅니다:"

#: ../../library/operator.rst:45
msgid ""
"Perform \"rich comparisons\" between *a* and *b*. Specifically, ``lt(a, "
"b)`` is equivalent to ``a < b``, ``le(a, b)`` is equivalent to ``a <= "
"b``, ``eq(a, b)`` is equivalent to ``a == b``, ``ne(a, b)`` is equivalent"
" to ``a != b``, ``gt(a, b)`` is equivalent to ``a > b`` and ``ge(a, b)`` "
"is equivalent to ``a >= b``.  Note that these functions can return any "
"value, which may or may not be interpretable as a Boolean value.  See "
":ref:`comparisons` for more information about rich comparisons."
msgstr ""
"*a*\\와 *b* 사이에 \"풍부한 비교(rich comparisons)\"를 수행합니다. 구체적으로, ``lt(a, "
"b)``\\는 ``a < b``\\와 동등하고, ``le(a, b)``\\는 ``a <= b``\\와 동등하고, ``eq(a, "
"b)``\\는 ``a == b``\\와 동등하고, ``ne(a, b)``\\는 ``a != b``\\와 동등하고, ``gt(a, "
"b)``\\는 ``a > b``\\와 동등하고, ``ge(a, b)``\\는 ``a >= b``\\와 동등합니다. 이러한 함수는 "
"불리언 값으로 해석 할 수도 있고, 그렇지 않을 수도 있는 임의의 값을 반환 할 수 있음에 유의하십시오. 풍부한 비교에 대한 자세한"
" 정보는 :ref:`comparisons`\\를 참조하십시오."

#: ../../library/operator.rst:54
msgid ""
"The logical operations are also generally applicable to all objects, and "
"support truth tests, identity tests, and boolean operations:"
msgstr "논리 연산도 일반적으로 모든 객체에 적용 할 수 있으며, 진릿값 검사, 아이덴티티 검사 및 불리언 연산을 지원합니다:"

#: ../../library/operator.rst:61
msgid ""
"Return the outcome of :keyword:`not` *obj*.  (Note that there is no "
":meth:`!__not__` method for object instances; only the interpreter core "
"defines this operation.  The result is affected by the "
":meth:`~object.__bool__` and :meth:`~object.__len__` methods.)"
msgstr ""
":keyword:`not` *obj*\\의 결과를 반환합니다. (객체 인스턴스에는 :meth:`!__not__` 메서드가 없음에 "
"유의하십시오; 인터프리터의 코어만이 이 연산을 정의합니다. 결과는 :meth:`~object.__bool__`\\과 "
":meth:`~object.__len__` 메서드의 영향을 받습니다.)"

#: ../../library/operator.rst:69
msgid ""
"Return :const:`True` if *obj* is true, and :const:`False` otherwise.  "
"This is equivalent to using the :class:`bool` constructor."
msgstr ""
"*obj*\\가 참이면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다. 이것은 "
":class:`bool` 생성자를 사용하는 것과 동등합니다."

#: ../../library/operator.rst:75
msgid "Return ``a is b``.  Tests object identity."
msgstr "``a is b``\\를 반환합니다. 객체 아이덴티티를 검사합니다."

#: ../../library/operator.rst:80
msgid "Return ``a is not b``.  Tests object identity."
msgstr "``a is not b``\\를 반환합니다. 객체 아이덴티티를 검사합니다."

#: ../../library/operator.rst:83
msgid "The mathematical and bitwise operations are the most numerous:"
msgstr "수학적 및 비트별 연산이 가장 많습니다:"

#: ../../library/operator.rst:89
msgid "Return the absolute value of *obj*."
msgstr "*obj*\\의 절댓값을 반환합니다."

#: ../../library/operator.rst:95
msgid "Return ``a + b``, for *a* and *b* numbers."
msgstr "*a*\\와 *b* 숫자에 대해, ``a + b``\\를 반환합니다."

#: ../../library/operator.rst:101
msgid "Return the bitwise and of *a* and *b*."
msgstr "*a*\\와 *b*\\의 비트별 논리곱(and)을 반환합니다."

#: ../../library/operator.rst:107
msgid "Return ``a // b``."
msgstr "``a // b``\\를 반환합니다."

#: ../../library/operator.rst:113
msgid "Return *a* converted to an integer.  Equivalent to ``a.__index__()``."
msgstr "정수로 변환된 *a*\\를 반환합니다. ``a.__index__()``\\와 동등합니다."

#: ../../library/operator.rst:115
msgid ""
"The result always has exact type :class:`int`.  Previously, the result "
"could have been an instance of a subclass of ``int``."
msgstr ""

#: ../../library/operator.rst:125
msgid ""
"Return the bitwise inverse of the number *obj*.  This is equivalent to "
"``~obj``."
msgstr "숫자 *obj*\\의 비트별 반전을 반환합니다. 이것은 ``~obj``\\와 동등합니다."

#: ../../library/operator.rst:131
msgid "Return *a* shifted left by *b*."
msgstr "*a*\\를 *b*\\만큼 왼쪽으로 시프트 한 값을 반환합니다."

#: ../../library/operator.rst:137
msgid "Return ``a % b``."
msgstr "``a % b``\\를 반환합니다."

#: ../../library/operator.rst:143
msgid "Return ``a * b``, for *a* and *b* numbers."
msgstr "*a*\\와 *b* 숫자에 대해, ``a * b``\\를 반환합니다."

#: ../../library/operator.rst:149
msgid "Return ``a @ b``."
msgstr "``a @ b``\\를 반환합니다."

#: ../../library/operator.rst:157
msgid "Return *obj* negated (``-obj``)."
msgstr "*obj*\\의 부정(``-obj``)을 반환합니다."

#: ../../library/operator.rst:163
msgid "Return the bitwise or of *a* and *b*."
msgstr "*a*\\와 *b*\\의 비트별 논리합(or)을 반환합니다."

#: ../../library/operator.rst:169
msgid "Return *obj* positive (``+obj``)."
msgstr "양의 *obj*\\(``+obj``)를 반환합니다."

#: ../../library/operator.rst:175
msgid "Return ``a ** b``, for *a* and *b* numbers."
msgstr "*a*\\와 *b* 숫자에 대해, ``a ** b``\\를 반환합니다."

#: ../../library/operator.rst:181
msgid "Return *a* shifted right by *b*."
msgstr "*a*\\를 *b*\\만큼 오른쪽으로 시프트 한 값을 반환합니다."

#: ../../library/operator.rst:187
msgid "Return ``a - b``."
msgstr "``a - b``\\를 반환합니다."

#: ../../library/operator.rst:193
msgid ""
"Return ``a / b`` where 2/3 is .66 rather than 0.  This is also known as "
"\"true\" division."
msgstr "``a / b``\\를 반환합니다. 여기서 2/3는 0이 아니라 .66입니다. 이것은 \"실수(true)\" 나누기라고 도합니다."

#: ../../library/operator.rst:200
msgid "Return the bitwise exclusive or of *a* and *b*."
msgstr "*a*\\와 *b*\\의 비트별 배타적 논리합을 반환합니다."

#: ../../library/operator.rst:203
msgid ""
"Operations which work with sequences (some of them with mappings too) "
"include:"
msgstr "시퀀스에 적용되는 연산(일부는 매핑에도 적용됩니다)은 다음과 같습니다:"

#: ../../library/operator.rst:208
msgid "Return ``a + b`` for *a* and *b* sequences."
msgstr "*a*\\와 *b* 시퀀스에 대해 ``a + b``\\를 반환합니다."

#: ../../library/operator.rst:214
msgid "Return the outcome of the test ``b in a``. Note the reversed operands."
msgstr "``b in a`` 검사의 결과를 반환합니다. 피연산자가 뒤집혀 있음에 유의하십시오."

#: ../../library/operator.rst:219
msgid "Return the number of occurrences of *b* in *a*."
msgstr "*a*\\에서 *b*\\가 발생하는 횟수를 반환합니다."

#: ../../library/operator.rst:225
msgid "Remove the value of *a* at index *b*."
msgstr "*a*\\의 값을 인덱스 *b*\\에서 제거합니다."

#: ../../library/operator.rst:231
msgid "Return the value of *a* at index *b*."
msgstr "인덱스 *b*\\에 있는 *a*\\의 값을 반환합니다."

#: ../../library/operator.rst:236
msgid "Return the index of the first of occurrence of *b* in *a*."
msgstr "*a*\\에서 *b*\\가 처음으로 발견되는 인덱스를 반환합니다."

#: ../../library/operator.rst:242
msgid "Set the value of *a* at index *b* to *c*."
msgstr "인덱스 *b*\\의 *a*\\의 값을 *c*\\로 설정합니다."

#: ../../library/operator.rst:247
msgid ""
"Return an estimated length for the object *obj*. First try to return its "
"actual length, then an estimate using :meth:`object.__length_hint__`, and"
" finally return the default value."
msgstr ""
"*obj* 객체의 추정된 길이를 반환합니다. 먼저 실제 길이를 반환하려고 시도한 다음, "
":meth:`object.__length_hint__`\\를 사용하여 추정치를 반환하려고 하고, 마지막으로 default 값을 "
"반환합니다."

#: ../../library/operator.rst:254
msgid "The following operation works with callables:"
msgstr ""

#: ../../library/operator.rst:259
msgid "Return ``obj(*args, **kwargs)``."
msgstr "``obj(*args, **kwargs)``\\를 반환합니다."

#: ../../library/operator.rst:264
msgid ""
"The :mod:`operator` module also defines tools for generalized attribute "
"and item lookups.  These are useful for making fast field extractors as "
"arguments for :func:`map`, :func:`sorted`, :meth:`itertools.groupby`, or "
"other functions that expect a function argument."
msgstr ""
":mod:`operator` 모듈은 일반화된 어트리뷰트와 항목 조회를 위한 도구도 정의합니다. 이것은 :func:`map`, "
":func:`sorted`, :meth:`itertools.groupby` 또는 함수 인자를 기대하는 다른 함수의 인자로 사용될 "
"고속 필드 추출기를 만드는 데 유용합니다."

#: ../../library/operator.rst:273
msgid ""
"Return a callable object that fetches *attr* from its operand. If more "
"than one attribute is requested, returns a tuple of attributes. The "
"attribute names can also contain dots. For example:"
msgstr ""
"피연산자에서 *attr*\\을 꺼내는 콜러블 객체를 반환합니다. 둘 이상의 어트리뷰트가 요청되면, 어트리뷰트의 튜플을 반환합니다. "
"어트리뷰트 이름은 점을 포함할 수도 있습니다. 예를 들어:"

#: ../../library/operator.rst:277
msgid "After ``f = attrgetter('name')``, the call ``f(b)`` returns ``b.name``."
msgstr "``f = attrgetter('name')`` 다음에, ``f(b)`` 호출은 ``b.name``\\을 반환합니다."

#: ../../library/operator.rst:279
msgid ""
"After ``f = attrgetter('name', 'date')``, the call ``f(b)`` returns "
"``(b.name, b.date)``."
msgstr ""
"``f = attrgetter('name', 'date')`` 다음에, ``f(b)`` 호출은 ``(b.name, "
"b.date)``\\를 반환합니다."

#: ../../library/operator.rst:282
msgid ""
"After ``f = attrgetter('name.first', 'name.last')``, the call ``f(b)`` "
"returns ``(b.name.first, b.name.last)``."
msgstr ""
"``f = attrgetter('name.first', 'name.last')`` 다음에, ``f(b)`` 호출은 "
"``(b.name.first, b.name.last)``\\를 반환합니다."

#: ../../library/operator.rst:285 ../../library/operator.rst:317
#: ../../library/operator.rst:365
msgid "Equivalent to::"
msgstr "다음과 동등합니다::"

#: ../../library/operator.rst:287
msgid ""
"def attrgetter(*items):\n"
"    if any(not isinstance(item, str) for item in items):\n"
"        raise TypeError('attribute name must be a string')\n"
"    if len(items) == 1:\n"
"        attr = items[0]\n"
"        def g(obj):\n"
"            return resolve_attr(obj, attr)\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(resolve_attr(obj, attr) for attr in items)\n"
"    return g\n"
"\n"
"def resolve_attr(obj, attr):\n"
"    for name in attr.split(\".\"):\n"
"        obj = getattr(obj, name)\n"
"    return obj"
msgstr ""
"def attrgetter(*items):\n"
"    if any(not isinstance(item, str) for item in items):\n"
"        raise TypeError('attribute name must be a string')\n"
"    if len(items) == 1:\n"
"        attr = items[0]\n"
"        def g(obj):\n"
"            return resolve_attr(obj, attr)\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(resolve_attr(obj, attr) for attr in items)\n"
"    return g\n"
"\n"
"def resolve_attr(obj, attr):\n"
"    for name in attr.split(\".\"):\n"
"        obj = getattr(obj, name)\n"
"    return obj"

#: ../../library/operator.rst:308
msgid ""
"Return a callable object that fetches *item* from its operand using the "
"operand's :meth:`~object.__getitem__` method.  If multiple items are "
"specified, returns a tuple of lookup values.  For example:"
msgstr ""
"피연산자의 :meth:`~object.__getitem__` 메서드를 사용하여 피연산자에서 *item*\\을 꺼내는 콜러블 객체를 "
"반환합니다. 여러 항목이 지정되면, 조회 값의 튜플을 반환합니다. 예를 들어:"

#: ../../library/operator.rst:312
msgid "After ``f = itemgetter(2)``, the call ``f(r)`` returns ``r[2]``."
msgstr "``f = itemgetter(2)`` 다음에, ``f(r)`` 호출은 ``r[2]``\\를 반환합니다."

#: ../../library/operator.rst:314
msgid ""
"After ``g = itemgetter(2, 5, 3)``, the call ``g(r)`` returns ``(r[2], "
"r[5], r[3])``."
msgstr ""
"``g = itemgetter(2, 5, 3)`` 다음에, ``g(r)`` 호출은 ``(r[2], r[5], r[3])``\\을 "
"반환합니다."

#: ../../library/operator.rst:319
msgid ""
"def itemgetter(*items):\n"
"    if len(items) == 1:\n"
"        item = items[0]\n"
"        def g(obj):\n"
"            return obj[item]\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(obj[item] for item in items)\n"
"    return g"
msgstr ""
"def itemgetter(*items):\n"
"    if len(items) == 1:\n"
"        item = items[0]\n"
"        def g(obj):\n"
"            return obj[item]\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(obj[item] for item in items)\n"
"    return g"

#: ../../library/operator.rst:329
msgid ""
"The items can be any type accepted by the operand's "
":meth:`~object.__getitem__` method.  Dictionaries accept any "
":term:`hashable` value.  Lists, tuples, and strings accept an index or a "
"slice:"
msgstr ""
"항목은 피연산자의 :meth:`~object.__getitem__` 메서드에서 허용되는 모든 형이 될 수 있습니다. 딕셔너리는 모든"
" :term:`해시 가능 <hashable>` 값을 허용합니다. 리스트, 튜플 및 문자열은 인덱스나 슬라이스를 허용합니다:"

#: ../../library/operator.rst:343
msgid ""
"Example of using :func:`itemgetter` to retrieve specific fields from a "
"tuple record:"
msgstr "튜플 레코드에서 특정 필드를 꺼내기 위해 :func:`itemgetter`\\를 사용하는 예:"

#: ../../library/operator.rst:356
msgid ""
"Return a callable object that calls the method *name* on its operand.  If"
" additional arguments and/or keyword arguments are given, they will be "
"given to the method as well.  For example:"
msgstr ""
"피연산자에서 *name* 메서드를 호출하는 콜러블 객체를 반환합니다. 추가 인자 및/또는 키워드 인자가 주어지면, 해당 인자도 "
"메서드에 제공됩니다. 예를 들어:"

#: ../../library/operator.rst:360
msgid ""
"After ``f = methodcaller('name')``, the call ``f(b)`` returns "
"``b.name()``."
msgstr "``f = methodcaller('name')`` 다음에, ``f(b)`` 호출은 ``b.name()``\\을 반환합니다."

#: ../../library/operator.rst:362
msgid ""
"After ``f = methodcaller('name', 'foo', bar=1)``, the call ``f(b)`` "
"returns ``b.name('foo', bar=1)``."
msgstr ""
"``f = methodcaller('name', 'foo', bar=1)`` 다음에, ``f(b)`` 호출은 "
"``b.name('foo', bar=1)``\\을 반환합니다."

#: ../../library/operator.rst:367
msgid ""
"def methodcaller(name, /, *args, **kwargs):\n"
"    def caller(obj):\n"
"        return getattr(obj, name)(*args, **kwargs)\n"
"    return caller"
msgstr ""
"def methodcaller(name, /, *args, **kwargs):\n"
"    def caller(obj):\n"
"        return getattr(obj, name)(*args, **kwargs)\n"
"    return caller"

#: ../../library/operator.rst:376
msgid "Mapping Operators to Functions"
msgstr "연산자를 함수에 매핑하기"

#: ../../library/operator.rst:378
msgid ""
"This table shows how abstract operations correspond to operator symbols "
"in the Python syntax and the functions in the :mod:`operator` module."
msgstr "이 표는 추상 연산이 파이썬 문법의 연산자 기호와 :mod:`operator` 모듈의 함수로 어떻게 대응되는지를 보여줍니다."

#: ../../library/operator.rst:382
msgid "Operation"
msgstr "연산"

#: ../../library/operator.rst:382
msgid "Syntax"
msgstr "문법"

#: ../../library/operator.rst:382
msgid "Function"
msgstr "함수"

#: ../../library/operator.rst:384
msgid "Addition"
msgstr "더하기(Addition)"

#: ../../library/operator.rst:384
msgid "``a + b``"
msgstr "``a + b``"

#: ../../library/operator.rst:384
msgid "``add(a, b)``"
msgstr "``add(a, b)``"

#: ../../library/operator.rst:386
msgid "Concatenation"
msgstr "이어붙이기(Concatenation)"

#: ../../library/operator.rst:386
msgid "``seq1 + seq2``"
msgstr "``seq1 + seq2``"

#: ../../library/operator.rst:386
msgid "``concat(seq1, seq2)``"
msgstr "``concat(seq1, seq2)``"

#: ../../library/operator.rst:388
msgid "Containment Test"
msgstr "포함 검사(Containment Test)"

#: ../../library/operator.rst:388
msgid "``obj in seq``"
msgstr "``obj in seq``"

#: ../../library/operator.rst:388
msgid "``contains(seq, obj)``"
msgstr "``contains(seq, obj)``"

#: ../../library/operator.rst:390 ../../library/operator.rst:392
msgid "Division"
msgstr "나누기(Division)"

#: ../../library/operator.rst:390
msgid "``a / b``"
msgstr "``a / b``"

#: ../../library/operator.rst:390
msgid "``truediv(a, b)``"
msgstr "``truediv(a, b)``"

#: ../../library/operator.rst:392
msgid "``a // b``"
msgstr "``a // b``"

#: ../../library/operator.rst:392
msgid "``floordiv(a, b)``"
msgstr "``floordiv(a, b)``"

#: ../../library/operator.rst:394
msgid "Bitwise And"
msgstr "비트별 논리곱(Bitwise And)"

#: ../../library/operator.rst:394
msgid "``a & b``"
msgstr "``a & b``"

#: ../../library/operator.rst:394
msgid "``and_(a, b)``"
msgstr "``and_(a, b)``"

#: ../../library/operator.rst:396
msgid "Bitwise Exclusive Or"
msgstr "비트별 배타적 논리합(Bitwise Exclusive Or)"

#: ../../library/operator.rst:396
msgid "``a ^ b``"
msgstr "``a ^ b``"

#: ../../library/operator.rst:396
msgid "``xor(a, b)``"
msgstr "``xor(a, b)``"

#: ../../library/operator.rst:398
msgid "Bitwise Inversion"
msgstr "비트별 반전(Bitwise Inversion)"

#: ../../library/operator.rst:398
msgid "``~ a``"
msgstr "``~ a``"

#: ../../library/operator.rst:398
msgid "``invert(a)``"
msgstr "``invert(a)``"

#: ../../library/operator.rst:400
msgid "Bitwise Or"
msgstr "비트별 논리합(Bitwise Or)"

#: ../../library/operator.rst:400
msgid "``a | b``"
msgstr "``a | b``"

#: ../../library/operator.rst:400
msgid "``or_(a, b)``"
msgstr "``or_(a, b)``"

#: ../../library/operator.rst:402
msgid "Exponentiation"
msgstr "거듭제곱(Exponentiation)"

#: ../../library/operator.rst:402
msgid "``a ** b``"
msgstr "``a ** b``"

#: ../../library/operator.rst:402
msgid "``pow(a, b)``"
msgstr "``pow(a, b)``"

#: ../../library/operator.rst:404 ../../library/operator.rst:406
msgid "Identity"
msgstr "아이덴티티(Identity)"

#: ../../library/operator.rst:404
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/operator.rst:404
msgid "``is_(a, b)``"
msgstr "``is_(a, b)``"

#: ../../library/operator.rst:406
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/operator.rst:406
msgid "``is_not(a, b)``"
msgstr "``is_not(a, b)``"

#: ../../library/operator.rst:408
msgid "Indexed Assignment"
msgstr "인덱싱된 대입(Indexed Assignment)"

#: ../../library/operator.rst:408
msgid "``obj[k] = v``"
msgstr "``obj[k] = v``"

#: ../../library/operator.rst:408
msgid "``setitem(obj, k, v)``"
msgstr "``setitem(obj, k, v)``"

#: ../../library/operator.rst:410
msgid "Indexed Deletion"
msgstr "인덱싱된 삭제(Indexed Deletion)"

#: ../../library/operator.rst:410
msgid "``del obj[k]``"
msgstr "``del obj[k]``"

#: ../../library/operator.rst:410
msgid "``delitem(obj, k)``"
msgstr "``delitem(obj, k)``"

#: ../../library/operator.rst:412
msgid "Indexing"
msgstr "인덱싱(Indexing)"

#: ../../library/operator.rst:412
msgid "``obj[k]``"
msgstr "``obj[k]``"

#: ../../library/operator.rst:412
msgid "``getitem(obj, k)``"
msgstr "``getitem(obj, k)``"

#: ../../library/operator.rst:414
msgid "Left Shift"
msgstr "왼쪽으로 시프트(Left Shift)"

#: ../../library/operator.rst:414
msgid "``a << b``"
msgstr "``a << b``"

#: ../../library/operator.rst:414
msgid "``lshift(a, b)``"
msgstr "``lshift(a, b)``"

#: ../../library/operator.rst:416
msgid "Modulo"
msgstr "모듈로(Modulo)"

#: ../../library/operator.rst:416
msgid "``a % b``"
msgstr "``a % b``"

#: ../../library/operator.rst:416
msgid "``mod(a, b)``"
msgstr "``mod(a, b)``"

#: ../../library/operator.rst:418
msgid "Multiplication"
msgstr "곱하기(Multiplication)"

#: ../../library/operator.rst:418
msgid "``a * b``"
msgstr "``a * b``"

#: ../../library/operator.rst:418
msgid "``mul(a, b)``"
msgstr "``mul(a, b)``"

#: ../../library/operator.rst:420
msgid "Matrix Multiplication"
msgstr "행렬 곱하기(Matrix Multiplication)"

#: ../../library/operator.rst:420
msgid "``a @ b``"
msgstr "``a @ b``"

#: ../../library/operator.rst:420
msgid "``matmul(a, b)``"
msgstr "``matmul(a, b)``"

#: ../../library/operator.rst:422
msgid "Negation (Arithmetic)"
msgstr "부정 (산술)(Negation (Arithmetic))"

#: ../../library/operator.rst:422
msgid "``- a``"
msgstr "``- a``"

#: ../../library/operator.rst:422
msgid "``neg(a)``"
msgstr "``neg(a)``"

#: ../../library/operator.rst:424
msgid "Negation (Logical)"
msgstr "부정 (논리)(Negation (Logical))"

#: ../../library/operator.rst:424
msgid "``not a``"
msgstr "``not a``"

#: ../../library/operator.rst:424
msgid "``not_(a)``"
msgstr "``not_(a)``"

#: ../../library/operator.rst:426
msgid "Positive"
msgstr "양(Positive)"

#: ../../library/operator.rst:426
msgid "``+ a``"
msgstr "``+ a``"

#: ../../library/operator.rst:426
msgid "``pos(a)``"
msgstr "``pos(a)``"

#: ../../library/operator.rst:428
msgid "Right Shift"
msgstr "오른쪽으로 시프트(Right Shift)"

#: ../../library/operator.rst:428
msgid "``a >> b``"
msgstr "``a >> b``"

#: ../../library/operator.rst:428
msgid "``rshift(a, b)``"
msgstr "``rshift(a, b)``"

#: ../../library/operator.rst:430
msgid "Slice Assignment"
msgstr "슬라이스 대입(Slice Assignment)"

#: ../../library/operator.rst:430
msgid "``seq[i:j] = values``"
msgstr "``seq[i:j] = values``"

#: ../../library/operator.rst:430
msgid "``setitem(seq, slice(i, j), values)``"
msgstr "``setitem(seq, slice(i, j), values)``"

#: ../../library/operator.rst:432
msgid "Slice Deletion"
msgstr "슬라이스 삭제(Slice Deletion)"

#: ../../library/operator.rst:432
msgid "``del seq[i:j]``"
msgstr "``del seq[i:j]``"

#: ../../library/operator.rst:432
msgid "``delitem(seq, slice(i, j))``"
msgstr "``delitem(seq, slice(i, j))``"

#: ../../library/operator.rst:434
msgid "Slicing"
msgstr "슬라이싱(Slicing)"

#: ../../library/operator.rst:434
msgid "``seq[i:j]``"
msgstr "``seq[i:j]``"

#: ../../library/operator.rst:434
msgid "``getitem(seq, slice(i, j))``"
msgstr "``getitem(seq, slice(i, j))``"

#: ../../library/operator.rst:436
msgid "String Formatting"
msgstr "문자열 포매팅(String Formatting)"

#: ../../library/operator.rst:436
#, python-format
msgid "``s % obj``"
msgstr "``s % obj``"

#: ../../library/operator.rst:436
msgid "``mod(s, obj)``"
msgstr "``mod(s, obj)``"

#: ../../library/operator.rst:438
msgid "Subtraction"
msgstr "빼기(Subtraction)"

#: ../../library/operator.rst:438
msgid "``a - b``"
msgstr "``a - b``"

#: ../../library/operator.rst:438
msgid "``sub(a, b)``"
msgstr "``sub(a, b)``"

#: ../../library/operator.rst:440
msgid "Truth Test"
msgstr "진릿값 검사(Truth Test)"

#: ../../library/operator.rst:440
msgid "``obj``"
msgstr "``obj``"

#: ../../library/operator.rst:440
msgid "``truth(obj)``"
msgstr "``truth(obj)``"

#: ../../library/operator.rst:442 ../../library/operator.rst:444
#: ../../library/operator.rst:450 ../../library/operator.rst:452
msgid "Ordering"
msgstr "대소비교(Ordering)"

#: ../../library/operator.rst:442
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/operator.rst:442
msgid "``lt(a, b)``"
msgstr "``lt(a, b)``"

#: ../../library/operator.rst:444
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/operator.rst:444
msgid "``le(a, b)``"
msgstr "``le(a, b)``"

#: ../../library/operator.rst:446
msgid "Equality"
msgstr "동등성(Equality)"

#: ../../library/operator.rst:446
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/operator.rst:446
msgid "``eq(a, b)``"
msgstr "``eq(a, b)``"

#: ../../library/operator.rst:448
msgid "Difference"
msgstr "다름(Difference)"

#: ../../library/operator.rst:448
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/operator.rst:448
msgid "``ne(a, b)``"
msgstr "``ne(a, b)``"

#: ../../library/operator.rst:450
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/operator.rst:450
msgid "``ge(a, b)``"
msgstr "``ge(a, b)``"

#: ../../library/operator.rst:452
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/operator.rst:452
msgid "``gt(a, b)``"
msgstr "``gt(a, b)``"

#: ../../library/operator.rst:456
msgid "In-place Operators"
msgstr "제자리 연산자"

#: ../../library/operator.rst:458
msgid ""
"Many operations have an \"in-place\" version.  Listed below are functions"
" providing a more primitive access to in-place operators than the usual "
"syntax does; for example, the :term:`statement` ``x += y`` is equivalent "
"to ``x = operator.iadd(x, y)``.  Another way to put it is to say that ``z"
" = operator.iadd(x, y)`` is equivalent to the compound statement ``z = x;"
" z += y``."
msgstr ""
"많은 연산에는 \"제자리(in-place)\" 버전이 있습니다. 아래에 나열된 것들은 일반적인 문법보다 제자리 연산자에 대한 더 "
"기본적인 액세스를 제공하는 함수입니다; 예를 들어, :term:`문장 <statement>` ``x += y``\\는 ``x = "
"operator.iadd(x, y)``\\와 동등합니다. 또 다른 식으로는, ``z = operator.iadd(x, y)``\\가"
" 복합문 ``z = x; z += y``\\와 동등하다고 말하는 것입니다."

#: ../../library/operator.rst:465
msgid ""
"In those examples, note that when an in-place method is called, the "
"computation and assignment are performed in two separate steps.  The in-"
"place functions listed below only do the first step, calling the in-place"
" method.  The second step, assignment, is not handled."
msgstr ""
"이 예제들에서, 제자리 메서드가 호출될 때, 계산과 대입이 두 개의 분리된 단계에서 수행된다는 점에 유의하십시오. 아래 나열된 "
"제자리 함수는 제자리 메서드를 호출하는 첫 번째 단계만 수행합니다. 두 번째 단계인 대입은 처리되지 않습니다."

#: ../../library/operator.rst:470
msgid ""
"For immutable targets such as strings, numbers, and tuples, the updated "
"value is computed, but not assigned back to the input variable:"
msgstr "문자열, 숫자 및 튜플과 같은 불변 대상의 경우, 갱신된 값이 계산되지만, 입력 변수에 다시 할당되지 않습니다:"

#: ../../library/operator.rst:479
msgid ""
"For mutable targets such as lists and dictionaries, the in-place method "
"will perform the update, so no subsequent assignment is necessary:"
msgstr "리스트와 딕셔너리 같은 가변 대상의 경우, 제자리 메서드가 갱신을 수행하므로, 이후 대입이 필요하지 않습니다:"

#: ../../library/operator.rst:491
msgid "``a = iadd(a, b)`` is equivalent to ``a += b``."
msgstr "``a = iadd(a, b)``\\는 ``a += b``\\와 동등합니다."

#: ../../library/operator.rst:497
msgid "``a = iand(a, b)`` is equivalent to ``a &= b``."
msgstr "``a = iand(a, b)``\\는 ``a &= b``\\와 동등합니다."

#: ../../library/operator.rst:503
msgid ""
"``a = iconcat(a, b)`` is equivalent to ``a += b`` for *a* and *b* "
"sequences."
msgstr "*a*\\와 *b* 시퀀스에 대해, ``a = iconcat(a, b)``\\는 ``a += b``\\와 동등합니다."

#: ../../library/operator.rst:509
msgid "``a = ifloordiv(a, b)`` is equivalent to ``a //= b``."
msgstr "``a = ifloordiv(a, b)``\\는 ``a //= b``\\와 동등합니다."

#: ../../library/operator.rst:515
msgid "``a = ilshift(a, b)`` is equivalent to ``a <<= b``."
msgstr "``a = ilshift(a, b)``\\는 ``a <<= b``\\와 동등합니다."

#: ../../library/operator.rst:521
msgid "``a = imod(a, b)`` is equivalent to ``a %= b``."
msgstr "``a = imod(a, b)``\\는 ``a %= b``\\와 동등합니다."

#: ../../library/operator.rst:527
msgid "``a = imul(a, b)`` is equivalent to ``a *= b``."
msgstr "``a = imul(a, b)``\\는 ``a *= b``\\와 동등합니다."

#: ../../library/operator.rst:533
msgid "``a = imatmul(a, b)`` is equivalent to ``a @= b``."
msgstr "``a = imatmul(a, b)``\\는 ``a @= b``\\와 동등합니다."

#: ../../library/operator.rst:541
msgid "``a = ior(a, b)`` is equivalent to ``a |= b``."
msgstr "``a = ior(a, b)``\\는 ``a |= b``\\와 동등합니다."

#: ../../library/operator.rst:547
msgid "``a = ipow(a, b)`` is equivalent to ``a **= b``."
msgstr "``a = ipow(a, b)``\\는 ``a **= b``\\와 동등합니다."

#: ../../library/operator.rst:553
msgid "``a = irshift(a, b)`` is equivalent to ``a >>= b``."
msgstr "``a = irshift(a, b)``\\는 ``a >>= b``\\와 동등합니다."

#: ../../library/operator.rst:559
msgid "``a = isub(a, b)`` is equivalent to ``a -= b``."
msgstr "``a = isub(a, b)``\\는 ``a -= b``\\와 동등합니다."

#: ../../library/operator.rst:565
msgid "``a = itruediv(a, b)`` is equivalent to ``a /= b``."
msgstr "``a = itruediv(a, b)``\\는 ``a /= b``\\와 동등합니다."

#: ../../library/operator.rst:571
msgid "``a = ixor(a, b)`` is equivalent to ``a ^= b``."
msgstr "``a = ixor(a, b)``\\는 ``a ^= b``\\와 동등합니다."

