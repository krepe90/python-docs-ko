# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/compileall.rst:2
msgid ":mod:`!compileall` --- Byte-compile Python libraries"
msgstr ":mod:`!compileall` --- 파이썬 라이브러리 바이트 컴파일하기"

#: ../../library/compileall.rst:7
msgid "**Source code:** :source:`Lib/compileall.py`"
msgstr "**소스 코드:** :source:`Lib/compileall.py`"

#: ../../library/compileall.rst:11
msgid ""
"This module provides some utility functions to support installing Python "
"libraries.  These functions compile Python source files in a directory "
"tree. This module can be used to create the cached byte-code files at "
"library installation time, which makes them available for use even by "
"users who don't have write permission to the library directories."
msgstr ""
"이 모듈은 파이썬 라이브러리 설치를 지원하는 몇 가지 유틸리티 함수를 제공합니다. 이 함수는 디렉터리 트리에서 파이썬 소스 파일을 "
"컴파일합니다. 이 모듈을 사용하면 라이브러리 설치 시 캐시 된 바이트 코드 파일을 만들 수 있으므로, 라이브러리 디렉터리에 쓰기 "
"권한이 없는 사용자도 사용할 수 있도록 합니다."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/compileall.rst:22
msgid "Command-line use"
msgstr "명령 줄 사용"

#: ../../library/compileall.rst:24
msgid ""
"This module can work as a script (using :program:`python -m compileall`) "
"to compile Python sources."
msgstr ""
"이 모듈은 파이썬 소스를 컴파일하는 스크립트로 작동할 수 있습니다 (:program:`python -m compileall`\\을 "
"사용합니다)."

#: ../../library/compileall.rst:32
#, python-brace-format
msgid ""
"Positional arguments are files to compile or directories that contain "
"source files, traversed recursively.  If no argument is given, behave as "
"if the command line was :samp:`-l {<directories from sys.path>}`."
msgstr ""
"위치 인자는 컴파일할 파일이나 소스 파일을 포함하는 디렉터리이며 재귀적으로 탐색 됩니다. 인자가 주어지지 않으면, 명령 줄이 "
":samp:`-l {<directories from sys.path>}` 인 것처럼 행동합니다."

#: ../../library/compileall.rst:38
msgid ""
"Do not recurse into subdirectories, only compile source code files "
"directly contained in the named or implied directories."
msgstr "서브 디렉터리를 재귀적으로 탐색하지 않고, 이름이 지정되었거나 암시된 디렉터리에 직접 포함된 소스 코드 파일 만 컴파일합니다."

#: ../../library/compileall.rst:43
msgid "Force rebuild even if timestamps are up-to-date."
msgstr "타임스탬프가 최신일 때도 강제로 다시 빌드합니다."

#: ../../library/compileall.rst:47
msgid ""
"Do not print the list of files compiled. If passed once, error messages "
"will still be printed. If passed twice (``-qq``), all output is "
"suppressed."
msgstr ""
"컴파일된 파일 목록을 인쇄하지 않습니다. 한 번 전달하면, 에러 메시지는 여전히 인쇄됩니다. 두 번 전달하면 (``-qq``), "
"모든 출력이 억제됩니다."

#: ../../library/compileall.rst:52
msgid ""
"Directory prepended to the path to each file being compiled.  This will "
"appear in compilation time tracebacks, and is also compiled in to the "
"byte-code file, where it will be used in tracebacks and other messages in"
" cases where the source file does not exist at the time the byte-code "
"file is executed."
msgstr ""
"디렉터리가 컴파일되는 각 파일의 경로 앞에 추가됩니다. 이것은 컴파일 시간 트레이스백에 나타나며, 바이트 코드 파일에 컴파일되어 "
"들어가서, 바이트 코드 파일이 실행되는 시점에 소스 파일이 존재하지 않으면 트레이스백과 기타 메시지에 사용됩니다."

#: ../../library/compileall.rst:61
msgid ""
"Remove (``-s``) or append (``-p``) the given prefix of paths recorded in "
"the ``.pyc`` files. Cannot be combined with ``-d``."
msgstr ""
"``.pyc`` 파일에 기록된 지정된 경로 접두사를 제거(``-s``)하거나 추가(``-p``)합니다. ``-d``\\와 함께 "
"사용할 수 없습니다."

#: ../../library/compileall.rst:67
msgid ""
"regex is used to search the full path to each file considered for "
"compilation, and if the regex produces a match, the file is skipped."
msgstr ""
"regex는 컴파일 대상으로 고려되는 각 파일의 전체 경로를 검색(search)하는 데 사용되며, 정규식이 일치를 생성하면 그 "
"파일을 건너뜁니다."

#: ../../library/compileall.rst:72
msgid ""
"Read the file ``list`` and add each line that it contains to the list of "
"files and directories to compile.  If ``list`` is ``-``, read lines from "
"``stdin``."
msgstr ""
"파일 ``list``\\를 읽고 포함된 각 줄을 컴파일할 파일과 디렉터리 목록에 추가합니다. ``list``\\가 "
"``-``\\이면, ``stdin``\\에서 줄을 읽습니다."

#: ../../library/compileall.rst:78
msgid ""
"Write the byte-code files to their legacy locations and names, which may "
"overwrite byte-code files created by another version of Python.  The "
"default is to write files to their :pep:`3147` locations and names, which"
" allows byte-code files from multiple versions of Python to coexist."
msgstr ""
"바이트 코드 파일을 레거시 위치 및 이름에 써서, 다른 버전의 파이썬이 만든 바이트 코드 파일을 덮어쓸 수 있습니다. 기본값은 여러"
" 버전의 파이썬의 바이트 코드 파일이 공존할 수 있는 :pep:`3147` 위치와 이름에 파일을 쓰는 것입니다."

#: ../../library/compileall.rst:85
msgid ""
"Control the maximum recursion level for subdirectories. If this is given,"
" then ``-l`` option will not be taken into account. :program:`python -m "
"compileall <directory> -r 0` is equivalent to :program:`python -m "
"compileall <directory> -l`."
msgstr ""
"서브 디렉터리의 최대 재귀 수준을 제어합니다. 이것이 주어지면, ``-l`` 옵션은 고려되지 않습니다. "
":program:`python -m compileall <directory> -r 0`\\은 :program:`python -m "
"compileall <directory> -l`\\과 동등합니다."

#: ../../library/compileall.rst:92
msgid ""
"Use *N* workers to compile the files within the given directory. If ``0``"
" is used, then the result of :func:`os.process_cpu_count` will be used."
msgstr ""
"주어진 디렉터리 내의 파일을 컴파일하는 데 *N* 작업자를 사용합니다. ``0``\\이 사용되면, "
":func:`os.process_cpu_count`\\의 결과가 사용됩니다."

#: ../../library/compileall.rst:98
msgid ""
"Control how the generated byte-code files are invalidated at runtime. The"
" ``timestamp`` value, means that ``.pyc`` files with the source timestamp"
" and size embedded will be generated. The ``checked-hash`` and "
"``unchecked-hash`` values cause hash-based pycs to be generated. Hash-"
"based pycs embed a hash of the source file contents rather than a "
"timestamp. See :ref:`pyc-invalidation` for more information on how Python"
" validates bytecode cache files at runtime. The default is ``timestamp`` "
"if the :envvar:`SOURCE_DATE_EPOCH` environment variable is not set, and "
"``checked-hash`` if the ``SOURCE_DATE_EPOCH`` environment variable is "
"set."
msgstr ""
"생성된 바이트 코드 파일이 실행 시간에 무효가 되는 방식을 제어합니다. ``timestamp`` 값은 소스 타임스탬프와 크기가 "
"포함된 ``.pyc`` 파일이 생성됨을 의미합니다. ``checked-hash``\\와 ``unchecked-hash`` 값은 해시"
" 기반 pyc를 생성합니다. 해시 기반 pyc는 타임스탬프 대신 소스 파일 내용의 해시를 포함합니다. 파이썬이 실행 시간에 바이트 "
"코드 캐시 파일의 유효성을 검사하는 방법에 대한 자세한 내용은 :ref:`pyc-invalidation`\\를 참조하십시오. "
"기본값은 :envvar:`SOURCE_DATE_EPOCH` 환경 변수가 설정되지 않으면 ``timestamp``\\이고, "
"``SOURCE_DATE_EPOCH`` 환경 변수가 설정되면 ``checked-hash``\\입니다."

#: ../../library/compileall.rst:111
msgid ""
"Compile with the given optimization level. May be used multiple times to "
"compile for multiple levels at a time (for example, ``compileall -o 1 -o "
"2``)."
msgstr ""
"주어진 최적화 수준으로 컴파일합니다. 한 번에 여러 수준으로 컴파일하기 위해 여러 번 사용할 수 있습니다 (예를 들어, "
"``compileall -o 1 -o 2``)."

#: ../../library/compileall.rst:117
msgid "Ignore symlinks pointing outside the given directory."
msgstr "지정된 디렉터리 외부를 가리키는 심볼릭 링크를 무시합니다."

#: ../../library/compileall.rst:121
msgid ""
"If two ``.pyc`` files with different optimization level have the same "
"content, use hard links to consolidate duplicate files."
msgstr "최적화 수준이 다른 두 개의 ``.pyc`` 파일의 내용이 같으면, 하드 링크를 사용하여 중복 파일을 통합합니다."

#: ../../library/compileall.rst:124
msgid "Added the ``-i``, ``-b`` and ``-h`` options."
msgstr "``-i``, ``-b`` 및 ``-h`` 옵션이 추가되었습니다."

#: ../../library/compileall.rst:127
msgid ""
"Added the  ``-j``, ``-r``, and ``-qq`` options.  ``-q`` option was "
"changed to a multilevel value.  ``-b`` will always produce a byte-code "
"file ending in ``.pyc``, never ``.pyo``."
msgstr ""
"``-j``, ``-r`` 및 ``-qq`` 옵션이 추가되었습니다. ``-q`` 옵션이 다중 수준 값으로 변경되었습니다. "
"``-b``\\는 항상 ``.pyc``\\로 끝나는 바이트 코드 파일을 생성하며, 결코 ``.pyo``\\를 생성하지 않습니다."

#: ../../library/compileall.rst:132
msgid "Added the ``--invalidation-mode`` option."
msgstr "``--invalidation-mode`` 옵션이 추가되었습니다."

#: ../../library/compileall.rst:135
msgid ""
"Added the ``-s``, ``-p``, ``-e`` and ``--hardlink-dupes`` options. Raised"
" the default recursion limit from 10 to "
":py:func:`sys.getrecursionlimit()`. Added the possibility to specify the "
"``-o`` option multiple times."
msgstr ""
"``-s``, ``-p``, ``-e`` 및 ``--hardlink-dupes`` 옵션을 추가했습니다. 기본 재귀 제한을 10에서 "
":py:func:`sys.getrecursionlimit()`\\로 올렸습니다. ``-o`` 옵션을 여러 번 지정할 수 있는 "
"가능성이 추가되었습니다."

#: ../../library/compileall.rst:142
msgid ""
"There is no command-line option to control the optimization level used by"
" the :func:`compile` function, because the Python interpreter itself "
"already provides the option: :program:`python -O -m compileall`."
msgstr ""
":func:`compile` 함수가 사용하는 최적화 수준을 제어하는 명령 줄 옵션은 없습니다. 파이썬 인터프리터 자신이 그 옵션을 "
"제공하고 있기 때문입니다: :program:`python -O -m compileall`."

#: ../../library/compileall.rst:146
msgid ""
"Similarly, the :func:`compile` function respects the "
":data:`sys.pycache_prefix` setting. The generated bytecode cache will "
"only be useful if :func:`compile` is run with the same "
":data:`sys.pycache_prefix` (if any) that will be used at runtime."
msgstr ""
"마찬가지로, :func:`compile` 함수는 :data:`sys.pycache_prefix` 설정을 따릅니다. 생성된 바이트 "
"코드 캐시는 :func:`compile`\\이 실행 시간에 사용될 것과 같은 "
":data:`sys.pycache_prefix`\\(있다면)로 실행될 때만 유용합니다."

#: ../../library/compileall.rst:152
msgid "Public functions"
msgstr "공용 함수"

#: ../../library/compileall.rst:156
msgid ""
"Recursively descend the directory tree named by *dir*, compiling all "
":file:`.py` files along the way. Return a true value if all the files "
"compiled successfully, and a false value otherwise."
msgstr ""
"*dir*\\로 명명된 디렉터리 트리를 재귀적으로 탐색해 내려가면서, 발견되는 모든 :file:`.py` 파일을 컴파일합니다. 모든"
" 파일이 성공적으로 컴파일되면 참값을 반환하고, 그렇지 않으면 거짓값을 반환합니다."

#: ../../library/compileall.rst:160
msgid ""
"The *maxlevels* parameter is used to limit the depth of the recursion; it"
" defaults to ``sys.getrecursionlimit()``."
msgstr ""
"*maxlevels* 매개 변수는 재귀의 깊이를 제한하는 데 사용됩니다; 기본값은 "
"``sys.getrecursionlimit()``\\입니다."

#: ../../library/compileall.rst:163
msgid ""
"If *ddir* is given, it is prepended to the path to each file being "
"compiled for use in compilation time tracebacks, and is also compiled in "
"to the byte-code file, where it will be used in tracebacks and other "
"messages in cases where the source file does not exist at the time the "
"byte-code file is executed."
msgstr ""
"*ddir*\\이 주어지면, 컴파일 시간 트레이스백에서 사용하기 위해 컴파일되는 각 파일의 경로 앞에 추가되며, 바이트 코드 파일에"
" 컴파일되어 들어가서, 바이트 코드 파일이 실행되는 시점에 소스 파일이 존재하지 않으면 트레이스백과 기타 메시지에 사용됩니다."

#: ../../library/compileall.rst:169
msgid ""
"If *force* is true, modules are re-compiled even if the timestamps are up"
" to date."
msgstr "*force*\\가 참이면, 타임스탬프가 최신일 때도 모듈이 다시 컴파일됩니다."

#: ../../library/compileall.rst:172
msgid ""
"If *rx* is given, its ``search`` method is called on the complete path to"
" each file considered for compilation, and if it returns a true value, "
"the file is skipped. This can be used to exclude files matching a regular"
" expression, given as a :ref:`re.Pattern <re-objects>` object."
msgstr ""
"*rx*\\가 주어지면, 컴파일 대상으로 고려되는 각 파일의 전체 경로로 그것의 ``search`` 메서드를 호출하고, 참값을 "
"반환하면 그 파일을 건너뜁니다. 이는 :ref:`re.Pattern <re-objects>` 객체로 주어지는 정규식과 일치하는 "
"파일을 제외하는 데 사용할 수 있습니다."

#: ../../library/compileall.rst:177 ../../library/compileall.rst:254
msgid ""
"If *quiet* is ``False`` or ``0`` (the default), the filenames and other "
"information are printed to standard out. Set to ``1``, only errors are "
"printed. Set to ``2``, all output is suppressed."
msgstr ""
"*quiet*\\가 ``False``\\나 ``0``\\(기본값)이면, 파일명과 기타 정보가 표준 출력에 인쇄됩니다. "
"``1``\\로 설정하면, 에러만 인쇄됩니다. ``2``\\로 설정하면, 모든 출력이 억제됩니다."

#: ../../library/compileall.rst:181 ../../library/compileall.rst:258
msgid ""
"If *legacy* is true, byte-code files are written to their legacy "
"locations and names, which may overwrite byte-code files created by "
"another version of Python.  The default is to write files to their "
":pep:`3147` locations and names, which allows byte-code files from "
"multiple versions of Python to coexist."
msgstr ""
"*legacy*\\가 참이면, 바이트 코드 파일을 레거시 위치 및 이름에 써서, 다른 버전의 파이썬이 만든 바이트 코드 파일을 "
"덮어쓸 수 있습니다. 기본값은 여러 버전의 파이썬의 바이트 코드 파일이 공존할 수 있는 :pep:`3147` 위치와 이름에 파일을 "
"쓰는 것입니다."

#: ../../library/compileall.rst:187 ../../library/compileall.rst:264
msgid ""
"*optimize* specifies the optimization level for the compiler.  It is "
"passed to the built-in :func:`compile` function. Accepts also a sequence "
"of optimization levels which lead to multiple compilations of one "
":file:`.py` file in one call."
msgstr ""
"*optimize*\\는 컴파일러의 최적화 수준을 지정합니다. 내장 :func:`compile` 함수로 전달됩니다. 한 번의 호출로"
" 하나의 :file:`.py` 파일을 여러 번 컴파일하도록 하는 최적화 수준의 시퀀스도 허용합니다."

#: ../../library/compileall.rst:191
msgid ""
"The argument *workers* specifies how many workers are used to compile "
"files in parallel. The default is to not use multiple workers. If the "
"platform can't use multiple workers and *workers* argument is given, then"
" sequential compilation will be used as a fallback.  If *workers* is 0, "
"the number of cores in the system is used.  If *workers* is lower than "
"``0``, a :exc:`ValueError` will be raised."
msgstr ""
"인자 *workers*\\는 파일을 컴파일하는 데 병렬로 사용되는 작업자 수를 지정합니다. 기본값은 다중 작업자를 사용하지 않는 "
"것입니다. 플랫폼이 다중 작업자를 사용할 수 없고 *workers* 인자가 주어지면, 순차 컴파일로 대체합니다. "
"*workers*\\가 0이면 시스템의 코어 수가 사용됩니다. *workers*\\가 ``0``\\보다 작으면, "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/compileall.rst:198 ../../library/compileall.rst:268
msgid ""
"*invalidation_mode* should be a member of the "
":class:`py_compile.PycInvalidationMode` enum and controls how the "
"generated pycs are invalidated at runtime."
msgstr ""
"*invalidation_mode*\\는 :class:`py_compile.PycInvalidationMode` 열거형의 멤버여야 "
"하며 실행 시간에 생성된 pyc가 무효가 되는 방식을 제어합니다."

#: ../../library/compileall.rst:202 ../../library/compileall.rst:272
msgid ""
"The *stripdir*, *prependdir* and *limit_sl_dest* arguments correspond to "
"the ``-s``, ``-p`` and ``-e`` options described above. They may be "
"specified as ``str`` or :py:class:`os.PathLike`."
msgstr ""
"*stripdir*, *prependdir* 및 *limit_sl_dest* 인자는 위에서 설명한 ``-s``, ``-p`` 및 "
"``-e`` 옵션에 해당합니다. ``str`` 이나 :py:class:`os.PathLike`\\으로 지정할 수 있습니다."

#: ../../library/compileall.rst:206 ../../library/compileall.rst:276
msgid ""
"If *hardlink_dupes* is true and two ``.pyc`` files with different "
"optimization level have the same content, use hard links to consolidate "
"duplicate files."
msgstr ""
"*hardlink_dupes*\\가 참이고 최적화 수준이 다른 두 개의 ``.pyc`` 파일의 내용이 같으면, 하드 링크를 사용하여"
" 중복 파일을 통합합니다."

#: ../../library/compileall.rst:209 ../../library/compileall.rst:307
msgid "Added the *legacy* and *optimize* parameter."
msgstr "*legacy*\\와 *optimize* 매개 변수가 추가되었습니다."

#: ../../library/compileall.rst:212
msgid "Added the *workers* parameter."
msgstr "*workers* 매개 변수가 추가되었습니다."

#: ../../library/compileall.rst:215 ../../library/compileall.rst:281
#: ../../library/compileall.rst:310
msgid "*quiet* parameter was changed to a multilevel value."
msgstr "*quiet* 매개 변수가 다중 수준 값으로 변경되었습니다."

#: ../../library/compileall.rst:218 ../../library/compileall.rst:284
#: ../../library/compileall.rst:313
msgid ""
"The *legacy* parameter only writes out ``.pyc`` files, not ``.pyo`` files"
" no matter what the value of *optimize* is."
msgstr "*legacy* 매개 변수는 *optimize* 값과 상관없이 ``.pyo`` 파일이 아니라 ``.pyc`` 파일 만 기록합니다."

#: ../../library/compileall.rst:222
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/compileall.rst:225 ../../library/compileall.rst:288
#: ../../library/compileall.rst:317
msgid "The *invalidation_mode* parameter was added."
msgstr "*invalidation_mode* 매개 변수가 추가되었습니다."

#: ../../library/compileall.rst:228 ../../library/compileall.rst:291
#: ../../library/compileall.rst:320
msgid "The *invalidation_mode* parameter's default value is updated to ``None``."
msgstr "*invalidation_mode* 매개 변수의 기본값이 ``None``\\으로 변경되었습니다."

#: ../../library/compileall.rst:231
msgid "Setting *workers* to 0 now chooses the optimal number of cores."
msgstr "*workers*\\를 0으로 설정하면 최적의 코어 수가 선택됩니다."

#: ../../library/compileall.rst:234
msgid ""
"Added *stripdir*, *prependdir*, *limit_sl_dest* and *hardlink_dupes* "
"arguments. Default value of *maxlevels* was changed from ``10`` to "
"``sys.getrecursionlimit()``"
msgstr ""
"*stripdir*, *prependdir*, *limit_sl_dest* 및 *hardlink_dupes* 인자가 추가되었습니다."
" *maxlevels*\\의 기본값이 ``10``\\에서 ``sys.getrecursionlimit()``\\으로 변경되었습니다."

#: ../../library/compileall.rst:240
msgid ""
"Compile the file with path *fullname*. Return a true value if the file "
"compiled successfully, and a false value otherwise."
msgstr "경로 *fullname*\\의 파일을 컴파일합니다. 파일이 성공적으로 컴파일되면 참값을 반환하고, 그렇지 않으면 거짓값을 반환합니다."

#: ../../library/compileall.rst:243
msgid ""
"If *ddir* is given, it is prepended to the path to the file being "
"compiled for use in compilation time tracebacks, and is also compiled in "
"to the byte-code file, where it will be used in tracebacks and other "
"messages in cases where the source file does not exist at the time the "
"byte-code file is executed."
msgstr ""
"*ddir*\\이 주어지면, 컴파일 시간 트레이스백에서 사용하기 위해 컴파일되는 파일의 경로 앞에 추가되며, 바이트 코드 파일에 "
"컴파일되어 들어가서, 바이트 코드 파일이 실행되는 시점에 소스 파일이 존재하지 않으면 트레이스백과 기타 메시지에 사용됩니다."

#: ../../library/compileall.rst:249
msgid ""
"If *rx* is given, its ``search`` method is passed the full path name to "
"the file being compiled, and if it returns a true value, the file is not "
"compiled and ``True`` is returned. This can be used to exclude files "
"matching a regular expression, given as a :ref:`re.Pattern <re-objects>` "
"object."
msgstr ""
"*rx*\\가 주어지면, 컴파일 중인 파일의 전체 경로가 그것의 ``search`` 메서드로 전달되고, 참값을 반환하면, 파일이 "
"컴파일되지 않고 ``True``\\가 반환됩니다. 이는 :ref:`re.Pattern <re-objects>` 객체로 주어지는 "
"정규식과 일치하는 파일을 제외하는 데 사용할 수 있습니다."

#: ../../library/compileall.rst:294
msgid ""
"Added *stripdir*, *prependdir*, *limit_sl_dest* and *hardlink_dupes* "
"arguments."
msgstr "*stripdir*, *prependdir*, *limit_sl_dest* 및 *hardlink_dupes* 인자가 추가되었습니다."

#: ../../library/compileall.rst:299
msgid ""
"Byte-compile all the :file:`.py` files found along ``sys.path``. Return a"
" true value if all the files compiled successfully, and a false value "
"otherwise."
msgstr ""
"``sys.path``\\에서 발견된 모든 :file:`.py` 파일을 바이트 컴파일합니다. 모든 파일이 성공적으로 컴파일되면 "
"참값을 반환하고, 그렇지 않으면 거짓값을 반환합니다."

#: ../../library/compileall.rst:302
msgid ""
"If *skip_curdir* is true (the default), the current directory is not "
"included in the search.  All other parameters are passed to the "
":func:`compile_dir` function.  Note that unlike the other compile "
"functions, ``maxlevels`` defaults to ``0``."
msgstr ""
"*skip_curdir*\\가 참(기본값)이면, 현재 디렉터리가 검색에 포함되지 않습니다. 다른 모든 매개 변수는 "
":func:`compile_dir` 함수에 전달됩니다. 다른 컴파일 함수와 달리, ``maxlevels``\\의 기본값은 "
"``0``\\임에 유의하십시오."

#: ../../library/compileall.rst:323
msgid ""
"To force a recompile of all the :file:`.py` files in the :file:`Lib/` "
"subdirectory and all its subdirectories::"
msgstr ""
":file:`Lib/` 서브 디렉터리와 그것의 모든 서브 디렉터리에 있는 모든 :file:`.py` 파일을 강제로 다시 컴파일하려면"
" 다음과 같이 합니다::"

#: ../../library/compileall.rst:326
msgid ""
"import compileall\n"
"\n"
"compileall.compile_dir('Lib/', force=True)\n"
"\n"
"# Perform same compilation, excluding files in .svn directories.\n"
"import re\n"
"compileall.compile_dir('Lib/', rx=re.compile(r'[/\\\\][.]svn'), "
"force=True)\n"
"\n"
"# pathlib.Path objects can also be used.\n"
"import pathlib\n"
"compileall.compile_dir(pathlib.Path('Lib/'), force=True)"
msgstr ""
"import compileall\n"
"\n"
"compileall.compile_dir('Lib/', force=True)\n"
"\n"
"# .svn 디렉터리의 파일을 제외하고, 같은 컴파일을 수행합니다.\n"
"import re\n"
"compileall.compile_dir('Lib/', rx=re.compile(r'[/\\\\][.]svn'), "
"force=True)\n"
"\n"
"# pathlib.Path 객체도 사용할 수 있습니다.\n"
"import pathlib\n"
"compileall.compile_dir(pathlib.Path('Lib/'), force=True)"

#: ../../library/compileall.rst:340
msgid "Module :mod:`py_compile`"
msgstr "모듈 :mod:`py_compile`"

#: ../../library/compileall.rst:341
msgid "Byte-compile a single source file."
msgstr "단일 소스 파일을 바이트 컴파일합니다."

