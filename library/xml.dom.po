# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/xml.dom.rst:2
#, fuzzy
msgid ":mod:`!xml.dom` --- The Document Object Model API"
msgstr ":mod:`xml.dom` --- 문서 객체 모델 API"

#: ../../library/xml.dom.rst:10
msgid "**Source code:** :source:`Lib/xml/dom/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/xml/dom/__init__.py`"

#: ../../library/xml.dom.rst:14
msgid ""
"The Document Object Model, or \"DOM,\" is a cross-language API from the "
"World Wide Web Consortium (W3C) for accessing and modifying XML "
"documents.  A DOM implementation presents an XML document as a tree "
"structure, or allows client code to build such a structure from scratch."
"  It then gives access to the structure through a set of objects which "
"provided well-known interfaces."
msgstr ""
"문서 객체 모델(Document Object Model), 또는 \"DOM\"은 XML 문서를 액세스하고 수정하기 위한 "
"W3C(World Wide Web Consortium)의 교차 언어 API입니다. DOM 구현은 XML 문서를 트리 구조로 "
"나타내거나, 클라이언트 코드가 이러한 구조를 처음부터 구축 할 수 있도록 합니다. 그런 다음 잘 알려진 인터페이스를 제공하는 객체 "
"집합을 통해 구조에 액세스 할 수 있습니다."

#: ../../library/xml.dom.rst:20
msgid ""
"The DOM is extremely useful for random-access applications.  SAX only "
"allows you a view of one bit of the document at a time.  If you are "
"looking at one SAX element, you have no access to another.  If you are "
"looking at a text node, you have no access to a containing element. When "
"you write a SAX application, you need to keep track of your program's "
"position in the document somewhere in your own code.  SAX does not do it "
"for you.  Also, if you need to look ahead in the XML document, you are "
"just out of luck."
msgstr ""
"DOM은 무작위 액세스 응용 프로그램에 매우 유용합니다. SAX에서는 한 번에 한 조각의 문서만 볼 수 있습니다. 하나의 SAX "
"요소를 보고 있는 동안, 다른 SAX 요소에 액세스할 수 없습니다. 텍스트 노드를 보고 있으면, 이것을 포함하는 요소에 액세스할 수"
" 없습니다. SAX 응용 프로그램을 작성할 때는, 문서에서의 프로그램의 위치를 자신의 코드 어딘가에서 추적해야 합니다. SAX는 "
"여러분을 위해 대신해주지 않습니다. 또한, XML 문서를 미리 보아야 한다면, 운이 다했다고 보아야 합니다."

#: ../../library/xml.dom.rst:28
msgid ""
"Some applications are simply impossible in an event driven model with no "
"access to a tree.  Of course you could build some sort of tree yourself "
"in SAX events, but the DOM allows you to avoid writing that code.  The "
"DOM is a standard tree representation for XML data."
msgstr ""
"트리에 액세스할 수 없는 이벤트 중심 모델에서는 일부 응용 프로그램이 불가능합니다. 물론 SAX 이벤트에서 트리를 직접 만들 수는 "
"있지만, DOM을 사용하면 그런 코드를 작성하지 않아도 됩니다. DOM은 XML 데이터의 표준 트리 표현입니다."

#: ../../library/xml.dom.rst:33
msgid ""
"The Document Object Model is being defined by the W3C in stages, or "
"\"levels\" in their terminology.  The Python mapping of the API is "
"substantially based on the DOM Level 2 recommendation."
msgstr ""
"문서 객체 모델은 W3C에 의해 단계적으로 또는 그들의 용어로는 \"수준\"으로 정의됩니다. API의 파이썬 매핑은 실질적으로 "
"DOM 수준 2 권장 사항을 기반으로 합니다."

#: ../../library/xml.dom.rst:45
msgid ""
"DOM applications typically start by parsing some XML into a DOM.  How "
"this is accomplished is not covered at all by DOM Level 1, and Level 2 "
"provides only limited improvements: There is a :class:`DOMImplementation`"
" object class which provides access to :class:`Document` creation "
"methods, but no way to access an XML reader/parser/Document builder in an"
" implementation-independent way. There is also no well-defined way to "
"access these methods without an existing :class:`Document` object.  In "
"Python, each DOM implementation will provide a function "
":func:`getDOMImplementation`. DOM Level 3 adds a Load/Store "
"specification, which defines an interface to the reader, but this is not "
"yet available in the Python standard library."
msgstr ""
"DOM 응용 프로그램은 일반적으로 일부 XML을 DOM으로 구문 분석하는 것으로 시작합니다. 이것을 달성하는 방법은 DOM 수준 "
"1은 전혀 다루지 않으며, 수준 2는 제한된 개선만을 제공합니다: :class:`Document` 생성 메서드에 대한 액세스를 "
"제공하는 :class:`DOMImplementation` 객체 클래스가 있습니다만, 구현에 독립적인 방법으로 XML "
"판독기(reader)/기록기(writer)/Document 구축기(builder)를 액세스하는 방법이 없습니다. 기존 "
":class:`Document` 객체 없이 이러한 메서드에 액세스할 수 있는 잘 정의된 방법도 없습니다. 파이썬에서, 각 DOM "
"구현은 :func:`getDOMImplementation` 함수를 제공합니다. DOM 수준 3은 판독기(reader)에 대한 "
"인터페이스를 정의하는 로드/저장 명세를 추가하지만, 아직 파이썬 표준 라이브러리에서는 사용할 수 없습니다."

#: ../../library/xml.dom.rst:56
msgid ""
"Once you have a DOM document object, you can access the parts of your XML"
" document through its properties and methods.  These properties are "
"defined in the DOM specification; this portion of the reference manual "
"describes the interpretation of the specification in Python."
msgstr ""
"일단 DOM 문서 객체가 있으면, 프로퍼티와 메서드를 통해 XML 문서의 일부에 액세스 할 수 있습니다. 이러한 프로퍼티는 DOM "
"명세에 정의되어 있습니다; 레퍼런스 설명서의 이 부분은 파이썬이 명세를 해석하는 방법을 설명합니다."

#: ../../library/xml.dom.rst:61
msgid ""
"The specification provided by the W3C defines the DOM API for Java, "
"ECMAScript, and OMG IDL.  The Python mapping defined here is based in "
"large part on the IDL version of the specification, but strict compliance"
" is not required (though implementations are free to support the strict "
"mapping from IDL).  See section :ref:`dom-conformance` for a detailed "
"discussion of mapping requirements."
msgstr ""
"W3C에서 제공하는 명세는 Java, ECMAScript 및 OMG IDL 용 DOM API를 정의합니다. 여기에 정의된 파이썬 "
"매핑은 대부분 명세의 IDL 버전을 기반으로 하지만, 엄격한 준수는 필요하지 않습니다 (구현은 IDL의 엄격한 매핑을 자유롭게 "
"지원할 수 있습니다). 매핑 요구 사항에 대한 자세한 내용은 :ref:`dom-conformance` 절을 참조하십시오."

#: ../../library/xml.dom.rst:70
msgid ""
"`Document Object Model (DOM) Level 2 Specification "
"<https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/>`_"
msgstr ""
"`Document Object Model (DOM) Level 2 Specification "
"<https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/>`_"

#: ../../library/xml.dom.rst:71
msgid "The W3C recommendation upon which the Python DOM API is based."
msgstr "파이썬 DOM API의 기반이 되는 W3C 권장 사항."

#: ../../library/xml.dom.rst:73
msgid ""
"`Document Object Model (DOM) Level 1 Specification <https://www.w3.org/TR"
"/REC-DOM-Level-1/>`_"
msgstr ""
"`Document Object Model (DOM) Level 1 Specification <https://www.w3.org/TR"
"/REC-DOM-Level-1/>`_"

#: ../../library/xml.dom.rst:74
msgid "The W3C recommendation for the DOM supported by :mod:`xml.dom.minidom`."
msgstr ":mod:`xml.dom.minidom`\\이 지원하는 DOM에 대한 W3C 권장 사항."

#: ../../library/xml.dom.rst:76
#, fuzzy
msgid ""
"`Python Language Mapping Specification "
"<https://www.omg.org/spec/PYTH/1.2/PDF>`_"
msgstr ""
"`Python Language Mapping Specification <http://www.omg.org/cgi-"
"bin/doc?formal/02-11-05.pdf>`_"

#: ../../library/xml.dom.rst:77
msgid "This specifies the mapping from OMG IDL to Python."
msgstr "OMG IDL에서 파이썬으로의 매핑을 지정합니다."

#: ../../library/xml.dom.rst:81
msgid "Module Contents"
msgstr "모듈 내용"

#: ../../library/xml.dom.rst:83
msgid "The :mod:`xml.dom` contains the following functions:"
msgstr ":mod:`xml.dom`\\에는 다음 함수가 포함되어 있습니다:"

#: ../../library/xml.dom.rst:88
msgid ""
"Register the *factory* function with the name *name*.  The factory "
"function should return an object which implements the "
":class:`DOMImplementation` interface.  The factory function can return "
"the same object every time, or a new one for each call, as appropriate "
"for the specific implementation (e.g. if that implementation supports "
"some customization)."
msgstr ""
"*factory* 함수를 *name*\\이라는 이름으로 등록합니다. 팩토리(factory) 함수는 "
":class:`DOMImplementation` 인터페이스를 구현하는 객체를 반환해야 합니다. 팩토리 함수는 호출 때마다 같은 "
"객체를 반환하거나 특정 구현에 적합하다면 새 객체를 반환할 수 있습니다 (예를 들어, 해당 구현이 일부 사용자 정의를 지원하는 "
"경우)."

#: ../../library/xml.dom.rst:97
msgid ""
"Return a suitable DOM implementation. The *name* is either well-known, "
"the module name of a DOM implementation, or ``None``. If it is not "
"``None``, imports the corresponding module and returns a "
":class:`DOMImplementation` object if the import succeeds.  If no name is "
"given, and if the environment variable :envvar:`PYTHON_DOM` is set, this "
"variable is used to find the implementation."
msgstr ""
"적절한 DOM 구현을 반환합니다. *name*\\은 잘 알려진 DOM 구현의 모듈 이름이거나, ``None``\\입니다. "
"``None``\\이 아니면, 해당 모듈을 임포트하고 성공하면 :class:`DOMImplementation` 객체를 반환합니다. "
"이름이 지정되지 않고, 환경 변수 :envvar:`PYTHON_DOM`\\이 설정되면, 이 변수를 구현을 찾는 데 사용합니다."

#: ../../library/xml.dom.rst:103
msgid ""
"If name is not given, this examines the available implementations to find"
" one with the required feature set.  If no implementation can be found, "
"raise an :exc:`ImportError`.  The features list must be a sequence of "
"``(feature, version)`` pairs which are passed to the :meth:`hasFeature` "
"method on available :class:`DOMImplementation` objects."
msgstr ""
"이름을 지정하지 않으면, 사용 가능한 구현을 검사하여 필요한 기능 집합이 있는 구현을 찾습니다. 구현을 찾을 수 없으면, "
":exc:`ImportError`\\를 발생시킵니다. 기능 목록은 사용 가능한 :class:`DOMImplementation` "
"객체의 :meth:`hasFeature` 메서드로 전달되는 ``(feature, version)`` 쌍의 시퀀스여야 합니다."

#: ../../library/xml.dom.rst:109
msgid "Some convenience constants are also provided:"
msgstr "몇 가지 편의 상수도 제공됩니다:"

#: ../../library/xml.dom.rst:114
msgid ""
"The value used to indicate that no namespace is associated with a node in"
" the DOM.  This is typically found as the :attr:`namespaceURI` of a node,"
" or used as the *namespaceURI* parameter to a namespaces-specific method."
msgstr ""
"이름 공간이 DOM의 노드와 연결되어 있지 않음을 나타내는 데 사용되는 값. 이것은 일반적으로 노드의 "
":attr:`namespaceURI`\\에서 발견되거나, 이름 공간별 메서드에 대한 *namespaceURI* 매개 변수로 "
"사용됩니다."

#: ../../library/xml.dom.rst:121
msgid ""
"The namespace URI associated with the reserved prefix ``xml``, as defined"
" by `Namespaces in XML <https://www.w3.org/TR/REC-xml-names/>`_ (section "
"4)."
msgstr ""
"예약된 접두어 ``xml``\\과 연관된 이름 공간 URI, `Namespaces in XML "
"<https://www.w3.org/TR/REC-xml-names/>`_\\에서 정의됩니다 (4절)."

#: ../../library/xml.dom.rst:127
msgid ""
"The namespace URI for namespace declarations, as defined by `Document "
"Object Model (DOM) Level 2 Core Specification <https://www.w3.org/TR/DOM-"
"Level-2-Core/core.html>`_ (section 1.1.8)."
msgstr ""
"이름 공간 선언의 이름 공간 URI, `Document Object Model (DOM) Level 2 Core "
"Specification <https://www.w3.org/TR/DOM-Level-2-Core/core.html>`_\\에서 "
"정의됩니다 (1.1.8 절)."

#: ../../library/xml.dom.rst:134
msgid ""
"The URI of the XHTML namespace as defined by `XHTML 1.0: The Extensible "
"HyperText Markup Language <https://www.w3.org/TR/xhtml1/>`_ (section "
"3.1.1)."
msgstr ""
"XHTML 이름 공간의 URI, `XHTML 1.0: The Extensible HyperText Markup Language "
"<https://www.w3.org/TR/xhtml1/>`_\\에서 정의됩니다 (3.1.1 절)."

#: ../../library/xml.dom.rst:138
msgid ""
"In addition, :mod:`xml.dom` contains a base :class:`Node` class and the "
"DOM exception classes.  The :class:`Node` class provided by this module "
"does not implement any of the methods or attributes defined by the DOM "
"specification; concrete DOM implementations must provide those.  The "
":class:`Node` class provided as part of this module does provide the "
"constants used for the :attr:`nodeType` attribute on concrete "
":class:`Node` objects; they are located within the class rather than at "
"the module level to conform with the DOM specifications."
msgstr ""
"또한, :mod:`xml.dom`\\에는 베이스 :class:`Node` 클래스와 DOM 예외 클래스가 포함됩니다. 이 모듈에서 "
"제공하는 :class:`Node` 클래스는 DOM 명세에 정의된 메서드나 어트리뷰트를 구현하지 않습니다; 구상(concrete) "
"DOM 구현이 이를 제공해야 합니다. 이 모듈의 일부로 제공되는 :class:`Node` 클래스는 구상 :class:`Node` "
"객체의 :attr:`nodeType` 어트리뷰트에 사용되는 상수를 제공합니다; 그것들은 DOM 명세를 준수하기 위해 모듈 수준이 "
"아니라 클래스 내에 위치합니다."

#: ../../library/xml.dom.rst:153
msgid "Objects in the DOM"
msgstr "DOM의 객체"

#: ../../library/xml.dom.rst:155
msgid ""
"The definitive documentation for the DOM is the DOM specification from "
"the W3C."
msgstr "DOM에 대한 결정적인 문서는 W3C의 DOM 명세입니다."

#: ../../library/xml.dom.rst:157
msgid ""
"Note that DOM attributes may also be manipulated as nodes instead of as "
"simple strings.  It is fairly rare that you must do this, however, so "
"this usage is not yet documented."
msgstr ""
"DOM 어트리뷰트는 간단한 문자열 대신 노드로 조작될 수도 있음에 유의하십시오. 하지만 그렇게 해야만 하는 경우는 매우 드물어서, "
"이 사용법은 아직 문서화되지 않았습니다."

#: ../../library/xml.dom.rst:162
msgid "Interface"
msgstr "인터페이스"

#: ../../library/xml.dom.rst:162
msgid "Section"
msgstr "절"

#: ../../library/xml.dom.rst:162
msgid "Purpose"
msgstr "목적"

#: ../../library/xml.dom.rst:164
msgid ":class:`DOMImplementation`"
msgstr ":class:`DOMImplementation`"

#: ../../library/xml.dom.rst:164
msgid ":ref:`dom-implementation-objects`"
msgstr ":ref:`dom-implementation-objects`"

#: ../../library/xml.dom.rst:164
msgid "Interface to the underlying implementation."
msgstr "하부 구현에 대한 인터페이스."

#: ../../library/xml.dom.rst:167
msgid ":class:`Node`"
msgstr ":class:`Node`"

#: ../../library/xml.dom.rst:167
msgid ":ref:`dom-node-objects`"
msgstr ":ref:`dom-node-objects`"

#: ../../library/xml.dom.rst:167
msgid "Base interface for most objects in a document."
msgstr "문서에 있는 대부분 객체에 대한 베이스 인터페이스."

#: ../../library/xml.dom.rst:170
msgid ":class:`NodeList`"
msgstr ":class:`NodeList`"

#: ../../library/xml.dom.rst:170
msgid ":ref:`dom-nodelist-objects`"
msgstr ":ref:`dom-nodelist-objects`"

#: ../../library/xml.dom.rst:170
msgid "Interface for a sequence of nodes."
msgstr "노드의 시퀀스를 위한 인터페이스."

#: ../../library/xml.dom.rst:173
msgid ":class:`DocumentType`"
msgstr ":class:`DocumentType`"

#: ../../library/xml.dom.rst:173
msgid ":ref:`dom-documenttype-objects`"
msgstr ":ref:`dom-documenttype-objects`"

#: ../../library/xml.dom.rst:173
msgid "Information about the declarations needed to process a document."
msgstr "문서를 처리하는 데 필요한 선언에 대한 정보."

#: ../../library/xml.dom.rst:177
msgid ":class:`Document`"
msgstr ":class:`Document`"

#: ../../library/xml.dom.rst:177
msgid ":ref:`dom-document-objects`"
msgstr ":ref:`dom-document-objects`"

#: ../../library/xml.dom.rst:177
msgid "Object which represents an entire document."
msgstr "전체 문서를 나타내는 객체."

#: ../../library/xml.dom.rst:180
msgid ":class:`Element`"
msgstr ":class:`Element`"

#: ../../library/xml.dom.rst:180
msgid ":ref:`dom-element-objects`"
msgstr ":ref:`dom-element-objects`"

#: ../../library/xml.dom.rst:180
msgid "Element nodes in the document hierarchy."
msgstr "문서 계층의 엘리먼트 노드."

#: ../../library/xml.dom.rst:183
msgid ":class:`Attr`"
msgstr ":class:`Attr`"

#: ../../library/xml.dom.rst:183
msgid ":ref:`dom-attr-objects`"
msgstr ":ref:`dom-attr-objects`"

#: ../../library/xml.dom.rst:183
msgid "Attribute value nodes on element nodes."
msgstr "엘리먼트 노드의 어트리뷰트 값 노드"

#: ../../library/xml.dom.rst:186
msgid ":class:`Comment`"
msgstr ":class:`Comment`"

#: ../../library/xml.dom.rst:186
msgid ":ref:`dom-comment-objects`"
msgstr ":ref:`dom-comment-objects`"

#: ../../library/xml.dom.rst:186
msgid "Representation of comments in the source document."
msgstr "소스 문서에 있는 주석의 표현."

#: ../../library/xml.dom.rst:189
msgid ":class:`Text`"
msgstr ":class:`Text`"

#: ../../library/xml.dom.rst:189
msgid ":ref:`dom-text-objects`"
msgstr ":ref:`dom-text-objects`"

#: ../../library/xml.dom.rst:189
msgid "Nodes containing textual content from the document."
msgstr "문서의 텍스트 내용을 포함하는 노드."

#: ../../library/xml.dom.rst:192
msgid ":class:`ProcessingInstruction`"
msgstr ":class:`ProcessingInstruction`"

#: ../../library/xml.dom.rst:192
msgid ":ref:`dom-pi-objects`"
msgstr ":ref:`dom-pi-objects`"

#: ../../library/xml.dom.rst:192
msgid "Processing instruction representation."
msgstr "처리 명령어 표현."

#: ../../library/xml.dom.rst:196
msgid ""
"An additional section describes the exceptions defined for working with "
"the DOM in Python."
msgstr "추가 절에서 파이썬에서 DOM 작업을 위해 정의된 예외에 관해 설명합니다."

#: ../../library/xml.dom.rst:203
msgid "DOMImplementation Objects"
msgstr "DOMImplementation 객체"

#: ../../library/xml.dom.rst:205
msgid ""
"The :class:`DOMImplementation` interface provides a way for applications "
"to determine the availability of particular features in the DOM they are "
"using. DOM Level 2 added the ability to create new :class:`Document` and "
":class:`DocumentType` objects using the :class:`DOMImplementation` as "
"well."
msgstr ""
":class:`DOMImplementation` 인터페이스는 응용 프로그램이 사용 중인 DOM에서 특정 기능의 가용성을 판별할 "
"방법을 제공합니다. DOM 수준 2는 :class:`DOMImplementation`\\을 사용하여 새로운 "
":class:`Document`\\와 :class:`DocumentType` 객체를 만드는 기능을 추가했습니다."

#: ../../library/xml.dom.rst:213
msgid ""
"Return ``True`` if the feature identified by the pair of strings "
"*feature* and *version* is implemented."
msgstr "문자열 *feature*\\와 *version* 쌍으로 식별되는 기능이 구현되었으면 ``True``\\를 반환합니다."

#: ../../library/xml.dom.rst:219
msgid ""
"Return a new :class:`Document` object (the root of the DOM), with a child"
" :class:`Element` object having the given *namespaceUri* and "
"*qualifiedName*. The *doctype* must be a :class:`DocumentType` object "
"created by :meth:`createDocumentType`, or ``None``. In the Python DOM "
"API, the first two arguments can also be ``None`` in order to indicate "
"that no :class:`Element` child is to be created."
msgstr ""
"지정된 *namespaceUri*\\와 *qualifiedName*\\을 가진 자식 :class:`Element` 객체를 포함하는 "
"새 :class:`Document` 객체(DOM의 루트)를 반환합니다. *doctype*\\은 "
":meth:`createDocumentType`\\으로 만든 :class:`DocumentType` 객체거나 "
"``None``\\이어야 합니다. 파이썬 DOM API에서, :class:`Element` 자식이 만들어지지 않음을 표시하기 위해 "
"처음 두 인자는 ``None``\\일 수 있습니다."

#: ../../library/xml.dom.rst:229
msgid ""
"Return a new :class:`DocumentType` object that encapsulates the given "
"*qualifiedName*, *publicId*, and *systemId* strings, representing the "
"information contained in an XML document type declaration."
msgstr ""
"XML 문서 형 선언에 포함된 정보를 나타내는, 지정된 *qualifiedName*, *publicId* 및 *systemId* "
"문자열을 캡슐화하는 새 :class:`DocumentType` 객체를 반환합니다."

#: ../../library/xml.dom.rst:237
msgid "Node Objects"
msgstr "Node 객체"

#: ../../library/xml.dom.rst:239
msgid "All of the components of an XML document are subclasses of :class:`Node`."
msgstr "XML 문서의 모든 구성 요소는 :class:`Node`\\의 서브 클래스입니다."

#: ../../library/xml.dom.rst:244
msgid ""
"An integer representing the node type.  Symbolic constants for the types "
"are on the :class:`Node` object: :const:`ELEMENT_NODE`, "
":const:`ATTRIBUTE_NODE`, :const:`TEXT_NODE`, :const:`CDATA_SECTION_NODE`,"
" :const:`ENTITY_NODE`, :const:`PROCESSING_INSTRUCTION_NODE`, "
":const:`COMMENT_NODE`, :const:`DOCUMENT_NODE`, "
":const:`DOCUMENT_TYPE_NODE`, :const:`NOTATION_NODE`. This is a read-only "
"attribute."
msgstr ""
"노드 형을 나타내는 정수. 형의 기호 상수는 :class:`Node` 객체에 있습니다: :const:`ELEMENT_NODE`, "
":const:`ATTRIBUTE_NODE`, :const:`TEXT_NODE`, :const:`CDATA_SECTION_NODE`,"
" :const:`ENTITY_NODE`, :const:`PROCESSING_INSTRUCTION_NODE`, "
":const:`COMMENT_NODE`, :const:`DOCUMENT_NODE`, "
":const:`DOCUMENT_TYPE_NODE`, :const:`NOTATION_NODE`. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:254
msgid ""
"The parent of the current node, or ``None`` for the document node. The "
"value is always a :class:`Node` object or ``None``.  For :class:`Element`"
" nodes, this will be the parent element, except for the root element, in "
"which case it will be the :class:`Document` object. For :class:`Attr` "
"nodes, this is always ``None``. This is a read-only attribute."
msgstr ""
"현재 노드의 부모, 또는 문서 노드의 경우 ``None``. 값은 항상 :class:`Node` 객체나 ``None``\\입니다. "
":class:`Element` 노드의 경우, 이것은 부모 엘리먼트가 되는데, 루트 엘리먼트는 예외로, 이때는 "
":class:`Document` 객체가 됩니다. :class:`Attr` 노드의 경우, 항상 ``None``\\입니다. 이것은 읽기"
" 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:263
msgid ""
"A :class:`NamedNodeMap` of attribute objects.  Only elements have actual "
"values for this; others provide ``None`` for this attribute. This is a "
"read-only attribute."
msgstr ""
"어트리뷰트 객체의 :class:`NamedNodeMap`. 엘리먼트에만 실제 값이 있습니다; 다른 것은 이 어트리뷰트에서 "
"``None``\\을 제공합니다. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:270
msgid ""
"The node that immediately precedes this one with the same parent.  For "
"instance the element with an end-tag that comes just before the *self* "
"element's start-tag.  Of course, XML documents are made up of more than "
"just elements so the previous sibling could be text, a comment, or "
"something else. If this node is the first child of the parent, this "
"attribute will be ``None``. This is a read-only attribute."
msgstr ""
"같은 부모를 갖고 이 노드 바로 앞에 있는 노드. 예를 들어 *self* 엘리먼트의 시작 태그 바로 앞에 오는 종료 태그의 "
"엘리먼트. 물론, XML 문서는 단순히 엘리먼트만으로 구성되지 않기 때문에, 이전 형제(previous sibling)는 텍스트, "
"주석 또는 뭔가 다른 것이 될 수 있습니다. 이 노드가 부모의 첫 번째 자식이면, 이 어트리뷰트는 ``None``\\입니다. 이것은"
" 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:280
msgid ""
"The node that immediately follows this one with the same parent.  See "
"also :attr:`previousSibling`.  If this is the last child of the parent, "
"this attribute will be ``None``. This is a read-only attribute."
msgstr ""
"같은 부모를 갖고 이 노드 바로 뒤에 나오는 노드. :attr:`previousSibling`\\도 참조하십시오. 이것이 부모의 "
"마지막 자식이면, 이 어트리뷰트는 ``None``\\입니다. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:287
msgid "A list of nodes contained within this node. This is a read-only attribute."
msgstr "이 노드에 포함된 노드의 리스트. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:292
msgid ""
"The first child of the node, if there are any, or ``None``. This is a "
"read-only attribute."
msgstr "노드의 첫 번째 자식 (있다면), 또는 ``None``. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:298
msgid ""
"The last child of the node, if there are any, or ``None``. This is a "
"read-only attribute."
msgstr "노드의 마지막 자식 (있다면), 또는 ``None``. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:304
msgid ""
"The part of the :attr:`tagName` following the colon if there is one, else"
" the entire :attr:`tagName`.  The value is a string."
msgstr ""
"콜론이 있으면 그 뒤에 오는 :attr:`tagName`\\의 부분, 그렇지 않으면 전체 :attr:`tagName`. 값은 "
"문자열입니다."

#: ../../library/xml.dom.rst:310
msgid ""
"The part of the :attr:`tagName` preceding the colon if there is one, else"
" the empty string.  The value is a string, or ``None``."
msgstr ""
"콜론이 있으면 그 앞에 오는 :attr:`tagName`\\의 부분, 그렇지 않으면 빈 문자열. 값은 문자열이나 "
"``None``\\입니다."

#: ../../library/xml.dom.rst:316
msgid ""
"The namespace associated with the element name.  This will be a string or"
" ``None``.  This is a read-only attribute."
msgstr "엘리먼트 이름과 연관된 이름 공간. 이것은 문자열이나 ``None``\\입니다. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:322
msgid ""
"This has a different meaning for each node type; see the DOM "
"specification for details.  You can always get the information you would "
"get here from another property such as the :attr:`tagName` property for "
"elements or the :attr:`name` property for attributes. For all node types,"
" the value of this attribute will be either a string or ``None``.  This "
"is a read-only attribute."
msgstr ""
"이는 각 노드 형마다 다른 의미입니다; 자세한 내용은 DOM 명세를 참조하십시오. 여기서 얻는 정보를 항상 다른 프로퍼티에서 얻을 "
"수 있습니다, 가령 엘리먼트의 :attr:`tagName` 프로퍼티나 어트리뷰트의 :attr:`name` 프로퍼티. 모든 노드 "
"형에서, 이 어트리뷰트의 값은 문자열이나 ``None``\\입니다. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:331
msgid ""
"This has a different meaning for each node type; see the DOM "
"specification for details.  The situation is similar to that with "
":attr:`nodeName`.  The value is a string or ``None``."
msgstr ""
"이는 각 노드 형마다 다른 의미입니다; 자세한 내용은 DOM 명세를 참조하십시오. 상황은 :attr:`nodeName`\\과 "
"유사합니다. 값은 문자열이나 ``None``\\입니다."

#: ../../library/xml.dom.rst:338
msgid "Return ``True`` if the node has any attributes."
msgstr "노드에 어트리뷰트가 있으면 ``True``\\를 반환합니다."

#: ../../library/xml.dom.rst:343
msgid "Return ``True`` if the node has any child nodes."
msgstr "노드에 자식 노드가 있으면 ``True``\\를 반환합니다."

#: ../../library/xml.dom.rst:348
msgid ""
"Return ``True`` if *other* refers to the same node as this node. This is "
"especially useful for DOM implementations which use any sort of proxy "
"architecture (because more than one object can refer to the same node)."
msgstr ""
"*other*\\가 이 노드와 같은 노드를 가리키면 ``True``\\를 반환합니다. 이것은 모든 종류의 프락시 구조를 사용하는 "
"DOM 구현에서 특히 유용합니다 (여러 객체가 같은 노드를 가리킬 수 있기 때문입니다)."

#: ../../library/xml.dom.rst:354
msgid ""
"This is based on a proposed DOM Level 3 API which is still in the "
"\"working draft\" stage, but this particular interface appears "
"uncontroversial.  Changes from the W3C will not necessarily affect this "
"method in the Python DOM interface (though any new W3C API for this would"
" also be supported)."
msgstr ""
"이것은 여전히 \"작업 초안\" 단계에 있는 제안된 DOM 수준 3 API를 기반으로 하지만, 이 특정 인터페이스는 논란의 여지가 "
"없는 것으로 보입니다. W3C의 변경 사항이 파이썬 DOM 인터페이스에서 이 메서드에 반드시 영향을 미치는 것은 아닙니다 (이를 "
"위한 새 W3C API도 지원되기는 하겠지만)."

#: ../../library/xml.dom.rst:362
msgid ""
"Add a new child node to this node at the end of the list of children, "
"returning *newChild*. If the node was already in the tree, it is removed "
"first."
msgstr ""
"자식 리스트의 끝에 이 노드의 새 자식 노드를 추가하고, *newChild*\\를 반환합니다. 노드가 이미 트리에 있으면, 먼저 "
"제거됩니다."

#: ../../library/xml.dom.rst:369
msgid ""
"Insert a new child node before an existing child.  It must be the case "
"that *refChild* is a child of this node; if not, :exc:`ValueError` is "
"raised. *newChild* is returned. If *refChild* is ``None``, it inserts "
"*newChild* at the end of the children's list."
msgstr ""
"기존 자식 앞에 새 자식 노드를 삽입합니다. *refChild*\\가 이 노드의 자식이어야 합니다; 그렇지 않으면 "
":exc:`ValueError`\\가 발생합니다. *newChild*\\가 반환됩니다. *refChild*\\가 "
"``None``\\이면, 자식 리스트의 끝에 *newChild*\\를 삽입합니다."

#: ../../library/xml.dom.rst:377
msgid ""
"Remove a child node.  *oldChild* must be a child of this node; if not, "
":exc:`ValueError` is raised.  *oldChild* is returned on success.  If "
"*oldChild* will not be used further, its :meth:`unlink` method should be "
"called."
msgstr ""
"자식 노드를 제거합니다. *oldChild*\\는 이 노드의 자식이어야 합니다; 그렇지 않으면, "
":exc:`ValueError`\\가 발생합니다. 성공하면 *oldChild*\\가 반환됩니다. *oldChild*\\가 더는 "
"사용되지 않으면, 그것의 :meth:`unlink` 메서드를 호출해야 합니다."

#: ../../library/xml.dom.rst:384
msgid ""
"Replace an existing node with a new node. It must be the case that  "
"*oldChild* is a child of this node; if not, :exc:`ValueError` is raised."
msgstr ""
"기존 노드를 새 노드로 교체합니다. *oldChild*\\는 이 노드의 자식이어야 합니다. 그렇지 않으면, "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/xml.dom.rst:390
msgid ""
"Join adjacent text nodes so that all stretches of text are stored as "
"single :class:`Text` instances.  This simplifies processing text from a "
"DOM tree for many applications."
msgstr ""
"모든 텍스트 스트레치(stretch)가 단일 :class:`Text` 인스턴스로 저장되도록, 인접한 텍스트 노드를 결합합니다. 이는"
" 많은 응용 프로그램에서 DOM 트리의 텍스트 처리를 단순화합니다."

#: ../../library/xml.dom.rst:397
msgid ""
"Clone this node.  Setting *deep* means to clone all child nodes as well."
"  This returns the clone."
msgstr "이 노드를 복제합니다. *deep*\\을 설정하면 모든 자식 노드도 복제됩니다. 복제를 반환합니다."

#: ../../library/xml.dom.rst:404
msgid "NodeList Objects"
msgstr "NodeList 객체"

#: ../../library/xml.dom.rst:406
msgid ""
"A :class:`NodeList` represents a sequence of nodes.  These objects are "
"used in two ways in the DOM Core recommendation:  an :class:`Element` "
"object provides one as its list of child nodes, and the "
":meth:`getElementsByTagName` and :meth:`getElementsByTagNameNS` methods "
"of :class:`Node` return objects with this interface to represent query "
"results."
msgstr ""
":class:`NodeList`\\는 노드의 시퀀스를 나타냅니다. 이러한 객체는 DOM Core 권장 사항에서 두 가지 방식으로 "
"사용됩니다: :class:`Element` 객체는 자식 노드의 리스트를 제공하고, :class:`Node`\\의 "
":meth:`getElementsByTagName`\\과 :meth:`getElementsByTagNameNS` 메서드는 이 "
"인터페이스를 사용하여 조회 결과를 나타냅니다."

#: ../../library/xml.dom.rst:412
msgid ""
"The DOM Level 2 recommendation defines one method and one attribute for "
"these objects:"
msgstr "DOM 수준 2 권장 사항은 이러한 객체에 대해 하나의 메서드와 하나의 어트리뷰트를 정의합니다:"

#: ../../library/xml.dom.rst:418
msgid ""
"Return the *i*'th item from the sequence, if there is one, or ``None``.  "
"The index *i* is not allowed to be less than zero or greater than or "
"equal to the length of the sequence."
msgstr ""
"시퀀스의 *i* 번째 항목(있다면)이나 ``None``\\을 반환합니다. 인덱스 *i*\\는 0보다 작거나 시퀀스의 길이보다 크거나"
" 같을 수 없습니다."

#: ../../library/xml.dom.rst:425
msgid "The number of nodes in the sequence."
msgstr "시퀀스의 노드 수."

#: ../../library/xml.dom.rst:427
msgid ""
"In addition, the Python DOM interface requires that some additional "
"support is provided to allow :class:`NodeList` objects to be used as "
"Python sequences.  All :class:`NodeList` implementations must include "
"support for :meth:`~object.__len__` and :meth:`~object.__getitem__`; this"
" allows iteration over the :class:`NodeList` in :keyword:`for` statements"
" and proper support for the :func:`len` built-in function."
msgstr ""
"또한, 파이썬 DOM 인터페이스는 :class:`NodeList` 객체를 파이썬 시퀀스로 사용할 수 있도록 몇 가지 추가 지원을 "
"요구합니다. 모든 :class:`NodeList` 구현에는 :meth:`~object.__len__`\\과 "
":meth:`~object.__getitem__`\\에 대한 지원이 포함되어야 합니다; 이를 통해 :keyword:`for` 문에서"
" :class:`NodeList`\\를 이터레이트할 수 있고, :func:`len` 내장 함수를 적절히 지원할 수 있습니다."

#: ../../library/xml.dom.rst:435
msgid ""
"If a DOM implementation supports modification of the document, the "
":class:`NodeList` implementation must also support the "
":meth:`~object.__setitem__` and :meth:`~object.__delitem__` methods."
msgstr ""
"DOM 구현이 문서 수정을 지원하면, :class:`NodeList` 구현은 :meth:`~object.__setitem__`\\과"
" :meth:`~object.__delitem__` 메서드도 지원해야 합니다."

#: ../../library/xml.dom.rst:443
msgid "DocumentType Objects"
msgstr "DocumentType 객체"

#: ../../library/xml.dom.rst:445
msgid ""
"Information about the notations and entities declared by a document "
"(including the external subset if the parser uses it and can provide the "
"information) is available from a :class:`DocumentType` object.  The "
":class:`DocumentType` for a document is available from the "
":class:`Document` object's :attr:`doctype` attribute; if there is no "
"``DOCTYPE`` declaration for the document, the document's :attr:`doctype` "
"attribute will be set to ``None`` instead of an instance of this "
"interface."
msgstr ""
"문서에 의해 선언된 표기법과 엔티티에 대한 정보(구문 분석기가 사용하고 정보를 제공할 수 있으면 외부 부분 집합(external "
"subset)을 포함하는)는 :class:`DocumentType` 객체에서 사용 가능합니다. 문서의 "
":class:`DocumentType`\\은 :class:`Document` 객체의 :attr:`doctype` 어트리뷰트에서 사용"
" 가능합니다; 문서에 ``DOCTYPE`` 선언이 없으면, 문서의 :attr:`doctype` 어트리뷰트는 이 인터페이스의 인스턴스"
" 대신 ``None``\\으로 설정됩니다."

#: ../../library/xml.dom.rst:453
msgid ""
":class:`DocumentType` is a specialization of :class:`Node`, and adds the "
"following attributes:"
msgstr ""
":class:`DocumentType`\\은 :class:`Node`\\의 특수화(specialization)이고 다음 어트리뷰트를"
" 추가합니다:"

#: ../../library/xml.dom.rst:459
msgid ""
"The public identifier for the external subset of the document type "
"definition. This will be a string or ``None``."
msgstr "문서 형 정의의 외부 부분 집합(external subset)에 대한 공용 식별자. 문자열이나 ``None``\\입니다."

#: ../../library/xml.dom.rst:465
msgid ""
"The system identifier for the external subset of the document type "
"definition. This will be a URI as a string, or ``None``."
msgstr ""
"문서 형 정의의 외부 부분 집합(external subset)에 대한 시스템 식별자. 문자열로 표현된 URI이거나 "
"``None``\\입니다."

#: ../../library/xml.dom.rst:471
msgid ""
"A string giving the complete internal subset from the document. This does"
" not include the brackets which enclose the subset.  If the document has "
"no internal subset, this should be ``None``."
msgstr ""
"문서에서 완전한 내부 부분 집합(internal subset)을 제공하는 문자열. 부분 집합을 묶는 대괄호는 포함되지 않습니다. "
"문서에 내부 부분 집합이 없으면 ``None``\\이어야 합니다."

#: ../../library/xml.dom.rst:478
msgid ""
"The name of the root element as given in the ``DOCTYPE`` declaration, if "
"present."
msgstr "``DOCTYPE`` 선언에 제공된 루트 엘리먼트의 이름 (있다면)."

#: ../../library/xml.dom.rst:484
msgid ""
"This is a :class:`NamedNodeMap` giving the definitions of external "
"entities. For entity names defined more than once, only the first "
"definition is provided (others are ignored as required by the XML "
"recommendation).  This may be ``None`` if the information is not provided"
" by the parser, or if no entities are defined."
msgstr ""
"외부 엔티티의 정의를 제공하는 :class:`NamedNodeMap`\\입니다. 엔티티 이름이 두 번 이상 정의되면, 첫 번째 정의"
" 만 제공됩니다 (XML 권장 사항에 따라 다른 정의는 무시됩니다). 구문 분석기가 정보를 제공하지 않거나 정의된 엔티티가 없으면 "
"``None``\\일 수 있습니다."

#: ../../library/xml.dom.rst:493
msgid ""
"This is a :class:`NamedNodeMap` giving the definitions of notations. For "
"notation names defined more than once, only the first definition is "
"provided (others are ignored as required by the XML recommendation).  "
"This may be ``None`` if the information is not provided by the parser, or"
" if no notations are defined."
msgstr ""
"표기법의 정의를 제공하는 :class:`NamedNodeMap`\\입니다. 표기법 이름이 두 번 이상 정의되면, 첫 번째 정의 만 "
"제공됩니다 (XML 권장 사항에 따라 다른 정의는 무시됩니다). 구문 분석기가 정보를 제공하지 않거나 정의된 표기법이 없으면 "
"``None``\\일 수 있습니다."

#: ../../library/xml.dom.rst:503
msgid "Document Objects"
msgstr "Document 객체"

#: ../../library/xml.dom.rst:505
msgid ""
"A :class:`Document` represents an entire XML document, including its "
"constituent elements, attributes, processing instructions, comments etc."
"  Remember that it inherits properties from :class:`Node`."
msgstr ""
":class:`Document`\\는 구성 엘리먼트, 어트리뷰트, 처리 명령어, 주석 등을 포함한 전체 XML 문서를 나타냅니다. "
":class:`Node`\\의 프로퍼티를 상속한다는 점을 기억하십시오."

#: ../../library/xml.dom.rst:512
msgid "The one and only root element of the document."
msgstr "문서의 유일한 루트 엘리먼트."

#: ../../library/xml.dom.rst:517
msgid ""
"Create and return a new element node.  The element is not inserted into "
"the document when it is created.  You need to explicitly insert it with "
"one of the other methods such as :meth:`insertBefore` or "
":meth:`appendChild`."
msgstr ""
"새 엘리먼트 노드를 만들고 반환합니다. 엘리먼트는 만들어질 때 문서에 삽입되지 않습니다. :meth:`insertBefore`\\나"
" :meth:`appendChild`\\와 같은 다른 메서드 중 하나를 사용하여 명시적으로 삽입해야 합니다."

#: ../../library/xml.dom.rst:524
msgid ""
"Create and return a new element with a namespace.  The *tagName* may have"
" a prefix.  The element is not inserted into the document when it is "
"created.  You need to explicitly insert it with one of the other methods "
"such as :meth:`insertBefore` or :meth:`appendChild`."
msgstr ""
"이름 공간을 사용하여 새 엘리먼트를 만들고 반환합니다. *tagName*\\은 접두사를 가질 수 있습니다. 엘리먼트는 만들어질 때 "
"문서에 삽입되지 않습니다. :meth:`insertBefore`\\나 :meth:`appendChild`\\와 같은 다른 메서드 중"
" 하나를 사용하여 명시적으로 삽입해야 합니다."

#: ../../library/xml.dom.rst:532
msgid ""
"Create and return a text node containing the data passed as a parameter."
"  As with the other creation methods, this one does not insert the node "
"into the tree."
msgstr ""
"매개 변수로 전달된 data를 포함하는 텍스트 노드를 만들고 반환합니다. 다른 생성 메서드와 마찬가지로 이 메서드는 노드를 트리에 "
"삽입하지 않습니다."

#: ../../library/xml.dom.rst:539
msgid ""
"Create and return a comment node containing the data passed as a "
"parameter.  As with the other creation methods, this one does not insert "
"the node into the tree."
msgstr ""
"매개 변수로 전달된 data를 포함하는 주석 노드를 만들고 반환합니다. 다른 생성 메서드와 마찬가지로 이 메서드는 노드를 트리에 "
"삽입하지 않습니다."

#: ../../library/xml.dom.rst:546
msgid ""
"Create and return a processing instruction node containing the *target* "
"and *data* passed as parameters.  As with the other creation methods, "
"this one does not insert the node into the tree."
msgstr ""
"매개 변수로 전달된 *target*\\과 *data*\\를 포함하는 처리 명령어 노드를 만들고 반환합니다. 다른 생성 메서드와 "
"마찬가지로 이 메서드는 노드를 트리에 삽입하지 않습니다."

#: ../../library/xml.dom.rst:553
msgid ""
"Create and return an attribute node.  This method does not associate the "
"attribute node with any particular element.  You must use "
":meth:`setAttributeNode` on the appropriate :class:`Element` object to "
"use the newly created attribute instance."
msgstr ""
"어트리뷰트 노드를 만들고 반환합니다. 이 메서드는 어트리뷰틀 노드를 특정 엘리먼트와 연관시키지 않습니다. 새로 만들어진 어트리뷰트 "
"인스턴스를 사용하려면 적절한 :class:`Element` 객체에서 :meth:`setAttributeNode`\\를 사용해야 "
"합니다."

#: ../../library/xml.dom.rst:561
msgid ""
"Create and return an attribute node with a namespace.  The *tagName* may "
"have a prefix.  This method does not associate the attribute node with "
"any particular element.  You must use :meth:`setAttributeNode` on the "
"appropriate :class:`Element` object to use the newly created attribute "
"instance."
msgstr ""
"이름 공간을 사용하여 어트리뷰트 노드를 만들고 반환합니다. *tagName*\\은 접두사를 가질 수 있습니다. 이 메서드는 "
"어트리뷰트 노드를 특정 엘리먼트와 연관시키지 않습니다. 새로 만들어진 어트리뷰트 인스턴스를 사용하려면 적절한 "
":class:`Element` 객체에서 :meth:`setAttributeNode`\\를 사용해야합니다."

#: ../../library/xml.dom.rst:569
msgid ""
"Search for all descendants (direct children, children's children, etc.) "
"with a particular element type name."
msgstr "특정 엘리먼트 형 이름을 가진 모든 자손(직계 자식, 자식의 자식 등)을 검색합니다."

#: ../../library/xml.dom.rst:575
msgid ""
"Search for all descendants (direct children, children's children, etc.) "
"with a particular namespace URI and localname.  The localname is the part"
" of the namespace after the prefix."
msgstr ""
"특정 이름 공간 URI와 지역 이름(localname)을 사용하여 모든 자손(직계 자식, 자식의 자식 등)을 검색합니다. 지역 "
"이름은 접두사 다음에 나오는 이름 공간의 일부입니다."

#: ../../library/xml.dom.rst:583
msgid "Element Objects"
msgstr "Element 객체"

#: ../../library/xml.dom.rst:585
msgid ""
":class:`Element` is a subclass of :class:`Node`, so inherits all the "
"attributes of that class."
msgstr ":class:`Element`\\는 :class:`Node`\\의 서브 클래스이므로, 모든 어트리뷰트를 상속합니다."

#: ../../library/xml.dom.rst:591
msgid ""
"The element type name.  In a namespace-using document it may have colons "
"in it. The value is a string."
msgstr "엘리먼트 형 이름. 이름 공간을 사용하는 문서에서는 콜론을 포함할 수 있습니다. 값은 문자열입니다."

#: ../../library/xml.dom.rst:597 ../../library/xml.dom.rst:602
msgid "Same as equivalent method in the :class:`Document` class."
msgstr ":class:`Document` 클래스의 동등한 메서드와 같습니다."

#: ../../library/xml.dom.rst:607
msgid "Return ``True`` if the element has an attribute named by *name*."
msgstr "엘리먼트에 *name*\\이라는 이름의 어트리뷰트가 있으면 ``True``\\를 반환합니다."

#: ../../library/xml.dom.rst:612
msgid ""
"Return ``True`` if the element has an attribute named by *namespaceURI* "
"and *localName*."
msgstr ""
"엘리먼트에 *namespaceURI*\\와 *localName*\\으로 이름이 지정된 어트리뷰트가 있으면 ``True``\\를 "
"반환합니다."

#: ../../library/xml.dom.rst:618
msgid ""
"Return the value of the attribute named by *name* as a string. If no such"
" attribute exists, an empty string is returned, as if the attribute had "
"no value."
msgstr ""
"*name*\\이라는 이름의 어트리뷰트의 값을 문자열로 반환합니다. 그러한 어트리뷰트가 없으면, 어트리뷰트에 값이 없는 것처럼 빈 "
"문자열이 반환됩니다."

#: ../../library/xml.dom.rst:624
msgid "Return the :class:`Attr` node for the attribute named by *attrname*."
msgstr "*attrname*\\이라는 이름의 어트리뷰트에 대한 :class:`Attr` 노드를 반환합니다."

#: ../../library/xml.dom.rst:629
msgid ""
"Return the value of the attribute named by *namespaceURI* and *localName*"
" as a string. If no such attribute exists, an empty string is returned, "
"as if the attribute had no value."
msgstr ""
"*namespaceURI*\\와 *localName*\\으로 이름이 지정된 어트리뷰트의 값을 문자열로 반환합니다. 그러한 "
"어트리뷰트가 없으면, 어트리뷰트에 값이 없는 것처럼 빈 문자열이 반환됩니다."

#: ../../library/xml.dom.rst:636
msgid ""
"Return an attribute value as a node, given a *namespaceURI* and "
"*localName*."
msgstr "*namespaceURI*\\와 *localName*\\으로 주어진 어트리뷰트의 값을 노드로 반환합니다."

#: ../../library/xml.dom.rst:641
msgid ""
"Remove an attribute by name.  If there is no matching attribute, a "
":exc:`NotFoundErr` is raised."
msgstr "이름(name)으로 어트리뷰트를 제거합니다. 일치하는 어트리뷰트가 없으면 :exc:`NotFoundErr`\\가 발생합니다."

#: ../../library/xml.dom.rst:647
msgid ""
"Remove and return *oldAttr* from the attribute list, if present. If "
"*oldAttr* is not present, :exc:`NotFoundErr` is raised."
msgstr ""
"존재하면, 어트리뷰트 목록에서 *oldAttr*\\를 제거하고 반환합니다. *oldAttr*\\가 없으면 "
":exc:`NotFoundErr`\\가 발생합니다."

#: ../../library/xml.dom.rst:653
msgid ""
"Remove an attribute by name.  Note that it uses a localName, not a qname."
"  No exception is raised if there is no matching attribute."
msgstr ""
"이름으로 어트리뷰트를 제거합니다. qname이 아닌 localName을 사용함에 유의하십시오. 일치하는 어트리뷰트가 없어도 예외가 "
"발생하지 않습니다."

#: ../../library/xml.dom.rst:659
msgid "Set an attribute value from a string."
msgstr "문자열로 어트리뷰트 값을 설정합니다."

#: ../../library/xml.dom.rst:664
msgid ""
"Add a new attribute node to the element, replacing an existing attribute "
"if necessary if the :attr:`name` attribute matches.  If a replacement "
"occurs, the old attribute node will be returned.  If *newAttr* is already"
" in use, :exc:`InuseAttributeErr` will be raised."
msgstr ""
"엘리먼트에 새 어트리뷰트 노드를 추가합니다. :attr:`name` 어트리뷰트가 일치할 때 필요하면 기존 어트리뷰트를 대체합니다. "
"대체가 발생하면, 이전 어트리뷰트 노드가 반환됩니다. *newAttr*\\가 이미 사용 중이면 "
":exc:`InuseAttributeErr`\\가 발생합니다."

#: ../../library/xml.dom.rst:672
msgid ""
"Add a new attribute node to the element, replacing an existing attribute "
"if necessary if the :attr:`namespaceURI` and :attr:`localName` attributes"
" match. If a replacement occurs, the old attribute node will be returned."
"  If *newAttr* is already in use, :exc:`InuseAttributeErr` will be "
"raised."
msgstr ""
"엘리먼트에 새 어트리뷰트 노드를 추가합니다. :attr:`namespaceURI`\\와 :attr:`localName` 어트리뷰트가"
" 일치할 때 필요하면 기존 어트리뷰트를 대체합니다. 대체가 발생하면 이전 어트리뷰트 노드가 반환됩니다. *newAttr*\\가 이미"
" 사용 중이면 :exc:`InuseAttributeErr`\\가 발생합니다."

#: ../../library/xml.dom.rst:680
msgid ""
"Set an attribute value from a string, given a *namespaceURI* and a "
"*qname*. Note that a qname is the whole attribute name.  This is "
"different than above."
msgstr ""
"문자열로 *namespaceURI*\\와 *qname*\\으로 지정된 어트리뷰트 값을 설정합니다. qname은 전체 어트리뷰트 "
"이름임에 유의하십시오. 이것은 위와 다릅니다."

#: ../../library/xml.dom.rst:687
msgid "Attr Objects"
msgstr "Attr 객체"

#: ../../library/xml.dom.rst:689
msgid ":class:`Attr` inherits from :class:`Node`, so inherits all its attributes."
msgstr ":class:`Attr`\\은 :class:`Node`\\를 상속하므로, 모든 어트리뷰트를 상속합니다."

#: ../../library/xml.dom.rst:694
msgid "The attribute name. In a namespace-using document it may include a colon."
msgstr "어트리뷰트 이름. 이름 공간을 사용하는 문서에서는 콜론을 포함할 수 있습니다."

#: ../../library/xml.dom.rst:700
msgid ""
"The part of the name following the colon if there is one, else the entire"
" name. This is a read-only attribute."
msgstr "콜론이 있으면 그 뒤에 오는 이름의 일부, 그렇지 않으면 전체 이름. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:707
msgid ""
"The part of the name preceding the colon if there is one, else the empty "
"string."
msgstr "콜론이 있으면 그 앞에 오는 이름의 일부, 그렇지 않으면 빈 문자열."

#: ../../library/xml.dom.rst:713
msgid ""
"The text value of the attribute.  This is a synonym for the "
":attr:`nodeValue` attribute."
msgstr "어트리뷰트의 텍스트 값. 이것은 :attr:`nodeValue` 어트리뷰트의 동의어입니다."

#: ../../library/xml.dom.rst:720
msgid "NamedNodeMap Objects"
msgstr "NamedNodeMap 객체"

#: ../../library/xml.dom.rst:722
msgid ":class:`NamedNodeMap` does *not* inherit from :class:`Node`."
msgstr ":class:`NamedNodeMap`\\은 :class:`Node`\\를 상속하지 *않습니다*."

#: ../../library/xml.dom.rst:727
msgid "The length of the attribute list."
msgstr "어트리뷰트 목록의 길이입니다."

#: ../../library/xml.dom.rst:732
msgid ""
"Return an attribute with a particular index.  The order you get the "
"attributes in is arbitrary but will be consistent for the life of a DOM."
"  Each item is an attribute node.  Get its value with the :attr:`value` "
"attribute."
msgstr ""
"특정 인덱스에 있는 어트리뷰트를 반환합니다. 어트리뷰트를 얻는 순서는 임의적이지만 DOM 수명 동안 일관적입니다. 각 항목은 "
"어트리뷰트 노드입니다. :attr:`value` 어트리뷰트로 값을 얻으십시오."

#: ../../library/xml.dom.rst:736
#, fuzzy
msgid ""
"There are also experimental methods that give this class more mapping "
"behavior. You can use them or you can use the standardized "
":meth:`!getAttribute\\*` family of methods on the :class:`Element` "
"objects."
msgstr ""
"이 클래스에 더 많은 매핑 동작을 제공하는 실험적인 메서드도 있습니다. 이를 사용하거나 :class:`Element` 객체에서 "
"표준화된 :meth:`getAttribute\\*` 메서드 집합을 사용할 수 있습니다."

#: ../../library/xml.dom.rst:744
msgid "Comment Objects"
msgstr "Comment 객체"

#: ../../library/xml.dom.rst:746
msgid ""
":class:`Comment` represents a comment in the XML document.  It is a "
"subclass of :class:`Node`, but cannot have child nodes."
msgstr ""
":class:`Comment`\\는 XML 문서의 주석을 나타냅니다. :class:`Node`\\의 서브 클래스이지만, 자식 노드를"
" 가질 수 없습니다."

#: ../../library/xml.dom.rst:752
msgid ""
"The content of the comment as a string.  The attribute contains all "
"characters between the leading ``<!-``\\ ``-`` and trailing ``-``\\ "
"``->``, but does not include them."
msgstr ""
"주석의 내용을 제공하는 문자열. 이 어트리뷰트는 선행 ``<!-``\\ ``-``\\와 후행 ``-``\\ ``->`` 사이의 모든"
" 문자를 포함하지만, 이들을 포함하지는 않습니다."

#: ../../library/xml.dom.rst:760
msgid "Text and CDATASection Objects"
msgstr "Text와 CDATASection 객체"

#: ../../library/xml.dom.rst:762
msgid ""
"The :class:`Text` interface represents text in the XML document.  If the "
"parser and DOM implementation support the DOM's XML extension, portions "
"of the text enclosed in CDATA marked sections are stored in "
":class:`CDATASection` objects. These two interfaces are identical, but "
"provide different values for the :attr:`nodeType` attribute."
msgstr ""
":class:`Text` 인터페이스는 XML 문서의 텍스트를 나타냅니다. 구문 분석기와 DOM 구현이 DOM의 XML 확장을 "
"지원하면, CDATA로 표시된 섹션으로 묶인 텍스트 부분은 :class:`CDATASection` 객체에 저장됩니다. 이 두 "
"인터페이스는 같지만, :attr:`nodeType` 어트리뷰트에서 다른 값을 제공합니다."

#: ../../library/xml.dom.rst:768
msgid ""
"These interfaces extend the :class:`Node` interface.  They cannot have "
"child nodes."
msgstr "이 인터페이스는 :class:`Node` 인터페이스를 확장합니다. 자식 노드를 가질 수 없습니다."

#: ../../library/xml.dom.rst:774
msgid "The content of the text node as a string."
msgstr "문자열로 표현된 텍스트 노드의 내용."

#: ../../library/xml.dom.rst:778
msgid ""
"The use of a :class:`CDATASection` node does not indicate that the node "
"represents a complete CDATA marked section, only that the content of the "
"node was part of a CDATA section.  A single CDATA section may be "
"represented by more than one node in the document tree.  There is no way "
"to determine whether two adjacent :class:`CDATASection` nodes represent "
"different CDATA marked sections."
msgstr ""
":class:`CDATASection` 노드의 사용이 그 노드가 완전한 CDATA 표시 섹션을 표현한다고 나타내는 것은 아닙니다, "
"단지 노드의 내용이 CDATA 섹션의 일부임을 나타낼 뿐입니다. 단일 CDATA 섹션은 문서 트리에서 둘 이상의 노드로 표현될 수 "
"있습니다. 인접한 두 개의 :class:`CDATASection` 노드가 다른 CDATA 표시 섹션을 나타내는지를 확인할 방법은 "
"없습니다."

#: ../../library/xml.dom.rst:788
msgid "ProcessingInstruction Objects"
msgstr "ProcessingInstruction 객체"

#: ../../library/xml.dom.rst:790
msgid ""
"Represents a processing instruction in the XML document; this inherits "
"from the :class:`Node` interface and cannot have child nodes."
msgstr "XML 문서의 처리 명령어를 나타냅니다; 이것은 :class:`Node` 인터페이스를 상속하며 자식 노드를 가질 수 없습니다."

#: ../../library/xml.dom.rst:796
msgid ""
"The content of the processing instruction up to the first whitespace "
"character. This is a read-only attribute."
msgstr "첫 번째 공백 문자까지의 처리 명령어의 내용. 이것은 읽기 전용 어트리뷰트입니다."

#: ../../library/xml.dom.rst:802
msgid ""
"The content of the processing instruction following the first whitespace "
"character."
msgstr "첫 번째 공백 문자 다음에 오는 처리 명령어의 내용."

#: ../../library/xml.dom.rst:809
msgid "Exceptions"
msgstr "예외"

#: ../../library/xml.dom.rst:811
msgid ""
"The DOM Level 2 recommendation defines a single exception, "
":exc:`DOMException`, and a number of constants that allow applications to"
" determine what sort of error occurred. :exc:`DOMException` instances "
"carry a :attr:`code` attribute that provides the appropriate value for "
"the specific exception."
msgstr ""
"DOM 수준 2 권장 사항은 단일 예외 :exc:`DOMException`\\과 응용 프로그램이 어떤 종류의 에러가 발생했는지 "
"판별하도록 하는 여러 상수를 정의합니다. :exc:`DOMException` 인스턴스에는 구체적인 예외에 적절한 값을 제공하는 "
":attr:`code` 어트리뷰트가 있습니다."

#: ../../library/xml.dom.rst:816
msgid ""
"The Python DOM interface provides the constants, but also expands the set"
" of exceptions so that a specific exception exists for each of the "
"exception codes defined by the DOM.  The implementations must raise the "
"appropriate specific exception, each of which carries the appropriate "
"value for the :attr:`code` attribute."
msgstr ""
"파이썬 DOM 인터페이스는 상수를 제공하지만, 동시에 예외 집합을 확장하여 DOM에 의해 정의된 각 예외 코드마다 구체적인 예외가 "
"존재하도록 합니다. 구현 시 적절한 구체적인 예외를 발생시켜야 하며, 각 예외는 :attr:`code` 속성으로 적절한 값을 "
"제공합니다."

#: ../../library/xml.dom.rst:825
msgid ""
"Base exception class used for all specific DOM exceptions.  This "
"exception class cannot be directly instantiated."
msgstr "모든 구체적인 DOM 예외에 사용되는 베이스 예외 클래스. 이 예외 클래스는 직접 인스턴스 화할 수 없습니다."

#: ../../library/xml.dom.rst:831
msgid ""
"Raised when a specified range of text does not fit into a string. This is"
" not known to be used in the Python DOM implementations, but may be "
"received from DOM implementations not written in Python."
msgstr ""
"지정된 텍스트 범위가 문자열에 맞지 않을 때 발생합니다. 이것은 파이썬 DOM 구현에서 사용되는 것으로 알려지지 않았지만, "
"파이썬으로 작성되지 않은 DOM 구현에서 수신될 수 있습니다."

#: ../../library/xml.dom.rst:838
msgid ""
"Raised when an attempt is made to insert a node where the node type is "
"not allowed."
msgstr "노드 형이 허용하지 않는 곳에 노드를 삽입하려고 할 때 발생합니다."

#: ../../library/xml.dom.rst:844
msgid ""
"Raised when an index or size parameter to a method is negative or exceeds"
" the allowed values."
msgstr "메서드의 인덱스(index)나 크기(size) 매개 변수가 음수이거나 허용된 값을 초과할 때 발생합니다."

#: ../../library/xml.dom.rst:850
msgid ""
"Raised when an attempt is made to insert an :class:`Attr` node that is "
"already present elsewhere in the document."
msgstr "문서의 다른 곳에 이미 존재하는 :class:`Attr` 노드를 삽입하려고 할 때 발생합니다."

#: ../../library/xml.dom.rst:856
msgid ""
"Raised if a parameter or an operation is not supported on the underlying "
"object."
msgstr "하부 객체에서 매개 변수나 연산이 지원되지 않으면 발생합니다."

#: ../../library/xml.dom.rst:861
msgid ""
"This exception is raised when a string parameter contains a character "
"that is not permitted in the context it's being used in by the XML 1.0 "
"recommendation. For example, attempting to create an :class:`Element` "
"node with a space in the element type name will cause this error to be "
"raised."
msgstr ""
"이 예외는 문자열 매개 변수에 XML 1.0 권장 사항에서 사용 중인 컨텍스트에서 허용되지 않는 문자가 포함될 때 발생합니다. 예를"
" 들어, 엘리먼트 형 이름에 스페이스가 있는 :class:`Element` 노드를 만들려고 하면 이 에러가 발생합니다."

#: ../../library/xml.dom.rst:869
msgid "Raised when an attempt is made to modify the type of a node."
msgstr "노드 형을 수정하려고 할 때 발생합니다."

#: ../../library/xml.dom.rst:874
msgid ""
"Raised when an attempt is made to use an object that is not defined or is"
" no longer usable."
msgstr "정의되지 않았거나 더는 사용할 수 없는 객체를 사용하려고 할 때 발생합니다."

#: ../../library/xml.dom.rst:880
msgid ""
"If an attempt is made to change any object in a way that is not permitted"
" with regard to the `Namespaces in XML <https://www.w3.org/TR/REC-xml-"
"names/>`_ recommendation, this exception is raised."
msgstr ""
"`Namespaces in XML <https://www.w3.org/TR/REC-xml-names/>`_ 권장 사항에서 허용되지 "
"않는 방식으로 객체를 변경하려고 시도하면 이 예외가 발생합니다."

#: ../../library/xml.dom.rst:887
msgid ""
"Exception when a node does not exist in the referenced context.  For "
"example, :meth:`NamedNodeMap.removeNamedItem` will raise this if the node"
" passed in does not exist in the map."
msgstr ""
"참조된 컨텍스트에 노드가 존재하지 않을 때 발생하는 예외. 예를 들어, "
":meth:`NamedNodeMap.removeNamedItem`\\은 전달된 노드가 맵에 존재하지 않으면 이것을 발생시킵니다."

#: ../../library/xml.dom.rst:894
msgid ""
"Raised when the implementation does not support the requested type of "
"object or operation."
msgstr "구현이 요청된 형의 객체나 연산을 지원하지 않을 때 발생합니다."

#: ../../library/xml.dom.rst:900
msgid ""
"This is raised if data is specified for a node which does not support "
"data."
msgstr "데이터를 지원하지 않는 노드에 데이터가 지정되면 발생합니다."

#: ../../library/xml.dom.rst:907
msgid ""
"Raised on attempts to modify an object where modifications are not "
"allowed (such as for read-only nodes)."
msgstr "수정이 허용되지 않는 객체(가령 읽기 전용 노드)를 수정하려고 하면 발생합니다."

#: ../../library/xml.dom.rst:913
msgid "Raised when an invalid or illegal string is specified."
msgstr "유효하지 않거나 잘못된 문자열이 지정될 때 발생합니다."

#: ../../library/xml.dom.rst:920
msgid ""
"Raised when a node is inserted in a different document than it currently "
"belongs to, and the implementation does not support migrating the node "
"from one document to the other."
msgstr "노드가 현재 속한 것과 다른 문서에 삽입되고 구현이 한 문서에서 다른 문서로 노드 이전을 지원하지 않을 때 발생합니다."

#: ../../library/xml.dom.rst:924
msgid ""
"The exception codes defined in the DOM recommendation map to the "
"exceptions described above according to this table:"
msgstr "DOM 권장 사항에 정의된 예외 코드는 이 테이블에 따라 위에서 설명한 예외에 매핑됩니다:"

#: ../../library/xml.dom.rst:928
msgid "Constant"
msgstr "상수"

#: ../../library/xml.dom.rst:928
msgid "Exception"
msgstr "예외"

#: ../../library/xml.dom.rst:930
msgid ":const:`DOMSTRING_SIZE_ERR`"
msgstr ":const:`DOMSTRING_SIZE_ERR`"

#: ../../library/xml.dom.rst:930
msgid ":exc:`DomstringSizeErr`"
msgstr ":exc:`DomstringSizeErr`"

#: ../../library/xml.dom.rst:932
msgid ":const:`HIERARCHY_REQUEST_ERR`"
msgstr ":const:`HIERARCHY_REQUEST_ERR`"

#: ../../library/xml.dom.rst:932
msgid ":exc:`HierarchyRequestErr`"
msgstr ":exc:`HierarchyRequestErr`"

#: ../../library/xml.dom.rst:934
msgid ":const:`INDEX_SIZE_ERR`"
msgstr ":const:`INDEX_SIZE_ERR`"

#: ../../library/xml.dom.rst:934
msgid ":exc:`IndexSizeErr`"
msgstr ":exc:`IndexSizeErr`"

#: ../../library/xml.dom.rst:936
msgid ":const:`INUSE_ATTRIBUTE_ERR`"
msgstr ":const:`INUSE_ATTRIBUTE_ERR`"

#: ../../library/xml.dom.rst:936
msgid ":exc:`InuseAttributeErr`"
msgstr ":exc:`InuseAttributeErr`"

#: ../../library/xml.dom.rst:938
msgid ":const:`INVALID_ACCESS_ERR`"
msgstr ":const:`INVALID_ACCESS_ERR`"

#: ../../library/xml.dom.rst:938
msgid ":exc:`InvalidAccessErr`"
msgstr ":exc:`InvalidAccessErr`"

#: ../../library/xml.dom.rst:940
msgid ":const:`INVALID_CHARACTER_ERR`"
msgstr ":const:`INVALID_CHARACTER_ERR`"

#: ../../library/xml.dom.rst:940
msgid ":exc:`InvalidCharacterErr`"
msgstr ":exc:`InvalidCharacterErr`"

#: ../../library/xml.dom.rst:942
msgid ":const:`INVALID_MODIFICATION_ERR`"
msgstr ":const:`INVALID_MODIFICATION_ERR`"

#: ../../library/xml.dom.rst:942
msgid ":exc:`InvalidModificationErr`"
msgstr ":exc:`InvalidModificationErr`"

#: ../../library/xml.dom.rst:944
msgid ":const:`INVALID_STATE_ERR`"
msgstr ":const:`INVALID_STATE_ERR`"

#: ../../library/xml.dom.rst:944
msgid ":exc:`InvalidStateErr`"
msgstr ":exc:`InvalidStateErr`"

#: ../../library/xml.dom.rst:946
msgid ":const:`NAMESPACE_ERR`"
msgstr ":const:`NAMESPACE_ERR`"

#: ../../library/xml.dom.rst:946
msgid ":exc:`NamespaceErr`"
msgstr ":exc:`NamespaceErr`"

#: ../../library/xml.dom.rst:948
msgid ":const:`NOT_FOUND_ERR`"
msgstr ":const:`NOT_FOUND_ERR`"

#: ../../library/xml.dom.rst:948
msgid ":exc:`NotFoundErr`"
msgstr ":exc:`NotFoundErr`"

#: ../../library/xml.dom.rst:950
msgid ":const:`NOT_SUPPORTED_ERR`"
msgstr ":const:`NOT_SUPPORTED_ERR`"

#: ../../library/xml.dom.rst:950
msgid ":exc:`NotSupportedErr`"
msgstr ":exc:`NotSupportedErr`"

#: ../../library/xml.dom.rst:952
msgid ":const:`NO_DATA_ALLOWED_ERR`"
msgstr ":const:`NO_DATA_ALLOWED_ERR`"

#: ../../library/xml.dom.rst:952
msgid ":exc:`NoDataAllowedErr`"
msgstr ":exc:`NoDataAllowedErr`"

#: ../../library/xml.dom.rst:954
msgid ":const:`NO_MODIFICATION_ALLOWED_ERR`"
msgstr ":const:`NO_MODIFICATION_ALLOWED_ERR`"

#: ../../library/xml.dom.rst:954
msgid ":exc:`NoModificationAllowedErr`"
msgstr ":exc:`NoModificationAllowedErr`"

#: ../../library/xml.dom.rst:956
msgid ":const:`SYNTAX_ERR`"
msgstr ":const:`SYNTAX_ERR`"

#: ../../library/xml.dom.rst:956
msgid ":exc:`SyntaxErr`"
msgstr ":exc:`SyntaxErr`"

#: ../../library/xml.dom.rst:958
msgid ":const:`WRONG_DOCUMENT_ERR`"
msgstr ":const:`WRONG_DOCUMENT_ERR`"

#: ../../library/xml.dom.rst:958
msgid ":exc:`WrongDocumentErr`"
msgstr ":exc:`WrongDocumentErr`"

#: ../../library/xml.dom.rst:965
msgid "Conformance"
msgstr "규격 준수"

#: ../../library/xml.dom.rst:967
msgid ""
"This section describes the conformance requirements and relationships "
"between the Python DOM API, the W3C DOM recommendations, and the OMG IDL "
"mapping for Python."
msgstr ""
"이 섹션에서는 규격 준수 요구 사항과 파이썬 DOM API, W3C DOM 권장 사항 및 파이썬의 OMG IDL 매핑 간의 관계에 "
"관해 설명합니다."

#: ../../library/xml.dom.rst:975
msgid "Type Mapping"
msgstr "형 매핑"

#: ../../library/xml.dom.rst:977
msgid ""
"The IDL types used in the DOM specification are mapped to Python types "
"according to the following table."
msgstr "DOM 명세에 사용된 IDL 형은 다음 표에 따라 파이썬 형에 매핑됩니다."

#: ../../library/xml.dom.rst:981
msgid "IDL Type"
msgstr "IDL 형"

#: ../../library/xml.dom.rst:981
msgid "Python Type"
msgstr "파이썬 형"

#: ../../library/xml.dom.rst:983
msgid "``boolean``"
msgstr "``boolean``"

#: ../../library/xml.dom.rst:983
msgid "``bool`` or ``int``"
msgstr "``bool`` 또는 ``int``"

#: ../../library/xml.dom.rst:985 ../../library/xml.dom.rst:987
#: ../../library/xml.dom.rst:989
msgid "``int``"
msgstr "``int``"

#: ../../library/xml.dom.rst:987
msgid "``long int``"
msgstr "``long int``"

#: ../../library/xml.dom.rst:989
msgid "``unsigned int``"
msgstr "``unsigned int``"

#: ../../library/xml.dom.rst:991
msgid "``DOMString``"
msgstr "``DOMString``"

#: ../../library/xml.dom.rst:991
msgid "``str`` or ``bytes``"
msgstr "``str`` 또는 ``bytes``"

#: ../../library/xml.dom.rst:993
msgid "``null``"
msgstr "``null``"

#: ../../library/xml.dom.rst:993
msgid "``None``"
msgstr "``None``"

#: ../../library/xml.dom.rst:999
msgid "Accessor Methods"
msgstr "접근자 메서드"

#: ../../library/xml.dom.rst:1001
msgid ""
"The mapping from OMG IDL to Python defines accessor functions for IDL "
"``attribute`` declarations in much the way the Java mapping does. Mapping"
" the IDL declarations ::"
msgstr ""
"OMG IDL에서 파이썬으로의 매핑은 Java 매핑과 거의 같은 방식으로 IDL ``attribute`` 선언에 대한 접근자 함수를"
" 정의합니다. 다음과 같은 IDL 선언 매핑은::"

#: ../../library/xml.dom.rst:1005
msgid ""
"readonly attribute string someValue;\n"
"         attribute string anotherValue;"
msgstr ""

#: ../../library/xml.dom.rst:1008
msgid ""
"yields three accessor functions:  a \"get\" method for :attr:`someValue` "
"(:meth:`_get_someValue`), and \"get\" and \"set\" methods for "
":attr:`anotherValue` (:meth:`_get_anotherValue` and "
":meth:`_set_anotherValue`).  The mapping, in particular, does not require"
" that the IDL attributes are accessible as normal Python attributes:  "
"``object.someValue`` is *not* required to work, and may raise an "
":exc:`AttributeError`."
msgstr ""
"세 개의 접근자 함수를 산출합니다: :attr:`someValue`\\를 위한 \"get\" "
"메서드(:meth:`_get_someValue`)와 :attr:`anotherValue`\\를 위한 \"get\"과 \"set\" "
"메서드(:meth:`_get_anotherValue`\\와 :meth:`_set_anotherValue`). 특히, 매핑은 IDL "
"어트리뷰트가 일반 파이썬 어트리뷰트로 액세스할 수 있도록 요구하지 않습니다: ``object.someValue``\\는 작동할 필요"
" *없으며*, :exc:`AttributeError`\\를 발생시킬 수 있습니다."

#: ../../library/xml.dom.rst:1015
msgid ""
"The Python DOM API, however, *does* require that normal attribute access "
"work. This means that the typical surrogates generated by Python IDL "
"compilers are not likely to work, and wrapper objects may be needed on "
"the client if the DOM objects are accessed via CORBA. While this does "
"require some additional consideration for CORBA DOM clients, the "
"implementers with experience using DOM over CORBA from Python do not "
"consider this a problem.  Attributes that are declared ``readonly`` may "
"not restrict write access in all DOM implementations."
msgstr ""
"그러나, 파이썬 DOM API는 일반 어트리뷰트 액세스가 동작하도록 *요구합니다*. 이것은 파이썬 IDL 컴파일러에 의해 생성된 "
"일반적인 서로게이트가 작동하지 않을 수 있으며, DOM 객체가 CORBA를 통해 액세스되는 경우 래퍼 객체가 클라이언트에 필요할 수"
" 있음을 의미합니다. CORBA DOM 클라이언트에 대해 추가적인 고려가 필요하지만, 파이썬에서 CORBA를 통해 DOM을 사용한 "
"경험이 있는 구현자들은 이것을 문제라고 보지 않습니다. ``readonly``\\로 선언된 어트리뷰트는 모든 DOM 구현에서 쓰기 "
"액세스를 제한하지 않을 수 있습니다."

#: ../../library/xml.dom.rst:1024
msgid ""
"In the Python DOM API, accessor functions are not required.  If provided,"
" they should take the form defined by the Python IDL mapping, but these "
"methods are considered unnecessary since the attributes are accessible "
"directly from Python. \"Set\" accessors should never be provided for "
"``readonly`` attributes."
msgstr ""
"파이썬 DOM API에서는, 접근자 함수가 필요하지 않습니다. 제공되면, 파이썬 IDL 매핑으로 정의된 형식을 취해야 하지만, "
"어트리뷰트를 파이썬에서 직접 액세스할 수 있어서 이러한 메서드들은 불필요한 것으로 간주합니다. ``readonly`` 어트리뷰트에 "
"\"set\" 접근자를 제공해서는 안 됩니다."

#: ../../library/xml.dom.rst:1029
msgid ""
"The IDL definitions do not fully embody the requirements of the W3C DOM "
"API, such as the notion of certain objects, such as the return value of "
":meth:`getElementsByTagName`, being \"live\".  The Python DOM API does "
"not require implementations to enforce such requirements."
msgstr ""
"IDL 정의는 W3C DOM API의 요구 사항을 완전히 담지 않습니다. 가령 "
":meth:`getElementsByTagName`\\의 반환 값과 같은 특정 객체가 \"살아있다(live)\"는 개념과 같은 것을"
" 표현하지 못합니다. 파이썬 DOM API는 구현이 이러한 요구 사항을 강제하도록 요구하지 않습니다."

