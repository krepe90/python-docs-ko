# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/timeit.rst:2
msgid ":mod:`!timeit` --- Measure execution time of small code snippets"
msgstr ":mod:`!timeit` --- 작은 코드 조각의 실행 시간 측정"

#: ../../library/timeit.rst:7
msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**소스 코드:** :source:`Lib/timeit.py`"

#: ../../library/timeit.rst:15
msgid ""
"This module provides a simple way to time small bits of Python code. It "
"has both a :ref:`timeit-command-line-interface` as well as a "
":ref:`callable <python-interface>` one.  It avoids a number of common "
"traps for measuring execution times. See also Tim Peters' introduction to"
" the \"Algorithms\" chapter in the second edition of *Python Cookbook*, "
"published by O'Reilly."
msgstr ""
"이 모듈은 파이썬 코드의 작은 조각의 시간을 측정하는 간단한 방법을 제공합니다. :ref:`timeit-command-line-"
"interface`\\뿐만 아니라 :ref:`콜러블 <python-interface>`\\도 있습니다. 실행 시간을 측정에 따르는 "
"흔한 함정들을 피할 수 있습니다. O'Reilly가 출판한 *Python Cookbook* 2판에 있는 Tim Peters의 "
"\"Algorithms\" 장의 개요도 참조하십시오."

#: ../../library/timeit.rst:23
msgid "Basic Examples"
msgstr "기본 예제"

#: ../../library/timeit.rst:25
msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` "
"can be used to compare three different expressions:"
msgstr ""
"다음 예제에서는 :ref:`timeit-command-line-interface`\\를 사용하여 세 가지 다른 표현식을 비교하는 "
"방법을 보여줍니다:"

#: ../../library/timeit.rst:28
msgid ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"
msgstr ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"

#: ../../library/timeit.rst:37
msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr "이것은 :ref:`python-interface`\\로는 다음과 같이 할 수 있습니다::"

#: ../../library/timeit.rst:39
msgid ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)"
"\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', "
"number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"
msgstr ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)"
"\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', "
"number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"

#: ../../library/timeit.rst:47
msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr "콜러블을 :ref:`python-interface`\\로 전달할 수도 있습니다::"

#: ../../library/timeit.rst:49
msgid ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)"
"\n"
"0.19665591977536678"
msgstr ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)"
"\n"
"0.19665591977536678"

#: ../../library/timeit.rst:52
msgid ""
"Note however that :func:`.timeit` will automatically determine the number"
" of repetitions only when the command-line interface is used.  In the "
":ref:`timeit-examples` section you can find more advanced examples."
msgstr ""
"그러나 :func:`.timeit`\\은 명령 줄 인터페이스가 사용될 때만 반복 횟수를 자동으로 결정합니다. :ref"
":`timeit-examples` 절에서 고급 예제를 찾을 수 있습니다."

#: ../../library/timeit.rst:60
msgid "Python Interface"
msgstr "파이썬 인터페이스"

#: ../../library/timeit.rst:62
msgid "The module defines three convenience functions and a public class:"
msgstr "이 모듈은 세 개의 편리 함수와 하나의 공용 클래스를 정의합니다:"

#: ../../library/timeit.rst:67
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code "
"and *timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in "
"which to execute the code."
msgstr ""
"지정된 문장, *setup* 코드 및 *timer* 함수로 :class:`Timer` 인스턴스를 만들고, *number* 실행으로 "
":meth:`.timeit` 메서드를 실행합니다. 선택적 *globals* 인자는 코드를 실행할 이름 공간을 지정합니다."

#: ../../library/timeit.rst:72 ../../library/timeit.rst:83
#: ../../library/timeit.rst:122
msgid "The optional *globals* parameter was added."
msgstr "선택적 *globals* 매개 변수가 추가되었습니다."

#: ../../library/timeit.rst:78
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code "
"and *timer* function and run its :meth:`.repeat` method with the given "
"*repeat* count and *number* executions.  The optional *globals* argument "
"specifies a namespace in which to execute the code."
msgstr ""
"주어진 문장, *setup* 코드 및 *timer* 함수로 :class:`Timer` 인스턴스를 생성하고, 주어진 *repeat* "
"카운트와 *number* 실행으로 :meth:`.repeat` 메서드를 실행합니다. 선택적 *globals* 인자는 코드를 실행할 "
"이름 공간을 지정합니다."

#: ../../library/timeit.rst:86 ../../library/timeit.rst:183
msgid "Default value of *repeat* changed from 3 to 5."
msgstr "*repeat*\\의 기본값이 3에서 5로 변경되었습니다."

#: ../../library/timeit.rst:92
msgid ""
"The default timer, which is always time.perf_counter(), returns float "
"seconds. An alternative, time.perf_counter_ns, returns integer "
"nanoseconds."
msgstr ""
"기본 타이머, 항상 time.perf_counter() 이고, 초 단위의 float를 반환합니다. 대안인 "
"time.perf_counter_ns 는 나노초 단위의 정수를 반환합니다."

#: ../../library/timeit.rst:95
msgid ":func:`time.perf_counter` is now the default timer."
msgstr "이제 :func:`time.perf_counter`\\가 기본 타이머입니다."

#: ../../library/timeit.rst:101
msgid "Class for timing execution speed of small code snippets."
msgstr "작은 코드 조각의 실행 속도를 측정하기 위한 클래스."

#: ../../library/timeit.rst:103
msgid ""
"The constructor takes a statement to be timed, an additional statement "
"used for setup, and a timer function.  Both statements default to "
"``'pass'``; the timer function is platform-dependent (see the module doc "
"string). *stmt* and *setup* may also contain multiple statements "
"separated by ``;`` or newlines, as long as they don't contain multi-line "
"string literals.  The statement will by default be executed within "
"timeit's namespace; this behavior can be controlled by passing a "
"namespace to *globals*."
msgstr ""
"생성자는 시간 측정될 문장, 설정에 사용되는 추가 문장 및 타이머 함수를 받아들입니다. 두 문장의 기본값은 "
"``'pass'``\\입니다; 타이머 함수는 플랫폼에 따라 다릅니다 (모듈 독스트링을 참조하십시오). *stmt*\\와 "
"*setup*\\은 여러 줄에 걸친 문자열 리터럴을 포함하지 않는 한 ``;``\\나 줄 바꿈으로 구분된 여러 개의 문장을 포함 할"
" 수도 있습니다. 문장은 기본적으로 timeit의 이름 공간 내에서 실행됩니다; 이 동작은 *globals*\\에 이름 공간을 "
"전달하여 제어 할 수 있습니다."

#: ../../library/timeit.rst:111
msgid ""
"To measure the execution time of the first statement, use the "
":meth:`.timeit` method.  The :meth:`.repeat` and :meth:`.autorange` "
"methods are convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"첫 번째 문장의 실행 시간을 측정하려면, :meth:`.timeit` 메서드를 사용하십시오. :meth:`.repeat`\\와 "
":meth:`.autorange` 메서드는 :meth:`.timeit`\\을 여러 번 호출하는 편리 메서드입니다."

#: ../../library/timeit.rst:115
msgid ""
"The execution time of *setup* is excluded from the overall timed "
"execution run."
msgstr "*setup*\\의 실행 시간은 전체 측정 실행 시간에서 제외됩니다."

#: ../../library/timeit.rst:117
msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable"
" without arguments.  This will embed calls to them in a timer function "
"that will then be executed by :meth:`.timeit`.  Note that the timing "
"overhead is a little larger in this case because of the extra function "
"calls."
msgstr ""
"*stmt*\\와 *setup* 매개 변수는 인자 없이 호출 할 수 있는 객체를 받아들일 수도 있습니다. 이렇게 하면 "
":meth:`.timeit`\\에 의해 실행될 타이머 함수에 그들에 대한 호출을 포함시킵니다. 이때는 여분의 함수 호출로 인해 "
"타이밍 오버헤드가 약간 더 커집니다."

#: ../../library/timeit.rst:127
msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times.  The default timer returns seconds as a "
"float. The argument is the number of times through the loop, defaulting "
"to one million.  The main statement, the setup statement and the timer "
"function to be used are passed to the constructor."
msgstr ""
"주 문장의 *number* 실행의 시간을 측정합니다. setup 문장을 한 번 실행한 다음, 주 문장을 여러 번 실행하는 데 걸리는"
" 시간을 반환합니다. 기본 타이머는 초 단위의 float를 반환합니다. 인자는 루프를 통과하는 횟수이며, 기본값은 백만입니다. 주 "
"문장, setup 문장 및 사용할 타이머 함수는 생성자에 전달됩니다."

#: ../../library/timeit.rst:136
msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage "
"collection` during the timing.  The advantage of this approach is that it"
" makes independent timings more comparable.  The disadvantage is that GC "
"may be an important component of the performance of the function being "
"measured.  If so, GC can be re-enabled as the first statement in the "
"*setup* string.  For example::"
msgstr ""
"기본적으로, :meth:`.timeit`\\은 시간 측정 중에 :term:`가비지 수거 <garbage collection>`\\를"
" 일시적으로 끕니다. 이 방법의 장점은 독립적인 시간 측정이 더 잘 비교될 수 있다는 것입니다. 단점은 GC가 측정되는 함수의 "
"성능에서 중요한 요소가 될 수 있다는 것입니다. 그렇다면, GC를 *setup* 문자열의 첫 번째 문장에서 다시 활성화할 수 "
"있습니다. 예를 들면::"

#: ../../library/timeit.rst:143
msgid "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"
msgstr "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"

#: ../../library/timeit.rst:148
msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr ":meth:`.timeit`\\를 호출하는 횟수를 자동으로 결정합니다."

#: ../../library/timeit.rst:150
msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so "
"that the total time >= 0.2 second, returning the eventual (number of "
"loops, time taken for that number of loops). It calls :meth:`.timeit` "
"with increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the time taken is at least 0.2 seconds."
msgstr ""
"이 함수는 총 시간이 0.2초 이상이 될 때까지 :meth:`.timeit`\\을 반복적으로 호출하고, 최종 (루프 수, 해당 루프"
" 수에 소요된 시간)을 반환하는 편리 함수입니다. 실행 시간이 적어도 0.2초가 될 때까지 1, 2, 5, 10, 20, 50 "
"... 로 루프 수를 증가시키면서 :meth:`.timeit`\\을 호출합니다."

#: ../../library/timeit.rst:156
msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"*callback*\\이 주어지고 ``None``\\이 아니면, 각 시도 다음에 두 개의 인자로 호출합니다: "
"``callback(number, time_taken)``."

#: ../../library/timeit.rst:164
msgid "Call :meth:`.timeit` a few times."
msgstr ":meth:`.timeit`\\을 몇 번 호출합니다."

#: ../../library/timeit.rst:166
msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly,"
" returning a list of results.  The first argument specifies how many "
"times to call :meth:`.timeit`.  The second argument specifies the "
"*number* argument for :meth:`.timeit`."
msgstr ""
"이것은 반복적으로 :meth:`.timeit`\\을 호출하여 결과 리스트를 반환하는 편리 함수입니다. 첫 번째 인자는 "
":meth:`.timeit`\\을 호출할 횟수를 지정합니다. 두 번째 인자는 :meth:`.timeit`\\에 대한 *number*"
" 인자를 지정합니다."

#: ../../library/timeit.rst:173
msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can "
"run the given code snippet; higher values in the result vector are "
"typically not caused by variability in Python's speed, but by other "
"processes interfering with your timing accuracy. So the :func:`min` of "
"the result is probably the only number you should be interested in.  "
"After that, you should look at the entire vector and apply common sense "
"rather than statistics."
msgstr ""
"결과 벡터로부터 평균과 표준 편차를 계산하고 이를 보고하고 싶을 수 있습니다. 하지만, 이것은 별로 유용하지 않습니다. 일반적으로,"
" 가장 낮은 값이 여러분의 기계가 주어진 코드 조각을 얼마나 빨리 실행할 수 있는지에 대한 하한값을 제공합니다; 결과 벡터의 더 "
"높은 값은 일반적으로 파이썬의 속도 변동성 때문이 아니라, 시간 측정의 정확성을 방해하는 다른 프로세스에 의해 발생합니다. 따라서 "
"결과의 :func:`min`\\이 여러분이 관심을 기울여야 할 유일한 숫자일 것입니다. 그 후에, 전체 벡터를 살펴보고 통계보다는 "
"상식을 적용해야 합니다."

#: ../../library/timeit.rst:189
msgid "Helper to print a traceback from the timed code."
msgstr "측정되는 코드로부터의 트레이스백을 인쇄하는 도우미."

#: ../../library/timeit.rst:191
msgid "Typical use::"
msgstr "일반적인 사용::"

#: ../../library/timeit.rst:193
msgid ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"
msgstr ""
"t = Timer(...)       # try/except 바깥\n"
"try:\n"
"    t.timeit(...)    # 또는 t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"

#: ../../library/timeit.rst:199
msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument "
"directs where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"표준 트레이스백에 비해 장점은 컴파일된 템플릿의 소스 행이 표시된다는 것입니다. 선택적 *file* 인자는 트레이스백을 보내야 할 "
"곳을 지시합니다; 기본값은 :data:`sys.stderr`\\입니다."

#: ../../library/timeit.rst:207
msgid "Command-Line Interface"
msgstr "명령 줄 인터페이스"

#: ../../library/timeit.rst:209
msgid ""
"When called as a program from the command line, the following form is "
"used::"
msgstr "명령 줄에서 프로그램으로 호출할 때, 다음 형식이 사용됩니다::"

#: ../../library/timeit.rst:211
msgid ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement "
"...]"
msgstr ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement "
"...]"

#: ../../library/timeit.rst:213
msgid "Where the following options are understood:"
msgstr "이때 다음 옵션을 지원합니다:"

#: ../../library/timeit.rst:219
msgid "how many times to execute 'statement'"
msgstr "'statement'를 실행하는 횟수"

#: ../../library/timeit.rst:223
msgid "how many times to repeat the timer (default 5)"
msgstr "타이머 반복 횟수 (기본값 5)"

#: ../../library/timeit.rst:227
msgid "statement to be executed once initially (default ``pass``)"
msgstr "초기에 한 번 실행될 문장 (기본값 ``pass``)"

#: ../../library/timeit.rst:231
msgid ""
"measure process time, not wallclock time, using :func:`time.process_time`"
" instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"벽시계 시간이 아니라 프로세스 시간을 측정합니다, 기본값인 :func:`time.perf_counter` 대신 "
":func:`time.process_time`\\을 사용합니다"

#: ../../library/timeit.rst:238
msgid ""
"specify a time unit for timer output; can select ``nsec``, ``usec``, "
"``msec``, or ``sec``"
msgstr ""
"타이머 출력의 시간 단위를 지정합니다; ``nsec``, ``usec``, ``msec`` 또는 ``sec`` 중에서 선택할 수 "
"있습니다."

#: ../../library/timeit.rst:244
msgid "print raw timing results; repeat for more digits precision"
msgstr "날 시간 측정 결과를 인쇄합니다; 더 많은 자릿수 정밀도를 위해서는 반복하십시오"

#: ../../library/timeit.rst:248
msgid "print a short usage message and exit"
msgstr "짧은 사용법 메시지를 출력하고 종료합니다"

#: ../../library/timeit.rst:250
msgid ""
"A multi-line statement may be given by specifying each line as a separate"
" statement argument; indented lines are possible by enclosing an argument"
" in quotes and using leading spaces.  Multiple :option:`-s` options are "
"treated similarly."
msgstr ""
"여러 줄의 문장은 각 줄을 별도의 statement 인자로 지정하여 제공할 수 있습니다; 들여쓰기 된 줄은 인자를 따옴표로 묶고 "
"선행 공백을 사용하면 됩니다. 여러 개의 :option:`-s` 옵션도 비슷하게 취급됩니다."

#: ../../library/timeit.rst:255
msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by"
" trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... "
"until the total time is at least 0.2 seconds."
msgstr ""
":option:`-n`\\이 주어지지 않으면, 총 시간이 최소 0.2초가 될 때까지 시퀀스 1, 2, 5, 10, 20, 50, "
"... 에서 증가하는 숫자를 시도하여 적절한 루프 수가 계산됩니다."

#: ../../library/timeit.rst:259
msgid ""
":func:`default_timer` measurements can be affected by other programs "
"running on the same machine, so the best thing to do when accurate timing"
" is necessary is to repeat the timing a few times and use the best time."
"  The :option:`-r` option is good for this; the default of 5 repetitions "
"is probably enough in most cases.  You can use :func:`time.process_time` "
"to measure CPU time."
msgstr ""
":func:`default_timer` 측정은 같은 기계에서 실행되는 다른 프로그램의 영향을 받을 수 있으므로, 정확한 시간 측정이"
" 필요할 때 가장 좋은 방법은 시간 측정을 몇 번 반복하고 가장 좋은 시간을 사용하는 것입니다. 이 작업에는 :option:`-r`"
" 옵션이 좋습니다; 대부분의 경우 기본값인 5번 반복으로 충분할 것입니다. :func:`time.process_time`\\을 "
"사용하여 CPU 시간을 측정 할 수 있습니다."

#: ../../library/timeit.rst:267
msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware "
"of it.  The baseline overhead can be measured by invoking the program "
"without arguments, and it might differ between Python versions."
msgstr ""
"pass 문을 실행하는 것과 관련된 어떤 기준 오버헤드가 있습니다. 여기에 있는 코드는 그것을 숨기려고 시도하지는 않지만, 여러분은"
" 신경 써야 합니다. 기준 오버헤드는 인자 없이 프로그램을 호출하여 측정 할 수 있으며, 파이썬 버전마다 다를 수 있습니다."

#: ../../library/timeit.rst:276
msgid "Examples"
msgstr "예제"

#: ../../library/timeit.rst:278
msgid ""
"It is possible to provide a setup statement that is executed only once at"
" the beginning:"
msgstr "처음에 한 번만 실행되는 setup 문을 제공 할 수 있습니다:"

#: ../../library/timeit.rst:280
msgid ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in "
"text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" "
"\"text.find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"
msgstr ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in "
"text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" "
"\"text.find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"

#: ../../library/timeit.rst:287
msgid ""
"In the output, there are three fields. The loop count, which tells you "
"how many times the statement body was run per timing loop repetition. The"
" repetition count ('best of 5') which tells you how many times the timing"
" loop was repeated, and finally the time the statement body took on "
"average within the best repetition of the timing loop. That is, the time "
"the fastest repetition took divided by the loop count."
msgstr ""

#: ../../library/timeit.rst:296
msgid ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char ="
" \"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; "
"char = \"g\"')\n"
"1.7246671520006203"
msgstr ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char ="
" \"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; "
"char = \"g\"')\n"
"1.7246671520006203"

#: ../../library/timeit.rst:302
msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr ":class:`Timer` 클래스와 그 메서드를 사용하여 같은 작업을 수행 할 수 있습니다::"

#: ../../library/timeit.rst:304
msgid ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; "
"char = \"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, "
"0.3712595970846668, 0.37866875250654886]"
msgstr ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; "
"char = \"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, "
"0.3712595970846668, 0.37866875250654886]"

#: ../../library/timeit.rst:312
msgid ""
"The following examples show how to time expressions that contain multiple"
" lines. Here we compare the cost of using :func:`hasattr` vs. "
":keyword:`try`/:keyword:`except` to test for missing and present object "
"attributes:"
msgstr ""
"다음 예제는 여러 줄을 포함하는 표현식의 시간을 측정하는 방법을 보여줍니다. 여기서 우리는 누락되었거나 존재하는 객체 어트리뷰트를 "
"검사하는데 :func:`hasattr`\\과 :keyword:`try`/:keyword:`except`\\를 사용하는 비용을 "
"비교합니다:"

#: ../../library/timeit.rst:316
msgid ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\""
" \"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\""
" \"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"
msgstr ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\""
" \"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\""
" \"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"

#: ../../library/timeit.rst:330
msgid ""
">>> import timeit\n"
">>> # attribute is missing\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # attribute is present\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"
msgstr ""
">>> import timeit\n"
">>> # 어트리뷰트가 없습니다\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # 어트리뷰트가 있습니다\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"

#: ../../library/timeit.rst:358
msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr ""
":mod:`timeit` 모듈이 여러분이 정의한 함수에 액세스하도록 하려면, import 문이 포함된 *setup* 매개 변수를 "
"전달하면 됩니다::"

#: ../../library/timeit.rst:361
msgid ""
"def test():\n"
"    \"\"\"Stupid test function\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"
msgstr ""
"def test():\n"
"    \"\"\"멍청한 테스트 함수\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"

#: ../../library/timeit.rst:369
msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, "
"which will cause the code to be executed within your current global "
"namespace.  This can be more convenient than individually specifying "
"imports::"
msgstr ""
"또 다른 옵션은 :func:`globals`\\를 *globals* 매개 변수로 전달해서, 여러분의 현재 전역 이름 공간에서 코드가"
" 실행되도록 하는 것입니다. 임포트를 개별적으로 지정하는 것보다 편리 할 수 있습니다::"

#: ../../library/timeit.rst:373
msgid ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"
msgstr ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"

#: ../../library/timeit.rst:9
msgid "Benchmarking"
msgstr "벤치마킹"

#: ../../library/timeit.rst:9
msgid "Performance"
msgstr "성능"

