# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/lzma.rst:2
msgid ":mod:`!lzma` --- Compression using the LZMA algorithm"
msgstr ":mod:`!lzma` --- LZMA 알고리즘을 사용한 압축"

#: ../../library/lzma.rst:12
msgid "**Source code:** :source:`Lib/lzma.py`"
msgstr "**소스 코드:** :source:`Lib/lzma.py`"

#: ../../library/lzma.rst:16
msgid ""
"This module provides classes and convenience functions for compressing "
"and decompressing data using the LZMA compression algorithm. Also "
"included is a file interface supporting the ``.xz`` and legacy ``.lzma`` "
"file formats used by the :program:`xz` utility, as well as raw compressed"
" streams."
msgstr ""
"이 모듈은 LZMA 압축 알고리즘을 사용하여 데이터를 압축 및 압축 해제하기 위한 클래스와 편의 함수를 제공합니다. 또한 "
":program:`xz` 유틸리티에서 사용되는 ``.xz``\\와 레거시 ``.lzma`` 파일 형식뿐만 아니라 원시 압축 스트림을"
" 지원하는 파일 인터페이스도 포함되어 있습니다."

#: ../../library/lzma.rst:21
msgid ""
"The interface provided by this module is very similar to that of the "
":mod:`bz2` module. Note that :class:`LZMAFile` and :class:`bz2.BZ2File` "
"are *not* thread-safe, so if you need to use a single :class:`LZMAFile` "
"instance from multiple threads, it is necessary to protect it with a "
"lock."
msgstr ""
"이 모듈에서 제공하는 인터페이스는 :mod:`bz2` 모듈의 인터페이스와 매우 유사합니다. :class:`LZMAFile`\\과 "
":class:`bz2.BZ2File`\\은 스레드 안전하지 *않아서*, 여러 스레드에서 단일 :class:`LZMAFile` "
"인스턴스를 사용해야 하면 록으로 보호해야 합니다."

#: ../../library/lzma.rst:29
msgid ""
"This exception is raised when an error occurs during compression or "
"decompression, or while initializing the compressor/decompressor state."
msgstr "이 예외는 압축이나 압축 해제 중, 또는 압축기/압축 해제기 상태를 초기화하는 동안 에러가 발생할 때 발생합니다."

#: ../../library/lzma.rst:34
msgid "Reading and writing compressed files"
msgstr "압축 파일 읽기와 쓰기"

#: ../../library/lzma.rst:38
msgid ""
"Open an LZMA-compressed file in binary or text mode, returning a "
":term:`file object`."
msgstr "바이너리나 텍스트 모드에서 LZMA 압축 파일을 열고, :term:`파일 객체 <file object>`\\를 반환합니다."

#: ../../library/lzma.rst:41
msgid ""
"The *filename* argument can be either an actual file name (given as a "
":class:`str`, :class:`bytes` or :term:`path-like <path-like object>` "
"object), in which case the named file is opened, or it can be an existing"
" file object to read from or write to."
msgstr ""
"*filename* 인자는 실제 파일 이름(:class:`str`, :class:`bytes` 또는 :term:`경로류 <path-"
"like object>` 객체로 제공됩니다)일 수 있고, 이때는 명명된 파일이 열립니다. 또는 읽거나 쓸 기존 파일 객체일 수 "
"있습니다."

#: ../../library/lzma.rst:46
msgid ""
"The *mode* argument can be any of ``\"r\"``, ``\"rb\"``, ``\"w\"``, "
"``\"wb\"``, ``\"x\"``, ``\"xb\"``, ``\"a\"`` or ``\"ab\"`` for binary "
"mode, or ``\"rt\"``, ``\"wt\"``, ``\"xt\"``, or ``\"at\"`` for text mode."
" The default is ``\"rb\"``."
msgstr ""
"*mode* 인자는 바이너리 모드의 경우 ``\"r\"``, ``\"rb\"``, ``\"w\"``, ``\"wb\"``, "
"``\"x\"``, ``\"xb\"``, ``\"a\"`` 또는 ``\"ab\"``\\이거나, 텍스트 모드의 경우 "
"``\"rt\"``, ``\"wt\"``, ``\"xt\"`` 또는 ``\"at\"`` 일 수 있습니다. 기본값은 "
"``\"rb\"``\\입니다."

#: ../../library/lzma.rst:50 ../../library/lzma.rst:95
msgid ""
"When opening a file for reading, the *format* and *filters* arguments "
"have the same meanings as for :class:`LZMADecompressor`. In this case, "
"the *check* and *preset* arguments should not be used."
msgstr ""
"파일을 읽기 위해 열 때, *format*\\과 *filters* 인자는 :class:`LZMADecompressor`\\와 같은 "
"의미입니다. 이 경우, *check*\\과 *preset* 인자를 사용하지 않아야 합니다."

#: ../../library/lzma.rst:54 ../../library/lzma.rst:99
msgid ""
"When opening a file for writing, the *format*, *check*, *preset* and "
"*filters* arguments have the same meanings as for "
":class:`LZMACompressor`."
msgstr ""
"파일을 쓰기 위해 열 때, *format*, *check*, *preset* 및 *filters* 인자는 "
":class:`LZMACompressor`\\와 같은 의미입니다."

#: ../../library/lzma.rst:57
msgid ""
"For binary mode, this function is equivalent to the :class:`LZMAFile` "
"constructor: ``LZMAFile(filename, mode, ...)``. In this case, the "
"*encoding*, *errors* and *newline* arguments must not be provided."
msgstr ""
"바이너리 모드의 경우, 이 함수는 :class:`LZMAFile` 생성자와 동등합니다: ``LZMAFile(filename, "
"mode, ...)``. 이 경우, *encoding*, *errors* 및 *newline* 인자는 제공하지 않아야 합니다."

#: ../../library/lzma.rst:61
msgid ""
"For text mode, a :class:`LZMAFile` object is created, and wrapped in an "
":class:`io.TextIOWrapper` instance with the specified encoding, error "
"handling behavior, and line ending(s)."
msgstr ""
"텍스트 모드의 경우, :class:`LZMAFile` 객체가 만들어지고, 지정된 인코딩, 에러 처리 동작 및 줄 종료로 "
":class:`io.TextIOWrapper` 인스턴스로 감쌉니다."

#: ../../library/lzma.rst:65
msgid "Added support for the ``\"x\"``, ``\"xb\"`` and ``\"xt\"`` modes."
msgstr "``\"x\"``, ``\"xb\"`` 및 ``\"xt\"`` 모드에 대한 지원이 추가되었습니다."

#: ../../library/lzma.rst:68 ../../library/lzma.rst:141
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 허용합니다."

#: ../../library/lzma.rst:74
msgid "Open an LZMA-compressed file in binary mode."
msgstr "바이너리 모드로 LZMA 압축 파일을 엽니다."

#: ../../library/lzma.rst:76
msgid ""
"An :class:`LZMAFile` can wrap an already-open :term:`file object`, or "
"operate directly on a named file. The *filename* argument specifies "
"either the file object to wrap, or the name of the file to open (as a "
":class:`str`, :class:`bytes` or :term:`path-like <path-like object>` "
"object). When wrapping an existing file object, the wrapped file will not"
" be closed when the :class:`LZMAFile` is closed."
msgstr ""
":class:`LZMAFile`\\은 이미 열려있는 :term:`파일 객체 <file object>`\\를 래핑하거나, 명명된 "
"파일에 직접 작용할 수 있습니다. *filename* 인자는 래핑할 파일 객체나 열 파일의 이름(:class:`str`, "
":class:`bytes` 또는 :term:`경로류 <path-like object>` 객체로)을 지정합니다. 기존 파일 객체를 "
"래핑할 때, 래핑 된 파일은 :class:`LZMAFile`\\이 닫힐 때 닫히지 않습니다."

#: ../../library/lzma.rst:83
msgid ""
"The *mode* argument can be either ``\"r\"`` for reading (default), "
"``\"w\"`` for overwriting, ``\"x\"`` for exclusive creation, or ``\"a\"``"
" for appending. These can equivalently be given as ``\"rb\"``, "
"``\"wb\"``, ``\"xb\"`` and ``\"ab\"`` respectively."
msgstr ""
"*mode* 인자는 읽기 위한 ``\"r\"`` (기본값), 덮어쓰기 위한 ``\"w\"``, 배타적 생성을 위한 ``\"x\"``"
" 또는 덧붙이기를 위한 ``\"a\"`` 일 수 있습니다. 이들은 각각 ``\"rb\"``, ``\"wb\"``, "
"``\"xb\"`` 및 ``\"ab\"``\\로 동등하게 제공될 수 있습니다."

#: ../../library/lzma.rst:88
msgid ""
"If *filename* is a file object (rather than an actual file name), a mode "
"of ``\"w\"`` does not truncate the file, and is instead equivalent to "
"``\"a\"``."
msgstr ""
"*filename*\\이 (실제 파일 이름이 아닌) 파일 객체이면, ``\"w\"`` 모드는 파일을 자르지 않으며, 대신 "
"``\"a\"``\\와 동등합니다."

#: ../../library/lzma.rst:91
msgid ""
"When opening a file for reading, the input file may be the concatenation "
"of multiple separate compressed streams. These are transparently decoded "
"as a single logical stream."
msgstr ""
"읽기 위해 파일을 열 때, 입력 파일은 여러 개의 개별 압축 스트림을 연결한 것일 수 있습니다. 이들은 단일 논리 스트림으로 "
"투명하게 디코딩됩니다."

#: ../../library/lzma.rst:102
msgid ""
":class:`LZMAFile` supports all the members specified by "
":class:`io.BufferedIOBase`, except for :meth:`~io.BufferedIOBase.detach` "
"and :meth:`~io.IOBase.truncate`. Iteration and the :keyword:`with` "
"statement are supported."
msgstr ""
":class:`LZMAFile`\\은 :meth:`~io.BufferedIOBase.detach`\\와 "
":meth:`~io.IOBase.truncate`\\를 제외하고, :class:`io.BufferedIOBase` 가 지정하는 모든"
" 멤버를 지원합니다. 이터레이션과 :keyword:`with` 문이 지원됩니다."

#: ../../library/lzma.rst:107
msgid "The following method and attributes are also provided:"
msgstr "다음과 같은 메서드와 어트리뷰트도 제공됩니다:"

#: ../../library/lzma.rst:111
msgid ""
"Return buffered data without advancing the file position. At least one "
"byte of data will be returned, unless EOF has been reached. The exact "
"number of bytes returned is unspecified (the *size* argument is ignored)."
msgstr ""
"파일 위치를 진행하지 않고 버퍼링 된 데이터를 반환합니다. EOF에 도달하지 않았으면, 최소 1바이트의 데이터가 반환됩니다. "
"반환되는 정확한 바이트 수는 지정되지 않습니다 (*size* 인자는 무시됩니다)."

#: ../../library/lzma.rst:115
msgid ""
"While calling :meth:`peek` does not change the file position of the "
":class:`LZMAFile`, it may change the position of the underlying file "
"object (e.g. if the :class:`LZMAFile` was constructed by passing a file "
"object for *filename*)."
msgstr ""
":meth:`peek`\\를 호출해도 :class:`LZMAFile`\\의 파일 위치는 변경되지 않지만, 하부 파일 객체의 위치는 "
"변경될 수 있습니다 (예를 들어 :class:`LZMAFile`\\이 *filename*\\으로 파일 객체를 전달하여 생성되었을 "
"때)."

#: ../../library/lzma.rst:122
msgid "``'rb'`` for reading and ``'wb'`` for writing."
msgstr ""

#: ../../library/lzma.rst:128
msgid ""
"The lzma file name.  Equivalent to the :attr:`~io.FileIO.name` attribute "
"of the underlying :term:`file object`."
msgstr ""

#: ../../library/lzma.rst:134
msgid "Added support for the ``\"x\"`` and ``\"xb\"`` modes."
msgstr "``\"x\"``\\와 ``\"xb\"`` 모드에 대한 지원이 추가되었습니다."

#: ../../library/lzma.rst:137
msgid ""
"The :meth:`~io.BufferedIOBase.read` method now accepts an argument of "
"``None``."
msgstr ":meth:`~io.BufferedIOBase.read` 메서드는 이제 ``None`` 인자를 허용합니다."

#: ../../library/lzma.rst:146
msgid "Compressing and decompressing data in memory"
msgstr "메모리에서의 데이터 압축과 압축 해제"

#: ../../library/lzma.rst:150
msgid ""
"Create a compressor object, which can be used to compress data "
"incrementally."
msgstr "데이터를 증분 압축하는 데 사용할 수 있는 압축기 객체를 만듭니다."

#: ../../library/lzma.rst:152
msgid ""
"For a more convenient way of compressing a single chunk of data, see "
":func:`compress`."
msgstr "단일 데이터 청크를 압축하는 더 편리한 방법은, :func:`compress`\\를 참조하십시오."

#: ../../library/lzma.rst:155
msgid ""
"The *format* argument specifies what container format should be used. "
"Possible values are:"
msgstr "*format* 인자는 사용해야 할 컨테이너 형식을 지정합니다. 가능한 값은 다음과 같습니다:"

#: ../../library/lzma.rst:158
msgid ":const:`FORMAT_XZ`: The ``.xz`` container format."
msgstr ":const:`FORMAT_XZ`: ``.xz`` 컨테이너 형식."

#: ../../library/lzma.rst:159
msgid "This is the default format."
msgstr "이것이 기본 형식입니다."

#: ../../library/lzma.rst:161
msgid ":const:`FORMAT_ALONE`: The legacy ``.lzma`` container format."
msgstr ":const:`FORMAT_ALONE`: 레거시 ``.lzma`` 컨테이너 형식."

#: ../../library/lzma.rst:162
msgid ""
"This format is more limited than ``.xz`` -- it does not support integrity"
" checks or multiple filters."
msgstr "이 형식은 ``.xz``\\보다 제한적입니다 -- 무결성 검사나 다중 필터를 지원하지 않습니다."

#: ../../library/lzma.rst:165
msgid ":const:`FORMAT_RAW`: A raw data stream, not using any container format."
msgstr ":const:`FORMAT_RAW`: 컨테이너 형식을 사용하지 않는 원시 데이터 스트림."

#: ../../library/lzma.rst:166
msgid ""
"This format specifier does not support integrity checks, and requires "
"that you always specify a custom filter chain (for both compression and "
"decompression). Additionally, data compressed in this manner cannot be "
"decompressed using :const:`FORMAT_AUTO` (see :class:`LZMADecompressor`)."
msgstr ""
"이 형식 지정자는 무결성 검사를 지원하지 않으며, 항상 사용자 지정 필터 체인(압축과 압축 해제 모두를 위한)을 지정해야 합니다. "
"또한, 이 방식으로 압축된 데이터는 :const:`FORMAT_AUTO`\\를 사용하여 압축 해제할 수 없습니다 "
"(:class:`LZMADecompressor`\\를 참조하십시오)."

#: ../../library/lzma.rst:171
msgid ""
"The *check* argument specifies the type of integrity check to include in "
"the compressed data. This check is used when decompressing, to ensure "
"that the data has not been corrupted. Possible values are:"
msgstr ""
"*check* 인자는 압축된 데이터에 포함할 무결성 검사 유형을 지정합니다. 이 검사는 압축을 풀 때 데이터가 손상되지 않았는지 "
"확인하는 데 사용됩니다. 가능한 값은 다음과 같습니다:"

#: ../../library/lzma.rst:175
msgid ""
":const:`CHECK_NONE`: No integrity check. This is the default (and the "
"only acceptable value) for :const:`FORMAT_ALONE` and :const:`FORMAT_RAW`."
msgstr ""
":const:`CHECK_NONE`: 무결성 검사가 없습니다. 이것은 :const:`FORMAT_ALONE`\\과 "
":const:`FORMAT_RAW`\\에 대한 기본값(그리고 유일하게 허용된 값)입니다."

#: ../../library/lzma.rst:179
msgid ":const:`CHECK_CRC32`: 32-bit Cyclic Redundancy Check."
msgstr ":const:`CHECK_CRC32`: 32비트 순환 중복 검사(Cyclic Redundancy Check)."

#: ../../library/lzma.rst:181
msgid ""
":const:`CHECK_CRC64`: 64-bit Cyclic Redundancy Check. This is the default"
" for :const:`FORMAT_XZ`."
msgstr ""
":const:`CHECK_CRC64`: 64비트 순환 중복 검사(Cyclic Redundancy Check). 이것이 "
":const:`FORMAT_XZ`\\의 기본값입니다."

#: ../../library/lzma.rst:184
msgid ":const:`CHECK_SHA256`: 256-bit Secure Hash Algorithm."
msgstr ":const:`CHECK_SHA256`: 256비트 보안 해시 알고리즘(Secure Hash Algorithm)."

#: ../../library/lzma.rst:186
msgid "If the specified check is not supported, an :class:`LZMAError` is raised."
msgstr "지정된 검사가 지원되지 않으면, :class:`LZMAError`\\가 발생합니다."

#: ../../library/lzma.rst:188
msgid ""
"The compression settings can be specified either as a preset compression "
"level (with the *preset* argument), or in detail as a custom filter chain"
" (with the *filters* argument)."
msgstr ""
"압축 설정은 사전 설정 압축 수준(*preset* 인자 사용), 또는 사용자 정의 필터 체인(*filters* 인자 사용)으로 "
"지정할 수 있습니다."

#: ../../library/lzma.rst:192
msgid ""
"The *preset* argument (if provided) should be an integer between ``0`` "
"and ``9`` (inclusive), optionally OR-ed with the constant "
":const:`PRESET_EXTREME`. If neither *preset* nor *filters* are given, the"
" default behavior is to use :const:`PRESET_DEFAULT` (preset level ``6``)."
" Higher presets produce smaller output, but make the compression process "
"slower."
msgstr ""
"*preset* 인자(제공된 경우)는 ``0``\\rhk ``9`` 사이의 (경계 포함) 정수여야 하며, 선택적으로 상수 "
":const:`PRESET_EXTREME`\\과 OR 할 수 있습니다. *preset*과 *filters*\\가 모두 제공되지 "
"않으면, 기본 동작은 :const:`PRESET_DEFAULT`\\(사전 설정 수준 ``6``)를 사용하는 것입니다. 사전 설정이 "
"높을수록 출력은 작아 지지만, 압축 과정은 느려집니다."

#: ../../library/lzma.rst:201
msgid ""
"In addition to being more CPU-intensive, compression with higher presets "
"also requires much more memory (and produces output that needs more "
"memory to decompress). With preset ``9`` for example, the overhead for an"
" :class:`LZMACompressor` object can be as high as 800 MiB. For this "
"reason, it is generally best to stick with the default preset."
msgstr ""
"CPU를 많이 사용하는 것 외에도, 사전 설정이 높은 압축은 훨씬 더 많은 메모리를 요구합니다 (그리고 압축을 풀기 위해 더 많은 "
"메모리를 요구하는 출력을 생성합니다). 예를 들어 사전 설정 ``9``\\를 사용하면, :class:`LZMACompressor` "
"객체의 오버헤드가 800 MiB에 이를 수 있습니다. 이런 이유로, 일반적으로 기본 사전 설정을 사용하는 것이 가장 좋습니다."

#: ../../library/lzma.rst:207
msgid ""
"The *filters* argument (if provided) should be a filter chain specifier. "
"See :ref:`filter-chain-specs` for details."
msgstr ""
"*filters* 인자(제공된 경우)는 필터 체인 지정자여야 합니다. 자세한 내용은 :ref:`filter-chain-"
"specs`\\을 참조하십시오."

#: ../../library/lzma.rst:212
msgid ""
"Compress *data* (a :class:`bytes` object), returning a :class:`bytes` "
"object containing compressed data for at least part of the input. Some of"
" *data* may be buffered internally, for use in later calls to "
":meth:`compress` and :meth:`flush`. The returned data should be "
"concatenated with the output of any previous calls to :meth:`compress`."
msgstr ""
"*data*\\(:class:`bytes` 객체)를 압축하여, 적어도 입력의 일부에 대한 압축 데이터가 포함된 "
":class:`bytes` 객체를 반환합니다. *data*\\의 일부는 나중에 :meth:`compress`\\와 "
":meth:`flush`\\에 대한 호출에 사용하기 위해 내부적으로 버퍼링 될 수 있습니다. 반환된 데이터는 "
":meth:`compress`\\에 대한 이전 호출의 출력에 이어 붙여야 합니다."

#: ../../library/lzma.rst:220
msgid ""
"Finish the compression process, returning a :class:`bytes` object "
"containing any data stored in the compressor's internal buffers."
msgstr "압축 과정을 마치고, 압축기의 내부 버퍼에 저장된 모든 데이터가 포함된 :class:`bytes` 객체를 반환합니다."

#: ../../library/lzma.rst:223
msgid "The compressor cannot be used after this method has been called."
msgstr "이 메서드를 호출한 후에는 압축기를 사용할 수 없습니다."

#: ../../library/lzma.rst:228
msgid ""
"Create a decompressor object, which can be used to decompress data "
"incrementally."
msgstr "데이터를 점진적으로 압축 해제하는 데 사용할 수 있는 압축 해제기 객체를 만듭니다."

#: ../../library/lzma.rst:231
msgid ""
"For a more convenient way of decompressing an entire compressed stream at"
" once, see :func:`decompress`."
msgstr "전체 압축 스트림을 한 번에 압축 해제하는 더 편리한 방법은 :func:`decompress`\\를 참조하십시오."

#: ../../library/lzma.rst:234
msgid ""
"The *format* argument specifies the container format that should be used."
" The default is :const:`FORMAT_AUTO`, which can decompress both ``.xz`` "
"and ``.lzma`` files. Other possible values are :const:`FORMAT_XZ`, "
":const:`FORMAT_ALONE`, and :const:`FORMAT_RAW`."
msgstr ""
"*format* 인자는 사용해야 하는 컨테이너 형식을 지정합니다. 기본값은 :const:`FORMAT_AUTO`\\이며, "
"``.xz``\\와 ``.lzma`` 파일을 모두 압축 해제할 수 있습니다. 다른 가능한 값은 :const:`FORMAT_XZ`, "
":const:`FORMAT_ALONE` 및 :const:`FORMAT_RAW`\\입니다."

#: ../../library/lzma.rst:239
msgid ""
"The *memlimit* argument specifies a limit (in bytes) on the amount of "
"memory that the decompressor can use. When this argument is used, "
"decompression will fail with an :class:`LZMAError` if it is not possible "
"to decompress the input within the given memory limit."
msgstr ""
"*memlimit* 인자는 압축 해제기가 사용할 수 있는 메모리양의 한계(바이트)를 지정합니다. 이 인자를 사용할 때, 주어진 "
"메모리 한계 내에서 입력을 압축 해제할 수 없으면 :class:`LZMAError`\\로 압축 해제에 실패합니다."

#: ../../library/lzma.rst:244
msgid ""
"The *filters* argument specifies the filter chain that was used to create"
" the stream being decompressed. This argument is required if *format* is "
":const:`FORMAT_RAW`, but should not be used for other formats. See :ref"
":`filter-chain-specs` for more information about filter chains."
msgstr ""
"*filters* 인자는 압축 해제 중인 스트림을 만드는 데 사용된 필터 체인을 지정합니다. *format*\\이 "
":const:`FORMAT_RAW`\\이면 이 인자가 필요하지만, 다른 형식에는 사용하지 않아야 합니다. 필터 체인에 대한 자세한 "
"내용은 :ref:`filter-chain-specs`\\을 참조하십시오."

#: ../../library/lzma.rst:250
msgid ""
"This class does not transparently handle inputs containing multiple "
"compressed streams, unlike :func:`decompress` and :class:`LZMAFile`. To "
"decompress a multi-stream input with :class:`LZMADecompressor`, you must "
"create a new decompressor for each stream."
msgstr ""
"이 클래스는 :func:`decompress`\\와 :class:`LZMAFile`\\과 달리, 여러 압축 스트림을 포함하는 입력을"
" 투명하게 처리하지 않습니다. :class:`LZMADecompressor`\\로 다중 스트림 입력을 압축 해제하려면 각 스트림에 "
"대해 새로운 압축 해제기를 만들어야 합니다."

#: ../../library/lzma.rst:257
msgid ""
"Decompress *data* (a :term:`bytes-like object`), returning uncompressed "
"data as bytes. Some of *data* may be buffered internally, for use in "
"later calls to :meth:`decompress`. The returned data should be "
"concatenated with the output of any previous calls to :meth:`decompress`."
msgstr ""
"*data*\\(:term:`바이트열류 객체 <bytes-like object>`)를 압축 해제하고, 압축되지 않은 데이터를 "
"바이트열로 반환합니다. *data*\\의 일부는 나중에 :meth:`decompress`\\를 호출할 때 사용하기 위해 내부적으로 "
"버퍼링 될 수 있습니다. 반환된 데이터는 :meth:`decompress`\\에 대한 이전 호출의 출력에 이어 붙여야 합니다."

#: ../../library/lzma.rst:263
msgid ""
"If *max_length* is nonnegative, returns at most *max_length* bytes of "
"decompressed data. If this limit is reached and further output can be "
"produced, the :attr:`~.needs_input` attribute will be set to ``False``. "
"In this case, the next call to :meth:`~.decompress` may provide *data* as"
" ``b''`` to obtain more of the output."
msgstr ""
"*max_length*\\가 음수가 아니면, 최대 *max_length* 바이트의 압축 해제된 데이터를 반환합니다. 이 한계에 "
"도달하고 추가 출력을 생성할 수 있으면, :attr:`~.needs_input` 어트리뷰트가 ``False``\\로 설정됩니다. 이"
" 경우, 다음 :meth:`~.decompress` 호출은 *data*\\를 ``b''``\\로 제공하여 더 많은 출력을 얻을 수 "
"있습니다."

#: ../../library/lzma.rst:270
msgid ""
"If all of the input data was decompressed and returned (either because "
"this was less than *max_length* bytes, or because *max_length* was "
"negative), the :attr:`~.needs_input` attribute will be set to ``True``."
msgstr ""
"모든 입력 데이터가 압축 해제되어 반환되면 (이것이 *max_length* 바이트 미만이거나 *max_length*\\가 음수이기 "
"때문에), :attr:`~.needs_input` 어트리뷰트는 ``True``\\로 설정됩니다."

#: ../../library/lzma.rst:275
msgid ""
"Attempting to decompress data after the end of stream is reached raises "
"an :exc:`EOFError`.  Any data found after the end of the stream is "
"ignored and saved in the :attr:`~.unused_data` attribute."
msgstr ""
"스트림 끝에 도달한 후 데이터 압축 해제를 시도하면 :exc:`EOFError`\\가 발생합니다. 스트림 끝 이후에 발견되는 모든 "
"데이터는 무시되고 :attr:`~.unused_data` 어트리뷰트에 저장됩니다."

#: ../../library/lzma.rst:279
msgid "Added the *max_length* parameter."
msgstr "*max_length* 매개 변수를 추가했습니다."

#: ../../library/lzma.rst:284
msgid ""
"The ID of the integrity check used by the input stream. This may be "
":const:`CHECK_UNKNOWN` until enough of the input has been decoded to "
"determine what integrity check it uses."
msgstr ""
"입력 스트림이 사용하는 무결성 검사의 ID. 사용되는 무결성 검사를 결정하기 위해 충분한 입력이 디코딩될 때까지 "
":const:`CHECK_UNKNOWN`\\일 수 있습니다."

#: ../../library/lzma.rst:290
msgid "``True`` if the end-of-stream marker has been reached."
msgstr "스트림 끝 마커에 도달하면 ``True``."

#: ../../library/lzma.rst:294
msgid "Data found after the end of the compressed stream."
msgstr "압축된 스트림이 끝난 후 발견된 데이터."

#: ../../library/lzma.rst:296
msgid "Before the end of the stream is reached, this will be ``b\"\"``."
msgstr "스트림의 끝에 도달하기 전에, 이것은 ``b\"\"``\\입니다."

#: ../../library/lzma.rst:300
msgid ""
"``False`` if the :meth:`.decompress` method can provide more decompressed"
" data before requiring new uncompressed input."
msgstr ""
":meth:`.decompress` 메서드가 새로운 압축 입력을 요구하기 전에 더 많은 압축 해제된 데이터를 제공 할 수 있으면 "
"``False``."

#: ../../library/lzma.rst:307
msgid ""
"Compress *data* (a :class:`bytes` object), returning the compressed data "
"as a :class:`bytes` object."
msgstr "*data*\\(:class:`bytes` 객체)를 압축하여, 압축된 데이터를 :class:`bytes` 객체로 반환합니다."

#: ../../library/lzma.rst:310
msgid ""
"See :class:`LZMACompressor` above for a description of the *format*, "
"*check*, *preset* and *filters* arguments."
msgstr ""
"*format*, *check*, *preset* 및 *filters* 인자에 대한 설명은 위의 "
":class:`LZMACompressor`\\를 참조하십시오."

#: ../../library/lzma.rst:316
msgid ""
"Decompress *data* (a :class:`bytes` object), returning the uncompressed "
"data as a :class:`bytes` object."
msgstr ""
"*data*\\(:class:`bytes` 객체)를 압축 해제하여, 압축되지 않은 데이터를 :class:`bytes` 객체로 "
"반환합니다."

#: ../../library/lzma.rst:319
msgid ""
"If *data* is the concatenation of multiple distinct compressed streams, "
"decompress all of these streams, and return the concatenation of the "
"results."
msgstr "*data*\\가 여러 개의 개별 압축 스트림의 연결이면, 이러한 스트림들을 모두 압축 해제하고 결과를 이어붙여 반환합니다."

#: ../../library/lzma.rst:322
msgid ""
"See :class:`LZMADecompressor` above for a description of the *format*, "
"*memlimit* and *filters* arguments."
msgstr ""
"*format*, *memlimit* 및 *filters* 인자에 대한 설명은 위의 "
":class:`LZMADecompressor`\\를 참조하십시오."

#: ../../library/lzma.rst:327
msgid "Miscellaneous"
msgstr "기타"

#: ../../library/lzma.rst:331
msgid "Return ``True`` if the given integrity check is supported on this system."
msgstr "주어진 무결성 검사가 이 시스템에서 지원되면 ``True``\\를 반환합니다."

#: ../../library/lzma.rst:333
msgid ""
":const:`CHECK_NONE` and :const:`CHECK_CRC32` are always supported. "
":const:`CHECK_CRC64` and :const:`CHECK_SHA256` may be unavailable if you "
"are using a version of :program:`liblzma` that was compiled with a "
"limited feature set."
msgstr ""
":const:`CHECK_NONE`\\과 :const:`CHECK_CRC32`\\는 항상 지원됩니다. 제한된 기능 집합으로 컴파일된"
" :program:`liblzma` 버전을 사용하는 경우 :const:`CHECK_CRC64`\\와 "
":const:`CHECK_SHA256`\\을 사용하지 못할 수 있습니다."

#: ../../library/lzma.rst:342
msgid "Specifying custom filter chains"
msgstr "사용자 정의 필터 체인 지정"

#: ../../library/lzma.rst:344
msgid ""
"A filter chain specifier is a sequence of dictionaries, where each "
"dictionary contains the ID and options for a single filter. Each "
"dictionary must contain the key ``\"id\"``, and may contain additional "
"keys to specify filter-dependent options. Valid filter IDs are as "
"follows:"
msgstr ""
"필터 체인 지정자는 딕셔너리의 시퀀스로, 각 딕셔너리에는 단일 필터의 ID와 옵션이 포함됩니다. 각 딕셔너리는 키 "
"``\"id\"``\\를 포함해야 하며, 필터 종속 옵션을 지정하기 위해 추가 키를 포함할 수 있습니다. 유효한 필터 ID는 다음과"
" 같습니다:"

#: ../../library/lzma.rst:349
msgid "Compression filters:"
msgstr "압축 필터:"

#: ../../library/lzma.rst:351
msgid ":const:`FILTER_LZMA1` (for use with :const:`FORMAT_ALONE`)"
msgstr ":const:`FILTER_LZMA1` (:const:`FORMAT_ALONE`\\과 함께 사용)"

#: ../../library/lzma.rst:352
msgid ""
":const:`FILTER_LZMA2` (for use with :const:`FORMAT_XZ` and "
":const:`FORMAT_RAW`)"
msgstr ":const:`FILTER_LZMA2` (:const:`FORMAT_XZ` 및 :const:`FORMAT_RAW`\\와 함께 사용)"

#: ../../library/lzma.rst:354
msgid "Delta filter:"
msgstr "델타 필터:"

#: ../../library/lzma.rst:356
msgid ":const:`FILTER_DELTA`"
msgstr ":const:`FILTER_DELTA`"

#: ../../library/lzma.rst:358
msgid "Branch-Call-Jump (BCJ) filters:"
msgstr "Branch-Call-Jump (BCJ) 필터:"

#: ../../library/lzma.rst:360
msgid ":const:`FILTER_X86`"
msgstr ":const:`FILTER_X86`"

#: ../../library/lzma.rst:361
msgid ":const:`FILTER_IA64`"
msgstr ":const:`FILTER_IA64`"

#: ../../library/lzma.rst:362
msgid ":const:`FILTER_ARM`"
msgstr ":const:`FILTER_ARM`"

#: ../../library/lzma.rst:363
msgid ":const:`FILTER_ARMTHUMB`"
msgstr ":const:`FILTER_ARMTHUMB`"

#: ../../library/lzma.rst:364
msgid ":const:`FILTER_POWERPC`"
msgstr ":const:`FILTER_POWERPC`"

#: ../../library/lzma.rst:365
msgid ":const:`FILTER_SPARC`"
msgstr ":const:`FILTER_SPARC`"

#: ../../library/lzma.rst:367
msgid ""
"A filter chain can consist of up to 4 filters, and cannot be empty. The "
"last filter in the chain must be a compression filter, and any other "
"filters must be delta or BCJ filters."
msgstr ""
"필터 체인은 최대 4개의 필터로 구성될 수 있으며, 비워 둘 수 없습니다. 체인의 마지막 필터는 압축 필터여야 하고, 다른 필터는 "
"델타나 BCJ 필터여야 합니다."

#: ../../library/lzma.rst:371
msgid ""
"Compression filters support the following options (specified as "
"additional entries in the dictionary representing the filter):"
msgstr "압축 필터는 다음 옵션을 지원합니다 (필터를 나타내는 딕셔너리에 추가 항목으로 지정됩니다):"

#: ../../library/lzma.rst:374
msgid ""
"``preset``: A compression preset to use as a source of default values for"
" options that are not specified explicitly."
msgstr "``preset``: 명시적으로 지정되지 않은 옵션의 기본값 소스로 사용할 압축 사전 설정."

#: ../../library/lzma.rst:376
msgid ""
"``dict_size``: Dictionary size in bytes. This should be between 4 KiB and"
" 1.5 GiB (inclusive)."
msgstr "``dict_size``: 바이트로 표현한 딕셔너리 크기. 4 KiB와 1.5 GiB 사이여야 합니다 (경계 포함)."

#: ../../library/lzma.rst:378
msgid "``lc``: Number of literal context bits."
msgstr "``lc``: 리터럴 컨텍스트 비트 수."

#: ../../library/lzma.rst:379
msgid ""
"``lp``: Number of literal position bits. The sum ``lc + lp`` must be at "
"most 4."
msgstr "``lp``: 리터럴 위치 비트 수. 합계 ``lc + lp``\\는 최대 4여야 합니다."

#: ../../library/lzma.rst:381
msgid "``pb``: Number of position bits; must be at most 4."
msgstr "``pb``: 위치 비트 수; 최대 4여야 합니다."

#: ../../library/lzma.rst:382
msgid "``mode``: :const:`MODE_FAST` or :const:`MODE_NORMAL`."
msgstr "``mode``: :const:`MODE_FAST`\\나 :const:`MODE_NORMAL`."

#: ../../library/lzma.rst:383
msgid ""
"``nice_len``: What should be considered a \"nice length\" for a match. "
"This should be 273 or less."
msgstr "``nice_len``: 매치에서 \"좋은 길이\"로 간주하는 것. 273 이하여야 합니다."

#: ../../library/lzma.rst:385
msgid ""
"``mf``: What match finder to use -- :const:`MF_HC3`, :const:`MF_HC4`, "
":const:`MF_BT2`, :const:`MF_BT3`, or :const:`MF_BT4`."
msgstr ""
"``mf``: 사용할 매치 파인더 -- :const:`MF_HC3`, :const:`MF_HC4`, :const:`MF_BT2`, "
":const:`MF_BT3` 또는 :const:`MF_BT4`."

#: ../../library/lzma.rst:387
msgid ""
"``depth``: Maximum search depth used by match finder. 0 (default) means "
"to select automatically based on other filter options."
msgstr "``depth``: 매치 파인더가 사용하는 최대 검색 깊이. 0(기본값)은 다른 필터 옵션을 기반으로 자동 선택함을 의미합니다."

#: ../../library/lzma.rst:390
msgid ""
"The delta filter stores the differences between bytes, producing more "
"repetitive input for the compressor in certain circumstances. It supports"
" one option, ``dist``. This indicates the distance between bytes to be "
"subtracted. The default is 1, i.e. take the differences between adjacent "
"bytes."
msgstr ""
"델타 필터는 바이트 간 차이를 저장하여, 특정 상황에서 압축기에 대해 더 반복적인 입력을 생성합니다. 한 가지 옵션을 지원합니다, "
"``dist``. 이것은 빼야 할 바이트 간의 거리를 나타냅니다. 기본값은 1입니다. 즉, 인접 바이트 간 차이를 취합니다."

#: ../../library/lzma.rst:395
msgid ""
"The BCJ filters are intended to be applied to machine code. They convert "
"relative branches, calls and jumps in the code to use absolute "
"addressing, with the aim of increasing the redundancy that can be "
"exploited by the compressor. These filters support one option, "
"``start_offset``. This specifies the address that should be mapped to the"
" beginning of the input data. The default is 0."
msgstr ""
"BCJ 필터는 기계 코드에 적용하려는 것입니다. 이들은 압축기가 이용할 수 있는 중복성을 높이기 위해 코드에서 상대 분기, 호출 및"
" 점프를 절대 주소 지정을 사용하도록 변환합니다. 이 필터는 한 가지 옵션을 지원합니다, ``start_offset``. 이것은 "
"입력 데이터의 시작 부분으로 매핑되어야 하는 주소를 지정합니다. 기본값은 0입니다."

#: ../../library/lzma.rst:403
msgid "Examples"
msgstr "예"

#: ../../library/lzma.rst:405
msgid "Reading in a compressed file::"
msgstr "압축 파일 읽기::"

#: ../../library/lzma.rst:407
msgid ""
"import lzma\n"
"with lzma.open(\"file.xz\") as f:\n"
"    file_content = f.read()"
msgstr ""
"import lzma\n"
"with lzma.open(\"file.xz\") as f:\n"
"    file_content = f.read()"

#: ../../library/lzma.rst:411
msgid "Creating a compressed file::"
msgstr "압축 파일 만들기::"

#: ../../library/lzma.rst:413
msgid ""
"import lzma\n"
"data = b\"Insert Data Here\"\n"
"with lzma.open(\"file.xz\", \"w\") as f:\n"
"    f.write(data)"
msgstr ""
"import lzma\n"
"data = b\"Insert Data Here\"\n"
"with lzma.open(\"file.xz\", \"w\") as f:\n"
"    f.write(data)"

#: ../../library/lzma.rst:418
msgid "Compressing data in memory::"
msgstr "메모리에서 데이터 압축하기::"

#: ../../library/lzma.rst:420
msgid ""
"import lzma\n"
"data_in = b\"Insert Data Here\"\n"
"data_out = lzma.compress(data_in)"
msgstr ""
"import lzma\n"
"data_in = b\"Insert Data Here\"\n"
"data_out = lzma.compress(data_in)"

#: ../../library/lzma.rst:424
msgid "Incremental compression::"
msgstr "증분 압축::"

#: ../../library/lzma.rst:426
msgid ""
"import lzma\n"
"lzc = lzma.LZMACompressor()\n"
"out1 = lzc.compress(b\"Some data\\n\")\n"
"out2 = lzc.compress(b\"Another piece of data\\n\")\n"
"out3 = lzc.compress(b\"Even more data\\n\")\n"
"out4 = lzc.flush()\n"
"# Concatenate all the partial results:\n"
"result = b\"\".join([out1, out2, out3, out4])"
msgstr ""
"import lzma\n"
"lzc = lzma.LZMACompressor()\n"
"out1 = lzc.compress(b\"Some data\\n\")\n"
"out2 = lzc.compress(b\"Another piece of data\\n\")\n"
"out3 = lzc.compress(b\"Even more data\\n\")\n"
"out4 = lzc.flush()\n"
"# 모든 부분 결과를 이어 붙입니다:\n"
"result = b\"\".join([out1, out2, out3, out4])"

#: ../../library/lzma.rst:435
msgid "Writing compressed data to an already-open file::"
msgstr "이미 열린 파일에 압축된 데이터 쓰기::"

#: ../../library/lzma.rst:437
msgid ""
"import lzma\n"
"with open(\"file.xz\", \"wb\") as f:\n"
"    f.write(b\"This data will not be compressed\\n\")\n"
"    with lzma.open(f, \"w\") as lzf:\n"
"        lzf.write(b\"This *will* be compressed\\n\")\n"
"    f.write(b\"Not compressed\\n\")"
msgstr ""
"import lzma\n"
"with open(\"file.xz\", \"wb\") as f:\n"
"    f.write(b\"This data will not be compressed\\n\")\n"
"    with lzma.open(f, \"w\") as lzf:\n"
"        lzf.write(b\"This *will* be compressed\\n\")\n"
"    f.write(b\"Not compressed\\n\")"

#: ../../library/lzma.rst:444
msgid "Creating a compressed file using a custom filter chain::"
msgstr "사용자 정의 필터 체인을 사용하여 압축 파일 만들기::"

#: ../../library/lzma.rst:446
#, python-brace-format
msgid ""
"import lzma\n"
"my_filters = [\n"
"    {\"id\": lzma.FILTER_DELTA, \"dist\": 5},\n"
"    {\"id\": lzma.FILTER_LZMA2, \"preset\": 7 | lzma.PRESET_EXTREME},\n"
"]\n"
"with lzma.open(\"file.xz\", \"w\", filters=my_filters) as f:\n"
"    f.write(b\"blah blah blah\")"
msgstr ""
"import lzma\n"
"my_filters = [\n"
"    {\"id\": lzma.FILTER_DELTA, \"dist\": 5},\n"
"    {\"id\": lzma.FILTER_LZMA2, \"preset\": 7 | lzma.PRESET_EXTREME},\n"
"]\n"
"with lzma.open(\"file.xz\", \"w\", filters=my_filters) as f:\n"
"    f.write(b\"blah blah blah\")"

