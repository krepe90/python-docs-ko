# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/datetime.rst:2
#, fuzzy
msgid ":mod:`!datetime` --- Basic date and time types"
msgstr ":mod:`datetime` --- 기본 날짜와 시간 형"

#: ../../library/datetime.rst:11
msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**소스 코드:** :source:`Lib/datetime.py`"

#: ../../library/datetime.rst:17
#, fuzzy
msgid ""
"The :mod:`!datetime` module supplies classes for manipulating dates and "
"times."
msgstr ":mod:`datetime` 모듈은 날짜와 시간을 조작하는 클래스를 제공합니다."

#: ../../library/datetime.rst:19
msgid ""
"While date and time arithmetic is supported, the focus of the "
"implementation is on efficient attribute extraction for output formatting"
" and manipulation."
msgstr "날짜와 시간 산술이 지원되지만, 구현의 초점은 출력 포매팅과 조작을 위한 효율적인 어트리뷰트 추출입니다."

#: ../../library/datetime.rst:24
msgid "Skip to :ref:`the format codes <format-codes>`."
msgstr ""

#: ../../library/datetime.rst:28
msgid "Module :mod:`calendar`"
msgstr "모듈 :mod:`calendar`"

#: ../../library/datetime.rst:29
msgid "General calendar related functions."
msgstr "일반 달력 관련 함수들."

#: ../../library/datetime.rst:31
msgid "Module :mod:`time`"
msgstr "모듈 :mod:`time`"

#: ../../library/datetime.rst:32
msgid "Time access and conversions."
msgstr "시간 액세스와 변환."

#: ../../library/datetime.rst:34
#, fuzzy
msgid "Module :mod:`zoneinfo`"
msgstr "모듈 :mod:`time`"

#: ../../library/datetime.rst:35
msgid "Concrete time zones representing the IANA time zone database."
msgstr ""

#: ../../library/datetime.rst:37
msgid "Package `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"
msgstr "패키지 `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"

#: ../../library/datetime.rst:38
msgid "Third-party library with expanded time zone and parsing support."
msgstr "시간대와 구문 분석 지원이 확장된 제삼자 라이브러리."

#: ../../library/datetime.rst:40
msgid "Package :pypi:`DateType`"
msgstr ""

#: ../../library/datetime.rst:41
msgid ""
"Third-party library that introduces distinct static types to e.g. allow "
":term:`static type checkers <static type checker>` to differentiate "
"between naive and aware datetimes."
msgstr ""

#: ../../library/datetime.rst:48
msgid "Aware and Naive Objects"
msgstr "어웨어와 나이브 객체"

#: ../../library/datetime.rst:50
#, fuzzy
msgid ""
"Date and time objects may be categorized as \"aware\" or \"naive\" "
"depending on whether or not they include time zone information."
msgstr "날짜와 시간 객체는 시간대 정보를 포함하는지에 따라 \"어웨어(aware)\"와 \"나이브(naive)\"로 분류될 수 있습니다."

#: ../../library/datetime.rst:53
msgid ""
"With sufficient knowledge of applicable algorithmic and political time "
"adjustments, such as time zone and daylight saving time information, an "
"**aware** object can locate itself relative to other aware objects. An "
"aware object represents a specific moment in time that is not open to "
"interpretation. [#]_"
msgstr ""
"시간대와 일광 절약 시간 정보와 같은 적용 가능한 알고리즘과 정치적 시간 조정에 대한 충분한 지식을 통해, **어웨어** 객체는 "
"다른 어웨어 객체와의 상대적인 위치를 파악할 수 있습니다. 어웨어 객체는 자의적으로 해석할 여지 없는 특정 시간을 나타냅니다. "
"[#]_"

#: ../../library/datetime.rst:59
#, fuzzy
msgid ""
"A **naive** object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects. Whether a naive object"
" represents Coordinated Universal Time (UTC), local time, or time in some"
" other time zone is purely up to the program, just like it is up to the "
"program whether a particular number represents metres, miles, or mass. "
"Naive objects are easy to understand and to work with, at the cost of "
"ignoring some aspects of reality."
msgstr ""
"**나이브** 객체는 모호하지 않게 자신과 다른 날짜/시간 객체의 상대적인 위치를 파악할 수 있는 충분한 정보를 포함하지 않습니다."
" 나이브 객체가 UTC(Coordinated Universal Time), 지역 시간 또는 다른 시간대의 시간 중 어느 것을 "
"나타내는지는 순전히 프로그램에 달려있습니다. 특정 숫자가 미터, 마일 또는 질량 중 어는 것을 나타내는지가 프로그램에 달린 것과 "
"마찬가지입니다. 나이브 객체는 이해하기 쉽고 작업하기 쉽지만, 현실의 일부 측면을 무시하는 대가를 치릅니다."

#: ../../library/datetime.rst:66
msgid ""
"For applications requiring aware objects, :class:`.datetime` and "
":class:`.time` objects have an optional time zone information attribute, "
":attr:`!tzinfo`, that can be set to an instance of a subclass of the "
"abstract :class:`tzinfo` class. These :class:`tzinfo` objects capture "
"information about the offset from UTC time, the time zone name, and "
"whether daylight saving time is in effect."
msgstr ""
"어웨어 객체가 필요한 응용 프로그램을 위해, :class:`.datetime` 과 :class:`.time` 객체에는 추상 "
":class:`tzinfo` 클래스의 서브 클래스 인스턴스로 설정할 수 있는 선택적 시간대 정보 어트리뷰트인 "
":attr:`!tzinfo`\\가 있습니다. 이러한 :class:`tzinfo` 객체는 UTC 시간으로부터의 오프셋, 시간대 이름 "
"및 일광 절약 시간이 적용되는지에 대한 정보를 보관합니다."

#: ../../library/datetime.rst:72
#, fuzzy
msgid ""
"Only one concrete :class:`tzinfo` class, the :class:`timezone` class, is "
"supplied by the :mod:`!datetime` module. The :class:`!timezone` class can"
" represent simple time zones with fixed offsets from UTC, such as UTC "
"itself or North American EST and EDT time zones. Supporting time zones at"
" deeper levels of detail is up to the application. The rules for time "
"adjustment across the world are more political than rational, change "
"frequently, and there is no standard suitable for every application aside"
" from UTC."
msgstr ""
":mod:`datetime` 모듈에서는 오직 하나의 구상 :class:`tzinfo` 클래스, :class:`timezone` "
"클래스만 제공됨에 유의하십시오. :class:`timezone` 클래스는 UTC 자체나 북미 EST와 EDT 시간대와 같은 "
"UTC로부터 고정 오프셋을 갖는 간단한 시간대를 나타낼 수 있습니다. 더욱 세부적인 수준의 시간대 지원은 응용 프로그램에 달려 "
"있습니다. 전 세계의 시간 조정에 대한 규칙은 합리적이라기보다 정치적이고, 자주 변경되며, UTC 이외에 모든 응용 프로그램에 "
"적합한 표준은 없습니다."

#: ../../library/datetime.rst:81
msgid "Constants"
msgstr "상수"

#: ../../library/datetime.rst:83
#, fuzzy
msgid "The :mod:`!datetime` module exports the following constants:"
msgstr ":mod:`datetime` 모듈은 다음 상수를 내보냅니다:"

#: ../../library/datetime.rst:87
#, fuzzy
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime`"
" object. :const:`MINYEAR` is 1."
msgstr ""
":class:`date`\\나 :class:`.datetime` 객체에서 허용되는 가장 작은 연도 번호. "
":const:`MINYEAR`\\는 ``1``\\입니다."

#: ../../library/datetime.rst:93
#, fuzzy
msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is 9999."
msgstr ""
":class:`date`\\나 :class:`.datetime` 객체에서 허용되는 가장 큰 연도 번호. "
":const:`MAXYEAR`\\는 ``9999``\\입니다."

#: ../../library/datetime.rst:98
msgid "Alias for the UTC time zone singleton :attr:`datetime.timezone.utc`."
msgstr ""

#: ../../library/datetime.rst:103
msgid "Available Types"
msgstr "사용 가능한 형"

#: ../../library/datetime.rst:108
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always "
"was, and always will be, in effect. Attributes: :attr:`year`, "
":attr:`month`, and :attr:`day`."
msgstr ""
"현재의 그레고리력이 언제나 적용되어왔고, 앞으로도 그럴 것이라는 가정하에 이상적인 나이브 날짜. 어트리뷰트: "
":attr:`year`, :attr:`month` 및 :attr:`day`."

#: ../../library/datetime.rst:116
msgid ""
"An idealized time, independent of any particular day, assuming that every"
" day has exactly 24\\*60\\*60 seconds.  (There is no notion of \"leap "
"seconds\" here.) Attributes: :attr:`hour`, :attr:`minute`, "
":attr:`second`, :attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"특정 날짜와 관계없이, 하루가 정확히 24\\*60\\*60초를 갖는다는 가정하에 이상적인 시간. (여기에는 \"윤초\"라는 개념이"
" 없습니다.) 어트리뷰트: :attr:`hour`, :attr:`minute`, :attr:`second`, "
":attr:`microsecond` 및 :attr:`.tzinfo`."

#: ../../library/datetime.rst:125
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, "
":attr:`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`,"
" :attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"날짜와 시간의 조합. 어트리뷰트: :attr:`year`, :attr:`month`, :attr:`day`, "
":attr:`hour`, :attr:`minute`, :attr:`second`, :attr:`microsecond` 및 "
":attr:`.tzinfo`."

#: ../../library/datetime.rst:133
#, fuzzy
msgid ""
"A duration expressing the difference between two :class:`.datetime` or "
":class:`date` instances to microsecond resolution."
msgstr ""
"두 :class:`date`, :class:`.time` 또는 :class:`.datetime` 인스턴스 간의 차이를 마이크로초 "
"해상도로 나타내는 기간."

#: ../../library/datetime.rst:140
msgid ""
"An abstract base class for time zone information objects. These are used "
"by the :class:`.datetime` and :class:`.time` classes to provide a "
"customizable notion of time adjustment (for example, to account for time "
"zone and/or daylight saving time)."
msgstr ""
"시간대 정보 객체의 추상 베이스 클래스. 이것들은 :class:`.datetime`\\과 :class:`.time` 클래스에서 "
"사용자 정의할 수 있는 시간 조정 개념(예를 들어, 시간대와/나 일광 절약 시간을 다루는 것)을 제공하기 위해 사용됩니다."

#: ../../library/datetime.rst:148
msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a "
"fixed offset from the UTC."
msgstr ":class:`tzinfo` 추상 베이스 클래스를 구현하는 클래스로, UTC로부터의 고정 오프셋을 나타냅니다."

#: ../../library/datetime.rst:153 ../../library/datetime.rst:171
msgid "Objects of these types are immutable."
msgstr "이러한 형의 객체는 불변입니다."

#: ../../library/datetime.rst:155
msgid "Subclass relationships::"
msgstr "서브 클래스 관계::"

#: ../../library/datetime.rst:157
msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""

#: ../../library/datetime.rst:166
msgid "Common Properties"
msgstr "공통 속성"

#: ../../library/datetime.rst:168
msgid ""
"The :class:`date`, :class:`.datetime`, :class:`.time`, and "
":class:`timezone` types share these common features:"
msgstr ""
":class:`date`, :class:`.datetime`, :class:`.time` 및 :class:`timezone` 형은 "
"다음과 같은 공통 기능을 공유합니다:"

#: ../../library/datetime.rst:172
#, fuzzy
msgid ""
"Objects of these types are :term:`hashable`, meaning that they can be "
"used as dictionary keys."
msgstr "이러한 형의 객체는 해시 가능합니다. 딕셔너리 키로 사용할 수 있다는 뜻입니다."

#: ../../library/datetime.rst:174
msgid ""
"Objects of these types support efficient pickling via the :mod:`pickle` "
"module."
msgstr "이러한 형의 객체는 :mod:`pickle` 모듈을 통한 효율적인 피클링을 지원합니다."

#: ../../library/datetime.rst:177
msgid "Determining if an Object is Aware or Naive"
msgstr "객체가 어웨어한지 나이브한지 판단하기"

#: ../../library/datetime.rst:179
msgid "Objects of the :class:`date` type are always naive."
msgstr ":class:`date` 형의 객체는 항상 나이브합니다."

#: ../../library/datetime.rst:181
msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be aware or "
"naive."
msgstr ":class:`.time`\\이나 :class:`.datetime` 형의 객체는 어웨어할 수도 나이브할 수도 있습니다."

#: ../../library/datetime.rst:183
#, fuzzy
msgid "A :class:`.datetime` object ``d`` is aware if both of the following hold:"
msgstr ":class:`.datetime` 객체 *d*\\는 다음 조건을 모두 만족하면 어웨어합니다:"

#: ../../library/datetime.rst:185
msgid "``d.tzinfo`` is not ``None``"
msgstr "``d.tzinfo``\\가 ``None``\\이 아닙니다"

#: ../../library/datetime.rst:186
msgid "``d.tzinfo.utcoffset(d)`` does not return ``None``"
msgstr "``d.tzinfo.utcoffset(d)``\\가 ``None``\\을 반환하지 않습니다"

#: ../../library/datetime.rst:188
#, fuzzy
msgid "Otherwise, ``d`` is naive."
msgstr "그렇지 않으면, *d*\\는 나이브합니다."

#: ../../library/datetime.rst:190
#, fuzzy
msgid "A :class:`.time` object ``t`` is aware if both of the following hold:"
msgstr ":class:`.time` 객체 *t*\\는 다음 조건을 모두 만족하면 어웨어합니다."

#: ../../library/datetime.rst:192
msgid "``t.tzinfo`` is not ``None``"
msgstr "``t.tzinfo``\\가 ``None``\\이 아닙니다"

#: ../../library/datetime.rst:193
msgid "``t.tzinfo.utcoffset(None)`` does not return ``None``."
msgstr "``t.tzinfo.utcoffset(None)``\\이 ``None``\\을 반환하지 않습니다"

#: ../../library/datetime.rst:195
#, fuzzy
msgid "Otherwise, ``t`` is naive."
msgstr "그렇지 않으면, *t*\\는 나이브합니다."

#: ../../library/datetime.rst:197
msgid ""
"The distinction between aware and naive doesn't apply to "
":class:`timedelta` objects."
msgstr "어웨어와 나이브 간의 차이점은 :class:`timedelta` 객체에는 적용되지 않습니다."

#: ../../library/datetime.rst:203
msgid ":class:`timedelta` Objects"
msgstr ":class:`timedelta` 객체"

#: ../../library/datetime.rst:205
#, fuzzy
msgid ""
"A :class:`timedelta` object represents a duration, the difference between"
" two :class:`.datetime` or :class:`date` instances."
msgstr ":class:`timedelta` 객체는 두 날짜나 시간의 차이인 기간을 나타냅니다."

#: ../../library/datetime.rst:210
#, fuzzy
msgid ""
"All arguments are optional and default to 0. Arguments may be integers or"
" floats, and may be positive or negative."
msgstr "모든 인자는 선택적이며 기본값은 ``0``\\입니다. 인자는 정수나 부동 소수점 수일 수 있으며, 양수나 음수일 수 있습니다."

#: ../../library/datetime.rst:213
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally. "
"Arguments are converted to those units:"
msgstr "*days*, *seconds* 및 *microseconds*\\만 내부적으로 저장됩니다. 인자는 이 단위로 변환됩니다:"

#: ../../library/datetime.rst:216
msgid "A millisecond is converted to 1000 microseconds."
msgstr "밀리 초는 1000마이크로초로 변환됩니다."

#: ../../library/datetime.rst:217
msgid "A minute is converted to 60 seconds."
msgstr "분은 60초로 변환됩니다."

#: ../../library/datetime.rst:218
msgid "An hour is converted to 3600 seconds."
msgstr "시간은 3600초로 변환됩니다."

#: ../../library/datetime.rst:219
msgid "A week is converted to 7 days."
msgstr "주는 7일로 변환됩니다."

#: ../../library/datetime.rst:221
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr "그런 다음 days, seconds 및 microseconds를 다음처럼 정규화하여 표현이 고유하도록 만듭니다"

#: ../../library/datetime.rst:224
msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= microseconds < 1000000``"

#: ../../library/datetime.rst:225
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= seconds < 3600*24`` (하루 내의 초 수)"

#: ../../library/datetime.rst:226
msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= days <= 999999999``"

#: ../../library/datetime.rst:228
msgid ""
"The following example illustrates how any arguments besides *days*, "
"*seconds* and *microseconds* are \"merged\" and normalized into those "
"three resulting attributes::"
msgstr ""
"다음 예는 *days*, *seconds* 및 *microseconds* 이외의 인자가 어떻게 \"병합\" 되어 세 개의 결과 "
"어트리뷰트로 정규화되는지를 보여줍니다::"

#: ../../library/datetime.rst:232
msgid ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"
msgstr ""

#: ../../library/datetime.rst:246
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and "
"their sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker. If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"인자가 float이고 부분 마이크로초가 있으면, 모든 인자의 남은 부분 마이크로초가 합쳐지고, 그 합은 동률일 때 짝수로 반올림하는"
" 방식으로 가장 가까운 마이크로초로 반올림됩니다. float 인자가 없으면, 변환과 정규화 프로세스는 정확합니다 (정보가 손실되지 "
"않습니다)."

#: ../../library/datetime.rst:253
msgid ""
"If the normalized value of days lies outside the indicated range, "
":exc:`OverflowError` is raised."
msgstr "정규화된 days 값이 표시된 범위를 벗어나면, :exc:`OverflowError`\\가 발생합니다."

#: ../../library/datetime.rst:256
msgid ""
"Note that normalization of negative values may be surprising at first. "
"For example::"
msgstr "음수 값의 정규화는 처음 보면 놀라울 수 있습니다. 예를 들어::"

#: ../../library/datetime.rst:259
msgid ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"
msgstr ""

#: ../../library/datetime.rst:265 ../../library/datetime.rst:566
#: ../../library/datetime.rst:1126 ../../library/datetime.rst:1764
#: ../../library/datetime.rst:2369
msgid "Class attributes:"
msgstr "클래스 어트리뷰트:"

#: ../../library/datetime.rst:269
msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr "가장 음수인 :class:`timedelta` 객체, ``timedelta(-999999999)``."

#: ../../library/datetime.rst:274
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
"가장 양수인 :class:`timedelta` 객체, ``timedelta(days=999999999, hours=23, "
"minutes=59, seconds=59, microseconds=999999)``."

#: ../../library/datetime.rst:280
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"같지 않은 :class:`timedelta` 객체 간의 가능한 가장 작은 차이, "
"``timedelta(microseconds=1)``."

#: ../../library/datetime.rst:283
#, fuzzy
msgid ""
"Note that, because of normalization, ``timedelta.max`` is greater than "
"``-timedelta.min``. ``-timedelta.max`` is not representable as a "
":class:`timedelta` object."
msgstr ""
"정규화로 인해, ``timedelta.max`` > ``-timedelta.min``\\입니다. "
"``-timedelta.max``\\는 :class:`timedelta` 객체로 표현할 수 없습니다."

#: ../../library/datetime.rst:287 ../../library/datetime.rst:584
#: ../../library/datetime.rst:1146 ../../library/datetime.rst:1784
msgid "Instance attributes (read-only):"
msgstr "인스턴스 어트리뷰트 (읽기 전용):"

#: ../../library/datetime.rst:291
#, fuzzy
msgid "Between -999,999,999 and 999,999,999 inclusive."
msgstr "-999999999와 999999999 사이, 경계 포함"

#: ../../library/datetime.rst:296
#, fuzzy
msgid "Between 0 and 86,399 inclusive."
msgstr "0과 86399 사이, 경계 포함"

#: ../../library/datetime.rst:300
msgid ""
"It is a somewhat common bug for code to unintentionally use this "
"attribute when it is actually intended to get a "
":meth:`~timedelta.total_seconds` value instead:"
msgstr ""

#: ../../library/datetime.rst:304
msgid ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"
msgstr ""

#: ../../library/datetime.rst:315
#, fuzzy
msgid "Between 0 and 999,999 inclusive."
msgstr "0과 999999 사이, 경계 포함"

#: ../../library/datetime.rst:318 ../../library/datetime.rst:601
#: ../../library/datetime.rst:1199
msgid "Supported operations:"
msgstr "지원되는 연산:"

#: ../../library/datetime.rst:323 ../../library/datetime.rst:604
#: ../../library/datetime.rst:1202
msgid "Operation"
msgstr "연산"

#: ../../library/datetime.rst:323 ../../library/datetime.rst:604
#: ../../library/datetime.rst:1202
msgid "Result"
msgstr "결과"

#: ../../library/datetime.rst:325
msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

#: ../../library/datetime.rst:325
#, fuzzy
msgid ""
"Sum of ``t2`` and ``t3``. Afterwards ``t1 - t2 == t3`` and ``t1 - t3 == "
"t2`` are true. (1)"
msgstr "*t2*\\와 *t3*\\의 합. 이후에는 *t1*-*t2* == *t3* 과 *t1*-*t3* == *t2*\\가 참입니다. (1)"

#: ../../library/datetime.rst:329
msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

#: ../../library/datetime.rst:329
#, fuzzy
msgid ""
"Difference of ``t2``  and ``t3``. Afterwards ``t1 == t2 - t3`` and ``t2 "
"== t1 + t3`` are true. (1)(6)"
msgstr ""
"*t2*\\와 *t3*\\의 차이. 이후에는 *t1* == *t2* - *t3* 과 *t2* == *t1* + *t3*\\가 "
"참입니다. (1)(6)"

#: ../../library/datetime.rst:333
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i 또는 t1 = i * t2``"

#: ../../library/datetime.rst:333
#, fuzzy
msgid ""
"Delta multiplied by an integer. Afterwards ``t1 // i == t2`` is true, "
"provided ``i != 0``."
msgstr "델타에 정수를 곱합니다. 이후에는 ``i != 0``\\일 때, *t1* // i == *t2*\\가 참입니다."

#: ../../library/datetime.rst:337
#, fuzzy
msgid "In general, ``t1  * i == t1 * (i-1) + t1`` is true. (1)"
msgstr "일반적으로, *t1* \\* i == *t1* \\* (i-1) + *t1*\\은 참입니다. (1)"

#: ../../library/datetime.rst:340
msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f 또는 t1 = f * t2``"

#: ../../library/datetime.rst:340
msgid ""
"Delta multiplied by a float. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"델타에 float를 곱합니다. 결과는 동률일 때 짝수로 반올림하는 방식으로 timedelta.resolution의 가장 가까운 "
"배수로 자리 올림 됩니다."

#: ../../library/datetime.rst:344
msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

#: ../../library/datetime.rst:344
#, fuzzy
msgid ""
"Division (3) of overall duration ``t2`` by interval unit ``t3``. Returns "
"a :class:`float` object."
msgstr "전체 기간 *t2*\\를 구간 단위 *t3*\\으로 나누기 (3). :class:`float` 객체를 반환합니다."

#: ../../library/datetime.rst:348
msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f 또는 t1 = t2 / i``"

#: ../../library/datetime.rst:348
msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"델타를 float나 int로 나눈 값. 결과는 동률일 때 짝수로 반올림하는 방식으로 timedelta.resolution의 가장 "
"가까운 배수로 자리 올림 됩니다."

#: ../../library/datetime.rst:352
msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` 또는 ``t1 = t2 // t3``"

#: ../../library/datetime.rst:352
msgid ""
"The floor is computed and the remainder (if any) is thrown away. In the "
"second case, an integer is returned. (3)"
msgstr "floor가 계산되고 나머지(있다면)를 버립니다. 두 번째 경우에는, 정수가 반환됩니다. (3)"

#: ../../library/datetime.rst:356
msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

#: ../../library/datetime.rst:356
msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "나머지가 :class:`timedelta` 객체로 계산됩니다. (3)"

#: ../../library/datetime.rst:359
msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

#: ../../library/datetime.rst:359
#, fuzzy
msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = "
"t1 % t2``. ``q`` is an integer and ``r`` is a :class:`timedelta` object."
msgstr ""
"몫과 나머지를 계산합니다: ``q = t1 // t2`` (3) 과 ``r = t1 % t2``. q는 정수고 r은 "
":class:`timedelta` 객체입니다."

#: ../../library/datetime.rst:364
msgid "``+t1``"
msgstr "``+t1``"

#: ../../library/datetime.rst:364
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "같은 값을 갖는 :class:`timedelta` 객체를 반환합니다. (2)"

#: ../../library/datetime.rst:367
msgid "``-t1``"
msgstr "``-t1``"

#: ../../library/datetime.rst:367
#, fuzzy
msgid ""
"Equivalent to ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, and"
" to ``t1 * -1``. (1)(4)"
msgstr ""
":class:`timedelta`\\ (-*t1.days*, -*t1.seconds*, -*t1.microseconds*) 와 "
"*t1*\\* -1과 동등합니다. (1)(4)"

#: ../../library/datetime.rst:371
msgid "``abs(t)``"
msgstr "``abs(t)``"

#: ../../library/datetime.rst:371
#, fuzzy
msgid ""
"Equivalent to ``+t`` when ``t.days >= 0``, and to ``-t`` when ``t.days < "
"0``. (2)"
msgstr "``t.days >= 0`` 일 때 +\\ *t* 와 ``t.days < 0`` 일 때 -*t*\\와 동등합니다. (2)"

#: ../../library/datetime.rst:374
msgid "``str(t)``"
msgstr "``str(t)``"

#: ../../library/datetime.rst:374
msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D"
" is negative for negative ``t``. (5)"
msgstr ""
"``[D day[s], ][H]H:MM:SS[.UUUUUU]`` 형식의 문자열을 반환합니다. 여기서 D는 음의 ``t``\\일 때 "
"음수입니다. (5)"

#: ../../library/datetime.rst:378
msgid "``repr(t)``"
msgstr "``repr(t)``"

#: ../../library/datetime.rst:378
msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr "규범적 어트리뷰트 값을 가진 생성자 호출로 표현한 :class:`timedelta` 객체의 문자열 표현을 반환합니다."

#: ../../library/datetime.rst:384 ../../library/datetime.rst:623
#: ../../library/datetime.rst:2600
msgid "Notes:"
msgstr "노트:"

#: ../../library/datetime.rst:387
msgid "This is exact but may overflow."
msgstr "이것은 정확하지만, 오버플로 할 수 있습니다."

#: ../../library/datetime.rst:390
msgid "This is exact and cannot overflow."
msgstr "이것은 정확하고, 오버플로 할 수 없습니다."

#: ../../library/datetime.rst:393
#, fuzzy
msgid "Division by zero raises :exc:`ZeroDivisionError`."
msgstr "0으로 나누면 :exc:`ZeroDivisionError`\\가 발생합니다."

#: ../../library/datetime.rst:396
#, fuzzy
msgid "``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr "-*timedelta.max*\\는 :class:`timedelta` 객체로 표현할 수 없습니다."

#: ../../library/datetime.rst:399
msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation. This leads to somewhat "
"unusual results for negative timedeltas. For example::"
msgstr ""
":class:`timedelta` 객체의 문자열 표현은 내부 표현과 유사하게 정규화됩니다. 이것은 음의 timedelta가 다소 "
"이상하게 표현되는 결과로 이어집니다. 예를 들어::"

#: ../../library/datetime.rst:403
msgid ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"
msgstr ""

#: ../../library/datetime.rst:409
msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + "
"(-t3)`` except when t3 is equal to ``timedelta.max``; in that case the "
"former will produce a result while the latter will overflow."
msgstr ""
"``t2 - t3`` 표현식은 항상 ``t2 + (-t3)`` 표현식과 같아지는데, t3이 ``timedelta.max``\\일 "
"때만 예외입니다; 이때는 앞에 있는 것은 결과를 만들지만, 뒤에 있는 것은 오버플로를 일으킵니다."

#: ../../library/datetime.rst:413
msgid ""
"In addition to the operations listed above, :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and "
":class:`.datetime` objects (see below)."
msgstr ""
"위에 나열된 연산 외에도, :class:`timedelta` 객체는 :class:`date`\\와 :class:`.datetime`"
" 객체와의 어떤 합과 차를 지원합니다 (아래를 참조하세요)."

#: ../../library/datetime.rst:417
msgid ""
"Floor division and true division of a :class:`timedelta` object by "
"another :class:`timedelta` object are now supported, as are remainder "
"operations and the :func:`divmod` function. True division and "
"multiplication of a :class:`timedelta` object by a :class:`float` object "
"are now supported."
msgstr ""
"나머지 연산과 :func:`divmod` 함수와 마찬가지로, :class:`timedelta` 객체를 다른 "
":class:`timedelta` 객체로 정수 나누기(floor division)와 실수 나누기(true division)가 이제 "
"지원됩니다. :class:`timedelta` 객체를 :class:`float` 객체로 실수 나누기와 곱셈도 이제 이제 지원됩니다."

#: ../../library/datetime.rst:423
msgid ":class:`timedelta` objects support equality and order comparisons."
msgstr ""

#: ../../library/datetime.rst:425
msgid ""
"In Boolean contexts, a :class:`timedelta` object is considered to be true"
" if and only if it isn't equal to ``timedelta(0)``."
msgstr "불리언 문맥에서 :class:`timedelta` 객체는 ``timedelta(0)``\\와 같지 않을 때만 참으로 간주합니다."

#: ../../library/datetime.rst:428 ../../library/datetime.rst:665
#: ../../library/datetime.rst:1289 ../../library/datetime.rst:1891
msgid "Instance methods:"
msgstr "인스턴스 메서드:"

#: ../../library/datetime.rst:432
msgid ""
"Return the total number of seconds contained in the duration. Equivalent "
"to ``td / timedelta(seconds=1)``. For interval units other than seconds, "
"use the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"기간에 포함된 총 시간을 초(seconds)로 반환합니다. ``td / timedelta(seconds=1)``\\와 동등합니다. "
"초 이외의 구간 단위에는, 나누기 형식을 직접 사용하십시오 (예를 들어, ``td / "
"timedelta(microseconds=1)``)."

#: ../../library/datetime.rst:436
msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr "매우 큰 시간 구간에서는 (대부분 플랫폼에서 270년 이상), 이 메서드는 마이크로초의 정확도를 잃게 됩니다."

#: ../../library/datetime.rst:442
msgid "Examples of usage: :class:`timedelta`"
msgstr "사용 예: :class:`timedelta`"

#: ../../library/datetime.rst:444
msgid "An additional example of normalization::"
msgstr "정규화의 추가 예::"

#: ../../library/datetime.rst:446
msgid ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"
msgstr ""

#: ../../library/datetime.rst:456
msgid "Examples of :class:`timedelta` arithmetic::"
msgstr ":class:`timedelta` 산술의 예::"

#: ../../library/datetime.rst:458
msgid ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"
msgstr ""

#: ../../library/datetime.rst:475
msgid ":class:`date` Objects"
msgstr ":class:`date` 객체"

#: ../../library/datetime.rst:477
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended "
"in both directions."
msgstr ":class:`date` 객체는 현재의 그레고리력을 무한히 양방향으로 확장한, 이상적인 달력에서의 날짜(년, 월, 일)를 나타냅니다."

#: ../../library/datetime.rst:481
msgid ""
"January 1 of year 1 is called day number 1, January 2 of year 1 is called"
" day number 2, and so on. [#]_"
msgstr "1년 1월 1일을 날 번호 1, 1년 1월 2일을 날 번호 2라고 부르고, 이런 식으로 계속됩니다. [#]_"

#: ../../library/datetime.rst:486
msgid ""
"All arguments are required. Arguments must be integers, in the following "
"ranges:"
msgstr "모든 인자가 필수입니다. 인자는 다음 범위에 있는 정수이어야 합니다:"

#: ../../library/datetime.rst:489
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= year <= MAXYEAR``"

#: ../../library/datetime.rst:490
msgid "``1 <= month <= 12``"
msgstr "``1 <= month <= 12``"

#: ../../library/datetime.rst:491
msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= day <= 주어진 month와 year에서의 날 수``"

#: ../../library/datetime.rst:493 ../../library/datetime.rst:883
msgid "If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr "이 범위를 벗어나는 인자가 주어지면, :exc:`ValueError`\\가 발생합니다."

#: ../../library/datetime.rst:496 ../../library/datetime.rst:888
msgid "Other constructors, all class methods:"
msgstr "다른 생성자, 모든 클래스 메서드:"

#: ../../library/datetime.rst:500
msgid "Return the current local date."
msgstr "현재 지역 날짜를 반환합니다."

#: ../../library/datetime.rst:502
msgid "This is equivalent to ``date.fromtimestamp(time.time())``."
msgstr "이것은 ``date.fromtimestamp(time.time())``\\과 동등합니다."

#: ../../library/datetime.rst:506
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`."
msgstr ":func:`time.time`\\에 의해 반환된 것과 같은 POSIX 타임스탬프에 해당하는 지역 날짜를 반환합니다."

#: ../../library/datetime.rst:509
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range"
" of values supported by the platform C :c:func:`localtime` function, and "
":exc:`OSError` on :c:func:`localtime` failure. It's common for this to be"
" restricted to years from 1970 through 2038. Note that on non-POSIX "
"systems that include leap seconds in their notion of a timestamp, leap "
"seconds are ignored by :meth:`fromtimestamp`."
msgstr ""
"타임스탬프가 플랫폼 C :c:func:`localtime` 함수에서 지원하는 값 범위를 벗어나면 "
":exc:`OverflowError`\\가 발생하고, :c:func:`localtime` 실패 시 :exc:`OSError`\\가 "
"발생합니다. 이것이 1970년에서 2038년으로 제한되는 것이 일반적입니다. 타임스탬프라는 개념에 윤초를 포함하는 POSIX가 아닌"
" 시스템에서는, 윤초가 :meth:`fromtimestamp`\\에서 무시됨에 유의하십시오."

#: ../../library/datetime.rst:516
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp "
"is out of the range of values supported by the platform C "
":c:func:`localtime` function. Raise :exc:`OSError` instead of "
":exc:`ValueError` on :c:func:`localtime` failure."
msgstr ""
"timestamp가 플랫폼 C :c:func:`localtime` 함수에서 지원하는 값 범위를 벗어나면 "
":exc:`ValueError` 대신 :exc:`OverflowError`\\를 발생시킵니다. :c:func:`localtime` "
"실패 시 :exc:`ValueError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/datetime.rst:525
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1."
msgstr "역산 그레고리력 서수에 해당하는 date를 반환합니다. 1년 1월 1일이 서수 1입니다."

#: ../../library/datetime.rst:528
#, fuzzy
msgid ""
":exc:`ValueError` is raised unless ``1 <= ordinal <= "
"date.max.toordinal()``. For any date ``d``, "
"``date.fromordinal(d.toordinal()) == d``."
msgstr ""
"``1 <= ordinal <= date.max.toordinal()``\\이 아니면 :exc:`ValueError`\\가 "
"발생합니다. 모든 date *d*\\에 대해, ``date.fromordinal(d.toordinal()) == d``\\입니다."

#: ../../library/datetime.rst:535
#, fuzzy
msgid ""
"Return a :class:`date` corresponding to a *date_string* given in any "
"valid ISO 8601 format, with the following exceptions:"
msgstr "``YYYY-MM-DD`` 형식으로 제공된 *date_string*\\에 해당하는 :class:`date`\\를 반환합니다::"

#: ../../library/datetime.rst:538 ../../library/datetime.rst:1048
msgid ""
"Reduced precision dates are not currently supported (``YYYY-MM``, "
"``YYYY``)."
msgstr ""

#: ../../library/datetime.rst:540 ../../library/datetime.rst:1050
msgid ""
"Extended date representations are not currently supported (``±YYYYYY-MM-"
"DD``)."
msgstr ""

#: ../../library/datetime.rst:542 ../../library/datetime.rst:1052
msgid "Ordinal dates are not currently supported (``YYYY-OOO``)."
msgstr ""

#: ../../library/datetime.rst:544 ../../library/datetime.rst:1054
#: ../../library/datetime.rst:1520
msgid "Examples::"
msgstr "예제:"

#: ../../library/datetime.rst:546
msgid ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"
msgstr ""

#: ../../library/datetime.rst:555
#, fuzzy
msgid "Previously, this method only supported the format ``YYYY-MM-DD``."
msgstr "이것은 :meth:`date.isoformat`\\의 역연산입니다. 형식 ``YYYY-MM-DD``\\만 지원합니다."

#: ../../library/datetime.rst:560
msgid ""
"Return a :class:`date` corresponding to the ISO calendar date specified "
"by year, week and day. This is the inverse of the function "
":meth:`date.isocalendar`."
msgstr ""
"년, 주 및 일로 지정된 ISO 달력 날짜에 해당하는 :class:`date`\\를 반환합니다. 이것은 함수 "
":meth:`date.isocalendar`\\의 역입니다."

#: ../../library/datetime.rst:570
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "표현 가능한 가장 이른 date, ``date(MINYEAR, 1, 1)``."

#: ../../library/datetime.rst:575
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "표현 가능한 가장 늦은 date, ``date(MAXYEAR, 12, 31)``."

#: ../../library/datetime.rst:580
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr "같지 않은 date 객체 간의 가능한 가장 작은 차이, ``timedelta(days=1)``."

#: ../../library/datetime.rst:588 ../../library/datetime.rst:1150
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ":const:`MINYEAR`\\와 :const:`MAXYEAR` 사이, 경계 포함."

#: ../../library/datetime.rst:593 ../../library/datetime.rst:1155
msgid "Between 1 and 12 inclusive."
msgstr "1과 12 사이, 경계 포함."

#: ../../library/datetime.rst:598 ../../library/datetime.rst:1160
msgid "Between 1 and the number of days in the given month of the given year."
msgstr "1과 주어진 year의 주어진 month의 날 수 사이."

#: ../../library/datetime.rst:606
msgid "``date2 = date1 + timedelta``"
msgstr "``date2 = date1 + timedelta``"

#: ../../library/datetime.rst:606
#, fuzzy
msgid "``date2`` will be ``timedelta.days`` days after ``date1``. (1)"
msgstr "*date2*\\는 *date1*\\에서 ``timedelta.days`` 일 이동한 날짜입니다. (1)"

#: ../../library/datetime.rst:609
msgid "``date2 = date1 - timedelta``"
msgstr "``date2 = date1 - timedelta``"

#: ../../library/datetime.rst:609
#, fuzzy
msgid "Computes ``date2`` such that ``date2 + timedelta == date1``. (2)"
msgstr "``date2 + timedelta == date1``\\가 성립하는 *date2*\\를 계산합니다. (2)"

#: ../../library/datetime.rst:612
msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = date1 - date2``"

#: ../../library/datetime.rst:612 ../../library/datetime.rst:1208
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/datetime.rst
#, fuzzy
msgid "``date1 == date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``date1 != date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst:614 ../../library/datetime.rst:1210
msgid "Equality comparison. (4)"
msgstr ""

#: ../../library/datetime.rst
msgid "``date1 < date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``date1 > date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``date1 <= date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``date1 >= date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst:617 ../../library/datetime.rst:1213
msgid "Order comparison. (5)"
msgstr ""

#: ../../library/datetime.rst:626
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward "
"if ``timedelta.days < 0``. Afterward ``date2 - date1 == timedelta.days``."
" ``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. "
":exc:`OverflowError` is raised if ``date2.year`` would be smaller than "
":const:`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"*date2*\\는 ``timedelta.days > 0``\\이면 미래로, ``timedelta.days < 0``\\이면 과거로"
" 이동합니다. 결국 ``date2 - date1 == timedelta.days``\\이 됩니다. "
"``timedelta.seconds``\\와 ``timedelta.microseconds``\\는 무시됩니다. "
"``date2.year``\\가 :const:`MINYEAR`\\보다 작거나 :const:`MAXYEAR`\\보다 크게 되려고 하면"
" :exc:`OverflowError`\\가 발생합니다."

#: ../../library/datetime.rst:633
msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds``\\와 ``timedelta.microseconds``\\는 무시됩니다."

#: ../../library/datetime.rst:636
#, fuzzy
msgid ""
"This is exact, and cannot overflow. ``timedelta.seconds`` and "
"``timedelta.microseconds`` are 0, and ``date2 + timedelta == date1`` "
"after."
msgstr ""
"이것은 정확하고, 오버플로 할 수 없습니다. timedelta.seconds와 timedelta.microseconds는 0이고, "
"이후에 date2 + timedelta == date1 이 됩니다."

#: ../../library/datetime.rst:640
msgid ":class:`date` objects are equal if they represent the same date."
msgstr ""

#: ../../library/datetime.rst:642
msgid ""
":class:`!date` objects that are not also :class:`.datetime` instances are"
" never equal to :class:`!datetime` objects, even if they represent the "
"same date."
msgstr ""

#: ../../library/datetime.rst:647
#, fuzzy
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. In other words, ``date1 < date2`` if and only if "
"``date1.toordinal() < date2.toordinal()``."
msgstr "*date1*\\이 *date2*\\에 앞서면 *date1*\\는 *date2*\\보다 작은 것으로 간주합니다. (4)"

#: ../../library/datetime.rst:651
#, fuzzy
msgid ""
"Order comparison between a :class:`!date` object that is not also a "
":class:`.datetime` instance and a :class:`!datetime` object raises "
":exc:`TypeError`."
msgstr "어웨어와 나이브 :class:`.datetime` 인스턴스 간의 동등 비교는 :exc:`TypeError`\\를 발생시키지 않습니다."

#: ../../library/datetime.rst:655 ../../library/datetime.rst:1281
msgid ""
"Comparison between :class:`.datetime` object and an instance of the "
":class:`date` subclass that is not a :class:`!datetime` subclass no "
"longer converts the latter to :class:`!date`, ignoring the time part and "
"the time zone. The default behavior can be changed by overriding the "
"special comparison methods in subclasses."
msgstr ""

#: ../../library/datetime.rst:663
msgid "In Boolean contexts, all :class:`date` objects are considered to be true."
msgstr "불리언 문맥에서, 모든 :class:`date` 객체는 참으로 간주합니다."

#: ../../library/datetime.rst:669
#, fuzzy
msgid ""
"Return a new :class:`date` object with the same values, but with "
"specified parameters updated."
msgstr "같은 year, month, day의 :class:`date` 객체를 반환합니다."

#: ../../library/datetime.rst:672 ../../library/datetime.rst:1937
msgid "Example::"
msgstr "예제:"

#: ../../library/datetime.rst:674
msgid ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"
msgstr ""

#: ../../library/datetime.rst:679
msgid ""
"The generic function :func:`copy.replace` also supports :class:`date` "
"objects."
msgstr ""

#: ../../library/datetime.rst:685 ../../library/datetime.rst:1405
msgid ""
"Return a :class:`time.struct_time` such as returned by "
":func:`time.localtime`."
msgstr ":func:`time.localtime`\\이 반환하는 것과 같은 :class:`time.struct_time`\\을 반환합니다."

#: ../../library/datetime.rst:687
msgid "The hours, minutes and seconds are 0, and the DST flag is -1."
msgstr "시, 분 및 초는 0이고, DST 플래그는 -1입니다."

#: ../../library/datetime.rst:689 ../../library/datetime.rst:1407
msgid "``d.timetuple()`` is equivalent to::"
msgstr "``d.timetuple()``\\은 다음과 동등합니다::"

#: ../../library/datetime.rst:691
msgid "time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"
msgstr ""

#: ../../library/datetime.rst:693
#, fuzzy
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is "
"the day number within the current year starting with 1 for January 1st."
msgstr ""
"여기서 ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1``\\은 1월 "
"1일에 ``1``\\로 시작하는 현재 연도의 날짜 번호입니다."

#: ../../library/datetime.rst:699
#, fuzzy
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of "
"year 1 has ordinal 1. For any :class:`date` object ``d``, "
"``date.fromordinal(d.toordinal()) == d``."
msgstr ""
"역산 그레고리력 서수를 돌려줍니다. 1년 1월 1일의 서수는 1입니다. 임의의 :class:`date` 객체 *d*\\에 대해 "
"``date.fromordinal(d.toordinal()) == d``\\입니다."

#: ../../library/datetime.rst:706
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is"
" 6. For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See "
"also :meth:`isoweekday`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 0이고 일요일은 6입니다. 예를 들어, ``date(2002, 12, 4).weekday() "
"== 2``, 수요일. :meth:`isoweekday`\\도 참조하십시오."

#: ../../library/datetime.rst:713
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is"
" 7. For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. "
"See also :meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 1이고 일요일은 7입니다. 예를 들어, ``date(2002, 12, "
"4).isoweekday() == 3``, 수요일. :meth:`weekday`, :meth:`isocalendar`\\도 "
"참조하십시오."

#: ../../library/datetime.rst:720
msgid ""
"Return a :term:`named tuple` object with three components: ``year``, "
"``week`` and ``weekday``."
msgstr ""
"세 개의 구성 요소가 있는 :term:`네임드 튜플 <named tuple>` 객체를 반환합니다: ``year``, ``week``"
" 및 ``weekday``."

#: ../../library/datetime.rst:723
msgid "The ISO calendar is a widely used variant of the Gregorian calendar. [#]_"
msgstr "ISO 달력은 널리 사용되는 그레고리력의 변형입니다. [#]_"

#: ../../library/datetime.rst:725
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on "
"a Monday and ends on a Sunday. The first week of an ISO year is the first"
" (Gregorian) calendar week of a year containing a Thursday. This is "
"called week number 1, and the ISO year of that Thursday is the same as "
"its Gregorian year."
msgstr ""
"ISO 연도는 52나 53개의 완전한 주로 구성되고, 주는 월요일에 시작하여 일요일에 끝납니다. ISO 연도의 첫 번째 주는 그 "
"해의 (그레고리) 달력에서 목요일이 들어있는 첫 번째 주입니다. 이것을 주 번호 1이라고 하며, 그 목요일의 ISO 연도는 그레고리"
" 연도와 같습니다."

#: ../../library/datetime.rst:730
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year "
"2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004::"
msgstr ""
"예를 들어, 2004년은 목요일에 시작되므로, ISO 연도 2004의 첫 주는 월요일, 2003년 12월 29일에 시작하고, "
"일요일, 2004년 1월 4일에 끝납니다::"

#: ../../library/datetime.rst:733
msgid ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"
msgstr ""

#: ../../library/datetime.rst:739
msgid "Result changed from a tuple to a :term:`named tuple`."
msgstr "결과가 튜플에서 :term:`네임드 튜플 <named tuple>`\\로 변경되었습니다."

#: ../../library/datetime.rst:744
msgid "Return a string representing the date in ISO 8601 format, ``YYYY-MM-DD``::"
msgstr "ISO 8601 형식으로 날짜를 나타내는 문자열을 반환합니다, ``YYYY-MM-DD``::"

#: ../../library/datetime.rst:746
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"
msgstr ""

#: ../../library/datetime.rst:752
#, fuzzy
msgid "For a date ``d``, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "날짜 *d*\\에 대해, ``str(d)``\\는 ``d.isoformat()``\\와 동등합니다."

#: ../../library/datetime.rst:757
msgid "Return a string representing the date::"
msgstr "날짜를 나타내는 문자열을 반환합니다::"

#: ../../library/datetime.rst:759
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"
msgstr ""

#: ../../library/datetime.rst:763 ../../library/datetime.rst:1591
msgid "``d.ctime()`` is equivalent to::"
msgstr "``d.ctime()``\\은 다음과::"

#: ../../library/datetime.rst:765 ../../library/datetime.rst:1593
msgid "time.ctime(time.mktime(d.timetuple()))"
msgstr ""

#: ../../library/datetime.rst:767
msgid ""
"on platforms where the native C :c:func:`ctime` function (which "
":func:`time.ctime` invokes, but which :meth:`date.ctime` does not invoke)"
" conforms to the C standard."
msgstr ""
"네이티브 C :c:func:`ctime` 함수(:func:`time.ctime`\\은 호출하지만 "
":meth:`date.ctime`\\은 호출하지 않습니다)가 C 표준을 준수하는 플랫폼에서 동등합니다."

#: ../../library/datetime.rst:774
#, fuzzy
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See also :ref:`strftime-strptime-behavior` and "
":meth:`date.isoformat`."
msgstr ""
"명시적인 포맷 문자열로 제어되는, 날짜를 나타내는 문자열을 반환합니다. 시, 분 또는 초를 나타내는 포맷 코드는 0 값을 보게 "
"됩니다. 포매팅 지시자의 전체 목록은, :ref:`strftime-strptime-behavior`\\를 참조하십시오."

#: ../../library/datetime.rst:781
#, fuzzy
msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a "
"format string for a :class:`.date` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref"
":`strftime-strptime-behavior` and :meth:`date.isoformat`."
msgstr ""
":meth:`.date.strftime`\\과 같습니다. 이것이 :ref:`포맷 문자열 리터럴 <f-strings>`\\과 "
":meth:`str.format`\\을 사용할 때 :class:`.date` 객체를 위한 포맷 문자열을 지정할 수 있도록 합니다. "
"포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-behavior`\\를 참조하십시오."

#: ../../library/datetime.rst:787
msgid "Examples of Usage: :class:`date`"
msgstr "사용 예: :class:`date`"

#: ../../library/datetime.rst:789
msgid "Example of counting days to an event::"
msgstr "이벤트까지 남은 날 수 계산 예::"

#: ../../library/datetime.rst:791
msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""

#: ../../library/datetime.rst:808
msgid "More examples of working with :class:`date`:"
msgstr ":class:`date`\\로 작업하는 추가 예:"

#: ../../library/datetime.rst:810
#, python-brace-format, python-format
msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")"
"\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"
msgstr ""

#: ../../library/datetime.rst:857
msgid ":class:`.datetime` Objects"
msgstr ":class:`.datetime` 객체"

#: ../../library/datetime.rst:859
msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object."
msgstr ""
":class:`.datetime` 객체는 :class:`date` 객체와 :class:`.time` 객체의 모든 정보를 포함하는 "
"단일 객체입니다."

#: ../../library/datetime.rst:862
msgid ""
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a :class:`.time` "
"object, :class:`.datetime` assumes there are exactly 3600\\*24 seconds in"
" every day."
msgstr ""
":class:`date` 객체와 마찬가지로, :class:`.datetime`\\은 현재의 그레고리력을 양방향으로 확장한다고 "
"가정합니다; :class:`.time` 객체와 마찬가지로, :class:`.datetime`\\은 하루가 정확히 "
"3600\\*24초인 것으로 가정합니다."

#: ../../library/datetime.rst:866
msgid "Constructor:"
msgstr "생성자:"

#: ../../library/datetime.rst:870
msgid ""
"The *year*, *month* and *day* arguments are required. *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass. The remaining "
"arguments must be integers in the following ranges:"
msgstr ""
"*year*, *month*, *day* 인자는 필수입니다. *tzinfo*\\는 ``None``\\이거나 "
":class:`tzinfo` 서브 클래스의 인스턴스일 수 있습니다. 나머지 인자는 다음 범위의 정수이어야 합니다:"

#: ../../library/datetime.rst:874
msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= year <= MAXYEAR``,"

#: ../../library/datetime.rst:875
msgid "``1 <= month <= 12``,"
msgstr "``1 <= month <= 12``,"

#: ../../library/datetime.rst:876
msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= day <= 주어진 month와 year에서의 날 수``,"

#: ../../library/datetime.rst:877 ../../library/datetime.rst:1755
msgid "``0 <= hour < 24``,"
msgstr "``0 <= hour < 24``,"

#: ../../library/datetime.rst:878 ../../library/datetime.rst:1756
msgid "``0 <= minute < 60``,"
msgstr "``0 <= minute < 60``,"

#: ../../library/datetime.rst:879 ../../library/datetime.rst:1757
msgid "``0 <= second < 60``,"
msgstr "``0 <= second < 60``,"

#: ../../library/datetime.rst:880 ../../library/datetime.rst:1758
msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= microsecond < 1000000``,"

#: ../../library/datetime.rst:881 ../../library/datetime.rst:1759
msgid "``fold in [0, 1]``."
msgstr "``fold in [0, 1]``."

#: ../../library/datetime.rst:885 ../../library/datetime.rst:1326
#: ../../library/datetime.rst:1904
#, fuzzy
msgid "Added the *fold* parameter."
msgstr "``fold`` 인자가 추가되었습니다."

#: ../../library/datetime.rst:892
#, fuzzy
msgid "Return the current local date and time, with :attr:`.tzinfo` ``None``."
msgstr ":attr:`.tzinfo`\\가 ``None``\\인 현재 지역 datetime을 반환합니다."

#: ../../library/datetime.rst:894
msgid "Equivalent to::"
msgstr "다음과 동등합니다::"

#: ../../library/datetime.rst:896
#, fuzzy
msgid "datetime.fromtimestamp(time.time())"
msgstr "이것은 ``date.fromtimestamp(time.time())``\\과 동등합니다."

#: ../../library/datetime.rst:898
msgid "See also :meth:`now`, :meth:`fromtimestamp`."
msgstr ":meth:`now`, :meth:`fromtimestamp`\\를 참조하십시오."

#: ../../library/datetime.rst:900
msgid ""
"This method is functionally equivalent to :meth:`now`, but without a "
"``tz`` parameter."
msgstr "이 메서드는 기능적으로 :meth:`now`\\와 동등하지만, ``tz`` 매개 변수는 없습니다."

#: ../../library/datetime.rst:905
msgid "Return the current local date and time."
msgstr "현재의 지역 날짜와 시간을 반환합니다."

#: ../../library/datetime.rst:907
msgid ""
"If optional argument *tz* is ``None`` or not specified, this is like "
":meth:`today`, but, if possible, supplies more precision than can be "
"gotten from going through a :func:`time.time` timestamp (for example, "
"this may be possible on platforms supplying the C :c:func:`gettimeofday` "
"function)."
msgstr ""
"선택적 인자 *tz*\\가 ``None``\\이거나 지정되지 않으면, :meth:`today`\\와 유사합니다. 하지만, 가능하면 "
":func:`time.time` 타임스탬프를 통해 얻을 수 있는 것보다 더 높은 정밀도를 제공합니다 (예를 들어, C "
":c:func:`gettimeofday` 함수를 제공하는 플랫폼에서 가능합니다)."

#: ../../library/datetime.rst:913
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time "
"zone."
msgstr ""
"*tz*\\가 ``None``\\이 아니면, :class:`tzinfo` 서브 클래스의 인스턴스여야 하며, 현재 날짜와 시간이 "
"*tz*\\의 시간대로 변환됩니다."

#: ../../library/datetime.rst:916
msgid "This function is preferred over :meth:`today` and :meth:`utcnow`."
msgstr "이 함수는 :meth:`today`\\와 :meth:`utcnow`\\보다 선호됩니다."

#: ../../library/datetime.rst:920
msgid ""
"Subsequent calls to :meth:`!datetime.now` may return the same instant "
"depending on the precision of the underlying clock."
msgstr ""

#: ../../library/datetime.rst:925
msgid "Return the current UTC date and time, with :attr:`.tzinfo` ``None``."
msgstr ":attr:`.tzinfo`\\가 ``None``\\인 현재 UTC 날짜와 시간을 반환합니다."

#: ../../library/datetime.rst:927
msgid ""
"This is like :meth:`now`, but returns the current UTC date and time, as a"
" naive :class:`.datetime` object. An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``. See also :meth:`now`."
msgstr ""
"이것은 :meth:`now`\\와 비슷하지만, 현재의 UTC 날짜와 시간을 나이브 :class:`.datetime` 객체로 "
"반환합니다. 현재 어웨어 UTC datetime은 ``datetime.now(timezone.utc)``\\를 호출하여 얻을 수 "
"있습니다. :meth:`now`\\도 참조하십시오."

#: ../../library/datetime.rst:933
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` "
"methods as local times, it is preferred to use aware datetimes to "
"represent times in UTC. As such, the recommended way to create an object "
"representing the current time in UTC is by calling "
"``datetime.now(timezone.utc)``."
msgstr ""
"나이브 ``datetime`` 객체는 많은 ``datetime`` 메서드에 의해 지역 시간으로 취급되므로, UTC로 시간을 나타내는"
" 어웨어 datetime을 사용하는 것이 좋습니다. 따라서 UTC로 현재 시간을 나타내는 객체를 만드는 권장 방법은 "
"``datetime.now(timezone.utc)``\\를 호출하는 것입니다."

#: ../../library/datetime.rst:940
msgid "Use :meth:`datetime.now` with :const:`UTC` instead."
msgstr ""

#: ../../library/datetime.rst:945
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such"
" as is returned by :func:`time.time`. If optional argument *tz* is "
"``None`` or not specified, the timestamp is converted to the platform's "
"local date and time, and the returned :class:`.datetime` object is naive."
msgstr ""
":func:`time.time`\\가 반환하는 것과 같은, POSIX timestamp에 해당하는 지역 날짜와 시간을 반환합니다. "
"선택적 인자 *tz*\\가 ``None``\\이거나 지정되지 않으면 timestamp는 플랫폼의 지역 날짜와 시간으로 변환되며, "
"반환된 :class:`.datetime` 객체는 나이브합니다."

#: ../../library/datetime.rst:950
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone."
msgstr ""
"*tz*\\가 ``None``\\이 아니면, :class:`tzinfo` 서브 클래스의 인스턴스여야 하며, timestamp는 "
"*tz*\\의 시간대로 변환됩니다."

#: ../../library/datetime.rst:953
msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is"
" out of the range of values supported by the platform C "
":c:func:`localtime` or :c:func:`gmtime` functions, and :exc:`OSError` on "
":c:func:`localtime` or :c:func:`gmtime` failure. It's common for this to "
"be restricted to years in 1970 through 2038. Note that on non-POSIX "
"systems that include leap seconds in their notion of a timestamp, leap "
"seconds are ignored by :meth:`fromtimestamp`, and then it's possible to "
"have two timestamps differing by a second that yield identical "
":class:`.datetime` objects. This method is preferred over "
":meth:`utcfromtimestamp`."
msgstr ""
"timestamp가 플랫폼 C :c:func:`localtime` 이나 :c:func:`gmtime` 함수에서 지원하는 값 범위를 "
"벗어나면 :meth:`fromtimestamp`\\가 :exc:`OverflowError`\\를 발생시킬 수 있고, "
":c:func:`localtime` 이나 :c:func:`gmtime`\\이 실패하면 :exc:`OSError`\\를 발생시킬 수 "
"있습니다. 1970년에서 2038년까지로 제한되는 것이 일반적입니다. 타임스탬프에 윤초 개념을 포함하는 비 POSIX 시스템에서, "
":meth:`fromtimestamp`\\는 윤초를 무시하므로, 1초 차이가 나는 두 개의 타임스탬프가 같은 "
":class:`.datetime` 객체를 산출할 수 있습니다. 이 방법은 :meth:`utcfromtimestamp`\\보다 "
"선호됩니다."

#: ../../library/datetime.rst:964
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp "
"is out of the range of values supported by the platform C "
":c:func:`localtime` or :c:func:`gmtime` functions. Raise :exc:`OSError` "
"instead of :exc:`ValueError` on :c:func:`localtime` or :c:func:`gmtime` "
"failure."
msgstr ""
"timestamp가 플랫폼 C :c:func:`localtime` 이나 :c:func:`gmtime` 함수에서 지원하는 값 범위를 "
"벗어나면 :exc:`ValueError` 대신 :exc:`OverflowError`\\를 발생시킵니다. "
":c:func:`localtime` 이나 :c:func:`gmtime`\\이 실패하면 :exc:`ValueError` 대신 "
":exc:`OSError`\\를 발생시킵니다."

#: ../../library/datetime.rst:971
msgid ":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ":meth:`fromtimestamp`\\는 :attr:`.fold`\\가 1로 설정된 인스턴스를 반환할 수 있습니다."

#: ../../library/datetime.rst:976
msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, "
"with :attr:`.tzinfo` ``None``.  (The resulting object is naive.)"
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\인 POSIX timestamp에 해당하는 UTC "
":class:`.datetime`\\을 반환합니다. (결과 객체는 나이브합니다.)"

#: ../../library/datetime.rst:979
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range"
" of values supported by the platform C :c:func:`gmtime` function, and "
":exc:`OSError` on :c:func:`gmtime` failure. It's common for this to be "
"restricted to years in 1970 through 2038."
msgstr ""
"timestamp가 플랫폼 C :c:func:`gmtime` 함수에서 지원하는 값 범위를 벗어나면 "
":exc:`OverflowError`\\가 발생하고, :c:func:`gmtime`\\이 실패하면 :exc:`OSError`\\가 "
"발생합니다. 1970년에서 2038년까지로 제한되는 것이 일반적입니다."

#: ../../library/datetime.rst:984
msgid "To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr "어웨어 :class:`.datetime` 객체를 얻으려며, :meth:`fromtimestamp`\\를 호출하십시오::"

#: ../../library/datetime.rst:986
msgid "datetime.fromtimestamp(timestamp, timezone.utc)"
msgstr ""

#: ../../library/datetime.rst:988
msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr "POSIX 호환 플랫폼에서, 다음 표현식과 동등합니다::"

#: ../../library/datetime.rst:991
msgid "datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"
msgstr ""

#: ../../library/datetime.rst:993
msgid ""
"except the latter formula always supports the full years range: between "
":const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""
"단, 후자의 식은 항상 전체 연도 범위를 지원합니다: :const:`MINYEAR`\\와 :const:`MAXYEAR` 사이, 경계"
" 포함."

#: ../../library/datetime.rst:998
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` "
"methods as local times, it is preferred to use aware datetimes to "
"represent times in UTC. As such, the recommended way to create an object "
"representing a specific timestamp in UTC is by calling "
"``datetime.fromtimestamp(timestamp, tz=timezone.utc)``."
msgstr ""
"나이브 ``datetime`` 객체는 많은 ``datetime`` 메서드에 의해 지역 시간으로 취급되므로. UTC로 시간을 나타내는"
" 어웨어 datetime을 사용하는 것이 좋습니다. 따라서 UTC로 특정 timestamp를 나타내는 객체를 만드는 권장 방법은 "
"``datetime.fromtimestamp(timestamp, tz=timezone.utc)``\\를 호출하는 것입니다."

#: ../../library/datetime.rst:1004
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp "
"is out of the range of values supported by the platform C "
":c:func:`gmtime` function. Raise :exc:`OSError` instead of "
":exc:`ValueError` on :c:func:`gmtime` failure."
msgstr ""
"timestamp가 플랫폼 C :c:func:`gmtime` 함수에서 지원하는 값 범위를 벗어나면 :exc:`ValueError` "
"대신 :exc:`OverflowError`\\를 발생시킵니다. :c:func:`gmtime`\\이 실패하면 "
":exc:`ValueError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/datetime.rst:1012
msgid "Use :meth:`datetime.fromtimestamp` with :const:`UTC` instead."
msgstr ""

#: ../../library/datetime.rst:1017
msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``. The hour, "
"minute, second and microsecond of the result are all 0, and "
":attr:`.tzinfo` is ``None``."
msgstr ""
"역산 그레고리력 서수(ordinal)에 해당하는 :class:`.datetime`\\을 반환합니다. 1년 1월 1일이 서수 "
"1입니다. ``1 <= ordinal <= datetime.max.toordinal()``\\이 아니면 "
":exc:`ValueError`\\가 발생합니다. 결과의 hour, minute, second 및 microsecond는 모두 "
"0이고, :attr:`.tzinfo`\\는 ``None``\\입니다."

#: ../../library/datetime.rst:1025
#, fuzzy
msgid ""
"Return a new :class:`.datetime` object whose date components are equal to"
" the given :class:`date` object's, and whose time components are equal to"
" the given :class:`.time` object's. If the *tzinfo* argument is provided,"
" its value is used to set the :attr:`.tzinfo` attribute of the result, "
"otherwise the :attr:`~.time.tzinfo` attribute of the *time* argument is "
"used.  If the *date* argument is a :class:`.datetime` object, its time "
"components and :attr:`.tzinfo` attributes are ignored."
msgstr ""
"지정된 :class:`date` 객체와 같은 날짜 구성 요소와 지정된 :class:`.time` 객체와 같은 시간 구성 요소를 갖는"
" 새 :class:`.datetime` 객체를 반환합니다. *tzinfo* 인자가 제공되면, 그 값은 결과의 "
":attr:`.tzinfo` 어트리뷰트를 설정하는 데 사용되며, 그렇지 않으면 *time* 인자의 "
":attr:`~.time.tzinfo` 어트리뷰트가 사용됩니다."

#: ../../library/datetime.rst:1033
#, fuzzy
msgid ""
"For any :class:`.datetime` object ``d``, ``d == "
"datetime.combine(d.date(), d.time(), d.tzinfo)``."
msgstr ""
"모든 :class:`.datetime` 객체 *d*\\에 대해, ``d == datetime.combine(d.date(), "
"d.time(), d.tzinfo)``\\가 성립합니다. date가 :class:`.datetime` 객체면, 그것의 시간 구성 "
"요소와 :attr:`.tzinfo` 어트리뷰트가 무시됩니다."

#: ../../library/datetime.rst:1036
msgid "Added the *tzinfo* argument."
msgstr "*tzinfo* 인자가 추가되었습니다."

#: ../../library/datetime.rst:1042
#, fuzzy
msgid ""
"Return a :class:`.datetime` corresponding to a *date_string* in any valid"
" ISO 8601 format, with the following exceptions:"
msgstr "*format*\\에 따라 구문 분석된, *date_string*\\에 해당하는 :class:`.datetime`\\를 반환합니다."

#: ../../library/datetime.rst:1045 ../../library/datetime.rst:1855
msgid "Time zone offsets may have fractional seconds."
msgstr ""

#: ../../library/datetime.rst:1046
#, fuzzy
msgid "The ``T`` separator may be replaced by any single unicode character."
msgstr "여기서 ``*``\\는 임의의 단일 문자와 일치 할 수 있습니다."

#: ../../library/datetime.rst:1047 ../../library/datetime.rst:1860
msgid "Fractional hours and minutes are not supported."
msgstr ""

#: ../../library/datetime.rst:1056
msgid ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, "
"tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"
msgstr ""

#: ../../library/datetime.rst:1078
#, fuzzy
msgid ""
"Previously, this method only supported formats that could be emitted by "
":meth:`date.isoformat` or :meth:`datetime.isoformat`."
msgstr ""
":meth:`date.isoformat`\\과 :meth:`datetime.isoformat`\\이 출력하는 형식 중 하나인 "
"*date_string*\\에 해당하는 :class:`.datetime`\\을 반환합니다."

#: ../../library/datetime.rst:1085
msgid ""
"Return a :class:`.datetime` corresponding to the ISO calendar date "
"specified by year, week and day. The non-date components of the datetime "
"are populated with their normal default values. This is the inverse of "
"the function :meth:`datetime.isocalendar`."
msgstr ""
"년, 주 및 일로 지정된 ISO 달력 날짜에 해당하는 :class:`.datetime`\\을 반환합니다. datetime의 날짜가 "
"아닌 구성 요소는 일반적인 기본값으로 채워집니다. 이것은 함수 :meth:`datetime.isocalendar`\\의 역입니다."

#: ../../library/datetime.rst:1094
msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed "
"according to *format*."
msgstr "*format*\\에 따라 구문 분석된, *date_string*\\에 해당하는 :class:`.datetime`\\를 반환합니다."

#: ../../library/datetime.rst:1097
msgid ""
"If *format* does not contain microseconds or time zone information, this "
"is equivalent to::"
msgstr ""

#: ../../library/datetime.rst:1099 ../../library/datetime.rst:2580
#, fuzzy
msgid "datetime(*(time.strptime(date_string, format)[0:6]))"
msgstr "``strptime(date_string, format)``"

#: ../../library/datetime.rst:1101
#, fuzzy
msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed"
" by :func:`time.strptime` or if it returns a value which isn't a time "
"tuple.  See also :ref:`strftime-strptime-behavior` and "
":meth:`datetime.fromisoformat`."
msgstr ""
"date_string과 format을 :func:`time.strptime`\\로 구문 분석할 수 없거나, 시간 튜플이 아닌 값을 "
"반환하면 :exc:`ValueError`\\가 발생합니다. 포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-"
"behavior`\\을 참조하십시오."

#: ../../library/datetime.rst:1108
msgid ""
"If *format* specifies a day of month without a year a "
":exc:`DeprecationWarning` is now emitted.  This is to avoid a quadrennial"
" leap year bug in code seeking to parse only a month and day as the "
"default year used in absence of one in the format is not a leap year. "
"Such *format* values may raise an error as of Python 3.15.  The "
"workaround is to always include a year in your *format*.  If parsing "
"*date_string* values that do not have a year, explicitly add a year that "
"is a leap year before parsing:"
msgstr ""

#: ../../library/datetime.rst:1117
#, python-brace-format, python-format
msgid ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # "
"Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"
msgstr ""

#: ../../library/datetime.rst:1130
msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr "표현 가능한 가장 이른 :class:`.datetime`, ``datetime(MINYEAR, 1, 1, tzinfo=None)``."

#: ../../library/datetime.rst:1136
msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, "
"23, 59, 59, 999999, tzinfo=None)``."
msgstr ""
"표현 가능한 가장 늦은 :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23, 59, 59, "
"999999, tzinfo=None)``."

#: ../../library/datetime.rst:1142
msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"같지 않은 :class:`.datetime` 객체 간의 가능한 가장 작은 차이, "
"``timedelta(microseconds=1)``."

#: ../../library/datetime.rst:1165 ../../library/datetime.rst:1788
msgid "In ``range(24)``."
msgstr "범위 ``range(24)``."

#: ../../library/datetime.rst:1170 ../../library/datetime.rst:1175
#: ../../library/datetime.rst:1793 ../../library/datetime.rst:1798
msgid "In ``range(60)``."
msgstr "범위 ``range(60)``."

#: ../../library/datetime.rst:1180 ../../library/datetime.rst:1803
msgid "In ``range(1000000)``."
msgstr "범위 ``range(1000000)``."

#: ../../library/datetime.rst:1185
msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr ":class:`.datetime` 생성자에 *tzinfo* 인자로 전달된 객체이거나, 전달되지 않았으면 ``None``\\입니다."

#: ../../library/datetime.rst:1191 ../../library/datetime.rst:1814
#, fuzzy
msgid ""
"In ``[0, 1]``. Used to disambiguate wall times during a repeated "
"interval. (A repeated interval occurs when clocks are rolled back at the "
"end of daylight saving time or when the UTC offset for the current zone "
"is decreased for political reasons.) The values 0 and 1 represent, "
"respectively, the earlier and later of the two moments with the same wall"
" time representation."
msgstr ""
"``[0, 1]`` 범위입니다. 반복되는 구간 동안 벽 시간(wall time)의 모호함을 제거하는 데 사용됩니다. 반복되는 구간은"
" 일광 절약 시간이 끝날 때나 현재 지역의 UTC 오프셋이 정치적인 이유로 줄어들어 시계를 되돌릴 때 발생합니다. 값 0(1)은 "
"같은 벽 시간을 나타내는 두 순간 중 이전(이후)을 나타냅니다."

#: ../../library/datetime.rst:1204
msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

#: ../../library/datetime.rst:1204 ../../library/datetime.rst:2427
#: ../../library/datetime.rst:2432 ../../library/datetime.rst:2444
#: ../../library/datetime.rst:2449 ../../library/datetime.rst:2509
#: ../../library/datetime.rst:2514 ../../library/datetime.rst:2518
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/datetime.rst:1206
msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

#: ../../library/datetime.rst:1206 ../../library/datetime.rst:2460
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/datetime.rst:1208
msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``datetime1 == datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``datetime1 != datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst
msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``datetime1 > datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``datetime1 <= datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst
#, fuzzy
msgid "``datetime1 >= datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst:1220
#, fuzzy
msgid ""
"``datetime2`` is a duration of ``timedelta`` removed from ``datetime1``, "
"moving forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. The result has the same :attr:`~.datetime.tzinfo`"
" attribute as the input datetime, and ``datetime2 - datetime1 == "
"timedelta`` after. :exc:`OverflowError` is raised if ``datetime2.year`` "
"would be smaller than :const:`MINYEAR` or larger than :const:`MAXYEAR`. "
"Note that no time zone adjustments are done even if the input is an aware"
" object."
msgstr ""
"datetime2는 datetime1에서 timedelta 기간만큼 이동한 시간이며, ``timedelta.days`` > 0이면 "
"미래로, ``timedelta.days`` < 0이면 과거로 이동합니다. 결과는 입력 datetime과 같은 "
":attr:`~.datetime.tzinfo` 어트리뷰트를 가지고, 이후에 datetime2 - datetime1 == "
"timedelta 입니다. datetime2.year가 :const:`MINYEAR`\\보다 작거나 "
":const:`MAXYEAR`\\보다 커지려고 하면 :exc:`OverflowError`\\가 발생합니다. 입력이 어웨어 객체일 "
"때도 시간대 조정이 수행되지 않음에 유의하십시오."

#: ../../library/datetime.rst:1229
#, fuzzy
msgid ""
"Computes the ``datetime2`` such that ``datetime2 + timedelta == "
"datetime1``. As for addition, the result has the same "
":attr:`~.datetime.tzinfo` attribute as the input datetime, and no time "
"zone adjustments are done even if the input is aware."
msgstr ""
"datetime2 + timedelta == datetime1 을 만족하는 datetime2를 계산합니다. 덧셈과 마찬가지로, "
"결과는 입력 datetime과 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지며 입력이 어웨어일 때도 시간대 "
"조정이 수행되지 않습니다."

#: ../../library/datetime.rst:1234
msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware. If one is aware "
"and the other is naive, :exc:`TypeError` is raised."
msgstr ""
":class:`.datetime`\\에서 :class:`.datetime`\\을 빼는 것은 두 피연산자 모두 나이브하거나, 모두 "
"어웨어할 때만 정의됩니다. 하나가 어웨어이고 다른 하나가 나이브면, :exc:`TypeError`\\가 발생합니다."

#: ../../library/datetime.rst:1238
#, fuzzy
msgid ""
"If both are naive, or both are aware and have the same "
":attr:`~.datetime.tzinfo` attribute, the :attr:`~.datetime.tzinfo` "
"attributes are ignored, and the result is a :class:`timedelta` object "
"``t`` such that ``datetime2 + t == datetime1``. No time zone adjustments "
"are done in this case."
msgstr ""
"둘 다 나이브하거나 둘 다 어웨어하고 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, "
":attr:`~.datetime.tzinfo` 어트리뷰트는 무시되고 결과는 ``datetime2 + t == datetime1`` "
"이 되도록 하는 :class:`timedelta` 객체 *t*\\입니다. 이때 시간대 조정이 수행되지 않습니다."

#: ../../library/datetime.rst:1243
#, fuzzy
msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` "
"attributes, ``a-b`` acts as if ``a`` and ``b`` were first converted to "
"naive UTC datetimes. The result is ``(a.replace(tzinfo=None) - "
"a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())`` except that "
"the implementation never overflows."
msgstr ""
"둘 다 어웨어하고 :attr:`~.datetime.tzinfo` 어트리뷰트가 다르면, ``a-b``\\는 *a*\\와 *b*\\가 "
"먼저 나이브 UTC datetime으로 먼저 변환된 것처럼 작동합니다. 구현이 절대 오버플로 하지 않는다는 것을 제외하면 결과는 "
"``(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - "
"b.utcoffset())``\\입니다."

#: ../../library/datetime.rst:1249
msgid ""
":class:`.datetime` objects are equal if they represent the same date and "
"time, taking into account the time zone."
msgstr ""

#: ../../library/datetime.rst:1252
msgid "Naive and aware :class:`!datetime` objects are never equal."
msgstr ""

#: ../../library/datetime.rst:1254
#, fuzzy
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are"
" ignored and the base datetimes are compared. If both comparands are "
"aware and have different :attr:`~.datetime.tzinfo` attributes, the "
"comparison acts as comparands were first converted to UTC datetimes "
"except that the implementation never overflows. :class:`!datetime` "
"instances in a repeated interval are never equal to :class:`!datetime` "
"instances in other time zone."
msgstr ""
"비교 피연산자가 모두 어웨어하고, 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 공통 "
":attr:`~.datetime.tzinfo` 어트리뷰트가 무시되고 기본 datetime이 비교됩니다. 두 비교 피연산자가 모두 "
"어웨어하고 다른 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 비교 피연산자들은 먼저 그들의 UTC 오프셋 "
"(``self.utcoffset()`` 에서 얻습니다)을 뺀 값으로 조정됩니다."

#: ../../library/datetime.rst:1264
#, fuzzy
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes"
" *datetime2* in time, taking into account the time zone."
msgstr ""
"*datetime1*\\이 *datetime2*\\에 앞서면 *datetime1*\\은 *datetime2*\\보다 작은 것으로 "
"간주합니다."

#: ../../library/datetime.rst:1267
#, fuzzy
msgid ""
"Order comparison between naive and aware :class:`.datetime` objects "
"raises :exc:`TypeError`."
msgstr "어웨어와 나이브 :class:`.datetime` 인스턴스 간의 동등 비교는 :exc:`TypeError`\\를 발생시키지 않습니다."

#: ../../library/datetime.rst:1270
#, fuzzy
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are"
" ignored and the base datetimes are compared. If both comparands are "
"aware and have different :attr:`~.datetime.tzinfo` attributes, the "
"comparison acts as comparands were first converted to UTC datetimes "
"except that the implementation never overflows."
msgstr ""
"비교 피연산자가 모두 어웨어하고, 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 공통 "
":attr:`~.datetime.tzinfo` 어트리뷰트가 무시되고 기본 datetime이 비교됩니다. 두 비교 피연산자가 모두 "
"어웨어하고 다른 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 비교 피연산자들은 먼저 그들의 UTC 오프셋 "
"(``self.utcoffset()`` 에서 얻습니다)을 뺀 값으로 조정됩니다."

#: ../../library/datetime.rst:1277
msgid ""
"Equality comparisons between aware and naive :class:`.datetime` instances"
" don't raise :exc:`TypeError`."
msgstr "어웨어와 나이브 :class:`.datetime` 인스턴스 간의 동등 비교는 :exc:`TypeError`\\를 발생시키지 않습니다."

#: ../../library/datetime.rst:1293
msgid "Return :class:`date` object with same year, month and day."
msgstr "같은 year, month, day의 :class:`date` 객체를 반환합니다."

#: ../../library/datetime.rst:1298
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond "
"and fold. :attr:`.tzinfo` is ``None``. See also method :meth:`timetz`."
msgstr ""
"같은 hour, minute, second, microsecond 및 fold의 :class:`.time` 객체를 반환합니다. "
":attr:`.tzinfo`\\는 ``None``\\입니다. 메서드 :meth:`timetz`\\도 참조하십시오."

#: ../../library/datetime.rst:1301 ../../library/datetime.rst:1310
msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "fold 값은 반환된 :class:`.time` 객체에 복사됩니다."

#: ../../library/datetime.rst:1307
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond,"
" fold, and tzinfo attributes. See also method :meth:`time`."
msgstr ""
"같은 hour, minute, second, microsecond, fold 및 tzinfo 어트리뷰트의 :class:`.time`"
" 객체를 반환합니다. 메서드 :meth:`time`\\도 참조하십시오."

#: ../../library/datetime.rst:1318
#, fuzzy
msgid ""
"Return a new :class:`datetime` object with the same attributes, but with "
"specified parameters updated. Note that ``tzinfo=None`` can be specified "
"to create a naive datetime from an aware datetime with no conversion of "
"date and time data."
msgstr ""
"키워드 인자로 새로운 값이 주어진 어트리뷰트를 제외하고, 같은 어트리뷰트를 가진 datetime을 반환합니다. "
"``tzinfo=None``\\을 지정하면 날짜와 시간 데이터의 변환 없이 어웨어 datetime에서 나이브 datetime을 만들"
" 수 있습니다."

#: ../../library/datetime.rst:1323
msgid ""
":class:`.datetime` objects are also supported by generic function "
":func:`copy.replace`."
msgstr ""

#: ../../library/datetime.rst:1332
msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute "
"*tz*, adjusting the date and time data so the result is the same UTC time"
" as *self*, but in *tz*'s local time."
msgstr ""
"새로운 :attr:`.tzinfo` 어트리뷰트 *tz*\\를 갖는 :class:`.datetime` 객체를 반환하는데, 결과가 "
"*self*\\와 같은 UTC 시간이지만 *tz*\\의 지역 시간이 되도록 날짜와 시간 데이터를 조정합니다."

#: ../../library/datetime.rst:1336
#, fuzzy
msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and "
"its :meth:`utcoffset` and :meth:`dst` methods must not return ``None``. "
"If *self* is naive, it is presumed to represent time in the system time "
"zone."
msgstr ""
"제공된다면 *tz*\\는 :class:`tzinfo` 서브 클래스의 인스턴스여야 하며, :meth:`utcoffset`\\과 "
":meth:`dst` 메서드는 ``None``\\을 반환하지 않아야 합니다. *self*\\가 나이브하면, 시스템 시간대의 시간을 "
"나타내는 것으로 가정합니다."

#: ../../library/datetime.rst:1340
#, fuzzy
msgid ""
"If called without arguments (or with ``tz=None``) the system local time "
"zone is assumed for the target time zone. The ``.tzinfo`` attribute of "
"the converted datetime instance will be set to an instance of "
":class:`timezone` with the zone name and offset obtained from the OS."
msgstr ""
"인자 없이 (또는 ``tz=None``\\으로) 호출되면 대상 시간대는 시스템 시간대로 간주합니다. 변환된 datetime "
"인스턴스의 ``.tzinfo`` 어트리뷰트는 OS에서 얻은 시간대 이름과 오프셋을 사용하는 :class:`timezone`\\의 "
"인스턴스로 설정됩니다."

#: ../../library/datetime.rst:1345
#, fuzzy
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  "
"no adjustment of date or time data is performed. Else the result is local"
" time in the time zone *tz*, representing the same UTC time as *self*:  "
"after ``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have"
" the same date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"``self.tzinfo``\\가 *tz*\\면, ``self.astimezone(tz)``\\는 *self*\\와 같습니다: "
"날짜나 시간 데이터 조정이 수행되지 않습니다. 그렇지 않으면 결과는 *self*\\와 같은 UTC 시간을 나타내는 *tz* 시간대의"
" 지역 시간입니다: ``astz = dt.astimezone(tz)`` 후에, ``astz - "
"astz.utcoffset()``\\는 ``dt - dt.utcoffset()``\\과 같은 날짜와 시간 데이터를 갖습니다."

#: ../../library/datetime.rst:1351
#, fuzzy
msgid ""
"If you merely want to attach a :class:`timezone` object *tz* to a "
"datetime *dt* without adjustment of date and time data, use "
"``dt.replace(tzinfo=tz)``. If you merely want to remove the "
":class:`!timezone` object from an aware datetime *dt* without conversion "
"of date and time data, use ``dt.replace(tzinfo=None)``."
msgstr ""
"날짜와 시간 데이터를 조정하지 않고 시간대 객체 *tz*\\를 datetime *dt*\\에 연결하기만 하려면, "
"``dt.replace(tzinfo=tz)``\\를 사용하십시오. 날짜와 시간 데이터를 변환하지 않고 어웨어 datetime "
"*dt*\\에서 시간대 객체를 제거하려면, ``dt.replace(tzinfo=None)``\\를 사용하십시오."

#: ../../library/datetime.rst:1356
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in "
"a :class:`tzinfo` subclass to affect the result returned by "
":meth:`astimezone`. Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"기본 :meth:`tzinfo.fromutc` 메서드는 :meth:`astimezone`\\에 의해 반환된 결과에 영향을 주도록 "
":class:`tzinfo` 서브 클래스에서 재정의할 수 있습니다. 에러가 발생하는 경우를 무시하고, "
":meth:`astimezone`\\는 다음과 같이 작동합니다::"

#: ../../library/datetime.rst:1360
msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""

#: ../../library/datetime.rst:1368
msgid "*tz* now can be omitted."
msgstr "이제 *tz*\\를 생략할 수 있습니다."

#: ../../library/datetime.rst:1371
msgid ""
"The :meth:`astimezone` method can now be called on naive instances that "
"are presumed to represent system local time."
msgstr ""
"이제 :meth:`astimezone` 메서드는 이제 나이브 인스턴스에서 호출될 수 있는데, 시스템 지역 시간을 나타내는 것으로 "
"간주합니다."

#: ../../library/datetime.rst:1378
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.utcoffset(self)``, and raises an exception if the latter "
"doesn't return ``None`` or a :class:`timedelta` object with magnitude "
"less than one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.utcoffset(self)``\\를 반환하고, 후자가 ``None``\\이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../../library/datetime.rst:1382 ../../library/datetime.rst:1977
#: ../../library/datetime.rst:2084 ../../library/datetime.rst:2329
#: ../../library/datetime.rst:2341 ../../library/datetime.rst:2653
msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "UTC 오프셋은 분 단위로 제한되지 않습니다."

#: ../../library/datetime.rst:1388
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.dst(self)``, and raises an exception if the latter doesn't "
"return ``None`` or a :class:`timedelta` object with magnitude less than "
"one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.dst(self)``\\를 반환하고, 후자가 ``None``\\이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../../library/datetime.rst:1392 ../../library/datetime.rst:1987
#: ../../library/datetime.rst:2138
msgid "The DST offset is not restricted to a whole number of minutes."
msgstr "DST 오프셋은 분 단위로 제한되지 않습니다."

#: ../../library/datetime.rst:1398
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.tzname(self)``, raises an exception if the latter doesn't "
"return ``None`` or a string object,"
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.tzname(self)``\\를 반환하고, 후자가 ``None``\\이나 문자열 객체를 반환하지 않으면 "
"예외를 발생시킵니다."

#: ../../library/datetime.rst:1409
msgid ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"
msgstr ""

#: ../../library/datetime.rst:1413
#, fuzzy
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is "
"the day number within the current year starting with 1 for January 1st. "
"The :attr:`~time.struct_time.tm_isdst` flag of the result is set "
"according to the :meth:`dst` method: :attr:`.tzinfo` is ``None`` or "
":meth:`dst` returns ``None``, :attr:`!tm_isdst` is set to ``-1``; else if"
" :meth:`dst` returns a non-zero value, :attr:`!tm_isdst` is set to 1; "
"else :attr:`!tm_isdst` is set to 0."
msgstr ""
"여기서 ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` 은 1월 "
"1일에 ``1``\\로 시작하는 현재 연도의 날짜 번호입니다. 결과의 :attr:`tm_isdst` 플래그는 :meth:`dst` "
"메서드에 따라 설정됩니다: :attr:`.tzinfo`\\가 ``None``\\이거나 :meth:`dst`\\가 "
"``None``\\을 반환하면, :attr:`tm_isdst`\\는 ``-1``\\로 설정됩니다; 그렇지 않고 "
":meth:`dst`\\가 0이 아닌 값을 반환하면, :attr:`tm_isdst`\\는 ``1``\\로 설정됩니다; 그렇지 않으면"
" :attr:`tm_isdst`\\는 ``0``\\으로 설정됩니다."

#: ../../library/datetime.rst:1424
#, fuzzy
msgid ""
"If :class:`.datetime` instance ``d`` is naive, this is the same as "
"``d.timetuple()`` except that :attr:`~.time.struct_time.tm_isdst` is "
"forced to 0 regardless of what ``d.dst()`` returns. DST is never in "
"effect for a UTC time."
msgstr ""
":class:`.datetime` 인스턴스 *d*\\가 나이브하면, 이것은 ``d.dst()``\\가 무엇을 반환하는지와 관계없이 "
":attr:`tm_isdst`\\가 강제로 0이 된다는 점만 제외하면, ``d.timetuple()``\\과 같습니다. DST는 "
"UTC 시간에는 적용되지 않습니다."

#: ../../library/datetime.rst:1428
#, fuzzy
msgid ""
"If ``d`` is aware, ``d`` is normalized to UTC time, by subtracting "
"``d.utcoffset()``, and a :class:`time.struct_time` for the normalized "
"time is returned. :attr:`!tm_isdst` is forced to 0. Note that an "
":exc:`OverflowError` may be raised if ``d.year`` was ``MINYEAR`` or "
"``MAXYEAR`` and UTC adjustment spills over a year boundary."
msgstr ""
"*d*\\가 어웨어하면, *d*\\는 ``d.utcoffset()``\\을 빼서 UTC 시간으로 정규화되고, 정규화된 시간의 "
":class:`time.struct_time`\\이 반환됩니다. :attr:`tm_isdst`\\는 강제로 0이 됩니다. "
"*d*.year가 ``MINYEAR``\\나 ``MAXYEAR``\\고 UTC 조정이 연도 경계를 넘어가면 "
":exc:`OverflowError`\\가 발생할 수 있습니다."

#: ../../library/datetime.rst:1437
#, fuzzy
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` "
"methods as local times, it is preferred to use aware datetimes to "
"represent times in UTC; as a result, using :meth:`datetime.utctimetuple` "
"may give misleading results. If you have a naive ``datetime`` "
"representing UTC, use ``datetime.replace(tzinfo=timezone.utc)`` to make "
"it aware, at which point you can use :meth:`.datetime.timetuple`."
msgstr ""
"나이브 ``datetime`` 객체는 많은 ``datetime`` 메서드에 의해 지역 시간으로 취급되므로, UTC로 시간을 나타내는"
" 어웨어 datetime을 사용하는 것이 좋습니다; 결과적으로, ``utcfromtimetuple``\\를 사용하면 잘못된 결과를 "
"초래할 수 있습니다. UTC를 나타내는 나이브 ``datetime``\\이 있으면, "
"``datetime.replace(tzinfo=timezone.utc)``\\를 사용하여 어웨어로 만드십시오, 이제 "
":meth:`.datetime.timetuple`\\을 사용할 수 있습니다."

#: ../../library/datetime.rst:1446
msgid ""
"Return the proleptic Gregorian ordinal of the date. The same as "
"``self.date().toordinal()``."
msgstr "날짜의 역산 그레고리력 서수를 반환합니다. ``self.date().toordinal()``\\과 같습니다."

#: ../../library/datetime.rst:1451
msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance. "
"The return value is a :class:`float` similar to that returned by "
":func:`time.time`."
msgstr ""
":class:`.datetime` 인스턴스에 해당하는 POSIX 타임스탬프를 반환합니다. 반환 값은 "
":func:`time.time`\\이 반환하는 것과 비슷한 :class:`float`\\입니다."

#: ../../library/datetime.rst:1455
#, fuzzy
msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time "
"and this method relies on the platform C :c:func:`mktime` function to "
"perform the conversion. Since :class:`.datetime` supports wider range of "
"values than :c:func:`mktime` on many platforms, this method may raise "
":exc:`OverflowError` or :exc:`OSError` for times far in the past or far "
"in the future."
msgstr ""
"나이브 :class:`.datetime` 인스턴스는 지역 시간을 나타내는 것으로 간주하며 이 메서드는 변환을 수행하기 위해 플랫폼 "
"C :c:func:`mktime` 함수에 의존합니다. :class:`.datetime`\\는 많은 플랫폼에서 "
":c:func:`mktime`\\보다 더 넓은 범위의 값을 지원하기 때문에, 이 메서드는 먼 과거나 먼 미래의 시간에 대해 "
":exc:`OverflowError`\\를 발생시킬 수 있습니다."

#: ../../library/datetime.rst:1462
msgid "For aware :class:`.datetime` instances, the return value is computed as::"
msgstr "어웨어 :class:`.datetime` 인스턴스의 경우, 반환 값은 다음과 같이 계산됩니다::"

#: ../../library/datetime.rst:1465
msgid "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"
msgstr ""

#: ../../library/datetime.rst:1469
msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ":meth:`timestamp` 메서드는 :attr:`.fold` 어트리뷰트를 사용하여 반복되는 구간의 시간을 구분합니다."

#: ../../library/datetime.rst:1475
#, fuzzy
msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive "
":class:`.datetime` instance representing UTC time. If your application "
"uses this convention and your system time zone is not set to UTC, you can"
" obtain the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"UTC 시간을 나타내는 나이브 :class:`.datetime` 인스턴스에서 직접 POSIX 타임스탬프를 얻는 메서드는 없습니다. "
"응용 프로그램에서 이 관례를 사용하고 시스템 시간대가 UTC로 설정되어 있지 않으면, "
"``tzinfo=timezone.utc``\\를 제공하여 POSIX 타임스탬프를 얻을 수 있습니다::"

#: ../../library/datetime.rst:1481
msgid "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"
msgstr ""

#: ../../library/datetime.rst:1483
msgid "or by calculating the timestamp directly::"
msgstr "또는 직접 타임스탬프를 계산할 수 있습니다::"

#: ../../library/datetime.rst:1485
msgid "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"
msgstr ""

#: ../../library/datetime.rst:1489
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is"
" 6. The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 0이고 일요일은 6입니다. ``self.date().weekday()``\\와 같습니다. "
":meth:`isoweekday`\\도 참조하십시오."

#: ../../library/datetime.rst:1495
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is"
" 7. The same as ``self.date().isoweekday()``. See also :meth:`weekday`, "
":meth:`isocalendar`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 1이고 일요일은 7입니다. ``self.date().isoweekday()`` 와 같습니다. "
":meth:`weekday`, :meth:`isocalendar`\\도 참조하십시오."

#: ../../library/datetime.rst:1502
msgid ""
"Return a :term:`named tuple` with three components: ``year``, ``week`` "
"and ``weekday``. The same as ``self.date().isocalendar()``."
msgstr ""
"세 개의 컴포넌트를 가진 :term:`네임드 튜플 <named tuple>`\\을 반환합니다: ``year``, ``week`` 및"
" ``weekday``. ``self.date().isocalendar()``\\와 같습니다."

#: ../../library/datetime.rst:1508
msgid "Return a string representing the date and time in ISO 8601 format:"
msgstr "ISO 8601 형식으로 날짜와 시간을 나타내는 문자열을 반환합니다:"

#: ../../library/datetime.rst:1510
msgid "``YYYY-MM-DDTHH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``YYYY-MM-DDTHH:MM:SS.ffffff``, :attr:`microsecond`\\가 0이 아니면"

#: ../../library/datetime.rst:1511
msgid "``YYYY-MM-DDTHH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``YYYY-MM-DDTHH:MM:SS``, :attr:`microsecond`\\가 0이면"

#: ../../library/datetime.rst:1513
msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, "
"giving the UTC offset:"
msgstr ":meth:`utcoffset`\\이 ``None``\\을 반환하지 않으면, UTC 오프셋을 제공하는 문자열을 덧붙입니다:"

#: ../../library/datetime.rst:1516
msgid ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if "
":attr:`microsecond` is not 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, "
":attr:`microsecond`\\가 0이 아니면"

#: ../../library/datetime.rst:1518
msgid "``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  if :attr:`microsecond` is 0"
msgstr "``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``, :attr:`microsecond`\\가 0이면"

#: ../../library/datetime.rst:1522
msgid ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"
msgstr ""

#: ../../library/datetime.rst:1528
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character "
"separator, placed between the date and time portions of the result. For "
"example::"
msgstr "선택적 인자 *sep*\\(기본값 ``'T'``)은 한 문자 구분자로, 결과의 날짜와 시간 부분 사이에 배치됩니다. 예를 들어::"

#: ../../library/datetime.rst:1531
msgid ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 "
"offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"
msgstr ""

#: ../../library/datetime.rst:1542 ../../library/datetime.rst:1917
msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be "
"one of the following:"
msgstr ""
"선택적 인자 *timespec*\\은 포함할 시간의 추가 구성 요소 수를 지정합니다 (기본값은 ``'auto'``\\입니다). 다음"
" 중 하나일 수 있습니다:"

#: ../../library/datetime.rst:1546 ../../library/datetime.rst:1921
msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'``: :attr:`microsecond`\\가 0이면 ``'seconds'``\\와 같고, 그렇지 않으면 "
"``'microseconds'``\\와 같습니다."

#: ../../library/datetime.rst:1548 ../../library/datetime.rst:1923
msgid "``'hours'``: Include the :attr:`hour` in the two-digit ``HH`` format."
msgstr "``'hours'``: :attr:`hour`\\를 두 자리 숫자 ``HH`` 형식으로 포함합니다."

#: ../../library/datetime.rst:1549 ../../library/datetime.rst:1924
msgid ""
"``'minutes'``: Include :attr:`hour` and :attr:`minute` in ``HH:MM`` "
"format."
msgstr "``'minutes'``: :attr:`hour`\\와 :attr:`minute`\\를 ``HH:MM`` 형식으로 포함합니다."

#: ../../library/datetime.rst:1550 ../../library/datetime.rst:1925
msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` "
"in ``HH:MM:SS`` format."
msgstr ""
"``'seconds'``: :attr:`hour`, :attr:`minute` 및 :attr:`second`\\를 "
"``HH:MM:SS`` 형식으로 포함합니다."

#: ../../library/datetime.rst:1552 ../../library/datetime.rst:1927
msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second "
"part to milliseconds. ``HH:MM:SS.sss`` format."
msgstr ""
"``'milliseconds'``: 전체 시간을 포함하지만, 초 미만은 밀리초 단위로 자릅니다. ``HH:MM:SS.sss`` "
"형식입니다."

#: ../../library/datetime.rst:1554 ../../library/datetime.rst:1929
msgid "``'microseconds'``: Include full time in ``HH:MM:SS.ffffff`` format."
msgstr "``'microseconds'``: 전체 시간을 ``HH:MM:SS.ffffff`` 형식으로 포함합니다."

#: ../../library/datetime.rst:1558 ../../library/datetime.rst:1933
msgid "Excluded time components are truncated, not rounded."
msgstr "제외된 시간 구성 요소는 반올림되지 않고 잘립니다."

#: ../../library/datetime.rst:1560
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument::"
msgstr "잘못된 *timespec* 인자는 :exc:`ValueError`\\를 발생시킵니다::"

#: ../../library/datetime.rst:1563
msgid ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"
msgstr ""

#: ../../library/datetime.rst:1570 ../../library/datetime.rst:1948
#, fuzzy
msgid "Added the *timespec* parameter."
msgstr "*timespec* 인자가 추가되었습니다."

#: ../../library/datetime.rst:1576
#, fuzzy
msgid ""
"For a :class:`.datetime` instance ``d``, ``str(d)`` is equivalent to "
"``d.isoformat(' ')``."
msgstr ""
":class:`.datetime` 인스턴스 *d*\\에 대해, ``str(d)``\\는 ``d.isoformat(' ')``\\과 "
"동등합니다."

#: ../../library/datetime.rst:1582
msgid "Return a string representing the date and time::"
msgstr "날짜와 시간을 나타내는 문자열을 반환합니다::"

#: ../../library/datetime.rst:1584
msgid ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"
msgstr ""

#: ../../library/datetime.rst:1588
msgid ""
"The output string will *not* include time zone information, regardless of"
" whether the input is aware or naive."
msgstr "출력 문자열은 입력이 어웨어인지 나이브인지와 관계없이 시간대 정보를 포함하지 *않습니다*."

#: ../../library/datetime.rst:1595
msgid ""
"on platforms where the native C :c:func:`ctime` function (which "
":func:`time.ctime` invokes, but which :meth:`datetime.ctime` does not "
"invoke) conforms to the C standard."
msgstr ""
"네이티브 C :c:func:`ctime` 함수(:func:`time.ctime`\\이 호출하지만, "
":meth:`datetime.ctime`\\은 호출하지 않습니다)가 C 표준을 준수하는 플랫폼에서 동등합니다."

#: ../../library/datetime.rst:1602
#, fuzzy
msgid ""
"Return a string representing the date and time, controlled by an explicit"
" format string. See also :ref:`strftime-strptime-behavior` and "
":meth:`datetime.isoformat`."
msgstr ""
"명시적인 포맷 문자열에 의해 제어되는 날짜와 시간을 나타내는 문자열을 반환합니다. 포매팅 지시자의 전체 목록은 :ref"
":`strftime-strptime-behavior`\\을 참조하십시오."

#: ../../library/datetime.rst:1609
#, fuzzy
msgid ""
"Same as :meth:`.datetime.strftime`. This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref"
":`strftime-strptime-behavior` and :meth:`datetime.isoformat`."
msgstr ""
":meth:`.datetime.strftime`\\과 같습니다. 이것이 :ref:`포맷 문자열 리터럴 <f-strings>`\\과 "
":meth:`str.format`\\을 사용할 때 :class:`.datetime` 객체를 위한 포맷 문자열을 지정할 수 있도록 "
"합니다. 포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-behavior`\\을 참조하십시오."

#: ../../library/datetime.rst:1616
msgid "Examples of Usage: :class:`.datetime`"
msgstr "사용 예: :class:`.datetime`"

#: ../../library/datetime.rst:1618
#, fuzzy
msgid "Examples of working with :class:`.datetime` objects:"
msgstr ":class:`.time` 객체로 작업하는 예제:"

#: ../../library/datetime.rst:1620
#, python-brace-format, python-format
msgid ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, "
"tzinfo=datetime.timezone.utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is "
"{0:%I:%M%p}.'.format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"
msgstr ""

#: ../../library/datetime.rst:1671
msgid ""
"The example below defines a :class:`tzinfo` subclass capturing time zone "
"information for Kabul, Afghanistan, which used +4 UTC until 1945 and then"
" +4:30 UTC thereafter::"
msgstr ""
"아래 예제는 1945년까지 +4 UTC를 사용한 후 +4:30 UTC로 변경한 아프가니스탄 카불의 시간대 정보를 캡처하는 "
":class:`tzinfo` 서브 클래스를 정의합니다::"

#: ../../library/datetime.rst:1675
msgid ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""
msgstr ""

#: ../../library/datetime.rst:1718
msgid "Usage of ``KabulTz`` from above::"
msgstr "위의 ``KabulTz`` 사용법::"

#: ../../library/datetime.rst:1720
msgid ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"
msgstr ""

#: ../../library/datetime.rst:1744
msgid ":class:`.time` Objects"
msgstr ":class:`.time` 객체"

#: ../../library/datetime.rst:1746
#, fuzzy
msgid ""
"A :class:`.time` object represents a (local) time of day, independent of "
"any particular day, and subject to adjustment via a :class:`tzinfo` "
"object."
msgstr ""
":class:`time` 객체는 특정 날짜와 관계없는 (지역) 시간을 나타내며, :class:`tzinfo` 객체를 통해 조정할 수"
" 있습니다."

#: ../../library/datetime.rst:1751
msgid ""
"All arguments are optional. *tzinfo* may be ``None``, or an instance of a"
" :class:`tzinfo` subclass. The remaining arguments must be integers in "
"the following ranges:"
msgstr ""
"모든 인자는 선택적입니다. *tzinfo*\\는 ``None``, 또는 :class:`tzinfo` 서브 클래스의 인스턴스일 수 "
"있습니다. 나머지 인자는 다음 범위의 정수이어야 합니다:"

#: ../../library/datetime.rst:1761
#, fuzzy
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is "
"raised. All default to 0 except *tzinfo*, which defaults to ``None``."
msgstr ""
"이 범위를 벗어나는 인자가 주어지면, :exc:`ValueError`\\가 발생합니다. *tzinfo*\\의 기본값은 "
":const:`None`\\이고, 그 외의 모든 기본값은 ``0``\\입니다."

#: ../../library/datetime.rst:1769
msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr "표현 가능한 가장 이른 :class:`.time`, ``time(0, 0, 0, 0)``."

#: ../../library/datetime.rst:1774
msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr "표현 가능한 가장 늦은 :class:`.time`, ``time(23, 59, 59, 999999)``."

#: ../../library/datetime.rst:1779
msgid ""
"The smallest possible difference between non-equal :class:`.time` "
"objects, ``timedelta(microseconds=1)``, although note that arithmetic on "
":class:`.time` objects is not supported."
msgstr ""
"같지 않은 :class:`.time` 객체 간의 가능한 가장 작은 차이, ``timedelta(microseconds=1)``, "
"하지만 :class:`.time` 객체에 대한 산술은 지원되지 않습니다."

#: ../../library/datetime.rst:1808
msgid ""
"The object passed as the tzinfo argument to the :class:`.time` "
"constructor, or ``None`` if none was passed."
msgstr ":class:`.time` 생성자에 *tzinfo* 인자로 전달된 객체이거나, 전달되지 않았으면 ``None``\\입니다."

#: ../../library/datetime.rst:1822
msgid ""
":class:`.time` objects support equality and order comparisons, where "
"``a`` is considered less than ``b`` when ``a`` precedes ``b`` in time."
msgstr ""

#: ../../library/datetime.rst:1825
msgid ""
"Naive and aware :class:`!time` objects are never equal. Order comparison "
"between naive and aware :class:`!time` objects raises :exc:`TypeError`."
msgstr ""

#: ../../library/datetime.rst:1829
#, fuzzy
msgid ""
"If both comparands are aware, and have the same :attr:`~.time.tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`!fold` attributes are ignored "
"and the base times are compared. If both comparands are aware and have "
"different :attr:`!tzinfo` attributes, the comparands are first adjusted "
"by subtracting their UTC offsets (obtained from ``self.utcoffset()``)."
msgstr ""
"비교 피연산자가 모두 어웨어하고, 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 공통 "
":attr:`~.datetime.tzinfo` 어트리뷰트가 무시되고 기본 datetime이 비교됩니다. 두 비교 피연산자가 모두 "
"어웨어하고 다른 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 비교 피연산자들은 먼저 그들의 UTC 오프셋 "
"(``self.utcoffset()`` 에서 얻습니다)을 뺀 값으로 조정됩니다."

#: ../../library/datetime.rst:1835
#, fuzzy
msgid ""
"Equality comparisons between aware and naive :class:`.time` instances "
"don't raise :exc:`TypeError`."
msgstr "어웨어와 나이브 :class:`.datetime` 인스턴스 간의 동등 비교는 :exc:`TypeError`\\를 발생시키지 않습니다."

#: ../../library/datetime.rst:1839
msgid ""
"In Boolean contexts, a :class:`.time` object is always considered to be "
"true."
msgstr "불리언 문맥에서, :class:`.time` 객체는 항상 참으로 간주합니다."

#: ../../library/datetime.rst:1841
msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if "
"it represented midnight in UTC. This behavior was considered obscure and "
"error-prone and has been removed in Python 3.5. See :issue:`13936` for "
"full details."
msgstr ""
"파이썬 3.5 이전에, :class:`.time` 객체는 UTC 자정을 나타낼 때 거짓으로 간주했습니다. 이 동작은 애매하고 에러가"
" 발생하기 쉬운 것으로 간주하여 파이썬 3.5에서 제거되었습니다. 자세한 내용은 :issue:`13936`\\을 참조하십시오."

#: ../../library/datetime.rst:1848
msgid "Other constructor:"
msgstr "기타 생성자:"

#: ../../library/datetime.rst:1852
#, fuzzy
msgid ""
"Return a :class:`.time` corresponding to a *time_string* in any valid ISO"
" 8601 format, with the following exceptions:"
msgstr "*format*\\에 따라 구문 분석된, *date_string*\\에 해당하는 :class:`.datetime`\\를 반환합니다."

#: ../../library/datetime.rst:1856
msgid ""
"The leading ``T``, normally required in cases where there may be "
"ambiguity between a date and a time, is not required."
msgstr ""

#: ../../library/datetime.rst:1858
msgid ""
"Fractional seconds may have any number of digits (anything beyond 6 will "
"be truncated)."
msgstr ""

#: ../../library/datetime.rst:1862
#, fuzzy
msgid "Examples:"
msgstr "예제:"

#: ../../library/datetime.rst:1864
msgid ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, "
"tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"
msgstr ""

#: ../../library/datetime.rst:1886
msgid ""
"Previously, this method only supported formats that could be emitted by "
":meth:`time.isoformat`."
msgstr ""

#: ../../library/datetime.rst:1896
#, fuzzy
msgid ""
"Return a new :class:`.time` with the same values, but with specified "
"parameters updated. Note that ``tzinfo=None`` can be specified to create "
"a naive :class:`.time` from an aware :class:`.time`, without conversion "
"of the time data."
msgstr ""
"키워드 인자로 새로운 값이 주어진 어트리뷰트를 제외하고, 같은 값을 가진 :class:`.time`\\을 반환합니다. "
"``tzinfo=None``\\을 지정하면 시간 데이터의 변환 없이 어웨어 :class:`.time`\\에서 나이브 "
":class:`.time`\\을 만들 수 있습니다."

#: ../../library/datetime.rst:1901
msgid ""
":class:`.time` objects are also supported by generic function "
":func:`copy.replace`."
msgstr ""

#: ../../library/datetime.rst:1910
msgid "Return a string representing the time in ISO 8601 format, one of:"
msgstr "ISO 8601 형식으로 시간을 나타내는 문자열을 반환합니다, 다음 중 한가지입니다:"

#: ../../library/datetime.rst:1912
msgid "``HH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``HH:MM:SS.ffffff``, :attr:`microsecond`\\가 0이 아니면"

#: ../../library/datetime.rst:1913
msgid "``HH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``HH:MM:SS``, :attr:`microsecond`\\가 0이면"

#: ../../library/datetime.rst:1914
msgid ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :meth:`utcoffset` does not "
"return ``None``"
msgstr ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, :meth:`utcoffset`\\이 ``None``\\을"
" 반환하지 않으면"

#: ../../library/datetime.rst:1915
msgid ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` is 0 and "
":meth:`utcoffset` does not return ``None``"
msgstr ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, :attr:`microsecond`\\가 0이고 "
":meth:`utcoffset`\\이 ``None``\\을 반환하지 않으면"

#: ../../library/datetime.rst:1935
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr "잘못된 *timespec* 인자는 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/datetime.rst:1939
msgid ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, "
"microsecond=123456).isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"
msgstr ""

#: ../../library/datetime.rst:1954
#, fuzzy
msgid "For a time ``t``, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr "time *t*\\에 대해, ``str(t)``\\는 ``t.isoformat()``\\과 동등합니다."

#: ../../library/datetime.rst:1959
#, fuzzy
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  See also :ref:`strftime-strptime-behavior` and "
":meth:`time.isoformat`."
msgstr ""
"명시적인 포맷 문자열로 제어되는, 시간을 나타내는 문자열을 반환합니다. 포매팅 지시자의 전체 목록은, :ref:`strftime-"
"strptime-behavior`\\을 참조하십시오."

#: ../../library/datetime.rst:1965
#, fuzzy
msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a "
"format string for a :class:`.time` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref"
":`strftime-strptime-behavior` and :meth:`time.isoformat`."
msgstr ""
":meth:`.time.strftime`\\과 같습니다. 이것이 :ref:`포맷 문자열 리터럴 <f-strings>`\\과 "
":meth:`str.format`\\을 사용할 때 :class:`.time` 객체를 위한 포맷 문자열을 지정할 수 있도록 합니다. "
"포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-behavior`\\을 참조하십시오."

#: ../../library/datetime.rst:1973
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.utcoffset(None)``, and raises an exception if the latter "
"doesn't return ``None`` or a :class:`timedelta` object with magnitude "
"less than one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.utcoffset(None)``\\를 반환하고, 후자가 ``None``\\이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../../library/datetime.rst:1983
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.dst(None)``, and raises an exception if the latter doesn't "
"return ``None``, or a :class:`timedelta` object with magnitude less than "
"one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.dst(None)``\\를 반환하고, 후자가 ``None``\\이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../../library/datetime.rst:1992
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.tzname(None)``, or raises an exception if the latter "
"doesn't return ``None`` or a string object."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.tzname(None)``\\를 반환하고, 후자가 ``None``\\이나 문자열 객체를 반환하지 않으면 "
"예외를 발생시킵니다."

#: ../../library/datetime.rst:1997
msgid "Examples of Usage: :class:`.time`"
msgstr "사용 예: :class:`.time`"

#: ../../library/datetime.rst:1999
msgid "Examples of working with a :class:`.time` object::"
msgstr ":class:`.time` 객체로 작업하는 예제:"

#: ../../library/datetime.rst:2001
#, python-brace-format
msgid ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"
msgstr ""

#: ../../library/datetime.rst:2030
msgid ":class:`tzinfo` Objects"
msgstr ":class:`tzinfo` 객체"

#: ../../library/datetime.rst:2034
msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  Define a subclass of :class:`tzinfo` to capture "
"information about a particular time zone."
msgstr ""
"이것은 추상 베이스 클래스입니다. 즉, 이 클래스를 직접 인스턴스로 만들면 안 됩니다. 특정 시간대에 대한 정보를 캡처하려면 "
":class:`tzinfo`\\의 서브 클래스를 정의하십시오."

#: ../../library/datetime.rst:2038
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to "
"the constructors for :class:`.datetime` and :class:`.time` objects. The "
"latter objects view their attributes as being in local time, and the "
":class:`tzinfo` object supports methods revealing offset of local time "
"from UTC, the name of the time zone, and DST offset, all relative to a "
"date or time object passed to them."
msgstr ""
":class:`tzinfo`\\의 (구상 서브 클래스의) 인스턴스는 :class:`.datetime`\\과 "
":class:`.time` 객체의 생성자에 전달될 수 있습니다. 이 객체들은 자신의 어트리뷰트를 지역 시간으로 간주하며, "
":class:`tzinfo` 객체는 지역 시간의 UTC로부터의 오프셋, 시간대 이름 및 DST 오프셋을 모두 전달된 날짜나 시간 "
"객체에 상대적으로 얻는 메서드들을 지원합니다."

#: ../../library/datetime.rst:2044
#, fuzzy
msgid ""
"You need to derive a concrete subclass, and (at least) supply "
"implementations of the standard :class:`tzinfo` methods needed by the "
":class:`.datetime` methods you use. The :mod:`!datetime` module provides "
":class:`timezone`, a simple concrete subclass of :class:`tzinfo` which "
"can represent time zones with fixed offset from UTC such as UTC itself or"
" North American EST and EDT."
msgstr ""
"여러분은 구상(concrete) 서브 클래스를 파생시킬 필요가 있고, (적어도) 여러분이 사용하는 :class:`.datetime`"
" 메서드에 필요한 표준 :class:`tzinfo` 메서드의 구현을 제공해야 합니다. :mod:`datetime` 모듈은 간단한 "
":class:`tzinfo`\\의 구상 서브 클래스 :class:`timezone`\\를 제공하는데, UTC 자체나 북미 EST, "
"EDT와 같은 UTC로부터의 고정 오프셋을 갖는 시간대를 나타낼 수 있습니다."

#: ../../library/datetime.rst:2051
#, fuzzy
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have "
"an :meth:`~object.__init__` method that can be called with no arguments, "
"otherwise it can be pickled but possibly not unpickled again. This is a "
"technical requirement that may be relaxed in the future."
msgstr ""
"피클링을 위한 특별한 요구 사항: :class:`tzinfo` 서브 클래스는 인자 없이 호출할 수 있는 "
":meth:`__init__` 메서드를 가져야 합니다. 그렇지 않으면 피클 될 수는 있지만, 다시 역 피클 될 수는 없습니다. "
"이것은 기술적 요구사항으로, 미래에 완화될 수 있습니다."

#: ../../library/datetime.rst:2057
#, fuzzy
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the "
"following methods. Exactly which methods are needed depends on the uses "
"made of aware :mod:`!datetime` objects. If in doubt, simply implement all"
" of them."
msgstr ""
":class:`tzinfo`\\의 구상 서브 클래스는 다음 메서드를 구현해야 할 수도 있습니다. 정확히 어떤 메서드가 필요한지는 "
"어웨어 :mod:`datetime` 객체를 사용하는 방법에 따라 다릅니다. 확실하지 않으면, 그냥 모두 구현하십시오."

#: ../../library/datetime.rst:2064
msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that"
" is positive east of UTC. If local time is west of UTC, this should be "
"negative."
msgstr ""
"지역 시간의 UTC로부터의 오프셋을 UTC의 동쪽에 있을 때 양의 값을 갖는 :class:`timedelta` 객체로 반환합니다. "
"지역 시간이 UTC의 서쪽이면 이 값은 음수여야 합니다."

#: ../../library/datetime.rst:2067
msgid ""
"This represents the *total* offset from UTC; for example, if a "
":class:`tzinfo` object represents both time zone and DST adjustments, "
":meth:`utcoffset` should return their sum. If the UTC offset isn't known,"
" return ``None``. Else the value returned must be a :class:`timedelta` "
"object strictly between ``-timedelta(hours=24)`` and "
"``timedelta(hours=24)`` (the magnitude of the offset must be less than "
"one day). Most implementations of :meth:`utcoffset` will probably look "
"like one of these two::"
msgstr ""
"이것은 UTC로부터의 총 오프셋을 나타냅니다; 예를 들어, :class:`tzinfo` 객체가 시간대와 DST 조정을 모두 "
"나타내면, :meth:`utcoffset`\\은 그들의 합계를 반환해야 합니다. UTC 오프셋을 알 수 없으면, "
"``None``\\을 반환합니다. 그렇지 않으면 반환되는 값은 반드시 ``-timedelta(hours=24)``\\와 "
"``timedelta(hours=24)`` 사이의 :class:`timedelta` 객체여야 합니다 (오프셋의 크기는 하루 "
"미만이어야 합니다). :meth:`utcoffset`\\의 대부분 구현은 아마도 이 두 가지 중 하나일 것입니다::"

#: ../../library/datetime.rst:2075
msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""

#: ../../library/datetime.rst:2078
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not "
"return ``None`` either."
msgstr ""
":meth:`utcoffset`\\이 ``None``\\을 반환하지 않으면, :meth:`dst`\\도 ``None``\\을 "
"반환하지 않아야 합니다."

#: ../../library/datetime.rst:2081
msgid ""
"The default implementation of :meth:`utcoffset` raises "
":exc:`NotImplementedError`."
msgstr ":meth:`utcoffset`\\의 기본 구현은 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/datetime.rst:2090
msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta`"
" object or ``None`` if DST information isn't known."
msgstr ""
"일광 절약 시간 (DST) 조정을 :class:`timedelta` 객체로, 또는 DST 정보를 모르면 ``None``\\을 "
"반환합니다."

#: ../../library/datetime.rst:2094
#, fuzzy
msgid ""
"Return ``timedelta(0)`` if DST is not in effect. If DST is in effect, "
"return the offset as a :class:`timedelta` object (see :meth:`utcoffset` "
"for details). Note that DST offset, if applicable, has already been added"
" to the UTC offset returned by :meth:`utcoffset`, so there's no need to "
"consult :meth:`dst` unless you're interested in obtaining DST info "
"separately. For example, :meth:`datetime.timetuple` calls its "
":attr:`~.datetime.tzinfo` attribute's :meth:`dst` method to determine how"
" the :attr:`~time.struct_time.tm_isdst` flag should be set, and "
":meth:`tzinfo.fromutc` calls :meth:`dst` to account for DST changes when "
"crossing time zones."
msgstr ""
"DST가 적용되고 있지 않으면, ``timedelta(0)``\\를 반환합니다. DST가 적용 중이면, 오프셋을 "
":class:`timedelta` 객체로 반환합니다 (자세한 내용은 :meth:`utcoffset`\\을 참조하십시오). 해당하면,"
" DST 오프셋이 :meth:`utcoffset`\\에서 반환된 UTC 오프셋에 이미 추가되어 있으므로, 따로 DST 정보를 얻는 "
"데 관심이 없다면 :meth:`dst`\\를 확인할 필요가 없습니다. 예를 들어, "
":meth:`datetime.timetuple`\\은 :attr:`~.datetime.tzinfo` 어트리뷰트의 "
":meth:`dst` 메서드를 호출하여 :attr:`tm_isdst` 플래그를 어떻게 설정할지를 결정하고, "
":meth:`tzinfo.fromutc`\\는 시간대를 가로지를 때 DST 변경을 고려하기 위해 :meth:`dst`\\를 "
"호출합니다."

#: ../../library/datetime.rst:2104
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard "
"and daylight times must be consistent in this sense:"
msgstr ""
"표준과 일광 절약 시간을 모두 모형화하는 :class:`tzinfo` 서브 클래스의 인스턴스 *tz*\\는 다음과 같은 의미에서 "
"일관되어야 합니다:"

#: ../../library/datetime.rst:2107
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

#: ../../library/datetime.rst:2109
#, fuzzy
msgid ""
"must return the same result for every :class:`.datetime` *dt* with "
"``dt.tzinfo == tz``. For sane :class:`tzinfo` subclasses, this expression"
" yields the time zone's \"standard offset\", which should not depend on "
"the date or the time, but only on geographic location. The implementation"
" of :meth:`datetime.astimezone` relies on this, but cannot detect "
"violations; it's the programmer's responsibility to ensure it. If a "
":class:`tzinfo` subclass cannot guarantee this, it may be able to "
"override the default implementation of :meth:`tzinfo.fromutc` to work "
"correctly with :meth:`~.datetime.astimezone` regardless."
msgstr ""
"는 ``dt.tzinfo == tz``\\인 모든 :class:`.datetime` *dt*\\에 대해 같은 결과를 반환해야 "
"합니다. 정상적인 :class:`tzinfo` 서브 클래스에서, 이 표현식은 시간대의 \"표준 오프셋\"을 산출하는데, 이것은 "
"날짜나 시간에 의존하지 않고, 지리적 위치에만 의존해야 합니다. :meth:`datetime.astimezone` 구현은 이 "
"일관성에 의존하지만, 위반을 감지할 수는 없습니다; 이를 보장하는 것은 프로그래머의 책임입니다. :class:`tzinfo` 서브 "
"클래스가 이를 보장 할 수 없으면, :meth:`astimezone`\\와 상관없이 올바르게 작동하도록 "
":meth:`tzinfo.fromutc`\\의 기본 구현을 재정의할 수 있습니다."

#: ../../library/datetime.rst:2118
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ":meth:`dst`\\의 대부분 구현은 아마도 이 두 가지 중 하나일 것입니다::"

#: ../../library/datetime.rst:2120
msgid ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""

#: ../../library/datetime.rst:2124
msgid "or::"
msgstr "또는::"

#: ../../library/datetime.rst:2126
msgid ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""

#: ../../library/datetime.rst:2136
msgid ""
"The default implementation of :meth:`dst` raises "
":exc:`NotImplementedError`."
msgstr ":meth:`dst`\\의 기본 구현은 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/datetime.rst:2144
#, fuzzy
msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the "
":mod:`!datetime` module, and there's no requirement that it mean anything"
" in particular. For example, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` "
"are all valid replies. Return ``None`` if a string name isn't known. Note"
" that this is a method rather than a fixed string primarily because some "
":class:`tzinfo` subclasses will wish to return different names depending "
"on the specific value of *dt* passed, especially if the :class:`tzinfo` "
"class is accounting for daylight time."
msgstr ""
":class:`.datetime` 객체 *dt*\\에 해당하는 시간대 이름을 문자열로 반환합니다. 문자열 이름에 관한 어떤 것도 "
":mod:`datetime` 모듈에 의해 정의되지 않으며, 특별히 어떤 것을 의미해야 한다는 요구 사항이 없습니다. 예를 들어, "
"\"GMT\", \"UTC\", \"-500\", \"-5:00\", \"EDT\", \"US/Eastern\", "
"\"America/New York\"은 모두 유효한 응답입니다. 문자열 이름을 모르면 ``None``\\을 반환합니다. 이것은 "
"고정된 문자열이기보다 메서드인데, 주로 어떤 :class:`tzinfo` 서브 클래스가 전달된 *dt*\\의 특정 값에 따라 다른 "
"이름을 반환하기를 원하기 때문입니다. 특히 :class:`tzinfo` 클래스가 일광 절약 시간을 고려할 때 그렇습니다."

#: ../../library/datetime.rst:2154
msgid ""
"The default implementation of :meth:`tzname` raises "
":exc:`NotImplementedError`."
msgstr ":meth:`tzname`\\의 기본 구현은 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/datetime.rst:2157
msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` "
"object, in response to their methods of the same names. A "
":class:`.datetime` object passes itself as the argument, and a "
":class:`.time` object passes ``None`` as the argument. A :class:`tzinfo` "
"subclass's methods should therefore be prepared to accept a *dt* argument"
" of ``None``, or of class :class:`.datetime`."
msgstr ""
"이 메서드들은 :class:`.datetime`\\나 :class:`.time` 객체에서 같은 이름의 메서드에 대한 응답으로 "
"호출됩니다. :class:`.datetime` 객체는 자신을 인자로 전달하고, :class:`.time` 객체는 인자로 "
"``None``\\을 전달합니다. 따라서 :class:`tzinfo` 서브 클래스의 메서드는 ``None``\\이나 "
":class:`.datetime` 클래스의 *dt* 인자를 받아들일 준비가 되어 있어야 합니다."

#: ../../library/datetime.rst:2163
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best"
" response. For example, returning ``None`` is appropriate if the class "
"wishes to say that time objects don't participate in the :class:`tzinfo` "
"protocols. It may be more useful for ``utcoffset(None)`` to return the "
"standard UTC offset, as there is no other convention for discovering the "
"standard offset."
msgstr ""
"``None``\\이 전달되면, 최선의 응답을 결정하는 것은 클래스 설계자에게 달려있습니다. 예를 들어, 클래스가 "
":class:`tzinfo` 프로토콜에 time 객체가 참여하지 않는다고 말하고 싶다면 ``None``\\을 반환하는 것이 "
"적절합니다. 표준 오프셋을 발견하는 다른 규칙이 없으므로, ``utcoffset(None)``\\이 표준 UTC 오프셋을 반환하는 "
"것이 더 유용할 수 있습니다."

#: ../../library/datetime.rst:2169
#, fuzzy
msgid ""
"When a :class:`.datetime` object is passed in response to a "
":class:`.datetime` method, ``dt.tzinfo`` is the same object as *self*. "
":class:`tzinfo` methods can rely on this, unless user code calls "
":class:`tzinfo` methods directly. The intent is that the :class:`tzinfo` "
"methods interpret *dt* as being in local time, and not need worry about "
"objects in other time zones."
msgstr ""
":class:`.datetime` 메서드에 대한 응답으로 :class:`.datetime` 객체가 전달되면, "
"``dt.tzinfo``\\는 *self*\\와 같은 객체입니다. 사용자 코드가 :class:`tzinfo` 메서드를 직접 호출하지"
" 않는 한, :class:`tzinfo` 메서드는 이것에 의존할 수 있습니다. :class:`tzinfo` 메서드가 *dt*\\를 "
"지역 시간으로 해석하고, 다른 시간대의 객체를 걱정할 필요가 없도록 하려는 의도입니다."

#: ../../library/datetime.rst:2175
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr "서브 클래스가 재정의할 수 있는 :class:`tzinfo` 메서드가 하나 더 있습니다:"

#: ../../library/datetime.rst:2180
#, fuzzy
msgid ""
"This is called from the default :meth:`datetime.astimezone` "
"implementation. When called from that, ``dt.tzinfo`` is *self*, and "
"*dt*'s date and time data are to be viewed as expressing a UTC time. The "
"purpose of :meth:`fromutc` is to adjust the date and time data, returning"
" an equivalent datetime in *self*'s local time."
msgstr ""
"이것은 기본 :class:`datetime.astimezone()` 구현에서 호출됩니다. 거기에서 호출되면, "
"``dt.tzinfo``\\는 *self*\\이고, *dt*\\의 날짜와 시간 데이터는 UTC 시간으로 표시된 것으로 봅니다. "
":meth:`fromutc`\\의 목적은 날짜와 시간 데이터를 조정하여, *self*\\의 지역 시간으로 동등한 datetime을 "
"반환하는 것입니다."

#: ../../library/datetime.rst:2186
#, fuzzy
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default "
":meth:`fromutc` implementation without problems. It's strong enough to "
"handle fixed-offset time zones, and time zones accounting for both "
"standard and daylight time, and the latter even if the DST transition "
"times differ in different years. An example of a time zone the default "
":meth:`fromutc` implementation may not handle correctly in all cases is "
"one where the standard offset (from UTC) depends on the specific date and"
" time passed, which can happen for political reasons. The default "
"implementations of :meth:`~.datetime.astimezone` and :meth:`fromutc` may "
"not produce the result you want if the result is one of the hours "
"straddling the moment the standard offset changes."
msgstr ""
"대부분 :class:`tzinfo` 서브 클래스는 문제없이 기본 :meth:`fromutc` 구현을 상속할 수 있어야 합니다. 고정"
" 오프셋 시간대와 표준과 일광 절약 시간을 모두 고려하는 시간대를, 해마다 DST 전환 시간이 다를 때도 일광 절약 시간을 처리할 "
"수 있을 만큼 강력합니다. 기본 :meth:`fromutc` 구현이 모든 경우에 올바르게 처리하지 못할 수 있는 시간대의 예는 "
"(정치적 이유로 인해 발생할 수 있는) 특정 날짜와 시간에 따라 (UTC로부터의) 표준 오프셋이 달라지는 것입니다. 결과가 표준 "
"오프셋이 변경되는 순간에 걸치는 시간 중 하나일 때, :meth:`astimezone`\\과 :meth:`fromutc`\\의 기본"
" 구현은 여러분이 원하는 결과를 생성하지 못할 수 있습니다."

#: ../../library/datetime.rst:2197
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation"
" acts like::"
msgstr "에러가 발생하는 경우를 위한 코드를 생략하면, 기본 :meth:`fromutc` 구현은 다음과 같이 동작합니다::"

#: ../../library/datetime.rst:2200
msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""

#: ../../library/datetime.rst:2215
msgid ""
"In the following :download:`tzinfo_examples.py "
"<../includes/tzinfo_examples.py>` file there are some examples of "
":class:`tzinfo` classes:"
msgstr ""
"다음 :download:`tzinfo_examples.py <../includes/tzinfo_examples.py>` 파일에는 "
":class:`tzinfo` 클래스의 몇 가지 예가 나와 있습니다:"

#: ../../library/datetime.rst:2219
msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones."
"\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules"
"\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the "
"first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last"
"\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default "
"astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone "
"from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""

#: ../../library/datetime.rst:2221
msgid ""
"Note that there are unavoidable subtleties twice per year in a "
":class:`tzinfo` subclass accounting for both standard and daylight time, "
"at the DST transition points. For concreteness, consider US Eastern (UTC "
"-0500), where EDT begins the minute after 1:59 (EST) on the second Sunday"
" in March, and ends the minute after 1:59 (EDT) on the first Sunday in "
"November::"
msgstr ""
"DST 전환점에서 표준 시간과 일광 절약 시간을 모두 고려하는 :class:`tzinfo` 서브 클래스에는 일 년에 두 번 불가피한"
" 미묘함이 있음에 유의하십시오. 구체적으로, 3월 두 번째 일요일의 1:59 (EST) 다음 분에 시작하고, 11월 첫 번째 일요일"
" 1:59 (EDT) 다음 분에 끝나는 미국 Eastern(UTC -0500)을 고려하십시오::"

#: ../../library/datetime.rst:2227
msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""

#: ../../library/datetime.rst:2235
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from "
"1:59 to 3:00. A wall time of the form 2:MM doesn't really make sense on "
"that day, so ``astimezone(Eastern)`` won't deliver a result with ``hour "
"== 2`` on the day DST begins. For example, at the Spring forward "
"transition of 2016, we get::"
msgstr ""
"DST가 시작할 때 (\"start\" 줄), 지역 벽시계는 1:59에서 3:00로 도약합니다. 그날에는 2:MM 형식의 벽 시간은"
" 실질적인 의미가 없으므로, ``astimezone(Eastern)``\\은 DST가 시작하는 날에 ``hour == 2``\\인 "
"결과를 전달하지 않습니다. 예를 들어, 2016년 봄의 전진 전환(forward transition)에서, 다음과 같은 결과를 "
"얻습니다::"

#: ../../library/datetime.rst:2240
msgid ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"
msgstr ""

#: ../../library/datetime.rst:2254
#, fuzzy
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: "
"the last hour of daylight time. In Eastern, that's times of the form 5:MM"
" UTC on the day daylight time ends. The local wall clock leaps from 1:59 "
"(daylight time) back to 1:00 (standard time) again. Local times of the "
"form 1:MM are ambiguous. :meth:`~.datetime.astimezone` mimics the local "
"clock's behavior by mapping two adjacent UTC hours into the same local "
"hour then. In the Eastern example, UTC times of the form 5:MM and 6:MM "
"both map to 1:MM when converted to Eastern, but earlier times have the "
":attr:`~.datetime.fold` attribute set to 0 and the later times have it "
"set to 1. For example, at the Fall back transition of 2016, we get::"
msgstr ""
"DST가 끝날 때 (\"end\" 줄), 잠재적으로 더 나쁜 문제가 있습니다: 지역 시간으로 명확하게 말할 수 없는 시(hour)가"
" 있습니다: 일광 절약 시간의 마지막 한 시간. Eastern에서, 이것은 일광 절약 시간제가 끝나는 날의 5:MM UTC 형식의 "
"시간입니다. 지역 벽시계는 1:59(일광 절약 시간)에서 다시 1:00(표준 시간)으로 도약합니다. 1:MM 형식의 지역 시간은 "
"모호합니다. :meth:`astimezone`\\은 두 개의 인접한 UTC 시(hour)를 같은 지역 시(hour)로 매핑하여 지역"
" 시계 동작을 모방합니다. Eastern 예제에서, 5:MM과 6:MM 형식의 UTC 시간은 모두 Eastern으로 변환될 때 "
"1:MM으로 매핑되지만, 이전 시간은 :attr:`~datetime.fold` 어트리뷰트가 0으로 설정되고 이후 시간은 1로 "
"설정됩니다. 예를 들어, 2016년 가을의 역 전환( back transition)에서, 다음과 같은 결과를 얻습니다::"

#: ../../library/datetime.rst:2265
msgid ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"
msgstr ""

#: ../../library/datetime.rst:2276
#, fuzzy
msgid ""
"Note that the :class:`.datetime` instances that differ only by the value "
"of the :attr:`~.datetime.fold` attribute are considered equal in "
"comparisons."
msgstr ""
":attr:`~datetime.fold` 어트리뷰트의 값만 다른 :class:`.datetime` 인스턴스는 비교에서 같다고 "
"간주하는 것에 유의하십시오."

#: ../../library/datetime.rst:2279
#, fuzzy
msgid ""
"Applications that can't bear wall-time ambiguities should explicitly "
"check the value of the :attr:`~.datetime.fold` attribute or avoid using "
"hybrid :class:`tzinfo` subclasses; there are no ambiguities when using "
":class:`timezone`, or any other fixed-offset :class:`tzinfo` subclass "
"(such as a class representing only EST (fixed offset -5 hours), or only "
"EDT (fixed offset -4 hours))."
msgstr ""
"벽 시간 모호성을 견딜 수 없는 응용 프로그램은 명시적으로 :attr:`~datetime.fold` 어트리뷰트 값을 확인하거나 "
"하이브리드 :class:`tzinfo` 서브 클래스를 사용하지 않아야 합니다; :class:`timezone`\\이나 기타 고정 "
"오프셋 :class:`tzinfo` 서브 클래스(가령 오직 EST(고정 오프셋 -5시간)와  EDT(고정 오프셋 -4시간) 중 어느"
" 한 가지만 나타내는 클래스)를 사용할 때는 모호함이 없습니다."

#: ../../library/datetime.rst:2287
msgid ":mod:`zoneinfo`"
msgstr ""

#: ../../library/datetime.rst:2288
#, fuzzy
msgid ""
"The :mod:`!datetime` module has a basic :class:`timezone` class (for "
"handling arbitrary fixed offsets from UTC) and its :attr:`timezone.utc` "
"attribute (a UTC :class:`!timezone` instance)."
msgstr ""
":mod:`datetime` 모듈에는 (UTC로부터의 임의의 고정 오프셋을 처리하기 위한) 기본적인 :class:`timezone`"
" 클래스와 :attr:`timezone.utc` 어트리뷰트(UTC timezone 인스턴스)가 있습니다."

#: ../../library/datetime.rst:2292
#, fuzzy
msgid ""
"``zoneinfo`` brings the *IANA time zone database* (also known as the "
"Olson database) to Python, and its usage is recommended."
msgstr ""
"*dateutil.tz* 라이브러리는 *IANA 시간대 데이터베이스* (Olson 데이터베이스라고도 합니다)를 파이썬으로 "
"가져옵니다. 사용을 권장합니다."

#: ../../library/datetime.rst:2295
#, fuzzy
msgid "`IANA time zone database <https://www.iana.org/time-zones>`_"
msgstr "`IANA timezone database <https://www.iana.org/time-zones>`_"

#: ../../library/datetime.rst:2296
msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains "
"code and data that represent the history of local time for many "
"representative locations around the globe. It is updated periodically to "
"reflect changes made by political bodies to time zone boundaries, UTC "
"offsets, and daylight-saving rules."
msgstr ""
"시간대 데이터베이스 (종종 tz, tzdata 또는 zoneinfo라고 합니다)에는 전 세계 여러 지역에서 지역 시간의 히스토리를 "
"표현하는 코드와 데이터가 포함되어 있습니다. 정치 단체가 변경 한 시간대 경계, UTC 오프셋 및 일광 절약 시간 규칙을 반영하기 "
"위해 주기적으로 갱신됩니다."

#: ../../library/datetime.rst:2306
msgid ":class:`timezone` Objects"
msgstr ":class:`timezone` 객체"

#: ../../library/datetime.rst:2308
#, fuzzy
msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each "
"instance of which represents a time zone defined by a fixed offset from "
"UTC."
msgstr ""
":class:`timezone` 클래스는 :class:`tzinfo`\\의 서브 클래스이며, 각 인스턴스는 UTC로부터의 고정 "
"오프셋으로 정의된 시간대를 나타냅니다."

#: ../../library/datetime.rst:2312
#, fuzzy
msgid ""
"Objects of this class cannot be used to represent time zone information "
"in the locations where different offsets are used in different days of "
"the year or where historical changes have been made to civil time."
msgstr ""
"이 클래스의 객체는 일 년 중 어떤 날에는 다른 오프셋이 사용되거나 민간 시간이 역사적으로 변해온 지역의 시간대 정보를 나타내는데 "
"사용할 수 없습니다."

#: ../../library/datetime.rst:2319
msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC. It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"*offset* 인자는 지역 시간과 UTC 간의 차이를 나타내는 :class:`timedelta` 객체로 지정해야 합니다. "
"엄격히(경계를 포함하지 않는) ``-timedelta(hours=24)``\\와 ``timedelta(hours=24)`` 사이여야"
" 합니다. 그렇지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/datetime.rst:2324
msgid ""
"The *name* argument is optional. If specified it must be a string that "
"will be used as the value returned by the :meth:`datetime.tzname` method."
msgstr ""
"*name* 인자는 선택적입니다. 지정되면 :meth:`datetime.tzname` 메서드가 반환하는 값으로 사용될 문자열이어야 "
"합니다."

#: ../../library/datetime.rst:2335 ../../library/datetime.rst:2346
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed."
msgstr ":class:`timezone` 인스턴스가 구축될 때 지정된 고정값을 반환합니다."

#: ../../library/datetime.rst:2338
msgid ""
"The *dt* argument is ignored. The return value is a :class:`timedelta` "
"instance equal to the difference between the local time and UTC."
msgstr "*dt* 인자는 무시됩니다. 반환 값은 지역 시간과 UTC 간의 차이와 같은 :class:`timedelta` 인스턴스입니다."

#: ../../library/datetime.rst:2349
msgid ""
"If *name* is not provided in the constructor, the name returned by "
"``tzname(dt)`` is generated from the value of the ``offset`` as follows. "
"If *offset* is ``timedelta(0)``, the name is \"UTC\", otherwise it is a "
"string in the format ``UTC±HH:MM``, where ± is the sign of ``offset``, HH"
" and MM are two digits of ``offset.hours`` and ``offset.minutes`` "
"respectively."
msgstr ""
"*name*\\을 생성자에 제공하지 않았으면, ``tzname(dt)``\\에 의해 반환되는 이름은 다음과 같이 ``offset``"
" 값으로부터 생성됩니다. *offset*\\이 ``timedelta(0)``\\이면, 이름은 \"UTC\"이고, 그렇지 않으면 "
"문자열 ``UTC±HH:MM``\\입니다. 여기서 ±는 ``offset``\\의 부호이고, HH와 MM은 각각 "
"``offset.hours``\\와 ``offset.minutes``\\의 두 자리 숫자입니다."

#: ../../library/datetime.rst:2355
#, fuzzy
msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain ``'UTC'``, not "
"``'UTC+00:00'``."
msgstr ""
"``offset=timedelta(0)``\\에서 생성된 이름은 이제 ``'UTC+00:00'``\\이 아니라 단순한 `'UTC'`"
" 입니다."

#: ../../library/datetime.rst:2362
msgid "Always returns ``None``."
msgstr "항상 ``None``\\을 반환합니다."

#: ../../library/datetime.rst:2366
msgid ""
"Return ``dt + offset``. The *dt* argument must be an aware "
":class:`.datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"``dt + offset``\\을 반환합니다. *dt* 인자는 ``tzinfo``\\가 ``self``\\로 설정된 어웨어 "
":class:`.datetime` 인스턴스여야 합니다."

#: ../../library/datetime.rst:2373
#, fuzzy
msgid "The UTC time zone, ``timezone(timedelta(0))``."
msgstr "UTC 시간대, ``timezone(timedelta(0))``."

#: ../../library/datetime.rst:2382
#, fuzzy
msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Behavior"
msgstr ":meth:`strftime`\\과 :meth:`strptime` 동작"

#: ../../library/datetime.rst:2384
msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support"
" a ``strftime(format)`` method, to create a string representing the time "
"under the control of an explicit format string."
msgstr ""
":class:`date`, :class:`.datetime` 및 :class:`.time` 객체는 모두 "
"``strftime(format)`` 메서드를 지원하여, 명시적 포맷 문자열로 제어된 시간을 나타내는 문자열을 만듭니다."

#: ../../library/datetime.rst:2388
msgid ""
"Conversely, the :meth:`datetime.strptime` class method creates a "
":class:`.datetime` object from a string representing a date and time and "
"a corresponding format string."
msgstr ""
"반대로, :meth:`datetime.strptime` 클래스 메서드는 날짜와 시간을 나타내는 문자열과 해당 포맷 문자열로 "
":class:`.datetime` 객체를 만듭니다."

#: ../../library/datetime.rst:2392
#, fuzzy
msgid ""
"The table below provides a high-level comparison of "
":meth:`~.datetime.strftime` versus :meth:`~.datetime.strptime`:"
msgstr "아래 표는 :meth:`strftime`\\과 :meth:`strptime`\\의 고수준 비교를 제공합니다:"

#: ../../library/datetime.rst:2396
msgid "``strftime``"
msgstr "``strftime``"

#: ../../library/datetime.rst:2396
msgid "``strptime``"
msgstr "``strptime``"

#: ../../library/datetime.rst:2398
msgid "Usage"
msgstr "용도"

#: ../../library/datetime.rst:2398
msgid "Convert object to a string according to a given format"
msgstr "주어진 포맷에 따라 객체를 문자열로 변환합니다"

#: ../../library/datetime.rst:2398
msgid ""
"Parse a string into a :class:`.datetime` object given a corresponding "
"format"
msgstr "주어진 해당 포맷으로 문자열을 :class:`.datetime` 객체로 구문 분석합니다"

#: ../../library/datetime.rst:2400
msgid "Type of method"
msgstr "메서드의 형"

#: ../../library/datetime.rst:2400
msgid "Instance method"
msgstr "인스턴스 메서드"

#: ../../library/datetime.rst:2400
msgid "Class method"
msgstr "클래스 메서드"

#: ../../library/datetime.rst:2402
msgid "Method of"
msgstr "메서드가 제공되는 곳"

#: ../../library/datetime.rst:2402
msgid ":class:`date`; :class:`.datetime`; :class:`.time`"
msgstr ":class:`date`; :class:`.datetime`; :class:`.time`"

#: ../../library/datetime.rst:2402
msgid ":class:`.datetime`"
msgstr ":class:`.datetime`"

#: ../../library/datetime.rst:2404
msgid "Signature"
msgstr "서명"

#: ../../library/datetime.rst:2404
msgid "``strftime(format)``"
msgstr "``strftime(format)``"

#: ../../library/datetime.rst:2404
msgid "``strptime(date_string, format)``"
msgstr "``strptime(date_string, format)``"

#: ../../library/datetime.rst:2411
#, fuzzy
msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Format Codes"
msgstr ":meth:`strftime`\\과 :meth:`strptime` 포맷 코드"

#: ../../library/datetime.rst:2413
msgid ""
"These methods accept format codes that can be used to parse and format "
"dates::"
msgstr ""

#: ../../library/datetime.rst:2415
#, python-format
msgid ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"
msgstr ""

#: ../../library/datetime.rst:2421
msgid ""
"The following is a list of all the format codes that the 1989 C standard "
"requires, and these work on all platforms with a standard C "
"implementation."
msgstr "다음은 1989 C 표준이 요구하는 모든 포맷 코드 목록이며, 표준 C 구현이 있는 모든 플랫폼에서 작동합니다."

#: ../../library/datetime.rst:2425 ../../library/datetime.rst:2528
msgid "Directive"
msgstr "지시자"

#: ../../library/datetime.rst:2425 ../../library/datetime.rst:2528
msgid "Meaning"
msgstr "의미"

#: ../../library/datetime.rst:2425 ../../library/datetime.rst:2528
msgid "Example"
msgstr "예"

#: ../../library/datetime.rst:2425 ../../library/datetime.rst:2528
msgid "Notes"
msgstr "노트"

#: ../../library/datetime.rst:2427
msgid "``%a``"
msgstr "``%a``"

#: ../../library/datetime.rst:2427
msgid "Weekday as locale's abbreviated name."
msgstr "요일을 로케일의 축약된 이름으로."

#: ../../library/datetime.rst
msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sun, Mon, ..., Sat (en_US);"

#: ../../library/datetime.rst
msgid "So, Mo, ..., Sa (de_DE)"
msgstr "So, Mo, ..., Sa (de_DE)"

#: ../../library/datetime.rst:2432
msgid "``%A``"
msgstr "``%A``"

#: ../../library/datetime.rst:2432
msgid "Weekday as locale's full name."
msgstr "요일을 로케일의 전체 이름으로."

#: ../../library/datetime.rst
msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "Sunday, Monday, ..., Saturday (en_US);"

#: ../../library/datetime.rst
msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Sonntag, Montag, ..., Samstag (de_DE)"

#: ../../library/datetime.rst:2437
msgid "``%w``"
msgstr "``%w``"

#: ../../library/datetime.rst:2437
msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr "요일을 10진수로, 0은 일요일이고 6은 토요일입니다."

#: ../../library/datetime.rst:2437
msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

#: ../../library/datetime.rst:2441
#, python-format
msgid "``%d``"
msgstr "``%d``"

#: ../../library/datetime.rst:2441
msgid "Day of the month as a zero-padded decimal number."
msgstr "월중 일(day of the month)을 0으로 채워진 10진수로."

#: ../../library/datetime.rst:2441
msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

#: ../../library/datetime.rst:2441 ../../library/datetime.rst:2454
#: ../../library/datetime.rst:2457 ../../library/datetime.rst:2463
#: ../../library/datetime.rst:2466 ../../library/datetime.rst:2472
#: ../../library/datetime.rst:2490
msgid "\\(9)"
msgstr "\\(9)"

#: ../../library/datetime.rst:2444
msgid "``%b``"
msgstr "``%b``"

#: ../../library/datetime.rst:2444
msgid "Month as locale's abbreviated name."
msgstr "월을 로케일의 축약된 이름으로."

#: ../../library/datetime.rst
msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, Feb, ..., Dec (en_US);"

#: ../../library/datetime.rst
msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "Jan, Feb, ..., Dez (de_DE)"

#: ../../library/datetime.rst:2449
msgid "``%B``"
msgstr "``%B``"

#: ../../library/datetime.rst:2449
msgid "Month as locale's full name."
msgstr "월을 로케일의 전체 이름으로."

#: ../../library/datetime.rst
msgid "January, February, ..., December (en_US);"
msgstr "January, February, ..., December (en_US);"

#: ../../library/datetime.rst
msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "Januar, Februar, ..., Dezember (de_DE)"

#: ../../library/datetime.rst:2454
msgid "``%m``"
msgstr "``%m``"

#: ../../library/datetime.rst:2454
msgid "Month as a zero-padded decimal number."
msgstr "월을 0으로 채워진 10진수로."

#: ../../library/datetime.rst:2454 ../../library/datetime.rst:2466
msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

#: ../../library/datetime.rst:2457
msgid "``%y``"
msgstr "``%y``"

#: ../../library/datetime.rst:2457
msgid "Year without century as a zero-padded decimal number."
msgstr "세기가 없는 해(year)를 0으로 채워진 10진수로."

#: ../../library/datetime.rst:2457
msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

#: ../../library/datetime.rst:2460
msgid "``%Y``"
msgstr "``%Y``"

#: ../../library/datetime.rst:2460
msgid "Year with century as a decimal number."
msgstr "세기가 있는 해(year)를 10진수로."

#: ../../library/datetime.rst:2460 ../../library/datetime.rst:2530
msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

#: ../../library/datetime.rst:2463
msgid "``%H``"
msgstr "``%H``"

#: ../../library/datetime.rst:2463
msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr "시(24시간제)를 0으로 채워진 십진수로."

#: ../../library/datetime.rst:2463
msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

#: ../../library/datetime.rst:2466
msgid "``%I``"
msgstr "``%I``"

#: ../../library/datetime.rst:2466
msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr "시(12시간제)를 0으로 채워진 십진수로."

#: ../../library/datetime.rst:2469
msgid "``%p``"
msgstr "``%p``"

#: ../../library/datetime.rst:2469
msgid "Locale's equivalent of either AM or PM."
msgstr "로케일의 오전이나 오후에 해당하는 것."

#: ../../library/datetime.rst
msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

#: ../../library/datetime.rst
msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

#: ../../library/datetime.rst:2469
msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

#: ../../library/datetime.rst:2472
msgid "``%M``"
msgstr "``%M``"

#: ../../library/datetime.rst:2472
msgid "Minute as a zero-padded decimal number."
msgstr "분을 0으로 채워진 십진수로."

#: ../../library/datetime.rst:2472 ../../library/datetime.rst:2475
msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

#: ../../library/datetime.rst:2475
msgid "``%S``"
msgstr "``%S``"

#: ../../library/datetime.rst:2475
msgid "Second as a zero-padded decimal number."
msgstr "초를 0으로 채워진 10진수로."

#: ../../library/datetime.rst:2475
msgid "\\(4), \\(9)"
msgstr "\\(4), \\(9)"

#: ../../library/datetime.rst:2478
#, python-format
msgid "``%f``"
msgstr "``%f``"

#: ../../library/datetime.rst:2478
#, fuzzy
msgid "Microsecond as a decimal number, zero-padded to 6 digits."
msgstr "마이크로초를 왼쪽에 0으로 채워진 십진수로."

#: ../../library/datetime.rst:2478
msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

#: ../../library/datetime.rst:2478
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/datetime.rst:2482 ../../library/datetime.rst:2641
msgid "``%z``"
msgstr "``%z``"

#: ../../library/datetime.rst:2482
msgid ""
"UTC offset in the form ``±HHMM[SS[.ffffff]]`` (empty string if the object"
" is naive)."
msgstr "``±HHMM[SS[.ffffff]]`` 형태의 UTC 오프셋 (객체가 나이브하면 빈 문자열)."

#: ../../library/datetime.rst:2482
msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(비어 있음), +0000, -0400, +1030, +063415, -030712.345216"

#: ../../library/datetime.rst:2482 ../../library/datetime.rst:2487
#: ../../library/datetime.rst:2544
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/datetime.rst:2487 ../../library/datetime.rst:2667
msgid "``%Z``"
msgstr "``%Z``"

#: ../../library/datetime.rst:2487
msgid "Time zone name (empty string if the object is naive)."
msgstr "시간대 이름 (객체가 나이브하면 빈 문자열)."

#: ../../library/datetime.rst:2487
msgid "(empty), UTC, GMT"
msgstr "(비어 있음), UTC, GMT"

#: ../../library/datetime.rst:2490
msgid "``%j``"
msgstr "``%j``"

#: ../../library/datetime.rst:2490
msgid "Day of the year as a zero-padded decimal number."
msgstr "연중 일(day of the year)을 0으로 채워진 십진수로."

#: ../../library/datetime.rst:2490
msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

#: ../../library/datetime.rst:2493
msgid "``%U``"
msgstr "``%U``"

#: ../../library/datetime.rst:2493
#, fuzzy
msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Sunday "
"are considered to be in week 0."
msgstr "연중 주 번호(일요일이 주의 시작)를 0으로 채워진 10진수로. 첫 번째 일요일에 선행하는 새해의 모든 날은 주 0으로 간주합니다."

#: ../../library/datetime.rst:2493 ../../library/datetime.rst:2501
msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

#: ../../library/datetime.rst:2493 ../../library/datetime.rst:2501
msgid "\\(7), \\(9)"
msgstr "\\(7), \\(9)"

#: ../../library/datetime.rst:2501
msgid "``%W``"
msgstr "``%W``"

#: ../../library/datetime.rst:2501
#, fuzzy
msgid ""
"Week number of the year (Monday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Monday "
"are considered to be in week 0."
msgstr "연중 주 번호(일요일이 주의 시작)를 0으로 채워진 10진수로. 첫 번째 일요일에 선행하는 새해의 모든 날은 주 0으로 간주합니다."

#: ../../library/datetime.rst:2509
#, python-format
msgid "``%c``"
msgstr "``%c``"

#: ../../library/datetime.rst:2509
msgid "Locale's appropriate date and time representation."
msgstr "로케일의 적절한 날짜와 시간 표현."

#: ../../library/datetime.rst
msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (en_US);"

#: ../../library/datetime.rst
msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "Di 16 Aug 21:30:00 1988 (de_DE)"

#: ../../library/datetime.rst:2514
#, python-format
msgid "``%x``"
msgstr "``%x``"

#: ../../library/datetime.rst:2514
msgid "Locale's appropriate date representation."
msgstr "로케일의 적절한 날짜 표현."

#: ../../library/datetime.rst
msgid "08/16/88 (None);"
msgstr "08/16/88 (None);"

#: ../../library/datetime.rst
msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (en_US);"

#: ../../library/datetime.rst
msgid "16.08.1988 (de_DE)"
msgstr "16.08.1988 (de_DE)"

#: ../../library/datetime.rst:2518
#, python-format
msgid "``%X``"
msgstr "``%X``"

#: ../../library/datetime.rst:2518
msgid "Locale's appropriate time representation."
msgstr "로케일의 적절한 시간 표현."

#: ../../library/datetime.rst
msgid "21:30:00 (en_US);"
msgstr "21:30:00 (en_US);"

#: ../../library/datetime.rst
msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (de_DE)"

#: ../../library/datetime.rst:2521
#, python-format
msgid "``%%``"
msgstr "``%%``"

#: ../../library/datetime.rst:2521
msgid "A literal ``'%'`` character."
msgstr "리터럴 ``'%'`` 문자."

#: ../../library/datetime.rst:2521
msgid "%"
msgstr "%"

#: ../../library/datetime.rst:2524
msgid ""
"Several additional directives not required by the C89 standard are "
"included for convenience. These parameters all correspond to ISO 8601 "
"date values."
msgstr ""
"C89 표준에서 요구하지 않는 몇 가지 추가 지시자가 편의상 포함되어 있습니다. 이 파라미터들은 모두 ISO 8601 날짜 값에 "
"해당합니다."

#: ../../library/datetime.rst:2530
#, python-format
msgid "``%G``"
msgstr "``%G``"

#: ../../library/datetime.rst:2530
msgid ""
"ISO 8601 year with century representing the year that contains the "
"greater part of the ISO week (``%V``)."
msgstr "ISO 주(``%V``)의 더 큰 부분을 포함하는 연도를 나타내는 세기가 있는 ISO 8601 연도."

#: ../../library/datetime.rst:2530
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/datetime.rst:2535
#, python-format
msgid "``%u``"
msgstr "``%u``"

#: ../../library/datetime.rst:2535
msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr "ISO 8601 요일을 10진수로, 1은 월요일입니다."

#: ../../library/datetime.rst:2535
msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

#: ../../library/datetime.rst:2538
msgid "``%V``"
msgstr "``%V``"

#: ../../library/datetime.rst:2538
msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the "
"week. Week 01 is the week containing Jan 4."
msgstr "ISO 8601 주를 월요일을 주의 시작으로 하는 십진수로. 주 01은 1월 4일을 포함하는 주입니다."

#: ../../library/datetime.rst:2538
msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

#: ../../library/datetime.rst:2538
msgid "\\(8), \\(9)"
msgstr "\\(8), \\(9)"

#: ../../library/datetime.rst:2544 ../../library/datetime.rst:2663
#, fuzzy
msgid "``%:z``"
msgstr "``%Z``"

#: ../../library/datetime.rst:2544
#, fuzzy
msgid ""
"UTC offset in the form ``±HH:MM[:SS[.ffffff]]`` (empty string if the "
"object is naive)."
msgstr "``±HHMM[SS[.ffffff]]`` 형태의 UTC 오프셋 (객체가 나이브하면 빈 문자열)."

#: ../../library/datetime.rst:2544
#, fuzzy
msgid "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"
msgstr "(비어 있음), +0000, -0400, +1030, +063415, -030712.345216"

#: ../../library/datetime.rst:2550
#, fuzzy
msgid ""
"These may not be available on all platforms when used with the "
":meth:`~.datetime.strftime` method. The ISO 8601 year and ISO 8601 week "
"directives are not interchangeable with the year and week number "
"directives above. Calling :meth:`~.datetime.strptime` with incomplete or "
"ambiguous ISO 8601 directives will raise a :exc:`ValueError`."
msgstr ""
":meth:`strftime` 메서드와 함께 사용될 때 모든 플랫폼에서 사용할 수 있는 것은 아닙니다. ISO 8601 연도와 "
"ISO 8601 주 지시자는 위의 연도 및 주 번호 지시자와 교환할 수 없습니다. 불완전하거나 모호한 ISO 8601 지시자로 "
":meth:`strptime`\\을 호출하면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/datetime.rst:2555
#, fuzzy
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :c:func:`strftime` function, and "
"platform variations are common. To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation. There are also differences between platforms in handling "
"of unsupported format specifiers."
msgstr ""
"파이썬이 플랫폼 C 라이브러리의 :func:`strftime` 함수를 호출하고, 플랫폼 변형이 일반적이기 때문에, 지원되는 전체 "
"포맷 코드 집합은 플랫폼에 따라 다릅니다. 여러분의 플랫폼에서 지원되는 모든 포맷 코드를 보려면, "
":manpage:`strftime(3)` 설명서를 참조하십시오."

#: ../../library/datetime.rst:2561
#, python-format
msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "``%G``, ``%u`` 및 ``%V``\\가 추가되었습니다."

#: ../../library/datetime.rst:2564
msgid "``%:z`` was added."
msgstr ""

#: ../../library/datetime.rst:2568
msgid "Technical Detail"
msgstr "기술적 세부 사항"

#: ../../library/datetime.rst:2570
#, fuzzy
msgid ""
"Broadly speaking, ``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a "
":meth:`~date.timetuple` method."
msgstr ""
"대체로 말하자면, 모든 객체가 :meth:`timetuple` 메서드를 지원하는 것은 아니지만, "
"``d.strftime(fmt)``\\는 :mod:`time` 모듈의 ``time.strftime(fmt, "
"d.timetuple())``\\처럼 작동합니다."

#: ../../library/datetime.rst:2574
#, fuzzy
msgid ""
"For the :meth:`.datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value. [#]_"
msgstr ""
":meth:`datetime.strptime` 클래스 메서드의 경우, 기본값은 "
"``1900-01-01T00:00:00.000``\\입니다: 포맷 문자열에 지정되지 않은 구성 요소는 기본값에서 가져옵니다. "
"[#]_"

#: ../../library/datetime.rst:2578
msgid "Using ``datetime.strptime(date_string, format)`` is equivalent to::"
msgstr "``datetime.strptime(date_string, format)``\\은 다음과 동등합니다::"

#: ../../library/datetime.rst:2582
#, fuzzy
msgid ""
"except when the format includes sub-second components or time zone offset"
" information, which are supported in ``datetime.strptime`` but are "
"discarded by ``time.strptime``."
msgstr ""
"format에 초 미만의 성분이나 시간대 오프셋 정보가 포함된 경우는 예외입니다. 이것들은 "
"``datetime.strptime``\\에서는 지원되지만 ``time.strptime``\\에서는 버려집니다."

#: ../../library/datetime.rst:2586
#, fuzzy
msgid ""
"For :class:`.time` objects, the format codes for year, month, and day "
"should not be used, as :class:`!time` objects have no such values. If "
"they're used anyway, 1900 is substituted for the year, and 1 for the "
"month and day."
msgstr ""
":class:`.time` 객체의 경우, :class:`time` 객체에 해당 값이 없으므로, 연(year), 월(month) 및 "
"일(day)의 포맷 코드는 사용하지 않아야 합니다. 어쨌든 사용되면, ``1900``\\이 해당 연도로, ``1``\\이 해당 월과"
" 일로 대체됩니다."

#: ../../library/datetime.rst:2590
#, fuzzy
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, "
"and microseconds should not be used, as :class:`date` objects have no "
"such values. If they're used anyway, 0 is substituted for them."
msgstr ""
":class:`date` 객체의 경우, :class:`date` 객체에 해당 값이 없으므로, 시(hour), 분(minute), "
"초(second) 및 마이크로초(microsecond)의 포맷 코드는 사용하지 않아야 합니다. 어쨌든 사용되면, ``0``\\으로 "
"대체됩니다."

#: ../../library/datetime.rst:2594
msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved"
" intact in the output, while on others ``strftime`` may raise "
":exc:`UnicodeError` or return an empty string instead."
msgstr ""
"같은 이유로, 현재 로케일의 문자 집합으로는 표현할 수 없는 유니코드 코드 포인트를 포함하는 포맷 문자열의 처리도 플랫폼에 따라 "
"다릅니다. 일부 플랫폼에서는 이러한 코드 포인트가 그대로 출력에 보존되지만, 다른 곳에서는 ``strftime``\\이 "
":exc:`UnicodeError`\\를 발생시키거나 대신 빈 문자열을 반환할 수 있습니다."

#: ../../library/datetime.rst:2603
#, fuzzy
msgid ""
"Because the format depends on the current locale, care should be taken "
"when making assumptions about the output value. Field orderings will vary"
" (for example, \"month/day/year\" versus \"day/month/year\"), and the "
"output may contain non-ASCII characters."
msgstr ""
"포맷이 현재 로케일에 따라 다르므로, 출력값에 대해 가정을 할 때 주의해야 합니다. 필드 순서가 달라지며 (예를 들어, "
"\"월/일/년\" 과 \"일/월/년\"), 출력에는 로케일의 기본 인코딩을 사용하여 인코딩된 유니코드 문자가 포함될 수 있습니다 "
"(예를 들어, 현재 로케일이 ``ja_JP``\\이면, 기본 인코딩은 ``eucJP``, ``SJIS`` 또는 ``utf-8`` 중"
" 하나일 수 있습니다; 현재 로케일의 인코딩을 결정하려면 :meth:`locale.getlocale`\\을 사용하십시오)."

#: ../../library/datetime.rst:2609
#, fuzzy
msgid ""
"The :meth:`~.datetime.strptime` method can parse years in the full [1, "
"9999] range, but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
":meth:`strptime` 메서드는 전체 [1, 9999] 범위에서 연도를 구문 분석할 수 있지만, 1000보다 작은 연도는 "
"4자리 너비가 되도록 0으로 채워야 합니다."

#: ../../library/datetime.rst:2612
#, fuzzy
msgid ""
"In previous versions, :meth:`~.datetime.strftime` method was restricted "
"to years >= 1900."
msgstr "이전 버전에서 :meth:`strftime` 메서드는 1900년 이상으로 제한되었습니다."

#: ../../library/datetime.rst:2616
#, fuzzy
msgid ""
"In version 3.2, :meth:`~.datetime.strftime` method was restricted to "
"years >= 1000."
msgstr "버전 3.2에서, :meth:`strftime` 메서드는 연도를 1000 이상으로 제한했습니다."

#: ../../library/datetime.rst:2621
#, fuzzy
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%p`` "
"directive only affects the output hour field if the ``%I`` directive is "
"used to parse the hour."
msgstr ""
":meth:`strptime` 메서드와 함께 사용할 때, ``%p`` 지시자는 시간을 구문 분석하는 데 ``%I`` 지시문을 사용할"
" 때만 출력 시간 필드에 영향을 줍니다."

#: ../../library/datetime.rst:2625
#, fuzzy
msgid ""
"Unlike the :mod:`time` module, the :mod:`!datetime` module does not "
"support leap seconds."
msgstr ":mod:`time` 모듈과 달리, :mod:`datetime` 모듈은 윤초를 지원하지 않습니다."

#: ../../library/datetime.rst:2629
#, fuzzy, python-format
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%f`` "
"directive accepts from one to six digits and zero pads on the right. "
"``%f`` is an extension to the set of format characters in the C standard "
"(but implemented separately in datetime objects, and therefore always "
"available)."
msgstr ""
":meth:`strptime` 메서드와 함께 사용할 때, ``%f`` 지시자는 하나에서 여섯 자리 숫자와 오른쪽의 0-채움을 "
"받아들입니다. ``%f``\\는 C 표준의 포맷 문자 집합에 대한 확장입니다 (하지만 datetime 객체에서 별도로 구현되므로 "
"항상 사용할 수 있습니다)."

#: ../../library/datetime.rst:2636
#, fuzzy
msgid ""
"For a naive object, the ``%z``, ``%:z`` and ``%Z`` format codes are "
"replaced by empty strings."
msgstr "나이브 객체의 경우, ``%z`` 와 ``%Z`` 포맷 코드는 빈 문자열로 치환됩니다."

#: ../../library/datetime.rst:2639
msgid "For an aware object:"
msgstr "어웨어 객체의 경우:"

#: ../../library/datetime.rst:2642
#, fuzzy
msgid ""
":meth:`~.datetime.utcoffset` is transformed into a string of the form "
"``±HHMM[SS[.ffffff]]``, where ``HH`` is a 2-digit string giving the "
"number of UTC offset hours, ``MM`` is a 2-digit string giving the number "
"of UTC offset minutes, ``SS`` is a 2-digit string giving the number of "
"UTC offset seconds and ``ffffff`` is a 6-digit string giving the number "
"of UTC offset microseconds. The ``ffffff`` part is omitted when the "
"offset is a whole number of seconds and both the ``ffffff`` and the "
"``SS`` part is omitted when the offset is a whole number of minutes. For "
"example, if :meth:`~.datetime.utcoffset` returns ``timedelta(hours=-3, "
"minutes=-30)``, ``%z`` is replaced with the string ``'-0330'``."
msgstr ""
":meth:`utcoffset`\\이 ``±HHMM[SS[.ffffff]]`` 형식의 문자열로 변환됩니다. 여기서 ``HH``\\는"
" UTC 오프셋 시간(hour)의 수를 나타내는 두 자리 숫자 문자열이고, ``MM``\\은 UTC 오프셋 분의 수를 나타내는 두 "
"자리 숫자 문자열이며, ``SS``\\는 UTC 오프셋 초의 수를 나타내는 두 자리 숫자 문자열이며, ``ffffff``\\는 "
"UTC 오프셋 마이크로초의 수를 나타내는 6자리 숫자 문자열입니다. 오프셋이 딱 떨어지는 초면 ``ffffff`` 부분은 생략되며,"
" offset이 딱 떨어지는 분이면 ``ffffff``\\와 ``SS`` 부분이 모두 생략됩니다. 예를 들어, "
":meth:`utcoffset`\\이 ``timedelta(hours=-3, minutes=-30)``\\를 반환하면, "
"``%z``\\는 ``'-0330'`` 문자열로 치환됩니다."

#: ../../library/datetime.rst:2656
#, fuzzy
msgid ""
"When the ``%z`` directive is provided to the  :meth:`~.datetime.strptime`"
" method, the UTC offsets can have a colon as a separator between hours, "
"minutes and seconds. For example, ``'+01:00:00'`` will be parsed as an "
"offset of one hour. In addition, providing ``'Z'`` is identical to "
"``'+00:00'``."
msgstr ""
"``%z`` 지시자가 :meth:`strptime` 메서드에 제공될 때, UTC 오프셋에는 콜론이 시, 분 및 초 사이의 구분 "
"기호로 사용될 수 있습니다. 예를 들어, ``'+01:00:00'``\\은 1시간의 오프셋으로 구문 분석됩니다. 또한, "
"``'Z'``\\를 제공하는 것은 ``'+00:00'``\\과 같습니다."

#: ../../library/datetime.rst:2664
msgid ""
"Behaves exactly as ``%z``, but has a colon separator added between hours,"
" minutes and seconds."
msgstr ""

#: ../../library/datetime.rst:2668
#, fuzzy
msgid ""
"In :meth:`~.datetime.strftime`, ``%Z`` is replaced by an empty string if "
":meth:`~.datetime.tzname` returns ``None``; otherwise ``%Z`` is replaced "
"by the returned value, which must be a string."
msgstr ""
":meth:`strftime`\\에서, :meth:`tzname`\\이 ``None``\\을 반환하면, ``%Z``\\는 빈 "
"문자열로 치환됩니다; 그렇지 않으면 ``%Z``\\는 문자열이어야 하는 반환 값으로 치환됩니다."

#: ../../library/datetime.rst:2672
#, fuzzy
msgid ":meth:`~.datetime.strptime` only accepts certain values for ``%Z``:"
msgstr ":meth:`strptime`\\은 ``%Z``\\에 특정 값만 허용합니다:"

#: ../../library/datetime.rst:2674
msgid "any value in ``time.tzname`` for your machine's locale"
msgstr "컴퓨터의 로케일에 대한 ``time.tzname``\\의 모든 값"

#: ../../library/datetime.rst:2675
msgid "the hard-coded values ``UTC`` and ``GMT``"
msgstr "하드 코딩된 값 ``UTC``\\와 ``GMT``"

#: ../../library/datetime.rst:2677
msgid ""
"So someone living in Japan may have ``JST``, ``UTC``, and ``GMT`` as "
"valid values, but probably not ``EST``. It will raise ``ValueError`` for "
"invalid values."
msgstr ""
"따라서 일본에 거주하는 사람은 ``JST``, ``UTC`` 및 ``GMT``\\를 유효한 값으로 가질 수 있지만, 아마도 "
"``EST``\\는 아닙니다. 유효하지 않은 값에 대해서는 ``ValueError``\\가 발생합니다."

#: ../../library/datetime.rst:2681
#, fuzzy
msgid ""
"When the ``%z`` directive is provided to the :meth:`~.datetime.strptime` "
"method, an aware :class:`.datetime` object will be produced. The "
"``tzinfo`` of the result will be set to a :class:`timezone` instance."
msgstr ""
"``%z`` 지시자가 :meth:`strptime` 메서드에 제공될 때, 어웨어 :class:`.datetime` 객체가 "
"생성됩니다. 결과의 ``tzinfo``\\는 :class:`timezone` 인스턴스로 설정됩니다."

#: ../../library/datetime.rst:2687
#, fuzzy
msgid ""
"When used with the :meth:`~.datetime.strptime` method, ``%U`` and ``%W`` "
"are only used in calculations when the day of the week and the calendar "
"year (``%Y``) are specified."
msgstr ""
":meth:`strptime` 메서드와 함께 사용될 때, ``%U`` 와 ``%W``\\는 요일과 달력 연도(``%Y``)가 "
"지정되었을 때만 계산에 사용됩니다."

#: ../../library/datetime.rst:2692
#, fuzzy, python-format
msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when "
"the day of the week and the ISO year (``%G``) are specified in a "
":meth:`~.datetime.strptime` format string. Also note that ``%G`` and "
"``%Y`` are not interchangeable."
msgstr ""
"``%U`` 와 ``%W``\\와 비슷하게, ``%V``\\는 요일과 ISO 연도(``%G``)가 :meth:`strptime` "
"포맷 문자열에 지정되었을 때만 계산에 사용됩니다. 또한 ``%G``\\와 ``%Y``\\를 상호 교환할 수 없음에 유의하십시오."

#: ../../library/datetime.rst:2698
#, fuzzy, python-format
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the leading zero "
"is optional for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading "
"zero."
msgstr ""
":meth:`strptime` 메서드와 함께 사용할 때, 선행 0은 ``%d``, ``%m``, ``%H``, ``%I``, "
"``%M``, ``%S``, ``%J``, ``%U``, ``%W`` 및 ``%V`` 포맷에서 선택적입니다. 포맷 "
"``%y``\\에는 선행 0이 필요합니다."

#: ../../library/datetime.rst:2703
msgid ""
"When parsing a month and day using :meth:`~.datetime.strptime`, always "
"include a year in the format.  If the value you need to parse lacks a "
"year, append an explicit dummy leap year.  Otherwise your code will raise"
" an exception when it encounters leap day because the default year used "
"by the parser is not a leap year.  Users run into this bug every four "
"years..."
msgstr ""

#: ../../library/datetime.rst:2709
#, python-brace-format, python-format
msgid ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # No leap "
"year bug.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"
msgstr ""

#: ../../library/datetime.rst:2715
msgid ""
":meth:`~.datetime.strptime` calls using a format string containing a day "
"of month without a year now emit a :exc:`DeprecationWarning`. In 3.15 or "
"later we may change this into an error or change the default year to a "
"leap year. See :gh:`70647`."
msgstr ""

#: ../../library/datetime.rst:2722
msgid "Footnotes"
msgstr "각주"

#: ../../library/datetime.rst:2723
msgid "If, that is, we ignore the effects of Relativity"
msgstr "즉, 상대론적 효과를 무시한다면"

#: ../../library/datetime.rst:2725
msgid ""
"This matches the definition of the \"proleptic Gregorian\" calendar in "
"Dershowitz and Reingold's book *Calendrical Calculations*, where it's the"
" base calendar for all computations. See the book for algorithms for "
"converting between proleptic Gregorian ordinals and many other calendar "
"systems."
msgstr ""
"이것은 Dershowitz와 Reingold의 책 *Calendrical Calculations*\\에 나오는 \"역산 "
"그레고리(proleptic Gregorian)\" 달력의 정의와 일치합니다. 이 달력은 모든 계산의 기본 달력입니다. 역산 "
"그레고리력 서수(ordinal)와 다른 많은 달력 시스템 사이의 변환을 위한 알고리즘에 관해서는 이 책을 참조하십시오."

#: ../../library/datetime.rst:2731
#, fuzzy
msgid ""
"See R. H. van Gent's `guide to the mathematics of the ISO 8601 calendar "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm>`_"
" for a good explanation."
msgstr ""
"R. H. van Gent의 `ISO 8601 달력의 수학 지침서 "
"<https://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm>`_\\에"
" 잘 설명되어 있습니다."

#: ../../library/datetime.rst:2735
#, fuzzy, python-format
msgid ""
"Passing ``datetime.strptime('Feb 29', '%b %d')`` will fail since 1900 is "
"not a leap year."
msgstr ""
"``1900``\\이 윤년이 아니므로 ``datetime.strptime('Feb 29', '%b %d')``\\를 전달하는 것은 "
"실패합니다."

#: ../../library/datetime.rst:2376
msgid "% (percent)"
msgstr ""

#: ../../library/datetime.rst:2376
#, fuzzy
msgid "datetime format"
msgstr "``strftime(format)``"

#~ msgid "Attribute"
#~ msgstr "어트리뷰트"

#~ msgid "Value"
#~ msgstr "값"

#~ msgid "``days``"
#~ msgstr "``days``"

#~ msgid "``seconds``"
#~ msgstr "``seconds``"

#~ msgid "``microseconds``"
#~ msgstr "``microseconds``"

#~ msgid ""
#~ "Comparisons of :class:`timedelta` objects are"
#~ " supported, with some caveats."
#~ msgstr ":class:`timedelta` 객체의 비교가 지원되지만, 주의할 점이 있습니다."

#~ msgid ""
#~ "The comparisons ``==`` or ``!=`` "
#~ "*always* return a :class:`bool`, no "
#~ "matter the type of the compared "
#~ "object::"
#~ msgstr "비교 ``==``\\나 ``!=``\\은 비교되는 객체의 형과 관계없이 *항상* :class:`bool`\\을 반환합니다."

#~ msgid ""
#~ "For all other comparisons (such as "
#~ "``<`` and ``>``), when a "
#~ ":class:`timedelta` object is compared to "
#~ "an object of a different type, "
#~ ":exc:`TypeError` is raised::"
#~ msgstr ""
#~ "다른 모든 비교의 경우 (가령 ``<``\\와 ``>``),"
#~ " :class:`timedelta` 객체가 다른 형의 객체와 비교될"
#~ " 때, :exc:`TypeError`\\가 발생합니다."

#~ msgid ""
#~ "In other words, ``date1 < date2`` "
#~ "if and only if ``date1.toordinal() < "
#~ "date2.toordinal()``. Date comparison raises "
#~ ":exc:`TypeError` if the other comparand "
#~ "isn't also a :class:`date` object. "
#~ "However, ``NotImplemented`` is returned "
#~ "instead if the other comparand has "
#~ "a :meth:`timetuple` attribute. This hook "
#~ "gives other kinds of date objects "
#~ "a chance at implementing mixed-type "
#~ "comparison. If not, when a :class:`date`"
#~ " object is compared to an object "
#~ "of a different type, :exc:`TypeError` is"
#~ " raised unless the comparison is "
#~ "``==`` or ``!=``. The latter cases "
#~ "return :const:`False` or :const:`True`, "
#~ "respectively."
#~ msgstr ""
#~ "즉, 오직 ``date1.toordinal() < "
#~ "date2.toordinal()``\\일 때만 ``date1 < "
#~ "date2``\\입니다. 비교 대상이 :class:`date` 객체가 "
#~ "아니면 날짜 비교는 :exc:`TypeError`\\를 발생시킵니다. "
#~ "그러나, 비교 대상에 :meth:`timetuple` 어트리뷰트가 "
#~ "있으면, 대신 ``NotImplemented``\\가 반환됩니다. 이 "
#~ "훅은 다른 형의 날짜 객체가 혼합형 비교를 구현할"
#~ " 기회를 제공합니다. 그렇지 않으면, :class:`date` "
#~ "객체가 다른 형의 객체와 비교될 때, 비교가 "
#~ "``==``\\나 ``!=``\\가 아니면 :exc:`TypeError`\\가 "
#~ "발생합니다. 두 상황에 해당하면 각각 :const:`False` "
#~ "나 :const:`True`\\를 반환합니다"

#~ msgid ""
#~ "Return a date with the same value,"
#~ " except for those parameters given "
#~ "new values by whichever keyword "
#~ "arguments are specified."
#~ msgstr "키워드 인자로 새로운 값이 주어진 매개 변수들을 제외하고, 같은 값을 가진 date를 반환합니다."

#~ msgid "This is the inverse of :meth:`date.fromisoformat`."
#~ msgstr "이것은 :meth:`date.fromisoformat`\\의 역입니다."

#~ msgid "Specifically, this function supports strings in the format:"
#~ msgstr "구체적으로, 이 함수는 다음과 같은 형식의 문자열을 지원합니다:"

#~ msgid ""
#~ "This does *not* support parsing "
#~ "arbitrary ISO 8601 strings - it is"
#~ " only intended as the inverse "
#~ "operation of :meth:`datetime.isoformat`. A "
#~ "more full-featured ISO 8601 parser, "
#~ "``dateutil.parser.isoparse`` is available in "
#~ "the third-party package `dateutil "
#~ "<https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.isoparse>`__."
#~ msgstr ""
#~ "이것은 임의의 ISO 8601 문자열을 구문 분석하는 "
#~ "것을 지원하지 *않습니다* - 이것은 "
#~ ":meth:`datetime.isoformat`\\의 역연산이고자 할 뿐입니다. "
#~ "더욱 완전한 기능을 갖춘 ISO 8601 구문 "
#~ "분석기인 ``dateutil.parser.isoparse``\\는 제삼자 패키지 "
#~ "`dateutil "
#~ "<https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.isoparse>`__\\에서"
#~ " 제공됩니다."

#~ msgid "This is equivalent to::"
#~ msgstr "이것은 다음과 동등합니다::"

#~ msgid "Compares :class:`.datetime` to :class:`.datetime`. (4)"
#~ msgstr ":class:`.datetime`\\과 :class:`.datetime`\\을 비교합니다. (4)"

#~ msgid ""
#~ "If one comparand is naive and the"
#~ " other is aware, :exc:`TypeError` is "
#~ "raised if an order comparison is "
#~ "attempted. For equality comparisons, naive "
#~ "instances are never equal to aware "
#~ "instances."
#~ msgstr ""
#~ "하나의 비교 피연산자가 나이브하고 다른 하나는 어웨어하면,"
#~ " 순서 비교가 시도될 때 :exc:`TypeError`\\가 "
#~ "발생합니다. 동등(equality) 비교에서는, 나이브 인스턴스는 절대"
#~ " 어웨어 인스턴스와 같지 않습니다."

#~ msgid ""
#~ "In order to stop comparison from "
#~ "falling back to the default scheme "
#~ "of comparing object addresses, datetime "
#~ "comparison normally raises :exc:`TypeError` if"
#~ " the other comparand isn't also a "
#~ ":class:`.datetime` object. However, "
#~ "``NotImplemented`` is returned instead if "
#~ "the other comparand has a "
#~ ":meth:`timetuple` attribute. This hook gives"
#~ " other kinds of date objects a "
#~ "chance at implementing mixed-type "
#~ "comparison. If not, when a "
#~ ":class:`.datetime` object is compared to "
#~ "an object of a different type, "
#~ ":exc:`TypeError` is raised unless the "
#~ "comparison is ``==`` or ``!=``. The "
#~ "latter cases return :const:`False` or "
#~ ":const:`True`, respectively."
#~ msgstr ""
#~ "비교가 객체 주소 기반의 기본 비교 체계로 떨어지는"
#~ " 것을 막기 위해, datetime 비교는 다른 비교"
#~ " 피연산자가 :class:`.datetime` 객체가 아니면 일반적으로 "
#~ ":exc:`TypeError`\\를 발생시킵니다. 그러나, 다른 비교 "
#~ "피연산자에 :meth:`timetuple` 어트리뷰트가 있으면 "
#~ "``NotImplemented``\\가 대신 반환됩니다. 이 훅은 다른"
#~ " 형의 날짜 객체에 혼합형 비교를 구현할 기회를 "
#~ "제공합니다. 그렇지 않으면, :class:`.datetime` 객체가 "
#~ "다른 형의 객체와 비교될 때, 비교가 ``==`` "
#~ "나 ``!=``\\가 아니면 :exc:`TypeError`\\가 발생합니다. "
#~ "두 상황에 해당하면 각각 :const:`False` 나 "
#~ ":const:`True`\\를 반환합니다."

#~ msgid "Examples of working with :class:`~datetime.datetime` objects:"
#~ msgstr ":class:`~datetime.datetime` 객체로 작업하는 예제:"

#~ msgid ""
#~ ":class:`.time` objects support comparison of"
#~ " :class:`.time` to :class:`.time`, where "
#~ "*a* is considered less than *b* "
#~ "when *a* precedes *b* in time. If"
#~ " one comparand is naive and the "
#~ "other is aware, :exc:`TypeError` is "
#~ "raised if an order comparison is "
#~ "attempted. For equality comparisons, naive "
#~ "instances are never equal to aware "
#~ "instances."
#~ msgstr ""
#~ ":class:`.time` 객체는 :class:`.time`\\과 "
#~ ":class:`.time`\\의 비교를 지원합니다, 이때 *a*\\가 "
#~ "*b*\\에 앞서면 *a*\\가 *b*\\보다 작은 것으로 "
#~ "간주합니다. 하나의 비교 피연산자가 나이브하고 다른 하나는"
#~ " 어웨어하면, 순서 비교가 시도될 때 "
#~ ":exc:`TypeError`\\가 발생합니다. 동등(equality) 비교에서는, "
#~ "나이브 인스턴스는 절대 어웨어 인스턴스와 같지 않습니다."

#~ msgid ""
#~ "If both comparands are aware, and "
#~ "have the same :attr:`~time.tzinfo` attribute,"
#~ " the common :attr:`~time.tzinfo` attribute "
#~ "is ignored and the base times are"
#~ " compared. If both comparands are "
#~ "aware and have different :attr:`~time.tzinfo`"
#~ " attributes, the comparands are first "
#~ "adjusted by subtracting their UTC "
#~ "offsets (obtained from ``self.utcoffset()``). "
#~ "In order to stop mixed-type "
#~ "comparisons from falling back to the "
#~ "default comparison by object address, "
#~ "when a :class:`.time` object is compared"
#~ " to an object of a different "
#~ "type, :exc:`TypeError` is raised unless "
#~ "the comparison is ``==`` or ``!=``. "
#~ "The latter cases return :const:`False` "
#~ "or :const:`True`, respectively."
#~ msgstr ""
#~ "비교 피연산자가 모두 어웨어하고, 같은 "
#~ ":attr:`~time.tzinfo` 어트리뷰트를 가지면, 공통 "
#~ ":attr:`~time.tzinfo` 어트리뷰트가 무시되고 기본 time이 "
#~ "비교됩니다. 두 비교 피연산자가 모두 어웨어하고 다른 "
#~ ":attr:`~time.tzinfo` 어트리뷰트를 가지면, 비교 피연산자들은 "
#~ "먼저 그들의 UTC 오프셋 (``self.utcoffset()``\\에서 "
#~ "얻습니다)을 뺀 값으로 조정됩니다. 혼합형 비교가 객체 "
#~ "주소 기반의 기본 비교로 떨어지는 것을 막기 위해,"
#~ " :class:`.time` 객체가 다른 형의 객체와 비교될 "
#~ "때, 비교가 ``==`` 이나 ``!=``\\가 아니면 "
#~ ":exc:`TypeError`\\가 발생합니다. 두 상황에 해당하면 각각"
#~ " :const:`False` 나 :const:`True`\\를 반환합니다."

#~ msgid ""
#~ "Equality comparisons between aware and "
#~ "naive :class:`~datetime.time` instances don't "
#~ "raise :exc:`TypeError`."
#~ msgstr ""
#~ "어웨어와 나이브 :class:`~datetime.time` 인스턴스 간의 "
#~ "동등 비교는 :exc:`TypeError`\\를 발생시키지 않습니다."

#~ msgid ""
#~ "Return a :class:`.time` corresponding to "
#~ "a *time_string* in one of the "
#~ "formats emitted by :meth:`time.isoformat`. "
#~ "Specifically, this function supports strings"
#~ " in the format:"
#~ msgstr ""
#~ ":meth:`date.isoformat`\\이 출력하는 형식 중 하나인 "
#~ "*time_string*\\에 해당하는 :class:`.time`\\을 반환합니다. "
#~ "구체적으로, 이 함수는 다음과 같은 형식의 문자열을 "
#~ "지원합니다:"

#~ msgid ""
#~ "This does *not* support parsing "
#~ "arbitrary ISO 8601 strings. It is "
#~ "only intended as the inverse operation"
#~ " of :meth:`time.isoformat`."
#~ msgstr ""
#~ "이것은 임의의 ISO 8601 문자열을 구문 분석하는 "
#~ "것을 지원하지 않습니다. 이것은 :meth:`time.isoformat`\\의"
#~ " 역연산이고자 할 뿐입니다."

#~ msgid "`dateutil.tz <https://dateutil.readthedocs.io/en/stable/tz.html>`_"
#~ msgstr "`dateutil.tz <https://dateutil.readthedocs.io/en/stable/tz.html>`_"

#~ msgid ""
#~ "Week number of the year (Monday as"
#~ " the first day of the week) as"
#~ " a decimal number. All days in "
#~ "a new year preceding the first "
#~ "Monday are considered to be in "
#~ "week 0."
#~ msgstr "연중 주 번호(월요일이 주의 시작)를 십진수로. 첫 번째 월요일에 선행하는 새해의 모든 말은 주 0으로 간주합니다."

