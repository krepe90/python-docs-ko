# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/doctest.rst:2
#, fuzzy
msgid ":mod:`!doctest` --- Test interactive Python examples"
msgstr ":mod:`doctest` --- 대화형 파이썬 예제 테스트"

#: ../../library/doctest.rst:12
msgid "**Source code:** :source:`Lib/doctest.py`"
msgstr "**소스 코드:** :source:`Lib/doctest.py`"

#: ../../library/doctest.rst:16
msgid ""
"The :mod:`doctest` module searches for pieces of text that look like "
"interactive Python sessions, and then executes those sessions to verify "
"that they work exactly as shown.  There are several common ways to use "
"doctest:"
msgstr ""
":mod:`doctest` 모듈은 대화형 파이썬 세션처럼 보이는 텍스트를 검색한 다음, 해당 세션을 실행하여 표시된 대로 정확하게 "
"작동하는지 검증합니다. doctest를 사용하는 몇 가지 일반적인 방법이 있습니다:"

#: ../../library/doctest.rst:20
msgid ""
"To check that a module's docstrings are up-to-date by verifying that all "
"interactive examples still work as documented."
msgstr "모든 대화식 예제가 설명된 대로 작동하는지 확인하여 모듈의 독스트링이 최신인지 확인합니다."

#: ../../library/doctest.rst:23
msgid ""
"To perform regression testing by verifying that interactive examples from"
" a test file or a test object work as expected."
msgstr "테스트 파일이나 테스트 객체의 대화형 예제가 예상대로 작동하는지 확인하여 회귀 테스트를 수행합니다."

#: ../../library/doctest.rst:26
msgid ""
"To write tutorial documentation for a package, liberally illustrated with"
" input-output examples.  Depending on whether the examples or the "
"expository text are emphasized, this has the flavor of \"literate "
"testing\" or \"executable documentation\"."
msgstr ""
"입/출력 예제를 그대로 보여줌으로써 패키지에 대한 자습서를 작성합니다. 예제나 설명문 중 어느 것이 강조되는지에 따라, \"문학적 "
"테스트(literate testing)\"나 \"실행 가능한 설명서(executable documentation)\"의 느낌을 "
"줍니다."

#: ../../library/doctest.rst:31
msgid "Here's a complete but small example module::"
msgstr "여기에 완전하지만 작은 예제 모듈이 있습니다::"

#: ../../library/doctest.rst:33
msgid ""
"\"\"\"\n"
"This is the \"example\" module.\n"
"\n"
"The example module supplies one function, factorial().  For example,\n"
"\n"
">>> factorial(5)\n"
"120\n"
"\"\"\"\n"
"\n"
"def factorial(n):\n"
"    \"\"\"Return the factorial of n, an exact integer >= 0.\n"
"\n"
"    >>> [factorial(n) for n in range(6)]\n"
"    [1, 1, 2, 6, 24, 120]\n"
"    >>> factorial(30)\n"
"    265252859812191058636308480000000\n"
"    >>> factorial(-1)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    ValueError: n must be >= 0\n"
"\n"
"    Factorials of floats are OK, but the float must be an exact integer:\n"
"    >>> factorial(30.1)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    ValueError: n must be exact integer\n"
"    >>> factorial(30.0)\n"
"    265252859812191058636308480000000\n"
"\n"
"    It must also not be ridiculously large:\n"
"    >>> factorial(1e100)\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    OverflowError: n too large\n"
"    \"\"\"\n"
"\n"
"    import math\n"
"    if not n >= 0:\n"
"        raise ValueError(\"n must be >= 0\")\n"
"    if math.floor(n) != n:\n"
"        raise ValueError(\"n must be exact integer\")\n"
"    if n+1 == n:  # catch a value like 1e300\n"
"        raise OverflowError(\"n too large\")\n"
"    result = 1\n"
"    factor = 2\n"
"    while factor <= n:\n"
"        result *= factor\n"
"        factor += 1\n"
"    return result\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    import doctest\n"
"    doctest.testmod()"
msgstr ""

#: ../../library/doctest.rst:88
msgid ""
"If you run :file:`example.py` directly from the command line, "
":mod:`doctest` works its magic:"
msgstr ":file:`example.py`\\를 명령 줄에서 직접 실행하면, :mod:`doctest`\\가 마술을 부리기 시작합니다:"

#: ../../library/doctest.rst:91
msgid ""
"$ python example.py\n"
"$"
msgstr ""

#: ../../library/doctest.rst:96
msgid ""
"There's no output!  That's normal, and it means all the examples worked."
"  Pass ``-v`` to the script, and :mod:`doctest` prints a detailed log of "
"what it's trying, and prints a summary at the end:"
msgstr ""
"출력이 없습니다! 이것이 정상이며, 모든 예제가 작동했다는 것을 뜻합니다. ``-v``\\를 스크립트에 전달하면, "
":mod:`doctest`\\는 시도하고 있는 내용에 대한 자세한 로그를 출력하고 끝에 요약을 인쇄합니다.:"

#: ../../library/doctest.rst:100
msgid ""
"$ python example.py -v\n"
"Trying:\n"
"    factorial(5)\n"
"Expecting:\n"
"    120\n"
"ok\n"
"Trying:\n"
"    [factorial(n) for n in range(6)]\n"
"Expecting:\n"
"    [1, 1, 2, 6, 24, 120]\n"
"ok"
msgstr ""

#: ../../library/doctest.rst:114
msgid "And so on, eventually ending with:"
msgstr "결국, 다음과 같이 끝납니다:"

#: ../../library/doctest.rst:116
msgid ""
"Trying:\n"
"    factorial(1e100)\n"
"Expecting:\n"
"    Traceback (most recent call last):\n"
"        ...\n"
"    OverflowError: n too large\n"
"ok\n"
"2 items passed all tests:\n"
"   1 test in __main__\n"
"   6 tests in __main__.factorial\n"
"7 tests in 2 items.\n"
"7 passed.\n"
"Test passed.\n"
"$"
msgstr ""

#: ../../library/doctest.rst:133
#, fuzzy
msgid ""
"That's all you need to know to start making productive use of "
":mod:`doctest`! Jump in.  The following sections provide full details.  "
"Note that there are many examples of doctests in the standard Python test"
" suite and libraries. Especially useful examples can be found in the "
"standard test file :file:`Lib/test/test_doctest/test_doctest.py`."
msgstr ""
"이것이 :mod:`doctest`\\를 생산적으로 사용하기 위해서 알아야 할 모든 것입니다! 시도해 보세요. 다음 절에서는 자세한 "
"내용을 제공합니다. 표준 파이썬 테스트 스위트와 라이브러리에는 doctest 예제가 많습니다. 특히 유용한 예제는 표준 테스트 파일"
" :file:`Lib/test/test_doctest.py`\\에서 찾을 수 있습니다."

#: ../../library/doctest.rst:143
msgid "Simple Usage: Checking Examples in Docstrings"
msgstr "간단한 사용법: 독스트링에 있는 예제 확인하기"

#: ../../library/doctest.rst:145
#, fuzzy
msgid ""
"The simplest way to start using doctest (but not necessarily the way "
"you'll continue to do it) is to end each module :mod:`!M` with::"
msgstr ""
"doctest를 사용하는 가장 간단한 방법은 (하지만 계속 이렇게 할 필요는 없습니다) 각 모듈 :mod:`M`\\을 다음과 같이 "
"끝내는 것입니다::"

#: ../../library/doctest.rst:148
msgid ""
"if __name__ == \"__main__\":\n"
"    import doctest\n"
"    doctest.testmod()"
msgstr ""

#: ../../library/doctest.rst:152
#, fuzzy
msgid ":mod:`!doctest` then examines docstrings in module :mod:`!M`."
msgstr "그러면 :mod:`doctest`\\는 모듈 :mod:`M`\\의 독스트링을 검사합니다."

#: ../../library/doctest.rst:154
msgid ""
"Running the module as a script causes the examples in the docstrings to "
"get executed and verified::"
msgstr "모듈을 스크립트로 실행하면 독스트링의 예제가 실행되고 검증됩니다::"

#: ../../library/doctest.rst:157
msgid "python M.py"
msgstr ""

#: ../../library/doctest.rst:159
msgid ""
"This won't display anything unless an example fails, in which case the "
"failing example(s) and the cause(s) of the failure(s) are printed to "
"stdout, and the final line of output is ``***Test Failed*** N "
"failures.``, where *N* is the number of examples that failed."
msgstr ""
"예제가 실패하지 않는 한 아무것도 표시되지 않습니다, 실패하면 실패한 예제와 실패 원인이 stdout으로 출력되고, 마지막 출력 "
"줄은 ``***Test Failed*** N failures.``\\입니다. 여기서 *N*\\은 실패한 예제의 수입니다."

#: ../../library/doctest.rst:164
msgid "Run it with the ``-v`` switch instead::"
msgstr "대신 ``-v`` 스위치로 실행해 보십시오::"

#: ../../library/doctest.rst:166
msgid "python M.py -v"
msgstr ""

#: ../../library/doctest.rst:168
msgid ""
"and a detailed report of all examples tried is printed to standard "
"output, along with assorted summaries at the end."
msgstr "그러면 시도한 모든 예제에 대한 자세한 보고서가 표준 출력으로 출력되고, 끝에 정돈된 요약이 붙습니다."

#: ../../library/doctest.rst:171
msgid ""
"You can force verbose mode by passing ``verbose=True`` to "
":func:`testmod`, or prohibit it by passing ``verbose=False``.  In either "
"of those cases, ``sys.argv`` is not examined by :func:`testmod` (so "
"passing ``-v`` or not has no effect)."
msgstr ""
"``verbose=True``\\를 :func:`testmod`\\에 전달하여 상세 모드를 강제하거나, "
"``verbose=False``\\를 전달하여 상세 모드를 금지할 수 있습니다. 두 경우 모두, ``sys.argv``\\는 "
":func:`testmod`\\에 의해 검사되지 않습니다 (따라서 ``-v``\\를 전달하거나 그렇지 않아도 효과가 없습니다)."

#: ../../library/doctest.rst:176
#, fuzzy
msgid ""
"There is also a command line shortcut for running :func:`testmod`, see "
"section :ref:`doctest-cli`."
msgstr ":func:`testmod`\\에 대한 자세한 내용은, :ref:`doctest-basic-api` 절을 참조하십시오."

#: ../../library/doctest.rst:179
msgid ""
"For more information on :func:`testmod`, see section :ref:`doctest-basic-"
"api`."
msgstr ":func:`testmod`\\에 대한 자세한 내용은, :ref:`doctest-basic-api` 절을 참조하십시오."

#: ../../library/doctest.rst:185
msgid "Simple Usage: Checking Examples in a Text File"
msgstr "간단한 사용법: 텍스트 파일에 있는 예제 확인하기"

#: ../../library/doctest.rst:187
msgid ""
"Another simple application of doctest is testing interactive examples in "
"a text file.  This can be done with the :func:`testfile` function::"
msgstr ""
"doctest의 또 다른 간단한 활용은 텍스트 파일에 있는 대화형 예제를 테스트하는 것입니다. 이것은 :func:`testfile`"
" 함수로 수행할 수 있습니다::"

#: ../../library/doctest.rst:190
msgid ""
"import doctest\n"
"doctest.testfile(\"example.txt\")"
msgstr ""

#: ../../library/doctest.rst:193
msgid ""
"That short script executes and verifies any interactive Python examples "
"contained in the file :file:`example.txt`.  The file content is treated "
"as if it were a single giant docstring; the file doesn't need to contain "
"a Python program!   For example, perhaps :file:`example.txt` contains "
"this:"
msgstr ""
"이 짧은 스크립트는 :file:`example.txt` 파일에 들어있는 대화형 파이썬 예제를 실행하고 검증합니다. 파일 내용은 "
"하나의 거대한 독스트링인 것처럼 취급됩니다; 파일이 파이썬 프로그램일 필요가 없습니다! 예를 들어, "
":file:`example.txt`\\에 다음과 같은 것이 들어있습니다:"

#: ../../library/doctest.rst:198
msgid ""
"The ``example`` module\n"
"======================\n"
"\n"
"Using ``factorial``\n"
"-------------------\n"
"\n"
"This is an example text file in reStructuredText format.  First import\n"
"``factorial`` from the ``example`` module:\n"
"\n"
"    >>> from example import factorial\n"
"\n"
"Now use it:\n"
"\n"
"    >>> factorial(6)\n"
"    120"
msgstr ""

#: ../../library/doctest.rst:216
msgid ""
"Running ``doctest.testfile(\"example.txt\")`` then finds the error in "
"this documentation::"
msgstr "``doctest.testfile(\"example.txt\")``\\를 실행하면 이 문서에 있는 에러를 찾습니다::"

#: ../../library/doctest.rst:219
msgid ""
"File \"./example.txt\", line 14, in example.txt\n"
"Failed example:\n"
"    factorial(6)\n"
"Expected:\n"
"    120\n"
"Got:\n"
"    720"
msgstr ""

#: ../../library/doctest.rst:227
msgid ""
"As with :func:`testmod`, :func:`testfile` won't display anything unless "
"an example fails.  If an example does fail, then the failing example(s) "
"and the cause(s) of the failure(s) are printed to stdout, using the same "
"format as :func:`testmod`."
msgstr ""
":func:`testmod`\\와 마찬가지로, :func:`testfile`\\은 예제가 실패하지 않는 한 아무것도 표시하지 "
"않습니다. 예제가 실패하면, 실패한 예제와 실패 원인이 :func:`testmod`\\와 같은 형식을 사용하여 stdout에 "
"인쇄됩니다."

#: ../../library/doctest.rst:232
msgid ""
"By default, :func:`testfile` looks for files in the calling module's "
"directory. See section :ref:`doctest-basic-api` for a description of the "
"optional arguments that can be used to tell it to look for files in other"
" locations."
msgstr ""
"기본적으로, :func:`testfile`\\은 호출하는 모듈의 디렉터리에서 파일을 찾습니다. 다른 위치에서 파일을 찾도록 지시하는"
" 데 사용할 수 있는 선택적 인자에 대한 설명은 :ref:`doctest-basic-api` 절을 참조하십시오."

#: ../../library/doctest.rst:236
msgid ""
"Like :func:`testmod`, :func:`testfile`'s verbosity can be set with the "
"``-v`` command-line switch or with the optional keyword argument "
"*verbose*."
msgstr ""
":func:`testmod`\\와 마찬가지로, :func:`testfile`\\의 상세도는 ``-v`` 명령 줄 스위치나 선택적 "
"키워드 인자 *verbose*\\를 사용하여 설정할 수 있습니다."

#: ../../library/doctest.rst:240
#, fuzzy
msgid ""
"There is also a command line shortcut for running :func:`testfile`, see "
"section :ref:`doctest-cli`."
msgstr ":func:`testfile`\\에 대한 자세한 내용은, :ref:`doctest-basic-api` 절을 참조하십시오."

#: ../../library/doctest.rst:243
msgid ""
"For more information on :func:`testfile`, see section :ref:`doctest-"
"basic-api`."
msgstr ":func:`testfile`\\에 대한 자세한 내용은, :ref:`doctest-basic-api` 절을 참조하십시오."

#: ../../library/doctest.rst:249
msgid "Command-line Usage"
msgstr ""

#: ../../library/doctest.rst:251
msgid ""
"The :mod:`doctest` module can be invoked as a script from the command "
"line:"
msgstr ""

#: ../../library/doctest.rst:253
msgid "python -m doctest [-v] [-o OPTION] [-f] file [file ...]"
msgstr ""

#: ../../library/doctest.rst:261
#, fuzzy
msgid ""
"Detailed report of all examples tried is printed to standard output, "
"along with assorted summaries at the end::"
msgstr "그러면 시도한 모든 예제에 대한 자세한 보고서가 표준 출력으로 출력되고, 끝에 정돈된 요약이 붙습니다."

#: ../../library/doctest.rst:264
msgid "python -m doctest -v example.py"
msgstr ""

#: ../../library/doctest.rst:266
#, fuzzy
msgid ""
"This will import :file:`example.py` as a standalone module and run "
":func:`testmod` on it. Note that this may not work correctly if the file "
"is part of a package and imports other submodules from that package."
msgstr ""
"이렇게 하면 :file:`example.py`\\를 독립 실행형 모듈로 임포트하고, :func:`testmod`\\를 실행합니다. "
"파일이 패키지 일부이고 그 패키지에서 다른 서브 모듈을 임포트하면, 올바르게 작동하지 않을 수 있음에 유의하십시오."

#: ../../library/doctest.rst:270
#, fuzzy
msgid ""
"If the file name does not end with :file:`.py`, :mod:`!doctest` infers "
"that it must be run with :func:`testfile` instead::"
msgstr ""
"파일 이름은 :file:`.py`\\로 끝나지 않으므로, :mod:`doctest`\\는 :func:`testmod`\\가 아니라 "
":func:`testfile`\\로 실행되어야 한다고 추론합니다."

#: ../../library/doctest.rst:273
msgid "python -m doctest -v example.txt"
msgstr ""

#: ../../library/doctest.rst:277
msgid ""
"Option flags control various aspects of doctest's behavior, see section "
":ref:`doctest-options`."
msgstr ""

#: ../../library/doctest.rst:284
#, fuzzy
msgid "This is shorthand for ``-o FAIL_FAST``."
msgstr "doctest 명령 줄은 옵션 ``-f``\\를 ``-o FAIL_FAST``\\의 축약으로 받아들입니다."

#: ../../library/doctest.rst:292
msgid "How It Works"
msgstr "작동 방법"

#: ../../library/doctest.rst:294
msgid ""
"This section examines in detail how doctest works: which docstrings it "
"looks at, how it finds interactive examples, what execution context it "
"uses, how it handles exceptions, and how option flags can be used to "
"control its behavior. This is the information that you need to know to "
"write doctest examples; for information about actually running doctest on"
" these examples, see the following sections."
msgstr ""
"이 절에서는 doctest가 어떻게 작동하는지 자세히 설명합니다: 어떤 독스트링을 살피는지, 대화형 예제를 어떻게 찾는지, 사용하는"
" 실행 컨텍스트는 무엇인지, 예외를 어떻게 처리하는지, 어떻게 옵션 플래그를 사용하여 동작을 제어하는지. 이것은 doctest "
"예제를 작성하기 위해 알아야 할 정보입니다; 이러한 예제에 대해 실제로 doctest를 실행하는 방법에 대한 자세한 내용은 다음 "
"절을 참조하십시오."

#: ../../library/doctest.rst:305
msgid "Which Docstrings Are Examined?"
msgstr "어떤 독스트링을 검사합니까?"

#: ../../library/doctest.rst:307
msgid ""
"The module docstring, and all function, class and method docstrings are "
"searched.  Objects imported into the module are not searched."
msgstr "모듈 독스트링과 모든 함수, 클래스 및 메서드 독스트링이 검색됩니다. 모듈로 임포트 된 객체는 검색되지 않습니다."

#: ../../library/doctest.rst:310
#, fuzzy
msgid ""
"In addition, there are cases when you want tests to be part of a module "
"but not part of the help text, which requires that the tests not be "
"included in the docstring. Doctest looks for a module-level variable "
"called ``__test__`` and uses it to locate other tests. If ``M.__test__`` "
"exists, it must be a dict, and each entry maps a (string) name to a "
"function object, class object, or string. Function and class object "
"docstrings found from ``M.__test__`` are searched, and strings are "
"treated as if they were docstrings.  In output, a key ``K`` in "
"``M.__test__`` appears with name ``M.__test__.K``."
msgstr ""
"또한, ``M.__test__``\\가 존재하고 \"참이면\", 딕셔너리이어야 하고 각 항목은 (문자열) 이름을 함수 객체, 클래스"
" 객체 또는 문자열에 매핑합니다. ``M.__test__``\\에서 발견된 함수와 클래스 객체 독스트링이 검색되고, 문자열은 "
"독스트링인 것처럼 처리됩니다. 출력에서, ``M.__test__``\\의 키 ``K``\\가 이름으로 나타납니다 ::"

#: ../../library/doctest.rst:319
msgid "For example, place this block of code at the top of :file:`example.py`:"
msgstr ""

#: ../../library/doctest.rst:321
#, python-brace-format
msgid ""
"__test__ = {\n"
"    'numbers': \"\"\"\n"
">>> factorial(6)\n"
"720\n"
"\n"
">>> [factorial(n) for n in range(6)]\n"
"[1, 1, 2, 6, 24, 120]\n"
"\"\"\"\n"
"}"
msgstr ""

#: ../../library/doctest.rst:333
msgid ""
"The value of ``example.__test__[\"numbers\"]`` will be treated as a "
"docstring and all the tests inside it will be run. It is important to "
"note that the value can be mapped to a function, class object, or module;"
" if so, :mod:`!doctest` searches them recursively for docstrings, which "
"are then scanned for tests."
msgstr ""

#: ../../library/doctest.rst:339
msgid ""
"Any classes found are recursively searched similarly, to test docstrings "
"in their contained methods and nested classes."
msgstr "발견된 모든 클래스는 포함된 메서드와 중첩된 클래스의 독스트링을 테스트하기 위해 유사하게 재귀적으로 검색됩니다."

#: ../../library/doctest.rst:346
msgid "How are Docstring Examples Recognized?"
msgstr "독스트링 예제는 어떻게 인식됩니까?"

#: ../../library/doctest.rst:348
msgid ""
"In most cases a copy-and-paste of an interactive console session works "
"fine, but doctest isn't trying to do an exact emulation of any specific "
"Python shell."
msgstr ""
"대부분 대화형 콘솔 세션의 복사하여 붙여넣기가 잘 작동하지만, doctest는 특정 파이썬 셸의 정확한 에뮬레이션을 시도하지 "
"않습니다."

#: ../../library/doctest.rst:353
msgid ""
">>> # comments are ignored\n"
">>> x = 12\n"
">>> x\n"
"12\n"
">>> if x == 13:\n"
"...     print(\"yes\")\n"
"... else:\n"
"...     print(\"no\")\n"
"...     print(\"NO\")\n"
"...     print(\"NO!!!\")\n"
"...\n"
"no\n"
"NO\n"
"NO!!!\n"
">>>"
msgstr ""

#: ../../library/doctest.rst:373
msgid ""
"Any expected output must immediately follow the final ``'>>> '`` or "
"``'... '`` line containing the code, and the expected output (if any) "
"extends to the next ``'>>> '`` or all-whitespace line."
msgstr ""
"모든 예상 출력은 코드가 포함된 마지막 ``'>>> '`` 또는 ``'... '`` 줄 바로 다음에 나와야 하며, (있다면) 예상 "
"출력은 다음 ``'>>> '`` 나 전체 공백 줄까지 확장됩니다."

#: ../../library/doctest.rst:377
msgid "The fine print:"
msgstr "세부 사항:"

#: ../../library/doctest.rst:379
msgid ""
"Expected output cannot contain an all-whitespace line, since such a line "
"is taken to signal the end of expected output.  If expected output does "
"contain a blank line, put ``<BLANKLINE>`` in your doctest example each "
"place a blank line is expected."
msgstr ""
"예상 출력은 전체 공백 줄을 포함할 수 없습니다. 그러한 줄은 예상 출력의 끝으로 인식되기 때문입니다. 예상 출력이 빈 줄을 "
"포함하면, doctest 예제에서 빈 줄이 나타나는 곳에 ``<BLANKLINE>``\\을 넣으십시오."

#: ../../library/doctest.rst:384
msgid ""
"All hard tab characters are expanded to spaces, using 8-column tab stops."
" Tabs in output generated by the tested code are not modified.  Because "
"any hard tabs in the sample output *are* expanded, this means that if the"
" code output includes hard tabs, the only way the doctest can pass is if "
"the :const:`NORMALIZE_WHITESPACE` option or :ref:`directive <doctest-"
"directives>` is in effect. Alternatively, the test can be rewritten to "
"capture the output and compare it to an expected value as part of the "
"test.  This handling of tabs in the source was arrived at through trial "
"and error, and has proven to be the least error prone way of handling "
"them.  It is possible to use a different algorithm for handling tabs by "
"writing a custom :class:`DocTestParser` class."
msgstr ""
"모든 하드 탭 문자는 8열 탭 정지를 사용하여 스페이스로 확장됩니다. 테스트 된 코드에 의해 생성된 출력의 탭은 수정되지 않습니다."
" 샘플 출력의 모든 하드 탭이 *확장되므로*, 이것은 코드 출력에 하드 탭이 포함될 때 doctest가 통과할 수 있는 유일한 "
"방법은, :const:`NORMALIZE_WHITESPACE` 옵션이나 :ref:`지시자 <doctest-"
"directives>`\\가 유효한 경우뿐임을 의미합니다. 또는, 출력을 캡처하여 테스트 일부로 예상값과 비교하도록 테스트를 다시 "
"작성할 수 있습니다. 이러한 소스의 탭 처리는 시행착오를 거쳐 얻어진 것이며, 가장 에러가 발생하지 않는 방법으로 입증되었습니다. "
"사용자 정의 :class:`DocTestParser` 클래스를 작성하여 탭 처리에 다른 알고리즘을 사용하는 것도 가능합니다."

#: ../../library/doctest.rst:396
msgid ""
"Output to stdout is captured, but not output to stderr (exception "
"tracebacks are captured via a different means)."
msgstr "stdout으로의 출력은 캡처되지만, stderr로의 출력은 그렇지 않습니다 (예외 트레이스백은 다른 수단을 통해 캡처됩니다)."

#: ../../library/doctest.rst:399
msgid ""
"If you continue a line via backslashing in an interactive session, or for"
" any other reason use a backslash, you should use a raw docstring, which "
"will preserve your backslashes exactly as you type them::"
msgstr ""
"대화식 세션에서 역 슬래시를 통해 줄을 계속하거나, 다른 이유로 백 슬래시를 사용하면, 날 독스트링(raw docstring)을 "
"사용해서 역 슬래시를 입력한 그대로 유지해야 합니다::"

#: ../../library/doctest.rst:403
msgid ""
">>> def f(x):\n"
"...     r'''Backslashes in a raw docstring: m\\n'''\n"
"...\n"
">>> print(f.__doc__)\n"
"Backslashes in a raw docstring: m\\n"
msgstr ""

#: ../../library/doctest.rst:409
msgid ""
"Otherwise, the backslash will be interpreted as part of the string. For "
"example, the ``\\n`` above would be interpreted as a newline character.  "
"Alternatively, you can double each backslash in the doctest version (and "
"not use a raw string)::"
msgstr ""
"그렇지 않으면, 백 슬래시가 문자열 일부로 해석됩니다. 예를 들어, 위의 ``\\n``\\은 개행 문자로 해석됩니다. 또는, "
"doctest 버전에서 각 백 슬래시를 중복시킬 수 있습니다 (그리고 날 문자열은 사용하지 않습니다)::"

#: ../../library/doctest.rst:413
msgid ""
">>> def f(x):\n"
"...     '''Backslashes in a raw docstring: m\\\\n'''\n"
"...\n"
">>> print(f.__doc__)\n"
"Backslashes in a raw docstring: m\\n"
msgstr ""

#: ../../library/doctest.rst:419
msgid "The starting column doesn't matter::"
msgstr "시작 열은 중요하지 않습니다::"

#: ../../library/doctest.rst:421
msgid ""
">>> assert \"Easy!\"\n"
"      >>> import math\n"
"          >>> math.floor(1.9)\n"
"          1"
msgstr ""

#: ../../library/doctest.rst:426
msgid ""
"and as many leading whitespace characters are stripped from the expected "
"output as appeared in the initial ``'>>> '`` line that started the "
"example."
msgstr "그리고 예제를 시작한 초기 ``'>>> '`` 줄에 나타나는 것만큼의 선행 공백을 예상 출력에서 제거합니다."

#: ../../library/doctest.rst:433
msgid "What's the Execution Context?"
msgstr "실행 컨텍스트란 무엇입니까?"

#: ../../library/doctest.rst:435
#, fuzzy
msgid ""
"By default, each time :mod:`doctest` finds a docstring to test, it uses a"
" *shallow copy* of :mod:`!M`'s globals, so that running tests doesn't "
"change the module's real globals, and so that one test in :mod:`!M` can't"
" leave behind crumbs that accidentally allow another test to work.  This "
"means examples can freely use any names defined at top-level in "
":mod:`!M`, and names defined earlier in the docstring being run. Examples"
" cannot see names defined in other docstrings."
msgstr ""
"기본적으로, :mod:`doctest`\\가 테스트할 독스트링을 찾을 때마다, :mod:`M`\\의 전역 이름 "
"공간(globals)의 *앝은 복사*\\를 사용하므로, 실행 중인 테스트는 모듈의 실제 전역을 변경하지 않고, :mod:`M`\\의"
" 한 테스트가 실수로 다른 테스트가 작동하도록 만드는 부스러기를 남기지 않습니다. 이는 예제가 :mod:`M`\\에서 최상위 수준에"
" 정의된 이름과 실행 중인 독스트링에서 앞서 정의한 이름을 자유롭게 사용할 수 있음을 의미합니다. 예제는 다른 독스트링에 정의된 "
"이름을 볼 수 없습니다."

#: ../../library/doctest.rst:443
msgid ""
"You can force use of your own dict as the execution context by passing "
"``globs=your_dict`` to :func:`testmod` or :func:`testfile` instead."
msgstr ""
"대신 ``globs=your_dict``\\를 :func:`testmod`\\나 :func:`testfile`\\로 전달하여 실행 "
"컨텍스트로 여러분 자신의 딕셔너리를 사용하도록 할 수 있습니다."

#: ../../library/doctest.rst:450
msgid "What About Exceptions?"
msgstr "예외는 어떻게 됩니까?"

#: ../../library/doctest.rst:452
msgid ""
"No problem, provided that the traceback is the only output produced by "
"the example:  just paste in the traceback. [#]_ Since tracebacks contain "
"details that are likely to change rapidly (for example, exact file paths "
"and line numbers), this is one case where doctest works hard to be "
"flexible in what it accepts."
msgstr ""
"문제없습니다, 트레이스백이 예제에 의해 생성된 유일한 출력이기만 하면 됩니다: 그냥 트레이스백을 붙여넣으십시오. [#]_ "
"트레이스백에는 빠르게 변할 가능성이 있는 세부 사항(예를 들어, 정확한 파일 경로와 줄 번호)이 포함되어 있으므로, 이것은 "
"doctest가 수락할 내용에 유연하도록 신경 써야 하는 한 가지 사례입니다."

#: ../../library/doctest.rst:458
msgid "Simple example::"
msgstr "간단한 예::"

#: ../../library/doctest.rst:460
msgid ""
">>> [1, 2, 3].remove(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: list.remove(x): x not in list"
msgstr ""

#: ../../library/doctest.rst:465
msgid ""
"That doctest succeeds if :exc:`ValueError` is raised, with the "
"``list.remove(x): x not in list`` detail as shown."
msgstr ""
"이 doctest는 ``list.remove(x): x not in list`` 세부 정보를 포함하는 "
":exc:`ValueError`\\가 발생하면 성공합니다."

#: ../../library/doctest.rst:468
msgid ""
"The expected output for an exception must start with a traceback header, "
"which may be either of the following two lines, indented the same as the "
"first line of the example::"
msgstr "예외의 예상 출력은 다음 두 줄 중 한 가지가 예제의 첫 번째 줄과 같게 들여쓰기 된 트레이스백 헤더로 시작해야 합니다::"

#: ../../library/doctest.rst:472
msgid ""
"Traceback (most recent call last):\n"
"Traceback (innermost last):"
msgstr ""

#: ../../library/doctest.rst:475
msgid ""
"The traceback header is followed by an optional traceback stack, whose "
"contents are ignored by doctest.  The traceback stack is typically "
"omitted, or copied verbatim from an interactive session."
msgstr ""
"트레이스백 헤더 다음에는 선택적인 트레이스백 스택이 오며, 그 내용은 doctest가 무시합니다. 보통 트레이스백 스택은 "
"생략되거나, 대화형 세션에서 그대로 복사됩니다."

#: ../../library/doctest.rst:479
msgid ""
"The traceback stack is followed by the most interesting part: the line(s)"
" containing the exception type and detail.  This is usually the last line"
" of a traceback, but can extend across multiple lines if the exception "
"has a multi-line detail::"
msgstr ""
"트레이스백 스택 다음에는 가장 흥미로운 부분이 옵니다: 예외 형과 세부 사항이 있는 줄. 대개 이것은 트레이스백의 마지막 줄이지만,"
" 예외에 여러 줄로 구성된 세부 사항이 있으면 여러 줄로 확장될 수 있습니다::"

#: ../../library/doctest.rst:484
msgid ""
">>> raise ValueError('multi\\n    line\\ndetail')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: multi\n"
"    line\n"
"detail"
msgstr ""

#: ../../library/doctest.rst:491
msgid ""
"The last three lines (starting with :exc:`ValueError`) are compared "
"against the exception's type and detail, and the rest are ignored."
msgstr "(:exc:`ValueError`\\로 시작하는) 마지막 세 줄이 예외의 형 및 세부 사항과 비교되고, 나머지는 무시됩니다."

#: ../../library/doctest.rst:494
msgid ""
"Best practice is to omit the traceback stack, unless it adds significant "
"documentation value to the example.  So the last example is probably "
"better as::"
msgstr ""
"모범 사례는 예제에 중요한 설명으로서의 가치를 추가하지 않는 한 트레이스백 스택을 생략하는 것입니다. 따라서 마지막 예제는 이렇게 "
"하는 것이 더 좋습니다::"

#: ../../library/doctest.rst:497
msgid ""
">>> raise ValueError('multi\\n    line\\ndetail')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: multi\n"
"    line\n"
"detail"
msgstr ""

#: ../../library/doctest.rst:504
msgid ""
"Note that tracebacks are treated very specially.  In particular, in the "
"rewritten example, the use of ``...`` is independent of doctest's "
":const:`ELLIPSIS` option.  The ellipsis in that example could be left "
"out, or could just as well be three (or three hundred) commas or digits, "
"or an indented transcript of a Monty Python skit."
msgstr ""
"트레이스백이 매우 특별하게 취급된다는 점에 유의하십시오. 특히, 다시 작성된 예제에서, ``...``\\의 사용은 doctest의 "
":const:`ELLIPSIS` 옵션과 무관합니다. 이 예제의 줄임표는 생략하거나, 3개(혹은 300개)의 쉼표나 숫자 또는 몬티 "
"파이썬 쇼의 들여쓰기 된 대본이어도 똑같이 잘 동작합니다."

#: ../../library/doctest.rst:510
msgid "Some details you should read once, but won't need to remember:"
msgstr "한 번쯤 읽어야 할 세부 정보이지만, 기억할 필요는 없습니다:"

#: ../../library/doctest.rst:512
msgid ""
"Doctest can't guess whether your expected output came from an exception "
"traceback or from ordinary printing.  So, e.g., an example that expects "
"``ValueError: 42 is prime`` will pass whether :exc:`ValueError` is "
"actually raised or if the example merely prints that traceback text.  In "
"practice, ordinary output rarely begins with a traceback header line, so "
"this doesn't create real problems."
msgstr ""
"Doctest는 예상 출력이 예외 트레이스백에서 온 것인지 일반 인쇄에서 온 것인지 추측할 수 없습니다. 그래서, 예를 들어, "
"``ValueError: 42 is prime``\\을 예상하는 예제는 :exc:`ValueError`\\가 실제로 발생해도 "
"통과하지만, 예제가 단지 그 트레이스백 텍스트를 출력해도 통과합니다. 실제로는, 일반 출력은 거의 트레이스백 헤더 줄로 시작하지 "
"않으므로, 실제 문제가 되지는 않습니다."

#: ../../library/doctest.rst:519
msgid ""
"Each line of the traceback stack (if present) must be indented further "
"than the first line of the example, *or* start with a non-alphanumeric "
"character. The first line following the traceback header indented the "
"same and starting with an alphanumeric is taken to be the start of the "
"exception detail.  Of course this does the right thing for genuine "
"tracebacks."
msgstr ""
"(있다면) 트레이스백 스택의 각 줄은 예제의 첫 번째 줄보다 더 들여쓰기 되거나, *또는* 영숫자(alphanumeric)가 아닌 "
"문자로 시작해야 합니다. 트레이스백 헤더 뒤에 같은 정도로 들여쓰기 되고, 영숫자로 시작하는 첫 번째 줄은 예외 세부 사항의 "
"시작으로 간주합니다. 물론 이것은 진짜 트레이스백에 잘 들어맞습니다."

#: ../../library/doctest.rst:525
msgid ""
"When the :const:`IGNORE_EXCEPTION_DETAIL` doctest option is specified, "
"everything following the leftmost colon and any module information in the"
" exception name is ignored."
msgstr ""
":const:`IGNORE_EXCEPTION_DETAIL` doctest 옵션을 지정하면, 가장 왼쪽 콜론 다음에 오는 모든 것과 "
"예외 이름의 모듈 정보가 무시됩니다."

#: ../../library/doctest.rst:529
msgid ""
"The interactive shell omits the traceback header line for some "
":exc:`SyntaxError`\\ s.  But doctest uses the traceback header line to "
"distinguish exceptions from non-exceptions.  So in the rare case where "
"you need to test a :exc:`SyntaxError` that omits the traceback header, "
"you will need to manually add the traceback header line to your test "
"example."
msgstr ""
"대화형 셸은 일부 :exc:`SyntaxError`\\에서 트레이스백 헤더 줄을 생략합니다. 그러나 doctest는 트레이스백 헤더"
" 줄을 사용하여 예외를 비 예외와 구별합니다. 따라서 트레이스백 헤더를 생략하는 :exc:`SyntaxError`\\를 테스트해야 "
"하는 드문 경우에는, 트레이스백 헤더 줄을 수동으로 테스트 예제에 추가해야 합니다."

#: ../../library/doctest.rst:537
#, fuzzy
msgid ""
"For some exceptions, Python displays the position of the error using "
"``^`` markers and tildes::"
msgstr "일부 :exc:`SyntaxError`\\의 경우, 파이썬은 ``^`` 마커를 사용하여 구문 에러의 문자 위치를 표시합니다::"

#: ../../library/doctest.rst:540
msgid ""
">>> 1 + None\n"
"  File \"<stdin>\", line 1\n"
"    1 + None\n"
"    ~~^~~~~~\n"
"TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'"
msgstr ""

#: ../../library/doctest.rst:546
msgid ""
"Since the lines showing the position of the error come before the "
"exception type and detail, they are not checked by doctest.  For example,"
" the following test would pass, even though it puts the ``^`` marker in "
"the wrong location::"
msgstr ""
"에러의 위치를 나타내는 줄은 예외 형과 세부 사항 앞에 오므로, doctest가 점검하지 않습니다. 예를 들어, ``^`` 마커를 "
"잘못된 위치에 넣어도, 다음 테스트가 통과합니다::"

#: ../../library/doctest.rst:550
msgid ""
">>> 1 + None\n"
"  File \"<stdin>\", line 1\n"
"    1 + None\n"
"    ^~~~~~~~\n"
"TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'"
msgstr ""

#: ../../library/doctest.rst:561
msgid "Option Flags"
msgstr "옵션 플래그"

#: ../../library/doctest.rst:563
msgid ""
"A number of option flags control various aspects of doctest's behavior. "
"Symbolic names for the flags are supplied as module constants, which can "
"be :ref:`bitwise ORed <bitwise>` together and passed to various "
"functions. The names can also be used in :ref:`doctest directives "
"<doctest-directives>`, and may be passed to the doctest command line "
"interface via the ``-o`` option."
msgstr ""
"많은 옵션 플래그가 doctest의 다양한 동작을 제어합니다. 플래그의 기호 이름은 모듈 상수로 제공되며, 함께 :ref:`비트별 "
"OR <bitwise>`\\되어 다양한 함수로 전달될 수 있습니다. 이 이름은 :ref:`doctest 지시자 <doctest-"
"directives>`\\에서도 사용될 수 있으며, ``-o`` 옵션을 통해 doctest 명령 줄 인터페이스로 전달될 수 "
"있습니다."

#: ../../library/doctest.rst:569
msgid ""
"The first group of options define test semantics, controlling aspects of "
"how doctest decides whether actual output matches an example's expected "
"output:"
msgstr ""
"첫 번째 옵션 그룹은 테스트의 의미를 정의하는데, doctest가 실제 출력이 예제의 예상 출력과 일치하는지를 결정하는 측면을 "
"제어합니다:"

#: ../../library/doctest.rst:575
msgid ""
"By default, if an expected output block contains just ``1``, an actual "
"output block containing just ``1`` or just ``True`` is considered to be a"
" match, and similarly for ``0`` versus ``False``.  When "
":const:`DONT_ACCEPT_TRUE_FOR_1` is specified, neither substitution is "
"allowed.  The default behavior caters to that Python changed the return "
"type of many functions from integer to boolean; doctests expecting "
"\"little integer\" output still work in these cases.  This option will "
"probably go away, but not for several years."
msgstr ""
"기본적으로, 예상 출력 블록에 ``1`` 만 있으면, 단지 ``1``\\이나 ``True`` 만 포함된 실제 출력 블록을 일치하는 "
"것으로 간주하며, ``0``\\과 ``False``\\도 유사하게 다룹니다. "
":const:`DONT_ACCEPT_TRUE_FOR_1`\\이 지정되면, 두 치환 모두 허용되지 않습니다. 기본 동작은 파이썬이 "
"많은 함수의 반환형을 정수에서 논릿값으로 변경했다는 것을 반영합니다; \"작은 정수\" 출력을 예상하는 doctest가 이러한 "
"경우에 여전히 작동합니다. 아마도 이 옵션은 사라지게 되겠지만, 몇 년 동안은 남아있을 겁니다."

#: ../../library/doctest.rst:587
msgid ""
"By default, if an expected output block contains a line containing only "
"the string ``<BLANKLINE>``, then that line will match a blank line in the"
" actual output.  Because a genuinely blank line delimits the expected "
"output, this is the only way to communicate that a blank line is "
"expected.  When :const:`DONT_ACCEPT_BLANKLINE` is specified, this "
"substitution is not allowed."
msgstr ""
"기본적으로, 예상 출력 블록에 ``<BLANKLINE>`` 문자열만 포함된 줄이 있으면, 해당하는 줄은 실제 출력의 빈 줄과 "
"일치합니다. 진짜 빈 줄은 예상 출력을 끝내므로, 이것이 빈 줄을 예상하는 유일한 방법입니다. "
":const:`DONT_ACCEPT_BLANKLINE`\\이 지정되면, 이 치환은 허용되지 않습니다."

#: ../../library/doctest.rst:596
msgid ""
"When specified, all sequences of whitespace (blanks and newlines) are "
"treated as equal.  Any sequence of whitespace within the expected output "
"will match any sequence of whitespace within the actual output. By "
"default, whitespace must match exactly. :const:`NORMALIZE_WHITESPACE` is "
"especially useful when a line of expected output is very long, and you "
"want to wrap it across multiple lines in your source."
msgstr ""
"지정되면, 모든 공백(빈칸과 개행) 시퀀스는 같게 취급됩니다. 예상 출력 내의 모든 공백 시퀀스는 실제 출력 내의 모든 공백 "
"시퀀스와 일치합니다. 기본적으로, 공백은 정확히 일치해야 합니다. :const:`NORMALIZE_WHITESPACE`\\는 예상 "
"출력 줄이 매우 길고 소스의 여러 줄에 걸쳐 줄넘김하려는 경우에 특히 유용합니다."

#: ../../library/doctest.rst:607
msgid ""
"When specified, an ellipsis marker (``...``) in the expected output can "
"match any substring in the actual output.  This includes substrings that "
"span line boundaries, and empty substrings, so it's best to keep usage of"
" this simple. Complicated uses can lead to the same kinds of \"oops, it "
"matched too much!\" surprises that ``.*`` is prone to in regular "
"expressions."
msgstr ""
"지정되면, 예상 출력의 줄임표(``...``)가 실제 출력의 모든 부분 문자열과 일치 할 수 있습니다. 여기에는 줄 경계를 넘는 "
"부분 문자열과 빈 부분 문자열이 포함되므로, 사용을 간단하게 유지하는 것이 가장 좋습니다. 복잡한 사용은 정규식에서 "
"``.*``\\를 쓸 때처럼 \"이런, 너무 많이 일치하는군!\" 과 같은 상황을 만들 수 있습니다."

#: ../../library/doctest.rst:616
msgid ""
"When specified, doctests expecting exceptions pass so long as an "
"exception of the expected type is raised, even if the details (message "
"and fully qualified exception name) don't match."
msgstr ""

#: ../../library/doctest.rst:620
msgid ""
"For example, an example expecting ``ValueError: 42`` will pass if the "
"actual exception raised is ``ValueError: 3*14``, but will fail if, say, a"
" :exc:`TypeError` is raised instead. It will also ignore any fully "
"qualified name included before the exception class, which can vary "
"between implementations and versions of Python and the code/libraries in "
"use. Hence, all three of these variations will work with the flag "
"specified:"
msgstr ""

#: ../../library/doctest.rst:628
msgid ""
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"Exception: message\n"
"\n"
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"builtins.Exception: message\n"
"\n"
">>> raise Exception('message')\n"
"Traceback (most recent call last):\n"
"__main__.Exception: message"
msgstr ""

#: ../../library/doctest.rst:642
msgid ""
"Note that :const:`ELLIPSIS` can also be used to ignore the details of the"
" exception message, but such a test may still fail based on whether the "
"module name is present or matches exactly."
msgstr ""

#: ../../library/doctest.rst:646
msgid ""
":const:`IGNORE_EXCEPTION_DETAIL` now also ignores any information "
"relating to the module containing the exception under test."
msgstr ":const:`IGNORE_EXCEPTION_DETAIL`\\은 이제 테스트 중인 예외를 포함하는 모듈과 관련된 정보도 무시합니다."

#: ../../library/doctest.rst:653
msgid ""
"When specified, do not run the example at all.  This can be useful in "
"contexts where doctest examples serve as both documentation and test "
"cases, and an example should be included for documentation purposes, but "
"should not be checked.  E.g., the example's output might be random; or "
"the example might depend on resources which would be unavailable to the "
"test driver."
msgstr ""
"지정되면, 예제를 전혀 실행하지 않습니다. 이것은 doctest 예제가 설명서와 테스트 케이스의 두 가지 역할을 하는 문맥에서, "
"설명을 위해 예제를 포함해야 하지만 검사하지는 않아야 할 때 유용할 수 있습니다. 예를 들어, 예제의 출력이 임의적일 수 있습니다;"
" 또는 예제가 테스트 구동기에서 사용할 수 없는 자원에 의존할 수 있습니다."

#: ../../library/doctest.rst:659
msgid ""
"The SKIP flag can also be used for temporarily \"commenting out\" "
"examples."
msgstr "SKIP 플래그는 임시로 \"주석 처리한\" 예제를 위해 사용될 수도 있습니다."

#: ../../library/doctest.rst:664
msgid "A bitmask or'ing together all the comparison flags above."
msgstr "위의 모든 비교 플래그를 함께 OR 한 비트 마스크."

#: ../../library/doctest.rst:666
msgid "The second group of options controls how test failures are reported:"
msgstr "두 번째 옵션 그룹은 테스트 실패가 보고되는 방식을 제어합니다:"

#: ../../library/doctest.rst:671
msgid ""
"When specified, failures that involve multi-line expected and actual "
"outputs are displayed using a unified diff."
msgstr "지정되면, 여러 줄의 예상 및 실제 출력을 수반하는 실패가 통합(unified) diff를 사용하여 표시됩니다."

#: ../../library/doctest.rst:677
msgid ""
"When specified, failures that involve multi-line expected and actual "
"outputs will be displayed using a context diff."
msgstr "지정되면, 여러 줄의 예상 및 실제 출력을 수반하는 실패가 문맥(context) diff를 사용하여 표시됩니다."

#: ../../library/doctest.rst:683
msgid ""
"When specified, differences are computed by ``difflib.Differ``, using the"
" same algorithm as the popular :file:`ndiff.py` utility. This is the only"
" method that marks differences within lines as well as across lines.  For"
" example, if a line of expected output contains digit ``1`` where actual "
"output contains letter ``l``, a line is inserted with a caret marking the"
" mismatching column positions."
msgstr ""
"지정되면, 차이점은 널리 사용되는 :file:`ndiff.py` 유틸리티와 같은 알고리즘을 사용하여, "
"``difflib.Differ``\\로 계산됩니다. 이 방법은 줄 간의 차이뿐만 아니라 줄 안에서의 차이점을 표시하는 유일한 "
"방법입니다. 예를 들어, 예상 출력 줄에 숫자 ``1``\\이 포함된 줄에 실제 출력이 문자 ``l``\\을 포함하고 있으면, "
"일치하지 않는 열 위치를 나타내는 캐럿(caret)이 들어간 줄이 삽입됩니다."

#: ../../library/doctest.rst:692
msgid ""
"When specified, display the first failing example in each doctest, but "
"suppress output for all remaining examples.  This will prevent doctest "
"from reporting correct examples that break because of earlier failures; "
"but it might also hide incorrect examples that fail independently of the "
"first failure.  When :const:`REPORT_ONLY_FIRST_FAILURE` is specified, the"
" remaining examples are still run, and still count towards the total "
"number of failures reported; only the output is suppressed."
msgstr ""
"지정되면, 각 doctest에서 실패한 첫 번째 예제를 표시하지만, 나머지 모든 예제에 대해서는 출력을 억제합니다. 이렇게 하면 "
"doctest가 이전의 실패로 인해 망가진 올바른 예제를 보고하지 않게 되지만, 첫 번째 실패와 무관하게 실패한 잘못된 예제를 숨길"
" 수도 있습니다. :const:`REPORT_ONLY_FIRST_FAILURE`\\가 지정될 때, 나머지 예제는 여전히 실행되며, "
"보고된 총실패 수에 포함됩니다; 출력만 억제됩니다."

#: ../../library/doctest.rst:703
msgid ""
"When specified, exit after the first failing example and don't attempt to"
" run the remaining examples. Thus, the number of failures reported will "
"be at most 1.  This flag may be useful during debugging, since examples "
"after the first failure won't even produce debugging output."
msgstr ""
"지정되면, 첫 번째 실패 예제 후에 종료하고, 나머지 예제를 실행하지 않습니다. 따라서, 보고되는 실패 횟수는 최대 1입니다. 이 "
"플래그는 디버깅 중에 유용할 수 있습니다, 첫 번째 실패 이후의 예제는 디버깅 출력조차 생성하지 않기 때문입니다."

#: ../../library/doctest.rst:711
msgid "A bitmask or'ing together all the reporting flags above."
msgstr "위의 모든 보고(reporting) 플래그를 함께 OR 한 비트 마스크."

#: ../../library/doctest.rst:714
msgid ""
"There is also a way to register new option flag names, though this isn't "
"useful unless you intend to extend :mod:`doctest` internals via "
"subclassing:"
msgstr ""
"새로운 옵션 플래그 이름을 등록하는 방법도 있습니다만, 서브 클래스를 통해 :mod:`doctest` 내부를 확장하려고 하지 않는 "
"한 유용하지는 않습니다:"

#: ../../library/doctest.rst:720
msgid ""
"Create a new option flag with a given name, and return the new flag's "
"integer value.  :func:`register_optionflag` can be used when subclassing "
":class:`OutputChecker` or :class:`DocTestRunner` to create new options "
"that are supported by your subclasses.  :func:`register_optionflag` "
"should always be called using the following idiom::"
msgstr ""
"지정된 이름으로 새로운 옵션 플래그를 만들고, 새로운 플래그의 정숫값을 반환합니다. "
":func:`register_optionflag`\\은 :class:`OutputChecker`\\나 "
":class:`DocTestRunner`\\를 서브 클래싱할 때 서브 클래스가 지원하는 새 옵션을 만들 때 사용할 수 있습니다. "
":func:`register_optionflag`\\는 항상 다음의 관용구를 사용하여 호출해야 합니다::"

#: ../../library/doctest.rst:726
msgid "MY_FLAG = register_optionflag('MY_FLAG')"
msgstr ""

#: ../../library/doctest.rst:736
msgid "Directives"
msgstr "지시자"

#: ../../library/doctest.rst:738
msgid ""
"Doctest directives may be used to modify the :ref:`option flags <doctest-"
"options>` for an individual example.  Doctest directives are special "
"Python comments following an example's source code:"
msgstr ""
"Doctest 지시자를 사용하면 개별 예제의 :ref:`옵션 플래그 <doctest-options>`\\를 수정할 수 있습니다. "
"Doctest 지시자는 예제의 소스 코드 뒤에 오는 특수한 파이썬 주석입니다:"

#: ../../library/doctest.rst:749
msgid ""
"Whitespace is not allowed between the ``+`` or ``-`` and the directive "
"option name.  The directive option name can be any of the option flag "
"names explained above."
msgstr ""
"``+``\\나 ``-``\\와 지시자 옵션 이름 사이의 공백은 허용되지 않습니다. 지시자 옵션 이름은 위에 설명된 옵션 플래그 "
"이름 중 하나일 수 있습니다."

#: ../../library/doctest.rst:753
msgid ""
"An example's doctest directives modify doctest's behavior for that single"
" example.  Use ``+`` to enable the named behavior, or ``-`` to disable "
"it."
msgstr ""
"예제의 doctest 지시자는 그 단일 예제에 대한 doctest의 동작을 수정합니다. 이름 붙인 동작을 활성화하려면 "
"``+``\\를 사용하고, 비활성화하려면 ``-``\\를 사용하십시오."

#: ../../library/doctest.rst:756
#, fuzzy
msgid "For example, this test passes:"
msgstr "예를 들어, 이 테스트는 통과합니다::"

#: ../../library/doctest.rst:758
msgid ""
">>> print(list(range(20)))  # doctest: +NORMALIZE_WHITESPACE\n"
"[0,   1,  2,  3,  4,  5,  6,  7,  8,  9,\n"
"10,  11, 12, 13, 14, 15, 16, 17, 18, 19]"
msgstr ""

#: ../../library/doctest.rst:765
#, fuzzy
msgid ""
"Without the directive it would fail, both because the actual output "
"doesn't have two blanks before the single-digit list elements, and "
"because the actual output is on a single line.  This test also passes, "
"and also requires a directive to do so:"
msgstr ""
"지시자가 없으면 실패하는데, 실제 출력에는 한 자리 숫자 리스트 요소 앞에 두 개의 공백이 없기도 하고, 실제 출력은 한 줄이기 "
"때문입니다. 이 테스트도 통과하는데, 그러기 위해서 역시 지시자가 필요합니다::"

#: ../../library/doctest.rst:770
msgid ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS\n"
"[0, 1, ..., 18, 19]"
msgstr ""

#: ../../library/doctest.rst:776
#, fuzzy
msgid ""
"Multiple directives can be used on a single physical line, separated by "
"commas:"
msgstr "하나의 물리적 줄에 여러 개의 지시자를 쉼표로 구분하여 사용할 수 있습니다::"

#: ../../library/doctest.rst:779
msgid ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n"
"[0,    1, ...,   18,    19]"
msgstr ""

#: ../../library/doctest.rst:785
#, fuzzy
msgid ""
"If multiple directive comments are used for a single example, then they "
"are combined:"
msgstr "하나의 예제에 여러 개의 지시자 주석이 사용되면, 모두 결합합니다::"

#: ../../library/doctest.rst:788
msgid ""
">>> print(list(range(20)))  # doctest: +ELLIPSIS\n"
"...                         # doctest: +NORMALIZE_WHITESPACE\n"
"[0,    1, ...,   18,    19]"
msgstr ""

#: ../../library/doctest.rst:795
#, fuzzy
msgid ""
"As the previous example shows, you can add ``...`` lines to your example "
"containing only directives.  This can be useful when an example is too "
"long for a directive to comfortably fit on the same line:"
msgstr ""
"앞의 예가 보여주듯이, 여러분의 예제에 지시자만 포함된 ``...`` 줄을 추가할 수 있습니다. 예가 너무 길어서 지시자가 같은 "
"줄에 편안하게 들어갈 수 없을 때 유용할 수 있습니다::"

#: ../../library/doctest.rst:799
msgid ""
">>> print(list(range(5)) + list(range(10, 20)) + list(range(30, 40)))\n"
"... # doctest: +ELLIPSIS\n"
"[0, ..., 4, 10, ..., 19, 30, ..., 39]"
msgstr ""

#: ../../library/doctest.rst:806
msgid ""
"Note that since all options are disabled by default, and directives apply"
" only to the example they appear in, enabling options (via ``+`` in a "
"directive) is usually the only meaningful choice.  However, option flags "
"can also be passed to functions that run doctests, establishing different"
" defaults.  In such cases, disabling an option via ``-`` in a directive "
"can be useful."
msgstr ""
"모든 옵션은 기본적으로 비활성화되고, 지시자가 표시된 예제에만 적용되므로, (지시자에 ``+``\\를 통해) 옵션을 활성화하는 것이"
" 일반적으로 유일한 의미 있는 선택입니다. 하지만, doctest를 실행하는 함수에 옵션 플래그를 전달하여 다른 기본값을 설정할 "
"수도 있습니다. 이럴 때, 지시자에서 ``-``\\를 통해 옵션을 비활성화하는 것이 유용할 수 있습니다."

#: ../../library/doctest.rst:816
msgid "Warnings"
msgstr "경고"

#: ../../library/doctest.rst:818
msgid ""
":mod:`doctest` is serious about requiring exact matches in expected "
"output.  If even a single character doesn't match, the test fails.  This "
"will probably surprise you a few times, as you learn exactly what Python "
"does and doesn't guarantee about output.  For example, when printing a "
"set, Python doesn't guarantee that the element is printed in any "
"particular order, so a test like ::"
msgstr ""
":mod:`doctest`\\는 예상 출력에서 정확한 일치를 요구하는 것에 심각합니다. 단일 문자가 일치하지 않아도 테스트가 "
"실패합니다. 여러분이 출력에 있어서 파이썬이 정확히 무엇을 보장하고 무엇을 보장하지 않는지 배워감에 따라, 이것은 아마도 여러분을 "
"몇 번 놀라게 할 것입니다. 예를 들어, 집합을 인쇄할 때, 파이썬은 원소가 특정 순서로 인쇄되는 것을 보장하지 않으므로, 다음과 "
"같은 테스트는 ::"

#: ../../library/doctest.rst:824
#, python-brace-format
msgid ""
">>> foo()\n"
"{\"spam\", \"eggs\"}"
msgstr ""

#: ../../library/doctest.rst:827
msgid "is vulnerable!  One workaround is to do ::"
msgstr "취약합니다! 한 가지 해결 방법은 다음과 같습니다 ::"

#: ../../library/doctest.rst:829
#, python-brace-format
msgid ""
">>> foo() == {\"spam\", \"eggs\"}\n"
"True"
msgstr ""

#: ../../library/doctest.rst:832
msgid "instead.  Another is to do ::"
msgstr "대신에. 또 다른 방법은 ::"

#: ../../library/doctest.rst:834
msgid ""
">>> d = sorted(foo())\n"
">>> d\n"
"['eggs', 'spam']"
msgstr ""

#: ../../library/doctest.rst:838
msgid "There are others, but you get the idea."
msgstr "다른 것들도 있지만, 아마 아이디어를 얻었을 겁니다."

#: ../../library/doctest.rst:840
#, fuzzy
msgid "Another bad idea is to print things that embed an object address, like"
msgstr "또 다른 나쁜 생각은 객체 주소를 포함하는 것들을 출력하는 것입니다 ::"

#: ../../library/doctest.rst:842
msgid ""
">>> id(1.0)  # certain to fail some of the time\n"
"7948648\n"
">>> class C: pass\n"
">>> C()  # the default repr() for instances embeds an address\n"
"<C object at 0x00AC18F0>"
msgstr ""

#: ../../library/doctest.rst:850
#, fuzzy
msgid ""
"The :const:`ELLIPSIS` directive gives a nice approach for the last "
"example:"
msgstr ":const:`ELLIPSIS` 지시자는 마지막 예제를 다루는 좋은 접근법을 제공합니다 ::"

#: ../../library/doctest.rst:852
msgid ""
">>> C()  # doctest: +ELLIPSIS\n"
"<C object at 0x...>"
msgstr ""

#: ../../library/doctest.rst:858
msgid ""
"Floating-point numbers are also subject to small output variations across"
" platforms, because Python defers to the platform C library for float "
"formatting, and C libraries vary widely in quality here. ::"
msgstr ""
"부동 소수점 숫자도 플랫폼에 따라 약간의 출력 변동이 있습니다. 파이썬이 float 포매팅을 플랫폼 C 라이브러리에 위임하고 있고,"
" 이때 C 라이브러리의 품질이 크게 다르기 때문입니다. ::"

#: ../../library/doctest.rst:862
msgid ""
">>> 1./7  # risky\n"
"0.14285714285714285\n"
">>> print(1./7) # safer\n"
"0.142857142857\n"
">>> print(round(1./7, 6)) # much safer\n"
"0.142857"
msgstr ""

#: ../../library/doctest.rst:869
msgid ""
"Numbers of the form ``I/2.**J`` are safe across all platforms, and I "
"often contrive doctest examples to produce numbers of that form::"
msgstr ""
"``I/2.**J`` 형식의 숫자는 모든 플랫폼에서 안전하며, 저는 종종 이런 형식의 숫자를 만들도록 doctest 예제를 "
"꾸밉니다::"

#: ../../library/doctest.rst:872
msgid ""
">>> 3./4  # utterly safe\n"
"0.75"
msgstr ""

#: ../../library/doctest.rst:875
msgid ""
"Simple fractions are also easier for people to understand, and that makes"
" for better documentation."
msgstr "간단한 분수는 또한 사람들이 이해하기가 더 쉬우므로, 더 좋은 설명서가 되도록 합니다."

#: ../../library/doctest.rst:882
msgid "Basic API"
msgstr "기본 API"

#: ../../library/doctest.rst:884
msgid ""
"The functions :func:`testmod` and :func:`testfile` provide a simple "
"interface to doctest that should be sufficient for most basic uses.  For "
"a less formal introduction to these two functions, see sections :ref"
":`doctest-simple-testmod` and :ref:`doctest-simple-testfile`."
msgstr ""
":func:`testmod`\\와 :func:`testfile` 함수는 대부분 기본 사용에 충분한 doctest에 대한 간단한 "
"인터페이스를 제공합니다. 이 두 함수에 대한 덜 형식적인 소개는 섹션 :ref:`doctest-simple-testmod`\\와 "
":ref:`doctest-simple-testfile`\\를 참조하십시오."

#: ../../library/doctest.rst:892
msgid ""
"All arguments except *filename* are optional, and should be specified in "
"keyword form."
msgstr "*filename*\\를 제외한 모든 인자는 선택적이며 키워드 형식으로 지정해야 합니다."

#: ../../library/doctest.rst:895
msgid ""
"Test examples in the file named *filename*.  Return ``(failure_count, "
"test_count)``."
msgstr "*filename* 파일에 있는 예제를 테스트합니다. ``(failure_count, test_count)``\\를 반환합니다."

#: ../../library/doctest.rst:898
msgid ""
"Optional argument *module_relative* specifies how the filename should be "
"interpreted:"
msgstr "선택적 인자 *module_relative*\\는 filename을 해석하는 방법을 지정합니다:"

#: ../../library/doctest.rst:901
msgid ""
"If *module_relative* is ``True`` (the default), then *filename* specifies"
" an OS-independent module-relative path.  By default, this path is "
"relative to the calling module's directory; but if the *package* argument"
" is specified, then it is relative to that package.  To ensure OS-"
"independence, *filename* should use ``/`` characters to separate path "
"segments, and may not be an absolute path (i.e., it may not begin with "
"``/``)."
msgstr ""
"*module_relative*\\가 ``True``\\(기본값)이면, *filename*\\는 OS 독립적 모듈 상대 경로를 "
"지정합니다. 기본적으로, 이 경로는 호출하는 모듈의 디렉터리에 상대적입니다; 그러나 *package* 인자가 지정되면, 해당 "
"패키지에 상대적입니다. OS 독립성을 보장하기 위해, *filename*\\은 ``/`` 문자를 사용하여 경로 세그먼트를 분리해야 "
"하며, 절대 경로일 수 없습니다 (즉, ``/``\\로 시작할 수 없습니다)."

#: ../../library/doctest.rst:908
msgid ""
"If *module_relative* is ``False``, then *filename* specifies an OS-"
"specific path.  The path may be absolute or relative; relative paths are "
"resolved with respect to the current working directory."
msgstr ""
"*module_relative*\\가 ``False``\\이면, *filename*\\은 OS 특정 경로를 지정합니다. 경로는 "
"절대나 상대일 수 있습니다; 상대 경로는 현재 작업 디렉터리를 기준으로 해석됩니다."

#: ../../library/doctest.rst:912
msgid ""
"Optional argument *name* gives the name of the test; by default, or if "
"``None``, ``os.path.basename(filename)`` is used."
msgstr ""
"선택적 인자 *name*\\은 테스트의 이름을 제공합니다; 기본적으로, 또는 ``None``\\이면, "
"``os.path.basename(filename)``\\이 사용됩니다."

#: ../../library/doctest.rst:915
msgid ""
"Optional argument *package* is a Python package or the name of a Python "
"package whose directory should be used as the base directory for a "
"module-relative filename.  If no package is specified, then the calling "
"module's directory is used as the base directory for module-relative "
"filenames.  It is an error to specify *package* if *module_relative* is "
"``False``."
msgstr ""
"선택적 인자 *package*\\는 디렉터리가 모듈 상대 filename의 기본 디렉터리로 사용될 파이썬 패키지나 파이썬 패키지의 "
"이름입니다. 패키지를 지정하지 않으면, 호출하는 모듈의 디렉터리가 모듈 상대 filename의 기본 디렉터리로 사용됩니다. "
"*module_relative*\\가 ``False``\\일 때 *package*\\를 지정하는 것은 에러입니다."

#: ../../library/doctest.rst:921
msgid ""
"Optional argument *globs* gives a dict to be used as the globals when "
"executing examples.  A new shallow copy of this dict is created for the "
"doctest, so its examples start with a clean slate. By default, or if "
"``None``, a new empty dict is used."
msgstr ""
"선택적 인자 *globs*\\는 예제를 실행할 때 전역으로 사용될 딕셔너리를 제공합니다. doctest를 위해 이 딕셔너리의 새 "
"얕은 사본이 만들어지므로, 예제는 깨끗한 서판으로 시작합니다. 기본적으로, 또는 ``None``\\이면, 새 빈 딕셔너리가 "
"사용됩니다."

#: ../../library/doctest.rst:926
msgid ""
"Optional argument *extraglobs* gives a dict merged into the globals used "
"to execute examples.  This works like :meth:`dict.update`:  if *globs* "
"and *extraglobs* have a common key, the associated value in *extraglobs* "
"appears in the combined dict.  By default, or if ``None``, no extra "
"globals are used.  This is an advanced feature that allows "
"parameterization of doctests.  For example, a doctest can be written for "
"a base class, using a generic name for the class, then reused to test any"
" number of subclasses by passing an *extraglobs* dict mapping the generic"
" name to the subclass to be tested."
msgstr ""
"선택적 인자 *extraglobs*\\는 예제를 실행하는 데 사용되는 전역에 병합될 딕셔너리를 제공합니다. 이것은 "
":meth:`dict.update`\\처럼 작동합니다: *globs*\\와 *extraglobs*\\에 공통 키가 있으면, "
"*extraglobs*\\의 연관된 값이 병합된 딕셔너리에 나타납니다. 기본적으로, 또는 ``None``\\이면, 추가 전역은 "
"사용되지 않습니다. doctest의 매개 변수화를 허용하는 고급 기능입니다. 예를 들어, doctest는 클래스의 일반 이름을 "
"사용하여 베이스 클래스용으로 작성할 수 있습니다, 그런 다음 일반 이름을 테스트할 서브 클래스에 매핑하는 *extraglobs* "
"딕셔너리를 전달하여 임의의 수의 서브 클래스를 테스트하는데 재사용할 수 있습니다."

#: ../../library/doctest.rst:935
msgid ""
"Optional argument *verbose* prints lots of stuff if true, and prints only"
" failures if false; by default, or if ``None``, it's true if and only if "
"``'-v'`` is in ``sys.argv``."
msgstr ""
"선택적 인자 *verbose*\\가 참이면 많은 것들을 인쇄하고, 거짓이면 실패만 인쇄합니다; 기본적으로, 또는 "
"``None``\\이면, ``'-v'``\\가 ``sys.argv``\\에 있을 때만 참입니다."

#: ../../library/doctest.rst:939
msgid ""
"Optional argument *report* prints a summary at the end when true, else "
"prints nothing at the end.  In verbose mode, the summary is detailed, "
"else the summary is very brief (in fact, empty if all tests passed)."
msgstr ""
"선택적 인자 *report*\\가 참이면 끝에 요약을 인쇄하고, 그렇지 않으면 끝에 아무것도 인쇄하지 않습니다. verbose "
"모드에서는 요약 정보가 상세히 표시되며, 그렇지 않으면 요약 정보는 매우 간단합니다 (사실, 모든 테스트가 통과되면 비어 "
"있습니다)."

#: ../../library/doctest.rst:943
msgid ""
"Optional argument *optionflags* (default value 0) takes the :ref:`bitwise"
" OR <bitwise>` of option flags. See section :ref:`doctest-options`."
msgstr ""
"선택적 인자 *optionflags*\\(기본값은 0)는 옵션 플래그의 :ref:`비트별 OR <bitwise>`\\를 취합니다. "
":ref:`doctest-options` 절을 참조하십시오."

#: ../../library/doctest.rst:947
msgid ""
"Optional argument *raise_on_error* defaults to false.  If true, an "
"exception is raised upon the first failure or unexpected exception in an "
"example.  This allows failures to be post-mortem debugged. Default "
"behavior is to continue running examples."
msgstr ""
"선택적 인자 *raise_on_error*\\의 기본값은 거짓입니다. 참이면, 예제에서 첫 번째 실패나 예기치 않은 예외가 발생할 "
"때 예외가 발생합니다. 이것은 실패를 사후(post-mortem) 디버깅할 수 있도록 합니다. 기본 동작은 예제를 계속 실행하는 "
"것입니다."

#: ../../library/doctest.rst:952 ../../library/doctest.rst:1094
msgid ""
"Optional argument *parser* specifies a :class:`DocTestParser` (or "
"subclass) that should be used to extract tests from the files.  It "
"defaults to a normal parser (i.e., ``DocTestParser()``)."
msgstr ""
"선택적 인자 *parser*\\는 파일에서 테스트를 추출하는 데 사용할 :class:`DocTestParser`\\(또는 서브 "
"클래스)를 지정합니다. 기본값은 일반 파서(즉, ``DocTestParser()``)입니다."

#: ../../library/doctest.rst:956 ../../library/doctest.rst:1098
msgid ""
"Optional argument *encoding* specifies an encoding that should be used to"
" convert the file to unicode."
msgstr "선택적 인자 *encoding*\\은 파일을 유니코드로 변환하는 데 사용할 인코딩을 지정합니다."

#: ../../library/doctest.rst:962
msgid ""
"All arguments are optional, and all except for *m* should be specified in"
" keyword form."
msgstr "모든 인자는 선택적이며, *m*\\을 제외한 모든 인자는 키워드 형식으로 지정해야 합니다."

#: ../../library/doctest.rst:965
msgid ""
"Test examples in docstrings in functions and classes reachable from "
"module *m* (or module :mod:`__main__` if *m* is not supplied or is "
"``None``), starting with ``m.__doc__``."
msgstr ""
"모듈 *m*\\(또는 *m*\\가 제공되지 않았거나 ``None``\\이면 모듈 :mod:`__main__`)에서 도달할 수 있는 "
"함수와 클래스의 독스트링에 있는 예제를 테스트합니다. ``m.__doc__``\\으로 시작합니다."

#: ../../library/doctest.rst:969
#, fuzzy
msgid ""
"Also test examples reachable from dict ``m.__test__``, if it exists. "
"``m.__test__`` maps names (strings) to functions, classes and strings; "
"function and class docstrings are searched for examples; strings are "
"searched directly, as if they were docstrings."
msgstr ""
"딕셔너리 ``m.__test__``\\이 존재하고 ``None``\\이 아니면, 여기에서 도달할 수 있는 예제도 테스트합니다. "
"``m.__test__``\\는 이름(문자열)을 함수, 클래스 및 문자열에 매핑합니다; 함수와 클래스 독스트링에서 예제를 "
"검색합니다; 문자열은 그것이 독스트링인 것처럼 직접 검색합니다."

#: ../../library/doctest.rst:974
msgid "Only docstrings attached to objects belonging to module *m* are searched."
msgstr "모듈 *m*\\에 속하는 객체에 연결된 독스트링 만 검색합니다."

#: ../../library/doctest.rst:976
msgid "Return ``(failure_count, test_count)``."
msgstr "``(failure_count, test_count)``\\를 반환합니다."

#: ../../library/doctest.rst:978
msgid ""
"Optional argument *name* gives the name of the module; by default, or if "
"``None``, ``m.__name__`` is used."
msgstr ""
"선택적 인자 *name*\\은 모듈의 이름을 제공합니다; 기본적으로, 또는 ``None``\\이면, ``m.__name__``\\이"
" 사용됩니다."

#: ../../library/doctest.rst:981
#, fuzzy
msgid ""
"Optional argument *exclude_empty* defaults to false.  If true, objects "
"for which no doctests are found are excluded from consideration. The "
"default is a backward compatibility hack, so that code still using "
":meth:`doctest.master.summarize <DocTestRunner.summarize>` in conjunction"
" with :func:`testmod` continues to get output for objects with no tests. "
"The *exclude_empty* argument to the newer :class:`DocTestFinder` "
"constructor defaults to true."
msgstr ""
"선택적 인자 *exclude_empty*\\의 기본값은 거짓입니다. 참이면, doctest가 발견되지 않은 객체는 고려 대상에서 "
"제외됩니다. 기본값은 이전 버전과의 호환성을 위한 해킹입니다, 여전히 :func:`testmod`\\와 함께 "
":meth:`doctest.master.summarize`\\를 사용하는 코드는 테스트가 없는 객체에 대해 계속 출력합니다. 새로운"
" :class:`DocTestFinder` 생성자에 대한 *exclude_empty* 인자의 기본값은 참입니다."

#: ../../library/doctest.rst:989
msgid ""
"Optional arguments *extraglobs*, *verbose*, *report*, *optionflags*, "
"*raise_on_error*, and *globs* are the same as for function "
":func:`testfile` above, except that *globs* defaults to ``m.__dict__``."
msgstr ""
"선택적 인자 *extraglobs*, *verbose*, *report*, *optionflags*, *raise_on_error*"
" 및 *globs*\\는 위의 함수 :func:`testfile`\\와 같습니다만, *globs*\\의 기본값이 "
"``m.__dict__``\\인 점이 다릅니다."

#: ../../library/doctest.rst:996
msgid ""
"Test examples associated with object *f*; for example, *f* may be a "
"string, a module, a function, or a class object."
msgstr "객체 *f*\\와 관련된 예제를 테스트합니다. 여기서, *f*\\는 문자열, 모듈, 함수 또는 클래스 객체일 수 있습니다."

#: ../../library/doctest.rst:999
msgid ""
"A shallow copy of dictionary argument *globs* is used for the execution "
"context."
msgstr "딕셔너리 인자 *globs*\\의 얕은 사본이 실행 컨텍스트에 사용됩니다."

#: ../../library/doctest.rst:1001
msgid ""
"Optional argument *name* is used in failure messages, and defaults to "
"``\"NoName\"``."
msgstr "선택적 인자 *name*\\은 실패 메시지에서 사용되며, 기본값은 ``\"NoName\"``\\입니다."

#: ../../library/doctest.rst:1004
msgid ""
"If optional argument *verbose* is true, output is generated even if there"
" are no failures.  By default, output is generated only in case of an "
"example failure."
msgstr "선택적 인자 *verbose*\\가 참이면, 실패가 없어도 출력이 생성됩니다. 기본적으로, 출력은 예제가 실패할 때만 생성됩니다."

#: ../../library/doctest.rst:1007
msgid ""
"Optional argument *compileflags* gives the set of flags that should be "
"used by the Python compiler when running the examples.  By default, or if"
" ``None``, flags are deduced corresponding to the set of future features "
"found in *globs*."
msgstr ""
"선택적 인자 *compileflags*\\는 예제를 실행할 때 파이썬 컴파일러에서 사용해야 하는 플래그 집합을 제공합니다. "
"기본적으로, 또는 ``None``\\이면, *globs*\\에서 발견되는 퓨처 기능 집합에 해당하는 플래그가 추론됩니다."

#: ../../library/doctest.rst:1011
msgid ""
"Optional argument *optionflags* works as for function :func:`testfile` "
"above."
msgstr "선택적 인자 *optionflags*\\는 위의 함수 :func:`testfile`\\에서 처럼 작동합니다."

#: ../../library/doctest.rst:1017
msgid "Unittest API"
msgstr "Unittest API"

#: ../../library/doctest.rst:1019
#, fuzzy
msgid ""
"As your collection of doctest'ed modules grows, you'll want a way to run "
"all their doctests systematically.  :mod:`doctest` provides two functions"
" that can be used to create :mod:`unittest` test suites from modules and "
"text files containing doctests.  To integrate with :mod:`unittest` test "
"discovery, include a :ref:`load_tests <load_tests-protocol>` function in "
"your test module::"
msgstr ""
"doctest된 모듈 모음이 늘어남에 따라, 모든 doctest를 체계적으로 실행하는 방법이 필요합니다. "
":mod:`doctest`\\는 doctest가 포함된 모듈과 텍스트 파일로부터 :mod:`unittest` 테스트 스위트를 만드는"
" 데 사용할 수 있는 두 가지 함수를 제공합니다. :mod:`unittest` 테스트 탐색과 통합하려면, 테스트 모듈에 "
":func:`load_tests` 함수를 포함하십시오::"

#: ../../library/doctest.rst:1025
msgid ""
"import unittest\n"
"import doctest\n"
"import my_module_with_doctests\n"
"\n"
"def load_tests(loader, tests, ignore):\n"
"    tests.addTests(doctest.DocTestSuite(my_module_with_doctests))\n"
"    return tests"
msgstr ""

#: ../../library/doctest.rst:1033
msgid ""
"There are two main functions for creating :class:`unittest.TestSuite` "
"instances from text files and modules with doctests:"
msgstr ""
"Doctest가 있는 텍스트 파일과 모듈로부터 :class:`unittest.TestSuite` 인스턴스를 만드는 두 가지 주요 "
"함수가 있습니다:"

#: ../../library/doctest.rst:1039
msgid ""
"Convert doctest tests from one or more text files to a "
":class:`unittest.TestSuite`."
msgstr "하나 이상의 텍스트 파일로부터 doctest 테스트를 :class:`unittest.TestSuite`\\로 변환합니다."

#: ../../library/doctest.rst:1042
#, fuzzy
msgid ""
"The returned :class:`unittest.TestSuite` is to be run by the unittest "
"framework and runs the interactive examples in each file.  If an example "
"in any file fails, then the synthesized unit test fails, and a "
":exc:`failureException` exception is raised showing the name of the file "
"containing the test and a (sometimes approximate) line number.  If all "
"the examples in a file are skipped, then the synthesized unit test is "
"also marked as skipped."
msgstr ""
"반환된 :class:`unittest.TestSuite`\\는 unittest 프레임워크에 의해 실행되고, 각 파일에 있는 대화식 "
"예제를 실행합니다. 어떤 파일의 예제가 실패하면, 합성된 단위 테스트가 실패하고, 테스트를 포함하는 파일의 이름과 (때로는 "
"근사치인) 줄 번호를 보여주는 :exc:`failureException` 예외가 발생합니다."

#: ../../library/doctest.rst:1049
msgid "Pass one or more paths (as strings) to text files to be examined."
msgstr "검사할 텍스트 파일을 하나 이상의 paths(문자열)로 전달합니다."

#: ../../library/doctest.rst:1051
msgid "Options may be provided as keyword arguments:"
msgstr "옵션은 키워드 인자로 제공될 수 있습니다:"

#: ../../library/doctest.rst:1053
msgid ""
"Optional argument *module_relative* specifies how the filenames in "
"*paths* should be interpreted:"
msgstr "선택적 인자 *module_relative*\\는 *paths*\\에 있는 파일명을 해석하는 방법을 지정합니다:"

#: ../../library/doctest.rst:1056
msgid ""
"If *module_relative* is ``True`` (the default), then each filename in "
"*paths* specifies an OS-independent module-relative path.  By default, "
"this path is relative to the calling module's directory; but if the "
"*package* argument is specified, then it is relative to that package.  To"
" ensure OS-independence, each filename should use ``/`` characters to "
"separate path segments, and may not be an absolute path (i.e., it may not"
" begin with ``/``)."
msgstr ""
"*module_relative*\\가 ``True``\\(기본값)이면, *paths*\\의 각 파일명은 OS 독립적 모듈 상대 "
"경로를 지정합니다. 기본적으로, 이 경로는 호출하는 모듈의 디렉터리에 상대적입니다; 그러나 *package* 인자가 지정되면, 해당"
" 패키지에 상대적입니다. OS 독립성을 보장하기 위해, 각 파일명은 ``/`` 문자를 사용하여 경로 세그먼트를 분리해야 하며, 절대"
" 경로일 수 없습니다 (즉, ``/``\\로 시작할 수 없습니다)."

#: ../../library/doctest.rst:1064
msgid ""
"If *module_relative* is ``False``, then each filename in *paths* "
"specifies an OS-specific path.  The path may be absolute or relative; "
"relative paths are resolved with respect to the current working "
"directory."
msgstr ""
"*module_relative*\\가 ``False``\\이면, *paths*\\의 각 파일명은 OS 특정 경로를 지정합니다. "
"경로는 절대나 상대일 수 있습니다; 상대 경로는 현재 작업 디렉터리를 기준으로 해석됩니다."

#: ../../library/doctest.rst:1068
msgid ""
"Optional argument *package* is a Python package or the name of a Python "
"package whose directory should be used as the base directory for module-"
"relative filenames in *paths*.  If no package is specified, then the "
"calling module's directory is used as the base directory for module-"
"relative filenames.  It is an error to specify *package* if "
"*module_relative* is ``False``."
msgstr ""
"선택적 인자 *package*\\는 디렉터리가 *paths*\\의 모듈 상대 파일명의 기본 디렉터리로 사용될 파이썬 패키지나 파이썬"
" 패키지의 이름입니다. 패키지를 지정하지 않으면, 호출하는 모듈의 디렉터리가 모듈 상대 파일명의 기본 디렉터리로 사용됩니다. "
"*module_relative*\\가 ``False``\\일 때 *package*\\를 지정하는 것은 에러입니다."

#: ../../library/doctest.rst:1075
msgid ""
"Optional argument *setUp* specifies a set-up function for the test suite."
" This is called before running the tests in each file.  The *setUp* "
"function will be passed a :class:`DocTest` object.  The setUp function "
"can access the test globals as the *globs* attribute of the test passed."
msgstr ""
"선택적 인자 *setUp*\\은 테스트 스위트에 대한 사전 설정(set-up) 함수를 지정합니다. 이것은 각 파일에서 테스트를 "
"실행하기 전에 호출됩니다. *setUp* 함수로 :class:`DocTest` 객체가 전달됩니다. setUp 함수는 전달된 테스트의"
" *globs* 어트리뷰트를 통해 테스트 전역에 액세스할 수 있습니다."

#: ../../library/doctest.rst:1080
msgid ""
"Optional argument *tearDown* specifies a tear-down function for the test "
"suite.  This is called after running the tests in each file.  The "
"*tearDown* function will be passed a :class:`DocTest` object.  The setUp "
"function can access the test globals as the *globs* attribute of the test"
" passed."
msgstr ""
"선택적 인자 *tearDown*\\은 테스트 스위트에 사후 정리(tear-down) 함수를 지정합니다. 이것은 각 파일에서 테스트를"
" 실행한 후에 호출됩니다. *tearDown* 함수로 :class:`DocTest` 객체가 전달됩니다. tearDown 함수는 "
"전달된 테스트의 *globs* 어트리뷰트를 통해 테스트 전역에 액세스할 수 있습니다."

#: ../../library/doctest.rst:1085 ../../library/doctest.rst:1120
msgid ""
"Optional argument *globs* is a dictionary containing the initial global "
"variables for the tests.  A new copy of this dictionary is created for "
"each test.  By default, *globs* is a new empty dictionary."
msgstr ""
"선택적 인자 *globs*\\는 테스트의 초기 전역 변수를 포함하는 딕셔너리입니다. 이 딕셔너리의 새 사본이 테스트마다 "
"만들어집니다. 기본적으로, *globs*\\는 새로운 빈 딕셔너리입니다."

#: ../../library/doctest.rst:1089
msgid ""
"Optional argument *optionflags* specifies the default doctest options for"
" the tests, created by or-ing together individual option flags.  See "
"section :ref:`doctest-options`. See function "
":func:`set_unittest_reportflags` below for a better way to set reporting "
"options."
msgstr ""
"선택적 인자 *optionflags*\\는 테스트에 대한 기본 doctest 옵션을 지정하는데, 개별 옵션 플래그를 함께 OR 해서"
" 만들어집니다. :ref:`doctest-options` 절을 참조하십시오. 보고(reporting) 옵션을 설정하는 더 좋은 "
"방법은 아래 함수 :func:`set_unittest_reportflags`\\를 참조하십시오."

#: ../../library/doctest.rst:1101
msgid ""
"The global ``__file__`` is added to the globals provided to doctests "
"loaded from a text file using :func:`DocFileSuite`."
msgstr ""
"전역 ``__file__``\\이 :func:`DocFileSuite`\\를 사용하여 텍스트 파일에서 로드된 doctest에 제공된"
" 전역에 추가됩니다."

#: ../../library/doctest.rst:1107
msgid "Convert doctest tests for a module to a :class:`unittest.TestSuite`."
msgstr "모듈에 대한 doctest 테스트를 :class:`unittest.TestSuite`\\로 변환합니다."

#: ../../library/doctest.rst:1109
#, fuzzy
msgid ""
"The returned :class:`unittest.TestSuite` is to be run by the unittest "
"framework and runs each doctest in the module.  If any of the doctests "
"fail, then the synthesized unit test fails, and a :exc:`failureException`"
" exception is raised showing the name of the file containing the test and"
" a (sometimes approximate) line number.  If all the examples in a "
"docstring are skipped, then the synthesized unit test is also marked as "
"skipped."
msgstr ""
"반환된 :class:`unittest.TestSuite`\\는 unittest 프레임워크에 의해 실행되고, 모듈에 있는 각 "
"doctest를 실행합니다. 어떤 doctest가 실패하면, 합성된 단위 테스트가 실패하고, 테스트를 포함하는 파일의 이름과 "
"(때로는 근사치인) 줄 번호를 보여주는 :exc:`failureException` 예외가 발생합니다."

#: ../../library/doctest.rst:1116
msgid ""
"Optional argument *module* provides the module to be tested.  It can be a"
" module object or a (possibly dotted) module name.  If not specified, the"
" module calling this function is used."
msgstr ""
"선택적 인자 *module*\\은 테스트할 모듈을 제공합니다. 모듈 객체나 (점으로 구분될 수 있는) 모듈 이름일 수 있습니다. "
"지정하지 않으면, 이 함수를 호출하는 모듈이 사용됩니다."

#: ../../library/doctest.rst:1124
msgid ""
"Optional argument *extraglobs* specifies an extra set of global "
"variables, which is merged into *globs*.  By default, no extra globals "
"are used."
msgstr ""
"선택적 인자 *extraglobs*\\는 *globs*\\에 병합되는 전역 변수의 추가 집합을 지정합니다. 기본적으로, 추가 전역 "
"변수는 사용되지 않습니다."

#: ../../library/doctest.rst:1127
msgid ""
"Optional argument *test_finder* is the :class:`DocTestFinder` object (or "
"a drop-in replacement) that is used to extract doctests from the module."
msgstr ""
"선택적 인자 *test_finder*\\는 모듈에서 doctest를 추출하는 데 사용되는 :class:`DocTestFinder` "
"객체(또는 드롭 인 대체)입니다."

#: ../../library/doctest.rst:1130
msgid ""
"Optional arguments *setUp*, *tearDown*, and *optionflags* are the same as"
" for function :func:`DocFileSuite` above."
msgstr ""
"선택적 인자 *setUp*, *tearDown* 및 *optionflags*\\는 위의 함수 "
":func:`DocFileSuite`\\와 같습니다."

#: ../../library/doctest.rst:1133
msgid "This function uses the same search technique as :func:`testmod`."
msgstr "이 함수는 :func:`testmod`\\와 같은 검색 기법을 사용합니다."

#: ../../library/doctest.rst:1135
msgid ""
":func:`DocTestSuite` returns an empty :class:`unittest.TestSuite` if "
"*module* contains no docstrings instead of raising :exc:`ValueError`."
msgstr ""
"*module*\\에 독스트링이 없으면 :func:`DocTestSuite`\\는 :exc:`ValueError`\\를 발생시키는 "
"대신 빈 :class:`unittest.TestSuite`\\를 반환합니다."

#: ../../library/doctest.rst:1141
msgid ""
"When doctests which have been converted to unit tests by "
":func:`DocFileSuite` or :func:`DocTestSuite` fail, this exception is "
"raised showing the name of the file containing the test and a (sometimes "
"approximate) line number."
msgstr ""

#: ../../library/doctest.rst:1145
#, fuzzy
msgid ""
"Under the covers, :func:`DocTestSuite` creates a "
":class:`unittest.TestSuite` out of :class:`!doctest.DocTestCase` "
"instances, and :class:`!DocTestCase` is a subclass of "
":class:`unittest.TestCase`. :class:`!DocTestCase` isn't documented here "
"(it's an internal detail), but studying its code can answer questions "
"about the exact details of :mod:`unittest` integration."
msgstr ""
"수면 아래에서, :func:`DocTestSuite`\\는 :class:`doctest.DocTestCase` 인스턴스에서 "
":class:`unittest.TestSuite`\\를 만들고, :class:`DocTestCase`\\는 "
":class:`unittest.TestCase`\\의 서브 클래스입니다. :class:`DocTestCase`\\는 여기에서 "
"설명되지는 않지만 (내부 세부 사항입니다), 그것의 코드를 살펴보면 :mod:`unittest` 통합의 정확한 세부 사항에 대한 "
"질문에 대한 답을 얻을 수 있습니다."

#: ../../library/doctest.rst:1151
#, fuzzy
msgid ""
"Similarly, :func:`DocFileSuite` creates a :class:`unittest.TestSuite` out"
" of :class:`!doctest.DocFileCase` instances, and :class:`!DocFileCase` is"
" a subclass of :class:`!DocTestCase`."
msgstr ""
"마찬가지로, :func:`DocFileSuite`\\는 :class:`doctest.DocFileCase` 인스턴스에서 "
":class:`unittest.TestSuite`\\를 만들고, :class:`DocFileCase`\\는 "
":class:`DocTestCase`\\의 서브 클래스입니다."

#: ../../library/doctest.rst:1155
#, fuzzy
msgid ""
"So both ways of creating a :class:`unittest.TestSuite` run instances of "
":class:`!DocTestCase`.  This is important for a subtle reason: when you "
"run :mod:`doctest` functions yourself, you can control the :mod:`doctest`"
" options in use directly, by passing option flags to :mod:`doctest` "
"functions.  However, if you're writing a :mod:`unittest` framework, "
":mod:`unittest` ultimately controls when and how tests get run.  The "
"framework author typically wants to control :mod:`doctest` reporting "
"options (perhaps, e.g., specified by command line options), but there's "
"no way to pass options through :mod:`unittest` to :mod:`doctest` test "
"runners."
msgstr ""
"따라서 :class:`unittest.TestSuite`\\를 만드는 두 가지 방법 모두 :class:`DocTestCase`\\의"
" 인스턴스를 실행합니다. 이것은 미묘한 이유로 중요합니다: 여러분이 :mod:`doctest` 함수를 직접 실행할 때, 옵션 "
"플래그를 :mod:`doctest` 함수에 전달하여 사용 중인 :mod:`doctest` 옵션을 직접 제어할 수 있습니다. 그러나,"
" :mod:`unittest` 프레임워크를 작성한다면, :mod:`unittest`\\가 테스트가 언제 어떻게 실행되는지 궁극적으로"
" 제어합니다. 프레임워크 저자는 일반적으로 :mod:`doctest` (아마도, 예를 들어, 명령 줄 옵션으로 지정하는) "
"보고(reporting) 옵션을 제어하려고 하지만, :mod:`unittest`\\를 통해 :mod:`doctest` 테스트 "
"실행기로 옵션을 전달할 방법이 없습니다."

#: ../../library/doctest.rst:1165
msgid ""
"For this reason, :mod:`doctest` also supports a notion of :mod:`doctest` "
"reporting flags specific to :mod:`unittest` support, via this function:"
msgstr ""
"이러한 이유로, :mod:`doctest`\\는 :mod:`unittest` 지원에 특화된 :mod:`doctest` "
"보고(reporting) 플래그 개념을 다음 함수를 통해 지원합니다:"

#: ../../library/doctest.rst:1171
msgid "Set the :mod:`doctest` reporting flags to use."
msgstr "사용할 :mod:`doctest` 보고 플래그를 설정합니다."

#: ../../library/doctest.rst:1173
msgid ""
"Argument *flags* takes the :ref:`bitwise OR <bitwise>` of option flags.  "
"See section :ref:`doctest-options`.  Only \"reporting flags\" can be "
"used."
msgstr ""
"인자 *flags*\\는 옵션 플래그의 :ref:`비트별 OR <bitwise>`\\를 취합니다. :ref:`doctest-"
"options` 절을 참조하십시오. \"보고 플래그\"만 사용할 수 있습니다."

#: ../../library/doctest.rst:1176
#, fuzzy
msgid ""
"This is a module-global setting, and affects all future doctests run by "
"module :mod:`unittest`:  the :meth:`!runTest` method of "
":class:`!DocTestCase` looks at the option flags specified for the test "
"case when the :class:`!DocTestCase` instance was constructed.  If no "
"reporting flags were specified (which is the typical and expected case), "
":mod:`!doctest`'s :mod:`unittest` reporting flags are :ref:`bitwise ORed "
"<bitwise>` into the option flags, and the option flags so augmented are "
"passed to the :class:`DocTestRunner` instance created to run the doctest."
"  If any reporting flags were specified when the :class:`!DocTestCase` "
"instance was constructed, :mod:`!doctest`'s :mod:`unittest` reporting "
"flags are ignored."
msgstr ""
"이것은 모듈 전역 설정이며, 모듈 :mod:`unittest`\\에 의해 실행되는 모든 미래의 doctest에 영향을 줍니다. "
":class:`DocTestCase`\\의 :meth:`runTest` 메서드는 :class:`DocTestCase` 인스턴스가 "
"생성될 때 테스트 케이스에 대해 지정된 옵션 플래그를 봅니다. 보고 플래그가 지정되지 않았으면 (이것이 일반적이고 예상되는 "
"경우입니다), :mod:`doctest`\\의 :mod:`unittest`\\보고 플래그는 옵션 플래그에 :ref:`비트별 OR "
"<bitwise>`\\되고, 이렇게 손질된 옵션 플래그가 doctest를 실행하기 위해 만들어진 "
":class:`DocTestRunner` 인스턴스로 전달됩니다. :class:`DocTestCase` 인스턴스가 생성될 때 보고 "
"플래그가 지정되었으면, :mod:`doctest`\\의 :mod:`unittest` 보고 플래그는 무시됩니다."

#: ../../library/doctest.rst:1187
msgid ""
"The value of the :mod:`unittest` reporting flags in effect before the "
"function was called is returned by the function."
msgstr "함수가 호출되기 전에 유효했던 :mod:`unittest` 보고 플래그의 값이 함수에 의해 반환됩니다."

#: ../../library/doctest.rst:1194
msgid "Advanced API"
msgstr "고급 API"

#: ../../library/doctest.rst:1196
msgid ""
"The basic API is a simple wrapper that's intended to make doctest easy to"
" use. It is fairly flexible, and should meet most users' needs; however, "
"if you require more fine-grained control over testing, or wish to extend "
"doctest's capabilities, then you should use the advanced API."
msgstr ""
"기본 API는 doctest를 사용하기 쉽게 하기 위한 간단한 래퍼입니다. 그것은 매우 유연하며, 대부분 사용자의 요구를 충족시켜야"
" 합니다; 그러나, 테스팅에 대한 세밀한 제어가 필요하거나, doctest의 기능을 확장하려면, 고급 API를 사용해야 합니다."

#: ../../library/doctest.rst:1201
msgid ""
"The advanced API revolves around two container classes, which are used to"
" store the interactive examples extracted from doctest cases:"
msgstr "고급 API는 doctest 케이스에서 추출한 대화식 예제를 저장하는 데 사용되는 두 개의 컨테이너 클래스를 중심으로 돌아갑니다:"

#: ../../library/doctest.rst:1204
msgid ""
":class:`Example`: A single Python :term:`statement`, paired with its "
"expected output."
msgstr ":class:`Example`: 예상 출력과 쌍을 이루는 단일 파이썬 :term:`문장 <statement>`."

#: ../../library/doctest.rst:1207
msgid ""
":class:`DocTest`: A collection of :class:`Example`\\ s, typically "
"extracted from a single docstring or text file."
msgstr ":class:`DocTest`: 일반적으로 단일 독스트링이나 텍스트 파일에서 추출된 :class:`Example`\\의 모음."

#: ../../library/doctest.rst:1210
msgid ""
"Additional processing classes are defined to find, parse, and run, and "
"check doctest examples:"
msgstr "doctest 예제를 찾고, 구문 분석하고, 실행하고, 검사하기 위해 추가 처리 클래스가 정의됩니다:"

#: ../../library/doctest.rst:1213
msgid ""
":class:`DocTestFinder`: Finds all docstrings in a given module, and uses "
"a :class:`DocTestParser` to create a :class:`DocTest` from every "
"docstring that contains interactive examples."
msgstr ""
":class:`DocTestFinder`: 주어진 모듈에서 모든 독스트링을 찾고, :class:`DocTestParser`\\를 "
"사용하여 대화식 예제가 들어있는 모든 독스트링에서 :class:`DocTest`\\를 만듭니다."

#: ../../library/doctest.rst:1217
msgid ""
":class:`DocTestParser`: Creates a :class:`DocTest` object from a string "
"(such as an object's docstring)."
msgstr ":class:`DocTestParser`: 문자열(가령 객체의 독스트링)에서 :class:`DocTest` 객체를 만듭니다."

#: ../../library/doctest.rst:1220
msgid ""
":class:`DocTestRunner`: Executes the examples in a :class:`DocTest`, and "
"uses an :class:`OutputChecker` to verify their output."
msgstr ""
":class:`DocTestRunner`: :class:`DocTest`\\에 있는 예제를 실행하고, "
":class:`OutputChecker`\\를 사용하여 출력을 확인합니다."

#: ../../library/doctest.rst:1223
msgid ""
":class:`OutputChecker`: Compares the actual output from a doctest example"
" with the expected output, and decides whether they match."
msgstr ":class:`OutputChecker`: doctest 예제의 실제 출력을 예상 출력과 비교하고, 그들이 일치하는지 결정합니다."

#: ../../library/doctest.rst:1226
msgid ""
"The relationships among these processing classes are summarized in the "
"following diagram::"
msgstr "이러한 처리 클래스 간의 관계는 다음 도표에 요약되어 있습니다::"

#: ../../library/doctest.rst:1229
msgid ""
"                            list of:\n"
"+------+                   +---------+\n"
"|module| --DocTestFinder-> | DocTest | --DocTestRunner-> results\n"
"+------+    |        ^     +---------+     |       ^    (printed)\n"
"            |        |     | Example |     |       |\n"
"            v        |     |   ...   |     v       |\n"
"           DocTestParser   | Example |   OutputChecker\n"
"                           +---------+"
msgstr ""

#: ../../library/doctest.rst:1242
msgid "DocTest Objects"
msgstr "DocTest 객체"

#: ../../library/doctest.rst:1247
msgid ""
"A collection of doctest examples that should be run in a single "
"namespace.  The constructor arguments are used to initialize the "
"attributes of the same names."
msgstr "단일 이름 공간에서 실행되어야 하는 doctest 예제의 모음. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다."

#: ../../library/doctest.rst:1251
msgid ""
":class:`DocTest` defines the following attributes.  They are initialized "
"by the constructor, and should not be modified directly."
msgstr ":class:`DocTest`\\는 다음 어트리뷰트를 정의합니다. 이들은 생성자에 의해 초기화되며, 직접 수정하면 안 됩니다."

#: ../../library/doctest.rst:1257
msgid ""
"A list of :class:`Example` objects encoding the individual interactive "
"Python examples that should be run by this test."
msgstr "이 테스트가 실행해야 하는 개별 대화형 파이썬 예제를 인코딩하는 :class:`Example` 객체의 리스트."

#: ../../library/doctest.rst:1263
msgid ""
"The namespace (aka globals) that the examples should be run in. This is a"
" dictionary mapping names to values.  Any changes to the namespace made "
"by the examples (such as binding new variables) will be reflected in "
":attr:`globs` after the test is run."
msgstr ""
"예제가 실행되어야 하는 이름 공간 (일명 전역). 이름을 값에 매핑하는 딕셔너리입니다. 예제가 만든 이름 공간의 모든 변경 "
"사항(가령 새 변수 바인딩)은 테스트가 실행된 후 :attr:`globs`\\에 반영됩니다."

#: ../../library/doctest.rst:1271
msgid ""
"A string name identifying the :class:`DocTest`.  Typically, this is the "
"name of the object or file that the test was extracted from."
msgstr ":class:`DocTest`\\를 식별하는 문자열 이름. 일반적으로, 테스트가 추출된 객체나 파일의 이름입니다."

#: ../../library/doctest.rst:1277
msgid ""
"The name of the file that this :class:`DocTest` was extracted from; or "
"``None`` if the filename is unknown, or if the :class:`DocTest` was not "
"extracted from a file."
msgstr ""
"이 :class:`DocTest`\\가 추출된 파일의 이름; 또는 파일 이름을 알 수 없거나 파일에서 "
":class:`DocTest`\\가 추출되지 않았으면 ``None``."

#: ../../library/doctest.rst:1284
msgid ""
"The line number within :attr:`filename` where this :class:`DocTest` "
"begins, or ``None`` if the line number is unavailable.  This line number "
"is zero-based with respect to the beginning of the file."
msgstr ""
"이 :class:`DocTest`\\가 시작되는 :attr:`filename` 내의 줄 번호, 또는 줄 번호가 없으면 "
"``None``. 이 줄 번호는 파일의 시작 부분을 기준으로 0에서 시작합니다."

#: ../../library/doctest.rst:1291
msgid ""
"The string that the test was extracted from, or ``None`` if the string is"
" unavailable, or if the test was not extracted from a string."
msgstr "테스트가 추출된 문자열, 또는 문자열이 없거나 테스트가 문자열에서 추출되지 않았으면 ``None``."

#: ../../library/doctest.rst:1298
msgid "Example Objects"
msgstr "Example 객체"

#: ../../library/doctest.rst:1303
msgid ""
"A single interactive example, consisting of a Python statement and its "
"expected output.  The constructor arguments are used to initialize the "
"attributes of the same names."
msgstr "파이썬 문장과 예상 출력으로 구성된 단일 대화형 예제. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다."

#: ../../library/doctest.rst:1308
msgid ""
":class:`Example` defines the following attributes.  They are initialized "
"by the constructor, and should not be modified directly."
msgstr ":class:`Example`\\는 다음 어트리뷰트를 정의합니다. 이들은 생성자에 의해 초기화되며, 직접 수정하면 안 됩니다."

#: ../../library/doctest.rst:1314
msgid ""
"A string containing the example's source code.  This source code consists"
" of a single Python statement, and always ends with a newline; the "
"constructor adds a newline when necessary."
msgstr ""
"예제의 소스 코드가 포함된 문자열. 이 소스 코드는 단일 파이썬 문으로 구성되며 항상 개행으로 끝납니다; 생성자는 필요하면 개행 "
"문자를 추가합니다."

#: ../../library/doctest.rst:1321
msgid ""
"The expected output from running the example's source code (either from "
"stdout, or a traceback in case of exception).  :attr:`want` ends with a "
"newline unless no output is expected, in which case it's an empty string."
"  The constructor adds a newline when necessary."
msgstr ""
"예제의 소스 코드를 실행할 때 (stdout이나 예외 발생 시 트레이스백으로부터) 예상되는 출력. :attr:`want`\\는 "
"출력이 예상되지 않으면 빈 문자열이고, 그렇지 않으면 개행으로 끝납니다. 생성자는 필요하면 개행을 추가합니다."

#: ../../library/doctest.rst:1329
msgid ""
"The exception message generated by the example, if the example is "
"expected to generate an exception; or ``None`` if it is not expected to "
"generate an exception.  This exception message is compared against the "
"return value of :func:`traceback.format_exception_only`.  :attr:`exc_msg`"
" ends with a newline unless it's ``None``.  The constructor adds a "
"newline if needed."
msgstr ""
"예제가 예외를 생성할 것으로 예상되면, 예제에서 생성된 예외 메시지; 또는 예외를 생성할 것으로 예상되지 않으면 ``None``. "
"이 예외 메시지는 :func:`traceback.format_exception_only`\\의 반환 값과 비교됩니다. "
":attr:`exc_msg`\\는 ``None``\\이 아니면 개행으로 끝납니다. 생성자는 필요하면 개행을 추가합니다."

#: ../../library/doctest.rst:1338
msgid ""
"The line number within the string containing this example where the "
"example begins.  This line number is zero-based with respect to the "
"beginning of the containing string."
msgstr ""
"이 예제가 시작하는 이 예제를 포함하는 문자열 내의 줄 번호. 이 줄 번호는 포함하는 문자열의 시작 부분을 기준으로 0에서 "
"시작합니다."

#: ../../library/doctest.rst:1345
msgid ""
"The example's indentation in the containing string, i.e., the number of "
"space characters that precede the example's first prompt."
msgstr "포함하는 문자열 내에서의 이 예제의 들여쓰기, 즉 예제의 첫 번째 프롬프트 앞에 오는 스페이스 문자의 수."

#: ../../library/doctest.rst:1351
#, fuzzy
msgid ""
"A dictionary mapping from option flags to ``True`` or ``False``, which is"
" used to override default options for this example.  Any option flags not"
" contained in this dictionary are left at their default value (as "
"specified by the :class:`DocTestRunner`'s :ref:`optionflags <doctest-"
"options>`). By default, no options are set."
msgstr ""
"옵션 플래그에서 ``True``\\나 ``False`` 로 매핑하는 딕셔너리, 이 예제의 기본 옵션을 재정의하는 데 사용됩니다. 이"
" 딕셔너리에 포함되지 않은 옵션 플래그는 (:class:`DocTestRunner`\\의 :attr:`optionflags`\\에 "
"지정된 대로) 기본값으로 남습니다. 기본적으로, 아무런 옵션도 설정되지 않습니다."

#: ../../library/doctest.rst:1361
msgid "DocTestFinder objects"
msgstr "DocTestFinder 객체"

#: ../../library/doctest.rst:1366
msgid ""
"A processing class used to extract the :class:`DocTest`\\ s that are "
"relevant to a given object, from its docstring and the docstrings of its "
"contained objects. :class:`DocTest`\\ s can be extracted from modules, "
"classes, functions, methods, staticmethods, classmethods, and properties."
msgstr ""
"주어진 객체에 관련된 :class:`DocTest`\\를 그것의 독스트링과 그것이 포함하는 객체의 독스트링으로부터 추출하기 위해서 "
"사용되는 처리 클래스. :class:`DocTest`\\는 모듈, 클래스, 함수, 메서드, 정적 메서드, 클래스 메서드 및 "
"프로퍼티에서 추출할 수 있습니다."

#: ../../library/doctest.rst:1371
msgid ""
"The optional argument *verbose* can be used to display the objects "
"searched by the finder.  It defaults to ``False`` (no output)."
msgstr ""
"선택적 인자 *verbose*\\는 파인더가 검색한 객체를 표시하는 데 사용될 수 있습니다. 기본값은 ``False`` (출력 "
"없음)입니다."

#: ../../library/doctest.rst:1374
msgid ""
"The optional argument *parser* specifies the :class:`DocTestParser` "
"object (or a drop-in replacement) that is used to extract doctests from "
"docstrings."
msgstr ""
"선택적 인자 *parser*\\는 독스트링에서 doctest를 추출하는 데 사용되는 :class:`DocTestParser` 객체 "
"(또는 드롭 인 대체)를 지정합니다."

#: ../../library/doctest.rst:1377
msgid ""
"If the optional argument *recurse* is false, then "
":meth:`DocTestFinder.find` will only examine the given object, and not "
"any contained objects."
msgstr ""
"선택적 인자 *recurse*\\가 거짓이면, :meth:`DocTestFinder.find`\\는 오직 주어진 객체만을 검사 할 "
"뿐, 포함된 객체는 검사하지 않습니다."

#: ../../library/doctest.rst:1380
msgid ""
"If the optional argument *exclude_empty* is false, then "
":meth:`DocTestFinder.find` will include tests for objects with empty "
"docstrings."
msgstr ""
"선택적 인자 *exclude_empty*\\가 거짓이면, :meth:`DocTestFinder.find`\\는 빈 독스트링을 가진 "
"객체에 대한 테스트를 포함합니다."

#: ../../library/doctest.rst:1384
msgid ":class:`DocTestFinder` defines the following method:"
msgstr ":class:`DocTestFinder`\\는 다음 메서드를 정의합니다:"

#: ../../library/doctest.rst:1389
msgid ""
"Return a list of the :class:`DocTest`\\ s that are defined by *obj*'s "
"docstring, or by any of its contained objects' docstrings."
msgstr "*obj*\\의 독스트링이나 포함된 객체의 독스트링으로 정의된 :class:`DocTest`\\의 리스트를 반환합니다."

#: ../../library/doctest.rst:1392
msgid ""
"The optional argument *name* specifies the object's name; this name will "
"be used to construct names for the returned :class:`DocTest`\\ s.  If "
"*name* is not specified, then ``obj.__name__`` is used."
msgstr ""
"선택적 인자 *name*\\은 객체의 이름을 지정합니다. 이 이름은 반환된 :class:`DocTest`\\의 이름을 구성하는 데 "
"사용됩니다. *name*\\이 지정되지 않으면, ``obj.__name__``\\이 사용됩니다."

#: ../../library/doctest.rst:1396
msgid ""
"The optional parameter *module* is the module that contains the given "
"object. If the module is not specified or is ``None``, then the test "
"finder will attempt to automatically determine the correct module.  The "
"object's module is used:"
msgstr ""
"선택적 매개 변수 *module*\\은 주어진 객체를 포함하는 모듈입니다. 모듈이 지정되지 않거나 ``None``\\이면, 테스트 "
"파인더는 자동으로 올바른 모듈을 판별하려고 시도합니다. 객체의 모듈은 다음과 같이 사용됩니다:"

#: ../../library/doctest.rst:1400
msgid "As a default namespace, if *globs* is not specified."
msgstr "*globs*\\가 지정되지 않으면, 기본 이름 공간으로."

#: ../../library/doctest.rst:1402
msgid ""
"To prevent the DocTestFinder from extracting DocTests from objects that "
"are imported from other modules.  (Contained objects with modules other "
"than *module* are ignored.)"
msgstr ""
"DocTestFinder가 다른 모듈에서 임포트 된 객체에서 DocTest를 추출하지 못하도록 하려고. (*module*\\이 아닌"
" 다른 모듈을 가진 포함 된 객체는 무시됩니다.)"

#: ../../library/doctest.rst:1406
msgid "To find the name of the file containing the object."
msgstr "객체를 포함하는 파일의 이름을 찾으려고."

#: ../../library/doctest.rst:1408
msgid "To help find the line number of the object within its file."
msgstr "해당 파일 내에서 객체의 줄 번호를 찾는 데 도움이 됩니다."

#: ../../library/doctest.rst:1410
msgid ""
"If *module* is ``False``, no attempt to find the module will be made.  "
"This is obscure, of use mostly in testing doctest itself: if *module* is "
"``False``, or is ``None`` but cannot be found automatically, then all "
"objects are considered to belong to the (non-existent) module, so all "
"contained objects will (recursively) be searched for doctests."
msgstr ""
"*module*\\이 ``False``\\면, 모듈을 찾으려고 시도하지 않습니다. 이것은 눈에 띄지 않는데, 대부분 doctest "
"자체를 테스트할 때 사용합니다: *module*\\이 ``False``\\이거나, ``None``\\이지만 자동으로 찾을 수 "
"없으면, 모든 객체는 (존재하지 않는) 모듈에 속한 것으로 간주하므로, 포함된 모든 객체에서 (재귀적으로) doctest를 "
"검색합니다."

#: ../../library/doctest.rst:1416
#, python-brace-format
msgid ""
"The globals for each :class:`DocTest` is formed by combining *globs* and "
"*extraglobs* (bindings in *extraglobs* override bindings in *globs*).  A "
"new shallow copy of the globals dictionary is created for each "
":class:`DocTest`. If *globs* is not specified, then it defaults to the "
"module's *__dict__*, if specified, or ``{}`` otherwise.  If *extraglobs* "
"is not specified, then it defaults to ``{}``."
msgstr ""
"각 :class:`DocTest`\\에 대한 전역은 *globs*\\와 *extraglobs*\\(*extraglobs*\\의 "
"바인딩이 *globs*\\의 바인딩에 우선합니다)를 결합하여 구성됩니다. 각 :class:`DocTest`\\마다 전역 딕셔너리의 "
"새 얕은 복사본이 만들어집니다. *globs*\\를 지정하지 않으면, 기본값은 모듈이 지정되었다면 모듈의 *__dict__*, 또는"
" 그렇지 않으면 ``{}``\\입니다. *extraglobs*\\가 지정되지 않으면, 기본값은 ``{}``\\입니다."

#: ../../library/doctest.rst:1427
msgid "DocTestParser objects"
msgstr "DocTestParser 객체"

#: ../../library/doctest.rst:1432
msgid ""
"A processing class used to extract interactive examples from a string, "
"and use them to create a :class:`DocTest` object."
msgstr "문자열에서 대화형 예제를 추출하고, 이를 사용하여 :class:`DocTest` 객체를 만드는 데 사용되는 처리 클래스."

#: ../../library/doctest.rst:1436
msgid ":class:`DocTestParser` defines the following methods:"
msgstr ":class:`DocTestParser`\\는 다음 메서드를 정의합니다:"

#: ../../library/doctest.rst:1441
msgid ""
"Extract all doctest examples from the given string, and collect them into"
" a :class:`DocTest` object."
msgstr "주어진 문자열에서 모든 doctest 예제를 추출하고, 이를 :class:`DocTest` 객체로 모읍니다."

#: ../../library/doctest.rst:1444
msgid ""
"*globs*, *name*, *filename*, and *lineno* are attributes for the new "
":class:`DocTest` object.  See the documentation for :class:`DocTest` for "
"more information."
msgstr ""
"*globs*, *name*, *filename* 및 *lineno*\\는 새 :class:`DocTest` 객체의 "
"어트리뷰트입니다. 자세한 내용은 :class:`DocTest` 설명서를 참조하십시오."

#: ../../library/doctest.rst:1451
msgid ""
"Extract all doctest examples from the given string, and return them as a "
"list of :class:`Example` objects.  Line numbers are 0-based.  The "
"optional argument *name* is a name identifying this string, and is only "
"used for error messages."
msgstr ""
"주어진 문자열에서 모든 doctest 예제를 추출하고, 이를 :class:`Example` 객체의 리스트로 반환합니다. 줄 번호는 "
"0부터 시작합니다. 선택적 인자 *name*\\은, 이 문자열을 식별하는 이름이며, 에러 메시지에만 사용됩니다."

#: ../../library/doctest.rst:1458
msgid ""
"Divide the given string into examples and intervening text, and return "
"them as a list of alternating :class:`Example`\\ s and strings. Line "
"numbers for the :class:`Example`\\ s are 0-based.  The optional argument "
"*name* is a name identifying this string, and is only used for error "
"messages."
msgstr ""
"주어진 문자열을 예제와 중간에 있는 텍스트로 나누고, 이를 :class:`Example`\\와 문자열이 번갈아 나오는 리스트로 "
"반환합니다. :class:`Example`\\의 줄 번호는 0부터 시작합니다. 선택적 인자 *name*\\은, 이 문자열을 식별하는"
" 이름이며, 에러 메시지에만 사용됩니다."

#: ../../library/doctest.rst:1465
#, fuzzy
msgid "TestResults objects"
msgstr "DocTest 객체"

#: ../../library/doctest.rst:1472
msgid "Number of failed tests."
msgstr ""

#: ../../library/doctest.rst:1476
msgid "Number of attempted tests."
msgstr ""

#: ../../library/doctest.rst:1480
msgid "Number of skipped tests."
msgstr ""

#: ../../library/doctest.rst:1488
msgid "DocTestRunner objects"
msgstr "DocTestRunner 객체"

#: ../../library/doctest.rst:1493
msgid ""
"A processing class used to execute and verify the interactive examples in"
" a :class:`DocTest`."
msgstr ":class:`DocTest`\\에 있는 대화형 예제를 실행하고 검증하는 데 사용되는 처리 클래스."

#: ../../library/doctest.rst:1496
msgid ""
"The comparison between expected outputs and actual outputs is done by an "
":class:`OutputChecker`.  This comparison may be customized with a number "
"of option flags; see section :ref:`doctest-options` for more information."
"  If the option flags are insufficient, then the comparison may also be "
"customized by passing a subclass of :class:`OutputChecker` to the "
"constructor."
msgstr ""
"예상 출력과 실제 출력 간의 비교는 :class:`OutputChecker`\\에 의해 수행됩니다. 이 비교는 여러 옵션 플래그로 "
"사용자 정의할 수 있습니다; 자세한 내용은 :ref:`doctest-options` 절을 참조하십시오. 옵션 플래그로 충분하지 "
"않으면, :class:`OutputChecker`\\의 서브 클래스를 생성자에 전달하여 비교를 사용자 정의할 수도 있습니다."

#: ../../library/doctest.rst:1502
#, fuzzy
msgid ""
"The test runner's display output can be controlled in two ways. First, an"
" output function can be passed to :meth:`run`; this function will be "
"called with strings that should be displayed.  It defaults to "
"``sys.stdout.write``.  If capturing the output is not sufficient, then "
"the display output can be also customized by subclassing DocTestRunner, "
"and overriding the methods :meth:`report_start`, :meth:`report_success`, "
":meth:`report_unexpected_exception`, and :meth:`report_failure`."
msgstr ""
"테스트 실행기의 디스플레이 출력은 두 가지 방법으로 제어할 수 있습니다. 첫째, 출력 함수를 "
":meth:`TestRunner.run`\\로 전달할 수 있습니다; 이 함수는 표시되어야 하는 문자열로 호출됩니다. 기본값은 "
"``sys.stdout.write``\\입니다. 출력을 캡처하는 것으로 충분하지 않으면, DocTestRunner를 서브 클래싱하고"
" :meth:`report_start`, :meth:`report_success`, "
":meth:`report_unexpected_exception` 및 :meth:`report_failure` 메서드를 재정의하여 "
"디스플레이 출력을 사용자 정의할 수 있습니다."

#: ../../library/doctest.rst:1510
msgid ""
"The optional keyword argument *checker* specifies the "
":class:`OutputChecker` object (or drop-in replacement) that should be "
"used to compare the expected outputs to the actual outputs of doctest "
"examples."
msgstr ""
"선택적 키워드 인자 *checker*\\는 예상 출력을 doctest 예제의 실제 출력과 비교하는 데 사용되는 "
":class:`OutputChecker` 객체(또는 드롭 인 대체)를 지정합니다."

#: ../../library/doctest.rst:1514
msgid ""
"The optional keyword argument *verbose* controls the "
":class:`DocTestRunner`'s verbosity.  If *verbose* is ``True``, then "
"information is printed about each example, as it is run.  If *verbose* is"
" ``False``, then only failures are printed.  If *verbose* is unspecified,"
" or ``None``, then verbose output is used iff the command-line switch "
"``-v`` is used."
msgstr ""
"선택적 키워드 인자 *verbose*\\는 :class:`DocTestRunner`\\의 상세도를 제어합니다. "
"*verbose*\\가 ``True``\\이면, 실행될 때 각 예제에 대한 정보가 인쇄됩니다. *verbose*\\가 "
"``False``\\이면, 실패만 인쇄됩니다. *verbose*\\가 지정되지 않거나 ``None``\\이면, 명령 줄 스위치 "
"``-v``\\가 사용될 때만 상세 출력이 사용됩니다."

#: ../../library/doctest.rst:1520
msgid ""
"The optional keyword argument *optionflags* can be used to control how "
"the test runner compares expected output to actual output, and how it "
"displays failures. For more information, see section :ref:`doctest-"
"options`."
msgstr ""
"선택적 키워드 인자 *optionflags*\\는 테스트 실행기가 예상 출력을 실제 출력과 비교하는 방법과 실패를 표시하는 방법을 "
"제어하는 데 사용할 수 있습니다. 자세한 내용은 :ref:`doctest-options` 절을 참조하십시오."

#: ../../library/doctest.rst:1524
msgid ""
"The test runner accumulates statistics. The aggregated number of "
"attempted, failed and skipped examples is also available via the "
":attr:`tries`, :attr:`failures` and :attr:`skips` attributes. The "
":meth:`run` and :meth:`summarize` methods return a :class:`TestResults` "
"instance."
msgstr ""

#: ../../library/doctest.rst:1529
#, fuzzy
msgid ":class:`DocTestRunner` defines the following methods:"
msgstr ":class:`DocTestParser`\\는 다음 메서드를 정의합니다:"

#: ../../library/doctest.rst:1534
msgid ""
"Report that the test runner is about to process the given example. This "
"method is provided to allow subclasses of :class:`DocTestRunner` to "
"customize their output; it should not be called directly."
msgstr ""
"테스트 러너가 주어진 예제를 처리하려고 한다고 보고합니다. 이 메서드는 :class:`DocTestRunner`\\의 서브 클래스가"
" 출력을 사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다."

#: ../../library/doctest.rst:1538
msgid ""
"*example* is the example about to be processed.  *test* is the test "
"*containing example*.  *out* is the output function that was passed to "
":meth:`DocTestRunner.run`."
msgstr ""
"*example*\\은 처리될 예제입니다. *test*\\는 *예제를 포함하는* 테스트입니다. *out*\\은 "
":meth:`DocTestRunner.run`\\에 전달된 출력 함수입니다."

#: ../../library/doctest.rst:1545
msgid ""
"Report that the given example ran successfully.  This method is provided "
"to allow subclasses of :class:`DocTestRunner` to customize their output; "
"it should not be called directly."
msgstr ""
"주어진 예제가 성공적으로 실행되었음을 보고합니다. 이 메서드는 :class:`DocTestRunner`\\의 서브 클래스가 출력을 "
"사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다."

#: ../../library/doctest.rst:1549 ../../library/doctest.rst:1560
msgid ""
"*example* is the example about to be processed.  *got* is the actual "
"output from the example.  *test* is the test containing *example*.  *out*"
" is the output function that was passed to :meth:`DocTestRunner.run`."
msgstr ""
"*example*\\은 처리될 예제입니다. *got*\\은 예제의 실제 출력입니다. *test*\\는 *example*\\을 "
"포함하는 테스트입니다. *out*\\은 :meth:`DocTestRunner.run`\\에 전달된 출력 함수입니다."

#: ../../library/doctest.rst:1556
msgid ""
"Report that the given example failed.  This method is provided to allow "
"subclasses of :class:`DocTestRunner` to customize their output; it should"
" not be called directly."
msgstr ""
"주어진 예제가 실패했음을 보고합니다. 이 메서드는 :class:`DocTestRunner`\\의 서브 클래스가 출력을 사용자 정의할"
" 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다."

#: ../../library/doctest.rst:1567
msgid ""
"Report that the given example raised an unexpected exception. This method"
" is provided to allow subclasses of :class:`DocTestRunner` to customize "
"their output; it should not be called directly."
msgstr ""
"주어진 예제가 예기치 않은 예외를 발생시켰다고 보고합니다. 이 메서드는 :class:`DocTestRunner`\\의 서브 클래스가"
" 출력을 사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다."

#: ../../library/doctest.rst:1571
msgid ""
"*example* is the example about to be processed. *exc_info* is a tuple "
"containing information about the unexpected exception (as returned by "
":func:`sys.exc_info`). *test* is the test containing *example*.  *out* is"
" the output function that was passed to :meth:`DocTestRunner.run`."
msgstr ""
"*example*\\은 처리될 예제입니다. *exc_info*\\는 예기치 않은 예외에 대한 정보를 포함하는 튜플입니다 "
"(:func:`sys.exc_info`\\에 의해 반환되는 것). *test*\\는 *example*\\을 포함하는 테스트입니다. "
"*out*\\은 :meth:`DocTestRunner.run`\\에 전달된 출력 함수입니다."

#: ../../library/doctest.rst:1579
#, fuzzy
msgid ""
"Run the examples in *test* (a :class:`DocTest` object), and display the "
"results using the writer function *out*. Return a :class:`TestResults` "
"instance."
msgstr "*test*\\(:class:`DocTest` 객체)에 있는 예제를 실행하고, 출력 함수 *out*\\을 사용하여 결과를 표시합니다."

#: ../../library/doctest.rst:1583
msgid ""
"The examples are run in the namespace ``test.globs``.  If *clear_globs* "
"is true (the default), then this namespace will be cleared after the test"
" runs, to help with garbage collection. If you would like to examine the "
"namespace after the test completes, then use *clear_globs=False*."
msgstr ""
"예제는 이름 공간 ``test.globs``\\에서 실행됩니다. *clear_globs*\\가 참(기본값)이면, 가비지 수집을 돕기"
" 위해 테스트가 실행된 후 이 이름 공간이 지워집니다. 테스트가 완료된 후에 이름 공간을 검사하려면 "
"*clear_globs=False*\\를 사용하십시오."

#: ../../library/doctest.rst:1588
msgid ""
"*compileflags* gives the set of flags that should be used by the Python "
"compiler when running the examples.  If not specified, then it will "
"default to the set of future-import flags that apply to *globs*."
msgstr ""
"*compileflags*\\는 예제를 실행할 때 파이썬 컴파일러에서 사용해야 하는 플래그 집합을 제공합니다. 지정되지 않으면, "
"*globs*\\에 적용되는 퓨처-임포트 플래그 집합이 기본값이 됩니다."

#: ../../library/doctest.rst:1592
#, fuzzy
msgid ""
"The output of each example is checked using the :class:`DocTestRunner`'s "
"output checker, and the results are formatted by the "
":meth:`!DocTestRunner.report_\\*` methods."
msgstr ""
"각 예제의 출력은 :class:`DocTestRunner`\\의 출력 검사기를 사용하여 검사되며, 결과는 "
":meth:`DocTestRunner.report_\\*` 메서드로 포맷됩니다."

#: ../../library/doctest.rst:1599
#, fuzzy
msgid ""
"Print a summary of all the test cases that have been run by this "
"DocTestRunner, and return a :class:`TestResults` instance."
msgstr ""
"이 DocTestRunner가 실행 한 모든 테스트 케이스의 요약을 인쇄하고, :term:`네임드 튜플 <named tuple>` "
"``TestResults(failed, attempted)``\\를 반환합니다."

#: ../../library/doctest.rst:1602
msgid ""
"The optional *verbose* argument controls how detailed the summary is.  If"
" the verbosity is not specified, then the :class:`DocTestRunner`'s "
"verbosity is used."
msgstr ""
"선택적 *verbose* 인자는 요약이 얼마나 상세할지를 제어합니다. 상세도가 지정되지 않으면, "
":class:`DocTestRunner`\\의 상세도가 사용됩니다."

#: ../../library/doctest.rst:1606
#, fuzzy
msgid ":class:`DocTestParser` has the following attributes:"
msgstr ":exc:`DocTestFailure`\\는 다음 어트리뷰트를 정의합니다:"

#: ../../library/doctest.rst:1610
msgid "Number of attempted examples."
msgstr ""

#: ../../library/doctest.rst:1614
msgid "Number of failed examples."
msgstr ""

#: ../../library/doctest.rst:1618
msgid "Number of skipped examples."
msgstr ""

#: ../../library/doctest.rst:1626
msgid "OutputChecker objects"
msgstr "OutputChecker 객체"

#: ../../library/doctest.rst:1631
msgid ""
"A class used to check the whether the actual output from a doctest "
"example matches the expected output.  :class:`OutputChecker` defines two "
"methods: :meth:`check_output`, which compares a given pair of outputs, "
"and returns ``True`` if they match; and :meth:`output_difference`, which "
"returns a string describing the differences between two outputs."
msgstr ""
"doctest 예제의 실제 출력이 예상 출력과 일치하는지를 확인하는 데 사용되는 클래스. "
":class:`OutputChecker`\\는 두 가지 메서드를 정의합니다: :meth:`check_output`\\은 주어진 출력"
" 쌍을 비교하고 일치하면 ``True``\\를 반환합니다; :meth:`output_difference`\\는 두 출력 간의 차이를"
" 설명하는 문자열을 반환합니다."

#: ../../library/doctest.rst:1638
msgid ":class:`OutputChecker` defines the following methods:"
msgstr ":class:`OutputChecker`\\는 다음 메서드를 정의합니다:"

#: ../../library/doctest.rst:1642
msgid ""
"Return ``True`` iff the actual output from an example (*got*) matches the"
" expected output (*want*).  These strings are always considered to match "
"if they are identical; but depending on what option flags the test runner"
" is using, several non-exact match types are also possible.  See section "
":ref:`doctest-options` for more information about option flags."
msgstr ""
"예제의 실제 출력(*got*)이 예상 출력(*want*)과 일치할 때만 ``True``\\를 반환합니다. 이 문자열은 같으면 항상 "
"일치하는 것으로 간주합니다; 그러나 테스트 실행기가 사용하는 옵션 플래그에 따라 몇 가지 정확하지 않은 일치 유형도 가능합니다. "
"옵션 플래그에 대한 자세한 정보는 :ref:`doctest-options` 절을 참조하십시오."

#: ../../library/doctest.rst:1651
msgid ""
"Return a string describing the differences between the expected output "
"for a given example (*example*) and the actual output (*got*).  "
"*optionflags* is the set of option flags used to compare *want* and "
"*got*."
msgstr ""
"주어진 예제(*example*)에 대한 예상 출력과 실제 출력(*got*)의 차이를 설명하는 문자열을 반환합니다. "
"*optionflags*\\는 *want*\\와 *got*\\을 비교하는 데 사용되는 옵션 플래그 집합입니다."

#: ../../library/doctest.rst:1659
msgid "Debugging"
msgstr "디버깅"

#: ../../library/doctest.rst:1661
msgid "Doctest provides several mechanisms for debugging doctest examples:"
msgstr "Doctest는 doctest 예제를 디버깅하기 위한 몇 가지 메커니즘을 제공합니다:"

#: ../../library/doctest.rst:1663
msgid ""
"Several functions convert doctests to executable Python programs, which "
"can be run under the Python debugger, :mod:`pdb`."
msgstr "몇몇 함수는 doctest를 파이썬 디버거 :mod:`pdb`\\에서 실행할 수 있는 실행 가능한 파이썬 프로그램으로 변환합니다."

#: ../../library/doctest.rst:1666
msgid ""
"The :class:`DebugRunner` class is a subclass of :class:`DocTestRunner` "
"that raises an exception for the first failing example, containing "
"information about that example. This information can be used to perform "
"post-mortem debugging on the example."
msgstr ""
":class:`DebugRunner` 클래스는 첫 번째 실패한 예제에 대한 예외를 발생시키는 "
":class:`DocTestRunner`\\의 서브 클래스이며 해당 예제에 대한 정보가 들어 있습니다. 이 정보는 예제에서 사후 "
"디버깅을 수행하는 데 사용될 수 있습니다."

#: ../../library/doctest.rst:1671
msgid ""
"The :mod:`unittest` cases generated by :func:`DocTestSuite` support the "
":meth:`debug` method defined by :class:`unittest.TestCase`."
msgstr ""
":func:`DocTestSuite`\\에 의해 생성된 :mod:`unittest` 케이스는 "
":class:`unittest.TestCase`\\에 의해 정의된 :meth:`debug` 메서드를 지원합니다."

#: ../../library/doctest.rst:1674
msgid ""
"You can add a call to :func:`pdb.set_trace` in a doctest example, and "
"you'll drop into the Python debugger when that line is executed.  Then "
"you can inspect current values of variables, and so on.  For example, "
"suppose :file:`a.py` contains just this module docstring::"
msgstr ""
"doctest 예제에 :func:`pdb.set_trace`\\에 대한 호출을 추가 할 수 있습니다. 그러면 해당하는 줄이 실행될 "
"때 파이썬 디버거로 들어갑니다. 그런 다음 변수의 현재 값을 검사하는 등의 일을 할 수 있습니다. 예를 들어, "
":file:`a.py`\\가 다음과 같은 모듈 독스트링을 포함한다고 가정합시다::"

#: ../../library/doctest.rst:1679
msgid ""
"\"\"\"\n"
">>> def f(x):\n"
"...     g(x*2)\n"
">>> def g(x):\n"
"...     print(x+3)\n"
"...     import pdb; pdb.set_trace()\n"
">>> f(3)\n"
"9\n"
"\"\"\""
msgstr ""

#: ../../library/doctest.rst:1689
msgid "Then an interactive Python session may look like this::"
msgstr "그러면 대화형 파이썬 세션은 이런 식이 됩니다::"

#: ../../library/doctest.rst:1691
msgid ""
">>> import a, doctest\n"
">>> doctest.testmod(a)\n"
"--Return--\n"
"> <doctest a[1]>(3)g()->None\n"
"-> import pdb; pdb.set_trace()\n"
"(Pdb) list\n"
"  1     def g(x):\n"
"  2         print(x+3)\n"
"  3  ->     import pdb; pdb.set_trace()\n"
"[EOF]\n"
"(Pdb) p x\n"
"6\n"
"(Pdb) step\n"
"--Return--\n"
"> <doctest a[0]>(2)f()->None\n"
"-> g(x*2)\n"
"(Pdb) list\n"
"  1     def f(x):\n"
"  2  ->     g(x*2)\n"
"[EOF]\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) step\n"
"--Return--\n"
"> <doctest a[2]>(1)?()->None\n"
"-> f(3)\n"
"(Pdb) cont\n"
"(0, 3)\n"
">>>"
msgstr ""

#: ../../library/doctest.rst:1722
msgid ""
"Functions that convert doctests to Python code, and possibly run the "
"synthesized code under the debugger:"
msgstr "Doctest를 파이썬 코드로 변환하고, 디버거에서 합성 코드를 실행할 수 있는 함수들:"

#: ../../library/doctest.rst:1728
msgid "Convert text with examples to a script."
msgstr "예제가 있는 텍스트를 스크립트로 변환합니다."

#: ../../library/doctest.rst:1730
msgid ""
"Argument *s* is a string containing doctest examples.  The string is "
"converted to a Python script, where doctest examples in *s* are converted"
" to regular code, and everything else is converted to Python comments.  "
"The generated script is returned as a string. For example, ::"
msgstr ""
"인자 *s*\\는 doctest 예제를 포함하는 문자열입니다. 문자열은 파이썬 스크립트로 변환됩니다. 여기서 *s*\\의 "
"doctest 예제는 일반 코드로 변환되고, 나머지는 파이썬 주석으로 변환됩니다. 생성된 스크립트는 문자열로 반환됩니다. 예를 "
"들어, ::"

#: ../../library/doctest.rst:1735
msgid ""
"import doctest\n"
"print(doctest.script_from_examples(r\"\"\"\n"
"    Set x and y to 1 and 2.\n"
"    >>> x, y = 1, 2\n"
"\n"
"    Print their sum:\n"
"    >>> print(x+y)\n"
"    3\n"
"\"\"\"))"
msgstr ""

#: ../../library/doctest.rst:1745
msgid "displays::"
msgstr "는 다음과 같이 출력합니다::"

#: ../../library/doctest.rst:1747
msgid ""
"# Set x and y to 1 and 2.\n"
"x, y = 1, 2\n"
"#\n"
"# Print their sum:\n"
"print(x+y)\n"
"# Expected:\n"
"## 3"
msgstr ""

#: ../../library/doctest.rst:1755
msgid ""
"This function is used internally by other functions (see below), but can "
"also be useful when you want to transform an interactive Python session "
"into a Python script."
msgstr "이 함수는 다른 함수(아래 참조)에서 내부적으로 사용되지만, 대화형 파이썬 세션을 파이썬 스크립트로 변환하려고 할 때도 유용합니다."

#: ../../library/doctest.rst:1762
msgid "Convert the doctest for an object to a script."
msgstr "객체에 대한 doctest를 스크립트로 변환합니다."

#: ../../library/doctest.rst:1764
#, fuzzy
msgid ""
"Argument *module* is a module object, or dotted name of a module, "
"containing the object whose doctests are of interest.  Argument *name* is"
" the name (within the module) of the object with the doctests of "
"interest.  The result is a string, containing the object's docstring "
"converted to a Python script, as described for "
":func:`script_from_examples` above.  For example, if module :file:`a.py` "
"contains a top-level function :func:`!f`, then ::"
msgstr ""
"인자 *module*\\은 doctest가 관심 대상인 객체를 포함하는 모듈 객체나 모듈의 점으로 구분된 이름입니다. 인자 "
"*name*\\은 doctest가 관심 대상인 객체의 (모듈 내에서의) 이름입니다. 결과는 위의 "
":func:`script_from_examples`\\에서 설명한 대로 파이썬 스크립트로 변환된 객체의 독스트링을 포함하는 "
"문자열입니다. 예를 들어, 모듈 :file:`a.py`\\에 최상위 함수 :func:`f`\\가 포함되었다면, ::"

#: ../../library/doctest.rst:1771
msgid ""
"import a, doctest\n"
"print(doctest.testsource(a, \"a.f\"))"
msgstr ""

#: ../../library/doctest.rst:1774
#, fuzzy
msgid ""
"prints a script version of function :func:`!f`'s docstring, with doctests"
" converted to code, and the rest placed in comments."
msgstr "는 doctest가 코드로 변환되고 나머지는 주석으로 배치된, 함수 :func:`f`\\의 독스트링의 스크립트 버전을 인쇄합니다."

#: ../../library/doctest.rst:1780
msgid "Debug the doctests for an object."
msgstr "객체의 doctest를 디버그합니다."

#: ../../library/doctest.rst:1782
msgid ""
"The *module* and *name* arguments are the same as for function "
":func:`testsource` above.  The synthesized Python script for the named "
"object's docstring is written to a temporary file, and then that file is "
"run under the control of the Python debugger, :mod:`pdb`."
msgstr ""
"*module*\\과 *name* 인자는 위의 함수 :func:`testsource`\\와 같습니다. 명명된 객체의 독스트링에 대한"
" 합성된 파이썬 스크립트가 임시 파일에 기록되고, 그 파일을 파이썬 디버거 :mod:`pdb`\\의 제어하에 실행합니다."

#: ../../library/doctest.rst:1787
msgid ""
"A shallow copy of ``module.__dict__`` is used for both local and global "
"execution context."
msgstr "``module.__dict__``\\의 얕은 사본이 지역과 전역 실행 컨텍스트 모두에 사용됩니다."

#: ../../library/doctest.rst:1790
msgid ""
"Optional argument *pm* controls whether post-mortem debugging is used.  "
"If *pm* has a true value, the script file is run directly, and the "
"debugger gets involved only if the script terminates via raising an "
"unhandled exception.  If it does, then post-mortem debugging is invoked, "
"via :func:`pdb.post_mortem`, passing the traceback object from the "
"unhandled exception.  If *pm* is not specified, or is false, the script "
"is run under the debugger from the start, via passing an appropriate "
":func:`exec` call to :func:`pdb.run`."
msgstr ""
"선택적 인자 *pm*\\은 사후 디버깅이 사용되는지를 제어합니다. *pm*\\이 참값이면, 스크립트 파일은 직접 실행되고, 처리되지"
" 않은 예외를 발생시켜 스크립트가 종료될 때만 디버거가 개입합니다. 그럴 때, 사후 디버깅이 "
":func:`pdb.post_mortem`\\를 통해 호출되어, 처리되지 않은 예외로부터 온 트레이스백 객체를 전달합니다. "
"*pm*\\이 지정되지 않았거나 거짓이면, 스크립트는 적절한 :func:`exec` 호출을 :func:`pdb.run`\\에 "
"전달하여 시작부터 디버거에서 실행됩니다."

#: ../../library/doctest.rst:1801
msgid "Debug the doctests in a string."
msgstr "문자열에 있는 doctest를 디버그합니다."

#: ../../library/doctest.rst:1803
msgid ""
"This is like function :func:`debug` above, except that a string "
"containing doctest examples is specified directly, via the *src* "
"argument."
msgstr ""
"doctest 예제를 포함하는 문자열이 *src* 인자를 통해 직접 지정된다는 점을 제외하면, 위의 함수 "
":func:`debug`\\과 같습니다."

#: ../../library/doctest.rst:1806
msgid ""
"Optional argument *pm* has the same meaning as in function :func:`debug` "
"above."
msgstr "선택적 인자 *pm*\\은 위의 함수 :func:`debug`\\에서와 같은 의미를 가집니다."

#: ../../library/doctest.rst:1808
msgid ""
"Optional argument *globs* gives a dictionary to use as both local and "
"global execution context.  If not specified, or ``None``, an empty "
"dictionary is used. If specified, a shallow copy of the dictionary is "
"used."
msgstr ""
"선택적 인자 *globs*\\는 지역과 전역 실행 컨텍스트 모두에 사용할 딕셔너리를 제공합니다. 지정되지 않거나 "
"``None``\\이면, 빈 딕셔너리가 사용됩니다. 지정되면, 딕셔너리의 얕은 사본이 사용됩니다."

#: ../../library/doctest.rst:1813
msgid ""
"The :class:`DebugRunner` class, and the special exceptions it may raise, "
"are of most interest to testing framework authors, and will only be "
"sketched here.  See the source code, and especially "
":class:`DebugRunner`'s docstring (which is a doctest!) for more details:"
msgstr ""
":class:`DebugRunner` 클래스와 이 클래스가 발생시킬 수 있는 특별한 예외는 주로 테스트 프레임워크 작성자가 관심을 "
"가지며, 여기에서는 대략적으로만 다룰 예정입니다. 자세한 내용은 소스 코드, 특히 :class:`DebugRunner`\\의 "
"독스트링(doctest입니다!)을 참조하십시오:"

#: ../../library/doctest.rst:1821
msgid ""
"A subclass of :class:`DocTestRunner` that raises an exception as soon as "
"a failure is encountered.  If an unexpected exception occurs, an "
":exc:`UnexpectedException` exception is raised, containing the test, the "
"example, and the original exception.  If the output doesn't match, then a"
" :exc:`DocTestFailure` exception is raised, containing the test, the "
"example, and the actual output."
msgstr ""
"실패를 만나자마자 예외를 발생시키는 :class:`DocTestRunner`\\의 서브 클래스. 예기치 않은 예외가 발생하면, "
"테스트, 예제 및 원래 예외가 포함된 :exc:`UnexpectedException` 예외가 발생합니다. 출력이 일치하지 않으면, "
"테스트, 예제 및 실제 출력을 포함하는 :exc:`DocTestFailure` 예외가 발생합니다."

#: ../../library/doctest.rst:1828
msgid ""
"For information about the constructor parameters and methods, see the "
"documentation for :class:`DocTestRunner` in section :ref:`doctest-"
"advanced-api`."
msgstr ""
"생성자 매개 변수와 메서드에 대한 자세한 내용은 :ref:`doctest-advanced-api` 절의 "
":class:`DocTestRunner` 설명서를 참조하십시오."

#: ../../library/doctest.rst:1831
msgid ""
"There are two exceptions that may be raised by :class:`DebugRunner` "
"instances:"
msgstr ":class:`DebugRunner` 인스턴스가 발생시킬 수 있는 두 가지 예외가 있습니다:"

#: ../../library/doctest.rst:1836
msgid ""
"An exception raised by :class:`DocTestRunner` to signal that a doctest "
"example's actual output did not match its expected output. The "
"constructor arguments are used to initialize the attributes of the same "
"names."
msgstr ""
"doctest 예제의 실제 출력이 예상 출력과 일치하지 않는다는 것을 알리기 위해 :class:`DocTestRunner`\\가 "
"발생시키는 예외. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다."

#: ../../library/doctest.rst:1840
msgid ":exc:`DocTestFailure` defines the following attributes:"
msgstr ":exc:`DocTestFailure`\\는 다음 어트리뷰트를 정의합니다:"

#: ../../library/doctest.rst:1845 ../../library/doctest.rst:1869
msgid "The :class:`DocTest` object that was being run when the example failed."
msgstr "예제가 실패했을 때 실행 중이던 :class:`DocTest` 객체."

#: ../../library/doctest.rst:1850 ../../library/doctest.rst:1874
msgid "The :class:`Example` that failed."
msgstr "실패한 :class:`Example`."

#: ../../library/doctest.rst:1855
msgid "The example's actual output."
msgstr "예제의 실제 출력."

#: ../../library/doctest.rst:1860
msgid ""
"An exception raised by :class:`DocTestRunner` to signal that a doctest "
"example raised an unexpected exception.  The constructor arguments are "
"used to initialize the attributes of the same names."
msgstr ""
"doctest 예제가 예기치 않은 예외를 발생시켰음을 알리기 위해 :class:`DocTestRunner`\\가 발생시키는 예외. "
"생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다."

#: ../../library/doctest.rst:1864
msgid ":exc:`UnexpectedException` defines the following attributes:"
msgstr ":exc:`UnexpectedException`\\는 다음 어트리뷰트를 정의합니다:"

#: ../../library/doctest.rst:1879
msgid ""
"A tuple containing information about the unexpected exception, as "
"returned by :func:`sys.exc_info`."
msgstr ":func:`sys.exc_info`\\에 의해 반환되는 것과 같은, 예기치 않은 예외에 대한 정보가 포함된 튜플."

#: ../../library/doctest.rst:1886
msgid "Soapbox"
msgstr "맺음말"

#: ../../library/doctest.rst:1888
msgid ""
"As mentioned in the introduction, :mod:`doctest` has grown to have three "
"primary uses:"
msgstr "소개에서 언급했듯이, :mod:`doctest`\\는 다음 세 가지 주요 용도로 성장했습니다:"

#: ../../library/doctest.rst:1891
msgid "Checking examples in docstrings."
msgstr "독스트링에 있는 예제 검사."

#: ../../library/doctest.rst:1893
msgid "Regression testing."
msgstr "회귀 테스트."

#: ../../library/doctest.rst:1895
msgid "Executable documentation / literate testing."
msgstr "실행 가능한 문서/문학적(literate) 테스트."

#: ../../library/doctest.rst:1897
msgid ""
"These uses have different requirements, and it is important to "
"distinguish them. In particular, filling your docstrings with obscure "
"test cases makes for bad documentation."
msgstr ""
"이러한 용도들은 다른 요구 사항을 가지며, 이를 구별하는 것이 중요합니다. 특히, 모호한 테스트 케이스로 독스트링을 채우는 것은 "
"나쁜 설명서를 만듭니다."

#: ../../library/doctest.rst:1901
msgid ""
"When writing a docstring, choose docstring examples with care. There's an"
" art to this that needs to be learned---it may not be natural at first.  "
"Examples should add genuine value to the documentation.  A good example "
"can often be worth many words. If done with care, the examples will be "
"invaluable for your users, and will pay back the time it takes to collect"
" them many times over as the years go by and things change.  I'm still "
"amazed at how often one of my :mod:`doctest` examples stops working after"
" a \"harmless\" change."
msgstr ""
"독스트링을 작성할 때, 독스트링 예제를 주의해서 선택하십시오. 여기에는 배울 필요가 있는 기술이 있습니다---처음에는 자연스럽지 "
"않을 수도 있습니다. 예제는 설명서에 진짜 가치를 부여해야 합니다. 좋은 예제는 종종 많은 단어의 가치가 있습니다. 주의 깊게 작업"
" 된다면, 예제는 사용자에게 매우 가치 있을 것이며, 몇 년이 지나고 변함에 따라 여러 번 수집하는 데 드는 시간을 갚을 것입니다."
" 제 :mod:`doctest` 예제 중 하나가 \"해가 없는\" 변경 후에 얼마나 자주 작동을 멈추는지 지금도 놀라울 뿐입니다."

#: ../../library/doctest.rst:1909
msgid ""
"Doctest also makes an excellent tool for regression testing, especially "
"if you don't skimp on explanatory text.  By interleaving prose and "
"examples, it becomes much easier to keep track of what's actually being "
"tested, and why.  When a test fails, good prose can make it much easier "
"to figure out what the problem is, and how it should be fixed.  It's true"
" that you could write extensive comments in code-based testing, but few "
"programmers do. Many have found that using doctest approaches instead "
"leads to much clearer tests.  Perhaps this is simply because doctest "
"makes writing prose a little easier than writing code, while writing "
"comments in code is a little harder.  I think it goes deeper than just "
"that: the natural attitude when writing a doctest-based test is that you "
"want to explain the fine points of your software, and illustrate them "
"with examples. This in turn naturally leads to test files that start with"
" the simplest features, and logically progress to complications and edge "
"cases.  A coherent narrative is the result, instead of a collection of "
"isolated functions that test isolated bits of functionality seemingly at "
"random.  It's a different attitude, and produces different results, "
"blurring the distinction between testing and explaining."
msgstr ""
"Doctest는 회귀 테스트를 위한 훌륭한 도구도 제공합니다. 특히 설명 텍스트를 생략하지 않는다면 더욱더 그렇습니다. 설명과 "
"예제를 번갈아 보여줌으로써, 실제로 무엇이 왜 테스트 되는지를 추적하기가 훨씬 쉬워집니다. 테스트가 실패할 때, 좋은 설명은 문제가"
" 무엇인지, 어떻게 고쳐야 하는지를 쉽게 파악할 수 있게 해줍니다. 코드 기반 테스트에 광범위한 주석을 쓸 수는 있는 것은 "
"사실이지만, 그렇게 하는 프로그래머는 거의 없습니다. 많은 사람이 doctest 접근법을 사용하는 것이 훨씬 더 명확한 테스트를 "
"유도한다는 것을 발견했습니다. 어쩌면 단순히 doctest가 설명을 작성하는 것을 코드를 작성하는 것보다 조금 더 쉽게 만들고, "
"코드에 주석을 쓰는 것이 조금 더 어렵기 때문일 것입니다. 저는 단지 그것보다는 더 깊이 들어간다고 생각합니다: doctest 기반"
" 테스트를 작성할 때의 자연스러운 태도는 소프트웨어의 미세한 포인트를 설명하고 그것을 예제로 보여주는 것입니다. 이것은 자연스럽게 "
"가장 간단한 기능으로 시작하고, 복잡하고 지엽적인 경우까지 논리적으로 진행되는 테스트 파일로 이어집니다. 무작위로 보이는 격리된 "
"기능 조각을 테스트하는 격리된 함수들의 모음 대신에, 일관된 내러티브가 얻어집니다. 이것은 다른 태도이며, 테스트와 설명의 구별을 "
"모호하게 하면서 다른 결과를 낳습니다."

#: ../../library/doctest.rst:1927
msgid ""
"Regression testing is best confined to dedicated objects or files.  There"
" are several options for organizing tests:"
msgstr "회귀 테스트는 전용 객체나 파일로 제한하는 것이 가장 좋습니다. 테스트 구성을 위한 몇 가지 옵션이 있습니다.:"

#: ../../library/doctest.rst:1930
msgid ""
"Write text files containing test cases as interactive examples, and test "
"the files using :func:`testfile` or :func:`DocFileSuite`.  This is "
"recommended, although is easiest to do for new projects, designed from "
"the start to use doctest."
msgstr ""
"대화형 예제로 테스트 케이스가 들어있는 텍스트 파일을 작성하고, :func:`testfile`\\이나 "
":func:`DocFileSuite`\\를 사용하여 파일을 테스트하십시오. doctest를 처음부터 사용하도록 고안된 새로운 "
"프로젝트에서 가장 쉬운 방법이지만, 이 방법을 권장합니다."

#: ../../library/doctest.rst:1935
msgid ""
"Define functions named ``_regrtest_topic`` that consist of single "
"docstrings, containing test cases for the named topics.  These functions "
"can be included in the same file as the module, or separated out into a "
"separate test file."
msgstr ""
"명명된 주제에 대한 테스트 케이스를 포함하는 단일 독스트링으로 구성된 ``_regrtest_topic``\\이라는 함수를 "
"정의하십시오. 이 함수들은 모듈과 같은 파일에 포함되거나 별도의 테스트 파일로 분리될 수 있습니다."

#: ../../library/doctest.rst:1939
msgid ""
"Define a ``__test__`` dictionary mapping from regression test topics to "
"docstrings containing test cases."
msgstr "회귀 테스트 주제에서 테스트 케이스가 포함된 독스트링에 대한 ``__test__`` 딕셔너리 매핑을 정의하십시오."

#: ../../library/doctest.rst:1942
msgid ""
"When you have placed your tests in a module, the module can itself be the"
" test runner.  When a test fails, you can arrange for your test runner to"
" re-run only the failing doctest while you debug the problem.  Here is a "
"minimal example of such a test runner::"
msgstr ""
"테스트를 모듈에 배치할 때, 모듈 자체가 테스트 실행기가 될 수 있습니다. 테스트가 실패할 때, 문제를 디버깅하는 동안 실패한 "
"doctest 만 다시 실행하도록 테스트 실행기를 조정할 수 있습니다. 다음은 그러한 테스트 실행기의 최소 예입니다::"

#: ../../library/doctest.rst:1947
#, python-brace-format
msgid ""
"if __name__ == '__main__':\n"
"    import doctest\n"
"    flags = doctest.REPORT_NDIFF|doctest.FAIL_FAST\n"
"    if len(sys.argv) > 1:\n"
"        name = sys.argv[1]\n"
"        if name in globals():\n"
"            obj = globals()[name]\n"
"        else:\n"
"            obj = __test__[name]\n"
"        doctest.run_docstring_examples(obj, globals(), name=name,\n"
"                                       optionflags=flags)\n"
"    else:\n"
"        fail, total = doctest.testmod(optionflags=flags)\n"
"        print(f\"{fail} failures out of {total} tests\")"
msgstr ""

#: ../../library/doctest.rst:1964
msgid "Footnotes"
msgstr "각주"

#: ../../library/doctest.rst:1965
msgid ""
"Examples containing both expected output and an exception are not "
"supported. Trying to guess where one ends and the other begins is too "
"error-prone, and that also makes for a confusing test."
msgstr ""
"예상 출력과 예외를 모두 포함하는 예제는 지원되지 않습니다. 어디에서 하나가 끝나고 다른 하나가 시작되는지 추측하는 것은 너무 "
"에러가 발생하기 쉽고, 이것은 또한 혼란스러운 테스트를 만들게 됩니다."

#: ../../library/doctest.rst:369
msgid ">>>"
msgstr ""

#: ../../library/doctest.rst:369
msgid "interpreter prompt"
msgstr ""

#: ../../library/doctest.rst:369 ../../library/doctest.rst:604
msgid "..."
msgstr ""

#: ../../library/doctest.rst:535
msgid "^ (caret)"
msgstr ""

#: ../../library/doctest.rst:535
msgid "marker"
msgstr ""

#: ../../library/doctest.rst:584
msgid "<BLANKLINE>"
msgstr ""

#: ../../library/doctest.rst:604 ../../library/doctest.rst:729
#, fuzzy
msgid "in doctests"
msgstr "DocTest 객체"

#: ../../library/doctest.rst:729
msgid "# (hash)"
msgstr ""

#: ../../library/doctest.rst:729
msgid "+ (plus)"
msgstr ""

#: ../../library/doctest.rst:729
msgid "- (minus)"
msgstr ""

#~ msgid ""
#~ "There is also a command line "
#~ "shortcut for running :func:`testmod`.  You "
#~ "can instruct the Python interpreter to"
#~ " run the doctest module directly from"
#~ " the standard library and pass the"
#~ " module name(s) on the command line::"
#~ msgstr ""
#~ "또한 :func:`testmod`\\를 실행하는 명령 줄 단축법이 "
#~ "있습니다. 파이썬 인터프리터에게 표준 라이브러리에서 직접 "
#~ "doctest 모듈을 실행하도록 지시하고 명령 줄에 모듈"
#~ " 이름(들)을 전달할 수 있습니다::"

#~ msgid ""
#~ "There is also a command line "
#~ "shortcut for running :func:`testfile`.  You"
#~ " can instruct the Python interpreter "
#~ "to run the doctest module directly "
#~ "from the standard library and pass "
#~ "the file name(s) on the command "
#~ "line::"
#~ msgstr ""
#~ "또한 :func:`testfile`\\를 실행하는 명령 줄 단축법이"
#~ " 있습니다. 파이썬 인터프리터에게 표준 라이브러리에서 직접 "
#~ "doctest 모듈을 실행하도록 지시하고 명령 줄에 파일"
#~ " 이름(들)을 전달할 수 있습니다::"

#~ msgid "The ``-o`` command line option."
#~ msgstr "``-o`` 명령 줄 옵션."

#~ msgid ""
#~ "When specified, an example that expects"
#~ " an exception passes if an exception"
#~ " of the expected type is raised, "
#~ "even if the exception detail does "
#~ "not match.  For example, an example "
#~ "expecting ``ValueError: 42`` will pass "
#~ "if the actual exception raised is "
#~ "``ValueError: 3*14``, but will fail, "
#~ "e.g., if :exc:`TypeError` is raised."
#~ msgstr ""
#~ "지정하면, 예외를 예상하는 예제가, 예외 세부 사항이 "
#~ "일치하지 않아도 예상 형의 예외가 발생하면 통과합니다. "
#~ "예를 들어, ``ValueError: 42``\\를 예상하는 예제는"
#~ " 발생한 실제 예외가 ``ValueError: 3*14``\\이면 "
#~ "통과하지만, 예를 들어 :exc:`TypeError`\\가 발생하면 "
#~ "실패합니다."

#~ msgid ""
#~ "It will also ignore the module "
#~ "name used in Python 3 doctest "
#~ "reports. Hence both of these variations"
#~ " will work with the flag specified,"
#~ " regardless of whether the test is"
#~ " run under Python 2.7 or Python "
#~ "3.2 (or later versions)::"
#~ msgstr ""
#~ "또한, 파이썬 3 doctest 보고서에 사용된 모듈 "
#~ "이름도 무시합니다. 따라서 이 두 변형은 이 "
#~ "플래그가 지정되면 테스트가 파이썬 2.7이나 파이썬 "
#~ "3.2(또는 이후 버전)에서 실행되는지와 관계없이 작동합니다::"

#~ msgid ""
#~ "Note that :const:`ELLIPSIS` can also be"
#~ " used to ignore the details of "
#~ "the exception message, but such a "
#~ "test may still fail based on "
#~ "whether or not the module details "
#~ "are printed as part of the "
#~ "exception name. Using "
#~ ":const:`IGNORE_EXCEPTION_DETAIL` and the details "
#~ "from Python 2.3 is also the only"
#~ " clear way to write a doctest "
#~ "that doesn't care about the exception"
#~ " detail yet continues to pass under"
#~ " Python 2.3 or earlier (those "
#~ "releases do not support :ref:`doctest "
#~ "directives <doctest-directives>` and ignore"
#~ " them as irrelevant comments). For "
#~ "example::"
#~ msgstr ""
#~ ":const:`ELLIPSIS`\\를 사용하여 예외 메시지의 세부 사항을"
#~ " 무시할 수도 있지만, 그러한 테스트는 모듈 세부 "
#~ "사항이 예외 이름의 일부로 인쇄되는지에 따라 여전히 "
#~ "실패할 수 있음에 유의하십시오. "
#~ ":const:`IGNORE_EXCEPTION_DETAIL`\\과 파이썬 2.3의 세부 "
#~ "사항을 사용하는 것은 또한 예외 세부 사항에 신경"
#~ " 쓰지 않고 여전히 파이썬 2.3이나 그 이전 "
#~ "버전(이 배포는 :ref:`doctest 지시자 <doctest-"
#~ "directives>`\\를 지원하지 않고 무의미한 주석으로 "
#~ "무시합니다)에서 통과하는 doctest를 작성하는 유일하게 명확한 "
#~ "방법입니다. 예를 들면::"

#~ msgid ""
#~ "passes under Python 2.3 and later "
#~ "Python versions with the flag specified,"
#~ " even though the detail changed in"
#~ " Python 2.4 to say \"does not\" "
#~ "instead of \"doesn't\"."
#~ msgstr ""
#~ "는 플래그가 지정될 때 파이썬 2.3 이후 버전에서"
#~ " 통과합니다. 파이썬 2.4에서 세부 사항이 \"doesn't\""
#~ " 대신 \"does not\"으로 변경되었음에도 통과합니다."

#~ msgid ""
#~ "Before Python 3.6, when printing a "
#~ "dict, Python did not guarantee that "
#~ "the key-value pairs was printed in"
#~ " any particular order."
#~ msgstr "파이썬 3.6 이전에는, 딕셔너리를 인쇄할 때, 파이썬은 키-값 쌍이 특정 순서로 인쇄되는 것을 보증하지 않았습니다."

