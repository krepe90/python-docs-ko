# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/ast.rst:2
#, fuzzy
msgid ":mod:`!ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- 추상 구문 트리"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**소스 코드:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` 모듈은 파이썬 응용 프로그램이 파이썬 추상 구문 문법의 트리를 처리하는 데 도움을 줍니다. 추상 구문 자체는 각"
" 파이썬 릴리스마다 바뀔 수 있습니다; 이 모듈은 프로그래밍 방식으로 현재 문법의 모양을 찾는 데 도움이 됩니다."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing "
":data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in "
"function, or using the :func:`parse` helper provided in this module.  The"
" result will be a tree of objects whose classes all inherit from "
":class:`ast.AST`.  An abstract syntax tree can be compiled into a Python "
"code object using the built-in :func:`compile` function."
msgstr ""
":data:`ast.PyCF_ONLY_AST`\\를 플래그로 :func:`compile` 내장 함수에 전달하거나, 이 모듈에서 "
"제공된 :func:`parse` 도우미를 사용하여 추상 구문 트리를 생성할 수 있습니다. 결과는 클래스가 모두 "
":class:`ast.AST`\\에서 상속되는 객체들의 트리가 됩니다. 내장 :func:`compile` 함수를 사용하여 추상 구문"
" 트리를 파이썬 코드 객체로 컴파일할 수 있습니다."

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "추상 문법"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "추상 문법은 현재 다음과 같이 정의됩니다:"

#: ../../library/ast.rst:37
#, python-brace-format
msgid ""
"-- ASDL's 4 builtin types are:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* "
"type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without "
"parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string?"
" type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, "
"stmt* finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- can appear only in Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* "
"body)\n"
"                    attributes (int lineno, int col_offset, int? "
"end_lineno, int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* "
"kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? "
"rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* "
"kwd_attrs, pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- The optional \"rest\" MatchMapping parameter handles "
"capturing extra mapping keys\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound, expr? "
"default_value)\n"
"               | ParamSpec(identifier name, expr? default_value)\n"
"               | TypeVarTuple(identifier name, expr? default_value)\n"
"               attributes (int lineno, int col_offset, int end_lineno, "
"int end_col_offset)\n"
"}\n"
msgstr ""

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "노드 클래스"

#: ../../library/ast.rst:46
#, fuzzy
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced "
":ref:`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C "
"module and re-exported in :mod:`ast`."
msgstr ""
"이것은 모든 AST 노드 클래스의 베이스입니다. 실제 노드 클래스는 :file:`Parser/Python.asdl` 파일에서 "
"파생되며, 이 파일의 내용은 :ref:`아래 <abstract-grammar>`\\에서 볼 수 있습니다. :mod:`_ast` C "
"모듈에 정의되어 있으며 :mod:`ast`\\로 다시 내보내 집니다."

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract"
" grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In "
"addition, there is one class defined for each constructor on the right-"
"hand side; these classes inherit from the classes for the left-hand side "
"trees.  For example, :class:`ast.BinOp` inherits from :class:`ast.expr`."
"  For production rules with alternatives (aka \"sums\"), the left-hand "
"side class is abstract: only instances of specific constructor nodes are "
"ever created."
msgstr ""
"추상 문법의 각 좌변 심볼마다 하나의 클래스가 정의되어 있습니다 (예를 들어, :class:`ast.stmt`\\나 "
":class:`ast.expr`). 또한, 우변의 생성자마다 하나의 클래스가 정의되어 있습니다; 이 클래스는 좌변 트리의 클래스에서"
" 상속됩니다. 예를 들어, :class:`ast.BinOp`\\는 :class:`ast.expr`\\에서 상속됩니다. 대안을 갖는 "
"생성 규칙(일명 \"합\")의 경우, 좌변 클래스는 추상입니다: 특정 생성자 노드의 인스턴스만 만들어집니다."

#: ../../library/ast.rst:64
#, fuzzy
msgid ""
"Each concrete class has an attribute :attr:`!_fields` which gives the "
"names of all child nodes."
msgstr "각 구상 클래스에는 모든 자식 노드의 이름을 제공하는 어트리뷰트 :attr:`_fields`\\가 있습니다."

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, "
"of the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"구상 클래스의 각 인스턴스에는 각 자식 노드마다 문법에 정의된 형의 어트리뷰트가 하나씩 있습니다. 예를 들어, "
":class:`ast.BinOp` 인스턴스는 :class:`ast.expr` 형의 어트리뷰트 :attr:`left`\\를 갖습니다."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a "
"question mark), the value might be ``None``.  If the attributes can have "
"zero-or-more values (marked with an asterisk), the values are represented"
" as Python lists.  All possible attributes must be present and have valid"
" values when compiling an AST with :func:`compile`."
msgstr ""
"문법에서 이러한 어트리뷰트가 선택적으로 표시되면 (물음표를 사용해서), 값은 ``None``\\일 수 있습니다. 어트리뷰트가 0개 "
"이상의 값을 가질 수 있으면 (애스터리스크로 표시됩니다), 값은 파이썬 리스트로 표현됩니다. :func:`compile`\\로 "
"AST를 컴파일할 때 가능한 모든 어트리뷰트가 존재하고 유효한 값을 가져야 합니다."

#: ../../library/ast.rst:79
msgid ""
"The :attr:`!_field_types` attribute on each concrete class is a "
"dictionary mapping field names (as also listed in :attr:`_fields`) to "
"their types."
msgstr ""

#: ../../library/ast.rst:82
#, python-brace-format
msgid ""
">>> ast.TypeVar._field_types\n"
"{'name': <class 'str'>, 'bound': ast.expr | None, 'default_value': "
"ast.expr | None}"
msgstr ""

#: ../../library/ast.rst:94
#, fuzzy
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have "
":attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and "
":attr:`end_col_offset` attributes.  The :attr:`lineno` and "
":attr:`end_lineno` are the first and last line numbers of source text "
"span (1-indexed so the first line is line 1) and the :attr:`col_offset` "
"and :attr:`end_col_offset` are the corresponding UTF-8 byte offsets of "
"the first and last tokens that generated the node. The UTF-8 offset is "
"recorded because the parser uses UTF-8 internally."
msgstr ""
":class:`ast.expr`\\과 :class:`ast.stmt` 서브 클래스의 인스턴스에는 :attr:`lineno`, "
":attr:`col_offset`, :attr:`lineno` 및 :attr:`col_offset` 어트리뷰트가 있습니다. "
":attr:`lineno`\\와 :attr:`end_lineno`\\는 소스 텍스트 스팬의 첫 번째와 마지막 줄 "
"번호(1-인덱싱이라서 첫 번째 줄은 줄 1입니다)이고 :attr:`col_offset`\\과 "
":attr:`end_col_offset`\\은 노드를 생성한 첫 번째와 마지막 토큰의 해당 UTF-8 바이트 오프셋입니다. 구문 "
"분석기가 UTF-8을 내부적으로 사용하기 때문에 UTF-8 오프셋이 기록됩니다."

#: ../../library/ast.rst:103
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for "
"example one can get the source segment of a one-line expression node "
"using ``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"종료 위치는 컴파일러에 필요하지 않아서 선택 사항입니다. 종료 오프셋은 마지막 심볼 *뒤*\\입니다. 예를 들어 "
"``source_line[node.col_offset : node.end_col_offset]``\\를 사용하여 한 줄 표현식 "
"노드의 소스 세그먼트를 가져올 수 있습니다."

#: ../../library/ast.rst:108
msgid "The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ":class:`ast.T` 클래스의 생성자는 다음과 같이 인자를 구문 분석합니다:"

#: ../../library/ast.rst:110
msgid ""
"If there are positional arguments, there must be as many as there are "
"items in :attr:`T._fields`; they will be assigned as attributes of these "
"names."
msgstr ""
"위치 인자가 있으면, :attr:`T._fields`\\에 있는 항목 수만큼 있어야 합니다; 이러한 이름의 어트리뷰트로 대입될 "
"것입니다."

#: ../../library/ast.rst:112
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr "키워드 인자가 있으면, 같은 이름의 어트리뷰트를 지정된 값으로 설정합니다."

#: ../../library/ast.rst:115
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you "
"could use ::"
msgstr "예를 들어, :class:`ast.UnaryOp` 노드를 만들고 채우려면, 다음과 같이 할 수 있습니다 ::"

#: ../../library/ast.rst:118
msgid ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"
msgstr ""

#: ../../library/ast.rst:121
msgid ""
"If a field that is optional in the grammar is omitted from the "
"constructor, it defaults to ``None``. If a list field is omitted, it "
"defaults to the empty list. If a field of type :class:`!ast.expr_context`"
" is omitted, it defaults to :class:`Load() <ast.Load>`. If any other "
"field is omitted, a :exc:`DeprecationWarning` is raised and the AST node "
"will not have this field. In Python 3.15, this condition will raise an "
"error."
msgstr ""

#: ../../library/ast.rst:130
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr ":class:`ast.Constant` 클래스는 이제 모든 상수에 사용됩니다."

#: ../../library/ast.rst:134
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr "단순 인덱스는 값으로 표현되고, 확장 슬라이스는 튜플로 표현됩니다."

#: ../../library/ast.rst:139
#, fuzzy
msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, "
":class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still "
"available, but they will be removed in future Python releases.  In the "
"meantime, instantiating them will return an instance of a different "
"class."
msgstr ""
"이전 클래스 :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, "
":class:`ast.NameConstant` 및 :class:`ast.Ellipsis`\\는 여전히 사용할 수 있지만, 향후 "
"파이썬 릴리스에서 제거될 예정입니다. 그동안, 이들을 인스턴스 화하면 다른 클래스의 인스턴스가 반환됩니다."

#: ../../library/ast.rst:146
#, fuzzy
msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different "
"class."
msgstr ""
"이전 클래스 :class:`ast.Index`\\와 :class:`ast.ExtSlice`\\는 여전히 사용할 수 있지만, 향후 "
"파이썬 릴리스에서 제거될 예정입니다. 그동안, 이들을 인스턴스 화하면 다른 클래스의 인스턴스가 반환됩니다."

#: ../../library/ast.rst:153
msgid ""
"Previous versions of Python allowed the creation of AST nodes that were "
"missing required fields. Similarly, AST node constructors allowed "
"arbitrary keyword arguments that were set as attributes of the AST node, "
"even if they did not match any of the fields of the AST node. This "
"behavior is deprecated and will be removed in Python 3.15."
msgstr ""

#: ../../library/ast.rst:160
msgid ""
"The descriptions of the specific node classes displayed here were "
"initially adapted from the fantastic `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`__ project and all "
"its contributors."
msgstr ""
"여기에 표시된 특정 노드 클래스에 대한 설명은 처음에는 환상적인 `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`__ 프로젝트와 모든 기여자로부터 "
"차용했습니다."

#: ../../library/ast.rst:169
msgid "Root nodes"
msgstr ""

#: ../../library/ast.rst:173
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type "
"generated by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""

#: ../../library/ast.rst:176
msgid "``body`` is a :class:`list` of the module's :ref:`ast-statements`."
msgstr ""

#: ../../library/ast.rst:178
msgid ""
"``type_ignores`` is a :class:`list` of the module's type ignore comments;"
" see :func:`ast.parse` for more details."
msgstr ""

#: ../../library/ast.rst:181
msgid ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))])"
msgstr ""

#: ../../library/ast.rst:194
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""

#: ../../library/ast.rst:197
msgid ""
"``body`` is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""

#: ../../library/ast.rst:200 ../../library/ast.rst:270
msgid ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"
msgstr ""

#: ../../library/ast.rst:209
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-"
"interac`. Node type generated by :func:`ast.parse` when *mode* is "
"``\"single\"``."
msgstr ""

#: ../../library/ast.rst:212
msgid "``body`` is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""

#: ../../library/ast.rst:214
msgid ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"
msgstr ""

#: ../../library/ast.rst:231
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""

#: ../../library/ast.rst:235
msgid "Such type comments would look like this::"
msgstr ""

#: ../../library/ast.rst:237
msgid ""
"def sum_two_number(a, b):\n"
"    # type: (int, int) -> int\n"
"    return a + b"
msgstr ""

#: ../../library/ast.rst:241
msgid ""
"``argtypes`` is a :class:`list` of :ref:`expression nodes <ast-"
"expressions>`."
msgstr ""

#: ../../library/ast.rst:243
msgid "``returns`` is a single :ref:`expression node <ast-expressions>`."
msgstr ""

#: ../../library/ast.rst:245
msgid ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', "
"mode='func_type'), indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""

#: ../../library/ast.rst:261
msgid "Literals"
msgstr "리터럴"

#: ../../library/ast.rst:265
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"상숫값. ``Constant`` 리터럴의 ``value`` 어트리뷰트는 그것이 나타내는 파이썬 객체를 포함합니다. 표현되는 값은 "
"숫자, 문자열 또는 ``None``\\과 같은 간단한 형일 수 있지만, 모든 요소가 상수라면 불변 컨테이너 형(튜플과 "
"frozenset)일 수도 있습니다."

#: ../../library/ast.rst:279
msgid ""
"Node representing a single formatting field in an f-string. If the string"
" contains a single formatting field and nothing else the node can be "
"isolated otherwise it appears in :class:`JoinedStr`."
msgstr ""
"f-문자열에서 단일 포매팅 필드를 나타내는 노드. 문자열에 단일 포매팅 필드가 포함되어 있고 다른 것이 없으면 노드를 분리 할 수 "
"있습니다, 그렇지 않으면 :class:`JoinedStr`\\에 나타납니다."

#: ../../library/ast.rst:283
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr "``value``\\는 모든 표현식 노드(가령 리터럴, 변수 또는 함수 호출)입니다."

#: ../../library/ast.rst:285
msgid "``conversion`` is an integer:"
msgstr "``conversion``\\은 정수입니다:"

#: ../../library/ast.rst:287
msgid "-1: no formatting"
msgstr "-1: 포매팅 없음"

#: ../../library/ast.rst:288
msgid "115: ``!s`` string formatting"
msgstr "115: ``!s`` 문자열 포매팅"

#: ../../library/ast.rst:289
msgid "114: ``!r`` repr formatting"
msgstr "114: ``!r`` repr 포매팅"

#: ../../library/ast.rst:290
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` ascii 포매팅"

#: ../../library/ast.rst:292
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting "
"of the value, or ``None`` if no format was specified. Both ``conversion``"
" and ``format_spec`` can be set at the same time."
msgstr ""
"``format_spec``\\은 값의 포매팅을 나타내는 :class:`JoinedStr` 노드이거나, 표맷이 지정되지 않았으면 "
"``None``\\입니다. ``conversion``\\과 ``format_spec``\\을 동시에 설정할 수 있습니다."

#: ../../library/ast.rst:299
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and "
":class:`Constant` nodes."
msgstr "일련의 :class:`FormattedValue`\\와 :class:`Constant` 노드로 구성된 f-문자열."

#: ../../library/ast.rst:302
#, python-brace-format
msgid ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', "
"mode='eval'), indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"
msgstr ""

#: ../../library/ast.rst:327
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the "
"elements. ``ctx`` is :class:`Store` if the container is an assignment "
"target (i.e. ``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"리스트나 튜플. ``elts``\\는 요소를 나타내는 노드의 리스트를 보유합니다. ``ctx``\\는 컨테이너가 대입 대상이면 "
"(가령 ``(x,y)=something``) :class:`Store`\\이고, 그렇지 않으면 :class:`Load`\\입니다."

#: ../../library/ast.rst:331
msgid ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"
msgstr ""

#: ../../library/ast.rst:353
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr "집합. ``elts``\\는 집합의 요소를 나타내는 노드의 리스트를 보유합니다."

#: ../../library/ast.rst:355
#, python-brace-format
msgid ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"
msgstr ""

#: ../../library/ast.rst:368
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing "
"the keys and the values respectively, in matching order (what would be "
"returned when calling :code:`dictionary.keys()` and "
":code:`dictionary.values()`)."
msgstr ""
"딕셔너리. ``keys``\\와 ``values``\\는 각각 키와 값을 나타내는 노드의 리스트를 일치하는 순서대로 "
"(:code:`dictionary.keys()`\\와 :code:`dictionary.values()`\\를 호출할 때 반환되는 "
"순서) 보유합니다."

#: ../../library/ast.rst:372
msgid ""
"When doing dictionary unpacking using dictionary literals the expression "
"to be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"딕셔너리 리터럴을 사용하여 딕셔너리 언 패킹을 수행할 때 확장될 표현식은 ``values`` 리스트로 가고, ``keys``\\의 "
"해당 위치에는 ``None``\\이 갑니다."

#: ../../library/ast.rst:376
#, python-brace-format
msgid ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"
msgstr ""

#: ../../library/ast.rst:390
msgid "Variables"
msgstr "변수"

#: ../../library/ast.rst:394
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of"
" the following types."
msgstr "변수 이름. ``id``\\는 이름을 문자열로 보유하며, ``ctx``\\는 다음 형 중 하나입니다."

#: ../../library/ast.rst:402
msgid ""
"Variable references can be used to load the value of a variable, to "
"assign a new value to it, or to delete it. Variable references are given "
"a context to distinguish these cases."
msgstr ""
"변수 참조는 변숫값을 로드하거나, 그것에 새 값을 대입하거나, 그것을 삭제하는데 사용될 수 있습니다. 변수 참조에는 이러한 경우를 "
"구별하기 위한 컨텍스트가 제공됩니다."

#: ../../library/ast.rst:406
msgid ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])])"
msgstr ""

#: ../../library/ast.rst:432
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a "
":class:`Name` node. This type must be used when building a :class:`Call` "
"node with ``*args``."
msgstr ""
"``*var`` 변수 참조. ``value``\\는 변수(일반적으로 :class:`Name` 노드)를 보유합니다. 이 형은 "
"``*args``\\로 :class:`Call` 노드를 빌드할 때 사용해야 합니다."

#: ../../library/ast.rst:436
msgid ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:456
msgid "Expressions"
msgstr "표현식"

#: ../../library/ast.rst:460
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a "
":class:`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` "
"or :class:`YieldFrom` node."
msgstr ""
"표현식(가령 함수 호출)이 반환 값이 사용되거나 저장되지 않은 자신만의 문장으로 나타나면, 이 컨테이너에 래핑 됩니다. "
"``value``\\는 이 섹션의 다른 노드인 :class:`Constant`, :class:`Name`, "
":class:`Lambda`, :class:`Yield` 또는 :class:`YieldFrom` 노드 중 하나를 보유합니다."

#: ../../library/ast.rst:465
msgid ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))])"
msgstr ""

#: ../../library/ast.rst:478
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression"
" node."
msgstr "단항 연산. ``op``\\는 연산자이고, ``operand``\\는 임의의 표현식 노드입니다."

#: ../../library/ast.rst:487
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, "
":class:`Invert` is the ``~`` operator."
msgstr "단항 연산자 토큰. :class:`Not`\\은 ``not`` 키워드이고, :class:`Invert`\\는 ``~`` 연산자입니다."

#: ../../library/ast.rst:490
msgid ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"
msgstr ""

#: ../../library/ast.rst:501
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, "
"and ``left`` and ``right`` are any expression nodes."
msgstr ""
"이항 연산 (더하기나 나누기 같은). ``op``\\는 연산자이고, ``left``\\와 ``right``\\는 임의의 표현식 "
"노드입니다."

#: ../../library/ast.rst:504
msgid ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"
msgstr ""

#: ../../library/ast.rst:528
msgid "Binary operator tokens."
msgstr "이항 연산자 토큰."

#: ../../library/ast.rst:533
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or "
":class:`And`. ``values`` are the values involved. Consecutive operations "
"with the same operator, such as ``a or b or c``, are collapsed into one "
"node with several values."
msgstr ""
"불리언 연산, 'or' 나 'and'. ``op``\\는 :class:`Or`\\나 :class:`And`\\입니다. "
"``values``\\는 관련된 값입니다. 같은 연산자를 사용하는 연속 연산(가령 ``a or b or c``)은 여러 값을 가진 "
"하나의 노드로 축소됩니다."

#: ../../library/ast.rst:538
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "여기에는 :class:`UnaryOp`\\인 ``not``\\이 포함되지 않습니다."

#: ../../library/ast.rst:540
msgid ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"
msgstr ""

#: ../../library/ast.rst:554
msgid "Boolean operator tokens."
msgstr "불리언 연산자 토큰."

#: ../../library/ast.rst:559
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list "
"of values after the first element in the comparison."
msgstr ""
"둘 이상의 값의 비교. ``left``\\는 비교의 첫 번째 값이고, ``ops``\\는 연산자의 리스트이며, "
"``comparators``\\는 비교의 첫 번째 요소 다음의 값 리스트입니다."

#: ../../library/ast.rst:563
msgid ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"
msgstr ""

#: ../../library/ast.rst:588
msgid "Comparison operator tokens."
msgstr "비교 연산자 토큰."

#: ../../library/ast.rst:593
msgid ""
"A function call. ``func`` is the function, which will often be a "
":class:`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"함수 호출. ``func``\\는 함수이며, 종종 :class:`Name`\\이나 :class:`Attribute` 객체입니다. "
"인자 중:"

#: ../../library/ast.rst:596
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args``\\는 위치로 전달된 인자의 리스트를 보유합니다."

#: ../../library/ast.rst:597
#, fuzzy
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr "``keywords``\\는 키워드로 전달된 인자를 나타내는 :class:`keyword` 객체의 리스트를 보유합니다."

#: ../../library/ast.rst:600
msgid ""
"The ``args`` and ``keywords`` arguments are optional and default to empty"
" lists."
msgstr ""

#: ../../library/ast.rst:602
msgid ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"
msgstr ""

#: ../../library/ast.rst:623
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a "
"raw string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"함수 호출이나 클래스 정의에 대한 키워드 인자. ``arg``\\는 매개 변수 이름의 원시 문자열이고, ``value``\\는 "
"전달할 노드입니다."

#: ../../library/ast.rst:629
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, "
"so in the following example, all three are :class:`Name` nodes."
msgstr ""
"``a if b else c``\\와 같은 표현식. 각 필드는 단일 노드를 보유해서, 다음 예에서, 세 개 모두 "
":class:`Name` 노드입니다."

#: ../../library/ast.rst:632
msgid ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"
msgstr ""

#: ../../library/ast.rst:644
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a "
":class:`Name`. ``attr`` is a bare string giving the name of the "
"attribute, and ``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` "
"according to how the attribute is acted on."
msgstr ""
"어트리뷰트 액세스, 예를 들어 ``d.keys``. ``value``\\는 노드(보통 :class:`Name`)입니다. "
"``attr``\\은 어트리뷰트의 이름을 제공하는 문자열이며, ``ctx``\\는 어트리뷰트에 적용되는 방식에 따라 "
":class:`Load`, :class:`Store` 또는 :class:`Del`\\입니다."

#: ../../library/ast.rst:649
msgid ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"
msgstr ""

#: ../../library/ast.rst:661
msgid ""
"A named expression. This AST node is produced by the assignment "
"expressions operator (also known as the walrus operator). As opposed to "
"the :class:`Assign` node in which the first argument can be multiple "
"nodes, in this case both ``target`` and ``value`` must be single nodes."
msgstr ""
"명명된 표현식. 이 AST 노드는 대입 표현식 연산자(바다코끼리(walrus) 연산자라고도 합니다)에 의해 생성됩니다. 첫 번째 "
"인자가 여러 노드일 수 있는 :class:`Assign` 노드와 달리, 이 경우에는 ``target``\\과 ``value``\\는"
" 모두 단일 노드여야 합니다."

#: ../../library/ast.rst:666
msgid ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"
msgstr ""

#: ../../library/ast.rst:677
msgid "Subscripting"
msgstr "서브스크립팅"

#: ../../library/ast.rst:681
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object "
"(usually sequence or mapping). ``slice`` is an index, slice or key. It "
"can be a :class:`Tuple` and contain a :class:`Slice`. ``ctx`` is "
":class:`Load`, :class:`Store` or :class:`Del` according to the action "
"performed with the subscript."
msgstr ""
"서브스크립트, 가령 ``l[1]``. ``value``\\는 서브스크립트되는 객체입니다 (보통 시퀀스나 매핑). "
"``slice``\\는 인덱스, 슬라이스 또는 키입니다. :class:`Tuple`\\일 수 있으며 :class:`Slice`\\를"
" 포함합니다. ``ctx``\\는 서브스크립트로 수행되는 동작에 따라 :class:`Load`, :class:`Store` 또는 "
":class:`Del`\\입니다."

#: ../../library/ast.rst:687
msgid ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""

#: ../../library/ast.rst:705
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). "
"Can occur only inside the *slice* field of :class:`Subscript`, either "
"directly or as an element of :class:`Tuple`."
msgstr ""
"일반 슬라이싱 (``lower:upper``\\나 ``lower:upper:step`` 형식). "
":class:`Subscript`\\의 *slice* 필드 내에서만 직접 또는 :class:`Tuple`\\의 요소로 등장할 수 "
"있습니다."

#: ../../library/ast.rst:709
msgid ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"
msgstr ""

#: ../../library/ast.rst:722
msgid "Comprehensions"
msgstr "컴프리헨션"

#: ../../library/ast.rst:729
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"리스트와 집합 컴프리헨션, 제너레이터 표현식 및 딕셔너리 컴프리헨션. ``elt``\\(또는 ``key``\\와 "
"``value``)는 항목마다 평가될 부분을 나타내는 단일 노드입니다."

#: ../../library/ast.rst:733
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators``\\는 :class:`comprehension` 노드의 리스트입니다."

#: ../../library/ast.rst:735
#, python-brace-format
msgid ""
">>> print(ast.dump(\n"
"...     ast.parse('[x for x in numbers]', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"
msgstr ""

#: ../../library/ast.rst:781
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use"
" for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"컴프리헨션에서 하나의 ``for`` 절. ``target``\\은 각 요소(보통 :class:`Name`\\이나 "
":class:`Tuple` 노드)에 사용할 참조입니다. ``iter``\\는 이터레이트 할 객체입니다. ``ifs``\\는 테스트 "
"표현식의 리스트입니다: 각 ``for`` 절은 여러 ``ifs``\\를 가질 수 있습니다."

#: ../../library/ast.rst:786
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async``\\는 컴프리헨션이 비동기임을 나타냅니다 (``for`` 대신 ``async for``\\를 사용합니다). "
"값은 정수(0이나 1)입니다."

#: ../../library/ast.rst:789
msgid ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"...                indent=4)) # Multiple comprehensions in one.\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Call(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            comprehension(\n"
"                target=Name(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"...                indent=4)) # generator comprehension\n"
"Expression(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Name(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='n', ctx=Store()),\n"
"                iter=Name(id='it', ctx=Load()),\n"
"                ifs=[\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(value=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"...                indent=4)) # Async comprehension\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='i', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"
msgstr ""

#: ../../library/ast.rst:851
msgid "Statements"
msgstr "문장"

#: ../../library/ast.rst:855
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr "대입. ``targets``\\는 노드의 리스트이고, ``value``\\는 단일 노드입니다."

#: ../../library/ast.rst:857
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to "
"each. Unpacking is represented by putting a :class:`Tuple` or "
":class:`List` within ``targets``."
msgstr ""
"``targets``\\의 여러 노드는 각각 같은 값을 할당하는 것을 나타냅니다. 언 패킹은 ``targets`` 내에 "
":class:`Tuple`\\이나 :class:`List`\\를 넣어 표현됩니다."

#: ../../library/ast.rst:863 ../../library/ast.rst:1158
#: ../../library/ast.rst:1352 ../../library/ast.rst:1881
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment."
msgstr "``type_comment``\\는 형 어노테이션이 주석으로 포함된 선택적 문자열입니다."

#: ../../library/ast.rst:865
msgid ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple "
"assignment\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store()),\n"
"                Name(id='b', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Name(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:891
#, fuzzy
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can"
" be a :class:`Name`, an :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or "
":class:`Name` node. ``value`` is a single optional node."
msgstr ""
"형 주석이 있는 대입. ``target``\\은 단일 노드이며 :class:`Name`, :class:`Attribute` 또는 "
":class:`Subscript`\\일 수 있습니다. ``annotation``\\은 :class:`Constant`\\나 "
":class:`Name` 노드와 같은 어노테이션입니다. ``value``\\는 단일 선택적 노드입니다. ``simple``\\은 "
"괄호 사이에 나타나지 않은 순수한 이름이며 표현식이 아닌 ``target``\\의 :class:`Name` 노드에 대해 True로 "
"설정된 불리언 정수입니다."

#: ../../library/ast.rst:896
msgid ""
"``simple`` is always either 0 (indicating a \"complex\" target) or 1 "
"(indicating a \"simple\" target). A \"simple\" target consists solely of "
"a :class:`Name` node that does not appear between parentheses; all other "
"targets are considered complex. Only simple targets appear in the "
":attr:`~object.__annotations__` dictionary of modules and classes."
msgstr ""

#: ../../library/ast.rst:902
msgid ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation "
"with parenthesis\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Attribute(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Subscript(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                slice=Constant(value=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"
msgstr ""

#: ../../library/ast.rst:946
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` "
"with value for 1."
msgstr ""
"증분 대입, 가령 ``a += 1``. 다음 예에서, ``target``\\은 ``x``\\(:class:`Store` "
"컨텍스트로)를 위한 :class:`Name` 노드이고, ``op``\\는 :class:`Add`\\이며, ``value``\\는 "
"값이 1인 :class:`Constant`\\입니다."

#: ../../library/ast.rst:951
#, fuzzy
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or "
":class:`List`, unlike the targets of :class:`Assign`."
msgstr ""
"``target`` 어트리뷰트는 :class:`Assign`\\의 대상과 달리 :class:`Tuple`\\이나 "
":class:`List` 클래스일 수 없습니다."

#: ../../library/ast.rst:954
msgid ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))])"
msgstr ""

#: ../../library/ast.rst:967
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from "
"y``."
msgstr ""
"``raise`` 문. ``exc``\\는 발생시킬 예외 객체로 일반적으로 :class:`Call`\\이나 "
":class:`Name`\\이거나, 독립 ``raise``\\의 경우 ``None``\\입니다. ``cause``\\는 "
"``raise x from y``\\에서 ``y``\\에 해당하는 선택적 부분입니다."

#: ../../library/ast.rst:971
msgid ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:983
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` "
"node. ``msg`` holds the failure message."
msgstr ""
"어서션. ``test``\\는 (:class:`Compare` 노드와 같은) 조건을 보유합니다. ``msg``\\는 실패 메시지를 "
"보유합니다."

#: ../../library/ast.rst:986
msgid ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:998
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as "
":class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"``del`` 문을 나타냅니다. ``targets``\\는 :class:`Name`, :class:`Attribute` 또는 "
":class:`Subscript` 같은 노드들의 리스트입니다."

#: ../../library/ast.rst:1001
msgid ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])])"
msgstr ""

#: ../../library/ast.rst:1015
msgid "A ``pass`` statement."
msgstr "``pass`` 문."

#: ../../library/ast.rst:1017
msgid ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()])"
msgstr ""

#: ../../library/ast.rst:1027
msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list "
"of :ref:`type parameters <ast-type-params>`, and ``value`` is the value "
"of the type alias."
msgstr ""

#: ../../library/ast.rst:1032
msgid ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:1043
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr "함수나 루프 내부에만 적용할 수 있는 다른 문장들은 다른 섹션에 설명되어 있습니다."

#: ../../library/ast.rst:1047
msgid "Imports"
msgstr "임포트"

#: ../../library/ast.rst:1051
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "import 문. ``names``\\는 :class:`alias` 노드의 리스트입니다."

#: ../../library/ast.rst:1053
msgid ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"
msgstr ""

#: ../../library/ast.rst:1067
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from"
" . import foo``. ``level`` is an integer holding the level of the "
"relative import (0 means absolute import)."
msgstr ""
"``from x import y``\\를 나타냅니다. ``module``\\은  선행 점이 없는 'from' 이름의 원시 "
"문자열이며, ``from . import foo``\\와 같은 문장의 경우 ``None``\\입니다. ``level``\\은 상대 "
"임포트 수준을 보유하는 정수입니다 (0은 절대 임포트를 의미합니다)."

#: ../../library/ast.rst:1072
msgid ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)])"
msgstr ""

#: ../../library/ast.rst:1088
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` "
"if the regular name is to be used."
msgstr "두 매개 변수 모두 이름의 원시 문자열입니다. 정규 이름을 사용하면 ``asname``\\은 ``None``\\이 될 수 있습니다."

#: ../../library/ast.rst:1091
msgid ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)])"
msgstr ""

#: ../../library/ast.rst:1104
msgid "Control flow"
msgstr "제어 흐름"

#: ../../library/ast.rst:1107
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're "
"not present."
msgstr "``else``\\와 같은 선택적 절은 존재하지 않으면 빈 목록으로 저장됩니다."

#: ../../library/ast.rst:1112
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a "
":class:`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"``if`` 문. ``test``\\는 (:class:`Compare` 노드와 같은) 단일 노드를 보유합니다. ``body``\\와"
" ``orelse``\\는 각각 노드 리스트를 보유합니다."

#: ../../library/ast.rst:1115
msgid ""
"``elif`` clauses don't have a special representation in the AST, but "
"rather appear as extra :class:`If` nodes within the ``orelse`` section of"
" the previous one."
msgstr ""
"``elif`` 절은 AST에서 특별한 표현이 없지만, 앞의 ``orelse`` 섹션 안에서 추가 :class:`If` 노드로 "
"나타납니다."

#: ../../library/ast.rst:1119
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1149
#, fuzzy
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as "
"a single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute`"
" or :class:`Subscript` node. ``iter`` holds the item to be looped over, "
"again as a single node. ``body`` and ``orelse`` contain lists of nodes to"
" execute. Those in ``orelse`` are executed if the loop finishes normally,"
" rather than via a ``break`` statement."
msgstr ""
"``for`` 루프 ``target``\\은 루프가 대입하는 변수를 단일 :class:`Name`, :class:`Tuple` 또는"
" :class:`List` 노드로 보유합니다. ``iter``\\는 루핑할 항목을 역시 단일 노드로 보유합니다. "
"``body``\\와 ``orelse``\\는 실행할 노드의 리스트를 포함합니다. 루프가 ``break`` 문을 통하지 않고 "
"정상적으로 완료되면 ``orelse``\\에 있는 노드가 실행됩니다."

#: ../../library/ast.rst:1160
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""

#: ../../library/ast.rst:1183
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a "
":class:`Compare` node."
msgstr "``while`` 루프. ``test``\\는 (:class:`Compare` 노드와 같은) 조건을 보유합니다."

#: ../../library/ast.rst:1186
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""

#: ../../library/ast.rst:1209
msgid "The ``break`` and ``continue`` statements."
msgstr "``break``\\와 ``continue`` 문."

#: ../../library/ast.rst:1211
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])])])"
msgstr ""

#: ../../library/ast.rst:1242
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``try`` 블록. :class:`ExceptHandler` 노드의 리스트인 ``handlers``\\를 제외한, 모든 "
"어트리뷰트는 실행할 노드의 리스트입니다."

#: ../../library/ast.rst:1245
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""

#: ../../library/ast.rst:1287
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes "
"are the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then "
"``except``."
msgstr ""

#: ../../library/ast.rst:1291
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1316
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match,"
" typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of "
"nodes."
msgstr ""
"단일 ``except`` 절. ``type``\\은 일치할 예외 형이며, 일반적으로 :class:`Name` 노드(또는 모두 잡는 "
"``except:`` 절의 경우는 ``None``)입니다. ``name``\\은 예외를 담을 이름을 위한 원시 문자열이거나, 절에 "
"``as foo``\\가 없으면 ``None``\\입니다. ``body``\\는 노드의 리스트입니다."

#: ../../library/ast.rst:1321
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"
msgstr ""

#: ../../library/ast.rst:1347
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block "
"inside the context."
msgstr ""
"``with`` 블록. ``items``\\는 컨텍스트 관리자를 나타내는 :class:`withitem` 노드의 리스트이며, "
"``body``\\는 컨텍스트 내에서 들여쓰기 된 블록입니다."

#: ../../library/ast.rst:1357
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a "
":class:`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, "
"or ``None`` if that isn't used."
msgstr ""
"``with`` 블록의 단일 컨텍스트 관리자. ``context_expr``\\은 컨텍스트 관리자이며, 종종 "
":class:`Call` 노드입니다. ``optional_vars``\\는 ``as foo`` 부분의 경우 "
":class:`Name`, :class:`Tuple` 또는 :class:`List`\\이거나, 사용하지 않으면 "
"``None``\\입니다."

#: ../../library/ast.rst:1362
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])"
msgstr ""

#: ../../library/ast.rst:1388
msgid "Pattern matching"
msgstr ""

#: ../../library/ast.rst:1393
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an"
" iterable of :class:`match_case` nodes with the different cases."
msgstr ""

#: ../../library/ast.rst:1401
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the "
":class:`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""

#: ../../library/ast.rst:1406
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if "
"the pattern matches the subject."
msgstr ""

#: ../../library/ast.rst:1409
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and "
"the result of evaluating the guard expression is true."
msgstr ""

#: ../../library/ast.rst:1412
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1450
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is "
"an expression node. Permitted value nodes are restricted as described in "
"the match statement documentation. This pattern succeeds if the match "
"subject is equal to the evaluated value."
msgstr ""

#: ../../library/ast.rst:1455
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1478
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""

#: ../../library/ast.rst:1482
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1504
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be "
"matched against the subject elements if the subject is a sequence. "
"Matches a variable length sequence if one of the subpatterns is a "
"``MatchStar`` node, otherwise matches a fixed length sequence."
msgstr ""

#: ../../library/ast.rst:1509
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1536
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern "
"is successful."
msgstr ""

#: ../../library/ast.rst:1540
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1577
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an"
" optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the "
"match statement documentation."
msgstr ""

#: ../../library/ast.rst:1583
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to "
"each key matches the corresponding subpattern. If ``rest`` is not "
"``None``, a dict containing the remaining mapping elements is bound to "
"that name if the overall mapping pattern is successful."
msgstr ""

#: ../../library/ast.rst:1589
#, python-brace-format
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1624
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class "
"to be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` "
"are the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""

#: ../../library/ast.rst:1631
msgid ""
"This pattern succeeds if the subject is an instance of the nominated "
"class, all positional patterns match the corresponding class-defined "
"attributes, and any specified keyword attributes match their "
"corresponding pattern."
msgstr ""

#: ../../library/ast.rst:1635
msgid ""
"Note: classes may define a property that returns self in order to match a"
" pattern node against the instance being matched. Several builtin types "
"are also matched that way, as described in the match statement "
"documentation."
msgstr ""

#: ../../library/ast.rst:1639
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1686
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If "
"the pattern is ``None``, the node represents a capture pattern (i.e a "
"bare name) and will always succeed."
msgstr ""

#: ../../library/ast.rst:1691
msgid ""
"The ``name`` attribute contains the name that will be bound if the "
"pattern is successful. If ``name`` is ``None``, ``pattern`` must also be "
"``None`` and the node represents the wildcard pattern."
msgstr ""

#: ../../library/ast.rst:1695
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1728
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to"
" succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will "
"be matched against the subject."
msgstr ""

#: ../../library/ast.rst:1734
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""

#: ../../library/ast.rst:1762
msgid "Type parameters"
msgstr ""

#: ../../library/ast.rst:1764
msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and"
" type aliases."
msgstr ""

#: ../../library/ast.rst:1769
msgid ""
"A :class:`typing.TypeVar`. ``name`` is the name of the type variable. "
"``bound`` is the bound or constraints, if any. If ``bound`` is a "
":class:`Tuple`, it represents constraints; otherwise it represents the "
"bound. ``default_value`` is the default value; if the :class:`!TypeVar` "
"has no default, this attribute will be set to ``None``."
msgstr ""

#: ../../library/ast.rst:1775
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:1794 ../../library/ast.rst:1829
#: ../../library/ast.rst:1861
#, fuzzy
msgid "Added the *default_value* parameter."
msgstr "*indent* 옵션을 추가했습니다."

#: ../../library/ast.rst:1799
msgid ""
"A :class:`typing.ParamSpec`. ``name`` is the name of the parameter "
"specification. ``default_value`` is the default value; if the "
":class:`!ParamSpec` has no default, this attribute will be set to "
"``None``."
msgstr ""

#: ../../library/ast.rst:1803
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[**P = [int, str]] = Callable[P,"
" int]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=List(\n"
"                        elts=[\n"
"                            Name(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load())],\n"
"                        ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:1834
msgid ""
"A :class:`typing.TypeVarTuple`. ``name`` is the name of the type variable"
" tuple. ``default_value`` is the default value; if the "
":class:`!TypeVarTuple` has no default, this attribute will be set to "
"``None``."
msgstr ""

#: ../../library/ast.rst:1838
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""

#: ../../library/ast.rst:1865
msgid "Function and class definitions"
msgstr "함수와 클래스 정의"

#: ../../library/ast.rst:1869
msgid "A function definition."
msgstr "함수 정의."

#: ../../library/ast.rst:1871
msgid "``name`` is a raw string of the function name."
msgstr "``name``\\은 함수 이름의 원시 문자열입니다."

#: ../../library/ast.rst:1872
#, fuzzy
msgid "``args`` is an :class:`arguments` node."
msgstr "``args``\\는 :class:`arguments` 노드입니다."

#: ../../library/ast.rst:1873
msgid "``body`` is the list of nodes inside the function."
msgstr "``body``\\는 함수 내부의 노드 리스트입니다."

#: ../../library/ast.rst:1874
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored "
"outermost first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list``\\는 적용할 데코레이터 리스트이며, 가장 바깥쪽에 먼저 저장됩니다 (즉, 리스트의 첫 번째가 "
"마지막에 적용됩니다)."

#: ../../library/ast.rst:1876
msgid "``returns`` is the return annotation."
msgstr "``returns``\\는 반환 어노테이션입니다."

#: ../../library/ast.rst:1877 ../../library/ast.rst:2040
msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr ""

#: ../../library/ast.rst:1883 ../../library/ast.rst:2067
#: ../../library/ast.rst:2078
msgid "Added ``type_params``."
msgstr ""

#: ../../library/ast.rst:1889
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda``\\는 표현식 내에서 사용할 수 있는 최소 함수 정의입니다. :class:`FunctionDef`\\와 달리, "
"``body``\\는 단일 노드를 보유합니다."

#: ../../library/ast.rst:1892
msgid ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Constant(value=Ellipsis)))])"
msgstr ""

#: ../../library/ast.rst:1908
msgid "The arguments for a function."
msgstr "함수의 인자."

#: ../../library/ast.rst:1910
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` "
"nodes."
msgstr "``posonlyargs``, ``args`` 및 ``kwonlyargs``\\는 :class:`arg` 노드의 리스트입니다."

#: ../../library/ast.rst:1911
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg``\\와 ``kwarg``\\는 ``*args, **kwargs`` 매개 변수를 참조하는 단일 "
":class:`arg` 노드입니다."

#: ../../library/ast.rst:1913
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. "
"If one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults``\\는 키워드 전용 인자의 기본값 리스트입니다. 어떤 것이 ``None``\\이면, 해당 인자는 "
"필수입니다."

#: ../../library/ast.rst:1915
msgid ""
"``defaults`` is a list of default values for arguments that can be passed"
" positionally. If there are fewer defaults, they correspond to the last n"
" arguments."
msgstr ""
"``defaults``\\는 위치적으로 전달될 수 있는 인자의 기본값 리스트입니다. 기본값 수가 더 적으면, 마지막 n개의 인자에 "
"해당합니다."

#: ../../library/ast.rst:1922
#, fuzzy
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument "
"name; ``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""
"리스트의 단일 인자. ``arg``\\는 인자 이름의 원시 문자열이고, ``annotation``\\은 "
":class:`Str`\\이나 :class:`Name` 노드와 같은 어노테이션입니다."

#: ../../library/ast.rst:1927
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment"
msgstr "``type_comment``\\는 주석으로 제공된 형 어노테이션이 있는 선택적 문자열입니다."

#: ../../library/ast.rst:1929
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'))])"
msgstr ""

#: ../../library/ast.rst:1969
msgid "A ``return`` statement."
msgstr "``return`` 문."

#: ../../library/ast.rst:1971
msgid ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))])"
msgstr ""

#: ../../library/ast.rst:1983
#, fuzzy
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in an :class:`Expr` node if the value sent back is "
"not used."
msgstr ""
"``yield``\\나 ``yield from`` 표현식. 이들은 표현식이라서, 반환된 값이 사용되지 않으면 "
":class:`Expr` 노드에 래핑 되어야 합니다."

#: ../../library/ast.rst:1986
msgid ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))])"
msgstr ""

#: ../../library/ast.rst:2006
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw "
"strings."
msgstr "``global``\\과 ``nonlocal`` 문. ``names``\\는 원시 문자열 리스트입니다."

#: ../../library/ast.rst:2008
msgid ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"
msgstr ""

#: ../../library/ast.rst:2031
msgid "A class definition."
msgstr "클래스 정의."

#: ../../library/ast.rst:2033
msgid "``name`` is a raw string for the class name"
msgstr "``name``\\은 클래스 이름의 원시 문자열입니다."

#: ../../library/ast.rst:2034
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases``\\는 명시적으로 지정된 베이스 클래스의 노드 리스트입니다."

#: ../../library/ast.rst:2035
#, fuzzy
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
":pep:`3115`."
msgstr ""
"``keywords``\\는 :class:`keyword` 노드 리스트입니다, 주로 'metaclass'를 위한 것입니다. 다른 "
"키워드는 `PEP-3115 <http://www.python.org/dev/peps/pep-3115/>`_\\에 따라 메타 클래스로"
" 전달됩니다."

#: ../../library/ast.rst:2037
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr "``body``\\는 클래스 정의 내에서 코드를 나타내는 노드 리스트입니다."

#: ../../library/ast.rst:2039
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list``\\는 :class:`FunctionDef`\\에서와 같이 노드 리스트입니다."

#: ../../library/ast.rst:2042
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"
msgstr ""

#: ../../library/ast.rst:2071
msgid "Async and await"
msgstr "Async와 await"

#: ../../library/ast.rst:2075
msgid ""
"An ``async def`` function definition. Has the same fields as "
":class:`FunctionDef`."
msgstr "``async def`` 함수 정의. :class:`FunctionDef`\\와 같은 필드를 갖습니다."

#: ../../library/ast.rst:2084
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in "
"the body of an :class:`AsyncFunctionDef`."
msgstr ""
"``await`` 표현식. ``value``\\는 기다릴 대상입니다. :class:`AsyncFunctionDef`\\의 본문에서만"
" 유효합니다."

#: ../../library/ast.rst:2087
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()))))])])"
msgstr ""

#: ../../library/ast.rst:2108
msgid ""
"``async for`` loops and ``async with`` context managers. They have the "
"same fields as :class:`For` and :class:`With`, respectively. Only valid "
"in the body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for`` 루프와 ``async with`` 컨텍스트 관리자. 이들은 각각 :class:`For`\\와 "
":class:`With`\\와 같은 필드를 갖습니다. :class:`AsyncFunctionDef`\\의 본문에서만 유효합니다."

#: ../../library/ast.rst:2113
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses "
"of :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, "
":class:`ast.boolop` and :class:`ast.expr_context`) on the returned tree "
"will be singletons. Changes to one will be reflected in all other "
"occurrences of the same value (e.g. :class:`ast.Add`)."
msgstr ""
"문자열이 :func:`ast.parse`\\로 구문 분석될 때, 반환된 트리의 연산자 노드(:class:`ast.operator`,"
" :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast.boolop` 및 "
":class:`ast.expr_context`\\의 서브 클래스)는 싱글톤이 됩니다. 어느 하나의 변경 사항은 같은 값으로 등장하는"
" 다른 모든 곳에 반영됩니다 (예를 들어 :class:`ast.Add`)."

#: ../../library/ast.rst:2121
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` 도우미"

#: ../../library/ast.rst:2123
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr "노드 클래스 외에도, :mod:`ast` 모듈은 추상 구문 트리를 탐색하기 위해 다음 유틸리티 함수와 클래스를 정의합니다:"

#: ../../library/ast.rst:2128
#, fuzzy
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, flags=FLAGS_VALUE, optimize=optimize)``, where "
"``FLAGS_VALUE`` is ``ast.PyCF_ONLY_AST`` if ``optimize <= 0`` and "
"``ast.PyCF_OPTIMIZED_AST`` otherwise."
msgstr ""
"소스를 AST 노드로 구문 분석합니다. ``compile(source, filename, mode, "
"ast.PyCF_ONLY_AST)``\\와 동등합니다."

#: ../../library/ast.rst:2133
#, fuzzy
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed "
"to :func:`compile`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In"
" addition, the locations of ``# type: ignore`` comments will be returned "
"as the ``type_ignores`` attribute of :class:`Module` (otherwise it is "
"always an empty list)."
msgstr ""
"``type_comments=True``\\가 제공되면, 구문 분석기는 :pep:`484`\\와 :pep:`526`\\에 지정된 형"
" 주석을 확인하고 반환하도록 수정됩니다. 이는 :func:`compile()`\\에 전달된 플래그에 "
":data:`ast.PyCF_TYPE_COMMENTS`\\를 추가하는 것과 같습니다. 이것은 잘못 배치된 형 주석에 대한 문법 "
"에러를 보고합니다. 이 플래그가 없으면, 형 주석은 무시되고, 선택한 AST 노드의 ``type_comment`` 필드는 항상 "
"``None``\\입니다. 또한, ``# type: ignore`` 주석의 위치는 :class:`Module`\\의 "
"``type_ignores`` 어트리뷰트로 반환됩니다 (그렇지 않으면 항상 빈 리스트입니다)."

#: ../../library/ast.rst:2143
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified"
" to correspond to :pep:`484` \"signature type comments\", e.g. ``(str, "
"int) -> List[str]``."
msgstr ""
"또한, ``mode``\\가 ``'func_type'``\\이면, 입력 문법은 :pep:`484` \"서명 형 주석\"에 따라 "
"수정됩니다, 예를 들어 ``(str, int) -> List[str]``."

#: ../../library/ast.rst:2147
msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in "
"a \"best-effort\" attempt to parse using that Python version's grammar. "
"For example, setting ``feature_version=(3, 9)`` will attempt to disallow "
"parsing of :keyword:`match` statements. Currently ``major`` must equal to"
" ``3``. The lowest supported version is ``(3, 7)`` (and this may increase"
" in future Python versions); the highest is ``sys.version_info[0:2]``. "
"\"Best-effort\" attempt means there is no guarantee that the parse (or "
"success of the parse) is the same as when run on the Python version "
"corresponding to ``feature_version``."
msgstr ""

#: ../../library/ast.rst:2157
msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is "
"raised."
msgstr ""

#: ../../library/ast.rst:2160
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to"
" be inside a function node)."
msgstr ""

#: ../../library/ast.rst:2167
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""

#: ../../library/ast.rst:2171
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string due to stack depth limitations in Python's AST "
"compiler."
msgstr "파이썬 AST 컴파일러의 스택 깊이 제한으로 인해 충분히 크고/복잡한 문자열로 파이썬 인터프리터가 충돌하도록 만들 수 있습니다."

#: ../../library/ast.rst:2175
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr "``type_comments``, ``mode='func_type'`` 및 ``feature_version``\\ 추가했습니다."

#: ../../library/ast.rst:2178
msgid ""
"The minimum supported version for ``feature_version`` is now ``(3, 7)``. "
"The ``optimize`` argument was added."
msgstr ""

#: ../../library/ast.rst:2185
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with "
":func:`ast.parse`."
msgstr ""
":class:`ast.AST` 객체를 역 구문 분석하고 :func:`ast.parse`\\로 다시 구문 분석할 경우 동등한 "
":class:`ast.AST` 객체를 생성하는 코드가 포함된 문자열을 생성합니다."

#: ../../library/ast.rst:2190
msgid ""
"The produced code string will not necessarily be equal to the original "
"code that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"생성된 코드 문자열은 :class:`ast.AST` 객체를 생성한 원래 코드와 반드시 같을 필요는 없습니다 (상수 "
"튜플/frozenset과 같은 컴파일러 최적화 없이)."

#: ../../library/ast.rst:2195
msgid ""
"Trying to unparse a highly complex expression would result with "
":exc:`RecursionError`."
msgstr "매우 복잡한 표현식을 역 구분 분석하려고 하면 :exc:`RecursionError`\\가 발생할 수 있습니다."

#: ../../library/ast.rst:2203
#, fuzzy
msgid ""
"Evaluate an expression node or a string containing only a Python literal "
"or container display.  The string or node provided may only consist of "
"the following Python literal structures: strings, bytes, numbers, tuples,"
" lists, dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"파이썬 리터럴 이나 컨테이너 디스플레이를 포함하는 표현식 노드나 문자열을 안전하게 평가합니다. 제공된 문자열이나 노드는 다음과 같은"
" 파이썬 리터럴 구조로만 구성될 수 있습니다: 문자열, 바이트열, 숫자, 튜플, 리스트, 딕셔너리, 집합, 불리언 및 "
"``None``."

#: ../../library/ast.rst:2208
#, fuzzy
msgid ""
"This can be used for evaluating strings containing Python values without "
"the need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or "
"indexing."
msgstr ""
"값을 직접 구문 분석할 필요 없이 신뢰할 수 없는 소스의 파이썬 값을 포함하는 문자열을 안전하게 평가하는 데 사용할 수 있습니다. "
"예를 들어 연산자나 인덱싱이 개입한, 임의의 복잡한 표현식을 평가할 수 없습니다."

#: ../../library/ast.rst:2213
msgid ""
"This function had been documented as \"safe\" in the past without "
"defining what that meant. That was misleading. This is specifically "
"designed not to execute Python code, unlike the more general "
":func:`eval`. There is no namespace, no name lookups, or ability to call "
"out. But it is not free from attack: A relatively small input can lead to"
" memory exhaustion or to C stack exhaustion, crashing the process. There "
"is also the possibility for excessive CPU consumption denial of service "
"on some inputs. Calling it on untrusted data is thus not recommended."
msgstr ""

#: ../../library/ast.rst:2223
#, fuzzy
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr "파이썬 AST 컴파일러의 스택 깊이 제한으로 인해 충분히 크고/복잡한 문자열로 파이썬 인터프리터가 충돌하도록 만들 수 있습니다."

#: ../../library/ast.rst:2226
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, "
":exc:`MemoryError` and :exc:`RecursionError` depending on the malformed "
"input."
msgstr ""

#: ../../library/ast.rst:2230
msgid "Now allows bytes and set literals."
msgstr "이제 바이트열과 집합 리터럴을 허용합니다."

#: ../../library/ast.rst:2233
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "이제 ``'set()'``\\으로 빈 집합을 만드는 것을 지원합니다."

#: ../../library/ast.rst:2236
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""

#: ../../library/ast.rst:2242
msgid ""
"Return the docstring of the given *node* (which must be a "
":class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or "
":class:`Module` node), or ``None`` if it has no docstring. If *clean* is "
"true, clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"주어진 *node*\\(:class:`FunctionDef`, :class:`AsyncFunctionDef`, "
":class:`ClassDef` 또는 :class:`Module` 노드이어야 합니다)의 독스트링이나, 독스트링이 없으면 "
"``None``\\을 반환합니다. *clean*\\이 참이면, :func:`inspect.cleandoc`\\으로 독스트링의 "
"들여쓰기를 정리합니다."

#: ../../library/ast.rst:2248
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` 가 이제 지원됩니다."

#: ../../library/ast.rst:2254
#, fuzzy
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, "
":attr:`~ast.AST.end_lineno`, :attr:`~ast.AST.col_offset`, or "
":attr:`~ast.AST.end_col_offset`) is missing, return ``None``."
msgstr ""
"*node*\\를 생성한 *source*\\의 소스 코드 세그먼트를 가져옵니다. 일부 위치 정보(:attr:`lineno`, "
":attr:`end_lineno`, :attr:`col_offset` 또는 :attr:`end_col_offset`)가 없으면, "
"``None``\\을 반환합니다."

#: ../../library/ast.rst:2258
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be"
" padded with spaces to match its original position."
msgstr "*padded*\\가 ``True``\\이면, 여러 줄 문장의 첫 번째 줄은 원래 위치와 일치하도록 스페이스로 채워집니다."

#: ../../library/ast.rst:2266
#, fuzzy
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects "
":attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for "
"every node that supports them.  This is rather tedious to fill in for "
"generated nodes, so this helper adds these attributes recursively where "
"not already set, by setting them to the values of the parent node.  It "
"works recursively starting at *node*."
msgstr ""
":func:`compile`\\로 노드 트리를 컴파일할 때, 컴파일러는 지원하는 모든 노드에 대해 :attr:`lineno`\\와 "
":attr:`col_offset` 어트리뷰트를 기대합니다. 생성된 노드를 채울 때는 이것이 다소 지루하므로, 이 도우미는 이러한 "
"어트리뷰트를 재귀적으로 아직 설정되지 않은 위치에 부모 노드의 값으로 설정하여 추가합니다. *node*\\부터 재귀적으로 "
"작동합니다."

#: ../../library/ast.rst:2275
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different"
" location in a file."
msgstr ""
"*node*\\에서 시작하는 트리에서 각 노드의 줄 번호와 끝 줄 번호를 *n*\\만큼 증가시킵니다. 파일의 다른 위치로 \"코드를"
" 이동\"하는 데 유용합니다."

#: ../../library/ast.rst:2282
#, fuzzy
msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, "
":attr:`~ast.AST.col_offset`, :attr:`~ast.AST.end_lineno`, and "
":attr:`~ast.AST.end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"가능하면 소스 위치(:attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` 및 "
":attr:`end_col_offset`)를 *old_node*\\에서 *new_node*\\로 복사하고, *new_node*\\를"
" 반환합니다."

#: ../../library/ast.rst:2289
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in "
"``node._fields`` that is present on *node*."
msgstr ""
"*node*\\에 존재하는 ``node._fields``\\의 각 필드에 대해 ``(fieldname, value)`` 튜플을 "
"산출합니다."

#: ../../library/ast.rst:2295
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are "
"nodes and all items of fields that are lists of nodes."
msgstr "*node*\\의 모든 직접 자식 노드, 즉 노드인 모든 필드와 노드 리스트인 필드의 모든 항목을 산출합니다."

#: ../../library/ast.rst:2301
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"*node*\\로 시작하는 트리(*node* 자체를 포함합니다)의 모든 자손 노드를 지정된 순서 없이 재귀적으로 산출합니다. 이는 "
"노드를 제자리에서 수정하고 문맥을 신경 쓰지 않을 때 유용합니다."

#: ../../library/ast.rst:2308
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a"
" visitor function for every node found.  This function may return a value"
" which is forwarded by the :meth:`visit` method."
msgstr ""
"추상 구문 트리를 걷고 발견된 모든 노드에 대해 방문자 함수를 호출하는 노드 방문자 베이스 클래스. 이 함수는 "
":meth:`visit` 메서드에 의해 전달되는 값을 반환할 수 있습니다."

#: ../../library/ast.rst:2312
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr "이 클래스는 서브 클래싱하고자 하는 것이며, 서브 클래스는 방문자 메서드를 추가합니다."

#: ../../library/ast.rst:2317
#, python-brace-format
msgid ""
"Visit a node.  The default implementation calls the method called "
":samp:`self.visit_{classname}` where *classname* is the name of the node "
"class, or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"노드를 방문합니다. 기본 구현은 :samp:`self.visit_{classname}`\\이라는 메서드를 호출하는데, 여기서 "
"*classname* 은 노드 클래스의 이름입니다. 또는 이 메서드가 없으면 :meth:`generic_visit`\\를 "
"호출합니다."

#: ../../library/ast.rst:2323
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "이 방문자는 노드의 자식에 대해 :meth:`visit`\\를 호출합니다."

#: ../../library/ast.rst:2325
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be"
" visited unless the visitor calls :meth:`generic_visit` or visits them "
"itself."
msgstr ""
"방문자가 :meth:`generic_visit`\\를 호출하거나 직접 방문하지 않는 한, 사용자 정의 방문자 메서드가 있는 노드의 "
"자식 노드는 방문 되지 않음에 유의하십시오."

#: ../../library/ast.rst:2331
msgid "Handles all constant nodes."
msgstr ""

#: ../../library/ast.rst:2333
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists "
"(:class:`NodeTransformer`) that allows modifications."
msgstr ""
"탐색 중에 노드에 변경 사항을 적용하려면 :class:`NodeVisitor`\\를 사용하지 마십시오. 이를 위해 수정을 허락하는 "
"특수한 방문자(:class:`NodeTransformer`)가 있습니다."

#: ../../library/ast.rst:2339
#, fuzzy
msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, "
":meth:`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated "
"now and will not be called in future Python versions.  Add the "
":meth:`visit_Constant` method to handle all constant nodes."
msgstr ""
"메서드 :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, "
":meth:`visit_NameConstant` 및 :meth:`visit_Ellipsis`\\는 이제 폐지되었고 향후 파이썬 "
"버전에서는 호출되지 않을 것입니다. 모든 상수 노드를 처리하려면 :meth:`visit_Constant` 메서드를 추가하십시오."

#: ../../library/ast.rst:2347
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr "추상 구문 트리를 걷고 노드 수정을 허락하는 :class:`NodeVisitor` 서브 클래스."

#: ../../library/ast.rst:2350
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value "
"of the visitor methods to replace or remove the old node.  If the return "
"value of the visitor method is ``None``, the node will be removed from "
"its location, otherwise it is replaced with the return value.  The return"
" value may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer`\\는 AST를 걷고 방문자 메서드의 반환 값을 사용하여 이전 노드를 바꾸거나 "
"제거합니다. 방문자 메서드의 반환 값이 ``None``\\이면, 노드가 그 위치에서 제거되고, 그렇지 않으면 반환 값으로 "
"치환됩니다. 반환 값은 원래 노드일 수 있으며, 이때는 치환이 일어나지 않습니다."

#: ../../library/ast.rst:2356
msgid ""
"Here is an example transformer that rewrites all occurrences of name "
"lookups (``foo``) to ``data['foo']``::"
msgstr "다음은 모든 이름 조회(``foo``)를 ``data['foo']``\\로 다시 쓰는 변환기 예제입니다::"

#: ../../library/ast.rst:2359
msgid ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"
msgstr ""

#: ../../library/ast.rst:2368
#, fuzzy
msgid ""
"Keep in mind that if the node you're operating on has child nodes you "
"must either transform the child nodes yourself or call the "
":meth:`~ast.NodeVisitor.generic_visit` method for the node first."
msgstr ""
"작업 중인 노드에 자식 노드가 있으면 자식 노드를 직접 변환하거나 노드에 대한 :meth:`generic_visit` 메서드를 먼저"
" 호출해야 함을 염두에 두십시오."

#: ../../library/ast.rst:2372
msgid ""
"For nodes that were part of a collection of statements (that applies to "
"all statement nodes), the visitor may also return a list of nodes rather "
"than just a single node."
msgstr ""
"문장의 컬렉션의 일부인 노드의 경우 (모든 문장 노드에 적용됩니다), 방문자는 단일 노드가 아닌 노드 리스트를 반환 할 수도 "
"있습니다."

#: ../../library/ast.rst:2376
#, fuzzy
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as "
":attr:`~ast.AST.lineno`), :func:`fix_missing_locations` should be called "
"with the new sub-tree to recalculate the location information::"
msgstr ""
":class:`NodeTransformer`\\가 위치 정보(가령 :attr:`lineno`)를 제공하지 않고 (원래 트리의 일부가"
" 아닌) 새 노드를 도입하면, 위치 정보를 다시 계산하려면 :func:`fix_missing_locations`\\를 새 서브 "
"트리로 호출해야 합니다::"

#: ../../library/ast.rst:2381
msgid ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"
msgstr ""

#: ../../library/ast.rst:2384
msgid "Usually you use the transformer like this::"
msgstr "일반적으로 다음과 같이 변환기를 사용합니다::"

#: ../../library/ast.rst:2386
msgid "node = YourTransformer().visit(node)"
msgstr ""

#: ../../library/ast.rst:2391
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for"
" debugging purposes.  If *annotate_fields* is true (by default), the "
"returned string will show the names and the values for fields. If "
"*annotate_fields* is false, the result string will be more compact by "
"omitting unambiguous field names.  Attributes such as line numbers and "
"column offsets are not dumped by default.  If this is wanted, "
"*include_attributes* can be set to true."
msgstr ""
"*node*\\에서 포맷된 트리 덤프를 반환합니다. 이것은 주로 디버깅 목적으로 유용합니다. *annotate_fields*\\가 "
"참이면 (기본값), 반환된 문자열에 필드의 이름과 값이 표시됩니다. *annotate_fields*\\가 거짓이면, 모호하지 않은 "
"필드 이름을 생략하여 결과 문자열이 더 간결해집니다. 줄 번호와 열 오프셋과 같은 어트리뷰트는 기본적으로 덤프 되지 않습니다. "
"원한다면, *include_attributes*\\를 참으로 설정할 수 있습니다."

#: ../../library/ast.rst:2399
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, "
"or ``\"\"`` will only insert newlines.  ``None`` (the default) selects "
"the single line representation. Using a positive integer indent indents "
"that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"*indent*\\가 음이 아닌 정수나 문자열이면, 트리는 그 들여쓰기 수준으로 예쁘게 인쇄됩니다. 들여쓰기 수준 0, 음수 또는 "
"``\"\"``\\는 줄 넘김 만 삽입합니다. ``None``\\(기본값)은 단일 줄 표현을 선택합니다. 양의 정수 indent를 "
"사용하면 수준마다 그만큼 들여쓰기 됩니다. *indent*\\가 문자열(가령 ``\"\\t\"``)이면, 해당 문자열은 각 수준을 "
"들여 쓰는 데 사용됩니다."

#: ../../library/ast.rst:2406
msgid ""
"If *show_empty* is ``False`` (the default), empty lists and fields that "
"are ``None`` will be omitted from the output."
msgstr ""

#: ../../library/ast.rst:2409
msgid "Added the *indent* option."
msgstr "*indent* 옵션을 추가했습니다."

#: ../../library/ast.rst:2412
#, fuzzy
msgid "Added the *show_empty* option."
msgstr "*indent* 옵션을 추가했습니다."

#: ../../library/ast.rst:2415
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""

#: ../../library/ast.rst:2446
msgid "Compiler Flags"
msgstr "컴파일러 플래그"

#: ../../library/ast.rst:2448
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr "프로그램 컴파일에 대한 효과를 변경하기 위해 다음 플래그를 :func:`compile`\\에 전달할 수 있습니다:"

#: ../../library/ast.rst:2453
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` "
"and async comprehensions."
msgstr ""
"최상위 수준 ``await``, ``async for``, ``async with`` 및 비동기 컴프리헨션에 대한 지원을 "
"활성화합니다."

#: ../../library/ast.rst:2460
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr "컴파일된 코드 객체를 반환하는 대신 추상 구문 트리를 생성하고 반환합니다."

#: ../../library/ast.rst:2465
msgid ""
"The returned AST is optimized according to the *optimize* argument in "
":func:`compile` or :func:`ast.parse`."
msgstr ""

#: ../../library/ast.rst:2472
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# "
"type: <type>``, ``# type: ignore <stuff>``)."
msgstr ""
":pep:`484`\\와 :pep:`526` 스타일 형 주석(``# type: <type>``, ``# type: ignore "
"<stuff>``)에 대한 지원을 활성화합니다."

#: ../../library/ast.rst:2481
msgid "Command-Line Usage"
msgstr "명령 줄 사용법"

#: ../../library/ast.rst:2485
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. "
"It is as simple as:"
msgstr ":mod:`ast` 모듈은 명령 줄에서 스크립트로 실행될 수 있습니다. 다음과 같이 간단합니다:"

#: ../../library/ast.rst:2488
msgid "python -m ast [-m <mode>] [-a] [infile]"
msgstr ""

#: ../../library/ast.rst:2492
msgid "The following options are accepted:"
msgstr "다음과 같은 옵션이 허용됩니다:"

#: ../../library/ast.rst:2498
msgid "Show the help message and exit."
msgstr "도움말 메시지를 표시하고 종료합니다."

#: ../../library/ast.rst:2503
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in "
":func:`parse`."
msgstr ":func:`parse`\\의 *mode* 인자와 같이, 컴파일해야 하는 코드 종류를 지정합니다."

#: ../../library/ast.rst:2508
msgid "Don't parse type comments."
msgstr "형 주석을 구문 분석하지 않습니다."

#: ../../library/ast.rst:2512
msgid "Include attributes such as line numbers and column offsets."
msgstr "줄 번호와 열 오프셋과 같은 어트리뷰트를 포함합니다."

#: ../../library/ast.rst:2517
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "AST에서 노드 들여쓰기(스페이스 수)."

#: ../../library/ast.rst:2519
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped "
"to stdout.  Otherwise, the content is read from stdin."
msgstr ""
":file:`infile`\\이 지정되면 그 내용이 AST로 구문 분석되고 stdout에 덤프 됩니다. 그렇지 않으면, "
"stdin에서 내용을 읽습니다."

#: ../../library/ast.rst:2525
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an "
"external documentation resource, has good details on working with Python "
"ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, 파이썬 AST로 "
"작업하는 것에 대한 자세한 내용이 있는 외부 문서 자원."

#: ../../library/ast.rst:2528
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_"
" annotates Python ASTs with the positions of tokens and text in the "
"source code that generated them. This is helpful for tools that make "
"source code transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-"
"guide.html>`_\\는 토큰의 위치와 토큰을 생성한 소스 코드의 텍스트로 파이썬 AST에 주석을 추가합니다. 이는 소스 코드"
" 변환을 수행하는 도구에 유용합니다."

#: ../../library/ast.rst:2533
#, fuzzy
msgid ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html"
"#leoast-py>`_ unifies the token-based and parse-tree-based views of "
"python programs by inserting two-way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_\\는 토큰과 ast "
"노드 사이에 양방향 링크를 삽입하여 파이썬 프로그램의 토큰 기반과 구문 분석 트리 기반 뷰를 통합합니다."

#: ../../library/ast.rst:2538
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete "
"Syntax Tree that looks like an ast tree and keeps all formatting details."
" It's useful for building automated refactoring (codemod) applications "
"and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_\\는 코드를 ast 트리처럼 보이고 모든 포매팅 세부 "
"정보를 유지하는 구상 구문 트리(Concrete Syntax Tree)로 구문 분석합니다. 자동화된 리팩토링 (codemod) 응용"
" 프로그램과 린터(linter)를 구축하는 데 유용합니다."

#: ../../library/ast.rst:2543
#, fuzzy
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax "
"errors in your Python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_\\는 다른 파이썬 버전(여러 Python 버전에서)에 대한 "
"에러 복구와 왕복 구문 분석(round-trip parsing)을 지원하는 파이썬 파서입니다. Parso는 여러분의 파이썬 파일에 "
"있는 여러 구문 에러를 나열 할 수도 있습니다."

#: ../../library/ast.rst:59
msgid "? (question mark)"
msgstr ""

#: ../../library/ast.rst:59 ../../library/ast.rst:60
#, fuzzy
msgid "in AST grammar"
msgstr "추상 문법"

#: ../../library/ast.rst:60
msgid "* (asterisk)"
msgstr ""

#~ msgid "or the more compact ::"
#~ msgstr "또는 더 간결하게 ::"

#~ msgid ""
#~ "When creating a ``Call`` node, ``args``"
#~ " and ``keywords`` are required, but "
#~ "they can be empty lists. ``starargs``"
#~ " and ``kwargs`` are optional."
#~ msgstr ""
#~ "``Call`` 노드를 만들 때, ``args``\\와 "
#~ "``keywords``\\는 필수이지만, 비어있는 리스트일 수 있습니다."
#~ " ``starargs``\\와 ``kwargs``\\는 선택적입니다."

#~ msgid ""
#~ "``starargs`` and ``kwargs`` are each a"
#~ " single node, as in a function "
#~ "call. starargs will be expanded to "
#~ "join the list of base classes, and"
#~ " kwargs will be passed to the "
#~ "metaclass."
#~ msgstr ""
#~ "``starargs``\\와 ``kwargs``\\는 함수 호출에서와같이 각각"
#~ " 단일 노드입니다. starargs는 베이스 클래스 리스트에 "
#~ "연결하도록 확장되고, kwargs는 메타 클래스로 전달됩니다."

#~ msgid ""
#~ "Also, setting ``feature_version`` to a "
#~ "tuple ``(major, minor)`` will attempt to"
#~ " parse using that Python version's "
#~ "grammar. Currently ``major`` must equal "
#~ "to ``3``.  For example, setting "
#~ "``feature_version=(3, 4)`` will allow the "
#~ "use of ``async`` and ``await`` as "
#~ "variable names.  The lowest supported "
#~ "version is ``(3, 4)``; the highest "
#~ "is ``sys.version_info[0:2]``."
#~ msgstr ""
#~ "또한, ``feature_version``\\을 튜플 ``(major, "
#~ "minor)``\\로 설정하면 해당 파이썬 버전의 문법을 "
#~ "사용하여 구문 분석을 시도합니다. 현재 ``major``\\는 "
#~ "``3``\\과 같아야 합니다. 예를 들어, "
#~ "``feature_version=(3, 4)``\\를 설정하면 변수 이름으로 "
#~ "``async``\\와 ``await``\\를 사용할 수 있습니다. 가장"
#~ " 낮은 지원 버전은 ``(3, 4)``\\입니다; 가장 "
#~ "높은 것은 ``sys.version_info[0:2]``\\입니다."

