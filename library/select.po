# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/select.rst:2
#, fuzzy
msgid ":mod:`!select` --- Waiting for I/O completion"
msgstr ":mod:`select` --- I/O 완료 대기"

#: ../../library/select.rst:9
#, fuzzy
msgid ""
"This module provides access to the :c:func:`!select` and :c:func:`!poll` "
"functions available in most operating systems, :c:func:`!devpoll` "
"available on Solaris and derivatives, :c:func:`!epoll` available on Linux"
" 2.5+ and :c:func:`!kqueue` available on most BSD. Note that on Windows, "
"it only works for sockets; on other operating systems, it also works for "
"other file types (in particular, on Unix, it works on pipes). It cannot "
"be used on regular files to determine whether a file has grown since it "
"was last read."
msgstr ""
"이 모듈은 대부분의 운영 체제에서 사용 가능한 :c:func:`select`\\와 :c:func:`poll` 함수, Solaris와"
" 파생 제품에서 사용 가능한 :c:func:`devpoll`, 리눅스 2.5+ 에서 사용 가능한 :c:func:`epoll` 및 "
"대부분의 BSD에서 사용 가능한 :c:func:`kqueue`\\에 대한 액세스를 제공합니다. 윈도우에서는 소켓에서만 작동함에 "
"유의하십시오; 다른 운영 체제에서는, 다른 파일 유형에서도 작동합니다 (특히, 유닉스에서는 파이프에서도 작동합니다). 일반 파일에서"
" 파일을 마지막으로 읽은 이후에 파일이 커졌는지를 판별하기 위해 사용할 수는 없습니다."

#: ../../library/select.rst:20
msgid ""
"The :mod:`selectors` module allows high-level and efficient I/O "
"multiplexing, built upon the :mod:`select` module primitives. Users are "
"encouraged to use the :mod:`selectors` module instead, unless they want "
"precise control over the OS-level primitives used."
msgstr ""
":mod:`selectors` 모듈은 :mod:`select` 모듈 프리미티브에 기반한 고수준의 효율적인 I/O 멀티플렉싱을 "
"제공합니다. 사용되는 OS 수준 프리미티브에 대한 정확한 제어를 원하지 않는 한, 사용자는 :mod:`selectors` 모듈을 "
"대신 사용하는 것이 좋습니다."

#: ../../includes/wasm-notavail.rst:3 ../../library/select.rst:177
#, fuzzy
msgid "Availability"
msgstr "쓰기 가능"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""

#: ../../library/select.rst:27
msgid "The module defines the following:"
msgstr "모듈은 다음을 정의합니다:"

#: ../../library/select.rst:32
msgid "A deprecated alias of :exc:`OSError`."
msgstr ":exc:`OSError`\\의 폐지된 별칭."

#: ../../library/select.rst:34
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ":pep:`3151`\\에 따라, 이 클래스는 :exc:`OSError`\\의 별칭이 되었습니다."

#: ../../library/select.rst:40
msgid ""
"(Only supported on Solaris and derivatives.)  Returns a ``/dev/poll`` "
"polling object; see section :ref:`devpoll-objects` below for the methods "
"supported by devpoll objects."
msgstr ""
"(Solaris와 파생 제품에서만 지원됩니다.) ``/dev/poll`` 폴링(polling) 객체를 반환합니다; devpoll "
"객체가 지원하는 메서드에 대해서는 아래의 :ref:`devpoll-objects` 섹션을 참조하십시오."

#: ../../library/select.rst:44
#, fuzzy
msgid ""
":c:func:`!devpoll` objects are linked to the number of file descriptors "
"allowed at the time of instantiation. If your program reduces this value,"
" :c:func:`!devpoll` will fail. If your program increases this value, "
":c:func:`!devpoll` may return an incomplete list of active file "
"descriptors."
msgstr ""
":c:func:`devpoll` 객체는 인스턴스 화 시점에 허용되는 파일 기술자 수에 연결됩니다. 프로그램이 이 값을 줄이면, "
":c:func:`devpoll`\\이 실패합니다. 프로그램이 이 값을 늘리면, :c:func:`devpoll`\\은 불완전한 활성 "
"파일 기술자 리스트를 반환할 수 있습니다."

#: ../../library/select.rst:50 ../../library/select.rst:79
#: ../../library/select.rst:106
msgid "The new file descriptor is :ref:`non-inheritable <fd_inheritance>`."
msgstr "새 파일 기술자는 :ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/select.rst:54 ../../library/select.rst:108
msgid "The new file descriptor is now non-inheritable."
msgstr "새 파일 기술자는 이제 상속 불가능합니다."

#: ../../library/select.rst:59
msgid ""
"(Only supported on Linux 2.5.44 and newer.) Return an edge polling "
"object, which can be used as Edge or Level Triggered interface for I/O "
"events."
msgstr ""
"(리눅스 2.5.44 이상에서만 지원됩니다.) I/O 이벤트를 위한 에지(Edge)나 레벨(Level) 트리거 되는 인터페이스로 "
"사용할 수 있는 에지 폴링 객체를 반환합니다."

#: ../../library/select.rst:63
#, fuzzy
msgid ""
"*sizehint* informs epoll about the expected number of events to be "
"registered.  It must be positive, or ``-1`` to use the default. It is "
"only used on older systems where :c:func:`!epoll_create1` is not "
"available; otherwise it has no effect (though its value is still "
"checked)."
msgstr ""
"*sizehint*\\는 epoll에 등록될 예상 이벤트 수를 알려줍니다. 양수이거나, 기본값을 사용하려면 `-1`\\이어야 "
"합니다. :c:func:`epoll_create1`\\을 사용할 수 없는 구형 시스템에서만 사용됩니다; 그렇지 않으면 효과가 "
"없습니다 (값을 여전히 확인하기는 합니다)."

#: ../../library/select.rst:68
msgid ""
"*flags* is deprecated and completely ignored.  However, when supplied, "
"its value must be ``0`` or ``select.EPOLL_CLOEXEC``, otherwise "
"``OSError`` is raised."
msgstr ""
"*flags*\\는 폐지되었고 완전히 무시됩니다. 그러나, 제공되면, 값은 ``0``\\이나 "
"``select.EPOLL_CLOEXEC``\\여야 합니다. 그렇지 않으면 ``OSError``\\가 발생합니다."

#: ../../library/select.rst:72
msgid ""
"See the :ref:`epoll-objects` section below for the methods supported by "
"epolling objects."
msgstr "epolling 객체가 지원하는 메서드는 아래의 :ref:`epoll-objects` 섹션을 참조하십시오."

#: ../../library/select.rst:75
msgid ""
"``epoll`` objects support the context management protocol: when used in a"
" :keyword:`with` statement, the new file descriptor is automatically "
"closed at the end of the block."
msgstr ""
"``epoll`` 객체는 컨텍스트 관리자 프로토콜을 지원합니다: :keyword:`with` 문에서 사용될 때, 새 파일 기술자는 "
"블록 끝에서 자동으로 닫힙니다."

#: ../../library/select.rst:81
msgid "Added the *flags* parameter."
msgstr "*flags* 매개 변수를 추가했습니다."

#: ../../library/select.rst:84
msgid ""
"Support for the :keyword:`with` statement was added. The new file "
"descriptor is now non-inheritable."
msgstr ":keyword:`with` 문에 대한 지원이 추가되었습니다. 새로운 파일 기술자는 이제 상속 불가능합니다."

#: ../../library/select.rst:88
msgid ""
"The *flags* parameter.  ``select.EPOLL_CLOEXEC`` is used by default now. "
"Use :func:`os.set_inheritable` to make the file descriptor inheritable."
msgstr ""
"*flags* 매개 변수. 이제 기본적으로 ``select.EPOLL_CLOEXEC``\\가 사용됩니다. 파일 기술자를 상속 "
"가능하게 하려면 :func:`os.set_inheritable`\\을 사용하십시오."

#: ../../library/select.rst:95
msgid ""
"(Not supported by all operating systems.)  Returns a polling object, "
"which supports registering and unregistering file descriptors, and then "
"polling them for I/O events; see section :ref:`poll-objects` below for "
"the methods supported by polling objects."
msgstr ""
"(모든 운영 체제에서 지원되는 것은 아닙니다.) 파일 기술자 등록과 등록 해지를 지원하고 그런 다음 I/O 이벤트에 대해 폴링하는 "
"폴링 객체를 반환합니다; 폴링 객체가 지원하는 메서드에 대해서는 아래의 :ref:`poll-objects` 섹션을 참조하십시오."

#: ../../library/select.rst:103
msgid ""
"(Only supported on BSD.)  Returns a kernel queue object; see section :ref"
":`kqueue-objects` below for the methods supported by kqueue objects."
msgstr ""
"(BSD에서만 지원됩니다.) 커널 큐 객체를 반환합니다; kqueue 객체가 지원하는 메서드에 대해서는 아래의 :ref"
":`kqueue-objects` 섹션을 참조하십시오."

#: ../../library/select.rst:114
msgid ""
"(Only supported on BSD.)  Returns a kernel event object; see section :ref"
":`kevent-objects` below for the methods supported by kevent objects."
msgstr ""
"(BSD에서만 지원됩니다.) 커널 이벤트 객체를 반환합니다. kevent 객체가 지원하는 메서드에 대해서는 아래의 :ref"
":`kevent-objects` 섹션을 참조하십시오."

#: ../../library/select.rst:120
#, fuzzy
msgid ""
"This is a straightforward interface to the Unix :c:func:`!select` system "
"call. The first three arguments are iterables of 'waitable objects': "
"either integers representing file descriptors or objects with a "
"parameterless method named :meth:`~io.IOBase.fileno` returning such an "
"integer:"
msgstr ""
"이것은 유닉스 :c:func:`select` 시스템 호출에 대한 간단한 인터페이스입니다. 처음 세 개의 인자는 '대기 가능한 "
"객체(waitable objects)'의 이터러블입니다: 대기 가능한 객체는 파일 기술자를 나타내는 정수나 그런 정수를 반환하는 "
":meth:`~io.IOBase.fileno`\\라는 매개 변수 없는 메서드를 가진 객체입니다:"

#: ../../library/select.rst:125
msgid "*rlist*: wait until ready for reading"
msgstr "*rlist*: 읽을 준비가 될 때까지 기다립니다"

#: ../../library/select.rst:126
msgid "*wlist*: wait until ready for writing"
msgstr "*wlist*: 쓰기 준비가 될 때까지 기다립니다"

#: ../../library/select.rst:127
msgid ""
"*xlist*: wait for an \"exceptional condition\" (see the manual page for "
"what your system considers such a condition)"
msgstr "*xlist*: \"예외 조건\"을 기다립니다 (시스템에서 어떤 것들을 이러한 조건으로 간주하는지는 매뉴얼 페이지를 참조하십시오)"

#: ../../library/select.rst:130
#, fuzzy
msgid ""
"Empty iterables are allowed, but acceptance of three empty iterables is "
"platform-dependent. (It is known to work on Unix but not on Windows.)  "
"The optional *timeout* argument specifies a time-out as a floating-point "
"number in seconds.  When the *timeout* argument is omitted the function "
"blocks until at least one file descriptor is ready.  A time-out value of "
"zero specifies a poll and never blocks."
msgstr ""
"빈 이터러블이 허용되지만, 세 개의 빈 이터러블을 받아들일지는 플랫폼에 따라 다릅니다. (유닉스에서는 작동하지만 윈도우에서는 "
"작동하지 않는 것으로 알려져 있습니다.) 선택적 *timeout* 인자는 시간제한을 초 단위의 부동 소수점 숫자로 지정합니다. "
"*timeout* 인자가 생략되면 최소한 하나의 파일 기술자가 준비될 때까지 함수가 블록 합니다. 시간제한 값이 0이면 폴링을 "
"지정하고 절대 블록 하지 않습니다."

#: ../../library/select.rst:137
msgid ""
"The return value is a triple of lists of objects that are ready: subsets "
"of the first three arguments.  When the time-out is reached without a "
"file descriptor becoming ready, three empty lists are returned."
msgstr ""
"반환 값은 준비된 객체의 리스트 3개입니다: 처음 세 인자의 부분 집합입니다. 파일 기술자가 준비되지 않고 시간제한에 도달하면, 세"
" 개의 빈 리스트가 반환됩니다."

#: ../../library/select.rst:145
msgid ""
"Among the acceptable object types in the iterables are Python :term:`file"
" objects <file object>` (e.g. ``sys.stdin``, or objects returned by "
":func:`open` or :func:`os.popen`), socket objects returned by "
":func:`socket.socket`.  You may also define a :dfn:`wrapper` class "
"yourself, as long as it has an appropriate :meth:`~io.IOBase.fileno` "
"method (that really returns a file descriptor, not just a random "
"integer)."
msgstr ""
"이터러블에서 허용되는 객체 형에는 파이썬 :term:`파일 객체 <file object>` (예를 들어 ``sys.stdin``, "
"또는 :func:`open`\\이나 :func:`os.popen`\\에서 반환된 객체), "
":func:`socket.socket`\\에서 반환된 소켓 객체가 있습니다. 적절한 (단지 임의의 정수가 아니라 실제 파일 기술자를"
" 반환하는) :meth:`~io.IOBase.fileno` 메서드가 있는 한, :dfn:`래퍼 (wrapper)` 클래스를 직접 "
"정의할 수도 있습니다."

#: ../../library/select.rst:156
#, fuzzy
msgid ""
"File objects on Windows are not acceptable, but sockets are.  On Windows,"
" the underlying :c:func:`!select` function is provided by the WinSock "
"library, and does not handle file descriptors that don't originate from "
"WinSock."
msgstr ""
"윈도우에서 파일 객체는 허용되지 않지만, 소켓은 허용됩니다. 윈도우에서, 하부 :c:func:`select` 함수는 WinSock "
"라이브러리에서 제공되며, WinSock에서 생성되지 않은 파일 기술자를 처리하지 않습니다."

#: ../../library/select.rst:161 ../../library/select.rst:267
#: ../../library/select.rst:367 ../../library/select.rst:455
#: ../../library/select.rst:496
msgid ""
"The function is now retried with a recomputed timeout when interrupted by"
" a signal, except if the signal handler raises an exception (see "
":pep:`475` for the rationale), instead of raising "
":exc:`InterruptedError`."
msgstr ""
"시그널 처리기가 :exc:`InterruptedError`\\를 발생시키는 대신 예외를 발생시키는 경우(이유는 "
":pep:`475`\\를 참조하십시오)를 제외하고, 시그널에 의해 인터럽트 될 때 다시 계산된 시간제한으로 함수가 다시 시도됩니다."

#: ../../library/select.rst:170
#, fuzzy
msgid ""
"The minimum number of bytes which can be written without blocking to a "
"pipe when the pipe has been reported as ready for writing by "
":func:`~select.select`, :func:`!poll` or another interface in this "
"module.  This doesn't apply to other kind of file-like objects such as "
"sockets."
msgstr ""
"파이프가 :func:`~select.select`, :func:`poll` 또는 이 모듈의 다른 인터페이스에서 쓰기 준비가 된 "
"것으로 보고될 때, 파이프를 블록 하지 않고 쓸 수 있는 최소 바이트 수. 소켓과 같은 다른 파일류 객체에는 적용되지 않습니다."

#: ../../library/select.rst:175
msgid "This value is guaranteed by POSIX to be at least 512."
msgstr "이 값은 POSIX에서 512 이상이 되도록 보장합니다."

#: ../../library/select.rst:185
msgid "``/dev/poll`` Polling Objects"
msgstr "``/dev/poll`` 폴링 객체"

#: ../../library/select.rst:187
#, fuzzy
msgid ""
"Solaris and derivatives have ``/dev/poll``. While :c:func:`!select` is "
"*O*\\ (*highest file descriptor*) and :c:func:`!poll` is *O*\\ (*number "
"of file descriptors*), ``/dev/poll`` is *O*\\ (*active file "
"descriptors*)."
msgstr ""
"Solaris와 파생 제품에는 ``/dev/poll``\\이 있습니다. :c:func:`select`\\는 O(가장 높은 파일 "
"기술자)이고 :c:func:`poll`\\은 O(파일 기술자 수)이지만 ``/dev/poll``\\은 O(활성 파일 기술자)입니다."

#: ../../library/select.rst:191
#, fuzzy
msgid ""
"``/dev/poll`` behaviour is very close to the standard :c:func:`!poll` "
"object."
msgstr "``/dev/poll`` 동작은 표준 :c:func:`poll` 객체에 매우 가깝습니다."

#: ../../library/select.rst:197
msgid "Close the file descriptor of the polling object."
msgstr "폴링 객체의 파일 기술자를 닫습니다."

#: ../../library/select.rst:204
msgid "``True`` if the polling object is closed."
msgstr "폴링 객체가 닫혔으면 ``True``."

#: ../../library/select.rst:211
msgid "Return the file descriptor number of the polling object."
msgstr "폴링 객체의 파일 기술자 번호를 반환합니다."

#: ../../library/select.rst:218 ../../library/select.rst:390
msgid ""
"Register a file descriptor with the polling object.  Future calls to the "
":meth:`poll` method will then check whether the file descriptor has any "
"pending I/O events.  *fd* can be either an integer, or an object with a "
":meth:`~io.IOBase.fileno` method that returns an integer.  File objects "
"implement :meth:`!fileno`, so they can also be used as the argument."
msgstr ""
"폴링 객체에 파일 기술자를 등록합니다. 이후 :meth:`poll` 메서드에 대한 호출은 파일 기술자에 계류 중인 I/O 이벤트가 "
"있는지 확인합니다. *fd*\\는 정수이거나, 정수를 반환하는 :meth:`~io.IOBase.fileno` 메서드가 있는 객체일 "
"수 있습니다. 파일 객체는 :meth:`!fileno`\\를 구현하므로, 인자로도 사용할 수 있습니다."

#: ../../library/select.rst:224
#, fuzzy
msgid ""
"*eventmask* is an optional bitmask describing the type of events you want"
" to check for. The constants are the same that with :c:func:`!poll` "
"object. The default value is a combination of the constants "
":const:`POLLIN`, :const:`POLLPRI`, and :const:`POLLOUT`."
msgstr ""
"*eventmask*\\는 확인할 이벤트 유형을 설명하는 선택적 비트 마스크입니다. 상수는 :c:func:`poll` 객체와 "
"같습니다. 기본값은 상수 :const:`POLLIN`, :const:`POLLPRI` 및 :const:`POLLOUT`\\의 "
"조합입니다."

#: ../../library/select.rst:231
#, fuzzy
msgid ""
"Registering a file descriptor that's already registered is not an error, "
"but the result is undefined. The appropriate action is to unregister or "
"modify it first. This is an important difference compared with "
":c:func:`!poll`."
msgstr ""
"이미 등록된 파일 기술자를 등록하는 것은 에러가 아니지만, 결과는 정의되지 않습니다. 적절한 액션은 먼저 unregister 하거나"
" modify 하는 것입니다. 이것은 :c:func:`poll`\\과 비교하여 중요한 차이점입니다."

#: ../../library/select.rst:239
msgid ""
"This method does an :meth:`unregister` followed by a :meth:`register`. It"
" is (a bit) more efficient that doing the same explicitly."
msgstr ""
"이 메서드는 :meth:`unregister` 다음에 :meth:`register`\\를 수행합니다. 명시적으로 같은 작업을 "
"수행하는 것보다 조금 더 효율적입니다."

#: ../../library/select.rst:246 ../../library/select.rst:434
msgid ""
"Remove a file descriptor being tracked by a polling object.  Just like "
"the :meth:`register` method, *fd* can be an integer or an object with a "
":meth:`~io.IOBase.fileno` method that returns an integer."
msgstr ""
"폴링 객체가 추적하는 파일 기술자를 제거합니다. :meth:`register` 메서드와 마찬가지로, *fd*\\는 정수이거나 정수를"
" 반환하는 :meth:`~io.IOBase.fileno` 메서드가 있는 객체일 수 있습니다."

#: ../../library/select.rst:250
msgid ""
"Attempting to remove a file descriptor that was never registered is "
"safely ignored."
msgstr "등록되지 않은 파일 기술자를 제거하려고 하면 안전하게 무시됩니다."

#: ../../library/select.rst:256
#, fuzzy
msgid ""
"Polls the set of registered file descriptors, and returns a possibly "
"empty list containing ``(fd, event)`` 2-tuples for the descriptors that "
"have events or errors to report. *fd* is the file descriptor, and *event*"
" is a bitmask with bits set for the reported events for that descriptor "
"--- :const:`POLLIN` for waiting input, :const:`POLLOUT` to indicate that "
"the descriptor can be written to, and so forth. An empty list indicates "
"that the call timed out and no file descriptors had any events to report."
" If *timeout* is given, it specifies the length of time in milliseconds "
"which the system will wait for events before returning. If *timeout* is "
"omitted, -1, or :const:`None`, the call will block until there is an "
"event for this poll object."
msgstr ""
"등록된 파일 기술자 집합을 폴링하고, 보고할 이벤트나 에러가 있는 기술자에 대한 ``(fd, event)`` 2-튜플이 포함된 "
"비어있을 수 있는 리스트를 반환합니다. *fd*\\는 파일 기술자이고, *event*\\는 해당 기술자에 대해 보고된 이벤트에 대해"
" 설정된 비트가 있는 비트 마스크입니다 --- 대기 중인 입력은 :const:`POLLIN`, 기술자에 쓸 수 있음을 나타내는 데는"
" :const:`POLLOUT`, 등등. 빈 리스트는 시간제한을 초과하였고 보고할 이벤트가 있는 파일 기술자가 없음을 나타냅니다. "
"*timeout*\\이 제공되면, 시스템이 반환하기 전에 이벤트를 기다리는 시간을 밀리초로 지정합니다. *timeout*\\을 "
"생략하거나 -1이거나 :const:`None`\\이면, 이 폴링 객체에 대한 이벤트가 있을 때까지 호출이 블록 됩니다."

#: ../../library/select.rst:277
msgid "Edge and Level Trigger Polling (epoll) Objects"
msgstr "에지와 레벨 트리거 폴링 (epoll) 객체"

#: ../../library/select.rst:279
msgid "https://linux.die.net/man/4/epoll"
msgstr "https://linux.die.net/man/4/epoll"

#: ../../library/select.rst:281
msgid "*eventmask*"
msgstr "*eventmask*"

#: ../../library/select.rst:284 ../../library/select.rst:402
#: ../../library/select.rst:522 ../../library/select.rst:551
#: ../../library/select.rst:582 ../../library/select.rst:590
#: ../../library/select.rst:610 ../../library/select.rst:633
msgid "Constant"
msgstr "상수"

#: ../../library/select.rst:284 ../../library/select.rst:402
#: ../../library/select.rst:522 ../../library/select.rst:551
#: ../../library/select.rst:582 ../../library/select.rst:590
#: ../../library/select.rst:610 ../../library/select.rst:633
msgid "Meaning"
msgstr "의미"

#: ../../library/select.rst:286
msgid ":const:`EPOLLIN`"
msgstr ":const:`EPOLLIN`"

#: ../../library/select.rst:286
msgid "Available for read"
msgstr "읽기 가능"

#: ../../library/select.rst:288
msgid ":const:`EPOLLOUT`"
msgstr ":const:`EPOLLOUT`"

#: ../../library/select.rst:288
msgid "Available for write"
msgstr "쓰기 가능"

#: ../../library/select.rst:290
msgid ":const:`EPOLLPRI`"
msgstr ":const:`EPOLLPRI`"

#: ../../library/select.rst:290
msgid "Urgent data for read"
msgstr "읽을 긴급 데이터"

#: ../../library/select.rst:292
msgid ":const:`EPOLLERR`"
msgstr ":const:`EPOLLERR`"

#: ../../library/select.rst:292
msgid "Error condition happened on the assoc. fd"
msgstr "연관된 fd에서 에러 조건이 발생했습니다"

#: ../../library/select.rst:294
msgid ":const:`EPOLLHUP`"
msgstr ":const:`EPOLLHUP`"

#: ../../library/select.rst:294
msgid "Hang up happened on the assoc. fd"
msgstr "연관된 fd에서 끊어짐(hang up)이 발생했습니다"

#: ../../library/select.rst:296
msgid ":const:`EPOLLET`"
msgstr ":const:`EPOLLET`"

#: ../../library/select.rst:296
msgid "Set Edge Trigger behavior, the default is Level Trigger behavior"
msgstr "에지 트리거 동작을 설정합니다, 기본값은 레벨 트리거 동작입니다"

#: ../../library/select.rst:299
msgid ":const:`EPOLLONESHOT`"
msgstr ":const:`EPOLLONESHOT`"

#: ../../library/select.rst:299
msgid ""
"Set one-shot behavior. After one event is pulled out, the fd is "
"internally disabled"
msgstr "원샷(one-shot) 동작을 설정합니다. 하나의 이벤트를 꺼낸 후에, fd는 내부적으로 비활성화됩니다."

#: ../../library/select.rst:302
msgid ":const:`EPOLLEXCLUSIVE`"
msgstr ":const:`EPOLLEXCLUSIVE`"

#: ../../library/select.rst:302
msgid ""
"Wake only one epoll object when the associated fd has an event. The "
"default (if this flag is not set) is to wake all epoll objects polling on"
" a fd."
msgstr ""
"연관된 fd에 이벤트가 있을 때 하나의 epoll 객체만 깨웁니다. 기본값(이 플래그가 설정되지 않으면)은 fd를 폴링하는 모든 "
"epoll 객체를 깨우는 것입니다."

#: ../../library/select.rst:307
msgid ":const:`EPOLLRDHUP`"
msgstr ":const:`EPOLLRDHUP`"

#: ../../library/select.rst:307
msgid ""
"Stream socket peer closed connection or shut down writing half of "
"connection."
msgstr "스트림 소켓 반대편이 연결을 닫았거나 연결의 쓰기 절반을 종료했습니다."

#: ../../library/select.rst:310
msgid ":const:`EPOLLRDNORM`"
msgstr ":const:`EPOLLRDNORM`"

#: ../../library/select.rst:310
msgid "Equivalent to :const:`EPOLLIN`"
msgstr ":const:`EPOLLIN`\\과 동등합니다"

#: ../../library/select.rst:312
msgid ":const:`EPOLLRDBAND`"
msgstr ":const:`EPOLLRDBAND`"

#: ../../library/select.rst:312
msgid "Priority data band can be read."
msgstr "우선순위가 높은 데이터 대역을 읽을 수 있습니다."

#: ../../library/select.rst:314
msgid ":const:`EPOLLWRNORM`"
msgstr ":const:`EPOLLWRNORM`"

#: ../../library/select.rst:314
msgid "Equivalent to :const:`EPOLLOUT`"
msgstr ":const:`EPOLLOUT`\\과 동등합니다"

#: ../../library/select.rst:316
msgid ":const:`EPOLLWRBAND`"
msgstr ":const:`EPOLLWRBAND`"

#: ../../library/select.rst:316
msgid "Priority data may be written."
msgstr "우선순위가 높은 데이터를 쓸 수 있습니다."

#: ../../library/select.rst:318
msgid ":const:`EPOLLMSG`"
msgstr ":const:`EPOLLMSG`"

#: ../../library/select.rst:318
msgid "Ignored."
msgstr "무시됩니다."

#: ../../library/select.rst:321
msgid ""
":const:`EPOLLEXCLUSIVE` was added.  It's only supported by Linux Kernel "
"4.5 or later."
msgstr ":const:`EPOLLEXCLUSIVE`\\가 추가되었습니다. 리눅스 커널 4.5 이상에서만 지원됩니다."

#: ../../library/select.rst:327
msgid "Close the control file descriptor of the epoll object."
msgstr "epoll 객체의 제어 파일 기술자를 닫습니다."

#: ../../library/select.rst:332
msgid "``True`` if the epoll object is closed."
msgstr "epoll 객체가 닫혔으면 ``True``."

#: ../../library/select.rst:337 ../../library/select.rst:479
msgid "Return the file descriptor number of the control fd."
msgstr "제어 fd의 파일 기술자 번호를 반환합니다."

#: ../../library/select.rst:342
msgid "Create an epoll object from a given file descriptor."
msgstr "주어진 파일 기술자에서 epoll 객체를 만듭니다."

#: ../../library/select.rst:347
msgid "Register a fd descriptor with the epoll object."
msgstr "epoll 객체에 fd 기술자를 등록합니다."

#: ../../library/select.rst:352
msgid "Modify a registered file descriptor."
msgstr "등록된 파일 기술자를 수정합니다."

#: ../../library/select.rst:357
msgid "Remove a registered file descriptor from the epoll object."
msgstr "epoll 객체에서 등록된 파일 기술자를 제거합니다."

#: ../../library/select.rst:359
msgid "The method no longer ignores the :data:`~errno.EBADF` error."
msgstr "이 메서드는 더는 :data:`~errno.EBADF` 에러를 무시하지 않습니다."

#: ../../library/select.rst:365
msgid "Wait for events. timeout in seconds (float)"
msgstr "이벤트를 기다립니다. 시간제한은 초 단위입니다 (float)"

#: ../../library/select.rst:377
msgid "Polling Objects"
msgstr "폴링 객체"

#: ../../library/select.rst:379
#, fuzzy
msgid ""
"The :c:func:`!poll` system call, supported on most Unix systems, provides"
" better scalability for network servers that service many, many clients "
"at the same time. :c:func:`!poll` scales better because the system call "
"only requires listing the file descriptors of interest, while "
":c:func:`!select` builds a bitmap, turns on bits for the fds of interest,"
" and then afterward the whole bitmap has to be linearly scanned again. "
":c:func:`!select` is *O*\\ (*highest file descriptor*), while "
":c:func:`!poll` is *O*\\ (*number of file descriptors*)."
msgstr ""
"대부분의 유닉스 시스템에서 지원되는 :c:func:`poll` 시스템 호출은 동시에 많은 클라이언트에게 서비스를 제공하는 네트워크 "
"서버에 더 나은 확장성을 제공합니다. :c:func:`select`\\는 비트맵을 빌드하고, 관심 있는 fd에 대한 비트를 켠 후,"
" 전체 비트 맵을 다시 선형으로 스캔해야 하지만, 이 시스템 호출은 관심 있는 파일 기술자만 나열하면 되기 때문에 "
":c:func:`poll`\\은 더 잘 확장됩니다. :c:func:`select`\\는 O(가장 높은 파일 기술자)이고 "
":c:func:`poll`\\은 O (파일 기술자 수)입니다."

#: ../../library/select.rst:396
msgid ""
"*eventmask* is an optional bitmask describing the type of events you want"
" to check for, and can be a combination of the constants :const:`POLLIN`,"
" :const:`POLLPRI`, and :const:`POLLOUT`, described in the table below.  "
"If not specified, the default value used will check for all 3 types of "
"events."
msgstr ""
"*eventmask*\\는 확인할 이벤트 유형을 설명하는 선택적 비트 마스크이고, 아래 표에 설명된 상수 "
":const:`POLLIN`, :const:`POLLPRI` 및 :const:`POLLOUT`\\의 조합일 수 있습니다. 지정하지 "
"않으면, 사용되는 기본값은 3가지 유형의 이벤트를 모두 확인합니다."

#: ../../library/select.rst:404
msgid ":const:`POLLIN`"
msgstr ":const:`POLLIN`"

#: ../../library/select.rst:404
msgid "There is data to read"
msgstr "읽을 데이터가 있습니다"

#: ../../library/select.rst:406
msgid ":const:`POLLPRI`"
msgstr ":const:`POLLPRI`"

#: ../../library/select.rst:406
msgid "There is urgent data to read"
msgstr "읽을 긴급한 데이터가 있습니다"

#: ../../library/select.rst:408
msgid ":const:`POLLOUT`"
msgstr ":const:`POLLOUT`"

#: ../../library/select.rst:408
msgid "Ready for output: writing will not block"
msgstr "출력 준비: 쓰기가 블록 되지 않을 것입니다"

#: ../../library/select.rst:410
msgid ":const:`POLLERR`"
msgstr ":const:`POLLERR`"

#: ../../library/select.rst:410
msgid "Error condition of some sort"
msgstr "어떤 종류의 에러 조건"

#: ../../library/select.rst:412
msgid ":const:`POLLHUP`"
msgstr ":const:`POLLHUP`"

#: ../../library/select.rst:412
msgid "Hung up"
msgstr "끊어졌습니다(Hung up)"

#: ../../library/select.rst:414
msgid ":const:`POLLRDHUP`"
msgstr ":const:`POLLRDHUP`"

#: ../../library/select.rst:414
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection"
msgstr "스트림 소켓 반대편이 연결을 닫았거나, 연결의 쓰기 절반을 종료했습니다"

#: ../../library/select.rst:417
msgid ":const:`POLLNVAL`"
msgstr ":const:`POLLNVAL`"

#: ../../library/select.rst:417
msgid "Invalid request: descriptor not open"
msgstr "잘못된 요청: 기술자가 열리지 않았습니다"

#: ../../library/select.rst:420
msgid ""
"Registering a file descriptor that's already registered is not an error, "
"and has the same effect as registering the descriptor exactly once."
msgstr "이미 등록된 파일 기술자를 등록하는 것은 에러가 아니며, 기술자를 정확히 한 번 등록하는 것과 같은 효과가 있습니다."

#: ../../library/select.rst:426
msgid ""
"Modifies an already registered fd. This has the same effect as "
"``register(fd, eventmask)``.  Attempting to modify a file descriptor that"
" was never registered causes an :exc:`OSError` exception with errno "
":const:`ENOENT` to be raised."
msgstr ""
"이미 등록된 fd를 수정합니다. 이것은 ``register(fd, eventmask)``\\와 같은 효과가 있습니다. 등록되지 않은"
" 파일 기술자를 수정하려고 하면 errno :const:`ENOENT`\\로 :exc:`OSError` 예외가 발생합니다."

#: ../../library/select.rst:438
msgid ""
"Attempting to remove a file descriptor that was never registered causes a"
" :exc:`KeyError` exception to be raised."
msgstr "등록되지 않은 파일 기술자를 제거하려고 하면 :exc:`KeyError` 예외가 발생합니다."

#: ../../library/select.rst:444
#, fuzzy
msgid ""
"Polls the set of registered file descriptors, and returns a possibly "
"empty list containing ``(fd, event)`` 2-tuples for the descriptors that "
"have events or errors to report. *fd* is the file descriptor, and *event*"
" is a bitmask with bits set for the reported events for that descriptor "
"--- :const:`POLLIN` for waiting input, :const:`POLLOUT` to indicate that "
"the descriptor can be written to, and so forth. An empty list indicates "
"that the call timed out and no file descriptors had any events to report."
" If *timeout* is given, it specifies the length of time in milliseconds "
"which the system will wait for events before returning. If *timeout* is "
"omitted, negative, or :const:`None`, the call will block until there is "
"an event for this poll object."
msgstr ""
"등록된 파일 기술자 집합을 폴링하고, 보고할 이벤트나 에러가 있는 기술자에 대한 ``(fd, event)`` 2-튜플이 포함된 "
"비어있을 수 있는 리스트를 반환합니다. *fd*\\는 파일 기술자이고, *event*\\는 해당 기술자에 대해 보고된 이벤트에 대해"
" 설정된 비트가 있는 비트 마스크입니다 --- 대기 중인 입력은 :const:`POLLIN`, 기술자에 쓸 수 있음을 나타내는 데는"
" :const:`POLLOUT`, 등등. 빈 리스트는 시간제한을 초과하였고 보고할 이벤트가 있는 파일 기술자가 없음을 나타냅니다. "
"*timeout*\\이 제공되면, 시스템이 반환하기 전에 이벤트를 기다리는 시간을 밀리초로 지정합니다. *timeout*\\을 "
"생략하거나 음수이거나 :const:`None`\\이면, 이 폴링 객체에 대한 이벤트가 있을 때까지 호출이 블록 됩니다."

#: ../../library/select.rst:465
msgid "Kqueue Objects"
msgstr "Kqueue 객체"

#: ../../library/select.rst:469
msgid "Close the control file descriptor of the kqueue object."
msgstr "kqueue 객체의 제어 파일 기술자를 닫습니다."

#: ../../library/select.rst:474
msgid "``True`` if the kqueue object is closed."
msgstr "kqueue 객체가 닫혔으면 ``True``."

#: ../../library/select.rst:484
msgid "Create a kqueue object from a given file descriptor."
msgstr "주어진 파일 기술자에서 kqueue 객체를 만듭니다."

#: ../../library/select.rst:489
msgid "Low level interface to kevent"
msgstr "kevent에 대한 저수준 인터페이스"

#: ../../library/select.rst:491
msgid "changelist must be an iterable of kevent objects or ``None``"
msgstr "changelist는 kevent 객체의 이터러블 이거나 ``None``\\이어야 합니다"

#: ../../library/select.rst:492
msgid "max_events must be 0 or a positive integer"
msgstr "max_events는 0이거나 양의 정수여야 합니다."

#: ../../library/select.rst:493
msgid ""
"timeout in seconds (floats possible); the default is ``None``, to wait "
"forever"
msgstr "timeout은 초 단위 (float 가능); 기본값은 ``None``\\이고 무한히 대기합니다"

#: ../../library/select.rst:506
msgid "Kevent Objects"
msgstr "Kevent 객체"

#: ../../library/select.rst:508
#, fuzzy
msgid "https://man.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2"
msgstr "https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2"

#: ../../library/select.rst:512
msgid ""
"Value used to identify the event. The interpretation depends on the "
"filter but it's usually the file descriptor. In the constructor ident can"
" either be an int or an object with a :meth:`~io.IOBase.fileno` method. "
"kevent stores the integer internally."
msgstr ""
"이벤트를 식별하는 데 사용되는 값. 해석은 필터에 따라 다르지만, 일반적으로 파일 기술자입니다. 생성자에서 ident 는 정수이거나"
" :meth:`~io.IOBase.fileno` 메서드가 있는 객체일 수 있습니다. kevent는 내부적으로 정수를 저장합니다."

#: ../../library/select.rst:519
msgid "Name of the kernel filter."
msgstr "커널 필터의 이름."

#: ../../library/select.rst:524
msgid ":const:`KQ_FILTER_READ`"
msgstr ":const:`KQ_FILTER_READ`"

#: ../../library/select.rst:524
msgid "Takes a descriptor and returns whenever there is data available to read"
msgstr "기술자를 취하고 읽을 수 있는 데이터가 있을 때마다 반환합니다"

#: ../../library/select.rst:527
msgid ":const:`KQ_FILTER_WRITE`"
msgstr ":const:`KQ_FILTER_WRITE`"

#: ../../library/select.rst:527
msgid "Takes a descriptor and returns whenever there is data available to write"
msgstr "기술자를 취하고 쓸 수 있는 데이터가 있을 때마다 반환합니다"

#: ../../library/select.rst:530
msgid ":const:`KQ_FILTER_AIO`"
msgstr ":const:`KQ_FILTER_AIO`"

#: ../../library/select.rst:530
msgid "AIO requests"
msgstr "AIO 요청"

#: ../../library/select.rst:532
msgid ":const:`KQ_FILTER_VNODE`"
msgstr ":const:`KQ_FILTER_VNODE`"

#: ../../library/select.rst:532
msgid "Returns when one or more of the requested events watched in *fflag* occurs"
msgstr "*fflag*\\에서 감시 중인 요청된 이벤트 중 하나 이상이 발생할 때 반환합니다"

#: ../../library/select.rst:535
msgid ":const:`KQ_FILTER_PROC`"
msgstr ":const:`KQ_FILTER_PROC`"

#: ../../library/select.rst:535
msgid "Watch for events on a process id"
msgstr "프로세스 id에서 이벤트를 감시합니다"

#: ../../library/select.rst:537
msgid ":const:`KQ_FILTER_NETDEV`"
msgstr ":const:`KQ_FILTER_NETDEV`"

#: ../../library/select.rst:537
#, fuzzy
msgid "Watch for events on a network device [not available on macOS]"
msgstr "네트워크 장치에서 이벤트를 감시합니다 [Mac OS X에서는 사용할 수 없습니다]"

#: ../../library/select.rst:540
msgid ":const:`KQ_FILTER_SIGNAL`"
msgstr ":const:`KQ_FILTER_SIGNAL`"

#: ../../library/select.rst:540
msgid "Returns whenever the watched signal is delivered to the process"
msgstr "감시하는 시그널이 프로세스에 전달될 때마다 반환합니다"

#: ../../library/select.rst:543
msgid ":const:`KQ_FILTER_TIMER`"
msgstr ":const:`KQ_FILTER_TIMER`"

#: ../../library/select.rst:543
msgid "Establishes an arbitrary timer"
msgstr "임의의 타이머를 설정합니다"

#: ../../library/select.rst:548
msgid "Filter action."
msgstr "필터 액션."

#: ../../library/select.rst:553
msgid ":const:`KQ_EV_ADD`"
msgstr ":const:`KQ_EV_ADD`"

#: ../../library/select.rst:553
msgid "Adds or modifies an event"
msgstr "이벤트를 추가하거나 수정합니다"

#: ../../library/select.rst:555
msgid ":const:`KQ_EV_DELETE`"
msgstr ":const:`KQ_EV_DELETE`"

#: ../../library/select.rst:555
msgid "Removes an event from the queue"
msgstr "큐에서 이벤트를 제거합니다"

#: ../../library/select.rst:557
msgid ":const:`KQ_EV_ENABLE`"
msgstr ":const:`KQ_EV_ENABLE`"

#: ../../library/select.rst:557
msgid "Permitscontrol() to returns the event"
msgstr "이벤트를 반환하도록 Permitscontrol() 합니다"

#: ../../library/select.rst:559
msgid ":const:`KQ_EV_DISABLE`"
msgstr ":const:`KQ_EV_DISABLE`"

#: ../../library/select.rst:559
msgid "Disablesevent"
msgstr "이벤트 비활성화"

#: ../../library/select.rst:561
msgid ":const:`KQ_EV_ONESHOT`"
msgstr ":const:`KQ_EV_ONESHOT`"

#: ../../library/select.rst:561
msgid "Removes event after first occurrence"
msgstr "처음 발생한 후 이벤트를 제거합니다"

#: ../../library/select.rst:563
msgid ":const:`KQ_EV_CLEAR`"
msgstr ":const:`KQ_EV_CLEAR`"

#: ../../library/select.rst:563
msgid "Reset the state after an event is retrieved"
msgstr "이벤트를 꺼낸 후 상태를 재설정합니다"

#: ../../library/select.rst:565
msgid ":const:`KQ_EV_SYSFLAGS`"
msgstr ":const:`KQ_EV_SYSFLAGS`"

#: ../../library/select.rst:565 ../../library/select.rst:567
msgid "internal event"
msgstr "내부 이벤트"

#: ../../library/select.rst:567
msgid ":const:`KQ_EV_FLAG1`"
msgstr ":const:`KQ_EV_FLAG1`"

#: ../../library/select.rst:569
msgid ":const:`KQ_EV_EOF`"
msgstr ":const:`KQ_EV_EOF`"

#: ../../library/select.rst:569
msgid "Filter specific EOF condition"
msgstr "필터 특정 EOF 조건"

#: ../../library/select.rst:571
msgid ":const:`KQ_EV_ERROR`"
msgstr ":const:`KQ_EV_ERROR`"

#: ../../library/select.rst:571
msgid "See return values"
msgstr "반환 값을 봅니다"

#: ../../library/select.rst:577
msgid "Filter specific flags."
msgstr "필터 특정 플래그."

#: ../../library/select.rst:579
msgid ":const:`KQ_FILTER_READ` and  :const:`KQ_FILTER_WRITE` filter flags:"
msgstr ":const:`KQ_FILTER_READ`\\와 :const:`KQ_FILTER_WRITE` 필터 플래그:"

#: ../../library/select.rst:584
msgid ":const:`KQ_NOTE_LOWAT`"
msgstr ":const:`KQ_NOTE_LOWAT`"

#: ../../library/select.rst:584
msgid "low water mark of a socket buffer"
msgstr "소켓 버퍼의 낮은 수위(low water mark)"

#: ../../library/select.rst:587
msgid ":const:`KQ_FILTER_VNODE` filter flags:"
msgstr ":const:`KQ_FILTER_VNODE` 필터 플래그:"

#: ../../library/select.rst:592
msgid ":const:`KQ_NOTE_DELETE`"
msgstr ":const:`KQ_NOTE_DELETE`"

#: ../../library/select.rst:592
msgid "*unlink()* was called"
msgstr "*unlink()*\\가 호출되었습니다"

#: ../../library/select.rst:594
msgid ":const:`KQ_NOTE_WRITE`"
msgstr ":const:`KQ_NOTE_WRITE`"

#: ../../library/select.rst:594
msgid "a write occurred"
msgstr "쓰기가 발생했습니다"

#: ../../library/select.rst:596
msgid ":const:`KQ_NOTE_EXTEND`"
msgstr ":const:`KQ_NOTE_EXTEND`"

#: ../../library/select.rst:596
msgid "the file was extended"
msgstr "파일이 확장되었습니다"

#: ../../library/select.rst:598
msgid ":const:`KQ_NOTE_ATTRIB`"
msgstr ":const:`KQ_NOTE_ATTRIB`"

#: ../../library/select.rst:598
msgid "an attribute was changed"
msgstr "속성이 변경되었습니다"

#: ../../library/select.rst:600
msgid ":const:`KQ_NOTE_LINK`"
msgstr ":const:`KQ_NOTE_LINK`"

#: ../../library/select.rst:600
msgid "the link count has changed"
msgstr "링크 수가 변경되었습니다"

#: ../../library/select.rst:602
msgid ":const:`KQ_NOTE_RENAME`"
msgstr ":const:`KQ_NOTE_RENAME`"

#: ../../library/select.rst:602
msgid "the file was renamed"
msgstr "파일 이름이 변경되었습니다"

#: ../../library/select.rst:604
msgid ":const:`KQ_NOTE_REVOKE`"
msgstr ":const:`KQ_NOTE_REVOKE`"

#: ../../library/select.rst:604
msgid "access to the file was revoked"
msgstr "파일에 대한 액세스가 취소되었습니다"

#: ../../library/select.rst:607
msgid ":const:`KQ_FILTER_PROC` filter flags:"
msgstr ":const:`KQ_FILTER_PROC` 필터 플래그:"

#: ../../library/select.rst:612
msgid ":const:`KQ_NOTE_EXIT`"
msgstr ":const:`KQ_NOTE_EXIT`"

#: ../../library/select.rst:612
msgid "the process has exited"
msgstr "프로세스가 종료되었습니다"

#: ../../library/select.rst:614
msgid ":const:`KQ_NOTE_FORK`"
msgstr ":const:`KQ_NOTE_FORK`"

#: ../../library/select.rst:614
msgid "the process has called *fork()*"
msgstr "프로세스가 *fork()*\\를 호출했습니다"

#: ../../library/select.rst:616
msgid ":const:`KQ_NOTE_EXEC`"
msgstr ":const:`KQ_NOTE_EXEC`"

#: ../../library/select.rst:616
msgid "the process has executed a new process"
msgstr "프로세스가 새로운 프로세스를 실행했습니다"

#: ../../library/select.rst:618
msgid ":const:`KQ_NOTE_PCTRLMASK`"
msgstr ":const:`KQ_NOTE_PCTRLMASK`"

#: ../../library/select.rst:618 ../../library/select.rst:620
msgid "internal filter flag"
msgstr "내부 필터 플래그"

#: ../../library/select.rst:620
msgid ":const:`KQ_NOTE_PDATAMASK`"
msgstr ":const:`KQ_NOTE_PDATAMASK`"

#: ../../library/select.rst:622
msgid ":const:`KQ_NOTE_TRACK`"
msgstr ":const:`KQ_NOTE_TRACK`"

#: ../../library/select.rst:622
msgid "follow a process across *fork()*"
msgstr "*fork()*\\를 가로질러 프로세스를 추적합니다"

#: ../../library/select.rst:624
msgid ":const:`KQ_NOTE_CHILD`"
msgstr ":const:`KQ_NOTE_CHILD`"

#: ../../library/select.rst:624
msgid "returned on the child process for *NOTE_TRACK*"
msgstr "*NOTE_TRACK*\\의 경우 자식 프로세스에서 반환됩니다"

#: ../../library/select.rst:627
msgid ":const:`KQ_NOTE_TRACKERR`"
msgstr ":const:`KQ_NOTE_TRACKERR`"

#: ../../library/select.rst:627
msgid "unable to attach to a child"
msgstr "자식에게 연결할 수 없습니다"

#: ../../library/select.rst:630
#, fuzzy
msgid ":const:`KQ_FILTER_NETDEV` filter flags (not available on macOS):"
msgstr ":const:`KQ_FILTER_NETDEV` 필터 플래그 (Mac OS X에서는 사용할 수 없습니다):"

#: ../../library/select.rst:635
msgid ":const:`KQ_NOTE_LINKUP`"
msgstr ":const:`KQ_NOTE_LINKUP`"

#: ../../library/select.rst:635
msgid "link is up"
msgstr "링크가 올라갔습니다"

#: ../../library/select.rst:637
msgid ":const:`KQ_NOTE_LINKDOWN`"
msgstr ":const:`KQ_NOTE_LINKDOWN`"

#: ../../library/select.rst:637
msgid "link is down"
msgstr "링크가 내려갔습니다"

#: ../../library/select.rst:639
msgid ":const:`KQ_NOTE_LINKINV`"
msgstr ":const:`KQ_NOTE_LINKINV`"

#: ../../library/select.rst:639
msgid "link state is invalid"
msgstr "링크 상태가 유효하지 않습니다"

#: ../../library/select.rst:645
msgid "Filter specific data."
msgstr "필터 특정 데이터."

#: ../../library/select.rst:650
msgid "User defined value."
msgstr "사용자 정의 값."

#: ../../library/select.rst:141
msgid "socket() (in module socket)"
msgstr ""

#: ../../library/select.rst:141
msgid "popen() (in module os)"
msgstr ""

#: ../../library/select.rst:154
msgid "WinSock"
msgstr ""

#~ msgid ":ref:`Availability <availability>`: Unix"
#~ msgstr ":ref:`가용성 <availability>`: 유닉스"

