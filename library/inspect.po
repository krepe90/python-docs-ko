# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/inspect.rst:2
#, fuzzy
msgid ":mod:`!inspect` --- Inspect live objects"
msgstr ":mod:`inspect` --- 라이브 객체 검사"

#: ../../library/inspect.rst:15
msgid "**Source code:** :source:`Lib/inspect.py`"
msgstr "**소스 코드:** :source:`Lib/inspect.py`"

#: ../../library/inspect.rst:19
msgid ""
"The :mod:`inspect` module provides several useful functions to help get "
"information about live objects such as modules, classes, methods, "
"functions, tracebacks, frame objects, and code objects.  For example, it "
"can help you examine the contents of a class, retrieve the source code of"
" a method, extract and format the argument list for a function, or get "
"all the information you need to display a detailed traceback."
msgstr ""
":mod:`inspect` 모듈은 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 객체 및 코드 객체와 같은 라이브 객체에 대한"
" 정보를 얻는 데 도움이 되는 몇 가지 유용한 함수를 제공합니다. 예를 들어, 클래스의 내용을 검사하거나, 메서드의 소스 코드를 "
"꺼내오거나, 함수의 인자 리스트를 추출하고 포맷하거나, 자세한 트레이스백을 표시하는 데 필요한 모든 정보를 얻는 데 도움이 될 수 "
"있습니다."

#: ../../library/inspect.rst:26
msgid ""
"There are four main kinds of services provided by this module: type "
"checking, getting source code, inspecting classes and functions, and "
"examining the interpreter stack."
msgstr "이 모듈은 4가지 종류의 주요 서비스를 제공합니다: 형 검사, 소스 코드 가져오기, 클래스와 함수 검사, 인터프리터 스택 검사."

#: ../../library/inspect.rst:34
msgid "Types and members"
msgstr "형과 멤버"

#: ../../library/inspect.rst:36
#, fuzzy
msgid ""
"The :func:`getmembers` function retrieves the members of an object such "
"as a class or module. The functions whose names begin with \"is\" are "
"mainly provided as convenient choices for the second argument to "
":func:`getmembers`. They also help you determine when you can expect to "
"find the following special attributes (see :ref:`import-mod-attrs` for "
"module attributes):"
msgstr ""
":func:`getmembers` 함수는 클래스나 모듈과 같은 객체의 멤버를 검색합니다. 이름이 \"is\"로 시작하는 함수는 주로"
" :func:`getmembers`\\의 두 번째 인자로 쓰기에 편리하도록 제공됩니다. 또한 다음과 같은 특수 어트리뷰트를 언제 "
"찾을 수 있는지 결정하는 데 도움이 됩니다:"

#: ../../library/inspect.rst:46
msgid "Type"
msgstr "형"

#: ../../library/inspect.rst:46
msgid "Attribute"
msgstr "어트리뷰트"

#: ../../library/inspect.rst:46
msgid "Description"
msgstr "설명"

#: ../../library/inspect.rst:48
msgid "class"
msgstr "클래스"

#: ../../library/inspect.rst:48 ../../library/inspect.rst:63
#: ../../library/inspect.rst:81 ../../library/inspect.rst:261
msgid "__doc__"
msgstr "__doc__"

#: ../../library/inspect.rst:48 ../../library/inspect.rst:63
#: ../../library/inspect.rst:81 ../../library/inspect.rst:261
msgid "documentation string"
msgstr "도큐멘테이션 문자열"

#: ../../library/inspect.rst:50 ../../library/inspect.rst:65
#: ../../library/inspect.rst:83 ../../library/inspect.rst:217
#: ../../library/inspect.rst:231 ../../library/inspect.rst:244
#: ../../library/inspect.rst:263
msgid "__name__"
msgstr "__name__"

#: ../../library/inspect.rst:50
msgid "name with which this class was defined"
msgstr "이 클래스가 정의된 이름"

#: ../../library/inspect.rst:53 ../../library/inspect.rst:68
#: ../../library/inspect.rst:86 ../../library/inspect.rst:219
#: ../../library/inspect.rst:233 ../../library/inspect.rst:246
#: ../../library/inspect.rst:266
msgid "__qualname__"
msgstr "__qualname__"

#: ../../library/inspect.rst:53 ../../library/inspect.rst:68
#: ../../library/inspect.rst:86 ../../library/inspect.rst:219
#: ../../library/inspect.rst:233 ../../library/inspect.rst:246
#: ../../library/inspect.rst:266
msgid "qualified name"
msgstr "정규화된 이름"

#: ../../library/inspect.rst:55 ../../library/inspect.rst:78
#: ../../library/inspect.rst:116
msgid "__module__"
msgstr "__module__"

#: ../../library/inspect.rst:55
msgid "name of module in which this class was defined"
msgstr "이 클래스가 정의된 모듈의 이름"

#: ../../library/inspect.rst:58 ../../library/inspect.rst:111
msgid "__type_params__"
msgstr ""

#: ../../library/inspect.rst:58
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a generic "
"class"
msgstr ""

#: ../../library/inspect.rst:63
msgid "method"
msgstr "메서드"

#: ../../library/inspect.rst:65
msgid "name with which this method was defined"
msgstr "이 메서드가 정의된 이름"

#: ../../library/inspect.rst:70
msgid "__func__"
msgstr "__func__"

#: ../../library/inspect.rst:70
msgid "function object containing implementation of method"
msgstr "메서드의 구현을 포함하는 함수 객체"

#: ../../library/inspect.rst:74 ../../library/inspect.rst:268
msgid "__self__"
msgstr "__self__"

#: ../../library/inspect.rst:74
msgid "instance to which this method is bound, or ``None``"
msgstr "이 메서드가 연결된 인스턴스, 또는 ``None``"

#: ../../library/inspect.rst:78
msgid "name of module in which this method was defined"
msgstr "이 메서드가 정의된 모듈의 이름"

#: ../../library/inspect.rst:81
msgid "function"
msgstr "함수"

#: ../../library/inspect.rst:83
msgid "name with which this function was defined"
msgstr "이 함수가 정의된 이름"

#: ../../library/inspect.rst:88
msgid "__code__"
msgstr "__code__"

#: ../../library/inspect.rst:88
msgid "code object containing compiled function :term:`bytecode`"
msgstr "컴파일된 함수 :term:`바이트 코드 <bytecode>`\\를 포함하는 코드 객체"

#: ../../library/inspect.rst:92
msgid "__defaults__"
msgstr "__defaults__"

#: ../../library/inspect.rst:92
msgid "tuple of any default values for positional or keyword parameters"
msgstr "위치나 키워드 매개 변수에 대한 기본값의 튜플"

#: ../../library/inspect.rst:96
msgid "__kwdefaults__"
msgstr "__kwdefaults__"

#: ../../library/inspect.rst:96
msgid "mapping of any default values for keyword-only parameters"
msgstr "키워드 전용 매개 변수의 기본값 매핑"

#: ../../library/inspect.rst:100
msgid "__globals__"
msgstr "__globals__"

#: ../../library/inspect.rst:100
msgid "global namespace in which this function was defined"
msgstr "이 함수가 정의된 전역 이름 공간"

#: ../../library/inspect.rst:103
#, fuzzy
msgid "__builtins__"
msgstr "f_builtins"

#: ../../library/inspect.rst:103
#, fuzzy
msgid "builtins namespace"
msgstr "이 프레임이 보는 내장 이름 공간"

#: ../../library/inspect.rst:105
msgid "__annotations__"
msgstr "__annotations__"

#: ../../library/inspect.rst:105
msgid ""
"mapping of parameters names to annotations; ``\"return\"`` key is "
"reserved for return annotations."
msgstr "매개 변수 이름에서 어노테이션으로의 매핑; ``\"return\"`` 키는 반환 값 어노테이션을 위해 예약되어 있습니다."

#: ../../library/inspect.rst:111
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a generic "
"function"
msgstr ""

#: ../../library/inspect.rst:116
msgid "name of module in which this function was defined"
msgstr "이 함수가 정의된 모듈의 이름"

#: ../../library/inspect.rst:119
msgid "traceback"
msgstr "트레이스백"

#: ../../library/inspect.rst:119
msgid "tb_frame"
msgstr "tb_frame"

#: ../../library/inspect.rst:119
msgid "frame object at this level"
msgstr "이 수준의 프레임 객체"

#: ../../library/inspect.rst:122
msgid "tb_lasti"
msgstr "tb_lasti"

#: ../../library/inspect.rst:122 ../../library/inspect.rst:144
msgid "index of last attempted instruction in bytecode"
msgstr "바이트 코드에서 마지막으로 시도한 명령의 인덱스"

#: ../../library/inspect.rst:125
msgid "tb_lineno"
msgstr "tb_lineno"

#: ../../library/inspect.rst:125 ../../library/inspect.rst:147
msgid "current line number in Python source code"
msgstr "파이썬 소스 코드의 현재 줄 번호"

#: ../../library/inspect.rst:128
msgid "tb_next"
msgstr "tb_next"

#: ../../library/inspect.rst:128
msgid "next inner traceback object (called by this level)"
msgstr "(이 수준에서 호출된) 다음 내부(inner) 트레이스백 객체"

#: ../../library/inspect.rst:132 ../../library/inspect.rst:221
#: ../../library/inspect.rst:238 ../../library/inspect.rst:251
msgid "frame"
msgstr "프레임"

#: ../../library/inspect.rst:132
msgid "f_back"
msgstr "f_back"

#: ../../library/inspect.rst:132
msgid "next outer frame object (this frame's caller)"
msgstr "다음 외부(outer) 프레임 객체 (이 프레임의 호출자)"

#: ../../library/inspect.rst:135
msgid "f_builtins"
msgstr "f_builtins"

#: ../../library/inspect.rst:135
msgid "builtins namespace seen by this frame"
msgstr "이 프레임이 보는 내장 이름 공간"

#: ../../library/inspect.rst:138
msgid "f_code"
msgstr "f_code"

#: ../../library/inspect.rst:138
msgid "code object being executed in this frame"
msgstr "이 프레임에서 실행되는 코드 객체"

#: ../../library/inspect.rst:141
msgid "f_globals"
msgstr "f_globals"

#: ../../library/inspect.rst:141
msgid "global namespace seen by this frame"
msgstr "이 프레임이 보는 전역 이름 공간"

#: ../../library/inspect.rst:144
msgid "f_lasti"
msgstr "f_lasti"

#: ../../library/inspect.rst:147
msgid "f_lineno"
msgstr "f_lineno"

#: ../../library/inspect.rst:150
msgid "f_locals"
msgstr "f_locals"

#: ../../library/inspect.rst:150
msgid "local namespace seen by this frame"
msgstr "이 프레임이 보는 지역 이름 공간"

#: ../../library/inspect.rst:153
msgid "f_trace"
msgstr "f_trace"

#: ../../library/inspect.rst:153
msgid "tracing function for this frame, or ``None``"
msgstr "이 프레임의 추적 함수(tracing function), 또는 ``None``"

#: ../../library/inspect.rst:156 ../../library/inspect.rst:225
#: ../../library/inspect.rst:242 ../../library/inspect.rst:255
msgid "code"
msgstr "코드"

#: ../../library/inspect.rst:156
msgid "co_argcount"
msgstr "co_argcount"

#: ../../library/inspect.rst:156
msgid ""
"number of arguments (not including keyword only arguments, \\* or \\*\\* "
"args)"
msgstr "인자 개수 (키워드 전용 인자, \\* 또는 \\*\\* 인자는 포함하지 않습니다)"

#: ../../library/inspect.rst:161
msgid "co_code"
msgstr "co_code"

#: ../../library/inspect.rst:161
msgid "string of raw compiled bytecode"
msgstr "컴파일된 날 바이트 코드의 문자열"

#: ../../library/inspect.rst:164
msgid "co_cellvars"
msgstr "co_cellvars"

#: ../../library/inspect.rst:164
msgid "tuple of names of cell variables (referenced by containing scopes)"
msgstr "(포함하는 스코프가 참조하는) 셀 변수 이름의 튜플"

#: ../../library/inspect.rst:168
msgid "co_consts"
msgstr "co_consts"

#: ../../library/inspect.rst:168
msgid "tuple of constants used in the bytecode"
msgstr "바이트 코드에서 사용되는 상수의 튜플"

#: ../../library/inspect.rst:171
msgid "co_filename"
msgstr "co_filename"

#: ../../library/inspect.rst:171
msgid "name of file in which this code object was created"
msgstr "이 코드 객체가 만들어진 파일의 이름"

#: ../../library/inspect.rst:175
msgid "co_firstlineno"
msgstr "co_firstlineno"

#: ../../library/inspect.rst:175
msgid "number of first line in Python source code"
msgstr "파이썬 소스 코드의 첫 줄 번호"

#: ../../library/inspect.rst:178
msgid "co_flags"
msgstr "co_flags"

#: ../../library/inspect.rst:178
msgid "bitmap of ``CO_*`` flags, read more :ref:`here <inspect-module-co-flags>`"
msgstr "``CO_*`` 플래그의 비트맵, :ref:`여기 <inspect-module-co-flags>`\\를 더 읽어보십시오"

#: ../../library/inspect.rst:182
msgid "co_lnotab"
msgstr "co_lnotab"

#: ../../library/inspect.rst:182
msgid "encoded mapping of line numbers to bytecode indices"
msgstr "줄 번호에서 바이트 코드 인덱스로의 인코딩된 매핑"

#: ../../library/inspect.rst:186
msgid "co_freevars"
msgstr "co_freevars"

#: ../../library/inspect.rst:186
msgid "tuple of names of free variables (referenced via a function's closure)"
msgstr "(함수의 클로저를 통해 참조되는) 자유 변수(free variables) 이름의 튜플"

#: ../../library/inspect.rst:190
msgid "co_posonlyargcount"
msgstr "co_posonlyargcount"

#: ../../library/inspect.rst:190
msgid "number of positional only arguments"
msgstr "위치 전용 인자의 개수"

#: ../../library/inspect.rst:193
msgid "co_kwonlyargcount"
msgstr "co_kwonlyargcount"

#: ../../library/inspect.rst:193
msgid "number of keyword only arguments (not including \\*\\* arg)"
msgstr "키워드 전용 인자의 개수 (\\*\\* 인자는 제외합니다)"

#: ../../library/inspect.rst:197
msgid "co_name"
msgstr "co_name"

#: ../../library/inspect.rst:197
msgid "name with which this code object was defined"
msgstr "이 코드 객체가 정의된 이름"

#: ../../library/inspect.rst:200
#, fuzzy
msgid "co_qualname"
msgstr "__qualname__"

#: ../../library/inspect.rst:200
#, fuzzy
msgid "fully qualified name with which this code object was defined"
msgstr "이 코드 객체가 정의된 이름"

#: ../../library/inspect.rst:204
msgid "co_names"
msgstr "co_names"

#: ../../library/inspect.rst:204
#, fuzzy
msgid "tuple of names other than arguments and function locals"
msgstr "인자와 지역 변수  이름의 튜플"

#: ../../library/inspect.rst:208
msgid "co_nlocals"
msgstr "co_nlocals"

#: ../../library/inspect.rst:208
msgid "number of local variables"
msgstr "지역 변수의 개수"

#: ../../library/inspect.rst:210
msgid "co_stacksize"
msgstr "co_stacksize"

#: ../../library/inspect.rst:210
msgid "virtual machine stack space required"
msgstr "필요한 가상 기계 스택 공간"

#: ../../library/inspect.rst:213
msgid "co_varnames"
msgstr "co_varnames"

#: ../../library/inspect.rst:213
msgid "tuple of names of arguments and local variables"
msgstr "인자와 지역 변수  이름의 튜플"

#: ../../library/inspect.rst:217
msgid "generator"
msgstr "제너레이터"

#: ../../library/inspect.rst:217 ../../library/inspect.rst:231
#: ../../library/inspect.rst:244
msgid "name"
msgstr "이름"

#: ../../library/inspect.rst:221
msgid "gi_frame"
msgstr "gi_frame"

#: ../../library/inspect.rst:223
msgid "gi_running"
msgstr "gi_running"

#: ../../library/inspect.rst:223 ../../library/inspect.rst:240
msgid "is the generator running?"
msgstr "제너레이터가 실행 중입니까?"

#: ../../library/inspect.rst:225
msgid "gi_code"
msgstr "gi_code"

#: ../../library/inspect.rst:227
msgid "gi_yieldfrom"
msgstr "gi_yieldfrom"

#: ../../library/inspect.rst:227
msgid "object being iterated by ``yield from``, or ``None``"
msgstr "``yield from``\\에 의해 이터레이트 중인 객체, 또는 ``None``"

#: ../../library/inspect.rst:231
#, fuzzy
msgid "async generator"
msgstr "제너레이터"

#: ../../library/inspect.rst:235
#, fuzzy
msgid "ag_await"
msgstr "cr_await"

#: ../../library/inspect.rst:235 ../../library/inspect.rst:248
msgid "object being awaited on, or ``None``"
msgstr "어웨이트 중인 객체, 또는 ``None``"

#: ../../library/inspect.rst:238
#, fuzzy
msgid "ag_frame"
msgstr "gi_frame"

#: ../../library/inspect.rst:240
#, fuzzy
msgid "ag_running"
msgstr "gi_running"

#: ../../library/inspect.rst:242
#, fuzzy
msgid "ag_code"
msgstr "gi_code"

#: ../../library/inspect.rst:244
msgid "coroutine"
msgstr "코루틴"

#: ../../library/inspect.rst:248
msgid "cr_await"
msgstr "cr_await"

#: ../../library/inspect.rst:251
msgid "cr_frame"
msgstr "cr_frame"

#: ../../library/inspect.rst:253
msgid "cr_running"
msgstr "cr_running"

#: ../../library/inspect.rst:253
msgid "is the coroutine running?"
msgstr "코루틴이 실행 중입니까?"

#: ../../library/inspect.rst:255
msgid "cr_code"
msgstr "cr_code"

#: ../../library/inspect.rst:257
msgid "cr_origin"
msgstr "cr_origin"

#: ../../library/inspect.rst:257
msgid "where coroutine was created, or ``None``. See |coroutine-origin-link|"
msgstr "코루틴이 생성된 곳, 또는 ``None``. |coroutine-origin-link|\\를 참조하세요"

#: ../../library/inspect.rst:261
msgid "builtin"
msgstr "내장"

#: ../../library/inspect.rst:263
msgid "original name of this function or method"
msgstr "이 함수나 메서드의 원래 이름"

#: ../../library/inspect.rst:268
msgid "instance to which a method is bound, or ``None``"
msgstr "메서드가 연결된 인스턴스, 또는 ``None``"

#: ../../library/inspect.rst:275
msgid "Add ``__qualname__`` and ``gi_yieldfrom`` attributes to generators."
msgstr "``__qualname__``\\과 ``gi_yieldfrom`` 어트리뷰트를 제너레이터에 추가합니다."

#: ../../library/inspect.rst:277
msgid ""
"The ``__name__`` attribute of generators is now set from the function "
"name, instead of the code name, and it can now be modified."
msgstr "제너레이터의 ``__name__`` 어트리뷰트는 이제 코드 이름 대신 함수 이름에서 설정되며, 이제 수정할 수 있습니다."

#: ../../library/inspect.rst:282
msgid "Add ``cr_origin`` attribute to coroutines."
msgstr "코루틴에 ``cr_origin`` 어트리뷰트를 추가합니다."

#: ../../library/inspect.rst:286
#, fuzzy
msgid "Add ``__builtins__`` attribute to functions."
msgstr "코루틴에 ``cr_origin`` 어트리뷰트를 추가합니다."

#: ../../library/inspect.rst:290
msgid ""
"Return all the members of an object in a list of ``(name, value)`` pairs "
"sorted by name. If the optional *predicate* argument—which will be called"
" with the ``value`` object of each member—is supplied, only members for "
"which the predicate returns a true value are included."
msgstr ""
"이름으로 정렬된 ``(name, value)`` 쌍의 리스트로 객체(object)의 모든 멤버를 반환합니다. 각 멤버의 "
"``value`` 객체로 호출될 선택적 *predicate* 인자가 제공되면, predicate가 참값을 반환하는 멤버만 "
"포함됩니다."

#: ../../library/inspect.rst:297
#, fuzzy
msgid ""
":func:`getmembers` will only return class attributes defined in the "
"metaclass when the argument is a class and those attributes have been "
"listed in the metaclass' custom :meth:`~object.__dir__`."
msgstr ""
":func:`getmembers`\\는 인자가 클래스이고 해당 클래스 어트리뷰트가 메타 클래스의 사용자 정의 "
":meth:`__dir__`\\에서 나열될 때만 메타 클래스에 정의된 클래스 어트리뷰트를 반환합니다."

#: ../../library/inspect.rst:304
msgid ""
"Return all the members of an object in a list of ``(name, value)`` pairs "
"sorted by name without triggering dynamic lookup via the descriptor "
"protocol, __getattr__ or __getattribute__. Optionally, only return "
"members that satisfy a given predicate."
msgstr ""

#: ../../library/inspect.rst:311
#, fuzzy
msgid ""
":func:`getmembers_static` may not be able to retrieve all members that "
"getmembers can fetch (like dynamically created attributes) and may find "
"members that getmembers can't (like descriptors that raise "
"AttributeError). It can also return descriptor objects instead of "
"instance members in some cases."
msgstr ""
"참고: 이 함수는 getattr이 가져올 수 있는 모든 어트리뷰트를 조회하지 못할 수 있으며 (가령 동적으로 만들어진 어트리뷰트),"
" getattr이 가져올 수 없는 어트리뷰트를 찾을 수 있습니다 (가령 AttributeError를 발생시키는 디스크립터). 또한 "
"인스턴스 멤버 대신 디스크립터 객체를 반환할 수도 있습니다."

#: ../../library/inspect.rst:322
msgid ""
"Return the name of the module named by the file *path*, without including"
" the names of enclosing packages. The file extension is checked against "
"all of the entries in :func:`importlib.machinery.all_suffixes`. If it "
"matches, the final path component is returned with the extension removed."
" Otherwise, ``None`` is returned."
msgstr ""
"감싸고 있는 패키지 이름 없이, 파일 경로(*path*)\\가 가리키는 모듈의 이름을 반환합니다. 파일 확장자는 "
":func:`importlib.machinery.all_suffixes`\\의 모든 항목에 대해 점검됩니다. 일치하면, 확장명이 "
"제거된 최종 경로 구성 요소가 반환됩니다. 그렇지 않으면, ``None``\\이 반환됩니다."

#: ../../library/inspect.rst:328
msgid ""
"Note that this function *only* returns a meaningful name for actual "
"Python modules - paths that potentially refer to Python packages will "
"still return ``None``."
msgstr ""
"이 함수는 *오직* 실제 파이썬 모듈로 의미 있는 이름만 반환합니다. 잠재적으로 파이썬 패키지를 가리키는 경로는 여전히 "
"``None``\\을 반환합니다."

#: ../../library/inspect.rst:332
msgid "The function is based directly on :mod:`importlib`."
msgstr "이 함수는 :mod:`importlib`\\에 직접 기반합니다."

#: ../../library/inspect.rst:338
msgid "Return ``True`` if the object is a module."
msgstr "객체가 모듈이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:343
msgid ""
"Return ``True`` if the object is a class, whether built-in or created in "
"Python code."
msgstr "객체가 (내장이거나 파이썬 코드로 만든) 클래스이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:349
msgid "Return ``True`` if the object is a bound method written in Python."
msgstr "객체가 파이썬으로 작성된 연결된(bound) 메서드면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:354
msgid ""
"Return ``True`` if the object is a Python function, which includes "
"functions created by a :term:`lambda` expression."
msgstr "객체가 파이썬 함수이면 ``True``\\를 반환합니다. :term:`람다 <lambda>` 표현식으로 만든 함수를 포함합니다."

#: ../../library/inspect.rst:360
msgid "Return ``True`` if the object is a Python generator function."
msgstr "객체가 파이썬 제너레이터 함수이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:362
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the"
" wrapped function is a Python generator function."
msgstr ""
"래핑 된 함수가 파이썬 제너레이터 함수일 때 :func:`functools.partial`\\로 래핑 된 함수는 이제 "
"``True``\\를 반환합니다."

#: ../../library/inspect.rst:366
#, fuzzy
msgid ""
"Functions wrapped in :func:`functools.partialmethod` now return ``True`` "
"if the wrapped function is a Python generator function."
msgstr ""
"래핑 된 함수가 파이썬 제너레이터 함수일 때 :func:`functools.partial`\\로 래핑 된 함수는 이제 "
"``True``\\를 반환합니다."

#: ../../library/inspect.rst:372
msgid "Return ``True`` if the object is a generator."
msgstr "객체가 제너레이터이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:377
#, fuzzy
msgid ""
"Return ``True`` if the object is a :term:`coroutine function` (a function"
" defined with an :keyword:`async def` syntax), a "
":func:`functools.partial` wrapping a :term:`coroutine function`, or a "
"sync function marked with :func:`markcoroutinefunction`."
msgstr ""
"객체가 :term:`코루틴 함수 <coroutine function>`\\(:keyword:`async def` 문법으로 정의된 "
"함수)이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:384
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the"
" wrapped function is a :term:`coroutine function`."
msgstr ""
"래핑 된 함수가 :term:`코루틴 함수 <coroutine function>`\\일 때 "
":func:`functools.partial`\\로 래핑 된 함수는 이제 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:388
msgid ""
"Sync functions marked with :func:`markcoroutinefunction` now return "
"``True``."
msgstr ""

#: ../../library/inspect.rst:392 ../../library/inspect.rst:462
#, fuzzy
msgid ""
"Functions wrapped in :func:`functools.partialmethod` now return ``True`` "
"if the wrapped function is a :term:`coroutine function`."
msgstr ""
"래핑 된 함수가 :term:`코루틴 함수 <coroutine function>`\\일 때 "
":func:`functools.partial`\\로 래핑 된 함수는 이제 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:399
msgid ""
"Decorator to mark a callable as a :term:`coroutine function` if it would "
"not otherwise be detected by :func:`iscoroutinefunction`."
msgstr ""

#: ../../library/inspect.rst:402
msgid ""
"This may be of use for sync functions that return a :term:`coroutine`, if"
" the function is passed to an API that requires "
":func:`iscoroutinefunction`."
msgstr ""

#: ../../library/inspect.rst:405
msgid ""
"When possible, using an :keyword:`async def` function is preferred. Also "
"acceptable is calling the function and testing the return with "
":func:`iscoroutine`."
msgstr ""

#: ../../library/inspect.rst:414
msgid ""
"Return ``True`` if the object is a :term:`coroutine` created by an "
":keyword:`async def` function."
msgstr ""
"객체가 :keyword:`async def` 함수가 만든 :term:`코루틴 <coroutine>`\\이면 ``True``\\를 "
"반환합니다."

#: ../../library/inspect.rst:422
msgid "Return ``True`` if the object can be used in :keyword:`await` expression."
msgstr ":keyword:`await` 표현식에서 객체를 사용할 수 있으면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:424
#, fuzzy
msgid ""
"Can also be used to distinguish generator-based coroutines from regular "
"generators:"
msgstr "제너레이터 기반 코루틴을 일반 제너레이터와 구별하는 데 사용할 수도 있습니다::"

#: ../../library/inspect.rst:427
msgid ""
"import types\n"
"\n"
"def gen():\n"
"    yield\n"
"@types.coroutine\n"
"def gen_coro():\n"
"    yield\n"
"\n"
"assert not isawaitable(gen())\n"
"assert isawaitable(gen_coro())"
msgstr ""

#: ../../library/inspect.rst:445
#, fuzzy
msgid ""
"Return ``True`` if the object is an :term:`asynchronous generator` "
"function, for example:"
msgstr ""
"객체가 :term:`비동기 제너레이터 <asynchronous generator>` 함수이면 ``True``\\를 반환합니다, 예를"
" 들면::"

#: ../../library/inspect.rst:448
msgid ""
">>> async def agen():\n"
"...     yield 1\n"
"...\n"
">>> inspect.isasyncgenfunction(agen)\n"
"True"
msgstr ""

#: ../../library/inspect.rst:458
#, fuzzy
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the"
" wrapped function is an :term:`asynchronous generator` function."
msgstr ""
"래핑 된 함수가 :term:`비동기 제너레이터 <asynchronous generator>` 함수일 때 "
":func:`functools.partial`\\로 래핑 된 함수는 이제 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:468
msgid ""
"Return ``True`` if the object is an :term:`asynchronous generator "
"iterator` created by an :term:`asynchronous generator` function."
msgstr ""
"객체가 :term:`asynchronous generator` 함수가 만든 :term:`비동기 제너레이터 이터레이터 "
"<asynchronous generator iterator>`\\이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:475
msgid "Return ``True`` if the object is a traceback."
msgstr "객체가 트레이스백이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:480
msgid "Return ``True`` if the object is a frame."
msgstr "객체가 프레임이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:485
msgid "Return ``True`` if the object is a code."
msgstr "객체가 코드이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:490
msgid ""
"Return ``True`` if the object is a built-in function or a bound built-in "
"method."
msgstr "객체가 내장 함수나 연결된(bound) 내장 메서드이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:495
#, fuzzy
msgid ""
"Return ``True`` if the type of object is a "
":class:`~types.MethodWrapperType`."
msgstr "객체가 코드이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:497
msgid ""
"These are instances of :class:`~types.MethodWrapperType`, such as "
":meth:`~object.__str__`, :meth:`~object.__eq__` and "
":meth:`~object.__repr__`."
msgstr ""

#: ../../library/inspect.rst:505
msgid ""
"Return ``True`` if the object is a user-defined or built-in function or "
"method."
msgstr "객체가 사용자 정의이거나 내장 함수나 메서드이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:510
msgid "Return ``True`` if the object is an abstract base class."
msgstr "객체가 추상 베이스 클래스이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:515
msgid ""
"Return ``True`` if the object is a method descriptor, but not if "
":func:`ismethod`, :func:`isclass`, :func:`isfunction` or "
":func:`isbuiltin` are true."
msgstr ""
"객체가 메서드 디스크립터이면 ``True``\\를 반환하지만, :func:`ismethod`, :func:`isclass`, "
":func:`isfunction` 또는 :func:`isbuiltin`\\이 참일 때는 그렇지 않습니다."

#: ../../library/inspect.rst:519
#, fuzzy
msgid ""
"This, for example, is true of ``int.__add__``.  An object passing this "
"test has a :meth:`~object.__get__` method, but not a "
":meth:`~object.__set__` method or a :meth:`~object.__delete__` method.  "
"Beyond that, the set of attributes varies.  A "
":attr:`~definition.__name__` attribute is usually sensible, and "
":attr:`~definition.__doc__` often is."
msgstr ""
"예를 들어, 이것은 ``int.__add__``\\에 대해서 참입니다. 이 테스트를 통과한 객체에는 "
":meth:`~object.__get__` 메서드가 있지만 :meth:`~object.__set__` 메서드는 없습니다. 하지만 그"
" 외의 어트리뷰트 집합은 달라집니다. :attr:`~definition.__name__` 어트리뷰트는 보통 존재하고, "
":attr:`__doc__`\\도 종종 그렇습니다."

#: ../../library/inspect.rst:525
#, fuzzy
msgid ""
"Methods implemented via descriptors that also pass one of the other tests"
" return ``False`` from the :func:`ismethoddescriptor` test, simply "
"because the other tests promise more -- you can, e.g., count on having "
"the :attr:`~method.__func__` attribute (etc) when an object passes "
":func:`ismethod`."
msgstr ""
"다른 테스트 중 하나를 통과하는 디스크립터로 구현된 메서드는 :func:`ismethoddescriptor` 테스트에서 "
"``False``\\를 반환합니다. 단순히 다른 테스트가 더 많은 것을 약속하기 때문입니다 -- 예를 들어, 객체가 "
":func:`ismethod`\\를 통과할 때 :attr:`__func__` 어트리뷰트(등)가 있다고 기대할 수 있습니다."

#: ../../library/inspect.rst:531
msgid ""
"This function no longer incorrectly reports objects with "
":meth:`~object.__get__` and :meth:`~object.__delete__`, but not "
":meth:`~object.__set__`, as being method descriptors (such objects are "
"data descriptors, not method descriptors)."
msgstr ""

#: ../../library/inspect.rst:539
msgid "Return ``True`` if the object is a data descriptor."
msgstr "객체가 데이터 디스크립터이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:541
#, fuzzy
msgid ""
"Data descriptors have a :attr:`~object.__set__` or a "
":attr:`~object.__delete__` method. Examples are properties (defined in "
"Python), getsets, and members.  The latter two are defined in C and there"
" are more specific tests available for those types, which is robust "
"across Python implementations.  Typically, data descriptors will also "
"have :attr:`~definition.__name__` and :attr:`!__doc__` attributes "
"(properties, getsets, and members have both of these attributes), but "
"this is not guaranteed."
msgstr ""
"데이터 디스크립터에는 :attr:`~object.__set__`\\이나 :attr:`~object.__delete__` 메서드가 "
"있습니다. 예는 (파이썬으로 정의한) 프로퍼티, getset 및 멤버입니다. 뒤의 두 가지는 C로 정의되며 해당 형에 대해 더 "
"구체적인 테스트가 있으며, 이는 다른 파이썬 구현에서도 지원됩니다. 일반적으로 데이터 디스크립터는 "
":attr:`~definition.__name__`\\과 :attr:`__doc__` 어트리뷰트를 갖지만 (프로퍼티, getet 및"
" 멤버는 이 두 어트리뷰트를 모두 갖습니다), 이것이 보장되지는 않습니다."

#: ../../library/inspect.rst:552
msgid "Return ``True`` if the object is a getset descriptor."
msgstr "객체가 getset 디스크립터이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:556
msgid ""
"getsets are attributes defined in extension modules via "
":c:type:`PyGetSetDef` structures.  For Python implementations without "
"such types, this method will always return ``False``."
msgstr ""
"getset은 :c:type:`PyGetSetDef` 구조체를 통해 확장 모듈에서 정의된 어트리뷰트입니다. 이러한 형이 없는 파이썬"
" 구현에서, 이 메서드는 항상 ``False``\\를 반환합니다."

#: ../../library/inspect.rst:563
msgid "Return ``True`` if the object is a member descriptor."
msgstr "객체가 멤버 디스크립터이면 ``True``\\를 반환합니다."

#: ../../library/inspect.rst:567
msgid ""
"Member descriptors are attributes defined in extension modules via "
":c:type:`PyMemberDef` structures.  For Python implementations without "
"such types, this method will always return ``False``."
msgstr ""
"멤버 디스크립터는 :c:type:`PyMemberDef` 구조체를 통해 확장 모듈에서 정의된 어트리뷰트입니다. 이러한 형이 없는 "
"파이썬 구현에서, 이 메서드는 항상 ``False``\\를 반환합니다."

#: ../../library/inspect.rst:575
msgid "Retrieving source code"
msgstr "소스 코드 가져오기"

#: ../../library/inspect.rst:579
#, fuzzy
msgid ""
"Get the documentation string for an object, cleaned up with "
":func:`cleandoc`. If the documentation string for an object is not "
"provided and the object is a class, a method, a property or a descriptor,"
" retrieve the documentation string from the inheritance hierarchy. Return"
" ``None`` if the documentation string is invalid or missing."
msgstr ""
":func:`cleandoc`\\으로 정리된 객체의 독스트링을 가져옵니다. 객체가 독스트링을 제공하지 않고 객체가 클래스, 메서드,"
" 프로퍼티 또는 디스크립터이면, 상속 계층 구조에서 독스트링을 가져옵니다."

#: ../../library/inspect.rst:585
msgid "Documentation strings are now inherited if not overridden."
msgstr "이제 재정의되지 않으면 독스트링이 상속됩니다."

#: ../../library/inspect.rst:591
msgid ""
"Return in a single string any lines of comments immediately preceding the"
" object's source code (for a class, function, or method), or at the top "
"of the Python source file (if the object is a module).  If the object's "
"source code is unavailable, return ``None``.  This could happen if the "
"object has been defined in C or the interactive shell."
msgstr ""
"객체의 소스 코드 바로 앞(클래스, 함수 또는 메서드일 때)이나 파이썬 소스 파일의 최상단 (객체가 모듈일 때) 주석 줄들을 단일 "
"문자열로 반환합니다. 객체의 소스 코드를 사용할 수 없으면, ``None``\\을 반환합니다. 객체가 C나 대화식 셸에서 정의될 때"
" 이런 일이 일어날 수 있습니다."

#: ../../library/inspect.rst:600
msgid ""
"Return the name of the (text or binary) file in which an object was "
"defined. This will fail with a :exc:`TypeError` if the object is a built-"
"in module, class, or function."
msgstr ""
"객체가 정의된 (텍스트나 바이너리) 파일의 이름을 반환합니다. 객체가 내장 모듈, 클래스 또는 함수이면 "
":exc:`TypeError`\\로 실패합니다."

#: ../../library/inspect.rst:607
#, fuzzy
msgid ""
"Try to guess which module an object was defined in. Return ``None`` if "
"the module cannot be determined."
msgstr "객체가 정의된 모듈을 추측합니다."

#: ../../library/inspect.rst:613
#, fuzzy
msgid ""
"Return the name of the Python source file in which an object was defined "
"or ``None`` if no way can be identified to get the source.  This will "
"fail with a :exc:`TypeError` if the object is a built-in module, class, "
"or function."
msgstr ""
"객체가 정의된 파이썬 소스 파일의 이름을 반환합니다. 객체가 내장 모듈, 클래스 또는 함수이면 :exc:`TypeError`\\로 "
"실패합니다."

#: ../../library/inspect.rst:621
#, fuzzy
msgid ""
"Return a list of source lines and starting line number for an object. The"
" argument may be a module, class, method, function, traceback, frame, or "
"code object.  The source code is returned as a list of the lines "
"corresponding to the object and the line number indicates where in the "
"original source file the first line of code was found.  An :exc:`OSError`"
" is raised if the source code cannot be retrieved. A :exc:`TypeError` is "
"raised if the object is a built-in module, class, or function."
msgstr ""
"객체의 소스 줄의 리스트와 시작 줄 번호를 반환합니다. 인자는 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 또는 코드 객체일"
" 수 있습니다. 소스 코드는 객체에 해당하는 줄 리스트로 반환되며 줄 번호는 원본 소스 파일에서 첫 번째 코드 줄이 발견되는 위치를"
" 나타냅니다. 소스 코드를 가져올 수 없으면 :exc:`OSError`\\가 발생합니다."

#: ../../library/inspect.rst:630 ../../library/inspect.rst:644
msgid ""
":exc:`OSError` is raised instead of :exc:`IOError`, now an alias of the "
"former."
msgstr ":exc:`IOError` 대신 :exc:`OSError`\\가 발생합니다. 이제 IOError는 OSError의 별칭입니다."

#: ../../library/inspect.rst:637
#, fuzzy
msgid ""
"Return the text of the source code for an object. The argument may be a "
"module, class, method, function, traceback, frame, or code object.  The "
"source code is returned as a single string.  An :exc:`OSError` is raised "
"if the source code cannot be retrieved. A :exc:`TypeError` is raised if "
"the object is a built-in module, class, or function."
msgstr ""
"객체의 소스 코드 텍스트를 반환합니다. 인자는 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 또는 코드 객체일 수 있습니다. "
"소스 코드는 단일 문자열로 반환됩니다. 소스 코드를 가져올 수 없으면 :exc:`OSError`\\가 발생합니다."

#: ../../library/inspect.rst:651
msgid ""
"Clean up indentation from docstrings that are indented to line up with "
"blocks of code."
msgstr "코드 블록과 일치하도록 들여쓰기 된 독스트링에서 들여쓰기를 정리합니다."

#: ../../library/inspect.rst:654
msgid ""
"All leading whitespace is removed from the first line.  Any leading "
"whitespace that can be uniformly removed from the second line onwards is "
"removed.  Empty lines at the beginning and end are subsequently removed."
"  Also, all tabs are expanded to spaces."
msgstr ""
"모든 선행 공백이 첫 번째 줄에서 제거됩니다. 두 번째 줄부터 균일하게 제거할 수 있는 선행 공백이 제거됩니다. 시작과 끝의 빈 "
"줄은 그다음에 제거됩니다. 또한, 모든 탭이 스페이스로 확장됩니다."

#: ../../library/inspect.rst:663
msgid "Introspecting callables with the Signature object"
msgstr "Signature 객체로 콜러블 검사하기"

#: ../../library/inspect.rst:667
#, fuzzy
msgid ""
"The :class:`Signature` object represents the call signature of a callable"
" object and its return annotation. To retrieve a :class:`!Signature` "
"object, use the :func:`!signature` function."
msgstr ""
"Signature 객체는 콜러블 객체의 호출 서명과 반환 값 어노테이션을 나타냅니다. Signature 객체를 가져오려면, "
":func:`signature` 함수를 사용하십시오."

#: ../../library/inspect.rst:674
#, fuzzy
msgid "Return a :class:`Signature` object for the given *callable*:"
msgstr "주어진 ``callable``\\에 대한 :class:`Signature` 객체를 반환합니다::"

#: ../../library/inspect.rst:676
msgid ""
">>> from inspect import signature\n"
">>> def foo(a, *, b:int, **kwargs):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
"\n"
">>> str(sig)\n"
"'(a, *, b: int, **kwargs)'\n"
"\n"
">>> str(sig.parameters['b'])\n"
"'b: int'\n"
"\n"
">>> sig.parameters['b'].annotation\n"
"<class 'int'>"
msgstr ""

#: ../../library/inspect.rst:693
msgid ""
"Accepts a wide range of Python callables, from plain functions and "
"classes to :func:`functools.partial` objects."
msgstr "일반 함수와 클래스에서 :func:`functools.partial` 객체에 이르기까지 광범위한 파이썬 콜러블을 받아들입니다."

#: ../../library/inspect.rst:696
msgid ""
"For objects defined in modules using stringized annotations (``from "
"__future__ import annotations``), :func:`signature` will attempt to "
"automatically un-stringize the annotations using :func:`get_annotations`."
"  The *globals*, *locals*, and *eval_str* parameters are passed into "
":func:`get_annotations` when resolving the annotations; see the "
"documentation for :func:`get_annotations` for instructions on how to use "
"these parameters."
msgstr ""

#: ../../library/inspect.rst:705
msgid ""
"Raises :exc:`ValueError` if no signature can be provided, and "
":exc:`TypeError` if that type of object is not supported.  Also, if the "
"annotations are stringized, and *eval_str* is not false, the ``eval()`` "
"call(s) to un-stringize the annotations in :func:`get_annotations` could "
"potentially raise any kind of exception."
msgstr ""

#: ../../library/inspect.rst:711
msgid ""
"A slash(/) in the signature of a function denotes that the parameters "
"prior to it are positional-only. For more info, see :ref:`the FAQ entry "
"on positional-only parameters <faq-positional-only-arguments>`."
msgstr ""
"함수 서명에서 슬래시(/)는 그 앞의 매개 변수가 위치 전용임을 나타냅니다. 자세한 내용은 :ref:`위치 전용 인자에 관한 FAQ"
" 항목 <faq-positional-only-arguments>`\\을 참조하십시오."

#: ../../library/inspect.rst:715
#, fuzzy
msgid ""
"The *follow_wrapped* parameter was added. Pass ``False`` to get a "
"signature of *callable* specifically (``callable.__wrapped__`` will not "
"be used to unwrap decorated callables.)"
msgstr ""
"``follow_wrapped`` 매개 변수. 구체적으로 ``callable``\\의 서명을 가져오려면 ``False``\\를 "
"전달하십시오 (데코레이트 된 콜러블의 래핑을 풀기 위해 ``callable.__wrapped__``\\를 사용하지 않게 됩니다)."

#: ../../library/inspect.rst:721 ../../library/inspect.rst:845
msgid "The *globals*, *locals*, and *eval_str* parameters were added."
msgstr ""

#: ../../library/inspect.rst:726
msgid ""
"Some callables may not be introspectable in certain implementations of "
"Python.  For example, in CPython, some built-in functions defined in C "
"provide no metadata about their arguments."
msgstr ""
"특정 파이썬 구현에서 일부 콜러블은 검사할 수 없습니다. 예를 들어, CPython에서, C로 정의된 일부 내장 함수는 인자에 대한"
" 메타 데이터를 제공하지 않습니다."

#: ../../library/inspect.rst:732
msgid ""
"If the passed object has a :attr:`!__signature__` attribute, we may use "
"it to create the signature. The exact semantics are an implementation "
"detail and are subject to unannounced changes. Consult the source code "
"for current semantics."
msgstr ""

#: ../../library/inspect.rst:740
#, fuzzy
msgid ""
"A :class:`!Signature` object represents the call signature of a function "
"and its return annotation.  For each parameter accepted by the function "
"it stores a :class:`Parameter` object in its :attr:`parameters` "
"collection."
msgstr ""
"Signature 객체는 함수의 호출 서명과 반환 값 어노테이션을 나타냅니다. 함수가 받아들이는 각 매개 변수에 대해 "
":attr:`parameters` 컬렉션에 :class:`Parameter` 객체를 저장합니다."

#: ../../library/inspect.rst:745
msgid ""
"The optional *parameters* argument is a sequence of :class:`Parameter` "
"objects, which is validated to check that there are no parameters with "
"duplicate names, and that the parameters are in the right order, i.e. "
"positional-only first, then positional-or-keyword, and that parameters "
"with defaults follow parameters without defaults."
msgstr ""
"선택적 *parameters* 인자는 :class:`Parameter` 객체의 시퀀스이며, 중복된 이름을 가진 매개 변수가 없는지,"
" 매개 변수가 올바른 순서인지 (즉, 위치 전용이 먼저 온 후, 위치-키워드가 그다음에 오는지), 기본값이 있는 매개 변수가 그렇지"
" 않은 매개 변수 뒤에 오는지 검사합니다."

#: ../../library/inspect.rst:751
#, fuzzy
msgid ""
"The optional *return_annotation* argument can be an arbitrary Python "
"object. It represents the \"return\" annotation of the callable."
msgstr "임의의 파이썬 객체일 수 있는, 선택적 *return_annotation* 인자는 콜러블의 \"반환 값\" 어노테이션입니다."

#: ../../library/inspect.rst:754
#, fuzzy
msgid ""
":class:`!Signature` objects are *immutable*.  Use "
":meth:`Signature.replace` or :func:`copy.replace` to make a modified "
"copy."
msgstr ""
"Signature 객체는 *불변(immutable)*\\입니다. 수정된 사본을 만들려면 "
":meth:`Signature.replace`\\를 사용하십시오."

#: ../../library/inspect.rst:757
#, fuzzy
msgid ":class:`!Signature` objects are now picklable and :term:`hashable`."
msgstr "Signature 객체는 피클 가능하고 해시 가능합니다."

#: ../../library/inspect.rst:762
msgid "A special class-level marker to specify absence of a return annotation."
msgstr "반환 값 어노테이션이 없음을 지정하는 특수 클래스 수준 마커입니다."

#: ../../library/inspect.rst:766
msgid ""
"An ordered mapping of parameters' names to the corresponding "
":class:`Parameter` objects.  Parameters appear in strict definition "
"order, including keyword-only parameters."
msgstr ""
"매개 변수 이름에서 해당 :class:`Parameter` 객체로의 순서 있는 매핑. 키워드 전용 매개 변수를 포함하여, 매개 "
"변수는 엄격한 정의 순서대로 나타납니다."

#: ../../library/inspect.rst:770 ../../library/inspect.rst:1125
msgid ""
"Python only explicitly guaranteed that it preserved the declaration order"
" of keyword-only parameters as of version 3.7, although in practice this "
"order had always been preserved in Python 3."
msgstr ""
"실제로 파이썬 3에서 항상 유지되었습니다만, 파이썬은 버전 3.7부터 키워드 전용 매개 변수의 선언 순서를 유지한다는 것을 "
"명시적으로 보장합니다."

#: ../../library/inspect.rst:777
msgid ""
"The \"return\" annotation for the callable.  If the callable has no "
"\"return\" annotation, this attribute is set to :attr:`Signature.empty`."
msgstr ""
"콜러블의 \"반환 값\" 어노테이션. 콜러블에 \"반환 값\" 어노테이션이 없으면, 이 어트리뷰트는 "
":attr:`Signature.empty`\\로 설정됩니다."

#: ../../library/inspect.rst:782
msgid ""
"Create a mapping from positional and keyword arguments to parameters. "
"Returns :class:`BoundArguments` if ``*args`` and ``**kwargs`` match the "
"signature, or raises a :exc:`TypeError`."
msgstr ""
"위치와 키워드 인자에서 매개 변수로의 매핑을 만듭니다. ``*args``\\와 ``**kwargs``\\가 서명과 일치하면 "
":class:`BoundArguments`\\를 반환하고, 그렇지 않으면 :exc:`TypeError`\\를 발생시킵니다."

#: ../../library/inspect.rst:788
msgid ""
"Works the same way as :meth:`Signature.bind`, but allows the omission of "
"some required arguments (mimics :func:`functools.partial` behavior.) "
"Returns :class:`BoundArguments`, or raises a :exc:`TypeError` if the "
"passed arguments do not match the signature."
msgstr ""
":meth:`Signature.bind`\\와 같은 방식으로 작동하지만, 일부 필수 인자를 생략 할 수 있습니다 "
"(:func:`functools.partial` 동작을 흉내 냅니다). :class:`BoundArguments`\\를 반환하거나,"
" 전달된 인자가 서명과 일치하지 않으면 :exc:`TypeError`\\를 발생시킵니다."

#: ../../library/inspect.rst:795
#, fuzzy
msgid ""
"Create a new :class:`Signature` instance based on the instance "
":meth:`replace` was invoked on. It is possible to pass different "
"*parameters* and/or *return_annotation* to override the corresponding "
"properties of the base signature.  To remove ``return_annotation`` from "
"the copied :class:`!Signature`, pass in :attr:`Signature.empty`."
msgstr ""
"replace가 호출된 인스턴스를 기반으로 새 Signature 인스턴스를 만듭니다. 다른 ``parameters``\\나 "
"``return_annotation`` 또는 둘 모두를 전달하여 기반 서명의 해당 속성을 재정의할 수 있습니다. 복사된 "
"Signature에서 return_annotation을 제거하려면, :attr:`Signature.empty`\\를 전달하십시오."

#: ../../library/inspect.rst:803
msgid ""
">>> def test(a, b):\n"
"...     pass\n"
"...\n"
">>> sig = signature(test)\n"
">>> new_sig = sig.replace(return_annotation=\"new return anno\")\n"
">>> str(new_sig)\n"
"\"(a, b) -> 'new return anno'\""
msgstr ""

#: ../../library/inspect.rst:813
msgid ""
":class:`Signature` objects are also supported by the generic function "
":func:`copy.replace`."
msgstr ""

#: ../../library/inspect.rst:818
#, fuzzy
msgid "Create a string representation of the :class:`Signature` object."
msgstr "부모 :class:`Signature` 객체에 대한 참조."

#: ../../library/inspect.rst:820
msgid ""
"If *max_width* is passed, the method will attempt to fit the signature "
"into lines of at most *max_width* characters. If the signature is longer "
"than *max_width*, all parameters will be on separate lines."
msgstr ""

#: ../../library/inspect.rst:829
#, fuzzy
msgid ""
"Return a :class:`Signature` (or its subclass) object for a given callable"
" *obj*."
msgstr "주어진 ``callable``\\에 대한 :class:`Signature` 객체를 반환합니다::"

#: ../../library/inspect.rst:832
#, fuzzy
msgid "This method simplifies subclassing of :class:`Signature`:"
msgstr "이 메서드는 :class:`Signature`\\의 서브 클래싱을 단순화합니다::"

#: ../../library/inspect.rst:834
msgid ""
"class MySignature(Signature):\n"
"    pass\n"
"sig = MySignature.from_callable(sum)\n"
"assert isinstance(sig, MySignature)"
msgstr ""

#: ../../library/inspect.rst:841
msgid "Its behavior is otherwise identical to that of :func:`signature`."
msgstr ""

#: ../../library/inspect.rst:851
#, fuzzy
msgid ""
":class:`!Parameter` objects are *immutable*. Instead of modifying a "
":class:`!Parameter` object, you can use :meth:`Parameter.replace` or "
":func:`copy.replace` to create a modified copy."
msgstr ""
"Parameter 객체는 *불변(immutable)*\\입니다. Parameter 객체를 수정하는 대신, 수정된 사본을 만들려면 "
":meth:`Parameter.replace`\\를 사용하십시오."

#: ../../library/inspect.rst:855
#, fuzzy
msgid "Parameter objects are now picklable and :term:`hashable`."
msgstr "Parameter 객체는 피클 가능하고 해시 가능합니다."

#: ../../library/inspect.rst:860
msgid ""
"A special class-level marker to specify absence of default values and "
"annotations."
msgstr "기본값과 어노테이션이 없음을 지정하는 특수 클래스 수준 마커."

#: ../../library/inspect.rst:865
msgid ""
"The name of the parameter as a string.  The name must be a valid Python "
"identifier."
msgstr "문자열로 표현한 매개 변수의 이름. 이름은 유효한 파이썬 식별자여야 합니다."

#: ../../library/inspect.rst:870
msgid ""
"CPython generates implicit parameter names of the form ``.0`` on the code"
" objects used to implement comprehensions and generator expressions."
msgstr ""
"CPython은 컴프리헨션과 제너레이터 표현식을 구현하는 데 사용되는 코드 객체에서 ``.0`` 형식의 묵시적 매개 변수 이름을 "
"생성합니다."

#: ../../library/inspect.rst:874
#, fuzzy
msgid ""
"These parameter names are now exposed by this module as names like "
"``implicit0``."
msgstr "이 매개 변수 이름은 이 모듈에서 ``implicit0``\\과 같은 이름으로 노출됩니다."

#: ../../library/inspect.rst:880
msgid ""
"The default value for the parameter.  If the parameter has no default "
"value, this attribute is set to :attr:`Parameter.empty`."
msgstr "매개 변수의 기본값. 매개 변수에 기본값이 없으면, 이 어트리뷰트는 :attr:`Parameter.empty`\\로 설정됩니다."

#: ../../library/inspect.rst:885
msgid ""
"The annotation for the parameter.  If the parameter has no annotation, "
"this attribute is set to :attr:`Parameter.empty`."
msgstr ""
"매개 변수의 어노테이션. 매개 변수에 어노테이션이 없으면, 이 어트리뷰트는 :attr:`Parameter.empty`\\로 "
"설정됩니다."

#: ../../library/inspect.rst:890
#, fuzzy
msgid ""
"Describes how argument values are bound to the parameter.  The possible "
"values are accessible via :class:`Parameter` (like "
"``Parameter.KEYWORD_ONLY``), and support comparison and ordering, in the "
"following order:"
msgstr ""
"인자 값이 매개 변수에 연결되는 방법을 설명합니다. 가능한 값은 다음과 같습니다 "
"(``Parameter.KEYWORD_ONLY``\\처럼 :class:`Parameter`\\를 통해 액세스할 수 있습니다):"

#: ../../library/inspect.rst:897
msgid "Name"
msgstr "이름"

#: ../../library/inspect.rst:897
msgid "Meaning"
msgstr "의미"

#: ../../library/inspect.rst:899
msgid "*POSITIONAL_ONLY*"
msgstr "*POSITIONAL_ONLY*"

#: ../../library/inspect.rst:899
msgid ""
"Value must be supplied as a positional argument. Positional only "
"parameters are those which appear before a ``/`` entry (if present) in a "
"Python function definition."
msgstr ""
"위치 인자로만 값을 제공해야 합니다. 위치 전용 매개 변수는 파이썬 함수 정의에서 ``/`` 항목 (있다면) 앞에 나오는 매개 "
"변수입니다."

#: ../../library/inspect.rst:904
msgid "*POSITIONAL_OR_KEYWORD*"
msgstr "*POSITIONAL_OR_KEYWORD*"

#: ../../library/inspect.rst:904
msgid ""
"Value may be supplied as either a keyword or positional argument (this is"
" the standard binding behaviour for functions implemented in Python.)"
msgstr "값은 키워드나 위치 인자로 제공될 수 있습니다 (이것이 파이썬으로 구현된 함수의 표준 연결 동작입니다)."

#: ../../library/inspect.rst:909
msgid "*VAR_POSITIONAL*"
msgstr "*VAR_POSITIONAL*"

#: ../../library/inspect.rst:909
msgid ""
"A tuple of positional arguments that aren't bound to any other parameter."
" This corresponds to a ``*args`` parameter in a Python function "
"definition."
msgstr "다른 매개 변수에 연결되지 않은 위치 인자의 튜플. 이것은 파이썬 함수 정의의 ``*args`` 매개 변수에 해당합니다."

#: ../../library/inspect.rst:914
msgid "*KEYWORD_ONLY*"
msgstr "*KEYWORD_ONLY*"

#: ../../library/inspect.rst:914
msgid ""
"Value must be supplied as a keyword argument. Keyword only parameters are"
" those which appear after a ``*`` or ``*args`` entry in a Python function"
" definition."
msgstr ""
"키워드 인자로만 값을 제공해야 합니다. 키워드 전용 매개 변수는 파이썬 함수 정의에서 ``*``\\나 ``*args`` 항목 다음에"
" 나오는 매개 변수입니다."

#: ../../library/inspect.rst:919
msgid "*VAR_KEYWORD*"
msgstr "*VAR_KEYWORD*"

#: ../../library/inspect.rst:919
msgid ""
"A dict of keyword arguments that aren't bound to any other parameter. "
"This corresponds to a ``**kwargs`` parameter in a Python function "
"definition."
msgstr "다른 매개 변수에 연결되지 않은 키워드 인자의 딕셔너리. 이것은 파이썬 함수 정의의 ``**kwargs`` 매개 변수에 해당합니다."

#: ../../library/inspect.rst:925
#, fuzzy
msgid "Example: print all keyword-only arguments without default values:"
msgstr "예: 기본값이 없는 모든 키워드 전용 인자를 인쇄합니다::"

#: ../../library/inspect.rst:927
msgid ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     if (param.kind == param.KEYWORD_ONLY and\n"
"...                        param.default is param.empty):\n"
"...         print('Parameter:', param)\n"
"Parameter: c"
msgstr ""

#: ../../library/inspect.rst:941
#, fuzzy
msgid "Describes an enum value of :attr:`Parameter.kind`."
msgstr "Parameter.kind의 열거형 값을 설명합니다."

#: ../../library/inspect.rst:945
#, fuzzy
msgid "Example: print all descriptions of arguments:"
msgstr "예: 모든 인자의 설명을 인쇄합니다::"

#: ../../library/inspect.rst:947
msgid ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     print(param.kind.description)\n"
"positional or keyword\n"
"positional or keyword\n"
"keyword-only\n"
"keyword-only"
msgstr ""

#: ../../library/inspect.rst:962
#, fuzzy
msgid ""
"Create a new :class:`Parameter` instance based on the instance replaced "
"was invoked on.  To override a :class:`!Parameter` attribute, pass the "
"corresponding argument.  To remove a default value or/and an annotation "
"from a :class:`!Parameter`, pass :attr:`Parameter.empty`."
msgstr ""
"replace가 호출된 인스턴스를 기반으로 새 Parameter 인스턴스를 만듭니다. :class:`Parameter` 어트리뷰트를"
" 재정의하려면, 해당 인자를 전달하십시오. Parameter에서 기본값이나 어노테이션, 또는 둘 다 제거하려면 "
":attr:`Parameter.empty`\\를 전달하십시오."

#: ../../library/inspect.rst:967
msgid ""
">>> from inspect import Parameter\n"
">>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)\n"
">>> str(param)\n"
"'foo=42'\n"
"\n"
">>> str(param.replace()) # Will create a shallow copy of 'param'\n"
"'foo=42'\n"
"\n"
">>> str(param.replace(default=Parameter.empty, annotation='spam'))\n"
"\"foo: 'spam'\""
msgstr ""

#: ../../library/inspect.rst:980
msgid ""
":class:`Parameter` objects are also supported by the generic function "
":func:`copy.replace`."
msgstr ""

#: ../../library/inspect.rst:983
#, fuzzy
msgid ""
"In Python 3.3 :class:`Parameter` objects were allowed to have ``name`` "
"set to ``None`` if their ``kind`` was set to ``POSITIONAL_ONLY``. This is"
" no longer permitted."
msgstr ""
"파이썬 3.3에서, ``kind``\\가 ``POSITIONAL_ONLY``\\로 설정되었을 때 Parameter 객체의 "
"``name``\\을 ``None``\\으로 설정할 수 있었습니다. 이는 더는 허용되지 않습니다."

#: ../../library/inspect.rst:990
msgid ""
"Result of a :meth:`Signature.bind` or :meth:`Signature.bind_partial` "
"call. Holds the mapping of arguments to the function's parameters."
msgstr ""
":meth:`Signature.bind`\\나 :meth:`Signature.bind_partial` 호출의 결과. 인자에서 함수의"
" 매개 변수로의 매핑을 보관합니다."

#: ../../library/inspect.rst:995
msgid ""
"A mutable mapping of parameters' names to arguments' values. Contains "
"only explicitly bound arguments.  Changes in :attr:`arguments` will "
"reflect in :attr:`args` and :attr:`kwargs`."
msgstr ""
"매개 변수 이름에서 인자 값으로의 가변 매핑. 명시적으로 연결된 인자만 포함합니다. :attr:`arguments`\\의 변경 "
"사항은 :attr:`args`\\와 :attr:`kwargs`\\에 반영됩니다."

#: ../../library/inspect.rst:999
msgid ""
"Should be used in conjunction with :attr:`Signature.parameters` for any "
"argument processing purposes."
msgstr "인자 처리 목적으로 :attr:`Signature.parameters`\\와 함께 사용해야 합니다."

#: ../../library/inspect.rst:1004
msgid ""
"Arguments for which :meth:`Signature.bind` or "
":meth:`Signature.bind_partial` relied on a default value are skipped. "
"However, if needed, use :meth:`BoundArguments.apply_defaults` to add "
"them."
msgstr ""
":meth:`Signature.bind`\\나 :meth:`Signature.bind_partial`\\이 기본값에 의존하는 인자는"
" 건너뜁니다. 그러나, 필요하다면 :meth:`BoundArguments.apply_defaults`\\를 사용하여 추가하십시오."

#: ../../library/inspect.rst:1009
msgid ""
":attr:`arguments` is now of type :class:`dict`. Formerly, it was of type "
":class:`collections.OrderedDict`."
msgstr ""
":attr:`arguments`\\는 이제 :class:`dict` 형입니다. 이전에는, "
":class:`collections.OrderedDict` 형이었습니다."

#: ../../library/inspect.rst:1015
msgid ""
"A tuple of positional arguments values.  Dynamically computed from the "
":attr:`arguments` attribute."
msgstr "위치 인자 값의 튜플. :attr:`arguments` 어트리뷰트에서 동적으로 계산됩니다."

#: ../../library/inspect.rst:1020
#, fuzzy
msgid ""
"A dict of keyword arguments values.  Dynamically computed from the "
":attr:`arguments` attribute.  Arguments that can be passed positionally "
"are included in :attr:`args` instead."
msgstr "키워드 인자 값의 딕셔너리. :attr:`arguments` 어트리뷰트에서 동적으로 계산됩니다."

#: ../../library/inspect.rst:1026
msgid "A reference to the parent :class:`Signature` object."
msgstr "부모 :class:`Signature` 객체에 대한 참조."

#: ../../library/inspect.rst:1030
msgid "Set default values for missing arguments."
msgstr "누락된 인자에 대한 기본값을 설정합니다."

#: ../../library/inspect.rst:1032
msgid ""
"For variable-positional arguments (``*args``) the default is an empty "
"tuple."
msgstr "가변 위치 인자(``*args``)의 기본값은 빈 튜플입니다."

#: ../../library/inspect.rst:1035
msgid ""
"For variable-keyword arguments (``**kwargs``) the default is an empty "
"dict."
msgstr "가변 변수 키워드 인자(``**kwargs``)의 기본값은 빈 딕셔너리입니다."

#: ../../library/inspect.rst:1038
#, python-brace-format
msgid ""
">>> def foo(a, b='ham', *args): pass\n"
">>> ba = inspect.signature(foo).bind('spam')\n"
">>> ba.apply_defaults()\n"
">>> ba.arguments\n"
"{'a': 'spam', 'b': 'ham', 'args': ()}"
msgstr ""

#: ../../library/inspect.rst:1048
#, fuzzy
msgid ""
"The :attr:`args` and :attr:`kwargs` properties can be used to invoke "
"functions:"
msgstr ":attr:`args`\\와 :attr:`kwargs` 프로퍼티를 사용하여 함수를 호출할 수 있습니다::"

#: ../../library/inspect.rst:1051
msgid ""
"def test(a, *, b):\n"
"    ...\n"
"\n"
"sig = signature(test)\n"
"ba = sig.bind(10, b=20)\n"
"test(*ba.args, **ba.kwargs)"
msgstr ""

#: ../../library/inspect.rst:1063
msgid ":pep:`362` - Function Signature Object."
msgstr ":pep:`362` - 함수 Signature 객체."

#: ../../library/inspect.rst:1064
msgid "The detailed specification, implementation details and examples."
msgstr "자세한 명세, 구현 세부 사항 및 예"

#: ../../library/inspect.rst:1070
msgid "Classes and functions"
msgstr "클래스와 함수"

#: ../../library/inspect.rst:1074
msgid ""
"Arrange the given list of classes into a hierarchy of nested lists. Where"
" a nested list appears, it contains classes derived from the class whose "
"entry immediately precedes the list.  Each entry is a 2-tuple containing "
"a class and a tuple of its base classes.  If the *unique* argument is "
"true, exactly one entry appears in the returned structure for each class "
"in the given list.  Otherwise, classes using multiple inheritance and "
"their descendants will appear multiple times."
msgstr ""
"주어진 클래스 리스트를 중첩된 리스트의 계층 구조로 배치합니다. 중첩된 리스트가 나타나면, 리스트 바로 앞에 나오는 항목의 "
"클래스에서 파생된 클래스를 포함합니다. 각 항목은 클래스와 베이스 클래스의 튜플을 포함하는 2-튜플입니다. *unique* 인자가 "
"참이면, 주어진 리스트의 각 클래스가 반환된 구조에 정확히 하나의 항목으로 나타납니다. 그렇지 않으면, 다중 상속을 사용하는 "
"클래스와 그 자식들이 여러 번 나타납니다."

#: ../../library/inspect.rst:1085
msgid ""
"Get the names and default values of a Python function's parameters.  A "
":term:`named tuple` is returned:"
msgstr "파이썬 함수 매개 변수의 이름과 기본값을 가져옵니다. :term:`네임드 튜플 <named tuple>`\\이 반환됩니다:"

#: ../../library/inspect.rst:1088
msgid ""
"``FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults,"
" annotations)``"
msgstr ""
"``FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults,"
" annotations)``"

#: ../../library/inspect.rst:1091
msgid ""
"*args* is a list of the positional parameter names. *varargs* is the name"
" of the ``*`` parameter or ``None`` if arbitrary positional arguments are"
" not accepted. *varkw* is the name of the ``**`` parameter or ``None`` if"
" arbitrary keyword arguments are not accepted. *defaults* is an *n*-tuple"
" of default argument values corresponding to the last *n* positional "
"parameters, or ``None`` if there are no such defaults defined. "
"*kwonlyargs* is a list of keyword-only parameter names in declaration "
"order. *kwonlydefaults* is a dictionary mapping parameter names from "
"*kwonlyargs* to the default values used if no argument is supplied. "
"*annotations* is a dictionary mapping parameter names to annotations. The"
" special key ``\"return\"`` is used to report the function return value "
"annotation (if any)."
msgstr ""
"*args*\\는 위치 매개 변수 이름의 리스트입니다. *varargs*\\는 ``*`` 매개 변수의 이름이거나 임의의 위치 인자가"
" 허용되지 않으면 ``None``\\입니다. *varkw*\\는 ``**`` 매개 변수의 이름이거나 임의의 키워드 인자가 허용되지 "
"않으면 ``None``\\입니다. *defaults*\\는 마지막 *n* 개의 위치 매개 변수에 해당하는 기본 인자 값의 "
"*n*-튜플이거나, 이러한 기본값이 정의되지 않으면 ``None``\\입니다. *kwonlyargs*\\는 선언 순서를 따르는 "
"키워드 전용 매개 변수 이름 리스트입니다. *kwonlydefaults*\\는 *kwonlyargs*\\의 매개 변수 이름에서 "
"인자가 제공되지 않을 때 사용되는 기본값으로의 딕셔너리 매핑입니다. *annotations*\\는 매개 변수 이름에서 "
"어노테이션으로의 딕셔너리 매핑입니다. 특수키 ``\"return\"``\\은 함수 반환 값 어노테이션(있다면)을 보고하는 데 "
"사용됩니다."

#: ../../library/inspect.rst:1106
msgid ""
"Note that :func:`signature` and :ref:`Signature Object <inspect-"
"signature-object>` provide the recommended API for callable "
"introspection, and support additional behaviours (like positional-only "
"arguments) that are sometimes encountered in extension module APIs. This "
"function is retained primarily for use in code that needs to maintain "
"compatibility with the Python 2 ``inspect`` module API."
msgstr ""
":func:`signature`\\와 :ref:`Signature 객체 <inspect-signature-object>`\\가 "
"콜러블 내부 검사에 권장되는 API를 제공하고, 확장 모듈 API에서 종종 등장하는 추가 동작(위치 전용 인자와 같은)을 지원함에 "
"유의하십시오. 이 함수는 주로 파이썬 2 ``inspect`` 모듈 API와의 호환성을 유지해야 하는 코드에서 사용하기 위해 "
"유지됩니다."

#: ../../library/inspect.rst:1113
msgid ""
"This function is now based on :func:`signature`, but still ignores "
"``__wrapped__`` attributes and includes the already bound first parameter"
" in the signature output for bound methods."
msgstr ""
"이 함수는 이제 :func:`signature`\\를 기반으로 하지만, 여전히 ``__wrapped__`` 어트리뷰트를 무시하고 "
"연결된(bound) 메서드의 서명 출력에 이미 연결된 첫 번째 매개 변수를 포함합니다."

#: ../../library/inspect.rst:1118
msgid ""
"This method was previously documented as deprecated in favour of "
":func:`signature` in Python 3.5, but that decision has been reversed in "
"order to restore a clearly supported standard interface for single-source"
" Python 2/3 code migrating away from the legacy :func:`getargspec` API."
msgstr ""
"이 메서드는 이전에 파이썬 3.5에서 :func:`signature`\\로 대신하면서 폐지된 것으로 문서화되었지만, 레거시 "
":func:`getargspec` API에서 마이그레이션 하는 단일 소스 파이썬 2/3 코드를 위한 명확하게 지원되는 표준 "
"인터페이스를 복원하기 위해 이 결정을 번복했습니다."

#: ../../library/inspect.rst:1133
msgid ""
"Get information about arguments passed into a particular frame.  A "
":term:`named tuple` ``ArgInfo(args, varargs, keywords, locals)`` is "
"returned. *args* is a list of the argument names.  *varargs* and "
"*keywords* are the names of the ``*`` and ``**`` arguments or ``None``.  "
"*locals* is the locals dictionary of the given frame."
msgstr ""
"특정 프레임으로 전달된 인자에 대한 정보를 얻습니다. :term:`네임드 튜플 <named tuple>` "
"``ArgInfo(args, varargs, keywords, locals)``\\가 반환됩니다. *args*\\는 인자 이름의 "
"리스트입니다. *varargs*\\와 *keywords*\\는 ``*``\\와 ``**`` 인자의 이름이거나 "
"``None``\\입니다. *locals*\\는 주어진 프레임의 지역 딕셔너리입니다."

#: ../../library/inspect.rst:1140 ../../library/inspect.rst:1150
msgid "This function was inadvertently marked as deprecated in Python 3.5."
msgstr "이 함수는 실수로 파이썬 3.5에서 폐지된 것으로 표시되었습니다."

#: ../../library/inspect.rst:1145
msgid ""
"Format a pretty argument spec from the four values returned by "
":func:`getargvalues`.  The format\\* arguments are the corresponding "
"optional formatting functions that are called to turn names and values "
"into strings."
msgstr ""
":func:`getargvalues`\\가 반환한 4개의 값으로 예쁜 인자 명세를 포맷합니다. format\\* 인자는 해당 이름과"
" 값을 문자열로 변환하기 위해 호출되는 선택적 포매팅 함수입니다."

#: ../../library/inspect.rst:1155
msgid ""
"Return a tuple of class cls's base classes, including cls, in method "
"resolution order.  No class appears more than once in this tuple. Note "
"that the method resolution order depends on cls's type.  Unless a very "
"peculiar user-defined metatype is in use, cls will be the first element "
"of the tuple."
msgstr ""
"클래스 cls의 베이스 클래스의 튜플(cls를 포함합니다)을 메서드 결정 순서로 반환합니다. 이 튜플에는 클래스가 두 번 이상 "
"나타나지 않습니다. 메서드 결정 순서는 cls의 형에 따라 다릅니다. 매우 독특한 사용자 정의 메타 형을 사용하지 않는 한, "
"cls는 튜플의 첫 번째 요소가 됩니다."

#: ../../library/inspect.rst:1163
#, fuzzy
msgid ""
"Bind the *args* and *kwds* to the argument names of the Python function "
"or method *func*, as if it was called with them. For bound methods, bind "
"also the first argument (typically named ``self``) to the associated "
"instance. A dict is returned, mapping the argument names (including the "
"names of the ``*`` and ``**`` arguments, if any) to their values from "
"*args* and *kwds*. In case of invoking *func* incorrectly, i.e. whenever "
"``func(*args, **kwds)`` would raise an exception because of incompatible "
"signature, an exception of the same type and the same or similar message "
"is raised. For example:"
msgstr ""
"*args*\\와 *kwds*\\를 마치 이들로 호출된 것처럼 파이썬 함수나 메서드 *func*\\의 인자 이름에 연결합니다. "
"연결된 메서드의 경우, 첫 번째 인자(일반적으로 ``self``\\라고 합니다)도 해당 인스턴스에 연결합니다. 인자 이름(있다면, "
"``*``\\와 ``**`` 인자의 이름도 포함합니다)을 *args*\\와 *kwds*\\의 값으로 매핑하는 딕셔너리가 반환됩니다."
" *func*\\를 잘못 호출하는 경우, 즉 호환되지 않는 서명으로 인해 ``func(*args, **kwds)``\\가 예외를 "
"발생시키게 될 때마다, 같은 형의 예외가 같거나 유사한 메시지로 발생합니다. 예를 들면::"

#: ../../library/inspect.rst:1172
#, python-brace-format
msgid ""
">>> from inspect import getcallargs\n"
">>> def f(a, b=1, *pos, **named):\n"
"...     pass\n"
"...\n"
">>> getcallargs(f, 1, 2, 3) == {'a': 1, 'named': {}, 'b': 2, 'pos': (3,)}"
"\n"
"True\n"
">>> getcallargs(f, a=2, x=4) == {'a': 2, 'named': {'x': 4}, 'b': 1, "
"'pos': ()}\n"
"True\n"
">>> getcallargs(f)\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: f() missing 1 required positional argument: 'a'"
msgstr ""

#: ../../library/inspect.rst:1189
msgid "Use :meth:`Signature.bind` and :meth:`Signature.bind_partial` instead."
msgstr "대신 :meth:`Signature.bind`\\와 :meth:`Signature.bind_partial`\\을 사용하십시오."

#: ../../library/inspect.rst:1195
msgid ""
"Get the mapping of external name references in a Python function or "
"method *func* to their current values. A :term:`named tuple` "
"``ClosureVars(nonlocals, globals, builtins, unbound)`` is returned. "
"*nonlocals* maps referenced names to lexical closure variables, *globals*"
" to the function's module globals and *builtins* to the builtins visible "
"from the function body. *unbound* is the set of names referenced in the "
"function that could not be resolved at all given the current module "
"globals and builtins."
msgstr ""
"파이썬 함수나 메서드 *func*\\에 있는 외부 이름 참조에서 현재 값으로의 매핑을 얻습니다. :term:`네임드 튜플 "
"<named tuple>` ``ClosureVars(nonlocals, globals, builtins, unbound)``\\가 "
"반환됩니다. *nonlocals*\\는 참조된 이름을 어휘 클로저(closure) 변수로, *globals*\\는 함수의 모듈 "
"전역으로, *builtins*\\는 함수 바디에서 볼 수 있는 내장으로 매핑합니다. *unbound*\\는 현재 모듈 전역과 "
"내장에서 전혀 결정할 수 없는 함수에서 참조된 이름 집합입니다."

#: ../../library/inspect.rst:1204
msgid ":exc:`TypeError` is raised if *func* is not a Python function or method."
msgstr "*func*\\가 파이썬 함수나 메서드가 아니면 :exc:`TypeError`\\가 발생합니다."

#: ../../library/inspect.rst:1211
msgid ""
"Get the object wrapped by *func*. It follows the chain of "
":attr:`__wrapped__` attributes returning the last object in the chain."
msgstr ""
"*func*\\로 래핑 된 객체를 가져옵니다. 체인의 마지막 객체를 반환하는 :attr:`__wrapped__` 어트리뷰트의 체인을"
" 따라갑니다."

#: ../../library/inspect.rst:1214
msgid ""
"*stop* is an optional callback accepting an object in the wrapper chain "
"as its sole argument that allows the unwrapping to be terminated early if"
" the callback returns a true value. If the callback never returns a true "
"value, the last object in the chain is returned as usual. For example, "
":func:`signature` uses this to stop unwrapping if any object in the chain"
" has a ``__signature__`` attribute defined."
msgstr ""
"*stop*\\은 래퍼 체인의 객체를 유일한 인자로 받아들이는 선택적 콜백으로, 콜백이 참값을 반환할 때 언 래핑을 조기에 종료 할"
" 수 있도록 합니다. 콜백이 참값을 반환하지 않으면, 체인의 마지막 객체가 평소처럼 반환됩니다. 예를 들어, "
":func:`signature`\\는 이것을 사용하여 체인에 있는 객체에 ``__signature__`` 어트리뷰트가 정의되면 언 "
"래핑을 중지합니다."

#: ../../library/inspect.rst:1221
msgid ":exc:`ValueError` is raised if a cycle is encountered."
msgstr "순환이 발견되면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/inspect.rst:1228
msgid "Compute the annotations dict for an object."
msgstr ""

#: ../../library/inspect.rst:1230
msgid ""
"``obj`` may be a callable, class, or module. Passing in an object of any "
"other type raises :exc:`TypeError`."
msgstr ""

#: ../../library/inspect.rst:1233
msgid ""
"Returns a dict.  ``get_annotations()`` returns a new dict every time it's"
" called; calling it twice on the same object will return two different "
"but equivalent dicts."
msgstr ""

#: ../../library/inspect.rst:1237
msgid "This function handles several details for you:"
msgstr ""

#: ../../library/inspect.rst:1239
msgid ""
"If ``eval_str`` is true, values of type ``str`` will be un-stringized "
"using :func:`eval`.  This is intended for use with stringized annotations"
" (``from __future__ import annotations``)."
msgstr ""

#: ../../library/inspect.rst:1243
msgid ""
"If ``obj`` doesn't have an annotations dict, returns an empty dict.  "
"(Functions and methods always have an annotations dict; classes, modules,"
" and other types of callables may not.)"
msgstr ""

#: ../../library/inspect.rst:1247
msgid ""
"Ignores inherited annotations on classes.  If a class doesn't have its "
"own annotations dict, returns an empty dict."
msgstr ""

#: ../../library/inspect.rst:1249
msgid ""
"All accesses to object members and dict values are done using "
"``getattr()`` and ``dict.get()`` for safety."
msgstr ""

#: ../../library/inspect.rst:1251
msgid "Always, always, always returns a freshly created dict."
msgstr ""

#: ../../library/inspect.rst:1253
msgid ""
"``eval_str`` controls whether or not values of type ``str`` are replaced "
"with the result of calling :func:`eval` on those values:"
msgstr ""

#: ../../library/inspect.rst:1256
msgid ""
"If eval_str is true, :func:`eval` is called on values of type ``str``. "
"(Note that ``get_annotations`` doesn't catch exceptions; if :func:`eval` "
"raises an exception, it will unwind the stack past the "
"``get_annotations`` call.)"
msgstr ""

#: ../../library/inspect.rst:1260
msgid "If eval_str is false (the default), values of type ``str`` are unchanged."
msgstr ""

#: ../../library/inspect.rst:1262
msgid ""
"``globals`` and ``locals`` are passed in to :func:`eval`; see the "
"documentation for :func:`eval` for more information.  If ``globals`` or "
"``locals`` is ``None``, this function may replace that value with a "
"context-specific default, contingent on ``type(obj)``:"
msgstr ""

#: ../../library/inspect.rst:1267
msgid "If ``obj`` is a module, ``globals`` defaults to ``obj.__dict__``."
msgstr ""

#: ../../library/inspect.rst:1268
msgid ""
"If ``obj`` is a class, ``globals`` defaults to "
"``sys.modules[obj.__module__].__dict__`` and ``locals`` defaults to the "
"``obj`` class namespace."
msgstr ""

#: ../../library/inspect.rst:1271
msgid ""
"If ``obj`` is a callable, ``globals`` defaults to :attr:`obj.__globals__ "
"<function.__globals__>`, although if ``obj`` is a wrapped function (using"
" :func:`functools.update_wrapper`) it is first unwrapped."
msgstr ""

#: ../../library/inspect.rst:1276
msgid ""
"Calling ``get_annotations`` is best practice for accessing the "
"annotations dict of any object.  See :ref:`annotations-howto` for more "
"information on annotations best practices."
msgstr ""

#: ../../library/inspect.rst:1286
msgid "The interpreter stack"
msgstr "인터프리터 스택"

#: ../../library/inspect.rst:1288
msgid ""
"Some of the following functions return :class:`FrameInfo` objects. For "
"backwards compatibility these objects allow tuple-like operations on all "
"attributes except ``positions``. This behavior is considered deprecated "
"and may be removed in the future."
msgstr ""

#: ../../library/inspect.rst:1297
msgid "The :ref:`frame object <frame-objects>` that the record corresponds to."
msgstr ""

#: ../../library/inspect.rst:1301
msgid ""
"The file name associated with the code being executed by the frame this "
"record corresponds to."
msgstr ""

#: ../../library/inspect.rst:1306
msgid ""
"The line number of the current line associated with the code being "
"executed by the frame this record corresponds to."
msgstr ""

#: ../../library/inspect.rst:1311
msgid ""
"The function name that is being executed by the frame this record "
"corresponds to."
msgstr ""

#: ../../library/inspect.rst:1315
msgid ""
"A list of lines of context from the source code that's being executed by "
"the frame this record corresponds to."
msgstr ""

#: ../../library/inspect.rst:1320 ../../library/inspect.rst:1359
msgid ""
"The index of the current line being executed in the :attr:`code_context` "
"list."
msgstr ""

#: ../../library/inspect.rst:1324
msgid ""
"A :class:`dis.Positions` object containing the start line number, end "
"line number, start column offset, and end column offset associated with "
"the instruction being executed by the frame this record corresponds to."
msgstr ""

#: ../../library/inspect.rst:1328
#, fuzzy
msgid "Return a :term:`named tuple` instead of a :class:`tuple`."
msgstr "튜플 대신 네임드 튜플을 반환합니다."

#: ../../library/inspect.rst:1331
msgid ""
":class:`!FrameInfo` is now a class instance (that is backwards compatible"
" with the previous :term:`named tuple`)."
msgstr ""

#: ../../library/inspect.rst:1340
msgid ""
"The file name associated with the code being executed by the frame this "
"traceback corresponds to."
msgstr ""

#: ../../library/inspect.rst:1345
msgid ""
"The line number of the current line associated with the code being "
"executed by the frame this traceback corresponds to."
msgstr ""

#: ../../library/inspect.rst:1350
msgid ""
"The function name that is being executed by the frame this traceback "
"corresponds to."
msgstr ""

#: ../../library/inspect.rst:1354
msgid ""
"A list of lines of context from the source code that's being executed by "
"the frame this traceback corresponds to."
msgstr ""

#: ../../library/inspect.rst:1363
msgid ""
"A :class:`dis.Positions` object containing the start line number, end "
"line number, start column offset, and end column offset associated with "
"the instruction being executed by the frame this traceback corresponds "
"to."
msgstr ""

#: ../../library/inspect.rst:1368
msgid ""
":class:`!Traceback` is now a class instance (that is backwards compatible"
" with the previous :term:`named tuple`)."
msgstr ""

#: ../../library/inspect.rst:1375
msgid ""
"Keeping references to frame objects, as found in the first element of the"
" frame records these functions return, can cause your program to create "
"reference cycles.  Once a reference cycle has been created, the lifespan "
"of all objects which can be accessed from the objects which form the "
"cycle can become much longer even if Python's optional cycle detector is "
"enabled.  If such cycles must be created, it is important to ensure they "
"are explicitly broken to avoid the delayed destruction of objects and "
"increased memory consumption which occurs."
msgstr ""
"이러한 함수가 반환하는 프레임 레코드의 첫 번째 요소에서 발견되는 것처럼, 프레임 객체에 대한 참조를 유지하면 프로그램이 참조 "
"순환을 만들 수 있습니다. 일단 참조 순환이 생성되면, 파이썬의 선택적 순환 검출기가 활성화되어 있어도, 순환을 형성하는 객체에서 "
"액세스 할 수 있는 모든 객체의 수명이 훨씬 더 길어질 수 있습니다. 이러한 순환을 만들어야만 하면, 명시적으로 끊어서 객체의 "
"지연된 파괴와 메모리 소비 증가를 피하는 것이 중요합니다."

#: ../../library/inspect.rst:1383
msgid ""
"Though the cycle detector will catch these, destruction of the frames "
"(and local variables) can be made deterministic by removing the cycle in "
"a :keyword:`finally` clause.  This is also important if the cycle "
"detector was disabled when Python was compiled or using "
":func:`gc.disable`.  For example::"
msgstr ""
"순환 감지기가 이를 잡기는 하겠지만, :keyword:`finally` 절에서 순환을 제거하여 프레임(과 지역 변수)의 파괴를 "
"결정적(deterministic)으로 만들 수 있습니다. 파이썬을 컴파일할 때나 :func:`gc.disable`\\을 사용해서 "
"순환 감지기를 비활성화했을 때도 중요합니다. 예를 들면::"

#: ../../library/inspect.rst:1388
msgid ""
"def handle_stackframe_without_leak():\n"
"    frame = inspect.currentframe()\n"
"    try:\n"
"        # do something with the frame\n"
"    finally:\n"
"        del frame"
msgstr ""

#: ../../library/inspect.rst:1395
msgid ""
"If you want to keep the frame around (for example to print a traceback "
"later), you can also break reference cycles by using the "
":meth:`frame.clear` method."
msgstr ""
"프레임을 계속 유지하려면 (예를 들어 나중에 트레이스백을 인쇄하려고) :meth:`frame.clear` 메서드를 사용하여 참조 "
"순환을 끊을 수도 있습니다."

#: ../../library/inspect.rst:1399
msgid ""
"The optional *context* argument supported by most of these functions "
"specifies the number of lines of context to return, which are centered "
"around the current line."
msgstr ""
"이 함수들 대부분이 지원하는 선택적 *context* 인자는 반환할 문맥(context) 줄 수를 지정합니다. 이 줄들은 현재 줄을"
" 중심으로 합니다."

#: ../../library/inspect.rst:1406
#, fuzzy
msgid ""
"Get information about a frame or traceback object.  A :class:`Traceback` "
"object is returned."
msgstr ""
"프레임이나 트레이스백 객체에 대한 정보를 얻습니다. :term:`네임드 튜플 <named tuple>` "
"``Traceback(filename, lineno, function, code_context, index)``\\가 반환됩니다."

#: ../../library/inspect.rst:1409
msgid "A :class:`Traceback` object is returned instead of a named tuple."
msgstr ""

#: ../../library/inspect.rst:1414
#, fuzzy
msgid ""
"Get a list of :class:`FrameInfo` objects for a frame and all outer "
"frames. These frames represent the calls that lead to the creation of "
"*frame*. The first entry in the returned list represents *frame*; the "
"last entry represents the outermost call on *frame*'s stack."
msgstr ""
"frame과 모든 외부(outer) 프레임에 대한 프레임 레코드 리스트를 얻습니다. 이 프레임들은 *frame*\\을 만들도록 한 "
"호출을 나타냅니다. 반환된 리스트의 첫 번째 항목은 *frame*\\을 나타냅니다; 마지막 항목은 *frame*\\의 스택에서 가장"
" 바깥쪽 호출을 나타냅니다."

#: ../../library/inspect.rst:1419 ../../library/inspect.rst:1434
#: ../../library/inspect.rst:1460 ../../library/inspect.rst:1475
msgid ""
"A list of :term:`named tuples <named tuple>` ``FrameInfo(frame, filename,"
" lineno, function, code_context, index)`` is returned."
msgstr ""
":term:`네임드 튜플 <named tuple>` ``FrameInfo(frame, filename, lineno, "
"function, code_context, index)``\\의 리스트가 반환됩니다."

#: ../../library/inspect.rst:1424 ../../library/inspect.rst:1439
#: ../../library/inspect.rst:1465 ../../library/inspect.rst:1480
msgid "A list of :class:`FrameInfo` objects is returned."
msgstr ""

#: ../../library/inspect.rst:1429
#, fuzzy
msgid ""
"Get a list of :class:`FrameInfo` objects for a traceback's frame and all "
"inner frames.  These frames represent calls made as a consequence of "
"*frame*. The first entry in the list represents *traceback*; the last "
"entry represents where the exception was raised."
msgstr ""
"traceback의 프레임과 모든 내부(inner) 프레임에 대한 프레임 레코드 리스트를 얻습니다. 이 프레임들은 "
"*frame*\\의 결과로 만들어진 호출을 나타냅니다. 리스트의 첫 번째 항목은 *traceback*\\을 나타냅니다; 마지막 "
"항목은 예외가 발생한 위치를 나타냅니다."

#: ../../library/inspect.rst:1444
msgid "Return the frame object for the caller's stack frame."
msgstr "호출자의 스택 프레임에 대한 프레임 객체를 반환합니다."

#: ../../library/inspect.rst:1448
msgid ""
"This function relies on Python stack frame support in the interpreter, "
"which isn't guaranteed to exist in all implementations of Python.  If "
"running in an implementation without Python stack frame support this "
"function returns ``None``."
msgstr ""
"이 함수는 인터프리터의 파이썬 스택 프레임 지원에 의존하며, 모든 파이썬 구현에서 제공된다고 보장되는 것은 아닙니다. 파이썬 스택 "
"프레임 지원이 없는 구현에서 실행하면, 이 함수는 ``None``\\을 반환합니다."

#: ../../library/inspect.rst:1456
#, fuzzy
msgid ""
"Return a list of :class:`FrameInfo` objects for the caller's stack.  The "
"first entry in the returned list represents the caller; the last entry "
"represents the outermost call on the stack."
msgstr ""
"호출자의 스택에 대한 프레임 레코드 리스트를 반환합니다. 반환된 리스트의 첫 번째 항목은 호출자를 나타냅니다; 마지막 항목은 "
"스택에서 가장 바깥쪽 호출을 나타냅니다."

#: ../../library/inspect.rst:1470
#, fuzzy
msgid ""
"Return a list of :class:`FrameInfo` objects for the stack between the "
"current frame and the frame in which an exception currently being handled"
" was raised in.  The first entry in the list represents the caller; the "
"last entry represents where the exception was raised."
msgstr ""
"현재 프레임과 현재 처리 중인 예외가 발생한 프레임 사이의 스택에 대한 프레임 레코드 리스트를 반환합니다. 리스트의 첫 번째 항목은"
" 호출자를 나타냅니다; 마지막 항목은 예외가 발생한 위치를 나타냅니다."

#: ../../library/inspect.rst:1484
msgid "Fetching attributes statically"
msgstr "정적으로 어트리뷰트 가져오기"

#: ../../library/inspect.rst:1486
#, fuzzy
msgid ""
"Both :func:`getattr` and :func:`hasattr` can trigger code execution when "
"fetching or checking for the existence of attributes. Descriptors, like "
"properties, will be invoked and :meth:`~object.__getattr__` and "
":meth:`~object.__getattribute__` may be called."
msgstr ""
":func:`getattr`\\과 :func:`hasattr`\\은 모두 어트리뷰트를 가져오거나 존재하는지 확인할 때 코드 실행을 "
"유발할 수 있습니다. 프로퍼티와 같은 디스크립터가 호출되고 :meth:`__getattr__`\\과 "
":meth:`__getattribute__`\\가 호출될 수 있습니다."

#: ../../library/inspect.rst:1492
msgid ""
"For cases where you want passive introspection, like documentation tools,"
" this can be inconvenient. :func:`getattr_static` has the same signature "
"as :func:`getattr` but avoids executing code when it fetches attributes."
msgstr ""
"문서화 도구처럼 수동적인(passive) 검사를 원할 때는 불편할 수 있습니다. :func:`getattr_static`\\은 "
":func:`getattr`\\과 같은 서명을 갖지만 어트리뷰트를 가져올 때 코드 실행을 피합니다."

#: ../../library/inspect.rst:1498
#, fuzzy
msgid ""
"Retrieve attributes without triggering dynamic lookup via the descriptor "
"protocol, :meth:`~object.__getattr__` or "
":meth:`~object.__getattribute__`."
msgstr ""
"디스크립터 프로토콜, :meth:`__getattr__` 또는 :meth:`__getattribute__`\\를 통한 동적 조회를 "
"일으키지 않고 어트리뷰트를 조회합니다."

#: ../../library/inspect.rst:1502
msgid ""
"Note: this function may not be able to retrieve all attributes that "
"getattr can fetch (like dynamically created attributes) and may find "
"attributes that getattr can't (like descriptors that raise "
"AttributeError). It can also return descriptors objects instead of "
"instance members."
msgstr ""
"참고: 이 함수는 getattr이 가져올 수 있는 모든 어트리뷰트를 조회하지 못할 수 있으며 (가령 동적으로 만들어진 어트리뷰트),"
" getattr이 가져올 수 없는 어트리뷰트를 찾을 수 있습니다 (가령 AttributeError를 발생시키는 디스크립터). 또한 "
"인스턴스 멤버 대신 디스크립터 객체를 반환할 수도 있습니다."

#: ../../library/inspect.rst:1508
msgid ""
"If the instance :attr:`~object.__dict__` is shadowed by another member "
"(for example a property) then this function will be unable to find "
"instance members."
msgstr ""
"인스턴스 :attr:`~object.__dict__`\\가 다른 멤버(예를 들어 프로퍼티)에 의해 가려지면 이 함수는 인스턴스 "
"멤버를 찾을 수 없습니다."

#: ../../library/inspect.rst:1514
msgid ""
":func:`getattr_static` does not resolve descriptors, for example slot "
"descriptors or getset descriptors on objects implemented in C. The "
"descriptor object is returned instead of the underlying attribute."
msgstr ""
":func:`getattr_static`\\은 디스크립터를 해석하지 않습니다, 예를 들어 C로 구현된 객체의 슬롯 디스크립터나 "
"getset 디스크립터. 하부 어트리뷰트 대신 디스크립터 객체가 반환됩니다."

#: ../../library/inspect.rst:1518
msgid ""
"You can handle these with code like the following. Note that for "
"arbitrary getset descriptors invoking these may trigger code execution::"
msgstr ""
"다음과 같은 코드로 이를 처리할 수 있습니다. 임의의 getset 디스크립터에 대해 이를 호출하면 코드 실행이 유발될 수 있음에 "
"유의하십시오::"

#: ../../library/inspect.rst:1522
msgid ""
"# example code for resolving the builtin descriptor types\n"
"class _foo:\n"
"    __slots__ = ['foo']\n"
"\n"
"slot_descriptor = type(_foo.foo)\n"
"getset_descriptor = type(type(open(__file__)).name)\n"
"wrapper_descriptor = type(str.__dict__['__add__'])\n"
"descriptor_types = (slot_descriptor, getset_descriptor, "
"wrapper_descriptor)\n"
"\n"
"result = getattr_static(some_object, 'foo')\n"
"if type(result) in descriptor_types:\n"
"    try:\n"
"        result = result.__get__()\n"
"    except AttributeError:\n"
"        # descriptors can raise AttributeError to\n"
"        # indicate there is no underlying value\n"
"        # in which case the descriptor itself will\n"
"        # have to do\n"
"        pass"
msgstr ""

#: ../../library/inspect.rst:1544
#, fuzzy
msgid "Current State of Generators, Coroutines, and Asynchronous Generators"
msgstr "제너레이터와 코루틴의 현재 상태"

#: ../../library/inspect.rst:1546
msgid ""
"When implementing coroutine schedulers and for other advanced uses of "
"generators, it is useful to determine whether a generator is currently "
"executing, is waiting to start or resume or execution, or has already "
"terminated. :func:`getgeneratorstate` allows the current state of a "
"generator to be determined easily."
msgstr ""
"코루틴 스케줄러를 구현할 때와 기타 제너레이터의 고급 사용을 위해, 제너레이터가 현재 실행 중인지, 시작, 재개 또는 실행을 "
"대기하는 중인지, 또는 이미 종료되었는지를 판별하는 것이 유용합니다. :func:`getgeneratorstate`\\를 사용하면 "
"제너레이터의 현재 상태를 쉽게 확인할 수 있습니다."

#: ../../library/inspect.rst:1554
msgid "Get current state of a generator-iterator."
msgstr "제너레이터-이터레이터의 현재 상태를 가져옵니다."

#: ../../library/inspect.rst:1556 ../../library/inspect.rst:1572
#: ../../library/inspect.rst:1589
msgid "Possible states are:"
msgstr "가능한 상태는 다음과 같습니다:"

#: ../../library/inspect.rst:1558
msgid "GEN_CREATED: Waiting to start execution."
msgstr "GEN_CREATED: 실행 시작을 기다리는 중입니다."

#: ../../library/inspect.rst:1559
msgid "GEN_RUNNING: Currently being executed by the interpreter."
msgstr "GEN_RUNNING: 현재 인터프리터에서 실행 중입니다."

#: ../../library/inspect.rst:1560
msgid "GEN_SUSPENDED: Currently suspended at a yield expression."
msgstr "GEN_SUSPENDED: 현재 일드(yield) 표현식에서 일시 중지되었습니다."

#: ../../library/inspect.rst:1561
msgid "GEN_CLOSED: Execution has completed."
msgstr "GEN_CLOSED: 실행이 완료되었습니다."

#: ../../library/inspect.rst:1567
msgid ""
"Get current state of a coroutine object.  The function is intended to be "
"used with coroutine objects created by :keyword:`async def` functions, "
"but will accept any coroutine-like object that has ``cr_running`` and "
"``cr_frame`` attributes."
msgstr ""
"코루틴 객체의 현재 상태를 가져옵니다. 이 함수는 :keyword:`async def` 함수가 만든 코루틴 객체와 함께 사용하기 "
"위한 것이지만, ``cr_running``\\과 ``cr_frame`` 어트리뷰트가 있는 임의의 코루틴류 객체를 허용합니다."

#: ../../library/inspect.rst:1574
msgid "CORO_CREATED: Waiting to start execution."
msgstr "CORO_CREATED: 실행 시작을 기다리는 중입니다."

#: ../../library/inspect.rst:1575
msgid "CORO_RUNNING: Currently being executed by the interpreter."
msgstr "CORO_RUNNING: 현재 인터프리터에서 실행 중입니다."

#: ../../library/inspect.rst:1576
msgid "CORO_SUSPENDED: Currently suspended at an await expression."
msgstr "CORO_SUSPENDED: 현재 어웨이트(await) 표현식에서 일시 중지되었습니다."

#: ../../library/inspect.rst:1577
msgid "CORO_CLOSED: Execution has completed."
msgstr "CORO_CLOSED: 실행이 완료되었습니다."

#: ../../library/inspect.rst:1583
#, fuzzy
msgid ""
"Get current state of an asynchronous generator object.  The function is "
"intended to be used with asynchronous iterator objects created by "
":keyword:`async def` functions which use the :keyword:`yield` statement, "
"but will accept any asynchronous generator-like object that has "
"``ag_running`` and ``ag_frame`` attributes."
msgstr ""
"코루틴 객체의 현재 상태를 가져옵니다. 이 함수는 :keyword:`async def` 함수가 만든 코루틴 객체와 함께 사용하기 "
"위한 것이지만, ``cr_running``\\과 ``cr_frame`` 어트리뷰트가 있는 임의의 코루틴류 객체를 허용합니다."

#: ../../library/inspect.rst:1591
#, fuzzy
msgid "AGEN_CREATED: Waiting to start execution."
msgstr "GEN_CREATED: 실행 시작을 기다리는 중입니다."

#: ../../library/inspect.rst:1592
#, fuzzy
msgid "AGEN_RUNNING: Currently being executed by the interpreter."
msgstr "GEN_RUNNING: 현재 인터프리터에서 실행 중입니다."

#: ../../library/inspect.rst:1593
#, fuzzy
msgid "AGEN_SUSPENDED: Currently suspended at a yield expression."
msgstr "GEN_SUSPENDED: 현재 일드(yield) 표현식에서 일시 중지되었습니다."

#: ../../library/inspect.rst:1594
#, fuzzy
msgid "AGEN_CLOSED: Execution has completed."
msgstr "GEN_CLOSED: 실행이 완료되었습니다."

#: ../../library/inspect.rst:1598
msgid ""
"The current internal state of the generator can also be queried. This is "
"mostly useful for testing purposes, to ensure that internal state is "
"being updated as expected:"
msgstr "제너레이터의 현재 내부 상태도 조회할 수 있습니다. 이는 주로 내부 상태가 예상대로 갱신되었는지 확인하는 테스트 목적으로 유용합니다:"

#: ../../library/inspect.rst:1604
msgid ""
"Get the mapping of live local variables in *generator* to their current "
"values.  A dictionary is returned that maps from variable names to "
"values. This is the equivalent of calling :func:`locals` in the body of "
"the generator, and all the same caveats apply."
msgstr ""
"*generator*\\의 라이브 로컬 변수에서 그것의 현재 값으로의 매핑을 얻습니다. 변수 이름을 값으로 매핑하는 딕셔너리가 "
"반환됩니다. 이것은 제너레이터 바디에서 :func:`locals`\\를 호출하는 것과 동등하며, 같은 경고가 모두 적용됩니다."

#: ../../library/inspect.rst:1609
msgid ""
"If *generator* is a :term:`generator` with no currently associated frame,"
" then an empty dictionary is returned.  :exc:`TypeError` is raised if "
"*generator* is not a Python generator object."
msgstr ""
"*generator*\\가 현재 연결된 프레임이 없는 :term:`제너레이터 <generator>`\\이면, 빈 딕셔너리가 "
"반환됩니다. *generator*\\가 파이썬 제너레이터 객체가 아니면 :exc:`TypeError`\\가 발생합니다."

#: ../../library/inspect.rst:1615
msgid ""
"This function relies on the generator exposing a Python stack frame for "
"introspection, which isn't guaranteed to be the case in all "
"implementations of Python. In such cases, this function will always "
"return an empty dictionary."
msgstr ""
"이 함수는 내부 검사를 위해 파이썬 스택 프레임을 노출하는 제너레이터에 의존하며, 모든 파이썬 구현에서 보장되는 것은 아닙니다. "
"그럴 경우, 이 함수는 항상 빈 딕셔너리를 반환합니다."

#: ../../library/inspect.rst:1624
msgid ""
"This function is analogous to :func:`~inspect.getgeneratorlocals`, but "
"works for coroutine objects created by :keyword:`async def` functions."
msgstr ""
"이 함수는 :func:`~inspect.getgeneratorlocals`\\와 유사하지만, :keyword:`async def` "
"함수가 만든 코루틴 객체에 작동합니다."

#: ../../library/inspect.rst:1631
#, fuzzy
msgid ""
"This function is analogous to :func:`~inspect.getgeneratorlocals`, but "
"works for asynchronous generator objects created by :keyword:`async def` "
"functions which use the :keyword:`yield` statement."
msgstr ""
"이 함수는 :func:`~inspect.getgeneratorlocals`\\와 유사하지만, :keyword:`async def` "
"함수가 만든 코루틴 객체에 작동합니다."

#: ../../library/inspect.rst:1641
msgid "Code Objects Bit Flags"
msgstr "코드 객체 비트 플래그"

#: ../../library/inspect.rst:1643
#, fuzzy
msgid ""
"Python code objects have a :attr:`~codeobject.co_flags` attribute, which "
"is a bitmap of the following flags:"
msgstr "파이썬 코드 객체에는 ``co_flags`` 어트리뷰트가 있으며, 이는 다음 플래그의 비트맵입니다:"

#: ../../library/inspect.rst:1648
msgid "The code object is optimized, using fast locals."
msgstr "코드 객체는 빠른 locals(fast locals)를 사용하여 최적화되었습니다."

#: ../../library/inspect.rst:1652
#, fuzzy
msgid ""
"If set, a new dict will be created for the frame's "
":attr:`~frame.f_locals` when the code object is executed."
msgstr "설정되면, 코드 객체가 실행될 때 프레임의 ``f_locals``\\에 대한 새 딕셔너리가 만들어집니다."

#: ../../library/inspect.rst:1657
msgid "The code object has a variable positional parameter (``*args``-like)."
msgstr "코드 객체에는 (``*args`` 같은) 가변 위치 매개 변수가 있습니다."

#: ../../library/inspect.rst:1661
msgid "The code object has a variable keyword parameter (``**kwargs``-like)."
msgstr "코드 객체에는 (``**kwargs`` 같은) 가변 키워드 매개 변수가 있습니다."

#: ../../library/inspect.rst:1665
msgid "The flag is set when the code object is a nested function."
msgstr "코드 객체가 중첩 함수일 때 이 플래그가 설정됩니다."

#: ../../library/inspect.rst:1669
msgid ""
"The flag is set when the code object is a generator function, i.e. a "
"generator object is returned when the code object is executed."
msgstr "코드 객체가 제너레이터 함수일 때, 즉 코드 객체가 실행될 때 제너레이터 객체를 반환할 때 이 플래그가 설정됩니다."

#: ../../library/inspect.rst:1674
msgid ""
"The flag is set when the code object is a coroutine function. When the "
"code object is executed it returns a coroutine object. See :pep:`492` for"
" more details."
msgstr ""
"코드 객체가 코루틴 함수일 때 이 플래그가 설정됩니다. 코드 객체가 실행될 때 코루틴 객체를 반환합니다. 자세한 내용은 "
":pep:`492`\\를 참조하십시오."

#: ../../library/inspect.rst:1682
msgid ""
"The flag is used to transform generators into generator-based coroutines."
"  Generator objects with this flag can be used in ``await`` expression, "
"and can ``yield from`` coroutine objects. See :pep:`492` for more "
"details."
msgstr ""
"이 플래그는 제너레이터를 제너레이터 기반 코루틴으로 변환하는 데 사용됩니다. 이 플래그가 있는 제너레이터 객체는 ``await`` "
"표현식에 사용될 수 있으며, 코루틴 객체를 ``yield from`` 할 수 있습니다. 자세한 내용은 :pep:`492`\\를 "
"참조하십시오."

#: ../../library/inspect.rst:1691
msgid ""
"The flag is set when the code object is an asynchronous generator "
"function.  When the code object is executed it returns an asynchronous "
"generator object.  See :pep:`525` for more details."
msgstr ""
"코드 객체가 비동기 제너레이터 함수일 때 이 플래그가 설정됩니다. 코드 객체가 실행될 때 비동기 제너레이터 객체가 반환됩니다. "
"자세한 내용은 :pep:`525`\\를 참조하십시오."

#: ../../library/inspect.rst:1698
msgid ""
"The flags are specific to CPython, and may not be defined in other Python"
" implementations.  Furthermore, the flags are an implementation detail, "
"and can be removed or deprecated in future Python releases. It's "
"recommended to use public APIs from the :mod:`inspect` module for any "
"introspection needs."
msgstr ""
"이 플래그들은 CPython에만 해당하며, 다른 파이썬 구현에서는 정의되지 않을 수 있습니다. 또한 플래그는 구현 세부 사항이며, "
"향후 파이썬 배포에서 제거되거나 폐지될 수 있습니다. 모든 내부 검사에는 :mod:`inspect` 모듈의 공개 API를 사용하는 "
"것이 좋습니다."

#: ../../library/inspect.rst:1706
msgid "Buffer flags"
msgstr ""

#: ../../library/inspect.rst:1710
msgid ""
"This is an :class:`enum.IntFlag` that represents the flags that can be "
"passed to the :meth:`~object.__buffer__` method of objects implementing "
"the :ref:`buffer protocol <bufferobjects>`."
msgstr ""

#: ../../library/inspect.rst:1714
msgid "The meaning of the flags is explained at :ref:`buffer-request-types`."
msgstr ""

#: ../../library/inspect.rst:1741
msgid "Command Line Interface"
msgstr "명령 줄 인터페이스"

#: ../../library/inspect.rst:1743
msgid ""
"The :mod:`inspect` module also provides a basic introspection capability "
"from the command line."
msgstr ":mod:`inspect` 모듈은 명령 줄에서 기본 내부 검사 기능을 제공하기도 합니다."

#: ../../library/inspect.rst:1748
msgid ""
"By default, accepts the name of a module and prints the source of that "
"module. A class or function within the module can be printed instead by "
"appended a colon and the qualified name of the target object."
msgstr ""
"기본적으로, 모듈의 이름을 받아들이고 해당 모듈의 소스를 인쇄합니다. 콜론과 대상 객체의 정규화된 이름을 덧붙여, 대신 모듈 내의 "
"클래스나 함수를 인쇄 할 수 있습니다."

#: ../../library/inspect.rst:1754
msgid "Print information about the specified object rather than the source code"
msgstr "소스 코드 대신에 지정된 객체에 대한 정보를 인쇄합니다"

#~ msgid "module"
#~ msgstr "모듈"

#~ msgid "__file__"
#~ msgstr "__file__"

#~ msgid "filename (missing for built-in modules)"
#~ msgstr "파일명 (내장 모듈에는 없습니다)"

#~ msgid "tuple of names of local variables"
#~ msgstr "지역 변수 이름의 튜플"

#~ msgid ""
#~ "Raises :exc:`ValueError` if no signature "
#~ "can be provided, and :exc:`TypeError` if"
#~ " that type of object is not "
#~ "supported."
#~ msgstr ""
#~ "서명을 제공할 수 없으면 :exc:`ValueError`\\가 발생하고,"
#~ " 해당 객체 형이 지원되지 않으면 "
#~ ":exc:`TypeError`\\가 발생합니다."

#~ msgid ""
#~ "Return a :class:`Signature` (or its "
#~ "subclass) object for a given callable"
#~ " ``obj``.  Pass ``follow_wrapped=False`` to "
#~ "get a signature of ``obj`` without "
#~ "unwrapping its ``__wrapped__`` chain."
#~ msgstr ""
#~ "주어진 콜러블 ``obj``\\에 대한 :class:`Signature` "
#~ "(또는 이의 서브 클래스) 객체를 반환합니다. "
#~ "``__wrapped__`` 체인의 래핑을 풀지 않고 ``obj``\\의"
#~ " 서명을 얻으려면 ``follow_wrapped=False``\\를 전달하십시오."

#~ msgid ""
#~ "Get the names and default values "
#~ "of a Python function's parameters. A "
#~ ":term:`named tuple` ``ArgSpec(args, varargs, "
#~ "keywords, defaults)`` is returned. *args* "
#~ "is a list of the parameter names."
#~ " *varargs* and *keywords* are the "
#~ "names of the ``*`` and ``**`` "
#~ "parameters or ``None``. *defaults* is a"
#~ " tuple of default argument values or"
#~ " ``None`` if there are no default "
#~ "arguments; if this tuple has *n* "
#~ "elements, they correspond to the last"
#~ " *n* elements listed in *args*."
#~ msgstr ""
#~ "파이썬 함수 매개 변수의 이름과 기본값을 가져옵니다. "
#~ ":term:`네임드 튜플 <named tuple>` ``ArgSpec(args,"
#~ " varargs, keywords, defaults)``\\가 반환됩니다. "
#~ "*args*\\는 매개 변수 이름의 리스트입니다. *varargs*\\와"
#~ " *keywords*\\는 ``*``\\와 ``**`` 매개 변수의 "
#~ "이름이거나 ``None``\\입니다. *defaults*\\는 기본 인자 "
#~ "값의 튜플이거나 기본 인자가 없으면 ``None``\\입니다; "
#~ "이 튜플에 *n* 개의 요소가 있으면, *args*\\에"
#~ " 나열된 마지막 *n* 요소에 해당합니다."

#~ msgid ""
#~ "Use :func:`getfullargspec` for an updated "
#~ "API that is usually a drop-in "
#~ "replacement, but also correctly handles "
#~ "function annotations and keyword-only "
#~ "parameters."
#~ msgstr ""
#~ "개정된 API의 :func:`getfullargspec`\\을 사용하십시오. 이것은"
#~ " 일반적으로 드롭인 대체이면서, 함수 어노테이션과 키워드 "
#~ "전용 매개 변수도 올바르게 처리합니다."

#~ msgid ""
#~ "Alternatively, use :func:`signature` and "
#~ ":ref:`Signature Object <inspect-signature-"
#~ "object>`, which provide a more "
#~ "structured introspection API for callables."
#~ msgstr ""
#~ "또는, :func:`signature`\\와 :ref:`Signature 객체 "
#~ "<inspect-signature-object>`\\를 사용하십시오. 콜러블에 "
#~ "대한 보다 구조적인 내부 검사(introspection) API를 "
#~ "제공합니다."

#~ msgid ""
#~ "Format a pretty argument spec from "
#~ "the values returned by :func:`getfullargspec`."
#~ msgstr ":func:`getfullargspec` 이 반환한 값으로 예쁜 인자 명세를 포맷합니다."

#~ msgid ""
#~ "The first seven arguments are (``args``,"
#~ " ``varargs``, ``varkw``, ``defaults``, "
#~ "``kwonlyargs``, ``kwonlydefaults``, ``annotations``)."
#~ msgstr ""
#~ "처음 7개의 인자는 (``args``, ``varargs``, "
#~ "``varkw``, ``defaults``, ``kwonlyargs``, "
#~ "``kwonlydefaults``, ``annotations``) 입니다."

#~ msgid ""
#~ "The other six arguments are functions"
#~ " that are called to turn argument "
#~ "names, ``*`` argument name, ``**`` "
#~ "argument name, default values, return "
#~ "annotation and individual annotations into "
#~ "strings, respectively."
#~ msgstr ""
#~ "다른 6개의 인자는 인자 이름, ``*`` 인자 "
#~ "이름, ``**`` 인자 이름, 기본값, 반환 값 "
#~ "어노테이션 및 개별 어노테이션을 각각 문자열로 변환하기 "
#~ "위해 호출되는 함수입니다."

#~ msgid "For example:"
#~ msgstr "예를 들면:"

#~ msgid ""
#~ "Use :func:`signature` and :ref:`Signature "
#~ "Object <inspect-signature-object>`, which "
#~ "provide a better introspecting API for"
#~ " callables."
#~ msgstr ""
#~ ":func:`signature`\\와 :ref:`Signature 객체 <inspect-"
#~ "signature-object>`\\를 사용하십시오. 콜러블에 대한 더"
#~ " 나은 내부 검사 API를 제공합니다."

#~ msgid ""
#~ "When the following functions return "
#~ "\"frame records,\" each record is a "
#~ ":term:`named tuple` ``FrameInfo(frame, filename, "
#~ "lineno, function, code_context, index)``. The"
#~ " tuple contains the frame object, the"
#~ " filename, the line number of the "
#~ "current line, the function name, a "
#~ "list of lines of context from the"
#~ " source code, and the index of "
#~ "the current line within that list."
#~ msgstr ""
#~ "다음 함수가 \"프레임 레코드\"를 반환할 때, 각 "
#~ "레코드는 :term:`네임드 튜플 <named tuple>` "
#~ "``FrameInfo(frame, filename, lineno, function, "
#~ "code_context, index)``\\입니다. 튜플에는 프레임 객체, "
#~ "파일명, 현재 줄의 줄 번호, 함수 이름, 소스"
#~ " 코드의 문맥(context) 줄 리스트 및 그 리스트"
#~ " 내에서의 현재 줄의 인덱스가 포함됩니다."

#~ msgid "The flag is set if there are no free or cell variables."
#~ msgstr "자유 변수(free variable)와 셀 변수(cell variable)가 없으면 이 플래그가 설정됩니다."

