# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/email.compat32-message.rst:4
msgid ""
":mod:`email.message.Message`: Representing an email message using the "
":data:`~email.policy.compat32` API"
msgstr ""
":mod:`email.message.Message`: :data:`~email.policy.compat32` API를 사용하여 "
"이메일 메시지 표현하기"

#: ../../library/email.compat32-message.rst:13
msgid ""
"The :class:`Message` class is very similar to the "
":class:`~email.message.EmailMessage` class, without the methods added by "
"that class, and with the default behavior of certain other methods being "
"slightly different.  We also document here some methods that, while "
"supported by the :class:`~email.message.EmailMessage` class, are not "
"recommended unless you are dealing with legacy code."
msgstr ""
":class:`Message` 클래스는 :class:`~email.message.EmailMessage` 클래스와 매우 유사지만, "
"이 클래스에 의해 추가된 메서드가 없고, 다른 특정 메서드의 기본 동작이 약간 다릅니다. 또한 "
":class:`~email.message.EmailMessage` 클래스에서 지원하지만, 레거시 코드를 다루지 않는 한 권장되지 "
"않는 일부 메서드도 여기에서 설명합니다."

#: ../../library/email.compat32-message.rst:20
msgid "The philosophy and structure of the two classes is otherwise the same."
msgstr "두 클래스의 철학과 구조는 그 외에는 같습니다."

#: ../../library/email.compat32-message.rst:22
msgid ""
"This document describes the behavior under the default (for "
":class:`Message`) policy :attr:`~email.policy.Compat32`.  If you are "
"going to use another policy, you should be using the "
":class:`~email.message.EmailMessage` class instead."
msgstr ""
"이 문서는 기본 (:class:`Message`\\의 경우) 정책 :attr:`~email.policy.Compat32`\\의 "
"동작을 설명합니다. 다른 정책을 사용하려면, :class:`~email.message.EmailMessage` 클래스를 대신 "
"사용해야 합니다."

#: ../../library/email.compat32-message.rst:26
msgid ""
"An email message consists of *headers* and a *payload*.  Headers must be "
":rfc:`5322` style names and values, where the field name and value are "
"separated by a colon.  The colon is not part of either the field name or "
"the field value.  The payload may be a simple text message, or a binary "
"object, or a structured sequence of sub-messages each with their own set "
"of headers and their own payload.  The latter type of payload is "
"indicated by the message having a MIME type such as "
":mimetype:`multipart/\\*` or :mimetype:`message/rfc822`."
msgstr ""
"이메일 메시지는 *헤더(headers)*\\와 *페이 로드(payload)*\\로 구성됩니다. 헤더는 :rfc:`5322` 스타일 "
"이름과 값이어야 하며, 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름이나 필드 값의 일부가 아닙니다. 페이 로드는 간단한"
" 텍스트 메시지, 바이너리 객체 또는 각각 자체 헤더 집합과 자체 페이 로드가 있는 서브 메시지의 구조화된 시퀀스일 수 있습니다. "
"후자의 페이 로드 유형은 :mimetype:`multipart/\\*`\\나 :mimetype:`message/rfc822`\\와 "
"같은 MIME 유형을 가진 메시지로 표시됩니다."

#: ../../library/email.compat32-message.rst:35
msgid ""
"The conceptual model provided by a :class:`Message` object is that of an "
"ordered dictionary of headers with additional methods for accessing both "
"specialized information from the headers, for accessing the payload, for "
"generating a serialized version of the message, and for recursively "
"walking over the object tree.  Note that duplicate headers are supported "
"but special methods must be used to access them."
msgstr ""
":class:`Message` 객체가 제공하는 개념 모델은 헤더의 순서 있는 딕셔너리이면서, 헤더의 특수 정보에 액세스하고, 페이 "
"로드에 액세스하고, 메시지의 직렬화된 버전을 생성하고, 객체 트리를 재귀적으로 탐색하기 위한 추가 메서드가 제공되는 것입니다. 중복"
" 헤더가 지원되지만, 특수한 메서드를 사용하여 액세스해야 함에 유의하십시오."

#: ../../library/email.compat32-message.rst:42
msgid ""
"The :class:`Message` pseudo-dictionary is indexed by the header names, "
"which must be ASCII values.  The values of the dictionary are strings "
"that are supposed to contain only ASCII characters; there is some special"
" handling for non-ASCII input, but it doesn't always produce the correct "
"results.  Headers are stored and returned in case-preserving form, but "
"field names are matched case-insensitively.  There may also be a single "
"envelope header, also known as the *Unix-From* header or the ``From_`` "
"header.  The *payload* is either a string or bytes, in the case of simple"
" message objects, or a list of :class:`Message` objects, for MIME "
"container documents (e.g. :mimetype:`multipart/\\*` and "
":mimetype:`message/rfc822`)."
msgstr ""
":class:`Message` 의사 딕셔너리는 헤더 이름으로 인덱싱되며, ASCII 값이어야 합니다. 딕셔너리의 값은 ASCII "
"문자만 포함해야 하는 문자열입니다; 비 ASCII 입력에 대한 특수 처리가 있지만, 항상 올바른 결과를 생성하지는 않습니다. 헤더는"
" 대소 문자를 유지하면서 저장되고 반환되지만, 필드 이름은 대소 문자를 구분하지 않고 일치합니다. *Unix-From* 헤더나 "
"``From_`` 헤더라고도 하는 단일 봉투 헤더가 있을 수도 있습니다. *페이 로드(payload)*\\는 단순 메시지 객체의 "
"경우는 문자열이나 바이트열이고, MIME 컨테이너 문서(예를 들어 :mimetype:`multipart/\\*`\\와 "
":mimetype:`message/rfc822`)의 경우는 :class:`Message` 객체의 리스트입니다."

#: ../../library/email.compat32-message.rst:53
msgid "Here are the methods of the :class:`Message` class:"
msgstr ":class:`Message` 클래스의 메서드는 다음과 같습니다:"

#: ../../library/email.compat32-message.rst:58
msgid ""
"If *policy* is specified (it must be an instance of a "
":mod:`~email.policy` class) use the rules it specifies to update and "
"serialize the representation of the message.  If *policy* is not set, use"
" the :class:`compat32 <email.policy.Compat32>` policy, which maintains "
"backward compatibility with the Python 3.2 version of the email package."
"  For more information see the :mod:`~email.policy` documentation."
msgstr ""
"*policy*\\가 지정되면 (:mod:`~email.policy` 클래스의 인스턴스여야 합니다) 메시지 표현을 갱신하고 "
"직렬화하기 위해 지정된 규칙을 사용합니다. *policy*\\가 설정되지 않으면, :class:`compat32 "
"<email.policy.Compat32>` 정책을 사용하는데, 파이썬 3.2 버전의 email 패키지와의 과거 호환성을 "
"유지합니다. 자세한 내용은 :mod:`~email.policy` 설명서를 참조하십시오."

#: ../../library/email.compat32-message.rst:65
msgid "The *policy* keyword argument was added."
msgstr "*policy* 키워드 인자가 추가되었습니다."

#: ../../library/email.compat32-message.rst:70
msgid ""
"Return the entire message flattened as a string.  When optional "
"*unixfrom* is true, the envelope header is included in the returned "
"string. *unixfrom* defaults to ``False``.  For backward compatibility "
"reasons, *maxheaderlen* defaults to ``0``, so if you want a different "
"value you must override it explicitly (the value specified for "
"*max_line_length* in the policy will be ignored by this method).  The "
"*policy* argument may be used to override the default policy obtained "
"from the message instance. This can be used to control some of the "
"formatting produced by the method, since the specified *policy* will be "
"passed to the ``Generator``."
msgstr ""
"평활화된 전체 메시지를 문자열로 반환합니다. 선택적 *unixfrom*\\이 참이면, 봉투 헤더가 반환된 문자열에 포함됩니다. "
"*unixfrom*\\의 기본값은 ``False``\\입니다. 이전 버전과의 호환성을 위해, *maxheaderlen*\\의 "
"기본값이 ``0``\\이라서 다른 값을 원하면 명시적으로 재정의해야 합니다 (정책에서 *max_line_length*\\에 지정된 "
"값은 이 메서드가 무시합니다). *policy* 인자는 메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. "
"지정된 *policy*\\가 ``Generator``\\로 전달되므로, 메서드에서 생성된 일부 포매팅을 제어하는 데 사용할 수 "
"있습니다."

#: ../../library/email.compat32-message.rst:80
#: ../../library/email.compat32-message.rst:122
msgid ""
"Flattening the message may trigger changes to the :class:`Message` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"문자열로의 변환을 완료하기 위해 기본값을 채워야 하면 메시지 평활화는 :class:`Message`\\에 대한 변경을 유발할 수 "
"있습니다 (예를 들어, MIME 경계가 생성되거나 수정될 수 있습니다)."

#: ../../library/email.compat32-message.rst:84
msgid ""
"Note that this method is provided as a convenience and may not always "
"format the message the way you want.  For example, by default it does not"
" do the mangling of lines that begin with ``From`` that is required by "
"the Unix mbox format.  For more flexibility, instantiate a "
":class:`~email.generator.Generator` instance and use its "
":meth:`~email.generator.Generator.flatten` method directly.  For "
"example::"
msgstr ""
"이 메서드는 편의상 제공되며 원하는 방식으로 메시지를 항상 포맷하지는 않음에 유의하십시오. 예를 들어, 기본적으로 유닉스 mbox "
"형식에 필요한 ``From``\\으로 시작하는 줄을 맹글링(mangling)하지 않습니다. 유연성을 높이려면, "
":class:`~email.generator.Generator` 인스턴스를 인스턴스 화하고 그것의 "
":meth:`~email.generator.Generator.flatten` 메서드를 직접 사용하십시오. 예를 들면::"

#: ../../library/email.compat32-message.rst:91
msgid ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

#: ../../library/email.compat32-message.rst:98
msgid ""
"If the message object contains binary data that is not encoded according "
"to RFC standards, the non-compliant data will be replaced by unicode "
"\"unknown character\" code points.  (See also :meth:`.as_bytes` and "
":class:`~email.generator.BytesGenerator`.)"
msgstr ""
"메시지 객체가 RFC 표준에 따라 인코딩되지 않은 바이너리 데이터를 포함하면, 비 호환 데이터는 유니코드 \"unknown "
"character\" 코드 포인트로 대체됩니다. (:meth:`.as_bytes`\\와 "
":class:`~email.generator.BytesGenerator`\\도 참조하십시오.)"

#: ../../library/email.compat32-message.rst:103
msgid "the *policy* keyword argument was added."
msgstr "*policy* 키워드 인자가 추가되었습니다."

#: ../../library/email.compat32-message.rst:108
msgid ""
"Equivalent to :meth:`.as_string`.  Allows ``str(msg)`` to produce a "
"string containing the formatted message."
msgstr ""
":meth:`.as_string`\\과 동등합니다. ``str(msg)``\\가 포맷된 메시지를 포함하는 문자열을 생성할 수 있도록"
" 합니다."

#: ../../library/email.compat32-message.rst:114
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned "
"string.  *unixfrom* defaults to ``False``.  The *policy* argument may be "
"used to override the default policy obtained from the message instance. "
"This can be used to control some of the formatting produced by the "
"method, since the specified *policy* will be passed to the "
"``BytesGenerator``."
msgstr ""
"평활화된 전체 메시지를 바이트열 객체로 반환합니다. 선택적 *unixfrom*\\이 참이면, 봉투 헤더가 반환된 문자열에 "
"포함됩니다. *unixfrom*\\의 기본값은 ``False``\\입니다. *policy* 인자는 메시지 인스턴스에서 얻은 기본 "
"정책을 대체하는 데 사용될 수 있습니다. 지정된 *policy*\\가 ``BytesGenerator``\\로 전달되므로, 메서드에서"
" 생성된 일부 포매팅을 제어하는 데 사용할 수 있습니다."

#: ../../library/email.compat32-message.rst:126
msgid ""
"Note that this method is provided as a convenience and may not always "
"format the message the way you want.  For example, by default it does not"
" do the mangling of lines that begin with ``From`` that is required by "
"the Unix mbox format.  For more flexibility, instantiate a "
":class:`~email.generator.BytesGenerator` instance and use its "
":meth:`~email.generator.BytesGenerator.flatten` method directly. For "
"example::"
msgstr ""
"이 메서드는 편의상 제공되며 원하는 방식으로 메시지를 항상 포맷하지는 않음에 유의하십시오. 예를 들어, 기본적으로 유닉스 mbox "
"형식에 필요한 ``From``\\으로 시작하는 줄을 맹글링(mangling)하지 않습니다. 유연성을 높이려면, "
":class:`~email.generator.BytesGenerator` 인스턴스를 인스턴스 화하고 그것의 "
":meth:`~email.generator.BytesGenerator.flatten` 메서드를 직접 사용하십시오. 예를 들면::"

#: ../../library/email.compat32-message.rst:134
msgid ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

#: ../../library/email.compat32-message.rst:146
msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a "
"bytes object containing the formatted message."
msgstr ""
":meth:`.as_bytes`\\와 동등합니다. ``bytes(msg)``\\가 포맷된 메시지를 포함하는 바이트열 객체를 생성할 "
"수 있도록 합니다."

#: ../../library/email.compat32-message.rst:154
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ "
":class:`Message` objects, otherwise return ``False``.  When "
":meth:`is_multipart` returns ``False``, the payload should be a string "
"object (which might be a CTE encoded binary payload).  (Note that "
":meth:`is_multipart` returning ``True`` does not necessarily mean that "
"\"msg.get_content_maintype() == 'multipart'\" will return the ``True``. "
"For example, ``is_multipart`` will return ``True`` when the "
":class:`Message` is of type ``message/rfc822``.)"
msgstr ""
"메시지의 페이 로드가 서브-\\ :class:`Message` 객체의 리스트이면 ``True``\\를, 그렇지 않으면 "
"``False``\\를 반환합니다. :meth:`is_multipart`\\가 ``False``\\를 반환할 때, 페이 로드는 "
"문자열 객체(CTE로 인코딩된 바이너리 페이 로드일 수 있습니다)여야 합니다. (``True``\\를 반환하는 "
":meth:`is_multipart`\\가 반드시 \"msg.get_content_maintype() == 'multipart'\""
" 가 ``True``\\를 반환한다는 것을 의미하지는 않습니다. 예를 들어, :class:`Message`\\가 "
"``message/rfc822`` 유형일 때, ``is_multipart``\\는 ``True``\\를 반환합니다."

#: ../../library/email.compat32-message.rst:166
msgid "Set the message's envelope header to *unixfrom*, which should be a string."
msgstr "메시지의 봉투 헤더를 (문자열이어야 하는) *unixfrom*\\으로 설정합니다."

#: ../../library/email.compat32-message.rst:171
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the "
"envelope header was never set."
msgstr "메시지의 봉투 헤더를 반환합니다. 봉투 헤더가 설정되지 않았으면 기본값은 ``None``\\입니다."

#: ../../library/email.compat32-message.rst:177
msgid ""
"Add the given *payload* to the current payload, which must be ``None`` or"
" a list of :class:`Message` objects before the call. After the call, the "
"payload will always be a list of :class:`Message` objects.  If you want "
"to set the payload to a scalar object (e.g. a string), use "
":meth:`set_payload` instead."
msgstr ""
"지정된 *payload*\\를 현재 페이 로드에 추가합니다. 호출 전에는 페이 로드가 ``None``\\이나 "
":class:`Message` 객체의 리스트여야 합니다. 호출 후에는 페이 로드가 항상 :class:`Message` 객체의 "
"리스트입니다. 페이 로드를 스칼라 객체(예를 들어 문자열)로 설정하려면, :meth:`set_payload`\\를 대신 "
"사용하십시오."

#: ../../library/email.compat32-message.rst:183
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class its functionality is "
"replaced by :meth:`~email.message.EmailMessage.set_content` and the "
"related ``make`` and ``add`` methods."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서 해당 기능은 "
":meth:`~email.message.EmailMessage.set_content`\\와 관련 ``make``\\와 ``add``"
" 메서드로 대체됩니다."

#: ../../library/email.compat32-message.rst:191
msgid ""
"Return the current payload, which will be a list of :class:`Message` "
"objects when :meth:`is_multipart` is ``True``, or a string when "
":meth:`is_multipart` is ``False``.  If the payload is a list and you "
"mutate the list object, you modify the message's payload in place."
msgstr ""
"현재 페이 로드를 반환합니다. :meth:`is_multipart`\\가 ``True``\\이면 :class:`Message` "
"객체의 리스트이고, :meth:`is_multipart`\\가 ``False``\\이면 문자열입니다. 페이 로드가 리스트이고 리스트"
" 객체를 변경하면, 메시지의 페이 로드를 제자리에서 수정하는 것입니다."

#: ../../library/email.compat32-message.rst:196
msgid ""
"With optional argument *i*, :meth:`get_payload` will return the *i*-th "
"element of the payload, counting from zero, if :meth:`is_multipart` is "
"``True``.  An :exc:`IndexError` will be raised if *i* is less than 0 or "
"greater than or equal to the number of items in the payload.  If the "
"payload is a string (i.e.  :meth:`is_multipart` is ``False``) and *i* is "
"given, a :exc:`TypeError` is raised."
msgstr ""
"선택적 인자 *i*\\를 사용하면, :meth:`get_payload`\\는 :meth:`is_multipart`\\가 "
"``True``\\일 때, 페이 로드의 *i* 번째 요소를 0부터 세어 반환합니다. *i*\\가 0보다 작거나 페이 로드의 항목 "
"수보다 크거나 같으면 :exc:`IndexError`\\가 발생합니다. 페이 로드가 문자열이고 (즉 "
":meth:`is_multipart`\\가 ``False``) *i*\\가 제공되면, :exc:`TypeError`\\가 "
"발생합니다."

#: ../../library/email.compat32-message.rst:203
msgid ""
"Optional *decode* is a flag indicating whether the payload should be "
"decoded or not, according to the :mailheader:`Content-Transfer-Encoding` "
"header. When ``True`` and the message is not a multipart, the payload "
"will be decoded if this header's value is ``quoted-printable`` or "
"``base64``. If some other encoding is used, or :mailheader:`Content-"
"Transfer-Encoding` header is missing, the payload is returned as-is "
"(undecoded).  In all cases the returned value is binary data.  If the "
"message is a multipart and the *decode* flag is ``True``, then ``None`` "
"is returned.  If the payload is base64 and it was not perfectly formed "
"(missing padding, characters outside the base64 alphabet), then an "
"appropriate defect will be added to the message's defect property "
"(:class:`~email.errors.InvalidBase64PaddingDefect` or "
":class:`~email.errors.InvalidBase64CharactersDefect`, respectively)."
msgstr ""
"선택적 *decode*\\는 :mailheader:`Content-Transfer-Encoding` 헤더에 따라 페이 로드를 "
"디코딩해야 하는지를 나타내는 플래그입니다. ``True``\\이고 메시지가 멀티 파트가 아닐 때, 이 헤더 값이 ``quoted-"
"printable``\\이나 ``base64``\\이면 페이 로드가 디코딩됩니다. 다른 인코딩이 사용되거나 :mailheader"
":`Content-Transfer-Encoding` 헤더가 누락되면, 페이 로드는 그대로 (디코딩되지 않고) 반환됩니다. 모든 "
"경우에 반환된 값은 바이너리 데이터입니다. 메시지가 멀티 파트이고 *decode* 플래그가 ``True``\\이면, "
"``None``\\이 반환됩니다. 페이 로드가 base64이고 완벽하게 구성되지 않았으면 (패딩 누락, base64 알파벳 이외의 "
"문자), 메시지의 결함 프로퍼티에 적절한 결함이 추가됩니다 (각각 "
":class:`~email.errors.InvalidBase64PaddingDefect`\\나 "
":class:`~email.errors.InvalidBase64CharactersDefect`)."

#: ../../library/email.compat32-message.rst:217
msgid ""
"When *decode* is ``False`` (the default) the body is returned as a string"
" without decoding the :mailheader:`Content-Transfer-Encoding`.  However, "
"for a :mailheader:`Content-Transfer-Encoding` of 8bit, an attempt is made"
" to decode the original bytes using the ``charset`` specified by the "
":mailheader:`Content-Type` header, using the ``replace`` error handler. "
"If no ``charset`` is specified, or if the ``charset`` given is not "
"recognized by the email package, the body is decoded using the default "
"ASCII charset."
msgstr ""
"*decode*\\가 ``False``\\(기본값)일 때 본문은 :mailheader:`Content-Transfer-"
"Encoding`\\을 디코딩하지 않고 문자열로 반환됩니다. 그러나, :mailheader:`Content-Transfer-"
"Encoding`\\이 8비트인 경우, ``replace`` 에러 처리기로, :mailheader:`Content-Type` 헤더에"
" 지정된 ``charset``\\을 사용하여 원래 바이트를 디코딩하려고 시도합니다. ``charset``\\이 지정되지 않았거나 "
"email 패키지가 ``charset``\\을 인식하지 못하면, 본문은 기본 ASCII 문자 집합을 사용하여 디코딩됩니다."

#: ../../library/email.compat32-message.rst:226
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class its functionality is "
"replaced by :meth:`~email.message.EmailMessage.get_content` and "
":meth:`~email.message.EmailMessage.iter_parts`."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서는 해당 기능이 "
":meth:`~email.message.EmailMessage.get_content`\\와 "
":meth:`~email.message.EmailMessage.iter_parts`\\로 대체되었습니다."

#: ../../library/email.compat32-message.rst:234
msgid ""
"Set the entire message object's payload to *payload*.  It is the client's"
" responsibility to ensure the payload invariants.  Optional *charset* "
"sets the message's default character set; see :meth:`set_charset` for "
"details."
msgstr ""
"전체 메시지 객체의 페이 로드를 *payload*\\로 설정합니다. 페이 로드 불변량(invariants)을 보장하는 것은 고객의 "
"책임입니다. 선택적 *charset*\\은 메시지의 기본 문자 집합을 설정합니다; 자세한 내용은 "
":meth:`set_charset`\\을 참조하십시오."

#: ../../library/email.compat32-message.rst:238
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class its functionality is "
"replaced by :meth:`~email.message.EmailMessage.set_content`."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서는 해당 기능이 "
":meth:`~email.message.EmailMessage.set_content`\\로 대체되었습니다."

#: ../../library/email.compat32-message.rst:245
msgid ""
"Set the character set of the payload to *charset*, which can either be a "
":class:`~email.charset.Charset` instance (see :mod:`email.charset`), a "
"string naming a character set, or ``None``.  If it is a string, it will "
"be converted to a :class:`~email.charset.Charset` instance.  If *charset*"
" is ``None``, the ``charset`` parameter will be removed from the "
":mailheader:`Content-Type` header (the message will not be otherwise "
"modified).  Anything else will generate a :exc:`TypeError`."
msgstr ""
"페이 로드의 문자 집합을 *charset*\\으로 설정합니다. 이는 :class:`~email.charset.Charset` "
"인스턴스 (:mod:`email.charset`\\을 참조하십시오), 문자 집합의 이름을 지정하는 문자열 또는 ``None``\\일"
" 수 있습니다. 문자열이면, :class:`~email.charset.Charset` 인스턴스로 변환됩니다. *charset*\\이"
" ``None``\\이면, ``charset`` 매개 변수가 :mailheader:`Content-Type` 헤더에서 제거됩니다 "
"(그렇지 않으면 메시지가 수정되지 않습니다). 그 외의 경우는 :exc:`TypeError`\\를 생성합니다."

#: ../../library/email.compat32-message.rst:253
msgid ""
"If there is no existing :mailheader:`MIME-Version` header one will be "
"added.  If there is no existing :mailheader:`Content-Type` header, one "
"will be added with a value of :mimetype:`text/plain`.  Whether the "
":mailheader:`Content-Type` header already exists or not, its ``charset`` "
"parameter will be set to *charset.output_charset*.   If "
"*charset.input_charset* and *charset.output_charset* differ, the payload "
"will be re-encoded to the *output_charset*.  If there is no existing "
":mailheader:`Content-Transfer-Encoding` header, then the payload will be "
"transfer-encoded, if needed, using the specified "
":class:`~email.charset.Charset`, and a header with the appropriate value "
"will be added.  If a :mailheader:`Content-Transfer-Encoding` header "
"already exists, the payload is assumed to already be correctly encoded "
"using that :mailheader:`Content-Transfer-Encoding` and is not modified."
msgstr ""
"기존 :mailheader:`MIME-Version` 헤더가 없으면 추가됩니다. 기존 :mailheader:`Content-"
"Type` 헤더가 없으면, :mimetype:`text/plain` 값으로 추가됩니다. :mailheader:`Content-"
"Type` 헤더가 존재하는지와 관계없이, ``charset`` 매개 변수는 *charset.output_charset*\\으로 "
"설정됩니다. *charset.input_charset*\\과 *charset.output_charset*\\이 다르면, 페이 로드가"
" *output_charset*\\으로 다시 인코딩됩니다. 기존 :mailheader:`Content-Transfer-"
"Encoding` 헤더가 없으면, 필요하면 지정된 :class:`~email.charset.Charset`\\을 사용하여 페이 "
"로드가 전송 인코딩되고(transfer-encoded), 적절한 값을 가진 헤더가 추가됩니다. :mailheader"
":`Content-Transfer-Encoding` 헤더가 이미 존재하면, 페이 로드는 해당 :mailheader:`Content-"
"Transfer-Encoding`\\을 사용하여 이미 올바르게 인코딩된 것으로 가정하며 수정하지 않습니다."

#: ../../library/email.compat32-message.rst:267
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class its functionality is "
"replaced by the *charset* parameter of the "
":meth:`email.emailmessage.EmailMessage.set_content` method."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서 해당 기능은 "
":meth:`email.emailmessage.EmailMessage.set_content` 메서드의 *charset* 매개 변수로"
" 대체됩니다."

#: ../../library/email.compat32-message.rst:275
msgid ""
"Return the :class:`~email.charset.Charset` instance associated with the "
"message's payload."
msgstr "메시지 페이 로드와 연관된 :class:`~email.charset.Charset` 인스턴스를 반환합니다."

#: ../../library/email.compat32-message.rst:278
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class it always returns "
"``None``."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서는 항상 "
"``None``\\을 반환합니다."

#: ../../library/email.compat32-message.rst:283
msgid ""
"The following methods implement a mapping-like interface for accessing "
"the message's :rfc:`2822` headers.  Note that there are some semantic "
"differences between these methods and a normal mapping (i.e. dictionary) "
"interface.  For example, in a dictionary there are no duplicate keys, but"
" here there may be duplicate message headers.  Also, in dictionaries "
"there is no guaranteed order to the keys returned by :meth:`keys`, but in"
" a :class:`Message` object, headers are always returned in the order they"
" appeared in the original message, or were added to the message later.  "
"Any header deleted and then re-added are always appended to the end of "
"the header list."
msgstr ""
"다음 메서드는 메시지의 :rfc:`2822` 헤더에 액세스하기 위한 매핑과 유사한 인터페이스를 구현합니다. 이 메서드들과 일반적인 "
"매핑 (즉, 딕셔너리) 인터페이스 사이에는 의미상 차이가 있습니다. 예를 들어, 딕셔너리에는 중복 키가 없지만, 여기에는 중복 "
"메시지 헤더가 있을 수 있습니다. 또한, 딕셔너리에서는 :meth:`keys`\\가 반환하는 키의 순서가 보장되지 않지만, "
":class:`Message` 객체에서는 헤더가 항상 원래 메시지에 나타나거나 나중에 메시지에 추가된 순서대로 반환됩니다. 삭제한 "
"후 다시 추가된 헤더는 항상 헤더 리스트의 끝에 추가됩니다."

#: ../../library/email.compat32-message.rst:293
msgid ""
"These semantic differences are intentional and are biased toward maximal "
"convenience."
msgstr "이러한 의미상 차이는 의도적이며 최대한의 편의를 위해 편향되어 있습니다."

#: ../../library/email.compat32-message.rst:296
msgid ""
"Note that in all cases, any envelope header present in the message is not"
" included in the mapping interface."
msgstr "모든 경우에, 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되지 않습니다."

#: ../../library/email.compat32-message.rst:299
msgid ""
"In a model generated from bytes, any header values that (in contravention"
" of the RFCs) contain non-ASCII bytes will, when retrieved through this "
"interface, be represented as :class:`~email.header.Header` objects with a"
" charset of ``unknown-8bit``."
msgstr ""
"바이트열에서 생성된 모델에서, (RFC에 반하여) 비 ASCII 바이트를 포함하는 헤더 값은, 이 인터페이스를 통해 꺼낼 때, 문자"
" 집합이 ``unknown-8bit``\\인 :class:`~email.header.Header` 객체로 표시됩니다."

#: ../../library/email.compat32-message.rst:307
msgid "Return the total number of headers, including duplicates."
msgstr "중복을 포함하여, 총 헤더 수를 반환합니다."

#: ../../library/email.compat32-message.rst:312
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching "
"is done case-insensitively and *name* should not include the trailing "
"colon. Used for the ``in`` operator, e.g.::"
msgstr ""
"메시지 객체에 *name*\\이라는 이름의 필드가 있으면 ``True``\\를 반환합니다. 대소 문자를 구분하지 않고 일치하며 "
"*name*\\은 후행 콜론을 포함하지 않아야 합니다. ``in`` 연산자에 사용됩니다, 예를 들어::"

#: ../../library/email.compat32-message.rst:316
msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"

#: ../../library/email.compat32-message.rst:322
msgid ""
"Return the value of the named header field.  *name* should not include "
"the colon field separator.  If the header is missing, ``None`` is "
"returned; a :exc:`KeyError` is never raised."
msgstr ""
"명명된 헤더 필드의 값을 반환합니다. *name*\\은 콜론 필드 구분자를 포함하지 않아야 합니다. 헤더가 없으면, "
"``None``\\이 반환됩니다; :exc:`KeyError`\\는 절대 발생하지 않습니다."

#: ../../library/email.compat32-message.rst:326
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is "
"undefined.  Use the :meth:`get_all` method to get the values of all the "
"extant named headers."
msgstr ""
"이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면, 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. "
"기존의 모든 명명된 헤더의 값을 가져오려면 :meth:`get_all` 메서드를 사용하십시오."

#: ../../library/email.compat32-message.rst:334
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing fields."
msgstr "메시지에 필드 이름이 *name*\\이고 값이 *val*\\인 헤더를 추가합니다. 필드는 메시지의 기존 필드 끝에 추가됩니다."

#: ../../library/email.compat32-message.rst:337
msgid ""
"Note that this does *not* overwrite or delete any existing header with "
"the same name.  If you want to ensure that the new header is the only one"
" present in the message with field name *name*, delete the field first, "
"e.g.::"
msgstr ""
"이것이 같은 이름을 가진 기존 헤더를 덮어쓰거나 삭제하지 *않음에* 유의하십시오. 새 헤더가 메시지에 필드 이름이 *name*\\인"
" 유일한 헤더가 되도록 하려면, 먼저 필드를 삭제하십시오. 예를 들어::"

#: ../../library/email.compat32-message.rst:341
msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"

#: ../../library/email.compat32-message.rst:347
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr "메시지 헤더에서 이름이 *name*\\인 모든 필드를 삭제합니다. 명명된 필드가 헤더에 없어도 예외가 발생하지 않습니다."

#: ../../library/email.compat32-message.rst:354
msgid "Return a list of all the message's header field names."
msgstr "메시지 헤더의 모든 필드 이름의 리스트를 반환합니다."

#: ../../library/email.compat32-message.rst:359
msgid "Return a list of all the message's field values."
msgstr "메시지의 모든 필드 값의 리스트를 반환합니다."

#: ../../library/email.compat32-message.rst:364
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr "메시지의 모든 필드 헤더와 값을 포함하는 2-튜플의 리스트를 반환합니다."

#: ../../library/email.compat32-message.rst:370
msgid ""
"Return the value of the named header field.  This is identical to "
":meth:`~object.__getitem__` except that optional *failobj* is returned if"
" the named header is missing (defaults to ``None``)."
msgstr ""
"명명된 헤더 필드의 값을 반환합니다. 명명된 헤더가 없으면 선택적 *failobj*\\가 반환된다는 점을 제외하고는 "
":meth:`~object.__getitem__`\\과 동일합니다 (기본값은 ``None``\\입니다)."

#: ../../library/email.compat32-message.rst:374
msgid "Here are some additional useful methods:"
msgstr "몇 가지 유용한 추가 메서드가 있습니다:"

#: ../../library/email.compat32-message.rst:379
msgid ""
"Return a list of all the values for the field named *name*. If there are "
"no such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"*name*\\이라는 필드의 모든 값 리스트를 반환합니다. 메시지에 이런 이름의 헤더가 없으면, *failobj*\\가 반환됩니다 "
"(기본값은 ``None``\\입니다)."

#: ../../library/email.compat32-message.rst:386
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the "
"*primary* value for the header."
msgstr ""
"확장된 헤더 설정. 이 메서드는 추가 헤더 매개 변수가 키워드 인자로 제공될 수 있다는 점을 제외하고는 "
":meth:`__setitem__`\\과 유사합니다. *_name*\\은 추가할 헤더 필드이고 *_value*\\는 헤더의 "
"*기본(primary)*\\값입니다."

#: ../../library/email.compat32-message.rst:391
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is "
"taken as the parameter name, with underscores converted to dashes (since "
"dashes are illegal in Python identifiers).  Normally, the parameter will "
"be added as ``key=\"value\"`` unless the value is ``None``, in which case"
" only the key will be added.  If the value contains non-ASCII characters,"
" it can be specified as a three tuple in the format ``(CHARSET, LANGUAGE,"
" VALUE)``, where ``CHARSET`` is a string naming the charset to be used to"
" encode the value, ``LANGUAGE`` can usually be set to ``None`` or the "
"empty string (see :rfc:`2231` for other possibilities), and ``VALUE`` is "
"the string value containing non-ASCII code points.  If a three tuple is "
"not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of "
"``utf-8`` and a ``LANGUAGE`` of ``None``."
msgstr ""
"키워드 인자 딕셔너리 *_params*\\의 각 항목에 대해, 키는 매개 변수 이름으로 사용되며, 밑줄은 대시로 변환됩니다 (대시는"
" 파이썬 식별자로 유효하지 않기 때문입니다). 일반적으로, 값이 ``None``\\이 아니면 매개 변수가 "
"``key=\"value\"``\\로 추가되며, ``None``\\이면 키만 추가됩니다. 값에 ASCII가 아닌 문자가 포함되면, "
"``(CHARSET, LANGUAGE, VALUE)`` 형식으로 3-튜플로 지정할 수 있습니다. 여기서 ``CHARSET``\\은 "
"값을 인코딩하는 데 사용할 문자 집합의 이름을 지정하는 문자열이고, ``LANGUAGE``\\는 일반적으로 ``None``\\이나 "
"빈 문자열(다른 가능성에 대해서는 :rfc:`2231`\\을 참조하십시오)로 설정될 수 있고, ``VALUE``\\는 비 ASCII"
" 코드 포인트를 포함하는 문자열 값입니다. 3-튜플이 전달되지 않고 값에 ASCII가 아닌 문자가 포함되면, "
"``CHARSET``\\으로 ``utf-8``\\을 ``LANGUAGE``\\로 ``None``\\을 사용하여 :rfc:`2231`"
" 형식으로 자동 인코딩됩니다."

#: ../../library/email.compat32-message.rst:405
msgid "Here's an example::"
msgstr "예를 들면 다음과 같습니다::"

#: ../../library/email.compat32-message.rst:407
msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"

#: ../../library/email.compat32-message.rst:409
msgid "This will add a header that looks like ::"
msgstr "이것은 다음과 같은 헤더를 추가합니다 ::"

#: ../../library/email.compat32-message.rst:411
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/email.compat32-message.rst:413
msgid "An example with non-ASCII characters::"
msgstr "비 ASCII 문자의 예::"

#: ../../library/email.compat32-message.rst:415
msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"

#: ../../library/email.compat32-message.rst:418
msgid "Which produces ::"
msgstr "이것은 다음을 생성합니다 ::"

#: ../../library/email.compat32-message.rst:420
msgid "Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""
msgstr "Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""

#: ../../library/email.compat32-message.rst:425
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case.  If no "
"matching header was found, a :exc:`KeyError` is raised."
msgstr ""
"헤더를 교체합니다. 헤더 순서와 필드 이름 대소 문자를 유지하면서, 메시지에서 *_name*\\과 일치하는 첫 번째로 발견된 헤더를"
" 교체합니다. 일치하는 헤더가 없으면, :exc:`KeyError`\\가 발생합니다."

#: ../../library/email.compat32-message.rst:432
msgid ""
"Return the message's content type.  The returned string is coerced to "
"lower case of the form :mimetype:`maintype/subtype`.  If there was no "
":mailheader:`Content-Type` header in the message the default type as "
"given by :meth:`get_default_type` will be returned.  Since according to "
":rfc:`2045`, messages always have a default type, "
":meth:`get_content_type` will always return a value."
msgstr ""
"메시지의 콘텐츠 유형을 반환합니다. 반환된 문자열은 :mimetype:`maintype/subtype` 형식의 소문자로 강제 "
"변환됩니다. 메시지에 :mailheader:`Content-Type` 헤더가 없으면 "
":meth:`get_default_type`\\에서 제공하는 기본 유형이 반환됩니다. :rfc:`2045`\\에 따르면, 메시지는 "
"항상 기본 유형을 가지므로, :meth:`get_content_type`\\은 항상 값을 반환합니다."

#: ../../library/email.compat32-message.rst:439
msgid ""
":rfc:`2045` defines a message's default type to be :mimetype:`text/plain`"
" unless it appears inside a :mimetype:`multipart/digest` container, in "
"which case it would be :mimetype:`message/rfc822`.  If the :mailheader"
":`Content-Type` header has an invalid type specification, :rfc:`2045` "
"mandates that the default type be :mimetype:`text/plain`."
msgstr ""
":rfc:`2045`\\는 메시지가 :mimetype:`multipart/digest` 컨테이너 안에 등장(이 경우 기본 유형은 "
":mimetype:`message/rfc822`\\가 됩니다)하지 않는 한 기본 유형을 "
":mimetype:`text/plain`\\으로 정의합니다. :mailheader:`Content-Type` 헤더에 유효하지 않은 "
"유형 명세가 있으면, :rfc:`2045`\\는 기본 유형이 :mimetype:`text/plain`\\으로 지정합니다."

#: ../../library/email.compat32-message.rst:448
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype`"
" part of the string returned by :meth:`get_content_type`."
msgstr ""
"메시지의 주 콘텐츠 유형을 반환합니다. 이것은 :meth:`get_content_type`\\이 반환하는 문자열의 "
":mimetype:`maintype` 부분입니다."

#: ../../library/email.compat32-message.rst:454
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"메시지의 부 콘텐츠 유형을 반환합니다. 이것은 :meth:`get_content_type`\\이 반환하는 문자열의 "
":mimetype:`subtype` 부분입니다."

#: ../../library/email.compat32-message.rst:460
msgid ""
"Return the default content type.  Most messages have a default content "
"type of :mimetype:`text/plain`, except for messages that are subparts of "
":mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"기본 콘텐츠 유형을 반환합니다. :mimetype:`multipart/digest` 컨테이너의 서브 파트인 메시지를 제외하고, "
"대부분의 메시지는 기본 콘텐츠 유형이 :mimetype:`text/plain`\\입니다. 이러한 서브 파트는 기본 콘텐츠 유형이 "
":mimetype:`message/rfc822`\\입니다."

#: ../../library/email.compat32-message.rst:468
msgid ""
"Set the default content type.  *ctype* should either be "
":mimetype:`text/plain` or :mimetype:`message/rfc822`, although this is "
"not enforced.  The default content type is not stored in the :mailheader"
":`Content-Type` header."
msgstr ""
"기본 콘텐츠 유형을 설정합니다. *ctype*\\은 :mimetype:`text/plain`\\이나 "
":mimetype:`message/rfc822`\\여야 하지만 강제하지는 않습니다. 기본 콘텐츠 유형은 :mailheader"
":`Content-Type` 헤더에 저장되지 않습니다."

#: ../../library/email.compat32-message.rst:476
msgid ""
"Return the message's :mailheader:`Content-Type` parameters, as a list. "
"The elements of the returned list are 2-tuples of key/value pairs, as "
"split on the ``'='`` sign.  The left hand side of the ``'='`` is the key,"
" while the right hand side is the value.  If there is no ``'='`` sign in "
"the parameter the value is the empty string, otherwise the value is as "
"described in :meth:`get_param` and is unquoted if optional *unquote* is "
"``True`` (the default)."
msgstr ""
"메시지의 :mailheader:`Content-Type` 매개 변수를 리스트로 반환합니다. 반환된 리스트의 요소는 ``'='`` "
"부호로 분할된 키/값 쌍의 2-튜플입니다. ``'='``\\의 왼쪽은 키이고 오른쪽은 값입니다. 매개 변수에 ``'='`` 부호가 "
"없으면 값은 빈 문자열이고, 그렇지 않으면 값은 :meth:`get_param`\\에 설명된대로이며 선택적 *unquote*\\가 "
"``True``\\(기본값)이면 인용되지 않습니다."

#: ../../library/email.compat32-message.rst:484
msgid ""
"Optional *failobj* is the object to return if there is no :mailheader"
":`Content-Type` header.  Optional *header* is the header to search "
"instead of :mailheader:`Content-Type`."
msgstr ""
"선택적 *failobj*\\는 :mailheader:`Content-Type` 헤더가 없을 때 반환할 객체입니다. 선택적 "
"*header*\\는 :mailheader:`Content-Type` 대신 검색할 헤더입니다."

#: ../../library/email.compat32-message.rst:488
#: ../../library/email.compat32-message.rst:526
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class its functionality is "
"replaced by the *params* property of the individual header objects "
"returned by the header access methods."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서 해당 기능은 헤더"
" 액세스 메서드가 반환한 개별 헤더 객체의 *params* 프로퍼티로 대체됩니다."

#: ../../library/email.compat32-message.rst:496
msgid ""
"Return the value of the :mailheader:`Content-Type` header's parameter "
"*param* as a string.  If the message has no :mailheader:`Content-Type` "
"header or if there is no such parameter, then *failobj* is returned "
"(defaults to ``None``)."
msgstr ""
":mailheader:`Content-Type` 헤더의 매개 변수 *param*\\의 값을 문자열로 반환합니다. 메시지에 "
":mailheader:`Content-Type` 헤더가 없거나 그러한 매개 변수가 없으면, *failobj*\\가 반환됩니다 "
"(기본값은 ``None``\\입니다)."

#: ../../library/email.compat32-message.rst:501
msgid ""
"Optional *header* if given, specifies the message header to use instead "
"of :mailheader:`Content-Type`."
msgstr "선택적 *header*\\가 제공되면, :mailheader:`Content-Type` 대신 사용할 메시지 헤더를 지정합니다."

#: ../../library/email.compat32-message.rst:504
msgid ""
"Parameter keys are always compared case insensitively.  The return value "
"can either be a string, or a 3-tuple if the parameter was :rfc:`2231` "
"encoded.  When it's a 3-tuple, the elements of the value are of the form "
"``(CHARSET, LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and "
"``LANGUAGE`` can be ``None``, in which case you should consider ``VALUE``"
" to be encoded in the ``us-ascii`` charset.  You can usually ignore "
"``LANGUAGE``."
msgstr ""
"매개 변수 키는 항상 대소 문자를 구분하지 않고 비교됩니다. 반환 값은 문자열이거나, 매개 변수가 :rfc:`2231`\\로 "
"인코딩되었으면 3-튜플일 수 있습니다. 3-튜플일 때, 값의 요소는 ``(CHARSET, LANGUAGE, VALUE)`` "
"형식입니다. ``CHARSET``\\과 ``LANGUAGE``\\는 모두 ``None``\\일 수 있으며, 이 경우 "
"``VALUE``\\가 ``us-ascii`` 문자 집합으로 인코딩된 것으로 간주해야 함에 유의하십시오. 일반적으로 "
"``LANGUAGE``\\를 무시할 수 있습니다."

#: ../../library/email.compat32-message.rst:512
msgid ""
"If your application doesn't care whether the parameter was encoded as in "
":rfc:`2231`, you can collapse the parameter value by calling "
":func:`email.utils.collapse_rfc2231_value`, passing in the return value "
"from :meth:`get_param`.  This will return a suitably decoded Unicode "
"string when the value is a tuple, or the original string unquoted if it "
"isn't.  For example::"
msgstr ""
"응용 프로그램이 :rfc:`2231`\\로 매개 변수가 인코딩되었는지를 신경 쓰지 않으면, "
":func:`email.utils.collapse_rfc2231_value`\\를 호출하면서 :meth:`get_param`\\의 "
"반환 값을 전달하여 매개 변숫값을 축소할 수 있습니다. 이것은 값이 튜플이면 적절하게 디코딩된 유니코드 문자열을 반환하고, 그렇지 "
"않으면 원래 문자열을 인용 없이 반환합니다. 예를 들면::"

#: ../../library/email.compat32-message.rst:519
msgid ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"
msgstr ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"

#: ../../library/email.compat32-message.rst:522
msgid ""
"In any case, the parameter value (either the returned string, or the "
"``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is "
"set to ``False``."
msgstr ""
"모든 경우에, *unquote*\\가 ``False``\\로 설정되어 있지 않으면, 매개 변숫값(반환된 문자열이나 3-튜플의 "
"``VALUE`` 항목)은 항상 인용되지 않습니다."

#: ../../library/email.compat32-message.rst:535
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the "
"parameter already exists in the header, its value will be replaced with "
"*value*.  If the :mailheader:`Content-Type` header as not yet been "
"defined for this message, it will be set to :mimetype:`text/plain` and "
"the new parameter value will be appended as per :rfc:`2045`."
msgstr ""
":mailheader:`Content-Type` 헤더에서 매개 변수를 설정합니다. 매개 변수가 이미 헤더에 존재하면, 해당 값은 "
"*value*\\로 대체됩니다. 이 메시지에 대해 :mailheader:`Content-Type` 헤더가 아직 정의되지 않았으면, "
":mimetype:`text/plain`\\으로 설정되고 :rfc:`2045`\\에 따라 새 매개 변숫값이 추가됩니다."

#: ../../library/email.compat32-message.rst:541
msgid ""
"Optional *header* specifies an alternative header to :mailheader"
":`Content-Type`, and all parameters will be quoted as necessary unless "
"optional *requote* is ``False`` (the default is ``True``)."
msgstr ""
"선택적 *header*\\는 :mailheader:`Content-Type`\\의 대체 헤더를 지정하며, 선택적 "
"*requote*\\가 ``False``\\(기본값은 ``True``)가 아닌 한 모든 매개 변수가 필요에 따라 인용됩니다."

#: ../../library/email.compat32-message.rst:545
msgid ""
"If optional *charset* is specified, the parameter will be encoded "
"according to :rfc:`2231`. Optional *language* specifies the RFC 2231 "
"language, defaulting to the empty string.  Both *charset* and *language* "
"should be strings."
msgstr ""
"선택적 *charset*\\이 지정되면, 매개 변수는 :rfc:`2231`\\에 따라 인코딩됩니다. 선택적 *language*\\는"
" RFC 2231 언어를 지정하며, 기본값은 빈 문자열입니다. *charset*\\과 *language*\\는 모두 문자열이어야 "
"합니다."

#: ../../library/email.compat32-message.rst:550
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of"
" the list of headers.  If *replace* is ``True``, the header will be "
"updated in place."
msgstr ""
"*replace*\\가 ``False``\\(기본값)이면 헤더가 헤더 리스트의 끝으로 이동합니다. *replace*\\가 "
"``True``\\이면, 헤더는 제자리에서 갱신됩니다."

#: ../../library/email.compat32-message.rst:554
msgid "``replace`` keyword was added."
msgstr "``replace`` 키워드가 추가되었습니다."

#: ../../library/email.compat32-message.rst:559
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type`"
" header.  The header will be re-written in place without the parameter or"
" its value.  All values will be quoted as necessary unless *requote* is "
"``False`` (the default is ``True``).  Optional *header* specifies an "
"alternative to :mailheader:`Content-Type`."
msgstr ""
":mailheader:`Content-Type` 헤더에서 지정된 매개 변수를 완전히 제거합니다. 매개 변수나 그 값 없이 헤더가 "
"다시 작성됩니다. *requote*\\가 ``False``\\(기본값은 ``True``)가 아닌 한 모든 값이 필요에 따라 "
"인용됩니다. 선택적 *header*\\는 :mailheader:`Content-Type`\\의 대체 헤더를 지정합니다."

#: ../../library/email.compat32-message.rst:568
msgid ""
"Set the main type and subtype for the :mailheader:`Content-Type` header. "
"*type* must be a string in the form :mimetype:`maintype/subtype`, "
"otherwise a :exc:`ValueError` is raised."
msgstr ""
":mailheader:`Content-Type` 헤더의 주 유형과 부 유형을 설정합니다. *type*\\은 "
":mimetype:`maintype/subtype` 형식의 문자열이어야 합니다, 그렇지 않으면 :exc:`ValueError`\\가"
" 발생합니다."

#: ../../library/email.compat32-message.rst:572
msgid ""
"This method replaces the :mailheader:`Content-Type` header, keeping all "
"the parameters in place.  If *requote* is ``False``, this leaves the "
"existing header's quoting as is, otherwise the parameters will be quoted "
"(the default)."
msgstr ""
"이 메서드는 모든 매개 변수를 그대로 유지하면서 :mailheader:`Content-Type` 헤더를 대체합니다. "
"*requote*\\가 ``False``\\이면, 기존 헤더의 인용을 그대로 두고, 그렇지 않으면 매개 변수가 인용됩니다 "
"(기본값)."

#: ../../library/email.compat32-message.rst:577
msgid ""
"An alternative header can be specified in the *header* argument. When the"
" :mailheader:`Content-Type` header is set a :mailheader:`MIME-Version` "
"header is also added."
msgstr ""
"*header* 인자에 대체 헤더를 지정할 수 있습니다. :mailheader:`Content-Type` 헤더가 설정될 때 "
":mailheader:`MIME-Version` 헤더도 추가됩니다."

#: ../../library/email.compat32-message.rst:581
msgid ""
"This is a legacy method.  On the "
":class:`~email.emailmessage.EmailMessage` class its functionality is "
"replaced by the ``make_`` and ``add_`` methods."
msgstr ""
"이것은 레거시 메서드입니다. :class:`~email.emailmessage.EmailMessage` 클래스에서 해당 기능은 "
"``make_``\\와 ``add_`` 메서드로 대체됩니다."

#: ../../library/email.compat32-message.rst:588
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader"
":`Content-Disposition` header of the message.  If the header does not "
"have a ``filename`` parameter, this method falls back to looking for the "
"``name`` parameter on the :mailheader:`Content-Type` header.  If neither "
"is found, or the header is missing, then *failobj* is returned. The "
"returned string will always be unquoted as per "
":func:`email.utils.unquote`."
msgstr ""
"메시지의 :mailheader:`Content-Disposition` 헤더의 ``filename`` 매개 변숫값을 반환합니다. "
"헤더에 ``filename`` 매개 변수가 없으면, 이 메서드는 :mailheader:`Content-Type` 헤더에서 "
"``name`` 매개 변수를 찾는 것으로 폴 백합니다. 둘 다 없거나, 헤더가 없으면, *failobj*\\가 반환됩니다. 반환된 "
"문자열은 항상 :func:`email.utils.unquote`\\로 인용 해제됩니다."

#: ../../library/email.compat32-message.rst:599
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader"
":`Content-Type` header of the message, or *failobj* if either the header "
"is missing, or has no ``boundary`` parameter.  The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"메시지의 :mailheader:`Content-Type` 헤더의 ``boundary`` 매개 변숫값이나, 헤더가 없거나 "
"``boundary`` 매개 변수가 없으면 *failobj*\\를 반환합니다. 반환된 문자열은 항상 "
":func:`email.utils.unquote`\\로 인용 해제됩니다."

#: ../../library/email.compat32-message.rst:607
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header "
"to *boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the "
"message object has no :mailheader:`Content-Type` header."
msgstr ""
":mailheader:`Content-Type` 헤더의 ``boundary`` 매개 변수를 *boundary*\\로 설정합니다. "
"필요하면 :meth:`set_boundary`\\는 항상 *boundary*\\를 인용합니다. 메시지 객체에 :mailheader"
":`Content-Type` 헤더가 없으면 :exc:`~email.errors.HeaderParseError` 가 발생합니다."

#: ../../library/email.compat32-message.rst:612
msgid ""
"Note that using this method is subtly different than deleting the old "
":mailheader:`Content-Type` header and adding a new one with the new "
"boundary via :meth:`add_header`, because :meth:`set_boundary` preserves "
"the order of the :mailheader:`Content-Type` header in the list of "
"headers. However, it does *not* preserve any continuation lines which may"
" have been present in the original :mailheader:`Content-Type` header."
msgstr ""
":meth:`set_boundary`\\는 헤더 리스트에서 :mailheader:`Content-Type` 헤더의 순서를 "
"유지하므로, 이 메서드를 사용하는 것은 이전 :mailheader:`Content-Type` 헤더를 삭제하고 "
":meth:`add_header`\\를 통해 새 경계를 가진 새 헤더를 추가하는 것과 미묘하게 다름에 유의하십시오. 그러나 원래 "
":mailheader:`Content-Type` 헤더에 있을 수 있는 이어지는 줄(continuation lines)을 유지하지 "
"*않습니다*."

#: ../../library/email.compat32-message.rst:622
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` "
"header, coerced to lower case.  If there is no :mailheader:`Content-Type`"
" header, or if that header has no ``charset`` parameter, *failobj* is "
"returned."
msgstr ""
":mailheader:`Content-Type` 헤더의 ``charset`` 매개 변수를 소문자로 강제 변환하여 반환합니다. "
":mailheader:`Content-Type` 헤더가 없거나, 해당 헤더에 ``charset`` 매개 변수가 없으면 "
"*failobj*\\가 반환됩니다."

#: ../../library/email.compat32-message.rst:626
msgid ""
"Note that this method differs from :meth:`get_charset` which returns the "
":class:`~email.charset.Charset` instance for the default encoding of the "
"message body."
msgstr ""
"이 메서드는 메시지 본문의 기본 인코딩에 대한 :class:`~email.charset.Charset` 인스턴스를 반환하는 "
":meth:`get_charset`\\과 다름에 유의하십시오."

#: ../../library/email.compat32-message.rst:632
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one "
"element for each subpart in the payload, otherwise, it will be a list of "
"length 1."
msgstr ""
"메시지 내의 문자 집합 이름을 포함하는 리스트를 반환합니다. 메시지가 :mimetype:`multipart`\\이면, 리스트에 페이"
" 로드의 각 서브 파트마다 하나의 요소가 포함되며, 그렇지 않으면 길이 1인 리스트가 됩니다."

#: ../../library/email.compat32-message.rst:636
msgid ""
"Each item in the list will be a string which is the value of the "
"``charset`` parameter in the :mailheader:`Content-Type` header for the "
"represented subpart.  However, if the subpart has no :mailheader"
":`Content-Type` header, no ``charset`` parameter, or is not of the "
":mimetype:`text` main MIME type, then that item in the returned list will"
" be *failobj*."
msgstr ""
"리스트의 각 항목은 표현된 서브 파트에 대한 :mailheader:`Content-Type` 헤더의 ``charset`` 매개 "
"변숫값인 문자열입니다. 그러나, 서브 파트에 :mailheader:`Content-Type` 헤더가 없거나, ``charset`` "
"매개 변수가 없거나, :mimetype:`text` 주 MIME 유형이 아니면, 반환된 목록의 해당 항목은 *failobj*\\가 "
"됩니다."

#: ../../library/email.compat32-message.rst:646
msgid ""
"Return the lowercased value (without parameters) of the message's "
":mailheader:`Content-Disposition` header if it has one, or ``None``.  The"
" possible values for this method are *inline*, *attachment* or ``None`` "
"if the message follows :rfc:`2183`."
msgstr ""
"있다면 메시지의 :mailheader:`Content-Disposition` 헤더의 (매개 변수가 없는) 소문자 값을, 그렇지 "
"않으면 ``None``\\을 반환합니다. 메시지가 :rfc:`2183`\\을 따른다면 이 메서드의 가능한 값은 *inline*, "
"*attachment* 또는 ``None``\\입니다."

#: ../../library/email.compat32-message.rst:655
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in "
"depth-first traversal order.  You will typically use :meth:`walk` as the "
"iterator in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
":meth:`walk` 메서드는 메시지 객체 트리의 모든 파트와 서브 파트를 깊이 우선 탐색 순서로 이터레이트 하는 데 사용할 수 "
"있는 범용 제너레이터입니다. 일반적으로 :meth:`walk`\\를 ``for`` 루프에서 이터레이터로 사용합니다; 각 이터레이션은"
" 다음 서브 파트를 반환합니다."

#: ../../library/email.compat32-message.rst:660
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr "다음은 멀티 파트 메시지 구조의 모든 파트에 대한 MIME 유형을 인쇄하는 예입니다:"

#: ../../library/email.compat32-message.rst:674
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"

#: ../../library/email.compat32-message.rst:686
msgid ""
"``walk`` iterates over the subparts of any part where "
":meth:`is_multipart` returns ``True``, even though "
"``msg.get_content_maintype() == 'multipart'`` may return ``False``.  We "
"can see this in our example by making use of the ``_structure`` debug "
"helper function:"
msgstr ""
"``msg.get_content_maintype() == 'multipart'``\\가 ``False``\\를 반환하더라도, "
"``walk``\\는 :meth:`is_multipart`\\가 ``True``\\를 반환하는 모든 파트의 서브 파트를 이터레이트 "
"합니다. ``_structure`` 디버그 도우미 함수를 사용하여 예제에서 이를 확인할 수 있습니다:"

#: ../../library/email.compat32-message.rst:692
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"

#: ../../library/email.compat32-message.rst:713
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into "
"the subparts."
msgstr ""
"여기서 ``message`` 파트는 ``multiparts``\\가 아니지만, 서브 파트를 포함합니다. "
"``is_multipart()``\\는 ``True``\\를 반환하고 ``walk``\\는 서브 파트로 내려갑니다."

#: ../../library/email.compat32-message.rst:718
msgid ""
":class:`Message` objects can also optionally contain two instance "
"attributes, which can be used when generating the plain text of a MIME "
"message."
msgstr ""
":class:`Message` 객체는 MIME 메시지의 단순 텍스트를 생성할 때 사용할 수 있는 두 개의 인스턴스 어트리뷰트를 "
"선택적으로 포함할 수 있습니다."

#: ../../library/email.compat32-message.rst:724
msgid ""
"The format of a MIME document allows for some text between the blank line"
" following the headers, and the first multipart boundary string. "
"Normally, this text is never visible in a MIME-aware mail reader because "
"it falls outside the standard MIME armor.  However, when viewing the raw "
"text of the message, or when viewing the message in a non-MIME aware "
"reader, this text can become visible."
msgstr ""
"MIME 문서의 형식은 헤더 다음의 빈 줄과 첫 번째 멀티 파트 경계 문자열 사이에 일부 텍스트를 허용합니다. 일반적으로, 이 "
"텍스트는 표준 MIME 장비를 벗어나기 때문에 MIME 인식 메일 리더에서 볼 수 없습니다. 그러나, 메시지의 원시 텍스트를 "
"보거나, MIME을 인식하지 않는 리더에서 메시지를 볼 때, 이 텍스트가 보일 수 있습니다."

#: ../../library/email.compat32-message.rst:731
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text "
"after the headers but before the first boundary string, it assigns this "
"text to the message's *preamble* attribute.  When the "
":class:`~email.generator.Generator` is writing out the plain text "
"representation of a MIME message, and it finds the message has a "
"*preamble* attribute, it will write this text in the area between the "
"headers and the first boundary.  See :mod:`email.parser` and "
":mod:`email.generator` for details."
msgstr ""
"*preamble* 어트리뷰트에는 MIME 문서에 대한 이 선행 추가 텍스트가 포함됩니다. "
":class:`~email.parser.Parser`\\가 헤더 다음이지만 첫 번째 경계 문자열 이전에 어떤 텍스트를 감지하면, 이"
" 텍스트를 메시지의 *preamble* 어트리뷰트에 대입합니다. "
":class:`~email.generator.Generator`\\가 MIME 메시지의 단순 텍스트 표현을 기록할 때, 메시지에 "
"*preamble* 어트리뷰트가 있는 것을 발견하면, 헤더와 첫 번째 경계 사이의 영역에 이 텍스트를 기록합니다. 자세한 내용은 "
":mod:`email.parser`\\와 :mod:`email.generator`\\를 참조하십시오."

#: ../../library/email.compat32-message.rst:741
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute"
" will be ``None``."
msgstr "메시지 객체에 프리앰블이 없으면, *preamble* 어트리뷰트는 ``None``\\이 됨에 유의하십시오."

#: ../../library/email.compat32-message.rst:747
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and "
"the end of the message."
msgstr ""
"*epilogue* 어트리뷰트는 메시지의 마지막 경계와 끝 사이에 나타나는 텍스트를 포함한다는 점을 제외하고, *preamble* "
"어트리뷰트와 같은 방식으로 작동합니다."

#: ../../library/email.compat32-message.rst:751
msgid ""
"You do not need to set the epilogue to the empty string in order for the "
":class:`~email.generator.Generator` to print a newline at the end of the "
"file."
msgstr ""
":class:`~email.generator.Generator`\\가 파일 끝에서 줄 넘김을 인쇄하도록 하기 위해 에필로그를 빈 "
"문자열로 설정할 필요는 없습니다."

#: ../../library/email.compat32-message.rst:758
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description"
" of the possible parsing defects."
msgstr ""
"*defects* 어트리뷰트는 이 메시지를 구문 분석할 때 발견된 모든 결함의 리스트를 포함합니다. 가능한 구문 분석 결함에 대한 "
"자세한 설명은 :mod:`email.errors`\\를 참조하십시오."

