# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/itertools.rst:2
#, fuzzy
msgid ":mod:`!itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`itertools` --- 효율적인 루핑을 위한 이터레이터를 만드는 함수"

#: ../../library/itertools.rst:20
msgid ""
"This module implements a number of :term:`iterator` building blocks "
"inspired by constructs from APL, Haskell, and SML.  Each has been recast "
"in a form suitable for Python."
msgstr ""
"이 모듈은 APL, Haskell 및 SML의 구성물들에서 영감을 얻은 여러 :term:`이터레이터 <iterator>` 빌딩 "
"블록을 구현합니다. 각각을 파이썬에 적합한 형태로 개선했습니다."

#: ../../library/itertools.rst:24
msgid ""
"The module standardizes a core set of fast, memory efficient tools that "
"are useful by themselves or in combination.  Together, they form an "
"\"iterator algebra\" making it possible to construct specialized tools "
"succinctly and efficiently in pure Python."
msgstr ""
"이 모듈은 자체적으로 혹은 조합하여 유용한 빠르고 메모리 효율적인 도구의 핵심 집합을 표준화합니다. 함께 모여, 순수 파이썬에서 "
"간결하고 효율적으로 특수화된 도구를 구성할 수 있도록 하는 \"이터레이터 대수(iterator algebra)\"를 형성합니다."

#: ../../library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which "
"produces a sequence ``f(0), f(1), ...``.  The same effect can be achieved"
" in Python by combining :func:`map` and :func:`count` to form ``map(f, "
"count())``."
msgstr ""
"예를 들어, SML은 테이블 화 도구를 제공합니다: 시퀀스 ``f(0), f(1), ...``\\를 생성하는 "
"``tabulate(f)``. :func:`map`\\과 :func:`count`\\를 결합하여 ``map(f, "
"count())``\\를 형성해서 파이썬에서도 같은 효과를 얻을 수 있습니다."

#: ../../library/itertools.rst:34
msgid "**Infinite iterators:**"
msgstr "**무한 이터레이터:**"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
#: ../../library/itertools.rst:68
msgid "Iterator"
msgstr "이터레이터"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
#: ../../library/itertools.rst:68
msgid "Arguments"
msgstr "인자"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
#: ../../library/itertools.rst:68 ../../library/itertools.rst:77
msgid "Results"
msgstr "결과"

#: ../../library/itertools.rst:37 ../../library/itertools.rst:47
msgid "Example"
msgstr "예"

#: ../../library/itertools.rst:39
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:39
#, fuzzy
msgid "[start[, step]]"
msgstr "start, [step]"

#: ../../library/itertools.rst:39
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: ../../library/itertools.rst:39
#, fuzzy
msgid "``count(10) → 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:40
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:40
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:40
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:40
#, fuzzy
msgid "``cycle('ABCD') → A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: ../../library/itertools.rst:41
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:41
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../../library/itertools.rst:41
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... 끝없이 또는 최대 n 번"

#: ../../library/itertools.rst:41
#, fuzzy
msgid "``repeat(10, 3) → 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: ../../library/itertools.rst:44
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**가장 짧은 입력 시퀀스에서 종료되는 이터레이터:**"

#: ../../library/itertools.rst:49
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: ../../library/itertools.rst:49
msgid "p [,func]"
msgstr "p [,func]"

#: ../../library/itertools.rst:49
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: ../../library/itertools.rst:49
#, fuzzy
msgid "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"

#: ../../library/itertools.rst:50
#, fuzzy
msgid ":func:`batched`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:50
#, fuzzy
msgid "p, n"
msgstr "p, r"

#: ../../library/itertools.rst:50
#, fuzzy
msgid "(p0, p1, ..., p_n-1), ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:50
#, fuzzy
msgid "``batched('ABCDEFG', n=3) → ABC DEF G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../../library/itertools.rst:51
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:51 ../../library/itertools.rst:62
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:51 ../../library/itertools.rst:52
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:51
#, fuzzy
msgid "``chain('ABC', 'DEF') → A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: ../../library/itertools.rst:52
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: ../../library/itertools.rst:52 ../../library/itertools.rst:58
msgid "iterable"
msgstr "iterable"

#: ../../library/itertools.rst:52
#, fuzzy
msgid "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: ../../library/itertools.rst:53
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:53
msgid "data, selectors"
msgstr "data, selectors"

#: ../../library/itertools.rst:53
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../../library/itertools.rst:53
#, fuzzy
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: ../../library/itertools.rst:54
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:54 ../../library/itertools.rst:55
#: ../../library/itertools.rst:60
#, fuzzy
msgid "predicate, seq"
msgstr "pred, seq"

#: ../../library/itertools.rst:54
#, fuzzy
msgid "seq[n], seq[n+1], starting when predicate fails"
msgstr "seq[n], seq[n+1], pred가 실패할 때 시작"

#: ../../library/itertools.rst:54
#, fuzzy
msgid "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: ../../library/itertools.rst:55
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: ../../library/itertools.rst:55
#, fuzzy
msgid "elements of seq where predicate(elem) fails"
msgstr "pred(elem)이 거짓인 seq의 요소들"

#: ../../library/itertools.rst:55
#, fuzzy
msgid "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: ../../library/itertools.rst:56
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:56
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: ../../library/itertools.rst:56
msgid "sub-iterators grouped by value of key(v)"
msgstr "key(v)의 값으로 그룹화된 서브 이터레이터들"

#: ../../library/itertools.rst:56
msgid "``groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)``"
msgstr ""

#: ../../library/itertools.rst:57
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:57
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../../library/itertools.rst:57
msgid "elements from seq[start:stop:step]"
msgstr "seq[start:stop:step]의 요소들"

#: ../../library/itertools.rst:57
#, fuzzy
msgid "``islice('ABCDEFG', 2, None) → C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../../library/itertools.rst:58
#, fuzzy
msgid ":func:`pairwise`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:58
#, fuzzy
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:58
#, fuzzy
msgid "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: ../../library/itertools.rst:59
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:59
msgid "func, seq"
msgstr "func, seq"

#: ../../library/itertools.rst:59
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:59
#, fuzzy
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: ../../library/itertools.rst:60
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:60
#, fuzzy
msgid "seq[0], seq[1], until predicate fails"
msgstr "seq[0], seq[1], pred가 실패할 때까지"

#: ../../library/itertools.rst:60
#, fuzzy
msgid "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: ../../library/itertools.rst:61
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:61
msgid "it, n"
msgstr "it, n"

#: ../../library/itertools.rst:61
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn 하나의 이터레이터를 n개의 이터레이터로 나눕니다"

#: ../../library/itertools.rst:62
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: ../../library/itertools.rst:62
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:62
#, fuzzy
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: ../../library/itertools.rst:65
msgid "**Combinatoric iterators:**"
msgstr "**조합형 이터레이터:**"

#: ../../library/itertools.rst:70
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:70
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:70
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "데카르트 곱(cartesian product), 중첩된 for 루프와 동등합니다"

#: ../../library/itertools.rst:71
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:71
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:71
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "r-길이 튜플들, 모든 가능한 순서, 반복되는 요소 없음"

#: ../../library/itertools.rst:72
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:72 ../../library/itertools.rst:73
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:72
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "r-길이 튜플들, 정렬된 순서, 반복되는 요소 없음"

#: ../../library/itertools.rst:73
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:73
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "r-길이 튜플들, 정렬된 순서, 반복되는 요소 있음"

#: ../../library/itertools.rst:77
msgid "Examples"
msgstr "예"

#: ../../library/itertools.rst:79
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:79
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:80
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:80
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:81
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:81
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:82
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:82
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:89
#, fuzzy
msgid "Itertool Functions"
msgstr "이터레이터 도구 함수"

#: ../../library/itertools.rst:91
#, fuzzy
msgid ""
"The following functions all construct and return iterators. Some provide "
"streams of infinite length, so they should only be accessed by functions "
"or loops that truncate the stream."
msgstr ""
"다음 모듈 함수는 모두 이터레이터를 생성하고 반환합니다. 일부는 길이가 무한한 스트림을 제공해서, 스트림을 자르는 함수나 루프로만 "
"액세스해야 합니다."

#: ../../library/itertools.rst:98
#, fuzzy
msgid ""
"Make an iterator that returns accumulated sums or accumulated results "
"from other binary functions."
msgstr "누적 합계나 다른 이항 함수(선택적 *func* 인자를 통해 지정됩니다)의 누적 결과를 반환하는 이터레이터를 만듭니다."

#: ../../library/itertools.rst:101
msgid ""
"The *function* defaults to addition.  The *function* should accept two "
"arguments, an accumulated total and a value from the *iterable*."
msgstr ""

#: ../../library/itertools.rst:104
#, fuzzy
msgid ""
"If an *initial* value is provided, the accumulation will start with that "
"value and the output will have one more element than the input iterable."
msgstr ""
"일반적으로, 출력되는 요소 수는 입력 iterable과 일치합니다. 그러나, 키워드 인자 *initial*\\이 제공되면, 누적이 "
"*initial* 값으로 시작하여 출력에 입력 iterable보다 하나 많은 요소가 있게 됩니다."

#: ../../library/itertools.rst:108 ../../library/itertools.rst:181
#: ../../library/itertools.rst:240 ../../library/itertools.rst:283
#: ../../library/itertools.rst:484 ../../library/itertools.rst:519
#: ../../library/itertools.rst:556 ../../library/itertools.rst:632
#: ../../library/itertools.rst:693 ../../library/itertools.rst:774
msgid "Roughly equivalent to::"
msgstr "대략 다음과 동등합니다::"

#: ../../library/itertools.rst:110
msgid ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"
msgstr ""

#: ../../library/itertools.rst:129
msgid ""
"To compute a running minimum, set *function* to :func:`min`. For a "
"running maximum, set *function* to :func:`max`. Or for a running product,"
" set *function* to :func:`operator.mul`. To build an `amortization table "
"<https://www.ramseysolutions.com/real-estate/amortization-schedule>`_, "
"accumulate the interest and apply payments:"
msgstr ""

#: ../../library/itertools.rst:136
#, python-format
msgid ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # running maximum\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # running product\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# Amortize a 5% loan of 1000 with 10 annual payments of 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"
msgstr ""

#: ../../library/itertools.rst:149
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the"
" final accumulated value."
msgstr "최종 누적값만 반환하는 유사한 함수에 대해서는 :func:`functools.reduce`\\를 참조하십시오."

#: ../../library/itertools.rst:154
#, fuzzy
msgid "Added the optional *function* parameter."
msgstr "선택적 *func* 매개 변수를 추가했습니다."

#: ../../library/itertools.rst:157
msgid "Added the optional *initial* parameter."
msgstr "선택적 *initial* 매개 변수를 추가했습니다."

#: ../../library/itertools.rst:163
msgid ""
"Batch data from the *iterable* into tuples of length *n*. The last batch "
"may be shorter than *n*."
msgstr ""

#: ../../library/itertools.rst:166
msgid ""
"If *strict* is true, will raise a :exc:`ValueError` if the final batch is"
" shorter than *n*."
msgstr ""

#: ../../library/itertools.rst:169
msgid ""
"Loops over the input iterable and accumulates data into tuples up to size"
" *n*.  The input is consumed lazily, just enough to fill a batch. The "
"result is yielded as soon as the batch is full or when the input iterable"
" is exhausted:"
msgstr ""

#: ../../library/itertools.rst:174
msgid ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', "
"'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"
msgstr ""

#: ../../library/itertools.rst:183
msgid ""
"def batched(iterable, n, *, strict=False):\n"
"    # batched('ABCDEFG', 3) → ABC DEF G\n"
"    if n < 1:\n"
"        raise ValueError('n must be at least one')\n"
"    iterator = iter(iterable)\n"
"    while batch := tuple(islice(iterator, n)):\n"
"        if strict and len(batch) != n:\n"
"            raise ValueError('batched(): incomplete batch')\n"
"        yield batch"
msgstr ""

#: ../../library/itertools.rst:195
msgid "Added the *strict* option."
msgstr ""

#: ../../library/itertools.rst:201
#, fuzzy
msgid ""
"Make an iterator that returns elements from the first iterable until it "
"is exhausted, then proceeds to the next iterable, until all of the "
"iterables are exhausted.  This combines multiple data sources into a "
"single iterator.  Roughly equivalent to::"
msgstr ""
"첫 번째 이터러블에서 소진될 때까지 요소를 반환한 다음 이터러블로 넘어가고, 이런 식으로 iterables의 모든 이터러블이 소진될"
" 때까지 진행하는 이터레이터를 만듭니다. 여러 시퀀스를 단일 시퀀스처럼 처리하는 데 사용됩니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:206
msgid ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""

#: ../../library/itertools.rst:214
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a "
"single iterable argument that is evaluated lazily.  Roughly equivalent "
"to::"
msgstr ""
":func:`chain`\\의 대체 생성자. 게으르게 평가되는 단일 이터러블 인자에서 연쇄 입력을 가져옵니다. 대략 다음과 "
"동등합니다::"

#: ../../library/itertools.rst:217
msgid ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""

#: ../../library/itertools.rst:225
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "입력 *iterable*\\에서 요소의 길이 *r* 서브 시퀀스들을 반환합니다."

#: ../../library/itertools.rst:227
msgid ""
"The output is a subsequence of :func:`product` keeping only entries that "
"are subsequences of the *iterable*.  The length of the output is given by"
" :func:`math.comb` which computes ``n! / r! / (n - r)!`` when ``0 ≤ r ≤ "
"n`` or zero when ``r > n``."
msgstr ""

#: ../../library/itertools.rst:232
#, fuzzy
msgid ""
"The combination tuples are emitted in lexicographic order according to "
"the order of the input *iterable*. If the input *iterable* is sorted, the"
" output tuples will be produced in sorted order."
msgstr ""
"조합(combination) 튜플은 입력 *iterable*\\의 순서에 따라 사전식 순서로 방출됩니다. 따라서, 입력 "
"*iterable*\\이 정렬되어있으면, 조합 튜플이 정렬된 순서로 생성됩니다."

#: ../../library/itertools.rst:236
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their "
"value.  If the input elements are unique, there will be no repeated "
"values within each combination."
msgstr "요소는 값이 아니라 위치로 고유성을 다룹니다. 따라서 입력 요소가 고유하면, 각 조합에 반복 값이 없습니다."

#: ../../library/itertools.rst:242
msgid ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../library/itertools.rst:267
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "입력 *iterable*\\에서 요소의 길이 *r* 서브 시퀀스들을 반환하는데, 개별 요소를 두 번 이상 반복할 수 있습니다."

#: ../../library/itertools.rst:270
msgid ""
"The output is a subsequence of :func:`product` that keeps only entries "
"that are subsequences (with possible repeated elements) of the "
"*iterable*.  The number of subsequence returned is ``(n + r - 1)! / r! / "
"(n - 1)!`` when ``n > 0``."
msgstr ""

#: ../../library/itertools.rst:275
#, fuzzy
msgid ""
"The combination tuples are emitted in lexicographic order according to "
"the order of the input *iterable*. if the input *iterable* is sorted, the"
" output tuples will be produced in sorted order."
msgstr ""
"조합(combination) 튜플은 입력 *iterable*\\의 순서에 따라 사전식 순서로 방출됩니다. 따라서, 입력 "
"*iterable*\\이 정렬되어있으면, 조합 튜플이 정렬된 순서로 생성됩니다."

#: ../../library/itertools.rst:279
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their "
"value.  If the input elements are unique, the generated combinations will"
" also be unique."
msgstr "요소는 값이 아니라 위치로 고유성을 다룹니다. 따라서 입력 요소가 고유하면, 생성된 조합도 고유합니다."

#: ../../library/itertools.rst:285
msgid ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../library/itertools.rst:309
#, fuzzy
msgid ""
"Make an iterator that returns elements from *data* where the "
"corresponding element in *selectors* is true.  Stops when either the "
"*data* or *selectors* iterables have been exhausted.  Roughly equivalent "
"to::"
msgstr ""
"*data*\\에서 요소를 필터링하여 *selectors*\\에서 ``True``\\로 평가되는 해당 요소들만 반환하는 이터레이터를"
" 만듭니다. *data*\\나 *selectors* 이터러블이 모두 소진되면 중지합니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:314
msgid ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"
msgstr ""

#: ../../library/itertools.rst:323
#, fuzzy
msgid ""
"Make an iterator that returns evenly spaced values beginning with "
"*start*. Can be used with :func:`map` to generate consecutive data points"
" or with :func:`zip` to add sequence numbers.  Roughly equivalent to::"
msgstr ""
"숫자 *start*\\로 시작하여 균등 간격의 값을 반환하는 이터레이터를 만듭니다. 연속적인 데이터 포인트를 생성하기 위해 "
":func:`map`\\에 대한 인자로 종종 사용됩니다. 또한, 시퀀스 번호를 추가하기 위해 :func:`zip`\\과 함께 "
"사용됩니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:328
msgid ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"
msgstr ""

#: ../../library/itertools.rst:336
#, fuzzy
msgid ""
"When counting with floating-point numbers, better accuracy can sometimes "
"be achieved by substituting multiplicative code such as: ``(start + step "
"* i for i in count())``."
msgstr ""
"부동 소수점 숫자로 count 할 때, ``(start + step * i for i in count())``\\와 같은 곱셈 "
"코드를 대체하여 때로 더 나은 정확도를 얻을 수 있습니다."

#: ../../library/itertools.rst:340
msgid "Added *step* argument and allowed non-integer arguments."
msgstr "*step* 인자를 추가하고 정수가 아닌 인자를 허용했습니다."

#: ../../library/itertools.rst:346
#, fuzzy
msgid ""
"Make an iterator returning elements from the *iterable* and saving a copy"
" of each.  When the iterable is exhausted, return elements from the saved"
" copy.  Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"iterable에서 요소를 반환하고 각 사본을 저장하는 이터레이터를 만듭니다. iterable이 소진되면, 저장된 사본에서 요소를 "
"반환합니다. 무한히 반복합니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:350
msgid ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"
msgstr ""

#: ../../library/itertools.rst:362
#, fuzzy
msgid ""
"This itertool may require significant auxiliary storage (depending on the"
" length of the iterable)."
msgstr "툴킷의 이 멤버에는 iterable의 길이에 따라 상당한 보조 기억 장치가 필요할 수 있음에 유의하십시오."

#: ../../library/itertools.rst:368
#, fuzzy
msgid ""
"Make an iterator that drops elements from the *iterable* while the "
"*predicate* is true and afterwards returns every element.  Roughly "
"equivalent to::"
msgstr "술어(predicate)가 참인 한 iterable에서 요소를 반환하는 이터레이터를 만듭니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:372
msgid ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterable)\n"
"    for x in iterator:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"\n"
"    for x in iterator:\n"
"        yield x"
msgstr ""

#: ../../library/itertools.rst:384
msgid ""
"Note this does not produce *any* output until the predicate first becomes"
" false, so this itertool may have a lengthy start-up time."
msgstr ""

#: ../../library/itertools.rst:390
#, fuzzy
msgid ""
"Make an iterator that filters elements from the *iterable* returning only"
" those for which the *predicate* returns a false value.  If *predicate* "
"is ``None``, returns the items that are false.  Roughly equivalent to::"
msgstr ""
"iterable에서 요소를 걸러내어 술어(predicate)가 ``False``\\인 요소만 반환하는 이터레이터를 만듭니다. "
"*predicate*\\가 ``None``\\이면, 거짓인 항목을 반환합니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:395
msgid ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"
msgstr ""

#: ../../library/itertools.rst:408
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each "
"element.  If not specified or is ``None``, *key* defaults to an identity "
"function and returns the element unchanged.  Generally, the iterable "
"needs to already be sorted on the same key function."
msgstr ""
"*iterable*\\에서 연속적인 키와 그룹을 반환하는 이터레이터를 만듭니다. *key*\\는 각 요소의 키값을 계산하는 "
"함수입니다. 지정되지 않거나 ``None``\\이면, *key*\\의 기본값은 항등함수(identity function)이고 요소를"
" 변경하지 않고 반환합니다. 일반적으로, iterable은 같은 키 함수로 이미 정렬되어 있어야 합니다."

#: ../../library/itertools.rst:414
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in "
"Unix.  It generates a break or new group every time the value of the key "
"function changes (which is why it is usually necessary to have sorted the"
" data using the same key function).  That behavior differs from SQL's "
"GROUP BY which aggregates common elements regardless of their input "
"order."
msgstr ""
":func:`groupby`\\의 작동은 유닉스의 ``uniq`` 필터와 유사합니다. 키 함수의 값이 변경될 때마다 "
"중단(break)이나 새 그룹을 생성합니다 (이것이 일반적으로 같은 키 함수를 사용하여 데이터를 정렬해야 하는 이유입니다). 이 "
"동작은 입력 순서와 관계없이 공통 요소를 집계하는 SQL의 GROUP BY와 다릅니다."

#: ../../library/itertools.rst:420
msgid ""
"The returned group is itself an iterator that shares the underlying "
"iterable with :func:`groupby`.  Because the source is shared, when the "
":func:`groupby` object is advanced, the previous group is no longer "
"visible.  So, if that data is needed later, it should be stored as a "
"list::"
msgstr ""
"반환되는 그룹 자체는 :func:`groupby`\\와 하부 이터러블(iterable)을 공유하는 이터레이터입니다. 소스가 "
"공유되므로, :func:`groupby` 객체가 진행하면, 이전 그룹은 이 더는 보이지 않게 됩니다. 따라서, 나중에 데이터가 "
"필요하면, 리스트로 저장해야 합니다::"

#: ../../library/itertools.rst:425
msgid ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"
msgstr ""

#: ../../library/itertools.rst:432
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby`\\는 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:434
msgid ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"
msgstr ""

#: ../../library/itertools.rst:470
msgid ""
"Make an iterator that returns selected elements from the iterable. Works "
"like sequence slicing but does not support negative values for *start*, "
"*stop*, or *step*."
msgstr ""

#: ../../library/itertools.rst:474
msgid ""
"If *start* is zero or ``None``, iteration starts at zero.  Otherwise, "
"elements from the iterable are skipped until *start* is reached."
msgstr ""

#: ../../library/itertools.rst:477
msgid ""
"If *stop* is ``None``, iteration continues until the input is exhausted, "
"if at all.  Otherwise, it stops at the specified position."
msgstr ""

#: ../../library/itertools.rst:480
msgid ""
"If *step* is ``None``, the step defaults to one.  Elements are returned "
"consecutively unless *step* is set higher than one which results in items"
" being skipped."
msgstr ""

#: ../../library/itertools.rst:486
msgid ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"
msgstr ""

#: ../../library/itertools.rst:506
msgid ""
"If the input is an iterator, then fully consuming the *islice* advances "
"the input iterator by ``max(start, stop)`` steps regardless of the *step*"
" value."
msgstr ""

#: ../../library/itertools.rst:513
#, fuzzy
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr "입력 *iterable*\\에서 요소의 길이 *r* 서브 시퀀스들을 반환합니다."

#: ../../library/itertools.rst:515
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than "
"two values."
msgstr ""

#: ../../library/itertools.rst:521
msgid ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"
msgstr ""

#: ../../library/itertools.rst:536
#, fuzzy
msgid ""
"Return successive *r* length `permutations of elements "
"<https://www.britannica.com/science/permutation>`_ from the *iterable*."
msgstr "*iterable*\\에서 요소의 연속된 길이 *r* 순열을 반환합니다."

#: ../../library/itertools.rst:539
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length "
"of the *iterable* and all possible full-length permutations are "
"generated."
msgstr ""
"*r*\\이 지정되지 않았거나 ``None``\\이면, *r*\\의 기본값은 *iterable*\\의 길이이며 가능한 모든 최대 "
"길이 순열이 생성됩니다."

#: ../../library/itertools.rst:543
msgid ""
"The output is a subsequence of :func:`product` where entries with "
"repeated elements have been filtered out.  The length of the output is "
"given by :func:`math.perm` which computes ``n! / (n - r)!`` when ``0 ≤ r "
"≤ n`` or zero when ``r > n``."
msgstr ""

#: ../../library/itertools.rst:548
#, fuzzy
msgid ""
"The permutation tuples are emitted in lexicographic order according to "
"the order of the input *iterable*.  If the input *iterable* is sorted, "
"the output tuples will be produced in sorted order."
msgstr ""
"순열(permutation) 튜플은 입력 *iterable*\\의 순서에 따라 사전식 순서로 방출됩니다. 따라서, 입력 "
"*iterable*\\이 정렬되어 있으면, 순열 튜플이 정렬된 순서로 생성됩니다."

#: ../../library/itertools.rst:552
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their "
"value.  If the input elements are unique, there will be no repeated "
"values within a permutation."
msgstr "요소는 값이 아니라 위치로 고유성을 다룹니다. 따라서 입력 요소가 고유하면, 각 순열에 반복 값이 없습니다."

#: ../../library/itertools.rst:558
msgid ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"
msgstr ""

#: ../../library/itertools.rst:589
msgid ""
"`Cartesian product <https://en.wikipedia.org/wiki/Cartesian_product>`_ of"
" the input iterables."
msgstr ""

#: ../../library/itertools.rst:592
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y "
"in B)``."
msgstr ""
"대략 제너레이터 표현식에서의 중첩된 for-루프와 동등합니다. 예를 들어, ``product(A, B)``\\는 ``((x,y) "
"for x in A for y in B)``\\와 같은 것을 반환합니다."

#: ../../library/itertools.rst:595
msgid ""
"The nested loops cycle like an odometer with the rightmost element "
"advancing on every iteration.  This pattern creates a lexicographic "
"ordering so that if the input's iterables are sorted, the product tuples "
"are emitted in sorted order."
msgstr ""
"중첩된 루프는 매 이터레이션마다 가장 오른쪽 요소가 진행되는 주행 거리계처럼 순환합니다. 이 패턴은 사전식 순서를 만들어서 입력의 "
"이터러블들이 정렬되어 있다면, 곱(product) 튜플이 정렬된 순서로 방출됩니다."

#: ../../library/itertools.rst:600
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"이터러블의 자신과의 곱을 계산하려면, 선택적 *repeat* 키워드 인자를 사용하여 반복 횟수를 지정하십시오. 예를 들어, "
"``product(A, repeat=4)``\\는 ``product(A, A, A, A)``\\와 같은 것을 뜻합니다."

#: ../../library/itertools.rst:604
msgid ""
"This function is roughly equivalent to the following code, except that "
"the actual implementation does not build up intermediate results in "
"memory::"
msgstr "이 함수는 실제 구현이 메모리에 중간 결과를 쌓지 않는다는 점을 제외하고 다음 코드와 대략 동등합니다::"

#: ../../library/itertools.rst:607
msgid ""
"def product(*iterables, repeat=1):\n"
"    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111\n"
"\n"
"    if repeat < 0:\n"
"        raise ValueError('repeat argument cannot be negative')\n"
"    pools = [tuple(pool) for pool in iterables] * repeat\n"
"\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"\n"
"    for prod in result:\n"
"        yield tuple(prod)"
msgstr ""

#: ../../library/itertools.rst:622
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly,"
" it is only useful with finite inputs."
msgstr ""
":func:`product`\\가 실행되기 전에, 입력 이터러블을 완전히 소비하여, 곱을 생성하기 위해 값의 풀(pool)을 "
"메모리에 유지합니다. 따라서, 유한 입력에만 유용합니다."

#: ../../library/itertools.rst:629
#, fuzzy
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr ""
"*object*\\를 반복해서 반환하는 이터레이터를 만듭니다. *times* 인자가 지정되지 않으면 무기한 실행됩니다. 호출되는 "
"함수에 대한 불변 매개 변수를 위해 :func:`map`\\에 대한 인자로 사용됩니다. :func:`zip`\\과 함께 사용하여 "
"튜플 레코드의 불변 부분을 만들기도 합니다."

#: ../../library/itertools.rst:634
msgid ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"
msgstr ""

#: ../../library/itertools.rst:643
#, fuzzy
msgid ""
"A common use for *repeat* is to supply a stream of constant values to "
"*map* or *zip*:"
msgstr "*repeat*\\의 일반적인 용도는 *map*\\이나 *zip*\\에 상숫값 스트림을 제공하는 것입니다::"

#: ../../library/itertools.rst:646
msgid ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""

#: ../../library/itertools.rst:654
#, fuzzy
msgid ""
"Make an iterator that computes the *function* using arguments obtained "
"from the *iterable*.  Used instead of :func:`map` when argument "
"parameters have already been \"pre-zipped\" into tuples."
msgstr ""
"iterable에서 얻은 인자를 사용하여 함수를 계산하는 이터레이터를 만듭니다. 인자 매개 변수가 이미 단일 이터러블에 튜플로 "
"그룹화되어있을 때 (데이터가 \"미리 zip\" 되었을 때) :func:`map` 대신 사용됩니다. :func:`map`\\과 "
":func:`starmap`\\의 차이는 ``function(a,b)``\\와 ``function(*c)``\\의 차이와 "
"유사합니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:658
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""

#: ../../library/itertools.rst:662
msgid ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"
msgstr ""

#: ../../library/itertools.rst:670
#, fuzzy
msgid ""
"Make an iterator that returns elements from the *iterable* as long as the"
" *predicate* is true.  Roughly equivalent to::"
msgstr "술어(predicate)가 참인 한 iterable에서 요소를 반환하는 이터레이터를 만듭니다. 대략 다음과 동등합니다::"

#: ../../library/itertools.rst:673
msgid ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"
msgstr ""

#: ../../library/itertools.rst:680
msgid ""
"Note, the element that first fails the predicate condition is consumed "
"from the input iterator and there is no way to access it. This could be "
"an issue if an application wants to further consume the input iterator "
"after *takewhile* has been run to exhaustion.  To work around this "
"problem, consider using `more-itertools before_and_after() <https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_"
" instead."
msgstr ""

#: ../../library/itertools.rst:691
msgid "Return *n* independent iterators from a single iterable."
msgstr "단일 iterable에서 *n* 개의 독립 이터레이터를 반환합니다."

#: ../../library/itertools.rst:695
msgid ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"
msgstr ""

#: ../../library/itertools.rst:728
msgid ""
"When the input *iterable* is already a tee iterator object, all members "
"of the return tuple are constructed as if they had been produced by the "
"upstream :func:`tee` call.  This \"flattening step\" allows nested "
":func:`tee` calls to share the same underlying data chain and to have a "
"single update step rather than a chain of calls."
msgstr ""

#: ../../library/itertools.rst:734
msgid "The flattening property makes tee iterators efficiently peekable:"
msgstr ""

#: ../../library/itertools.rst:736
msgid ""
"def lookahead(tee_iterator):\n"
"     \"Return the next value without moving the input forward\"\n"
"     [forked_iterator] = tee(tee_iterator, 1)\n"
"     return next(forked_iterator)"
msgstr ""

#: ../../library/itertools.rst:743
msgid ""
">>> iterator = iter('abcdef')\n"
">>> [iterator] = tee(iterator, 1)   # Make the input peekable\n"
">>> next(iterator)                  # Move the iterator forward\n"
"'a'\n"
">>> lookahead(iterator)             # Check next value\n"
"'b'\n"
">>> next(iterator)                  # Continue moving forward\n"
"'b'"
msgstr ""

#: ../../library/itertools.rst:754
#, fuzzy
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised"
" when simultaneously using iterators returned by the same :func:`tee` "
"call, even if the original *iterable* is threadsafe."
msgstr ""
"``tee`` 이터레이터는 스레드 안전하지 않습니다. 원래 *iterable*\\이 스레드 안전해도, 같은 :func:`tee` "
"호출로 반환된 이터레이터를 동시에 사용하면 :exc:`RuntimeError`\\가 발생할 수 있습니다."

#: ../../library/itertools.rst:758
msgid ""
"This itertool may require significant auxiliary storage (depending on how"
" much temporary data needs to be stored). In general, if one iterator "
"uses most or all of the data before another iterator starts, it is faster"
" to use :func:`list` instead of :func:`tee`."
msgstr ""
"이 이터레이터 도구에는 상당한 보조 기억 장치가 필요할 수 있습니다 (일시적으로 저장해야 하는 데이터양에 따라 다릅니다). "
"일반적으로, 다른 이터레이터가 시작하기 전에 하나의 이터레이터가 대부분이나 모든 데이터를 사용하면, :func:`tee` 대신 "
":func:`list`\\를 사용하는 것이 더 빠릅니다."

#: ../../library/itertools.rst:766
msgid "Make an iterator that aggregates elements from each of the *iterables*."
msgstr ""

#: ../../library/itertools.rst:769
msgid ""
"If the iterables are of uneven length, missing values are filled-in with "
"*fillvalue*.  If not specified, *fillvalue* defaults to ``None``."
msgstr ""

#: ../../library/itertools.rst:772
msgid "Iteration continues until the longest iterable is exhausted."
msgstr ""

#: ../../library/itertools.rst:776
msgid ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"
msgstr ""

#: ../../library/itertools.rst:798
#, fuzzy
msgid ""
"If one of the iterables is potentially infinite, then the "
":func:`zip_longest` function should be wrapped with something that limits"
" the number of calls (for example :func:`islice` or :func:`takewhile`)."
msgstr ""
"이터러블 중 하나가 무한할 수 있으면, :func:`zip_longest` 함수는 호출 수를 제한하는 것으로 감싸야 합니다 (예를 "
"들어 :func:`islice`\\나 :func:`takewhile`). 지정하지 않으면, *fillvalue*\\의 기본값은 "
"``None``\\입니다."

#: ../../library/itertools.rst:806
msgid "Itertools Recipes"
msgstr "Itertools 조리법"

#: ../../library/itertools.rst:808
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "이 섹션에서는 기존 itertools를 빌딩 블록으로 사용하여 확장 도구 집합을 만드는 방법을 보여줍니다."

#: ../../library/itertools.rst:811
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes"
" show various ways of thinking about individual tools — for example, that"
" ``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``starmap()`` and ``repeat()`` can work together.  The "
"recipes also show patterns for using itertools with the :mod:`operator` "
"and :mod:`collections` modules as well as with the built-in itertools "
"such as ``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""

#: ../../library/itertools.rst:820
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started "
"out as recipes.  Currently, the ``sliding_window()``, ``iter_index()``, "
"and ``sieve()`` recipes are being tested to see whether they prove their "
"worth."
msgstr ""

#: ../../library/itertools.rst:825
#, fuzzy
msgid ""
"Substantially all of these recipes and many, many others can be installed"
" from the :pypi:`more-itertools` project found on the Python Package "
"Index::"
msgstr ""
"실질적으로 이 모든 조리법과 더 많은 조리법이 파이썬 패키지 색인(Python Package Index)에서 찾을 수 있는 "
"`more-itertools 프로젝트 <https://pypi.org/project/more-itertools/>`_\\로 설치할 "
"수 있습니다::"

#: ../../library/itertools.rst:829
msgid "python -m pip install more-itertools"
msgstr ""

#: ../../library/itertools.rst:831
#, fuzzy
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one "
"at a time rather than bringing the whole iterable into memory all at "
"once. Code volume is kept small by linking the tools together in a "
"`functional style "
"<https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_.  High"
" speed is retained by preferring \"vectorized\" building blocks over the "
"use of for-loops and :term:`generators <generator>` which incur "
"interpreter overhead."
msgstr ""
"확장 도구는 하부 도구 집합과 같은 고성능을 제공합니다. 전체 이터러블을 한 번에 메모리로 가져오지 않고 한 번에 하나씩 요소를 "
"처리하여 뛰어난 메모리 성능을 유지합니다. 도구를 함수형(functional) 스타일로 연결하여 임시 변수를 제거함으로써 코드 "
"크기를 작게 유지합니다. 인터프리터 오버헤드가 발생하는 for-루프와 :term:`제너레이터 <generator>`\\를 사용하는 "
"것보다 \"벡터화된\" 빌딩 블록을 선호하여 고속을 유지합니다."

#: ../../library/itertools.rst:839
msgid ""
"from collections import Counter, deque\n"
"from contextlib import suppress\n"
"from functools import reduce\n"
"from math import comb, prod, sumprod, isqrt\n"
"from operator import itemgetter, getitem, mul, neg\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list.\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable.\"\n"
"    # prepend(1, [2, 3, 4]) → 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def repeatfunc(function, times=None, *args):\n"
"    \"Repeat calls to a function with specified arguments.\"\n"
"    if times is None:\n"
"        return starmap(function, repeat(args))\n"
"    return starmap(function, repeat(args, times))\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting.\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times.\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def loops(n):\n"
"    \"Loop n times. Like range(n) but without creating integers.\"\n"
"    # for _ in loops(100): ...\n"
"    return repeat(None, n)\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items.\"\n"
"    # tail(3, 'ABCDEFG') → E F G\n"
"    return iter(deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume "
"entirely.\"\n"
"    # Use functions that consume iterators at C speed.\n"
"    if n is None:\n"
"        deque(iterator, maxlen=0)\n"
"    else:\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value.\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def quantify(iterable, predicate=bool):\n"
"    \"Given a predicate that returns True or False, count the True "
"results.\"\n"
"    return sum(map(predicate, iterable))\n"
"\n"
"def first_true(iterable, default=False, predicate=None):\n"
"    \"Returns the first true value or the *default* if there is no true "
"value.\"\n"
"    # first_true([a,b,c], x) → a or b or c or x\n"
"    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x\n"
"    return next(filter(predicate, iterable), default)\n"
"\n"
"def all_equal(iterable, key=None):\n"
"    \"Returns True if all the elements are equal to each other.\"\n"
"    # all_equal('4٤௪౪໔', key=int) → True\n"
"    return len(take(2, groupby(iterable, key))) <= 1\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember only the element "
"just seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.casefold) → A B c A D\n"
"    if key is None:\n"
"        return map(itemgetter(0), groupby(iterable))\n"
"    return map(next, map(itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember all elements ever"
" seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') → A B C D\n"
"    # unique_everseen('ABBcCAD', str.casefold) → A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"\n"
"def unique(iterable, key=None, reverse=False):\n"
"   \"Yield unique elements in sorted order. Supports unhashable inputs.\""
"\n"
"   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]\n"
"   sequenced = sorted(iterable, key=key, reverse=reverse)\n"
"   return unique_justseen(sequenced, key=key)\n"
"\n"
"def sliding_window(iterable, n):\n"
"    \"Collect data into overlapping fixed-length chunks or blocks.\"\n"
"    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG\n"
"    iterator = iter(iterable)\n"
"    window = deque(islice(iterator, n - 1), maxlen=n)\n"
"    for x in iterator:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF\n"
"    iterators = [iter(iterable)] * n\n"
"    match incomplete:\n"
"        case 'fill':\n"
"            return zip_longest(*iterators, fillvalue=fillvalue)\n"
"        case 'strict':\n"
"            return zip(*iterators, strict=True)\n"
"        case 'ignore':\n"
"            return zip(*iterators)\n"
"        case _:\n"
"            raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"Visit input iterables in a cycle until each is exhausted.\"\n"
"    # roundrobin('ABC', 'D', 'EF') → A D E B F C\n"
"    # Algorithm credited to George Sakkis\n"
"    iterators = map(iter, iterables)\n"
"    for num_active in range(len(iterables), 0, -1):\n"
"        iterators = cycle(islice(iterators, num_active))\n"
"        yield from map(next, iterators)\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence.\"\n"
"    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(getitem, repeat(seq), slices)\n"
"\n"
"def iter_index(iterable, value, start=0, stop=None):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') → 0 1 4 7\n"
"    seq_index = getattr(iterable, 'index', None)\n"
"    if seq_index is None:\n"
"        iterator = islice(iterable, start, stop)\n"
"        for i, element in enumerate(iterator, start):\n"
"            if element is value or element == value:\n"
"                yield i\n"
"    else:\n"
"        stop = len(iterable) if stop is None else stop\n"
"        i = start\n"
"        with suppress(ValueError):\n"
"            while True:\n"
"                yield (i := seq_index(value, i, stop))\n"
"                i += 1\n"
"\n"
"def iter_except(function, exception, first=None):\n"
"    \"Convert a call-until-exception interface to an iterator "
"interface.\"\n"
"    # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator"
"\n"
"    with suppress(exception):\n"
"        if first is not None:\n"
"            yield first()\n"
"        while True:\n"
"            yield function()"
msgstr ""

#: ../../library/itertools.rst:1008
msgid "The following recipes have a more mathematical flavor:"
msgstr ""

#: ../../library/itertools.rst:1010
msgid ""
"def powerset(iterable):\n"
"    \"Subsequences of the iterable from shortest to longest.\"\n"
"    # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in "
"range(len(s)+1))\n"
"\n"
"def sum_of_squares(iterable):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) → 1400\n"
"    return sumprod(*tee(iterable))\n"
"\n"
"def reshape(matrix, columns):\n"
"    \"Reshape a 2-D matrix to have a given number of columns.\"\n"
"    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)\n"
"    return batched(chain.from_iterable(matrix), columns, strict=True)\n"
"\n"
"def transpose(matrix):\n"
"    \"Swap the rows and columns of a 2-D matrix.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)\n"
"    return zip(*matrix, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    \"\"\"Discrete linear convolution of two iterables.\n"
"    Equivalent to polynomial multiplication.\n"
"\n"
"    Convolutions are mathematically commutative; however, the inputs are\n"
"    evaluated differently.  The signal is consumed lazily and can be\n"
"    infinite. The kernel is fully consumed before the calculations begin."
"\n"
"\n"
"    Article:  https://betterexplained.com/articles/intuitive-convolution/"
"\n"
"    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA\n"
"    \"\"\"\n"
"    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)\n"
"    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate\n"
"    # convolve(data, [1, -2, 1]) → 2nd derivative estimate\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))\n"
"    windowed_signal = sliding_window(padded_signal, n)\n"
"    return map(sumprod, repeat(kernel), windowed_signal)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]\n"
"    factors = zip(repeat(1), map(neg, roots))\n"
"    return list(reduce(convolve, factors, [1]))\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 5\n"
"    # polynomial_eval([1, -4, -17, 60], x=5) → 0\n"
"    n = len(coefficients)\n"
"    if not n:\n"
"        return type(x)(0)\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return sumprod(coefficients, powers)\n"
"\n"
"def polynomial_derivative(coefficients):\n"
"    \"\"\"Compute the first derivative of a polynomial.\n"
"\n"
"       f(x)  =  x³ -4x² -17x + 60\n"
"       f'(x) = 3x² -8x  -17\n"
"    \"\"\"\n"
"    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]\n"
"    n = len(coefficients)\n"
"    powers = reversed(range(1, n))\n"
"    return list(map(mul, coefficients, powers))\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n.\"\n"
"    # sieve(30) → 2 3 5 7 11 13 17 19 23 29\n"
"    if n > 2:\n"
"        yield 2\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    for p in iter_index(data, 1, start=3, stop=isqrt(n) + 1):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    yield from iter_index(data, 1, start=3)\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) → 3 3 11\n"
"    # factor(1_000_000_000_000_007) → 47 59 360620266859\n"
"    # factor(1_000_000_000_000_403) → 1000000000000403\n"
"    for prime in sieve(isqrt(n) + 1):\n"
"        while not n % prime:\n"
"            yield prime\n"
"            n //= prime\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def is_prime(n):\n"
"    \"Return True if n is prime.\"\n"
"    # is_prime(1_000_000_000_000_403) → True\n"
"    return n > 1 and next(factor(n)) == n\n"
"\n"
"def totient(n):\n"
"    \"Count of natural numbers up to n that are coprime to n.\"\n"
"    # https://mathworld.wolfram.com/TotientFunction.html\n"
"    # totient(12) → 4 because len([1, 5, 7, 11]) == 4\n"
"    for prime in set(factor(n)):\n"
"        n -= n // prime\n"
"    return n\n"
"\n"
"def multinomial(*counts):\n"
"    \"Number of distinct arrangements of a multiset.\"\n"
"    # Counter('abracadabra').values() → 5 2 2 1 1\n"
"    # multinomial(5, 2, 2, 1, 1) → 83160\n"
"    return prod(map(comb, accumulate(counts), counts))"
msgstr ""

#~ msgid ""
#~ "These tools and their built-in "
#~ "counterparts also work well with the "
#~ "high-speed functions in the "
#~ ":mod:`operator` module.  For example, the "
#~ "multiplication operator can be mapped "
#~ "across two vectors to form an "
#~ "efficient dot-product: ``sum(map(operator.mul, "
#~ "vector1, vector2))``."
#~ msgstr ""
#~ "이러한 도구와 그들의 내장 대응물들은 :mod:`operator` "
#~ "모듈의 고속 함수와도 잘 작동합니다. 예를 들어, "
#~ "곱셈 연산자는 두 벡터에 걸쳐 map 되어 효율적인"
#~ " 내적(dot-product)을 형성할 수 있습니다: "
#~ "``sum(map(operator.mul, vector1, vector2))``."

#~ msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
#~ msgstr "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#~ msgid ""
#~ "If *func* is supplied, it should "
#~ "be a function of two arguments. "
#~ "Elements of the input *iterable* may "
#~ "be any type that can be accepted"
#~ " as arguments to *func*. (For "
#~ "example, with the default operation of"
#~ " addition, elements may be any "
#~ "addable type including :class:`~decimal.Decimal` "
#~ "or :class:`~fractions.Fraction`.)"
#~ msgstr ""
#~ "*func*\\가 제공되면, 두 인자를 취하는 함수여야 "
#~ "합니다. 입력 *iterable*\\의 요소는 *func*\\에 대한"
#~ " 인자로 허용될 수 있는 모든 형일 수 "
#~ "있습니다. (예를 들어, 기본 더하기 연산에서 요소는 "
#~ ":class:`~decimal.Decimal`\\이나 :class:`~fractions.Fraction`\\을"
#~ " 포함하는 모든 더할 수 있는 형일 수 "
#~ "있습니다.)"

#~ msgid ""
#~ "There are a number of uses for "
#~ "the *func* argument.  It can be "
#~ "set to :func:`min` for a running "
#~ "minimum, :func:`max` for a running "
#~ "maximum, or :func:`operator.mul` for a "
#~ "running product.  Amortization tables can "
#~ "be built by accumulating interest and"
#~ " applying payments.  First-order "
#~ "`recurrence relations "
#~ "<https://en.wikipedia.org/wiki/Recurrence_relation>`_ can "
#~ "be modeled by supplying the initial "
#~ "value in the iterable and using "
#~ "only the accumulated total in *func* "
#~ "argument::"
#~ msgstr ""
#~ "*func* 인자는 여러 가지 용도가 있습니다. 누적 "
#~ "최솟값을 위해서는 :func:`min`, 누적 최댓값을 위해서는 "
#~ ":func:`max`, 누적 곱을 위해서는 "
#~ ":func:`operator.mul`\\로 설정할 수 있습니다. 할부 "
#~ "상환 표는 이자를 누적하고 지불을 적용하여 만들 수"
#~ " 있습니다. 일차 `점화식 "
#~ "<https://en.wikipedia.org/wiki/Recurrence_relation>`_\\은 "
#~ "iterable에 초깃값을 제공하고 *func* 인자에서 누적 "
#~ "합계만 사용하여 모델링 할 수 있습니다::"

#~ msgid ""
#~ "The code for :func:`combinations` can be"
#~ " also expressed as a subsequence of"
#~ " :func:`permutations` after filtering entries "
#~ "where the elements are not in "
#~ "sorted order (according to their "
#~ "position in the input pool)::"
#~ msgstr ""
#~ ":func:`combinations`\\의 코드는 요소가 정렬된 순서(입력 "
#~ "풀에서의 위치에 따라)가 아닌 항목을 걸러내어 만들어지는"
#~ " :func:`permutations`\\의 서브 시퀀스로 표현될 수도 "
#~ "있습니다::"

#~ msgid ""
#~ "The number of items returned is "
#~ "``n! / r! / (n-r)!`` when ``0 "
#~ "<= r <= n`` or zero when ``r"
#~ " > n``."
#~ msgstr ""
#~ "반환되는 항목 수는 ``0 <= r <= "
#~ "n``\\일 때는 ``n! / r! / (n-r)!`` "
#~ "이고 ``r > n``\\일 때는 0입니다."

#~ msgid ""
#~ "The code for :func:`combinations_with_replacement`"
#~ " can be also expressed as a "
#~ "subsequence of :func:`product` after filtering"
#~ " entries where the elements are not"
#~ " in sorted order (according to their"
#~ " position in the input pool)::"
#~ msgstr ""
#~ ":func:`combinations_with_replacement`\\의 코드는 요소가 정렬된"
#~ " 순서(입력 풀에서의 위치에 따라)가 아닌 항목을 "
#~ "걸러내어 만들어지는 :func:`product`\\의 서브 시퀀스로 "
#~ "표현될 수도 있습니다::"

#~ msgid ""
#~ "The number of items returned is "
#~ "``(n+r-1)! / r! / (n-1)!`` when "
#~ "``n > 0``."
#~ msgstr "반환되는 항목 수는 ``n > 0``\\일 때 ``(n+r-1)! / r! / (n-1)!`` 입니다."

#~ msgid ""
#~ "Make an iterator that drops elements "
#~ "from the iterable as long as the"
#~ " predicate is true; afterwards, returns "
#~ "every element.  Note, the iterator does"
#~ " not produce *any* output until the"
#~ " predicate first becomes false, so it"
#~ " may have a lengthy start-up "
#~ "time.  Roughly equivalent to::"
#~ msgstr ""
#~ "술어(predicate)가 참인 한 iterable에서 요소를 걸러내는"
#~ " 이터레이터를 만듭니다; 그 후에는 모든 요소를 "
#~ "반환합니다. 술어(predicate)가 처음 거짓이 될 때까지 "
#~ "이터레이터는 *아무런* 출력도 생성하지 않아서 시작 소요"
#~ " 시간이 길어질 수 있음에 유의하십시오. 대략 다음과"
#~ " 동등합니다::"

#~ msgid ""
#~ "Make an iterator that returns selected"
#~ " elements from the iterable. If "
#~ "*start* is non-zero, then elements "
#~ "from the iterable are skipped until "
#~ "start is reached. Afterward, elements "
#~ "are returned consecutively unless *step* "
#~ "is set higher than one which "
#~ "results in items being skipped.  If "
#~ "*stop* is ``None``, then iteration "
#~ "continues until the iterator is "
#~ "exhausted, if at all; otherwise, it "
#~ "stops at the specified position.  Unlike"
#~ " regular slicing, :func:`islice` does not"
#~ " support negative values for *start*, "
#~ "*stop*, or *step*.  Can be used to"
#~ " extract related fields from data "
#~ "where the internal structure has been"
#~ " flattened (for example, a multi-line"
#~ " report may list a name field "
#~ "on every third line).  Roughly "
#~ "equivalent to::"
#~ msgstr ""
#~ "iterable에서 선택된 요소를 반환하는 이터레이터를 만듭니다. "
#~ "*start*\\가 0이 아니면, iterable의 요소는 start에"
#~ " 도달할 때까지 건너뜁니다. 그 후에는 *step*\\이 "
#~ "1보다 크게 설정(이때는 항목을 건너뛰게 됩니다)되지 않는"
#~ " 한 요소가 연속적으로 반환됩니다. *stop*\\이 "
#~ "``None``\\이면, 이터레이터가 완전히 소진될 때까지 이터레이션이"
#~ " 계속됩니다 (소진한다면); 그렇지 않으면, 지정된 위치에서 "
#~ "멈춥니다. 일반 슬라이싱과 달리, :func:`islice`\\는 "
#~ "*start*, *stop* 또는 *step*\\에 대해 음수 "
#~ "값을 지원하지 않습니다. 내부 구조가 평탄화된 데이터에서"
#~ " 관련 필드를 추출하는 데 사용할 수 있습니다 "
#~ "(예를 들어, 여러 줄 보고서가 세 번째 줄마다"
#~ " 이름 필드를 나열할 수 있습니다). 대략 다음과 "
#~ "동등합니다::"

#~ msgid ""
#~ "If *start* is ``None``, then iteration"
#~ " starts at zero. If *step* is "
#~ "``None``, then the step defaults to "
#~ "one."
#~ msgstr ""
#~ "*start*\\가 ``None``\\이면, 이터레이션은 0에서 시작합니다. "
#~ "*step*\\이 ``None``\\이면, step의 기본값은 1입니다."

#~ msgid ""
#~ "The code for :func:`permutations` can be"
#~ " also expressed as a subsequence of"
#~ " :func:`product`, filtered to exclude "
#~ "entries with repeated elements (those "
#~ "from the same position in the "
#~ "input pool)::"
#~ msgstr ""
#~ ":func:`permutations`\\의 코드는 반복되는 요소(입력 풀에서 "
#~ "같은 위치에 있는 요소)가 있는 항목을 제외하도록 "
#~ "걸러낸 :func:`product`\\의 서브 시퀀스로 표현될 수도"
#~ " 있습니다::"

#~ msgid ""
#~ "The number of items returned is "
#~ "``n! / (n-r)!`` when ``0 <= r "
#~ "<= n`` or zero when ``r > "
#~ "n``."
#~ msgstr ""
#~ "반환되는 항목 수는 ``0 <= r <= "
#~ "n``\\일 때는 ``n! / (n-r)!`` 이고 ``r"
#~ " > n``\\일 때는 0입니다."

#~ msgid "Cartesian product of input iterables."
#~ msgstr "입력 이터러블들(iterables)의 데카르트 곱."

#~ msgid ""
#~ "The following Python code helps explain"
#~ " what *tee* does (although the actual"
#~ " implementation is more complex and "
#~ "uses only a single underlying "
#~ ":abbr:`FIFO (first-in, first-out)` "
#~ "queue)."
#~ msgstr ""
#~ "다음 파이썬 코드는 *tee*\\의 기능을 설명하는 데 "
#~ "도움이 됩니다 (하지만 실제 구현은 더 복잡하고 "
#~ "단일 하부 :abbr:`FIFO (선입 선출 - "
#~ "first-in, first-out)` 큐만 사용합니다)."

#~ msgid ""
#~ "Once :func:`tee` has made a split, "
#~ "the original *iterable* should not be"
#~ " used anywhere else; otherwise, the "
#~ "*iterable* could get advanced without "
#~ "the tee objects being informed."
#~ msgstr ""
#~ "일단 :func:`tee`\\가 분할되면, 원래 *iterable*\\을 "
#~ "다른 곳에서 사용해서는 안 됩니다; 그렇지 않으면, "
#~ "tee 객체에 알리지 않고 *iterable*\\이 진행할 수"
#~ " 있습니다."

#~ msgid ""
#~ "Make an iterator that aggregates "
#~ "elements from each of the iterables. "
#~ "If the iterables are of uneven "
#~ "length, missing values are filled-in "
#~ "with *fillvalue*. Iteration continues until"
#~ " the longest iterable is exhausted.  "
#~ "Roughly equivalent to::"
#~ msgstr ""
#~ "iterables의 각각에서 요소를 집계하는 이터레이터를 만듭니다."
#~ " 이터러블들의 길이가 고르지 않으면, 누락된 값이 "
#~ "*fillvalue*\\로 채워집니다. 가장 긴 이터러블이 소진될 "
#~ "때까지 이터레이션이 계속됩니다. 대략 다음과 동등합니다::"

