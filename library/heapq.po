# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/heapq.rst:2
#, fuzzy
msgid ":mod:`!heapq` --- Heap queue algorithm"
msgstr ":mod:`heapq` --- 힙 큐 알고리즘"

#: ../../library/heapq.rst:12
msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**소스 코드:** :source:`Lib/heapq.py`"

#: ../../library/heapq.rst:16
msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr "이 모듈은 우선순위 큐 알고리즘이라고도 하는 힙(heap) 큐 알고리즘의 구현을 제공합니다."

#: ../../library/heapq.rst:19
msgid ""
"Heaps are binary trees for which every parent node has a value less than "
"or equal to any of its children.  We refer to this condition as the heap "
"invariant."
msgstr ""

#: ../../library/heapq.rst:22
#, fuzzy
msgid ""
"This implementation uses arrays for which ``heap[k] <= heap[2*k+1]`` and "
"``heap[k] <= heap[2*k+2]`` for all *k*, counting elements from zero.  For"
" the sake of comparison, non-existing elements are considered to be "
"infinite.  The interesting property of a heap is that its smallest "
"element is always the root, ``heap[0]``."
msgstr ""
"힙은 모든 부모 노드가 자식보다 작거나 같은 값을 갖는 이진 트리입니다. 이 구현에서는 모든 *k*\\에 대해 ``heap[k] "
"<= heap[2*k+1]``\\과 ``heap[k] <= heap[2*k+2]``\\인 배열을 사용합니다, 요소는 0부터 셉니다."
" 비교를 위해, 존재하지 않는 요소는 무한으로 간주합니다. 힙의 흥미로운 특성은 가장 작은 요소가 항상 루트인 "
"``heap[0]``\\이라는 것입니다."

#: ../../library/heapq.rst:28
msgid ""
"The API below differs from textbook heap algorithms in two aspects: (a) "
"We use zero-based indexing.  This makes the relationship between the "
"index for a node and the indexes for its children slightly less obvious, "
"but is more suitable since Python uses zero-based indexing. (b) Our pop "
"method returns the smallest item, not the largest (called a \"min heap\" "
"in textbooks; a \"max heap\" is more common in texts because of its "
"suitability for in-place sorting)."
msgstr ""
"아래의 API는 두 가지 측면에서 교과서 힙 알고리즘과 다릅니다: (a) 우리는 0부터 시작하는 인덱싱을 사용합니다. 이것은 노드의"
" 인덱스와 자식의 인덱스 사이의 관계를 약간 덜 분명하게 만들지만, 파이썬이 0부터 시작하는 인덱스를 사용하기 때문에 더 "
"적합합니다. (b) pop 메서드는 가장 큰 항목이 아닌 가장 작은 항목을 반환합니다 (교과서에서는 \"최소 힙(min "
"heap)\"이라고 합니다; \"최대 힙(max heap)\"은 제자리 정렬에 적합하기 때문에 텍스트에서 더 흔합니다)."

#: ../../library/heapq.rst:35
msgid ""
"These two make it possible to view the heap as a regular Python list "
"without surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` "
"maintains the heap invariant!"
msgstr ""
"이 두 가지가 힙을 놀라지 않고도 일반 파이썬 목록으로 볼 수 있도록 만듭니다: ``heap[0]``\\은 가장 작은 항목이고, "
"``heap.sort()``\\는 힙의 불변성(invariant)을 유지합니다!"

#: ../../library/heapq.rst:39
msgid ""
"To create a heap, use a list initialized to ``[]``, or you can transform "
"a populated list into a heap via function :func:`heapify`."
msgstr ""
"힙을 만들려면, ``[]``\\로 초기화된 리스트를 사용하거나, 함수 :func:`heapify`\\를 통해 값이 들어 있는 "
"리스트를 힙으로 변환 할 수 있습니다."

#: ../../library/heapq.rst:42
msgid "The following functions are provided:"
msgstr "다음과 같은 함수가 제공됩니다:"

#: ../../library/heapq.rst:47
msgid "Push the value *item* onto the *heap*, maintaining the heap invariant."
msgstr "힙 불변성을 유지하면서, *item* 값을 *heap*\\으로 푸시합니다."

#: ../../library/heapq.rst:52
msgid ""
"Pop and return the smallest item from the *heap*, maintaining the heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access"
" the smallest item without popping it, use ``heap[0]``."
msgstr ""
"힙 불변성을 유지하면서, *heap*\\에서 가장 작은 항목을 팝하고 반환합니다. 힙이 비어 있으면, "
":exc:`IndexError`\\가 발생합니다. 팝 하지 않고 가장 작은 항목에 액세스하려면, ``heap[0]``\\을 "
"사용하십시오."

#: ../../library/heapq.rst:59
msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"힙에 *item*\\을 푸시한 다음, *heap*\\에서 가장 작은 항목을 팝하고 반환합니다. 결합한 액션은 "
":func:`heappush`\\한 다음 :func:`heappop`\\을 별도로 호출하는 것보다 더 효율적으로 실행합니다."

#: ../../library/heapq.rst:66
msgid "Transform list *x* into a heap, in-place, in linear time."
msgstr "리스트 *x*\\를 선형 시간으로 제자리에서 힙으로 변환합니다."

#: ../../library/heapq.rst:71
msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, "
":exc:`IndexError` is raised."
msgstr ""
"*heap*\\에서 가장 작은 항목을 팝하고 반환하며, 새로운 *item*\\도 푸시합니다. 힙 크기는 변경되지 않습니다. 힙이 "
"비어 있으면, :exc:`IndexError`\\가 발생합니다."

#: ../../library/heapq.rst:74
msgid ""
"This one step operation is more efficient than a :func:`heappop` followed"
" by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap "
"and replaces it with *item*."
msgstr ""
"이 한 단계 연산은 :func:`heappop`\\한 다음 :func:`heappush`\\하는 것보다 더 효율적이며 고정 크기 "
"힙을 사용할 때 더 적합 할 수 있습니다. 팝/푸시 조합은 항상 힙에서 요소를 반환하고 그것을 *item*\\으로 대체합니다."

#: ../../library/heapq.rst:79
msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger "
"value on the heap."
msgstr ""
"반환된 값은 추가된 *item*\\보다 클 수 있습니다. 그것이 바람직하지 않다면, 대신 :func:`heappushpop` 사용을"
" 고려하십시오. 푸시/팝 조합은 두 값 중 작은 값을 반환하여, 힙에 큰 값을 남겨 둡니다."

#: ../../library/heapq.rst:85
msgid "The module also offers three general purpose functions based on heaps."
msgstr "이 모듈은 또한 힙 기반의 세 가지 범용 함수를 제공합니다."

#: ../../library/heapq.rst:90
msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, "
"merge timestamped entries from multiple log files).  Returns an "
":term:`iterator` over the sorted values."
msgstr ""
"여러 정렬된 입력을 단일 정렬된 출력으로 병합합니다 (예를 들어, 여러 로그 파일에서 타임 스탬프 된 항목을 병합합니다). 정렬된 "
"값에 대한 :term:`이터레이터 <iterator>`\\를 반환합니다."

#: ../../library/heapq.rst:94
msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an "
"iterable, does not pull the data into memory all at once, and assumes "
"that each of the input streams is already sorted (smallest to largest)."
msgstr ""
"``sorted(itertools.chain(*iterables))``\\와 비슷하지만 이터러블을 반환하고, 데이터를 한 번에 "
"메모리로 가져오지 않으며, 각 입력 스트림이 이미 (최소에서 최대로) 정렬된 것으로 가정합니다."

#: ../../library/heapq.rst:98
msgid "Has two optional arguments which must be specified as keyword arguments."
msgstr "키워드 인자로 지정해야 하는 두 개의 선택적 인자가 있습니다."

#: ../../library/heapq.rst:100
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key*\\는 각 입력 요소에서 비교 키를 추출하는 데 사용되는 단일 인자의 :term:`키 함수 <key "
"function>`\\를 지정합니다. 기본값은 ``None``\\입니다 (요소를 직접 비교합니다)."

#: ../../library/heapq.rst:104
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input "
"elements are merged as if each comparison were reversed. To achieve "
"behavior similar to ``sorted(itertools.chain(*iterables), "
"reverse=True)``, all iterables must be sorted from largest to smallest."
msgstr ""
"*reverse*\\는 불리언 값입니다. ``True``\\로 설정하면, 각 비교가 반대로 된 것처럼 입력 요소가 병합됩니다. "
"``sorted(itertools.chain(*iterables), reverse=True)``\\와 유사한 동작을 달성하려면 모든"
" 이터러블이 최대에서 최소로 정렬되어 있어야 합니다."

#: ../../library/heapq.rst:109
msgid "Added the optional *key* and *reverse* parameters."
msgstr "선택적 *key*\\와 *reverse* 매개 변수를 추가했습니다."

#: ../../library/heapq.rst:115
msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument "
"that is used to extract a comparison key from each element in *iterable* "
"(for example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, "
"key=key, reverse=True)[:n]``."
msgstr ""
"*iterable*\\에 의해 정의된 데이터 집합에서 *n* 개의 가장 큰 요소로 구성된 리스트를 반환합니다. *key*\\가 "
"제공되면 *iterable*\\의 각 요소에서 비교 키를 추출하는 데 사용되는 단일 인자 함수를 지정합니다 (예를 들어, "
"``key=str.lower``). 다음과 동등합니다: ``sorted(iterable, key=key, "
"reverse=True)[:n]``."

#: ../../library/heapq.rst:124
msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument "
"that is used to extract a comparison key from each element in *iterable* "
"(for example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, "
"key=key)[:n]``."
msgstr ""
"*iterable*\\에 의해 정의된 데이터 집합에서 *n* 개의 가장 작은 요소로 구성된 리스트를 반환합니다. *key*\\가 "
"제공되면 *iterable*\\의 각 요소에서 비교 키를 추출하는 데 사용되는 단일 인자 함수를 지정합니다 (예를 들어, "
"``key=str.lower``). 다음과 동등합니다: ``sorted(iterable, key=key)[:n]``."

#: ../../library/heapq.rst:130
msgid ""
"The latter two functions perform best for smaller values of *n*.  For "
"larger values, it is more efficient to use the :func:`sorted` function.  "
"Also, when ``n==1``, it is more efficient to use the built-in :func:`min`"
" and :func:`max` functions.  If repeated usage of these functions is "
"required, consider turning the iterable into an actual heap."
msgstr ""
"마지막 두 함수는 작은 *n* 값에서 가장 잘 동작합니다. 값이 크면, :func:`sorted` 기능을 사용하는 것이 더 "
"효율적입니다. 또한, ``n==1``\\일 때는, 내장 :func:`min`\\과 :func:`max` 함수를 사용하는 것이 더 "
"효율적입니다. 이 함수를 반복해서 사용해야 하면, iterable을 실제 힙으로 바꾸는 것이 좋습니다."

#: ../../library/heapq.rst:138
msgid "Basic Examples"
msgstr "기본 예"

#: ../../library/heapq.rst:140
msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented"
" by pushing all values onto a heap and then popping off the smallest "
"values one at a time::"
msgstr ""
"`힙 정렬 <https://en.wikipedia.org/wiki/Heapsort>`_\\은 모든 값을 힙으로 푸시한 다음 한 번에"
" 하나씩 가장 작은 값을 팝 하여 구현할 수 있습니다::"

#: ../../library/heapq.rst:144
msgid ""
">>> def heapsort(iterable):\n"
"...     h = []\n"
"...     for value in iterable:\n"
"...         heappush(h, value)\n"
"...     return [heappop(h) for i in range(len(h))]\n"
"...\n"
">>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""

#: ../../library/heapq.rst:153
msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"이것은 ``sorted(iterable)``\\과 비슷하지만, :func:`sorted`\\와 달리, 이 구현은 "
"안정적(stable)이지 않습니다."

#: ../../library/heapq.rst:156
msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison "
"values (such as task priorities) alongside the main record being "
"tracked::"
msgstr "힙 요소는 튜플일 수 있습니다. 추적하는 기본 레코드와 함께 비교 값(가령 작업 우선순위)을 지정하는 데 유용합니다::"

#: ../../library/heapq.rst:159
msgid ""
">>> h = []\n"
">>> heappush(h, (5, 'write code'))\n"
">>> heappush(h, (7, 'release product'))\n"
">>> heappush(h, (1, 'write spec'))\n"
">>> heappush(h, (3, 'create tests'))\n"
">>> heappop(h)\n"
"(1, 'write spec')"
msgstr ""

#: ../../library/heapq.rst:169
msgid "Priority Queue Implementation Notes"
msgstr "우선순위 큐 구현 참고 사항"

#: ../../library/heapq.rst:171
msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is "
"common use for a heap, and it presents several implementation challenges:"
msgstr ""
"`우선순위 큐 <https://en.wikipedia.org/wiki/Priority_queue>`_\\는 힙의 일반적인 사용이며,"
" 몇 가지 구현 과제가 있습니다:"

#: ../../library/heapq.rst:174
msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr "정렬 안정성: 우선순위가 같은 두 개의 작업을 어떻게 원래 추가된 순서대로 반환합니까?"

#: ../../library/heapq.rst:177
msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr "우선순위가 같고 작업에 기본 비교 순서가 없으면 (우선순위, 작업) 쌍에 대한 튜플 비교가 성립하지 않습니다."

#: ../../library/heapq.rst:180
msgid ""
"If the priority of a task changes, how do you move it to a new position "
"in the heap?"
msgstr "작업의 우선순위가 변경되면, 어떻게 힙의 새로운 위치로 옮깁니까?"

#: ../../library/heapq.rst:183
msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove "
"it from the queue?"
msgstr "또는 계류 중인 작업을 삭제해야 하면, 작업을 어떻게 찾고 큐에서 제거합니까?"

#: ../../library/heapq.rst:186
msgid ""
"A solution to the first two challenges is to store entries as 3-element "
"list including the priority, an entry count, and the task.  The entry "
"count serves as a tie-breaker so that two tasks with the same priority "
"are returned in the order they were added. And since no two entry counts "
"are the same, the tuple comparison will never attempt to directly compare"
" two tasks."
msgstr ""
"처음 두 가지 과제에 대한 해결책은 항목을 우선순위, 항목 수 및 작업을 포함하는 3-요소 리스트로 저장하는 것입니다. 항목 수는 "
"순위 결정자 역할을 하므로 우선순위가 같은 두 작업이 추가된 순서대로 반환됩니다. 두 항목 수가 같은 경우는 없어서, 튜플 비교는 "
"두 작업을 직접 비교하려고 하지 않습니다."

#: ../../library/heapq.rst:192
msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr "비교할 수 없는 작업의 문제에 대한 또 다른 해결책은 작업 항목을 무시하고 우선순위 필드만 비교하는 래퍼 클래스를 만드는 것입니다::"

#: ../../library/heapq.rst:195
msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""

#: ../../library/heapq.rst:203
msgid ""
"The remaining challenges revolve around finding a pending task and making"
" changes to its priority or removing it entirely.  Finding a task can be "
"done with a dictionary pointing to an entry in the queue."
msgstr ""
"나머지 과제는 계류 중인 작업을 찾고 우선순위를 변경하거나 완전히 제거하는 것과 관련이 있습니다. 작업을 찾는 것은 큐에 있는 "
"항목을 가리키는 딕셔너리를 사용해서 해결할 수 있습니다."

#: ../../library/heapq.rst:207
msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to"
" mark the entry as removed and add a new entry with the revised "
"priority::"
msgstr ""
"힙 구조 불변성을 깨뜨리기 때문에 항목을 제거하거나 우선순위를 변경하는 것은 더 어렵습니다. 따라서, 가능한 해결책은 항목을 제거된"
" 것으로 표시하고 우선순위가 수정된 새 항목을 추가하는 것입니다::"

#: ../../library/heapq.rst:211
#, python-brace-format
msgid ""
"pq = []                         # list of entries arranged in a heap\n"
"entry_finder = {}               # mapping of tasks to entries\n"
"REMOVED = '<removed-task>'      # placeholder for a removed task\n"
"counter = itertools.count()     # unique sequence count\n"
"\n"
"def add_task(task, priority=0):\n"
"    'Add a new task or update the priority of an existing task'\n"
"    if task in entry_finder:\n"
"        remove_task(task)\n"
"    count = next(counter)\n"
"    entry = [priority, count, task]\n"
"    entry_finder[task] = entry\n"
"    heappush(pq, entry)\n"
"\n"
"def remove_task(task):\n"
"    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n"
"    entry = entry_finder.pop(task)\n"
"    entry[-1] = REMOVED\n"
"\n"
"def pop_task():\n"
"    'Remove and return the lowest priority task. Raise KeyError if "
"empty.'\n"
"    while pq:\n"
"        priority, count, task = heappop(pq)\n"
"        if task is not REMOVED:\n"
"            del entry_finder[task]\n"
"            return task\n"
"    raise KeyError('pop from an empty priority queue')"
msgstr ""

#: ../../library/heapq.rst:241
msgid "Theory"
msgstr "이론"

#: ../../library/heapq.rst:243
msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` "
"for all *k*, counting elements from 0.  For the sake of comparison, non-"
"existing elements are considered to be infinite.  The interesting "
"property of a heap is that ``a[0]`` is always its smallest element."
msgstr ""
"힙은 0부터 요소를 셀 때, 모든 *k*\\에 대해 ``a[k] <= a[2*k+1]``\\와 ``a[k] <= "
"a[2*k+2]``\\가 유지되는 배열입니다. 비교를 위해, 존재하지 않는 요소는 무한인 것으로 간주합니다. 힙의 흥미로운 특성은 "
"``a[0]``\\이 항상 가장 작은 요소라는 것입니다."

#: ../../library/heapq.rst:248
msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not "
"``a[k]``::"
msgstr ""
"위의 특이한 불변성은 토너먼트를 위한 효율적인 메모리 표현을 위한 것입니다. 아래 숫자는 ``a[k]``\\가 아니라 "
"*k*\\입니다::"

#: ../../library/heapq.rst:251
msgid ""
"                               0\n"
"\n"
"              1                                 2\n"
"\n"
"      3               4                5               6\n"
"\n"
"  7       8       9       10      11      12      13      14\n"
"\n"
"15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30"
msgstr ""

#: ../../library/heapq.rst:261
msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a"
" usual binary tournament we see in sports, each cell is the winner over "
"the two cells it tops, and we can trace the winner down the tree to see "
"all opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the"
" two cells it tops contain three different items, but the top cell "
"\"wins\" over the two topped cells."
msgstr ""
"위의 트리에서, 각 셀 *k*\\는 ``2*k+1``\\과 ``2*k+2``\\위에 있습니다. 우리가 스포츠에서 볼 수 있는 "
"일반적인 이진 토너먼트에서, 각 셀은 아래에 있는 두 개의 셀의 승자가 되며, 트리 아래로 승자를 추적하여 모든 상대를 볼 수 "
"있습니다. 그러나, 이러한 토너먼트의 많은 컴퓨터 응용에서 승자의 이력을 추적할 필요는 없습니다. 메모리 효율성을 높이기 위해, "
"승자가 승격될 때, 하위 수준에서 다른 것으로 대체하려고 시도합니다. 규칙은 셀과 셀 아래의 두 셀이 세 개의 다른 항목을 "
"포함하지만, 위의 셀은 아래의 두 셀에 \"이기는\" 것입니다."

#: ../../library/heapq.rst:270
#, fuzzy
msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly"
" logarithmic on the total number of items in the tree. By iterating over "
"all items, you get an *O*\\ (*n* log *n*) sort."
msgstr ""
"이 힙 불변성이 항상 보호된다면, 인덱스 0은 분명히 최종 승자입니다. 이것을 제거하고 \"다음\" 승자를 찾는 가장 간단한 "
"알고리즘 적인 방법은 어떤 패자(위의 도표에서 셀 30이라고 합시다)를 0 위치로 옮기고, 불변성을 다시 만족할 때까지 값을 "
"교환하면서 이 새로운 0을 트리 아래로 침투시키는 것입니다. 이것은 트리의 총 항목 수에 대해 분명히 로그 "
"함수적(logarithmic)입니다. 모든 항목에 대해 반복하면, O(n log n) 정렬을 얻게 됩니다."

#: ../../library/heapq.rst:277
msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not "
"\"better\" than the last 0'th element you extracted.  This is especially "
"useful in simulation contexts, where the tree holds all incoming events, "
"and the \"win\" condition means the smallest scheduled time.  When an "
"event schedules other events for execution, they are scheduled into the "
"future, so they can easily go into the heap.  So, a heap is a good "
"structure for implementing schedulers (this is what I used for my MIDI "
"sequencer :-)."
msgstr ""
"이 정렬의 멋진 기능은 삽입된 항목이 추출한 마지막 0번째 요소보다 \"더 나은\" 항목이 아니라면, 정렬이 진행되는 동안 새 "
"항목을 효율적으로 삽입 할 수 있다는 것입니다. 이는 트리가 들어오는 모든 이벤트를 담고, \"승리\" 조건이 가장 작은 예약 "
"시간을 의미하는 시뮬레이션 문맥에서 특히 유용합니다. 이벤트가 실행을 위해 다른 이벤트를 예약하면, 이들은 미래에 예약되어서, 쉽게"
" 힙에 들어갈 수 있습니다. 따라서, 힙은 스케줄러를 구현하기에 좋은 구조입니다 (이것이 제가 MIDI 시퀀서에 사용한 것입니다 "
":-)."

#: ../../library/heapq.rst:286
msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than "
"the average case. However, there are other representations which are more"
" efficient overall, yet the worst cases might be terrible."
msgstr ""
"스케줄러를 구현하기 위한 다양한 구조가 광범위하게 연구되었으며, 힙은 합리적으로 빠르며, 속도가 거의 일정합니다, 최악의 경우는 "
"평균 경우와 크게 다르지 않기 때문에 스케줄러에 좋습니다. 하지만, 최악의 경우는 끔찍할 수 있습니다만, 전반적으로 더 효율적인 "
"다른 표현이 있기는 합니다."

#: ../../library/heapq.rst:292
msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know"
" that a big sort implies producing \"runs\" (which are pre-sorted "
"sequences, whose size is usually related to the amount of CPU memory), "
"followed by a merging passes for these runs, which merging is often very "
"cleverly organised [#]_. It is very important that the initial sort "
"produces the longest runs possible.  Tournaments are a good way to "
"achieve that.  If, using all the memory available to hold a tournament, "
"you replace and percolate items that happen to fit the current run, "
"you'll produce runs which are twice the size of the memory for random "
"input, and much better for input fuzzily ordered."
msgstr ""
"힙은 큰 디스크 정렬에도 매우 유용합니다. 여러분은 아마도 큰 정렬은 \"런(runs)\"(크기가 일반적으로 CPU 메모리 크기와 "
"관련된 사전 정렬된 시퀀스)을 생성한 후에 이러한 런들에 대한 병합 패스가 따라옴을 의미하며, 이러한 병합은 종종 매우 영리하게 "
"조직됨을 알고 있을 겁니다 [#]_. 초기 정렬이 가능한 한 가장 긴 런을 생성하는 것이 매우 중요합니다. 토너먼트는 이를 달성하기"
" 위한 좋은 방법입니다. 토너먼트를 개최하는 데 사용할 수 있는 모든 메모리를 사용하여 현재 런에 맞는 항목들을 교체하고 "
"침투시키면, 무작위 입력을 위한 메모리 크기의 두 배인 런을 생성하게 되고, 적당히 정렬된 입력에 대해서는 더 좋습니다."

#: ../../library/heapq.rst:302
msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may "
"not fit in the current tournament (because the value \"wins\" over the "
"last output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same "
"rate the first heap is melting.  When the first heap completely vanishes,"
" you switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"더 나아가, 또한 디스크에 0번째 항목을 출력하고 현재 토너먼트에 맞지 않는 입력을 받으면 (그 값이 마지막 출력값을 \"이기기\""
" 때문에), 힙에 넣을 수 없어서 힙의 크기가 줄어듭니다. 해제된 메모리는 두 번째 힙을 점진적으로 구축하는데 즉시 영리하게 "
"재사용될 수 있고, 두 번째 힙이 자라는 속도는 첫 번째 힙이 줄어드는 것과 같습니다. 첫 번째 힙이 완전히 사라지면, 힙을 "
"전환하고 새 런을 시작합니다. 영리하고 매우 효과적입니다!"

#: ../../library/heapq.rst:310
msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a "
"few applications, and I think it is good to keep a 'heap' module around. "
":-)"
msgstr ""
"한마디로, 힙은 알아두어야 할 유용한 메모리 구조입니다. 저는 몇 가지 응용 프로그램에서 사용하며, '힙' 모듈을 근처에 두는 것이"
" 좋다고 생각합니다. :-)"

#: ../../library/heapq.rst:314
msgid "Footnotes"
msgstr "각주"

#: ../../library/heapq.rst:315
msgid ""
"The disk balancing algorithms which are current, nowadays, are more "
"annoying than clever, and this is a consequence of the seeking "
"capabilities of the disks. On devices which cannot seek, like big tape "
"drives, the story was quite different, and one had to be very clever to "
"ensure (far in advance) that each tape movement will be the most "
"effective possible (that is, will best participate at \"progressing\" the"
" merge).  Some tapes were even able to read backwards, and this was also "
"used to avoid the rewinding time. Believe me, real good tape sorts were "
"quite spectacular to watch! From all times, sorting has always been a "
"Great Art! :-)"
msgstr ""
"요즘 최신 디스크 밸런싱 알고리즘은 영리하다기보다는 성가시며, 이는 디스크의 탐색(seek) 기능으로 인한 결과입니다. 큰 테이프 "
"드라이브와 같이 탐색할 수 없는 장치에서는, 이야기가 상당히 달랐으며, 각 테이프 움직임이 가장 효과적일 수 있도록 (즉, 병합을 "
"\"진행하는데\" 최대한 참여할 수 있도록) (일찌감치) 계획하기 위해 아주 영리해야 했습니다. 일부 테이프는 반대 방향으로 읽을 "
"수도 있었으며, 이것은 되감기 시간을 피하는 데 사용되기도 했습니다. 저를 믿으십시오, 진짜 훌륭한 테이프 정렬은 장관이었습니다! "
"언제나, 정렬은 항상 위대한 예술이었습니다! :-)"

