# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/urllib.parse.rst:2
#, fuzzy
msgid ":mod:`!urllib.parse` --- Parse URLs into components"
msgstr ":mod:`urllib.parse` --- URL을 구성 요소로 구문 분석"

#: ../../library/urllib.parse.rst:7
msgid "**Source code:** :source:`Lib/urllib/parse.py`"
msgstr "**소스 코드:** :source:`Lib/urllib/parse.py`"

#: ../../library/urllib.parse.rst:18
msgid ""
"This module defines a standard interface to break Uniform Resource "
"Locator (URL) strings up in components (addressing scheme, network "
"location, path etc.), to combine the components back into a URL string, "
"and to convert a \"relative URL\" to an absolute URL given a \"base "
"URL.\""
msgstr ""
"이 모듈은 URL(Uniform Resource Locator) 문자열을 구성 요소(주소 지정 체계, 네트워크 위치, 경로 등)로 "
"분리하고, 구성 요소를 다시 URL 문자열로 결합하고, \"상대 URL\"을 주어진 \"기본 URL\"에 따라 절대 URL로 "
"변환하는 표준 인터페이스를 정의합니다."

#: ../../library/urllib.parse.rst:23
#, fuzzy
msgid ""
"The module has been designed to match the internet RFC on Relative "
"Uniform Resource Locators. It supports the following URL schemes: "
"``file``, ``ftp``, ``gopher``, ``hdl``, ``http``, ``https``, ``imap``, "
"``itms-services``, ``mailto``, ``mms``, ``news``, ``nntp``, ``prospero``,"
" ``rsync``, ``rtsp``, ``rtsps``, ``rtspu``, ``sftp``, ``shttp``, ``sip``,"
" ``sips``, ``snews``, ``svn``, ``svn+ssh``, ``telnet``, ``wais``, ``ws``,"
" ``wss``."
msgstr ""
"이 모듈은 상대 URL(Relative Uniform Resource Locators)의 인터넷 RFC와 일치하도록 설계되었습니다."
" 다음과 같은 URL 스킴을 지원합니다: ``file``, ``ftp``, ``gopher``, ``hdl``, ``http``, "
"``https``, ``imap``, ``mailto``, ``mms``, ``news``, ``nntp``, "
"``prospero``, ``rsync``, ``rtsp``, ``rtspu``, ``sftp``, ``shttp``, "
"``sip``, ``sips``, ``snews``, ``svn``, ``svn+ssh``, ``telnet``, ``wais``,"
" ``ws``, ``wss``."

#: ../../library/urllib.parse.rst:32
msgid ""
"The inclusion of the ``itms-services`` URL scheme can prevent an app from"
" passing Apple's App Store review process for the macOS and iOS App "
"Stores. Handling for the ``itms-services`` scheme is always removed on "
"iOS; on macOS, it *may* be removed if CPython has been built with the "
":option:`--with-app-store-compliance` option."
msgstr ""

#: ../../library/urllib.parse.rst:38
msgid ""
"The :mod:`urllib.parse` module defines functions that fall into two broad"
" categories: URL parsing and URL quoting. These are covered in detail in "
"the following sections."
msgstr ""
":mod:`urllib.parse` 모듈은 두 가지 넓은 범주에 속하는 함수들을 정의합니다: URL 구문 분석과 URL "
"인용(quoting). 이에 대해서는 다음 섹션에서 자세히 설명합니다."

#: ../../library/urllib.parse.rst:42
msgid ""
"This module's functions use the deprecated term ``netloc`` (or "
"``net_loc``), which was introduced in :rfc:`1808`. However, this term has"
" been obsoleted by :rfc:`3986`, which introduced the term ``authority`` "
"as its replacement. The use of ``netloc`` is continued for backward "
"compatibility."
msgstr ""

#: ../../library/urllib.parse.rst:48
msgid "URL Parsing"
msgstr "URL 구문 분석"

#: ../../library/urllib.parse.rst:50
msgid ""
"The URL parsing functions focus on splitting a URL string into its "
"components, or on combining URL components into a URL string."
msgstr "URL 구문 분석 함수는 URL 문자열을 구성 요소로 분할하거나 URL 구성 요소를 URL 문자열로 결합하는 데 중점을 둡니다."

#: ../../library/urllib.parse.rst:55
#, python-format
msgid ""
"Parse a URL into six components, returning a 6-item :term:`named tuple`."
"  This corresponds to the general structure of a URL: "
"``scheme://netloc/path;parameters?query#fragment``. Each tuple item is a "
"string, possibly empty. The components are not broken up into smaller "
"parts (for example, the network location is a single string), and % "
"escapes are not expanded. The delimiters as shown above are not part of "
"the result, except for a leading slash in the *path* component, which is "
"retained if present.  For example:"
msgstr ""
"URL을 6개의 구성 요소로 구문 분석하여, 6개 항목 :term:`네임드 튜플 <named tuple>`\\을 반환합니다. 이는 "
"URL의 일반적인 구조에 해당합니다: ``scheme://netloc/path;parameters?query#fragment``. "
"각 튜플 항목은 문자열이며 비어있을 수 있습니다. 구성 요소는 더 작은 부분으로 나뉘지 않으며 (예를 들어 네트워크 위치는 단일 "
"문자열입니다), % 이스케이프는 확장되지 않습니다. 위에 표시된 분리 문자는 *path* 구성 요소의 선행 슬래시를 제외하고는 "
"결과의 일부가 아니며 존재하면 유지됩니다. 예를 들면:"

#: ../../library/urllib.parse.rst:64
msgid ""
">>> from urllib.parse import urlparse\n"
">>> urlparse(\"scheme://netloc/path;parameters?query#fragment\")\n"
"ParseResult(scheme='scheme', netloc='netloc', path='/path;parameters', "
"params='',\n"
"            query='query', fragment='fragment')\n"
">>> o = "
"urlparse(\"http://docs.python.org:80/3/library/urllib.parse.html?\"\n"
"...              \"highlight=params#url-parsing\")\n"
">>> o\n"
"ParseResult(scheme='http', netloc='docs.python.org:80',\n"
"            path='/3/library/urllib.parse.html', params='',\n"
"            query='highlight=params', fragment='url-parsing')\n"
">>> o.scheme\n"
"'http'\n"
">>> o.netloc\n"
"'docs.python.org:80'\n"
">>> o.hostname\n"
"'docs.python.org'\n"
">>> o.port\n"
"80\n"
">>> o._replace(fragment=\"\").geturl()\n"
"'http://docs.python.org:80/3/library/urllib.parse.html?highlight=params'"
msgstr ""

#: ../../library/urllib.parse.rst:88
msgid ""
"Following the syntax specifications in :rfc:`1808`, urlparse recognizes a"
" netloc only if it is properly introduced by '//'.  Otherwise the input "
"is presumed to be a relative URL and thus to start with a path component."
msgstr ""
":rfc:`1808`\\의 문법 명세에 따라, urlparse는 '//' 로 올바르게 도입되었을 때만 netloc을 인식합니다. "
"그렇지 않으면 입력은 상대 URL인 것으로 간주하고 path 구성 요소로 시작합니다."

#: ../../library/urllib.parse.rst:93
#, python-format
msgid ""
">>> from urllib.parse import urlparse\n"
">>> urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n"
"ParseResult(scheme='', netloc='www.cwi.nl:80', "
"path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> urlparse('www.cwi.nl/%7Eguido/Python.html')\n"
"ParseResult(scheme='', netloc='', path='www.cwi.nl/%7Eguido/Python.html',"
"\n"
"            params='', query='', fragment='')\n"
">>> urlparse('help/Python.html')\n"
"ParseResult(scheme='', netloc='', path='help/Python.html', params='',\n"
"            query='', fragment='')"
msgstr ""

#: ../../library/urllib.parse.rst:107
msgid ""
"The *scheme* argument gives the default addressing scheme, to be used "
"only if the URL does not specify one.  It should be the same type (text "
"or bytes) as *urlstring*, except that the default value ``''`` is always "
"allowed, and is automatically converted to ``b''`` if appropriate."
msgstr ""
"*scheme* 인자는 URL이 지정하지 않은 경우에만 사용될 기본 주소 지정 체계를 제공합니다. 기본값 ``''``\\가 항상 "
"허용되고 필요하면 자동으로 ``b''``\\로 변환된다는 점을 제외하고, *urlstring*\\과 같은 형(텍스트나 "
"바이트열)이어야 합니다."

#: ../../library/urllib.parse.rst:112
msgid ""
"If the *allow_fragments* argument is false, fragment identifiers are not "
"recognized.  Instead, they are parsed as part of the path, parameters or "
"query component, and :attr:`fragment` is set to the empty string in the "
"return value."
msgstr ""
"*allow_fragments* 인자가 거짓이면, 프래그먼트 식별자는 인식되지 않습니다. 대신, path, parameters 또는"
" query 구성 요소의 일부로 구문 분석되고 :attr:`fragment`\\는 반환 값에서 빈 문자열로 설정됩니다."

#: ../../library/urllib.parse.rst:117
msgid ""
"The return value is a :term:`named tuple`, which means that its items can"
" be accessed by index or as named attributes, which are:"
msgstr ""
"반환 값은 :term:`네임드 튜플 <named tuple>`\\입니다. 즉, 다음과 같은 인덱스나 이름있는 어트리뷰트로 해당 "
"항목에 액세스 할 수 있습니다:"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Attribute"
msgstr "어트리뷰트"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Index"
msgstr "인덱스"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Value"
msgstr "값"

#: ../../library/urllib.parse.rst:121 ../../library/urllib.parse.rst:310
#: ../../library/urllib.parse.rst:432
msgid "Value if not present"
msgstr "존재하지 않을 때의 값"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
msgid ":attr:`scheme`"
msgstr ":attr:`scheme`"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
#: ../../library/urllib.parse.rst:434
msgid "0"
msgstr "0"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
msgid "URL scheme specifier"
msgstr "URL 스킴 지정자"

#: ../../library/urllib.parse.rst:123 ../../library/urllib.parse.rst:312
msgid "*scheme* parameter"
msgstr "*scheme* 매개 변수"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:314
msgid ":attr:`netloc`"
msgstr ":attr:`netloc`"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:314
#: ../../library/urllib.parse.rst:436
msgid "1"
msgstr "1"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:314
msgid "Network location part"
msgstr "네트워크 위치 부분"

#: ../../library/urllib.parse.rst:125 ../../library/urllib.parse.rst:127
#: ../../library/urllib.parse.rst:129 ../../library/urllib.parse.rst:132
#: ../../library/urllib.parse.rst:134 ../../library/urllib.parse.rst:314
#: ../../library/urllib.parse.rst:316 ../../library/urllib.parse.rst:318
#: ../../library/urllib.parse.rst:320 ../../library/urllib.parse.rst:434
#: ../../library/urllib.parse.rst:436
msgid "empty string"
msgstr "빈 문자열"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:316
msgid ":attr:`path`"
msgstr ":attr:`path`"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:316
msgid "2"
msgstr "2"

#: ../../library/urllib.parse.rst:127 ../../library/urllib.parse.rst:316
msgid "Hierarchical path"
msgstr "계층적 경로"

#: ../../library/urllib.parse.rst:129
msgid ":attr:`params`"
msgstr ":attr:`params`"

#: ../../library/urllib.parse.rst:129 ../../library/urllib.parse.rst:318
msgid "3"
msgstr "3"

#: ../../library/urllib.parse.rst:129
msgid "Parameters for last path element"
msgstr "마지막 경로 요소의 파라미터"

#: ../../library/urllib.parse.rst:132 ../../library/urllib.parse.rst:318
msgid ":attr:`query`"
msgstr ":attr:`query`"

#: ../../library/urllib.parse.rst:132 ../../library/urllib.parse.rst:320
msgid "4"
msgstr "4"

#: ../../library/urllib.parse.rst:132 ../../library/urllib.parse.rst:318
msgid "Query component"
msgstr "쿼리 구성 요소"

#: ../../library/urllib.parse.rst:134 ../../library/urllib.parse.rst:320
#: ../../library/urllib.parse.rst:436
msgid ":attr:`fragment`"
msgstr ":attr:`fragment`"

#: ../../library/urllib.parse.rst:134
msgid "5"
msgstr "5"

#: ../../library/urllib.parse.rst:134 ../../library/urllib.parse.rst:320
#: ../../library/urllib.parse.rst:436
msgid "Fragment identifier"
msgstr "프래그먼트 식별자"

#: ../../library/urllib.parse.rst:136 ../../library/urllib.parse.rst:322
msgid ":attr:`username`"
msgstr ":attr:`username`"

#: ../../library/urllib.parse.rst:136 ../../library/urllib.parse.rst:322
msgid "User name"
msgstr "사용자 이름"

#: ../../library/urllib.parse.rst:136 ../../library/urllib.parse.rst:138
#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:142
#: ../../library/urllib.parse.rst:322 ../../library/urllib.parse.rst:324
#: ../../library/urllib.parse.rst:326 ../../library/urllib.parse.rst:328
msgid ":const:`None`"
msgstr ":const:`None`"

#: ../../library/urllib.parse.rst:138 ../../library/urllib.parse.rst:324
msgid ":attr:`password`"
msgstr ":attr:`password`"

#: ../../library/urllib.parse.rst:138 ../../library/urllib.parse.rst:324
msgid "Password"
msgstr "비밀번호"

#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:326
msgid ":attr:`hostname`"
msgstr ":attr:`hostname`"

#: ../../library/urllib.parse.rst:140 ../../library/urllib.parse.rst:326
msgid "Host name (lower case)"
msgstr "호스트 이름 (소문자)"

#: ../../library/urllib.parse.rst:142 ../../library/urllib.parse.rst:328
msgid ":attr:`port`"
msgstr ":attr:`port`"

#: ../../library/urllib.parse.rst:142 ../../library/urllib.parse.rst:328
msgid "Port number as integer, if present"
msgstr "존재하면, 정수로 표시되는 포트 번호"

#: ../../library/urllib.parse.rst:146 ../../library/urllib.parse.rst:332
msgid ""
"Reading the :attr:`port` attribute will raise a :exc:`ValueError` if an "
"invalid port is specified in the URL.  See section :ref:`urlparse-result-"
"object` for more information on the result object."
msgstr ""
"URL에 잘못된 포트가 지정된 경우 :attr:`port` 어트리뷰트를 읽으면 :exc:`ValueError`\\가 발생합니다. "
"결과 객체에 대한 자세한 내용은 :ref:`urlparse-result-object` 섹션을 참조하십시오."

#: ../../library/urllib.parse.rst:150 ../../library/urllib.parse.rst:336
msgid ""
"Unmatched square brackets in the :attr:`netloc` attribute will raise a "
":exc:`ValueError`."
msgstr ""
":attr:`netloc` 어트리뷰트에서 대괄호(square brackets)가 일치하지 않으면 "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/urllib.parse.rst:153 ../../library/urllib.parse.rst:339
msgid ""
"Characters in the :attr:`netloc` attribute that decompose under NFKC "
"normalization (as used by the IDNA encoding) into any of ``/``, ``?``, "
"``#``, ``@``, or ``:`` will raise a :exc:`ValueError`. If the URL is "
"decomposed before parsing, no error will be raised."
msgstr ""
"(IDNA 인코딩에서 사용되는) NFKC 정규화에서 ``/``, ``?``, ``#``, ``@`` 또는 ``:`` 중 하나로 "
"분해(decompose)되는 :attr:`netloc` 어트리뷰트의 문자는 :exc:`ValueError`\\를 발생시킵니다. 구문"
" 분석하기 전에 URL이 분해(decompose)되면, 에러가 발생하지 않습니다."

#: ../../library/urllib.parse.rst:158
msgid ""
"As is the case with all named tuples, the subclass has a few additional "
"methods and attributes that are particularly useful. One such method is "
":meth:`_replace`. The :meth:`_replace` method will return a new "
"ParseResult object replacing specified fields with new values."
msgstr ""
"모든 네임드 튜플의 경우와 마찬가지로, 서브 클래스는 특히 유용한 몇 가지 추가 메서드와 어트리뷰트를 갖습니다. 그러한 메서드 중 "
"하나는 :meth:`_replace`\\입니다. :meth:`_replace` 메서드는 지정된 필드를 새로운 값으로 대체한 새로운 "
"ParseResult 객체를 반환합니다."

#: ../../library/urllib.parse.rst:163
#, python-format
msgid ""
">>> from urllib.parse import urlparse\n"
">>> u = urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n"
">>> u\n"
"ParseResult(scheme='', netloc='www.cwi.nl:80', "
"path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')\n"
">>> u._replace(scheme='http')\n"
"ParseResult(scheme='http', netloc='www.cwi.nl:80', "
"path='/%7Eguido/Python.html',\n"
"            params='', query='', fragment='')"
msgstr ""

#: ../../library/urllib.parse.rst:177
msgid ""
":func:`urlparse` does not perform validation.  See :ref:`URL parsing "
"security <url-parsing-security>` for details."
msgstr ""

#: ../../library/urllib.parse.rst:180
msgid "Added IPv6 URL parsing capabilities."
msgstr "IPv6 URL 구문 분석 기능이 추가되었습니다."

#: ../../library/urllib.parse.rst:183
#, fuzzy
msgid ""
"The fragment is now parsed for all URL schemes (unless *allow_fragments* "
"is false), in accordance with :rfc:`3986`.  Previously, an allowlist of "
"schemes that support fragments existed."
msgstr ""
":rfc:`3986`\\에 따라, 프래그먼트는 이제 모든 URL 스킴에 대해 구문 분석됩니다 (*allow_fragment*\\가 "
"거짓이 아니라면). 이전에는, 프래그먼트를 지원하는 스킴의 화이트리스트가 있었습니다."

#: ../../library/urllib.parse.rst:188 ../../library/urllib.parse.rst:353
msgid ""
"Out-of-range port numbers now raise :exc:`ValueError`, instead of "
"returning :const:`None`."
msgstr "범위를 벗어난 포트 번호는 이제 :const:`None`\\을 반환하는 대신 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/urllib.parse.rst:192 ../../library/urllib.parse.rst:357
msgid ""
"Characters that affect netloc parsing under NFKC normalization will now "
"raise :exc:`ValueError`."
msgstr "NFKC 정규화에서 netloc 구문 분석에 영향을 주는 문자는 이제 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/urllib.parse.rst:199
msgid ""
"Parse a query string given as a string argument (data of type "
":mimetype:`application/x-www-form-urlencoded`).  Data are returned as a "
"dictionary.  The dictionary keys are the unique query variable names and "
"the values are lists of values for each name."
msgstr ""
"문자열 인자(:mimetype:`application/x-www-form-urlencoded` 유형의 데이터)로 제공된 쿼리 "
"문자열을 구문 분석합니다. 데이터는 딕셔너리로 반환됩니다. 딕셔너리 키는 고유한 쿼리 변수 이름이고 값은 각 이름의 값 "
"리스트입니다."

#: ../../library/urllib.parse.rst:204 ../../library/urllib.parse.rst:249
msgid ""
"The optional argument *keep_blank_values* is a flag indicating whether "
"blank values in percent-encoded queries should be treated as blank "
"strings. A true value indicates that blanks should be retained as  blank "
"strings.  The default false value indicates that blank values are to be "
"ignored and treated as if they were not included."
msgstr ""
"선택적 인자 *keep_blank_values*\\는 퍼센트 인코딩된 쿼리의 빈 값을 빈 문자열로 처리해야 하는지를 나타내는 "
"플래그입니다. 참값은 빈 값을 빈 문자열로 유지해야 함을 나타냅니다. 기본 거짓 값은 빈 값이 무시되고 포함되지 않은 것처럼 "
"처리됨을 나타냅니다."

#: ../../library/urllib.parse.rst:210 ../../library/urllib.parse.rst:255
msgid ""
"The optional argument *strict_parsing* is a flag indicating what to do "
"with parsing errors.  If false (the default), errors are silently "
"ignored.  If true, errors raise a :exc:`ValueError` exception."
msgstr ""
"선택적 인자 *strict_parsing*\\은 구문 분석 에러 시 수행할 작업을 나타내는 플래그입니다. 거짓(기본값)이면, 에러가"
" 조용히 무시됩니다. 참이면, 에러는 :exc:`ValueError` 예외를 발생시킵니다."

#: ../../library/urllib.parse.rst:214 ../../library/urllib.parse.rst:259
msgid ""
"The optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the "
":meth:`bytes.decode` method."
msgstr ""
"선택적 *encoding*\\과 *errors* 매개 변수는 :meth:`bytes.decode` 메서드에서 받아들이는 것처럼 "
"퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다."

#: ../../library/urllib.parse.rst:218 ../../library/urllib.parse.rst:263
msgid ""
"The optional argument *max_num_fields* is the maximum number of fields to"
" read. If set, then throws a :exc:`ValueError` if there are more than "
"*max_num_fields* fields read."
msgstr ""
"선택적 인자 *max_num_fields*\\는 읽을 최대 필드 수입니다. 설정되면, *max_num_fields* 필드보다 많은 "
"것을 읽을 때 :exc:`ValueError`\\가 발생합니다."

#: ../../library/urllib.parse.rst:222 ../../library/urllib.parse.rst:267
msgid ""
"The optional argument *separator* is the symbol to use for separating the"
" query arguments. It defaults to ``&``."
msgstr "선택적 인자 *separator*\\는 쿼리 인자를 구분하는 데 사용할 기호입니다. 기본값은 ``&``\\입니다."

#: ../../library/urllib.parse.rst:225
msgid ""
"Use the :func:`urllib.parse.urlencode` function (with the ``doseq`` "
"parameter set to ``True``) to convert such dictionaries into query "
"strings."
msgstr ""
"이러한 딕셔너리를 쿼리 문자열로 변환하려면 :func:`urllib.parse.urlencode` 함수를 (``doseq`` 매개 "
"변수를 ``True``\\로 설정해서) 사용하십시오."

#: ../../library/urllib.parse.rst:230 ../../library/urllib.parse.rst:273
msgid "Add *encoding* and *errors* parameters."
msgstr "*encoding*\\과 *errors* 매개 변수를 추가합니다."

#: ../../library/urllib.parse.rst:233 ../../library/urllib.parse.rst:276
msgid "Added *max_num_fields* parameter."
msgstr "*max_num_fields* 매개 변수를 추가했습니다."

#: ../../library/urllib.parse.rst:236 ../../library/urllib.parse.rst:279
#, fuzzy
msgid ""
"Added *separator* parameter with the default value of ``&``. Python "
"versions earlier than Python 3.10 allowed using both ``;`` and ``&`` as "
"query parameter separator. This has been changed to allow only a single "
"separator key, with ``&`` as the default separator."
msgstr ""
"기본값이 ``&`` 인 *separator* 매개 변수를 추가했습니다. 파이썬 3.9.2 이전의 파이썬 버전에서는 쿼리 매개 변수 "
"구분 기호로 ``;``\\와 ``&``\\를 모두 사용할 수 있었습니다. ``&``\\를 기본 구분자 기호로 사용하여, 단일 구분자"
" 키만 허용하도록 변경되었습니다."

#: ../../library/urllib.parse.rst:245
msgid ""
"Parse a query string given as a string argument (data of type "
":mimetype:`application/x-www-form-urlencoded`).  Data are returned as a "
"list of name, value pairs."
msgstr ""
"문자열 인자(:mimetype:`application/x-www-form-urlencoded` 유형의 데이터)로 제공된 쿼리 "
"문자열을 구문 분석합니다. 데이터는 이름, 값 쌍의 리스트로 반환됩니다."

#: ../../library/urllib.parse.rst:270
msgid ""
"Use the :func:`urllib.parse.urlencode` function to convert such lists of "
"pairs into query strings."
msgstr "이러한 쌍의 리스트를 쿼리 문자열로 변환하려면 :func:`urllib.parse.urlencode` 함수를 사용하십시오."

#: ../../library/urllib.parse.rst:288
msgid ""
"Construct a URL from a tuple as returned by ``urlparse()``. The *parts* "
"argument can be any six-item iterable. This may result in a slightly "
"different, but equivalent URL, if the URL that was parsed originally had "
"unnecessary delimiters (for example, a ``?`` with an empty query; the RFC"
" states that these are equivalent)."
msgstr ""
"``urlparse()``\\에 의해 반환된 튜플에서 URL을 구성합니다. *parts* 인자는 임의의 6개 항목 이터러블일 수 "
"있습니다. 구문 분석된 원래 URL에 불필요한 구분자가 있는 경우 (예를 들어 비어있는 쿼리가 있는 ``?``; RFC는 이들이 "
"동등하다고 말합니다) 약간 다르지만 동등한 URL이 만들어질 수 있습니다."

#: ../../library/urllib.parse.rst:297
msgid ""
"This is similar to :func:`urlparse`, but does not split the params from "
"the URL. This should generally be used instead of :func:`urlparse` if the"
" more recent URL syntax allowing parameters to be applied to each segment"
" of the *path* portion of the URL (see :rfc:`2396`) is wanted.  A "
"separate function is needed to separate the path segments and parameters."
"  This function returns a 5-item :term:`named tuple`::"
msgstr ""
"이것은 :func:`urlparse`\\와 유사하지만, URL에서 파라미터를 분할하지 않습니다. URL의 *path* 부분의 각 "
"세그먼트에 파라미터를 적용할 수 있는 최신 URL 문법(:rfc:`2396`\\을 참조하십시오)이 필요하면 일반적으로 "
":func:`urlparse` 대신 사용해야 합니다. 경로 세그먼트와 파라미터를 분리하려면 별도의 함수가 필요합니다. 이 함수는 "
"5개 항목 :term:`네임드 튜플 <named tuple>`\\을 반환합니다::"

#: ../../library/urllib.parse.rst:304
msgid "(addressing scheme, network location, path, query, fragment identifier)."
msgstr ""

#: ../../library/urllib.parse.rst:306 ../../library/urllib.parse.rst:428
msgid ""
"The return value is a :term:`named tuple`, its items can be accessed by "
"index or as named attributes:"
msgstr ""
"반환 값은 :term:`네임드 튜플 <named tuple>`\\입니다, 항목은 인덱스나 이름 붙은 어트리뷰트로 액세스 할 수 "
"있습니다:"

#: ../../library/urllib.parse.rst:344
msgid ""
"Following some of the `WHATWG spec`_ that updates RFC 3986, leading C0 "
"control and space characters are stripped from the URL. ``\\n``, ``\\r`` "
"and tab ``\\t`` characters are removed from the URL at any position."
msgstr ""

#: ../../library/urllib.parse.rst:350
msgid ""
":func:`urlsplit` does not perform validation.  See :ref:`URL parsing "
"security <url-parsing-security>` for details."
msgstr ""

#: ../../library/urllib.parse.rst:361
msgid "ASCII newline and tab characters are stripped from the URL."
msgstr ""

#: ../../library/urllib.parse.rst:364
msgid "Leading WHATWG C0 control and space characters are stripped from the URL."
msgstr ""

#: ../../library/urllib.parse.rst:371
msgid ""
"Combine the elements of a tuple as returned by :func:`urlsplit` into a "
"complete URL as a string. The *parts* argument can be any five-item "
"iterable. This may result in a slightly different, but equivalent URL, if"
" the URL that was parsed originally had unnecessary delimiters (for "
"example, a ? with an empty query; the RFC states that these are "
"equivalent)."
msgstr ""
":func:`urlsplit`\\에 의해 반환된 튜플 요소를 완전한 URL 문자열로 결합합니다. *parts* 인자는 임의의 5개 "
"항목 이터러블일 수 있습니다. 구문 분석된 원래 URL에 불필요한 구분자가 있는 경우 (예를 들어 비어있는 쿼리가 있는 ?; "
"RFC는 이들이 동등하다고 말합니다) 약간 다르지만 동등한 URL이 만들어질 수 있습니다."

#: ../../library/urllib.parse.rst:380
msgid ""
"Construct a full (\"absolute\") URL by combining a \"base URL\" (*base*) "
"with another URL (*url*).  Informally, this uses components of the base "
"URL, in particular the addressing scheme, the network location and (part "
"of) the path, to provide missing components in the relative URL.  For "
"example:"
msgstr ""
"\"기본 URL\"(*base*)을 다른 URL(*url*)과 결합하여 전체 (\"절대\") URL을 구성합니다. 비형식적으로, "
"이것은 기본 URL의 구성 요소, 특히 주소 지정 체계, 네트워크 위치 및 경로(의 일부)를 사용하여 상대 URL에 누락된 구성 "
"요소를 제공합니다. 예를 들면:"

#: ../../library/urllib.parse.rst:389
msgid ""
"The *allow_fragments* argument has the same meaning and default as for "
":func:`urlparse`."
msgstr "*allow_fragments* 인자는 :func:`urlparse`\\와 같은 의미와 기본값을 갖습니다."

#: ../../library/urllib.parse.rst:394
msgid ""
"If *url* is an absolute URL (that is, it starts with ``//`` or "
"``scheme://``), the *url*'s hostname and/or scheme will be present in the"
" result.  For example:"
msgstr ""
"*url*\\이 절대 URL이면 (즉, ``//``\\나 ``scheme://``\\로 시작하면), *url*\\의 호스트명 "
"및/또는 스킴이 결과에 나타납니다. 예를 들면:"

#: ../../library/urllib.parse.rst:397
#, python-format
msgid ""
">>> urljoin('http://www.cwi.nl/%7Eguido/Python.html',\n"
"...         '//www.python.org/%7Eguido')\n"
"'http://www.python.org/%7Eguido'"
msgstr ""

#: ../../library/urllib.parse.rst:403
msgid ""
"If you do not want that behavior, preprocess the *url* with "
":func:`urlsplit` and :func:`urlunsplit`, removing possible *scheme* and "
"*netloc* parts."
msgstr ""
"이런 동작을 원하지 않으면, *url*\\을 :func:`urlsplit`\\과 :func:`urlunsplit`\\으로 사전 "
"처리하여 가능한 *scheme*\\과 *netloc* 부분을 제거하십시오."

#: ../../library/urllib.parse.rst:408
msgid ""
"Because an absolute URL may be passed as the ``url`` parameter, it is "
"generally **not secure** to use ``urljoin`` with an attacker-controlled "
"``url``. For example in, ``urljoin(\"https://website.com/users/\", "
"username)``, if ``username`` can contain an absolute URL, the result of "
"``urljoin`` will be the absolute URL."
msgstr ""

#: ../../library/urllib.parse.rst:418
msgid "Behavior updated to match the semantics defined in :rfc:`3986`."
msgstr ":rfc:`3986`\\에 정의된 의미론과 일치하도록 동작이 갱신되었습니다."

#: ../../library/urllib.parse.rst:423
msgid ""
"If *url* contains a fragment identifier, return a modified version of "
"*url* with no fragment identifier, and the fragment identifier as a "
"separate string.  If there is no fragment identifier in *url*, return "
"*url* unmodified and an empty string."
msgstr ""
"*url*\\에 프래그먼트 식별자가 포함되면, 프래그먼트 식별자 없는 *url*\\의 수정된 버전과 프래그먼트 식별자를 별도의 "
"문자열로 반환합니다. *url*\\에 프래그먼트 식별자가 없으면, 수정되지 않은 *url*\\과 빈 문자열을 반환합니다."

#: ../../library/urllib.parse.rst:434
msgid ":attr:`url`"
msgstr ":attr:`url`"

#: ../../library/urllib.parse.rst:434
msgid "URL with no fragment"
msgstr "프래그먼트 없는 URL"

#: ../../library/urllib.parse.rst:439
msgid ""
"See section :ref:`urlparse-result-object` for more information on the "
"result object."
msgstr "결과 객체에 대한 자세한 정보는 섹션 :ref:`urlparse-result-object`\\를 참조하십시오."

#: ../../library/urllib.parse.rst:442
msgid "Result is a structured object rather than a simple 2-tuple."
msgstr "결과는 단순한 2-튜플이 아닌 구조화된 객체입니다."

#: ../../library/urllib.parse.rst:447
msgid ""
"Extract the url from a wrapped URL (that is, a string formatted as "
"``<URL:scheme://host/path>``, ``<scheme://host/path>``, "
"``URL:scheme://host/path`` or ``scheme://host/path``). If *url* is not a "
"wrapped URL, it is returned without changes."
msgstr ""
"래핑 된 URL(즉, ``<URL:scheme://host/path>``, ``<scheme://host/path>``, "
"``URL:scheme://host/path`` 또는 ``scheme://host/path`` 형식의 문자열)에서 URL을 "
"추출합니다. *url*\\이 래핑 된 URL이 아니면, 변경 없이 반환됩니다."

#: ../../library/urllib.parse.rst:455
#, fuzzy
msgid "URL parsing security"
msgstr "URL 구문 분석"

#: ../../library/urllib.parse.rst:457
msgid ""
"The :func:`urlsplit` and :func:`urlparse` APIs do not perform "
"**validation** of inputs.  They may not raise errors on inputs that other"
" applications consider invalid.  They may also succeed on some inputs "
"that might not be considered URLs elsewhere.  Their purpose is for "
"practical functionality rather than purity."
msgstr ""

#: ../../library/urllib.parse.rst:463
msgid ""
"Instead of raising an exception on unusual input, they may instead return"
" some component parts as empty strings. Or components may contain more "
"than perhaps they should."
msgstr ""

#: ../../library/urllib.parse.rst:467
msgid ""
"We recommend that users of these APIs where the values may be used "
"anywhere with security implications code defensively. Do some "
"verification within your code before trusting a returned component part."
"  Does that ``scheme`` make sense?  Is that a sensible ``path``?  Is "
"there anything strange about that ``hostname``?  etc."
msgstr ""

#: ../../library/urllib.parse.rst:473
msgid ""
"What constitutes a URL is not universally well defined.  Different "
"applications have different needs and desired constraints.  For instance "
"the living `WHATWG spec`_ describes what user facing web clients such as "
"a web browser require. While :rfc:`3986` is more general.  These "
"functions incorporate some aspects of both, but cannot be claimed "
"compliant with either.  The APIs and existing user code with expectations"
" on specific behaviors predate both standards leading us to be very "
"cautious about making API behavior changes."
msgstr ""

#: ../../library/urllib.parse.rst:484
msgid "Parsing ASCII Encoded Bytes"
msgstr "ASCII로 인코딩된 바이트열 구문 분석"

#: ../../library/urllib.parse.rst:486
msgid ""
"The URL parsing functions were originally designed to operate on "
"character strings only. In practice, it is useful to be able to "
"manipulate properly quoted and encoded URLs as sequences of ASCII bytes. "
"Accordingly, the URL parsing functions in this module all operate on "
":class:`bytes` and :class:`bytearray` objects in addition to :class:`str`"
" objects."
msgstr ""
"URL 구문 분석 함수는 원래 문자열에서만 작동하도록 설계되었습니다. 실제로는, 적절히 인용되고 인코딩된 URL을 ASCII 바이트"
" 시퀀스로 조작할 수 있으면 유용합니다. 따라서, 이 모듈의 URL 구문 분석 함수는 모두 :class:`str` 객체 외에 "
":class:`bytes`\\와 :class:`bytearray` 객체에서 작동합니다."

#: ../../library/urllib.parse.rst:492
msgid ""
"If :class:`str` data is passed in, the result will also contain only "
":class:`str` data. If :class:`bytes` or :class:`bytearray` data is passed"
" in, the result will contain only :class:`bytes` data."
msgstr ""
":class:`str` 데이터가 전달되면, 결과에는 :class:`str` 데이터만 포함됩니다. :class:`bytes`\\나 "
":class:`bytearray` 데이터가 전달되면, 결과에는 :class:`bytes` 데이터만 포함됩니다."

#: ../../library/urllib.parse.rst:496
msgid ""
"Attempting to mix :class:`str` data with :class:`bytes` or "
":class:`bytearray` in a single function call will result in a "
":exc:`TypeError` being raised, while attempting to pass in non-ASCII byte"
" values will trigger :exc:`UnicodeDecodeError`."
msgstr ""
"단일 함수 호출에서 :class:`str` 데이터를 :class:`bytes`\\나 :class:`bytearray`\\와 "
"혼합하려고 시도하면 :exc:`TypeError`\\가 발생하는 반면, 비 ASCII 바이트 값을 전달하면 "
":exc:`UnicodeDecodeError`\\가 트리거 됩니다."

#: ../../library/urllib.parse.rst:501
msgid ""
"To support easier conversion of result objects between :class:`str` and "
":class:`bytes`, all return values from URL parsing functions provide "
"either an :meth:`encode` method (when the result contains :class:`str` "
"data) or a :meth:`decode` method (when the result contains :class:`bytes`"
" data). The signatures of these methods match those of the corresponding "
":class:`str` and :class:`bytes` methods (except that the default encoding"
" is ``'ascii'`` rather than ``'utf-8'``). Each produces a value of a "
"corresponding type that contains either :class:`bytes` data (for "
":meth:`encode` methods) or :class:`str` data (for :meth:`decode` "
"methods)."
msgstr ""
":class:`str`\\과 :class:`bytes` 간에 결과 객체를 쉽게 변환 할 수 있도록, URL 구문 분석 함수의 모든 "
"반환 값은 :meth:`encode` 메서드(결과에 :class:`str` 데이터가 포함될 때)나 :meth:`decode` "
"메서드(결과에 :class:`bytes` 데이터가 포함될 때)를 제공합니다. 이러한 메서드의 서명은 해당 "
":class:`str`\\와 :class:`bytes` 메서드의 서명과 일치합니다 (기본 인코딩이 ``'utf-8'``\\가 아니라"
" ``'ascii'``\\라는 점은 예외입니다). 각각은 :class:`bytes` 데이터(:meth:`encode` 메서드의 "
"경우)나 :class:`str` 데이터(:meth:`decode` 메서드의 경우)를 포함하는 해당 형의 값을 생성합니다."

#: ../../library/urllib.parse.rst:512
msgid ""
"Applications that need to operate on potentially improperly quoted URLs "
"that may contain non-ASCII data will need to do their own decoding from "
"bytes to characters before invoking the URL parsing methods."
msgstr ""
"ASCII가 아닌 데이터를 포함할 수 있는 잘못 인용된 URL에서 작동할 가능성이 있는 응용 프로그램은 URL 구문 분석 메서드를 "
"호출하기 전에 바이트열에서 문자로 자체 디코딩을 수행할 필요가 있습니다."

#: ../../library/urllib.parse.rst:516
msgid ""
"The behaviour described in this section applies only to the URL parsing "
"functions. The URL quoting functions use their own rules when producing "
"or consuming byte sequences as detailed in the documentation of the "
"individual URL quoting functions."
msgstr ""
"이 섹션에서 설명하는 동작은 URL 구문 분석 함수에만 적용됩니다. URL 인용 함수는 개별 URL 인용 함수의 설명서에 기술된 "
"대로 바이트 시퀀스를 생성하거나 소비할 때 자체 규칙을 사용합니다."

#: ../../library/urllib.parse.rst:521
msgid "URL parsing functions now accept ASCII encoded byte sequences"
msgstr "URL 구문 분석 함수는 이제 ASCII 인코딩된 바이트 시퀀스를 받아들입니다."

#: ../../library/urllib.parse.rst:528
msgid "Structured Parse Results"
msgstr "구조화된 구문 분석 결과"

#: ../../library/urllib.parse.rst:530
msgid ""
"The result objects from the :func:`urlparse`, :func:`urlsplit`  and "
":func:`urldefrag` functions are subclasses of the :class:`tuple` type. "
"These subclasses add the attributes listed in the documentation for those"
" functions, the encoding and decoding support described in the previous "
"section, as well as an additional method:"
msgstr ""
":func:`urlparse`, :func:`urlsplit` 및 :func:`urldefrag` 함수의 결과 객체는 "
":class:`tuple` 형의 서브 클래스입니다. 이 서브 클래스는 해당 함수에 대한 설명서에 나열된 어트리뷰트, 이전 섹션에서 "
"설명한 인코딩과 디코딩 지원 및 추가 메서드를 추가합니다:"

#: ../../library/urllib.parse.rst:538
msgid ""
"Return the re-combined version of the original URL as a string. This may "
"differ from the original URL in that the scheme may be normalized to "
"lower case and empty components may be dropped. Specifically, empty "
"parameters, queries, and fragment identifiers will be removed."
msgstr ""
"원래 URL의 재결합된 버전을 문자열로 반환합니다. 스킴이 소문자로 정규화되고 빈 구성 요소가 삭제될 수 있다는 점에서 원래 "
"URL과 다를 수 있습니다. 특히, 빈 파라미터, 쿼리 및 프래그먼트 식별자가 제거됩니다."

#: ../../library/urllib.parse.rst:543
msgid ""
"For :func:`urldefrag` results, only empty fragment identifiers will be "
"removed. For :func:`urlsplit` and :func:`urlparse` results, all noted "
"changes will be made to the URL returned by this method."
msgstr ""
":func:`urldefrag` 결과의 경우, 빈 프래그먼트 식별자만 제거됩니다. :func:`urlsplit`\\과 "
":func:`urlparse` 결과의 경우, 이 메서드가 반환한 URL에 대해 언급된 모든 변경 사항이 적용됩니다."

#: ../../library/urllib.parse.rst:547
msgid ""
"The result of this method remains unchanged if passed back through the "
"original parsing function:"
msgstr "이 메서드의 결과는 원래 구문 분석 함수를 통해 다시 전달될 때 변경되지 않은 상태로 유지됩니다:"

#: ../../library/urllib.parse.rst:560
msgid ""
"The following classes provide the implementations of the structured parse"
" results when operating on :class:`str` objects:"
msgstr "다음 클래스는 :class:`str` 객체에서 작동할 때 구조화된 구문 분석 결과의 구현을 제공합니다:"

#: ../../library/urllib.parse.rst:565
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`str` "
"data. The :meth:`encode` method returns a :class:`DefragResultBytes` "
"instance."
msgstr ""
":class:`str` 데이터를 포함하는 :func:`urldefrag` 결과의 구상 클래스. :meth:`encode` 메서드는 "
":class:`DefragResultBytes` 인스턴스를 반환합니다."

#: ../../library/urllib.parse.rst:573
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`str` data."
" The :meth:`encode` method returns a :class:`ParseResultBytes` instance."
msgstr ""
":class:`str` 데이터를 포함하는 :func:`urlparse` 결과의 구상 클래스. :meth:`encode` 메서드는 "
":class:`ParseResultBytes` 인스턴스를 반환합니다."

#: ../../library/urllib.parse.rst:579
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`str` data."
" The :meth:`encode` method returns a :class:`SplitResultBytes` instance."
msgstr ""
":class:`str` 데이터를 포함하는 :func:`urlsplit` 결과의 구상 클래스. :meth:`encode` 메서드는 "
":class:`SplitResultBytes` 인스턴스를 반환합니다."

#: ../../library/urllib.parse.rst:584
msgid ""
"The following classes provide the implementations of the parse results "
"when operating on :class:`bytes` or :class:`bytearray` objects:"
msgstr ""
"다음 클래스는 :class:`bytes`\\나 :class:`bytearray` 객체에서 작동할 때 구문 분석 결과의 구현을 "
"제공합니다:"

#: ../../library/urllib.parse.rst:589
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`bytes` "
"data. The :meth:`decode` method returns a :class:`DefragResult` instance."
msgstr ""
":class:`bytes` 데이터를 포함하는 :func:`urldefrag` 결과의 구상 클래스. :meth:`decode` "
"메서드는 :class:`DefragResult` 인스턴스를 반환합니다."

#: ../../library/urllib.parse.rst:597
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`bytes` "
"data. The :meth:`decode` method returns a :class:`ParseResult` instance."
msgstr ""
":class:`bytes` 데이터를 포함하는 :func:`urlparse` 결과의 구상 클래스. :meth:`decode` 메서드는"
" :class:`ParseResult` 인스턴스를 반환합니다."

#: ../../library/urllib.parse.rst:605
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`bytes` "
"data. The :meth:`decode` method returns a :class:`SplitResult` instance."
msgstr ""
":class:`bytes` 데이터를 포함하는 :func:`urlsplit` 결과의 구상 클래스. :meth:`decode` 메서드는"
" :class:`SplitResult` 인스턴스를 반환합니다."

#: ../../library/urllib.parse.rst:613
msgid "URL Quoting"
msgstr "URL 인용"

#: ../../library/urllib.parse.rst:615
msgid ""
"The URL quoting functions focus on taking program data and making it safe"
" for use as URL components by quoting special characters and "
"appropriately encoding non-ASCII text. They also support reversing these "
"operations to recreate the original data from the contents of a URL "
"component if that task isn't already covered by the URL parsing functions"
" above."
msgstr ""
"URL 인용(quoting) 함수는 특수 문자를 인용하고 비 ASCII 텍스트를 적절히 인코딩하여 프로그램 데이터를 취해서 URL "
"구성 요소로 안전하게 사용할 수 있도록 하는 데 중점을 둡니다. 또한 해당 작업이 위의 URL 구문 분석 함수로 처리되지 않는 경우"
" URL 구성 요소의 내용에서 원래 데이터를 다시 만들기 위해 이러한 작업을 뒤집는 것도 지원합니다."

#: ../../library/urllib.parse.rst:623
#, fuzzy, python-brace-format, python-format
msgid ""
"Replace special characters in *string* using the :samp:`%{xx}` escape. "
"Letters, digits, and the characters ``'_.-~'`` are never quoted. By "
"default, this function is intended for quoting the path section of a URL."
" The optional *safe* parameter specifies additional ASCII characters that"
" should not be quoted --- its default value is ``'/'``."
msgstr ""
"``%xx`` 이스케이프를 사용하여 *string*\\의 특수 문자를 치환합니다. 글자, 숫자 및 문자 ``'_.-~'``\\는 "
"절대 인용되지 않습니다. 기본적으로, 이 함수는 URL의 경로 섹션을 인용하기 위한 것입니다. 선택적 *safe* 매개 변수는 "
"인용해서는 안 되는 추가 ASCII 문자를 지정합니다 --- 기본값은 ``'/'``\\입니다."

#: ../../library/urllib.parse.rst:629 ../../library/urllib.parse.rst:675
#: ../../library/urllib.parse.rst:704
msgid "*string* may be either a :class:`str` or a :class:`bytes` object."
msgstr "*string*\\은 :class:`str`\\이나 :class:`bytes` 객체일 수 있습니다."

#: ../../library/urllib.parse.rst:631
msgid ""
"Moved from :rfc:`2396` to :rfc:`3986` for quoting URL strings. \"~\" is "
"now included in the set of unreserved characters."
msgstr ""
"URL 문자열 인용을 :rfc:`2396`\\에서 :rfc:`3986`\\으로 옮겼습니다. \"~\"는 이제 예약되지 않은 문자 "
"집합에 포함됩니다."

#: ../../library/urllib.parse.rst:635
msgid ""
"The optional *encoding* and *errors* parameters specify how to deal with "
"non-ASCII characters, as accepted by the :meth:`str.encode` method. "
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'strict'``, "
"meaning unsupported characters raise a :class:`UnicodeEncodeError`. "
"*encoding* and *errors* must not be supplied if *string* is a "
":class:`bytes`, or a :class:`TypeError` is raised."
msgstr ""
"선택적 *encoding*\\과 *errors* 매개 변수는 :meth:`str.encode` 메서드에서 받아들이는 것처럼 비 "
"ASCII 문자를 처리하는 방법을 지정합니다. *encoding*\\의 기본값은 ``'utf-8'``\\입니다. "
"*errors*\\의 기본값은 ``'strict'``\\로, 지원되지 않는 문자는 "
":class:`UnicodeEncodeError`\\를 발생시킴을 의미합니다. *string*\\이 "
":class:`bytes`\\이면 *encoding*\\과 *errors*\\를 제공해서는 안 됩니다, 그렇지 않으면 "
":class:`TypeError`\\가 발생합니다."

#: ../../library/urllib.parse.rst:643
msgid ""
"Note that ``quote(string, safe, encoding, errors)`` is equivalent to "
"``quote_from_bytes(string.encode(encoding, errors), safe)``."
msgstr ""
"``quote(string, safe, encoding, errors)``\\는 "
"``quote_from_bytes(string.encode(encoding, errors), safe)``\\와 동등함에 "
"유의하십시오."

#: ../../library/urllib.parse.rst:646
msgid "Example: ``quote('/El Niño/')`` yields ``'/El%20Ni%C3%B1o/'``."
msgstr "예: ``quote('/El Niño/')``\\는 ``'/El%20Ni%C3%B1o/'``\\를 산출합니다."

#: ../../library/urllib.parse.rst:651
msgid ""
"Like :func:`quote`, but also replace spaces with plus signs, as required "
"for quoting HTML form values when building up a query string to go into a"
" URL. Plus signs in the original string are escaped unless they are "
"included in *safe*.  It also does not have *safe* default to ``'/'``."
msgstr ""
":func:`quote`\\와 유사하지만, URL로 이동하기 위한 쿼리 문자열을 만들 때 HTML 폼값을 인용하는 데 필요한 대로 "
"스페이스를 더하기 부호로 치환하기도 합니다. *safe*\\에 포함되지 않으면 원래 문자열의 더하기 부호가 이스케이프 됩니다. 또한"
" *safe*\\의 기본값은 ``'/'``\\가 아닙니다."

#: ../../library/urllib.parse.rst:656
#, python-format
msgid "Example: ``quote_plus('/El Niño/')`` yields ``'%2FEl+Ni%C3%B1o%2F'``."
msgstr "예: ``quote_plus('/El Niño/')``\\는 ``'%2FEl+Ni%C3%B1o%2F'``\\를 산출합니다."

#: ../../library/urllib.parse.rst:661
msgid ""
"Like :func:`quote`, but accepts a :class:`bytes` object rather than a "
":class:`str`, and does not perform string-to-bytes encoding."
msgstr ""
":func:`quote`\\와 유사하지만, :class:`str` 대신 :class:`bytes` 객체를 받아들이고, 문자열을 "
"바이트열로 인코딩하지 않습니다."

#: ../../library/urllib.parse.rst:664
#, python-format
msgid "Example: ``quote_from_bytes(b'a&\\xef')`` yields ``'a%26%EF'``."
msgstr "예: ``quote_from_bytes(b'a&\\xef')``\\는 ``'a%26%EF'``\\를 산출합니다."

#: ../../library/urllib.parse.rst:670
#, fuzzy, python-brace-format, python-format
msgid ""
"Replace :samp:`%{xx}` escapes with their single-character equivalent. The"
" optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the "
":meth:`bytes.decode` method."
msgstr ""
"``%xx`` 이스케이프를 동등한 단일 문자로 대체합니다. 선택적 *encoding*\\과 *errors* 매개 변수는 "
":meth:`bytes.decode` 메서드에서 받아들이는 것처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 "
"지정합니다."

#: ../../library/urllib.parse.rst:677
msgid ""
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'replace'``, "
"meaning invalid sequences are replaced by a placeholder character."
msgstr ""
"*encoding*\\의 기본값은 ``'utf-8'``\\입니다. *errors*\\의 기본값은 ``'replace'``\\로, "
"유효하지 않은 시퀀스는 자리 표시자 문자(placeholder character)로 대체됩니다."

#: ../../library/urllib.parse.rst:681
msgid "Example: ``unquote('/El%20Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "예: ``unquote('/El%20Ni%C3%B1o/')``\\는 ``'/El Niño/'``\\를 산출합니다."

#: ../../library/urllib.parse.rst:683
msgid "*string* parameter supports bytes and str objects (previously only str)."
msgstr "*string* 매개 변수는 바이트열과 문자열 객체를 지원합니다 (이전에는 문자열만 지원했습니다)."

#: ../../library/urllib.parse.rst:691
msgid ""
"Like :func:`unquote`, but also replace plus signs with spaces, as "
"required for unquoting HTML form values."
msgstr ""
":func:`unquote`\\와 유사하지만, HTML 폼값을 인용 해제할 때 요구되는 것처럼, 더하기 부호를 스페이스로 치환하기도"
" 합니다."

#: ../../library/urllib.parse.rst:694
msgid "*string* must be a :class:`str`."
msgstr "*string*\\은 :class:`str`\\이어야 합니다."

#: ../../library/urllib.parse.rst:696
msgid "Example: ``unquote_plus('/El+Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "예: ``unquote_plus('/El+Ni%C3%B1o/')``\\는 ``'/El Niño/'``\\를 산출합니다."

#: ../../library/urllib.parse.rst:701
#, fuzzy, python-brace-format, python-format
msgid ""
"Replace :samp:`%{xx}` escapes with their single-octet equivalent, and "
"return a :class:`bytes` object."
msgstr "``%xx`` 이스케이프를 해당 단일 옥텟(octet)으로 대체하고, :class:`bytes` 객체를 반환합니다."

#: ../../library/urllib.parse.rst:706
msgid ""
"If it is a :class:`str`, unescaped non-ASCII characters in *string* are "
"encoded into UTF-8 bytes."
msgstr ":class:`str`\\이면, *string*\\의 이스케이프 되지 않은 비 ASCII 문자는 UTF-8 바이트열로 인코딩됩니다."

#: ../../library/urllib.parse.rst:709
#, python-format
msgid "Example: ``unquote_to_bytes('a%26%EF')`` yields ``b'a&\\xef'``."
msgstr "예: ``unquote_to_bytes('a%26%EF')``\\는 ``b'a&\\xef'``\\를 산출합니다."

#: ../../library/urllib.parse.rst:715
msgid ""
"Convert a mapping object or a sequence of two-element tuples, which may "
"contain :class:`str` or :class:`bytes` objects, to a percent-encoded "
"ASCII text string.  If the resultant string is to be used as a *data* for"
" POST operation with the :func:`~urllib.request.urlopen` function, then "
"it should be encoded to bytes, otherwise it would result in a "
":exc:`TypeError`."
msgstr ""
":class:`str`\\이나 :class:`bytes` 객체를 포함할 수 있는 매핑 객체나 두 요소 튜플의 시퀀스를 퍼센트 "
"인코딩된 ASCII 텍스트 문자열로 변환합니다. 결과 문자열을 :func:`~urllib.request.urlopen` 함수를 "
"사용하여 POST 연산을 위한 *data*\\로 사용하려면, 바이트열로 인코딩해야 합니다, 그렇지 않으면 "
":exc:`TypeError`\\가 발생합니다."

#: ../../library/urllib.parse.rst:722
#, python-format
msgid ""
"The resulting string is a series of ``key=value`` pairs separated by "
"``'&'`` characters, where both *key* and *value* are quoted using the "
"*quote_via* function.  By default, :func:`quote_plus` is used to quote "
"the values, which means spaces are quoted as a ``'+'`` character and '/' "
"characters are encoded as ``%2F``, which follows the standard for GET "
"requests (``application/x-www-form-urlencoded``).  An alternate function "
"that can be passed as *quote_via* is :func:`quote`, which will encode "
"spaces as ``%20`` and not encode '/' characters.  For maximum control of "
"what is quoted, use ``quote`` and specify a value for *safe*."
msgstr ""
"결과 문자열은 ``'&'`` 문자로 구분된 일련의 ``key=value`` 쌍이고, 여기서 *key*\\와 *value*\\는 "
"*quote_via* 함수를 사용하여 인용됩니다. 기본적으로, :func:`quote_plus`\\가 값을 인용하는 데 사용되는데,"
" 스페이스는 ``'+'`` 문자로 인용되고 '/' 문자는 ``%2F``\\로 인코딩되어 GET 요청 "
"표준(``application/x-www-form-urlencoded``)을 따름을 뜻합니다. *quote_via*\\로 전달될 수"
" 있는 대체 함수는 :func:`quote`\\이며, 스페이스를 ``%20``\\로 인코딩하고 '/' 문자를 인코딩하지 않습니다. "
"무엇을 인용할지를 최대한 제어하려면, ``quote``\\를 사용하고 *safe*\\의 값을 지정하십시오."

#: ../../library/urllib.parse.rst:732
msgid ""
"When a sequence of two-element tuples is used as the *query* argument, "
"the first element of each tuple is a key and the second is a value. The "
"value element in itself can be a sequence and in that case, if the "
"optional parameter *doseq* evaluates to ``True``, individual "
"``key=value`` pairs separated by ``'&'`` are generated for each element "
"of the value sequence for the key.  The order of parameters in the "
"encoded string will match the order of parameter tuples in the sequence."
msgstr ""
"*query* 인자에 두 요소 튜플의 시퀀스가 사용될 때, 각 튜플의 첫 번째 요소는 키이고 두 번째 요소는 값입니다. 값 요소 "
"자체는 시퀀스일 수 있으며, 이 경우 선택적 매개 변수 *doseq*\\가 ``True``\\로 평가되면, ``'&'``\\로 "
"구분된 개별 ``key=value`` 쌍이 키에 대한 값 시퀀스의 각 요소에 대해 생성됩니다. 인코딩된 문자열의 파라미터 순서는 "
"시퀀스의 파라미터 튜플 순서와 일치합니다."

#: ../../library/urllib.parse.rst:740
msgid ""
"The *safe*, *encoding*, and *errors* parameters are passed down to "
"*quote_via* (the *encoding* and *errors* parameters are only passed when "
"a query element is a :class:`str`)."
msgstr ""
"*safe*, *encoding* 및 *errors* 매개 변수는 *quote_via*\\로 전달됩니다 (*encoding*\\과 "
"*errors* 매개 변수는 쿼리 요소가 :class:`str`\\일 때만 전달됩니다)."

#: ../../library/urllib.parse.rst:744
msgid ""
"To reverse this encoding process, :func:`parse_qs` and :func:`parse_qsl` "
"are provided in this module to parse query strings into Python data "
"structures."
msgstr ""
"이 인코딩 프로세스를 뒤집기 위해, 쿼리 문자열을 파이썬 데이터 구조로 구문 분석하기 위해 이 모듈에서 "
":func:`parse_qs`\\와 :func:`parse_qsl`\\이 제공됩니다."

#: ../../library/urllib.parse.rst:747
msgid ""
"Refer to :ref:`urllib examples <urllib-examples>` to find out how the "
":func:`urllib.parse.urlencode` method can be used for generating the "
"query string of a URL or data for a POST request."
msgstr ""
":func:`urllib.parse.urlencode` 메서드를 사용하여 URL의 쿼리 문자열이나 POST 요청의 데이터를 생성하는"
" 방법을 알아보려면 :ref:`urllib 예제 <urllib-examples>`\\를 참조하십시오."

#: ../../library/urllib.parse.rst:751
msgid "*query* supports bytes and string objects."
msgstr "*query* 매개 변수는 바이트열과 문자열 객체를 지원합니다."

#: ../../library/urllib.parse.rst:754
#, fuzzy
msgid "Added the *quote_via* parameter."
msgstr "*quote_via* 매개 변수."

#: ../../library/urllib.parse.rst:760
msgid "`WHATWG`_ -  URL Living standard"
msgstr ""

#: ../../library/urllib.parse.rst:761
msgid ""
"Working Group for the URL Standard that defines URLs, domains, IP "
"addresses, the application/x-www-form-urlencoded format, and their API."
msgstr ""

#: ../../library/urllib.parse.rst:764
msgid ":rfc:`3986` - Uniform Resource Identifiers"
msgstr ":rfc:`3986` - Uniform Resource Identifiers"

#: ../../library/urllib.parse.rst:765
msgid ""
"This is the current standard (STD66). Any changes to urllib.parse module "
"should conform to this. Certain deviations could be observed, which are "
"mostly for backward compatibility purposes and for certain de-facto "
"parsing requirements as commonly observed in major browsers."
msgstr ""
"이것이 현재 표준입니다 (STD66). urllib.parse 모듈에 대한 모든 변경 사항은 이를 준수해야 합니다. 특정 편차가 "
"관찰될 수 있는데, 이는 대부분 이전 버전과의 호환성과 주요 브라우저에서 일반적으로 관찰되는 사실상의 구문 분석 요구 사항을 위한 "
"것입니다."

#: ../../library/urllib.parse.rst:770
msgid ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."
msgstr ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."

#: ../../library/urllib.parse.rst:771
msgid "This specifies the parsing requirements of IPv6 URLs."
msgstr "IPv6 URL의 구문 분석 요구 사항을 지정합니다."

#: ../../library/urllib.parse.rst:773
msgid ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"
msgstr ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"

#: ../../library/urllib.parse.rst:774
msgid ""
"Document describing the generic syntactic requirements for both Uniform "
"Resource Names (URNs) and Uniform Resource Locators (URLs)."
msgstr ""
"URN(Uniform Resource Names)과 URL(Uniform Resource Locator)에 대한 일반적인 문법 요구"
" 사항을 설명하는 문서."

#: ../../library/urllib.parse.rst:777
msgid ":rfc:`2368` - The mailto URL scheme."
msgstr ":rfc:`2368` - The mailto URL scheme."

#: ../../library/urllib.parse.rst:778
msgid "Parsing requirements for mailto URL schemes."
msgstr "mailto URL 스킴에 대한 구문 분석 요구 사항."

#: ../../library/urllib.parse.rst:780
msgid ":rfc:`1808` - Relative Uniform Resource Locators"
msgstr ":rfc:`1808` - Relative Uniform Resource Locators"

#: ../../library/urllib.parse.rst:781
msgid ""
"This Request For Comments includes the rules for joining an absolute and "
"a relative URL, including a fair number of \"Abnormal Examples\" which "
"govern the treatment of border cases."
msgstr ""
"이 RFC는 경계 사례의 처리를 정의하는 꽤 많은 수의 \"비정상적인 예\"를 포함하여, 절대와 상대 URL을 결합하는 규칙을 "
"포함합니다."

#: ../../library/urllib.parse.rst:785
msgid ":rfc:`1738` - Uniform Resource Locators (URL)"
msgstr ":rfc:`1738` - Uniform Resource Locators (URL)"

#: ../../library/urllib.parse.rst:786
msgid "This specifies the formal syntax and semantics of absolute URLs."
msgstr "절대 URL의 형식 문법과 의미를 지정합니다."

#: ../../library/urllib.parse.rst:9
msgid "WWW"
msgstr ""

#: ../../library/urllib.parse.rst:9
msgid "World Wide Web"
msgstr ""

#: ../../library/urllib.parse.rst:9
msgid "URL"
msgstr ""

#: ../../library/urllib.parse.rst:9
#, fuzzy
msgid "parsing"
msgstr "URL 구문 분석"

#: ../../library/urllib.parse.rst:9
msgid "relative"
msgstr ""

