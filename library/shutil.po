# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/shutil.rst:2
#, fuzzy
msgid ":mod:`!shutil` --- High-level file operations"
msgstr ":mod:`shutil` --- 고수준 파일 연산"

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**소스 코드:** :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on "
"files and collections of files.  In particular, functions are provided  "
"which support file copying and removal. For operations on individual "
"files, see also the :mod:`os` module."
msgstr ""
":mod:`shutil` 모듈은 파일과 파일 모음에 대한 여러 가지 고수준 연산을 제공합니다. 특히, 파일 복사와 삭제를 지원하는 "
"함수가 제공됩니다. 개별 파일에 대한 연산에 대해서는, :mod:`os` 모듈도 참조하십시오."

#: ../../library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, "
":func:`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"더 고수준의 파일 복사 함수(:func:`shutil.copy`, :func:`shutil.copy2`)조차도 모든 파일 메타 "
"데이터를 복사할 수는 없습니다."

#: ../../library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well"
" as ACLs.  On Mac OS, the resource fork and other metadata are not used. "
"This means that resources will be lost and file type and creator codes "
"will not be correct. On Windows, file owners, ACLs and alternate data "
"streams are not copied."
msgstr ""
"POSIX 플랫폼에서, 이는 ACL뿐만 아니라 파일 소유자와 그룹이 유실됨을 의미합니다. Mac OS에서는, 리소스 "
"포크(resource fork)와 기타 메타 데이터가 사용되지 않습니다. 이는 리소스가 손실되고 파일 유형과 작성자 코드가 올바르지"
" 않음을 의미합니다. 윈도우에서는, 파일 소유자, ACL 및 대체 데이터 스트림(alternate data streams)이 "
"복사되지 않습니다."

#: ../../library/shutil.rst:38
msgid "Directory and files operations"
msgstr "디렉터리와 파일 연산"

#: ../../library/shutil.rst:42
#, fuzzy
msgid ""
"Copy the contents of the :term:`file-like object <file object>` *fsrc* to"
" the file-like object *fdst*. The integer *length*, if given, is the "
"buffer size. In particular, a negative *length* value means to copy the "
"data without looping over the source data in chunks; by default the data "
"is read in chunks to avoid uncontrolled memory consumption. Note that if "
"the current file position of the *fsrc* object is not 0, only the "
"contents from the current file position to the end of the file will be "
"copied."
msgstr ""
"파일류 객체 *fsrc*\\의 내용을 파일류 객체 *fdst*\\에 복사합니다. 주어지면, 정수 *length*\\는 버퍼 "
"크기입니다. 특히, 음의 *length* 값은 청크 단위로 소스 데이터를 반복하지 않고 데이터를 복사하는 것을 의미합니다; "
"기본적으로 제어되지 않은 메모리 소비를 피하고자 데이터를 청크로 읽습니다. *fsrc* 객체의 현재 파일 위치가 0이 아니면, 현재"
" 파일 위치에서 파일 끝까지의 내용만 복사됨에 유의하십시오."

#: ../../library/shutil.rst:53
#, fuzzy
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and "
"*dst* are :term:`path-like objects <path-like object>` or path names "
"given as strings."
msgstr ""
"가능한 가장 효율적인 방법으로 이름이 *src* 인 파일의 내용을 (메타 데이터 없이) 이름이 *dst* 인 파일에 복사하고 "
"*dst*\\를 반환합니다. *src*\\와 *dst*\\는 경로류 객체나 문자열로 지정된 경로 이름입니다."

#: ../../library/shutil.rst:57
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy`"
" for a copy that accepts a target directory path.  If *src* and *dst* "
"specify the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst*\\는 완전한 대상 파일 이름이어야 합니다; 대상 디렉터리 경로를 허용하는 복사는 "
":func:`~shutil.copy`\\를 참조하십시오. *src*\\와 *dst*\\가 같은 파일을 지정하면, "
":exc:`SameFileError`\\가 발생합니다."

#: ../../library/shutil.rst:61
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be "
"copied with this function."
msgstr ""
"대상 위치는 쓰기 가능해야 합니다; 그렇지 않으면, :exc:`OSError` 예외가 발생합니다. *dst*\\가 이미 존재하면, "
"교체됩니다. 문자나 블록 장치 및 파이프와 같은 특수 파일은 이 함수로 복사할 수 없습니다."

#: ../../library/shutil.rst:66
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new "
"symbolic link will be created instead of copying the file *src* points "
"to."
msgstr ""
"*follow_symlinks*\\가 거짓이고 *src*\\가 심볼릭 링크이면, *src*\\가 가리키는 파일을 복사하는 대신 새 "
"심볼릭 링크가 만들어집니다."

#: ../../library/shutil.rst:70 ../../library/shutil.rst:177
#: ../../library/shutil.rst:208
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"인자 ``src``, ``dst``\\로 :ref:`감사 이벤트 <auditing>` ``shutil.copyfile``\\을 "
"발생시킵니다."

#: ../../library/shutil.rst:72
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"예전에는 :exc:`OSError` 대신 :exc:`IOError`\\를 발생시켰습니다. *follow_symlinks* 인자가 "
"추가되었습니다. 이제 *dst*\\를 반환합니다."

#: ../../library/shutil.rst:77
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is "
"a subclass of the latter, this change is backward compatible."
msgstr ""
":exc:`Error` 대신 :exc:`SameFileError`\\를 발생시킵니다. 후자는 전자의 서브 클래스라서, 이 변경은 "
"이전 버전과 호환됩니다."

#: ../../library/shutil.rst:81 ../../library/shutil.rst:185
#: ../../library/shutil.rst:217 ../../library/shutil.rst:287
#: ../../library/shutil.rst:396
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to "
"copy the file more efficiently. See :ref:`shutil-platform-dependent-"
"efficient-copy-operations` section."
msgstr ""
"파일을 더 효율적으로 복사하기 위해 플랫폼별 빠른 복사(fast-copy) 시스템 호출을 내부적으로 사용할 수 있습니다. :ref"
":`shutil-platform-dependent-efficient-copy-operations` 섹션을 참조하십시오."

#: ../../library/shutil.rst:88
msgid ""
"This exception is raised if source and destination in :func:`copyfile` "
"are the same file."
msgstr "이 예외는 :func:`copyfile`\\의 소스와 대상이 같은 파일일 때 발생합니다."

#: ../../library/shutil.rst:96
#, fuzzy
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, "
"and group are unaffected.  *src* and *dst* are :term:`path-like objects "
"<path-like object>` or path names given as strings. If *follow_symlinks* "
"is false, and both *src* and *dst* are symbolic links, :func:`copymode` "
"will attempt to modify the mode of *dst* itself (rather than the file it "
"points to).  This functionality is not available on every platform; "
"please see :func:`copystat` for more information.  If :func:`copymode` "
"cannot modify symbolic links on the local platform, and it is asked to do"
" so, it will do nothing and return."
msgstr ""
"*src*\\에서 *dst*\\로 권한 비트를 복사합니다. 파일 내용, 소유자 및 그룹은 영향을 받지 않습니다. *src*\\와 "
"*dst*\\는 경로류 객체나 문자열로 지정된 경로 이름입니다. *follow_symlinks*\\가 거짓이고 *src*\\와 "
"*dst*\\가 모두 심볼릭 링크이면, :func:`copymode`\\는 (가리키는 파일이 아니라) *dst* 자체의 모드를 "
"수정하려고 시도합니다. 이 기능이 모든 플랫폼에서 사용 가능한 것은 아닙니다; 자세한 내용은 :func:`copystat`\\을 "
"참조하십시오. :func:`copymode`\\가 로컬 플랫폼에서 심볼릭 링크를 수정할 수 없고, 그렇게 하도록 요청받으면, "
"아무것도 하지 않고 반환합니다."

#: ../../library/shutil.rst:106 ../../library/shutil.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"인자 ``src``, ``dst``\\로 :ref:`감사 이벤트 <auditing>` ``shutil.copymode``\\를 "
"발생시킵니다."

#: ../../library/shutil.rst:108
msgid "Added *follow_symlinks* argument."
msgstr "*follow_symlinks* 인자가 추가되었습니다."

#: ../../library/shutil.rst:113
#, fuzzy
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are :term:`path-like objects "
"<path-like object>` or path names given as strings."
msgstr ""
"권한 비트, 마지막 액세스 시간, 마지막 수정 시간 및 플래그를 *src*\\에서 *dst*\\로 복사합니다. 리눅스에서 "
":func:`copystat`\\은 가능하면 \"확장 어트리뷰트(extended attributes)\"도 복사합니다. 파일 내용,"
" 소유자 및 그룹은 영향을 받지 않습니다. *src*\\와 *dst*\\는 경로류 객체나 문자열로 지정된 경로 이름입니다."

#: ../../library/shutil.rst:119
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic"
" links, :func:`copystat` will operate on the symbolic links themselves "
"rather than the files the symbolic links refer to—reading the information"
" from the *src* symbolic link, and writing the information to the *dst* "
"symbolic link."
msgstr ""
"*follow_symlinks*\\가 거짓이고 *src*\\와 *dst*\\가 모두 심볼릭 링크를 참조하면, "
":func:`copystat`\\은 심볼릭 링크가 참조하는 파일이 아닌 심볼릭 링크 자체에 대해 작동합니다 - *src* 심볼릭 "
"링크에서 정보를 읽고, *dst* 심볼릭 링크로 정보를 씁니다."

#: ../../library/shutil.rst:128
msgid ""
"Not all platforms provide the ability to examine and modify symbolic "
"links.  Python itself can tell you what functionality is locally "
"available."
msgstr ""
"모든 플랫폼이 심볼릭 링크를 검사하고 수정할 수 있는 기능을 제공하지는 않습니다. 파이썬 자체는 어떤 기능이 로컬에서 사용 가능한지"
" 알려줄 수 있습니다."

#: ../../library/shutil.rst:132
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, "
":func:`copystat` can modify the permission bits of a symbolic link."
msgstr ""
"``os.chmod in os.supports_follow_symlinks``\\가 ``True``\\이면, "
":func:`copystat`\\은 심볼릭 링크의 권한 비트를 수정할 수 있습니다."

#: ../../library/shutil.rst:136
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, "
":func:`copystat` can modify the last access and modification times of a "
"symbolic link."
msgstr ""
"``os.utime in os.supports_follow_symlinks``\\가 ``True``\\이면, "
":func:`copystat`\\은 심볼릭 링크의 마지막 액세스와 수정 시간을 수정할 수 있습니다."

#: ../../library/shutil.rst:140
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, "
":func:`copystat` can modify the flags of a symbolic link.  "
"(``os.chflags`` is not available on all platforms.)"
msgstr ""
"``os.chflags in os.supports_follow_symlinks``\\가 ``True``\\이면, "
":func:`copystat`\\은 심볼릭 링크의 플래그를 수정할 수 있습니다. (``os.chflags``\\가 모든 플랫폼에서 "
"사용 가능한 것은 아닙니다.)"

#: ../../library/shutil.rst:145
msgid ""
"On platforms where some or all of this functionality is unavailable, when"
" asked to modify a symbolic link, :func:`copystat` will copy everything "
"it can. :func:`copystat` never returns failure."
msgstr ""
"이 기능 중 일부나 전부를 사용할 수 없는 플랫폼에서, 심볼릭 링크를 수정하라는 요청을 하면, :func:`copystat`\\은 "
"가능한 모든 것들을 복사합니다. :func:`copystat`\\은 절대 실패를 반환하지 않습니다."

#: ../../library/shutil.rst:150
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "자세한 내용은 :data:`os.supports_follow_symlinks`\\를 참조하십시오."

#: ../../library/shutil.rst:153 ../../library/shutil.rst:210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"인자 ``src``, ``dst``\\로 :ref:`감사 이벤트 <auditing>` ``shutil.copystat``\\을 "
"발생시킵니다."

#: ../../library/shutil.rst:155
msgid ""
"Added *follow_symlinks* argument and support for Linux extended "
"attributes."
msgstr "*follow_symlinks* 인자와 리눅스 확장 어트리뷰트 지원을 추가했습니다."

#: ../../library/shutil.rst:160
#, fuzzy
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If "
"*dst* specifies a directory, the file will be copied into *dst* using the"
" base filename from *src*. If *dst* specifies a file that already exists,"
" it will be replaced. Returns the path to the newly created file."
msgstr ""
"파일 *src*\\를 파일이나 디렉터리 *dst*\\에 복사합니다. *src*\\와 *dst*\\는 :term:`경로류 객체 "
"<path-like object>`\\나 문자열이어야 합니다. *dst*\\가 디렉터리를 지정하면, 파일은 *src*\\의 기본 "
"파일명을 사용하여 *dst*\\로 복사됩니다. 새로 만든 파일의 경로를 반환합니다."

#: ../../library/shutil.rst:166
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will "
"be created as a symbolic link.  If *follow_symlinks* is true and *src* is"
" a symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"*follow_symlinks*\\가 거짓이고, *src*\\가 심볼릭 링크이면, *dst*\\는 심볼릭 링크로 만들어집니다. "
"*follow_symlinks*\\가 참이고 *src*\\가 심볼릭 링크이면, *dst*\\는 *src*\\가 참조하는 파일의 "
"사본이 됩니다."

#: ../../library/shutil.rst:171
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from "
"the original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy`\\는 파일 데이터와 파일의 권한 모드(:func:`os.chmod`\\를 참조하십시오)를 "
"복사합니다. 파일의 생성과 수정 시간과 같은 다른 메타 데이터는 유지되지 않습니다. 원본의 모든 파일 메타 데이터를 유지하려면 대신"
" :func:`~shutil.copy2`\\를 사용하십시오."

#: ../../library/shutil.rst:181
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created "
"file."
msgstr "*follow_symlinks* 인자가 추가되었습니다. 이제 새로 만든 파일의 경로를 반환합니다."

#: ../../library/shutil.rst:192
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts"
" to preserve file metadata."
msgstr ""
":func:`copy2`\\가 파일 메타 데이터 보존도 시도한다는 점을 제외하고는 :func:`~shutil.copy`\\와 "
"동일합니다."

#: ../../library/shutil.rst:195
#, fuzzy
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, "
":func:`copy2` attempts to copy all metadata from the *src* symbolic link "
"to the newly created *dst* symbolic link. However, this functionality is "
"not available on all platforms. On platforms where some or all of this "
"functionality is unavailable, :func:`copy2` will preserve all the "
"metadata it can; :func:`copy2` never raises an exception because it "
"cannot preserve file metadata."
msgstr ""
"*follow_symlinks*\\가 거짓이고, *src*\\가 심볼릭 링크이면, :func:`copy2`\\는 *src* 심볼릭 "
"링크의 모든 메타 데이터를 새로 만들어진 *dst* 심볼릭 링크로 복사하려고 시도합니다. 그러나, 이 기능이 모든 플랫폼에서 사용 "
"가능한 것은 아닙니다. 이 기능의 일부나 전부를 사용할 수 없는 플랫폼에서, :func:`copy2`\\는 가능한 모든 메타 "
"데이터를 보존합니다; :func:`copy2`\\는 파일 메타 데이터를 보존할 수 없다는 이유로 예외를 발생시키지 않습니다."

#: ../../library/shutil.rst:204
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see"
" :func:`copystat` for more information about platform support for "
"modifying symbolic link metadata."
msgstr ""
":func:`copy2`\\는 :func:`copystat`\\을 사용하여 파일 메타 데이터를 복사합니다. 심볼릭 링크 메타 데이터"
" 수정을 위한 플랫폼 지원에 대한 자세한 정보는 :func:`copystat`\\을 참조하십시오."

#: ../../library/shutil.rst:212
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly "
"created file."
msgstr ""
"*follow_symlinks* 인자를 추가하고, 확장 파일 시스템 어트리뷰트도 복사하려고 합니다 (현재 리눅스만 해당합니다). "
"이제 새로 만든 파일의 경로를 반환합니다."

#: ../../library/shutil.rst:224
msgid ""
"This factory function creates a function that can be used as a callable "
"for :func:`copytree`\\'s *ignore* argument, ignoring files and "
"directories that match one of the glob-style *patterns* provided.  See "
"the example below."
msgstr ""
"이 팩토리 함수는 :func:`copytree`\\의 *ignore* 인자를 위한 콜러블 함수로 사용할 수 있는 함수를 만드는데, "
"제공된 glob 스타일 *patterns* 중 하나와 일치하는 파일과 디렉터리를 무시하도록 합니다. 아래 예를 참조하십시오."

#: ../../library/shutil.rst:233
#, fuzzy
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"*src*\\를 루트로 하는 전체 디렉터리 트리를 *dst*\\라는 디렉터리에 재귀적으로 복사하고 대상 디렉터리를 반환합니다. "
"*dirs_exist_ok*\\는 *dst*\\나 누락된 부모 디렉터리가 이미 존재할 때 예외를 발생시킬지를 나타냅니다."

#: ../../library/shutil.rst:237
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"디렉터리의 권한과 시간은 :func:`copystat`\\으로 복사되고, 개별 파일은 :func:`~shutil.copy2`\\를 "
"사용하여 복사됩니다."

#: ../../library/shutil.rst:240
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented "
"as symbolic links in the new tree and the metadata of the original links "
"will be copied as far as the platform allows; if false or omitted, the "
"contents and metadata of the linked files are copied to the new tree."
msgstr ""
"*symlinks*\\가 참이면, 소스 트리의 심볼릭 링크가 새 트리에서 심볼릭 링크로 표시되고 플랫폼이 허용하는 한 원래 링크의 "
"메타 데이터가 복사됩니다; 거짓이거나 생략되면, 링크된 파일의 내용과 메타 데이터가 새 트리에 복사됩니다."

#: ../../library/shutil.rst:245
#, fuzzy
msgid ""
"When *symlinks* is false, if the file pointed to by the symlink doesn't "
"exist, an exception will be added in the list of errors raised in an "
":exc:`Error` exception at the end of the copy process. You can set the "
"optional *ignore_dangling_symlinks* flag to true if you want to silence "
"this exception. Notice that this option has no effect on platforms that "
"don't support :func:`os.symlink`."
msgstr ""
"*symlinks*\\가 거짓이면, 심볼릭 링크가 가리키는 파일이 존재하지 않으면, 복사 과정 종료 시 발생하는 "
":exc:`Error` 예외의 에러 리스트에 예외가 추가됩니다. 이 예외를 침묵시키려면 선택적 "
"*ignore_dangling_symlinks* 플래그를 참으로 설정할 수 있습니다. 이 옵션은 "
":func:`os.symlink`\\를 지원하지 않는 플랫폼에는 영향을 미치지 않음에 주목하십시오."

#: ../../library/shutil.rst:252
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of "
"its contents, as returned by :func:`os.listdir`.  Since :func:`copytree` "
"is called recursively, the *ignore* callable will be called once for each"
" directory that is copied.  The callable must return a sequence of "
"directory and file names relative to the current directory (i.e. a subset"
" of the items in its second argument); these names will then be ignored "
"in the copy process.  :func:`ignore_patterns` can be used to create such "
"a callable that ignores names based on glob-style patterns."
msgstr ""
"*ignore*\\가 주어지면, :func:`copytree`\\가 방문하는 디렉터리와 :func:`os.listdir`\\가 "
"반환한 이 디렉터리 내용의 리스트를 인자로 수신하는 콜러블 이어야 합니다. :func:`copytree`\\는 재귀적으로 호출되기 "
"때문에, 복사되는 디렉터리마다 *ignore* 콜러블이 한 번 호출됩니다. 콜러블은 현재 디렉터리에 상대적인 디렉터리와 파일 이름의"
" 시퀀스를 반환해야 합니다 (즉, 두 번째 인자에 있는 항목의 부분집합); 이 이름들은 복사 과정에서 무시됩니다. "
":func:`ignore_patterns`\\를 사용하여 glob 스타일 패턴을 기반으로 이름을 무시하는 콜러블을 만들 수 "
"있습니다."

#: ../../library/shutil.rst:262
msgid "If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr "예외가 발생하면, 이유 리스트와 함께 :exc:`Error`\\가 발생합니다."

#: ../../library/shutil.rst:264
msgid ""
"If *copy_function* is given, it must be a callable that will be used to "
"copy each file. It will be called with the source path and the "
"destination path as arguments. By default, :func:`~shutil.copy2` is used,"
" but any function that supports the same signature (like "
":func:`~shutil.copy`) can be used."
msgstr ""
"*copy_function*\\이 제공되면, 각 파일을 복사하는 데 사용되는 콜러블 이어야 합니다. 소스 경로와 대상 경로를 인자로"
" 호출됩니다. 기본적으로, :func:`~shutil.copy2`\\가 사용되지만, 같은 서명을 지원하는 "
"(:func:`~shutil.copy`\\와 같은) 모든 함수를 사용할 수 있습니다."

#: ../../library/shutil.rst:269
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a "
":exc:`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying"
" operation will continue if it encounters existing directories, and files"
" within the *dst* tree will be overwritten by corresponding files from "
"the *src* tree."
msgstr ""

#: ../../library/shutil.rst:275
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"인자 ``src``, ``dst``\\로 :ref:`감사 이벤트 <auditing>` ``shutil.copytree``\\를 "
"발생시킵니다."

#: ../../library/shutil.rst:277
#, fuzzy
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence "
"dangling symlinks errors when *symlinks* is false."
msgstr ""
"사용자 정의 복사 함수를 제공할 수 있도록 *copy_function* 인자를 추가했습니다. *symlinks*\\가 거짓일 때 "
"연결이 끊긴(dangling) 심볼릭 링크 에러를 침묵시키도록 *ignore_dangling_symlinks* 인자를 추가했습니다."

#: ../../library/shutil.rst:283
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "*symlinks*\\가 거짓일 때 메타 데이터를 복사합니다. 이제 *dst*\\를 반환합니다."

#: ../../library/shutil.rst:292
#, fuzzy
msgid "Added the *dirs_exist_ok* parameter."
msgstr "*dirs_exist_ok* 매개 변수."

#: ../../library/shutil.rst:299
#, fuzzy
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but "
"not a symbolic link to a directory).  If *ignore_errors* is true, errors "
"resulting from failed removals will be ignored; if false or omitted, such"
" errors are handled by calling a handler specified by *onexc* or "
"*onerror* or, if both are omitted, exceptions are propagated to the "
"caller."
msgstr ""
"전체 디렉터리 트리를 삭제합니다; *path*\\는 디렉터리를 가리켜야 합니다 (하지만 디렉터리에 대한 심볼릭 링크는 아닙니다). "
"*ignore_errors*\\가 참이면, 삭제 실패로 인한 에러는 무시됩니다; 거짓이거나 생략되면, 이러한 에러는 "
"*onerror*\\로 지정된 처리기를 호출하여 처리하거나, 생략하면 예외가 발생합니다."

#: ../../library/shutil.rst:305
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""

#: ../../library/shutil.rst:310
msgid ""
"On platforms that support the necessary fd-based functions a symlink "
"attack resistant version of :func:`rmtree` is used by default.  On other "
"platforms, the :func:`rmtree` implementation is susceptible to a symlink "
"attack: given proper timing and circumstances, attackers can manipulate "
"symlinks on the filesystem to delete files they wouldn't be able to "
"access otherwise.  Applications can use the "
":data:`rmtree.avoids_symlink_attacks` function attribute to determine "
"which case applies."
msgstr ""
"필요한 fd 기반 함수를 지원하는 플랫폼에서는 기본적으로 :func:`rmtree`\\의 심볼릭 링크 공격 방지 버전이 사용됩니다."
" 다른 플랫폼에서는, :func:`rmtree` 구현이 심볼릭 링크 공격에 취약합니다: 적절한 타이밍과 상황에 따라, 공격자는 파일"
" 시스템에서 심볼릭 링크를 조작하여 다른 방법으로는 액세스할 수 없는 파일을 삭제할 수 있습니다. 응용 프로그램은 "
":data:`rmtree.avoids_symlink_attacks` 함수 어트리뷰트를 사용하여 어떤 버전이 사용되는지 판별할 수 "
"있습니다."

#: ../../library/shutil.rst:318
#, fuzzy
msgid ""
"If *onexc* is provided, it must be a callable that accepts three "
"parameters: *function*, *path*, and *excinfo*."
msgstr ""
"*onerror*\\가 제공되면, 세 가지 매개 변수를 받아들이는 콜러블 이어야 합니다: *function*, *path* 및 "
"*excinfo*."

#: ../../library/shutil.rst:321
#, fuzzy
msgid ""
"The first parameter, *function*, is the function which raised the "
"exception; it depends on the platform and implementation.  The second "
"parameter, *path*, will be the path name passed to *function*.  The third"
" parameter, *excinfo*, is the exception that was raised. Exceptions "
"raised by *onexc* will not be caught."
msgstr ""
"첫 번째 매개 변수 *function*\\은 예외를 발생시킨 함수입니다; 플랫폼과 구현에 따라 다릅니다. 두 번째 매개 변수 "
"*path*\\는 *function*\\에 전달된 경로 이름입니다. 세 번째 매개 변수 *excinfo*\\는 "
":func:`sys.exc_info`\\가 반환한 예외 정보입니다. *onerror*\\에 의해 발생한 예외는 포착되지 않습니다."

#: ../../library/shutil.rst:327
msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""

#: ../../library/shutil.rst:330
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with "
"arguments ``path``, ``dir_fd``."
msgstr "인자 ``path``\\로 :ref:`감사 이벤트 <auditing>` ``shutil.rmtree``\\를 발생시킵니다."

#: ../../library/shutil.rst:332
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr "플랫폼이 fd 기반 함수를 지원하면 자동으로 사용되는 심볼릭 링크 공격 방지 버전을 추가했습니다."

#: ../../library/shutil.rst:336
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr "윈도우에서, 정션(junction)을 제거하기 전에 더는 디렉터리 정션의 내용을 삭제하지 않습니다."

#: ../../library/shutil.rst:340
#, fuzzy
msgid "Added the *dir_fd* parameter."
msgstr "*dirs_exist_ok* 매개 변수."

#: ../../library/shutil.rst:343
msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr ""

#: ../../library/shutil.rst:346
msgid ""
":func:`!rmtree` now ignores :exc:`FileNotFoundError` exceptions for all "
"but the top-level path. Exceptions other than :exc:`OSError` and "
"subclasses of :exc:`!OSError` are now always propagated to the caller."
msgstr ""

#: ../../library/shutil.rst:354
msgid ""
"Indicates whether the current platform and implementation provides a "
"symlink attack resistant version of :func:`rmtree`.  Currently this is "
"only true for platforms supporting fd-based directory access functions."
msgstr ""
"현재 플랫폼과 구현이 :func:`rmtree`\\의 심볼릭 링크 공격 방지 버전을 제공하는지를 나타냅니다. 현재 이것은 fd 기반"
" 디렉터리 액세스 함수를 지원하는 플랫폼에서만 참입니다."

#: ../../library/shutil.rst:363
#, fuzzy
msgid ""
"Recursively move a file or directory (*src*) to another location and "
"return the destination."
msgstr "파일이나 디렉터리(*src*)를 다른 위치(*dst*)로 재귀적으로 옮기고 대상을 반환합니다."

#: ../../library/shutil.rst:366
msgid ""
"If *dst* is an existing directory or a symlink to a directory, then *src*"
" is moved inside that directory. The destination path in that directory "
"must not already exist."
msgstr ""

#: ../../library/shutil.rst:370
#, fuzzy
msgid ""
"If *dst* already exists but is not a directory, it may be overwritten "
"depending on :func:`os.rename` semantics."
msgstr ""
"대상이 기존 디렉터리이면, *src*\\가 해당 디렉터리 내로 이동됩니다. 대상이 이미 존재하지만, 디렉터리가 아니면, "
":func:`os.rename` 의미에 따라 덮어쓸 수 있습니다."

#: ../../library/shutil.rst:373
#, fuzzy
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` "
"is used. Otherwise, *src* is copied to the destination using "
"*copy_function* and then removed.  In case of symlinks, a new symlink "
"pointing to the target of *src* will be created as the destination and "
"*src* will be removed."
msgstr ""
"대상이 현재 파일 시스템에 있으면, :func:`os.rename`\\이 사용됩니다. 그렇지 않으면, "
"*copy_function*\\을 사용하여 *src*\\를 *dst*\\로 복사한 다음 제거합니다. 심볼릭 링크의 경우, "
"*src*\\의 대상을 가리키는 새 심볼릭 링크가 *dst*\\나 그 안에 만들어지고 *src*\\가 제거됩니다."

#: ../../library/shutil.rst:378
#, fuzzy
msgid ""
"If *copy_function* is given, it must be a callable that takes two "
"arguments, *src* and the destination, and will be used to copy *src* to "
"the destination if :func:`os.rename` cannot be used.  If the source is a "
"directory, :func:`copytree` is called, passing it the *copy_function*. "
"The default *copy_function* is :func:`copy2`.  Using :func:`~shutil.copy`"
" as the *copy_function* allows the move to succeed when it is not "
"possible to also copy the metadata, at the expense of not copying any of "
"the metadata."
msgstr ""
"*copy_function*\\이 제공되면, *src*\\와 *dst* 두 개의 인자를 취하는 콜러블 이어야 하며, "
":func:`os.rename`\\을 사용할 수 없을 때 *src*\\를 *dst*\\로 복사하는 데 사용됩니다. 소스가 "
"디렉터리이면, :func:`copytree`\\가 호출되고 :func:`copy_function`\\을 전달합니다. 기본 "
"*copy_function*\\은 :func:`copy2`\\입니다. *copy_function*\\으로 "
":func:`~shutil.copy`\\를 사용하면 메타 데이터를 복사하지 않는 비용을 지불하는 대신 메타 데이터도 복사할 때 "
"실패하는 이동이 성공할 수 있습니다."

#: ../../library/shutil.rst:386
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments"
" ``src``, ``dst``."
msgstr "인자 ``src``, ``dst``\\로 :ref:`감사 이벤트 <auditing>` ``shutil.move``\\를 발생시킵니다."

#: ../../library/shutil.rst:388
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it"
" to the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"외부 파일 시스템에 대한 명시적 심볼릭 링크 처리를 추가하여, GNU :program:`mv`\\의 동작에 맞게 조정했습니다. 이제"
" *dst*\\를 반환합니다."

#: ../../library/shutil.rst:393
msgid "Added the *copy_function* keyword argument."
msgstr "*copy_function* 키워드 인자를 추가했습니다."

#: ../../library/shutil.rst:401
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "*src*\\와 *dst* 모두에 대해 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/shutil.rst:406
msgid ""
"Return disk usage statistics about the given path as a :term:`named "
"tuple` with the attributes *total*, *used* and *free*, which are the "
"amount of total, used and free space, in bytes. *path* may be a file or a"
" directory."
msgstr ""
"지정된 경로(path)에 대한 디스크 사용량 통계를 *total*, *used* 및 *free* 어트리뷰트를 갖는 "
":term:`네임드 튜플 <named tuple>`\\로 반환합니다. 이들은 바이트 단위의 총, 사용된, 여유 공간의 양입니다. "
"*path*\\는 파일이나 디렉터리일 수 있습니다."

#: ../../library/shutil.rst:413
msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""

#: ../../library/shutil.rst:419
msgid "On Windows, *path* can now be a file or directory."
msgstr "윈도우에서, *path*\\는 이제 파일이나 디렉터리일 수 있습니다."

#: ../../library/shutil.rst:422 ../../library/shutil.rst:436
msgid "Availability"
msgstr "가용성"

#: ../../library/shutil.rst:427
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "주어진 *path*\\의 소유자 *user* 및/또는 *group*\\을 변경합니다."

#: ../../library/shutil.rst:429
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. "
"At least one argument is required."
msgstr ""
"*user*\\는 시스템 사용자 이름이나 uid 일 수 있습니다; *group*\\도 마찬가지입니다. 최소한 하나의 인자가 "
"필요합니다."

#: ../../library/shutil.rst:432
msgid "See also :func:`os.chown`, the underlying function."
msgstr "하부 함수인 :func:`os.chown`\\도 참조하십시오."

#: ../../library/shutil.rst:434
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with "
"arguments ``path``, ``user``, ``group``."
msgstr ""
"인자 ``path``, ``user``, ``group``\\으로 :ref:`감사 이벤트 <auditing>` "
"``shutil.chown``\\을 발생시킵니다."

#: ../../library/shutil.rst:440
#, fuzzy
msgid "Added *dir_fd* and *follow_symlinks* parameters."
msgstr "*follow_symlinks* 인자가 추가되었습니다."

#: ../../library/shutil.rst:446
msgid ""
"Return the path to an executable which would be run if the given *cmd* "
"was called.  If no *cmd* would be called, return ``None``."
msgstr ""
"주어진 *cmd*\\가 호출되면 실행될 실행 파일의 경로를 반환합니다. 아무런 *cmd*\\도 호출되지 않을 것이라면, "
"``None``\\을 반환합니다."

#: ../../library/shutil.rst:449
#, fuzzy
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and is executable."
msgstr ""
"*mode*\\는 :func:`os.access`\\에 전달되는 권한 마스크입니다, 기본적으로 파일이 존재하고 실행 가능한지를 "
"판단합니다."

#: ../../library/shutil.rst:452
msgid ""
"*path* is a \"``PATH`` string\" specifying the directories to look in, "
"delimited by :data:`os.pathsep`. When no *path* is specified, the "
":envvar:`PATH` environment variable is read from :data:`os.environ`, "
"falling back to :data:`os.defpath` if it is not set."
msgstr ""

#: ../../library/shutil.rst:457
msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* "
"does not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, "
"the Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To "
"avoid consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""

#: ../../library/shutil.rst:464
#, fuzzy
msgid ""
"Also on Windows, the :envvar:`PATHEXT` environment variable is used to "
"resolve commands that may not already include an extension. For example, "
"if you call ``shutil.which(\"python\")``, :func:`which` will search "
"``PATHEXT`` to know that it should look for ``python.exe`` within the "
"*path* directories. For example, on Windows::"
msgstr ""
"윈도우에서, 기본값을 사용하건 여러분 스스로 제공한 값을 사용하건 현재 디렉터리가 항상 *path* 앞에 추가됩니다, 이는 실행 "
"파일을 찾을 때 명령 셸이 사용하는 동작입니다. 또한, *path*\\에서 *cmd*\\를 찾을 때, ``PATHEXT`` 환경 "
"변수가 확인됩니다. 예를 들어, ``shutil.which(\"python\")``\\을 호출하면, :func:`which`\\는 "
"``PATHEXT``\\를 검색하여 *path* 디렉터리에서 ``python.exe``\\를 찾아야 한다는 것을 알 수 있습니다. "
"예를 들어, 윈도우에서::"

#: ../../library/shutil.rst:470
msgid ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""

#: ../../library/shutil.rst:473
msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr ""

#: ../../library/shutil.rst:476
msgid ""
">> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""

#: ../../library/shutil.rst:481
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is "
":class:`bytes`, the result type is also :class:`bytes`."
msgstr ""
"이제 :class:`bytes` 형을 받아들입니다. *cmd* 형이 :class:`bytes`\\이면 결과 형도 "
":class:`bytes`\\입니다."

#: ../../library/shutil.rst:485
msgid ""
"On Windows, the current directory is no longer prepended to the search "
"path if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; "
"``PATHEXT`` is used now even when *cmd* includes a directory component or"
" ends with an extension that is in ``PATHEXT``; and filenames that have "
"no extension can now be found."
msgstr ""

#: ../../library/shutil.rst:496
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of "
"3-tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"이 예외는 다중 파일 연산 중에 발생한 예외를 수집합니다. :func:`copytree`\\의 경우, 예외 인자는 "
"3-튜플(*srcname*, *dstname*, *exception*)의 리스트입니다."

#: ../../library/shutil.rst:503
msgid "Platform-dependent efficient copy operations"
msgstr "플랫폼 의존적 효율적인 복사 연산"

#: ../../library/shutil.rst:505
msgid ""
"Starting from Python 3.8, all functions involving a file copy "
"(:func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`,"
" and :func:`move`) may use platform-specific \"fast-copy\" syscalls in "
"order to copy the file more efficiently (see :issue:`33671`). \"fast-"
"copy\" means that the copying operation occurs within the kernel, "
"avoiding the use of userspace buffers in Python as in "
"\"``outfd.write(infd.read())``\"."
msgstr ""
"파이썬 3.8부터, 파일 복사를 수반하는 모든 함수(:func:`copyfile`, :func:`~shutil.copy`, "
":func:`copy2`, :func:`copytree` 및 :func:`move`)는 파일을 더 효율적으로 복사하기 위해 플랫폼별"
" \"빠른 복사(fast-copy)\" 시스템 호출을 사용할 수 있습니다 (:issue:`33671`\\을 참조하십시오). \"빠른"
" 복사\"는 복사 연산이 커널 내에서 발생하여, \"``outfd.write(infd.read())``\"와 같이 파이썬에서 사용자"
" 공간 버퍼 사용을 피함을 의미합니다."

#: ../../library/shutil.rst:513
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr "macOS에서는 `fcopyfile`_\\이 (메타 데이터가 아닌) 파일 내용을 복사하는 데 사용됩니다."

#: ../../library/shutil.rst:515
msgid "On Linux :func:`os.sendfile` is used."
msgstr "리눅스에서는 :func:`os.sendfile`\\이 사용됩니다."

#: ../../library/shutil.rst:517
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 "
"MiB instead of 64 KiB) and a :func:`memoryview`-based variant of "
":func:`shutil.copyfileobj` is used."
msgstr ""
"윈도우에서는 :func:`shutil.copyfile`\\이 더 큰 기본 버퍼 크기(64 KiB 대신 1 MiB)를 사용하고 "
":func:`shutil.copyfileobj`\\의 :func:`memoryview` 기반 변형이 사용됩니다."

#: ../../library/shutil.rst:521
msgid ""
"If the fast-copy operation fails and no data was written in the "
"destination file then shutil will silently fallback on using less "
"efficient :func:`copyfileobj` function internally."
msgstr ""
"빠른 복사 연산이 실패하고 대상 파일에 아무런 데이터도 기록되지 않았으면 shutil은 내부적으로 덜 효율적인 "
":func:`copyfileobj` 함수를 사용하여 조용히 폴 백 됩니다."

#: ../../library/shutil.rst:530
msgid "copytree example"
msgstr "copytree 예"

#: ../../library/shutil.rst:532
#, fuzzy
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr ":func:`ignore_patterns` 도우미를 사용하는 다른 예::"

#: ../../library/shutil.rst:534
msgid ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"
msgstr ""

#: ../../library/shutil.rst:538
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr "이것은 ``.pyc`` 파일과 이름이 ``tmp``\\로 시작하는 파일이나 디렉터리를 제외한 모든 것을 복사합니다."

#: ../../library/shutil.rst:541
msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr "로깅 호출을 추가하기 위해 *ignore* 인자를 사용하는 또 다른 예::"

#: ../../library/shutil.rst:543
#, python-format
msgid ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"
msgstr ""

#: ../../library/shutil.rst:556
msgid "rmtree example"
msgstr "rmtree 예"

#: ../../library/shutil.rst:558
#, fuzzy
msgid ""
"This example shows how to remove a directory tree on Windows where some "
"of the files have their read-only bit set. It uses the onexc callback to "
"clear the readonly bit and reattempt the remove. Any subsequent failure "
"will propagate. ::"
msgstr ""
"이 예는 윈도우에서 일부 파일에 읽기 전용 비트가 설정된 디렉터리 트리를 삭제하는 방법을 보여줍니다. onerror 콜백을 사용하여"
" 읽기 전용 비트를 지우고 삭제를 다시 시도합니다. 후속 실패는 전파됩니다. ::"

#: ../../library/shutil.rst:563
msgid ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"
msgstr ""

#: ../../library/shutil.rst:576
msgid "Archiving operations"
msgstr "아카이브 연산"

#: ../../library/shutil.rst:580
msgid "Added support for the *xztar* format."
msgstr "*xztar* 형식에 대한 지원이 추가되었습니다."

#: ../../library/shutil.rst:584
msgid ""
"High-level utilities to create and read compressed and archived files are"
" also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` "
"modules."
msgstr ""
"압축 및 아카이브 된 파일을 만들고 읽는 고수준 유틸리티도 제공됩니다. 이들은 :mod:`zipfile`\\과 "
":mod:`tarfile` 모듈에 의존합니다."

#: ../../library/shutil.rst:589
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "아카이브 파일(가령 zip이나 tar)을 만들고 이름을 반환합니다."

#: ../../library/shutil.rst:591
msgid ""
"*base_name* is the name of the file to create, including the path, minus "
"any format-specific extension."
msgstr ""

#: ../../library/shutil.rst:594
#, fuzzy
msgid ""
"*format* is the archive format: one of \"zip\" (if the :mod:`zlib` module"
" is available), \"tar\", \"gztar\" (if the :mod:`zlib` module is "
"available), \"bztar\" (if the :mod:`bz2` module is available), or "
"\"xztar\" (if the :mod:`lzma` module is available)."
msgstr ""
"*base_name*\\은 만들 파일의 이름인데, 경로를 포함하고 형식별 확장자는 제외합니다. *format*\\은 아카이브 "
"형식입니다: \"zip\" (:mod:`zlib` 모듈을 사용할 수 있으면), \"tar\", \"gztar\" "
"(:mod:`zlib` 모듈을 사용할 수 있으면), \"bztar\" (:mod:`bz2` 모듈을 사용할 수 있으면) 또는 "
"\"xztar\" (:mod:`lzma` 모듈을 사용할 수 있으면) 중 하나."

#: ../../library/shutil.rst:599
msgid ""
"*root_dir* is a directory that will be the root directory of the archive,"
" all paths in the archive will be relative to it; for example, we "
"typically chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir*\\은 아카이브의 루트 디렉터리가 될 디렉터리입니다, 아카이브의 모든 경로는 이것에 상대적입니다; 예를 들어, "
"보통 아카이브를 만들기 전에 *root_dir*\\로 chdir 합니다."

#: ../../library/shutil.rst:603
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. "
"*base_dir* will be the common prefix of all files and directories in the "
"archive.  *base_dir* must be given relative to *root_dir*.  See :ref"
":`shutil-archiving-example-with-basedir` for how to use *base_dir* and "
"*root_dir* together."
msgstr ""
"*base_dir*\\은 아카이브를 시작할 디렉터리입니다; 즉, *base_dir*\\은 아카이브에 있는 모든 파일과 디렉터리의 "
"공통 접두사가 됩니다. *base_dir*\\은 *root_dir*\\에 상대적으로 제공되어야 합니다. *base_dir*\\과 "
"*root_dir*\\을 함께 사용하는 방법은 :ref:`shutil-archiving-example-with-basedir`\\를"
" 참조하십시오."

#: ../../library/shutil.rst:609
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir*\\과 *base_dir*\\은 모두 현재 디렉터리가 기본값입니다."

#: ../../library/shutil.rst:611
msgid ""
"If *dry_run* is true, no archive is created, but the operations that "
"would be executed are logged to *logger*."
msgstr "*dry_run*\\이 참이면, 아카이브가 만들어지지 않지만, 실행될 연산이 *logger*\\에 로그 됩니다."

#: ../../library/shutil.rst:614
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, "
"uses the current owner and group."
msgstr "tar 아카이브를 만들 때 *owner\\와 *group*\\이 사용됩니다. 기본적으로, 현재 소유자와 그룹을 사용합니다."

#: ../../library/shutil.rst:617
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an "
"instance of :class:`logging.Logger`."
msgstr ""
"*logger*\\는 :pep:`282`\\와 호환되는 객체여야 합니다, 일반적으로 :class:`logging.Logger`\\의"
" 인스턴스."

#: ../../library/shutil.rst:620
msgid "The *verbose* argument is unused and deprecated."
msgstr "*verbose* 인자는 사용되지 않으며 폐지되었습니다."

#: ../../library/shutil.rst:622
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"인자 ``base_name``, ``format``, ``root_dir``, ``base_dir``\\로 :ref:`감사 이벤트 "
"<auditing>` ``shutil.make_archive``\\를 발생시킵니다."

#: ../../library/shutil.rst:626
msgid ""
"This function is not thread-safe when custom archivers registered with "
":func:`register_archive_format` do not support the *root_dir* argument.  "
"In this case it temporarily changes the current working directory of the "
"process to *root_dir* to perform archiving."
msgstr ""

#: ../../library/shutil.rst:632
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy "
"GNU format for archives created with ``format=\"tar\"``."
msgstr ""
"``format=\"tar\"``\\로 만들어진 아카이브에 기존 GNU 형식 대신 최신 pax (POSIX.1-2001) 형식이 "
"사용됩니다."

#: ../../library/shutil.rst:636
msgid ""
"This function is now made thread-safe during creation of standard "
"``.zip`` and tar archives."
msgstr ""

#: ../../library/shutil.rst:642
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr "아카이브에 지원되는 형식의 리스트를 반환합니다. 반환된 시퀀스의 각 요소는 튜플 ``(name, description)``\\입니다."

#: ../../library/shutil.rst:645 ../../library/shutil.rst:756
msgid "By default :mod:`shutil` provides these formats:"
msgstr "기본적으로 :mod:`shutil`\\은 다음 형식을 제공합니다:"

#: ../../library/shutil.rst:647
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP 파일 (:mod:`zlib` 모듈을 사용할 수 있으면)."

#: ../../library/shutil.rst:648
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new "
"archives."
msgstr "*tar*: 압축되지 않은 tar 파일. 새 아카이브에 POSIX.1-2001 pax 형식을 사용합니다."

#: ../../library/shutil.rst:649 ../../library/shutil.rst:761
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: gzip 된 tar 파일 (:mod:`zlib` 모듈을 사용할 수 있으면)."

#: ../../library/shutil.rst:650 ../../library/shutil.rst:762
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr "*bztar*: bzip2 된 tar 파일 (:mod:`bz2` 모듈을 사용할 수 있으면)."

#: ../../library/shutil.rst:651 ../../library/shutil.rst:763
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz 된 tar 파일 (:mod:`lzma` 모듈을 사용할 수 있으면)."

#: ../../library/shutil.rst:653
msgid ""
"You can register new formats or provide your own archiver for any "
"existing formats, by using :func:`register_archive_format`."
msgstr ""
":func:`register_archive_format`\\을 사용하여, 새 형식을 등록하거나 기존 형식에 대해 여러분 자신의 "
"아카이버를 제공할 수 있습니다."

#: ../../library/shutil.rst:659
msgid "Register an archiver for the format *name*."
msgstr "*name* 형식을 위한 아카이버를 등록합니다."

#: ../../library/shutil.rst:661
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by "
"the *base_dir* (which defaults to :data:`os.curdir`) to start archiving "
"from. Further arguments are passed as keyword arguments: *owner*, "
"*group*, *dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function*\\은 아카이브를 만드는 데 사용되는 콜러블입니다. 콜러블은 만들 파일의 *base_name*\\과 그 뒤에 "
"아카이브를 시작할 *base_dir*\\(기본값은 :data:`os.curdir`)를 받습니다. 추가 인자는 키워드 인자로 "
"전달됩니다: *owner*, *group*, *dry_run* 및 *logger* (:func:`make_archive`\\로 "
"전달됩니다)."

#: ../../library/shutil.rst:667
msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set"
" to ``True``, the *root_dir* argument is passed as a keyword argument. "
"Otherwise the current working directory of the process is temporarily "
"changed to *root_dir* before calling *function*. In this case "
":func:`make_archive` is not thread-safe."
msgstr ""

#: ../../library/shutil.rst:673
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will"
" be used as extra keywords arguments when the archiver callable is used."
msgstr ""
"주어지면, *extra_args*\\는 아카이버 콜러블이 사용될 때 추가 키워드 인자로 사용되는 ``(name, value)`` "
"쌍의 시퀀스입니다."

#: ../../library/shutil.rst:676
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the "
"list of archivers.  Defaults to an empty string."
msgstr ""
"*description*\\은 아카이버 목록을 반환하는 :func:`get_archive_formats`\\에서 사용됩니다. "
"기본값은 빈 문자열입니다."

#: ../../library/shutil.rst:679
#, fuzzy
msgid "Added support for functions supporting the *root_dir* argument."
msgstr "*xztar* 형식에 대한 지원이 추가되었습니다."

#: ../../library/shutil.rst:685
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "지원되는 형식 리스트에서 *name* 아카이브 형식을 제거합니다."

#: ../../library/shutil.rst:690
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "아카이브를 풉니다. *filename*\\은 아카이브의 전체 경로입니다."

#: ../../library/shutil.rst:692
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr "*extract_dir*\\은 아카이브가 풀리는 대상 디렉터리의 이름입니다. 제공되지 않으면, 현재 작업 디렉터리가 사용됩니다."

#: ../../library/shutil.rst:695
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with "
":func:`register_unpack_format`.  If not provided, :func:`unpack_archive` "
"will use the archive file name extension and see if an unpacker was "
"registered for that extension.  In case none is found, a "
":exc:`ValueError` is raised."
msgstr ""
"*format*\\은 아카이브 형식입니다: \"zip\", \"tar\", \"gztar\", \"bztar\" 또는 "
"\"xztar\" 중 하나. 또는 :func:`register_unpack_format`\\으로 등록된 다른 형식. 제공되지 "
"않으면, :func:`unpack_archive`\\는 아카이브 파일 이름 확장자를 사용하여 그 확장자에 대한 아카이브 해제기가 "
"등록되었는지 확인합니다. 아무것도 발견되지 않으면, :exc:`ValueError`\\가 발생합니다."

#: ../../library/shutil.rst:702
msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to set it to ``'data'``, unless using features specific to "
"tar and UNIX-like filesystems. (See :ref:`tarfile-extraction-filter` for "
"details.) The ``'data'`` filter will become the default for tar files in "
"Python 3.14."
msgstr ""

#: ../../library/shutil.rst:710
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with"
" arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"인자 ``filename``, ``extract_dir``, ``format``\\으로 :ref:`감사 이벤트 <auditing>`"
" ``shutil.unpack_archive``\\를 발생시킵니다."

#: ../../library/shutil.rst:714
msgid ""
"Never extract archives from untrusted sources without prior inspection. "
"It is possible that files are created outside of the path specified in "
"the *extract_dir* argument, e.g. members that have absolute filenames "
"starting with \"/\" or filenames with two dots \"..\"."
msgstr ""

#: ../../library/shutil.rst:719
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr ""
"*filename*\\과 *extract_dir*\\에 대해 :term:`경로류 객체 <path-like object>`\\를 "
"받아들입니다."

#: ../../library/shutil.rst:722
#, fuzzy
msgid "Added the *filter* argument."
msgstr "*copy_function* 키워드 인자를 추가했습니다."

#: ../../library/shutil.rst:727
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like "
"``.zip`` for Zip files."
msgstr ""
"아카이브 해제기를 등록합니다. *name*\\은 형식의 이름이고 *extensions*\\는 형식에 해당하는 확장자의 리스트입니다,"
" 가령 Zip 파일의 경우 ``.zip``."

#: ../../library/shutil.rst:731
#, fuzzy
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr ""
"*function*\\은 아카이브를 푸는 데 사용되는 콜러블입니다. 콜러블은 아카이브의 경로와 그 뒤로 아카이브를 추출해야 하는 "
"디렉터리를 받습니다."

#: ../../library/shutil.rst:734
msgid "the path of the archive, as a positional argument;"
msgstr ""

#: ../../library/shutil.rst:735
msgid "the directory the archive must be extracted to, as a positional argument;"
msgstr ""

#: ../../library/shutil.rst:736
msgid ""
"possibly a *filter* keyword argument, if it was given to "
":func:`unpack_archive`;"
msgstr ""

#: ../../library/shutil.rst:738
msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr ""

#: ../../library/shutil.rst:741
msgid ""
"*description* can be provided to describe the format, and will be "
"returned by the :func:`get_unpack_formats` function."
msgstr ""
"*description*\\은 형식을 설명하기 위해 제공될 수 있으며, :func:`get_unpack_formats` 함수에 의해"
" 반환됩니다."

#: ../../library/shutil.rst:747
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "아카이브 해제 형식을 등록 취소합니다. *name*\\은 형식의 이름입니다."

#: ../../library/shutil.rst:752
msgid ""
"Return a list of all registered formats for unpacking. Each element of "
"the returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"아카이브 해제를 위해 등록된 모든 형식의 리스트를 반환합니다. 반환된 시퀀스의 각 요소는 튜플 ``(name, extensions,"
" description)``\\입니다."

#: ../../library/shutil.rst:758
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the "
"corresponding module is available)."
msgstr "*zip*: ZIP 파일 (압축된 파일의 해제는 해당 모듈을 사용할 수 있을 때만 작동합니다)."

#: ../../library/shutil.rst:760
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: 압축되지 않은 tar 파일."

#: ../../library/shutil.rst:765
msgid ""
"You can register new formats or provide your own unpacker for any "
"existing formats, by using :func:`register_unpack_format`."
msgstr ""
":func:`register_unpack_format`\\을 사용하여, 새 형식을 등록하거나 기존 형식에 대한 여러분 자신의 "
"아카이브 해제기를 제공할 수 있습니다."

#: ../../library/shutil.rst:772
msgid "Archiving example"
msgstr "아카이브 예"

#: ../../library/shutil.rst:774
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all "
"files found in the :file:`.ssh` directory of the user::"
msgstr "이 예에서는, 사용자의 :file:`.ssh` 디렉터리에 있는 모든 파일을 포함하는 gzip 된 tar 파일 아카이브를 만듭니다::"

#: ../../library/shutil.rst:777
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"
msgstr ""

#: ../../library/shutil.rst:784
msgid "The resulting archive contains:"
msgstr "결과 아카이브에는 다음이 포함됩니다:"

#: ../../library/shutil.rst:786
msgid ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"
msgstr ""

#: ../../library/shutil.rst:802
msgid "Archiving example with *base_dir*"
msgstr "*base_dir*\\을 사용한 아카이브 예"

#: ../../library/shutil.rst:804
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_,"
" we show how to use :func:`make_archive`, but this time with the usage of"
" *base_dir*.  We now have the following directory structure:"
msgstr ""
"이 예에서는, `위의 예 <shutil-archiving-example_>`_\\와 유사하게, "
":func:`make_archive`\\를 사용하는 방법을 보여 주지만, 이번에는 *base_dir*\\을 사용합니다. 이제 다음 "
"디렉터리 구조가 있습니다:"

#: ../../library/shutil.rst:808
msgid ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"
msgstr ""

#: ../../library/shutil.rst:818
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but "
":file:`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"최종 아카이브에는, :file:`please_add.txt`\\가 포함되어야 하지만, :file:`do_not_add.txt`\\는"
" 포함되지 않아야 합니다. 따라서 다음을 사용합니다::"

#: ../../library/shutil.rst:821
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/my_archive.tar'"
msgstr ""

#: ../../library/shutil.rst:832
msgid "Listing the files in the resulting archive gives us:"
msgstr "결과 아카이브에 파일을 나열하면 다음과 같습니다:"

#: ../../library/shutil.rst:834
msgid ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"
msgstr ""

#: ../../library/shutil.rst:842
msgid "Querying the size of the output terminal"
msgstr "출력 터미널의 크기 조회하기"

#: ../../library/shutil.rst:846
msgid "Get the size of the terminal window."
msgstr "터미널 창의 크기를 가져옵니다."

#: ../../library/shutil.rst:848
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and"
" ``LINES`` respectively, is checked. If the variable is defined and the "
"value is a positive integer, it is used."
msgstr ""
"두 차원 각각에 대해, 환경 변수 ``COLUMNS``\\와 ``LINES``\\가 각각 확인됩니다. 변수가 정의되고 값이 양의 "
"정수이면 사용됩니다."

#: ../../library/shutil.rst:852
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, "
"the terminal connected to :data:`sys.__stdout__` is queried by invoking "
":func:`os.get_terminal_size`."
msgstr ""
"``COLUMNS``\\나 ``LINES``\\가 정의되지 않으면 (이것이 일반적입니다), "
":func:`os.get_terminal_size`\\를 호출하여 :data:`sys.__stdout__`\\에 연결된 터미널을 "
"조회합니다."

#: ../../library/shutil.rst:856
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback``"
" defaults to ``(80, 24)`` which is the default size used by many terminal"
" emulators."
msgstr ""
"시스템이 조회를 지원하지 않거나, 터미널에 연결되어 있지 않기 때문에 터미널 크기를 성공적으로 조회할 수 없으면, "
"``fallback`` 매개 변수에 제공된 값이 사용됩니다. ``fallback``\\의 기본값은 많은 터미널 에뮬레이터에서 "
"사용하는 기본 크기인 ``(80, 24)``\\입니다."

#: ../../library/shutil.rst:862
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr "반환된 값은 :class:`os.terminal_size` 형의 네임드 튜플입니다."

#: ../../library/shutil.rst:864
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"참조: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."

#: ../../library/shutil.rst:869
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr ""

#: ../../library/shutil.rst:12
msgid "file"
msgstr ""

#: ../../library/shutil.rst:12
msgid "copying"
msgstr ""

#: ../../library/shutil.rst:12
msgid "copying files"
msgstr ""

#: ../../library/shutil.rst:297
msgid "directory"
msgstr ""

#: ../../library/shutil.rst:297
msgid "deleting"
msgstr ""

#~ msgid ":ref:`Availability <availability>`: Unix, Windows."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스, 윈도우."

#~ msgid ":ref:`Availability <availability>`: Unix."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스."

#~ msgid ""
#~ "When no *path* is specified, the "
#~ "results of :func:`os.environ` are used, "
#~ "returning either the \"PATH\" value or"
#~ " a fallback of :attr:`os.defpath`."
#~ msgstr ""
#~ "*path*\\를 지정하지 않으면, :func:`os.environ`\\의 결과가"
#~ " 사용되어, \"PATH\" 값이나 :attr:`os.defpath`\\의 폴"
#~ " 백을 반환합니다."

#~ msgid ""
#~ "This example is the implementation of"
#~ " the :func:`copytree` function, described "
#~ "above, with the docstring omitted.  It"
#~ " demonstrates many of the other "
#~ "functions provided by this module. ::"
#~ msgstr ""
#~ "이 예제는 위에서 설명한 :func:`copytree` 함수의 "
#~ "독스트링이 생략된 구현입니다. 이 모듈에서 제공하는 다른"
#~ " 많은 함수를 예시합니다. ::"

#~ msgid ""
#~ "When provided, *extra_args* is a "
#~ "sequence of ``(name, value)`` tuples "
#~ "that will be passed as keywords "
#~ "arguments to the callable."
#~ msgstr "제공되면, *extra_args*\\는 키워드 인자로 콜러블에 전달되는 ``(name, value)`` 튜플의 시퀀스입니다."

