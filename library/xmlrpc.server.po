# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/xmlrpc.server.rst:2
msgid ":mod:`!xmlrpc.server` --- Basic XML-RPC servers"
msgstr ":mod:`!xmlrpc.server` --- 기본 XML-RPC 서버"

#: ../../library/xmlrpc.server.rst:10
msgid "**Source code:** :source:`Lib/xmlrpc/server.py`"
msgstr "**소스 코드:** :source:`Lib/xmlrpc/server.py`"

#: ../../library/xmlrpc.server.rst:14
msgid ""
"The :mod:`xmlrpc.server` module provides a basic server framework for "
"XML-RPC servers written in Python.  Servers can either be free standing, "
"using :class:`SimpleXMLRPCServer`, or embedded in a CGI environment, "
"using :class:`CGIXMLRPCRequestHandler`."
msgstr ""
":mod:`xmlrpc.server` 모듈은 파이썬으로 작성된 XML-RPC 서버를 위한 기본 서버 프레임워크를 제공합니다. 서버는"
" :class:`SimpleXMLRPCServer`\\를 사용하여 독립적이거나, "
":class:`CGIXMLRPCRequestHandler`\\를 사용하여 CGI 환경에 내장될 수 있습니다."

#: ../../library/xmlrpc.server.rst:22
msgid ""
"The :mod:`xmlrpc.server` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data"
" see :ref:`xml-vulnerabilities`."
msgstr ""
":mod:`xmlrpc.server` 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 "
"데이터를 구문 분석해야 한다면 :ref:`xml-vulnerabilities`\\를 참조하십시오."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/xmlrpc.server.rst:32
msgid ""
"Create a new server instance.  This class provides methods for "
"registration of functions that can be called by the XML-RPC protocol.  "
"The *requestHandler* parameter should be a factory for request handler "
"instances; it defaults to :class:`SimpleXMLRPCRequestHandler`.  The "
"*addr* and *requestHandler* parameters are passed to the "
":class:`socketserver.TCPServer` constructor.  If *logRequests* is true "
"(the default), requests will be logged; setting this parameter to false "
"will turn off logging.   The *allow_none* and *encoding* parameters are "
"passed on to :mod:`xmlrpc.client` and control the XML-RPC responses that "
"will be returned from the server. The *bind_and_activate* parameter "
"controls whether :meth:`server_bind` and :meth:`server_activate` are "
"called immediately by the constructor; it defaults to true. Setting it to"
" false allows code to manipulate the *allow_reuse_address* class variable"
" before the address is bound. The *use_builtin_types* parameter is passed"
" to the :func:`~xmlrpc.client.loads` function and controls which types "
"are processed when date/times values or binary data are received; it "
"defaults to false."
msgstr ""
"새 서버 인스턴스를 만듭니다. 이 클래스는 XML-RPC 프로토콜에 의해 호출될 수 있는 함수를 등록하는 메서드를 제공합니다. "
"*requestHandler* 매개 변수는 요청 처리기 인스턴스의 팩토리여야 합니다; 기본값은 "
":class:`SimpleXMLRPCRequestHandler` 입니다. *addr*\\과 *requestHandler* 매개 "
"변수는 :class:`socketserver.TCPServer` 생성자에 전달됩니다. *logRequests*\\가 "
"참(기본값)이면, 요청이 로그 됩니다; 이 매개 변수를 거짓으로 설정하면 로깅이 해제됩니다. *allow_none*\\과 "
"*encoding* 매개 변수는 :mod:`xmlrpc.client`\\로 전달되고 서버에서 반환될 XML-RPC 응답을 "
"제어합니다. *bind_and_activate* 매개 변수는 생성자가 :meth:`server_bind`\\와 "
":meth:`server_activate`\\를 즉시 호출하는지를 제어합니다; 기본값은 참입니다. 이를 거짓으로 설정하면 코드가 "
"주소가 바인드되기 전에 *allow_reuse_address* 클래스 변수를 조작할 수 있습니다. "
"*use_builtin_types* 매개 변수는 :func:`~xmlrpc.client.loads` 함수로 전달되며 날짜/시간 "
"값이나 바이너리 데이터가 수신될 때 처리되는 형을 제어합니다; 기본값은 거짓입니다."

#: ../../library/xmlrpc.server.rst:48 ../../library/xmlrpc.server.rst:62
#: ../../library/xmlrpc.server.rst:374
msgid "The *use_builtin_types* flag was added."
msgstr "*use_builtin_types* 플래그가 추가되었습니다."

#: ../../library/xmlrpc.server.rst:55
msgid ""
"Create a new instance to handle XML-RPC requests in a CGI environment.  "
"The *allow_none* and *encoding* parameters are passed on to "
":mod:`xmlrpc.client` and control the XML-RPC responses that will be "
"returned from the server. The *use_builtin_types* parameter is passed to "
"the :func:`~xmlrpc.client.loads` function and controls which types are "
"processed when date/times values or binary data are received; it defaults"
" to false."
msgstr ""
"CGI 환경에서 XML-RPC 요청을 처리할 새 인스턴스를 만듭니다. *allow_none*\\과 *encoding* 매개 변수는 "
":mod:`xmlrpc.client`\\로 전달되고 서버에서 반환될 XML-RPC 응답을 제어합니다. "
"*use_builtin_types* 매개 변수는 :func:`~xmlrpc.client.loads` 함수로 전달되며 날짜/시간 "
"값이나 바이너리 데이터가 수신될 때 처리되는 형을 제어합니다; 기본값은 거짓입니다."

#: ../../library/xmlrpc.server.rst:68
msgid ""
"Create a new request handler instance.  This request handler supports "
"``POST`` requests and modifies logging so that the *logRequests* "
"parameter to the :class:`SimpleXMLRPCServer` constructor parameter is "
"honored."
msgstr ""
"새 요청 처리기 인스턴스를 만듭니다. 이 요청 처리기는 ``POST`` 요청을 지원하고 "
":class:`SimpleXMLRPCServer` 생성자 매개 변수에 대한 *logRequests* 매개 변수가 적용되도록 로깅을 "
"수정합니다."

#: ../../library/xmlrpc.server.rst:76
msgid "SimpleXMLRPCServer Objects"
msgstr "SimpleXMLRPCServer 객체"

#: ../../library/xmlrpc.server.rst:78
msgid ""
"The :class:`SimpleXMLRPCServer` class is based on "
":class:`socketserver.TCPServer` and provides a means of creating simple, "
"stand alone XML-RPC servers."
msgstr ""
":class:`SimpleXMLRPCServer` 클래스는 :class:`socketserver.TCPServer`\\를 기반으로 "
"하며 간단한 독립형 XML-RPC 서버를 작성하는 수단을 제공합니다."

#: ../../library/xmlrpc.server.rst:85 ../../library/xmlrpc.server.rst:299
msgid ""
"Register a function that can respond to XML-RPC requests.  If *name* is "
"given, it will be the method name associated with *function*, otherwise "
":attr:`function.__name__` will be used.  *name* is a string, and may "
"contain characters not legal in Python identifiers, including the period "
"character."
msgstr ""
"XML-RPC 요청에 응답할 수 있는 함수를 등록합니다. *name*\\이 제공되면, *function*\\과 연결되는 메서드 "
"이름이 되고, 그렇지 않으면 :attr:`function.__name__`\\이 사용됩니다. *name*\\은 문자열이며 마침표 "
"문자를 포함하여 파이썬 식별자에서 유효하지 않은 문자를 포함할 수 있습니다."

#: ../../library/xmlrpc.server.rst:90 ../../library/xmlrpc.server.rst:304
msgid ""
"This method can also be used as a decorator.  When used as a decorator, "
"*name* can only be given as a keyword argument to register *function* "
"under *name*.  If no *name* is given, :attr:`function.__name__` will be "
"used."
msgstr ""
"이 메서드는 데코레이터로도 사용할 수 있습니다. 데코레이터로 사용될 때, *name*\\은 *function*\\을 "
"*name*\\으로 등록하기 위해 키워드 인자로만 제공될 수 있습니다. *name*\\을 제공하지 않으면, "
":attr:`function.__name__`\\이 사용됩니다."

#: ../../library/xmlrpc.server.rst:94 ../../library/xmlrpc.server.rst:308
msgid ":meth:`register_function` can be used as a decorator."
msgstr ":meth:`register_function`\\은 데코레이터로 사용할 수 있습니다."

#: ../../library/xmlrpc.server.rst:100
msgid ""
"Register an object which is used to expose method names which have not "
"been registered using :meth:`register_function`.  If *instance* contains "
"a :meth:`_dispatch` method, it is called with the requested method name "
"and the parameters from the request.  Its API is ``def _dispatch(self, "
"method, params)`` (note that *params* does not represent a variable "
"argument list).  If it calls an underlying function to perform its task, "
"that function is called as ``func(*params)``, expanding the parameter "
"list. The return value from :meth:`_dispatch` is returned to the client "
"as the result.  If *instance* does not have a :meth:`_dispatch` method, "
"it is searched for an attribute matching the name of the requested "
"method."
msgstr ""
":meth:`register_function`\\을 사용하여 등록되지 않은 메서드 이름을 노출하는데 사용되는 객체를 등록합니다. "
"*instance*\\가 :meth:`_dispatch` 메서드를 포함하면, 요청된 메서드 이름과 요청의 매개 변수로 호출됩니다. "
"API는 ``def _dispatch(self, method, params)``\\입니다 (*params*\\가 가변 인자 목록을 "
"나타내지 않음에 유의하십시오). 이것이 작업을 수행하기 위해 하부 함수를 호출하면, 해당 함수를 매개 변수 리스트를 확장하여 "
"``func(*params)``\\로 호출합니다. :meth:`_dispatch`\\의 반환 값이 클라이언트에 결과로 반환됩니다. "
"*instance*\\에 :meth:`_dispatch` 메서드가 없으면, 요청된 메서드의 이름과 일치하는 어트리뷰트를 검색합니다."

#: ../../library/xmlrpc.server.rst:111
msgid ""
"If the optional *allow_dotted_names* argument is true and the instance "
"does not have a :meth:`_dispatch` method, then if the requested method "
"name contains periods, each component of the method name is searched for "
"individually, with the effect that a simple hierarchical search is "
"performed.  The value found from this search is then called with the "
"parameters from the request, and the return value is passed back to the "
"client."
msgstr ""
"선택적 *allow_dotted_names* 인자가 참이고 인스턴스에 :meth:`_dispatch` 메서드가 없으면, 요청된 "
"메서드 이름에 마침표가 포함될 때, 메서드 이름의 각 구성 요소가 개별적으로 검색되어, 간단한 계층 구조 검색이 수행되는 효과를 "
"줍니다. 이 검색에서 찾은 값은 요청의 매개 변수로 호출되며 반환 값은 클라이언트로 다시 전달됩니다."

#: ../../library/xmlrpc.server.rst:120
msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary "
"code on your machine.  Only use this option on a secure, closed network."
msgstr ""
"*allow_dotted_names* 옵션을 활성화하면 침입자가 모듈의 전역 변수에 액세스할 수 있으며 침입자가 여러분의 기계에서 "
"임의의 코드를 실행할 수 있습니다. 안전한 폐쇄 네트워크에서만 이 옵션을 사용하십시오."

#: ../../library/xmlrpc.server.rst:127
msgid ""
"Registers the XML-RPC introspection functions ``system.listMethods``, "
"``system.methodHelp`` and ``system.methodSignature``."
msgstr ""
"XML-RPC 내부 검사 함수 ``system.listMethods``, ``system.methodHelp`` 및 "
"``system.methodSignature``\\를 등록합니다."

#: ../../library/xmlrpc.server.rst:133
msgid "Registers the XML-RPC multicall function system.multicall."
msgstr "XML-RPC 다중 호출(multicall) 함수 system.multicall을 등록합니다."

#: ../../library/xmlrpc.server.rst:138
msgid ""
"An attribute value that must be a tuple listing valid path portions of "
"the URL for receiving XML-RPC requests.  Requests posted to other paths "
"will result in a 404 \"no such page\" HTTP error.  If this tuple is "
"empty, all paths will be considered valid. The default value is ``('/', "
"'/RPC2')``."
msgstr ""
"XML-RPC 요청을 수신하기 위한 URL의 유효한 경로 부분을 나열하는 튜플이어야 하는 어트리뷰트 값. 다른 경로로 들어오는 "
"요청은 404 \"no such page\" HTTP 에러를 발생시킵니다. 이 튜플이 비어 있으면, 모든 경로를 유효한 것으로 "
"간주합니다. 기본값은 ``('/', '/RPC2')``\\입니다."

#: ../../library/xmlrpc.server.rst:147
msgid "SimpleXMLRPCServer Example"
msgstr "SimpleXMLRPCServer 예제"

#: ../../library/xmlrpc.server.rst:148
msgid "Server code::"
msgstr "서버 코드::"

#: ../../library/xmlrpc.server.rst:150
msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# 특정 경로로 제한합니다.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# 서버를 만듭니다\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # pow() 함수를 등록합니다; pow.__name__ 값을 이름으로 사용하는데,\n"
"    # 그냥 'pow' 입니다.\n"
"    server.register_function(pow)\n"
"\n"
"    # 함수를 다른 이름으로 등록합니다\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # 인스턴스를 등록합니다; 인스턴스의 모든 메서드가 XML-RPC 메서드로 노출됩니다\n"
"    # (이 경우는 'mul' 뿐입니다).\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # 서버의 메인 루프를 실행합니다\n"
"    server.serve_forever()"

#: ../../library/xmlrpc.server.rst:182
msgid ""
"The following client code will call the methods made available by the "
"preceding server::"
msgstr "다음 클라이언트 코드는 앞의 서버가 제공하는 메서드를 호출합니다::"

#: ../../library/xmlrpc.server.rst:185
msgid ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"
msgstr ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # 2**3 = 8 을 반환합니다\n"
"print(s.add(2,3))  # 5 를 반환합니다\n"
"print(s.mul(5,2))  # 5*2 = 10 을 반환합니다\n"
"\n"
"# 사용할 수 있는 메서드의 목록을 인쇄합니다\n"
"print(s.system.listMethods())"

#: ../../library/xmlrpc.server.rst:195
msgid ""
":meth:`register_function` can also be used as a decorator. The previous "
"server example can register functions in a decorator way::"
msgstr ""
":meth:`register_function`\\은 데코레이터로도 사용할 수 있습니다. 앞의 서버 예제에서 데코레이터 방식으로 "
"함수를 등록할 수 있습니다::"

#: ../../library/xmlrpc.server.rst:198
msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # pow() 함수를 등록합니다; pow.__name__ 값을 이름으로 사용하는데,\n"
"    # 그냥 'pow' 입니다.\n"
"    server.register_function(pow)\n"
"\n"
"    # register_function을 데코레이터로 사용해서, 함수를 다른 이름으로 등록합니다.\n"
"    # *name* 은 키워드 인자로만 줄 수 있습니다.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # 함수를 function.__name__ 으로 등록합니다.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"

#: ../../library/xmlrpc.server.rst:226
msgid ""
"The following example included in the :file:`Lib/xmlrpc/server.py` module"
" shows a server allowing dotted names and registering a multicall "
"function."
msgstr ""
":file:`Lib/xmlrpc/server.py` 모듈에 포함된 다음 예는 점으로 구분된 이름을 허용하고 다중 호출 함수를 "
"등록하는 서버를 보여줍니다."

#: ../../library/xmlrpc.server.rst:231
msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary "
"code on your machine.  Only use this example only within a secure, closed"
" network."
msgstr ""
"*allow_dotted_names* 옵션을 활성화하면 침입자가 모듈의 전역 변수에 액세스할 수 있으며 침입자가 여러분의 기계에서 "
"임의의 코드를 실행할 수 있습니다. 이 예제는 안전한 폐쇄 네트워크 내에서만 사용하십시오."

#: ../../library/xmlrpc.server.rst:237
msgid ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"
msgstr ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"

#: ../../library/xmlrpc.server.rst:260
msgid "This ExampleService demo can be invoked from the command line::"
msgstr "이 ExampleService 데모는 명령 줄에서 호출할 수 있습니다::"

#: ../../library/xmlrpc.server.rst:262
msgid "python -m xmlrpc.server"
msgstr "python -m xmlrpc.server"

#: ../../library/xmlrpc.server.rst:265
msgid ""
"The client that interacts with the above server is included in "
"``Lib/xmlrpc/client.py``::"
msgstr "위 서버와 상호 작용하는 클라이언트는 ``Lib/xmlrpc/client.py``\\에 포함되어 있습니다::"

#: ../../library/xmlrpc.server.rst:268
msgid ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"
msgstr ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"

#: ../../library/xmlrpc.server.rst:285
msgid ""
"This client which interacts with the demo XMLRPC server can be invoked "
"as::"
msgstr "데모 XMLRPC 서버와 상호 작용하는 이 클라이언트는 다음과 같이 호출할 수 있습니다::"

#: ../../library/xmlrpc.server.rst:287
msgid "python -m xmlrpc.client"
msgstr "python -m xmlrpc.client"

#: ../../library/xmlrpc.server.rst:291
msgid "CGIXMLRPCRequestHandler"
msgstr "CGIXMLRPCRequestHandler"

#: ../../library/xmlrpc.server.rst:293
msgid ""
"The :class:`CGIXMLRPCRequestHandler` class can be used to handle XML-RPC "
"requests sent to Python CGI scripts."
msgstr ""
":class:`CGIXMLRPCRequestHandler` 클래스는 파이썬 CGI 스크립트로 전송된 XML-RPC 요청을 처리하는 "
"데 사용할 수 있습니다."

#: ../../library/xmlrpc.server.rst:314
msgid ""
"Register an object which is used to expose method names  which have not "
"been registered using :meth:`register_function`. If  instance contains a "
":meth:`_dispatch` method, it is called with the  requested method name "
"and the parameters from the  request; the return value is returned to the"
" client as the result. If instance does not have a :meth:`_dispatch` "
"method, it is searched for an attribute matching the name of the "
"requested method; if  the requested method name contains periods, each  "
"component of the method name is searched for individually,  with the "
"effect that a simple hierarchical search is performed. The value found "
"from this search is then called with the  parameters from the request, "
"and the return value is passed  back to the client."
msgstr ""
":meth:`register_function`\\을 사용하여 등록되지 않은 메서드 이름을 노출하는데 사용되는 객체를 등록합니다. "
"instance가 :meth:`_dispatch` 메서드를 포함하면, 요청된 메서드 이름과 요청의 매개 변수로 호출됩니다; 반환 "
"값이 클라이언트에 결과로 반환됩니다. instance에 :meth:`_dispatch` 메서드가 없으면, 요청된 메서드의 이름과 "
"일치하는 어트리뷰트를 검색합니다; 요청된 메서드 이름에 마침표가 포함될 때, 메서드 이름의 각 구성 요소가 개별적으로 검색되어, "
"간단한 계층 구조 검색이 수행되는 효과를 줍니다. 이 검색에서 찾은 값은 요청의 매개 변수로 호출되며 반환 값은 클라이언트로 다시 "
"전달됩니다."

#: ../../library/xmlrpc.server.rst:328
msgid ""
"Register the XML-RPC introspection functions  ``system.listMethods``, "
"``system.methodHelp`` and  ``system.methodSignature``."
msgstr ""
"XML-RPC 내부 검사 함수 ``system.listMethods``, ``system.methodHelp`` 및 "
"``system.methodSignature``\\를 등록합니다."

#: ../../library/xmlrpc.server.rst:334
msgid "Register the XML-RPC multicall function ``system.multicall``."
msgstr "XML-RPC 다중 호출(multicall) 함수 ``system.multicall``\\을 등록합니다."

#: ../../library/xmlrpc.server.rst:339
msgid ""
"Handle an XML-RPC request. If *request_text* is given, it should be the "
"POST data provided by the HTTP server,  otherwise the contents of stdin "
"will be used."
msgstr ""
"XML-RPC 요청을 처리합니다. *request_text*\\가 제공되면, HTTP 서버가 제공한 POST 데이터여야 합니다, "
"그렇지 않으면 stdin의 내용이 사용됩니다."

#: ../../library/xmlrpc.server.rst:342
msgid "Example::"
msgstr "예::"

#: ../../library/xmlrpc.server.rst:344
msgid ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"
msgstr ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"

#: ../../library/xmlrpc.server.rst:358
msgid "Documenting XMLRPC server"
msgstr "XMLRPC 서버 문서화"

#: ../../library/xmlrpc.server.rst:360
msgid ""
"These classes extend the above classes to serve HTML documentation in "
"response to HTTP GET requests.  Servers can either be free standing, "
"using :class:`DocXMLRPCServer`, or embedded in a CGI environment, using "
":class:`DocCGIXMLRPCRequestHandler`."
msgstr ""
"이 클래스들은 HTTP GET 요청에 대한 응답으로 HTML 설명서를 제공하기 위해 위의 클래스를 확장합니다. 서버는 "
":class:`DocXMLRPCServer`\\를 사용하여 독립적이거나, "
":class:`DocCGIXMLRPCRequestHandler`\\를 사용하여 CGI 환경에 내장될 수 있습니다."

#: ../../library/xmlrpc.server.rst:370
msgid ""
"Create a new server instance. All parameters have the same meaning as for"
" :class:`SimpleXMLRPCServer`; *requestHandler* defaults to "
":class:`DocXMLRPCRequestHandler`."
msgstr ""
"새 서버 인스턴스를 만듭니다. 모든 매개 변수는 :class:`SimpleXMLRPCServer`\\와 같은 의미입니다; "
"*requestHandler*\\의 기본값은 :class:`DocXMLRPCRequestHandler` 입니다."

#: ../../library/xmlrpc.server.rst:380
msgid "Create a new instance to handle XML-RPC requests in a CGI environment."
msgstr "CGI 환경에서 XML-RPC 요청을 처리할 새 인스턴스를 만듭니다."

#: ../../library/xmlrpc.server.rst:385
msgid ""
"Create a new request handler instance. This request handler supports XML-"
"RPC POST requests, documentation GET requests, and modifies logging so "
"that the *logRequests* parameter to the :class:`DocXMLRPCServer` "
"constructor parameter is honored."
msgstr ""
"새 요청 처리기 인스턴스를 만듭니다. 이 요청 처리기는 XML-RPC POST 요청과 설명서 GET 요청을 지원하고, "
":class:`DocXMLRPCServer` 생성자 매개 변수에 대한 *logRequests* 매개 변수가 적용되도록 로깅을 "
"수정합니다."

#: ../../library/xmlrpc.server.rst:394
msgid "DocXMLRPCServer Objects"
msgstr "DocXMLRPCServer 객체"

#: ../../library/xmlrpc.server.rst:396
msgid ""
"The :class:`DocXMLRPCServer` class is derived from "
":class:`SimpleXMLRPCServer` and provides a means of creating self-"
"documenting, stand alone XML-RPC servers. HTTP POST requests are handled "
"as XML-RPC method calls. HTTP GET requests are handled by generating "
"pydoc-style HTML documentation. This allows a server to provide its own "
"web-based documentation."
msgstr ""
":class:`DocXMLRPCServer` 클래스는 :class:`SimpleXMLRPCServer` 에서 파생되며 스스로 "
"설명하는 독립형 XML-RPC 서버를 만드는 수단을 제공합니다. HTTP POST 요청은 XML-RPC 메서드 호출로 처리됩니다. "
"HTTP GET 요청은 pydoc 스타일 HTML 문서를 생성하는 것으로 처리합니다. 이를 통해 서버는 자체 웹 기반 설명서를 "
"제공할 수 있습니다."

#: ../../library/xmlrpc.server.rst:405 ../../library/xmlrpc.server.rst:433
msgid ""
"Set the title used in the generated HTML documentation. This title will "
"be used inside the HTML \"title\" element."
msgstr "생성된 HTML 설명서에 사용되는 제목을 설정합니다. 이 제목은 HTML \"title\" 요소 안에서 사용됩니다."

#: ../../library/xmlrpc.server.rst:411 ../../library/xmlrpc.server.rst:439
msgid ""
"Set the name used in the generated HTML documentation. This name will "
"appear at the top of the generated documentation inside a \"h1\" element."
msgstr "생성된 HTML 설명서에 사용되는 이름을 설정합니다. 이 이름은 설명서의 최상단의 \"h1\" 요소 안에 나타납니다."

#: ../../library/xmlrpc.server.rst:417 ../../library/xmlrpc.server.rst:445
msgid ""
"Set the description used in the generated HTML documentation. This "
"description will appear as a paragraph, below the server name, in the "
"documentation."
msgstr "생성된 HTML 설명서에 사용되는 설명을 설정합니다. 이 설명은 설명서에서 서버 이름 아래 단락으로 나타납니다."

#: ../../library/xmlrpc.server.rst:422
msgid "DocCGIXMLRPCRequestHandler"
msgstr "DocCGIXMLRPCRequestHandler"

#: ../../library/xmlrpc.server.rst:424
msgid ""
"The :class:`DocCGIXMLRPCRequestHandler` class is derived from "
":class:`CGIXMLRPCRequestHandler` and provides a means of creating self-"
"documenting, XML-RPC CGI scripts. HTTP POST requests are handled as XML-"
"RPC method calls. HTTP GET requests are handled by generating pydoc-style"
" HTML documentation. This allows a server to provide its own web-based "
"documentation."
msgstr ""
":class:`DocCGIXMLRPCRequestHandler` 클래스는 :class:`CGIXMLRPCRequestHandler`"
" 에서 파생되며 스스로 설명하는 XML-RPC CGI 스크립트를 만드는 수단을 제공합니다. HTTP POST 요청은 XML-RPC "
"메서드 호출로 처리됩니다. HTTP GET 요청은 pydoc 스타일 HTML 문서를 생성하는 것으로 처리합니다. 이를 통해 서버는 "
"자체 웹 기반 설명서를 제공할 수 있습니다."

