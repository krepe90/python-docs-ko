# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/ssl.rst:2
#, fuzzy
msgid ":mod:`!ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- 소켓 객체용 TLS/SSL 래퍼"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**소스 코드:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
#, fuzzy
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities "
"for network sockets, both client-side and server-side.  This module uses "
"the OpenSSL library. It is available on all modern Unix systems, Windows,"
" macOS, and probably additional platforms, as long as OpenSSL is "
"installed on that platform."
msgstr ""
"이 모듈은 클라이언트 쪽과 서버 쪽 네트워크 소켓에 대한 전송 계층 보안(Transport Layer Security) (\"보안 "
"소켓 계층(Secure Sockets Layer)\" 이라고도 함) 암호화와 피어 인증 기능에 대한 액세스를 제공합니다. 이 모듈은"
" OpenSSL 라이브러리를 사용합니다. OpenSSL이 해당 플랫폼에 설치되어있는 한, 모든 최신 유닉스 시스템, 윈도우, 맥 "
"OS X 및 추가 플랫폼에서 사용할 수 있습니다."

#: ../../library/ssl.rst:26
#, fuzzy
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 comes with OpenSSL "
"version 1.1.1."
msgstr ""
"운영 체제 소켓 API를 호출하기 때문에, 일부 동작은 플랫폼에 따라 다를 수 있습니다. 설치된 OpenSSL 버전도 동작을 바꿀 "
"수 있습니다. 예를 들어, TLSv1.1과 TLSv1.2는 openssl 버전 1.0.1과 함께 제공됩니다."

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so "
"may lead to a false sense of security, as the default settings of the ssl"
" module are not necessarily appropriate for your application."
msgstr ""
":ref:`ssl-security`\\을 읽지 않고 이 모듈을 사용하지 마십시오. 그렇게 하면 ssl 모듈의 기본 설정이 반드시 "
"여러분의 응용 프로그램에 적합하지는 않으므로 잘못된 보안 인식으로 이어질 수 있습니다."

#: ../../includes/wasm-notavail.rst:3 ../../library/ssl.rst:454
#: ../../library/ssl.rst:469
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""

#: ../../library/ssl.rst:38
msgid ""
"This section documents the objects and functions in the ``ssl`` module; "
"for more general information about TLS, SSL, and certificates, the reader"
" is referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"이 절에서는 ``ssl`` 모듈의 객체와 함수를 설명합니다; TLS, SSL 및 인증서에 대한보다 일반적인 정보는, 하단의 \"더 "
"보기\" 절에 있는 문서를 참조하십시오."

#: ../../library/ssl.rst:42
#, fuzzy
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived "
"from the :class:`socket.socket` type, and provides a socket-like wrapper "
"that also encrypts and decrypts the data going over the socket with SSL."
"  It supports additional methods such as :meth:`getpeercert`, which "
"retrieves the certificate of the other side of the connection, "
":meth:`cipher`, which retrieves the cipher being used for the secure "
"connection or :meth:`get_verified_chain`, :meth:`get_unverified_chain` "
"which retrieves certificate chain."
msgstr ""
"이 모듈은 :class:`socket.socket` 형에서 파생된 :class:`ssl.SSLSocket` 클래스를 제공하며, "
"SSL을 사용하여 소켓을 통해 전달되는 데이터를 암호화하고 복호화하는 소켓 형 래퍼를 제공합니다. 또한 추가 메서드를 지원하는데, "
"가령 연결의 다른 쪽 인증서를 조회하는 :meth:`getpeercert`\\와 보안 연결에 사용되는 사이퍼(cipher)를 "
"조회하는 :meth:`cipher`\\가 있습니다."

#: ../../library/ssl.rst:51
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class "
"helps manage settings and certificates, which can then be inherited by "
"SSL sockets created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"더욱 정교한 응용 프로그램의 경우, :class:`ssl.SSLContext` 클래스는 설정과 인증서를 관리하는 데 도움이 되며, "
":meth:`SSLContext.wrap_socket` 메서드를 통해 만들어진 SSL 소켓이 상속할 수 있습니다."

#: ../../library/ssl.rst:55
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "OpenSSL 1.1.0과의 링크를 지원하도록 갱신되었습니다"

#: ../../library/ssl.rst:60
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In"
" the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 및 1.0.1은 폐지되었으며 더는 지원되지 않습니다. 미래에는 ssl 모듈이 최소한 "
"OpenSSL 1.0.2 나 1.1.0을 요구할 것입니다."

#: ../../library/ssl.rst:66
#, fuzzy
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or"
" newer."
msgstr "이 기능을 사용하려면 OpenSSL 1.1.1 이상이 필요합니다."

#: ../../library/ssl.rst:69
msgid "Use of deprecated constants and functions result in deprecation warnings."
msgstr ""

#: ../../library/ssl.rst:73
msgid "Functions, Constants, and Exceptions"
msgstr "함수, 상수 및 예외"

#: ../../library/ssl.rst:77
msgid "Socket creation"
msgstr "소켓 생성"

#: ../../library/ssl.rst:79
#, fuzzy
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method. The helper function "
":func:`create_default_context` returns a new context with secure default "
"settings."
msgstr ""
":class:`SSLSocket`\\의 인스턴스는 :meth:`SSLContext.wrap_socket` 메서드를 사용하여 민들어야"
" 합니다."

#: ../../library/ssl.rst:84
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr "기본 컨텍스트와 IPv4/IPv6 이중 스택을 사용하는 클라이언트 소켓 예제::"

#: ../../library/ssl.rst:86
msgid ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""

#: ../../library/ssl.rst:97
msgid "Client socket example with custom context and IPv4::"
msgstr "사용자 정의 컨텍스트와 IPv4를 사용하는 클라이언트 소켓 예제::"

#: ../../library/ssl.rst:99
msgid ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""

#: ../../library/ssl.rst:109
msgid "Server socket example listening on localhost IPv4::"
msgstr "localhost IPv4에서 리스닝하는 서버 소켓 예제::"

#: ../../library/ssl.rst:111
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')"
"\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."
msgstr ""

#: ../../library/ssl.rst:123
msgid "Context creation"
msgstr "컨텍스트 생성"

#: ../../library/ssl.rst:125
msgid ""
"A convenience function helps create :class:`SSLContext` objects for "
"common purposes."
msgstr "편리 함수는 공통 목적을 위한 :class:`SSLContext` 객체를 만드는 데 도움이 됩니다."

#: ../../library/ssl.rst:130
msgid ""
"Return a new :class:`SSLContext` object with default settings for the "
"given *purpose*.  The settings are chosen by the :mod:`ssl` module, and "
"usually represent a higher security level than when calling the "
":class:`SSLContext` constructor directly."
msgstr ""
"지정된 *purpose*\\를 위한 기본 설정으로 새 :class:`SSLContext` 객체를 반환합니다. 설정은 "
":mod:`ssl` 모듈에 의해 선택되며, 일반적으로 :class:`SSLContext` 생성자를 직접 호출할 때 보다 높은 보안 "
"수준을 나타냅니다."

#: ../../library/ssl.rst:135
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust "
"for certificate verification, as in "
":meth:`SSLContext.load_verify_locations`.  If all three are "
":const:`None`, this function can choose to trust the system's default CA "
"certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata*\\는, "
":meth:`SSLContext.load_verify_locations`\\에서와 같이, 인증서 확인을 위해 신뢰할 수 있는 선택적"
" CA 인증서를 나타냅니다. 세 개 모두가 :const:`None`\\이면, 이 함수는 대신 시스템의 기본 CA 인증서를 신뢰하도록"
" 선택할 수 있습니다."

#: ../../library/ssl.rst:141
#, fuzzy
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3`"
" with high encryption cipher suites without RC4 and without "
"unauthenticated cipher suites. Passing :const:`~Purpose.SERVER_AUTH` as "
"*purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` "
"and either loads CA certificates (when at least one of *cafile*, *capath*"
" or *cadata* is given) or uses :meth:`SSLContext.load_default_certs` to "
"load default CA certificates."
msgstr ""
"설정은: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2` 및 :data:`OP_NO_SSLv3`\\이며,"
" RC4가 없는 높은 암호화 사이퍼 스위트가 포함되고, 인증되지 않은 사이퍼 스위트는 포함되지 않습니다. "
":data:`~Purpose.SERVER_AUTH`\\를 *purpose*\\로 전달하면 "
":data:`~SSLContext.verify_mode`\\가 :data:`CERT_REQUIRED`\\로 설정되고 CA 인증서가 "
"로드되거나 (*cafile*, *capath* 또는 *cadata* 중 하나 이상이 제공될 때), "
":meth:`SSLContext.load_default_certs`\\를 사용하여 기본 CA 인증서를 로드합니다."

#: ../../library/ssl.rst:150
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment"
" variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
":attr:`~SSLContext.keylog_filename`\\이 지원되고 환경 변수 "
":envvar:`SSLKEYLOGFILE`\\이 설정될 때, :func:`create_default_context`\\는 키 로깅을"
" 활성화합니다."

#: ../../library/ssl.rst:154
msgid ""
"The default settings for this context include "
":data:`VERIFY_X509_PARTIAL_CHAIN` and :data:`VERIFY_X509_STRICT`. These "
"make the underlying OpenSSL implementation behave more like a conforming "
"implementation of :rfc:`5280`, in exchange for a small amount of "
"incompatibility with older X.509 certificates."
msgstr ""

#: ../../library/ssl.rst:161
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values "
"represent a fair balance between compatibility and security."
msgstr ""
"프로토콜, 옵션, 사이퍼 및 기타 설정은 사전 폐지 없이 언제든지 더욱 제한적인 값으로 변경될 수 있습니다. 이 값은 호환성과 보안"
" 간의 적절한 균형을 나타냅니다."

#: ../../library/ssl.rst:165
msgid ""
"If your application needs specific settings, you should create a "
":class:`SSLContext` and apply the settings yourself."
msgstr "응용 프로그램에 특정 설정이 필요하면, :class:`SSLContext`\\를 만들어 설정을 직접 적용해야 합니다."

#: ../../library/ssl.rst:169
msgid ""
"If you find that when certain older clients or servers attempt to connect"
" with a :class:`SSLContext` created by this function that they get an "
"error stating \"Protocol or cipher suite mismatch\", it may be that they "
"only support SSL3.0 which this function excludes using the "
":data:`OP_NO_SSLv3`. SSL3.0 is widely considered to be `completely broken"
" <https://en.wikipedia.org/wiki/POODLE>`_. If you still wish to continue "
"to use this function but still allow SSL 3.0 connections you can re-"
"enable them using::"
msgstr ""
"특정 이전 클라이언트나 서버가 이 함수로 만든 :class:`SSLContext`\\로 연결을 시도할 때 \"Protocol or "
"cipher suite mismatch\"라는 에러가 발생하면, 이 함수가 :data:`OP_NO_SSLv3`\\를 사용해서 "
"제외하는 SSL3.0만 지원하는 것일 수 있습니다. SSL3.0은 `완전히 망가진 "
"<https://en.wikipedia.org/wiki/POODLE>`_\\것으로 널리 인식되고 있습니다. 이 함수를 계속 "
"사용하면서 SSL 3.0 연결을 계속 허용하려면 다음과 같이 다시 활성화할 수 있습니다::"

#: ../../library/ssl.rst:178
msgid ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"
msgstr ""

#: ../../library/ssl.rst:182
msgid ""
"This context enables :data:`VERIFY_X509_STRICT` by default, which may "
"reject pre-:rfc:`5280` or malformed certificates that the underlying "
"OpenSSL implementation otherwise would accept. While disabling this is "
"not recommended, you can do so using::"
msgstr ""

#: ../../library/ssl.rst:187
msgid ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"
msgstr ""

#: ../../library/ssl.rst:194
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4는 기본 사이퍼 문자열에서 삭제되었습니다."

#: ../../library/ssl.rst:198
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305가 기본 사이퍼 문자열에 추가되었습니다."

#: ../../library/ssl.rst:200
msgid "3DES was dropped from the default cipher string."
msgstr "3DES가 기본 사이퍼 문자열에서 삭제되었습니다."

#: ../../library/ssl.rst:204
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr ":envvar:`SSLKEYLOGFILE`\\에 대한 키 로깅 지원이 추가되었습니다."

#: ../../library/ssl.rst:208
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER` protocol instead of generic "
":data:`PROTOCOL_TLS`."
msgstr ""

#: ../../library/ssl.rst:214
msgid ""
"The context now uses :data:`VERIFY_X509_PARTIAL_CHAIN` and "
":data:`VERIFY_X509_STRICT` in its default verify flags."
msgstr ""

#: ../../library/ssl.rst:219
msgid "Exceptions"
msgstr "예외"

#: ../../library/ssl.rst:223
msgid ""
"Raised to signal an error from the underlying SSL implementation "
"(currently provided by the OpenSSL library).  This signifies some problem"
" in the higher-level encryption and authentication layer that's "
"superimposed on the underlying network connection.  This error is a "
"subtype of :exc:`OSError`.  The error code and message of :exc:`SSLError`"
" instances are provided by the OpenSSL library."
msgstr ""
"하부 SSL 구현(현재 OpenSSL 라이브러리에서 제공)으로부터의 에러를 알리기 위해 발생합니다. 이는 하부 네트워크 연결에 "
"겹쳐진 상위 수준의 암호화와 인증 계층에서 문제가 있음을 나타냅니다. 이 에러는 :exc:`OSError`\\의 서브 형입니다. "
":exc:`SSLError` 인스턴스의 에러 코드와 메시지는 OpenSSL 라이브러리에 의해 제공됩니다."

#: ../../library/ssl.rst:230
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError`\\는 :exc:`socket.error`\\의 서브 형이었습니다."

#: ../../library/ssl.rst:235
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"``SSL``, ``PEM`` 또는 ``X509``\\와 같이, 에러가 발생한 OpenSSL 하위 모듈을 지정하는 문자열 "
"기호입니다. 가능한 값의 범위는 OpenSSL 버전에 따라 다릅니다."

#: ../../library/ssl.rst:243
msgid ""
"A string mnemonic designating the reason this error occurred, for example"
" ``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on "
"the OpenSSL version."
msgstr ""
"이 에러가 발생한 이유를 나타내는 문자열 기호, 예를 들어, ``CERTIFICATE_VERIFY_FAILED``. 가능한 값의 "
"범위는 OpenSSL 버전에 따라 다릅니다."

#: ../../library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the"
" SSL connection has been closed cleanly.  Note that this doesn't mean "
"that the underlying transport (read TCP) has been closed."
msgstr ""
"읽기나 쓰기를 시도하고 SSL 연결이 정상적으로 닫혔을 때 발생하는 :exc:`SSLError`\\의 서브 클래스. 이것이 하부 "
"트랜스포트(TCP 읽기)가 닫혔음을 뜻하지는 않습니다."

#: ../../library/ssl.rst:259
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs"
" to be received on the underlying TCP transport before the request can be"
" fulfilled."
msgstr ""
"데이터를 읽거나 쓰려고 하지만, 요청을 만족하려면 하부 TCP 트랜스포트에서 데이터를 더 수신해야 할 때, :ref:`비 블로킹 "
"SSL 소켓 <ssl-nonblocking>`\\에 의해 발생하는 :exc:`SSLError`\\의 서브 클래스."

#: ../../library/ssl.rst:268
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket "
"<ssl-nonblocking>` when trying to read or write data, but more data needs"
" to be sent on the underlying TCP transport before the request can be "
"fulfilled."
msgstr ""
"데이터를 읽거나 쓰려고 하지만, 요청을 만족하려면 하부 TCP 트랜스포트로 데이터를 더 보내야 할 때, :ref:`비 블로킹 SSL"
" 소켓 <ssl-nonblocking>`\\에 의해 발생하는 :exc:`SSLError`\\의 서브 클래스."

#: ../../library/ssl.rst:277
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, "
"there is no easy way to inspect the original errno number."
msgstr ""
"SSL 소켓에서 작업을 수행하는 동안 시스템 에러를 만났을 때 발생하는 :exc:`SSLError`\\의 서브 클래스. 불행히도 "
"원래의 errno 번호를 검사하는 쉬운 방법은 없습니다."

#: ../../library/ssl.rst:285
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the "
"underlying transport when this error is encountered."
msgstr ""
"SSL 연결이 갑자기 종료되었을 때 발생하는 :exc:`SSLError`\\의 서브 클래스. 일반적으로, 이 에러가 발생하면 하부 "
"트랜스포트를 다시 사용하지 않아야 합니다."

#: ../../library/ssl.rst:293
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has "
"failed."
msgstr "인증서 유효성 검사가 실패했을 때 발생하는 :exc:`SSLError`\\의 서브 클래스."

#: ../../library/ssl.rst:300
msgid "A numeric error number that denotes the verification error."
msgstr "유효성 검사 에러를 나타내는 숫자 에러 번호."

#: ../../library/ssl.rst:304
msgid "A human readable string of the verification error."
msgstr "사람이 읽을 수 있는 유효성 검사 에러 문자열."

#: ../../library/ssl.rst:308
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr ":exc:`SSLCertVerificationError`\\의 별칭."

#: ../../library/ssl.rst:310
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "예외는 이제 :exc:`SSLCertVerificationError`\\의 별칭입니다."

#: ../../library/ssl.rst:315
msgid "Random generation"
msgstr "난수 생성"

#: ../../library/ssl.rst:319
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an "
":class:`SSLError` if the PRNG has not been seeded with enough data or if "
"the operation is not supported by the current RAND method. "
":func:`RAND_status` can be used to check the status of the PRNG and "
":func:`RAND_add` can be used to seed the PRNG."
msgstr ""
"길이 *num*\\의 암호학적으로 강한 의사 난수 바이트열을 반환합니다. PRNG에 충분한 데이터가 시드(seed) 되지 않았거나 "
"현재 RAND 메서드에서 지원되지 않는 연산이면 :class:`SSLError`\\를 발생시킵니다. "
":func:`RAND_status`\\를 PRNG의 상태를 확인하는 데 사용할 수 있으며 :func:`RAND_add`\\는 "
"PRNG를 시드 하는 데 사용할 수 있습니다."

#: ../../library/ssl.rst:325
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "거의 모든 응용 프로그램에서 :func:`os.urandom`\\을 선호합니다."

#: ../../library/ssl.rst:327
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number"
" generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_,"
" to get the requirements of a cryptographically strong generator."
msgstr ""
"암호학적으로 강한 생성기의 요구 사항을 얻으려면 위키피디아 기사 `Cryptographically secure "
"pseudorandom number generator (CSPRNG) "
"<https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>`_\\를"
" 읽으십시오."

#: ../../library/ssl.rst:336
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded"
" with 'enough' randomness, and ``False`` otherwise.  You can use "
":func:`ssl.RAND_egd` and :func:`ssl.RAND_add` to increase the randomness "
"of the pseudo-random number generator."
msgstr ""
"SSL 의사 난수 생성기에 '충분한' 임의성이 시드 되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 "
"반환합니다. :func:`ssl.RAND_egd`\\와 :func:`ssl.RAND_add`\\를 사용하여 의사 난수 생성기의 "
"임의성을 높일 수 있습니다."

#: ../../library/ssl.rst:343
#, fuzzy
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained "
"in string (so you can always use ``0.0``).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"주어진 *bytes*\\를 SSL 의사 난수 생성기에 섞습니다. 매개 변수 *entropy*\\(float)는 문자열에 포함된 "
"엔트로피의 하한값이므로 항상 :const:`0.0`\\을 사용할 수 있습니다. 엔트로피 소스에 대한 추가 정보는 "
":rfc:`1750`\\을 참조하십시오."

#: ../../library/ssl.rst:348
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "이제 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>`\\를 받아들입니다."

#: ../../library/ssl.rst:352
msgid "Certificate handling"
msgstr "인증서 처리"

#: ../../library/ssl.rst:360
#, python-format
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` "
"string representing the \"notBefore\" or \"notAfter\" date from a "
"certificate in ``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"인증서의 \"notBefore\" 나 \"notAfter\" 날짜를 나타내는 ``\"%b %d %H:%M:%S %Y %Z\"`` "
"strptime 형식(C 로케일)의 ``cert_time`` 문자열이 지정하는 시간을 Epoch 이후 초 단위로 반환합니다."

#: ../../library/ssl.rst:365
msgid "Here's an example:"
msgstr "여기 예제가 있습니다:"

#: ../../library/ssl.rst:367
msgid ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"
msgstr ""

#: ../../library/ssl.rst:377
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "\"notBefore\" 나 \"notAfter\" 날짜는 GMT(:rfc:`5280`)를 사용해야 합니다."

#: ../../library/ssl.rst:379
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone "
"in the input string. Local timezone was used previously. Return an "
"integer (no fractions of a second in the input format)"
msgstr ""
"입력된 시간을 입력 문자열의 'GMT' 시간대로 지정된 UTC 시간으로 해석합니다. 이전에는 지역 시간대가 사용되었습니다. 정수를 "
"반환합니다 (입력 형식에는 부분 초가 없습니다)."

#: ../../library/ssl.rst:388
#, fuzzy
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as "
"a PEM-encoded string.  If ``ssl_version`` is specified, uses that version"
" of the SSL protocol to attempt to connect to the server.  If *ca_certs* "
"is specified, it should be a file containing a list of root certificates,"
" the same format as used for the *cafile* parameter in "
":meth:`SSLContext.load_verify_locations`.  The call will attempt to "
"validate the server certificate against that set of root certificates, "
"and will fail if the validation attempt fails.  A timeout can be "
"specified with the ``timeout`` parameter."
msgstr ""
"주어진 SSL로 보호된 서버의 주소 ``addr``\\((*hostname*, *port-number*) 쌍)에 대해, 서버 "
"인증서를 가져와서 PEM-인코딩된 문자열로 반환합니다. ``ssl_version``\\이 지정되면, 해당 버전의 SSL 프로토콜을 "
"사용하여 서버에 연결을 시도합니다. ``ca_certs``\\가 지정되면, 루트 인증서 목록을 포함하는 파일이어야 하는데, "
":meth:`SSLContext.wrap_socket`\\에서 같은 매개 변수에 사용된 것과 같은 형식입니다. 호출은 해당 루트 "
"인증서 집합에 대해 서버 인증서의 유효성을 검사하려고 시도하며, 유효성 검사 시도가 실패하면 실패합니다."

#: ../../library/ssl.rst:399
msgid "This function is now IPv6-compatible."
msgstr "이 함수는 이제 IPv6와 호환됩니다."

#: ../../library/ssl.rst:402
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to "
":data:`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"최신 서버와의 호환성을 최대화하기 위해 기본 *ssl_version*\\이 :data:`PROTOCOL_SSLv3`\\에서 "
":data:`PROTOCOL_TLS`\\로 변경되었습니다."

#: ../../library/ssl.rst:406
#, fuzzy
msgid "The *timeout* parameter was added."
msgstr "*session* 인자가 추가되었습니다."

#: ../../library/ssl.rst:411
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded"
" string version of the same certificate."
msgstr "인증서가 DER-인코딩된 바이트열로 주어지면, 같은 인증서의 PEM-인코딩된 문자열 버전을 반환합니다."

#: ../../library/ssl.rst:416
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded "
"sequence of bytes for that same certificate."
msgstr "인증서가 ASCII PEM 문자열로 주어지면, 같은 인증서의 DER-인코딩된 바이트열 시퀀스를 반환합니다."

#: ../../library/ssl.rst:421
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. "
"The paths are the same as used by "
":meth:`SSLContext.set_default_verify_paths`. The return value is a "
":term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"OpenSSL의 기본 cafile 및 capath에 대한 경로가 있는 네임드 튜플을 반환합니다. 경로는 "
":meth:`SSLContext.set_default_verify_paths`\\에서 사용하는 경로와 같습니다. 반환 값은 "
":term:`네임드 튜플 <named tuple>` ``DefaultVerifyPaths``\\입니다.:"

#: ../../library/ssl.rst:426
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - cafile에 대한 확인된 경로나 파일이 존재하지 않으면 ``None``,"

#: ../../library/ssl.rst:427
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - capath에 대한 확인된 경로나 디렉터리가 존재하지 않으면 ``None``,"

#: ../../library/ssl.rst:428
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - cafile을 가리키는 OpenSSL의 환경 키,"

#: ../../library/ssl.rst:429
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - cafile에 대한 하드 코딩된 경로,"

#: ../../library/ssl.rst:430
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - capath를 가리키는 OpenSSL의 환경 키,"

#: ../../library/ssl.rst:431
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - capath 디렉터리에 대한 하드 코딩된 경로"

#: ../../library/ssl.rst:437
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may "
"be one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert"
" stores, too."
msgstr ""
"윈도우의 시스템 인증서 저장소에서 인증서를 꺼냅니다. *store_name*\\은 ``CA``, ``ROOT`` 또는 ``MY`` "
"중 하나일 수 있습니다. 윈도우가 추가 인증서 저장소를 제공 할 수도 있습니다."

#: ../../library/ssl.rst:441
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples."
" The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data. Trust specifies the purpose of the certificate as a set of "
"OIDS or exactly ``True`` if the certificate is trustworthy for all "
"purposes."
msgstr ""
"이 함수는 (cert_bytes, encoding_type, trust) 튜플의 리스트를 반환합니다. encoding_type은 "
"cert_bytes의 인코딩을 지정합니다. X.509 ASN.1 데이터를 위한 :const:`x509_asn`\\이거나 PKCS#7"
" ASN.1 데이터를 위한 :const:`pkcs_7_asn`\\입니다. Trust는 인증서의 목적을 OIDS 집합으로 지정하거나,"
" 인증서가 모든 목적에 대해 신뢰할 수 있으면 정확히 ``True``\\입니다."

#: ../../library/ssl.rst:448 ../../library/ssl.rst:1599
#: ../../library/ssl.rst:1898
msgid "Example::"
msgstr "예제::"

#: ../../library/ssl.rst:450
#, python-brace-format
msgid ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'data...', 'x509_asn', True)]"
msgstr ""

#: ../../library/ssl.rst:460
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of"
" ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, "
"too."
msgstr ""
"윈도우의 시스템 인증서 저장소에서 CRL을 꺼냅니다. *store_name*\\는 ``CA``, ``ROOT`` 또는 ``MY`` "
"중 하나일 수 있습니다. 윈도우가 추가 인증서 저장소를 제공 할 수도 있습니다."

#: ../../library/ssl.rst:464
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples."
" The encoding_type specifies the encoding of cert_bytes. It is either "
":const:`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 "
"ASN.1 data."
msgstr ""
"이 함수는 (cert_bytes, encoding_type, trust) 튜플의 리스트를 반환합니다. encoding_type은 "
"cert_bytes의 인코딩을 지정합니다. X.509 ASN.1 데이터를 위한 :const:`x509_asn`\\이거나 PKCS#7"
" ASN.1 데이터를 위한 :const:`pkcs_7_asn`\\입니다."

#: ../../library/ssl.rst:475
msgid "Constants"
msgstr "상수"

#: ../../library/ssl.rst:477
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr "모든 상수는 이제 :class:`enum.IntEnum` 이나 :class:`enum.IntFlag` 컬렉션입니다."

#: ../../library/ssl.rst:483
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. Except for "
":const:`PROTOCOL_TLS_CLIENT`, it is the default mode.  With client-side "
"sockets, just about any cert is accepted.  Validation errors, such as "
"untrusted or expired cert, are ignored and do not abort the TLS/SSL "
"handshake."
msgstr ""
":attr:`SSLContext.verify_mode`\\나 :func:`wrap_socket`\\의 ``cert_reqs`` 매개"
" 변수의 가능한 값. :const:`PROTOCOL_TLS_CLIENT`\\를 제외하고는, 기본 모드입니다. 클라이언트 측 "
"소켓에서는, 모든 인증서가 허용됩니다. 신뢰할 수 없거나 만료된 인증서와 같은 유효성 검사 에러는 무시되며 TLS/SSL 핸드 "
"셰이크를 중단하지 않습니다."

#: ../../library/ssl.rst:489
msgid ""
"In server mode, no certificate is requested from the client, so the "
"client does not send any for client cert authentication."
msgstr "서버 모드에서는, 클라이언트에서 인증서를 요청하지 않으므로 클라이언트는 클라이언트 인증서 인증을 위해 인증서를 보내지 않습니다."

#: ../../library/ssl.rst:492 ../../library/ssl.rst:2400
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "아래의 :ref:`ssl-security`\\의 논의를 참조하십시오."

#: ../../library/ssl.rst:496
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In client mode, "
":const:`CERT_OPTIONAL` has the same meaning as :const:`CERT_REQUIRED`. It"
" is recommended to use :const:`CERT_REQUIRED` for client-side sockets "
"instead."
msgstr ""
":attr:`SSLContext.verify_mode`\\나 :func:`wrap_socket`\\의 ``cert_reqs`` 매개"
" 변수의 가능한 값. 클라이언트 모드에서, :const:`CERT_OPTIONAL`\\는 "
":const:`CERT_REQUIRED`\\와 같은 의미입니다. 클라이언트 측 소켓에서는 대신 "
":const:`CERT_REQUIRED`\\를 사용하는 것이 좋습니다."

#: ../../library/ssl.rst:501
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order "
"perform TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts "
"the TLS handshake."
msgstr ""
"서버 모드에서는, 클라이언트 인증서 요청이 클라이언트로 전송됩니다. 클라이언트는 요청을 무시하거나 TLS 클라이언트 인증서 인증을 "
"수행하기 위해 인증서를 보낼 수 있습니다. 클라이언트가 인증서를 보내기로 선택하면, 인증서가 유효성 검사됩니다. 모든 유효성 검사 "
"에러는, TLS 핸드 셰이크를 즉시 중단합니다."

#: ../../library/ssl.rst:507 ../../library/ssl.rst:526
#, fuzzy
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed "
"to :meth:`SSLContext.load_verify_locations`."
msgstr ""
"이 설정을 사용하려면 유효한 CA 인증서 집합을 :meth:`SSLContext.load_verify_locations` 나 "
":func:`wrap_socket`\\의 ``ca_certs`` 매개 변숫값으로 전달해야 합니다."

#: ../../library/ssl.rst:512
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In this mode, "
"certificates are required from the other side of the socket connection; "
"an :class:`SSLError` will be raised if no certificate is provided, or if "
"its validation fails. This mode is **not** sufficient to verify a "
"certificate in client mode as it does not match hostnames.  "
":attr:`~SSLContext.check_hostname` must be enabled as well to verify the "
"authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses "
":const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
":attr:`SSLContext.verify_mode`\\나 :func:`wrap_socket`\\의 ``cert_reqs`` 매개"
" 변수의 가능한 값. 이 모드에서는, 소켓 연결의 다른 쪽에서 인증서를 요구합니다; 인증서가 제공되지 않거나 유효성 검사에 실패하면"
" :class:`SSLError`\\가 발생합니다. 이 모드는 호스트 이름 일치를 수행하지 않기 때문에 클라이언트 모드에서 인증서를"
" 유효성 검사하기에 충분하지 **않습니다**. 인증서의 진위를 검사하기 위해 "
":attr:`~SSLContext.check_hostname`\\도 활성화해야 합니다. "
":const:`PROTOCOL_TLS_CLIENT`\\는 기본적으로 :const:`CERT_REQUIRED`\\를 사용하고 "
":attr:`~SSLContext.check_hostname`\\을 활성화합니다."

#: ../../library/ssl.rst:522
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and "
"the client must provide a valid and trusted certificate."
msgstr ""
"서버 소켓에서, 이 모드는 필수 TLS 클라이언트 인증서 인증을 제공합니다. 클라이언트 인증서 요청이 클라이언트에 보내지고 "
"클라이언트는 유효하고 신뢰할 수 있는 인증서를 제공해야 합니다."

#: ../../library/ssl.rst:531
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "CERT_* 상수의 :class:`enum.IntEnum` 컬렉션."

#: ../../library/ssl.rst:537
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL "
"does neither require nor verify CRLs."
msgstr ""
":attr:`SSLContext.verify_flags`\\의 가능한 값. 이 모드에서는 인증서 해지 목록(CRL)을 검사하지 "
"않습니다. 기본적으로 OpenSSL은 CRL을 요구하지도 검사하지도 않습니다."

#: ../../library/ssl.rst:545
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only "
"the peer cert is checked but none of the intermediate CA certificates. "
"The mode requires a valid CRL that is signed by the peer cert's issuer "
"(its direct ancestor CA). If no proper CRL has been loaded with "
":attr:`SSLContext.load_verify_locations`, validation will fail."
msgstr ""
":attr:`SSLContext.verify_flags`\\의 가능한 값. 이 모드에서는, 피어 인증서만 확인할 뿐 중간 CA "
"인증서는 확인하지 않습니다. 이 모드는 피어 인증서의 발급자(그것의 직계 조상 CA)가 서명한 유효한 CRL을 요구합니다. 적절한 "
"CRL이 :attr:`SSLContext.load_verify_locations`\\로 로드되지 않았으면 유효성 검사가 실패합니다."

#: ../../library/ssl.rst:555
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of"
" all certificates in the peer cert chain are checked."
msgstr ""
":attr:`SSLContext.verify_flags`\\의 가능한 값. 이 모드에서는, 피어 인증서 체인의 모든 인증서에 대한 "
"CRL이 확인됩니다."

#: ../../library/ssl.rst:562
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds"
" for broken X.509 certificates."
msgstr ""
"망가진 X.509 인증서에 대한 우회를 사용하지 못하도록 하는 :attr:`SSLContext.verify_flags`\\의 가능한"
" 값."

#: ../../library/ssl.rst:569
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"망가진 X.509 인증서에 대한 우회를 사용하지 못하도록 하는 :attr:`SSLContext.verify_flags`\\의 가능한"
" 값."

#: ../../library/ssl.rst:576
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL "
"to prefer trusted certificates when building the trust chain to validate "
"a certificate. This flag is enabled by default."
msgstr ""
":attr:`SSLContext.verify_flags`\\의 가능한 값. OpenSSL이 인증서의 유효성을 검사하기 위해 트러스트"
" 체인을 구축할 때 신뢰할 수 있는 인증서를 선호하도록 지시합니다. 이 플래그는 기본적으로 활성화됩니다."

#: ../../library/ssl.rst:584
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL "
"to accept intermediate CAs in the trust store to be treated as trust-"
"anchors, in the same way as the self-signed root CA certificates. This "
"makes it possible to trust certificates issued by an intermediate CA "
"without having to trust its ancestor root CA."
msgstr ""

#: ../../library/ssl.rst:595
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "VERIFY_* 상수의 :class:`enum.IntFlag` 컬렉션."

#: ../../library/ssl.rst:601
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and "
"\"TLS\" protocols."
msgstr ""
"클라이언트와 서버가 모두 지원하는 가장 높은 프로토콜 버전을 선택합니다. 이름에도 불구하고, 이 옵션은 \"SSL\" 과 "
"\"TLS\" 프로토콜을 모두 선택할 수 있습니다."

#: ../../library/ssl.rst:608
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor "
"of :data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../../library/ssl.rst:614
#, fuzzy
msgid ""
"Auto-negotiate the highest protocol version that both the client and "
"server support, and configure the context client-side connections. The "
"protocol enables :data:`CERT_REQUIRED` and "
":attr:`~SSLContext.check_hostname` by default."
msgstr ""
":data:`PROTOCOL_TLS`\\처럼 가장 높은 프로토콜 버전을 자동 협상하지만, 클라이언트 측 "
":class:`SSLSocket` 연결만 지원합니다. 이 프로토콜은 기본적으로 :data:`CERT_REQUIRED`\\와 "
":attr:`~SSLContext.check_hostname`\\을 활성화합니다."

#: ../../library/ssl.rst:623
#, fuzzy
msgid ""
"Auto-negotiate the highest protocol version that both the client and "
"server support, and configure the context server-side connections."
msgstr ""
"클라이언트와 서버가 모두 지원하는 가장 높은 프로토콜 버전을 선택합니다. 이름에도 불구하고, 이 옵션은 \"SSL\" 과 "
"\"TLS\" 프로토콜을 모두 선택할 수 있습니다."

#: ../../library/ssl.rst:630
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr ":data:`PROTOCOL_TLS`\\의 별칭."

#: ../../library/ssl.rst:634
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "대신 :data:`PROTOCOL_TLS`\\를 사용하십시오."

#: ../../library/ssl.rst:638
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "채널 암호화 프로토콜로 SSL 버전 3을 선택합니다."

#: ../../library/ssl.rst:640
#, fuzzy
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-"
"ssl3`` option."
msgstr "OpenSSL이 ``OPENSSL_NO_SSL2`` 플래그로 컴파일되었으면 이 프로토콜을 사용할 수 없습니다."

#: ../../library/ssl.rst:645
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL 버전 3은 안전하지 않습니다. 사용하지 말도록 강력히 권고합니다."

#: ../../library/ssl.rst:649
#, fuzzy
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version`"
" instead."
msgstr ""
"OpenSSL은 모든 버전 특정 프로토콜을 폐지했습니다. 대신 :data:`OP_NO_SSLv3`\\와 같은 플래그와 함께 기본 "
"프로토콜 :data:`PROTOCOL_TLS`\\를 사용하십시오."

#: ../../library/ssl.rst:657
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "채널 암호화 프로토콜로 TLS 버전 1.0을 선택합니다."

#: ../../library/ssl.rst:661 ../../library/ssl.rst:672
#: ../../library/ssl.rst:683
msgid "OpenSSL has deprecated all version specific protocols."
msgstr ""

#: ../../library/ssl.rst:665
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available "
"only with openssl version 1.0.1+."
msgstr "채널 암호화 프로토콜로 TLS 버전 1.1을 선택합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:676
#, fuzzy
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available "
"only with openssl version 1.0.1+."
msgstr "채널 암호화 프로토콜로 TLS 버전 1.1을 선택합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:687
msgid ""
"Enables workarounds for various bugs present in other SSL "
"implementations. This option is set by default.  It does not necessarily "
"set the same flags as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"다른 SSL 구현에 있는 다양한 버그에 대한 해결 방법을 활성화합니다. 이 옵션은 기본적으로 설정됩니다. 반드시 OpenSSL의 "
"``SSL_OP_ALL`` 상수와 같은 플래그를 설정할 필요는 없습니다."

#: ../../library/ssl.rst:695
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in "
"conjunction with :const:`PROTOCOL_TLS`.  It prevents the peers from "
"choosing SSLv2 as the protocol version."
msgstr ""
"SSLv2 연결을 방지합니다. 이 옵션은 :const:`PROTOCOL_TLS`\\와 결합해서만 적용할 수 있습니다. 피어가 "
"SSLv2를 프로토콜 버전으로 선택하지 못하도록 합니다."

#: ../../library/ssl.rst:703
msgid "SSLv2 is deprecated"
msgstr "SSLv2는 폐지되었습니다."

#: ../../library/ssl.rst:707
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in "
"conjunction with :const:`PROTOCOL_TLS`.  It prevents the peers from "
"choosing SSLv3 as the protocol version."
msgstr ""
"SSLv3 연결을 방지합니다. 이 옵션은 :const:`PROTOCOL_TLS`\\와 결합해서만 적용할 수 있습니다. 피어가 "
"프로토콜 버전으로 SSLv3을 선택하지 못하게 합니다."

#: ../../library/ssl.rst:715
msgid "SSLv3 is deprecated"
msgstr "SSLv3은 폐지되었습니다."

#: ../../library/ssl.rst:719
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in "
"conjunction with :const:`PROTOCOL_TLS`.  It prevents the peers from "
"choosing TLSv1 as the protocol version."
msgstr ""
"TLSv1 연결을 금지합니다. 이 옵션은 :const:`PROTOCOL_TLS`\\와 결합해서만 적용할 수 있습니다. 피어가 "
"TLSv1을 프로토콜 버전으로 선택하지 못하게 합니다."

#: ../../library/ssl.rst:725
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new "
":attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version`"
" instead."
msgstr ""
"이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다, 새로운 :attr:`SSLContext.minimum_version`\\과 "
":attr:`SSLContext.maximum_version`\\을 대신 사용하십시오."

#: ../../library/ssl.rst:732
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in "
"conjunction with :const:`PROTOCOL_TLS`. It prevents the peers from "
"choosing TLSv1.1 as the protocol version. Available only with openssl "
"version 1.0.1+."
msgstr ""
"TLSv1.1 연결을 금지합니다. 이 옵션은 :const:`PROTOCOL_TLS`\\와 결합해서만 적용할 수 있습니다. 피어가 "
"TLSv1.1을 프로토콜 버전으로 선택하지 못하게 합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:738 ../../library/ssl.rst:749
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다."

#: ../../library/ssl.rst:743
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in "
"conjunction with :const:`PROTOCOL_TLS`. It prevents the peers from "
"choosing TLSv1.2 as the protocol version. Available only with openssl "
"version 1.0.1+."
msgstr ""
"TLSv1.2 연결을 방지합니다. 이 옵션은 :const:`PROTOCOL_TLS`\\와 결합해서만 적용할 수 있습니다. 피어가 "
"프로토콜 버전으로 TLSv1.2를 선택하지 못하게 합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:754
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in "
"conjunction with :const:`PROTOCOL_TLS`. It prevents the peers from "
"choosing TLSv1.3 as the protocol version. TLS 1.3 is available with "
"OpenSSL 1.1.1 or later. When Python has been compiled against an older "
"version of OpenSSL, the flag defaults to *0*."
msgstr ""
"TLSv1.3 연결을 방지합니다. 이 옵션은 :const:`PROTOCOL_TLS`\\와 결합해서만 적용할 수 있습니다. 피어가 "
"프로토콜 버전으로 TLSv1.3을 선택하지 못하게 합니다. TLS 1.3은 OpenSSL 1.1.1 이상에서 사용할 수 있습니다. "
"파이썬이 OpenSSL의 이전 버전에 대해 컴파일되면, 플래그의 기본값은 *0*\\입니다."

#: ../../library/ssl.rst:762
#, fuzzy
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and "
"3.6.3 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다. OpenSSL 1.0.2와의 하위 호환성을 위해 2.7.15, 3.6.3 및"
" 3.7.0에 추가되었습니다."

#: ../../library/ssl.rst:768
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send "
"HelloRequest messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"TLSv1.2와 그 이전 버전에서 모든 재협상을 비활성화합니다. HelloRequest 메시지를 보내지 않고, "
"ClientHello를 통한 재협상 요청을 무시합니다."

#: ../../library/ssl.rst:771
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "이 옵션은 OpenSSL 1.1.0h 이상에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:777
msgid ""
"Use the server's cipher ordering preference, rather than the client's. "
"This option has no effect on client sockets and SSLv2 server sockets."
msgstr "클라이언트보다는 서버의 사이퍼 순서 선호를 사용합니다. 이 옵션은 클라이언트 소켓과 SSLv2 서버 소켓에는 영향을 미치지 않습니다."

#: ../../library/ssl.rst:784
#, fuzzy
msgid ""
"Prevents reuse of the same DH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"서로 다른 SSL 세션에 대해 같은 DH 키 재사용을 방지합니다. 이렇게 하면 FS(forward secrecy)는 향상되지만, 더"
" 많은 계산 자원을 요구합니다. 이 옵션은 서버 소켓에만 적용됩니다."

#: ../../library/ssl.rst:792
#, fuzzy
msgid ""
"Prevents reuse of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"서로 다른 SSL 세션에 대해 같은 ECDH 키 재사용을 방지합니다. 이렇게 하면 FS(forward secrecy)는 향상되지만,"
" 더 많은 계산 자원을 요구합니다. 이 옵션은 서버 소켓에만 적용됩니다."

#: ../../library/ssl.rst:800
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make"
" a TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"TLS 1.3 연결을 더 TLS 1.2 연결처럼 보이게 하려고 TLS 1.3 핸드 셰이크에서 더미 암호 변경 사양(CCS - "
"Change Cipher Spec) 메시지를 보냅니다."

#: ../../library/ssl.rst:803
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "이 옵션은 OpenSSL 1.1.1 이상에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:809
msgid ""
"Disable compression on the SSL channel.  This is useful if the "
"application protocol supports its own compression scheme."
msgstr "SSL 채널에서 압축을 사용하지 않습니다. 응용 프로그램 프로토콜이 자체 압축 방법을 지원할 때 유용합니다."

#: ../../library/ssl.rst:816
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr "OP_* 상수의 :class:`enum.IntFlag` 컬렉션."

#: ../../library/ssl.rst:820
msgid "Prevent client side from requesting a session ticket."
msgstr "클라이언트 측에서 세션 티켓을 요청하지 못하게 합니다."

#: ../../library/ssl.rst:826
msgid "Ignore unexpected shutdown of TLS connections."
msgstr ""

#: ../../library/ssl.rst:828 ../../library/ssl.rst:844
#, fuzzy
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "이 옵션은 OpenSSL 1.0.0 이상에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:834
msgid ""
"Enable the use of the kernel TLS. To benefit from the feature, OpenSSL "
"must have been compiled with support for it, and the negotiated cipher "
"suites and extensions must be supported by it (a list of supported ones "
"may vary by platform and kernel version)."
msgstr ""

#: ../../library/ssl.rst:839
msgid ""
"Note that with enabled kernel TLS some cryptographic operations are "
"performed by the kernel directly and not via any available OpenSSL "
"Providers. This might be undesirable if, for example, the application "
"requires all cryptographic operations to be performed by the FIPS "
"provider."
msgstr ""

#: ../../library/ssl.rst:850
msgid ""
"Allow legacy insecure renegotiation between OpenSSL and unpatched servers"
" only."
msgstr ""

#: ../../library/ssl.rst:857
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-"
"Layer Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"OpenSSL 라이브러리가 :rfc:`7301`\\에서 설명한 대로 *응용 계층 프로토콜 협상(Application-Layer "
"Protocol Negotiation)* TLS 확장에 대한 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:864
msgid ""
"Whether the OpenSSL library has built-in support not checking subject "
"common name and :attr:`SSLContext.hostname_checks_common_name` is "
"writeable."
msgstr ""
"OpenSSL 라이브러리가 SCN(subject common name)을 검사하지 않는 지원을 기본 제공하고 "
":attr:`SSLContext.hostname_checks_common_name`\\가 쓰기 가능한지 아닌지."

#: ../../library/ssl.rst:872
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the "
"feature was explicitly disabled by the distributor."
msgstr ""
"OpenSSL 라이브러리가 타원 곡선(Elliptic Curve) 기반 Diffie-Hellman 키 교환 지원을 기본 제공하는지 "
"여부. 기능이 배포자에 의해 명시적으로 비활성화되어 있지 않은 한, 참이어야 합니다."

#: ../../library/ssl.rst:880
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"OpenSSL 라이브러리가 *서버 이름 표시(Server Name Indication)* 확장(:rfc:`6066`\\에 정의된 "
"대로)에 대한 지원을 기본 제공하는지 여부."

#: ../../library/ssl.rst:887
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_."
" When true, you can use the :meth:`SSLContext.set_npn_protocols` method "
"to advertise which protocols you want to support."
msgstr ""
"OpenSSL 라이브러리가 `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_\\에 설명된 대로 *NPN(Next Protocol "
"Negotiation)*\\에 대한 지원을 기본 제공하는지 여부. 참이면 "
":meth:`SSLContext.set_npn_protocols` 메서드를 사용하여 지원할 프로토콜을 알릴 수 있습니다."

#: ../../library/ssl.rst:897
msgid "Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "OpenSSL 라이브러리가 SSL 2.0 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:903
msgid "Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "OpenSSL 라이브러리가 SSL 3.0 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:909
msgid "Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "OpenSSL 라이브러리가 TLS 1.0 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:915
msgid "Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "OpenSSL 라이브러리가 TLS 1.1 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:921
msgid "Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "OpenSSL 라이브러리가 TLS 1.2 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:927
msgid "Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "OpenSSL 라이브러리가 TLS 1.3 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:933
#, fuzzy
msgid "Whether the OpenSSL library has built-in support for TLS-PSK."
msgstr "OpenSSL 라이브러리가 TLS 1.3 프로토콜 지원을 기본 제공하는지 여부"

#: ../../library/ssl.rst:939
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be"
" used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"지원되는 TLS 채널 바인딩 유형의 리스트. 이 리스트의 문자열은 "
":meth:`SSLSocket.get_channel_binding`\\에 대한 인자로 사용될 수 있습니다."

#: ../../library/ssl.rst:946
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "인터프리터에 의해 로드된 OpenSSL 라이브러리의 버전 문자열::"

#: ../../library/ssl.rst:948
msgid ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"
msgstr ""

#: ../../library/ssl.rst:955
msgid ""
"A tuple of five integers representing version information about the "
"OpenSSL library::"
msgstr "OpenSSL 라이브러리에 대한 버전 정보를 나타내는 5개의 정수 튜플::"

#: ../../library/ssl.rst:958
msgid ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"
msgstr ""

#: ../../library/ssl.rst:965
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "단일 정수로 표현되는, OpenSSL 라이브러리의 원시 버전 번호::"

#: ../../library/ssl.rst:967
msgid ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"
msgstr ""

#: ../../library/ssl.rst:978
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert "
"Registry <https://www.iana.org/assignments/tls-parameters/tls-"
"parameters.xml#tls-parameters-6>`_ contains this list and references to "
"the RFCs where their meaning is defined."
msgstr ""
":rfc:`5246` 및 기타의 경고 설명. `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_\\에는 이 목록과 그 의미가 정의된 RFC에 대한 참조가 들어 있습니다."

#: ../../library/ssl.rst:982
msgid ""
"Used as the return value of the callback function in "
":meth:`SSLContext.set_servername_callback`."
msgstr ":meth:`SSLContext.set_servername_callback`\\에서 콜백 함수의 반환 값으로 사용됩니다."

#: ../../library/ssl.rst:989
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr "ALERT_DESCRIPTION_* 상수의 :class:`enum.IntEnum` 컬렉션."

#: ../../library/ssl.rst:995
#, fuzzy
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate web servers (therefore, it will be "
"used to create client-side sockets)."
msgstr ""
":func:`create_default_context`\\와 :meth:`SSLContext.load_default_certs` "
"옵션. 이 값은 컨텍스트가 웹 서버를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 클라이언트 측 소켓을 만드는 데 "
"사용됩니다)."

#: ../../library/ssl.rst:1004
#, fuzzy
msgid ""
"Option for :func:`create_default_context` and "
":meth:`SSLContext.load_default_certs`.  This value indicates that the "
"context may be used to authenticate web clients (therefore, it will be "
"used to create server-side sockets)."
msgstr ""
":func:`create_default_context` 와 :meth:`SSLContext.load_default_certs` "
"옵션. 이 값은 컨텍스트가 웹 클라이언트를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 서버 측 소켓을 만드는 데 "
"사용됩니다)."

#: ../../library/ssl.rst:1013
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr "SSL_ERROR_* 상수의 :class:`enum.IntEnum` 컬렉션."

#: ../../library/ssl.rst:1019
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for "
":attr:`SSLContext.maximum_version` and "
":attr:`SSLContext.minimum_version`."
msgstr ""
":attr:`SSLContext.maximum_version`\\과 :attr:`SSLContext.minimum_version` "
"용 SSL과 TLS 버전의 :class:`enum.IntEnum` 컬렉션."

#: ../../library/ssl.rst:1027
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available "
"TLS/SSL versions."
msgstr ""
"지원되는 SSL 또는 TLS 버전의 최소 또는 최대. 이것들은 마법 상수(magic constant)입니다. 이들의 값은 사용 "
"가능한 가장 낮거나 높은 TLS/SSL 버전을 반영하지 않습니다."

#: ../../library/ssl.rst:1037
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 에서 TLS 1.3."

#: ../../library/ssl.rst:1041
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and "
":attr:`TLSVersion.TLSv1_3` are deprecated."
msgstr ""

#: ../../library/ssl.rst:1046
msgid "SSL Sockets"
msgstr "SSL 소켓"

#: ../../library/ssl.rst:1050
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL 소켓은 다음과 같은 :ref:`socket-objects` 메서드를 제공합니다:"

#: ../../library/ssl.rst:1052
#, fuzzy
msgid ":meth:`~socket.socket.accept`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:1053
#, fuzzy
msgid ":meth:`~socket.socket.bind`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:1054
#, fuzzy
msgid ":meth:`~socket.socket.close`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:1055
#, fuzzy
msgid ":meth:`~socket.socket.connect`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:1056
#, fuzzy
msgid ":meth:`~socket.socket.detach`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../../library/ssl.rst:1057
#, fuzzy
msgid ":meth:`~socket.socket.fileno`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:1058
#, fuzzy
msgid ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"
msgstr ":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:1059
#, fuzzy
msgid ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"
msgstr ":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:1060
#, fuzzy
msgid ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, "
":meth:`~socket.socket.setblocking`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`,"
" :meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:1062
#, fuzzy
msgid ":meth:`~socket.socket.listen`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:1063
#, fuzzy
msgid ":meth:`~socket.socket.makefile`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:1064
#, fuzzy
msgid ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (그러나 0이"
" 아닌 ``flags`` 인자를 전달하는 것은 허용되지 않습니다)"

#: ../../library/ssl.rst:1066
#, fuzzy
msgid ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (with the "
"same limitation)"
msgstr ":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (같은 제한 있음)"

#: ../../library/ssl.rst:1068
#, fuzzy
msgid ""
":meth:`~socket.socket.sendfile` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (그러나 :mod:`os.sendfile`\\는 평문 소켓에만 "
"사용되며, 그렇지 않으면 :meth:`~socket.socket.send()`\\가 사용됩니다)"

#: ../../library/ssl.rst:1070
#, fuzzy
msgid ":meth:`~socket.socket.shutdown`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:1072
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of "
"TCP, the SSL sockets abstraction can, in certain respects, diverge from "
"the specification of normal, OS-level sockets.  See especially the "
":ref:`notes on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"그러나 SSL (및 TLS) 프로토콜은 TCP 위에 자체 프레임을 가지고 있으므로, SSL 소켓 추상화는 특정 측면에서 정상적인 "
"OS 수준 소켓의 사양에서 벗어날 수 있습니다. 특히 :ref:`비 블로킹 소켓에 대한 참고 사항 <ssl-"
"nonblocking>`\\을 보십시오."

#: ../../library/ssl.rst:1077
msgid ""
"Instances of :class:`SSLSocket` must be created using the "
":meth:`SSLContext.wrap_socket` method."
msgstr ""
":class:`SSLSocket`\\의 인스턴스는 :meth:`SSLContext.wrap_socket` 메서드를 사용하여 민들어야"
" 합니다."

#: ../../library/ssl.rst:1080
msgid "The :meth:`sendfile` method was added."
msgstr ":meth:`sendfile` 메서드가 추가되었습니다."

#: ../../library/ssl.rst:1083
#, fuzzy
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes "
"are received or sent. The socket timeout is now the maximum total "
"duration of the shutdown."
msgstr ""
":meth:`shutdown`\\은 바이트가 수신되거나 전송될 때마다 소켓 시간제한을 재설정하지 않습니다. 소켓 시간제한은 이제 "
"shutdown의 최대 총 지속 시간입니다."

#: ../../library/ssl.rst:1088
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use "
":meth:`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
":class:`SSLSocket` 인스턴스를 직접 만드는 것은 폐지되었습니다, "
":meth:`SSLContext.wrap_socket`\\를 사용하여 소켓을 감싸십시오."

#: ../../library/ssl.rst:1092
msgid ""
":class:`SSLSocket` instances must to created with "
":meth:`~SSLContext.wrap_socket`. In earlier versions, it was possible to "
"create instances directly. This was never documented or officially "
"supported."
msgstr ""
":class:`SSLSocket` 인스턴스는 :meth:`~SSLContext.wrap_socket`\\로 만들어야 합니다. 이전 "
"버전에서는 직접 인스턴스를 만들 수 있었습니다. 이것은 문서로 만들어지거나 공식적으로 지원된 적이 없습니다."

#: ../../library/ssl.rst:1098
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing "
"zero-length data no longer fails with a protocol violation error."
msgstr ""

#: ../../library/ssl.rst:1103
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL 소켓에는 다음과 같은 추가 메서드와 어트리뷰트도 있습니다:"

#: ../../library/ssl.rst:1107
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result "
"as a ``bytes`` instance. If *buffer* is specified, then read into the "
"buffer instead, and return the number of bytes read."
msgstr ""
"SSL 소켓에서 최대 *len* 바이트의 데이터를 읽고 그 결과를 ``bytes`` 인스턴스로 반환합니다. *buffer*\\가 "
"지정되면, 대신 버퍼로 읽어 들이고, 읽은 바이트 수를 반환합니다."

#: ../../library/ssl.rst:1111
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket "
"is :ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"소켓이 :ref:`비 블로킹 <ssl-nonblocking>`\\이고 읽기가 블록 되려고 하면 "
":exc:`SSLWantReadError` 나 :exc:`SSLWantWriteError`\\를 발생시킵니다."

#: ../../library/ssl.rst:1114
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can "
"also cause write operations."
msgstr "언제나 재협상이 가능하므로, :meth:`read`\\를 호출해도 쓰기 연산이 발생할 수 있습니다."

#: ../../library/ssl.rst:1117
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time bytes are received or "
"sent. The socket timeout is now the maximum total duration to read up to "
"*len* bytes."
msgstr ""
"소켓 시간제한은 바이트가 수신되거나 전송될 때마다 재설정되지 않습니다. 소켓 시간제한은 이제 최대 *len* 바이트까지 읽을 "
"때까지의 최대 총 지속 시간입니다."

#: ../../library/ssl.rst:1122
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr ":meth:`~SSLSocket.read` 대신 :meth:`~SSLSocket.recv`\\를 사용하십시오."

#: ../../library/ssl.rst:1127
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The"
" *buf* argument must be an object supporting the buffer interface."
msgstr ""
"SSL 소켓에 *buf*\\를 기록하고, 기록한 바이트 수를 돌려줍니다. *buf* 인자는 버퍼 인터페이스를 지원하는 객체여야 "
"합니다."

#: ../../library/ssl.rst:1130
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket "
"is :ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"소켓이 :ref:`비 블로킹 <ssl-nonblocking>`\\이고, 쓰기가 블록 하려고 하면 "
":exc:`SSLWantReadError` 나 :exc:`SSLWantWriteError`\\를 발생시킵니다."

#: ../../library/ssl.rst:1133
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr "언제나 재협상이 가능하므로, :meth:`write`\\를 호출해도 읽기 연산이 발생할 수 있습니다."

#: ../../library/ssl.rst:1136
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time bytes are received or "
"sent. The socket timeout is now the maximum total duration to write "
"*buf*."
msgstr ""
"소켓 시간제한은 바이트가 수신되거나 전송될 때마다 재설정되지 않습니다. 소켓 시간제한은 이제 *buf*\\를 쓰는 최대 총 지속 "
"시간입니다."

#: ../../library/ssl.rst:1140
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr ":meth:`~SSLSocket.write` 대신 :meth:`~SSLSocket.send`\\를 사용하십시오."

#: ../../library/ssl.rst:1145
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the "
"low-level methods that read and write unencrypted, application-level data"
" and decrypt/encrypt it to encrypted, wire-level data. These methods "
"require an active SSL connection, i.e. the handshake was completed and "
":meth:`SSLSocket.unwrap` was not called."
msgstr ""
":meth:`~SSLSocket.read` 과 :meth:`~SSLSocket.write` 메서드는 암호화되지 않은 응용 프로그램 "
"수준 데이터를 읽고 쓰고 그것을 암호화되고 와이어 수준(wire-level) 데이터로 복호화/암호화하는 저수준 메서드입니다. 이 "
"메서드는 활성화된 SSL 연결, 즉, 핸드 셰이크가 완료되고, :meth:`SSLSocket.unwrap`\\가 호출되지 않은 것이"
" 필요합니다."

#: ../../library/ssl.rst:1151
msgid ""
"Normally you should use the socket API methods like "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` instead of "
"these methods."
msgstr ""
"일반적으로 이러한 메서드 대신 :meth:`~socket.socket.recv` 와 "
":meth:`~socket.socket.send`\\와 같은 소켓 API 메서드를 사용해야합니다."

#: ../../library/ssl.rst:1157
msgid "Perform the SSL setup handshake."
msgstr "SSL 설정 핸드 셰이크를 수행합니다."

#: ../../library/ssl.rst:1159
msgid ""
"The handshake method also performs :func:`match_hostname` when the "
":attr:`~SSLContext.check_hostname` attribute of the socket's "
":attr:`~SSLSocket.context` is true."
msgstr ""
"핸드 셰이크 메서드는 소켓의 :attr:`~SSLSocket.context`\\의 "
":attr:`~SSLContext.check_hostname` 어트리뷰트가 참일 때 :func:`match_hostname`\\도 "
"수행합니다."

#: ../../library/ssl.rst:1164
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time bytes are received or "
"sent. The socket timeout is now the maximum total duration of the "
"handshake."
msgstr "소켓 시간제한은 바이트가 수신되거나 전송될 때마다 재설정되지 않습니다. 소켓 시간제한은 이제 핸드 셰이크의 최대 지속 시간입니다."

#: ../../library/ssl.rst:1168
#, fuzzy
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The "
"function :func:`match_hostname` is no longer used. In case OpenSSL "
"refuses a hostname or IP address, the handshake is aborted early and a "
"TLS alert message is sent to the peer."
msgstr ""
"호스트 이름이나 IP 주소는 핸드 셰이크 중 OpenSSL에서 일치합니다. 함수 :func:`match_hostname`\\는 더는"
" 사용되지 않습니다. OpenSSL이 호스트 이름이나 IP 주소를 거절할 경우, 핸드 셰이크가 일찍 중단되고 TLS 경고 메시지가 "
"상대방에게 전송됩니다."

#: ../../library/ssl.rst:1176
msgid ""
"If there is no certificate for the peer on the other end of the "
"connection, return ``None``.  If the SSL handshake hasn't been done yet, "
"raise :exc:`ValueError`."
msgstr ""
"연결의 다른 끝의 피어에 대한 인증서가 없으면 ``None``\\을 반환합니다. SSL 핸드 셰이크가 아직 수행되지 않았으면, "
":exc:`ValueError`\\를 발생시킵니다."

#: ../../library/ssl.rst:1180
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was"
" received from the peer, this method returns a :class:`dict` instance.  "
"If the certificate was not validated, the dict is empty.  If the "
"certificate was validated, it returns a dict with several keys, amongst "
"them ``subject`` (the principal for which the certificate was issued) and"
" ``issuer`` (the principal issuing the certificate).  If a certificate "
"contains an instance of the *Subject Alternative Name* extension (see "
":rfc:`3280`), there will also be a ``subjectAltName`` key in the "
"dictionary."
msgstr ""
"``binary_form`` 매개 변수가 :const:`False`\\이고, 피어에서 인증서를 받았으면, 이 메서드는 "
":class:`dict` 인스턴스를 반환합니다. 인증서의 유효성을 검사하지 않았으면, 딕셔너리는 비어 있습니다. 인증서의 유효성을 "
"검사했으면 ``subject``\\(인증서가 발행된 주체)와 ``issuer``\\(인증서를 발급한 주체)와 같은 몇 가지 키가 "
"있는 dict를 반환합니다. 인증서가 *SAN(Subject Alternative Name)* 확장(:rfc:`3280` 참조)의 "
"인스턴스를 포함하면 딕셔너리에 ``subjectAltName`` 키도 있습니다."

#: ../../library/ssl.rst:1189
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence "
"of relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"``subject`` 와 ``issuer`` 필드는 각 필드에 대한 인증서의 데이터 구조에 제공된 RDN(relative "
"distinguished name)의 시퀀스를 포함하는 튜플이며, 각 RDN은 이름-값 쌍의 시퀀스입니다. 실제 예를 들어 "
"보겠습니다::"

#: ../../library/ssl.rst:1194
#, python-brace-format
msgid ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"
msgstr ""

#: ../../library/ssl.rst:1213
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire "
"certificate as a sequence of bytes, or :const:`None` if the peer did not "
"provide a certificate.  Whether the peer provides a certificate depends "
"on the SSL socket's role:"
msgstr ""
"``binary_form`` 매개 변수가 :const:`True`\\이고, 인증서가 제공되었으면, 이 메서드는 전체 인증서의 "
"DER-인코딩 형식을 바이트 시퀀스로 반환하고, 피어가 인증서를 제공하지 않았으면 :const:`None`\\을 반환합니다. 피어가"
" 인증서를 제공하는지는 SSL 소켓의 역할에 따라 다릅니다:"

#: ../../library/ssl.rst:1219
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr "클라이언트 SSL 소켓의 경우, 서버는 유효성 검사가 필요한지에 관계없이 항상 인증서를 제공합니다."

#: ../../library/ssl.rst:1222
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return "
":const:`None` if you used :const:`CERT_NONE` (rather than "
":const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`)."
msgstr ""
"서버 SSL 소켓의 경우, 클라이언트는 서버가 요청할 때만 인증서를 제공합니다; 따라서 "
":const:`CERT_NONE`\\(:const:`CERT_OPTIONAL` 나 :const:`CERT_REQUIRED` 대신)을"
" 사용하면 :meth:`getpeercert`\\는 :const:`None`\\을 반환합니다."

#: ../../library/ssl.rst:1227
msgid "See also :attr:`SSLContext.check_hostname`."
msgstr ""

#: ../../library/ssl.rst:1229
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr "반환된 딕셔너리에는 ``issuer`` 와 ``notBefore``\\와 같은 추가 항목이 포함됩니다."

#: ../../library/ssl.rst:1233
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
"핸드 셰이크가 완료되지 않았으면 :exc:`ValueError`\\가 발생합니다. 반환된 딕셔너리에는 "
"``crlDistributionPoints``, ``caIssuers`` 및 ``OCSP`` URI와 같은 추가 X509v3 확장 "
"항목이 포함됩니다."

#: ../../library/ssl.rst:1238
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "IPv6 주소 문자열에는 더는 후행 줄 바꿈이 없습니다."

#: ../../library/ssl.rst:1243
msgid ""
"Returns verified certificate chain provided by the other end of the SSL "
"channel as a list of DER-encoded bytes. If certificate verification was "
"disabled method acts the same as :meth:`~SSLSocket.get_unverified_chain`."
msgstr ""

#: ../../library/ssl.rst:1252
msgid ""
"Returns raw certificate chain provided by the other end of the SSL "
"channel as a list of DER-encoded bytes."
msgstr ""

#: ../../library/ssl.rst:1259
msgid ""
"Returns a three-value tuple containing the name of the cipher being used,"
" the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"사용되는 사이퍼의 이름, 그것의 사용을 정의하는 SSL 프로토콜의 버전 및 사용되는 비밀 비트의 수를 포함하는 3-튜플을 "
"반환합니다. 연결이 이루어지지 않았으면 ``None``\\을 반환합니다."

#: ../../library/ssl.rst:1265
#, fuzzy
msgid ""
"Return the list of ciphers available in both the client and server.  Each"
" entry of the returned list is a three-value tuple containing the name of"
" the cipher, the version of the SSL protocol that defines its use, and "
"the number of secret bits the cipher uses.  "
":meth:`~SSLSocket.shared_ciphers` returns ``None`` if no connection has "
"been established or the socket is a client socket."
msgstr ""
"핸드 셰이크 중에 클라이언트에 의해 공유되는 사이퍼의 리스트를 돌려줍니다. 반환된 리스트의 각 항목은 사이퍼의 이름, 그것의 사용을"
" 정의하는 SSL 프로토콜의 버전 및 사이퍼가 사용하는 비밀 비트의 수를 포함하는 3-튜플입니다. 연결이 이루어지지 않았거나 소켓이"
" 클라이언트 소켓이면 :meth:`~SSLSocket.shared_ciphers`\\는 ``None``\\을 반환합니다."

#: ../../library/ssl.rst:1276
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if "
"the connection isn't compressed."
msgstr "사용되는 압축 알고리즘을 문자열로 반환하거나, 연결이 압축되지 않으면 ``None``\\을 반환합니다."

#: ../../library/ssl.rst:1279
msgid ""
"If the higher-level protocol supports its own compression mechanism, you "
"can use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"상위-수준 프로토콜이 자체 압축 메커니즘을 지원하면, :data:`OP_NO_COMPRESSION`\\을 사용하여 SSL-수준 "
"압축을 비활성화할 수 있습니다."

#: ../../library/ssl.rst:1286
msgid ""
"Get channel binding data for current connection, as a bytes object.  "
"Returns ``None`` if not connected or the handshake has not been "
"completed."
msgstr ""
"현재 연결에 대한 채널 바인딩 데이터를 바이트열 객체로 가져옵니다. 연결되어 있지 않거나 핸드 셰이크가 완료되지 않았으면 "
"``None``\\을 반환합니다."

#: ../../library/ssl.rst:1289
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding "
"type. Valid channel binding types are listed in the "
":data:`CHANNEL_BINDING_TYPES` list.  Currently only the 'tls-unique' "
"channel binding, defined by :rfc:`5929`, is supported.  :exc:`ValueError`"
" will be raised if an unsupported channel binding type is requested."
msgstr ""
"*cb_type* 매개 변수를 사용하여 원하는 채널 바인딩 유형을 선택할 수 있습니다. 유효한 채널 바인딩 유형은 "
":data:`CHANNEL_BINDING_TYPES` 리스트에 나열됩니다. 현재는 :rfc:`5929`\\가 정의한 'tls-"
"unique' 채널 바인딩만 지원됩니다. 지원되지 않는 채널 바인딩 유형이 요청되면 :exc:`ValueError`\\가 "
"발생합니다."

#: ../../library/ssl.rst:1299
msgid ""
"Return the protocol that was selected during the TLS handshake.  If "
":meth:`SSLContext.set_alpn_protocols` was not called, if the other party "
"does not support ALPN, if this socket does not support any of the "
"client's proposed protocols, or if the handshake has not happened yet, "
"``None`` is returned."
msgstr ""
"TLS 핸드 셰이크 중에 선택된 프로토콜을 반환합니다. :meth:`SSLContext.set_alpn_protocols`\\가 "
"호출되지 않았거나, 상대방이 ALPN을 지원하지 않거나, 이 소켓이 클라이언트가 제안한 프로토콜 중 어떤 것도 지원하지 않거나, "
"핸드 셰이크가 아직 발생하지 않았으면 ``None``\\이 반환됩니다."

#: ../../library/ssl.rst:1309
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if "
"the other party does not support NPN, or if the handshake has not yet "
"happened, this will return ``None``."
msgstr ""
"TLS/SSL 핸드 셰이크 중에 선택된 상위-수준의 프로토콜을 반환합니다. "
":meth:`SSLContext.set_npn_protocols`\\가 호출되지 않았거나, 상대방이 NPN을 지원하지 않거나, 핸드"
" 셰이크가 아직 발생하지 않았으면 ``None``\\을 반환합니다."

#: ../../library/ssl.rst:1318 ../../library/ssl.rst:1687
msgid "NPN has been superseded by ALPN"
msgstr ""

#: ../../library/ssl.rst:1322
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the"
" underlying socket, and returns the underlying socket object.  This can "
"be used to go from encrypted operation over a connection to unencrypted."
"  The returned socket should always be used for further communication "
"with the other side of the connection, rather than the original socket."
msgstr ""
"SSL 종료 핸드 셰이크를 수행해서 하부 소켓에서 TLS 계층을 제거하고, 하부 소켓 객체를 반환합니다. 이것은 연결을 통한 "
"암호화된 연산에서 암호화되지 않은 것으로 이동하는 데 사용할 수 있습니다. 원래 소켓이 아닌 반환된 소켓을 연결의 다른 쪽과 계속 "
"통신하기 위해 항상 사용해야 합니다."

#: ../../library/ssl.rst:1330
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA "
"can only be initiated for a TLS 1.3 connection from a server-side socket,"
" after the initial TLS handshake and with PHA enabled on both sides, see "
":attr:`SSLContext.post_handshake_auth`."
msgstr ""
"TLS 1.3 클라이언트로부터 PHA(post-handshake authentication)를 요청합니다. PHA는 양쪽에서 "
"PHA가 활성화된 초기 TLS 핸드 셰이크 후에 서버 측 소켓에서 TLS 1.3 연결에 대해서만 시작할 수 있습니다, "
":attr:`SSLContext.post_handshake_auth`\\를 참조하세요."

#: ../../library/ssl.rst:1335
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"이 메서드는 즉시 인증서 교환을 수행하지 않습니다. 서버 측은 다음 쓰기 이벤트 중에 CertificateRequest를 보내고 "
"클라이언트가 다음 읽기 이벤트에서 인증서로 응답할 것으로 기대합니다."

#: ../../library/ssl.rst:1339
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an "
":exc:`SSLError` is raised."
msgstr ""
"사전 조건이 모두 충족되지 않으면 (예를 들어, TLS 1.3이 아니거나 PHA가 활성화되지 않았을 때), "
":exc:`SSLError`\\가 발생합니다."

#: ../../library/ssl.rst:1343
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"OpenSSL 1.1.1과 TLS 1.3이 활성화된 경우에만 사용할 수 있습니다. TLS 1.3 지원이 없으면, 이 메서드는 "
":exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/ssl.rst:1350
#, fuzzy
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL "
"versions may define more return values."
msgstr ""
"연결에서 협상한 실제 SSL 프로토콜 버전을 문자열로 반환하거나, 보안 연결이 이루어지지 않았으면 ``None``\\을 반환합니다."
" 이 글을 쓰는 시점에서, 가능한 반환 값은 ``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, "
"``\"TLSv1.1\"`` 및 ``\"TLSv1.2\"``\\입니다. 최근의 OpenSSL 버전은 더욱더 많은 반환 값을 정의할 "
"수 있습니다."

#: ../../library/ssl.rst:1360
msgid ""
"Returns the number of already decrypted bytes available for read, pending"
" on the connection."
msgstr "접속에 계류 중인, 읽기용으로 이미 복호화된 바이트의 수를 돌려줍니다."

#: ../../library/ssl.rst:1365
msgid "The :class:`SSLContext` object this SSL socket is tied to."
msgstr ""

#: ../../library/ssl.rst:1371
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for "
"client-side sockets."
msgstr "서버 측 소켓에서는 ``True``\\이고 클라이언트 측 소켓에서는 ``False`` 인 논릿값."

#: ../../library/ssl.rst:1378
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr "서버의 호스트 이름: :class:`str` 형, 또는 서버 측 소켓이거나 호스트 이름이 생성자에 지정되지 않았으면 ``None``."

#: ../../library/ssl.rst:1383
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the "
"A-label form (``\"xn--pythn-mua.org\"``), rather than the U-label form "
"(``\"pythön.org\"``)."
msgstr ""
"어트리뷰트는 이제 항상 ASCII 텍스트입니다. ``server_hostname``\\이 국제화 된 도메인 이름(IDN)일 때, 이"
" 어트리뷰트는 이제 U-레이블 형식(``\"pythön.org\"``) 대신 A-레이블 형식(``\"xn--pythn-"
"mua.org\"``)을 저장합니다."

#: ../../library/ssl.rst:1391
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available"
" for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before "
":meth:`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"이 SSL 연결을 위한 :class:`SSLSession`. 이 세션은 TLS 핸드 셰이크가 수행된 후 클라이언트와 서버 측 "
"소켓에서 사용할 수 있습니다. 클라이언트 소켓의 경우 세션을 다시 사용하기 위해 "
":meth:`~SSLSocket.do_handshake`\\가 호출되기 전에 세션을 설정할 수 있습니다."

#: ../../library/ssl.rst:1404
msgid "SSL Contexts"
msgstr "SSL 컨텍스트"

#: ../../library/ssl.rst:1408
msgid ""
"An SSL context holds various data longer-lived than single SSL "
"connections, such as SSL configuration options, certificate(s) and "
"private key(s). It also manages a cache of SSL sessions for server-side "
"sockets, in order to speed up repeated connections from the same clients."
msgstr ""
"SSL 컨텍스트는 SSL 구성 옵션, 인증서 및 개인 키와 같이 단일 SSL 연결보다 수명이 긴 다양한 데이터를 보관합니다. 또한,"
" 같은 클라이언트의 반복된 연결 속도를 높이기 위해 서버 측 소켓에 대한 SSL 세션 캐시를 관리합니다."

#: ../../library/ssl.rst:1415
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of "
"the ``PROTOCOL_*`` constants defined in this module.  The parameter "
"specifies which version of the SSL protocol to use.  Typically, the "
"server chooses a particular protocol version, and the client must adapt "
"to the server's choice.  Most of the versions are not interoperable with "
"the other versions.  If not specified, the default is "
":data:`PROTOCOL_TLS`; it provides the most compatibility with other "
"versions."
msgstr ""
"새 SSL 컨텍스트를 만듭니다. *protocol*\\를 전달할 수 있는데, 이 모듈에 정의된 ``PROTOCOL_*`` 상수 중 "
"하나여야 합니다. 매개 변수는 사용할 SSL 프로토콜의 버전을 지정합니다. 일반적으로 서버는 특정 프로토콜 버전을 선택하고, "
"클라이언트는 서버의 선택에 적응해야 합니다. 대부분의 버전은 다른 버전과 상호 운용할 수 없습니다. 지정하지 않으면, 기본값은 "
":data:`PROTOCOL_TLS`\\입니다; 다른 버전과의 호환성이 가장 뛰어납니다."

#: ../../library/ssl.rst:1424
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr "다음은 클라이언트의 어느 버전(행)이 서버의 어떤 버전(열)에 연결할 수 있는지 보여주는 표입니다:"

#: ../../library/ssl.rst:1430
msgid "*client* / **server**"
msgstr "*클라이언트* / **서버**"

#: ../../library/ssl.rst:1430
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1430
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1430
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1430
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1430
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1430
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1432
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1433
#: ../../library/ssl.rst:1434 ../../library/ssl.rst:1435
#: ../../library/ssl.rst:1436 ../../library/ssl.rst:1437
msgid "yes"
msgstr "yes"

#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1433
#: ../../library/ssl.rst:1435 ../../library/ssl.rst:1436
#: ../../library/ssl.rst:1437
msgid "no"
msgstr "no"

#: ../../library/ssl.rst:1432 ../../library/ssl.rst:1434
msgid "no [1]_"
msgstr "no [1]_"

#: ../../library/ssl.rst:1433
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1433 ../../library/ssl.rst:1434
msgid "no [2]_"
msgstr "no [2]_"

#: ../../library/ssl.rst:1434
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1435
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1436
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1437
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1440
msgid "Footnotes"
msgstr "각주"

#: ../../library/ssl.rst:1441
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ":class:`SSLContext`\\는 기본적으로 :data:`OP_NO_SSLv2`\\로 SSLv2를 비활성화합니다."

#: ../../library/ssl.rst:1442
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ":class:`SSLContext`\\는 기본적으로 :data:`OP_NO_SSLv3`\\으로 SSLv3을 비활성화합니다."

#: ../../library/ssl.rst:1443
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL "
">= 1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"TLS 1.3 프로토콜은 OpenSSL >= 1.1.1에서 :data:`PROTOCOL_TLS`\\로 사용할 수 있습니다. TLS "
"1.3만을 위한 전용 PROTOCOL 상수는 없습니다."

#: ../../library/ssl.rst:1448
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security"
" settings for a given purpose."
msgstr ""
":func:`create_default_context`\\는 :mod:`ssl` 모듈이 주어진 목적을 위한 보안 설정을 선택할 수 "
"있게 합니다."

#: ../../library/ssl.rst:1453
#, fuzzy
msgid ""
"The context is created with secure default values. The options "
":data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, "
":data:`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, "
":data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` (except for "
":data:`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list"
" contains only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` "
"ciphers."
msgstr ""
"컨텍스트는 안전한 기본값으로 생성됩니다. :data:`OP_NO_COMPRESSION`, "
":data:`OP_CIPHER_SERVER_PREFERENCE`, :data:`OP_SINGLE_DH_USE`, "
":data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (:data:`PROTOCOL_SSLv2` "
"제외) 및 :data:`OP_NO_SSLv3` (:data:`PROTOCOL_SSLv3` 제외) 옵션은 기본적으로 설정됩니다. 초기"
" 사이퍼 스위트 리스트에는 ``HIGH`` 사이퍼만 포함되고 ``NULL`` 사이퍼나 ``MD5`` 사이퍼는 포함되지 않습니다 "
"(:data:`PROTOCOL_SSLv2` 제외)."

#: ../../library/ssl.rst:1463
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or "
":data:`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""

#: ../../library/ssl.rst:1469
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 "
"ciphers with forward secrecy and security level 2. RSA and DH keys with "
"less than 2048 bits and ECC keys with less than 224 bits are prohibited. "
":data:`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and "
":data:`PROTOCOL_TLS_SERVER` use TLS 1.2 as minimum TLS version."
msgstr ""

#: ../../library/ssl.rst:1477
msgid ""
":class:`SSLContext` only supports limited mutation once it has been used "
"by a connection. Adding new certificates to the internal trust store is "
"allowed, but changing ciphers, verification settings, or mTLS "
"certificates may result in surprising behavior."
msgstr ""

#: ../../library/ssl.rst:1484
msgid ""
":class:`SSLContext` is designed to be shared and used by multiple "
"connections. Thus, it is thread-safe as long as it is not reconfigured "
"after being used by a connection."
msgstr ""

#: ../../library/ssl.rst:1489
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` 객체에는 다음과 같은 메서드와 어트리뷰트가 있습니다:"

#: ../../library/ssl.rst:1493
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of "
"X.509 certificates flagged as CA certificates and certificate revocation "
"lists as dictionary."
msgstr ""
"로드된 X.509 인증서 수량, CA 인증서로 표시된 X.509 인증서 및 인증서 취소 목록(CRL)의 수에 대한 통계를 딕셔너리로"
" 가져옵니다."

#: ../../library/ssl.rst:1497
msgid "Example for a context with one CA cert and one other cert::"
msgstr "하나의 CA 인증서와 다른 인증서 하나를 가진 컨텍스트 예::"

#: ../../library/ssl.rst:1499
#, python-brace-format
msgid ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"
msgstr ""

#: ../../library/ssl.rst:1507
#, fuzzy
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* "
"string must be the path to a single file in PEM format containing the "
"certificate as well as any number of CA certificates needed to establish "
"the certificate's authenticity.  The *keyfile* string, if present, must "
"point to a file containing the private key.  Otherwise the private key "
"will be taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in "
"the *certfile*."
msgstr ""
"개인 키와 해당 인증서를 로드합니다. *certfile* 문자열은 인증서뿐만 아니라 인증서의 신뢰성을 확보하는 데 필요한 여러 CA"
" 인증서가 포함된 PEM 형식의 단일 파일 경로여야 합니다. *keyfile* 문자열이 있으면 개인 키가 들어있는 파일을 가리켜야 "
"합니다. 그렇지 않으면 개인 키도 *certfile*\\에서 가져옵니다. 인증서가 *certfile*\\에 저장되는 방법에 대한 "
"자세한 내용은 :ref:`ssl-certificates`\\의 논의를 참조하십시오."

#: ../../library/ssl.rst:1516
msgid ""
"The *password* argument may be a function to call to get the password for"
" decrypting the private key.  It will only be called if the private key "
"is encrypted and a password is necessary.  It will be called with no "
"arguments, and it should return a string, bytes, or bytearray.  If the "
"return value is a string it will be encoded as UTF-8 before using it to "
"decrypt the key. Alternatively a string, bytes, or bytearray value may be"
" supplied directly as the *password* argument.  It will be ignored if the"
" private key is not encrypted and no password is needed."
msgstr ""
"*password* 인자는 개인 키의 복호화를 위한 암호를 얻기 위해 호출하는 함수가 될 수 있습니다. 개인 키가 암호화되어있고 "
"암호가 필요한 경우에만 호출됩니다. 인자 없이 호출되며, 문자열, 바이트열 또는 bytearray를 반환해야 합니다. 반환 값이 "
"문자열이면 키를 해독하기 전에 UTF-8로 인코딩됩니다. 또는 문자열, 바이트열 또는 bytearray 값을 *password* "
"인자로 직접 제공할 수 있습니다. 개인 키가 암호화되지 않고 암호가 필요 없으면 무시됩니다."

#: ../../library/ssl.rst:1525
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"*password* 인자가 지정되지 않고 암호가 필요하면, OpenSSL의 기본 암호 프롬프트 메커니즘을 사용하여 대화식으로 "
"사용자에게 암호를 묻습니다."

#: ../../library/ssl.rst:1529
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "개인 키가 인증서와 일치하지 않으면 :class:`SSLError`\\가 발생합니다."

#: ../../library/ssl.rst:1532
msgid "New optional argument *password*."
msgstr "새로운 선택적 인자 *password*."

#: ../../library/ssl.rst:1537
#, fuzzy
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and "
"``ROOT`` system stores. On all systems it calls "
":meth:`SSLContext.set_default_verify_paths`. In the future the method may"
" load CA certificates from other locations, too."
msgstr ""
"기본 위치에서 기본 \"인증 기관\"(CA) 인증서 집합을 로드합니다. 윈도우에서는 ``CA`` 와 ``ROOT`` 시스템 "
"저장소에서 CA 인증서를 로드합니다. 다른 시스템에서는 "
":meth:`SSLContext.set_default_verify_paths`\\를 호출합니다. 장래에 이 메서드는 다른 위치에서도"
" CA 인증서를 로드할 수 있습니다."

#: ../../library/ssl.rst:1543
#, fuzzy
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The"
" default settings :const:`Purpose.SERVER_AUTH` loads certificates, that "
"are flagged and trusted for TLS web server authentication (client side "
"sockets). :const:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"*purpose* 플래그는 로드되는 CA 인증서의 종류를 지정합니다. 기본 설정인 "
":data:`Purpose.SERVER_AUTH`\\는 TLS 웹 서버 인증 (클라이언트 측 소켓)용으로 표시되고 신뢰 되는 "
"인증서를 로드합니다. :data:`Purpose.CLIENT_AUTH`\\는 서버 측에서 클라이언트 인증서 확인을 위한 CA "
"인증서를 로드합니다."

#: ../../library/ssl.rst:1553
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to "
"validate other peers' certificates when :data:`verify_mode` is other than"
" :data:`CERT_NONE`.  At least one of *cafile* or *capath* must be "
"specified."
msgstr ""
":data:`verify_mode`\\가 :data:`CERT_NONE`\\가 아닐 때, 다른 피어의 인증서를 확인하는 데 사용되는"
" \"인증 기관\" (CA) 인증서 집합을 로드합니다. *cafile* 나 *capath* 중 적어도 하나는 지정해야 합니다."

#: ../../library/ssl.rst:1557
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or"
" DER format. In order to make use of CRLs, "
":attr:`SSLContext.verify_flags` must be configured properly."
msgstr ""
"이 메서드는 PEM 이나 DER 형식으로 인증서 해지 목록(CRL)을 로드할 수도 있습니다. CRL을 사용하려면 "
":attr:`SSLContext.verify_flags`\\를 올바르게 구성해야 합니다."

#: ../../library/ssl.rst:1561
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA"
" certificates in PEM format. See the discussion of :ref:`ssl-"
"certificates` for more information about how to arrange the certificates "
"in this file."
msgstr ""
"*cafile* 문자열이 있으면 이어붙인 PEM 형식의 CA 인증서 파일 경로입니다. 이 파일에 인증서를 정렬하는 방법에 대한 "
"자세한 내용은 :ref:`ssl-certificates`\\의 논의를 참조하십시오."

#: ../../library/ssl.rst:1566
#, fuzzy
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific "
"layout "
"<https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_."
msgstr ""
"*capath* 문자열이 있으면, `OpenSSL 특정 배치 "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html>`_\\를"
" 따르는 PEM 형식의 여러 CA 인증서를 포함하는 디렉터리에 대한 경로입니다."

#: ../../library/ssl.rst:1571
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more"
" PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded "
"certificates are ignored but at least one certificate must be present."
msgstr ""
"*cadata* 객체가 있으면, 하나 이상의 PEM-인코딩된 인증서의 ASCII 문자열이거나 DER-인코딩된 인증서의 "
":term:`바이트열류 객체 <bytes-like object>`\\입니다. *capath*\\와 마찬가지로 PEM-인코딩된 인증서"
" 주위에 추가한 줄은 무시되지만 적어도 하나의 인증서가 있어야 합니다."

#: ../../library/ssl.rst:1576
msgid "New optional argument *cadata*"
msgstr "새로운 선택적 인자 *cadata*"

#: ../../library/ssl.rst:1581
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If "
"the ``binary_form`` parameter is :const:`False` each list entry is a dict"
" like the output of :meth:`SSLSocket.getpeercert`. Otherwise the method "
"returns a list of DER-encoded certificates. The returned list does not "
"contain certificates from *capath* unless a certificate was requested and"
" loaded by a SSL connection."
msgstr ""
"로드된 \"인증 기관\" (CA) 인증서 목록을 가져옵니다. ``binary_form`` 매개 변수가 "
":const:`False`\\면 각 리스트 항목은 :meth:`SSLSocket.getpeercert`\\의 출력과 같은 "
"딕셔너리입니다. 그렇지 않으면, 이 메서드는 DER-인코딩된 인증서의 리스트를 반환합니다. 반환된 리스트에는 인증서가 SSL 연결이"
" 요청하고 로드되지 않는 한 *capath*\\의 인증서가 포함되어 있지 않습니다."

#: ../../library/ssl.rst:1589
msgid ""
"Certificates in a capath directory aren't loaded unless they have been "
"used at least once."
msgstr "capath 디렉터리의 인증서는 적어도 한 번 이상 사용하지 않으면 로드되지 않습니다."

#: ../../library/ssl.rst:1596
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. "
"See :meth:`SSLContext.set_ciphers`."
msgstr ""
"활성화된 사이퍼의 리스트를 가져옵니다. 리스트는 사이퍼 우선순위 순입니다. "
":meth:`SSLContext.set_ciphers`\\를 참조하십시오."

#: ../../library/ssl.rst:1601
#, python-brace-format
msgid ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA"
"  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA"
"  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"
msgstr ""

#: ../../library/ssl.rst:1633
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"a filesystem path defined when building the OpenSSL library.  "
"Unfortunately, there's no easy way to know whether this method succeeds: "
"no error is returned if no certificates are to be found.  When the "
"OpenSSL library is provided as part of the operating system, though, it "
"is likely to be configured properly."
msgstr ""
"OpenSSL 라이브러리를 빌드할 때 정의된 파일 시스템 경로에서 기본 \"인증 기관\" (CA) 인증서 집합을 로드합니다. "
"불행히도, 이 메서드가 성공하는지를 쉽게 알 방법이 없습니다: 인증서를 찾을 수 없어도 에러가 반환되지 않습니다. 하지만 "
"OpenSSL 라이브러리가 운영 체제 일부로 제공되면 올바르게 구성되었을 가능성이 큽니다."

#: ../../library/ssl.rst:1642
#, fuzzy
msgid ""
"Set the available ciphers for sockets created with this context. It "
"should be a string in the `OpenSSL cipher list format "
"<https://docs.openssl.org/master/man1/ciphers/>`_. If no cipher can be "
"selected (because compile-time options or other configuration forbids use"
" of all the specified ciphers), an :class:`SSLError` will be raised."
msgstr ""
"이 컨텍스트로 만들어진 소켓에 사용할 수 있는 사이퍼를 설정합니다. `OpenSSL 사이퍼 리스트 형식 "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_\\의 문자열이어야 "
"합니다. 사이퍼를 아무것도 선택할 수 없으면 (컴파일 시간 옵션이나 다른 구성이 지정된 모든 사이퍼의 사용을 금지하기 때문에), "
":class:`SSLError`\\가 발생합니다."

#: ../../library/ssl.rst:1650
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will "
"give the currently selected cipher."
msgstr "연결될 때, SSL 소켓의 :meth:`SSLSocket.cipher` 메서드가 현재 선택된 사이퍼를 제공합니다."

#: ../../library/ssl.rst:1653
#, fuzzy
msgid ""
"TLS 1.3 cipher suites cannot be disabled with "
":meth:`~SSLContext.set_ciphers`."
msgstr ""
"OpenSSL 1.1.1에는 기본적으로 활성화된 TLS 1.3 사이퍼 스위트가 있습니다. 이 스위트는 "
":meth:`~SSLContext.set_ciphers`\\로 비활성화할 수 없습니다."

#: ../../library/ssl.rst:1658
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will "
"happen during the handshake, and will play out according to :rfc:`7301`. "
"After a successful handshake, the "
":meth:`SSLSocket.selected_alpn_protocol` method will return the agreed-"
"upon protocol."
msgstr ""
"SSL/TLS 핸드 셰이크 중에 소켓이 알려야 하는 프로토콜을 지정합니다. 우선순위에 따라 정렬된 ``['http/1.1', "
"'spdy/2']``\\와 같은 ASCII 문자열 리스트여야 합니다. 프로토콜 선택은 핸드 셰이크 중에 발생하며, "
":rfc:`7301`\\에 따라 처리됩니다. 성공적인 핸드 셰이크가 끝나면, "
":meth:`SSLSocket.selected_alpn_protocol` 메서드는 합의된 프로토콜을 반환합니다."

#: ../../library/ssl.rst:1665
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
":data:`HAS_NPN`\\이 ``False``\\면, 이 메서드는 :exc:`NotImplementedError`\\를 "
"발생시킵니다."

#: ../../library/ssl.rst:1672
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will "
"happen during the handshake, and will play out according to the "
"`Application Layer Protocol Negotiation <https://en.wikipedia.org/wiki"
"/Application-Layer_Protocol_Negotiation>`_. After a successful handshake,"
" the :meth:`SSLSocket.selected_npn_protocol` method will return the "
"agreed-upon protocol."
msgstr ""
"SSL/TLS 핸드 셰이크 중에 소켓이 알려야 하는 프로토콜을 지정합니다. 우선순위에 따라 정렬된 ``['http/1.1', "
"'spdy/2']``\\와 같은 문자열 리스트여야 합니다. 프로토콜 선택은 핸드 셰이크 중에 발생하며, `Application "
"Layer Protocol Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_\\에 따라 처리됩니다. 성공적인 핸드 셰이크가 끝나면, "
":meth:`SSLSocket.selected_npn_protocol` 메서드는 합의된 프로토콜을 반환합니다."

#: ../../library/ssl.rst:1680
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
":data:`HAS_NPN`\\이 ``False``\\면, 이 메서드는 :exc:`NotImplementedError`\\를 "
"발생시킵니다."

#: ../../library/ssl.rst:1691
msgid ""
"Register a callback function that will be called after the TLS Client "
"Hello handshake message has been received by the SSL/TLS server when the "
"TLS client specifies a server name indication. The server name indication"
" mechanism is specified in :rfc:`6066` section 3 - Server Name "
"Indication."
msgstr ""
"TLS 클라이언트가 서버 이름 표시를 지정할 때 SSL/TLS 서버에서 TLS 클라이언트 Hello 핸드 셰이크 메시지를 받은 후 "
"호출될 콜백 함수를 등록합니다. 서버 이름 표시 메커니즘은 :rfc:`6066` section 3 - Server Name "
"Indication에서 지정됩니다."

#: ../../library/ssl.rst:1696
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is "
"set to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"``SSLContext`` 당 하나의 콜백 만 설정할 수 있습니다. *sni_callback*\\이 ``None``\\으로 설정되면"
" 콜백이 비활성화됩니다. 이 함수를 호출하면 이전에 등록된 콜백이 비활성화됩니다."

#: ../../library/ssl.rst:1700
msgid ""
"The callback function will be called with three arguments; the first "
"being the :class:`ssl.SSLSocket`, the second is a string that represents "
"the server name that the client is intending to communicate (or "
":const:`None` if the TLS Client Hello does not contain a server name) and"
" the third argument is the original :class:`SSLContext`. The server name "
"argument is text. For internationalized domain name, the server name is "
"an IDN A-label (``\"xn--pythn-mua.org\"``)."
msgstr ""
"콜백 함수는 세 개의 인자로 호출됩니다. 첫 번째는 :class:`ssl.SSLSocket`\\이고, 두 번째는 클라이언트가 "
"통신하려는 서버 이름을 나타내는 문자열(또는 TLS 클라이언트 Hello에 서버 이름이 없으면 :const:`None`)이며, 세 "
"번째 인자는 원래 :class:`SSLContext`\\입니다. 서버 이름 인자는 텍스트입니다. 국제화된 도메인 이름의 경우, 서버"
" 이름은 IDN A-레이블(``\"xn--pythn-mua.org\"``)입니다."

#: ../../library/ssl.rst:1708
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s "
":attr:`SSLSocket.context` attribute to a new object of type "
":class:`SSLContext` representing a certificate chain that matches the "
"server name."
msgstr ""
"이 콜백은 일반적으로 :class:`ssl.SSLSocket`\\의 :attr:`SSLSocket.context` 어트리뷰트를 서버"
" 이름과 일치하는 인증서 체인을 나타내는 :class:`SSLContext` 형의 새 객체로 변경하는 데 사용됩니다."

#: ../../library/ssl.rst:1713
#, fuzzy
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like "
":meth:`SSLSocket.selected_alpn_protocol` and :attr:`SSLSocket.context`. "
"The :meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.get_verified_chain`, "
":meth:`SSLSocket.get_unverified_chain` :meth:`SSLSocket.cipher` and "
":meth:`SSLSocket.compression` methods require that the TLS connection has"
" progressed beyond the TLS Client Hello and therefore will not return "
"meaningful values nor can they be called safely."
msgstr ""
"TLS 연결의 초기 협상 단계로 인해, :meth:`SSLSocket.selected_alpn_protocol`\\과 "
":attr:`SSLSocket.context`\\와 같은 제한된 메서드와 어트리뷰트만 사용할 수 있습니다. "
":meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.getpeercert`, "
":meth:`SSLSocket.cipher` 및 :meth:`SSLSocket.compress` 메서드는 TLS 연결이 TLS "
"클라이언트 Hello 이상으로 진행되었을 것을 요구하므로, 의미 있는 값을 반환하거나 안전하게 호출할 수 없습니다."

#: ../../library/ssl.rst:1722
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be "
"returned.  Other return values will result in a TLS fatal error with "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"TLS 협상을 계속하려면 *sni_callback* 함수가 ``None``\\을 반환해야 합니다. TLS 실패가 필요하면, 상수 "
":const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>`\\를 반환할 수 "
"있습니다. 다른 반환 값은 :const:`ALERT_DESCRIPTION_INTERNAL_ERROR`\\로 TLS 치명적인 에러를 "
"발생시킵니다."

#: ../../library/ssl.rst:1728
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"*sni_callback* 함수에서 예외가 발생하면, TLS 연결이 치명적인 TLS 경고 메시지 "
":const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`\\로 종료됩니다."

#: ../../library/ssl.rst:1732
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library "
"had OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"이 메서드는 OpenSSL 라이브러리가 빌드될 때 OPENSSL_NO_TLSEXT가 정의되었으면 "
":exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/ssl.rst:1739
msgid ""
"This is a legacy API retained for backwards compatibility. When possible,"
" you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the"
" server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"이전 버전과의 호환성을 위해 유지되는 기존 API입니다. 가능하면, 대신 :attr:`sni_callback`\\을 사용해야 "
"합니다. 주어진 *server_name_callback*\\은 *sni_callback*\\과 비슷하지만, 서버 호스트 이름이 "
"IDN-인코딩된 국제화된 도메인 이름일 때 *server_name_callback*\\은 디코딩된 "
"U-레이블(``\"pythön.org\"``)을 받습니다."

#: ../../library/ssl.rst:1745
#, fuzzy
msgid ""
"If there is a decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS "
"alert message to the client."
msgstr ""
"서버 이름에 디코딩 에러가 있으면, TLS 연결이 클라이언트로 "
":const:`ALERT_DESCRIPTION_INTERNAL_ERROR` 치명적인 TLS 경고 메시지를 주면서 종료됩니다."

#: ../../library/ssl.rst:1753
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The "
"*dhfile* parameter should be the path to a file containing DH parameters "
"in PEM format."
msgstr ""
"Diffie-Hellman (DH) 키 교환을 위한 키 생성 매개 변수를 로드합니다. DH 키 교환을 사용하면 계산 자원(서버와 "
"클라이언트 모두)을 희생하여 FS(forward secrecy)를 향상합니다. *dhfile* 매개 변수는 PEM 형식의 DH 매개"
" 변수를 포함하는 파일의 경로여야 합니다."

#: ../../library/ssl.rst:1759
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"이 설정은 클라이언트 소켓에는 적용되지 않습니다. :data:`OP_SINGLE_DH_USE` 옵션을 사용하여 보안을 더 향상할 "
"수도 있습니다."

#: ../../library/ssl.rst:1766
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as"
" secure.  The *curve_name* parameter should be a string describing a "
"well-known elliptic curve, for example ``prime256v1`` for a widely "
"supported curve."
msgstr ""
"타원 곡선(Elliptic Curve) 기반 Diffie-Hellman (ECDH) 키 교환을 위한 곡선 이름을 설정합니다. "
"보안성에 대한 논란의 여지는 있지만 ECDH는 일반 DH보다 상당히 빠릅니다. *curve_name* 매개 변수는 잘 알려진 타원 "
"곡선을 설명하는 문자열이어야 합니다, 예를 들어, 널리 지원되는 곡선인 ``prime256v1``."

#: ../../library/ssl.rst:1772
msgid ""
"This setting doesn't apply to client sockets.  You can also use the "
":data:`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"이 설정은 클라이언트 소켓에는 적용되지 않습니다. :data:`OP_SINGLE_ECDH_USE` 옵션을 사용하여 보안을 더 향상할"
" 수도 있습니다."

#: ../../library/ssl.rst:1775
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr ":data:`HAS_ECDH`\\가 ``False``\\면 이 메서드를 사용할 수 없습니다."

#: ../../library/ssl.rst:1780
#, fuzzy
msgid ""
"`SSL/TLS & Perfect Forward Secrecy "
"<https://vincent.bernat.ch/en/blog/2011-ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy "
"<https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy>`_"

#: ../../library/ssl.rst:1781
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1787
#, fuzzy
msgid ""
"Wrap an existing Python socket *sock* and return an instance of "
":attr:`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The "
"returned SSL socket is tied to the context, its settings and "
"certificates. *sock* must be a :const:`~socket.SOCK_STREAM` socket; other"
" socket types are unsupported."
msgstr ""
"기존 파이썬 소켓 *sock*\\을 감싸고 :attr:`SSLContext.sslsocket_class`\\(기본값 "
":class:`SSLSocket`)의 인스턴스를 반환합니다. 반환 된 SSL 소켓은 컨텍스트, 설정 및 인증서에 연결됩니다. "
"*sock*\\은 :data:`~socket.SOCK_STREAM` 소켓이어야합니다; 다른 소켓 유형은 지원되지 않습니다."

#: ../../library/ssl.rst:1793
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether "
"server-side or client-side behavior is desired from this socket."
msgstr "매개 변수 ``server_side``\\는 서버 측과 클라이언트 측 동작 중 어느 것이 소켓에서 필요한지를 식별하는 논릿값입니다."

#: ../../library/ssl.rst:1796
msgid ""
"For client-side sockets, the context construction is lazy; if the "
"underlying socket isn't connected yet, the context construction will be "
"performed after :meth:`connect` is called on the socket.  For server-side"
" sockets, if the socket has no remote peer, it is assumed to be a "
"listening socket, and the server-side SSL wrapping is automatically "
"performed on client connections accepted via the :meth:`accept` method. "
"The method may raise :exc:`SSLError`."
msgstr ""
"클라이언트 측 소켓의 경우, 컨텍스트 구성이 지연됩니다; 하부 소켓이 아직 연결되어 있지 않으면, :meth:`connect`\\가"
" 소켓에서 호출된 후 컨텍스트 생성이 수행됩니다. 서버 측 소켓의 경우, 소켓에 원격 피어가 없으면, 리스닝 소켓이라고 가정하고, "
"서버 측 SSL 감싸기는 :meth:`accept` 메서드를 통해 받아들인 클라이언트 연결에 대해 자동으로 수행됩니다. 메서드는 "
":exc:`SSLError`\\를 발생시킬 수 있습니다."

#: ../../library/ssl.rst:1804
msgid ""
"On client connections, the optional parameter *server_hostname* specifies"
" the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is "
"true."
msgstr ""
"클라이언트 연결에서, 선택적 매개 변수 *server_hostname*\\는 연결하려는 서비스의 호스트 이름을 지정합니다. 이를 "
"통해 단일 서버는 HTTP 가상 호스트와 매우 흡사하게 서로 다른 인증서로 여러 SSL 기반 서비스를 호스팅 할 수 있습니다. "
"*server_side*\\가 참일 때 *server_hostname*\\를 지정하면 :exc:`ValueError`\\가 "
"발생합니다."

#: ../../library/ssl.rst:1810
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL"
" handshake automatically after doing a :meth:`socket.connect`, or whether"
" the application program will call it explicitly, by invoking the "
":meth:`SSLSocket.do_handshake` method.  Calling "
":meth:`SSLSocket.do_handshake` explicitly gives the program control over "
"the blocking behavior of the socket I/O involved in the handshake."
msgstr ""
"매개 변수 ``do_handshake_on_connect``\\는 :meth:`socket.connect`\\를 수행한 후 SSL "
"핸드 셰이크를 자동으로 수행할지, 또는 응용 프로그램이 :meth:`SSLSocket.do_handshake` 메서드를 호출하여 "
"명시적으로 호출할지를 지정합니다. :meth:`SSLSocket.do_handshake`\\를 명시적으로 호출하면, 핸드 셰이크에 "
"수반되는 소켓 I/O의 블로킹 동작을 프로그램에서 제어할 수 있습니다."

#: ../../library/ssl.rst:1817
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the "
":meth:`SSLSocket.recv` method should signal unexpected EOF from the other"
" end of the connection.  If specified as :const:`True` (the default), it "
"returns a normal EOF (an empty bytes object) in response to unexpected "
"EOF errors raised from the underlying socket; if :const:`False`, it will "
"raise the exceptions back to the caller."
msgstr ""
"매개 변수 ``suppress_ragged_eofs``\\는 :meth:`SSLSocket.recv` 메서드가 연결의 다른 "
"끝으로부터의 예기치 않은 EOF를 알리는 방법을 지정합니다. :const:`True`\\(기본값)로 지정되면, 하부 소켓에서 발생한"
" 예기치 않은 EOF 에러에 대한 응답으로 정상 EOF(빈 바이트열 객체)를 반환합니다. :const:`False`\\면 예외를 "
"호출자에게 다시 발생시킵니다."

#: ../../library/ssl.rst:1824
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, :attr:`~SSLSocket.session`\\을 참조하십시오."

#: ../../library/ssl.rst:1826
#, fuzzy
msgid ""
"To wrap an :class:`SSLSocket` in another :class:`SSLSocket`, use "
":meth:`SSLContext.wrap_bio`."
msgstr ""
":class:`SSLSocket` 인스턴스를 직접 만드는 것은 폐지되었습니다, "
":meth:`SSLContext.wrap_socket`\\를 사용하여 소켓을 감싸십시오."

#: ../../library/ssl.rst:1829
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not "
"have SNI."
msgstr "OpenSSL에 SNI가 없더라도 항상 server_hostname을 전달할 수 있습니다."

#: ../../library/ssl.rst:1833 ../../library/ssl.rst:1859
msgid "*session* argument was added."
msgstr "*session* 인자가 추가되었습니다."

#: ../../library/ssl.rst:1836
#, fuzzy
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` "
"instead of hard-coded :class:`SSLSocket`."
msgstr ""
"이 메서드는 하드 코드 된 :class:`SSLSocket` 대신 :attr:`SSLContext.sslsocket_class` "
"인스턴스를 반환합니다."

#: ../../library/ssl.rst:1842
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to "
":class:`SSLSocket`. The attribute can be overridden on instance of class "
"in order to return a custom subclass of :class:`SSLSocket`."
msgstr ""
":meth:`SSLContext.wrap_socket`\\의 반환형, 기본값은 :class:`SSLSocket`\\입니다. 이 "
"어트리뷰트는 :class:`SSLSocket`\\의 사용자 정의 서브 클래스를 반환하기 위해 클래스의 인스턴스에서 재정의될 수 "
"있습니다."

#: ../../library/ssl.rst:1851
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of "
":attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the"
" outgoing BIO."
msgstr ""
"BIO 객체 *incoming* 과 *outgoing*\\을 감싸고 "
":attr:`SSLContext.sslobject_class`\\(기본값 :class:`SSLObject`)의 인스턴스를 "
"반환합니다. SSL 루틴은 incoming BIO에서 입력 데이터를 읽고 outgoing BIO에 데이터를 씁니다."

#: ../../library/ssl.rst:1856
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the "
"same meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"*server_side*, *server_hostname* 및 *session* 매개 변수는 "
":meth:`SSLContext.wrap_socket`\\에서와 같은 의미입니다."

#: ../../library/ssl.rst:1862
#, fuzzy
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` "
"instead of hard-coded :class:`SSLObject`."
msgstr ""
"이 메서드는 하드 코드 된 :class:`SSLObject` 대신 :attr:`SSLContext.sslobject_class` "
"인스턴스를 반환합니다."

#: ../../library/ssl.rst:1868
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to "
":class:`SSLObject`. The attribute can be overridden on instance of class "
"in order to return a custom subclass of :class:`SSLObject`."
msgstr ""
":meth:`SSLContext.wrap_bio`\\의 반환형, 기본값은 :class:`SSLObject`\\입니다. 이 "
"어트리뷰트는 :class:`SSLObject`\\의 사용자 정의 서브 클래스를 반환하기 위해 클래스의 인스턴스에서 재정의될 수 "
"있습니다."

#: ../../library/ssl.rst:1876
#, fuzzy
msgid ""
"Get statistics about the SSL sessions created or managed by this context."
" A dictionary is returned which maps the names of each `piece of "
"information <https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ "
"to their numeric values.  For example, here is the total number of hits "
"and misses in the session cache since the context was created::"
msgstr ""
"이 컨텍스트에 의해 생성되거나 관리된 SSL 세션에 대한 통계를 가져옵니다. 각 `정보 조각 "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_\\의"
" 이름을 숫자 값에 매핑하는 딕셔너리가 반환됩니다. 예를 들어, 다음은 컨텍스트가 생성된 이후 세션 캐시의 총 적중 횟수 및 누락 "
"횟수입니다::"

#: ../../library/ssl.rst:1881
msgid ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"
msgstr ""

#: ../../library/ssl.rst:1887
msgid ""
"Whether to match the peer cert's hostname in "
":meth:`SSLSocket.do_handshake`. The context's "
":attr:`~SSLContext.verify_mode` must be set to :data:`CERT_OPTIONAL` or "
":data:`CERT_REQUIRED`, and you must pass *server_hostname* to "
":meth:`~SSLContext.wrap_socket` in order to match the hostname.  Enabling"
" hostname checking automatically sets :attr:`~SSLContext.verify_mode` "
"from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be set back "
"to :data:`CERT_NONE` as long as hostname checking is enabled. The "
":data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by "
"default. With other protocols, hostname checking must be enabled "
"explicitly."
msgstr ""
":meth:`SSLSocket.do_handshake`\\에서 피어 인증서의 호스트 이름을 일치시킬지 여부. 컨텍스트의 "
":attr:`~SSLContext.verify_mode`\\는 :data:`CERT_OPTIONAL`\\나 "
":data:`CERT_REQUIRED`\\로 설정되어야 하며, 호스트 이름을 일치시키려면 *server_hostname*\\을 "
":meth:`~SSLContext.wrap_socket`\\로 전달해야 합니다. 호스트 이름 확인을 활성화하면 "
":attr:`~SSLContext.verify_mode`\\가 :data:`CERT_NONE`\\에서 "
":data:`CERT_REQUIRED`\\로 자동 설정됩니다. 호스트 이름 검사가 활성화되어 있으면 "
":data:`CERT_NONE`\\로 다시 설정할 수 없습니다. :data:`PROTOCOL_TLS_CLIENT` 프로토콜은 "
"기본적으로 호스트 이름 확인을 활성화합니다. 다른 프로토콜의 경우, 호스트 이름 확인을 명시적으로 활성화해야 합니다."

#: ../../library/ssl.rst:1900
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"
msgstr ""

#: ../../library/ssl.rst:1915
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to "
":data:`CERT_REQUIRED`  when hostname checking is enabled and "
":attr:`~SSLContext.verify_mode` is :data:`CERT_NONE`. Previously the same"
" operation would have failed with a :exc:`ValueError`."
msgstr ""
"호스트 이름 검사가 활성화되고 :attr:`~SSLContext.verify_mode`\\가 :data:`CERT_NONE`\\이면"
" 이제 :attr:`~SSLContext.verify_mode`\\가 :data:`CERT_REQUIRED`\\로 자동 변경됩니다."
" 이전에는 같은 작업이 :exc:`ValueError`\\로 실패했을 것입니다."

#: ../../library/ssl.rst:1922
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The "
"file format is specified by NSS and used by many traffic analyzers such "
"as Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"키 자료가 생성되거나 수신될 때마다, TLS 키를 키로그(keylog) 파일에 기록합니다. 키로그 파일은 디버깅 목적으로만 "
"설계되었습니다. 파일 형식은 NSS에 의해 지정되었고 Wireshark과 같은 많은 트래픽 분석기에서 사용됩니다. 로그 파일은 "
"덧붙이기 전용 모드로 열립니다. 쓰기는 스레드 간에 동기화되지만, 프로세스 간에는 동기화되지 않습니다."

#: ../../library/ssl.rst:1932
#, fuzzy
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :const:`PROTOCOL_TLS`, "
":const:`PROTOCOL_TLS_CLIENT`, and :const:`PROTOCOL_TLS_SERVER`."
msgstr ""
"지원되는 가장 높은 TLS 버전을 나타내는 :class:`TLSVersion` 열거형 멤버. 기본값은 "
":attr:`TLSVersion.MAXIMUM_SUPPORTED`\\입니다. 어트리뷰트는 :attr:`PROTOCOL_TLS`, "
":attr:`PROTOCOL_TLS_CLIENT` 및 :attr:`PROTOCOL_TLS_SERVER` 이외의 프로토콜에 대해 읽기"
" 전용입니다."

#: ../../library/ssl.rst:1937
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` and :attr:`SSLContext.options` all "
"affect the supported SSL and TLS versions of the context. The "
"implementation does not prevent invalid combination. For example a "
"context with :attr:`OP_NO_TLSv1_2` in :attr:`~SSLContext.options` and "
":attr:`~SSLContext.maximum_version` set to :attr:`TLSVersion.TLSv1_2` "
"will not be able to establish a TLS 1.2 connection."
msgstr ""
"어트리뷰트 :attr:`~SSLContext.maximum_version`, "
":attr:`~SSLContext.minimum_version` 및 :attr:`SSLContext.options`\\는 모두 "
"컨텍스트의 지원되는 SSL과 TLS 버전에 영향을 줍니다. 구현은 부적합한 조합을 방지하지 못합니다. 예를 들어, "
":attr:`~SSLContext.options`\\에 :attr:`OP_NO_TLSv1_2`\\가 있고 "
":attr:`~SSLContext.maximum_version`\\이 :attr:`TLSVersion.TLSv1_2`\\로 설정된 "
"컨텍스트는 TLS 1.2 연결을 이룰 수 없습니다."

#: ../../library/ssl.rst:1950
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported"
" version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"가장 낮은 지원 버전 또는 :attr:`TLSVersion.MINIMUM_SUPPORTED`\\이라는 것만 제외하면 "
":attr:`SSLContext.maximum_version`\\과 같습니다."

#: ../../library/ssl.rst:1957
#, fuzzy
msgid ""
"Control the number of TLS 1.3 session tickets of a "
":const:`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS "
"1.0 to 1.2 connections."
msgstr ""
":attr:`TLS_PROTOCOL_SERVER` 컨텍스트의 TLS 1.3 세션 티켓 수를 제어합니다. 이 설정은 TLS 1.0에서"
" 1.2 연결에는 영향을 미치지 않습니다."

#: ../../library/ssl.rst:1965
msgid ""
"An integer representing the set of SSL options enabled on this context. "
"The default value is :data:`OP_ALL`, but you can specify other options "
"such as :data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"이 컨텍스트에서 활성화된 SSL 옵션 집합을 나타내는 정수. 기본값은 :data:`OP_ALL`\\이지만, "
":data:`OP_NO_SSLv2`\\와 같은 다른 옵션을 함께 OR로 연결하여 지정할 수 있습니다."

#: ../../library/ssl.rst:1969
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options`\\는 :class:`Options` 플래그를 반환합니다.:"

#: ../../library/ssl.rst:1977
#, fuzzy
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and "
":attr:`SSLContext.maximum_version` instead."
msgstr ""
"이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다, 새로운 :attr:`SSLContext.minimum_version`\\과 "
":attr:`SSLContext.maximum_version`\\을 대신 사용하십시오."

#: ../../library/ssl.rst:1983
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth "
"is disabled by default and a server can only request a TLS client "
"certificate during the initial handshake. When enabled, a server may "
"request a TLS client certificate at any time after the handshake."
msgstr ""
"TLS 1.3 포스트 핸드 셰이크 클라이언트 인증을 사용합니다. 포스트 핸드 셰이크 인증은 기본적으로 사용되지 않으며 서버는 초기 "
"핸드 셰이크 중에 TLS 클라이언트 인증서만 요청할 수 있습니다. 활성화되면, 서버는 핸드 셰이크 후에 언제든지 TLS 클라이언트 "
"인증서를 요청할 수 있습니다."

#: ../../library/ssl.rst:1988
msgid ""
"When enabled on client-side sockets, the client signals the server that "
"it supports post-handshake authentication."
msgstr "클라이언트 측 소켓에서 활성화될 때, 클라이언트는 포스트 핸드 셰이크 인증을 지원하는 서버에 신호를 보냅니다."

#: ../../library/ssl.rst:1991
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must "
"be set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual"
" client cert exchange is delayed until "
":meth:`SSLSocket.verify_client_post_handshake` is called and some I/O is "
"performed."
msgstr ""
"서버 측 소켓에서 활성화될 때, :attr:`SSLContext.verify_mode`\\도 "
":data:`CERT_OPTIONAL`\\이나 :data:`CERT_REQUIRED`\\로 설정해야 합니다. 실제 클라이언트 인증서"
" 교환은 :meth:`SSLSocket.verify_client_post_handshake`\\가 호출되고 일부 I/O가 수행될 "
"때까지 지연됩니다."

#: ../../library/ssl.rst:2001
msgid ""
"The protocol version chosen when constructing the context.  This "
"attribute is read-only."
msgstr "컨텍스트를 구성할 때 선택한 프로토콜 버전. 이 어트리뷰트는 읽기 전용입니다."

#: ../../library/ssl.rst:2006
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the "
"cert's subject common name in the absence of a subject alternative name "
"extension (default: true)."
msgstr ""
":attr:`~SSLContext.check_hostname`\\가 SAN(subject alternative name) 확장이 "
"없을 때 인증서의 SCN(subject common name)을 유효성 검사하는 것으로 폴백 할지 아닐지 (기본값: 참)"

#: ../../library/ssl.rst:2014
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""

#: ../../library/ssl.rst:2019
msgid ""
"An integer representing the `security level "
"<https://docs.openssl.org/master/man3/SSL_CTX_get_security_level/>`_ for "
"the context. This attribute is read-only."
msgstr ""

#: ../../library/ssl.rst:2027
#, fuzzy
msgid ""
"The flags for certificate verification operations. You can set flags like"
" :data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL"
" does neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"인증서 유효성 검사 연산을 위한 플래그. :data:`VERIFY_CRL_CHECK_LEAF`\\와 같은 플래그를 함께 OR로 "
"연결하여 설정할 수 있습니다. 기본적으로 OpenSSL은 인증서 해지 목록(CRL)을 요구하지도 확인하지도 않습니다. openssl"
" 버전 0.9.8+ 에서만 사용할 수 있습니다."

#: ../../library/ssl.rst:2033
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags`\\는 :class:`VerifyFlags` 플래그를 반환합니다.:"

#: ../../library/ssl.rst:2041
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, "
":data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"다른 피어의 인증서를 확인할지와 확인이 실패할 때 어떻게 해야 하는지를 나타냅니다. 이 어트리뷰트는 "
":data:`CERT_NONE`, :data:`CERT_OPTIONAL` 또는 :data:`CERT_REQUIRED` 중 하나여야 "
"합니다."

#: ../../library/ssl.rst:2045
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode`\\는 :class:`VerifyMode` 열거형을 반환합니다.:"

#: ../../library/ssl.rst:2053
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a client-side "
"connection."
msgstr ""

#: ../../library/ssl.rst:2055 ../../library/ssl.rst:2104
msgid ""
"In general, certificate based authentication should be preferred over "
"this method."
msgstr ""

#: ../../library/ssl.rst:2057
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def"
" callback(hint: str | None) -> tuple[str | None, bytes]``. The ``hint`` "
"parameter is an optional identity hint sent by the server. The return "
"value is a tuple in the form (client-identity, psk). Client-identity is "
"an optional string which may be used by the server to select a "
"corresponding PSK for the client. The string must be less than or equal "
"to ``256`` octets when UTF-8 encoded. PSK is a :term:`bytes-like object` "
"representing the pre-shared key. Return a zero length PSK to reject the "
"connection."
msgstr ""

#: ../../library/ssl.rst:2067 ../../library/ssl.rst:2113
msgid "Setting ``callback`` to :const:`None` removes any existing callback."
msgstr ""

#: ../../library/ssl.rst:2070
msgid "When using TLS 1.3:"
msgstr ""

#: ../../library/ssl.rst:2072
msgid "the ``hint`` parameter is always :const:`None`."
msgstr ""

#: ../../library/ssl.rst:2073
msgid "client-identity must be a non-empty string."
msgstr ""

#: ../../library/ssl.rst:2075 ../../library/ssl.rst:2122
#, fuzzy
msgid "Example usage::"
msgstr "예제::"

#: ../../library/ssl.rst:2077
#, python-brace-format
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# A table using the hint from the server:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"
msgstr ""

#: ../../library/ssl.rst:2095 ../../library/ssl.rst:2140
#, fuzzy
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_PSK` is "
"``False``."
msgstr ""
":data:`HAS_NPN`\\이 ``False``\\면, 이 메서드는 :exc:`NotImplementedError`\\를 "
"발생시킵니다."

#: ../../library/ssl.rst:2102
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a server-side "
"connection."
msgstr ""

#: ../../library/ssl.rst:2106
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def"
" callback(identity: str | None) -> bytes``. The ``identity`` parameter is"
" an optional identity sent by the client which can be used to select a "
"corresponding PSK. The return value is a :term:`bytes-like object` "
"representing the pre-shared key. Return a zero length PSK to reject the "
"connection."
msgstr ""

#: ../../library/ssl.rst:2115
msgid ""
"The parameter ``identity_hint`` is an optional identity hint string sent "
"to the client. The string must be less than or equal to ``256`` octets "
"when UTF-8 encoded."
msgstr ""

#: ../../library/ssl.rst:2120
msgid ""
"When using TLS 1.3 the ``identity_hint`` parameter is not sent to the "
"client."
msgstr ""

#: ../../library/ssl.rst:2124
#, python-brace-format
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# A table using the identity of the client:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"
msgstr ""

#: ../../library/ssl.rst:2152
msgid "Certificates"
msgstr "인증서"

#: ../../library/ssl.rst:2154
msgid ""
"Certificates in general are part of a public-key / private-key system.  "
"In this system, each *principal*, (which may be a machine, or a person, "
"or an organization) is assigned a unique two-part encryption key.  One "
"part of the key is public, and is called the *public key*; the other part"
" is kept secret, and is called the *private key*.  The two parts are "
"related, in that if you encrypt a message with one of the parts, you can "
"decrypt it with the other part, and **only** with the other part."
msgstr ""
"인증서는 일반적으로 공개키/개인키 시스템 일부입니다. 이 시스템에서, 각 *주체(principal)*\\(시스템, 사람 또는 조직일"
" 수 있습니다)에게는 고유한 두 부분으로 된 암호화 키가 지정됩니다. 열쇠의 한 부분은 공개(public)며, *공개키(public"
" key)*\\라고 불립니다; 다른 부분은 비밀로 유지되며, *개인키(private key)*\\라고 합니다. 두 부분은 관련이 "
"있습니다. 두 부분 중 하나를 사용하여 메시지를 암호화하면, 다른 부분으로 해독할 수 있고, **오직** 다른 부분으로만 해독할 수"
" 있습니다."

#: ../../library/ssl.rst:2162
msgid ""
"A certificate contains information about two principals.  It contains the"
" name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who "
"they claim to be, and that this is indeed the subject's public key.  The "
"issuer's statement is signed with the issuer's private key, which only "
"the issuer knows.  However, anyone can verify the issuer's statement by "
"finding the issuer's public key, decrypting the statement with it, and "
"comparing it to the other information in the certificate. The certificate"
" also contains information about the time period over which it is valid."
"  This is expressed as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"인증서에는 두 주체에 대한 정보가 들어 있습니다. *주체(subject)*\\의 이름과 주체의 공개키가 들어 있습니다. 또한 "
"*발행자(issuer)*\\라는 두 번째 주체의 진술을 포함하는데, 해당 주체(subject)는 자신이 주장하는 존재며, 실제로 "
"공개키 또한 주체(subject)의 것이 맞는다는 내용입니다. 발행자의 진술은 발행자만이 알고 있는 발행자의 개인키로 서명됩니다. "
"그러나 누구든지 발행자의 공개키를 찾고 이를 사용하여 진술을 해독하고 인증서의 다른 정보와 비교함으로써 발행자의 진술을 확인할 수 "
"있습니다. 또한, 인증서에는 유효 기간에 대한 정보가 들어 있습니다. 이것은 \"notBefore\"와 \"notAfter\"라고 "
"하는 두 개의 필드로 표현됩니다."

#: ../../library/ssl.rst:2172
msgid ""
"In the Python use of certificates, a client or server can use a "
"certificate to prove who they are.  The other side of a network "
"connection can also be required to produce a certificate, and that "
"certificate can be validated to the satisfaction of the client or server "
"that requires such validation.  The connection attempt can be set to "
"raise an exception if the validation fails. Validation is done "
"automatically, by the underlying OpenSSL framework; the application need "
"not concern itself with its mechanics.  But the application does usually "
"need to provide sets of certificates to allow this process to take place."
msgstr ""
"파이썬에서 인증서를 사용할 때, 클라이언트나 서버는 인증서를 사용하여 자신이 누구인지 증명할 수 있습니다. 네트워크 연결의 다른 "
"쪽은 인증서 생성을 요구받을 수도 있으며, 해당 인증서는 이러한 유효성 검사가 필요한 클라이언트나 서버를 만족하도록 유효성을 검사할"
" 수 있습니다. 유효성 검증이 실패하면 연결 시도가 예외를 발생시키도록 설정할 수 있습니다. 유효성 검사는 하부 OpenSSL "
"프레임워크에 의해 자동으로 수행됩니다; 응용 프로그램은 그 메커니즘에 관심을 두지 않아도 됩니다. 그러나 응용 프로그램은 일반적으로"
" 이 절차를 수행할 수 있도록 인증서 집합을 제공해야 합니다."

#: ../../library/ssl.rst:2182
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a"
" header line and a footer line::"
msgstr ""
"파이썬은 인증서를 포함하기 위해 파일을 사용합니다. 그들은 \"PEM\"(:rfc:`1422`\\를 참조하세요)으로 포맷해야 "
"합니다. 머릿줄과 꼬리 줄로 감싼 base-64 로 인코딩된 형식입니다::"

#: ../../library/ssl.rst:2186
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../library/ssl.rst:2191
msgid "Certificate chains"
msgstr "인증서 체인"

#: ../../library/ssl.rst:2193
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the "
"client or server, and then the certificate for the issuer of that "
"certificate, and then the certificate for the issuer of *that* "
"certificate, and so on up the chain till you get to a certificate which "
"is *self-signed*, that is, a certificate which has the same subject and "
"issuer, sometimes called a *root certificate*.  The certificates should "
"just be concatenated together in the certificate file.  For example, "
"suppose we had a three certificate chain, from our server certificate to "
"the certificate of the certification authority that signed our server "
"certificate, to the root certificate of the agency which issued the "
"certification authority's certificate::"
msgstr ""
"인증서를 포함하는 파이썬 파일에는 인증서 시퀀스가 포함될 수 있는데, 때로 *인증서 체인(*certificate "
"chain)*\\이라고 부릅니다. 이 체인은 클라이언트 또는 서버 \"당사자\" 주체에 대한 특정 인증서로 시작해야 하며, 그다음에"
" 그 인증서의 발행자에 대한 인증서가 오고, 그다음에 *직전* 인증서 발행자에 대한 인증서가 오는 식으로 이어지다가, 결국에는 "
"*자체 서명(self-signed)* 인증서를 얻게 되는데, 주체와 발행자가 같은 인증서로 때로 *루트 인증서*\\라고도 부릅니다."
" 인증서는 인증서 파일에 함께 이어붙여야 합니다. 예를 들어, 서버 인증서에서 서버 인증서에 서명한 인증 기관의 인증서를 거쳐 인증"
" 기관의 인증서를 발행한 기관의 루트 인증서에 이르는 세 개의 인증서 체인이 있다고 가정합시다::"

#: ../../library/ssl.rst:2206
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../library/ssl.rst:2217
msgid "CA certificates"
msgstr "CA 인증서"

#: ../../library/ssl.rst:2219
msgid ""
"If you are going to require validation of the other side of the "
"connection's certificate, you need to provide a \"CA certs\" file, filled"
" with the certificate chains for each issuer you are willing to trust.  "
"Again, this file just contains these chains concatenated together.  For "
"validation, Python will use the first chain it finds in the file which "
"matches.  The platform's certificates file can be used by calling "
":meth:`SSLContext.load_default_certs`, this is done automatically with "
":func:`.create_default_context`."
msgstr ""
"연결의 반대편의 인증서의 유효성 검사가 필요하면, 신뢰할 수 있는 각 발행자의 인증서 체인으로 채워진 \"CA 인증서\" 파일을 "
"제공해야 합니다. 다시 말하지만, 이 파일은 단지 이러한 체인들을 함께 이어붙인 것입니다. 유효성 검사를 위해, 파이썬은 일치하는 "
"파일에서 찾은 첫 번째 체인을 사용합니다. 플랫폼의 인증서 파일은 "
":meth:`SSLContext.load_default_certs`\\를 호출하여 사용할 수 있습니다, 이는 "
":func:`.create_default_context`\\로 자동으로 수행됩니다."

#: ../../library/ssl.rst:2228
msgid "Combined key and certificate"
msgstr "결합한 키와 인증서"

#: ../../library/ssl.rst:2230
#, fuzzy
msgid ""
"Often the private key is stored in the same file as the certificate; in "
"this case, only the ``certfile`` parameter to "
":meth:`SSLContext.load_cert_chain` needs to be passed.  If the private "
"key is stored with the certificate, it should come before the first "
"certificate in the certificate chain::"
msgstr ""
"종종 개인 키는 인증서와 같은 파일에 저장됩니다; 이럴 때, :meth:`SSLContext.load_cert_chain`\\과 "
":func:`wrap_socket`\\에 대한 ``certfile`` 매개 변수만 전달하면 됩니다. 개인 키가 인증서와 함께 "
"저장되면, 인증서 체인의 첫 번째 인증서보다 먼저 와야 합니다.::"

#: ../../library/ssl.rst:2236
msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../library/ssl.rst:2244
msgid "Self-signed certificates"
msgstr "자체 서명 인증서"

#: ../../library/ssl.rst:2246
msgid ""
"If you are going to create a server that provides SSL-encrypted "
"connection services, you will need to acquire a certificate for that "
"service.  There are many ways of acquiring appropriate certificates, such"
" as buying one from a certification authority.  Another common practice "
"is to generate a self-signed certificate.  The simplest way to do this is"
" with the OpenSSL package, using something like the following::"
msgstr ""
"SSL-암호화된 연결 서비스를 제공하는 서버를 만들려면, 해당 서비스에 대한 인증서를 얻어야 합니다. 인증 기관에서 사는 등 다양한"
" 방법으로 적절한 인증서를 얻을 수 있습니다. 또 다른 일반적인 관행은 자체 서명 인증서를 생성하는 것입니다. 이렇게 하는 가장 "
"간단한 방법은 OpenSSL 패키지에서 다음과 같은 방법을 사용하는 것입니다::"

#: ../../library/ssl.rst:2253
#, python-format
msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a "
"DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My "
"Organization, Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""

#: ../../library/ssl.rst:2275
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"자체 서명 인증서의 단점은 그 자신이 루트 인증서이고, 아무도 그들의 알려진(그리고 신뢰할 수 있는) 루트 인증서의 캐시에 이 "
"인증서를 갖고 있지 않다는 것입니다."

#: ../../library/ssl.rst:2281
msgid "Examples"
msgstr "예제"

#: ../../library/ssl.rst:2284
msgid "Testing for SSL support"
msgstr "SSL 지원 검사하기"

#: ../../library/ssl.rst:2286
msgid ""
"To test for the presence of SSL support in a Python installation, user "
"code should use the following idiom::"
msgstr "파이썬 설치에 SSL 지원이 있는지를 검사하려면, 사용자 코드는 다음과 같은 관용구를 사용해야 합니다::"

#: ../../library/ssl.rst:2289
msgid ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # do something that requires SSL support"
msgstr ""

#: ../../library/ssl.rst:2297
msgid "Client-side operation"
msgstr "클라이언트 측 연산"

#: ../../library/ssl.rst:2299
msgid ""
"This example creates a SSL context with the recommended security settings"
" for client sockets, including automatic certificate verification::"
msgstr "이 예제는 자동 인증서 확인을 포함하여 클라이언트 소켓에 대해 권장되는 보안 설정을 사용하여 SSL 컨텍스트를 만듭니다::"

#: ../../library/ssl.rst:2302
msgid ">>> context = ssl.create_default_context()"
msgstr ""

#: ../../library/ssl.rst:2304
msgid ""
"If you prefer to tune security settings yourself, you might create a "
"context from scratch (but beware that you might not get the settings "
"right)::"
msgstr "보안 설정을 직접 조정하려면, 처음부터 컨텍스트를 만들 수 있습니다 (그러나 올바른 설정을 얻지 못할 수도 있습니다)::"

#: ../../library/ssl.rst:2308
msgid ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"
msgstr ""

#: ../../library/ssl.rst:2311
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(이 코드 조각은 운영 체제가 모든 CA 인증서 번들을 ``/etc/ssl/certs/ca-bundle.crt``\\에 배치한다고 "
"가정합니다; 그렇지 않으면, 에러가 발생하고 위치를 조정해야 합니다)"

#: ../../library/ssl.rst:2315
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is "
"set to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is "
"set to ``True``. All other protocols create SSL contexts with insecure "
"defaults."
msgstr ""
":data:`PROTOCOL_TLS_CLIENT` 프로토콜은 인증서 유효성 검사와 호스트 이름 확인을 위한 컨텍스트를 구성합니다. "
":attr:`~SSLContext.verify_mode`\\는 :data:`CERT_REQUIRED`\\로 설정되고 "
":attr:`~SSLContext.check_hostname`\\는 ``True``\\로 설정됩니다. 다른 모든 프로토콜은 안전하지"
" 않은 기본값으로 SSL 컨텍스트를 만듭니다."

#: ../../library/ssl.rst:2320
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` "
"and :attr:`~SSLContext.check_hostname` validate the server certificate: "
"it ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"컨텍스트를 사용하여 서버에 연결할 때, :const:`CERT_REQUIRED`\\와 "
":attr:`~SSLContext.check_hostname`\\은 서버 인증서의 유효성을 검사합니다: 서버 인증서가 CA 인증서 "
"중 하나를 사용하여 서명되었는지 확인하고, 서명의 정확성을 검사하고, 호스트 이름의 유효성과 아이덴티티와 같은 다른 속성을 "
"확인합니다::"

#: ../../library/ssl.rst:2326
msgid ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"
msgstr ""

#: ../../library/ssl.rst:2330
msgid "You may then fetch the certificate::"
msgstr "그런 다음 인증서를 가져올 수 있습니다::"

#: ../../library/ssl.rst:2332
msgid ">>> cert = conn.getpeercert()"
msgstr ""

#: ../../library/ssl.rst:2334
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr "시각적인 검사는 인증서가 원하는 서비스(즉, HTTPS 호스트 ``www.python.org``)를 식별함을 보여줍니다::"

#: ../../library/ssl.rst:2337
#, python-brace-format
msgid ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': "
"('http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt',),"
"\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-"
"server-g1.crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-"
"server-g1.crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server "
"CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"
msgstr ""

#: ../../library/ssl.rst:2377
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr "이제 SSL 채널이 설정되고 인증서가 확인되었습니다, 서버와 대화할 수 있습니다::"

#: ../../library/ssl.rst:2380
msgid ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")"
"\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"
msgstr ""

#: ../../library/ssl.rst:2404
msgid "Server-side operation"
msgstr "서버 측 연산"

#: ../../library/ssl.rst:2406
msgid ""
"For server operation, typically you'll need to have a server certificate,"
" and private key, each in a file.  You'll first create a context holding "
"the key and the certificate, so that clients can check your authenticity."
"  Then you'll open a socket, bind it to a port, call :meth:`listen` on "
"it, and start waiting for clients to connect::"
msgstr ""
"서버 연산의 경우, 일반적으로 서버 인증서와 개인 키가 각각 파일에 있어야 합니다. 먼저 클라이언트가 여러분의 신원을 확인할 수 "
"있도록 키와 인증서가 있는 컨텍스트를 만듭니다. 그런 다음 소켓을 열고, 포트에 바인드 하고, :meth:`listen`\\을 "
"호출한 다음 클라이언트가 연결하기를 기다립니다::"

#: ../../library/ssl.rst:2412
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""

#: ../../library/ssl.rst:2421
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get "
"the new socket from the other end, and use the context's "
":meth:`SSLContext.wrap_socket` method to create a server-side SSL socket "
"for the connection::"
msgstr ""
"클라이언트가 연결하면, 소켓에서 :meth:`accept`\\를 호출하여 다른 쪽 끝과 연결된 새 소켓을 얻고, 컨텍스트의 "
":meth:`SSLContext.wrap_socket` 메서드를 사용하여 연결을 위한 서버 측 SSL 소켓을 만듭니다.::"

#: ../../library/ssl.rst:2425
msgid ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"
msgstr ""

#: ../../library/ssl.rst:2434
msgid ""
"Then you'll read data from the ``connstream`` and do something with it "
"till you are finished with the client (or the client is finished with "
"you)::"
msgstr ""
"그런 다음 ``connstream``\\에서 데이터를 읽고 클라이언트와 작업을 마칠 때까지 (또는 클라이언트가 마칠 때까지) 뭔가 "
"합니다::"

#: ../../library/ssl.rst:2437
msgid ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # empty data means the client is finished with us\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # we'll assume do_something returns False\n"
"            # when we're finished with client\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # finished with client"
msgstr ""

#: ../../library/ssl.rst:2448
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread,"
" or put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use"
" an event loop)."
msgstr ""
"그리고는 새로운 클라이언트 연결을 리스닝하는 것으로 돌아갑니다 (물론, 실제 서버는 별도의 스레드에서 각 클라이언트 연결을 "
"처리하거나 소켓을 :ref:`비 블로킹 모드 <ssl-nonblocking>`\\로 만들고 이벤트 루프를 사용합니다)."

#: ../../library/ssl.rst:2456
msgid "Notes on non-blocking sockets"
msgstr "비 블로킹 소켓에 대한 참고 사항"

#: ../../library/ssl.rst:2458
msgid ""
"SSL sockets behave slightly different than regular sockets in non-"
"blocking mode. When working with non-blocking sockets, there are thus "
"several things you need to be aware of:"
msgstr ""
"SSL 소켓은 비 블로킹 모드에서 일반 소켓과 약간 다르게 작동합니다. 비 블로킹 소켓으로 작업할 때 주의해야 할 몇 가지 사항이 "
"있습니다:"

#: ../../library/ssl.rst:2462
msgid ""
"Most :class:`SSLSocket` methods will raise either "
":exc:`SSLWantWriteError` or :exc:`SSLWantReadError` instead of "
":exc:`BlockingIOError` if an I/O operation would block. "
":exc:`SSLWantReadError` will be raised if a read operation on the "
"underlying socket is necessary, and :exc:`SSLWantWriteError` for a write "
"operation on the underlying socket. Note that attempts to *write* to an "
"SSL socket may require *reading* from the underlying socket first, and "
"attempts to *read* from the SSL socket may require a prior *write* to the"
" underlying socket."
msgstr ""
"대부분 :class:`SSLSocket` 메서드는 I/O 연산이 블록하려고 할 때 :exc:`BlockingIOError` 대신 "
":exc:`SSLWantWriteError` 나 :exc:`SSLWantReadError`\\를 발생시킵니다. 하부 소켓에서의 읽기"
" 연산이 필요하면 :exc:`SSLWantReadError`\\가 발생하고, 하부 소켓에서의 쓰기 연산이 필요하면 "
":exc:`SSLWantWriteError`\\가 발생합니다. SSL 소켓에 대한 *쓰기* 시도는 우선 하부 소켓에서 *읽기*\\가"
" 필요할 수 있으며, SSL 소켓에서 *읽기*\\를 시도하면 하부 소켓에서 선행 *쓰기*\\가 필요할 수 있습니다."

#: ../../library/ssl.rst:2474
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned "
"zero instead of raising :exc:`SSLWantWriteError` or "
":exc:`SSLWantReadError`."
msgstr ""
"이전 파이썬 버전에서는, :meth:`!SSLSocket.send` 메서드가 :exc:`SSLWantWriteError` 나 "
":exc:`SSLWantReadError`\\를 발생시키는 대신 0을 반환했습니다."

#: ../../library/ssl.rst:2478
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient"
" data at the upper SSL layer.  For example, only part of an SSL frame "
"might have arrived.  Therefore, you must be ready to handle "
":meth:`SSLSocket.recv` and :meth:`SSLSocket.send` failures, and retry "
"after another call to :func:`~select.select`."
msgstr ""
":func:`~select.select`\\를 호출하면 OS-수준 소켓을 읽을 수 있음을 (또는 쓸 수 있음을) 알려줄 수 "
"있습니다만, 이것이 상위 SSL 계층에 충분한 데이터가 있음을 의미하지는 않습니다. 예를 들어, SSL 프레임의 일부만 도착했을 수"
" 있습니다. 따라서, :meth:`SSLSocket.recv` 와 :meth:`SSLSocket.send` 실패를 처리할 준비가 "
"되어 있어야 하며, :func:`~select.select`\\를 다시 호출한 후 재시도해야 합니다."

#: ../../library/ssl.rst:2485
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may "
"still have data available for reading without :func:`~select.select` "
"being aware of it.  Therefore, you should first call "
":meth:`SSLSocket.recv` to drain any potentially available data, and then "
"only block on a :func:`~select.select` call if still necessary."
msgstr ""
"반대로, SSL 계층에는 자체 프레임이 있으므로, SSL 소켓에는 :func:`~select.select`\\가 인식하지 못하더라도"
" 읽을 수 있는 데이터가 있을 수 있습니다. 따라서, 먼저 :meth:`SSLSocket.recv`\\를 호출하여 잠재적으로 사용 "
"가능한 모든 데이터를 꺼낸 다음, 여전히 필요할 때만 :func:`~select.select` 호출에 블록해야 합니다."

#: ../../library/ssl.rst:2491
msgid ""
"(of course, similar provisions apply when using other primitives such as "
":func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(물론, :func:`~select.poll` 이나 :mod:`selectors` 모듈에 있는 것과 같은 다른 프리미티브를 사용할 "
"때도 비슷한 조항이 적용됩니다)"

#: ../../library/ssl.rst:2494
msgid ""
"The SSL handshake itself will be non-blocking: the "
":meth:`SSLSocket.do_handshake` method has to be retried until it returns "
"successfully.  Here is a synopsis using :func:`~select.select` to wait "
"for the socket's readiness::"
msgstr ""
"SSL 핸드 셰이크 자체는 비 블로킹입니다: :meth:`SSLSocket.do_handshake` 메서드는 성공적으로 반환될 "
"때까지 재시도해야 합니다. 다음은 :func:`~select.select`\\를 사용하여 소켓의 준비 상태를 기다리는 개요입니다::"

#: ../../library/ssl.rst:2499
msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"
msgstr ""

#: ../../library/ssl.rst:2510
#, fuzzy
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level :ref:`Streams API <asyncio-"
"streams>`. It polls for events using the :mod:`selectors` module and "
"handles :exc:`SSLWantWriteError`, :exc:`SSLWantReadError` and "
":exc:`BlockingIOError` exceptions. It runs the SSL handshake "
"asynchronously as well."
msgstr ""
":mod:`asyncio` 모듈은 :ref:`비 블로킹 SSL 소켓 <ssl-nonblocking>`\\을 지원하며 더 고수준의 "
"API를 제공합니다. :mod:`selectors` 모듈을 사용하여 이벤트를 폴링 하고 "
":exc:`SSLWantWriteError`, :exc:`SSLWantReadError` 및 "
":exc:`BlockingIOError` 예외를 처리합니다. SSL 핸드 셰이크도 비동기적으로 실행됩니다."

#: ../../library/ssl.rst:2519
msgid "Memory BIO Support"
msgstr "메모리 BIO 지원"

#: ../../library/ssl.rst:2523
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the "
":class:`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"SSL 모듈이 파이썬 2.6에서 소개된 이래로, :class:`SSLSocket` 클래스는 관련성이 있지만, 별개의 두 기능 영역을"
" 제공했습니다:"

#: ../../library/ssl.rst:2526
msgid "SSL protocol handling"
msgstr "SSL 프로토콜 처리"

#: ../../library/ssl.rst:2527
msgid "Network IO"
msgstr "네트워크 IO"

#: ../../library/ssl.rst:2529
msgid ""
"The network IO API is identical to that provided by "
":class:`socket.socket`, from which :class:`SSLSocket` also inherits. This"
" allows an SSL socket to be used as a drop-in replacement for a regular "
"socket, making it very easy to add SSL support to an existing "
"application."
msgstr ""
"네트워크 IO API는 :class:`socket.socket`\\가 제공하는 것과 같으며, :class:`SSLSocket`\\는"
" 그 것을 상속합니다. 이렇게해서 SSL 소켓을 일반 소켓의 드롭 인 대체품으로 사용할 수 있으므로, 기존 응용 프로그램에 SSL "
"지원을 쉽게 추가 할 수 있습니다."

#: ../../library/ssl.rst:2534
msgid ""
"Combining SSL protocol handling and network IO usually works well, but "
"there are some cases where it doesn't. An example is async IO frameworks "
"that want to use a different IO multiplexing model than the \"select/poll"
" on a file descriptor\" (readiness based) model that is assumed by "
":class:`socket.socket` and by the internal OpenSSL socket IO routines. "
"This is mostly relevant for platforms like Windows where this model is "
"not efficient. For this purpose, a reduced scope variant of "
":class:`SSLSocket` called :class:`SSLObject` is provided."
msgstr ""
"SSL 프로토콜 처리와 네트워크 IO의 결합은 일반적으로 잘 작동하지만, 그렇지 않은 경우도 있습니다. "
":class:`socket.socket` 과 내부 OpenSSL 소켓 IO 루틴이 가정하는 \"파일 기술자에 대한 "
"select/poll\" (준비 상태 기반) 모델과 다른 IO 멀티플렉싱 모델을 사용하려는 비동기 IO 프레임워크가 그 예입니다. "
"이것은 주로 이 모델이 효율적이지 않은 윈도우와 같은 플랫폼과 관련이 있습니다. 이를 위해, "
":class:`SSLObject`\\라는 :class:`SSLSocket`\\의 축소된 범위 변형이 제공됩니다."

#: ../../library/ssl.rst:2545
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL "
"protocol instance that does not contain any network IO methods. This "
"class is typically used by framework authors that want to implement "
"asynchronous IO for SSL through memory buffers."
msgstr ""
"네트워크 IO 메서드를 포함하지 않는 SSL 프로토콜 인스턴스를 나타내는 :class:`SSLSocket`\\의 축소 범위 "
"변형입니다. 이 클래스는 일반적으로 메모리 버퍼를 통해 SSL 용 비동기 IO를 구현하려는 프레임워크 작성자가 사용합니다."

#: ../../library/ssl.rst:2550
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL "
"connection but does not provide any network IO itself. IO needs to be "
"performed through separate \"BIO\" objects which are OpenSSL's IO "
"abstraction layer."
msgstr ""
"이 클래스는 OpenSSL에 의해 구현된 저수준 SSL 객체 위에 인터페이스를 구현합니다. 이 객체는 SSL 연결의 상태를 "
"캡처하지만, 네트워크 IO 자체를 제공하지는 않습니다. IO는 OpenSSL의 IO 추상화 계층인 별도의 \"BIO\" 객체를 통해"
" 수행되어야 합니다."

#: ../../library/ssl.rst:2555
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance "
"must be created using the :meth:`~SSLContext.wrap_bio` method. This "
"method will create the :class:`SSLObject` instance and bind it to a pair "
"of BIOs. The *incoming* BIO is used to pass data from Python to the SSL "
"protocol instance, while the *outgoing* BIO is used to pass data the "
"other way around."
msgstr ""
"이 클래스에는 공개된 생성자가 없습니다. :class:`SSLObject` 인스턴스는 "
":meth:`~SSLContext.wrap_bio` 메서드를 사용해서 만들어야 합니다. 이 메서드는 "
":class:`SSLObject` 인스턴스를 생성하고 BIO 쌍에 연결합니다. *incoming* BIO는 파이썬에서 SSL "
"프로토콜 인스턴스로 데이터를 전달하는 데 사용되는 반면, *outgoing* BIO는 반대 방향으로 데이터를 전달하는 데 "
"사용됩니다."

#: ../../library/ssl.rst:2562
msgid "The following methods are available:"
msgstr "다음 메서드를 사용할 수 있습니다:"

#: ../../library/ssl.rst:2564
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2565
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2566
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2567
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2568
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2569
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2570
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2571
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2572
#, fuzzy
msgid ":meth:`~SSLSocket.get_verified_chain`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2573
#, fuzzy
msgid ":meth:`~SSLSocket.get_unverified_chain`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2574
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2575
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2576
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2577
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2578
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2579
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2580
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2581
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2582
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2583
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2584
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2586
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ":class:`SSLSocket`\\와 비교할 때, 이 객체에는 다음과 같은 기능이 없습니다:"

#: ../../library/ssl.rst:2589
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to "
"the underlying :class:`MemoryBIO` buffers."
msgstr ""
"모든 형태의 네트워크 IO; ``recv()`` 와 ``send()``\\는 하부 :class:`MemoryBIO` 버퍼만 읽고 "
"씁니다."

#: ../../library/ssl.rst:2592
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually"
" call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"*do_handshake_on_connect* 기작이 없습니다. 핸드 셰이크를 시작하려면 항상 "
":meth:`~SSLSocket.do_handshake`\\를 수동으로 호출해야 합니다."

#: ../../library/ssl.rst:2595
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file "
"conditions that are in violation of the protocol are reported via the "
":exc:`SSLEOFError` exception."
msgstr ""
"*suppress_ragged_eofs*\\는 처리되지 않습니다. 프로토콜을 위반하는 모든 파일 끝(end-of-file) 조건은 "
":exc:`SSLEOFError` 예외를 통해 보고됩니다."

#: ../../library/ssl.rst:2599
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, "
"unlike for an SSL socket where it returns the underlying socket."
msgstr "메서드 :meth:`~SSLSocket.unwrap` 호출은 하부 소켓을 반환하는 SSL 소켓과 달리 아무것도 반환하지 않습니다."

#: ../../library/ssl.rst:2602
msgid ""
"The *server_name_callback* callback passed to "
":meth:`SSLContext.set_servername_callback` will get an :class:`SSLObject`"
" instance instead of a :class:`SSLSocket` instance as its first "
"parameter."
msgstr ""
":meth:`SSLContext.set_servername_callback`\\에 전달된 *server_name_callback* "
"콜백은 첫 번째 매개 변수로 :class:`SSLSocket` 인스턴스 대신 :class:`SSLObject` 인스턴스를 받습니다."

#: ../../library/ssl.rst:2606
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr ":class:`SSLObject` 사용과 관련된 몇 가지 참고 사항:"

#: ../../library/ssl.rst:2608
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`."
" This means that for example :meth:`~SSLSocket.read` will raise an "
":exc:`SSLWantReadError` if it needs more data than the incoming BIO has "
"available."
msgstr ""
":class:`SSLObject`\\의 모든 IO는 :ref:`비 블로킹 <ssl-nonblocking>`\\입니다. 이것은 예를 "
"들어 :meth:`~SSLSocket.read`\\는 incoming BIO에 있는 것보다 많은 데이터가 필요하면 "
":exc:`SSLWantReadError`\\를 발생시킨다는 것을 의미합니다."

#: ../../library/ssl.rst:2613
#, fuzzy
msgid ""
":class:`SSLObject` instances must be created with "
":meth:`~SSLContext.wrap_bio`. In earlier versions, it was possible to "
"create instances directly. This was never documented or officially "
"supported."
msgstr ""
":class:`SSLObject` 인스턴스는 :meth:`~SSLContext.wrap_bio`\\로 만들어야 합니다. 이전 "
"버전에서는, 직접 인스턴스를 만들 수 있었습니다. 이것은 문서로 만들어지거나 공식적으로 지원된 적이 없습니다."

#: ../../library/ssl.rst:2619
msgid ""
"An SSLObject communicates with the outside world using memory buffers. "
"The class :class:`MemoryBIO` provides a memory buffer that can be used "
"for this purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject는 메모리 버퍼를 사용하여 바깥세상과 통신합니다. :class:`MemoryBIO` 클래스는 이 목적으로 사용할 수"
" 있는 메모리 버퍼를 제공합니다. OpenSSL 메모리 BIO (Basic IO) 객체를 감쌉니다:"

#: ../../library/ssl.rst:2625
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr "파이썬과 SSL 프로토콜 인스턴스 간에 데이터를 전달하는 데 사용할 수 있는 메모리 버퍼."

#: ../../library/ssl.rst:2630
msgid "Return the number of bytes currently in the memory buffer."
msgstr "현재 메모리 버퍼에 있는 바이트의 수를 반환합니다."

#: ../../library/ssl.rst:2634
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file"
" position."
msgstr "메모리 BIO가 현재 EOF(end-of-file) 위치에 있는지를 나타내는 논릿값입니다."

#: ../../library/ssl.rst:2639
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr "메모리 버퍼에서 최대 *n* 바이트를 읽습니다. *n*\\이 지정되지 않았거나 음수면, 모든 바이트가 반환됩니다."

#: ../../library/ssl.rst:2644
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be "
"an object supporting the buffer protocol."
msgstr "*buf*\\의 바이트를 메모리 BIO에 씁니다. *buf* 인자는 버퍼 프로토콜을 지원하는 객체여야 합니다."

#: ../../library/ssl.rst:2647
msgid ""
"The return value is the number of bytes written, which is always equal to"
" the length of *buf*."
msgstr "반환 값은 기록된 바이트 수인데, 항상 *buf*\\의 길이와 같습니다."

#: ../../library/ssl.rst:2652
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called,"
" it is illegal to call :meth:`~MemoryBIO.write`. The attribute "
":attr:`eof` will become true after all data currently in the buffer has "
"been read."
msgstr ""
"EOF 마커를 메모리 BIO에 씁니다. 이 메서드가 호출된 후, :meth:`~MemoryBIO.write`\\를 호출하는 것은 "
"불법입니다. :attr:`eof` 어트리뷰트는 현재 버퍼에 있는 모든 데이터를 읽은 후에 참이 됩니다."

#: ../../library/ssl.rst:2658
msgid "SSL session"
msgstr "SSL 세션"

#: ../../library/ssl.rst:2664
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr ":attr:`~SSLSocket.session`\\에서 사용되는 세션 객체."

#: ../../library/ssl.rst:2676
msgid "Security considerations"
msgstr "보안 고려 사항"

#: ../../library/ssl.rst:2679
msgid "Best defaults"
msgstr "가장 좋은 기본값"

#: ../../library/ssl.rst:2681
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the "
":func:`create_default_context` function to create your SSL context. It "
"will load the system's trusted CA certificates, enable certificate "
"validation and hostname checking, and try to choose reasonably secure "
"protocol and cipher settings."
msgstr ""
"**클라이언트**\\의 경우, 보안 정책에 대한 특별한 요구 사항이 없으면, :func:`create_default_context`"
" 함수를 사용하여 SSL 컨텍스트를 만드는 것이 좋습니다. 시스템의 신뢰할 수 있는 CA 인증서를 로드하고, 인증서 유효성 검사와 "
"호스트 이름 검사를 활성화하고, 합리적으로 안전한 프로토콜과 사이퍼 설정을 선택합니다."

#: ../../library/ssl.rst:2688
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to"
" create a trusted, secure connection to a SMTP server::"
msgstr ""
"예를 들어, 다음은 :class:`smtplib.SMTP` 클래스를 사용하여 SMTP 서버에 대한 신뢰할 수 있고 안전한 연결을 "
"만드는 방법입니다::"

#: ../../library/ssl.rst:2691
msgid ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"
msgstr ""

#: ../../library/ssl.rst:2697
msgid ""
"If a client certificate is needed for the connection, it can be added "
"with :meth:`SSLContext.load_cert_chain`."
msgstr "연결에 클라이언트 인증서가 필요하면, :meth:`SSLContext.load_cert_chain`\\으로 추가할 수 있습니다."

#: ../../library/ssl.rst:2700
msgid ""
"By contrast, if you create the SSL context by calling the "
":class:`SSLContext` constructor yourself, it will not have certificate "
"validation nor hostname checking enabled by default.  If you do so, "
"please read the paragraphs below to achieve a good security level."
msgstr ""
"대조적으로, :class:`SSLContext` 생성자를 직접 호출하여 SSL 컨텍스트를 만들면, 기본적으로 인증서 유효성 검사나 "
"호스트 이름 확인이 활성화되지 않습니다. 그렇게 하면, 아래 단락을 읽고 적절한 보안 수준을 달성하십시오."

#: ../../library/ssl.rst:2706
msgid "Manual settings"
msgstr "수동 설정"

#: ../../library/ssl.rst:2709
msgid "Verifying certificates"
msgstr "인증서 확인"

#: ../../library/ssl.rst:2711
#, fuzzy
msgid ""
"When calling the :class:`SSLContext` constructor directly, "
":const:`CERT_NONE` is the default.  Since it does not authenticate the "
"other peer, it can be insecure, especially in client mode where most of "
"the time you would like to ensure the authenticity of the server you're "
"talking to. Therefore, when in client mode, it is highly recommended to "
"use :const:`CERT_REQUIRED`.  However, it is in itself not sufficient; you"
" also have to check that the server certificate, which can be obtained by"
" calling :meth:`SSLSocket.getpeercert`, matches the desired service.  For"
" many protocols and applications, the service can be identified by the "
"hostname. This common check is automatically performed when "
":attr:`SSLContext.check_hostname` is enabled."
msgstr ""
":class:`SSLContext` 생성자를 직접 호출할 때, :const:`CERT_NONE`\\이 기본값입니다. 이것은 다른 "
"피어를 인증하지 않기 때문에, 특히 대부분 대화를 나누려는 서버의 신뢰성을 보장하고 싶어 하는 클라이언트 모드에서는 안전하지 않을 "
"수 있습니다. 따라서 클라이언트 모드에서는, :const:`CERT_REQUIRED`\\를 사용하는 것이 좋습니다. 그러나 그 "
"자체로는 충분하지 않습니다; :meth:`SSLSocket.getpeercert`\\를 호출하여 얻을 수 있는 서버 인증서가 원하는"
" 서비스와 일치하는지 확인해야 합니다. 많은 프로토콜과 응용 프로그램에서 서비스는 호스트 이름으로 식별할 수 있습니다; 이럴 때, "
":func:`match_hostname` 함수를 사용할 수 있습니다. 이 공통 검사는 "
":attr:`SSLContext.check_hostname`\\이 활성화되면 자동으로 수행됩니다."

#: ../../library/ssl.rst:2723
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses "
":func:`match_hostname`."
msgstr ""
"이제 호스트 이름 일치가 OpenSSL에 의해 수행됩니다. 파이썬은 더는 :func:`match_hostname`\\을 사용하지 "
"않습니다."

#: ../../library/ssl.rst:2727
msgid ""
"In server mode, if you want to authenticate your clients using the SSL "
"layer (rather than using a higher-level authentication mechanism), you'll"
" also have to specify :const:`CERT_REQUIRED` and similarly check the "
"client certificate."
msgstr ""
"서버 모드에서, (고수준 인증 메커니즘을 사용하는 대신) SSL 계층을 사용하여 클라이언트를 인증하려면, "
":const:`CERT_REQUIRED`\\를 지정하고 클라이언트 인증서도 비슷하게 확인해야 합니다."

#: ../../library/ssl.rst:2733
msgid "Protocol versions"
msgstr "프로토콜 버전"

#: ../../library/ssl.rst:2735
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous "
"to use.  If you want maximum compatibility between clients and servers, "
"it is recommended to use :const:`PROTOCOL_TLS_CLIENT` or "
":const:`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are"
" disabled by default."
msgstr ""
"SSL 버전 2와 3은 안전하지 않은 것으로 간주하므로 사용하기에 위험합니다. 클라이언트와 서버 간에 최대한의 호환성을 원하면 "
"프로토콜 버전으로 :const:`PROTOCOL_TLS_CLIENT` 나 :const:`PROTOCOL_TLS_SERVER`\\를 "
"사용하는 것이 좋습니다. SSLv2 및 SSLv3은 기본적으로 비활성화되어 있습니다."

#: ../../library/ssl.rst:2743
msgid ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"
msgstr ""

#: ../../library/ssl.rst:2748
#, fuzzy
msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. "
":const:`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname "
"checks by default. You have to load certificates into the context."
msgstr ""
"위에 만들어진 SSL 컨텍스트는 서버로 TLSv1.2 이상(시스템이 지원한다면)의 연결만 허용합니다. "
":const:`PROTOCOL_TLS_CLIENT`\\는 기본적으로 인증서 유효성 검사와 호스트 이름 검사를 의미합니다. 인증서를 "
"컨텍스트에 로드 해야 합니다."

#: ../../library/ssl.rst:2755
msgid "Cipher selection"
msgstr "사이퍼 선택"

#: ../../library/ssl.rst:2757
#, fuzzy
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the "
":meth:`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the "
"ssl module disables certain weak ciphers by default, but you may want to "
"further restrict the cipher choice. Be sure to read OpenSSL's "
"documentation about the `cipher list format "
"<https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-list-format>`_. If "
"you want to check which ciphers are enabled by a given cipher list, use "
":meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` command on your"
" system."
msgstr ""
"고급 보안 요구 사항이 있으면, :meth:`SSLContext.set_ciphers` 메서드를 통해 SSL 세션을 협상할 때 "
"활성화되는 사이퍼의 미세 조정이 가능합니다. 파이썬 3.2.3부터, ssl 모듈은 기본적으로 특정 약한 사이퍼를 비활성화하지만, "
"사이퍼 선택을 추가로 제한하려고 할 수 있습니다. `사이퍼 목록 형식 "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-"
"FORMAT>`_\\에 대한 OpenSSL의 설명서를 읽으십시오. 주어진 사이퍼 목록에 의해 활성화된 사이퍼를 확인하려면, "
":meth:`SSLContext.get_ciphers` 나 시스템에서 ``openssl ciphers`` 명령을 사용하십시오."

#: ../../library/ssl.rst:2768
msgid "Multi-processing"
msgstr "다중 프로세싱"

#: ../../library/ssl.rst:2770
#, fuzzy
msgid ""
"If using this module as part of a multi-processed application (using, for"
" example the :mod:`multiprocessing` or :mod:`concurrent.futures` "
"modules), be aware that OpenSSL's internal random number generator does "
"not properly handle forked processes.  Applications must change the PRNG "
"state of the parent process if they use any SSL feature with "
":func:`os.fork`.  Any successful call of :func:`~ssl.RAND_add` or "
":func:`~ssl.RAND_bytes` is sufficient."
msgstr ""
"다중 프로세스 응용 프로그램(예를 들어, : :mod:`multiprocessing` 이나 "
":mod:`concurrent.futures` 모듈을 사용하는)의 일부로 이 모듈을 사용하면, OpenSSL의 내부 난수 생성기가 "
"포크 된 프로세스를 제대로 처리하지 못합니다. 응용 프로그램이 :func:`os.fork`\\와 함께 SSL 기능을 사용하면, 부모"
" 프로세스의 PRNG 상태를 변경해야 합니다. :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` "
"또는 :func:`~ssl.RAND_pseudo_bytes`\\의 성공적인 호출이면 충분합니다."

#: ../../library/ssl.rst:2782
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2786
#, fuzzy
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version "
"of TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"파이썬은 OpenSSL 1.1.1을 사용해서 TLS 1.3에 대한 잠정적이고 실험적인 지원을 제공합니다. 새 프로토콜은 이전 버전의"
" TLS/SSL과 약간 다르게 동작합니다. 몇몇 새로운 TLS 1.3 기능은 아직 제공되지 않습니다."

#: ../../library/ssl.rst:2789
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method "
":meth:`SSLContext.set_ciphers` cannot enable or disable any TLS 1.3 "
"ciphers yet, but :meth:`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3은 분리된 사이퍼 스위트 집합을 사용합니다. 모든 AES-GCM과 ChaCha20 사이퍼 스위트는 기본적으로 활성화되어"
" 있습니다. :meth:`SSLContext.set_ciphers` 메서드는 아직 TLS 1.3 사이퍼를 활성화하거나 비활성화할 수"
" 없지만, :meth:`SSLContext.get_ciphers`\\는 이들을 반환합니다."

#: ../../library/ssl.rst:2793
msgid ""
"Session tickets are no longer sent as part of the initial handshake and "
"are handled differently.  :attr:`SSLSocket.session` and "
":class:`SSLSession` are not compatible with TLS 1.3."
msgstr ""
"세션 티켓은 더는 초기 핸드 셰이크의 일부로 전송되지 않고 다르게 처리됩니다. :attr:`SSLSocket.session` 과 "
":class:`SSLSession`\\은 TLS 1.3과 호환되지 않습니다."

#: ../../library/ssl.rst:2796
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients "
"process certificate requests while they send or receive application data "
"from the server."
msgstr ""
"클라이언트 측 인증서도 더는 초기 핸드 셰이크 중에 검증되지 않습니다. 서버는 언제든지 인증서를 요청할 수 있습니다. 클라이언트는 "
"서버와 응용 프로그램 데이터를 주고받는 동안 인증서 요청을 처리합니다."

#: ../../library/ssl.rst:2800
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"초기 데이터(early data), 지연된 TLS 클라이언트 인증서 요청, 서명 알고리즘 구성 및 rekeying과 같은 TLS "
"1.3 기능은 아직 지원되지 않습니다."

#: ../../library/ssl.rst:2806
msgid "Class :class:`socket.socket`"
msgstr ":class:`socket.socket` 클래스"

#: ../../library/ssl.rst:2807
msgid "Documentation of underlying :mod:`socket` class"
msgstr "하부 :mod:`socket` 클래스의 설명서"

#: ../../library/ssl.rst:2809
msgid ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Strong Encryption: An Introduction "
"<https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2810
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Apache HTTP 서버 설명서의 개요"

#: ../../library/ssl.rst:2812
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part "
"II: Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part "
"II: Certificate-Based Key Management <1422>`"

#: ../../library/ssl.rst:2813
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2815
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"

#: ../../library/ssl.rst:2816
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2818
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"

#: ../../library/ssl.rst:2819
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2821
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"

#: ../../library/ssl.rst:2822
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2824
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"

#: ../../library/ssl.rst:2825
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2827
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Transport Layer Security (TLS) Parameters "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2828
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2830
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer "
"Security (TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer "
"Security (TLS) and Datagram Transport Layer Security (DTLS) <7525>`"

#: ../../library/ssl.rst:2831
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2833
msgid ""
"`Mozilla's Server Side TLS recommendations "
"<https://wiki.mozilla.org/Security/Server_Side_TLS>`_"
msgstr "`모질라의 서버 측 TLS 추천 <https://wiki.mozilla.org/Security/Server_Side_TLS>`_"

#: ../../library/ssl.rst:2834
msgid "Mozilla"
msgstr "Mozilla"

#: ../../library/ssl.rst:12
msgid "OpenSSL"
msgstr ""

#: ../../library/ssl.rst:12
msgid "(use in module ssl)"
msgstr ""

#: ../../library/ssl.rst:14
#, fuzzy
msgid "TLS"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:14
#, fuzzy
msgid "SSL"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:14
msgid "Transport Layer Security"
msgstr ""

#: ../../library/ssl.rst:14
msgid "Secure Sockets Layer"
msgstr ""

#: ../../library/ssl.rst:2145
#, fuzzy
msgid "certificates"
msgstr "인증서"

#: ../../library/ssl.rst:2147
#, fuzzy
msgid "X509 certificate"
msgstr "인증서"

#~ msgid ""
#~ "Since Python 3.2 and 2.7.9, it is"
#~ " recommended to use the "
#~ ":meth:`SSLContext.wrap_socket` of an "
#~ ":class:`SSLContext` instance to wrap sockets"
#~ " as :class:`SSLSocket` objects. The helper"
#~ " functions :func:`create_default_context` returns "
#~ "a new context with secure default "
#~ "settings. The old :func:`wrap_socket` function"
#~ " is deprecated since it is both "
#~ "inefficient and has no support for "
#~ "server name indication (SNI) and "
#~ "hostname matching."
#~ msgstr ""
#~ "파이썬 3.2와 2.7.9 이후로, :class:`SSLSocket` "
#~ "객체로 소켓을 포장하기 위해 :class:`SSLContext` "
#~ "인스턴스의 :meth:`SSLContext.wrap_socket`\\을 사용하는 것이 "
#~ "좋습니다. 도우미 함수 :func:`create_default_context`\\는 "
#~ "보안 기본 설정의 새 컨텍스트를 반환합니다. 오래된 "
#~ ":func:`wrap_socket` 함수는 비효율적이고 서버 이름 "
#~ "표시(SNI)와 호스트 이름 일치를 지원하지 않기 때문에"
#~ " 폐지되었습니다."

#~ msgid ""
#~ "Return (bytes, is_cryptographic): bytes are"
#~ " *num* pseudo-random bytes, "
#~ "is_cryptographic is ``True`` if the "
#~ "bytes generated are cryptographically strong."
#~ " Raises an :class:`SSLError` if the "
#~ "operation is not supported by the "
#~ "current RAND method."
#~ msgstr ""
#~ "(bytes, is_cryptographic) 을 반환합니다: bytes는 "
#~ "*num* 길이의 의사 난수 바이트열이며, 생성된 bytes가"
#~ " 암호학적으로 강하면 is_cryptographic은 ``True``\\입니다. "
#~ "현재 RAND 메서드에서 지원되지 않는 연산이면 "
#~ ":class:`SSLError`\\를 발생시킵니다."

#~ msgid ""
#~ "Generated pseudo-random byte sequences "
#~ "will be unique if they are of "
#~ "sufficient length, but are not "
#~ "necessarily unpredictable. They can be "
#~ "used for non-cryptographic purposes and"
#~ " for certain purposes in cryptographic "
#~ "protocols, but usually not for key "
#~ "generation etc."
#~ msgstr ""
#~ "생성된 의사 난수 바이트 시퀀스는 충분한 길이일 때"
#~ " 고유하지만, 예측할 수 없는 것은 아닙니다. 이것들은"
#~ " 비암호화 목적이나 암호화 프로토콜에서의 특정 목적을 "
#~ "위해 사용될 수 있지만, 보통 키 생성 등을 "
#~ "위해 사용되지는 않습니다."

#~ msgid ""
#~ "OpenSSL has deprecated "
#~ ":func:`ssl.RAND_pseudo_bytes`, use :func:`ssl.RAND_bytes`"
#~ " instead."
#~ msgstr ""
#~ "OpenSSL은 :func:`ssl.RAND_pseudo_bytes`\\를 폐지했습니다. 대신"
#~ " :func:`ssl.RAND_bytes`\\를 사용하십시오."

#~ msgid ""
#~ "If you are running an entropy-"
#~ "gathering daemon (EGD) somewhere, and "
#~ "*path* is the pathname of a socket"
#~ " connection open to it, this will "
#~ "read 256 bytes of randomness from "
#~ "the socket, and add it to the "
#~ "SSL pseudo-random number generator to"
#~ " increase the security of generated "
#~ "secret keys.  This is typically only "
#~ "necessary on systems without better "
#~ "sources of randomness."
#~ msgstr ""
#~ "어딘가에 엔트로피 수집 데몬(EGD - entropy-"
#~ "gathering daemon)을 실행 중이고, *path*\\가 "
#~ "그곳으로 열려있는 소켓 연결의 경로명이면, 그 소켓에서 "
#~ "256바이트의 임의성을 읽고, 생성된 비밀 키의 보안을 "
#~ "강화하기 위해 이를 SSL 의사 난수 생성기에 "
#~ "추가합니다. 이것은 일반적으로 더 나은 임의성 소스가 "
#~ "없는 시스템에서만 필요합니다."

#~ msgid ""
#~ "See http://egd.sourceforge.net/ or "
#~ "http://prngd.sourceforge.net/ for sources of "
#~ "entropy-gathering daemons."
#~ msgstr ""
#~ "엔트로피 수집 데몬의 소스에 대해서는 "
#~ "http://egd.sourceforge.net/ 나 "
#~ "http://prngd.sourceforge.net/ 을 참조하십시오."

#~ msgid ""
#~ ":ref:`Availability <availability>`: not available"
#~ " with LibreSSL and OpenSSL > 1.1.0."
#~ msgstr ":ref:`가용성 <availability>`: LibreSSL 과 OpenSSL > 1.1.0에서는 사용할 수 없습니다."

#~ msgid ""
#~ "Verify that *cert* (in decoded format"
#~ " as returned by :meth:`SSLSocket.getpeercert`)"
#~ " matches the given *hostname*.  The "
#~ "rules applied are those for checking "
#~ "the identity of HTTPS servers as "
#~ "outlined in :rfc:`2818`, :rfc:`5280` and "
#~ ":rfc:`6125`.  In addition to HTTPS, this"
#~ " function should be suitable for "
#~ "checking the identity of servers in "
#~ "various SSL-based protocols such as "
#~ "FTPS, IMAPS, POPS and others."
#~ msgstr ""
#~ "*cert*\\(:meth:`SSLSocket.getpeercert`\\에서 반환된 디코딩된 "
#~ "형식)가 지정된 *hostname*\\과 일치하는지 확인합니다. 적용되는"
#~ " 규칙은 :rfc:`2818`, :rfc:`5280` 및 "
#~ ":rfc:`6125`\\에 설명된 대로 HTTPS 서버의 "
#~ "신원(identity)을 확인하기 위한 것입니다. HTTPS 외에도,"
#~ " 이 함수는 FTPS, IMAPS, POPS 및 그"
#~ " 밖의 다양한 SSL 기반 프로토콜에서 서버의 신원을"
#~ " 확인하는 데 적합합니다."

#~ msgid ""
#~ ":exc:`CertificateError` is raised on failure."
#~ " On success, the function returns "
#~ "nothing::"
#~ msgstr "실패하면 :exc:`CertificateError`\\가 발생합니다. 성공하면, 함수는 아무것도 반환하지 않습니다::"

#~ msgid ""
#~ "The function now follows :rfc:`6125`, "
#~ "section 6.4.3 and does neither match "
#~ "multiple wildcards (e.g. ``*.*.com`` or "
#~ "``*a*.example.org``) nor a wildcard inside "
#~ "an internationalized domain names (IDN) "
#~ "fragment. IDN A-labels such as ``www*.xn"
#~ "--pthon-kva.org`` are still supported, but"
#~ " ``x*.python.org`` no longer matches ``xn"
#~ "--tda.python.org``."
#~ msgstr ""
#~ "이 함수는 이제 :rfc:`6125`, 6.4.3절을 따르며 "
#~ "다중 와일드카드(예를 들어, ``*.*.com`` 나 "
#~ "``*a*.example.org``)나 국제화된 도메인 이름(IDN) 내부의 "
#~ "와일드카드와 일치하지 않습니다. ``www*.xn--pthon-"
#~ "kva.org``\\와 같은 IDN A-레이블은 계속 지원되지만, "
#~ "``x*.python.org``\\는 더는 ``xn--tda.python.org``\\와"
#~ " 일치하지 않습니다."

#~ msgid ""
#~ "Matching of IP addresses, when present"
#~ " in the subjectAltName field of the"
#~ " certificate, is now supported."
#~ msgstr "인증서의 subjectAltName 필드에 있을 때, IP 주소의 일치는 이제 지원됩니다."

#~ msgid ""
#~ "The function is no longer used to"
#~ " TLS connections. Hostname matching is "
#~ "now performed by OpenSSL."
#~ msgstr "이 함수는 더는 TLS 연결에 사용되지 않습니다. 이제 호스트 이름 일치는 OpenSSL에 의해 수행됩니다."

#~ msgid ""
#~ "Allow wildcard when it is the "
#~ "leftmost and the only character in "
#~ "that segment. Partial wildcards like "
#~ "``www*.example.com`` are no longer supported."
#~ msgstr ""
#~ "와일드카드가 가장 왼쪽에 있고 그 세그먼트의 유일한 "
#~ "문자일 때 와일드카드를 허용합니다. ``www*.example.com``\\와"
#~ " 같은 부분적인 와일드카드는 더는 지원되지 않습니다."

#~ msgid ""
#~ ":ref:`Availability <availability>`: LibreSSL ignores"
#~ " the environment vars :attr:`openssl_cafile_env`"
#~ " and :attr:`openssl_capath_env`."
#~ msgstr ""
#~ ":ref:`가용성 <availability>`: LibreSSL은 환경 변수 "
#~ ":attr:`openssl_cafile_env`\\와 :attr:`openssl_capath_env`\\를 "
#~ "무시합니다."

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우."

#~ msgid ""
#~ "Takes an instance ``sock`` of "
#~ ":class:`socket.socket`, and returns an "
#~ "instance of :class:`ssl.SSLSocket`, a subtype"
#~ " of :class:`socket.socket`, which wraps the"
#~ " underlying socket in an SSL context."
#~ "  ``sock`` must be a "
#~ ":data:`~socket.SOCK_STREAM` socket; other socket "
#~ "types are unsupported."
#~ msgstr ""
#~ ":class:`socket.socket`\\의 인스턴스 ``sock``\\을 취해서, "
#~ "SSL 컨텍스트에 하부 소켓을 감싸는 "
#~ ":class:`socket.socket`\\의 서브 형인 "
#~ ":class:`ssl.SSLSocket` 인스턴스를 반환합니다. ``sock``\\은 "
#~ ":data:`~socket.SOCK_STREAM` 소켓이어야합니다; 다른 소켓 "
#~ "유형은 지원되지 않습니다."

#~ msgid ""
#~ "Internally, function creates a "
#~ ":class:`SSLContext` with protocol *ssl_version* "
#~ "and :attr:`SSLContext.options` set to "
#~ "*cert_reqs*. If parameters *keyfile*, "
#~ "*certfile*, *ca_certs* or *ciphers* are "
#~ "set, then the values are passed to"
#~ " :meth:`SSLContext.load_cert_chain`, "
#~ ":meth:`SSLContext.load_verify_locations`, and "
#~ ":meth:`SSLContext.set_ciphers`."
#~ msgstr ""
#~ "내부적으로, 함수는 프로토콜이 *ssl_version* 이고 "
#~ ":attr:`SSLContext.options`\\이 *cert_reqs*\\로 설정된 "
#~ ":class:`SSLContext`\\를 만듭니다. 매개 변수 *keyfile*,"
#~ " *certfile*, *ca_certs* 또는 *ciphers*\\가 "
#~ "설정되면, 값은 :meth:`SSLContext.load_cert_chain`, "
#~ ":meth:`SSLContext.load_verify_locations` 및 "
#~ ":meth:`SSLContext.set_ciphers`\\로 전달됩니다."

#~ msgid ""
#~ "The arguments *server_side*, "
#~ "*do_handshake_on_connect*, and *suppress_ragged_eofs* "
#~ "have the same meaning as "
#~ ":meth:`SSLContext.wrap_socket`."
#~ msgstr ""
#~ "인자 *server_side*, *do_handshake_on_connect* 및 "
#~ "*suppress_ragged_eofs*\\는 :meth:`SSLContext.wrap_socket`\\과 "
#~ "같은 의미입니다."

#~ msgid ""
#~ "Since Python 3.2 and 2.7.9, it is"
#~ " recommended to use the "
#~ ":meth:`SSLContext.wrap_socket` instead of "
#~ ":func:`wrap_socket`. The top-level function"
#~ " is limited and creates an insecure"
#~ " client socket without server name "
#~ "indication or hostname matching."
#~ msgstr ""
#~ "파이썬 3.2와 2.7.9부터, :func:`wrap_socket` 대신 "
#~ ":meth:`SSLContext.wrap_socket`\\을 사용하는 것이 좋습니다. "
#~ "최상위 함수는 제한적이고 서버 이름 표시나 호스트 "
#~ "이름 일치가 없는 안전하지 않은 클라이언트 소켓을 "
#~ "만듭니다."

#~ msgid ""
#~ "Auto-negotiate the highest protocol "
#~ "version like :data:`PROTOCOL_TLS`, but only"
#~ " support server-side :class:`SSLSocket` "
#~ "connections."
#~ msgstr ""
#~ ":data:`PROTOCOL_TLS`\\처럼 가장 높은 프로토콜 버전을 "
#~ "자동 협상하지만, 서버 측 :class:`SSLSocket` 연결만"
#~ " 지원합니다."

#~ msgid "Selects SSL version 2 as the channel encryption protocol."
#~ msgstr "채널 암호화 프로토콜로 SSL 버전 2를 선택합니다."

#~ msgid "SSL version 2 is insecure.  Its use is highly discouraged."
#~ msgstr "SSL 버전 2는 안전하지 않습니다. 사용하지 말도록 강력히 권고합니다."

#~ msgid "OpenSSL has removed support for SSLv2."
#~ msgstr "OpenSSL은 SSLv2에 대한 지원을 제거했습니다."

#~ msgid ""
#~ "This protocol is not be available "
#~ "if OpenSSL is compiled with the "
#~ "``OPENSSL_NO_SSLv3`` flag."
#~ msgstr "OpenSSL이 ``OPENSSL_NO_SSLv3`` 플래그로 컴파일되었으면 이 프로토콜을 사용할 수 없습니다."

#~ msgid ""
#~ "Selects TLS version 1.2 as the "
#~ "channel encryption protocol. This is the"
#~ " most modern version, and probably "
#~ "the best choice for maximum protection,"
#~ " if both sides can speak it.  "
#~ "Available only with openssl version "
#~ "1.0.1+."
#~ msgstr ""
#~ "채널 암호화 프로토콜로 TLS 버전 1.2를 선택합니다."
#~ " 이것은 가장 현대적인 버전이며, 양측이 모두 가능하다면"
#~ " 최대한의 보호를 위해 아마도 제일 나은 선택입니다."
#~ " openssl 버전 1.0.1+ 에서만 사용할 수 "
#~ "있습니다."

#~ msgid ""
#~ "To validate a certificate for a "
#~ "particular service, you can use the "
#~ ":func:`match_hostname` function."
#~ msgstr "특정 서비스를 위해 인증서를 유효성 검사하려면, :func:`match_hostname` 함수를 사용할 수 있습니다."

#~ msgid ""
#~ "The :class:`SSLContext` object this SSL "
#~ "socket is tied to.  If the SSL "
#~ "socket was created using the deprecated"
#~ " :func:`wrap_socket` function (rather than "
#~ ":meth:`SSLContext.wrap_socket`), this is a "
#~ "custom context object created for this"
#~ " SSL socket."
#~ msgstr ""
#~ "이 SSL 소켓이 연결된 :class:`SSLContext` 객체."
#~ " SSL 소켓이 폐지된 :func:`wrap_socket` "
#~ "함수(:meth:`SSLContext.wrap_socket`\\이 아니라)를 사용하여 "
#~ "만들어졌으면, 이것은 이 SSL 소켓에 대해 만든 "
#~ "사용자 정의 컨텍스트 객체입니다."

#~ msgid "On OpenSSL 1.1 and newer the cipher dict contains additional fields::"
#~ msgstr "OpenSSL 1.1 이상에서 사이퍼 딕셔너리에는 다음과 같은 추가 필드가 포함됩니다::"

#~ msgid ":ref:`Availability <availability>`: OpenSSL 1.0.2+."
#~ msgstr ":ref:`가용성 <availability>`: OpenSSL 1.0.2+."

#~ msgid ""
#~ "OpenSSL 1.1.0 to 1.1.0e will abort "
#~ "the handshake and raise :exc:`SSLError` "
#~ "when both sides support ALPN but "
#~ "cannot agree on a protocol. 1.1.0f+ "
#~ "behaves like 1.0.2, "
#~ ":meth:`SSLSocket.selected_alpn_protocol` returns None."
#~ msgstr ""
#~ "OpenSSL 1.1.0에서 1.1.0e는 양측이 ALPN을 지원하지만,"
#~ " 프로토콜에 합의할 수 없으면 핸드 셰이크를 중지하고"
#~ " :exc:`SSLError`\\를 발생시킵니다. 1.1.0f+는 1.0.2처럼 "
#~ "동작합니다, :meth:`SSLSocket.selected_alpn_protocol`\\는 None을"
#~ " 반환합니다."

#~ msgid "This features requires OpenSSL 0.9.8f or newer."
#~ msgstr "이 기능을 사용하려면 OpenSSL 0.9.8f 이상이 필요합니다."

#~ msgid ""
#~ "This attribute is not available unless"
#~ " the ssl module is compiled with "
#~ "OpenSSL 1.1.0g or newer."
#~ msgstr "ssl 모듈을 OpenSSL 1.1.0g 이상으로 컴파일하지 않으면 이 어트리뷰트를 사용할 수 없습니다."

#~ msgid ""
#~ "This attribute is not available unless"
#~ " the ssl module is compiled with "
#~ "OpenSSL 1.1.1 or newer."
#~ msgstr "ssl 모듈을 OpenSSL 1.1.1 이상으로 컴파일하지 않으면 이 어트리뷰트를 사용할 수 없습니다."

#~ msgid ""
#~ "With versions of OpenSSL older than "
#~ "0.9.8m, it is only possible to set"
#~ " options, not to clear them.  "
#~ "Attempting to clear an option (by "
#~ "resetting the corresponding bits) will "
#~ "raise a :exc:`ValueError`."
#~ msgstr ""
#~ "0.9.8m보다 오래된 OpenSSL 버전에서는, 옵션을 지우지는 "
#~ "못하고 설정만 할 수 있습니다. (해당 비트를 "
#~ "재설정하여) 옵션을 지우려고 하면 :exc:`ValueError`\\가 "
#~ "발생합니다."

#~ msgid ""
#~ "Only available with OpenSSL 1.1.1 and"
#~ " TLS 1.3 enabled. Without TLS 1.3 "
#~ "support, the property value is None "
#~ "and can't be modified"
#~ msgstr ""
#~ "OpenSSL 1.1.1과 TLS 1.3이 활성화될 때만 "
#~ "사용할 수 있습니다. TLS 1.3을 지원 없이는, "
#~ "프로퍼티 값이 None이며 수정할 수 없습니다."

#~ msgid "Only writeable with OpenSSL 1.1.0 or higher."
#~ msgstr "OpenSSL 1.1.0 이상에서만 쓰기 가능합니다."

#~ msgid ""
#~ "There is no module-level ``wrap_bio()``"
#~ " call like there is for "
#~ ":meth:`~SSLContext.wrap_socket`. An :class:`SSLObject` "
#~ "is always created via an "
#~ ":class:`SSLContext`."
#~ msgstr ""
#~ ":meth:`~SSLContext.wrap_socket` 에 있는 것과 같은 "
#~ "모듈 수준의 ``wrap_bio()`` 호출이 없습니다. "
#~ ":class:`SSLObject`\\는 항상 :class:`SSLContext`\\를 통해"
#~ " 만들어집니다."

#~ msgid "LibreSSL support"
#~ msgstr "LibreSSL 지원"

#~ msgid ""
#~ "LibreSSL is a fork of OpenSSL "
#~ "1.0.1. The ssl module has limited "
#~ "support for LibreSSL. Some features are"
#~ " not available when the ssl module"
#~ " is compiled with LibreSSL."
#~ msgstr ""
#~ "LibreSSL은 OpenSSL 1.0.1 포크입니다. ssl 모듈은"
#~ " LibreSSL을 제한적으로 지원합니다. ssl 모듈이 "
#~ "LibreSSL로 컴파일될 때 일부 기능을 사용할 수 "
#~ "없습니다."

#~ msgid ""
#~ "LibreSSL >= 2.6.1 no longer supports "
#~ "NPN. The methods "
#~ ":meth:`SSLContext.set_npn_protocols` and "
#~ ":meth:`SSLSocket.selected_npn_protocol` are not "
#~ "available."
#~ msgstr ""
#~ "LibreSSL >= 2.6.1은 더는 NPN을 지원하지 "
#~ "않습니다. :meth:`SSLContext.set_npn_protocols`\\와 "
#~ ":meth:`SSLSocket.selected_npn_protocol` 메서드는 사용할 수"
#~ " 없습니다."

#~ msgid ""
#~ ":meth:`SSLContext.set_default_verify_paths` ignores the"
#~ " env vars :envvar:`SSL_CERT_FILE` and "
#~ ":envvar:`SSL_CERT_PATH` although "
#~ ":func:`get_default_verify_paths` still reports them."
#~ msgstr ""
#~ ":meth:`SSLContext.set_default_verify_paths`\\는 비록 "
#~ ":func:`get_default_verify_paths`\\가 여전히 보고하지만, 환경"
#~ " 변수 :envvar:`SSL_CERT_FILE`\\와 "
#~ ":envvar:`SSL_CERT_PATH`\\를 무시합니다."

