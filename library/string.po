# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/string.rst:2
#, fuzzy
msgid ":mod:`!string` --- Common string operations"
msgstr ":mod:`string` --- 일반적인 문자열 연산"

#: ../../library/string.rst:7
msgid "**Source code:** :source:`Lib/string.py`"
msgstr "**소스 코드:** :source:`Lib/string.py`"

#: ../../library/string.rst:14
msgid ":ref:`textseq`"
msgstr ":ref:`textseq`"

#: ../../library/string.rst:16
msgid ":ref:`string-methods`"
msgstr ":ref:`string-methods`"

#: ../../library/string.rst:19
msgid "String constants"
msgstr "문자열 상수"

#: ../../library/string.rst:21
msgid "The constants defined in this module are:"
msgstr "이 모듈에 정의된 상수는 다음과 같습니다:"

#: ../../library/string.rst:26
msgid ""
"The concatenation of the :const:`ascii_lowercase` and "
":const:`ascii_uppercase` constants described below.  This value is not "
"locale-dependent."
msgstr ""
"아래에 나오는 :const:`ascii_lowercase`\\와 :const:`ascii_uppercase` 상수를 이어붙인 "
"것입니다. 이 값은 로케일에 의존적이지 않습니다."

#: ../../library/string.rst:32
msgid ""
"The lowercase letters ``'abcdefghijklmnopqrstuvwxyz'``.  This value is "
"not locale-dependent and will not change."
msgstr "소문자 ``'abcdefghijklmnopqrstuvwxyz'``. 이 값은 로케일에 의존적이지 않고 변경되지 않습니다."

#: ../../library/string.rst:38
msgid ""
"The uppercase letters ``'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``.  This value is "
"not locale-dependent and will not change."
msgstr "대문자 ``'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. 이 값은 로케일에 의존적이지 않고 변경되지 않습니다."

#: ../../library/string.rst:44
msgid "The string ``'0123456789'``."
msgstr "문자열 ``'0123456789'``."

#: ../../library/string.rst:49
msgid "The string ``'0123456789abcdefABCDEF'``."
msgstr "문자열 ``'0123456789abcdefABCDEF'``."

#: ../../library/string.rst:54
msgid "The string ``'01234567'``."
msgstr "문자열 ``'01234567'``."

#: ../../library/string.rst:59
#, python-brace-format
msgid ""
"String of ASCII characters which are considered punctuation characters in"
" the ``C`` locale: ``!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``."
msgstr ""
"``C`` 로케일에서 구두점 문자로 간주하는 ASCII 문자의 문자열: "
"``!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``."

#: ../../library/string.rst:65
#, fuzzy
msgid ""
"String of ASCII characters which are considered printable by Python. This"
" is a combination of :const:`digits`, :const:`ascii_letters`, "
":const:`punctuation`, and :const:`whitespace`."
msgstr ""
"인쇄 가능한 것으로 간주하는 ASCII 문자의 문자열. :const:`digits`, :const:`ascii_letters`, "
":const:`punctuation`, :const:`whitespace` 의 조합입니다."

#: ../../library/string.rst:71
msgid ""
"By design, :meth:`string.printable.isprintable() <str.isprintable>` "
"returns :const:`False`. In particular, ``string.printable`` is not "
"printable in the POSIX sense (see :manpage:`LC_CTYPE <locale(5)>`)."
msgstr ""

#: ../../library/string.rst:78
msgid ""
"A string containing all ASCII characters that are considered whitespace. "
"This includes the characters space, tab, linefeed, return, formfeed, and "
"vertical tab."
msgstr ""
"공백으로 간주하는 모든 ASCII 문자를 포함하는 문자열. 여기에는 스페이스, 탭, 줄 바꿈, 캐리지 리턴, 세로 탭 및 폼 피드 "
"문자가 포함됩니다."

#: ../../library/string.rst:86
msgid "Custom String Formatting"
msgstr "사용자 지정 문자열 포매팅"

#: ../../library/string.rst:88
msgid ""
"The built-in string class provides the ability to do complex variable "
"substitutions and value formatting via the :meth:`~str.format` method "
"described in :pep:`3101`.  The :class:`Formatter` class in the "
":mod:`string` module allows you to create and customize your own string "
"formatting behaviors using the same implementation as the built-in "
":meth:`~str.format` method."
msgstr ""
"내장 문자열 클래스는 :pep:`3101` 에 설명된 :meth:`~str.format` 메서드를 통해 복잡한 변수 치환 및 값 "
"포매팅을 수행할 수 있는 기능을 제공합니다. :mod:`string` 모듈의 :class:`Formatter` 클래스는 내장 "
":meth:`~str.format` 메서드와 같은 구현을 사용하여 자신만의 문자열 포매팅 동작을 만들고 사용자 정의할 수 있게 "
"합니다."

#: ../../library/string.rst:97
msgid "The :class:`Formatter` class has the following public methods:"
msgstr ":class:`Formatter` 클래스에는 다음과 같은 공개 메서드가 있습니다:"

#: ../../library/string.rst:101
msgid ""
"The primary API method.  It takes a format string and an arbitrary set of"
" positional and keyword arguments. It is just a wrapper that calls "
":meth:`vformat`."
msgstr ""
"기본 API 메서드입니다. 포맷 문자열과 임의의 위치 및 키워드 인자의 집합을 받아들입니다. 이것은 :meth:`vformat` 을"
" 호출하는 래퍼일 뿐입니다."

#: ../../library/string.rst:105
msgid ""
"A format string argument is now :ref:`positional-only <positional-"
"only_parameter>`."
msgstr "포맷 문자열 인자는 이제 :ref:`위치 전용 <positional-only_parameter>`\\입니다."

#: ../../library/string.rst:111
msgid ""
"This function does the actual work of formatting.  It is exposed as a "
"separate function for cases where you want to pass in a predefined "
"dictionary of arguments, rather than unpacking and repacking the "
"dictionary as individual arguments using the ``*args`` and ``**kwargs`` "
"syntax.  :meth:`vformat` does the work of breaking up the format string "
"into character data and replacement fields.  It calls the various methods"
" described below."
msgstr ""
"이 함수는 실제 포맷 작업을 수행합니다. ``*args`` 와 ``**kwargs`` 문법을 사용하여 딕셔너리를 개별적인 인자로 언"
" 패킹한 후 다시 패킹하는 대신 미리 정의된 인자 딕셔너리를 전달하고자 하는 경우를 위해 별도의 함수로 노출합니다. "
":meth:`vformat` 은 포맷 문자열을 문자 데이터와 치환 필드로 분리하는 작업을 수행합니다. 아래에 설명된 다양한 메서드를"
" 호출합니다."

#: ../../library/string.rst:119
msgid ""
"In addition, the :class:`Formatter` defines a number of methods that are "
"intended to be replaced by subclasses:"
msgstr "이에 더해, :class:`Formatter` 는 서브 클래스에 의해 대체될 목적으로 많은 메서드를 정의합니다:"

#: ../../library/string.rst:124
msgid ""
"Loop over the format_string and return an iterable of tuples "
"(*literal_text*, *field_name*, *format_spec*, *conversion*).  This is "
"used by :meth:`vformat` to break the string into either literal text, or "
"replacement fields."
msgstr ""
"format_string을 루핑하면서 튜플 (*literal_text*, *field_name*, *format_spec*, "
"*conversion*) 의 이터러블을 반환합니다. 이것은 :meth:`vformat` 이 문자열을 리터럴 텍스트와 치환 필드로 "
"나누는 데 사용합니다."

#: ../../library/string.rst:129
msgid ""
"The values in the tuple conceptually represent a span of literal text "
"followed by a single replacement field.  If there is no literal text "
"(which can happen if two replacement fields occur consecutively), then "
"*literal_text* will be a zero-length string.  If there is no replacement "
"field, then the values of *field_name*, *format_spec* and *conversion* "
"will be ``None``."
msgstr ""
"튜플의 값은 개념적으로 리터럴 텍스트와 그 뒤를 따르는 하나의 치환 필드의 범위를 나타냅니다. 리터럴 텍스트가 없는 경우 (두 개의"
" 치환 필드가 연속적으로 나타나는 경우 발생할 수 있습니다), *literal_text* 는 길이가 0인 문자열입니다. 치환 필드가"
" 없는 경우 *field_name*, *format_spec* 및 *conversion* 값은 ``None`` 입니다."

#: ../../library/string.rst:138
msgid ""
"Given *field_name* as returned by :meth:`parse` (see above), convert it "
"to an object to be formatted.  Returns a tuple (obj, used_key).  The "
"default version takes strings of the form defined in :pep:`3101`, such as"
" \"0[name]\" or \"label.title\".  *args* and *kwargs* are as passed in to"
" :meth:`vformat`.  The return value *used_key* has the same meaning as "
"the *key* parameter to :meth:`get_value`."
msgstr ""
":meth:`parse` 가 반환한 *field_name* 을 (위를 보세요) 포맷될 객체로 변환합니다. 튜플 (obj, "
"used_key) 를 반환합니다. 기본 버전은 \"0[name]\" 이나 \"label.title\"과 같이 :pep:`3101` "
"에 정의된 형식의 문자열을 받아들입니다. *args* 와 *kwargs* 는 :meth:`vformat` 에 전달된 것과 같습니다."
" 반환 값 *used_key* 는 :meth:`get_value` 의 *key* 매개 변수와 같은 의미가 있습니다."

#: ../../library/string.rst:147
msgid ""
"Retrieve a given field value.  The *key* argument will be either an "
"integer or a string.  If it is an integer, it represents the index of the"
" positional argument in *args*; if it is a string, then it represents a "
"named argument in *kwargs*."
msgstr ""
"지정된 필드의 값을 가져옵니다. *key* 인자는 정수 또는 문자열입니다. 정수의 경우, *args* 에 있는 위치 인자의 인덱스를"
" 나타냅니다; 문자열인 경우, *kwargs* 에 있는 이름있는 인자를 나타냅니다."

#: ../../library/string.rst:152
msgid ""
"The *args* parameter is set to the list of positional arguments to "
":meth:`vformat`, and the *kwargs* parameter is set to the dictionary of "
"keyword arguments."
msgstr ""
"*args* 매개 변수는 :meth:`vformat` 의 위치 인자 목록으로 설정되고, *kwargs* 매개 변수는 키워드 인자 "
"딕셔너리로 설정됩니다."

#: ../../library/string.rst:156
msgid ""
"For compound field names, these functions are only called for the first "
"component of the field name; subsequent components are handled through "
"normal attribute and indexing operations."
msgstr ""
"복합 필드 이름의 경우, 이러한 함수는 필드 이름의 첫 번째 구성 요소에 대해서만 호출됩니다; 후속 구성 요소는 일반 어트리뷰트 및"
" 인덱싱 연산을 통해 처리됩니다."

#: ../../library/string.rst:160
msgid ""
"So for example, the field expression '0.name' would cause "
":meth:`get_value` to be called with a *key* argument of 0.  The ``name`` "
"attribute will be looked up after :meth:`get_value` returns by calling "
"the built-in :func:`getattr` function."
msgstr ""
"그래서 예를 들어, 필드 표현식 '0.name' 은 :meth:`get_value` 가 *key* 인자 0으로 호출되도록 합니다. "
"``name`` 어트리뷰트는 :meth:`get_value` 가 반환한 후에 내장 :func:`getattr` 함수를 호출하여 "
"조회합니다."

#: ../../library/string.rst:165
msgid ""
"If the index or keyword refers to an item that does not exist, then an "
":exc:`IndexError` or :exc:`KeyError` should be raised."
msgstr "인덱스 또는 키워드가 존재하지 않는 항목을 참조하면, :exc:`IndexError` 나 :exc:`KeyError` 가 발생합니다."

#: ../../library/string.rst:170
msgid ""
"Implement checking for unused arguments if desired.  The arguments to "
"this function is the set of all argument keys that were actually referred"
" to in the format string (integers for positional arguments, and strings "
"for named arguments), and a reference to the *args* and *kwargs* that was"
" passed to vformat.  The set of unused args can be calculated from these "
"parameters.  :meth:`check_unused_args` is assumed to raise an exception "
"if the check fails."
msgstr ""
"원하는 경우 사용하지 않는 인자를 검사하도록 구현합니다. 이 함수에 대한 인자는 포맷 문자열에서 참조되는 모든 인자 키의 집합과 "
"(위치 인자의 경우 정수, 이름있는 인자의 경우 문자열), vformat 으로 전달된 *args* 와 *kwargs* 에 대한 "
"참조입니다. 사용되지 않은 인자의 집합은 이 매개 변수들로 계산할 수 있습니다. :meth:`check_unused_args` 는 "
"검사가 실패할 경우 예외를 발생시킬 것으로 가정합니다."

#: ../../library/string.rst:180
msgid ""
":meth:`format_field` simply calls the global :func:`format` built-in.  "
"The method is provided so that subclasses can override it."
msgstr ""
":meth:`format_field` 는 단순히 전역 :func:`format` 내장 함수를 호출합니다. 서브 클래스가 재정의할 수"
" 있도록 메서드가 제공됩니다."

#: ../../library/string.rst:185
msgid ""
"Converts the value (returned by :meth:`get_field`) given a conversion "
"type (as in the tuple returned by the :meth:`parse` method).  The default"
" version understands 's' (str), 'r' (repr) and 'a' (ascii) conversion "
"types."
msgstr ""
"(:meth:`get_field` 가 반환한) 값(value)을 (:meth:`parse` 메서드가 반환하는 튜플에 있는 것과 "
"같은) 주어진 변환 유형(conversion)으로 변환합니다. 기본 버전은 's' (str), 'r' (repr) 및 'a' "
"(ascii) 변환 유형을 인식합니다."

#: ../../library/string.rst:194
msgid "Format String Syntax"
msgstr "포맷 문자열 문법"

#: ../../library/string.rst:196
msgid ""
"The :meth:`str.format` method and the :class:`Formatter` class share the "
"same syntax for format strings (although in the case of "
":class:`Formatter`, subclasses can define their own format string "
"syntax).  The syntax is related to that of :ref:`formatted string "
"literals <f-strings>`, but it is less sophisticated and, in particular, "
"does not support arbitrary expressions."
msgstr ""
":meth:`str.format` 메서드와 :class:`Formatter` 클래스는 포맷 문자열에 대해서 같은 문법을 공유합니다 "
"(:class:`Formatter` 의 경우, 서브 클래스는 그들 자신의 포맷 문자열 문법을 정의 할 수 있습니다). 문법은 "
":ref:`포맷 문자열 리터럴 <f-strings>` 과 관련 있지만, 덜 정교하며, 특히 임의의 표현식을 지원하지 않습니다."

#: ../../library/string.rst:209
#, python-brace-format
msgid ""
"Format strings contain \"replacement fields\" surrounded by curly braces "
"``{}``. Anything that is not contained in braces is considered literal "
"text, which is copied unchanged to the output.  If you need to include a "
"brace character in the literal text, it can be escaped by doubling: "
"``{{`` and ``}}``."
msgstr ""
"포맷 문자열에는 중괄호 ``{}`` 로 둘러싸인 \"치환 필드\" 가 들어 있습니다. 중괄호 안에 포함되지 않은 것은 리터럴 "
"텍스트로 간주하며 변경되지 않고 그대로 출력으로 복사됩니다. 리터럴 텍스트에 중괄호를 포함해야 하는 경우, 중복으로 이스케이프 할 "
"수 있습니다: ``{{`` 와 ``}}``."

#: ../../library/string.rst:214
msgid "The grammar for a replacement field is as follows:"
msgstr "치환 필드의 문법은 다음과 같습니다:"

#: ../../library/string.rst:226
msgid ""
"In less formal terms, the replacement field can start with a *field_name*"
" that specifies the object whose value is to be formatted and inserted "
"into the output instead of the replacement field. The *field_name* is "
"optionally followed by a  *conversion* field, which is preceded by an "
"exclamation point ``'!'``, and a *format_spec*, which is preceded by a "
"colon ``':'``.  These specify a non-default format for the replacement "
"value."
msgstr ""
"덜 형식적인 용어로, 치환 필드는 *field_name* 으로 시작할 수 있는데, 값이 포맷되어 출력에 치환 필드 대신 삽입될 "
"객체를 지정합니다. *field_name* 다음에는 선택적으로 느낌표 ``'!'`` 가 앞에 오는 *conversion* 필드와 "
"콜론 ``':'`` 이 앞에 오는 *format_spec* 이 옵니다. 이 값은 치환 값에 대해 기본값이 아닌 포맷을 지정합니다."

#: ../../library/string.rst:233
msgid "See also the :ref:`formatspec` section."
msgstr ":ref:`formatspec` 섹션을 참고하십시오."

#: ../../library/string.rst:235
#, fuzzy
msgid ""
"The *field_name* itself begins with an *arg_name* that is either a number"
" or a keyword.  If it's a number, it refers to a positional argument, and"
" if it's a keyword, it refers to a named keyword argument. An *arg_name* "
"is treated as a number if a call to :meth:`str.isdecimal` on the string "
"would return true. If the numerical arg_names in a format string are 0, "
"1, 2, ... in sequence, they can all be omitted (not just some) and the "
"numbers 0, 1, 2, ... will be automatically inserted in that order. "
"Because *arg_name* is not quote-delimited, it is not possible to specify "
"arbitrary dictionary keys (e.g., the strings ``'10'`` or ``':-]'``) "
"within a format string. The *arg_name* can be followed by any number of "
"index or attribute expressions. An expression of the form ``'.name'`` "
"selects the named attribute using :func:`getattr`, while an expression of"
" the form ``'[index]'`` does an index lookup using "
":meth:`~object.__getitem__`."
msgstr ""
"*field_name* 자체는 숫자나 키워드인 *arg_name* 으로 시작합니다. 숫자면 위치 인자를 나타내고, 키워드면 이름이 "
"있는 키워드 인자를 나타냅니다. 포맷 문자열의 숫자 arg_name이 0, 1, 2, ... 순으로 나열되는 경우, (일부가 "
"아니라) 전부 생략 할 수 있으며 숫자 0, 1, 2, ...이 순서대로 자동 삽입됩니다. *arg_name* 이 따옴표로 분리되어"
" 있지 않기 때문에, 포맷 문자열 내에서 임의의 딕셔너리 키(예를 들어, ``'10'`` 이나 ``':-]'``)를 지정할 수 "
"없습니다. *arg_name* 다음에는 제한 없는 개수의 인덱스나 어트리뷰트 표현식이 올 수 있습니다. ``'.name'`` 형태의"
" 표현식은 :func:`getattr`\\을 사용하여 이름있는 어트리뷰트를 선택하는 반면, ``'[index]'`` 형태의 표현식은"
" :func:`__getitem__` 을 사용해서 인덱스 조회를 합니다."

#: ../../library/string.rst:249
#, python-brace-format
msgid ""
"The positional argument specifiers can be omitted for :meth:`str.format`,"
" so ``'{} {}'.format(a, b)`` is equivalent to ``'{0} {1}'.format(a, b)``."
msgstr ""
"위치 인자 지정자는 :meth:`str.format` 에서 생략 할 수 있습니다. 그래서, ``'{} {}'.format(a, "
"b)`` 는 ``'{0} {1}'.format(a, b)`` 과 동등합니다."

#: ../../library/string.rst:253
msgid "The positional argument specifiers can be omitted for :class:`Formatter`."
msgstr "위치 인자 지정자는 :class:`Formatter`\\에서 생략 할 수 있습니다."

#: ../../library/string.rst:256
msgid "Some simple format string examples::"
msgstr "몇 가지 간단한 포맷 문자열 예제::"

#: ../../library/string.rst:258
#, python-brace-format
msgid ""
"\"First, thou shalt count to {0}\"  # References first positional "
"argument\n"
"\"Bring me a {}\"                   # Implicitly references the first "
"positional argument\n"
"\"From {} to {}\"                   # Same as \"From {0} to {1}\"\n"
"\"My quest is {name}\"              # References keyword argument 'name'\n"
"\"Weight in tons {0.weight}\"       # 'weight' attribute of first "
"positional arg\n"
"\"Units destroyed: {players[0]}\"   # First element of keyword argument "
"'players'."
msgstr ""

#: ../../library/string.rst:265
#, fuzzy
msgid ""
"The *conversion* field causes a type coercion before formatting.  "
"Normally, the job of formatting a value is done by the "
":meth:`~object.__format__` method of the value itself.  However, in some "
"cases it is desirable to force a type to be formatted as a string, "
"overriding its own definition of formatting.  By converting the value to "
"a string before calling :meth:`~object.__format__`, the normal formatting"
" logic is bypassed."
msgstr ""
"*conversion* 필드는 포매팅 전에 형 코어션을 일으킵니다. 보통은, 값을 포매팅하는 작업은 값 자체의 "
":meth:`__format__` 메서드에 의해 수행됩니다. 그러나 어떤 경우에는 형 자신의 포매팅 정의를 무시하고 문자열로 "
"포맷되도록 강제할 필요가 있습니다. :meth:`__format__` 을 호출하기 전에 값을 문자열로 변환하면, 일반적인 포매팅 "
"논리가 무시됩니다."

#: ../../library/string.rst:272
msgid ""
"Three conversion flags are currently supported: ``'!s'`` which calls "
":func:`str` on the value, ``'!r'`` which calls :func:`repr` and ``'!a'`` "
"which calls :func:`ascii`."
msgstr ""
"현재 세 가지 변환 플래그가 지원됩니다: ``'!s'`` 는 값에 :func:`str` 을 호출하고, ``'!r'`` 은 값에 "
":func:`repr` 을 호출하고, ``'!a'`` 는 값에 :func:`ascii` 를 호출합니다."

#: ../../library/string.rst:276
msgid "Some examples::"
msgstr "몇 가지 예::"

#: ../../library/string.rst:278
#, python-brace-format
msgid ""
"\"Harold's a clever {0!s}\"        # Calls str() on the argument first\n"
"\"Bring out the holy {name!r}\"    # Calls repr() on the argument first\n"
"\"More {!a}\"                      # Calls ascii() on the argument first"
msgstr ""

#: ../../library/string.rst:282
msgid ""
"The *format_spec* field contains a specification of how the value should "
"be presented, including such details as field width, alignment, padding, "
"decimal precision and so on.  Each value type can define its own "
"\"formatting mini-language\" or interpretation of the *format_spec*."
msgstr ""
"*format_spec* 필드에는 값을 표시하는 방법에 대한 명세가 포함되어 있는데, 필드 너비, 정렬, 채움, 십진 정밀도 등이 "
"포함됩니다. 각 값 형은 자체 \"포매팅 미니 언어\" 또는 *format_spec* 의 해석을 정의 할 수 있습니다."

#: ../../library/string.rst:287
msgid ""
"Most built-in types support a common formatting mini-language, which is "
"described in the next section."
msgstr "대부분의 내장형은 다음 절에서 설명하는 공통 포매팅 미니 언어를 지원합니다."

#: ../../library/string.rst:290
msgid ""
"A *format_spec* field can also include nested replacement fields within "
"it. These nested replacement fields may contain a field name, conversion "
"flag and format specification, but deeper nesting is not allowed.  The "
"replacement fields within the format_spec are substituted before the "
"*format_spec* string is interpreted. This allows the formatting of a "
"value to be dynamically specified."
msgstr ""
"A *format_spec* 필드는 그 안에 중첩된 치환 필드를 포함할 수도 있습니다. 이러한 중첩 된 치환 필드에는 필드 이름, "
"변환 플래그 및 포맷 명세가 포함될 수 있지만, 더 깊은 중첩은 허용되지 않습니다. format_spec 내의 치환 필드는 "
"*format_spec* 문자열이 해석되기 전에 치환됩니다. 이렇게 해서 값의 포매팅을 동적으로 지정할 수 있게 합니다."

#: ../../library/string.rst:297
msgid "See the :ref:`formatexamples` section for some examples."
msgstr "몇 가지 예제는 :ref:`formatexamples` 섹션을 보십시오."

#: ../../library/string.rst:303
msgid "Format Specification Mini-Language"
msgstr "포맷 명세 미니 언어"

#: ../../library/string.rst:305
msgid ""
"\"Format specifications\" are used within replacement fields contained "
"within a format string to define how individual values are presented (see"
" :ref:`formatstrings` and :ref:`f-strings`). They can also be passed "
"directly to the built-in :func:`format` function.  Each formattable type "
"may define how the format specification is to be interpreted."
msgstr ""
"\"포맷 명세\" 는 포맷 문자열에 포함된 치환 필드 내에서 개별 값의 표시 방법을 정의하는 데 사용됩니다 "
"(:ref:`formatstrings` 과 :ref:`f-strings`\\을 보세요). 이것들은 내장 :func:`format` "
"함수에 직접 전달될 수도 있습니다. 각 포맷 가능한 형은 포맷 명세를 해석하는 방법을 정의 할 수 있습니다."

#: ../../library/string.rst:312
msgid ""
"Most built-in types implement the following options for format "
"specifications, although some of the formatting options are only "
"supported by the numeric types."
msgstr "대부분의 내장형은 포맷 명세에 대해 다음 옵션을 구현하지만, 일부 포맷 옵션은 숫자 형에서만 지원됩니다."

#: ../../library/string.rst:315
msgid ""
"A general convention is that an empty format specification produces the "
"same result as if you had called :func:`str` on the value. A non-empty "
"format specification typically modifies the result."
msgstr ""
"일반적인 관례는 빈 포맷 명세가 값에 :func:`str` 을 호출한 것과 같은 결과를 만드는 것입니다. 비어 있지 않은 포맷 "
"명세는 보통 결과를 수정합니다."

#: ../../library/string.rst:319
msgid "The general form of a *standard format specifier* is:"
msgstr "*표준 포맷 지정자* 의 일반적인 형식은 다음과 같습니다:"

#: ../../library/string.rst:333
#, python-brace-format
msgid ""
"If a valid *align* value is specified, it can be preceded by a *fill* "
"character that can be any character and defaults to a space if omitted. "
"It is not possible to use a literal curly brace (\"``{``\" or \"``}``\") "
"as the *fill* character in a :ref:`formatted string literal <f-strings>` "
"or when using the :meth:`str.format` method.  However, it is possible to "
"insert a curly brace with a nested replacement field.  This limitation "
"doesn't affect the :func:`format` function."
msgstr ""
"유효한 *align* 값이 지정되면, *fill* 문자가 앞에 나올 수 있는데 임의의 문자가 될 수 있고, 생략된 경우에는 "
"스페이스가 기본값으로 사용됩니다. :ref:`포맷 문자열 리터럴 <f-strings>` 에서나 :meth:`str.format` "
"메서드를 사용할 때는, 리터럴 중괄호(\"``{``\" 또는 \"``}``\")를 *fill* 문자로 사용할 수 없습니다. 그러나,"
" 중첩된 치환 필드로 중괄호를 삽입 할 수 있습니다. 이 제한은 :func:`format` 함수에는 영향을 미치지 않습니다."

#: ../../library/string.rst:342
msgid "The meaning of the various alignment options is as follows:"
msgstr "다양한 정렬 옵션의 의미는 다음과 같습니다:"

#: ../../library/string.rst:351 ../../library/string.rst:383
#: ../../library/string.rst:442
msgid "Option"
msgstr "옵션"

#: ../../library/string.rst:351 ../../library/string.rst:383
#: ../../library/string.rst:442 ../../library/string.rst:481
#: ../../library/string.rst:492 ../../library/string.rst:527
msgid "Meaning"
msgstr "의미"

#: ../../library/string.rst:353
msgid "``'<'``"
msgstr "``'<'``"

#: ../../library/string.rst:353
msgid ""
"Forces the field to be left-aligned within the available space (this is "
"the default for most objects)."
msgstr "사용 가능한 공간 내에서 필드가 왼쪽 정렬되도록 합니다 (대부분 객체에서 이것이 기본값입니다)."

#: ../../library/string.rst:356
msgid "``'>'``"
msgstr "``'>'``"

#: ../../library/string.rst:356
msgid ""
"Forces the field to be right-aligned within the available space (this is "
"the default for numbers)."
msgstr "사용 가능한 공간 내에서 필드가 오른쪽 정렬되도록 합니다 (숫자에서 이것이 기본값입니다)."

#: ../../library/string.rst:359
msgid "``'='``"
msgstr "``'='``"

#: ../../library/string.rst:359
#, fuzzy
msgid ""
"Forces the padding to be placed after the sign (if any) but before the "
"digits.  This is used for printing fields in the form '+000000120'. This "
"alignment option is only valid for numeric types, excluding "
":class:`complex`. It becomes the default for numbers when '0' immediately"
" precedes the field width."
msgstr ""
"채움이 부호 (있다면) 뒤에, 숫자 앞에 오도록 강제합니다. 이것은 '+000000120' 형식으로 필드를 인쇄하는 데 사용됩니다."
" 이 정렬 옵션은 숫자 형에게만 유효합니다. 이것은 필드 너비 바로 앞에 '0' 이 있으면 기본값이 됩니다."

#: ../../library/string.rst:366
msgid "``'^'``"
msgstr "``'^'``"

#: ../../library/string.rst:366
msgid "Forces the field to be centered within the available space."
msgstr "사용 가능한 공간 내에서 필드를 가운데에 배치합니다."

#: ../../library/string.rst:370
msgid ""
"Note that unless a minimum field width is defined, the field width will "
"always be the same size as the data to fill it, so that the alignment "
"option has no meaning in this case."
msgstr "최소 필드 너비가 정의되지 않으면, 필드 너비는 항상 필드를 채울 데이터와 같은 크기이므로, 정렬 옵션은 이 경우 의미가 없습니다."

#: ../../library/string.rst:374
msgid ""
"The *sign* option is only valid for number types, and can be one of the "
"following:"
msgstr "*sign* 옵션은 숫자 형에게만 유효하며, 다음 중 하나일 수 있습니다:"

#: ../../library/string.rst:385
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/string.rst:385
#, fuzzy
msgid ""
"Indicates that a sign should be used for both positive as well as "
"negative numbers."
msgstr "음수뿐만 아니라 양수에도 부호를 사용해야 함을 나타냅니다."

#: ../../library/string.rst:388
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/string.rst:388
#, fuzzy
msgid ""
"Indicates that a sign should be used only for negative numbers (this is "
"the default behavior)."
msgstr "음수에 대해서만 부호를 사용해야 함을 나타냅니다 (이것이 기본 동작입니다)."

#: ../../library/string.rst:377 ../../library/string.rst:391
msgid "space"
msgstr "스페이스"

#: ../../library/string.rst:391
#, fuzzy
msgid ""
"Indicates that a leading space should be used on positive numbers, and a "
"minus sign on negative numbers."
msgstr "양수에는 선행 스페이스를 사용하고, 음수에는 마이너스 부호를 사용해야 함을 나타냅니다."

#: ../../library/string.rst:398
msgid ""
"The ``'z'`` option coerces negative zero floating-point values to "
"positive zero after rounding to the format precision.  This option is "
"only valid for floating-point presentation types."
msgstr ""

#: ../../library/string.rst:402
#, fuzzy
msgid "Added the ``'z'`` option (see also :pep:`682`)."
msgstr "``','`` 옵션을 추가했습니다 (:pep:`378` 도 보세요)."

#: ../../library/string.rst:407
#, fuzzy
msgid ""
"The ``'#'`` option causes the \"alternate form\" to be used for the "
"conversion.  The alternate form is defined differently for different "
"types.  This option is only valid for integer, float and complex types. "
"For integers, when binary, octal, or hexadecimal output is used, this "
"option adds the respective prefix ``'0b'``, ``'0o'``, ``'0x'``, or "
"``'0X'`` to the output value. For float and complex the alternate form "
"causes the result of the conversion to always contain a decimal-point "
"character, even if no digits follow it. Normally, a decimal-point "
"character appears in the result of these conversions only if a digit "
"follows it. In addition, for ``'g'`` and ``'G'`` conversions, trailing "
"zeros are not removed from the result."
msgstr ""
"``'#'`` 옵션은 변환에 \"대안 형식\" 이 사용되도록 만듭니다. 대안 형식은 형별로 다르게 정의됩니다. 이 옵션은 정수, "
"실수와 복소수 형에게만 유효합니다. 정수의 경우, 이진수, 8진수 또는 16진수 출력이 사용될 때, 이 옵션은 출력값에 각각 접두사"
" ``'0b'``, ``'0o'`` 또는 ``'0x'`` 를 추가합니다. 실수와 복소수의 경우, 대안 형식은 변환 결과의 소수점 "
"아래 숫자가 없어도 항상 소수점 문자가 포함되게 합니다. 보통은, 소수점 문자는 그 뒤에 숫자가 있는 경우에만 변환 결과에 "
"나타납니다. 이에 더해, ``'g'`` 및 ``'G'`` 변환의 경우 끝에 붙는 0이 결과에서 제거되지 않습니다."

#: ../../library/string.rst:419
#, fuzzy
msgid ""
"The *width* is a decimal integer defining the minimum total field width, "
"including any prefixes, separators, and other formatting characters. If "
"not specified, then the field width will be determined by the content."
msgstr ""
"*width* 는 최소 총 필드 너비를 정의하는 십진 정수인데, 접두사, 구분자 및 다른 포매팅 문자들을 포함합니다. 지정하지 "
"않으면, 필드 너비는 내용에 의해 결정됩니다."

#: ../../library/string.rst:423
#, fuzzy
msgid ""
"When no explicit alignment is given, preceding the *width* field by a "
"zero (``'0'``) character enables sign-aware zero-padding for numeric "
"types, excluding :class:`complex`.  This is equivalent to a *fill* "
"character of ``'0'`` with an *alignment* type of ``'='``."
msgstr ""
"명시적 정렬이 주어지지 않을 때, *width* 필드 앞에 ``'0'`` 문자를 붙이면 숫자 형에 대해 부호를 고려하는 0 채움을 "
"사용할 수 있습니다. 이것은 ``'0'`` 의 *fill* 문자와 ``'='`` 의 *alignment* 유형을 갖는 것과 "
"동등합니다."

#: ../../library/string.rst:428
msgid ""
"Preceding the *width* field by ``'0'`` no longer affects the default "
"alignment for strings."
msgstr ""

#: ../../library/string.rst:433
msgid ""
"The *grouping* option after the *width* field specifies a digit group "
"separator for the integral part of a number. It can be one of the "
"following:"
msgstr ""

#: ../../library/string.rst:444
#, fuzzy
msgid "``','``"
msgstr "``'X'``"

#: ../../library/string.rst:444
msgid ""
"Inserts a comma every 3 digits for integer presentation type ``'d'`` and "
"floating-point presentation types, excluding ``'n'``. For other "
"presentation types, this option is not supported."
msgstr ""

#: ../../library/string.rst:450
#, fuzzy
msgid "``'_'``"
msgstr "``'X'``"

#: ../../library/string.rst:450
#, fuzzy
msgid ""
"Inserts an underscore every 3 digits for integer presentation type "
"``'d'`` and floating-point presentation types, excluding ``'n'``. For "
"integer presentation types ``'b'``, ``'o'``, ``'x'``, and ``'X'``, "
"underscores are inserted every 4 digits. For other presentation types, "
"this option is not supported."
msgstr ""
"``'_'`` 옵션은 부동 소수점 표시 유형 및 정수 표시 유형 ``'d'`` 에 대해 천 단위 구분 기호에 밑줄을 사용하도록 "
"알립니다. 정수 표시 유형 ``'b'``, ``'o'``, ``'x'`` 및 ``'X'`` 의 경우 밑줄이 4자리마다 삽입됩니다. "
"다른 표시 유형의 경우, 이 옵션을 지정하면 에러가 발생합니다."

#: ../../library/string.rst:460
#, fuzzy
msgid "For a locale aware separator, use the ``'n'`` presentation type instead."
msgstr ""
"``','`` 옵션은 천 단위 구분 기호에 쉼표를 사용하도록 알립니다. 로케일을 고려하는 구분자의 경우, 대신 ``'n'`` 정수 "
"표시 유형을 사용하십시오."

#: ../../library/string.rst:462
msgid "Added the ``','`` option (see also :pep:`378`)."
msgstr "``','`` 옵션을 추가했습니다 (:pep:`378` 도 보세요)."

#: ../../library/string.rst:465
msgid "Added the ``'_'`` option (see also :pep:`515`)."
msgstr "``'_'`` 옵션을 추가했습니다 (:pep:`515` 도 보세요)."

#: ../../library/string.rst:468
#, fuzzy
msgid ""
"The *precision* is a decimal integer indicating how many digits should be"
" displayed after the decimal point for presentation types ``'f'`` and "
"``'F'``, or before and after the decimal point for presentation types "
"``'g'`` or ``'G'``.  For string presentation types the field indicates "
"the maximum field size - in other words, how many characters will be used"
" from the field content.  The *precision* is not allowed for integer "
"presentation types."
msgstr ""
"*precision* 는 ``'f'`` 및 ``'F'`` 로 포맷된 부동 소수점 값의 소수점 이하 또는 ``'g'`` 또는 "
"``'G'`` 로 포맷된 부동 소수점 값의 소수점 앞, 뒤로 표시할 숫자의 개수를 나타내는 십진수입니다. 숫자가 아닌 유형의 경우 "
"필드는 최대 필드 크기를 나타냅니다 - 즉, 필드 내용에서 몇 개의 문자가 사용되는지 나타냅니다. 정숫값에는 *precision* "
"이 허용되지 않습니다."

#: ../../library/string.rst:476
msgid "Finally, the *type* determines how the data should be presented."
msgstr "마지막으로 *type* 은 데이터를 표시하는 방법을 결정합니다."

#: ../../library/string.rst:478
msgid "The available string presentation types are:"
msgstr "사용 가능한 문자열 표시 유형은 다음과 같습니다:"

#: ../../library/string.rst:481 ../../library/string.rst:492
#: ../../library/string.rst:527
msgid "Type"
msgstr "유형"

#: ../../library/string.rst:483
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/string.rst:483
msgid "String format. This is the default type for strings and may be omitted."
msgstr "문자열 포맷. 이것은 문자열의 기본 유형이고 생략될 수 있습니다."

#: ../../library/string.rst:486 ../../library/string.rst:515
#: ../../library/string.rst:601
msgid "None"
msgstr "없음"

#: ../../library/string.rst:486
msgid "The same as ``'s'``."
msgstr "``'s'`` 와 같습니다."

#: ../../library/string.rst:489
msgid "The available integer presentation types are:"
msgstr "사용 가능한 정수 표시 유형은 다음과 같습니다:"

#: ../../library/string.rst:494
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/string.rst:494
msgid "Binary format. Outputs the number in base 2."
msgstr "이진 형식. 이진법으로 숫자를 출력합니다."

#: ../../library/string.rst:496
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/string.rst:496
msgid ""
"Character. Converts the integer to the corresponding unicode character "
"before printing."
msgstr "문자. 인쇄하기 전에 정수를 해당 유니코드 문자로 변환합니다."

#: ../../library/string.rst:499
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/string.rst:499
msgid "Decimal Integer. Outputs the number in base 10."
msgstr "십진 정수. 십진법으로 숫자를 출력합니다."

#: ../../library/string.rst:501
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/string.rst:501
msgid "Octal format. Outputs the number in base 8."
msgstr "8진 형식. 8진법으로 숫자를 출력합니다."

#: ../../library/string.rst:503
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/string.rst:503
msgid ""
"Hex format. Outputs the number in base 16, using lower-case letters for "
"the digits above 9."
msgstr "16진 형식. 9보다 큰 숫자의 경우 소문자를 사용하여 16진법으로 숫자를 출력합니다."

#: ../../library/string.rst:506
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/string.rst:506
#, fuzzy
msgid ""
"Hex format. Outputs the number in base 16, using upper-case letters for "
"the digits above 9. In case ``'#'`` is specified, the prefix ``'0x'`` "
"will be upper-cased to ``'0X'`` as well."
msgstr "16진 형식. 9보다 큰 숫자의 경우 대문자를 사용하여 16진법으로 숫자를 출력합니다."

#: ../../library/string.rst:511 ../../library/string.rst:593
msgid "``'n'``"
msgstr "``'n'``"

#: ../../library/string.rst:511
#, fuzzy
msgid ""
"Number. This is the same as ``'d'``, except that it uses the current "
"locale setting to insert the appropriate digit group separators."
msgstr "숫자. 이는 현재 로케일 설정을 사용하여 적절한 숫자 구분 문자를 삽입한다는 점을 제외하고는 ``'d'`` 와 같습니다."

#: ../../library/string.rst:515
msgid "The same as ``'d'``."
msgstr "``'d'`` 와 같습니다."

#: ../../library/string.rst:518
#, fuzzy
msgid ""
"In addition to the above presentation types, integers can be formatted "
"with the floating-point presentation types listed below (except ``'n'`` "
"and ``None``). When doing so, :func:`float` is used to convert the "
"integer to a floating-point number before formatting."
msgstr ""
"위의 표시 유형에 더해, 정수는 아래에 나열된 부동 소수점 표시 유형으로 포맷될 수 있습니다 (``'n'`` 및 ``없음`` "
"제외). 그렇게 할 때, 포매팅 전에 정수를 부동 소수점 숫자로 변환하기 위해 :func:`float` 가 사용됩니다."

#: ../../library/string.rst:523
msgid ""
"The available presentation types for :class:`float` and "
":class:`~decimal.Decimal` values are:"
msgstr ":class:`float` 및 :class:`~decimal.Decimal` 값에 사용할 수 있는 표시 유형은 다음과 같습니다:"

#: ../../library/string.rst:529
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/string.rst:529
#, fuzzy
msgid ""
"Scientific notation. For a given precision ``p``, formats the number in "
"scientific notation with the letter 'e' separating the coefficient from "
"the exponent. The coefficient has one digit before and ``p`` digits after"
" the decimal point, for a total of ``p + 1`` significant digits. With no "
"precision given, uses a precision of ``6`` digits after the decimal point"
" for :class:`float`, and shows all coefficient digits for "
":class:`~decimal.Decimal`.  If ``p=0``, the decimal point is omitted "
"unless the ``#`` option is used."
msgstr ""
"과학적 표기법. 주어진 정밀도 ``p``\\에 대해, 지수에서 계수를 구분하는 문자 'e'를 사용하여 과학적 표기법으로 숫자를 "
"포맷합니다. 계수는 소수점 앞의 한 자리와 소수점 뒤에 ``p`` 자리를 가져서, 총 ``p + 1`` 유효 자릿수를 갖습니다. "
"정밀도가 지정되지 않으면, :class:`float`\\의 경우는 소수점 뒤에 ``6`` 숫자의 정밀도를 사용하고, "
":class:`~decimal.Decimal`\\의 경우는 모든 계수 숫자를 표시합니다. 소수점 뒤에 숫자가 없으면, ``#`` "
"옵션을 사용하지 않는 한 소수점도 제거됩니다."

#: ../../library/string.rst:540
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/string.rst:540
msgid ""
"Scientific notation. Same as ``'e'`` except it uses an upper case 'E' as "
"the separator character."
msgstr "과학적 표기법. 구분 문자로 대문자 'E'\\를 사용한다는 것을 제외하고 ``'e'`` 와 같습니다."

#: ../../library/string.rst:543
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/string.rst:543
#, fuzzy
msgid ""
"Fixed-point notation. For a given precision ``p``, formats the number as "
"a decimal number with exactly ``p`` digits following the decimal point. "
"With no precision given, uses a precision of ``6`` digits after the "
"decimal point for :class:`float`, and uses a precision large enough to "
"show all coefficient digits for :class:`~decimal.Decimal`.  If ``p=0``, "
"the decimal point is omitted unless the ``#`` option is used."
msgstr ""
"고정 소수점 표기법. 주어진 정밀도 ``p``\\에 대해, 소수점 뒤에 정확히 ``p`` 자리가 있는 십진수로 숫자를 포맷합니다. "
"정밀도가 지정되지 않으면, :class:`float`\\의 경우는 소수점 뒤에 ``6`` 숫자의 정밀도를 사용하고, "
":class:`~decimal.Decimal`\\의 경우는 모든 계수 숫자를 표시할 만큼 충분히 큰 정밀도를 사용합니다. 소수점 "
"뒤에 숫자가 없으면, ``#`` 옵션을 사용하지 않는 한 소수점도 제거됩니다."

#: ../../library/string.rst:552
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/string.rst:552
msgid ""
"Fixed-point notation. Same as ``'f'``, but converts ``nan`` to  ``NAN`` "
"and ``inf`` to ``INF``."
msgstr ""
"고정 소수점 표기법. ``'f'`` 와 같지만, ``nan`` 을 ``NAN`` 으로, ``inf`` 를 ``INF`` 로 "
"변환합니다."

#: ../../library/string.rst:555
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/string.rst:555
msgid ""
"General format.  For a given precision ``p >= 1``, this rounds the number"
" to ``p`` significant digits and then formats the result in either fixed-"
"point format or in scientific notation, depending on its magnitude. A "
"precision of ``0`` is treated as equivalent to a precision of ``1``."
msgstr ""
"범용 형식. 주어진 정밀도 ``p >= 1`` 에 대해, 숫자를 유효 숫자 ``p`` 로 자리 올림 한 다음, 결과를 크기에 따라 "
"고정 소수점 형식이나 과학 표기법으로 포맷합니다. 정밀도 ``0``\\은 정밀도 ``1``\\과 동등하게 처리됩니다."

#: ../../library/string.rst:562
msgid ""
"The precise rules are as follows: suppose that the result formatted with "
"presentation type ``'e'`` and precision ``p-1`` would have exponent "
"``exp``.  Then, if ``m <= exp < p``, where ``m`` is -4 for floats and -6 "
"for :class:`Decimals <decimal.Decimal>`, the number is formatted with "
"presentation type ``'f'`` and precision ``p-1-exp``.  Otherwise, the "
"number is formatted with presentation type ``'e'`` and precision ``p-1``."
" In both cases insignificant trailing zeros are removed from the "
"significand, and the decimal point is also removed if there are no "
"remaining digits following it, unless the ``'#'`` option is used."
msgstr ""
"정확한 규칙은 다음과 같습니다: 표시 유형 ``'e'`` 와 정밀도 ``p-1`` 로 포맷된 결과의 지수가 ``exp`` 라고 "
"가정하십시오. 이때 ``-m <= exp < p`` 이면 (여기서 ``m``\\은 float에서 -4이고 "
":class:`Decimal <decimal.Decimal>` 이면 -6입니다), 숫자는 표시 형식 ``'f'`` 와 정밀도 "
"``p-1-exp`` 로 포맷됩니다. 그렇지 않으면, 숫자는 표시 유형 ``'e'`` 와 정밀도 ``p-1`` 로 포맷됩니다. 두 "
"경우 유효하지 않은 후행 0은 모두 유효숫자부에서 제거되고, 뒤에 남아있는 숫자가 없다면 ``'#'`` 옵션이 사용되지 않는 한 "
"소수점도 제거됩니다."

#: ../../library/string.rst:575
msgid ""
"With no precision given, uses a precision of ``6`` significant digits for"
" :class:`float`. For :class:`~decimal.Decimal`, the coefficient of the "
"result is formed from the coefficient digits of the value; scientific "
"notation is used for values smaller than ``1e-6`` in absolute value and "
"values where the place value of the least significant digit is larger "
"than 1, and fixed-point notation is used otherwise."
msgstr ""
"정밀도가 지정되지 않으면, :class:`float`\\의 경우 ``6`` 유효 자릿수의 정밀도를 사용합니다. "
":class:`~decimal.Decimal`\\의 경우, 결과 계수는 값의 계수 숫자로 구성됩니다; 과학적 표기법은 절댓값이 "
"``1e-6`` 보다 작은 값과 최하위 숫자의 자릿값이 1보다 큰 값에 사용되며, 그렇지 않으면 고정 소수점 표기법이 사용됩니다."

#: ../../library/string.rst:584
msgid ""
"Positive and negative infinity, positive and negative zero, and nans, are"
" formatted as ``inf``, ``-inf``, ``0``, ``-0`` and ``nan`` respectively, "
"regardless of the precision."
msgstr ""
"양과 음의 무한대, 양과 음의 0, nans는 정밀도와 무관하게 각각 ``inf``, ``-inf``, ``0``, ``-0``, "
"``nan`` 으로 포맷됩니다."

#: ../../library/string.rst:589
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/string.rst:589
msgid ""
"General format. Same as ``'g'`` except switches to ``'E'`` if the number "
"gets too large. The representations of infinity and NaN are uppercased, "
"too."
msgstr ""
"범용 형식. 숫자가 너무 커지면 ``'E'`` 로 전환하는 것을 제외하고 ``'g'`` 와 같습니다. 무한과 NaN 의 표현도 "
"대문자로 바뀝니다."

#: ../../library/string.rst:593
#, fuzzy
msgid ""
"Number. This is the same as ``'g'``, except that it uses the current "
"locale setting to insert the appropriate digit group separators for the "
"integral part of a number."
msgstr "숫자. 현재 로케일 설정을 사용하여 적절한 숫자 구분 문자를 삽입한다는 점을 제외하면 ``'g'`` 와 같습니다."

#: ../../library/string.rst:598
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/string.rst:598
msgid ""
"Percentage. Multiplies the number by 100 and displays in fixed (``'f'``) "
"format, followed by a percent sign."
msgstr "백분율. 숫자에 100을 곱해서 고정 (``'f'``) 형식으로 표시한 다음 백분율 기호를 붙입니다."

#: ../../library/string.rst:601
#, fuzzy
msgid ""
"For :class:`float` this is like the ``'g'`` type, except that when fixed-"
"point notation is used to format the result, it always includes at least "
"one digit past the decimal point, and switches to the scientific notation"
" when ``exp >= p - 1``.  When the precision is not specified, the latter "
"will be as large as needed to represent the given value faithfully."
msgstr ""
":class:`float`\\의 경우, 고정 소수점 표기법이 결과를 포맷하는데 사용될 때, 소수점 이하로 적어도 하나의 숫자를 항상"
" 포함한다는 점을 제외하면 ``'g'`` 와 같습니다. 사용되는 정밀도는 주어진 값을 충실히 표현하는 데 필요한 만큼 큽니다."

#: ../../library/string.rst:609
msgid ""
"For :class:`~decimal.Decimal`, this is the same as either ``'g'`` or "
"``'G'`` depending on the value of ``context.capitals`` for the current "
"decimal context."
msgstr ""
":class:`~decimal.Decimal`\\의 경우, 현재 십진 컨텍스트의 ``context.capitals`` 값에 따라 "
"``'g'``\\나 ``'G'``\\와 같습니다."

#: ../../library/string.rst:613
msgid ""
"The overall effect is to match the output of :func:`str` as altered by "
"the other format modifiers."
msgstr "전체적인 효과는 :func:`str` 의 출력을 다른 포맷 수정자에 의해 변경된 것처럼 만드는 것입니다."

#: ../../library/string.rst:617
msgid ""
"The result should be correctly rounded to a given precision ``p`` of "
"digits after the decimal point.  The rounding mode for :class:`float` "
"matches that of the :func:`round` builtin.  For "
":class:`~decimal.Decimal`, the rounding mode of the current :ref:`context"
" <decimal-context>` will be used."
msgstr ""

#: ../../library/string.rst:622
msgid ""
"The available presentation types for :class:`complex` are the same as "
"those for :class:`float` (``'%'`` is not allowed).  Both the real and "
"imaginary components of a complex number are formatted as floating-point "
"numbers, according to the specified presentation type.  They are "
"separated by the mandatory sign of the imaginary part, the latter being "
"terminated by a ``j`` suffix.  If the presentation type is missing, the "
"result will match the output of :func:`str` (complex numbers with a non-"
"zero real part are also surrounded by parentheses), possibly altered by "
"other format modifiers."
msgstr ""

#: ../../library/string.rst:635
msgid "Format examples"
msgstr "포맷 예제"

#: ../../library/string.rst:637
msgid ""
"This section contains examples of the :meth:`str.format` syntax and "
"comparison with the old ``%``-formatting."
msgstr "이 절은 :meth:`str.format` 문법의 예와 예전 ``%``-포매팅과의 비교를 포함합니다."

#: ../../library/string.rst:640
#, python-brace-format, python-format
msgid ""
"In most of the cases the syntax is similar to the old ``%``-formatting, "
"with the addition of the ``{}`` and with ``:`` used instead of ``%``. For"
" example, ``'%03.2f'`` can be translated to ``'{:03.2f}'``."
msgstr ""
"대부분은 문법이 예전의 ``%``-포매팅과 유사하며, ``{}`` 가 추가되고 ``%`` 대신 및 ``:`` 이 사용됩니다. 예를 "
"들어, ``'%03.2f'`` 는 ``'{:03.2f}'`` 로 번역될 수 있습니다."

#: ../../library/string.rst:644
msgid ""
"The new format syntax also supports new and different options, shown in "
"the following examples."
msgstr "새 포맷 문법은 다음 예제에 보이는 것과 같이 새롭고 다양한 옵션도 지원합니다."

#: ../../library/string.rst:647
msgid "Accessing arguments by position::"
msgstr "위치로 인자 액세스::"

#: ../../library/string.rst:649
#, python-brace-format
msgid ""
">>> '{0}, {1}, {2}'.format('a', 'b', 'c')\n"
"'a, b, c'\n"
">>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only\n"
"'a, b, c'\n"
">>> '{2}, {1}, {0}'.format('a', 'b', 'c')\n"
"'c, b, a'\n"
">>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence\n"
"'c, b, a'\n"
">>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be "
"repeated\n"
"'abracadabra'"
msgstr ""

#: ../../library/string.rst:660
msgid "Accessing arguments by name::"
msgstr "이름으로 인자 액세스::"

#: ../../library/string.rst:662
#, python-brace-format
msgid ""
">>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', "
"longitude='-115.81W')\n"
"'Coordinates: 37.24N, -115.81W'\n"
">>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}\n"
">>> 'Coordinates: {latitude}, {longitude}'.format(**coord)\n"
"'Coordinates: 37.24N, -115.81W'"
msgstr ""

#: ../../library/string.rst:668
msgid "Accessing arguments' attributes::"
msgstr "인자의 어트리뷰트 액세스::"

#: ../../library/string.rst:670
#, python-brace-format
msgid ""
">>> c = 3-5j\n"
">>> ('The complex number {0} is formed from the real part {0.real} '\n"
"...  'and the imaginary part {0.imag}.').format(c)\n"
"'The complex number (3-5j) is formed from the real part 3.0 and the "
"imaginary part -5.0.'\n"
">>> class Point:\n"
"...     def __init__(self, x, y):\n"
"...         self.x, self.y = x, y\n"
"...     def __str__(self):\n"
"...         return 'Point({self.x}, {self.y})'.format(self=self)\n"
"...\n"
">>> str(Point(4, 2))\n"
"'Point(4, 2)'"
msgstr ""

#: ../../library/string.rst:683
msgid "Accessing arguments' items::"
msgstr "인자의 항목 액세스::"

#: ../../library/string.rst:685
#, python-brace-format
msgid ""
">>> coord = (3, 5)\n"
">>> 'X: {0[0]};  Y: {0[1]}'.format(coord)\n"
"'X: 3;  Y: 5'"
msgstr ""

#: ../../library/string.rst:689
#, python-format
msgid "Replacing ``%s`` and ``%r``::"
msgstr "``%s`` 과 ``%r`` 대체::"

#: ../../library/string.rst:691
#, python-brace-format
msgid ""
">>> \"repr() shows quotes: {!r}; str() doesn't: {!s}\".format('test1', "
"'test2')\n"
"\"repr() shows quotes: 'test1'; str() doesn't: test2\""
msgstr ""

#: ../../library/string.rst:694
msgid "Aligning the text and specifying a width::"
msgstr "텍스트 정렬과 너비 지정::"

#: ../../library/string.rst:696
#, python-brace-format
msgid ""
">>> '{:<30}'.format('left aligned')\n"
"'left aligned                  '\n"
">>> '{:>30}'.format('right aligned')\n"
"'                 right aligned'\n"
">>> '{:^30}'.format('centered')\n"
"'           centered           '\n"
">>> '{:*^30}'.format('centered')  # use '*' as a fill char\n"
"'***********centered***********'"
msgstr ""

#: ../../library/string.rst:705
#, python-format
msgid "Replacing ``%+f``, ``%-f``, and ``% f`` and specifying a sign::"
msgstr "``%+f``, ``%-f``, ``% f`` 대체와 부호 지정::"

#: ../../library/string.rst:707
#, python-brace-format
msgid ""
">>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always\n"
"'+3.140000; -3.140000'\n"
">>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive "
"numbers\n"
"' 3.140000; -3.140000'\n"
">>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as "
"'{:f}; {:f}'\n"
"'3.140000; -3.140000'"
msgstr ""

#: ../../library/string.rst:714
#, python-format
msgid "Replacing ``%x`` and ``%o`` and converting the value to different bases::"
msgstr "``%x``, ``%o`` 대체와 다른 진법으로 값 변환::"

#: ../../library/string.rst:716
#, python-brace-format
msgid ""
">>> # format also supports binary numbers\n"
">>> \"int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}\".format(42)\n"
"'int: 42;  hex: 2a;  oct: 52;  bin: 101010'\n"
">>> # with 0x, 0o, or 0b as prefix:\n"
">>> \"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}\".format(42)\n"
"'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'"
msgstr ""

#: ../../library/string.rst:723
#, fuzzy
msgid "Using the comma or the underscore as a digit group separator::"
msgstr "쉼표를 천 단위 구분자로 사용::"

#: ../../library/string.rst:725
#, python-brace-format
msgid ""
">>> '{:,}'.format(1234567890)\n"
"'1,234,567,890'\n"
">>> '{:_}'.format(1234567890)\n"
"'1_234_567_890'\n"
">>> '{:_b}'.format(1234567890)\n"
"'100_1001_1001_0110_0000_0010_1101_0010'\n"
">>> '{:_x}'.format(1234567890)\n"
"'4996_02d2'"
msgstr ""

#: ../../library/string.rst:734
msgid "Expressing a percentage::"
msgstr "백분율 표현::"

#: ../../library/string.rst:736
#, python-brace-format
msgid ""
">>> points = 19\n"
">>> total = 22\n"
">>> 'Correct answers: {:.2%}'.format(points/total)\n"
"'Correct answers: 86.36%'"
msgstr ""

#: ../../library/string.rst:741
msgid "Using type-specific formatting::"
msgstr "형별 포매팅 사용::"

#: ../../library/string.rst:743
#, python-brace-format, python-format
msgid ""
">>> import datetime\n"
">>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)\n"
">>> '{:%Y-%m-%d %H:%M:%S}'.format(d)\n"
"'2010-07-04 12:15:58'"
msgstr ""

#: ../../library/string.rst:748
msgid "Nesting arguments and more complex examples::"
msgstr "인자 중첩과 보다 복잡한 예제::"

#: ../../library/string.rst:750
#, python-brace-format
msgid ""
">>> for align, text in zip('<^>', ['left', 'center', 'right']):\n"
"...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)\n"
"...\n"
"'left<<<<<<<<<<<<'\n"
"'^^^^^center^^^^^'\n"
"'>>>>>>>>>>>right'\n"
">>>\n"
">>> octets = [192, 168, 0, 1]\n"
">>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)\n"
"'C0A80001'\n"
">>> int(_, 16)\n"
"3232235521\n"
">>>\n"
">>> width = 5\n"
">>> for num in range(5,12):\n"
"...     for base in 'dXob':\n"
"...         print('{0:{width}{base}}'.format(num, base=base, "
"width=width), end=' ')\n"
"...     print()\n"
"...\n"
"    5     5     5   101\n"
"    6     6     6   110\n"
"    7     7     7   111\n"
"    8     8    10  1000\n"
"    9     9    11  1001\n"
"   10     A    12  1010\n"
"   11     B    13  1011"
msgstr ""

#: ../../library/string.rst:782
msgid "Template strings"
msgstr "템플릿 문자열"

#: ../../library/string.rst:784
#, fuzzy
msgid ""
"Template strings provide simpler string substitutions as described in "
":pep:`292`.  A primary use case for template strings is for "
"internationalization (i18n) since in that context, the simpler syntax and"
" functionality makes it easier to translate than other built-in string "
"formatting facilities in Python.  As an example of a library built on "
"template strings for i18n, see the `flufl.i18n "
"<https://flufli18n.readthedocs.io/en/latest/>`_ package."
msgstr ""
"템플릿 문자열은 :pep:`292` 에 설명된 대로 더 간단한 문자열 치환을 제공합니다. 템플릿 문자열의 주요 사례는 "
"국제화(i18n)입니다. 이 문맥에서, 더 간단한 문법과 기능은 파이썬의 다른 내장 문자열 포매팅 기능보다 번역하기 쉽게 만들기 "
"때문입니다. i18n을 위해 템플릿 문자열을 기반으로 구축된 라이브러리의 예는 `flufl.i18n "
"<http://flufli18n.readthedocs.io/en/latest/>`_ 패키지를 보십시오."

#: ../../library/string.rst:794
msgid ""
"Template strings support ``$``-based substitutions, using the following "
"rules:"
msgstr "템플릿 문자열은 다음 규칙을 사용하여 ``$``-기반 치환을 지원합니다:"

#: ../../library/string.rst:796
msgid "``$$`` is an escape; it is replaced with a single ``$``."
msgstr "``$$`` 는 이스케이프입니다. 이것은 하나의 ``$`` 로 치환됩니다."

#: ../../library/string.rst:798
msgid ""
"``$identifier`` names a substitution placeholder matching a mapping key "
"of ``\"identifier\"``.  By default, ``\"identifier\"`` is restricted to "
"any case-insensitive ASCII alphanumeric string (including underscores) "
"that starts with an underscore or ASCII letter.  The first non-identifier"
" character after the ``$`` character terminates this placeholder "
"specification."
msgstr ""
"``$identifier`` 는 매핑 키 ``\"identifier\"`` 와 일치하는 치환 자리 표시자를 지정합니다. 기본적으로,"
" ``\"identifier\"`` 는 밑줄이나 ASCII 알파벳으로 시작하는 대소문자 구분 없는 ASCII 영숫자(밑줄 포함) "
"문자열로 제한됩니다. ``$`` 문자 뒤의 첫 번째 비 식별자 문자는 이 자리 표시자 명세를 종료합니다."

#: ../../library/string.rst:805
#, python-brace-format
msgid ""
"``${identifier}`` is equivalent to ``$identifier``.  It is required when "
"valid identifier characters follow the placeholder but are not part of "
"the placeholder, such as ``\"${noun}ification\"``."
msgstr ""
"``${identifier}`` 는 ``$identifier`` 와 동등합니다. 유효한 식별자 문자가 자리 표시자 뒤에 오지만, "
"자리 표시자의 일부가 아니면 필요합니다, 가령 ``\"${noun}ification\"``."

#: ../../library/string.rst:809
msgid ""
"Any other appearance of ``$`` in the string will result in a "
":exc:`ValueError` being raised."
msgstr "문자열에 다른 방식으로 ``$`` 이 등장하면 :exc:`ValueError` 가 발생합니다."

#: ../../library/string.rst:812
msgid ""
"The :mod:`string` module provides a :class:`Template` class that "
"implements these rules.  The methods of :class:`Template` are:"
msgstr ""
":mod:`string` 모듈은 이 규칙들을 구현하는 :class:`Template` 클래스를 제공합니다. "
":class:`Template` 의 메서드는 다음과 같습니다:"

#: ../../library/string.rst:818
msgid "The constructor takes a single argument which is the template string."
msgstr "생성자는 템플릿 문자열 하나를 받아들입니다."

#: ../../library/string.rst:823
msgid ""
"Performs the template substitution, returning a new string.  *mapping* is"
" any dictionary-like object with keys that match the placeholders in the "
"template.  Alternatively, you can provide keyword arguments, where the "
"keywords are the placeholders.  When both *mapping* and *kwds* are given "
"and there are duplicates, the placeholders from *kwds* take precedence."
msgstr ""
"템플릿 치환을 수행하고, 새 문자열을 반환합니다. *mapping* 은 템플릿의 자리 표시자와 일치하는 키를 가진 임의의 딕셔너리류"
" 객체입니다. 또는, 키워드가 자리 표시자인 키워드 인자를 제공 할 수 있습니다. *mapping* 및 *kwds* 가 모두 "
"제공되고 중복이 있는 경우, *kwds* 의 자리 표시자가 우선합니다."

#: ../../library/string.rst:832
msgid ""
"Like :meth:`substitute`, except that if placeholders are missing from "
"*mapping* and *kwds*, instead of raising a :exc:`KeyError` exception, the"
" original placeholder will appear in the resulting string intact.  Also, "
"unlike with :meth:`substitute`, any other appearances of the ``$`` will "
"simply return ``$`` instead of raising :exc:`ValueError`."
msgstr ""
":meth:`substitute`\\와 비슷하지만, *mapping* 과 *kwds* 에 자리 표시자가 없는 경우, "
":exc:`KeyError` 예외를 발생시키지 않고 원래 자리 표시자가 결과 문자열에 그대로 나타납니다. 또한 "
":meth:`substitute` 와는 달리, ``$`` 가 잘못 사용되는 경우 :exc:`ValueError` 를 일으키는 대신 "
"단순히 ``$`` 를 반환합니다."

#: ../../library/string.rst:838
msgid ""
"While other exceptions may still occur, this method is called \"safe\" "
"because it always tries to return a usable string instead of raising an "
"exception.  In another sense, :meth:`safe_substitute` may be anything "
"other than safe, since it will silently ignore malformed templates "
"containing dangling delimiters, unmatched braces, or placeholders that "
"are not valid Python identifiers."
msgstr ""
"다른 예외가 여전히 발생할 수 있지만, 이 메서드가 항상 예외를 발생시키는 대신 사용 가능한 문자열을 반환하려고 시도하기 때문에 "
"\"안전(safe)\" 하다고 합니다. 다른 의미에서, :meth:`safe_substitute` 는 안전하다고 할 수 없습니다. "
"길 잃은(dangling) 구분 기호, 쌍을 이루지 않는 중괄호, 유효한 파이썬 식별자가 아닌 자리 표시자를 포함하는 잘못된 "
"템플릿을 조용히 무시하기 때문입니다."

#: ../../library/string.rst:848
msgid ""
"Returns false if the template has invalid placeholders that will cause "
":meth:`substitute` to raise :exc:`ValueError`."
msgstr ""

#: ../../library/string.rst:856
msgid ""
"Returns a list of the valid identifiers in the template, in the order "
"they first appear, ignoring any invalid identifiers."
msgstr ""

#: ../../library/string.rst:861
msgid ":class:`Template` instances also provide one public data attribute:"
msgstr ":class:`Template` 인스턴스는 공개 데이터 어트리뷰트도 하나 제공합니다:"

#: ../../library/string.rst:865
msgid ""
"This is the object passed to the constructor's *template* argument.  In "
"general, you shouldn't change it, but read-only access is not enforced."
msgstr ""
"이것은 생성자의 *template* 인자로 전달된 객체입니다. 일반적으로, 변경해서는 안 되지만, 읽기 전용 액세스가 강제되지는 "
"않습니다."

#: ../../library/string.rst:868
msgid "Here is an example of how to use a Template::"
msgstr "다음은 Template 사용 방법의 예입니다::"

#: ../../library/string.rst:870
msgid ""
">>> from string import Template\n"
">>> s = Template('$who likes $what')\n"
">>> s.substitute(who='tim', what='kung pao')\n"
"'tim likes kung pao'\n"
">>> d = dict(who='tim')\n"
">>> Template('Give $who $100').substitute(d)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Invalid placeholder in string: line 1, col 11\n"
">>> Template('$who likes $what').substitute(d)\n"
"Traceback (most recent call last):\n"
"...\n"
"KeyError: 'what'\n"
">>> Template('$who likes $what').safe_substitute(d)\n"
"'tim likes $what'"
msgstr ""

#: ../../library/string.rst:886
msgid ""
"Advanced usage: you can derive subclasses of :class:`Template` to "
"customize the placeholder syntax, delimiter character, or the entire "
"regular expression used to parse template strings.  To do this, you can "
"override these class attributes:"
msgstr ""
"고급 사용법: :class:`Template` 의 서브 클래스를 파생하여, 자리 표시자 문법, 구분 기호 문자 또는 템플릿 문자열을"
" 파싱하는데 사용되는 전체 정규식을 사용자 정의 할 수 있습니다. 이렇게 하려면, 다음 클래스 어트리뷰트를 재정의할 수 있습니다:"

#: ../../library/string.rst:891
msgid ""
"*delimiter* -- This is the literal string describing a placeholder "
"introducing delimiter.  The default value is ``$``.  Note that this "
"should *not* be a regular expression, as the implementation will call "
":meth:`re.escape` on this string as needed.  Note further that you cannot"
" change the delimiter after class creation (i.e. a different delimiter "
"must be set in the subclass's class namespace)."
msgstr ""
"*delimiter* -- 자리 표시자를 도입하는 구분자를 나타내는 리터럴 문자열입니다. 기본값은 ``$`` 입니다. 구현체는 "
"필요할 때 이 문자열에 :meth:`re.escape` 를 호출하므로, 이 문자열은 정규식이 *아니어야* 합니다. 또한, 클래스 "
"생성 후에 구분자를 변경할 수 없습니다 (즉, 다른 구분자는 반드시 서브 클래스의 클래스 이름 공간에 설정해야 합니다)."

#: ../../library/string.rst:898
msgid ""
"*idpattern* -- This is the regular expression describing the pattern for "
"non-braced placeholders.  The default value is the regular expression "
"``(?a:[_a-z][_a-z0-9]*)``.  If this is given and *braceidpattern* is "
"``None`` this pattern will also apply to braced placeholders."
msgstr ""
"*idpattern* -- 중괄호로 둘러싸지 않은 자리 표시자의 패턴을 설명하는 정규식입니다. 기본값은 정규식 "
"``(?a:[_a-z][_a-z0-9]*)`` 입니다. *braceidpattern* 이 ``None`` 인 경우, 이 패턴은 "
"중괄호가 있는 자리 표시자에게도 적용됩니다."

#: ../../library/string.rst:905
msgid ""
"Since default *flags* is ``re.IGNORECASE``, pattern ``[a-z]`` can match "
"with some non-ASCII characters. That's why we use the local ``a`` flag "
"here."
msgstr ""
"기본 *flags* 가 ``re.IGNORECASE`` 이기 때문에, 패턴 ``[a-z]`` 는 비 ASCII 문자와 일치 할 수 "
"있습니다. 이 때문에 정규식에 ``a`` 플래그를 사용했습니다."

#: ../../library/string.rst:909
msgid ""
"*braceidpattern* can be used to define separate patterns used inside and "
"outside the braces."
msgstr "*braceidpattern* 은 중괄호로 싸여있을 때와 그렇지 않을 때 사용되는 별도의 패턴을 정의하는데 사용할 수 있습니다."

#: ../../library/string.rst:913
msgid ""
"*braceidpattern* -- This is like *idpattern* but describes the pattern "
"for braced placeholders.  Defaults to ``None`` which means to fall back "
"to *idpattern* (i.e. the same pattern is used both inside and outside "
"braces). If given, this allows you to define different patterns for "
"braced and unbraced placeholders."
msgstr ""
"*braceidpattern* -- *idpattern* 과 유사하지만, 중괄호로 싸인 자리 표시자에 대한 패턴을 설명합니다. "
"기본값은 ``None`` 인데, *idpattern* 을 사용하는 것을 의미합니다 (즉, 같은 패턴이 중괄호가 있을 때와 없을 때 "
"모두 사용됩니다). 이 값을 주면, 중괄호가 있을 때와 없을 때의 자리 표시자에 서로 다른 패턴을 정의 할 수 있습니다."

#: ../../library/string.rst:921
msgid ""
"*flags* -- The regular expression flags that will be applied when "
"compiling the regular expression used for recognizing substitutions.  The"
" default value is ``re.IGNORECASE``.  Note that ``re.VERBOSE`` will "
"always be added to the flags, so custom *idpattern*\\ s must follow "
"conventions for verbose regular expressions."
msgstr ""
"*flags* -- 치환 인식에 사용되는 정규식을 컴파일할 때 적용될 정규식 플래그입니다. 기본값은 ``re.IGNORECASE``"
" 입니다. ``re.VERBOSE`` 가 항상 플래그에 추가되므로, 사용자 정의 *idpattern* 은 상세한 정규식의 규칙을 "
"따라야 합니다."

#: ../../library/string.rst:929
msgid ""
"Alternatively, you can provide the entire regular expression pattern by "
"overriding the class attribute *pattern*.  If you do this, the value must"
" be a regular expression object with four named capturing groups.  The "
"capturing groups correspond to the rules given above, along with the "
"invalid placeholder rule:"
msgstr ""
"또는, 클래스 어트리뷰트 *pattern* 을 재정의하여 전체 정규식 패턴을 제공 할 수 있습니다. 이렇게 하는 경우, 값은 네 "
"개의 이름있는 캡처 그룹이 있는 정규식 객체여야 합니다. 캡처 그룹은 위에 제공된 규칙과 함께 유효하지 않은 자리 표시자 규칙에 "
"해당합니다:"

#: ../../library/string.rst:935
msgid ""
"*escaped* -- This group matches the escape sequence, e.g. ``$$``, in the "
"default pattern."
msgstr "*escaped* -- 이 그룹은 이스케이프 시퀀스를 일치시킵니다, 예를 들어 기본 패턴에서 ``$$``."

#: ../../library/string.rst:938
msgid ""
"*named* -- This group matches the unbraced placeholder name; it should "
"not include the delimiter in capturing group."
msgstr "*named* -- 이 그룹은 중괄호가 없는 자리 표시자 이름을 일치합니다; 캡처 그룹에 구분자를 포함해서는 안 됩니다."

#: ../../library/string.rst:941
msgid ""
"*braced* -- This group matches the brace enclosed placeholder name; it "
"should not include either the delimiter or braces in the capturing group."
msgstr "*braced* -- 이 그룹은 중괄호로 묶인 자리 표시자 이름을 일치시킵니다; 캡처 그룹에 구분자나 중괄호를 포함해서는 안 됩니다."

#: ../../library/string.rst:944
msgid ""
"*invalid* -- This group matches any other delimiter pattern (usually a "
"single delimiter), and it should appear last in the regular expression."
msgstr "*invalid* -- 이 그룹은 그 외의 구분자 패턴(일반적으로 단일 구분자)을 일치시키고, 정규식의 마지막에 나타나야 합니다."

#: ../../library/string.rst:947
msgid ""
"The methods on this class will raise :exc:`ValueError` if the pattern "
"matches the template without one of these named groups matching."
msgstr ""

#: ../../library/string.rst:952
msgid "Helper functions"
msgstr "도움 함수"

#: ../../library/string.rst:956
msgid ""
"Split the argument into words using :meth:`str.split`, capitalize each "
"word using :meth:`str.capitalize`, and join the capitalized words using "
":meth:`str.join`.  If the optional second argument *sep* is absent or "
"``None``, runs of whitespace characters are replaced by a single space "
"and leading and trailing whitespace are removed, otherwise *sep* is used "
"to split and join the words."
msgstr ""
"인자를 :meth:`str.split` 을 사용하여 단어로 나누고, :meth:`str.capitalize` 를 사용하여 각 단어의"
" 첫 글자를 대문자로 만들고, 이렇게 만들어진 단어들을 :meth:`str.join` 을 사용하여 결합합니다. 선택적 두 번째 인자"
" *sep* 가 없거나 ``None`` 이면, 연속된 공백 문자는 단일 스페이스로 바뀌고 앞뒤 공백이 제거됩니다. 그렇지 않으면 "
"*sep* 가 단어를 나누고 합치는 데 사용됩니다."

#: ../../library/string.rst:202
#, python-brace-format
msgid "{} (curly brackets)"
msgstr ""

#: ../../library/string.rst:202 ../../library/string.rst:344
#: ../../library/string.rst:377 ../../library/string.rst:396
#: ../../library/string.rst:405 ../../library/string.rst:437
#, fuzzy
msgid "in string formatting"
msgstr "사용자 지정 문자열 포매팅"

#: ../../library/string.rst:202
msgid ". (dot)"
msgstr ""

#: ../../library/string.rst:202
msgid "[] (square brackets)"
msgstr ""

#: ../../library/string.rst:202
msgid "! (exclamation)"
msgstr ""

#: ../../library/string.rst:202
msgid ": (colon)"
msgstr ""

#: ../../library/string.rst:344
msgid "< (less)"
msgstr ""

#: ../../library/string.rst:344
msgid "> (greater)"
msgstr ""

#: ../../library/string.rst:344
msgid "= (equals)"
msgstr ""

#: ../../library/string.rst:344
msgid "^ (caret)"
msgstr ""

#: ../../library/string.rst:377
msgid "+ (plus)"
msgstr ""

#: ../../library/string.rst:377
msgid "- (minus)"
msgstr ""

#: ../../library/string.rst:396
msgid "z"
msgstr ""

#: ../../library/string.rst:405
msgid "# (hash)"
msgstr ""

#: ../../library/string.rst:437
msgid ", (comma)"
msgstr ""

#: ../../library/string.rst:437
msgid "_ (underscore)"
msgstr ""

#: ../../library/string.rst:792
msgid "$ (dollar)"
msgstr ""

#: ../../library/string.rst:792
#, fuzzy
msgid "in template strings"
msgstr "템플릿 문자열"

