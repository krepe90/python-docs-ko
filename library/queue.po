# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/queue.rst:2
#, fuzzy
msgid ":mod:`!queue` --- A synchronized queue class"
msgstr ":mod:`queue` --- 동기화된 큐 클래스"

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**소스 코드:** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues."
" It is especially useful in threaded programming when information must be"
" exchanged safely between multiple threads.  The :class:`Queue` class in "
"this module implements all the required locking semantics."
msgstr ""
":mod:`queue` 모듈은 다중 생산자, 다중 소비자 큐를 구현합니다. 정보가 여러 스레드 간에 안전하게 교환되어야 할 때 "
"스레드 프로그래밍에서 특히 유용합니다. 이 모듈의 :class:`Queue` 클래스는 필요한 모든 로킹 개념을 구현합니다."

#: ../../library/queue.rst:16
#, fuzzy
msgid ""
"The module implements three types of queue, which differ only in the "
"order in which the entries are retrieved.  In a :abbr:`FIFO (first-in, "
"first-out)` queue, the first tasks added are the first retrieved.  In a "
":abbr:`LIFO (last-in, first-out)` queue, the most recently added entry is"
" the first retrieved (operating like a stack).  With a priority queue, "
"the entries are kept sorted (using the :mod:`heapq` module) and the "
"lowest valued entry is retrieved first."
msgstr ""
"모듈은 항목을 꺼내는 순서 만 다른 3가지 유형의 큐를 구현합니다. :abbr:`FIFO (선입선출, first-in, first-"
"out)` 큐에서는, 추가된 첫 번째 작업이 처음으로 꺼내지는 작업입니다. :abbr:`LIFO (후입선출, last-in, "
"first-out)` 큐에서는, 가장 최근에 추가된 항목이 처음으로 꺼내지는 항목입니다 (스택처럼 작동합니다). "
"우선순위(priority) 큐에서는, 항목이 정렬된 상태로 유지되고 (:mod:`heapq` 모듈을 사용합니다) 가장 낮은 값을 "
"갖는 항목이 먼저 꺼내집니다."

#: ../../library/queue.rst:24
msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"내부적으로, 이러한 3가지 유형의 큐는 록을 사용하여 경쟁 스레드를 일시적으로 블록합니다; 그러나, 스레드 내에서의 재진입을 "
"처리하도록 설계되지는 않았습니다."

#: ../../library/queue.rst:28
msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, "
"first-out)` queue type, :class:`SimpleQueue`, whose specific "
"implementation provides additional guarantees in exchange for the smaller"
" functionality."
msgstr ""
"또한, 이 모듈은 \"간단한\" :abbr:`FIFO (선입선출, first-in, first-out)` 큐 유형인 "
":class:`SimpleQueue`\\를 구현합니다. 이 특정 구현은 작은 기능을 포기하는 대신 추가 보장을 제공합니다."

#: ../../library/queue.rst:33
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr ":mod:`queue` 모듈은 다음 클래스와 예외를 정의합니다:"

#: ../../library/queue.rst:37
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is"
" an integer that sets the upperbound limit on the number of items that "
"can be placed in the queue.  Insertion will block once this size has been"
" reached, until queue items are consumed.  If *maxsize* is less than or "
"equal to zero, the queue size is infinite."
msgstr ""
":abbr:`FIFO (선입선출, first-in, first-out)` 큐의 생성자. *maxsize*\\는 큐에 배치할 수 있는"
" 항목 수에 대한 상한을 설정하는 정수입니다. 일단, 이 크기에 도달하면, 큐 항목이 소비될 때까지 삽입이 블록 됩니다. "
"*maxsize*\\가 0보다 작거나 같으면, 큐 크기는 무한합니다."

#: ../../library/queue.rst:45
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is "
"an integer that sets the upperbound limit on the number of items that can"
" be placed in the queue.  Insertion will block once this size has been "
"reached, until queue items are consumed.  If *maxsize* is less than or "
"equal to zero, the queue size is infinite."
msgstr ""
":abbr:`LIFO (후임선출, last-in, first-out)` 큐의 생성자. *maxsize*\\는 큐에 배치할 수 있는 "
"항목 수에 대한 상한을 설정하는 정수입니다. 일단, 이 크기에 도달하면, 큐 항목이 소비될 때까지 삽입이 블록 됩니다. "
"*maxsize*\\가 0보다 작거나 같으면, 큐 크기는 무한합니다."

#: ../../library/queue.rst:54
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue."
"  Insertion will block once this size has been reached, until queue items"
" are consumed.  If *maxsize* is less than or equal to zero, the queue "
"size is infinite."
msgstr ""
"우선순위 큐의 생성자. *maxsize*\\는 큐에 배치할 수 있는 항목 수에 대한 상한을 설정하는 정수입니다. 일단, 이 크기에 "
"도달하면, 큐 항목이 소비될 때까지 삽입이 블록 됩니다. *maxsize*\\가 0보다 작거나 같으면, 큐 크기는 무한합니다."

#: ../../library/queue.rst:59
#, fuzzy
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is"
" the one that would be returned by ``min(entries)``).  A typical pattern "
"for entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"가장 낮은 값을 갖는 항목이 먼저 꺼내집니다 (가장 낮은 값을 갖는 항목은 ``sorted(list(entries))[0]`` 에 "
"의해 반환되는 항목입니다). 항목의 전형적인 패턴은 ``(priority_number, data)`` 형식의 튜플입니다."

#: ../../library/queue.rst:63
msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr "*data* 요소를 비교할 수 없으면, 데이터는 데이터 항목을 무시하고 우선순위 숫자만 비교하는 클래스로 감쌀 수 있습니다::"

#: ../../library/queue.rst:66
msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""

#: ../../library/queue.rst:76
msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"상한 없는 :abbr:`FIFO (선입선출, first-in, first-out)` 큐의 생성자. 단순 큐에는 작업 추적과 같은 "
"고급 기능이 없습니다."

#: ../../library/queue.rst:84
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or "
":meth:`~Queue.get_nowait`) is called on a :class:`Queue` object which is "
"empty."
msgstr ""
"비 블로킹 :meth:`~Queue.get`\\(또는 :meth:`~Queue.get_nowait`)이 비어있는 "
":class:`Queue` 객체에 호출될 때 발생하는 예외."

#: ../../library/queue.rst:91
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or "
":meth:`~Queue.put_nowait`) is called on a :class:`Queue` object which is "
"full."
msgstr ""
"비 블로킹 :meth:`~Queue.put`\\(또는 :meth:`~Queue.put_nowait`)이 가득 찬 "
":class:`Queue` 객체에 호출될 때 발생하는 예외."

#: ../../library/queue.rst:98
#, fuzzy
msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called "
"on a :class:`Queue` object which has been shut down."
msgstr ""
"비 블로킹 :meth:`~Queue.get`\\(또는 :meth:`~Queue.get_nowait`)이 비어있는 "
":class:`Queue` 객체에 호출될 때 발생하는 예외."

#: ../../library/queue.rst:107
msgid "Queue Objects"
msgstr "큐 객체"

#: ../../library/queue.rst:109
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or "
":class:`PriorityQueue`) provide the public methods described below."
msgstr ""
"큐 객체(:class:`Queue`, :class:`LifoQueue` 또는 :class:`PriorityQueue`)는 아래에 "
"설명된 공용 메서드를 제공합니다."

#: ../../library/queue.rst:115
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < "
"maxsize guarantee that put() will not block."
msgstr ""
"큐의 대략의 크기를 돌려줍니다. 주의하십시오, qsize() > 0 은 후속 get()이 블록 되지 않는다는 것을 보장하지 않으며,"
" qsize() < maxsize 도 put()이 블록 되지 않는다고 보장하지 않습니다."

#: ../../library/queue.rst:122
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() "
"will not block.  Similarly, if empty() returns ``False`` it doesn't "
"guarantee that a subsequent call to get() will not block."
msgstr ""
"큐가 비어 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. empty()가 ``True``\\를 "
"반환하면, put()에 대한 후속 호출이 블록 되지 않는다고 보장하는 것은 아닙니다. 마찬가지로 empty()가 "
"``False``\\를 반환하면, get()에 대한 후속 호출이 블록 되지 않는다고 보장하는 것은 아닙니다."

#: ../../library/queue.rst:130
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() "
"will not block.  Similarly, if full() returns ``False`` it doesn't "
"guarantee that a subsequent call to put() will not block."
msgstr ""
"큐가 가득 차면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. full()이 ``True``\\를 "
"반환하면, get()에 대한 후속 호출이 블록 되지 않는다고 보장하는 것은 아닙니다. 마찬가지로 full()이 "
"``False``\\를 반환하면, put()에 대한 후속 호출이 블록 되지 않는다고 보장하는 것은 아닙니다."

#: ../../library/queue.rst:138
#, fuzzy
msgid ""
"Put *item* into the queue.  If optional args *block* is true and "
"*timeout* is ``None`` (the default), block if necessary until a free slot"
" is available.  If *timeout* is a positive number, it blocks at most "
"*timeout* seconds and raises the :exc:`Full` exception if no free slot "
"was available within that time. Otherwise (*block* is false), put an item"
" on the queue if a free slot is immediately available, else raise the "
":exc:`Full` exception (*timeout* is ignored in that case)."
msgstr ""
"큐에 *item*\\을 넣습니다. 선택적 인자 *block*\\이 참이고 *timeout*\\이 ``None``\\(기본값)이면, "
"사용 가능한 슬롯이 확보될 때까지 필요하면 블록합니다. *timeout*\\이 양수면, 최대 *timeout* 초 동안 블록하고 그"
" 시간 내에 사용 가능한 슬롯이 없으면 :exc:`Full` 예외가 발생합니다. 그렇지 않으면 (*block*\\이 거짓), 빈 "
"슬롯이 즉시 사용할 수 있으면 큐에 항목을 넣고, 그렇지 않으면 :exc:`Full` 예외를 발생시킵니다 (이때 "
"*timeout*\\은 무시됩니다)."

#: ../../library/queue.rst:146
msgid "Raises :exc:`ShutDown` if the queue has been shut down."
msgstr ""

#: ../../library/queue.rst:151
#, fuzzy
msgid "Equivalent to ``put(item, block=False)``."
msgstr "``put(item, False)``\\와 동등합니다."

#: ../../library/queue.rst:156 ../../library/queue.rst:297
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"true and *timeout* is ``None`` (the default), block if necessary until an"
" item is available. If *timeout* is a positive number, it blocks at most "
"*timeout* seconds and raises the :exc:`Empty` exception if no item was "
"available within that time. Otherwise (*block* is false), return an item "
"if one is immediately available, else raise the :exc:`Empty` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"큐에서 항목을 제거하고 반환합니다. 선택적 인자 *block*\\이 참이고 *timeout*\\이 ``None``\\(기본값)이면,"
" 항목이 사용 가능할 때까지 필요하면 블록합니다. *timeout*\\이 양수면, 최대 *timeout* 초 동안 블록하고 그 시간"
" 내에 사용 가능한 항목이 없으면 :exc:`Empty` 예외가 발생합니다. 그렇지 않으면 (*block*\\이 거짓), 즉시 "
"사용할 수 있는 항목이 있으면 반환하고, 그렇지 않으면 :exc:`Empty` 예외를 발생시킵니다 (이때 *timeout*\\은 "
"무시됩니다)."

#: ../../library/queue.rst:163
#, fuzzy
msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if "
"*block* is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no "
"exceptions can occur, and in particular a SIGINT will not trigger a "
":exc:`KeyboardInterrupt`."
msgstr ""
"POSIX 시스템에서 3.0 이전에서, 윈도우의 모든 버전에서, *block*\\이 참이고 *timeout*\\이 "
"``None``\\이면, 이 연산은 하부 록에 대한 중단되지 않는(uninterruptible) 대기로 들어갑니다. 이는 어떤 "
"예외도 발생할 수 없음을 뜻하고, 특히 SIGINT가 :exc:`KeyboardInterrupt`\\를 일으키지 않습니다."

#: ../../library/queue.rst:168
msgid ""
"Raises :exc:`ShutDown` if the queue has been shut down and is empty, or "
"if the queue has been shut down immediately."
msgstr ""

#: ../../library/queue.rst:174 ../../library/queue.rst:307
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)``\\와 동등합니다."

#: ../../library/queue.rst:176
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have "
"been fully processed by daemon consumer threads."
msgstr "큐에 넣은 작업이 데몬 소비자 스레드에 의해 완전히 처리되었는지를 추적하는 것을 지원하는 두 가지 메서드가 제공됩니다."

#: ../../library/queue.rst:182
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue "
"consumer threads.  For each :meth:`get` used to fetch a task, a "
"subsequent call to :meth:`task_done` tells the queue that the processing "
"on the task is complete."
msgstr ""
"앞서 큐에 넣은 작업이 완료되었음을 나타냅니다. 큐 소비자 스레드에서 사용됩니다. 작업을 꺼내는 데 사용되는 "
":meth:`get`\\마다, 후속 :meth:`task_done` 호출은 작업에 대한 처리가 완료되었음을 큐에 알려줍니다."

#: ../../library/queue.rst:186
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items "
"have been processed (meaning that a :meth:`task_done` call was received "
"for every item that had been :meth:`put` into the queue)."
msgstr ""
":meth:`join`\\이 현재 블로킹 중이면, 모든 항목이 처리되면 (큐로 :meth:`put` 된 모든 항목에 대해 "
":meth:`task_done` 호출이 수신되었음을 뜻합니다) 재개됩니다."

#: ../../library/queue.rst:190
msgid ""
"``shutdown(immediate=True)`` calls :meth:`task_done` for each remaining "
"item in the queue."
msgstr ""

#: ../../library/queue.rst:193
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items "
"placed in the queue."
msgstr "큐에 있는 항목보다 더 많이 호출되면 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/queue.rst:199
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "큐의 모든 항목을 꺼내서 처리할 때까지 블록합니다."

#: ../../library/queue.rst:201
#, fuzzy
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls "
":meth:`task_done` to indicate that the item was retrieved and all work on"
" it is complete.  When the count of unfinished tasks drops to zero, "
":meth:`join` unblocks."
msgstr ""
"완료되지 않은 작업 카운트는 항목이 큐에 추가될 때마다 올라갑니다. 소비자 스레드가 :meth:`task_done`\\을 호출해서 "
"항목을 꺼내고 작업이 모두 완료되었음을 나타낼 때마다 카운트가 내려갑니다. 완료되지 않은 작업 카운트가 0으로 떨어지면, "
":meth:`join`\\이 블록 해제됩니다."

#: ../../library/queue.rst:207
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "큐에 포함된 작업이 완료될 때까지 대기하는 방법의 예::"

#: ../../library/queue.rst:209
#, python-brace-format
msgid ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"
msgstr ""

#: ../../library/queue.rst:234
msgid "Terminating queues"
msgstr ""

#: ../../library/queue.rst:236
msgid ""
":class:`Queue` objects can be made to prevent further interaction by "
"shutting them down."
msgstr ""

#: ../../library/queue.rst:241
msgid ""
"Shut down the queue, making :meth:`~Queue.get` and :meth:`~Queue.put` "
"raise :exc:`ShutDown`."
msgstr ""

#: ../../library/queue.rst:244
msgid ""
"By default, :meth:`~Queue.get` on a shut down queue will only raise once "
"the queue is empty. Set *immediate* to true to make :meth:`~Queue.get` "
"raise immediately instead."
msgstr ""

#: ../../library/queue.rst:248
msgid ""
"All blocked callers of :meth:`~Queue.put` and :meth:`~Queue.get` will be "
"unblocked. If *immediate* is true, a task will be marked as done for each"
" remaining item in the queue, which may unblock callers of "
":meth:`~Queue.join`."
msgstr ""

#: ../../library/queue.rst:257
msgid "SimpleQueue Objects"
msgstr "SimpleQueue 객체"

#: ../../library/queue.rst:259
msgid ":class:`SimpleQueue` objects provide the public methods described below."
msgstr ":class:`SimpleQueue` 객체는 아래에서 설명하는 공용 메서드를 제공합니다."

#: ../../library/queue.rst:263
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"큐의 대략의 크기를 돌려줍니다.  주의하십시오, qsize() > 0 은 후속 get()이 블록 되지 않는다는 것을 보장하지 "
"않습니다."

#: ../../library/queue.rst:269
#, fuzzy
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() "
"will not block."
msgstr ""
"큐가 비어 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. empty()가 ``False``\\를 "
"반환하면, get()에 대한 후속 호출이 블록 되지 않는다는 것을 보장하지는 않습니다."

#: ../../library/queue.rst:276
msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate "
"memory). The optional args *block* and *timeout* are ignored and only "
"provided for compatibility with :meth:`Queue.put`."
msgstr ""
"*item*\\을 큐에 넣습니다. 이 메서드는 결코 블록하지 않고 항상 성공합니다 (메모리 할당 실패와 같은 잠재적 저수준 에러 "
"제외). 선택적 인자 *block*\\과 *timeout*\\은 무시되고 :meth:`Queue.put`\\과의 호환성을 위해서만 "
"제공됩니다."

#: ../../library/queue.rst:282
msgid ""
"This method has a C implementation which is reentrant.  That is, a "
"``put()`` or ``get()`` call can be interrupted by another ``put()`` call "
"in the same thread without deadlocking or corrupting internal state "
"inside the queue.  This makes it appropriate for use in destructors such "
"as ``__del__`` methods or :mod:`weakref` callbacks."
msgstr ""

#: ../../library/queue.rst:291
#, fuzzy
msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with"
" :meth:`Queue.put_nowait`."
msgstr "``put(item)``\\과 동등합니다, :meth:`Queue.put_nowait`\\와의 호환성을 위해 제공됩니다."

#: ../../library/queue.rst:312
msgid "Class :class:`multiprocessing.Queue`"
msgstr ":class:`multiprocessing.Queue` 클래스"

#: ../../library/queue.rst:313
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading)"
" context."
msgstr "(다중 스레드 대신) 다중 프로세스 문맥에서 사용하기 위한 큐 클래스."

#: ../../library/queue.rst:316
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and "
":meth:`~collections.deque.popleft` operations that do not require locking"
" and also support indexing."
msgstr ""
":class:`collections.deque`\\는 록을 필요로하지 않고 인덱싱을 지원하는 빠른 원자적 "
":meth:`~collections.deque.append`\\와 :meth:`~collections.deque.popleft` "
"연산을 제공하는 크기 제한 없는 큐의 대체 구현입니다."

#~ msgid ""
#~ "Remove and return an item from the"
#~ " queue. If optional args *block* is"
#~ " true and *timeout* is ``None`` (the"
#~ " default), block if necessary until "
#~ "an item is available. If *timeout* "
#~ "is a positive number, it blocks at"
#~ " most *timeout* seconds and raises "
#~ "the :exc:`Empty` exception if no item"
#~ " was available within that time. "
#~ "Otherwise (*block* is false), return an"
#~ " item if one is immediately "
#~ "available, else raise the :exc:`Empty` "
#~ "exception (*timeout* is ignored in that"
#~ " case)."
#~ msgstr ""
#~ "큐에서 항목을 제거하고 반환합니다. 선택적 인자 "
#~ "*block*\\이 참이고 *timeout*\\이 ``None``\\(기본값)이면, "
#~ "항목이 사용 가능할 때까지 필요하면 블록합니다. "
#~ "*timeout*\\이 양수면, 최대 *timeout* 초 동안 "
#~ "블록하고 그 시간 내에 사용 가능한 항목이 없으면"
#~ " :exc:`Empty` 예외가 발생합니다. 그렇지 않으면 "
#~ "(*block*\\이 거짓), 즉시 사용할 수 있는 항목이"
#~ " 있으면 반환하고, 그렇지 않으면 :exc:`Empty` 예외를"
#~ " 발생시킵니다 (이때 *timeout*\\은 무시됩니다)."

