# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/asyncio-future.rst:8
msgid "Futures"
msgstr "퓨처"

#: ../../library/asyncio-future.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/futures.py`, "
":source:`Lib/asyncio/base_futures.py`"
msgstr ""
"**소스 코드:** :source:`Lib/asyncio/futures.py`, "
":source:`Lib/asyncio/base_futures.py`"

#: ../../library/asyncio-future.rst:15
msgid ""
"*Future* objects are used to bridge **low-level callback-based code** "
"with high-level async/await code."
msgstr "*Future* 객체는 **저수준 콜백 기반 코드**\\와 고수준 async/await 코드 간에 다리를 놓는 데 사용됩니다."

#: ../../library/asyncio-future.rst:20
msgid "Future Functions"
msgstr "퓨처 함수"

#: ../../library/asyncio-future.rst:24
msgid "Return ``True`` if *obj* is either of:"
msgstr "*obj*\\가 다음 중 하나면 ``True``\\를 반환합니다:"

#: ../../library/asyncio-future.rst:26
msgid "an instance of :class:`asyncio.Future`,"
msgstr ":class:`asyncio.Future`\\의 인스턴스,"

#: ../../library/asyncio-future.rst:27
msgid "an instance of :class:`asyncio.Task`,"
msgstr ":class:`asyncio.Task`\\의 인스턴스,"

#: ../../library/asyncio-future.rst:28
msgid "a Future-like object with a ``_asyncio_future_blocking`` attribute."
msgstr "``_asyncio_future_blocking`` 어트리뷰트를 가진 퓨처류 객체."

#: ../../library/asyncio-future.rst:36
msgid "Return:"
msgstr "다음을 반환합니다:"

#: ../../library/asyncio-future.rst:38
msgid ""
"*obj* argument as is, if *obj* is a :class:`Future`, a :class:`Task`, or "
"a Future-like object (:func:`isfuture` is used for the test.)"
msgstr ""
"*obj*\\가 :class:`Future`, :class:`Task` 또는 퓨처류 객체면, *obj* 인자를 있는 그대로 "
"(:func:`isfuture`\\로 검사합니다.)"

#: ../../library/asyncio-future.rst:42
msgid ""
"a :class:`Task` object wrapping *obj*, if *obj* is a coroutine "
"(:func:`iscoroutine` is used for the test); in this case the coroutine "
"will be scheduled by ``ensure_future()``."
msgstr ""
"*obj*\\가 코루틴이면, *obj*\\를 감싸는 :class:`Task` 객체 (:func:`iscoroutine`\\로 "
"검사합니다); 이 경우 코루틴은 ``ensure_future()``\\로 예약됩니다."

#: ../../library/asyncio-future.rst:47
msgid ""
"a :class:`Task` object that would await on *obj*, if *obj* is an "
"awaitable (:func:`inspect.isawaitable` is used for the test.)"
msgstr ""
"*obj*\\가 어웨이터블이면, *obj*\\를 기다릴 :class:`Task` 객체 "
"(:func:`inspect.isawaitable`\\로 검사합니다.)"

#: ../../library/asyncio-future.rst:50
msgid "If *obj* is neither of the above a :exc:`TypeError` is raised."
msgstr "*obj*\\가 이 중 어느 것도 아니면, :exc:`TypeError`\\가 발생합니다."

#: ../../library/asyncio-future.rst:54
msgid ""
"See also the :func:`create_task` function which is the preferred way for "
"creating new Tasks."
msgstr "새 태스크를 만드는 데 선호되는 :func:`create_task` 함수도 참조하십시오."

#: ../../library/asyncio-future.rst:57
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution."
msgstr ""

#: ../../library/asyncio-future.rst:60
msgid "The function accepts any :term:`awaitable` object."
msgstr "함수는 모든 :term:`어웨이터블 <awaitable>` 객체를 받아들입니다."

#: ../../library/asyncio-future.rst:63
msgid ""
"Deprecation warning is emitted if *obj* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""

#: ../../library/asyncio-future.rst:70
msgid ""
"Wrap a :class:`concurrent.futures.Future` object in a "
":class:`asyncio.Future` object."
msgstr ":class:`concurrent.futures.Future` 객체를 :class:`asyncio.Future` 객체로 감쌉니다."

#: ../../library/asyncio-future.rst:73
msgid ""
"Deprecation warning is emitted if *future* is not a Future-like object "
"and *loop* is not specified and there is no running event loop."
msgstr ""

#: ../../library/asyncio-future.rst:79
msgid "Future Object"
msgstr "Future 객체"

#: ../../library/asyncio-future.rst:83
msgid ""
"A Future represents an eventual result of an asynchronous operation.  Not"
" thread-safe."
msgstr "Future는 비동기 연산의 최종 결과를 나타냅니다. 스레드 안전하지 않습니다."

#: ../../library/asyncio-future.rst:86
msgid ""
"Future is an :term:`awaitable` object.  Coroutines can await on Future "
"objects until they either have a result or an exception set, or until "
"they are cancelled. A Future can be awaited multiple times and the result"
" is same."
msgstr ""
"Future는 :term:`어웨이터블 <awaitable>` 객체입니다. 코루틴은 결과나 예외가 설정되거나 취소될 때까지 "
"Future 객체를 기다릴 수 있습니다. Future는 여러번 어웨이트할 수 있으며 결과는 같습니다."

#: ../../library/asyncio-future.rst:91
msgid ""
"Typically Futures are used to enable low-level callback-based code (e.g. "
"in protocols implemented using asyncio :ref:`transports <asyncio-"
"transports-protocols>`) to interoperate with high-level async/await code."
msgstr ""
"일반적으로 퓨처는 저수준 콜백 기반 코드(예를 들어, asyncio :ref:`트랜스포트 <asyncio-transports-"
"protocols>`\\를 사용하여 구현된 프로토콜에서)가 고수준 async/await 코드와 상호 운용되도록 하는 데 사용됩니다."

#: ../../library/asyncio-future.rst:96
msgid ""
"The rule of thumb is to never expose Future objects in user-facing APIs, "
"and the recommended way to create a Future object is to call "
":meth:`loop.create_future`.  This way alternative event loop "
"implementations can inject their own optimized implementations of a "
"Future object."
msgstr ""
"간단한 규칙은 사용자가 만나는 API에서 Future 객체를 절대 노출하지 않는 것이며, Future 객체를 만드는 권장 방법은 "
":meth:`loop.create_future`\\를 호출하는 것입니다. 이런 식으로 대체 이벤트 루프 구현이 자신의 최적화된 "
"Future 객체 구현을 주입할 수 있습니다."

#: ../../library/asyncio-future.rst:102
msgid "Added support for the :mod:`contextvars` module."
msgstr ":mod:`contextvars` 모듈에 대한 지원이 추가되었습니다."

#: ../../library/asyncio-future.rst:105
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no"
" running event loop."
msgstr ""

#: ../../library/asyncio-future.rst:111
msgid "Return the result of the Future."
msgstr "Future의 결과를 반환합니다."

#: ../../library/asyncio-future.rst:113
msgid ""
"If the Future is *done* and has a result set by the :meth:`set_result` "
"method, the result value is returned."
msgstr "Future가 *완료(done)*\\했고 :meth:`set_result` 메서드로 결과가 설정되었으면, 결괏값이 반환됩니다."

#: ../../library/asyncio-future.rst:116
msgid ""
"If the Future is *done* and has an exception set by the "
":meth:`set_exception` method, this method raises the exception."
msgstr ""
"Future가 *완료(done)*\\했고 :meth:`set_exception` 메서드로 예외가 설정되었으면, 이 메서드는 예외를 "
"발생시킵니다."

#: ../../library/asyncio-future.rst:119 ../../library/asyncio-future.rst:207
msgid ""
"If the Future has been *cancelled*, this method raises a "
":exc:`CancelledError` exception."
msgstr "Future가 *취소(cancelled)*\\되었으면, 이 메서드는 :exc:`CancelledError` 예외를 발생시킵니다."

#: ../../library/asyncio-future.rst:122
msgid ""
"If the Future's result isn't yet available, this method raises an "
":exc:`InvalidStateError` exception."
msgstr "Future의 결과를 아직 사용할 수 없으면, 이 메서드는 :exc:`InvalidStateError` 예외를 발생시킵니다."

#: ../../library/asyncio-future.rst:127
msgid "Mark the Future as *done* and set its result."
msgstr "Future를 *완료(done)*\\로 표시하고, 그 결과를 설정합니다."

#: ../../library/asyncio-future.rst:129 ../../library/asyncio-future.rst:136
msgid "Raises an :exc:`InvalidStateError` error if the Future is already *done*."
msgstr "Future가 이미 *완료(done)*\\했으면, :exc:`InvalidStateError` 에러를 발생시킵니다."

#: ../../library/asyncio-future.rst:134
msgid "Mark the Future as *done* and set an exception."
msgstr "Future를 *완료(done)*\\로 표시하고, 예외를 설정합니다."

#: ../../library/asyncio-future.rst:141
msgid "Return ``True`` if the Future is *done*."
msgstr "Future가 *완료(done)*\\했으면 ``True``\\를 반환합니다."

#: ../../library/asyncio-future.rst:143
msgid ""
"A Future is *done* if it was *cancelled* or if it has a result or an "
"exception set with :meth:`set_result` or :meth:`set_exception` calls."
msgstr ""
"Future는 *취소(cancelled)*\\되었거나 :meth:`set_result` 나 :meth:`set_exception` "
"호출로 결과나 예외가 설정되면 *완료(done)*\\됩니다."

#: ../../library/asyncio-future.rst:149
msgid "Return ``True`` if the Future was *cancelled*."
msgstr "Future가 *최소(cancelled)*\\되었으면, ``True``\\를 반환합니다."

#: ../../library/asyncio-future.rst:151
msgid ""
"The method is usually used to check if a Future is not *cancelled* before"
" setting a result or an exception for it::"
msgstr "이 메서드는 대개 결과나 예외를 설정하기 전에 Future가 *취소(cancelled)*\\되었는지 확인하는 데 사용됩니다::"

#: ../../library/asyncio-future.rst:154
msgid ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"
msgstr ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"

#: ../../library/asyncio-future.rst:159
msgid "Add a callback to be run when the Future is *done*."
msgstr "Future가 *완료(done)*\\될 때 실행할 콜백을 추가합니다."

#: ../../library/asyncio-future.rst:161
msgid "The *callback* is called with the Future object as its only argument."
msgstr "*callback*\\는 유일한 인자인 Future 객체로 호출됩니다."

#: ../../library/asyncio-future.rst:164
msgid ""
"If the Future is already *done* when this method is called, the callback "
"is scheduled with :meth:`loop.call_soon`."
msgstr ""
"이 메서드가 호출될 때 Future가 이미 *완료(done)*\\되었으면, 콜백이 :meth:`loop.call_soon`\\으로 "
"예약됩니다."

#: ../../library/asyncio-future.rst:167
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"선택적 키워드 전용 *context* 인자는 *callback*\\이 실행될 사용자 정의 "
":class:`contextvars.Context`\\를 지정할 수 있도록 합니다. *context*\\가 제공되지 않으면 현재 "
"컨텍스트가 사용됩니다."

#: ../../library/asyncio-future.rst:171
msgid ""
":func:`functools.partial` can be used to pass parameters to the callback,"
" e.g.::"
msgstr ":func:`functools.partial`\\을 사용하여 매개 변수를 callback에 전달할 수 있습니다, 예를 들어::"

#: ../../library/asyncio-future.rst:174
msgid ""
"# Call 'print(\"Future:\", fut)' when \"fut\" is done.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"
msgstr ""
"# \"fut\"가 완료되면 'print(\"Future:\", fut)'를 호출합니다.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"

#: ../../library/asyncio-future.rst:178
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr "*context* 키워드 전용 매개 변수가 추가되었습니다. 자세한 내용은 :pep:`567`\\을 참조하십시오."

#: ../../library/asyncio-future.rst:184
msgid "Remove *callback* from the callbacks list."
msgstr "콜백 목록에서 *callback*\\을 제거합니다."

#: ../../library/asyncio-future.rst:186
msgid ""
"Returns the number of callbacks removed, which is typically 1, unless a "
"callback was added more than once."
msgstr "제거된 콜백 수를 반환합니다. 콜백이 두 번 이상 추가되지 않는 한 일반적으로 1입니다."

#: ../../library/asyncio-future.rst:191
msgid "Cancel the Future and schedule callbacks."
msgstr "Future를 취소하고 콜백을 예약합니다."

#: ../../library/asyncio-future.rst:193
msgid ""
"If the Future is already *done* or *cancelled*, return ``False``. "
"Otherwise, change the Future's state to *cancelled*, schedule the "
"callbacks, and return ``True``."
msgstr ""
"Future가 이미 *완료(done)*\\했거나 *취소(cancelled)*\\되었으면, ``False``\\를 반환합니다. 그렇지"
" 않으면 Future의 상태를 *취소(cancelled)*\\로 변경하고, 콜백을 예약한 다음 ``True``\\를 반환합니다."

#: ../../library/asyncio-future.rst:197
msgid "Added the *msg* parameter."
msgstr "*msg* 매개 변수를 추가했습니다."

#: ../../library/asyncio-future.rst:202
msgid "Return the exception that was set on this Future."
msgstr "이 Future에 설정된 예외를 반환합니다."

#: ../../library/asyncio-future.rst:204
msgid ""
"The exception (or ``None`` if no exception was set) is returned only if "
"the Future is *done*."
msgstr "Future가 *완료(done)*\\했을 때만 예외(또는 예외가 설정되지 않았으면 ``None``)가 반환됩니다."

#: ../../library/asyncio-future.rst:210
msgid ""
"If the Future isn't *done* yet, this method raises an "
":exc:`InvalidStateError` exception."
msgstr ""
"Future가 아직 *완료(done)*\\하지 않았으면, 이 메서드는 :exc:`InvalidStateError` 예외를 "
"발생시킵니다."

#: ../../library/asyncio-future.rst:215
msgid "Return the event loop the Future object is bound to."
msgstr "Future 객체가 연결된 이벤트 루프를 반환합니다."

#: ../../library/asyncio-future.rst:222
msgid ""
"This example creates a Future object, creates and schedules an "
"asynchronous Task to set result for the Future, and waits until the "
"Future has a result::"
msgstr ""
"이 예제는 Future 객체를 만들고, Future에 결과를 설정하는 비동기 Task를 만들고 예약하며, Future가 결과를 얻을"
" 때까지 기다립니다::"

#: ../../library/asyncio-future.rst:226
msgid ""
"async def set_after(fut, delay, value):\n"
"    # Sleep for *delay* seconds.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Set *value* as a result of *fut* Future.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # Get the current event loop.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a new Future object.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Run \"set_after()\" coroutine in a parallel Task.\n"
"    # We are using the low-level \"loop.create_task()\" API here because\n"
"    # we already have a reference to the event loop at hand.\n"
"    # Otherwise we could have just used \"asyncio.create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # Wait until *fut* has a result (1 second) and print it.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def set_after(fut, delay, value):\n"
"    # *delay* 초 동안 잠잡니다.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # *fut* 퓨처의 결과로 *value* 를 설정합니다.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # 현재 이벤트 루프를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # 새로운 Future 객체를 만듭니다.\n"
"    fut = loop.create_future()\n"
"\n"
"    # 병렬 태스크로 \"set_after()\" 코루틴을 실행합니다.\n"
"    # 이벤트 루프에 대한 참조를 이미 가지고 있으므로, 여기서는 저수준 \"loop.create_task()\"\n"
"    # API를 사용하고 있습니다.\n"
"    # 그렇지 않다면 그저 \"asyncio.create_task()\" 를 사용할 수 있었습니다.\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # *fut* 에 결과가 올 때까지 기다렸다가 (1초) 그것을 인쇄합니다.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-future.rst:257
msgid ""
"The Future object was designed to mimic "
":class:`concurrent.futures.Future`.  Key differences include:"
msgstr ""
"Future 객체는 :class:`concurrent.futures.Future`\\를 흉내 내도록 설계되었습니다. 주요 차이점은 "
"다음과 같습니다:"

#: ../../library/asyncio-future.rst:260
msgid ""
"unlike asyncio Futures, :class:`concurrent.futures.Future` instances "
"cannot be awaited."
msgstr "asyncio 퓨처와는 달리, :class:`concurrent.futures.Future` 인스턴스는 await 할 수 없습니다."

#: ../../library/asyncio-future.rst:263
msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` do not"
" accept the *timeout* argument."
msgstr ""
":meth:`asyncio.Future.result` 와 :meth:`asyncio.Future.exception`\\은 "
"*timeout* 인자를 받아들이지 않습니다."

#: ../../library/asyncio-future.rst:266
msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` raise "
"an :exc:`InvalidStateError` exception when the Future is not *done*."
msgstr ""
":meth:`asyncio.Future.result` 와 :meth:`asyncio.Future.exception`\\는 "
"Future가 *완료(done)*\\하지 않았을 때 :exc:`InvalidStateError` 예외를 발생시킵니다."

#: ../../library/asyncio-future.rst:270
msgid ""
"Callbacks registered with :meth:`asyncio.Future.add_done_callback` are "
"not called immediately.  They are scheduled with :meth:`loop.call_soon` "
"instead."
msgstr ""
":meth:`asyncio.Future.add_done_callback`\\으로 등록된 콜백은 즉시 호출되지 않습니다. 대신 "
":meth:`loop.call_soon`\\로 예약됩니다."

#: ../../library/asyncio-future.rst:274
msgid ""
"asyncio Future is not compatible with the :func:`concurrent.futures.wait`"
" and :func:`concurrent.futures.as_completed` functions."
msgstr ""
"asyncio Future는 :func:`concurrent.futures.wait` 와 "
":func:`concurrent.futures.as_completed` 함수와 호환되지 않습니다."

#: ../../library/asyncio-future.rst:278
msgid ""
":meth:`asyncio.Future.cancel` accepts an optional ``msg`` argument, but "
":meth:`concurrent.futures.Future.cancel` does not."
msgstr ""
":meth:`asyncio.Future.cancel`\\은 선택적 ``msg`` 인자를 받아들이지만, "
":meth:`concurrent.futures.Future.cancel`\\은 받아들이지 않습니다."

