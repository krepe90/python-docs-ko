# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/zipapp.rst:2
msgid ":mod:`!zipapp` --- Manage executable Python zip archives"
msgstr ":mod:`!zipapp` --- 실행 가능한 파이썬 zip 아카이브 관리"

#: ../../library/zipapp.rst:9
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**소스 코드:** :source:`Lib/zipapp.py`"

#: ../../library/zipapp.rst:16
msgid ""
"This module provides tools to manage the creation of zip files containing"
" Python code, which can be  :ref:`executed directly by the Python "
"interpreter <using-on-interface-options>`.  The module provides both a "
":ref:`zipapp-command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"이 모듈은 :ref:`파이썬 인터프리터가 직접 실행할 <using-on-interface-options>` 수 있는 파이썬 코드를 "
"포함하는 zip 파일 생성을 관리하는 도구를 제공합니다. 이 모듈은 :ref:`zipapp-command-line-"
"interface`\\와 :ref:`zipapp-python-api`\\를 모두 제공합니다."

#: ../../library/zipapp.rst:23
msgid "Basic Example"
msgstr "기본 예"

#: ../../library/zipapp.rst:25
msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` "
"can be used to create an executable archive from a directory containing "
"Python code.  When run, the archive will execute the ``main`` function "
"from the module ``myapp`` in the archive."
msgstr ""
"다음 예제는 :ref:`zipapp-command-line-interface`\\를 사용하여 파이썬 코드가 포함된 디렉터리에서 실행"
" 가능 아카이브를 만드는 방법을 보여줍니다. 실행하면, 아카이브가 아카이브의 모듈 ``myapp``\\에서 ``main`` 함수를 "
"실행합니다."

#: ../../library/zipapp.rst:30
msgid ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:40
msgid "Command-Line Interface"
msgstr "명령 줄 인터페이스"

#: ../../library/zipapp.rst:42
msgid ""
"When called as a program from the command line, the following form is "
"used:"
msgstr "명령 줄에서 프로그램으로 호출될 때, 다음 형식이 사용됩니다:"

#: ../../library/zipapp.rst:44
msgid "$ python -m zipapp source [options]"
msgstr "$ python -m zipapp source [options]"

#: ../../library/zipapp.rst:48
msgid ""
"If *source* is a directory, this will create an archive from the contents"
" of *source*.  If *source* is a file, it should be an archive, and it "
"will be copied to the target archive (or the contents of its shebang line"
" will be displayed if the --info option is specified)."
msgstr ""
"*source*\\가 디렉터리면, *source*\\의 내용으로부터 아카이브를 만듭니다. *source*\\가 파일이면, "
"아카이브여야 하며, 대상 아카이브로 복사됩니다 (또는 --info 옵션이 지정되면 셔뱅(shebang) 줄의 내용이 표시됩니다)."

#: ../../library/zipapp.rst:53
msgid "The following options are understood:"
msgstr "다음과 같은 옵션이 이해됩니다:"

#: ../../library/zipapp.rst:59
msgid ""
"Write the output to a file named *output*.  If this option is not "
"specified, the output filename will be the same as the input *source*, "
"with the extension ``.pyz`` added.  If an explicit filename is given, it "
"is used as is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"출력을 *output*\\이라는 이름의 파일에 씁니다. 이 옵션을 지정하지 않으면, 출력 파일명은 입력 *source*\\와 같고,"
" 확장자 ``.pyz``\\가 추가됩니다. 명시적인 파일명이 제공되면, 그대로 사용됩니다 (그래서 필요하면 ``.pyz`` 확장자를"
" 포함해야 합니다)."

#: ../../library/zipapp.rst:64
msgid ""
"An output filename must be specified if the *source* is an archive (and "
"in that case, *output* must not be the same as *source*)."
msgstr ""
"*source*\\가 아카이브이면 반드시 출력 파일명을 지정해야 합니다 (그리고 이 경우, *output*\\은 "
"*source*\\와 달라야 합니다)."

#: ../../library/zipapp.rst:69
msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command "
"to run.  Also, on POSIX, make the archive executable.  The default is to "
"write no ``#!`` line, and not make the file executable."
msgstr ""
"실행할 명령으로 *interpreter*\\를 지정하여 ``#!`` 줄을 아카이브에 추가합니다. 또한, POSIX에서, 아카이브를 "
"실행 파일로 만듭니다. 기본값은 ``#!`` 줄을 쓰지 않고, 파일을 실행 파일로 만들지 않는 것입니다."

#: ../../library/zipapp.rst:75
msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" "
"is a package/module in the archive, and \"fn\" is a callable in the given"
" module. The ``__main__.py`` file will execute that callable."
msgstr ""
"아카이브에 *mainfn*\\을 실행하는 ``__main__.py`` 파일을 씁니다. *mainfn* 인자는 "
"\"pkg.mod:fn\" 형식이어야 합니다. 여기서 \"pkg.mod\"는 아카이브의 패키지/모듈이며, \"fn\"은 주어진 "
"모듈에 있는 콜러블입니다. ``__main__.py`` 파일은 그 콜러블을 실행합니다."

#: ../../library/zipapp.rst:80
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr "아카이브를 복사할 때 :option:`--main`\\을 지정할 수 없습니다."

#: ../../library/zipapp.rst:84
msgid ""
"Compress files with the deflate method, reducing the size of the output "
"file. By default, files are stored uncompressed in the archive."
msgstr ""
"디플레이트(deflate) 메서드로 파일을 압축하여, 출력 파일의 크기를 줄입니다. 기본적으로, 파일은 아카이브에 압축되지 않은 "
"상태로 저장됩니다."

#: ../../library/zipapp.rst:87
msgid ":option:`--compress` has no effect when copying an archive."
msgstr "아카이브를 복사할 때 :option:`--compress`\\는 효과가 없습니다."

#: ../../library/zipapp.rst:93
msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes."
"  In this case, any other options are ignored and SOURCE must be an "
"archive, not a directory."
msgstr ""
"진단 목적으로, 아카이브에 내장된 인터프리터를 표시합니다. 이 경우, 다른 옵션은 무시되고 SOURCE는 디렉터리가 아닌 "
"아카이브여야 합니다."

#: ../../library/zipapp.rst:99
msgid "Print a short usage message and exit."
msgstr "간단한 사용법 메시지를 인쇄하고 종료합니다."

#: ../../library/zipapp.rst:105
msgid "Python API"
msgstr "파이썬 API"

#: ../../library/zipapp.rst:107
msgid "The module defines two convenience functions:"
msgstr "이 모듈은 두 개의 편의 함수를 정의합니다:"

#: ../../library/zipapp.rst:112
msgid ""
"Create an application archive from *source*.  The source can be any of "
"the following:"
msgstr "*source*\\로 응용 프로그램 아카이브를 만듭니다. 소스는 다음 중 하나일 수 있습니다:"

#: ../../library/zipapp.rst:115
msgid ""
"The name of a directory, or a :term:`path-like object` referring to a "
"directory, in which case a new application archive will be created from "
"the content of that directory."
msgstr ""
"디렉터리 이름, 또는 디렉터리를 참조하는 :term:`경로류 객체 <path-like object>`. 이 경우 해당 디렉터리의 "
"내용으로 새 응용 프로그램 아카이브가 만들어집니다."

#: ../../library/zipapp.rst:118
msgid ""
"The name of an existing application archive file, or a :term:`path-like "
"object` referring to such a file, in which case the file is copied to the"
" target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if "
"required."
msgstr ""
"기존 응용 프로그램 아카이브 파일의 이름, 또는 이러한 파일을 참조하는 :term:`경로류 객체 <path-like "
"object>`. 이 경우 파일이 대상(target)으로 복사됩니다 (*interpreter* 인자에 제공된 값을 반영하도록 "
"수정하면서). 필요하면, 파일 이름에 ``.pyz`` 확장자가 포함되어야 합니다."

#: ../../library/zipapp.rst:122
msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr ""
"바이너리 모드에서 읽기로 열린 파일 객체. 파일의 내용은 응용 프로그램 아카이브여야 하며, 파일 객체는 아카이브의 시작 부분에 "
"위치한 것으로 가정합니다."

#: ../../library/zipapp.rst:126
msgid ""
"The *target* argument determines where the resulting archive will be "
"written:"
msgstr "*target* 인자는 결과 아카이브가 기록될 위치를 결정합니다:"

#: ../../library/zipapp.rst:129
msgid ""
"If it is the name of a file, or a :term:`path-like object`, the archive "
"will be written to that file."
msgstr "파일 이름이거나 :term:`경로류 객체 <path-like object>`\\이면, 아카이브가 그 파일에 기록됩니다."

#: ../../library/zipapp.rst:131
msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr "열린 파일 객체면, 그 파일 객체에 아카이브가 기록되며, 파일은 바이너리 모드로 쓰기로 열려 있어야 합니다."

#: ../../library/zipapp.rst:133
msgid ""
"If the target is omitted (or ``None``), the source must be a directory "
"and the target will be a file with the same name as the source, with a "
"``.pyz`` extension added."
msgstr ""
"target이 생략되면 (또는 ``None``\\이면), 소스(source)는 디렉터리여야 하며 대상은 ``.pyz`` 확장자가 "
"추가된 소스와 이름이 같은 파일이 됩니다."

#: ../../library/zipapp.rst:137
msgid ""
"The *interpreter* argument specifies the name of the Python interpreter "
"with which the archive will be executed.  It is written as a \"shebang\" "
"line at the start of the archive.  On POSIX, this will be interpreted by "
"the OS, and on Windows it will be handled by the Python launcher.  "
"Omitting the *interpreter* results in no shebang line being written.  If "
"an interpreter is specified, and the target is a filename, the executable"
" bit of the target file will be set."
msgstr ""
"*interpreter* 인자는 아카이브가 실행될 파이썬 인터프리터의 이름을 지정합니다. 아카이브 시작 부분에 "
"\"셔뱅(shebang)\" 줄로 기록됩니다. POSIX에서는 이를 OS가 해석하고, 윈도우에서는 파이썬 런처가 이를 처리합니다. "
"*interpreter*\\를 생략하면 셔뱅 줄이 기록되지 않습니다. interpreter가 지정되고 target이 파일명이면, "
"target 파일의 실행 가능 비트가 설정됩니다."

#: ../../library/zipapp.rst:145
msgid ""
"The *main* argument specifies the name of a callable which will be used "
"as the main program for the archive.  It can only be specified if the "
"source is a directory, and the source does not already contain a "
"``__main__.py`` file.  The *main* argument should take the form "
"\"pkg.module:callable\" and the archive will be run by importing "
"\"pkg.module\" and executing the given callable with no arguments.  It is"
" an error to omit *main* if the source is a directory and does not "
"contain a ``__main__.py`` file, as otherwise the resulting archive would "
"not be executable."
msgstr ""
"*main* 인자는 아카이브의 메인 프로그램으로 사용될 콜러블의 이름을 지정합니다. 소스가 디렉터리이고 소스에 아직 "
"``__main__.py`` 파일이 없을 때만 지정할 수 있습니다. *main* 인자는 \"pkg.module:callable\" "
"형식이어야 하며 아카이브는 \"pkg.module\"을 임포트 하고 인자 없이 지정된 콜러블을 실행해서 실행됩니다. 소스가 "
"디렉터리이고 ``__main__.py`` 파일을 포함하지 않을 때 *main*\\을 생략하는 것은 에러입니다, 그렇지 않으면 결과 "
"아카이브가 실행 가능하지 않기 때문입니다."

#: ../../library/zipapp.rst:155
msgid ""
"The optional *filter* argument specifies a callback function that is "
"passed a Path object representing the path to the file being added "
"(relative to the source directory).  It should return ``True`` if the "
"file is to be added."
msgstr ""
"선택적 *filter* 인자는 추가되는 파일의 (소스 디렉터리에 상대적인) 경로를 나타내는 Path 객체가 전달되는 콜백 함수를 "
"지정합니다. 파일을 추가하려면 ``True``\\를 반환해야 합니다."

#: ../../library/zipapp.rst:160
msgid ""
"The optional *compressed* argument determines whether files are "
"compressed.  If set to ``True``, files in the archive are compressed with"
" the deflate method; otherwise, files are stored uncompressed. This "
"argument has no effect when copying an existing archive."
msgstr ""
"선택적 *compressed* 인자는 파일을 압축할지를 결정합니다. ``True``\\로 설정하면, 아카이브의 파일이 "
"디플레이트(deflate) 메서드로 압축됩니다; 그렇지 않으면 파일이 압축되지 않은 상태로 저장됩니다. 기존 아카이브를 복사할 때는"
" 이 인자가 효과가 없습니다."

#: ../../library/zipapp.rst:165
msgid ""
"If a file object is specified for *source* or *target*, it is the "
"caller's responsibility to close it after calling create_archive."
msgstr ""
"*source*\\나 *target*\\에 파일 객체가 지정되면, create_archive를 호출한 후 파일 객체를 닫는 것은 "
"호출자의 책임입니다."

#: ../../library/zipapp.rst:168
msgid ""
"When copying an existing archive, file objects supplied only need "
"``read`` and ``readline``, or ``write`` methods.  When creating an "
"archive from a directory, if the target is a file object it will be "
"passed to the ``zipfile.ZipFile`` class, and must supply the methods "
"needed by that class."
msgstr ""
"기존 아카이브를 복사할 때, 제공된 파일 객체에는 ``read``\\와 ``readline`` 또는 ``write`` 메서드만 "
"필요합니다. 디렉터리에서 아카이브를 만들 때, 대상이 파일 객체면 ``zipfile.ZipFile`` 클래스로 전달되며, 해당 "
"클래스에 필요한 메서드를 제공해야 합니다."

#: ../../library/zipapp.rst:174
msgid "Added the *filter* and *compressed* parameters."
msgstr "*filter*\\와 *compressed* 매개 변수를 추가했습니다."

#: ../../library/zipapp.rst:179
msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive*"
" argument can be a filename or a file-like object open for reading in "
"bytes mode.  It is assumed to be at the start of the archive."
msgstr ""
"아카이브 시작 부분에서 ``#!`` 줄에 지정된 인터프리터를 반환합니다. ``#!`` 줄이 없으면, :const:`None`\\을 "
"반환합니다. *archive* 인자는 파일명이나 바이너리 모드로 읽기로 열린 파일류 객체일 수 있습니다. 아카이브가 시작 부분에 "
"위치한 것으로 가정합니다."

#: ../../library/zipapp.rst:188
msgid "Examples"
msgstr "예"

#: ../../library/zipapp.rst:190
msgid "Pack up a directory into an archive, and run it."
msgstr "디렉터리를 아카이브로 패킹하고, 실행합니다."

#: ../../library/zipapp.rst:192
msgid ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:198
msgid "The same can be done using the :func:`create_archive` function::"
msgstr ":func:`create_archive` 함수를 사용하여 같은 작업을 수행할 수 있습니다::"

#: ../../library/zipapp.rst:200
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"
msgstr ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"

#: ../../library/zipapp.rst:203
msgid ""
"To make the application directly executable on POSIX, specify an "
"interpreter to use."
msgstr "POSIX에서 응용 프로그램을 직접 실행할 수 있게 만들려면, 사용할 인터프리터를 지정하십시오."

#: ../../library/zipapp.rst:206
msgid ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:212
msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr "기존 아카이브에서 셔뱅 줄을 바꾸려면, :func:`create_archive` 함수를 사용하여 수정된 아카이브를 만드십시오::"

#: ../../library/zipapp.rst:215
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', "
"'/usr/bin/python3')"
msgstr ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', "
"'/usr/bin/python3')"

#: ../../library/zipapp.rst:218
msgid ""
"To update the file in place, do the replacement in memory using a "
":class:`~io.BytesIO` object, and then overwrite the source afterwards.  "
"Note that there is a risk when overwriting a file in place that an error "
"will result in the loss of the original file.  This code does not protect"
" against such errors, but production code should do so.  Also, this "
"method will only work if the archive fits in memory::"
msgstr ""
"파일을 제자리에서 갱신하려면, :class:`~io.BytesIO` 객체를 사용하여 메모리에서 치환을 수행한 다음, 나중에 소스를 "
"덮어씁니다. 파일을 제자리에서 덮어쓰면 에러로 인해 원본 파일을 손실할 위험이 있음에 유의하십시오. 이 코드는 이러한 에러에 대한 "
"보호는 없지만, 프로덕션 코드는 이를 방지해야 합니다. 또한, 이 방법은 아카이브가 메모리에 올라올 수 있을 때만 작동합니다::"

#: ../../library/zipapp.rst:225
msgid ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"
msgstr ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"

#: ../../library/zipapp.rst:236
msgid "Specifying the Interpreter"
msgstr "인터프리터 지정하기"

#: ../../library/zipapp.rst:238
msgid ""
"Note that if you specify an interpreter and then distribute your "
"application archive, you need to ensure that the interpreter used is "
"portable.  The Python launcher for Windows supports most common forms of "
"POSIX ``#!`` line, but there are other issues to consider:"
msgstr ""
"인터프리터를 지정한 다음 응용 프로그램 아카이브를 배포한다면, 사용된 인터프리터가 이식성 있는지 확인할 필요가 있음에 유의하십시오."
" 윈도우 용 파이썬 런처는 가장 일반적인 POSIX ``#!`` 줄 형식을 지원하지만, 고려해야 할 다른 문제가 있습니다:"

#: ../../library/zipapp.rst:243
msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your "
"users may have either Python 2 or Python 3 as their default, and write "
"your code to work under both versions."
msgstr ""
"\"/usr/bin/env python\"(또는 \"/usr/bin/python\"과 같은 \"python\" 명령의 다른 형식)을"
" 사용한다면, 사용자에게 기본적으로 파이썬 2나 파이썬 3이 있을 수 있음을 고려해야 하고, 두 버전에서 작동하도록 코드를 "
"작성하십시오."

#: ../../library/zipapp.rst:247
msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your"
" application will not work for users who do not have that version.  (This"
" may be what you want if you have not made your code Python 2 "
"compatible)."
msgstr ""
"\"/usr/bin/env python3\"과 같이 명시적인 버전을 사용하면 해당 버전이 없는 사용자에게는 응용 프로그램이 작동하지"
" 않습니다. (여러분의 코드를 파이썬 2 호환으로 만들지 않았다면 이것이 여러분이 원하는 것일 수 있습니다)."

#: ../../library/zipapp.rst:250
msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an"
" exact version like \"/usr/bin/env python3.4\" as you will need to change"
" your shebang line for users of Python 3.5, for example."
msgstr ""
"\"파이썬 X.Y 이상\"이라고 말할 방법이 없어서, \"/usr/bin/env python3.4\"처럼 정확한 버전을 사용할 때는"
" 주의하십시오. 예를 들어 파이썬 3.5 사용자를 위해서는 셔뱅 줄을 변경해야 합니다."

#: ../../library/zipapp.rst:254
msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""
"일반적으로, 여러분의 코드가 파이썬 2나 3중 어느 것으로 작성되었는지에 따라 \"/usr/bin/env python2\"나 "
"\"/usr/bin/env python3\"을 사용해야 합니다."

#: ../../library/zipapp.rst:259
msgid "Creating Standalone Applications with zipapp"
msgstr "zipapp으로 독립형 응용 프로그램 만들기"

#: ../../library/zipapp.rst:261
msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to "
"have a suitable version of Python installed on their system.  The key to "
"doing this is to bundle all of the application's dependencies into the "
"archive, along with the application code."
msgstr ""
":mod:`zipapp` 모듈을 사용하면, 시스템에 적합한 버전의 파이썬만 설치되어있는 최종 사용자에게 배포 할 수 있는 필요한 "
"모든 것이 담긴 파이썬 프로그램을 만들 수 있습니다. 이 작업의 핵심은 응용 프로그램 코드와 함께 모든 응용 프로그램의 종속성을 "
"아카이브에 묶는 것입니다."

#: ../../library/zipapp.rst:267
msgid "The steps to create a standalone archive are as follows:"
msgstr "독립형 아카이브를 만드는 단계는 다음과 같습니다:"

#: ../../library/zipapp.rst:269
msgid ""
"Create your application in a directory as normal, so you have a ``myapp``"
" directory containing a ``__main__.py`` file, and any supporting "
"application code."
msgstr ""
"정상적으로 디렉터리에 응용 프로그램을 만드십시오, 그러면 ``__main__.py`` 파일과 모든 지원 응용 프로그램 코드를 "
"포함하는 ``myapp`` 디렉터리를 얻게 됩니다."

#: ../../library/zipapp.rst:273
msgid ""
"Install all of your application's dependencies into the ``myapp`` "
"directory, using pip:"
msgstr "pip을 사용하여 모든 응용 프로그램의 종속성을 ``myapp`` 디렉터리에 설치하십시오:"

#: ../../library/zipapp.rst:276
msgid "$ python -m pip install -r requirements.txt --target myapp"
msgstr "$ python -m pip install -r requirements.txt --target myapp"

#: ../../library/zipapp.rst:280
msgid ""
"(this assumes you have your project requirements in a "
"``requirements.txt`` file - if not, you can just list the dependencies "
"manually on the pip command line)."
msgstr ""
"(이것은 ``requirements.txt`` 파일에 프로젝트 요구 사항이 있다고 가정합니다 - 그렇지 않으면, pip 명령 줄에 "
"종속성을 수동으로 나열할 수 있습니다)."

#: ../../library/zipapp.rst:284
msgid "Package the application using:"
msgstr "다음과 같이 응용 프로그램을 패키징하십시오:"

#: ../../library/zipapp.rst:286
msgid "$ python -m zipapp -p \"interpreter\" myapp"
msgstr "$ python -m zipapp -p \"interpreter\" myapp"

#: ../../library/zipapp.rst:290
msgid ""
"This will produce a standalone executable, which can be run on any "
"machine with the appropriate interpreter available. See :ref:`zipapp-"
"specifying-the-interpreter` for details. It can be shipped to users as a "
"single file."
msgstr ""
"그러면 독립형 실행 파일이 생성되며, 사용 가능한 적절한 인터프리터가 있는 모든 시스템에서 실행할 수 있습니다. 자세한 내용은 "
":ref:`zipapp-specifying-the-interpreter`\\를 참조하십시오. 단일 파일로 사용자에게 제공될 수 "
"있습니다."

#: ../../library/zipapp.rst:294
msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can "
"rename the file to remove the ``.pyz`` extension if you prefer a "
"\"plain\" command name.  On Windows, the ``myapp.pyz[w]`` file is "
"executable by virtue of the fact that the Python interpreter registers "
"the ``.pyz`` and ``.pyzw`` file extensions when installed."
msgstr ""
"유닉스에서, ``myapp.pyz`` 파일은 그대로 실행 파일입니다. \"평범한\" 명령 이름을 선호하면, 파일 이름을 변경하여 "
"``.pyz`` 확장자를 제거할 수 있습니다. 윈도우에서, 파이썬 인터프리터가 설치될 때 ``.pyz``\\와 ``.pyzw`` "
"파일 확장자를 등록한다는 점에서  ``myapp.pyz[w]`` 파일은 실행 파일입니다."

#: ../../library/zipapp.rst:302
msgid "Caveats"
msgstr "경고"

#: ../../library/zipapp.rst:304
msgid ""
"If your application depends on a package that includes a C extension, "
"that package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to "
"load it). In this case, you can exclude that dependency from the zipfile,"
" and either require your users to have it installed, or ship it alongside"
" your zipfile and add code to your ``__main__.py`` to include the "
"directory containing the unzipped module in ``sys.path``. In this case, "
"you will need to make sure to ship appropriate binaries for your target "
"architecture(s) (and potentially pick the correct version to add to "
"``sys.path`` at runtime, based on the user's machine)."
msgstr ""
"응용 프로그램이 C 확장을 포함하는 패키지에 의존하면, 해당 패키지는 zip 파일에서 실행할 수 없습니다 (이것은 OS 제한 "
"사항인데, OS 로더가 로드 할 수 있으려면 실행 코드는 파일 시스템에 있어야만 합니다). 이 경우, zip 파일에서 해당 종속성을"
" 제외하고, 사용자가 파일을 설치하도록 요구하거나, zip 파일과 함께 제공하고 ``__main__.py``\\에 코드를 추가하여 "
"``sys.path``\\에 압축 해제된 모듈을 포함하는 디렉터리를 포함할 수 있습니다. 이 경우, 대상 아키텍처에 적합한 "
"바이너리를 제공해야 합니다 (그리고 아마도 사용자 컴퓨터를 기반으로 실행 시간에 ``sys.path``\\에 추가할 올바른 버전을 "
"선택해야 합니다)."

#: ../../library/zipapp.rst:316
msgid "The Python Zip Application Archive Format"
msgstr "파이썬 Zip 응용 프로그램 아카이브 형식"

#: ../../library/zipapp.rst:318
msgid ""
"Python has been able to execute zip files which contain a ``__main__.py``"
" file since version 2.6.  In order to be executed by Python, an "
"application archive simply has to be a standard zip file containing a "
"``__main__.py`` file which will be run as the entry point for the "
"application.  As usual for any Python script, the parent of the script "
"(in this case the zip file) will be placed on :data:`sys.path` and thus "
"further modules can be imported from the zip file."
msgstr ""
"파이썬은 버전 2.6부터 ``__main__.py`` 파일이 포함된 zip 파일을 실행할 수 있었습니다. 파이썬에서 실행되려면, "
"응용 프로그램 아카이브는 응용 프로그램의 진입점으로 실행될 ``__main__.py`` 파일이 포함된 표준 zip 파일이어야 "
"합니다. 모든 파이썬 스크립트와 마찬가지로, 스크립트의 부모(이 경우 zip 파일)가 :data:`sys.path`\\에 배치되므로"
" zip 파일에서 추가 모듈을 임포트 할 수 있습니다."

#: ../../library/zipapp.rst:325
msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file."
"  The zip application format uses this ability to prepend a standard "
"POSIX \"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""
"zip 파일 형식은 임의의 데이터를 zip 파일 앞에 추가할 수 있도록 합니다. zip 응용 프로그램 형식은 이 기능을 사용하여 "
"표준 POSIX \"셔뱅(shebang)\" 줄을 파일 앞에 추가합니다 (``#!/path/to/interpreter``)."

#: ../../library/zipapp.rst:329
msgid "Formally, the Python zip application format is therefore:"
msgstr "따라서 공식적으로 파이썬 zip 응용 프로그램 형식은 다음과 같습니다:"

#: ../../library/zipapp.rst:331
msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by"
" an interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be"
" encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding` on"
" POSIX."
msgstr ""
"문자 ``b'#!'``, 인터프리터 이름, 개행 (``b'\\n'``) 문자를 포함하는 선택적 셔뱅(shebang) 줄. 인터프리터"
" 이름은 OS \"셔뱅\" 처리가 허용하는 모든 것, 또는 윈도우의 파이썬 런처일 수 있습니다. 인터프리터는 윈도우에서는 "
"UTF-8로, POSIX에서는 :func:`sys.getfilesystemencoding`\\으로 인코딩되어야 합니다."

#: ../../library/zipapp.rst:336
msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must "
"be in the \"root\" of the zipfile - i.e., it cannot be in a "
"subdirectory).  The zipfile data can be compressed or uncompressed."
msgstr ""
":mod:`zipfile` 모듈에 의해 생성된 표준 zip 파일 데이터. zipfile 내용은 *반드시* "
"``__main__.py``\\라는 파일을 포함해야 합니다 (zip 파일의 \"루트\"에 있어야 합니다 - 즉, 서브 디렉터리에 "
"있을 수 없습니다). zip 파일 데이터는 압축되거나 그렇지 않을 수 있습니다."

#: ../../library/zipapp.rst:341
msgid ""
"If an application archive has a shebang line, it may have the executable "
"bit set on POSIX systems, to allow it to be executed directly."
msgstr "응용 프로그램 아카이브에 셔뱅 줄이 있으면, POSIX 시스템에서 직접 실행될 수 있도록 실행 파일 비트를 설정할 수 있습니다."

#: ../../library/zipapp.rst:344
msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr ""
"이 모듈의 도구를 사용하여 응용 프로그램 아카이브를 만들 필요는 없습니다 - 모듈은 편의를 위한 것입니다. 하지만 어떤 방법으로 "
"만들었든 위 형식의 아카이브는 파이썬에서 허용됩니다."

#: ../../library/zipapp.rst:11
msgid "Executable Zip Files"
msgstr "실행 가능한 Zip 파일"

