# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/collections.rst:2
#, fuzzy
msgid ":mod:`!collections` --- Container datatypes"
msgstr ":mod:`collections` --- 컨테이너 데이터형"

#: ../../library/collections.rst:10
msgid "**Source code:** :source:`Lib/collections/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/collections/__init__.py`"

#: ../../library/collections.rst:20
msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, "
":class:`dict`, :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"이 모듈은 파이썬의 범용 내장 컨테이너 :class:`dict`, :class:`list`, :class:`set` 및 "
":class:`tuple`\\에 대한 대안을 제공하는 특수 컨테이너 데이터형을 구현합니다."

#: ../../library/collections.rst:25
msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

#: ../../library/collections.rst:25
msgid "factory function for creating tuple subclasses with named fields"
msgstr "이름 붙은 필드를 갖는 튜플 서브 클래스를 만들기 위한 팩토리 함수"

#: ../../library/collections.rst:26
msgid ":class:`deque`"
msgstr ":class:`deque`"

#: ../../library/collections.rst:26
msgid "list-like container with fast appends and pops on either end"
msgstr "양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너"

#: ../../library/collections.rst:27
msgid ":class:`ChainMap`"
msgstr ":class:`ChainMap`"

#: ../../library/collections.rst:27
msgid "dict-like class for creating a single view of multiple mappings"
msgstr "여러 매핑의 단일 뷰를 만드는 딕셔너리류 클래스"

#: ../../library/collections.rst:28
msgid ":class:`Counter`"
msgstr ":class:`Counter`"

#: ../../library/collections.rst:28
#, fuzzy
msgid "dict subclass for counting :term:`hashable` objects"
msgstr "해시 가능한 객체를 세는 데 사용하는 딕셔너리 서브 클래스"

#: ../../library/collections.rst:29
msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

#: ../../library/collections.rst:29
msgid "dict subclass that remembers the order entries were added"
msgstr "항목이 추가된 순서를 기억하는 딕셔너리 서브 클래스"

#: ../../library/collections.rst:30
msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

#: ../../library/collections.rst:30
msgid "dict subclass that calls a factory function to supply missing values"
msgstr "누락된 값을 제공하기 위해 팩토리 함수를 호출하는 딕셔너리 서브 클래스"

#: ../../library/collections.rst:31
msgid ":class:`UserDict`"
msgstr ":class:`UserDict`"

#: ../../library/collections.rst:31
msgid "wrapper around dictionary objects for easier dict subclassing"
msgstr "더 쉬운 딕셔너리 서브 클래싱을 위해 딕셔너리 객체를 감싸는 래퍼"

#: ../../library/collections.rst:32
msgid ":class:`UserList`"
msgstr ":class:`UserList`"

#: ../../library/collections.rst:32
msgid "wrapper around list objects for easier list subclassing"
msgstr "더 쉬운 리스트 서브 클래싱을 위해 리스트 객체를 감싸는 래퍼"

#: ../../library/collections.rst:33
msgid ":class:`UserString`"
msgstr ":class:`UserString`"

#: ../../library/collections.rst:33
msgid "wrapper around string objects for easier string subclassing"
msgstr "더 쉬운 문자열 서브 클래싱을 위해 문자열 객체를 감싸는 래퍼"

#: ../../library/collections.rst:38
msgid ":class:`ChainMap` objects"
msgstr ":class:`ChainMap` 객체"

#: ../../library/collections.rst:42
msgid ""
"A :class:`ChainMap` class is provided for quickly linking a number of "
"mappings so they can be treated as a single unit.  It is often much "
"faster than creating a new dictionary and running multiple "
":meth:`~dict.update` calls."
msgstr ""
":class:`ChainMap` 클래스는 여러 매핑을 빠르게 연결하여 단일 단위로 취급 할 수 있도록 합니다. 종종 새로운 "
"딕셔너리를 만들고 여러 :meth:`~dict.update` 호출을 실행하는 것보다 훨씬 빠릅니다."

#: ../../library/collections.rst:46
msgid ""
"The class can be used to simulate nested scopes and is useful in "
"templating."
msgstr "이 클래스는 중첩된 스코프를 시뮬레이션하는 데 사용할 수 있으며 템플릿에 유용합니다."

#: ../../library/collections.rst:50
msgid ""
"A :class:`ChainMap` groups multiple dicts or other mappings together to "
"create a single, updateable view.  If no *maps* are specified, a single "
"empty dictionary is provided so that a new chain always has at least one "
"mapping."
msgstr ""
":class:`ChainMap`\\은 여러 딕셔너리나 다른 매핑을 함께 묶어 갱신 가능한 단일 뷰를 만듭니다. *maps*\\가 "
"지정되지 않으면, 새 체인에 항상 하나 이상의 매핑이 있도록, 빈 딕셔너리 하나가 제공됩니다."

#: ../../library/collections.rst:54
msgid ""
"The underlying mappings are stored in a list.  That list is public and "
"can be accessed or updated using the *maps* attribute.  There is no other"
" state."
msgstr ""
"하부 매핑은 리스트에 저장됩니다. 이 리스트는 공개이며 *maps* 어트리뷰트를 사용하여 액세스하거나 갱신할 수 있습니다. 다른 "
"상태는 없습니다."

#: ../../library/collections.rst:57
msgid ""
"Lookups search the underlying mappings successively until a key is found."
"  In contrast, writes, updates, and deletions only operate on the first "
"mapping."
msgstr "조회는 키를 찾을 때까지 하부 매핑을 검색합니다. 반면에, 쓰기, 갱신 및 삭제는 첫 번째 매핑에만 작동합니다."

#: ../../library/collections.rst:60
msgid ""
"A :class:`ChainMap` incorporates the underlying mappings by reference.  "
"So, if one of the underlying mappings gets updated, those changes will be"
" reflected in :class:`ChainMap`."
msgstr ""
":class:`ChainMap`\\은 하부 매핑을 참조로 통합합니다. 따라서 하부 매핑 중 하나가 갱신되면 해당 변경 사항이 "
":class:`ChainMap`\\에 반영됩니다."

#: ../../library/collections.rst:64
msgid ""
"All of the usual dictionary methods are supported.  In addition, there is"
" a *maps* attribute, a method for creating new subcontexts, and a "
"property for accessing all but the first mapping:"
msgstr ""
"일반적인 딕셔너리 메서드가 모두 지원됩니다. 또한, *maps* 어트리뷰트, 새 서브 컨텍스트를 만드는 메서드 및 첫 번째 매핑을 "
"제외한 모든 것에 액세스하는 프로퍼티가 있습니다:"

#: ../../library/collections.rst:70
msgid ""
"A user updateable list of mappings.  The list is ordered from first-"
"searched to last-searched.  It is the only stored state and can be "
"modified to change which mappings are searched.  The list should always "
"contain at least one mapping."
msgstr ""
"사용자 갱신 가능한 매핑 리스트. 리스트는 먼저 검색되는 것에서 나중에 검색되는 순서를 따릅니다. 저장된 유일한 상태이며 검색할 "
"매핑을 변경하도록 수정할 수 있습니다. 리스트는 항상 하나 이상의 매핑이 포함되어야 합니다."

#: ../../library/collections.rst:77
#, fuzzy, python-brace-format
msgid ""
"Returns a new :class:`ChainMap` containing a new map followed by all of "
"the maps in the current instance.  If ``m`` is specified, it becomes the "
"new map at the front of the list of mappings; if not specified, an empty "
"dict is used, so that a call to ``d.new_child()`` is equivalent to: "
"``ChainMap({}, *d.maps)``. If any keyword arguments are specified, they "
"update passed map or new empty dict. This method is used for creating "
"subcontexts that can be updated without altering values in any of the "
"parent mappings."
msgstr ""
"새 맵과 그 뒤로 현재 인스턴스의 모든 맵을 포함하는 새 :class:`ChainMap`\\을 반환합니다. ``m``\\이 "
"지정되면, 매핑 리스트의 맨 앞에 놓이는 새 맵이 됩니다. 지정하지 않으면, 빈 딕셔너리가 사용되므로 "
"``d.new_child()`` 호출은 ``ChainMap({}, *d.maps)``\\과 동등합니다. 이 메서드는 어떤 부모 "
"매핑에 있는 값도 변경하지 않으면서 갱신할 수 있는 서브 컨텍스트를 만드는 데 사용됩니다."

#: ../../library/collections.rst:86
msgid "The optional ``m`` parameter was added."
msgstr "선택적 ``m`` 매개 변수가 추가되었습니다."

#: ../../library/collections.rst:89
msgid "Keyword arguments support was added."
msgstr ""

#: ../../library/collections.rst:94
msgid ""
"Property returning a new :class:`ChainMap` containing all of the maps in "
"the current instance except the first one.  This is useful for skipping "
"the first map in the search.  Use cases are similar to those for the "
":keyword:`nonlocal` keyword used in :term:`nested scopes <nested scope>`."
"  The use cases also parallel those for the built-in :func:`super` "
"function.  A reference to ``d.parents`` is equivalent to: "
"``ChainMap(*d.maps[1:])``."
msgstr ""
"첫 번째 맵을 제외하고 현재 인스턴스의 모든 맵을 포함하는 새 :class:`ChainMap`\\을 반환하는 프로퍼티. 검색에서 첫"
" 번째 맵을 건너뛰려고 할 때 유용합니다. 사용 사례는 :term:`중첩된 스코프 <nested scope>`\\에서 사용되는 "
":keyword:`nonlocal` 키워드와 유사합니다. 사용 사례는 내장 :func:`super` 함수와도 유사합니다. "
"``d.parents``\\에 대한 참조는 ``ChainMap(*d.maps[1:])``\\과 동등합니다."

#: ../../library/collections.rst:102
#, fuzzy
msgid ""
"Note, the iteration order of a :class:`ChainMap` is determined by "
"scanning the mappings last to first::"
msgstr ":class:`ChainMap()`\\의 이터레이션 순서는 매핑을 마지막에서 첫 번째 방향으로 스캔하여 결정됩니다::"

#: ../../library/collections.rst:105
#, python-brace-format
msgid ""
">>> baseline = {'music': 'bach', 'art': 'rembrandt'}\n"
">>> adjustments = {'art': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(adjustments, baseline))\n"
"['music', 'art', 'opera']"
msgstr ""

#: ../../library/collections.rst:110
msgid ""
"This gives the same ordering as a series of :meth:`dict.update` calls "
"starting with the last mapping::"
msgstr "이것은 마지막 매핑에서 시작하는 일련의 :meth:`dict.update` 호출과 같은 순서를 제공합니다::"

#: ../../library/collections.rst:113
msgid ""
">>> combined = baseline.copy()\n"
">>> combined.update(adjustments)\n"
">>> list(combined)\n"
"['music', 'art', 'opera']"
msgstr ""

#: ../../library/collections.rst:118
msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr ":pep:`584`\\에 지정된, ``|``\\와 ``|=`` 연산자에 대한 지원이 추가되었습니다."

#: ../../library/collections.rst:123
msgid ""
"The `MultiContext class "
"<https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py>`_"
" in the Enthought `CodeTools package "
"<https://github.com/enthought/codetools>`_ has options to support writing"
" to any mapping in the chain."
msgstr ""
"Enthought `CodeTools 패키지 <https://github.com/enthought/codetools>`_\\의 "
"`MultiContext 클래스 "
"<https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py>`_\\에는"
" 체인의 모든 매핑으로의 쓰기를 지원하는 옵션이 있습니다."

#: ../../library/collections.rst:129
msgid ""
"Django's `Context class "
"<https://github.com/django/django/blob/main/django/template/context.py>`_"
" for templating is a read-only chain of mappings.  It also features "
"pushing and popping of contexts similar to the "
":meth:`~collections.ChainMap.new_child` method and the "
":attr:`~collections.ChainMap.parents` property."
msgstr ""
"템플릿을 위한 Django의 `Context 클래스 "
"<https://github.com/django/django/blob/main/django/template/context.py>`_\\는"
" 읽기 전용 매핑 체인입니다. 또한 :meth:`~collections.ChainMap.new_child` 메서드와 "
":attr:`~collections.ChainMap.parents` 프로퍼티와 유사하게 컨텍스트를 푸시(push)하고 팝(pop) "
"하는 기능이 있습니다."

#: ../../library/collections.rst:136
#, fuzzy
msgid ""
"The `Nested Contexts recipe <https://code.activestate.com/recipes/577434"
"-nested-contexts-a-chain-of-mapping-objects/>`_ has options to control "
"whether writes and other mutations apply only to the first mapping or to "
"any mapping in the chain."
msgstr ""
"`중첩된 컨텍스트 조리법 <https://code.activestate.com/recipes/577434/>`_\\에는 쓰기와 기타"
" 변경이 첫 번째 매핑에만 적용되는지 아니면 체인의 모든 매핑에 적용되는지를 제어하는 옵션이 있습니다."

#: ../../library/collections.rst:141
msgid ""
"A `greatly simplified read-only version of Chainmap "
"<https://code.activestate.com/recipes/305268/>`_."
msgstr "`매우 단순화된 체인 맵의 읽기 전용 버전 <https://code.activestate.com/recipes/305268/>`_"

#: ../../library/collections.rst:146
msgid ":class:`ChainMap` Examples and Recipes"
msgstr ":class:`ChainMap` 예제와 조리법"

#: ../../library/collections.rst:148
msgid "This section shows various approaches to working with chained maps."
msgstr "이 절에서는 체인 맵으로 작업하는 다양한 접근 방식을 보여줍니다."

#: ../../library/collections.rst:151
msgid "Example of simulating Python's internal lookup chain::"
msgstr "파이썬의 내부 조회 체인을 시뮬레이션하는 예::"

#: ../../library/collections.rst:153
msgid ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"
msgstr ""

#: ../../library/collections.rst:156
msgid ""
"Example of letting user specified command-line arguments take precedence "
"over environment variables which in turn take precedence over default "
"values::"
msgstr "사용자 지정 명령 줄 인자가 환경 변수보다 우선하고, 환경 변수는 기본값보다 우선하도록 하는 예::"

#: ../../library/collections.rst:159
#, python-brace-format
msgid ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not"
" None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"
msgstr ""

#: ../../library/collections.rst:173
msgid ""
"Example patterns for using the :class:`ChainMap` class to simulate nested"
" contexts::"
msgstr "중첩된 컨텍스트를 시뮬레이션하기 위해 :class:`ChainMap` 클래스를 사용하는 예제 패턴::"

#: ../../library/collections.rst:176
msgid ""
"c = ChainMap()        # Create root context\n"
"d = c.new_child()     # Create nested child context\n"
"e = c.new_child()     # Child of c, independent from d\n"
"e.maps[0]             # Current context dictionary -- like Python's "
"locals()\n"
"e.maps[-1]            # Root context -- like Python's globals()\n"
"e.parents             # Enclosing context chain -- like Python's "
"nonlocals\n"
"\n"
"d['x'] = 1            # Set value in current context\n"
"d['x']                # Get first key in the chain of contexts\n"
"del d['x']            # Delete from current context\n"
"list(d)               # All nested values\n"
"k in d                # Check all nested values\n"
"len(d)                # Number of nested values\n"
"d.items()             # All nested items\n"
"dict(d)               # Flatten into a regular dictionary"
msgstr ""

#: ../../library/collections.rst:192
msgid ""
"The :class:`ChainMap` class only makes updates (writes and deletions) to "
"the first mapping in the chain while lookups will search the full chain."
"  However, if deep writes and deletions are desired, it is easy to make a"
" subclass that updates keys found deeper in the chain::"
msgstr ""
":class:`ChainMap` 클래스는 체인의 첫 번째 매핑만 갱신(쓰기와 삭제)하지만, 조회는 전체 체인을 검색합니다. 그러나,"
" 깊은 쓰기와 삭제가 필요하면, 체인의 더 깊은 곳에서 발견된 키를 갱신하는 서브 클래스를 쉽게 만들 수 있습니다::"

#: ../../library/collections.rst:197
#, python-brace-format
msgid ""
"class DeepChainMap(ChainMap):\n"
"    'Variant of ChainMap that allows direct updates to inner scopes'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': "
"'yellow'})\n"
">>> d['lion'] = 'orange'         # update an existing key two levels down"
"\n"
">>> d['snake'] = 'red'           # new keys get added to the topmost dict"
"\n"
">>> del d['elephant']            # remove an existing key one level down\n"
">>> d                            # display result\n"
"DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})"
msgstr ""

#: ../../library/collections.rst:223
msgid ":class:`Counter` objects"
msgstr ":class:`Counter` 객체"

#: ../../library/collections.rst:225
msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr "편리하고 빠르게 개수를 세도록 지원하는 계수기 도구가 제공됩니다. 예를 들면::"

#: ../../library/collections.rst:228
#, python-brace-format
msgid ""
">>> # Tally occurrences of words in a list\n"
">>> cnt = Counter()\n"
">>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})\n"
"\n"
">>> # Find the ten most common words in Hamlet\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"
msgstr ""

#: ../../library/collections.rst:245
#, fuzzy
msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting "
":term:`hashable` objects. It is a collection where elements are stored as"
" dictionary keys and their counts are stored as dictionary values.  "
"Counts are allowed to be any integer value including zero or negative "
"counts.  The :class:`Counter` class is similar to bags or multisets in "
"other languages."
msgstr ""
":class:`Counter`\\는 해시 가능한 객체를 세기 위한 :class:`dict` 서브 클래스입니다. 요소가 딕셔너리 키로"
" 저장되고 개수가 딕셔너리값으로 저장되는 컬렉션입니다. 개수는 0이나 음수를 포함하는 임의의 정숫값이 될 수 있습니다. "
":class:`Counter` 클래스는 다른 언어의 백(bag)이나 멀티 셋(multiset)과 유사합니다."

#: ../../library/collections.rst:251
msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr "요소는 *이터러블*\\로부터 계산되거나 다른 *매핑*\\(또는 계수기)에서 초기화됩니다:"

#: ../../library/collections.rst:259
msgid ""
"Counter objects have a dictionary interface except that they return a "
"zero count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"계수기 객체는 누락된 항목에 대해 :exc:`KeyError`\\를 발생시키는 대신 0을 반환한다는 점을 제외하고 딕셔너리 "
"인터페이스를 갖습니다:"

#: ../../library/collections.rst:266
msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr "개수를 0으로 설정해도 계수기에서 요소가 제거되지 않습니다. 완전히 제거하려면 ``del``\\을 사용하십시오:"

#: ../../library/collections.rst:274
#, fuzzy
msgid ""
"As a :class:`dict` subclass, :class:`Counter` inherited the capability to"
" remember insertion order.  Math operations on *Counter* objects also "
"preserve order.  Results are ordered according to when an element is "
"first encountered in the left operand and then by the order encountered "
"in the right operand."
msgstr ""
":class:`dict` 서브 클래스로서, :class:`Counter`\\는 삽입 순서를 기억하는 기능을 상속했습니다. "
"*Counter* 객체에 대한 수학 연산도 순서를 유지합니다. 결과는 요소가 왼쪽 피연산자에서 처음 발견된 순서로 먼저 나열된 후 "
"오른쪽 피연산자에서 새로 발견되는 순서로 나열되는 순서를 따릅니다."

#: ../../library/collections.rst:280
#, fuzzy
msgid ""
"Counter objects support additional methods beyond those available for all"
" dictionaries:"
msgstr "계수기 객체는 모든 딕셔너리에서 사용할 수 있는 메서드 이외의 세 가지 메서드를 지원합니다:"

#: ../../library/collections.rst:285
msgid ""
"Return an iterator over elements repeating each as many times as its "
"count.  Elements are returned in the order first encountered. If an "
"element's count is less than one, :meth:`elements` will ignore it."
msgstr ""
"개수만큼 반복되는 요소에 대한 이터레이터를 반환합니다. 요소는 처음 발견되는 순서대로 반환됩니다. 요소의 개수가 1보다 작으면 "
":meth:`elements`\\는 이를 무시합니다."

#: ../../library/collections.rst:295
msgid ""
"Return a list of the *n* most common elements and their counts from the "
"most common to the least.  If *n* is omitted or ``None``, "
":meth:`most_common` returns *all* elements in the counter. Elements with "
"equal counts are ordered in the order first encountered:"
msgstr ""
"*n* 개의 가장 흔한 요소와 그 개수를 가장 흔한 것부터 가장 적은 것 순으로 나열한 리스트를 반환합니다. *n*\\이 생략되거나"
" ``None``\\이면, :meth:`most_common`\\은 계수기의 *모든* 요소를 반환합니다. 개수가 같은 요소는 처음 "
"발견된 순서를 유지합니다:"

#: ../../library/collections.rst:305
msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"*이터러블*\\이나 다른 *매핑* (또는 계수기)으로부터 온 요소들을 뺍니다. :meth:`dict.update`\\와 비슷하지만 "
"교체하는 대신 개수를 뺍니다. 입력과 출력 모두 0이나 음수일 수 있습니다."

#: ../../library/collections.rst:319
msgid "Compute the sum of the counts."
msgstr ""

#: ../../library/collections.rst:327
msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr "일반적인 딕셔너리 메서드를 :class:`Counter` 객체에 사용할 수 있습니다만, 두 메서드는 계수기에서 다르게 동작합니다."

#: ../../library/collections.rst:332
msgid "This class method is not implemented for :class:`Counter` objects."
msgstr "이 클래스 메서드는 :class:`Counter` 객체에 구현되지 않았습니다."

#: ../../library/collections.rst:336
msgid ""
"Elements are counted from an *iterable* or added-in from another "
"*mapping* (or counter).  Like :meth:`dict.update` but adds counts instead"
" of replacing them.  Also, the *iterable* is expected to be a sequence of"
" elements, not a sequence of ``(key, value)`` pairs."
msgstr ""
"요소는 *이터러블*\\에서 세거나 다른 *매핑*\\(또는 계수기)에서 더해집니다. :meth:`dict.update`\\와 "
"비슷하지만, 교체하는 대신 더합니다. 또한, *이터러블*\\은 ``(key, value)`` 쌍의 시퀀스가 아닌, 요소의 시퀀스일 "
"것으로 기대합니다."

#: ../../library/collections.rst:341
msgid ""
"Counters support rich comparison operators for equality, subset, and "
"superset relationships: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. All"
" of those tests treat missing elements as having zero counts so that "
"``Counter(a=1) == Counter(a=1, b=0)`` returns true."
msgstr ""

#: ../../library/collections.rst:346
msgid "Rich comparison operations were added."
msgstr ""

#: ../../library/collections.rst:349
msgid ""
"In equality tests, missing elements are treated as having zero counts. "
"Formerly, ``Counter(a=3)`` and ``Counter(a=3, b=0)`` were considered "
"distinct."
msgstr ""

#: ../../library/collections.rst:354
msgid "Common patterns for working with :class:`Counter` objects::"
msgstr ":class:`Counter` 객체로 작업하는 일반적인 패턴::"

#: ../../library/collections.rst:356
msgid ""
"c.total()                       # total of all counts\n"
"c.clear()                       # reset all counts\n"
"list(c)                         # list unique elements\n"
"set(c)                          # convert to a set\n"
"dict(c)                         # convert to a regular dictionary\n"
"c.items()                       # access the (elem, cnt) pairs\n"
"Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) "
"pairs\n"
"c.most_common()[:-n-1:-1]       # n least common elements\n"
"+c                              # remove zero and negative counts"
msgstr ""

#: ../../library/collections.rst:366
#, fuzzy
msgid ""
"Several mathematical operations are provided for combining "
":class:`Counter` objects to produce multisets (counters that have counts "
"greater than zero). Addition and subtraction combine counters by adding "
"or subtracting the counts of corresponding elements.  Intersection and "
"union return the minimum and maximum of corresponding counts.  Equality "
"and inclusion compare corresponding counts.  Each operation can accept "
"inputs with signed counts, but the output will exclude results with "
"counts of zero or less."
msgstr ""
":class:`Counter` 객체를 결합하여 멀티 셋(multiset, 개수가 0보다 큰 계수기)을 생성하는 여러 수학 연산이 "
"제공됩니다. 더하기와 빼기는 해당 요소의 개수를 더 하거나 빼서 계수기를 결합합니다. 교집합(intersection)과 "
"합집합(union)은 해당 개수의 최솟값과 최댓값을 반환합니다. 각 연산은 부호 있는 개수를 입력으로 받을 수 있지만, 출력은 "
"개수가 0 이하면 결과에서 제외합니다."

#: ../../library/collections.rst:374
#, python-brace-format
msgid ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # add two counters together:  c[x] + d[x]"
"\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # subtract (keeping only positive counts)"
"\n"
"Counter({'a': 2})\n"
">>> c & d                       # intersection:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # union:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # equality:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # inclusion:  c[x] <= d[x]\n"
"False"
msgstr ""

#: ../../library/collections.rst:391
msgid ""
"Unary addition and subtraction are shortcuts for adding an empty counter "
"or subtracting from an empty counter."
msgstr "단항 덧셈과 뺄셈은 빈 계수기를 더하거나 빈 계수기를 빼는 것의 줄임 표현입니다."

#: ../../library/collections.rst:400
msgid ""
"Added support for unary plus, unary minus, and in-place multiset "
"operations."
msgstr "단항 플러스, 단항 마이너스 및 제자리 멀티 셋 연산에 대한 지원이 추가되었습니다."

#: ../../library/collections.rst:405
msgid ""
"Counters were primarily designed to work with positive integers to "
"represent running counts; however, care was taken to not unnecessarily "
"preclude use cases needing other types or negative values.  To help with "
"those use cases, this section documents the minimum range and type "
"restrictions."
msgstr ""
"계수기는 주로 양의 정수로 작동하여 횟수를 나타내도록 설계되었습니다; 그러나, 다른 형이나 음수 값이 필요한 사용 사례를 불필요하게"
" 배제하지 않도록 주의를 기울였습니다. 이러한 사용 사례에 도움이 되도록, 이 절은 최소 범위와 형 제약 사항을 설명합니다."

#: ../../library/collections.rst:410
msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be "
"numbers representing counts, but you *could* store anything in the value "
"field."
msgstr ""
":class:`Counter` 클래스 자체는 키와 값에 제한이 없는 딕셔너리 서브 클래스입니다. 값은 개수를 나타내는 숫자로 "
"의도되었지만, 값 필드에 어떤 것이든 저장할 *수* 있습니다."

#: ../../library/collections.rst:414
msgid ""
"The :meth:`~Counter.most_common` method requires only that the values be "
"orderable."
msgstr ":meth:`~Counter.most_common` 메서드는 값에 대해 순서만을 요구합니다."

#: ../../library/collections.rst:416
msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only"
" support addition and subtraction.  So fractions, floats, and decimals "
"would work and negative values are supported.  The same is also true for "
":meth:`~Counter.update` and :meth:`~Counter.subtract` which allow "
"negative and zero values for both inputs and outputs."
msgstr ""
"``c[key] += 1``\\과 같은 제자리 연산의 경우, 값 형은 덧셈과 뺄셈만 지원하면 됩니다. 따라서 "
"분수(fractions), 부동 소수점(floats) 및 십진수(decimals)가 작동하고 음수 값이 지원됩니다. "
":meth:`~Counter.update`\\와 :meth:`~Counter.subtract`\\에 대해서도 마찬가지인데, 입력과 "
"출력 모두 음수와 0을 허용합니다."

#: ../../library/collections.rst:422
msgid ""
"The multiset methods are designed only for use cases with positive "
"values. The inputs may be negative or zero, but only outputs with "
"positive values are created.  There are no type restrictions, but the "
"value type needs to support addition, subtraction, and comparison."
msgstr ""
"멀티 셋(multiset) 메서드는 양의 값에 대한 사용 사례를 위해서만 설계되었습니다. 입력은 음수이거나 0일 수 있지만, 양수 "
"값을 갖는 출력만 만들어집니다. 형 제한은 없지만, 값 형은 더하기, 빼기 및 비교를 지원해야 합니다."

#: ../../library/collections.rst:427
msgid ""
"The :meth:`~Counter.elements` method requires integer counts.  It ignores"
" zero and negative counts."
msgstr ":meth:`~Counter.elements` 메서드는 정수 개수를 요구합니다. 0과 음수 개수는 무시합니다."

#: ../../library/collections.rst:432
msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-"
"base/html_node/Bag.html>`_ in Smalltalk."
msgstr ""
"스몰토크(Smalltalk)의 `Bag 클래스 <https://www.gnu.org/software/smalltalk/manual-"
"base/html_node/Bag.html>`_."

#: ../../library/collections.rst:435
msgid "Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr "`Multisets <https://en.wikipedia.org/wiki/Multiset>`_\\에 대한 위키피디아 항목."

#: ../../library/collections.rst:437
msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset"
"/Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"예제가 포함된 `C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-"
"multiset/Catalog0380__set-multiset.htm>`_ 자습서."

#: ../../library/collections.rst:440
msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth,"
" Donald. The Art of Computer Programming Volume II, Section 4.6.3, "
"Exercise 19*."
msgstr ""
"멀티 셋에 대한 수학 연산과 그 사용 사례에 대해서는, *Knuth, Donald. The Art of Computer "
"Programming Volume II, Section 4.6.3, Exercise 19*\\를 참조하십시오."

#: ../../library/collections.rst:444
msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`::"
msgstr ""
"주어진 요소 집합에 대해 주어진 크기의 모든 서로 다른 멀티 셋을 열거하려면, "
":func:`itertools.combinations_with_replacement`\\를 참조하십시오::"

#: ../../library/collections.rst:447
msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB "
"BC CC"
msgstr ""

#: ../../library/collections.rst:451
msgid ":class:`deque` objects"
msgstr ":class:`deque` 객체"

#: ../../library/collections.rst:455
msgid ""
"Returns a new deque object initialized left-to-right (using "
":meth:`append`) with data from *iterable*.  If *iterable* is not "
"specified, the new deque is empty."
msgstr ""
"*iterable*\\의 데이터로 왼쪽에서 오른쪽으로 (:meth:`append`\\를 사용해서) 초기화된 새 데크(deque) "
"객체를 반환합니다. *iterable*\\을 지정하지 않으면, 새 데크는 비어 있습니다."

#: ../../library/collections.rst:458
#, fuzzy
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support "
"thread-safe, memory efficient appends and pops from either side of the "
"deque with approximately the same *O*\\ (1) performance in either "
"direction."
msgstr ""
"데크는 스택과 큐를 일반화 한 것입니다 (이름은 \"deck\"이라고 발음하며 \"double-ended queue\"의 "
"약자입니다). 데크는 스레드 안전하고 메모리 효율적인 데크의 양쪽 끝에서의 추가(append)와 팝(pop)을 양쪽에서 거의 같은 "
"O(1) 성능으로 지원합니다."

#: ../../library/collections.rst:463
#, fuzzy
msgid ""
"Though :class:`list` objects support similar operations, they are "
"optimized for fast fixed-length operations and incur *O*\\ (*n*) memory "
"movement costs for ``pop(0)`` and ``insert(0, v)`` operations which "
"change both the size and position of the underlying data representation."
msgstr ""
":class:`list` 객체는 유사한 연산을 지원하지만, 빠른 고정 길이 연산에 최적화되어 있으며, 하부 데이터 표현의 크기와 "
"위치를 모두 변경하는 ``pop(0)``\\과 ``insert(0, v)`` 연산에 대해 O(n) 메모리 이동 비용이 발생합니다."

#: ../../library/collections.rst:469
msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an "
"arbitrary length.  Otherwise, the deque is bounded to the specified "
"maximum length.  Once a bounded length deque is full, when new items are "
"added, a corresponding number of items are discarded from the opposite "
"end.  Bounded length deques provide functionality similar to the ``tail``"
" filter in Unix. They are also useful for tracking transactions and other"
" pools of data where only the most recent activity is of interest."
msgstr ""
"*maxlen*\\이 지정되지 않거나 ``None``\\이면, 데크는 임의의 길이로 커질 수 있습니다. 그렇지 않으면, 데크는 "
"지정된 최대 길이로 제한됩니다. 일단 제한된 길이의 데크가 가득 차면, 새 항목이 추가될 때, 해당하는 수의 항목이 반대쪽 끝에서 "
"삭제됩니다. 제한된 길이의 데크는 유닉스의 ``tail`` 필터와 유사한 기능을 제공합니다. 또한 가장 최근 활동만 관심이 있는 "
"트랜잭션과 기타 데이터 풀을 추적하는 데 유용합니다."

#: ../../library/collections.rst:478
msgid "Deque objects support the following methods:"
msgstr "deque 객체는 다음 메서드를 지원합니다:"

#: ../../library/collections.rst:482
msgid "Add *x* to the right side of the deque."
msgstr "데크의 오른쪽에 *x*\\를 추가합니다."

#: ../../library/collections.rst:487
msgid "Add *x* to the left side of the deque."
msgstr "데크의 왼쪽에 *x*\\를 추가합니다."

#: ../../library/collections.rst:492
msgid "Remove all elements from the deque leaving it with length 0."
msgstr "데크에서 모든 요소를 제거하고 길이가 0인 상태로 만듭니다."

#: ../../library/collections.rst:497
msgid "Create a shallow copy of the deque."
msgstr "데크의 얕은 복사본을 만듭니다."

#: ../../library/collections.rst:504
msgid "Count the number of deque elements equal to *x*."
msgstr "*x* 와 같은 데크 요소의 수를 셉니다."

#: ../../library/collections.rst:511
msgid ""
"Extend the right side of the deque by appending elements from the "
"iterable argument."
msgstr "iterable 인자에서 온 요소를 추가하여 데크의 오른쪽을 확장합니다."

#: ../../library/collections.rst:517
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of "
"elements in the iterable argument."
msgstr ""
"*iterable*\\에서 온 요소를 추가하여 데크의 왼쪽을 확장합니다. 일련의 왼쪽 추가는 iterable 인자에 있는 요소의 "
"순서를 뒤집는 결과를 줍니다."

#: ../../library/collections.rst:524
msgid ""
"Return the position of *x* in the deque (at or after index *start* and "
"before index *stop*).  Returns the first match or raises "
":exc:`ValueError` if not found."
msgstr ""
"데크에 있는 *x*\\의 위치를 반환합니다 (인덱스 *start* 또는 그 이후, 그리고 인덱스 *stop* 이전). 첫 번째 "
"일치를 반환하거나 찾을 수 없으면 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/collections.rst:533
msgid "Insert *x* into the deque at position *i*."
msgstr "*x*\\를 데크의 *i* 위치에 삽입합니다."

#: ../../library/collections.rst:535
msgid ""
"If the insertion would cause a bounded deque to grow beyond *maxlen*, an "
":exc:`IndexError` is raised."
msgstr "삽입으로 인해 제한된 길이의 데크가 *maxlen* 이상으로 커지면, :exc:`IndexError`\\가 발생합니다."

#: ../../library/collections.rst:543
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr "데크의 오른쪽에서 요소를 제거하고 반환합니다. 요소가 없으면, :exc:`IndexError`\\를 발생시킵니다."

#: ../../library/collections.rst:549
msgid ""
"Remove and return an element from the left side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr "데크의 왼쪽에서 요소를 제거하고 반환합니다. 요소가 없으면, :exc:`IndexError`\\를 발생시킵니다."

#: ../../library/collections.rst:555
msgid ""
"Remove the first occurrence of *value*.  If not found, raises a "
":exc:`ValueError`."
msgstr "*value*\\의 첫 번째 항목을 제거합니다. 찾을 수 없으면, :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/collections.rst:561
msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "데크의 요소들을 제자리에서 순서를 뒤집고 ``None``\\을 반환합니다."

#: ../../library/collections.rst:568
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to "
"the left."
msgstr "데크를 *n* 단계 오른쪽으로 회전합니다. *n*\\이 음수이면, 왼쪽으로 회전합니다."

#: ../../library/collections.rst:571
msgid ""
"When the deque is not empty, rotating one step to the right is equivalent"
" to ``d.appendleft(d.pop())``, and rotating one step to the left is "
"equivalent to ``d.append(d.popleft())``."
msgstr ""
"데크가 비어 있지 않으면, 오른쪽으로 한 단계 회전하는 것은 ``d.appendleft(d.pop())``\\과 동등하고, 왼쪽으로"
" 한 단계 회전하는 것은 ``d.append(d.popleft())``\\와 동등합니다."

#: ../../library/collections.rst:576
msgid "Deque objects also provide one read-only attribute:"
msgstr "데크 객체는 하나의 읽기 전용 어트리뷰트도 제공합니다:"

#: ../../library/collections.rst:580
msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "데크의 최대 크기 또는 제한이 없으면 ``None``."

#: ../../library/collections.rst:585
#, fuzzy
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``,"
" ``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership "
"testing with the :keyword:`in` operator, and subscript references such as"
" ``d[0]`` to access the first element.  Indexed access is *O*\\ (1) at "
"both ends but slows to *O*\\ (*n*) in the middle.  For fast random "
"access, use lists instead."
msgstr ""
"상기한 것들 외에도, 데크는 이터레이션, 피클링, ``len(d)``, ``reversed(d)``, "
"``copy.copy(d)``, ``copy.deepcopy(d)``, :keyword:`in` 연산자를 사용한 멤버십 검사 및 첫"
" 번째 요소를 액세스하는 ``d[0]``\\과 같은 서브 스크립트 참조를 지원합니다. 인덱스를 사용하는 액세스는 양쪽 끝에서는 "
"O(1) 이지만 중간에서는 O(n) 으로 느려집니다. 빠른 무작위 액세스를 위해서는 대신 리스트를 사용하십시오."

#: ../../library/collections.rst:591
msgid ""
"Starting in version 3.5, deques support ``__add__()``, ``__mul__()``, and"
" ``__imul__()``."
msgstr "버전 3.5부터, 데크는 ``__add__()``, ``__mul__()`` 및 ``__imul__()``\\을 지원합니다."

#: ../../library/collections.rst:594
msgid "Example:"
msgstr "예:"

#: ../../library/collections.rst:596
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the "
"deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost "
"item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost "
"item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in "
"reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input "
"order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""

#: ../../library/collections.rst:651
msgid ":class:`deque` Recipes"
msgstr ":class:`deque` 조리법"

#: ../../library/collections.rst:653
msgid "This section shows various approaches to working with deques."
msgstr "이 절은 데크로 작업하는 다양한 접근 방식을 보여줍니다."

#: ../../library/collections.rst:655
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` "
"filter in Unix::"
msgstr "제한된 길이의 데크는 유닉스의 ``tail`` 필터와 유사한 기능을 제공합니다::"

#: ../../library/collections.rst:658
msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    with open(filename) as f:\n"
"        return deque(f, n)"
msgstr ""

#: ../../library/collections.rst:663
msgid ""
"Another approach to using deques is to maintain a sequence of recently "
"added elements by appending to the right and popping to the left::"
msgstr "데크를 사용하는 또 다른 접근법은 오른쪽에 추가하고 왼쪽에서 팝 하여 최근에 추가된 요소의 시퀀스를 유지하는 것입니다::"

#: ../../library/collections.rst:666
msgid ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"
msgstr ""

#: ../../library/collections.rst:678
msgid ""
"A `round-robin scheduler <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ can be implemented with input iterators stored in a "
":class:`deque`.  Values are yielded from the active iterator in position "
"zero.  If that iterator is exhausted, it can be removed with "
":meth:`~deque.popleft`; otherwise, it can be cycled back to the end with "
"the :meth:`~deque.rotate` method::"
msgstr ""
"`라운드 로빈 스케줄러(round-robin scheduler) <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_\\는 :class:`deque`\\에 저장된 입력 이터레이터로 구현할 수 있습니다. 위치 0에 "
"있는 활성 이터레이터에서 값이 산출됩니다. 그 이터레이터가 소진되면, :meth:`~deque.popleft`\\로 제거할 수 "
"있습니다; 그렇지 않으면, :meth:`~deque.rotate` 메서드로 끝으로 보내 순환할 수 있습니다::"

#: ../../library/collections.rst:685
msgid ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iterators = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        try:\n"
"            while True:\n"
"                yield next(iterators[0])\n"
"                iterators.rotate(-1)\n"
"        except StopIteration:\n"
"            # Remove an exhausted iterator.\n"
"            iterators.popleft()"
msgstr ""

#: ../../library/collections.rst:697
msgid ""
"The :meth:`~deque.rotate` method provides a way to implement "
":class:`deque` slicing and deletion.  For example, a pure Python "
"implementation of ``del d[n]`` relies on the ``rotate()`` method to "
"position elements to be popped::"
msgstr ""
":meth:`~deque.rotate` 메서드는 :class:`deque` 슬라이싱과 삭제를 구현하는 방법을 제공합니다. 예를 "
"들어, ``del d[n]``\\의 순수 파이썬 구현은 팝 될 요소의 위치를 잡기 위해 ``rotate()`` 메서드에 "
"의존합니다::"

#: ../../library/collections.rst:701
msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""

#: ../../library/collections.rst:706
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying "
":meth:`~deque.rotate` to bring a target element to the left side of the "
"deque. Remove old entries with :meth:`~deque.popleft`, add new entries "
"with :meth:`~deque.extend`, and then reverse the rotation. With minor "
"variations on that approach, it is easy to implement Forth style stack "
"manipulations such as ``dup``, ``drop``, ``swap``, ``over``, ``pick``, "
"``rot``, and ``roll``."
msgstr ""
":class:`deque` 슬라이싱을 구현하려면, 대상 요소를 데크의 왼쪽으로 가져오기 위해 "
":meth:`~deque.rotate`\\를 적용하는 유사한 접근법을 사용하십시오. :meth:`~deque.popleft`\\로 "
"이전 항목을 제거하고, :meth:`~deque.extend`\\로 새 항목을 추가한 다음, 회전을 되돌립니다. 이 접근 방식에 "
"약간의 변형을 가하면, ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot`` 및 "
"``roll``\\과 같은 Forth 스타일 스택 조작을 쉽게 구현할 수 있습니다."

#: ../../library/collections.rst:716
msgid ":class:`defaultdict` objects"
msgstr ":class:`defaultdict` 객체"

#: ../../library/collections.rst:720
#, fuzzy
msgid ""
"Return a new dictionary-like object.  :class:`defaultdict` is a subclass "
"of the built-in :class:`dict` class.  It overrides one method and adds "
"one writable instance variable.  The remaining functionality is the same "
"as for the :class:`dict` class and is not documented here."
msgstr ""
"새 딕셔너리류 객체를 반환합니다. :class:`defaultdict`\\는 내장 :class:`dict` 클래스의 서브 "
"클래스입니다. 하나의 메서드를 재정의하고 하나의 쓰기 가능한 인스턴스 변수를 추가합니다. 나머지 기능은 :class:`dict` "
"클래스와 같고 여기에 설명하지 않습니다."

#: ../../library/collections.rst:725
msgid ""
"The first argument provides the initial value for the "
":attr:`default_factory` attribute; it defaults to ``None``. All remaining"
" arguments are treated the same as if they were passed to the "
":class:`dict` constructor, including keyword arguments."
msgstr ""
"첫 번째 인자는 :attr:`default_factory` 어트리뷰트의 초깃값을 제공합니다; 기본값은 ``None``\\입니다. "
"나머지 모든 인자는 키워드 인자를 포함하여 :class:`dict` 생성자에 전달될 때와 마찬가지로 취급됩니다."

#: ../../library/collections.rst:731
msgid ""
":class:`defaultdict` objects support the following method in addition to "
"the standard :class:`dict` operations:"
msgstr ":class:`defaultdict` 객체는 표준 :class:`dict` 연산 외에도 다음 메서드를 지원합니다:"

#: ../../library/collections.rst:736
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a "
":exc:`KeyError` exception with the *key* as argument."
msgstr ""
":attr:`default_factory` 어트리뷰트가 ``None``\\이면, *key*\\를 인자로 사용하는 "
":exc:`KeyError` 예외가 발생합니다."

#: ../../library/collections.rst:739
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without "
"arguments to provide a default value for the given *key*, this value is "
"inserted in the dictionary for the *key*, and returned."
msgstr ""
":attr:`default_factory`\\가 ``None``\\이 아니면, 주어진 *key*\\에 대한 기본값을 제공하기 위해 "
"인자 없이 호출되며, 반환 값은 *key*\\로 딕셔너리에 삽입되고 반환됩니다."

#: ../../library/collections.rst:743
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ":attr:`default_factory`\\를 호출할 때 예외가 발생하면 이 예외는 변경되지 않고 전파됩니다."

#: ../../library/collections.rst:746
#, fuzzy
msgid ""
"This method is called by the :meth:`~object.__getitem__` method of the "
":class:`dict` class when the requested key is not found; whatever it "
"returns or raises is then returned or raised by "
":meth:`~object.__getitem__`."
msgstr ""
"이 메서드는 요청된 키를 찾을 수 없을 때 :class:`dict` 클래스의 :meth:`__getitem__` 메서드에 의해 "
"호출됩니다; 이것이 반환하거나 발생시키는 모든 것은, :meth:`__getitem__`\\이 반환하거나 발생시킵니다."

#: ../../library/collections.rst:750
#, fuzzy
msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides "
":meth:`~object.__getitem__`. This means that :meth:`~dict.get` will, like"
" normal dictionaries, return ``None`` as a default rather than using "
":attr:`default_factory`."
msgstr ""
":meth:`__missing__`\\은 :meth:`__getitem__` 이외의 어떤 연산에서도 호출되지 *않음*\\에 "
"유의하십시오. 이것은 :meth:`get`\\이 일반 딕셔너리와 마찬가지로 :attr:`default_factory`\\를 사용하지"
" 않고 ``None``\\을 기본값으로 반환한다는 것을 의미합니다."

#: ../../library/collections.rst:756
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ":class:`defaultdict` 객체는 다음 인스턴스 변수를 지원합니다:"

#: ../../library/collections.rst:761
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is "
"initialized from the first argument to the constructor, if present, or to"
" ``None``, if absent."
msgstr ""
"이 어트리뷰트는 :meth:`__missing__` 메서드에서 사용됩니다; 생성자의 첫 번째 인자가 있으면 그것으로, 없으면 "
"``None``\\으로 초기화됩니다."

#: ../../library/collections.rst:765 ../../library/collections.rst:1192
msgid ""
"Added merge (``|``) and update (``|=``) operators, specified in "
":pep:`584`."
msgstr ":pep:`584`\\에 지정된, 병합(``|``)과 업데이트(``|=``) 연산자가 추가되었습니다."

#: ../../library/collections.rst:771
msgid ":class:`defaultdict` Examples"
msgstr ":class:`defaultdict` 예"

#: ../../library/collections.rst:773
msgid ""
"Using :class:`list` as the :attr:`~defaultdict.default_factory`, it is "
"easy to group a sequence of key-value pairs into a dictionary of lists:"
msgstr ""
":class:`list`\\를 :attr:`~defaultdict.default_factory`\\로 사용하면, 키-값 쌍의 "
"시퀀스를 리스트의 딕셔너리로 쉽게 그룹화 할 수 있습니다:"

#: ../../library/collections.rst:784
#, fuzzy
msgid ""
"When each key is encountered for the first time, it is not already in the"
" mapping; so an entry is automatically created using the "
":attr:`~defaultdict.default_factory` function which returns an empty "
":class:`list`.  The :meth:`!list.append` operation then attaches the "
"value to the new list.  When keys are encountered again, the look-up "
"proceeds normally (returning the list for that key) and the "
":meth:`!list.append` operation adds another value to the list. This "
"technique is simpler and faster than an equivalent technique using "
":meth:`dict.setdefault`:"
msgstr ""
"각 키가 처음 발견될 때, 아직 매핑에 있지 않게 됩니다; 그래서 :attr:`~defaultdict.default_factory`"
" 함수를 사용하여 항목이 자동으로 만들어지는데, 빈 :class:`list`\\를 반환합니다. 그런 다음 "
":meth:`list.append` 연산이 값을 새 리스트에 추가합니다. 키를 다시 만나면, 조회가 정상적으로 진행되고 (해당 키의"
" 리스트를 반환합니다), :meth:`list.append` 연산은 다른 값을 리스트에 추가합니다. 이 기법은 "
":meth:`dict.setdefault`\\를 사용하는 동등한 기법보다 간단하고 빠릅니다:"

#: ../../library/collections.rst:799
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`int` makes "
"the :class:`defaultdict` useful for counting (like a bag or multiset in "
"other languages):"
msgstr ""
":attr:`~defaultdict.default_factory`\\를 :class:`int`\\로 설정하면 "
":class:`defaultdict`\\를 세는(counting) 데 유용하게 사용할 수 있습니다 (다른 언어의 백(bag)이나 "
"멀티 셋(multiset)처럼):"

#: ../../library/collections.rst:811
msgid ""
"When a letter is first encountered, it is missing from the mapping, so "
"the :attr:`~defaultdict.default_factory` function calls :func:`int` to "
"supply a default count of zero.  The increment operation then builds up "
"the count for each letter."
msgstr ""
"글자가 처음 발견될 때, 매핑에서 누락되었으므로, :attr:`~defaultdict.default_factory` 함수는 "
":func:`int`\\를 호출하여 기본 계수 0을 제공합니다. 증분 연산은 각 문자의 개수를 쌓아나갑니다."

#: ../../library/collections.rst:815
msgid ""
"The function :func:`int` which always returns zero is just a special case"
" of constant functions.  A faster and more flexible way to create "
"constant functions is to use a lambda function which can supply any "
"constant value (not just zero):"
msgstr ""
"항상 0을 반환하는 함수 :func:`int`\\는 상수 함수의 특별한 경우일 뿐입니다. 상수 함수를 만드는 더 빠르고 유연한 "
"방법은 (단지 0이 아니라) 임의의 상숫값을 제공 할 수 있는 람다 함수를 사용하는 것입니다:"

#: ../../library/collections.rst:828
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`set` makes "
"the :class:`defaultdict` useful for building a dictionary of sets:"
msgstr ""
":attr:`~defaultdict.default_factory`\\를 :class:`set`\\으로 설정하면, "
":class:`defaultdict`\\를 집합의 딕셔너리를 만드는 데 유용하게 만듭니다:"

#: ../../library/collections.rst:841
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr "이름있는 필드를 가진 튜플을 위한 :func:`namedtuple` 팩토리 함수"

#: ../../library/collections.rst:843
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for "
"more readable, self-documenting code.  They can be used wherever regular "
"tuples are used, and they add the ability to access fields by name "
"instead of position index."
msgstr ""
"네임드 튜플은 튜플의 각 위치에 의미를 부여하고 더 읽기 쉽고 스스로 설명하는 코드를 만들도록 합니다. 일반 튜플이 사용되는 "
"곳이라면 어디에서나 사용할 수 있으며, 위치 인덱스 대신 이름으로 필드에 액세스하는 기능을 추가합니다."

#: ../../library/collections.rst:849
#, fuzzy
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used "
"to create tuple-like objects that have fields accessible by attribute "
"lookup as well as being indexable and iterable.  Instances of the "
"subclass also have a helpful docstring (with *typename* and "
"*field_names*) and a helpful :meth:`~object.__repr__` method which lists "
"the tuple contents in a ``name=value`` format."
msgstr ""
"*typename*\\이라는 이름의 새 튜플 서브 클래스를 반환합니다. 새로운 서브 클래스는 인덱싱되고 이터러블일 뿐만 아니라 "
"어트리뷰트 조회로 액세스 할 수 있는 필드를 갖는 튜플류 객체를 만드는 데 사용됩니다. 서브 클래스의 인스턴스에는 유용한 "
"독스트링(typename과 field_names를 포함합니다)과 튜플 내용을 ``name=value`` 형식으로 나열하는 유용한 "
":meth:`__repr__` 메서드가 있습니다."

#: ../../library/collections.rst:856
msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, "
"y'``."
msgstr ""
"*field_names*\\는 ``['x', 'y']``\\와 같은 문자열의 시퀀스입니다. 또는, *field_names*\\는 각"
" 필드명이 공백 및/또는 쉼표로 구분된 단일 문자열일 수 있습니다, 예를 들어 ``'x y'``\\나 ``'x, y'``."

#: ../../library/collections.rst:860
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, "
"digits, and underscores but do not start with a digit or underscore and "
"cannot be a :mod:`keyword` such as *class*, *for*, *return*, *global*, "
"*pass*, or *raise*."
msgstr ""
"밑줄로 시작하는 이름을 제외한 모든 유효한 파이썬 식별자를 필드명에 사용할 수 있습니다. 유효한 식별자는 글자, 숫자 및 밑줄로 "
"구성되지만, 숫자나 밑줄로 시작하지 않으며 *class*, *for*, *return*, *global*, *pass* 또는 "
"*raise*\\와 같은 :mod:`keyword`\\일 수 없습니다."

#: ../../library/collections.rst:866
msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword "
"``def`` and the duplicate fieldname ``abc``."
msgstr ""
"*rename*\\이 참이면, 유효하지 않은 필드명은 위치 이름으로 자동 대체됩니다. 예를 들어, ``['abc', 'def', "
"'ghi', 'abc']``\\는 ``['abc', '_1', 'ghi', '_3']``\\으로 변환되어 키워드 ``def``\\와"
" 중복된 필드명 ``abc``\\를 제거합니다."

#: ../../library/collections.rst:871
msgid ""
"*defaults* can be ``None`` or an :term:`iterable` of default values. "
"Since fields with a default value must come after any fields without a "
"default, the *defaults* are applied to the rightmost parameters.  For "
"example, if the fieldnames are ``['x', 'y', 'z']`` and the defaults are "
"``(1, 2)``, then ``x`` will be a required argument, ``y`` will default to"
" ``1``, and ``z`` will default to ``2``."
msgstr ""
"*defaults*\\는 ``None``\\이나 기본값의 :term:`이터러블 <iterable>` 일 수 있습니다. 기본값이 있는"
" 필드는 기본값이 없는 필드 뒤에 와야 하므로, *defaults*\\는 가장 오른쪽의 매개 변수에 적용됩니다. 예를 들어, "
"field_names가 ``['x', 'y', 'z']``\\이고 defaults가 ``(1, 2)``\\이면 ``x``\\는 필수"
" 인자이고, ``y``\\의 기본값은 ``1``, ``z``\\의 기본값은 ``2``\\입니다."

#: ../../library/collections.rst:878
#, fuzzy
msgid ""
"If *module* is defined, the :attr:`~type.__module__` attribute of the "
"named tuple is set to that value."
msgstr "*module*\\이 정의되면, 네임드 튜플의 ``__module__`` 어트리뷰트가 해당 값으로 설정됩니다."

#: ../../library/collections.rst:881
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr "네임드 튜플 인스턴스에는 인스턴스 별 딕셔너리가 없어서, 가볍고 일반 튜플보다 더 많은 메모리가 필요하지 않습니다."

#: ../../library/collections.rst:884
msgid ""
"To support pickling, the named tuple class should be assigned to a "
"variable that matches *typename*."
msgstr "피클링을 지원하려면, 네임드 튜플 클래스를 *typename*\\과 일치하는 변수에 대입해야 합니다."

#: ../../library/collections.rst:887
msgid "Added support for *rename*."
msgstr "*rename*\\에 대한 지원이 추가되었습니다."

#: ../../library/collections.rst:890
msgid ""
"The *verbose* and *rename* parameters became :ref:`keyword-only arguments"
" <keyword-only_parameter>`."
msgstr ""
"*verbose*\\와 *rename* 매개 변수는 :ref:`키워드 전용 인자 <keyword-only_parameter>`\\가"
" 되었습니다."

#: ../../library/collections.rst:894
msgid "Added the *module* parameter."
msgstr "*module* 매개 변수를 추가했습니다."

#: ../../library/collections.rst:897
#, fuzzy
msgid "Removed the *verbose* parameter and the :attr:`!_source` attribute."
msgstr "*verbose* 매개 변수와 :attr:`_source` 어트리뷰트를 제거했습니다."

#: ../../library/collections.rst:900
#, fuzzy
msgid ""
"Added the *defaults* parameter and the "
":attr:`~somenamedtuple._field_defaults` attribute."
msgstr "*defaults* 매개 변수와 :attr:`_field_defaults` 어트리뷰트가 추가되었습니다."

#: ../../library/collections.rst:904
msgid ""
">>> # Basic example\n"
">>> Point = namedtuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword "
"arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../library/collections.rst:920
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""
"네임드 튜플은 :mod:`csv` 나 :mod:`sqlite3` 모듈이 반환한 결과 튜플에 필드 이름을 할당하는 데 특히 "
"유용합니다::"

#: ../../library/collections.rst:923
msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, "
"department, paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"
msgstr ""

#: ../../library/collections.rst:936
msgid ""
"In addition to the methods inherited from tuples, named tuples support "
"three additional methods and two attributes.  To prevent conflicts with "
"field names, the method and attribute names start with an underscore."
msgstr ""
"튜플에서 상속된 메서드 외에도 네임드 튜플은 세 가지 추가 메서드와 두 가지 어트리뷰트를 지원합니다. 필드 이름과의 충돌을 방지하기"
" 위해, 메서드와 어트리뷰트 이름은 밑줄로 시작합니다."

#: ../../library/collections.rst:942
msgid ""
"Class method that makes a new instance from an existing sequence or "
"iterable."
msgstr "기존 시퀀스나 이터러블로 새 인스턴스를 만드는 클래스 메서드."

#: ../../library/collections.rst:944
msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../library/collections.rst:952
msgid ""
"Return a new :class:`dict` which maps field names to their corresponding "
"values:"
msgstr "필드 이름을 해당 값으로 매핑하는 새 :class:`dict`\\를 반환합니다:"

#: ../../library/collections.rst:955
#, python-brace-format
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""

#: ../../library/collections.rst:961
msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr "일반 :class:`dict` 대신 :class:`OrderedDict`\\를 반환합니다."

#: ../../library/collections.rst:964
msgid ""
"Returns a regular :class:`dict` instead of an :class:`OrderedDict`. As of"
" Python 3.7, regular dicts are guaranteed to be ordered.  If the extra "
"features of :class:`OrderedDict` are required, the suggested remediation "
"is to cast the result to the desired type: ``OrderedDict(nt._asdict())``."
msgstr ""
":class:`OrderedDict` 대신 일반 :class:`dict`\\를 반환합니다. 파이썬 3.7부터, 일반 딕셔너리의 "
"순서가 유지되도록 보장합니다. :class:`OrderedDict`\\의 추가 기능이 필요할 때, 제안하는 처방은 결과를 원하는 "
"형으로 캐스트 하는 것입니다: ``OrderedDict(nt._asdict())``."

#: ../../library/collections.rst:973
msgid ""
"Return a new instance of the named tuple replacing specified fields with "
"new values::"
msgstr "지정된 필드들을 새로운 값으로 치환하는 네임드 튜플의 새 인스턴스를 반환합니다::"

#: ../../library/collections.rst:976
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], "
"timestamp=time.now())"
msgstr ""

#: ../../library/collections.rst:983
msgid "Named tuples are also supported by generic function :func:`copy.replace`."
msgstr ""

#: ../../library/collections.rst:985
msgid ""
"Raise :exc:`TypeError` instead of :exc:`ValueError` for invalid keyword "
"arguments."
msgstr ""

#: ../../library/collections.rst:991
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and "
"for creating new named tuple types from existing named tuples."
msgstr "필드 이름을 나열하는 문자열의 튜플. 인트로스펙션과 기존 네임드 튜플에서 새로운 네임드 튜플 형을 만드는 데 유용합니다."

#: ../../library/collections.rst:994
msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""

#: ../../library/collections.rst:1006
msgid "Dictionary mapping field names to default values."
msgstr "필드 이름을 기본값으로 매핑하는 딕셔너리."

#: ../../library/collections.rst:1008
#, python-brace-format
msgid ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{'balance': 0}\n"
">>> Account('premium')\n"
"Account(type='premium', balance=0)"
msgstr ""

#: ../../library/collections.rst:1016
msgid ""
"To retrieve a field whose name is stored in a string, use the "
":func:`getattr` function:"
msgstr "이름이 문자열에 저장된 필드를 조회하려면 :func:`getattr` 함수를 사용하십시오.:"

#: ../../library/collections.rst:1022
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator "
"(as described in :ref:`tut-unpacking-arguments`):"
msgstr ""
"딕셔너리를 네임드 튜플로 변환하려면 이중 애스터리스크 연산자를 사용하십시오 (:ref:`tut-unpacking-"
"arguments`\\에서 설명합니다).:"

#: ../../library/collections.rst:1029
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or "
"change functionality with a subclass.  Here is how to add a calculated "
"field and a fixed-width print format:"
msgstr ""
"네임드 튜플은 일반적인 파이썬 클래스이므로, 서브 클래스를 사용하여 기능을 쉽게 추가하거나 변경할 수 있습니다. 계산된 필드와 고정"
" 너비 인쇄 포맷을 추가하는 방법은 다음과 같습니다:"

#: ../../library/collections.rst:1033
#, python-format
msgid ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hypot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, "
"self.y, self.hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"...     print(p)\n"
"Point: x= 3.000  y= 4.000  hypot= 5.000\n"
"Point: x=14.000  y= 0.714  hypot=14.018"
msgstr ""

#: ../../library/collections.rst:1048
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This "
"helps keep memory requirements low by preventing the creation of instance"
" dictionaries."
msgstr ""
"위에 표시된 서브 클래스는 ``__slots__``\\를 빈 튜플로 설정합니다. 이렇게 하면 인스턴스 딕셔너리 생성을 방지하여 "
"메모리 요구 사항을 낮게 유지할 수 있습니다."

#: ../../library/collections.rst:1051
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply"
" create a new named tuple type from the :attr:`~somenamedtuple._fields` "
"attribute:"
msgstr ""
"서브 클래싱은 저장된 새 필드를 추가하는 데는 유용하지 않습니다. 대신, :attr:`~somenamedtuple._fields` "
"어트리뷰트로 새로운 네임드 튜플 형을 만드십시오:"

#: ../../library/collections.rst:1056
msgid ""
"Docstrings can be customized by making direct assignments to the "
"``__doc__`` fields:"
msgstr "``__doc__`` 필드에 직접 대입하여 독스트링을 사용자 정의할 수 있습니다:"

#: ../../library/collections.rst:1065
msgid "Property docstrings became writeable."
msgstr "프로퍼티 독스트링이 쓰기 가능하게 되었습니다."

#: ../../library/collections.rst:1070
msgid ""
"See :class:`typing.NamedTuple` for a way to add type hints for named "
"tuples.  It also provides an elegant notation using the :keyword:`class` "
"keyword::"
msgstr ""
"네임드 튜플에 형 힌트를 추가하는 방법은 :class:`typing.NamedTuple`\\을 참조하십시오. 이것은 "
":keyword:`class` 키워드를 사용하는 우아한 표기법도 제공합니다::"

#: ../../library/collections.rst:1074
msgid ""
"class Component(NamedTuple):\n"
"    part_number: int\n"
"    weight: float\n"
"    description: Optional[str] = None"
msgstr ""

#: ../../library/collections.rst:1079
msgid ""
"See :meth:`types.SimpleNamespace` for a mutable namespace based on an "
"underlying dictionary instead of a tuple."
msgstr ""
"튜플 대신 하부 딕셔너리를 기반으로 하는 가변 이름 공간에 대해서는 :meth:`types.SimpleNamespace`\\를 "
"참조하십시오."

#: ../../library/collections.rst:1082
msgid ""
"The :mod:`dataclasses` module provides a decorator and functions for "
"automatically adding generated special methods to user-defined classes."
msgstr ":mod:`dataclasses` 모듈은 사용자 정의 클래스에 생성된 특수 메서드를 자동으로 추가하는 데코레이터와 함수를 제공합니다."

#: ../../library/collections.rst:1087
msgid ":class:`OrderedDict` objects"
msgstr ":class:`OrderedDict` 객체"

#: ../../library/collections.rst:1089
msgid ""
"Ordered dictionaries are just like regular dictionaries but have some "
"extra capabilities relating to ordering operations.  They have become "
"less important now that the built-in :class:`dict` class gained the "
"ability to remember insertion order (this new behavior became guaranteed "
"in Python 3.7)."
msgstr ""
"순서 있는 딕셔너리는 일반 딕셔너리와 비슷하지만, 순서를 다루는 연산과 관련된 몇 가지 추가 기능이 있습니다. 내장 "
":class:`dict` 클래스가 삽입 순서를 기억하는 기능을 얻었으므로 (이 새로운 동작은 파이썬 3.7에서 보장되었습니다), "
"이제 덜 중요해졌습니다."

#: ../../library/collections.rst:1095
msgid "Some differences from :class:`dict` still remain:"
msgstr "몇 가지 :class:`dict`\\와의 차이점은 여전히 남아 있습니다:"

#: ../../library/collections.rst:1097
msgid ""
"The regular :class:`dict` was designed to be very good at mapping "
"operations.  Tracking insertion order was secondary."
msgstr "일반 :class:`dict`\\는 매핑 연산에 매우 적합하도록 설계되었습니다. 삽입 순서 추적은 부차적입니다."

#: ../../library/collections.rst:1100
msgid ""
"The :class:`OrderedDict` was designed to be good at reordering "
"operations. Space efficiency, iteration speed, and the performance of "
"update operations were secondary."
msgstr ""
":class:`OrderedDict`\\는 순서를 바꾸는 연산에 적합하도록 설계되었습니다. 공간 효율성, 이터레이션 속도 및 갱신 "
"연산의 성능은 부차적입니다."

#: ../../library/collections.rst:1104
#, fuzzy
msgid ""
"The :class:`OrderedDict` algorithm can handle frequent reordering "
"operations better than :class:`dict`.  As shown in the recipes below, "
"this makes it suitable for implementing various kinds of LRU caches."
msgstr ""
"알고리즘 적으로, :class:`OrderedDict`\\는 :class:`dict`\\보다 빈번한 순서 변경 연산을 더 잘 처리할"
" 수 있습니다. 이것은 최근 액세스를 추적하는 데 적합하도록 만듭니다 (예를 들어 `LRU 캐시 "
"<https://medium.com/@krishankantsinghal/my-first-blog-on-"
"medium-583159139237>`_\\에서)."

#: ../../library/collections.rst:1108
msgid "The equality operation for :class:`OrderedDict` checks for matching order."
msgstr ":class:`OrderedDict`\\의 동등 비교 연산은 순서의 일치를 확인합니다."

#: ../../library/collections.rst:1110
msgid ""
"A regular :class:`dict` can emulate the order sensitive equality test "
"with ``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."
msgstr ""

#: ../../library/collections.rst:1113
#, fuzzy
msgid ""
"The :meth:`~OrderedDict.popitem` method of :class:`OrderedDict` has a "
"different signature.  It accepts an optional argument to specify which "
"item is popped."
msgstr ""
":class:`OrderedDict`\\의 :meth:`popitem` 메서드는 서명이 다릅니다. 어떤 항목을 팝 할지는 지정하는 "
"선택적 인자를 받아들입니다."

#: ../../library/collections.rst:1116
msgid ""
"A regular :class:`dict` can emulate OrderedDict's "
"``od.popitem(last=True)`` with ``d.popitem()`` which is guaranteed to pop"
" the rightmost (last) item."
msgstr ""

#: ../../library/collections.rst:1119
msgid ""
"A regular :class:`dict` can emulate OrderedDict's "
"``od.popitem(last=False)`` with ``(k := next(iter(d)), d.pop(k))`` which "
"will return and remove the leftmost (first) item if it exists."
msgstr ""

#: ../../library/collections.rst:1123
#, fuzzy
msgid ""
":class:`OrderedDict` has a :meth:`~OrderedDict.move_to_end` method to "
"efficiently reposition an element to an endpoint."
msgstr ""
":class:`OrderedDict`\\에는 요소를 효율적으로 끝으로 재배치하는 :meth:`move_to_end` 메서드가 "
"있습니다."

#: ../../library/collections.rst:1126
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.move_to_end(k, "
"last=True)`` with ``d[k] = d.pop(k)`` which will move the key and its "
"associated value to the rightmost (last) position."
msgstr ""

#: ../../library/collections.rst:1130
msgid ""
"A regular :class:`dict` does not have an efficient equivalent for "
"OrderedDict's ``od.move_to_end(k, last=False)`` which moves the key and "
"its associated value to the leftmost (first) position."
msgstr ""

#: ../../library/collections.rst:1134
#, fuzzy
msgid ""
"Until Python 3.8, :class:`dict` lacked a :meth:`~object.__reversed__` "
"method."
msgstr "파이썬 3.8 이전에는, :class:`dict`\\에 :meth:`__reversed__` 메서드가 없었습니다."

#: ../../library/collections.rst:1139
msgid ""
"Return an instance of a :class:`dict` subclass that has methods "
"specialized for rearranging dictionary order."
msgstr "딕셔너리 순서 재배치에 특화된 메서드가 있는 :class:`dict` 서브 클래스의 인스턴스를 반환합니다."

#: ../../library/collections.rst:1146
msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a"
" (key, value) pair.  The pairs are returned in :abbr:`LIFO (last-in, "
"first-out)` order if *last* is true or :abbr:`FIFO (first-in, first-out)`"
" order if false."
msgstr ""
"순서 있는 딕셔너리의 :meth:`popitem` 메서드는 (키, 값) 쌍을 반환하고 제거합니다. *last*\\가 참이면 쌍이 "
":abbr:`LIFO (last-in, first-out - 후입선출)` 순서로 반환되고, 거짓이면 :abbr:`FIFO "
"(first-in, first-out - 선입선출)` 순서로 반환됩니다."

#: ../../library/collections.rst:1153
#, fuzzy
msgid ""
"Move an existing *key* to either end of an ordered dictionary.  The item "
"is moved to the right end if *last* is true (the default) or to the "
"beginning if *last* is false.  Raises :exc:`KeyError` if the *key* does "
"not exist:"
msgstr ""
"기존 *key*\\를 순서 있는 딕셔너리의 한쪽 끝으로 옮깁니다. *last*\\가 참(기본값)이면 항목은 오른쪽 끝으로 이동하고,"
" *last*\\가 거짓이면 처음으로 이동합니다. *key*\\가 존재하지 않으면 :exc:`KeyError`\\가 발생합니다::"

#: ../../library/collections.rst:1158
msgid ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"
msgstr ""

#: ../../library/collections.rst:1170
msgid ""
"In addition to the usual mapping methods, ordered dictionaries also "
"support reverse iteration using :func:`reversed`."
msgstr "일반적인 매핑 메서드 외에도 순서 있는 딕셔너리는 :func:`reversed`\\를 사용하는 역 이터레이션을 지원합니다."

#: ../../library/collections.rst:1175
msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive "
"and are roughly equivalent to ``list(od1.items())==list(od2.items())``."
msgstr ""

#: ../../library/collections.rst:1178
#, fuzzy
msgid ""
"Equality tests between :class:`OrderedDict` objects and other "
":class:`~collections.abc.Mapping` objects are order-insensitive like "
"regular dictionaries.  This allows :class:`OrderedDict` objects to be "
"substituted anywhere a regular dictionary is used."
msgstr ""
":class:`OrderedDict` 객체 간의 동등성(equality) 테스트는 순서를 고려하며 "
"``list(od1.items())==list(od2.items())``\\로 구현됩니다. :class:`OrderedDict` "
"객체와 다른 :class:`~collections.abc.Mapping` 객체 간의 동등성 테스트는 일반 딕셔너리처럼 순서를 "
"고려하지 않습니다. 이 때문에 :class:`OrderedDict` 객체를 일반 딕셔너리가 사용되는 모든 곳에 대체 할 수 "
"있습니다."

#: ../../library/collections.rst:1183
msgid ""
"The items, keys, and values :term:`views <dictionary view>` of "
":class:`OrderedDict` now support reverse iteration using "
":func:`reversed`."
msgstr ""
":class:`OrderedDict`\\의 items, keys 및 values :term:`뷰 <dictionary "
"view>`\\는 이제 :func:`reversed`\\를 사용하는 역 이터레이션을 지원합니다."

#: ../../library/collections.rst:1187
#, fuzzy
msgid ""
"With the acceptance of :pep:`468`, order is retained for keyword "
"arguments passed to the :class:`OrderedDict` constructor and its "
":meth:`~dict.update` method."
msgstr ""
":pep:`468`\\을 수락함에 따라, :class:`OrderedDict` 생성자와 :meth:`update` 메서드로 전달된 "
"키워드 인자의 순서가 보존됩니다."

#: ../../library/collections.rst:1197
msgid ":class:`OrderedDict` Examples and Recipes"
msgstr ":class:`OrderedDict` 예제와 조리법"

#: ../../library/collections.rst:1199
msgid ""
"It is straightforward to create an ordered dictionary variant that "
"remembers the order the keys were *last* inserted. If a new entry "
"overwrites an existing entry, the original insertion position is changed "
"and moved to the end::"
msgstr ""
"키가 *마지막에* 삽입된 순서를 기억하는 순서 있는 딕셔너리 변형을 만드는 것은 간단합니다. 새 항목이 기존 항목을 덮어쓰면, 원래"
" 삽입 위치가 변경되고 끝으로 이동합니다::"

#: ../../library/collections.rst:1204
msgid ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    'Store items in the order the keys were last added'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"
msgstr ""

#: ../../library/collections.rst:1211
#, fuzzy
msgid ""
"An :class:`OrderedDict` would also be useful for implementing variants of"
" :func:`functools.lru_cache`:"
msgstr ""
":class:`OrderedDict`\\는 :func:`functools.lru_cache`\\의 변형을 구현하는 데에도 "
"유용합니다::"

#: ../../library/collections.rst:1214
#, python-brace-format
msgid ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"
msgstr ""

#: ../../library/collections.rst:1241
#, python-brace-format
msgid ""
"class MultiHitLRUCache:\n"
"    \"\"\" LRU cache that defers caching a result until\n"
"        it has been requested multiple times.\n"
"\n"
"        To avoid flushing the LRU cache with one-time requests,\n"
"        we don't cache until a request has been made more than once.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, "
"cache_after=1):\n"
"        self.requests = OrderedDict()   # { uncached_key : request_count "
"}\n"
"        self.cache = OrderedDict()      # { cached_key : function_result "
"}\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # max number of uncached requests"
"\n"
"        self.maxsize = maxsize          # max number of stored return "
"values\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        result = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        else:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = result\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return result"
msgstr ""

#: ../../library/collections.rst:1310
msgid ":class:`UserDict` objects"
msgstr ":class:`UserDict` 객체"

#: ../../library/collections.rst:1312
msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects."
" The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier "
"to work with because the underlying dictionary is accessible as an "
"attribute."
msgstr ""
":class:`UserDict` 클래스는 딕셔너리 객체를 감싸는 래퍼 역할을 합니다. 이 클래스의 필요성은 "
":class:`dict`\\에서 직접 서브 클래싱 할 수 있는 능력에 의해 부분적으로 대체되었습니다; 그러나 하부 딕셔너리를 "
"어트리뷰트로 액세스 할 수 있어서, 이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다."

#: ../../library/collections.rst:1320
#, fuzzy
msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a"
" regular dictionary, which is accessible via the :attr:`data` attribute "
"of :class:`UserDict` instances.  If *initialdata* is provided, "
":attr:`data` is initialized with its contents; note that a reference to "
"*initialdata* will not be kept, allowing it to be used for other "
"purposes."
msgstr ""
"딕셔너리를 시뮬레이트 하는 클래스. 인스턴스의 내용은 일반 딕셔너리에 보관되며, :class:`UserDict` 인스턴스의 "
":attr:`data` 어트리뷰트를 통해 액세스 할 수 있습니다. *initialdata*\\가 제공되면 "
":attr:`data`\\는 그 내용으로 초기화됩니다; *initialdata*\\에 대한 참조는 유지되지 않아서, 다른 용도로 "
"사용할 수 있습니다."

#: ../../library/collections.rst:1326
msgid ""
"In addition to supporting the methods and operations of mappings, "
":class:`UserDict` instances provide the following attribute:"
msgstr ":class:`UserDict` 인스턴스는 매핑의 메서드와 연산을 지원할 뿐만 아니라, 다음과 같은 어트리뷰트를 제공합니다:"

#: ../../library/collections.rst:1331
msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` "
"class."
msgstr ":class:`UserDict` 클래스의 내용을 저장하는 데 사용되는 실제 딕셔너리."

#: ../../library/collections.rst:1337
msgid ":class:`UserList` objects"
msgstr ":class:`UserList` 객체"

#: ../../library/collections.rst:1339
msgid ""
"This class acts as a wrapper around list objects.  It is a useful base "
"class for your own list-like classes which can inherit from them and "
"override existing methods or add new ones.  In this way, one can add new "
"behaviors to lists."
msgstr ""
"이 클래스는 리스트 객체를 둘러싸는 래퍼 역할을 합니다. 여러분 자신의 리스트류 클래스가 상속하고 기존 메서드를 재정의하거나 새로운"
" 메서드를 추가할 수 있는 유용한 베이스 클래스입니다. 이런 식으로 리스트에 새로운 동작을 추가 할 수 있습니다."

#: ../../library/collections.rst:1344
msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier "
"to work with because the underlying list is accessible as an attribute."
msgstr ""
"이 클래스의 필요성은 :class:`list`\\에서 직접 서브 클래싱할 수 있는 능력에 의해 부분적으로 대체되었습니다; 그러나 "
"하부 리스트에 어트리뷰트로 액세스할 수 있어서, 이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다."

#: ../../library/collections.rst:1350
msgid ""
"Class that simulates a list.  The instance's contents are kept in a "
"regular list, which is accessible via the :attr:`data` attribute of "
":class:`UserList` instances.  The instance's contents are initially set "
"to a copy of *list*, defaulting to the empty list ``[]``.  *list* can be "
"any iterable, for example a real Python list or a :class:`UserList` "
"object."
msgstr ""
"리스트를 시뮬레이트 하는 클래스. 인스턴스의 내용은 일반 리스트로 유지되며 :class:`UserList` 인스턴스의 "
":attr:`data` 어트리뷰트를 통해 액세스 할 수 있습니다. 인스턴스의 내용은 초기에 *list*\\의 사본으로 설정되며, "
"기본값은 빈 목록 ``[]``\\입니다. *list*\\는 모든 이터러블일 수 있습니다, 예를 들어 실제 파이썬 리스트나 "
":class:`UserList` 객체."

#: ../../library/collections.rst:1356
msgid ""
"In addition to supporting the methods and operations of mutable "
"sequences, :class:`UserList` instances provide the following attribute:"
msgstr ":class:`UserList` 인스턴스는 가변 시퀀스의 메서드와 연산을 지원할 뿐만 아니라 다음 어트리뷰트를 제공합니다:"

#: ../../library/collections.rst:1361
msgid ""
"A real :class:`list` object used to store the contents of the "
":class:`UserList` class."
msgstr ":class:`UserList` 클래스의 내용을 저장하는 데 사용되는 실제 :class:`list` 객체."

#: ../../library/collections.rst:1364
msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are "
"expected to offer a constructor which can be called with either no "
"arguments or one argument.  List operations which return a new sequence "
"attempt to create an instance of the actual implementation class.  To do "
"so, it assumes that the constructor can be called with a single "
"parameter, which is a sequence object used as a data source."
msgstr ""
"**서브 클래싱 요구 사항:** :class:`UserList`\\의 서브 클래스는 인자가 없거나 하나의 인자로 호출 할 수 있는 "
"생성자를 제공해야 합니다. 새 시퀀스를 반환하는 리스트 연산은 실제 구현 클래스의 인스턴스를 만들려고 시도합니다. 이를 위해, "
"데이터 소스로 사용되는 시퀀스 객체인 단일 매개 변수로 생성자를 호출할 수 있다고 가정합니다."

#: ../../library/collections.rst:1371
msgid ""
"If a derived class does not wish to comply with this requirement, all of "
"the special methods supported by this class will need to be overridden; "
"please consult the sources for information about the methods which need "
"to be provided in that case."
msgstr ""
"파생 클래스가 이 요구 사항을 준수하고 싶지 않다면, 이 클래스에서 지원하는 모든 특수 메서드를 재정의해야 합니다; 이때 제공해야 "
"하는 메서드에 대한 정보는 소스를 참조하십시오."

#: ../../library/collections.rst:1377
msgid ":class:`UserString` objects"
msgstr ":class:`UserString` 객체"

#: ../../library/collections.rst:1379
msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`str`; however, this class can be easier to"
" work with because the underlying string is accessible as an attribute."
msgstr ""
":class:`UserString` 클래스는 문자열 객체를 둘러싸는 래퍼 역할을 합니다. 이 클래스의 필요성은 "
":class:`str`\\에서 직접 서브 클래싱할 수 있는 능력에 의해 부분적으로 대체되었습니다; 그러나 하부 문자열을 어트리뷰트로"
" 액세스할 수 있어서, 이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다."

#: ../../library/collections.rst:1387
msgid ""
"Class that simulates a string object.  The instance's content is kept in "
"a regular string object, which is accessible via the :attr:`data` "
"attribute of :class:`UserString` instances.  The instance's contents are "
"initially set to a copy of *seq*.  The *seq* argument can be any object "
"which can be converted into a string using the built-in :func:`str` "
"function."
msgstr ""
"문자열 객체를 시뮬레이트 하는 클래스. 인스턴스의 내용은 일반 문자열 객체로 유지되며, :class:`UserString` "
"인스턴스의 :attr:`data` 어트리뷰트를 통해 액세스 할 수 있습니다. 인스턴스의 내용은 처음에 *seq*\\의 사본으로 "
"설정됩니다. *seq* 인자는 내장 :func:`str` 함수를 사용하여 문자열로 변환 할 수 있는 모든 객체가 될 수 있습니다."

#: ../../library/collections.rst:1394
msgid ""
"In addition to supporting the methods and operations of strings, "
":class:`UserString` instances provide the following attribute:"
msgstr ":class:`UserString` 인스턴스는 문자열의 메서드와 연산을 지원할 뿐만 아니라 다음과 같은 어트리뷰트를 제공합니다:"

#: ../../library/collections.rst:1399
msgid ""
"A real :class:`str` object used to store the contents of the "
":class:`UserString` class."
msgstr ":class:`UserString` 클래스의 내용을 저장하는 데 사용되는 실제 :class:`str` 객체."

#: ../../library/collections.rst:1402
msgid ""
"New methods ``__getnewargs__``, ``__rmod__``, ``casefold``, "
"``format_map``, ``isprintable``, and ``maketrans``."
msgstr ""
"새로운 메서드 ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable`` 및 ``maketrans``."

#~ msgid ""
#~ "Moved :ref:`collections-abstract-base-classes`"
#~ " to the :mod:`collections.abc` module. For"
#~ " backwards compatibility, they continue to"
#~ " be visible in this module through"
#~ " Python 3.9."
#~ msgstr ""
#~ ":ref:`collections-abstract-base-classes`\\를 "
#~ ":mod:`collections.abc` 모듈로 옮겼습니다. 이전 버전과의 "
#~ "호환성을 위해, 파이썬 3.9까지 이 모듈에서 계속 "
#~ "볼 수 있습니다."

