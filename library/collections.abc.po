# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/collections.abc.rst:2
#, fuzzy
msgid ":mod:`!collections.abc` --- Abstract Base Classes for Containers"
msgstr ":mod:`collections.abc` --- 컨테이너의 추상 베이스 클래스"

#: ../../library/collections.abc.rst:10
msgid "Formerly, this module was part of the :mod:`collections` module."
msgstr "이전에는, 이 모듈이 :mod:`collections` 모듈의 일부였습니다."

#: ../../library/collections.abc.rst:13
msgid "**Source code:** :source:`Lib/_collections_abc.py`"
msgstr "**소스 코드:** :source:`Lib/_collections_abc.py`"

#: ../../library/collections.abc.rst:23
#, fuzzy
msgid ""
"This module provides :term:`abstract base classes <abstract base class>` "
"that can be used to test whether a class provides a particular interface;"
" for example, whether it is :term:`hashable` or whether it is a "
":term:`mapping`."
msgstr ""
"이 모듈은 클래스가 특정 인터페이스를 제공하는지를 검사하는 데 사용할 수 있는 :term:`추상 베이스 클래스 <abstract "
"base class>`\\를 제공합니다; 예를 들어, 해시 가능한지 또는 매핑인지입니다."

#: ../../library/collections.abc.rst:27
msgid ""
"An :func:`issubclass` or :func:`isinstance` test for an interface works "
"in one of three ways."
msgstr ""

#: ../../library/collections.abc.rst:30
msgid ""
"A newly written class can inherit directly from one of the abstract base "
"classes.  The class must supply the required abstract methods.  The "
"remaining mixin methods come from inheritance and can be overridden if "
"desired.  Other methods may be added as needed:"
msgstr ""

#: ../../library/collections.abc.rst:35
msgid ""
"class C(Sequence):                      # Direct inheritance\n"
"    def __init__(self): ...             # Extra method not required by "
"the ABC\n"
"    def __getitem__(self, index):  ...  # Required abstract method\n"
"    def __len__(self):  ...             # Required abstract method\n"
"    def count(self, value): ...         # Optionally override a mixin "
"method"
msgstr ""

#: ../../library/collections.abc.rst:43
msgid ""
">>> issubclass(C, Sequence)\n"
"True\n"
">>> isinstance(C(), Sequence)\n"
"True"
msgstr ""

#: ../../library/collections.abc.rst:50
msgid ""
"Existing classes and built-in classes can be registered as \"virtual "
"subclasses\" of the ABCs.  Those classes should define the full API "
"including all of the abstract methods and all of the mixin methods. This "
"lets users rely on :func:`issubclass` or :func:`isinstance` tests to "
"determine whether the full interface is supported.  The exception to this"
" rule is for methods that are automatically inferred from the rest of the"
" API:"
msgstr ""

#: ../../library/collections.abc.rst:58
msgid ""
"class D:                                 # No inheritance\n"
"    def __init__(self): ...              # Extra method not required by "
"the ABC\n"
"    def __getitem__(self, index):  ...   # Abstract method\n"
"    def __len__(self):  ...              # Abstract method\n"
"    def count(self, value): ...          # Mixin method\n"
"    def index(self, value): ...          # Mixin method\n"
"\n"
"Sequence.register(D)                     # Register instead of inherit"
msgstr ""

#: ../../library/collections.abc.rst:69
msgid ""
">>> issubclass(D, Sequence)\n"
"True\n"
">>> isinstance(D(), Sequence)\n"
"True"
msgstr ""

#: ../../library/collections.abc.rst:76
msgid ""
"In this example, class :class:`!D` does not need to define "
"``__contains__``, ``__iter__``, and ``__reversed__`` because the :ref"
":`in-operator <comparisons>`, the :term:`iteration <iterable>` logic, and"
" the :func:`reversed` function automatically fall back to using "
"``__getitem__`` and ``__len__``."
msgstr ""

#: ../../library/collections.abc.rst:82
msgid ""
"Some simple interfaces are directly recognizable by the presence of the "
"required methods (unless those methods have been set to :const:`None`):"
msgstr ""

#: ../../library/collections.abc.rst:85
msgid ""
"class E:\n"
"    def __iter__(self): ...\n"
"    def __next__(self): ..."
msgstr ""

#: ../../library/collections.abc.rst:91
msgid ""
">>> issubclass(E, Iterable)\n"
"True\n"
">>> isinstance(E(), Iterable)\n"
"True"
msgstr ""

#: ../../library/collections.abc.rst:98
msgid ""
"Complex interfaces do not support this last technique because an "
"interface is more than just the presence of method names.  Interfaces "
"specify semantics and relationships between methods that cannot be "
"inferred solely from the presence of specific method names.  For example,"
" knowing that a class supplies ``__getitem__``, ``__len__``, and "
"``__iter__`` is insufficient for distinguishing a :class:`Sequence` from "
"a :class:`Mapping`."
msgstr ""

#: ../../library/collections.abc.rst:106
msgid ""
"These abstract classes now support ``[]``. See :ref:`types-genericalias` "
"and :pep:`585`."
msgstr ""

#: ../../library/collections.abc.rst:113
msgid "Collections Abstract Base Classes"
msgstr "Collections 추상 베이스 클래스"

#: ../../library/collections.abc.rst:115
msgid ""
"The collections module offers the following :term:`ABCs <abstract base "
"class>`:"
msgstr "collections 모듈은 다음과 같은 :term:`ABC <abstract base class>`\\를 제공합니다:"

#: ../../library/collections.abc.rst:120
msgid "ABC"
msgstr "ABC"

#: ../../library/collections.abc.rst:120
msgid "Inherits from"
msgstr "상속"

#: ../../library/collections.abc.rst:120
msgid "Abstract Methods"
msgstr "추상 메서드"

#: ../../library/collections.abc.rst:120
msgid "Mixin Methods"
msgstr "믹스인 메서드"

#: ../../library/collections.abc.rst:122
#, fuzzy
msgid ":class:`Container` [1]_"
msgstr ":class:`Container`"

#: ../../library/collections.abc.rst:122
msgid "``__contains__``"
msgstr "``__contains__``"

#: ../../library/collections.abc.rst:123
#, fuzzy
msgid ":class:`Hashable` [1]_"
msgstr ":class:`Hashable`"

#: ../../library/collections.abc.rst:123
msgid "``__hash__``"
msgstr "``__hash__``"

#: ../../library/collections.abc.rst:124
#, fuzzy
msgid ":class:`Iterable` [1]_ [2]_"
msgstr ":class:`Iterable`"

#: ../../library/collections.abc.rst:124 ../../library/collections.abc.rst:125
msgid "``__iter__``"
msgstr "``__iter__``"

#: ../../library/collections.abc.rst:125
#, fuzzy
msgid ":class:`Iterator` [1]_"
msgstr ":class:`Iterator`"

#: ../../library/collections.abc.rst:125 ../../library/collections.abc.rst:126
msgid ":class:`Iterable`"
msgstr ":class:`Iterable`"

#: ../../library/collections.abc.rst:125
msgid "``__next__``"
msgstr "``__next__``"

#: ../../library/collections.abc.rst:126
#, fuzzy
msgid ":class:`Reversible` [1]_"
msgstr ":class:`Reversible`"

#: ../../library/collections.abc.rst:126
msgid "``__reversed__``"
msgstr "``__reversed__``"

#: ../../library/collections.abc.rst:127
#, fuzzy
msgid ":class:`Generator`  [1]_"
msgstr ":class:`Generator`"

#: ../../library/collections.abc.rst:127
msgid ":class:`Iterator`"
msgstr ":class:`Iterator`"

#: ../../library/collections.abc.rst:127 ../../library/collections.abc.rst:176
msgid "``send``, ``throw``"
msgstr "``send``, ``throw``"

#: ../../library/collections.abc.rst:127
msgid "``close``, ``__iter__``, ``__next__``"
msgstr "``close``, ``__iter__``, ``__next__``"

#: ../../library/collections.abc.rst:128
#, fuzzy
msgid ":class:`Sized`  [1]_"
msgstr ":class:`Sized`"

#: ../../library/collections.abc.rst:128
msgid "``__len__``"
msgstr "``__len__``"

#: ../../library/collections.abc.rst:129
#, fuzzy
msgid ":class:`Callable`  [1]_"
msgstr ":class:`Callable`"

#: ../../library/collections.abc.rst:129
msgid "``__call__``"
msgstr "``__call__``"

#: ../../library/collections.abc.rst:130
#, fuzzy
msgid ":class:`Collection`  [1]_"
msgstr ":class:`Collection`"

#: ../../library/collections.abc.rst:130
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ":class:`Sized`, :class:`Iterable`, :class:`Container`"

#: ../../library/collections.abc.rst:130 ../../library/collections.abc.rst:146
msgid "``__contains__``, ``__iter__``, ``__len__``"
msgstr "``__contains__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:134 ../../library/collections.abc.rst:137
#: ../../library/collections.abc.rst:143
msgid ":class:`Sequence`"
msgstr ":class:`Sequence`"

#: ../../library/collections.abc.rst:134
msgid ":class:`Reversible`, :class:`Collection`"
msgstr ":class:`Reversible`, :class:`Collection`"

#: ../../library/collections.abc.rst:134 ../../library/collections.abc.rst:143
msgid "``__getitem__``, ``__len__``"
msgstr "``__getitem__``, ``__len__``"

#: ../../library/collections.abc.rst:134
msgid "``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"
msgstr "``__contains__``, ``__iter__``, ``__reversed__``, ``index`` 및 ``count``"

#: ../../library/collections.abc.rst:137
msgid ":class:`MutableSequence`"
msgstr ":class:`MutableSequence`"

#: ../../library/collections.abc.rst:137
msgid "``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"
msgstr "``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"

#: ../../library/collections.abc.rst:137
#, fuzzy
msgid ""
"Inherited :class:`Sequence` methods and ``append``, ``clear``, "
"``reverse``, ``extend``, ``pop``, ``remove``, and ``__iadd__``"
msgstr ""
"상속된 :class:`Sequence` 메서드와 ``append``, ``reverse``, ``extend``, ``pop``, "
"``remove`` 및 ``__iadd__``"

#: ../../library/collections.abc.rst:143
msgid ":class:`ByteString`"
msgstr ":class:`ByteString`"

#: ../../library/collections.abc.rst:143
msgid "Inherited :class:`Sequence` methods"
msgstr "상속된 :class:`Sequence` 메서드"

#: ../../library/collections.abc.rst:146 ../../library/collections.abc.rst:151
msgid ":class:`Set`"
msgstr ":class:`Set`"

#: ../../library/collections.abc.rst:146 ../../library/collections.abc.rst:157
msgid ":class:`Collection`"
msgstr ":class:`Collection`"

#: ../../library/collections.abc.rst:146
#, fuzzy
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__rsub__``, ``__xor__``, "
"``__rxor__`` and ``isdisjoint``"
msgstr ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__xor__`` 및 ``isdisjoint``"

#: ../../library/collections.abc.rst:151
msgid ":class:`MutableSet`"
msgstr ":class:`MutableSet`"

#: ../../library/collections.abc.rst:151
msgid "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"
msgstr "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"

#: ../../library/collections.abc.rst:151
msgid ""
"Inherited :class:`Set` methods and ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""
"상속된 :class:`Set` 메서드와 ``clear``, ``pop``, ``remove``, ``__ior__``, "
"``__iand__``, ``__ixor__`` 및 ``__isub__``"

#: ../../library/collections.abc.rst:157 ../../library/collections.abc.rst:161
msgid ":class:`Mapping`"
msgstr ":class:`Mapping`"

#: ../../library/collections.abc.rst:157
msgid "``__getitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:157
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, "
"and ``__ne__``"
msgstr ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__`` 및 "
"``__ne__``"

#: ../../library/collections.abc.rst:161
msgid ":class:`MutableMapping`"
msgstr ":class:`MutableMapping`"

#: ../../library/collections.abc.rst:161
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, "
"``__len__``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, "
"``__len__``"

#: ../../library/collections.abc.rst:161
msgid ""
"Inherited :class:`Mapping` methods and ``pop``, ``popitem``, ``clear``, "
"``update``, and ``setdefault``"
msgstr ""
"상속된 :class:`Mapping` 메서드와 ``pop``, ``popitem``, ``clear``, ``update`` 및 "
"``setdefault``"

#: ../../library/collections.abc.rst:168
msgid ":class:`MappingView`"
msgstr ":class:`MappingView`"

#: ../../library/collections.abc.rst:168
msgid ":class:`Sized`"
msgstr ":class:`Sized`"

#: ../../library/collections.abc.rst:168
#, fuzzy
msgid "``__init__``, ``__len__`` and ``__repr__``"
msgstr "``__getitem__``, ``__len__``"

#: ../../library/collections.abc.rst:169
msgid ":class:`ItemsView`"
msgstr ":class:`ItemsView`"

#: ../../library/collections.abc.rst:169 ../../library/collections.abc.rst:171
msgid ":class:`MappingView`, :class:`Set`"
msgstr ":class:`MappingView`, :class:`Set`"

#: ../../library/collections.abc.rst:169 ../../library/collections.abc.rst:171
#: ../../library/collections.abc.rst:173
msgid "``__contains__``, ``__iter__``"
msgstr "``__contains__``, ``__iter__``"

#: ../../library/collections.abc.rst:171
msgid ":class:`KeysView`"
msgstr ":class:`KeysView`"

#: ../../library/collections.abc.rst:173
msgid ":class:`ValuesView`"
msgstr ":class:`ValuesView`"

#: ../../library/collections.abc.rst:173
msgid ":class:`MappingView`, :class:`Collection`"
msgstr ":class:`MappingView`, :class:`Collection`"

#: ../../library/collections.abc.rst:175
#, fuzzy
msgid ":class:`Awaitable` [1]_"
msgstr ":class:`Awaitable`"

#: ../../library/collections.abc.rst:175
msgid "``__await__``"
msgstr "``__await__``"

#: ../../library/collections.abc.rst:176
#, fuzzy
msgid ":class:`Coroutine` [1]_"
msgstr ":class:`Coroutine`"

#: ../../library/collections.abc.rst:176
msgid ":class:`Awaitable`"
msgstr ":class:`Awaitable`"

#: ../../library/collections.abc.rst:176
msgid "``close``"
msgstr "``close``"

#: ../../library/collections.abc.rst:177
#, fuzzy
msgid ":class:`AsyncIterable` [1]_"
msgstr ":class:`AsyncIterable`"

#: ../../library/collections.abc.rst:177 ../../library/collections.abc.rst:178
msgid "``__aiter__``"
msgstr "``__aiter__``"

#: ../../library/collections.abc.rst:178
#, fuzzy
msgid ":class:`AsyncIterator` [1]_"
msgstr ":class:`AsyncIterator`"

#: ../../library/collections.abc.rst:178
msgid ":class:`AsyncIterable`"
msgstr ":class:`AsyncIterable`"

#: ../../library/collections.abc.rst:178
msgid "``__anext__``"
msgstr "``__anext__``"

#: ../../library/collections.abc.rst:179
#, fuzzy
msgid ":class:`AsyncGenerator` [1]_"
msgstr ":class:`AsyncGenerator`"

#: ../../library/collections.abc.rst:179
msgid ":class:`AsyncIterator`"
msgstr ":class:`AsyncIterator`"

#: ../../library/collections.abc.rst:179
msgid "``asend``, ``athrow``"
msgstr "``asend``, ``athrow``"

#: ../../library/collections.abc.rst:179
msgid "``aclose``, ``__aiter__``, ``__anext__``"
msgstr "``aclose``, ``__aiter__``, ``__anext__``"

#: ../../library/collections.abc.rst:180
#, fuzzy
msgid ":class:`Buffer` [1]_"
msgstr ":class:`Set`"

#: ../../library/collections.abc.rst:180
#, fuzzy
msgid "``__buffer__``"
msgstr "``__iter__``"

#: ../../library/collections.abc.rst:185
msgid "Footnotes"
msgstr ""

#: ../../library/collections.abc.rst:186
msgid ""
"These ABCs override :meth:`~abc.ABCMeta.__subclasshook__` to support "
"testing an interface by verifying the required methods are present and "
"have not been set to :const:`None`.  This only works for simple "
"interfaces.  More complex interfaces require registration or direct "
"subclassing."
msgstr ""

#: ../../library/collections.abc.rst:192
#, fuzzy
msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are "
"registered as :class:`Iterable` or that have an "
":meth:`~container.__iter__` method, but it does not detect classes that "
"iterate with the :meth:`~object.__getitem__` method.  The only reliable "
"way to determine whether an object is :term:`iterable` is to call "
"``iter(obj)``."
msgstr ""
"``isinstance(obj, Iterable)``\\를 검사하면 :class:`Iterable`\\로 등록되었거나 "
":meth:`__iter__` 메서드가 있는 클래스를 감지하지만, :meth:`__getitem__` 메서드로 이터레이트 하는 "
"클래스는 감지하지 않습니다. 객체가 :term:`이터러블 <iterable>`\\인지를 확인하는 유일하게 신뢰성 있는 방법은 "
"``iter(obj)``\\를 호출하는 것입니다."

#: ../../library/collections.abc.rst:200
#, fuzzy
msgid "Collections Abstract Base Classes -- Detailed Descriptions"
msgstr "Collections 추상 베이스 클래스"

#: ../../library/collections.abc.rst:205
#, fuzzy
msgid "ABC for classes that provide the :meth:`~object.__contains__` method."
msgstr ":meth:`__contains__` 메서드를 제공하는 클래스의 ABC."

#: ../../library/collections.abc.rst:209
#, fuzzy
msgid "ABC for classes that provide the :meth:`~object.__hash__` method."
msgstr ":meth:`__hash__` 메서드를 제공하는 클래스의 ABC."

#: ../../library/collections.abc.rst:213
#, fuzzy
msgid "ABC for classes that provide the :meth:`~object.__len__` method."
msgstr ":meth:`__len__` 메서드를 제공하는 클래스의 ABC."

#: ../../library/collections.abc.rst:217
#, fuzzy
msgid "ABC for classes that provide the :meth:`~object.__call__` method."
msgstr ":meth:`__call__` 메서드를 제공하는 클래스의 ABC."

#: ../../library/collections.abc.rst:219
msgid ""
"See :ref:`annotating-callables` for details on how to use "
":class:`!Callable` in type annotations."
msgstr ""

#: ../../library/collections.abc.rst:224
#, fuzzy
msgid "ABC for classes that provide the :meth:`~container.__iter__` method."
msgstr ":meth:`__iter__` 메서드를 제공하는 클래스의 ABC."

#: ../../library/collections.abc.rst:226
#, fuzzy
msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are "
"registered as :class:`Iterable` or that have an "
":meth:`~container.__iter__` method, but it does not detect classes that "
"iterate with the :meth:`~object.__getitem__` method. The only reliable "
"way to determine whether an object is :term:`iterable` is to call "
"``iter(obj)``."
msgstr ""
"``isinstance(obj, Iterable)``\\를 검사하면 :class:`Iterable`\\로 등록되었거나 "
":meth:`__iter__` 메서드가 있는 클래스를 감지하지만, :meth:`__getitem__` 메서드로 이터레이트 하는 "
"클래스는 감지하지 않습니다. 객체가 :term:`이터러블 <iterable>`\\인지를 확인하는 유일하게 신뢰성 있는 방법은 "
"``iter(obj)``\\를 호출하는 것입니다."

#: ../../library/collections.abc.rst:235
msgid "ABC for sized iterable container classes."
msgstr "길이가 있는 이터러블 컨테이너 클래스의 ABC."

#: ../../library/collections.abc.rst:241
msgid ""
"ABC for classes that provide the :meth:`~iterator.__iter__` and "
":meth:`~iterator.__next__` methods.  See also the definition of "
":term:`iterator`."
msgstr ""
":meth:`~iterator.__iter__` 와 :meth:`~iterator.__next__` 메서드를 제공하는 클래스의 "
"ABC. :term:`이터레이터 <iterator>`\\의 정의도 참조하십시오."

#: ../../library/collections.abc.rst:247
#, fuzzy
msgid ""
"ABC for iterable classes that also provide the "
":meth:`~object.__reversed__` method."
msgstr ":meth:`__reversed__` 메서드도 제공하는 이터러블 클래스의 ABC."

#: ../../library/collections.abc.rst:254
#, fuzzy
msgid ""
"ABC for :term:`generator` classes that implement the protocol defined in "
":pep:`342` that extends :term:`iterators <iterator>` with the "
":meth:`~generator.send`, :meth:`~generator.throw` and "
":meth:`~generator.close` methods."
msgstr ""
":meth:`~generator.send`, :meth:`~generator.throw` 및 "
":meth:`~generator.close` 메서드로 이터레이터를 확장하는 :pep:`342`\\에 정의된 프로토콜을 구현하는 "
"제너레이터 클래스의 ABC. :term:`제너레이터 <generator>`\\의 정의도 참조하십시오."

#: ../../library/collections.abc.rst:259
msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using "
":class:`!Generator` in type annotations."
msgstr ""

#: ../../library/collections.abc.rst:268
msgid "ABCs for read-only and mutable :term:`sequences <sequence>`."
msgstr "읽기 전용과 가변 :term:`시퀀스 <sequence>`\\의 ABC."

#: ../../library/collections.abc.rst:270
#, fuzzy
msgid ""
"Implementation note: Some of the mixin methods, such as "
":meth:`~container.__iter__`, :meth:`~object.__reversed__` and "
":meth:`index`, make repeated calls to the underlying "
":meth:`~object.__getitem__` method. Consequently, if "
":meth:`~object.__getitem__` is implemented with constant access speed, "
"the mixin methods will have linear performance; however, if the "
"underlying method is linear (as it would be with a linked list), the "
"mixins will have quadratic performance and will likely need to be "
"overridden."
msgstr ""
"구현 참고 사항: :meth:`__iter__`, :meth:`__reversed__` 및 :meth:`index`\\와 같은 일부"
" 믹스인(mixin) 메서드는 하부 :meth:`__getitem__` 메서드를 반복적으로 호출합니다. 따라서, "
":meth:`__getitem__`\\이 상수 액세스 속도로 구현되면 믹스인 메서드는 선형 성능을 갖습니다; 그러나 하부 메서드가 "
"선형이면 (링크드 리스트에서처럼), 믹스인은 2차 함수 성능을 가지므로 재정의해야 할 수 있습니다."

#: ../../library/collections.abc.rst:279
msgid "The index() method added support for *stop* and *start* arguments."
msgstr "index() 메서드는 *stop*\\과 *start* 인자에 대한 지원을 추가했습니다."

#: ../../library/collections.abc.rst:283
msgid ""
"The :class:`ByteString` ABC has been deprecated. For use in typing, "
"prefer a union, like ``bytes | bytearray``, or "
":class:`collections.abc.Buffer`. For use as an ABC, prefer "
":class:`Sequence` or :class:`collections.abc.Buffer`."
msgstr ""

#: ../../library/collections.abc.rst:292
#, fuzzy
msgid "ABCs for read-only and mutable :ref:`sets <types-set>`."
msgstr "읽기 전용과 가변 집합의 ABC."

#: ../../library/collections.abc.rst:297
msgid "ABCs for read-only and mutable :term:`mappings <mapping>`."
msgstr "읽기 전용과 가변 :term:`매핑 <mapping>`\\의 ABC."

#: ../../library/collections.abc.rst:304
msgid "ABCs for mapping, items, keys, and values :term:`views <dictionary view>`."
msgstr "매핑, 항목, 키 및 값 :term:`뷰 <dictionary view>`\\의 ABC."

#: ../../library/collections.abc.rst:308
#, fuzzy
msgid ""
"ABC for :term:`awaitable` objects, which can be used in :keyword:`await` "
"expressions.  Custom implementations must provide the "
":meth:`~object.__await__` method."
msgstr ""
":keyword:`await` 표현식에서 사용할 수 있는 :term:`어웨이터블 <awaitable>` 객체의 ABC. 사용자 정의"
" 구현은 :meth:`__await__` 메서드를 제공해야 합니다."

#: ../../library/collections.abc.rst:312
msgid ""
":term:`Coroutine <coroutine>` objects and instances of the "
":class:`~collections.abc.Coroutine` ABC are all instances of this ABC."
msgstr ""
":term:`코루틴 <coroutine>` 객체와 :class:`~collections.abc.Coroutine` ABC의 "
"인스턴스는 모두 이 ABC의 인스턴스입니다."

#: ../../library/collections.abc.rst:316
#, fuzzy
msgid ""
"In CPython, generator-based coroutines (:term:`generators <generator>` "
"decorated with :func:`@types.coroutine <types.coroutine>`) are "
"*awaitables*, even though they do not have an :meth:`~object.__await__` "
"method. Using ``isinstance(gencoro, Awaitable)`` for them will return "
"``False``. Use :func:`inspect.isawaitable` to detect them."
msgstr ""
"CPython에서, 제너레이터 기반 코루틴(:func:`types.coroutine`\\이나 "
":func:`asyncio.coroutine`\\으로 데코레이트 된 제너레이터)은, :meth:`__await__` 메서드가 없어도"
" *어웨이터블* 입니다. 이들에 대해 ``isinstance(gencoro, Awaitable)``\\를 사용하면 "
"``False``\\가 반환됩니다. 이들을 감지하려면 :func:`inspect.isawaitable`\\을 사용하십시오."

#: ../../library/collections.abc.rst:326
#, fuzzy
msgid ""
"ABC for :term:`coroutine` compatible classes.  These implement the "
"following methods, defined in :ref:`coroutine-objects`: "
":meth:`~coroutine.send`, :meth:`~coroutine.throw`, and "
":meth:`~coroutine.close`.  Custom implementations must also implement "
":meth:`~object.__await__`.  All :class:`Coroutine` instances are also "
"instances of :class:`Awaitable`."
msgstr ""
"코루틴 호환 클래스의 ABC. :ref:`coroutine-objects`\\에 정의된 다음 메서드를 구현합니다: "
":meth:`~coroutine.send`, :meth:`~coroutine.throw` 및 "
":meth:`~coroutine.close`. 사용자 정의 구현은 :meth:`__await__`\\도 구현해야 합니다. 모든 "
":class:`Coroutine` 인스턴스는 :class:`Awaitable`\\의 인스턴스이기도 합니다. :term:`코루틴 "
"<coroutine>`\\의 정의도 참조하십시오."

#: ../../library/collections.abc.rst:334
#, fuzzy
msgid ""
"In CPython, generator-based coroutines (:term:`generators <generator>` "
"decorated with :func:`@types.coroutine <types.coroutine>`) are "
"*awaitables*, even though they do not have an :meth:`~object.__await__` "
"method. Using ``isinstance(gencoro, Coroutine)`` for them will return "
"``False``. Use :func:`inspect.isawaitable` to detect them."
msgstr ""
"CPython에서, 제너레이터 기반 코루틴(:func:`types.coroutine`\\이나 "
":func:`asyncio.coroutine`\\으로 데코레이트 된 제너레이터)은, :meth:`__await__` 메서드가 없어도"
" *어웨이터블* 입니다. 이들에 대해 ``isinstance(gencoro, Coroutine)``\\을 사용하면 "
"``False``\\가 반환됩니다. 이들을 감지하려면 :func:`inspect.isawaitable`\\을 사용하십시오."

#: ../../library/collections.abc.rst:340
msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using "
":class:`!Coroutine` in type annotations. The variance and order of type "
"parameters correspond to those of :class:`Generator`."
msgstr ""

#: ../../library/collections.abc.rst:349
#, fuzzy
msgid ""
"ABC for classes that provide an ``__aiter__`` method.  See also the "
"definition of :term:`asynchronous iterable`."
msgstr ""
"``__aiter__`` 메서드를 제공하는 클래스의 ABC. :term:`비동기 이터러블 <asynchronous "
"iterable>`\\의 정의도 참조하십시오."

#: ../../library/collections.abc.rst:356
msgid ""
"ABC for classes that provide ``__aiter__`` and ``__anext__`` methods.  "
"See also the definition of :term:`asynchronous iterator`."
msgstr ""
"``__aiter__`` 와 ``__anext__`` 메서드를 제공하는 클래스의 ABC. :term:`비동기 이터레이터 "
"<asynchronous iterator>`\\의 정의도 참조하십시오."

#: ../../library/collections.abc.rst:363
#, fuzzy
msgid ""
"ABC for :term:`asynchronous generator` classes that implement the "
"protocol defined in :pep:`525` and :pep:`492`."
msgstr ":pep:`525`\\와 :pep:`492`\\에 정의된 프로토콜을 구현하는 비동기 제너레이터 클래스의 ABC."

#: ../../library/collections.abc.rst:366
msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using "
":class:`!AsyncGenerator` in type annotations."
msgstr ""

#: ../../library/collections.abc.rst:373
msgid ""
"ABC for classes that provide the :meth:`~object.__buffer__` method, "
"implementing the :ref:`buffer protocol <bufferobjects>`. See :pep:`688`."
msgstr ""

#: ../../library/collections.abc.rst:379
msgid "Examples and Recipes"
msgstr ""

#: ../../library/collections.abc.rst:381
#, fuzzy
msgid ""
"ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr "이러한 ABC들은 클래스나 인스턴스가 특정 기능을 제공하는지 묻는 것을 허용합니다, 예를 들어::"

#: ../../library/collections.abc.rst:384
msgid ""
"size = None\n"
"if isinstance(myvar, collections.abc.Sized):\n"
"    size = len(myvar)"
msgstr ""

#: ../../library/collections.abc.rst:388
#, fuzzy
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to "
"develop classes supporting container APIs.  For example, to write a class"
" supporting the full :class:`Set` API, it is only necessary to supply the"
" three underlying abstract methods: :meth:`~object.__contains__`, "
":meth:`~container.__iter__`, and :meth:`~object.__len__`. The ABC "
"supplies the remaining methods such as :meth:`!__and__` and "
":meth:`~frozenset.isdisjoint`::"
msgstr ""
"ABC 중 일부는 믹스인으로도 유용하여 컨테이너 API를 지원하는 클래스를 쉽게 개발할 수 있게 합니다. 예를 들어, 전체 "
":class:`Set` API를 지원하는 클래스를 작성하려면, :meth:`__contains__`, :meth:`__iter__`"
" 및 :meth:`__len__`\\의 세 가지 하부 추상 메서드 만 제공하면 됩니다. ABC는 :meth:`__and__`\\와 "
":meth:`isdisjoint`\\와 같은 나머지 메서드를 제공합니다::"

#: ../../library/collections.abc.rst:395
msgid ""
"class ListBasedSet(collections.abc.Set):\n"
"    ''' Alternate set implementation favoring space over speed\n"
"        and not requiring the set elements to be hashable. '''\n"
"    def __init__(self, iterable):\n"
"        self.elements = lst = []\n"
"        for value in iterable:\n"
"            if value not in lst:\n"
"                lst.append(value)\n"
"\n"
"    def __iter__(self):\n"
"        return iter(self.elements)\n"
"\n"
"    def __contains__(self, value):\n"
"        return value in self.elements\n"
"\n"
"    def __len__(self):\n"
"        return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2            # The __and__() method is supported "
"automatically"
msgstr ""

#: ../../library/collections.abc.rst:417
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr ":class:`Set`\\과 :class:`MutableSet`\\을 믹스인으로 사용할 때의 주의 사항:"

#: ../../library/collections.abc.rst:420
#, fuzzy
msgid ""
"Since some set operations create new sets, the default mixin methods need"
" a way to create new instances from an :term:`iterable`. The class "
"constructor is assumed to have a signature in the form "
"``ClassName(iterable)``. That assumption is factored-out to an internal "
":class:`classmethod` called :meth:`!_from_iterable` which calls "
"``cls(iterable)`` to produce a new set. If the :class:`Set` mixin is "
"being used in a class with a different constructor signature, you will "
"need to override :meth:`!_from_iterable` with a classmethod or regular "
"method that can construct new instances from an iterable argument."
msgstr ""
"일부 집합 연산은 새로운 집합을 만들기 때문에, 기본 믹스인 메서드는 이터러블로부터 새 인스턴스를 만드는 방법이 필요합니다. 클래스"
" 생성자가 ``ClassName(iterable)`` 형식의 서명을 가진 것으로 가정합니다. 이 가정은 새로운 집합을 생성하기 위해"
" ``cls(iterable)``\\를 호출하는 :meth:`_from_iterable`\\이라는 내부 클래스 메서드로 "
"분리되었습니다. :class:`Set` 믹스인이 다른 생성자 서명을 갖는 클래스에서 사용되고 있으면, 이터러블 인자로부터 새 "
"인스턴스를 생성할 수 있는 클래스 메서드나 일반 메서드로 :meth:`_from_iterable`\\을 재정의해야 합니다."

#: ../../library/collections.abc.rst:431
#, fuzzy
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`~object.__le__` and :meth:`~object.__ge__`, then "
"the other operations will automatically follow suit."
msgstr ""
"비교를 재정의하려면 (의미는 고정되었으므로, 아마도 속도 때문에), :meth:`__le__`\\와 :meth:`__ge__`\\를"
" 재정의하십시오, 그러면 다른 연산은 자동으로 맞춰집니다."

#: ../../library/collections.abc.rst:437
#, fuzzy
msgid ""
"The :class:`Set` mixin provides a :meth:`!_hash` method to compute a hash"
" value for the set; however, :meth:`~object.__hash__` is not defined "
"because not all sets are :term:`hashable` or immutable.  To add set "
"hashability using mixins, inherit from both :meth:`Set` and "
":meth:`Hashable`, then define ``__hash__ = Set._hash``."
msgstr ""
":class:`Set` 믹스인은 집합의 해시값을 계산하는 :meth:`_hash` 메서드를 제공합니다; 그러나 모든 집합이 해시 "
"가능하거나 불변이지는 않기 때문에 :meth:`__hash__`\\는 정의되지 않습니다. 믹스인을 사용하여 집합 해시 가능성을 "
"추가하려면, :meth:`Set`\\와 :meth:`Hashable`\\을 모두 상속한 다음, ``__hash__ = "
"Set._hash``\\를 정의하십시오."

#: ../../library/collections.abc.rst:445
msgid ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ for "
"an example built on :class:`MutableSet`."
msgstr ""
":class:`MutableSet`\\으로 구축한 예제 `OrderedSet 조리법 "
"<https://code.activestate.com/recipes/576694/>`_."

#: ../../library/collections.abc.rst:448
msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr "ABC에 대한 자세한 내용은, :mod:`abc` 모듈과 :pep:`3119`\\를 참조하십시오."

