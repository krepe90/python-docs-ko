# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/getopt.rst:2
msgid ":mod:`!getopt` --- C-style parser for command line options"
msgstr ":mod:`!getopt` --- 명령 줄 옵션용 C 스타일 구문 분석기"

#: ../../library/getopt.rst:8
msgid "**Source code:** :source:`Lib/getopt.py`"
msgstr "**소스 코드:** :source:`Lib/getopt.py`"

#: ../../library/getopt.rst:12
msgid ""
"This module is considered feature complete. A more declarative and "
"extensible alternative to this API is provided in the :mod:`optparse` "
"module. Further functional enhancements for command line parameter "
"processing are provided either as third party modules on PyPI, or else as"
" features in the :mod:`argparse` module."
msgstr ""

#: ../../library/getopt.rst:20
msgid ""
"This module helps scripts to parse the command line arguments in "
"``sys.argv``. It supports the same conventions as the Unix "
":c:func:`!getopt` function (including the special meanings of arguments "
"of the form '``-``' and '``--``').  Long options similar to those "
"supported by GNU software may be used as well via an optional third "
"argument."
msgstr ""
"이 모듈은 스크립트가 ``sys.argv``\\에 있는 명령 줄 인자를 구문 분석하는 데 도움이 됩니다. 유닉스 "
":c:func:`!getopt` 함수와 같은 규칙을 지원합니다 ('``-``' 와 '``--``' 형식의 인자의 특수한 의미를 "
"포함합니다). 선택적인 세 번째 인자를 통해 GNU 소프트웨어가 지원하는 것과 유사한 긴 옵션을 사용할 수 있습니다."

#: ../../library/getopt.rst:26
msgid ""
"Users who are unfamiliar with the Unix :c:func:`!getopt` function should "
"consider using the :mod:`argparse` module instead. Users who are familiar"
" with the Unix :c:func:`!getopt` function, but would like to get "
"equivalent behavior while writing less code and getting better help and "
"error messages should consider using the :mod:`optparse` module. See :ref"
":`choosing-an-argument-parser` for additional details."
msgstr ""

#: ../../library/getopt.rst:33
msgid "This module provides two functions and an exception:"
msgstr "이 모듈은 두 가지 함수와 예외를 제공합니다:"

#: ../../library/getopt.rst:39
msgid ""
"Parses command line options and parameter list.  *args* is the argument "
"list to be parsed, without the leading reference to the running program. "
"Typically, this means ``sys.argv[1:]``. *shortopts* is the string of "
"option letters that the script wants to recognize, with options that "
"require an argument followed by a colon (``':'``; i.e., the same format "
"that Unix :c:func:`!getopt` uses)."
msgstr ""
"명령 줄 옵션과 매개 변수 목록을 구문 분석합니다. *args*\\는 실행 중인 프로그램에 대한 앞머리 참조를 포함하지 않는, 구문"
" 분석할 인자 리스트입니다. 일반적으로, 이는 ``sys.argv[1:]``\\를 의미합니다. *shortopts*\\는 스크립트가"
" 인식하고자 하는 옵션 문자의 문자열이며, 인자를 요구하는 옵션은 뒤에 콜론(``':'``; 즉, 유닉스 "
":c:func:`!getopt`\\가 사용하는 것과 같은 형식)이 필요합니다."

#: ../../library/getopt.rst:47
msgid ""
"Unlike GNU :c:func:`!getopt`, after a non-option argument, all further "
"arguments are considered also non-options. This is similar to the way "
"non-GNU Unix systems work."
msgstr ""
"GNU :c:func:`!getopt`\\와는 달리, 옵션이 아닌 인자 다음에 오는 모든 인자는 옵션이 아닌 것으로 간주합니다. "
"이는 비 GNU 유닉스 시스템이 작동하는 방식과 비슷합니다."

#: ../../library/getopt.rst:51
msgid ""
"*longopts*, if specified, must be a list of strings with the names of the"
" long options which should be supported.  The leading ``'--'`` characters"
" should not be included in the option name.  Long options which require "
"an argument should be followed by an equal sign (``'='``).  Optional "
"arguments are not supported.  To accept only long options, *shortopts* "
"should be an empty string.  Long options on the command line can be "
"recognized so long as they provide a prefix of the option name that "
"matches exactly one of the accepted options.  For example, if *longopts* "
"is ``['foo', 'frob']``, the option ``--fo`` will match as ``--foo``, but "
"``--f`` will not match uniquely, so :exc:`GetoptError` will be raised."
msgstr ""
"지정되면, *longopts*\\는 지원되어야 하는 긴 옵션의 이름을 가진 문자열 리스트여야 합니다. 선행 ``'--'`` 문자는 "
"옵션 이름에 포함되지 않아야 합니다. 인자가 필요한 긴 옵션 뒤에는 등호(``'='``)가 와야 합니다. 선택적 인자는 지원되지 "
"않습니다. 긴 옵션만 허용하려면, *shortopts*\\는 빈 문자열이어야 합니다. 명령 줄에서 긴 옵션은 허용된 옵션 중 하나와"
" 정확히 일치하는 옵션 이름의 접두사를 제공하는 한 인식 할 수 있습니다. 예를 들어, *longopts*\\가 ``['foo', "
"'frob']`` 면 ``--fo`` 옵션은 ``--foo``\\로 일치하지만, ``--f``\\는 유일하게 일치하지 않으므로 "
":exc:`GetoptError`\\가 발생합니다."

#: ../../library/getopt.rst:62
msgid ""
"The return value consists of two elements: the first is a list of "
"``(option, value)`` pairs; the second is the list of program arguments "
"left after the option list was stripped (this is a trailing slice of "
"*args*).  Each option-and-value pair returned has the option as its first"
" element, prefixed with a hyphen for short options (e.g., ``'-x'``) or "
"two hyphens for long options (e.g., ``'--long-option'``), and the option "
"argument as its second element, or an empty string if the option has no "
"argument.  The options occur in the list in the same order in which they "
"were found, thus allowing multiple occurrences.  Long and short options "
"may be mixed."
msgstr ""
"반환 값은 두 요소로 구성됩니다: 첫 번째는 ``(option, value)`` 쌍의 리스트입니다; 두 번째는 옵션 리스트가 제거된"
" 후 남겨진 프로그램 인자 리스트입니다 (이것은 *args*\\의 후행 슬라이스입니다). 반환된 각 옵션-값 쌍은 첫 번째 요소로 "
"옵션을 가지며, 짧은 옵션(예를 들어, ``'-x'``)은 하이픈이, 긴 옵션(예를 들어, ``'--long-option'``)은 "
"두 개의 하이픈이 접두사로 붙고, 두 번째 요소는 옵션 인자나 옵션에 인자가 없으면 빈 문자열입니다. 옵션은 발견된 순서와 같은 "
"순서로 리스트에 나타나므로, 여러 번 나오는 것을 허용합니다. 긴 옵션과 짧은 옵션은 혼합될 수 있습니다."

#: ../../library/getopt.rst:75
msgid ""
"This function works like :func:`getopt`, except that GNU style scanning "
"mode is used by default. This means that option and non-option arguments "
"may be intermixed. The :func:`getopt` function stops processing options "
"as soon as a non-option argument is encountered."
msgstr ""
"이 함수는 기본적으로 GNU 스타일 스캔 모드가 사용된다는 점을 제외하고는 :func:`getopt`\\처럼 작동합니다. 이것은 "
"옵션과 옵션이 아닌 인자가 섞일 수 있음을 뜻합니다. :func:`getopt` 함수는 옵션이 아닌 인자가 발견되자마자 옵션 처리를"
" 중지합니다."

#: ../../library/getopt.rst:80
msgid ""
"If the first character of the option string is ``'+'``, or if the "
"environment variable :envvar:`!POSIXLY_CORRECT` is set, then option "
"processing stops as soon as a non-option argument is encountered."
msgstr ""
"옵션 문자열의 첫 번째 문자가 ``'+'`` 이거나, 환경 변수 :envvar:`!POSIXLY_CORRECT`\\가 설정되면, "
"옵션이 아닌 인자를 만나자마자 옵션 처리가 중지됩니다."

#: ../../library/getopt.rst:87
msgid ""
"This is raised when an unrecognized option is found in the argument list "
"or when an option requiring an argument is given none. The argument to "
"the exception is a string indicating the cause of the error.  For long "
"options, an argument given to an option which does not require one will "
"also cause this exception to be raised.  The attributes :attr:`!msg` and "
":attr:`!opt` give the error message and related option; if there is no "
"specific option to which the exception relates, :attr:`!opt` is an empty "
"string."
msgstr ""
"인자 목록에 인식할 수 없는 옵션이 있거나 인자가 필요한 옵션에 아무것도 주어지지 않으면 발생합니다. 예외에 대한 인자는 에러의 "
"원인을 나타내는 문자열입니다. 긴 옵션의 경우, 인자를 요구하지 않는 옵션에 인자가 주어질 때도 이 예외를 발생시킵니다. 어트리뷰트"
" :attr:`!msg` 와 :attr:`!opt`\\는 에러 메시지와 관련 옵션을 제공합니다; 예외와 관련된 특정 옵션이 없으면 "
":attr:`!opt`\\는 빈 문자열입니다."

#: ../../library/getopt.rst:98
msgid "Alias for :exc:`GetoptError`; for backward compatibility."
msgstr ":exc:`GetoptError`\\의 별칭; 과거 호환성을 위한 것입니다."

#: ../../library/getopt.rst:100
msgid "An example using only Unix style options:"
msgstr "유닉스 스타일 옵션만 사용하는 예제:"

#: ../../library/getopt.rst:102
msgid ""
">>> import getopt\n"
">>> args = '-a -b -cfoo -d bar a1 a2'.split()\n"
">>> args\n"
"['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']\n"
">>> optlist, args = getopt.getopt(args, 'abc:d:')\n"
">>> optlist\n"
"[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]\n"
">>> args\n"
"['a1', 'a2']"
msgstr ""
">>> import getopt\n"
">>> args = '-a -b -cfoo -d bar a1 a2'.split()\n"
">>> args\n"
"['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']\n"
">>> optlist, args = getopt.getopt(args, 'abc:d:')\n"
">>> optlist\n"
"[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]\n"
">>> args\n"
"['a1', 'a2']"

#: ../../library/getopt.rst:114
msgid "Using long option names is equally easy:"
msgstr "긴 옵션 이름을 사용하는 것도 똑같이 간단합니다:"

#: ../../library/getopt.rst:116
msgid ""
">>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'\n"
">>> args = s.split()\n"
">>> args\n"
"['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', "
"'a2']\n"
">>> optlist, args = getopt.getopt(args, 'x', [\n"
"...     'condition=', 'output-file=', 'testing'])\n"
">>> optlist\n"
"[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'),"
" ('-x', '')]\n"
">>> args\n"
"['a1', 'a2']"
msgstr ""
">>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'\n"
">>> args = s.split()\n"
">>> args\n"
"['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', "
"'a2']\n"
">>> optlist, args = getopt.getopt(args, 'x', [\n"
"...     'condition=', 'output-file=', 'testing'])\n"
">>> optlist\n"
"[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'),"
" ('-x', '')]\n"
">>> args\n"
"['a1', 'a2']"

#: ../../library/getopt.rst:129
msgid "In a script, typical usage is something like this:"
msgstr "스크립트에서, 일반적인 사용법은 다음과 같습니다:"

#: ../../library/getopt.rst:131
msgid ""
"import getopt, sys\n"
"\n"
"def main():\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", "
"\"output=\"])\n"
"    except getopt.GetoptError as err:\n"
"        # print help information and exit:\n"
"        print(err)  # will print something like \"option -a not "
"recognized\"\n"
"        usage()\n"
"        sys.exit(2)\n"
"    output = None\n"
"    verbose = False\n"
"    for o, a in opts:\n"
"        if o == \"-v\":\n"
"            verbose = True\n"
"        elif o in (\"-h\", \"--help\"):\n"
"            usage()\n"
"            sys.exit()\n"
"        elif o in (\"-o\", \"--output\"):\n"
"            output = a\n"
"        else:\n"
"            assert False, \"unhandled option\"\n"
"    process(args, output=output, verbose=verbose)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"import getopt, sys\n"
"\n"
"def main():\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", "
"\"output=\"])\n"
"    except getopt.GetoptError as err:\n"
"        # 도움말 정보를 출력하고 종료합니다:\n"
"        print(err)  # \"option -a not recognized\" 같은 것을 출력합니다\n"
"        usage()\n"
"        sys.exit(2)\n"
"    output = None\n"
"    verbose = False\n"
"    for o, a in opts:\n"
"        if o == \"-v\":\n"
"            verbose = True\n"
"        elif o in (\"-h\", \"--help\"):\n"
"            usage()\n"
"            sys.exit()\n"
"        elif o in (\"-o\", \"--output\"):\n"
"            output = a\n"
"        else:\n"
"            assert False, \"unhandled option\"\n"
"    process(args, output=output, verbose=verbose)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

#: ../../library/getopt.rst:160
msgid ""
"Note that an equivalent command line interface could be produced with "
"less code and more informative help and error messages by using the "
":mod:`optparse` module:"
msgstr ""
":mod:`optparse` 모듈을 사용하면 더 적은 코드로, 더욱 유용한 도움말과 에러 메시지를 제공하는 동등한 명령 줄 "
"인터페이스를 만들 수 있습니다:"

#: ../../library/getopt.rst:163
msgid ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"
msgstr ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"

#: ../../library/getopt.rst:174
msgid ""
"A roughly equivalent command line interface for this case can also be "
"produced by using the :mod:`argparse` module:"
msgstr "이 경우와 거의 동등한 명령 줄 인터페이스를 :mod:`argparse` 모듈을 사용해서도 만들 수 있습니다:"

#: ../../library/getopt.rst:177
msgid ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"
msgstr ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"

#: ../../library/getopt.rst:189
msgid ""
"See :ref:`choosing-an-argument-parser` for details on how the "
"``argparse`` version of this code differs in behaviour from the "
"``optparse`` (and ``getopt``) version."
msgstr ""

#: ../../library/getopt.rst:195
msgid "Module :mod:`optparse`"
msgstr "모듈 :mod:`optparse`"

#: ../../library/getopt.rst:196
msgid "Declarative command line option parsing."
msgstr "선언적 명령 줄 옵션 구문 분석."

#: ../../library/getopt.rst:198
msgid "Module :mod:`argparse`"
msgstr "모듈 :mod:`argparse`"

#: ../../library/getopt.rst:199
msgid "More opinionated command line option and argument parsing library."
msgstr "더 견해가 강한 명령 줄 옵션과 인자 구문 분석 라이브러리."

#~ msgid ""
#~ "The :mod:`getopt` module is a parser "
#~ "for command line options whose API "
#~ "is designed to be familiar to "
#~ "users of the C :c:func:`getopt` "
#~ "function. Users who are unfamiliar with"
#~ " the C :c:func:`getopt` function or "
#~ "who would like to write less code"
#~ " and get better help and error "
#~ "messages should consider using the "
#~ ":mod:`argparse` module instead."
#~ msgstr ""
#~ ":mod:`getopt` 모듈은 API가 C :c:func:`getopt` "
#~ "함수의 사용자에게 익숙하도록 설계된 명령 줄 옵션용 "
#~ "파서입니다. C :c:func:`getopt` 함수에 익숙하지 않거나,"
#~ " 더 적은 코드를 작성하고 더 나은 도움말과 "
#~ "에러 메시지를 얻으려는 사용자는 대신 :mod:`argparse` "
#~ "모듈 사용을 고려해야 합니다."

