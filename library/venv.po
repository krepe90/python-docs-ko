# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/venv.rst:2
#, fuzzy
msgid ":mod:`!venv` --- Creation of virtual environments"
msgstr ":mod:`venv` --- 가상 환경 생성"

#: ../../library/venv.rst:12
msgid "**Source code:** :source:`Lib/venv/`"
msgstr "**소스 코드:** :source:`Lib/venv/`"

#: ../../library/venv.rst:21
msgid ""
"The :mod:`!venv` module supports creating lightweight \"virtual "
"environments\", each with their own independent set of Python packages "
"installed in their :mod:`site` directories. A virtual environment is "
"created on top of an existing Python installation, known as the virtual "
"environment's \"base\" Python, and may optionally be isolated from the "
"packages in the base environment, so only those explicitly installed in "
"the virtual environment are available."
msgstr ""

#: ../../library/venv.rst:29
#, fuzzy
msgid ""
"When used from within a virtual environment, common installation tools "
"such as :pypi:`pip` will install Python packages into a virtual "
"environment without needing to be told to do so explicitly."
msgstr ""
"setuptools_\\나 pip_\\와 같은 일반적인 설치 도구는 가상 환경에서 예상대로 작동합니다. 즉, 가상 환경이 "
"활성화되면, 명시적으로 그렇게 지정하지 않아도 파이썬 패키지를 가상 환경에 설치합니다."

#: ../../library/venv.rst:33
msgid "A virtual environment is (amongst other things):"
msgstr ""

#: ../../library/venv.rst:35
msgid ""
"Used to contain a specific Python interpreter and software libraries and "
"binaries which are needed to support a project (library or application). "
"These are by default isolated from software in other virtual environments"
" and Python interpreters and libraries installed in the operating system."
msgstr ""

#: ../../library/venv.rst:40
msgid ""
"Contained in a directory, conventionally named ``.venv`` or ``venv`` in "
"the project directory, or under a container directory for lots of virtual"
" environments, such as ``~/.virtualenvs``."
msgstr ""

#: ../../library/venv.rst:44
msgid "Not checked into source control systems such as Git."
msgstr ""

#: ../../library/venv.rst:46
msgid ""
"Considered as disposable -- it should be simple to delete and recreate it"
" from scratch. You don't place any project code in the environment."
msgstr ""

#: ../../library/venv.rst:49
msgid ""
"Not considered as movable or copyable -- you just recreate the same "
"environment in the target location."
msgstr ""

#: ../../library/venv.rst:52
#, fuzzy
msgid "See :pep:`405` for more background on Python virtual environments."
msgstr "파이썬 가상 환경에 대한 자세한 내용은 :pep:`405`\\를 참조하십시오."

#: ../../library/venv.rst:56
#, fuzzy
msgid ""
"`Python Packaging User Guide: Creating and using virtual environments "
"<https://packaging.python.org/guides/installing-using-pip-and-virtual-"
"environments/#create-and-use-virtual-environments>`__"
msgstr ""
"`Python Packaging User Guide: Creating and using virtual environments "
"<https://packaging.python.org/guides/installing-using-pip-and-virtual-"
"environments/#creating-a-virtual-environment>`__"

#: ../../includes/wasm-mobile-notavail.rst:3
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""

#: ../../library/venv.rst:62
msgid "Creating virtual environments"
msgstr "가상 환경 만들기"

#: ../../library/venv.rst:64
#, fuzzy
msgid ""
":ref:`Virtual environments <venv-def>` are created by executing the "
"``venv`` module:"
msgstr ":ref:`가상 환경 <venv-def>`\\은 ``venv`` 명령을 실행해서 만들어집니다::"

#: ../../library/venv.rst:67
msgid "python -m venv /path/to/new/virtual/environment"
msgstr ""

#: ../../library/venv.rst:71
#, fuzzy
msgid ""
"This creates the target directory (including parent directories as "
"needed) and places a :file:`pyvenv.cfg` file in it with a ``home`` key "
"pointing to the Python installation from which the command was run. It "
"also creates a :file:`bin` (or :file:`Scripts` on Windows) subdirectory "
"containing a copy or symlink of the Python executable (as appropriate for"
" the platform or arguments used at environment creation time). It also "
"creates a :file:`lib/pythonX.Y/site-packages` subdirectory (on Windows, "
"this is :file:`Lib\\site-packages`). If an existing directory is "
"specified, it will be re-used."
msgstr ""
"이 명령을 실행하면 대상 디렉터리가 만들어지고 (이미 존재하지 않는 부모 디렉터리도 만듭니다) 명령이 실행된 파이썬 설치를 가리키는"
" ``home`` 키가 있는 ``pyvenv.cfg`` 파일이 배치됩니다 (대상 디렉터리의 일반적인 이름은 "
"``.venv``\\입니다). 또한 파이썬 바이너리/바이너리들의 사본/심볼릭 링크를 포함하는 ``bin`` (또는 윈도우의 경우 "
"``Scripts``) 서브 디렉터리를 만듭니다 (플랫폼이나 환경 생성 시에 사용된 인자에 적절하게). 또한 (처음에는 비어있는) "
"``lib/pythonX.Y/site-packages`` (윈도우에서는, ``Lib\\site-packages``) 서브 디렉터리를"
" 만듭니다. 기존 디렉터리가 지정되면 재사용됩니다."

#: ../../library/venv.rst:81
msgid "The use of ``venv`` is now recommended for creating virtual environments."
msgstr "이제 가상 환경을 만들 때 ``venv``\\를 사용하는 것이 좋습니다."

#: ../../library/venv.rst:84
#, fuzzy
msgid ""
":program:`pyvenv` was the recommended tool for creating virtual "
"environments for Python 3.3 and 3.4, and replaced in 3.5 by executing "
"``venv`` directly."
msgstr ""
"``pyvenv``\\는 파이썬 3.3 및 3.4 용 가상 환경을 만드는 데 권장되는 도구였으며, `파이썬 3.6 에서 "
"폐지되었습니다 <../whatsnew/3.6.html#deprecated-features>`_."

#: ../../library/venv.rst:90
#, fuzzy
msgid "On Windows, invoke the ``venv`` command as follows:"
msgstr "윈도우에서는, 다음과 같이 ``venv`` 명령을 호출하십시오::"

#: ../../library/venv.rst:92
msgid "PS> python -m venv C:\\path\\to\\new\\virtual\\environment"
msgstr ""

#: ../../library/venv.rst:96
msgid "The command, if run with ``-h``, will show the available options::"
msgstr "명령에 ``-h``\\를 사용하면 사용 가능한 옵션이 표시됩니다::"

#: ../../library/venv.rst:98
msgid ""
"usage: venv [-h] [--system-site-packages] [--symlinks | --copies] "
"[--clear]\n"
"            [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-"
"deps]\n"
"            [--without-scm-ignore-files]\n"
"            ENV_DIR [ENV_DIR ...]\n"
"\n"
"Creates virtual Python environments in one or more target directories.\n"
"\n"
"positional arguments:\n"
"  ENV_DIR               A directory to create the environment in.\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  --system-site-packages\n"
"                        Give the virtual environment access to the system"
"\n"
"                        site-packages dir.\n"
"  --symlinks            Try to use symlinks rather than copies, when\n"
"                        symlinks are not the default for the platform.\n"
"  --copies              Try to use copies rather than symlinks, even when"
"\n"
"                        symlinks are the default for the platform.\n"
"  --clear               Delete the contents of the environment directory\n"
"                        if it already exists, before environment "
"creation.\n"
"  --upgrade             Upgrade the environment directory to use this\n"
"                        version of Python, assuming Python has been\n"
"                        upgraded in-place.\n"
"  --without-pip         Skips installing or upgrading pip in the virtual\n"
"                        environment (pip is bootstrapped by default)\n"
"  --prompt PROMPT       Provides an alternative prompt prefix for this\n"
"                        environment.\n"
"  --upgrade-deps        Upgrade core dependencies (pip) to the latest\n"
"                        version in PyPI\n"
"  --without-scm-ignore-files\n"
"                        Skips adding SCM ignore files to the environment\n"
"                        directory (Git is supported by default).\n"
"\n"
"Once an environment has been created, you may wish to activate it, e.g. "
"by\n"
"sourcing an activate script in its bin directory."
msgstr ""

#: ../../library/venv.rst:136
#, fuzzy
msgid ""
"Installs pip by default, added the ``--without-pip``  and ``--copies`` "
"options."
msgstr "기본적으로 pip을 설치합니다. ``--without-pip`` 와 ``--copies`` 옵션을 추가했습니다."

#: ../../library/venv.rst:140
msgid ""
"In earlier versions, if the target directory already existed, an error "
"was raised, unless the ``--clear`` or ``--upgrade`` option was provided."
msgstr ""
"이전 버전에서는, ``--clear`` 나 ``--upgrade`` 옵션이 제공되지 않았을 때, 대상 디렉터리가 이미 존재하면 "
"에러가 발생했습니다."

#: ../../library/venv.rst:144
#, fuzzy
msgid ""
"Add ``--upgrade-deps`` option to upgrade pip + setuptools to the latest "
"on PyPI."
msgstr "PyPI에 있는 최신으로 pip + setuptools를 업그레이드하는 ``--upgrade-deps`` 옵션을 추가했습니다"

#: ../../library/venv.rst:149
msgid "``setuptools`` is no longer a core venv dependency."
msgstr ""

#: ../../library/venv.rst:153
msgid "Added the ``--without-scm-ignore-files`` option."
msgstr ""

#: ../../library/venv.rst:154
msgid "``venv`` now creates a :file:`.gitignore` file for Git by default."
msgstr ""

#: ../../library/venv.rst:158
msgid ""
"While symlinks are supported on Windows, they are not recommended. Of "
"particular note is that double-clicking ``python.exe`` in File Explorer "
"will resolve the symlink eagerly and ignore the virtual environment."
msgstr ""
"심볼릭 링크가 윈도우에서 지원되지만, 추천하지는 않습니다. 특히 파일 탐색기에서 ``python.exe``\\를 더블 클릭하면 "
"심볼릭 링크를 열심히 따라가고(resolve) 가상 환경은 무시됩니다."

#: ../../library/venv.rst:163
msgid ""
"On Microsoft Windows, it may be required to enable the ``Activate.ps1`` "
"script by setting the execution policy for the user. You can do this by "
"issuing the following PowerShell command:"
msgstr ""
"마이크로소프트 윈도우에서는 사용자에 대한 실행 정책을 설정하여 ``Activate.ps1`` 스크립트를 활성화해야 할 수도 "
"있습니다. 다음 PowerShell 명령을 실행하여 이를 수행할 수 있습니다:"

#: ../../library/venv.rst:167
msgid ""
"PS C:\\> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope "
"CurrentUser"
msgstr ""
"PS C:\\> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope "
"CurrentUser"

#: ../../library/venv.rst:171
msgid ""
"See `About Execution Policies "
"<https://go.microsoft.com/fwlink/?LinkID=135170>`_ for more information."
msgstr ""
"자세한 정보는 `About Execution Policies "
"<https://go.microsoft.com/fwlink/?LinkID=135170>`_\\를 참조하십시오."

#: ../../library/venv.rst:175
#, fuzzy
msgid ""
"The created :file:`pyvenv.cfg` file also includes the ``include-system-"
"site-packages`` key, set to ``true`` if ``venv`` is run with the "
"``--system-site-packages`` option, ``false`` otherwise."
msgstr ""
"만들어진 ``pyvenv.cfg`` 파일에는 ``include-system-site-packages`` 키도 포함되어 있으며, "
"``venv``\\가 ``--system-site-packages`` 옵션으로 실행되면 ``true``\\로 설정되고, 그렇지 "
"않으면 ``false``\\로 설정됩니다."

#: ../../library/venv.rst:179
msgid ""
"Unless the ``--without-pip`` option is given, :mod:`ensurepip` will be "
"invoked to bootstrap ``pip`` into the virtual environment."
msgstr ""
"``--without-pip`` 옵션을 주지 않는 한, 가상 환경으로 ``pip``\\을 부트스트랩 하기 위해 "
":mod:`ensurepip`\\가 호출됩니다."

#: ../../library/venv.rst:182
msgid ""
"Multiple paths can be given to ``venv``, in which case an identical "
"virtual environment will be created, according to the given options, at "
"each provided path."
msgstr "``venv``\\에 여러 경로를 지정할 수 있습니다. 이때 지정된 옵션에 따라 제공된 각 경로에서 같은 가상 환경이 만들어집니다."

#: ../../library/venv.rst:189
msgid "How venvs work"
msgstr ""

#: ../../library/venv.rst:191
msgid ""
"When a Python interpreter is running from a virtual environment, "
":data:`sys.prefix` and :data:`sys.exec_prefix` point to the directories "
"of the virtual environment, whereas :data:`sys.base_prefix` and "
":data:`sys.base_exec_prefix` point to those of the base Python used to "
"create the environment. It is sufficient to check ``sys.prefix != "
"sys.base_prefix`` to determine if the current interpreter is running from"
" a virtual environment."
msgstr ""

#: ../../library/venv.rst:200
#, python-brace-format
msgid ""
"A virtual environment may be \"activated\" using a script in its binary "
"directory (``bin`` on POSIX; ``Scripts`` on Windows). This will prepend "
"that directory to your :envvar:`PATH`, so that running :program:`python` "
"will invoke the environment's Python interpreter and you can run "
"installed scripts without having to use their full path. The invocation "
"of the activation script is platform-specific (:samp:`{<venv>}` must be "
"replaced by the path to the directory containing the virtual "
"environment):"
msgstr ""

#: ../../library/venv.rst:210
msgid "Platform"
msgstr "플랫폼"

#: ../../library/venv.rst:210
msgid "Shell"
msgstr "셸"

#: ../../library/venv.rst:210
msgid "Command to activate virtual environment"
msgstr "가상 환경을 활성화하는 명령"

#: ../../library/venv.rst:212
msgid "POSIX"
msgstr "POSIX"

#: ../../library/venv.rst:212
msgid "bash/zsh"
msgstr "bash/zsh"

#: ../../library/venv.rst:212
#, fuzzy, python-brace-format
msgid ":samp:`$ source {<venv>}/bin/activate`"
msgstr "$ source <venv>/bin/activate"

#: ../../library/venv.rst:214
msgid "fish"
msgstr "fish"

#: ../../library/venv.rst:214
#, fuzzy, python-brace-format
msgid ":samp:`$ source {<venv>}/bin/activate.fish`"
msgstr "$ source <venv>/bin/activate.fish"

#: ../../library/venv.rst:216
msgid "csh/tcsh"
msgstr "csh/tcsh"

#: ../../library/venv.rst:216
#, fuzzy, python-brace-format
msgid ":samp:`$ source {<venv>}/bin/activate.csh`"
msgstr "$ source <venv>/bin/activate.csh"

#: ../../library/venv.rst:218
msgid "pwsh"
msgstr ""

#: ../../library/venv.rst:218
#, fuzzy, python-brace-format
msgid ":samp:`$ {<venv>}/bin/Activate.ps1`"
msgstr "$ <venv>/bin/Activate.ps1"

#: ../../library/venv.rst:220
msgid "Windows"
msgstr "윈도우"

#: ../../library/venv.rst:220
msgid "cmd.exe"
msgstr "cmd.exe"

#: ../../library/venv.rst:220
#, fuzzy, python-brace-format
msgid ":samp:`C:\\\\> {<venv>}\\\\Scripts\\\\activate.bat`"
msgstr "C:\\\\> <venv>\\\\Scripts\\\\activate.bat"

#: ../../library/venv.rst:222
msgid "PowerShell"
msgstr "PowerShell"

#: ../../library/venv.rst:222
#, fuzzy, python-brace-format
msgid ":samp:`PS C:\\\\> {<venv>}\\\\Scripts\\\\Activate.ps1`"
msgstr "PS C:\\\\> <venv>\\\\Scripts\\\\Activate.ps1"

#: ../../library/venv.rst:225
#, fuzzy
msgid ":program:`fish` and :program:`csh` activation scripts."
msgstr "``fish`` 와 ``csh`` 활성화 스크립트."

#: ../../library/venv.rst:228
msgid ""
"PowerShell activation scripts installed under POSIX for PowerShell Core "
"support."
msgstr "PowerShell Core 지원을 위해 POSIX에 설치된 PowerShell 활성화 스크립트."

#: ../../library/venv.rst:232
#, fuzzy
msgid ""
"You don't specifically *need* to activate a virtual environment, as you "
"can just specify the full path to that environment's Python interpreter "
"when invoking Python. Furthermore, all scripts installed in the "
"environment should be runnable without activating it."
msgstr ""
"환경을 구체적으로 활성화할 *필요*\\는 없습니다; 활성화는 단지 PATH의 처음에 가상 환경의 바이너리 디렉터리를 추가해서, "
"\"python\"이 가상 환경의 파이썬 인터프리터를 호출하고 전체 경로를 사용하지 않고도 설치된 스크립트를 실행할 수 있도록 할 "
"뿐입니다. 그러나, 가상 환경에 설치된 모든 스크립트는 활성화하지 않고도 실행 가능해야 하며, 자동으로 가상 환경의 파이썬을 "
"사용하여 실행해야 합니다."

#: ../../library/venv.rst:238
#, python-brace-format
msgid ""
"In order to achieve this, scripts installed into virtual environments "
"have a \"shebang\" line which points to the environment's Python "
"interpreter, :samp:`#!/{<path-to-venv>}/bin/python`. This means that the "
"script will run with that interpreter regardless of the value of "
":envvar:`PATH`. On Windows, \"shebang\" line processing is supported if "
"you have the :ref:`launcher` installed. Thus, double-clicking an "
"installed script in a Windows Explorer window should run it with the "
"correct interpreter without the environment needing to be activated or on"
" the :envvar:`PATH`."
msgstr ""

#: ../../library/venv.rst:247
#, fuzzy
msgid ""
"When a virtual environment has been activated, the :envvar:`!VIRTUAL_ENV`"
" environment variable is set to the path of the environment. Since "
"explicitly activating a virtual environment is not required to use it, "
":envvar:`!VIRTUAL_ENV` cannot be relied upon to determine whether a "
"virtual environment is being used."
msgstr ""
"가상 환경이 활성화되면, :envvar:`VIRTUAL_ENV` 환경 변수가 가상 환경의 경로로 설정됩니다. 가상 환경 내에서 실행"
" 중인지 확인하는 데 사용할 수 있습니다."

#: ../../library/venv.rst:253
msgid ""
"Because scripts installed in environments should not expect the "
"environment to be activated, their shebang lines contain the absolute "
"paths to their environment's interpreters. Because of this, environments "
"are inherently non-portable, in the general case. You should always have "
"a simple means of recreating an environment (for example, if you have a "
"requirements file ``requirements.txt``, you can invoke ``pip install -r "
"requirements.txt`` using the environment's ``pip`` to install all of the "
"packages needed by the environment). If for any reason you need to move "
"the environment to a new location, you should recreate it at the desired "
"location and delete the one at the old location. If you move an "
"environment because you moved a parent directory of it, you should "
"recreate the environment in its new location. Otherwise, software "
"installed into the environment may not work as expected."
msgstr ""

#: ../../library/venv.rst:267
#, fuzzy
msgid ""
"You can deactivate a virtual environment by typing ``deactivate`` in your"
" shell. The exact mechanism is platform-specific and is an internal "
"implementation detail (typically, a script or shell function will be "
"used)."
msgstr ""
"셸에서 \"deactivate\"를 입력하여 가상 환경을 비활성화할 수 있습니다. 정확한 메커니즘은 플랫폼에 따라 다르고 내부 구현"
" 상세입니다 (보통 스크립트나 셸 함수가 사용됩니다)."

#: ../../library/venv.rst:275
msgid "API"
msgstr "API"

#: ../../library/venv.rst:279
msgid ""
"The high-level method described above makes use of a simple API which "
"provides mechanisms for third-party virtual environment creators to "
"customize environment creation according to their needs, the "
":class:`EnvBuilder` class."
msgstr ""
"위에서 설명한 고수준 메서드는 제삼자 가상 환경 작성자가 필요에 따라 환경을 사용자 정의할 수 있는 메커니즘을 제공하는 간단한 "
"API를 사용합니다: :class:`EnvBuilder` 클래스."

#: ../../library/venv.rst:288
msgid ""
"The :class:`EnvBuilder` class accepts the following keyword arguments on "
"instantiation:"
msgstr ":class:`EnvBuilder` 클래스는 인스턴스를 만들 때 다음 키워드 인자를 받아들입니다:"

#: ../../library/venv.rst:291
#, fuzzy
msgid ""
"*system_site_packages* -- a boolean value indicating that the system "
"Python site-packages should be available to the environment (defaults to "
"``False``)."
msgstr ""
"``system_site_packages`` -- 시스템 파이썬 site-packages가 환경에서 사용 가능해야 함을 나타내는 "
"논릿값입니다 (기본값은 ``False``)."

#: ../../library/venv.rst:294
#, fuzzy
msgid ""
"*clear* -- a boolean value which, if true, will delete the contents of "
"any existing target directory, before creating the environment."
msgstr "``clear`` -- 참이면, 환경을 만들기 전에, 대상 디렉터리에 존재하는 내용을 지우도록 하는 논릿값."

#: ../../library/venv.rst:297
#, fuzzy
msgid ""
"*symlinks* -- a boolean value indicating whether to attempt to symlink "
"the Python binary rather than copying."
msgstr "``symlinks`` -- 파이썬 바이너리를 복사하는 대신 심볼릭 링크하려고 시도할지를 나타내는 논릿값입니다."

#: ../../library/venv.rst:300
#, fuzzy
msgid ""
"*upgrade* -- a boolean value which, if true, will upgrade an existing "
"environment with the running Python - for use when that Python has been "
"upgraded in-place (defaults to ``False``)."
msgstr ""
"``upgrade`` -- 참이면 실행 중인 파이썬으로 기존 환경을 업그레이드하도록 하는 논릿값 - 파이썬이 그 자리에서 "
"업그레이드되었을 때 사용됩니다 (기본값은 ``False``)."

#: ../../library/venv.rst:304
#, fuzzy
msgid ""
"*with_pip* -- a boolean value which, if true, ensures pip is installed in"
" the virtual environment. This uses :mod:`ensurepip` with the "
"``--default-pip`` option."
msgstr ""
"``with_pip`` -- 참이면 가상 환경에 pip이 설치되도록 하는 논릿값입니다. ``--default-pip`` 옵션과 함께"
" :mod:`ensurepip`\\를 사용합니다."

#: ../../library/venv.rst:308
#, fuzzy
msgid ""
"*prompt* -- a string to be used after virtual environment is activated "
"(defaults to ``None`` which means directory name of the environment would"
" be used). If the special string ``\".\"`` is provided, the basename of "
"the current directory is used as the prompt."
msgstr ""
"``prompt`` -- 가상 환경이 활성화된 후 사용할 문자열입니다 (기본값은 환경의 디렉터리 이름이 사용됨을 뜻하는 "
"``None``\\입니다). 특수한 문자열 ``\".\"``\\이 제공되면, 현재 디렉터리의 기본 이름(basename)이 "
"프롬프트로 사용됩니다."

#: ../../library/venv.rst:313
#, fuzzy
msgid "*upgrade_deps* -- Update the base venv modules to the latest on PyPI"
msgstr "``upgrade_deps`` -- PyPI에서 기반 venv 모듈을 최신으로 갱신합니다"

#: ../../library/venv.rst:315
#, python-brace-format
msgid ""
"*scm_ignore_files* -- Create ignore files based for the specified source "
"control managers (SCM) in the iterable. Support is defined by having a "
"method named ``create_{scm}_ignore_file``. The only value supported by "
"default is ``\"git\"`` via :meth:`create_git_ignore_file`."
msgstr ""

#: ../../library/venv.rst:321
msgid "Added the ``with_pip`` parameter"
msgstr "``with_pip`` 매개 변수 추가"

#: ../../library/venv.rst:324
msgid "Added the ``prompt`` parameter"
msgstr "``prompt`` 매개 변수 추가"

#: ../../library/venv.rst:327
msgid "Added the ``upgrade_deps`` parameter"
msgstr "``upgrade_deps`` 매개 변수 추가"

#: ../../library/venv.rst:330
#, fuzzy
msgid "Added the ``scm_ignore_files`` parameter"
msgstr "``upgrade_deps`` 매개 변수 추가"

#: ../../library/venv.rst:333
msgid ":class:`EnvBuilder` may be used as a base class."
msgstr ""

#: ../../library/venv.rst:337
msgid ""
"Create a virtual environment by specifying the target directory (absolute"
" or relative to the current directory) which is to contain the virtual "
"environment.  The ``create`` method will either create the environment in"
" the specified directory, or raise an appropriate exception."
msgstr ""
"가상 환경을 담을 대상 디렉터리(절대 또는 현재 디렉터리에 대한 상대)를 지정해서 가상 환경을 만듭니다. ``create`` "
"메서드는 지정된 디렉터리에 환경을 만들거나 적절한 예외를 발생시킵니다."

#: ../../library/venv.rst:343
msgid ""
"The ``create`` method of the :class:`EnvBuilder` class illustrates the "
"hooks available for subclass customization::"
msgstr ":class:`EnvBuilder` 클래스의 ``create`` 메서드는 서브 클래스가 사용자 정의할 수 있는 훅을 보여줍니다::"

#: ../../library/venv.rst:346
msgid ""
"def create(self, env_dir):\n"
"    \"\"\"\n"
"    Create a virtualized Python environment in a directory.\n"
"    env_dir is the target directory to create an environment in.\n"
"    \"\"\"\n"
"    env_dir = os.path.abspath(env_dir)\n"
"    context = self.ensure_directories(env_dir)\n"
"    self.create_configuration(context)\n"
"    self.setup_python(context)\n"
"    self.setup_scripts(context)\n"
"    self.post_setup(context)"
msgstr ""

#: ../../library/venv.rst:358
msgid ""
"Each of the methods :meth:`ensure_directories`, "
":meth:`create_configuration`, :meth:`setup_python`, :meth:`setup_scripts`"
" and :meth:`post_setup` can be overridden."
msgstr ""
"메서드 :meth:`ensure_directories`, :meth:`create_configuration`, "
":meth:`setup_python`, :meth:`setup_scripts` 및 :meth:`post_setup` 각각을 재정의할"
" 수 있습니다."

#: ../../library/venv.rst:364
#, fuzzy
msgid ""
"Creates the environment directory and all necessary subdirectories that "
"don't already exist, and returns a context object.  This context object "
"is just a holder for attributes (such as paths) for use by the other "
"methods.  If the :class:`EnvBuilder` is created with the arg "
"``clear=True``, contents of the environment directory will be cleared and"
" then all necessary subdirectories will be recreated."
msgstr ""
"환경 디렉터리와 필요한 모든 디렉터리를 만들고 문맥 객체를 돌려줍니다. 이것은 다른 메서드에서 사용하기 위한 어트리뷰트(가령 "
"경로)를 담고 있을 뿐입니다. 기존 환경 디렉터리에 작동하도록 ``clear`` 나 ``upgrade``\\가 지정되어있는 한, "
"디렉터리는 이미 존재할 수 있습니다."

#: ../../library/venv.rst:371
msgid ""
"The returned context object is a :class:`types.SimpleNamespace` with the "
"following attributes:"
msgstr ""

#: ../../library/venv.rst:374
msgid ""
"``env_dir`` - The location of the virtual environment. Used for "
"``__VENV_DIR__`` in activation scripts (see :meth:`install_scripts`)."
msgstr ""

#: ../../library/venv.rst:377
msgid ""
"``env_name`` - The name of the virtual environment. Used for "
"``__VENV_NAME__`` in activation scripts (see :meth:`install_scripts`)."
msgstr ""

#: ../../library/venv.rst:380
msgid ""
"``prompt`` - The prompt to be used by the activation scripts. Used for "
"``__VENV_PROMPT__`` in activation scripts (see :meth:`install_scripts`)."
msgstr ""

#: ../../library/venv.rst:383
msgid ""
"``executable`` - The underlying Python executable used by the virtual "
"environment. This takes into account the case where a virtual environment"
" is created from another virtual environment."
msgstr ""

#: ../../library/venv.rst:387
msgid "``inc_path`` - The include path for the virtual environment."
msgstr ""

#: ../../library/venv.rst:389
msgid "``lib_path`` - The purelib path for the virtual environment."
msgstr ""

#: ../../library/venv.rst:391
#, fuzzy
msgid "``bin_path`` - The script path for the virtual environment."
msgstr "플랫폼에 적합한 활성화 스크립트를 가상 환경에 설치합니다."

#: ../../library/venv.rst:393
msgid ""
"``bin_name`` - The name of the script path relative to the virtual "
"environment location. Used for ``__VENV_BIN_NAME__`` in activation "
"scripts (see :meth:`install_scripts`)."
msgstr ""

#: ../../library/venv.rst:397
msgid ""
"``env_exe`` - The name of the Python interpreter in the virtual "
"environment. Used for ``__VENV_PYTHON__`` in activation scripts (see "
":meth:`install_scripts`)."
msgstr ""

#: ../../library/venv.rst:401
msgid ""
"``env_exec_cmd`` - The name of the Python interpreter, taking into "
"account filesystem redirections. This can be used to run Python in the "
"virtual environment."
msgstr ""

#: ../../library/venv.rst:406
msgid ""
"The *venv* :ref:`sysconfig installation scheme <installation_paths>` is "
"used to construct the paths of the created directories."
msgstr ""

#: ../../library/venv.rst:411
msgid ""
"The attribute ``lib_path`` was added to the context, and the context "
"object was documented."
msgstr ""

#: ../../library/venv.rst:417
msgid "Creates the ``pyvenv.cfg`` configuration file in the environment."
msgstr "환경에 ``pyvenv.cfg`` 구성 파일을 만듭니다."

#: ../../library/venv.rst:421
msgid ""
"Creates a copy or symlink to the Python executable in the environment. On"
" POSIX systems, if a specific executable ``python3.x`` was used, symlinks"
" to ``python`` and ``python3`` will be created pointing to that "
"executable, unless files with those names already exist."
msgstr ""
"환경에 파이썬 실행 파일의 복사본이나 심볼릭 링크를 만듭니다. POSIX 시스템에서, 특정 실행 파일 ``python3.x``\\가"
" 사용되면, 해당 이름의 파일이 이미 존재하지 않는 한 ``python`` 과 ``python3`` 심볼릭 링크가 해당 실행 파일을"
" 가리키도록 만들어집니다."

#: ../../library/venv.rst:428
msgid ""
"Installs activation scripts appropriate to the platform into the virtual "
"environment."
msgstr "플랫폼에 적합한 활성화 스크립트를 가상 환경에 설치합니다."

#: ../../library/venv.rst:433
#, fuzzy
msgid ""
"Upgrades the core venv dependency packages (currently :pypi:`pip`) in the"
" environment. This is done by shelling out to the ``pip`` executable in "
"the environment."
msgstr ""
"환경에서 핵심 venv 종속성 패키지 (현재 ``pip``\\와 ``setuptools``)를 업그레이드합니다. 이것은 환경에서 "
"셸로 ``pip`` 실행 파일을 실행하여 수행됩니다."

#: ../../library/venv.rst:440
msgid ":pypi:`setuptools` is no longer a core venv dependency."
msgstr ""

#: ../../library/venv.rst:444
msgid ""
"A placeholder method which can be overridden in third party "
"implementations to pre-install packages in the virtual environment or "
"perform other post-creation steps."
msgstr "제삼자 구현에서 재정의하여 가상 환경에 패키지를 사전 설치하거나 다른 생성 후 단계를 수행할 수 있는 메서드입니다."

#: ../../library/venv.rst:450
#, fuzzy
msgid ""
"This method can be called from :meth:`setup_scripts` or "
":meth:`post_setup` in subclasses to assist in installing custom scripts "
"into the virtual environment."
msgstr ""
"또한, :class:`EnvBuilder`\\는 가상 환경에 사용자 정의 스크립트를 설치하는 데 도움이 되는 유틸리티 메서드를 "
"제공하는데, 서브 클래스의 :meth:`setup_scripts` 나 :meth:`post_setup`\\에서 호출할 수 있습니다."

#: ../../library/venv.rst:454
#, fuzzy
msgid ""
"*path* is the path to a directory that should contain subdirectories "
"``common``, ``posix``, ``nt``; each containing scripts destined for the "
"``bin`` directory in the environment.  The contents of ``common`` and the"
" directory corresponding to :data:`os.name` are copied after some text "
"replacement of placeholders:"
msgstr ""
"*path*\\는 \"common\", \"posix\", \"nt\" 서브 디렉터리를 포함해야 하는 디렉터리 경로입니다. 각 "
"디렉터리에는 환경의 bin 디렉터리로 들어갈 스크립트가 들어 있습니다. \"common\"과 :data:`os.name`\\에 "
"해당하는 디렉터리의 내용은 자리 표시자의 일부 텍스트 치환 후 복사됩니다:"

#: ../../library/venv.rst:460
msgid ""
"``__VENV_DIR__`` is replaced with the absolute path of the environment "
"directory."
msgstr "``__VENV_DIR__``\\은 환경 디렉터리의 절대 경로로 치환됩니다."

#: ../../library/venv.rst:463
msgid ""
"``__VENV_NAME__`` is replaced with the environment name (final path "
"segment of environment directory)."
msgstr "``__VENV_NAME__``\\은 환경 이름(환경 디렉터리의 최종 경로 세그먼트)으로 치환됩니다."

#: ../../library/venv.rst:466
msgid ""
"``__VENV_PROMPT__`` is replaced with the prompt (the environment name "
"surrounded by parentheses and with a following space)"
msgstr "``__VENV_PROMPT__``\\는 프롬프트(괄호로 묶인 환경 이름과 그 뒤의 스페이스)로 치환됩니다"

#: ../../library/venv.rst:469
msgid ""
"``__VENV_BIN_NAME__`` is replaced with the name of the bin directory "
"(either ``bin`` or ``Scripts``)."
msgstr "``__VENV_BIN_NAME__``\\은 bin 디렉터리의 이름(``bin`` 이나 ``Scripts``)으로 치환됩니다."

#: ../../library/venv.rst:472
msgid ""
"``__VENV_PYTHON__`` is replaced with the absolute path of the "
"environment's executable."
msgstr "``__VENV_PYTHON__``\\은 환경의 실행 파일의 절대 경로로 치환됩니다."

#: ../../library/venv.rst:475
msgid ""
"The directories are allowed to exist (for when an existing environment is"
" being upgraded)."
msgstr "디렉터리는 존재하는 것이 허용됩니다 (기존 환경이 업그레이드될 때)."

#: ../../library/venv.rst:480
msgid ""
"Creates a ``.gitignore`` file within the virtual environment that causes "
"the entire directory to be ignored by the Git source control manager."
msgstr ""

#: ../../library/venv.rst:485
msgid ""
"Windows now uses redirector scripts for ``python[w].exe`` instead of "
"copying the actual binaries. In 3.7.2 only :meth:`setup_python` does "
"nothing unless running from a build in the source tree."
msgstr ""
"윈도우는 이제 실제 바이너리를 복사하는 대신 ``python[w].exe``\\를 위한 리디렉터 스크립트를 사용합니다. 3.7.2 "
"에서만, 소스 트리의 빌드에서 실행하지 않는 한 :meth:`setup_python`\\ 아무 작업도 수행하지 않습니다."

#: ../../library/venv.rst:490
msgid ""
"Windows copies the redirector scripts as part of :meth:`setup_python` "
"instead of :meth:`setup_scripts`. This was not the case in 3.7.2. When "
"using symlinks, the original executables will be linked."
msgstr ""
"윈도우는 :meth:`setup_scripts` 대신 :meth:`setup_python`\\의 일부로 리디렉터 스크립트를 "
"복사합니다. 이것은 3.7.2는 해당하지 않습니다. 심볼릭 링크를 사용하면, 원래 실행 파일이 링크됩니다."

#: ../../library/venv.rst:495
msgid "There is also a module-level convenience function:"
msgstr "모듈 수준의 편리 함수도 있습니다:"

#: ../../library/venv.rst:501
msgid ""
"Create an :class:`EnvBuilder` with the given keyword arguments, and call "
"its :meth:`~EnvBuilder.create` method with the *env_dir* argument."
msgstr ""
"주어진 키워드 인자로 :class:`EnvBuilder`\\를 만들고, *env_dir* 인자로 "
":meth:`~EnvBuilder.create` 메서드를 호출합니다."

#: ../../library/venv.rst:506
#, fuzzy
msgid "Added the *with_pip* parameter"
msgstr "``with_pip`` 매개 변수 추가"

#: ../../library/venv.rst:509
#, fuzzy
msgid "Added the *prompt* parameter"
msgstr "``prompt`` 매개 변수 추가"

#: ../../library/venv.rst:512
#, fuzzy
msgid "Added the *upgrade_deps* parameter"
msgstr "``upgrade_deps`` 매개 변수 추가"

#: ../../library/venv.rst:515
#, fuzzy
msgid "Added the *scm_ignore_files* parameter"
msgstr "``upgrade_deps`` 매개 변수 추가"

#: ../../library/venv.rst:519
msgid "An example of extending ``EnvBuilder``"
msgstr "``EnvBuilder`` 확장 예제"

#: ../../library/venv.rst:521
msgid ""
"The following script shows how to extend :class:`EnvBuilder` by "
"implementing a subclass which installs setuptools and pip into a created "
"virtual environment::"
msgstr ""
"다음 스크립트는 생성된 가상 환경에 setuptools 와 pip을 설치하는 서브 클래스를 구현하여 "
":class:`EnvBuilder`\\를 확장하는 방법을 보여줍니다::"

#: ../../library/venv.rst:524
#, python-format
msgid ""
"import os\n"
"import os.path\n"
"from subprocess import Popen, PIPE\n"
"import sys\n"
"from threading import Thread\n"
"from urllib.parse import urlparse\n"
"from urllib.request import urlretrieve\n"
"import venv\n"
"\n"
"class ExtendedEnvBuilder(venv.EnvBuilder):\n"
"    \"\"\"\n"
"    This builder installs setuptools and pip so that you can pip or\n"
"    easy_install other packages into the created virtual environment.\n"
"\n"
"    :param nodist: If true, setuptools and pip are not installed into the"
"\n"
"                   created virtual environment.\n"
"    :param nopip: If true, pip is not installed into the created\n"
"                  virtual environment.\n"
"    :param progress: If setuptools or pip are installed, the progress of "
"the\n"
"                     installation can be monitored by passing a progress\n"
"                     callable. If specified, it is called with two\n"
"                     arguments: a string indicating some progress, and a\n"
"                     context indicating where the string is coming from.\n"
"                     The context argument can have one of three values:\n"
"                     'main', indicating that it is called from "
"virtualize()\n"
"                     itself, and 'stdout' and 'stderr', which are "
"obtained\n"
"                     by reading lines from the output streams of a "
"subprocess\n"
"                     which is used to install the app.\n"
"\n"
"                     If a callable is not specified, default progress\n"
"                     information is output to sys.stderr.\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        self.nodist = kwargs.pop('nodist', False)\n"
"        self.nopip = kwargs.pop('nopip', False)\n"
"        self.progress = kwargs.pop('progress', None)\n"
"        self.verbose = kwargs.pop('verbose', False)\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"    def post_setup(self, context):\n"
"        \"\"\"\n"
"        Set up any packages which need to be pre-installed into the\n"
"        virtual environment being created.\n"
"\n"
"        :param context: The information for the virtual environment\n"
"                        creation request being processed.\n"
"        \"\"\"\n"
"        os.environ['VIRTUAL_ENV'] = context.env_dir\n"
"        if not self.nodist:\n"
"            self.install_setuptools(context)\n"
"        # Can't install pip without setuptools\n"
"        if not self.nopip and not self.nodist:\n"
"            self.install_pip(context)\n"
"\n"
"    def reader(self, stream, context):\n"
"        \"\"\"\n"
"        Read lines from a subprocess' output stream and either pass to a "
"progress\n"
"        callable (if specified) or write progress information to "
"sys.stderr.\n"
"        \"\"\"\n"
"        progress = self.progress\n"
"        while True:\n"
"            s = stream.readline()\n"
"            if not s:\n"
"                break\n"
"            if progress is not None:\n"
"                progress(s, context)\n"
"            else:\n"
"                if not self.verbose:\n"
"                    sys.stderr.write('.')\n"
"                else:\n"
"                    sys.stderr.write(s.decode('utf-8'))\n"
"                sys.stderr.flush()\n"
"        stream.close()\n"
"\n"
"    def install_script(self, context, name, url):\n"
"        _, _, path, _, _, _ = urlparse(url)\n"
"        fn = os.path.split(path)[-1]\n"
"        binpath = context.bin_path\n"
"        distpath = os.path.join(binpath, fn)\n"
"        # Download script into the virtual environment's binaries folder\n"
"        urlretrieve(url, distpath)\n"
"        progress = self.progress\n"
"        if self.verbose:\n"
"            term = '\\n'\n"
"        else:\n"
"            term = ''\n"
"        if progress is not None:\n"
"            progress('Installing %s ...%s' % (name, term), 'main')\n"
"        else:\n"
"            sys.stderr.write('Installing %s ...%s' % (name, term))\n"
"            sys.stderr.flush()\n"
"        # Install in the virtual environment\n"
"        args = [context.env_exe, fn]\n"
"        p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=binpath)\n"
"        t1 = Thread(target=self.reader, args=(p.stdout, 'stdout'))\n"
"        t1.start()\n"
"        t2 = Thread(target=self.reader, args=(p.stderr, 'stderr'))\n"
"        t2.start()\n"
"        p.wait()\n"
"        t1.join()\n"
"        t2.join()\n"
"        if progress is not None:\n"
"            progress('done.', 'main')\n"
"        else:\n"
"            sys.stderr.write('done.\\n')\n"
"        # Clean up - no longer needed\n"
"        os.unlink(distpath)\n"
"\n"
"    def install_setuptools(self, context):\n"
"        \"\"\"\n"
"        Install setuptools in the virtual environment.\n"
"\n"
"        :param context: The information for the virtual environment\n"
"                        creation request being processed.\n"
"        \"\"\"\n"
"        url = \"https://bootstrap.pypa.io/ez_setup.py\"\n"
"        self.install_script(context, 'setuptools', url)\n"
"        # clear up the setuptools archive which gets downloaded\n"
"        pred = lambda o: o.startswith('setuptools-') and "
"o.endswith('.tar.gz')\n"
"        files = filter(pred, os.listdir(context.bin_path))\n"
"        for f in files:\n"
"            f = os.path.join(context.bin_path, f)\n"
"            os.unlink(f)\n"
"\n"
"    def install_pip(self, context):\n"
"        \"\"\"\n"
"        Install pip in the virtual environment.\n"
"\n"
"        :param context: The information for the virtual environment\n"
"                        creation request being processed.\n"
"        \"\"\"\n"
"        url = 'https://bootstrap.pypa.io/get-pip.py'\n"
"        self.install_script(context, 'pip', url)\n"
"\n"
"\n"
"def main(args=None):\n"
"    import argparse\n"
"\n"
"    parser = argparse.ArgumentParser(prog=__name__,\n"
"                                     description='Creates virtual Python "
"'\n"
"                                                 'environments in one or "
"'\n"
"                                                 'more target '\n"
"                                                 'directories.')\n"
"    parser.add_argument('dirs', metavar='ENV_DIR', nargs='+',\n"
"                        help='A directory in which to create the '\n"
"                             'virtual environment.')\n"
"    parser.add_argument('--no-setuptools', default=False,\n"
"                        action='store_true', dest='nodist',\n"
"                        help=\"Don't install setuptools or pip in the \"\n"
"                             \"virtual environment.\")\n"
"    parser.add_argument('--no-pip', default=False,\n"
"                        action='store_true', dest='nopip',\n"
"                        help=\"Don't install pip in the virtual \"\n"
"                             \"environment.\")\n"
"    parser.add_argument('--system-site-packages', default=False,\n"
"                        action='store_true', dest='system_site',\n"
"                        help='Give the virtual environment access to the "
"'\n"
"                             'system site-packages dir.')\n"
"    if os.name == 'nt':\n"
"        use_symlinks = False\n"
"    else:\n"
"        use_symlinks = True\n"
"    parser.add_argument('--symlinks', default=use_symlinks,\n"
"                        action='store_true', dest='symlinks',\n"
"                        help='Try to use symlinks rather than copies, '\n"
"                             'when symlinks are not the default for '\n"
"                             'the platform.')\n"
"    parser.add_argument('--clear', default=False, action='store_true',\n"
"                        dest='clear', help='Delete the contents of the '\n"
"                                           'virtual environment '\n"
"                                           'directory if it already '\n"
"                                           'exists, before virtual '\n"
"                                           'environment creation.')\n"
"    parser.add_argument('--upgrade', default=False, action='store_true',\n"
"                        dest='upgrade', help='Upgrade the virtual '\n"
"                                             'environment directory to '\n"
"                                             'use this version of '\n"
"                                             'Python, assuming Python '\n"
"                                             'has been upgraded '\n"
"                                             'in-place.')\n"
"    parser.add_argument('--verbose', default=False, action='store_true',\n"
"                        dest='verbose', help='Display the output '\n"
"                                             'from the scripts which '\n"
"                                             'install setuptools and "
"pip.')\n"
"    options = parser.parse_args(args)\n"
"    if options.upgrade and options.clear:\n"
"        raise ValueError('you cannot supply --upgrade and --clear "
"together.')\n"
"    builder = "
"ExtendedEnvBuilder(system_site_packages=options.system_site,\n"
"                                   clear=options.clear,\n"
"                                   symlinks=options.symlinks,\n"
"                                   upgrade=options.upgrade,\n"
"                                   nodist=options.nodist,\n"
"                                   nopip=options.nopip,\n"
"                                   verbose=options.verbose)\n"
"    for d in options.dirs:\n"
"        builder.create(d)\n"
"\n"
"if __name__ == '__main__':\n"
"    rc = 1\n"
"    try:\n"
"        main()\n"
"        rc = 0\n"
"    except Exception as e:\n"
"        print('Error: %s' % e, file=sys.stderr)\n"
"    sys.exit(rc)"
msgstr ""

#: ../../library/venv.rst:732
msgid ""
"This script is also available for download `online "
"<https://gist.github.com/vsajip/4673395>`_."
msgstr "이 스크립트는 `온라인 <https://gist.github.com/vsajip/4673395>`_\\에서 내려받을 수도 있습니다."

#: ../../library/venv.rst:14
msgid "Environments"
msgstr ""

#: ../../library/venv.rst:14
msgid "virtual"
msgstr ""

#~ msgid ""
#~ "The :mod:`venv` module provides support "
#~ "for creating lightweight \"virtual "
#~ "environments\" with their own site "
#~ "directories, optionally isolated from system"
#~ " site directories.  Each virtual "
#~ "environment has its own Python binary"
#~ " (which matches the version of the"
#~ " binary that was used to create "
#~ "this environment) and can have its "
#~ "own independent set of installed Python"
#~ " packages in its site directories."
#~ msgstr ""
#~ ":mod:`venv` 모듈은 자체 사이트 디렉터리를 갖는 경량"
#~ " \"가상 환경\"을 만들고, 선택적으로 시스템 사이트 "
#~ "디렉터리에서 격리할 수 있도록 지원합니다. 각 가상 "
#~ "환경은 고유한 파이썬 바이너리(이 환경을 만드는 데 "
#~ "사용된 바이너리 버전과 일치함)를 가지며 자신의 사이트 "
#~ "디렉터리에 독립적으로 설치된 파이썬 패키지 집합을 가질 "
#~ "수 있습니다."

#~ msgid ""
#~ "Alternatively, if you configured the "
#~ "``PATH`` and ``PATHEXT`` variables for "
#~ "your :ref:`Python installation <using-on-"
#~ "windows>`::"
#~ msgstr ""
#~ "또는, 여러분의 :ref:`파이썬 설치 <using-on-"
#~ "windows>`\\에 ``PATH`` 와 ``PATHEXT`` 변수를 "
#~ "구성했으면::"

#~ msgid ""
#~ "Once a virtual environment has been "
#~ "created, it can be \"activated\" using"
#~ " a script in the virtual "
#~ "environment's binary directory. The invocation"
#~ " of the script is platform-specific"
#~ " (`<venv>` must be replaced by the"
#~ " path of the directory containing the"
#~ " virtual environment):"
#~ msgstr ""
#~ "일단 가상 환경이 만들어지면, 가상 환경의 바이너리 "
#~ "디렉터리에 있는 스크립트를 사용하여 \"활성화\"할 수 "
#~ "있습니다. 스크립트의 호출은 플랫폼에 따라 다릅니다 "
#~ "(`<venv>`\\는 가상 환경을 포함하는 디렉터리의 경로로 "
#~ "대체되어야 합니다):"

#~ msgid "PowerShell Core"
#~ msgstr "PowerShell Core"

#~ msgid ""
#~ "A virtual environment is a Python "
#~ "environment such that the Python "
#~ "interpreter, libraries and scripts installed"
#~ " into it are isolated from those "
#~ "installed in other virtual environments, "
#~ "and (by default) any libraries installed"
#~ " in a \"system\" Python, i.e., one"
#~ " which is installed as part of "
#~ "your operating system."
#~ msgstr ""
#~ "가상 환경은 파이썬 인터프리터, 라이브러리 및 스크립트가"
#~ " 다른 가상 환경에 설치된 것과 (기본적으로) "
#~ "\"시스템\" 파이썬(즉, 여러분의 운영 체제 일부로 "
#~ "설치되어있는 것)에 설치된 모든 라이브러리와 격리되어있는 "
#~ "파이썬 환경입니다."

#~ msgid ""
#~ "A virtual environment is a directory "
#~ "tree which contains Python executable "
#~ "files and other files which indicate "
#~ "that it is a virtual environment."
#~ msgstr "가상 환경은 파이썬 실행 파일과 가상 환경임을 나타내는 다른 파일을 포함하는 디렉터리 트리입니다."

#~ msgid ""
#~ "When a virtual environment is active "
#~ "(i.e., the virtual environment's Python "
#~ "interpreter is running), the attributes "
#~ ":attr:`sys.prefix` and :attr:`sys.exec_prefix` point"
#~ " to the base directory of the "
#~ "virtual environment, whereas :attr:`sys.base_prefix`"
#~ " and :attr:`sys.base_exec_prefix` point to "
#~ "the non-virtual environment Python "
#~ "installation which was used to create"
#~ " the virtual environment. If a "
#~ "virtual environment is not active, then"
#~ " :attr:`sys.prefix` is the same as "
#~ ":attr:`sys.base_prefix` and :attr:`sys.exec_prefix` "
#~ "is the same as :attr:`sys.base_exec_prefix`"
#~ " (they all point to a non-"
#~ "virtual environment Python installation)."
#~ msgstr ""
#~ "가상 환경이 활성일 때 (즉, 가상 환경의 파이썬"
#~ " 인터프리터가 실행 중일 때), 어트리뷰트 "
#~ ":attr:`sys.prefix` 와 :attr:`sys.exec_prefix`\\는 가상"
#~ " 환경의 베이스 디렉터리를 가리키지만, "
#~ ":attr:`sys.base_prefix`\\와 :attr:`sys.base_exec_prefix`\\는 "
#~ "가상 환경을 만들 때 사용한 가상이 아닌 환경의"
#~ " 파이썬을 가리킵니다. 가상 환경이 활성화되어 있지 "
#~ "않으면, :attr:`sys.prefix`\\는 :attr:`sys.base_prefix`\\와 "
#~ "같고, :attr:`sys.exec_prefix`\\는 "
#~ ":attr:`sys.base_exec_prefix`\\와 같습니다 (모두 가상 "
#~ "환경이 아닌 파이썬 설치를 가리킵니다)."

#~ msgid ""
#~ "When a virtual environment is active,"
#~ " any options that change the "
#~ "installation path will be ignored from"
#~ " all :mod:`distutils` configuration files "
#~ "to prevent projects being inadvertently "
#~ "installed outside of the virtual "
#~ "environment."
#~ msgstr ""
#~ "가상 환경이 활성일 때, 설치 경로를 변경하는 모든"
#~ " 옵션이 모든 :mod:`distutils` 구성 파일에서 "
#~ "무시되어, 실수로 가상 환경 외부에 프로젝트가 설치되는 "
#~ "것을 방지합니다."

#~ msgid ""
#~ "When working in a command shell, "
#~ "users can make a virtual environment "
#~ "active by running an ``activate`` script"
#~ " in the virtual environment's executables"
#~ " directory (the precise filename and "
#~ "command to use the file is "
#~ "shell-dependent), which prepends the "
#~ "virtual environment's directory for "
#~ "executables to the ``PATH`` environment "
#~ "variable for the running shell. There"
#~ " should be no need in other "
#~ "circumstances to activate a virtual "
#~ "environment; scripts installed into virtual"
#~ " environments have a \"shebang\" line "
#~ "which points to the virtual "
#~ "environment's Python interpreter. This means"
#~ " that the script will run with "
#~ "that interpreter regardless of the value"
#~ " of ``PATH``. On Windows, \"shebang\" "
#~ "line processing is supported if you "
#~ "have the Python Launcher for Windows "
#~ "installed (this was added to Python "
#~ "in 3.3 - see :pep:`397` for more"
#~ " details). Thus, double-clicking an "
#~ "installed script in a Windows Explorer"
#~ " window should run the script with"
#~ " the correct interpreter without there "
#~ "needing to be any reference to its"
#~ " virtual environment in ``PATH``."
#~ msgstr ""
#~ "명령 셸에서 작업할 때, 사용자는 가상 환경의 실행"
#~ " 파일 디렉터리(정확한 파일 이름과 파일을 사용하는 "
#~ "명령은 셸 종속적입니다)에서 ``activate`` 스크립트를 실행하여"
#~ " 가상 환경을 활성화할 수 있습니다. 이 파일은 "
#~ "가상 환경의 실행 파일 디렉터리를 실행 중인 셸의"
#~ " ``PATH`` 환경 변수 앞에 추가합니다. 다른 "
#~ "상황에서는 가상 환경을 활성화할 필요가 없습니다; 가상 "
#~ "환경에 설치된 스크립트에는 가상 환경의 파이썬 인터프리터를"
#~ " 가리키는 \"셔뱅\" 줄이 있습니다. 이는 스크립트가 "
#~ "``PATH`` 값과 상관없이 해당 인터프리터로 실행됨을 "
#~ "뜻합니다. 윈도우에서는, Python Launcher for "
#~ "Windows를 설치하면 \"셔뱅\" 줄 처리가 지원됩니다 "
#~ "(이것은 파이썬 3.3에 추가되었습니다 - 자세한 내용은"
#~ " :pep:`397`\\를 참조하십시오). 그래서, 윈도우 탐색기 "
#~ "창에서 설치된 스크립트를 더블 클릭하면 ``PATH``\\에 "
#~ "가상 환경에 대한 참조가 없어도 올바른 인터프리터로 "
#~ "스크립트를 실행하게 됩니다."

#~ msgid ""
#~ "Creators of third-party virtual "
#~ "environment tools will be free to "
#~ "use the provided :class:`EnvBuilder` class "
#~ "as a base class."
#~ msgstr ""
#~ "제삼자 가상 환경 도구 제작자는 제공된 "
#~ ":class:`EnvBuilder` 클래스를 베이스 클래스로 자유롭게 "
#~ "사용할 수 있습니다."

#~ msgid "The returned env-builder is an object which has a method, ``create``:"
#~ msgstr "반환된 객체에는 메서드 ``create``\\가 있습니다:"

