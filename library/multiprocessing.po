# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/multiprocessing.rst:2
#, fuzzy
msgid ":mod:`!multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- 프로세스 기반 병렬 처리"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**소스 코드:** :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-mobile-notavail.rst:3
#, fuzzy
msgid "Availability"
msgstr "피클 가능성"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "소개"

#: ../../library/multiprocessing.rst:16
#, fuzzy
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes "
"using an API similar to the :mod:`threading` module.  The "
":mod:`multiprocessing` package offers both local and remote concurrency, "
"effectively side-stepping the :term:`Global Interpreter Lock <global "
"interpreter lock>` by using subprocesses instead of threads.  Due to "
"this, the :mod:`multiprocessing` module allows the programmer to fully "
"leverage multiple processors on a given machine.  It runs on both POSIX "
"and Windows."
msgstr ""
":mod:`multiprocessing` 은 :mod:`threading` 모듈과 유사한 API를 사용하여 프로세스 "
"스포닝(spawning)을 지원하는 패키지입니다. :mod:`multiprocessing` 패키지는 지역과 원격 동시성을 모두 "
"제공하며 스레드 대신 서브 프로세스를 사용하여 :term:`전역 인터프리터 록 <global interpreter lock>` 을 "
"효과적으로 피합니다. 이것 때문에, :mod:`multiprocessing` 모듈은 프로그래머가 주어진 기계에서 다중 프로세서를 "
"최대한 활용할 수 있게 합니다. 유닉스와 윈도우에서 모두 실행됩니다."

#: ../../library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the "
":class:`~multiprocessing.pool.Pool` object which offers a convenient "
"means of parallelizing the execution of a function across multiple input "
"values, distributing the input data across processes (data parallelism)."
"  The following example demonstrates the common practice of defining such"
" functions in a module so that child processes can successfully import "
"that module.  This basic example of data parallelism using "
":class:`~multiprocessing.pool.Pool`, ::"
msgstr ""
":mod:`multiprocessing` 모듈은 :mod:`threading` 모듈에 대응 물이 없는 API도 제공합니다. 이것의 "
"대표적인 예가 :class:`~multiprocessing.pool.Pool` 객체입니다. 이 객체는 여러 입력 값에 걸쳐 함수의 "
"실행을 병렬 처리하고 입력 데이터를 프로세스에 분산시키는 편리한 방법을 제공합니다(데이터 병렬 처리). 다음 예제는 자식 프로세스가"
" 해당 모듈을 성공적으로 임포트 할 수 있도록, 모듈에서 이러한 함수를 정의하는 일반적인 방법을 보여줍니다. 다음은 "
":class:`~multiprocessing.pool.Pool` 를 사용하는 데이터 병렬 처리의 기본 예제입니다::"

#: ../../library/multiprocessing.rst:34
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"
msgstr ""

#: ../../library/multiprocessing.rst:43
msgid "will print to standard output ::"
msgstr "표준 출력으로 다음과 같은 것을 인쇄합니다 ::"

#: ../../library/multiprocessing.rst:45
msgid "[1, 4, 9]"
msgstr ""

#: ../../library/multiprocessing.rst:50
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking "
"execution of the calling process. Compared to using the "
":class:`~multiprocessing.pool.Pool` interface directly, the "
":mod:`concurrent.futures` API more readily allows the submission of work "
"to the underlying process pool to be separated from waiting for the "
"results."
msgstr ""

#: ../../library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr ":class:`Process` 클래스"

#: ../../library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a "
":class:`Process` object and then calling its :meth:`~Process.start` "
"method.  :class:`Process` follows the API of :class:`threading.Thread`.  "
"A trivial example of a multiprocess program is ::"
msgstr ""
":mod:`multiprocessing`\\에서, 프로세스는 :class:`Process` 객체를 생성한 후 "
":meth:`~Process.start` 메서드를 호출해서 스폰합니다. :class:`Process` 는 "
":class:`threading.Thread` 의 API를 따릅니다. 다중 프로세스 프로그램의 간단한 예는 다음과 같습니다 ::"

#: ../../library/multiprocessing.rst:66
msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:76
msgid "To show the individual process IDs involved, here is an expanded example::"
msgstr "이 과정에 참여하는 개별 프로세스의 ID를 보기 위해, 이렇게 예제를 확장합니다::"

#: ../../library/multiprocessing.rst:78
msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:97
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"``if __name__ == '__main__'`` 부분이 필요한 이유에 대한 설명은 :ref:`multiprocessing-"
"programming`\\을 보십시오."

#: ../../library/multiprocessing.rst:105
msgid "Contexts and start methods"
msgstr "컨텍스트 및 시작 방법"

#: ../../library/multiprocessing.rst:107
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"플랫폼에 따라, :mod:`multiprocessing`\\은 프로세스를 시작하는 세 가지 방법을 지원합니다. 이러한 *시작 방법*"
" 은"

#: ../../library/multiprocessing.rst:110
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:111
#, fuzzy
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using "
"*fork* or *forkserver*."
msgstr ""
"부모 프로세스는 깨끗한 새 파이썬 인터프리터 프로세스를 시작합니다. 자식 프로세스는 프로세스 객체의 "
":meth:`~Process.run` 메서드를 실행하는데 필요한 자원만 상속받습니다. 특히, 부모 프로세스의 불필요한 파일 기술자와"
" 핸들은 상속되지 않습니다. 이 방법을 사용하여 프로세스를 시작하는 것은 *fork* 나 *forkserver* 를 사용하는 것에 "
"비해 다소 느립니다."

#: ../../library/multiprocessing.rst:118
#, fuzzy
msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and "
"macOS."
msgstr "유닉스 및 윈도우에서 사용 가능합니다. 윈도우와 macOS의 기본값."

#: ../../library/multiprocessing.rst:120
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:121
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  "
"The child process, when it begins, is effectively identical to the parent"
" process.  All resources of the parent are inherited by the child "
"process.  Note that safely forking a multithreaded process is "
"problematic."
msgstr ""
"부모 프로세스는 :func:`os.fork` 를 사용하여 파이썬 인터프리터를 포크 합니다. 자식 프로세스는, 시작될 때, 부모 "
"프로세스와 실질적으로 같습니다. 부모의 모든 자원이 자식 프로세스에 의해 상속됩니다. 다중 스레드 프로세스를 안전하게 포크 하기 "
"어렵다는 점에 주의하십시오."

#: ../../library/multiprocessing.rst:127
#, fuzzy
msgid "Available on POSIX systems.  Currently the default on POSIX except macOS."
msgstr "유닉스에서만 사용 가능합니다. 유닉스의 기본값."

#: ../../library/multiprocessing.rst:130
msgid ""
"The default start method will change away from *fork* in Python 3.14. "
"Code that requires *fork* should explicitly specify that via "
":func:`get_context` or :func:`set_start_method`."
msgstr ""

#: ../../library/multiprocessing.rst:134
msgid ""
"If Python is able to detect that your process has multiple threads, the "
":func:`os.fork` function that this start method calls internally will "
"raise a :exc:`DeprecationWarning`. Use a different start method. See the "
":func:`os.fork` documentation for further explanation."
msgstr ""

#: ../../library/multiprocessing.rst:140
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:141
#, fuzzy
msgid ""
"When the program starts and selects the *forkserver* start method, a "
"server process is spawned.  From then on, whenever a new process is "
"needed, the parent process connects to the server and requests that it "
"fork a new process.  The fork server process is single threaded unless "
"system libraries or preloaded imports spawn threads as a side-effect so "
"it is generally safe for it to use :func:`os.fork`. No unnecessary "
"resources are inherited."
msgstr ""
"프로그램이 시작되고 *forkserver* 시작 방법을 선택하면, 서버 프로세스가 시작됩니다. 그 이후부터, 새로운 프로세스가 "
"필요할 때마다, 부모 프로세스는 서버에 연결하여 새로운 프로세스를 포크 하도록 요청합니다. 포크 서버 프로세스는 단일 스레드이므로 "
":func:`os.fork` 를 사용하는 것이 안전합니다. 불필요한 자원은 상속되지 않습니다."

#: ../../library/multiprocessing.rst:149
#, fuzzy
msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux."
msgstr "유닉스 파이프를 통해 파일 기술자를 전달할 수 있는 유닉스 플랫폼에서 사용할 수 있습니다."

#: ../../library/multiprocessing.rst:153
#, fuzzy
msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some "
"POSIX platforms. Child processes no longer inherit all of the parents "
"inheritable handles on Windows."
msgstr ""
"모든 유닉스 플랫폼에 *spawn* 이 추가되었고, 일부 유닉스 플랫폼에는 *forkserver* 가 추가되었습니다. 윈도우에서 "
"자식 프로세스는 상속 가능한 모든 부모 핸들을 더는 상속하지 않습니다."

#: ../../library/multiprocessing.rst:161
#, fuzzy
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See "
":issue:`33725`."
msgstr ""
"macOS에서, *spawn* 시작 방법이 이제 기본값입니다. *fork* 시작 방법은 서브 프로세스의 충돌로 이어질 수 있기 "
"때문에, 안전하지 않은 것으로 간주해야 합니다. :issue:`33725`\\를 참조하십시오."

#: ../../library/multiprocessing.rst:165
#, fuzzy
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start "
"a *resource tracker* process which tracks the unlinked named system "
"resources (such as named semaphores or "
":class:`~multiprocessing.shared_memory.SharedMemory` objects) created by "
"processes of the program.  When all processes have exited the resource "
"tracker unlinks any remaining tracked object. Usually there should be "
"none, but if a process was killed by a signal there may be some "
"\"leaked\" resources.  (Neither leaked semaphores nor shared memory "
"segments will be automatically unlinked until the next reboot. This is "
"problematic for both objects because the system allows only a limited "
"number of named semaphores, and shared memory segments occupy some space "
"in the main memory.)"
msgstr ""
"유닉스에서 *spawn* 또는 *forkserver* 시작 방법을 사용하면 *자원 추적기* 프로세스 역시 시작되는데, 프로그램의 "
"프로세스들이 만든 삭제되지 않은 이름있는 시스템 자원(가령 이름있는 세마포어나 "
":class:`~multiprocessing.shared_memory.SharedMemory` 객체)을 추적합니다. 모든 프로세스가"
" 종료된 후 자원 추적기는 남아있는 추적되는 객체들을 제거합니다. 일반적으로 아무것도 남아 있지 않아야 하지만, 프로세스가 시그널에"
" 의해 죽으면 \"누수된\" 자원이 있을 수 있습니다. (누수된 세마포어나 공유 메모리 세그먼트는 다음 재부팅 때까지 자동으로 "
"제거되지 않습니다. 두 객체 모두에게 이것은 문제가 되는데, 시스템이 제한된 수의 이름있는 세마포어만 허용하고, 공유 메모리 "
"세그먼트는 주 메모리에 일정 공간을 차지하기 때문입니다.)"

#: ../../library/multiprocessing.rst:178
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if"
" __name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"시작 방법을 선택하려면 메인 모듈의 ``if __name__ == '__main__'`` 절에서 "
":func:`set_start_method`\\를 사용하십시오. 예를 들면::"

#: ../../library/multiprocessing.rst:182
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:195
msgid ":func:`set_start_method` should not be used more than once in the program."
msgstr ":func:`set_start_method` 는 프로그램에서 한 번만 사용되어야 합니다."

#: ../../library/multiprocessing.rst:198
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context "
"object.  Context objects have the same API as the multiprocessing module,"
" and allow one to use multiple start methods in the same program. ::"
msgstr ""
"또는, :func:`get_context`\\를 사용하여 컨텍스트 객체를 얻을 수 있습니다. 컨텍스트 객체는 "
"multiprocessing 모듈과 같은 API를 제공하므로 한 프로그램에서 여러 시작 방법을 사용할 수 있습니다. ::"

#: ../../library/multiprocessing.rst:203
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:216
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using "
"the *fork* context cannot be passed to processes started using the "
"*spawn* or *forkserver* start methods."
msgstr ""
"한 컨텍스트와 관련된 객체는 다른 컨텍스트의 프로세스와 호환되지 않을 수 있음에 주의하십시오. 특히 *fork* 컨텍스트를 사용하여"
" 생성된 록은 *spawn* 또는 *forkserver* 시작 방법을 사용하여 시작된 프로세스로 전달될 수 없습니다."

#: ../../library/multiprocessing.rst:221
msgid ""
"A library which wants to use a particular start method should probably "
"use :func:`get_context` to avoid interfering with the choice of the "
"library user."
msgstr ""
"특정 시작 방법을 사용하고자 하는 라이브러리는 아마도 :func:`get_context`\\를 사용하여 라이브러리 사용자의 선택을 "
"방해하지 않아야 합니다."

#: ../../library/multiprocessing.rst:227
#, fuzzy
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be "
"used with \"frozen\" executables (i.e., binaries produced by packages "
"like **PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` "
"start method may work if code does not use threads."
msgstr ""
"``'spawn'`` 과 ``'forkserver'`` 시작 방법은 현재 유닉스에서 \"고정된(frozen)\" 실행 파일(즉, "
"**PyInstaller**\\와 **cx_Freeze**\\와 같은 패키지로 만든 바이너리)과 함께 사용할 수 없습니다. "
"``'fork'`` 시작 방법은 작동합니다."

#: ../../library/multiprocessing.rst:234
msgid "Exchanging objects between processes"
msgstr "프로세스 간 객체 교환"

#: ../../library/multiprocessing.rst:236
msgid ""
":mod:`multiprocessing` supports two types of communication channel "
"between processes:"
msgstr ":mod:`multiprocessing` 은 두 가지 유형의 프로세스 간 통신 채널을 지원합니다:"

#: ../../library/multiprocessing.rst:239
msgid "**Queues**"
msgstr "**큐**"

#: ../../library/multiprocessing.rst:241
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ":class:`Queue` 클래스는 :class:`queue.Queue` 의 클론에 가깝습니다. 예를 들면::"

#: ../../library/multiprocessing.rst:244
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:256
msgid ""
"Queues are thread and process safe. Any object put into a "
":mod:`~multiprocessing` queue will be serialized."
msgstr ""

#: ../../library/multiprocessing.rst:259
msgid "**Pipes**"
msgstr "**파이프**"

#: ../../library/multiprocessing.rst:261
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected "
"by a pipe which by default is duplex (two-way).  For example::"
msgstr ":func:`Pipe` 함수는 파이프로 연결된 한 쌍의 연결 객체를 돌려주는데 기본적으로 양방향(duplex)입니다. 예를 들면::"

#: ../../library/multiprocessing.rst:264
msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""

#: ../../library/multiprocessing.rst:277
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two "
"ends of the pipe.  Each connection object has :meth:`~Connection.send` "
"and :meth:`~Connection.recv` methods (among others).  Note that data in a"
" pipe may become corrupted if two processes (or threads) try to read from"
" or write to the *same* end of the pipe at the same time.  Of course "
"there is no risk of corruption from processes using different ends of the"
" pipe at the same time."
msgstr ""
":func:`Pipe` 가 반환하는 두 개의 연결 객체는 파이프의 두 끝을 나타냅니다. 각 연결 객체에는 (다른 것도 있지만) "
":meth:`~Connection.send` 및 :meth:`~Connection.recv` 메서드가 있습니다. 두 프로세스 (또는"
" 스레드)가 파이프의 *같은* 끝에서 동시에 읽거나 쓰려고 하면 파이프의 데이터가 손상될 수 있습니다. 물론 파이프의 다른 끝을 "
"동시에 사용하는 프로세스로 인해 손상될 위험은 없습니다."

#: ../../library/multiprocessing.rst:285
msgid ""
"The :meth:`~Connection.send` method serializes the object and "
":meth:`~Connection.recv` re-creates the object."
msgstr ""

#: ../../library/multiprocessing.rst:289
msgid "Synchronization between processes"
msgstr "프로세스 간 동기화"

#: ../../library/multiprocessing.rst:291
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to "
"ensure that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` 은 :mod:`threading` 에 있는 모든 동기화 프리미티브의 등가물을 포함합니다. "
"예를 들어 한 번에 하나의 프로세스만 표준 출력으로 인쇄하도록 록을 사용할 수 있습니다::"

#: ../../library/multiprocessing.rst:295
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""

#: ../../library/multiprocessing.rst:310
msgid ""
"Without using the lock output from the different processes is liable to "
"get all mixed up."
msgstr "록을 사용하지 않으면 다른 프로세스의 출력들이 모두 섞일 수 있습니다."

#: ../../library/multiprocessing.rst:315
msgid "Sharing state between processes"
msgstr "프로세스 간 상태 공유"

#: ../../library/multiprocessing.rst:317
msgid ""
"As mentioned above, when doing concurrent programming it is usually best "
"to avoid using shared state as far as possible.  This is particularly "
"true when using multiple processes."
msgstr ""
"위에서 언급했듯이, 동시성 프로그래밍을 할 때 보통 가능한 한 공유된 상태를 사용하지 않는 것이 최선입니다. 여러 프로세스를 사용할"
" 때 특히 그렇습니다."

#: ../../library/multiprocessing.rst:321
msgid ""
"However, if you really do need to use some shared data then "
":mod:`multiprocessing` provides a couple of ways of doing so."
msgstr "그러나, 정말로 공유 데이터를 사용해야 한다면 :mod:`multiprocessing` 이 몇 가지 방법을 제공합니다."

#: ../../library/multiprocessing.rst:324
msgid "**Shared memory**"
msgstr "**공유 메모리**"

#: ../../library/multiprocessing.rst:326
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or "
":class:`Array`.  For example, the following code ::"
msgstr ""
"데이터는 :class:`Value` 또는 :class:`Array`\\를 사용하여 공유 메모리 맵에 저장 될 수 있습니다. 예를 "
"들어, 다음 코드는 ::"

#: ../../library/multiprocessing.rst:329
msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"
msgstr ""

#: ../../library/multiprocessing.rst:347 ../../library/multiprocessing.rst:393
msgid "will print ::"
msgstr "를 인쇄할 것입니다 ::"

#: ../../library/multiprocessing.rst:349
msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""

#: ../../library/multiprocessing.rst:352
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` "
"are typecodes of the kind used by the :mod:`array` module: ``'d'`` "
"indicates a double precision float and ``'i'`` indicates a signed "
"integer.  These shared objects will be process and thread-safe."
msgstr ""
"``num`` 과 ``arr`` 을 만들 때 사용되는 ``'d'`` 와 ``'i'`` 인자는 :mod:`array` 모듈에서 "
"사용되는 종류의 타입 코드입니다: ``'d'`` 는 배정밀도 부동 소수점을 나타내고, ``'i'`` 는 부호 있는 정수를 "
"나타냅니다. 이러한 공유 객체는 프로세스 및 스레드에 안전합니다."

#: ../../library/multiprocessing.rst:357
msgid ""
"For more flexibility in using shared memory one can use the "
":mod:`multiprocessing.sharedctypes` module which supports the creation of"
" arbitrary ctypes objects allocated from shared memory."
msgstr ""
"공유 메모리를 더 유연하게 사용하려면, 공유 메모리에 할당된 임의의 ctypes 객체 생성을 지원하는 "
":mod:`multiprocessing.sharedctypes` 모듈을 사용할 수 있습니다."

#: ../../library/multiprocessing.rst:361
msgid "**Server process**"
msgstr "**서버 프로세스**"

#: ../../library/multiprocessing.rst:363
msgid ""
"A manager object returned by :func:`Manager` controls a server process "
"which holds Python objects and allows other processes to manipulate them "
"using proxies."
msgstr ""
":func:`Manager` 가 반환한 관리자 객체는 파이썬 객체를 유지하고 다른 프로세스가 프락시를 사용하여 이 객체를 조작할 수"
" 있게 하는 서버 프로세스를 제어합니다."

#: ../../library/multiprocessing.rst:367
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, "
":class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, "
":class:`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, "
":class:`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, "
":class:`Value` and :class:`Array`.  For example, ::"
msgstr ""
":func:`Manager` 가 반환한 관리자는 :class:`list`, :class:`dict`, "
":class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` 그리고 "
":class:`Array` 형을 지원합니다. 예를 들어, 다음 코드는 ::"

#: ../../library/multiprocessing.rst:373
msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"\n"
"        p = Process(target=f, args=(d, l))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)"
msgstr ""

#: ../../library/multiprocessing.rst:395
#, python-brace-format
msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
msgstr ""

#: ../../library/multiprocessing.rst:398
msgid ""
"Server process managers are more flexible than using shared memory "
"objects because they can be made to support arbitrary object types.  "
"Also, a single manager can be shared by processes on different computers "
"over a network. They are, however, slower than using shared memory."
msgstr ""
"서버 프로세스 관리자는 임의의 객체 형을 지원하도록 만들 수 있으므로 공유 메모리 객체를 사용하는 것보다 융통성이 있습니다. 또한,"
" 단일 관리자를 네트워크를 통해 서로 다른 컴퓨터의 프로세스에서 공유 할 수 있습니다. 그러나 공유 메모리를 사용할 때보다 "
"느립니다."

#: ../../library/multiprocessing.rst:405
msgid "Using a pool of workers"
msgstr "작업자 풀 사용"

#: ../../library/multiprocessing.rst:407
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker"
" processes.  It has methods which allows tasks to be offloaded to the "
"worker processes in a few different ways."
msgstr ""
":class:`~multiprocessing.pool.Pool` 클래스는 작업자 프로세스 풀을 나타냅니다. 여기에는 몇 가지 다른 "
"방법으로 작업을 작업자 프로세스로 넘길 수 있는 메서드가 있습니다."

#: ../../library/multiprocessing.rst:411
msgid "For example::"
msgstr "예를 들면::"

#: ../../library/multiprocessing.rst:413
msgid ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one "
"process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one "
"process\n"
"        print(res.get(timeout=1))             # prints the PID of that "
"process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more "
"processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a "
"multiprocessing.TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more "
"work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"
msgstr ""

#: ../../library/multiprocessing.rst:455
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "풀의 메서드는 풀을 만든 프로세스에서만 사용되어야 함에 유의하세요."

#: ../../library/multiprocessing.rst:460
msgid ""
"Functionality within this package requires that the ``__main__`` module "
"be importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will "
"not work in the interactive interpreter. For example::"
msgstr ""
"이 패키지 내의 기능을 사용하려면 ``__main__`` 모듈을 자식이 임포트 할 수 있어야 합니다. 이것은 :ref"
":`multiprocessing-programming`\\에서 다루지만, 여기에서 지적할 가치가 있습니다. 이것은 몇몇 예제, 가령"
" :class:`multiprocessing.pool.Pool` 예제가 대화형 인터프리터에서 동작하지 않음을 의미합니다. 예를 "
"들면::"

#: ../../library/multiprocessing.rst:466
msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>"
msgstr ""

#: ../../library/multiprocessing.rst:483
msgid ""
"(If you try this it will actually output three full tracebacks "
"interleaved in a semi-random fashion, and then you may have to stop the "
"parent process somehow.)"
msgstr ""
"(이것을 시도해 보면 실제로 세 개의 전체 트레이스백이 어느 정도 임의로 번갈아 출력됩니다. 그런 다음 부모 프로세스를 중지시켜야 "
"할 수도 있습니다.)"

#: ../../library/multiprocessing.rst:489
msgid "Reference"
msgstr "레퍼런스"

#: ../../library/multiprocessing.rst:491
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the "
":mod:`threading` module."
msgstr ":mod:`multiprocessing` 패키지는 대부분 :mod:`threading` 모듈의 API를 복제합니다."

#: ../../library/multiprocessing.rst:496
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process`\\와 예외"

#: ../../library/multiprocessing.rst:501
msgid ""
"Process objects represent activity that is run in a separate process. The"
" :class:`Process` class has equivalents of all the methods of "
":class:`threading.Thread`."
msgstr ""
"프로세스 객체는 별도의 프로세스에서 실행되는 작업을 나타냅니다. :class:`Process` 클래스는 "
":class:`threading.Thread` 의 모든 메서드와 같은 메서드를 갖습니다."

#: ../../library/multiprocessing.rst:505
#, fuzzy
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with "
":class:`threading.Thread`.  *target* is the callable object to be invoked"
" by the :meth:`run` method.  It defaults to ``None``, meaning nothing is "
"called. *name* is the process name (see :attr:`name` for more details). "
"*args* is the argument tuple for the target invocation.  *kwargs* is a "
"dictionary of keyword arguments for the target invocation.  If provided, "
"the keyword-only *daemon* argument sets the process :attr:`daemon` flag "
"to ``True`` or ``False``.  If ``None`` (the default), this flag will be "
"inherited from the creating process."
msgstr ""
"생성자는 항상 키워드 인자로 호출해야 합니다. *group* 은 항상 ``None`` 이어야 합니다; 이것은 "
":class:`threading.Thread` 와의 호환성을 위해서만 존재합니다. *target* 은 :meth:`run()` "
"메서드에 의해 호출될 콜러블 객체입니다. 기본값은 ``None`` 인데, 아무것도 호출되지 않음을 의미합니다. *name* 은 "
"프로세스 이름입니다 (자세한 내용은 :attr:`name` 참조). *args* 는 target 호출을 위한 인자 튜플입니다. "
"*kwargs* 는 target 호출을 위한 키워드 인자 딕셔너리입니다. 제공되는 경우, 키워드 전용 *daemon* 인자는 "
"프로세스 :attr:`daemon` 플래그를 ``True`` 또는 ``False`` 로 설정합니다. ``None`` (기본값) "
"이면, 이 플래그는 만드는 프로세스로부터 상속됩니다."

#: ../../library/multiprocessing.rst:516
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, "
"which defaults to ``()``, can be used to specify a list or tuple of the "
"arguments to pass to *target*."
msgstr ""

#: ../../library/multiprocessing.rst:520
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the"
" base class constructor (:meth:`Process.__init__`) before doing anything "
"else to the process."
msgstr ""
"서브 클래스가 생성자를 재정의하면, 프로세스에 다른 작업을 하기 전에 베이스 클래스 "
"생성자(:meth:`Process.__init__`)를 호출해야 합니다."

#: ../../library/multiprocessing.rst:524
#, fuzzy
msgid "Added the *daemon* parameter."
msgstr "*daemon* 인자가 추가되었습니다."

#: ../../library/multiprocessing.rst:529
msgid "Method representing the process's activity."
msgstr "프로세스의 활동을 나타내는 메서드."

#: ../../library/multiprocessing.rst:531
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` "
"method invokes the callable object passed to the object's constructor as "
"the target argument, if any, with sequential and keyword arguments taken "
"from the *args* and *kwargs* arguments, respectively."
msgstr ""
"서브 클래스에서 이 메서드를 재정의할 수 있습니다. 표준 :meth:`run` 메서드는 객체의 생성자에 target 인자로 전달된 "
"콜러블 객체를 호출하는데 (있다면) *args* 와 *kwargs* 인자를 각각 위치 인자와 키워드 인자로 사용합니다."

#: ../../library/multiprocessing.rst:536
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""

#: ../../library/multiprocessing.rst:539
#, fuzzy
msgid "Example::"
msgstr "예제"

#: ../../library/multiprocessing.rst:541
msgid ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"
msgstr ""

#: ../../library/multiprocessing.rst:551
msgid "Start the process's activity."
msgstr "프로세스의 활동을 시작합니다."

#: ../../library/multiprocessing.rst:553
msgid ""
"This must be called at most once per process object.  It arranges for the"
" object's :meth:`run` method to be invoked in a separate process."
msgstr "이것은 프로세스 객체 당 최대 한 번 호출되어야 합니다. 객체의 :meth:`run` 메서드가 별도의 프로세스에서 호출되도록 합니다."

#: ../../library/multiprocessing.rst:558
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. "
"If *timeout* is a positive number, it blocks at most *timeout* seconds. "
"Note that the method returns ``None`` if its process terminates or if the"
" method times out.  Check the process's :attr:`exitcode` to determine if "
"it terminated."
msgstr ""
"선택적 인자 *timeout* 이 ``None`` (기본값) 인 경우, 메서드는 :meth:`join` 메서드가 호출된 프로세스가 "
"종료될 때까지 블록 됩니다. *timeout* 이 양수면 최대 *timeout* 초 동안 블록 됩니다. 이 메서드는 프로세스가 "
"종료되거나 메서드가 시간 초과 되면 ``None`` 을 돌려줌에 주의해야 합니다. 프로세스의 :attr:`exitcode` 를 "
"검사하여 종료되었는지 확인하십시오."

#: ../../library/multiprocessing.rst:565
msgid "A process can be joined many times."
msgstr "프로세스는 여러 번 조인할 수 있습니다."

#: ../../library/multiprocessing.rst:567
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is "
"an error to attempt to join a process before it has been started."
msgstr ""
"교착 상태를 유발할 수 있으므로 프로세스는 자신을 조인할 수 없습니다. 프로세스가 시작되기 전에 프로세스에 조인하려고 하면 에러가 "
"발생합니다."

#: ../../library/multiprocessing.rst:572
msgid ""
"The process's name.  The name is a string used for identification "
"purposes only.  It has no semantics.  Multiple processes may be given the"
" same name."
msgstr ""
"프로세스의 이름. 이름은 식별 목적으로만 사용되는 문자열입니다. 다른 의미는 없습니다. 여러 프로세스에 같은 이름이 주어질 수 "
"있습니다."

#: ../../library/multiprocessing.rst:576
msgid ""
"The initial name is set by the constructor.  If no explicit name is "
"provided to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\"
" :sub:`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is "
"the N-th child of its parent."
msgstr ""
"초기 이름은 생성자에 의해 설정됩니다. 명시적 이름이 생성자에 제공되지 않으면, 'Process-N\\ :sub:`1`:N\\ "
":sub:`2`:...:N\\ :sub:`k`' 형식의 이름이 만들어지는데, 각각의 N\\ :sub:`k` 는 부모의 N 번째 "
"자식입니다."

#: ../../library/multiprocessing.rst:583
msgid "Return whether the process is alive."
msgstr "프로세스가 살아있는지 아닌지를 반환합니다."

#: ../../library/multiprocessing.rst:585
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` "
"method returns until the child process terminates."
msgstr "대략, 프로세스 객체는 :meth:`start` 메서드가 반환하는 순간부터 자식 프로세스가 종료될 때까지 살아있습니다."

#: ../../library/multiprocessing.rst:590
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before "
":meth:`start` is called."
msgstr "프로세스의 데몬 플래그, 논리값. :meth:`start` 가 호출되기 전에 설정되어야 합니다."

#: ../../library/multiprocessing.rst:593
msgid "The initial value is inherited from the creating process."
msgstr "초깃값은 생성 프로세스에서 상속됩니다."

#: ../../library/multiprocessing.rst:595
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "프로세스가 종료할 때, 모든 데몬 자식 프로세스를 강제 종료시키려고(terminate) 시도합니다."

#: ../../library/multiprocessing.rst:598
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets"
" terminated when its parent process exits. Additionally, these are "
"**not** Unix daemons or services, they are normal processes that will be "
"terminated (and not joined) if non-daemonic processes have exited."
msgstr ""
"데몬 프로세스는 하위 프로세스를 만들 수 없음에 유의하십시오. 그렇지 않으면 부모 프로세스가 종료될 때 데몬 프로세스가 강제 "
"종료되어, 데몬 프로세스가 자식 프로세스를 고아로 남기게 됩니다. 또한, 이들은 유닉스 데몬이나 서비스가 **아닙니다**, 데몬이 "
"아닌 프로세스들이 종료되면 강제 종료되는 (그리고 조인되지 않는) 일반 프로세스입니다."

#: ../../library/multiprocessing.rst:604
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` "
"objects also support the following attributes and methods:"
msgstr ""
":class:`threading.Thread` API 외에도 :class:`Process` 객체는 다음 어트리뷰트와 메서드도 "
"지원합니다 :"

#: ../../library/multiprocessing.rst:609
msgid ""
"Return the process ID.  Before the process is spawned, this will be "
"``None``."
msgstr "프로세스 ID를 돌려줍니다. 프로세스가 스폰 되기 전에는 ``None`` 입니다."

#: ../../library/multiprocessing.rst:614
#, fuzzy
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"자식의 종료 코드. 프로세스가 아직 종료되지 않았으면 ``None`` 이 됩니다. 음수 값 *-N* 은 자식이 시그널 *N* 에 "
"의해 강제 종료되었음을 나타냅니다."

#: ../../library/multiprocessing.rst:617
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will "
"be 0.  If it terminated via :func:`sys.exit` with an integer argument "
"*N*, the exit code will be *N*."
msgstr ""

#: ../../library/multiprocessing.rst:621
msgid ""
"If the child terminated due to an exception not caught within "
":meth:`run`, the exit code will be 1.  If it was terminated by signal "
"*N*, the exit code will be the negative value *-N*."
msgstr ""

#: ../../library/multiprocessing.rst:627
msgid "The process's authentication key (a byte string)."
msgstr "프로세스의 인증 키 (바이트열) 입니다."

#: ../../library/multiprocessing.rst:629
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a"
" random string using :func:`os.urandom`."
msgstr ""
":mod:`multiprocessing` 이 초기화될 때, 메인 프로세스는 :func:`os.urandom` 을 사용하여 임의의 "
"문자열을 할당받습니다."

#: ../../library/multiprocessing.rst:632
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by"
" setting :attr:`authkey` to another byte string."
msgstr ""
":class:`Process` 객체가 생성될 때, 부모 프로세스의 인증 키를 상속받습니다. :attr:`authkey` 를 다른 "
"바이트열로 설정하여 변경할 수 있습니다."

#: ../../library/multiprocessing.rst:636
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr ":ref:`multiprocessing-auth-keys`\\를 참조하세요."

#: ../../library/multiprocessing.rst:640
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr "프로세스가 끝나면 \"준비(ready)\" 될 시스템 객체의 숫자 핸들."

#: ../../library/multiprocessing.rst:643
#, fuzzy
msgid ""
"You can use this value if you want to wait on several events at once "
"using :func:`multiprocessing.connection.wait`.  Otherwise calling "
":meth:`join` is simpler."
msgstr ""
":func:`multiprocessing.connection.wait` 를 사용해서 한 번에 여러 이벤트를 기다리고 싶다면, 이 "
"값을 사용할 수 있습니다. 그렇지 않으면 :meth:`join()`\\을 호출하는 것이 더 간단합니다."

#: ../../library/multiprocessing.rst:647
#, fuzzy
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` "
"and ``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a "
"file descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"윈도우에서, 이것은 ``WaitForSingleObject`` 및 ``WaitForMultipleObjects`` 계열의 API "
"호출에서 사용할 수 있는 OS 핸들입니다. 유닉스에서, 이것은 :mod:`select` 모듈의 프리미티브들에서 사용할 수 있는 파일"
" 기술자입니다."

#: ../../library/multiprocessing.rst:655
#, fuzzy
msgid ""
"Terminate the process.  On POSIX this is done using the "
":py:const:`~signal.SIGTERM` signal; on Windows "
":c:func:`!TerminateProcess` is used.  Note that exit handlers and finally"
" clauses, etc., will not be executed."
msgstr ""
"프로세스를 강제 종료합니다. 유닉스에서는 ``SIGTERM`` 시그널을 사용합니다; 윈도우에서는 "
":c:func:`TerminateProcess` 가 사용됩니다. 종료 처리기(exit handler)와 finally 절 등이 "
"실행되지 않음에 주의하십시오."

#: ../../library/multiprocessing.rst:659
msgid ""
"Note that descendant processes of the process will *not* be terminated --"
" they will simply become orphaned."
msgstr "프로세스의 자손 프로세스들은 강제 종료되지 *않을* 것입니다 -- 단순히 고아가 될 것입니다."

#: ../../library/multiprocessing.rst:664
msgid ""
"If this method is used when the associated process is using a pipe or "
"queue then the pipe or queue is liable to become corrupted and may become"
" unusable by other process.  Similarly, if the process has acquired a "
"lock or semaphore etc. then terminating it is liable to cause other "
"processes to deadlock."
msgstr ""
"연결된 프로세스가 파이프 또는 큐를 사용할 때 이 메서드를 사용하면, 파이프 또는 큐가 손상되어 다른 프로세스에서 사용할 수 없게 "
"될 수 있습니다. 마찬가지로, 프로세스가 록이나 세마포어 등을 획득한 경우 강제 종료하면 다른 프로세스가 교착 상태가 될 수 "
"있습니다."

#: ../../library/multiprocessing.rst:672
#, fuzzy
msgid "Same as :meth:`terminate` but using the ``SIGKILL`` signal on POSIX."
msgstr ":meth:`terminate()`\\와 같지만, 유닉스에서 ``SIGKILL`` 시그널을 사용합니다."

#: ../../library/multiprocessing.rst:678
msgid ""
"Close the :class:`Process` object, releasing all resources associated "
"with it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and"
" attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
":class:`Process` 객체를 닫아, 그것과 관련된 모든 자원을 해제합니다. 하부 프로세스가 여전히 실행 중이면 "
":exc:`ValueError` 가 발생합니다. 일단 :meth:`close` 가 성공적으로 반환되면, "
":class:`Process` 객체의 다른 대부분의 메서드와 어트리뷰트는 :exc:`ValueError` 를 발생시킵니다."

#: ../../library/multiprocessing.rst:686
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` and :attr:`exitcode` methods should only be called by "
"the process that created the process object."
msgstr ""
":meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:`terminate` 및 "
":attr:`exitcode` 메서드는 프로세스 객체를 생성한 프로세스에 의해서만 호출되어야 합니다."

#: ../../library/multiprocessing.rst:690
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr ":class:`Process` 의 몇몇 메서드를 사용하는 예제:"

#: ../../library/multiprocessing.rst:692
msgid ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""

#: ../../library/multiprocessing.rst:711
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "모든 :mod:`multiprocessing` 예외의 베이스 클래스입니다."

#: ../../library/multiprocessing.rst:715
#, fuzzy
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into` when the supplied "
"buffer object is too small for the message read."
msgstr ""
":meth:`Connection.recv_bytes_into()` 가, 제공된 버퍼 객체가 읽은 메시지에 비해 너무 작을 때 "
"일으키는 예외."

#: ../../library/multiprocessing.rst:718
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr "``e`` 가 :exc:`BufferTooShort` 의 인스턴스라면, ``e.args[0]`` 는 메시지를 바이트열로 줍니다."

#: ../../library/multiprocessing.rst:723
msgid "Raised when there is an authentication error."
msgstr "인증 에러가 일어날 때 발생합니다."

#: ../../library/multiprocessing.rst:727
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "시간제한이 초과하였을 때 시간제한을 건 메서드에 의해 발생합니다."

#: ../../library/multiprocessing.rst:730
msgid "Pipes and Queues"
msgstr "파이프와 큐"

#: ../../library/multiprocessing.rst:732
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any "
"synchronization primitives like locks."
msgstr "여러 프로세스를 사용할 때, 일반적으로 프로세스 간 통신을 위해 메시지 전달을 사용하고 록과 같은 동기화 프리미티브 사용을 피합니다."

#: ../../library/multiprocessing.rst:736
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between "
"two processes) or a queue (which allows multiple producers and "
"consumers)."
msgstr ""
"메시지를 전달하기 위해 :func:`Pipe` (두 프로세스 간의 연결) 또는 큐(여러 생산자와 소비자를 허용합니다)를 사용할 수 "
"있습니다."

#: ../../library/multiprocessing.rst:739
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types"
" are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` "
"queues modelled on the :class:`queue.Queue` class in the standard "
"library.  They differ in that :class:`Queue` lacks the "
":meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join` methods "
"introduced into Python 2.5's :class:`queue.Queue` class."
msgstr ""
":class:`Queue`, :class:`SimpleQueue` 그리고 :class:`JoinableQueue` 형은, 표준 "
"라이브러리의 :class:`queue.Queue` 클래스에 따라 모델링 된, 다중 생산자, 다중 소비자 :abbr:`FIFO "
"(first-in, first-out)` 큐입니다. 이것들은 파이썬 2.5의 :class:`queue.Queue` 클래스에서 도입된"
" :meth:`~queue.Queue.task_done`\\과 :meth:`~queue.Queue.join` 메서드가 "
":class:`Queue` 에 없다는 점에서 다릅니다."

#: ../../library/multiprocessing.rst:746
msgid ""
"If you use :class:`JoinableQueue` then you **must** call "
":meth:`JoinableQueue.task_done` for each task removed from the queue or "
"else the semaphore used to count the number of unfinished tasks may "
"eventually overflow, raising an exception."
msgstr ""
":class:`JoinableQueue`\\를 사용하면, 큐에서 제거된 작업마다 "
":meth:`JoinableQueue.task_done`\\을 호출해야 합니다. 그렇지 않으면 완료되지 않은 작업의 수를 세는 데 "
"사용되는 세마포어가 결국 오버플로 되어 예외를 일으킵니다."

#: ../../library/multiprocessing.rst:751
msgid ""
"One difference from other Python queue implementations, is that "
":mod:`multiprocessing` queues serializes all objects that are put into "
"them using :mod:`pickle`. The object return by the get method is a re-"
"created object that does not share memory with the original object."
msgstr ""

#: ../../library/multiprocessing.rst:756
msgid ""
"Note that one can also create a shared queue by using a manager object --"
" see :ref:`multiprocessing-managers`."
msgstr "관리자 객체를 사용하여 공유 큐를 생성할 수도 있습니다 -- :ref:`multiprocessing-managers`\\를 보세요."

#: ../../library/multiprocessing.rst:761
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and "
":exc:`queue.Full` exceptions to signal a timeout.  They are not available"
" in the :mod:`multiprocessing` namespace so you need to import them from "
":mod:`queue`."
msgstr ""
":mod:`multiprocessing` 은 제한 시간 초과 신호를 보내기 위해 보통 :exc:`queue.Empty` 와 "
":exc:`queue.Full` 예외를 사용합니다. :mod:`multiprocessing` 이름 공간에는 없으므로 "
":mod:`queue`\\에서 임포트 해야 합니다."

#: ../../library/multiprocessing.rst:768
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has "
"some consequences which are a little surprising, but should not cause any"
" practical difficulties -- if they really bother you then you can instead"
" use a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"객체를 큐에 넣으면, 객체는 피클 되고 배경 스레드가 나중에 피클 된 데이터를 하부 파이프로 플러시 합니다. 이것은 다소 의외의 "
"결과로 이어지지만, 실제적인 어려움을 일으키지는 않아야 합니다 -- 이것이 여러분을 정말로 신경 쓰이게 한다면, 대신 "
":ref:`관리자 <multiprocessing-managers>` 로 만든 큐를 사용할 수 있습니다."

#: ../../library/multiprocessing.rst:775
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns "
":const:`False` and :meth:`~Queue.get_nowait` can return without raising "
":exc:`queue.Empty`."
msgstr ""
"빈 큐에 객체를 넣은 후에, :meth:`~Queue.empty` 메서드가 :const:`False`\\를 반환하고 "
":meth:`~Queue.get_nowait`\\가 :exc:`queue.Empty` 를 일으키지 않고 반환할 수 있기 전까지 극히"
" 작은 지연이 있을 수 있습니다."

#: ../../library/multiprocessing.rst:780
msgid ""
"If multiple processes are enqueuing objects, it is possible for the "
"objects to be received at the other end out-of-order. However, objects "
"enqueued by the same process will always be in the expected order with "
"respect to each other."
msgstr ""
"여러 프로세스가 객체를 큐에 넣는 경우, 반대편에서 객체가 다른 순서로 수신될 수 있습니다. 그러나, 같은 프로세스에 의해 큐에 "
"들어간 객체들은 항상 상대적인 순서가 유지됩니다."

#: ../../library/multiprocessing.rst:787
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill`"
" while it is trying to use a :class:`Queue`, then the data in the queue "
"is likely to become corrupted.  This may cause any other process to get "
"an exception when it tries to use the queue later on."
msgstr ""
":class:`Queue`\\를 사용하려고 하는 동안 :meth:`Process.terminate` 또는 "
":func:`os.kill` 을 사용하여 프로세스를 죽이면, 큐의 데이터가 손상될 수 있습니다. 이로 인해 나중에 다른 프로세스가 "
"큐를 사용하려고 할 때 예외가 발생할 수 있습니다."

#: ../../library/multiprocessing.rst:794
msgid ""
"As mentioned above, if a child process has put items on a queue (and it "
"has not used :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), then that process will not "
"terminate until all buffered items have been flushed to the pipe."
msgstr ""
"위에서 언급했듯이, 자식 프로세스가 항목을 큐에 넣었을 때 (그리고 "
":meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` 를 사용하지 않았다면), 버퍼링 된 모든 항목이 "
"파이프로 플러시 될 때까지 해당 프로세스가 종료되지 않습니다."

#: ../../library/multiprocessing.rst:799
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-"
"daemonic children."
msgstr ""
"이것은, 여러분이 그 자식 프로세스를 조인하려고 하면, 큐에 넣은 모든 항목을 소진하지 않는 한 교착 상태가 발생할 수 있다는 "
"뜻입니다. 마찬가지로, 그 자식 프로세스가 데몬이 아니면 부모 프로세스가 종료 시점에 데몬이 아닌 모든 자식을 조인하려고 할 때 "
"정지될 수 있습니다."

#: ../../library/multiprocessing.rst:804
msgid ""
"Note that a queue created using a manager does not have this issue.  See "
":ref:`multiprocessing-programming`."
msgstr "관리자를 사용하여 생성된 큐에는 이 문제가 없습니다. :ref:`multiprocessing-programming`\\을 참조하세요."

#: ../../library/multiprocessing.rst:807
msgid ""
"For an example of the usage of queues for interprocess communication see "
":ref:`multiprocessing-examples`."
msgstr "프로세스 간 통신을 위해 큐를 사용하는 예는 :ref:`multiprocessing-examples`\\을 참조하십시오."

#: ../../library/multiprocessing.rst:813
msgid ""
"Returns a pair ``(conn1, conn2)`` of "
":class:`~multiprocessing.connection.Connection` objects representing the "
"ends of a pipe."
msgstr ""
"파이프의 끝을 나타내는 :class:`~multiprocessing.connection.Connection` 객체 쌍 "
"``(conn1, conn2)`` 를 반환합니다."

#: ../../library/multiprocessing.rst:817
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If"
" *duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can "
"only be used for receiving messages and ``conn2`` can only be used for "
"sending messages."
msgstr ""
"*duplex* 가 ``True`` (기본값) 면 파이프는 양방향입니다. *duplex* 가 ``False`` 인 경우 파이프는 "
"단방향입니다: ``conn1`` 은 메시지를 받는 데에만 사용할 수 있고, ``conn2`` 는 메시지를 보낼 때만 사용할 수 "
"있습니다."

#: ../../library/multiprocessing.rst:822
msgid ""
"The :meth:`~multiprocessing.Connection.send` method serializes the object"
" using :mod:`pickle` and the :meth:`~multiprocessing.Connection.recv` re-"
"creates the object."
msgstr ""

#: ../../library/multiprocessing.rst:827
msgid ""
"Returns a process shared queue implemented using a pipe and a few "
"locks/semaphores.  When a process first puts an item on the queue a "
"feeder thread is started which transfers objects from a buffer into the "
"pipe."
msgstr ""
"파이프와 몇 개의 록/세마포어를 사용하여 구현된 프로세스 공유 큐를 반환합니다. 프로세스가 처음으로 항목을 큐에 넣으면 버퍼에서 "
"파이프로 객체를 전송하는 피더 스레드가 시작됩니다."

#: ../../library/multiprocessing.rst:831
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"제한 시간 초과를 알리기 위해 표준 라이브러리의 :mod:`queue` 모듈에서 정의되는 :exc:`queue.Empty` 와 "
":exc:`queue.Full` 예외를 일으킵니다."

#: ../../library/multiprocessing.rst:834
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` 는 :meth:`~queue.Queue.task_done`\\과 "
":meth:`~queue.Queue.join` 을 제외한 :class:`queue.Queue` 의 모든 메서드를 구현합니다."

#: ../../library/multiprocessing.rst:839
msgid ""
"Return the approximate size of the queue.  Because of "
"multithreading/multiprocessing semantics, this number is not reliable."
msgstr "큐의 대략의 크기를 돌려줍니다. 다중 스레딩/다중 프로세싱 특성을 타기 때문에 이 숫자는 신뢰할 수 없습니다."

#: ../../library/multiprocessing.rst:842
#, fuzzy
msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like "
"macOS where ``sem_getvalue()`` is not implemented."
msgstr ""
"이것은 ``sem_getvalue()`` 가 구현되지 않은 Mac OS X와 같은 유닉스 플랫폼에서 "
":exc:`NotImplementedError`\\를 발생시킬 수 있습니다."

#: ../../library/multiprocessing.rst:847
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"큐가 비어 있다면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다. 다중 스레딩/다중 프로세싱 특성을 타기 "
"때문에 신뢰할 수 없습니다."

#: ../../library/multiprocessing.rst:850
msgid "May raise an :exc:`OSError` on closed queues. (not guaranteed)"
msgstr ""

#: ../../library/multiprocessing.rst:854
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"큐가 가득 차면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다. 다중 스레딩/다중 프로세싱 특성을 타기 때문에"
" 신뢰할 수 없습니다."

#: ../../library/multiprocessing.rst:859
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` "
"(the default) and *timeout* is ``None`` (the default), block if necessary"
" until a free slot is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Full` "
"exception if no free slot was available within that time.  Otherwise "
"(*block* is ``False``), put an item on the queue if a free slot is "
"immediately available, else raise the :exc:`queue.Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"obj를 큐에 넣습니다. 선택적 인자 *block* 이 ``True`` (기본값)이고 *timeout* 이 ``None`` "
"(기본값) 이면, 빈 슬롯이 생길 때까지 필요한 경우 블록합니다. *timeout* 이 양수인 경우, 최대 *timeout* 초만큼"
" 블록하고 그 시간 내에 사용 가능 슬롯이 생기지 않으면 :exc:`queue.Full` 예외를 발생시킵니다. 그렇지 않으면 "
"(*block* 이 ``False``) 빈 슬롯을 즉시 사용할 수 있으면 큐에 항목을 넣고, 그렇지 않으면 "
":exc:`queue.Full` 예외를 발생시킵니다 (이 경우 *timeout* 은 무시됩니다)."

#: ../../library/multiprocessing.rst:868
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of "
":exc:`AssertionError`."
msgstr "큐가 닫혔으면, :exc:`AssertionError` 대신 :exc:`ValueError`\\가 발생합니다."

#: ../../library/multiprocessing.rst:874
msgid "Equivalent to ``put(obj, False)``."
msgstr "``put(obj, False)`` 와 같습니다."

#: ../../library/multiprocessing.rst:878
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number,"
" it blocks at most *timeout* seconds and raises the :exc:`queue.Empty` "
"exception if no item was available within that time.  Otherwise (block is"
" ``False``), return an item if one is immediately available, else raise "
"the :exc:`queue.Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"큐에서 항목을 제거하고 반환합니다. 선택적 인자 *block* 이 ``True`` (기본값)이고 *timeout* 이 "
"``None`` (기본값) 이면, 항목이 들어올 때까지 필요한 경우 블록합니다. *timeout* 이 양수인 경우, 최대 "
"*timeout* 초만큼 블록하고 그 시간 내에 항목이 들어오지 않으면 :exc:`queue.Empty` 예외를 발생시킵니다. "
"그렇지 않으면 (block이 ``False``) 즉시 사용할 수 있는 항목이 있으면 반환하고, 그렇지 않으면 "
":exc:`queue.Empty` 예외를 발생시킵니다 (이 경우 *timeout* 은 무시됩니다)."

#: ../../library/multiprocessing.rst:886
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of "
":exc:`OSError`."
msgstr "큐가 닫혔으면, :exc:`OSError` 대신 :exc:`ValueError`\\가 발생합니다."

#: ../../library/multiprocessing.rst:892
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` 와 같습니다."

#: ../../library/multiprocessing.rst:894
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in "
":class:`queue.Queue`.  These methods are usually unnecessary for most "
"code:"
msgstr ""
":class:`multiprocessing.Queue` 에는 :class:`queue.Queue` 에서 찾을 수 없는 몇 가지 추가"
" 메서드가 있습니다. 일반적으로 이러한 메서드는 대부분 코드에서 필요하지 않습니다:"

#: ../../library/multiprocessing.rst:900
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all "
"buffered data to the pipe.  This is called automatically when the queue "
"is garbage collected."
msgstr ""
"현재 프로세스가 이 큐에 더는 데이터를 넣지 않을 것을 나타냅니다. 버퍼에 저장된 모든 데이터를 파이프로 플러시 하면 배경 스레드가"
" 종료됩니다. 큐가 가비지 수집될 때 자동으로 호출됩니다."

#: ../../library/multiprocessing.rst:907
msgid ""
"Join the background thread.  This can only be used after :meth:`close` "
"has been called.  It blocks until the background thread exits, ensuring "
"that all data in the buffer has been flushed to the pipe."
msgstr ""
"배경 스레드에 조인합니다. :meth:`close` 가 호출된 후에만 사용할 수 있습니다. 배경 스레드가 종료될 때까지 블록해서 "
"버퍼의 모든 데이터가 파이프로 플러시 되었음을 보증합니다."

#: ../../library/multiprocessing.rst:911
msgid ""
"By default if a process is not the creator of the queue then on exit it "
"will attempt to join the queue's background thread.  The process can call"
" :meth:`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"기본적으로 프로세스가 큐를 만든 주체가 아니면 종료할 때 큐의 배경 스레드를 조인하려고 합니다. 프로세스는 "
":meth:`cancel_join_thread`\\를 호출하여 :meth:`join_thread` 가 아무것도 하지 않게 할 수 "
"있습니다."

#: ../../library/multiprocessing.rst:917
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents "
"the background thread from being joined automatically when the process "
"exits -- see :meth:`join_thread`."
msgstr ""
":meth:`join_thread` 의 블록을 방지합니다. 특히, 프로세스가 종료할 때 배경 스레드를 자동으로 조인하는 것을 "
"막습니다 -- :meth:`join_thread`\\를 보십시오."

#: ../../library/multiprocessing.rst:921
#, fuzzy
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  "
"It is likely to cause enqueued data to be lost, and you almost certainly "
"will not need to use it. It is really only there if you need the current "
"process to exit immediately without waiting to flush enqueued data to the"
" underlying pipe, and you don't care about lost data."
msgstr ""
"이 메서드의 더 좋은 이름은 ``allow_exit_without_flush()`` 일 것입니다. 큐에 포함된 데이터가 유실될 "
"가능성이 크며, 거의 확실히 사용할 필요가 없을 겁니다. 현재 프로세스가 하부 파이프로 대기 중인 데이터를 플러시 할 때까지 "
"기다리지 않고 즉시 종료해야 하고 데이터 손실에 대해서는 신경 쓰지 않을 때만을 위한 것입니다."

#: ../../library/multiprocessing.rst:930
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the "
"functionality in this class will be disabled, and attempts to instantiate"
" a :class:`Queue` will result in an :exc:`ImportError`. See :issue:`3770`"
" for additional information.  The same holds true for any of the "
"specialized queue types listed below."
msgstr ""
"이 클래스의 기능은 호스트 운영 체제의 작동하는 공유 세마포어 구현을 요구합니다. 그런 것이 없으면, 클래스의 기능이 비활성화되고,"
" :class:`Queue` 의 인스턴스를 만들려고 하면 :exc:`ImportError` 를 일으킵니다. 자세한 내용은 "
":issue:`3770`\\을 참조하십시오. 아래에 나열된 특수 큐 형들도 마찬가지입니다."

#: ../../library/multiprocessing.rst:939
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked "
":class:`Pipe`."
msgstr "이것은 단순화된 :class:`Queue` 형으로, 록이 걸린 :class:`Pipe` 에 매우 가깝습니다."

#: ../../library/multiprocessing.rst:943
msgid "Close the queue: release internal resources."
msgstr "큐를 닫습니다: 내부 자원을 해제합니다."

#: ../../library/multiprocessing.rst:945
msgid ""
"A queue must not be used anymore after it is closed. For example, "
":meth:`get`, :meth:`put` and :meth:`empty` methods must no longer be "
"called."
msgstr ""
"큐를 닫은 후에는 더는 사용해서는 안 됩니다. 예를 들어, :meth:`get`, :meth:`put` 및 :meth:`empty`"
" 메서드가 더는 호출되지 않아야 합니다."

#: ../../library/multiprocessing.rst:953
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "큐가 비어 있다면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다."

#: ../../library/multiprocessing.rst:955
msgid "Always raises an :exc:`OSError` if the SimpleQueue is closed."
msgstr ""

#: ../../library/multiprocessing.rst:959
msgid "Remove and return an item from the queue."
msgstr "큐에서 항목을 제거하고 반환합니다."

#: ../../library/multiprocessing.rst:963
msgid "Put *item* into the queue."
msgstr "*item* 을 큐에 넣습니다."

#: ../../library/multiprocessing.rst:968
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`Queue` 서브 클래스 :class:`JoinableQueue` 는 추가로 :meth:`task_done`\\과 "
":meth:`join` 메서드를 가진 큐입니다."

#: ../../library/multiprocessing.rst:973
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a "
"subsequent call to :meth:`task_done` tells the queue that the processing "
"on the task is complete."
msgstr ""
"앞서 큐에 넣은 작업이 완료되었음을 나타냅니다. 큐 소비자가 사용합니다. 작업을 가져오는데 사용된 각 "
":meth:`~Queue.get` 마다, 뒤따르는 :meth:`task_done` 호출은 작업에 대한 처리가 완료되었음을 큐에 "
"알립니다."

#: ../../library/multiprocessing.rst:978
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when"
" all items have been processed (meaning that a :meth:`task_done` call was"
" received for every item that had been :meth:`~Queue.put` into the "
"queue)."
msgstr ""
"만약 :meth:`~queue.Queue.join` 이 현재 블록하고 있다면, 모든 항목이 처리될 때 재개될 것입니다 "
"(:meth:`~Queue.put` 으로 큐에 넣은 모든 항목에 대해 :meth:`task_done` 호출을 수신했다는 뜻입니다)."

#: ../../library/multiprocessing.rst:982
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items "
"placed in the queue."
msgstr "큐에 있는 항목보다 많이 호출되면 :exc:`ValueError` 를 발생시킵니다."

#: ../../library/multiprocessing.rst:988
msgid "Block until all items in the queue have been gotten and processed."
msgstr "큐의 모든 항목을 가져가서 처리할 때까지 블록합니다."

#: ../../library/multiprocessing.rst:990
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` "
"to indicate that the item was retrieved and all work on it is complete.  "
"When the count of unfinished tasks drops to zero, "
":meth:`~queue.Queue.join` unblocks."
msgstr ""
"항목이 큐에 추가될 때마다 완료되지 않은 작업의 수는 올라갑니다. 소비자가 그 항목을 꺼냈고 그에 대한 모든 작업을 완료했음을 "
"알리기 위해 :meth:`task_done`\\을 호출할 때마다 숫자는 줄어듭니다. 완료되지 않은 작업의 수가 0으로 떨어지면 "
":meth:`~queue.Queue.join` 이 블록으로부터 풀려납니다."

#: ../../library/multiprocessing.rst:998
msgid "Miscellaneous"
msgstr "잡동사니"

#: ../../library/multiprocessing.rst:1002
msgid "Return list of all live children of the current process."
msgstr "현재 프로세스의 모든 살아있는 자식 리스트를 반환합니다."

#: ../../library/multiprocessing.rst:1004
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "이것을 호출하면 이미 완료된 프로세스에 \"조인\" 하는 부작용이 있습니다."

#: ../../library/multiprocessing.rst:1009
msgid "Return the number of CPUs in the system."
msgstr "시스템의 CPU 수를 반환합니다."

#: ../../library/multiprocessing.rst:1011
#, fuzzy
msgid ""
"This number is not equivalent to the number of CPUs the current process "
"can use.  The number of usable CPUs can be obtained with "
":func:`os.process_cpu_count` (or ``len(os.sched_getaffinity(0))``)."
msgstr ""
"이 숫자는 현재 프로세스에서 사용할 수 있는 CPU 수와 같지 않습니다. 사용 가능한 CPU 수는 "
"``len(os.sched_getaffinity(0))`` 로 얻을 수 있습니다."

#: ../../library/multiprocessing.rst:1015
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError`"
" is raised."
msgstr ""

#: ../../library/multiprocessing.rst:1019
msgid ":func:`os.cpu_count` :func:`os.process_cpu_count`"
msgstr ""

#: ../../library/multiprocessing.rst:1024
msgid ""
"The return value can also be overridden using the :option:`-X cpu_count "
"<-X>` flag or :envvar:`PYTHON_CPU_COUNT` as this is merely a wrapper "
"around the :mod:`os` cpu count APIs."
msgstr ""

#: ../../library/multiprocessing.rst:1030
msgid "Return the :class:`Process` object corresponding to the current process."
msgstr "현재 프로세스에 해당하는 :class:`Process` 객체를 반환합니다."

#: ../../library/multiprocessing.rst:1032
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread`\\와 유사한 기능을 제공합니다."

#: ../../library/multiprocessing.rst:1036
msgid ""
"Return the :class:`Process` object corresponding to the parent process of"
" the :func:`current_process`. For the main process, ``parent_process`` "
"will be ``None``."
msgstr ""
":func:`current_process`\\의 부모 프로세스에 해당하는 :class:`Process` 객체를 반환합니다. 메인 "
"프로세스에서, ``parent_process``\\는 ``None``\\입니다."

#: ../../library/multiprocessing.rst:1044
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been"
" frozen to produce a Windows executable.  (Has been tested with "
"**py2exe**, **PyInstaller** and **cx_Freeze**.)"
msgstr ""
":mod:`multiprocessing`\\을 사용하는 프로그램이 고정되어(frozen) 윈도우 실행 파일을 생성할 때를 위한 "
"지원을 추가합니다. (**py2exe**, **PyInstaller** 및 **cx_Freeze** 에서 테스트 되었습니다.)"

#: ../../library/multiprocessing.rst:1048
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr "메인 모듈의 ``if __name__ == '__main__'`` 줄 바로 뒤에서 이 함수를 호출해야 합니다. 예를 들면::"

#: ../../library/multiprocessing.rst:1051
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""

#: ../../library/multiprocessing.rst:1060
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen"
" executable will raise :exc:`RuntimeError`."
msgstr ""
"``freeze_support()`` 줄이 생략된 경우 고정된 실행 파일을 실행하려고 하면 :exc:`RuntimeError` 가 "
"발생합니다."

#: ../../library/multiprocessing.rst:1063
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run "
"normally by the Python interpreter on Windows (the program has not been "
"frozen), then ``freeze_support()`` has no effect."
msgstr ""
"``freeze_support()`` 호출은 윈도우가 아닌 다른 운영 체제에서 실행될 때는 아무런 영향을 미치지 않습니다. 또한, "
"모듈이 윈도우상의 파이썬 인터프리터에 의해 정상적으로 실행되는 경우 (프로그램이 고정되지 않은 경우)에도 "
"``freeze_support()`` 는 아무 효과가 없습니다."

#: ../../library/multiprocessing.rst:1070
#, fuzzy
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See :ref"
":`multiprocessing-start-methods`."
msgstr ""
"지원되는 시작 방법의 리스트를 반환하는데, 그 중 첫 번째가 기본값입니다. 가능한 시작 방법은 ``'fork'``, "
"``'spawn'`` 및 ``'forkserver'`` 입니다. 윈도우에서는 ``'spawn'`` 만 사용할 수 있습니다. "
"유닉스에서는 ``'fork'`` 와 ``'spawn'`` 이 항상 지원되며 ``'fork'`` 가 기본값입니다."

#: ../../library/multiprocessing.rst:1079
msgid ""
"Return a context object which has the same attributes as the "
":mod:`multiprocessing` module."
msgstr ":mod:`multiprocessing` 모듈과 같은 어트리뷰트를 가진 컨텍스트 객체를 반환합니다."

#: ../../library/multiprocessing.rst:1082
#, fuzzy
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  "
":exc:`ValueError` is raised if the specified start method is not "
"available.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"*method* 가 ``None`` 이면 기본 컨텍스트가 반환됩니다. 그렇지 않으면 *method* 는 ``'fork'``, "
"``'spawn'``, ``'forkserver'`` 이어야 합니다. 지정된 시작 방법을 사용할 수 없는 경우 "
":exc:`ValueError` 가 발생합니다."

#: ../../library/multiprocessing.rst:1091
msgid "Return the name of start method used for starting processes."
msgstr "프로세스를 기동하기 위해서 사용되는 시작 방법의 이름을 돌려줍니다."

#: ../../library/multiprocessing.rst:1093
msgid ""
"If the start method has not been fixed and *allow_none* is false, then "
"the start method is fixed to the default and the name is returned.  If "
"the start method has not been fixed and *allow_none* is true then "
"``None`` is returned."
msgstr ""
"시작 방법이 고정되지 않았고 *allow_none* 이 거짓이면, 시작 방법이 기본값으로 고정되고 이름이 반환됩니다. 시작 방법이 "
"고정되지 않았고 *allow_none*\\이 참이면, ``None`` 이 반환됩니다."

#: ../../library/multiprocessing.rst:1098
#, fuzzy
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"반환 값은 ``'fork'``, ``'spawn'``, ``'forkserver'`` 또는 ``None`` 입니다. 유닉스에서는 "
"``'fork'`` 가 기본값이고, 윈도우에서는 ``'spawn'`` 이 기본값입니다."

#: ../../library/multiprocessing.rst:1105
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"macOS에서, *spawn* 시작 방법이 이제 기본값입니다. *fork* 시작 방법은 서브 프로세스의 충돌로 이어질 수 있기 "
"때문에, 안전하지 않은 것으로 간주해야 합니다. :issue:`33725`\\를 참조하십시오."

#: ../../library/multiprocessing.rst:1111
#, fuzzy
msgid ""
"Set the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr ""
"자식 프로세스를 시작할 때 사용할 파이썬 인터프리터의 경로를 설정합니다. (기본적으로 :data:`sys.executable` 이 "
"사용됩니다). 파이썬은 내장하는 사람들은 아마도 다음과 같이 할 필요가 있습니다 ::"

#: ../../library/multiprocessing.rst:1115
msgid "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr ""

#: ../../library/multiprocessing.rst:1117
msgid "before they can create child processes."
msgstr "자식 프로세스를 만들기 전에 해야 합니다."

#: ../../library/multiprocessing.rst:1119
#, fuzzy
msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr "이제 ``'spawn'`` 시작 방법을 사용할 때 유닉스에서 지원됩니다."

#: ../../library/multiprocessing.rst:1122
msgid "Accepts a :term:`path-like object`."
msgstr ""

#: ../../library/multiprocessing.rst:1127
msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This"
" can be used as a performance enhancement to avoid repeated work in every"
" process."
msgstr ""

#: ../../library/multiprocessing.rst:1133
msgid ""
"For this to work, it must be called before the forkserver process has "
"been launched (before creating a :class:`Pool` or starting a "
":class:`Process`)."
msgstr ""

#: ../../library/multiprocessing.rst:1136
msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See :ref"
":`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1143
msgid ""
"Set the method which should be used to start child processes. The "
"*method* argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. "
"Raises :exc:`RuntimeError` if the start method has already been set and "
"*force* is not ``True``.  If *method* is ``None`` and *force* is ``True``"
" then the start method is set to ``None``.  If *method* is ``None`` and "
"*force* is ``False`` then the context is set to the default context."
msgstr ""

#: ../../library/multiprocessing.rst:1150
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr "이것은 한 번만 호출해야 하며, 메인 모듈의 ``if __name__ == '__main__'`` 절 내에서 보호되어야 합니다."

#: ../../library/multiprocessing.rst:1154
#, fuzzy
msgid "See :ref:`multiprocessing-start-methods`."
msgstr ":ref:`multiprocessing-auth-keys`\\를 참조하세요."

#: ../../library/multiprocessing.rst:1160
msgid ""
":mod:`multiprocessing` contains no analogues of "
":func:`threading.active_count`, :func:`threading.enumerate`, "
":func:`threading.settrace`, :func:`threading.setprofile`, "
":class:`threading.Timer`, or :class:`threading.local`."
msgstr ""
":mod:`multiprocessing` 에는 :func:`threading.active_count`, "
":func:`threading.enumerate`, :func:`threading.settrace`, "
":func:`threading.setprofile`, :class:`threading.Timer` 또는 "
":class:`threading.local` 의 대응 물이 없습니다."

#: ../../library/multiprocessing.rst:1167
msgid "Connection Objects"
msgstr "Connection 객체"

#: ../../library/multiprocessing.rst:1171
msgid ""
"Connection objects allow the sending and receiving of picklable objects "
"or strings.  They can be thought of as message oriented connected "
"sockets."
msgstr "연결 객체를 사용하면 피클 가능한 객체나 문자열을 보내고 받을 수 있습니다. 메시지 지향 연결된 소켓으로 생각할 수 있습니다."

#: ../../library/multiprocessing.rst:1174
msgid ""
"Connection objects are usually created using :func:`Pipe "
"<multiprocessing.Pipe>` -- see also :ref:`multiprocessing-listeners-"
"clients`."
msgstr ""
"연결 객체는 보통 :func:`Pipe <multiprocessing.Pipe>` 를 사용해서 만들어집니다 -- :ref"
":`multiprocessing-listeners-clients` 도 참고하세요."

#: ../../library/multiprocessing.rst:1182
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr "연결의 반대편 끝에서 :meth:`recv`\\를 사용하여 읽을 객체를 보냅니다."

#: ../../library/multiprocessing.rst:1185
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+,"
" though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"객체는 피클 가능해야 합니다. 매우 큰 피클(약 32 MiB+, OS에 따라 다릅니다)은 :exc:`ValueError` 예외를 "
"발생시킬 수 있습니다."

#: ../../library/multiprocessing.rst:1190
msgid ""
"Return an object sent from the other end of the connection using "
":meth:`send`.  Blocks until there is something to receive.  Raises "
":exc:`EOFError` if there is nothing left to receive and the other end was"
" closed."
msgstr ""
"연결의 반대편 끝에서 :meth:`send`\\로 보낸 객체를 반환합니다. 뭔가 수신할 때까지 블록합니다. 수신할 내용이 없고 "
"반대편 끝이 닫혔으면 :exc:`EOFError`\\를 발생시킵니다."

#: ../../library/multiprocessing.rst:1197
msgid "Return the file descriptor or handle used by the connection."
msgstr "연결이 사용하는 파일 기술자나 핸들을 돌려줍니다."

#: ../../library/multiprocessing.rst:1201
msgid "Close the connection."
msgstr "연결을 닫습니다."

#: ../../library/multiprocessing.rst:1203
msgid "This is called automatically when the connection is garbage collected."
msgstr "연결이 가비지 수집될 때 자동으로 호출됩니다."

#: ../../library/multiprocessing.rst:1207
msgid "Return whether there is any data available to be read."
msgstr "읽어 들일 데이터가 있는지를 돌려줍니다."

#: ../../library/multiprocessing.rst:1209
msgid ""
"If *timeout* is not specified then it will return immediately.  If "
"*timeout* is a number then this specifies the maximum time in seconds to "
"block.  If *timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"*timeout* 을 지정하지 않으면 즉시 반환됩니다. *timeout* 이 숫자면 블록할 최대 시간(초)을 지정합니다. "
"*timeout* 이 ``None`` 이면 시간제한이 없습니다."

#: ../../library/multiprocessing.rst:1213
msgid ""
"Note that multiple connection objects may be polled at once by using "
":func:`multiprocessing.connection.wait`."
msgstr ""
"여러 개의 연결 객체를 :func:`multiprocessing.connection.wait` 을 사용하여 한 번에 폴링 할 수 "
"있습니다."

#: ../../library/multiprocessing.rst:1218
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ":term:`바이트열류 객체 <bytes-like object>` 의 바이트 데이터를 하나의 완전한 메시지로 보냅니다."

#: ../../library/multiprocessing.rst:1220
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  "
"If *size* is given then that many bytes will be read from buffer.  Very "
"large buffers (approximately 32 MiB+, though it depends on the OS) may "
"raise a :exc:`ValueError` exception"
msgstr ""
"*offset* 이 주어지면 *buffer* 의 해당 위치부터 데이터를 읽습니다. *size* 가 주어지면 그만큼의 바이트를 "
"버퍼에서 읽습니다. 매우 큰 버퍼(약 32 MiB+, OS에 따라 다릅니다)는 :exc:`ValueError` 예외를 발생시킬 수 "
"있습니다"

#: ../../library/multiprocessing.rst:1227
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. "
"Raises :exc:`EOFError` if there is nothing left to receive and the other "
"end has closed."
msgstr ""
"접속의 반대편 끝에서 송신된 바이트 데이터의 완전한 메시지를 문자열로 돌려줍니다. 뭔가 수신할 때까지 블록합니다. 수신할 내용이 "
"없고 반대편 끝이 닫혔으면 :exc:`EOFError`\\를 발생시킵니다."

#: ../../library/multiprocessing.rst:1232
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* "
"then :exc:`OSError` is raised and the connection will no longer be "
"readable."
msgstr ""
"*maxlength* 가 지정되고 메시지가 *maxlength* 보다 길면 :exc:`OSError` 가 발생하고 연결은 더는 읽을"
" 수 없게 됩니다."

#: ../../library/multiprocessing.rst:1236
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of "
":exc:`OSError`."
msgstr "이 함수는 :exc:`IOError` 를 발생시켜왔는데, 이제는 :exc:`OSError` 의 별칭입니다."

#: ../../library/multiprocessing.rst:1243
msgid ""
"Read into *buffer* a complete message of byte data sent from the other "
"end of the connection and return the number of bytes in the message.  "
"Blocks until there is something to receive.  Raises :exc:`EOFError` if "
"there is nothing left to receive and the other end was closed."
msgstr ""
"연결의 반대편 끝에서 보낸 바이트 데이터의 전체 메시지를 *buffer* 로 읽어 들이고, 메시지의 바이트 수를 반환합니다. 뭔가 "
"수신할 때까지 블록합니다. 수신할 내용이 없고 반대편 끝이 닫혔으면 :exc:`EOFError`\\를 발생시킵니다."

#: ../../library/multiprocessing.rst:1249
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is "
"given then the message will be written into the buffer from that "
"position.  Offset must be a non-negative integer less than the length of "
"*buffer* (in bytes)."
msgstr ""
"*buffer* 는 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>` 여야 합니다. *offset* 이"
" 지정되면, 버퍼의 그 위치로부터 메시지를 씁니다. offset은 *buffer* 길이보다 작은 음수가 아닌 정수여야 합니다 "
"(바이트 단위)."

#: ../../library/multiprocessing.rst:1254
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is "
"raised and the complete message is available as ``e.args[0]`` where ``e``"
" is the exception instance."
msgstr ""
"버퍼가 너무 작으면 :exc:`BufferTooShort` 예외가 발생하고, 완전한 메시지는 ``e.args[0]`` 으로 "
"제공되는데, 여기서 ``e`` 는 예외 인스턴스입니다."

#: ../../library/multiprocessing.rst:1258
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"이제 연결 객체 자체를 :meth:`Connection.send` 와 :meth:`Connection.recv` 를 사용하여 "
"프로세스 간에 전송할 수 있습니다."

#: ../../library/multiprocessing.rst:1262
#, fuzzy
msgid ""
"Connection objects also now support the context management protocol -- "
"see :ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns"
" the connection object, and :meth:`~contextmanager.__exit__` calls "
":meth:`close`."
msgstr ""
"이제 연결 객체는 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보세요. "
":meth:`~contextmanager.__enter__` 는 연결 객체를 반환하고, "
":meth:`~contextmanager.__exit__` 는 :meth:`close`\\를 호출합니다."

#: ../../library/multiprocessing.rst:1266
msgid "For example:"
msgstr "예를 들어:"

#: ../../library/multiprocessing.rst:1268
msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""

#: ../../library/multiprocessing.rst:1291
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
":meth:`Connection.recv` 메서드는 수신한 데이터를 자동으로 언 피클 합니다. 메시지를 보낸 프로세스를 신뢰할 수 "
"없다면 보안상 위험 할 수 있습니다."

#: ../../library/multiprocessing.rst:1295
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` "
"you should only use the :meth:`~Connection.recv` and "
":meth:`~Connection.send` methods after performing some sort of "
"authentication.  See :ref:`multiprocessing-auth-keys`."
msgstr ""
"따라서, 연결 객체가 :func:`Pipe`\\를 사용하여 생성되지 않았다면, 일종의 인증을 수행한 후에만 "
":meth:`~Connection.recv` 및 :meth:`~Connection.send` 메서드를 사용해야 합니다. :ref"
":`multiprocessing-auth-keys`\\를 참조하세요."

#: ../../library/multiprocessing.rst:1302
msgid ""
"If a process is killed while it is trying to read or write to a pipe then"
" the data in the pipe is likely to become corrupted, because it may "
"become impossible to be sure where the message boundaries lie."
msgstr ""
"프로세스가 파이프에 읽거나 쓰려고 할 때 죽으면, 파이프의 데이터가 손상될 가능성이 있습니다. 메시지 경계가 어디에 있는지 확신할 "
"수 없는 상태가 될 가능성이 있기 때문입니다."

#: ../../library/multiprocessing.rst:1308
msgid "Synchronization primitives"
msgstr "동기화 프리미티브"

#: ../../library/multiprocessing.rst:1312
msgid ""
"Generally synchronization primitives are not as necessary in a "
"multiprocess program as they are in a multithreaded program.  See the "
"documentation for :mod:`threading` module."
msgstr ""
"일반적으로 다중 프로세스 프로그램에서는 동기화 프리미티브가 다중 스레드 프로그램에서만큼 필요하지는 않습니다. "
":mod:`threading` 모듈에 대한 설명서를 참조하십시오."

#: ../../library/multiprocessing.rst:1316
msgid ""
"Note that one can also create synchronization primitives by using a "
"manager object -- see :ref:`multiprocessing-managers`."
msgstr ""
"관리자 객체를 사용하여 동기화 프리미티브를 생성할 수도 있습니다 -- :ref:`multiprocessing-managers`\\를"
" 참조하세요."

#: ../../library/multiprocessing.rst:1321
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "배리어(barrier) 객체: :class:`threading.Barrier` 의 복제본."

#: ../../library/multiprocessing.rst:1327
msgid ""
"A bounded semaphore object: a close analog of "
":class:`threading.BoundedSemaphore`."
msgstr "제한된 세마포어 객체: :class:`threading.BoundedSemaphore` 과 유사한 대응 물."

#: ../../library/multiprocessing.rst:1330
#: ../../library/multiprocessing.rst:1468
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` "
"method's first argument is named *block*, as is consistent with "
":meth:`Lock.acquire`."
msgstr ""
"대응 물과 한 가지 차이가 있습니다: ``acquire`` 메서드의 첫 번째 인자에 *block* 이라는 이름을 사용해서 "
":meth:`Lock.acquire` 와의 일관성을 유지합니다."

#: ../../library/multiprocessing.rst:1334
#, fuzzy
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"Mac OS X에서, ``sem_getvalue()`` 가 해당 플랫폼에 구현되어 있지 않기 때문에 "
":class:`Semaphore`\\와 구별되지 않습니다."

#: ../../library/multiprocessing.rst:1339
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "조건 변수: :class:`threading.Condition` 의 별칭."

#: ../../library/multiprocessing.rst:1341
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or "
":class:`RLock` object from :mod:`multiprocessing`."
msgstr ""
"*lock* 을 지정할 때는 :mod:`multiprocessing` 의 :class:`Lock` 이나 :class:`RLock` "
"객체여야 합니다."

#: ../../library/multiprocessing.rst:1344
#: ../../library/multiprocessing.rst:1882
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr ":meth:`~threading.Condition.wait_for` 메서드가 추가되었습니다."

#: ../../library/multiprocessing.rst:1349
msgid "A clone of :class:`threading.Event`."
msgstr ":class:`threading.Event` 의 복제본."

#: ../../library/multiprocessing.rst:1354
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. "
"Once a process or thread has acquired a lock, subsequent attempts to "
"acquire it from any process or thread will block until it is released; "
"any process or thread may release it.  The concepts and behaviors of "
":class:`threading.Lock` as it applies to threads are replicated here in "
":class:`multiprocessing.Lock` as it applies to either processes or "
"threads, except as noted."
msgstr ""
"비 재귀적 록 객체: :class:`threading.Lock` 과 유사한 대응 물. 일단 프로세스 또는 스레드가 록을 획득하면, "
"프로세스 또는 스레드에서 록을 획득하려는 후속 시도는 록이 해제될 때까지 블록 됩니다; 모든 프로세스 또는 스레드가 이를 해제할 수"
" 있습니다. 스레드에 적용되는 :class:`threading.Lock` 의 개념과 동작은, 명시된 경우를 제외하고, "
":class:`multiprocessing.Lock` 를 통해 프로세스나 스레드에 그대로 적용됩니다."

#: ../../library/multiprocessing.rst:1362
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a "
"default context."
msgstr ""
":class:`Lock` 은 실제로 기본 컨텍스트로 초기화된 ``multiprocessing.synchronize.Lock`` 의 "
"인스턴스를 반환하는 팩토리 함수입니다."

#: ../../library/multiprocessing.rst:1366
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may "
"be used in :keyword:`with` statements."
msgstr ""
":class:`Lock` 은 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원하므로 "
":keyword:`with` 문에서 사용될 수 있습니다."

#: ../../library/multiprocessing.rst:1371
#: ../../library/multiprocessing.rst:1422
msgid "Acquire a lock, blocking or non-blocking."
msgstr "블록하거나 블록하지 않는 방식으로 록을 획득합니다."

#: ../../library/multiprocessing.rst:1373
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked "
"and return ``True``.  Note that the name of this first argument differs "
"from that in :meth:`threading.Lock.acquire`."
msgstr ""
"*block* 인자가 ``True`` (기본값) 로 설정되면, 메서드 호출은 록이 해제 상태가 될 때까지 블록 한 다음, 잠금 "
"상태로 만들고 ``True`` 를 반환합니다. 이 첫 번째 인자의 이름은 :meth:`threading.Lock.acquire` 와"
" 다르다는 것에 유의하세요."

#: ../../library/multiprocessing.rst:1378
msgid ""
"With the *block* argument set to ``False``, the method call does not "
"block.  If the lock is currently in a locked state, return ``False``; "
"otherwise set the lock to a locked state and return ``True``."
msgstr ""
"*block* 인자가 ``False`` 로 설정되면, 메서드 호출은 블록 되지 않습니다. 록이 현재 잠금 상태면 ``False`` "
"를 반환합니다. 그렇지 않으면 록을 잠금 상태로 설정하고 ``True`` 를 반환합니다."

#: ../../library/multiprocessing.rst:1382
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block "
"for at most the number of seconds specified by *timeout* as long as the "
"lock can not be acquired.  Invocations with a negative value for "
"*timeout* are equivalent to a *timeout* of zero.  Invocations with a "
"*timeout* value of ``None`` (the default) set the timeout period to "
"infinite.  Note that the treatment of negative or ``None`` values for "
"*timeout* differs from the implemented behavior in "
":meth:`threading.Lock.acquire`.  The *timeout* argument has no practical "
"implications if the *block* argument is set to ``False`` and is thus "
"ignored.  Returns ``True`` if the lock has been acquired or ``False`` if "
"the timeout period has elapsed."
msgstr ""
"*timeout* 에 대해 양의 부동 소수점 값을 사용하여 호출하는 경우, 록을 얻을 수 없는 한 최대 *timeout* 으로 "
"지정된 시간(초) 동안 블록합니다. *timeout* 을 음수 값으로 호출하는 것은 *timeout* 에 0을 주는 것과 같습니다."
" *timeout* 값이 ``None`` (기본값) 인 호출은 제한 시간을 무한대로 설정합니다. *timeout* 에 대한 음수와 "
"``None`` 값의 처리는 :meth:`threading.Lock.acquire` 에서 구현된 동작과 다르다는 것에 주의하십시오."
" *timeout* 인자는 *block* 인자가 ``False`` 로 설정되면 실제적인 의미는 없고 무시됩니다. 록이 획득되면 "
"``True`` 를 돌려주고, 제한 시간 초과가 발생하면 ``False`` 를 돌려줍니다."

#: ../../library/multiprocessing.rst:1397
msgid ""
"Release a lock.  This can be called from any process or thread, not only "
"the process or thread which originally acquired the lock."
msgstr "록을 해제합니다. 이것은 원래 록을 획득한 프로세스나 스레드뿐만 아니라 모든 프로세스나 스레드에서 호출 할 수 있습니다."

#: ../../library/multiprocessing.rst:1400
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that "
"when invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"동작은 :meth:`threading.Lock.release` 와 같지만, 해제된 록에서 호출될 때 :exc:`ValueError`"
" 가 발생한다는 점만 다릅니다."

#: ../../library/multiprocessing.rst:1406
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired "
"it. Once a process or thread has acquired a recursive lock, the same "
"process or thread may acquire it again without blocking; that process or "
"thread must release it once for each time it has been acquired."
msgstr ""
"재귀적 록 객체: :class:`threading.RLock` 과 유사한 대응 물. 재귀적 록은 획득한 프로세스 또는 스레드에 의해"
" 해제되어야 합니다. 일단 프로세스나 스레드가 재귀적 록을 획득하면, 같은 프로세스나 스레드가 블록 없이 다시 획득할 수 있습니다;"
" 해당 프로세스나 스레드는 획득할 때마다 한 번 해제해야 합니다."

#: ../../library/multiprocessing.rst:1412
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a "
"default context."
msgstr ""
":class:`RLock` 은 실제로 기본 컨텍스트로 초기화된 ``multiprocessing.synchronize.RLock`` "
"의 인스턴스를 반환하는 팩토리 함수입니다."

#: ../../library/multiprocessing.rst:1416
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may"
" be used in :keyword:`with` statements."
msgstr ""
":class:`RLock` 은 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원하므로 "
":keyword:`with` 문에서 사용될 수 있습니다."

#: ../../library/multiprocessing.rst:1424
msgid ""
"When invoked with the *block* argument set to ``True``, block until the "
"lock is in an unlocked state (not owned by any process or thread) unless "
"the lock is already owned by the current process or thread.  The current "
"process or thread then takes ownership of the lock (if it does not "
"already have ownership) and the recursion level inside the lock "
"increments by one, resulting in a return value of ``True``.  Note that "
"there are several differences in this first argument's behavior compared "
"to the implementation of :meth:`threading.RLock.acquire`, starting with "
"the name of the argument itself."
msgstr ""
"*block* 인자를 ``True`` 로 설정해서 호출하면, 록이 현재 프로세스나 스레드가 이미 획득한 상태가 아니면 록이 (어떤 "
"프로세스나 스레드도 획득하지 않은) 록 해제 상태가 될 때까지 블록합니다. 이후에 현재 프로세스나 스레드가 (소유권이 아직 없는 "
"경우) 록 소유권을 얻게 되며 록 내 재귀 수준이 1 증가하고 ``True`` 를 반환합니다. 이 첫 번째 인자의 동작에는, 인자의"
" 이름부터 시작해서 :meth:`threading.RLock.acquire` 구현과 비교되는 몇 가지 차이점이 있습니다."

#: ../../library/multiprocessing.rst:1434
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If"
" the lock has already been acquired (and thus is owned) by another "
"process or thread, the current process or thread does not take ownership "
"and the recursion level within the lock is not changed, resulting in a "
"return value of ``False``.  If the lock is in an unlocked state, the "
"current process or thread takes ownership and the recursion level is "
"incremented, resulting in a return value of ``True``."
msgstr ""
"*block* 인자를 ``False`` 로 설정해서 호출하면 블록하지 않습니다. 록이 이미 다른 프로세스나 스레드에 의해 "
"획득되었으면 (그래서 소유하고 있으면), 현재 프로세스나 스레드는 소유권을 갖지 않으며 록 내 재귀 수준은 변경되지 않고 "
"``False`` 를 반환합니다. 록이 해제 상태에 있으면, 현재 프로세스 또는 스레드가 소유권을 가져오며 재귀 수준이 증가하고 "
"``True`` 를 반환합니다."

#: ../../library/multiprocessing.rst:1442
msgid ""
"Use and behaviors of the *timeout* argument are the same as in "
":meth:`Lock.acquire`.  Note that some of these behaviors of *timeout* "
"differ from the implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"*timeout* 인자의 사용법과 동작은 :meth:`Lock.acquire` 와 같습니다. *timeout* 의 이러한 동작 중 "
"일부는 :meth:`threading.RLock.acquire` 에서 구현된 동작과 다르다는 것에 주의하십시오."

#: ../../library/multiprocessing.rst:1449
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement"
" the recursion level is zero, reset the lock to unlocked (not owned by "
"any process or thread) and if any other processes or threads are blocked "
"waiting for the lock to become unlocked, allow exactly one of them to "
"proceed.  If after the decrement the recursion level is still nonzero, "
"the lock remains locked and owned by the calling process or thread."
msgstr ""
"재귀 수준을 감소시키면서 록을 해제합니다. 감소 후에 재귀 수준이 0이면, 록을 해제 상태(어떤 프로세스나 스레드에도 소유되지 "
"않음)로 재설정하고, 다른 프로세스나 스레드가 록이 해제될 때까지 기다리며 블록하고 있는 경우 해당 프로세스나 스레드 중 정확히 "
"하나가 계속 진행하도록 허용합니다. 감소 후에 재귀 수준이 여전히 0이 아닌 경우, 록은 획득된 상태로 남고 호출한 프로세스나 "
"스레드에 의해 소유됩니다."

#: ../../library/multiprocessing.rst:1457
msgid ""
"Only call this method when the calling process or thread owns the lock. "
"An :exc:`AssertionError` is raised if this method is called by a process "
"or thread other than the owner or if the lock is in an unlocked (unowned)"
" state.  Note that the type of exception raised in this situation differs"
" from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"호출한 프로세스나 스레드가 록을 소유하고 있을 때만 이 메서드를 호출하십시오. 이 메서드가 소유자가 아닌 프로세스나 스레드에 의해 "
"호출되거나, 록이 해제 (소유되지 않은) 상태면 :exc:`AssertionError` 가 발생합니다. 이 상황에서 발생하는 예외 "
"형은 :meth:`threading.RLock.release` 에서 구현된 동작과 다릅니다."

#: ../../library/multiprocessing.rst:1466
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "세마포어 객체: :class:`threading.Semaphore` 와 유사한 대응 물."

#: ../../library/multiprocessing.rst:1473
#, fuzzy
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with"
" a timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"Mac OS X에서, ``sem_timedwait`` 가 지원되지 않기 때문에, ``acquire()`` 를 시간제한 있게 호출하면"
" 잠자는 루프를 사용하여 해당 함수의 동작을 흉내 냅니다."

#: ../../library/multiprocessing.rst:1478
msgid ""
"Some of this package's functionality requires a functioning shared "
"semaphore implementation on the host operating system. Without one, the "
":mod:`multiprocessing.synchronize` module will be disabled, and attempts "
"to import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"이 패키지의 기능 중 일부는 호스트 운영 체제의 작동하는 공유 세마포어 구현을 요구합니다. 그런 것이 없으면, "
":mod:`multiprocessing.synchronize` 모듈이 비활성화되고, 임포트하려고 하면 "
":exc:`ImportError` 를 일으킵니다. 자세한 내용은 :issue:`3770`\\을 참조하십시오."

#: ../../library/multiprocessing.rst:1486
msgid "Shared :mod:`ctypes` Objects"
msgstr "공유 :mod:`ctypes` 객체"

#: ../../library/multiprocessing.rst:1488
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "자식 프로세스가 상속할 수 있는 공유 메모리를 사용하여 공유 객체를 만들 수 있습니다."

#: ../../library/multiprocessing.rst:1493
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default "
"the return value is actually a synchronized wrapper for the object.  The "
"object itself can be accessed via the *value* attribute of a "
":class:`Value`."
msgstr ""
"공유 메모리에 할당된 :mod:`ctypes` 객체를 반환합니다. 기본적으로 반환 값은, 사실 객체에 대한 동기화 된 래퍼입니다. "
"객체 자체는 :class:`Value` 의 *value* 어트리뷰트를 통해 접근 할 수 있습니다."

#: ../../library/multiprocessing.rst:1497
#: ../../library/multiprocessing.rst:1584
msgid ""
"*typecode_or_type* determines the type of the returned object: it is "
"either a ctypes type or a one character typecode of the kind used by the "
":mod:`array` module.  *\\*args* is passed on to the constructor for the "
"type."
msgstr ""
"*typecode_or_type* 은 반환된 객체의 형을 결정합니다: ctypes 형이거나 :mod:`array` 모듈에 의해 "
"사용되는 종류의 한 문자 typecode입니다. *\\*args* 는 형의 생성자로 전달됩니다."

#: ../../library/multiprocessing.rst:1501
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock`"
" or :class:`RLock` object then that will be used to synchronize access to"
" the value.  If *lock* is ``False`` then access to the returned object "
"will not be automatically protected by a lock, so it will not necessarily"
" be \"process-safe\"."
msgstr ""
"*lock* 이 ``True`` (기본값) 면 값에 대한 액세스를 동기화하기 위해 새 재귀적 록 객체가 생성됩니다. *lock* 이"
" :class:`Lock` 또는 :class:`RLock` 객체인 경우, 이 값이 값에 대한 액세스를 동기화하는 데 사용됩니다. "
"*lock* 이 ``False`` 면, 반환된 객체에 대한 액세스는 록에 의해 자동으로 보호되지 않으므로 \"프로세스 안전\" 하지"
" 않습니다."

#: ../../library/multiprocessing.rst:1508
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So"
" if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"읽기와 쓰기를 포함하는 ``+=`` 와 같은 연산은 원자 적(atomic)이지 않습니다. 따라서, 예를 들어, 공유 값을 원자 "
"적으로 증가시키려면, 다음과 같이 하는 것으로는 충분하지 않습니다::"

#: ../../library/multiprocessing.rst:1512
msgid "counter.value += 1"
msgstr ""

#: ../../library/multiprocessing.rst:1514
msgid ""
"Assuming the associated lock is recursive (which it is by default) you "
"can instead do ::"
msgstr "연관된 록이 재귀적이라고 가정하면 (기본적으로 그렇습니다), 대신 다음과 같이 할 수 있습니다 ::"

#: ../../library/multiprocessing.rst:1517
msgid ""
"with counter.get_lock():\n"
"    counter.value += 1"
msgstr ""

#: ../../library/multiprocessing.rst:1520
#: ../../library/multiprocessing.rst:1610
#: ../../library/multiprocessing.rst:1625
msgid "Note that *lock* is a keyword-only argument."
msgstr "*lock* 은 키워드 전용 인자입니다."

#: ../../library/multiprocessing.rst:1524
msgid ""
"Return a ctypes array allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the array."
msgstr "공유 메모리에서 할당된 ctypes 배열을 반환합니다. 기본적으로 반환 값은, 사실 배열에 대한 동기화 된 래퍼입니다."

#: ../../library/multiprocessing.rst:1527
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind"
" used by the :mod:`array` module.  If *size_or_initializer* is an "
"integer, then it determines the length of the array, and the array will "
"be initially zeroed. Otherwise, *size_or_initializer* is a sequence which"
" is used to initialize the array and whose length determines the length "
"of the array."
msgstr ""
"*typecode_or_type* 은 반환된 배열의 요소의 형을 결정합니다: ctypes 형이거나 :mod:`array` 모듈에 "
"의해 사용되는 종류의 한 문자 typecode입니다. *size_or_initializer* 가 정수면, 배열의 길이를 결정하고 "
"배열은 0으로 초기화됩니다. 그렇지 않으면, *size_or_initializer* 는 배열을 초기화하는 데 사용되는 시퀀스고, "
"길이는 배열의 길이를 결정합니다."

#: ../../library/multiprocessing.rst:1534
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or "
":class:`RLock` object then that will be used to synchronize access to the"
" value.  If *lock* is ``False`` then access to the returned object will "
"not be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"*lock* 이 ``True`` (기본값) 면 값에 대한 액세스를 동기화하기 위해 새 록 객체가 생성됩니다. *lock* 이 "
":class:`Lock` 또는 :class:`RLock` 객체인 경우, 이 값이 값에 대한 액세스를 동기화하는 데 사용됩니다. "
"*lock* 이 ``False`` 면, 반환된 객체에 대한 액세스는 록에 의해 자동으로 보호되지 않으므로 \"프로세스 안전\" 하지"
" 않습니다."

#: ../../library/multiprocessing.rst:1541
msgid "Note that *lock* is a keyword only argument."
msgstr "*lock* 은 키워드 전용 인자입니다."

#: ../../library/multiprocessing.rst:1543
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* "
"attributes which allow one to use it to store and retrieve strings."
msgstr ""
":data:`ctypes.c_char` 의 배열은 *value* 와 *raw* 어트리뷰트를 가지고 있습니다. 이 어트리뷰트를 "
"사용하여 문자열을 저장하고 꺼낼 수 있습니다."

#: ../../library/multiprocessing.rst:1548
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` 모듈"

#: ../../library/multiprocessing.rst:1553
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be "
"inherited by child processes."
msgstr ""
":mod:`multiprocessing.sharedctypes` 모듈은 자식 프로세스에 의해 상속될 수 있는 공유 메모리에 "
":mod:`ctypes` 객체를 할당하는 기능을 제공합니다."

#: ../../library/multiprocessing.rst:1559
msgid ""
"Although it is possible to store a pointer in shared memory remember that"
" this will refer to a location in the address space of a specific "
"process. However, the pointer is quite likely to be invalid in the "
"context of a second process and trying to dereference the pointer from "
"the second process may cause a crash."
msgstr ""
"공유 메모리에 포인터를 저장할 수는 있지만, 특정 프로세스의 주소 공간에 있는 위치를 참조하게 됩니다. 그러나 포인터는 두 번째 "
"프로세스의 컨텍스트에서는 유효하지 않을 가능성이 커서, 두 번째 프로세스에서 포인터를 역 참조하려고 하면 충돌이 일어날 수 "
"있습니다."

#: ../../library/multiprocessing.rst:1567
msgid "Return a ctypes array allocated from shared memory."
msgstr "공유 메모리에 할당된 ctypes 배열을 반환합니다."

#: ../../library/multiprocessing.rst:1569
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind"
" used by the :mod:`array` module.  If *size_or_initializer* is an integer"
" then it determines the length of the array, and the array will be "
"initially zeroed. Otherwise *size_or_initializer* is a sequence which is "
"used to initialize the array and whose length determines the length of "
"the array."
msgstr ""
"*typecode_or_type* 은 반환된 배열의 요소의 형을 결정합니다: ctypes 형이거나 :mod:`array` 모듈에 "
"의해 사용되는 종류의 한 문자 typecode입니다. *size_or_initializer* 가 정수면, 배열의 길이를 결정하고 "
"배열은 0으로 초기화됩니다. 그렇지 않으면, *size_or_initializer* 는 배열을 초기화하는 데 사용되는 시퀀스고, "
"길이는 배열의 길이를 결정합니다."

#: ../../library/multiprocessing.rst:1576
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use"
" :func:`Array` instead to make sure that access is automatically "
"synchronized using a lock."
msgstr ""
"요소를 쓰고 읽는 것은 잠재적으로 원자 적이지 않습니다 -- 액세스가 록을 사용하여 자동으로 동기화되기 원하면 "
":func:`Array`\\를 대신 사용하세요."

#: ../../library/multiprocessing.rst:1582
msgid "Return a ctypes object allocated from shared memory."
msgstr "공유 메모리에 할당된 ctypes 객체를 반환합니다."

#: ../../library/multiprocessing.rst:1588
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use "
":func:`Value` instead to make sure that access is automatically "
"synchronized using a lock."
msgstr ""
"값을 쓰고 읽는 것은 잠재적으로 원자 적이지 않습니다 -- 액세스가 록을 사용하여 자동으로 동기화되기 원하면 "
":func:`Value`\\를 대신 사용하세요."

#: ../../library/multiprocessing.rst:1592
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see"
" documentation for :mod:`ctypes`."
msgstr ""
":data:`ctypes.c_char` 의 배열은 *value* 와 *raw* 어트리뷰트를 가지고 있습니다. 이 어트리뷰트를 "
"사용하여 문자열을 저장하고 꺼낼 수 있습니다 -- :mod:`ctypes` 설명서를 보십시오."

#: ../../library/multiprocessing.rst:1598
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock*"
" a process-safe synchronization wrapper may be returned instead of a raw "
"ctypes array."
msgstr ""
"*lock* 값에 따라, 날 ctypes 배열 대신 프로세스 안전한 동기화 래퍼가 반환될 수 있다는 것을 제외하고는 "
":func:`RawArray` 와 같습니다."

#: ../../library/multiprocessing.rst:1602
#: ../../library/multiprocessing.rst:1618
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a "
":class:`~multiprocessing.Lock` or :class:`~multiprocessing.RLock` object "
"then that will be used to synchronize access to the value.  If *lock* is "
"``False`` then access to the returned object will not be automatically "
"protected by a lock, so it will not necessarily be \"process-safe\"."
msgstr ""
"*lock* 이 ``True`` (기본값) 면 값에 대한 액세스를 동기화하기 위해 새 록 객체가 생성됩니다. *lock* 이 "
":class:`~multiprocessing.Lock` 또는 :class:`~multiprocessing.RLock` 객체인 경우,"
" 이 값이 값에 대한 액세스를 동기화하는 데 사용됩니다. *lock* 이 ``False`` 면, 반환된 객체에 대한 액세스는 록에 "
"의해 자동으로 보호되지 않으므로 \"프로세스 안전\" 하지 않습니다."

#: ../../library/multiprocessing.rst:1614
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock*"
" a process-safe synchronization wrapper may be returned instead of a raw "
"ctypes object."
msgstr ""
"*lock* 값에 따라, 날 ctypes 객체 대신 프로세스 안전한 동기화 래퍼가 반환될 수 있다는 것을 제외하고는 "
":func:`RawValue` 와 같습니다."

#: ../../library/multiprocessing.rst:1629
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of "
"the ctypes object *obj*."
msgstr "공유 메모리에서 할당된 ctypes 객체를 반환합니다. 이 객체는 ctypes 객체 *obj* 의 복사본입니다."

#: ../../library/multiprocessing.rst:1634
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses "
"*lock* to synchronize access.  If *lock* is ``None`` (the default) then a"
" :class:`multiprocessing.RLock` object is created automatically."
msgstr ""
"*lock* 을 사용하여 액세스를 동기화하는 ctypes 객체에 대한 프로세스 안전한 래퍼 객체를 반환합니다. *lock* 이 "
"``None`` (기본값)이면 :class:`multiprocessing.RLock` 객체가 자동으로 생성됩니다."

#: ../../library/multiprocessing.rst:1638
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and "
":meth:`get_lock` returns the lock object used for synchronization."
msgstr ""
"동기화 래퍼는 래핑 된 객체의 메서드 외에도 두 개의 메서드를 더 갖습니다: :meth:`get_obj` 는 래핑 된 객체를 "
"반환하고, :meth:`get_lock` 은 동기화에 사용되는 록 객체를 반환합니다."

#: ../../library/multiprocessing.rst:1642
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr "래퍼를 통해 ctypes 객체에 액세스하는 것은, 날 ctypes 객체에 액세스하는 것보다 훨씬 느릴 수 있습니다."

#: ../../library/multiprocessing.rst:1645
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "동기화된 객체는 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원합니다."

#: ../../library/multiprocessing.rst:1649
msgid ""
"The table below compares the syntax for creating shared ctypes objects "
"from shared memory with the normal ctypes syntax.  (In the table "
"``MyStruct`` is some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"아래 표는 공유 메모리에 공유 ctypes 객체를 만드는 문법과 일반적인 ctypes 문법을 비교합니다. (표에서 "
"``MyStruct`` 는 :class:`ctypes.Structure` 의 서브 클래스입니다.)"

#: ../../library/multiprocessing.rst:1654
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1654
msgid "sharedctypes using type"
msgstr "type을 사용하는 공유 ctypes"

#: ../../library/multiprocessing.rst:1654
msgid "sharedctypes using typecode"
msgstr "typecode를 사용하는 공유 ctypes"

#: ../../library/multiprocessing.rst:1656
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1656
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1656
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1657
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1657
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1658
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1658
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1658
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1659
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1659
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1659
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1663
msgid ""
"Below is an example where a number of ctypes objects are modified by a "
"child process::"
msgstr "다음은 자식 프로세스가 여러 ctypes 객체를 수정하는 예입니다::"

#: ../../library/multiprocessing.rst:1666
msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], "
"lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"
msgstr ""

#: ../../library/multiprocessing.rst:1701
msgid "The results printed are ::"
msgstr "인쇄되는 결과는 이렇습니다 ::"

#: ../../library/multiprocessing.rst:1703
msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""

#: ../../library/multiprocessing.rst:1714
msgid "Managers"
msgstr "관리자"

#: ../../library/multiprocessing.rst:1716
msgid ""
"Managers provide a way to create data which can be shared between "
"different processes, including sharing over a network between processes "
"running on different machines. A manager object controls a server process"
" which manages *shared objects*.  Other processes can access the shared "
"objects by using proxies."
msgstr ""
"관리자는 서로 다른 컴퓨터에서 실행되는 프로세스 간에 네트워크를 통해 공유하는 것을 포함하여 서로 다른 프로세스 간에 공유할 수 "
"있는 데이터를 만드는 방법을 제공합니다. 관리자 객체는 *공유 객체* 를 관리하는 서버 프로세스를 제어합니다. 다른 프로세스는 "
"프락시를 사용하여 공유 객체에 액세스 할 수 있습니다."

#: ../../library/multiprocessing.rst:1725
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods "
"which will create shared objects and return corresponding proxies."
msgstr ""
"프로세스 간에 객체를 공유하는 데 사용할 수 있는 시작된 "
":class:`~multiprocessing.managers.SyncManager` 객체를 반환합니다. 반환된 관리자 객체는 생성된"
" 자식 프로세스에 해당하며 공유 객체를 만들고 해당 프락시를 반환하는 메서드가 있습니다."

#: ../../library/multiprocessing.rst:1733
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected "
"or their parent process exits.  The manager classes are defined in the "
":mod:`multiprocessing.managers` module:"
msgstr ""
"관리자 프로세스는 가비지 수집되거나 상위 프로세스가 종료되자마자 종료됩니다. 관리자 클래스는 "
":mod:`multiprocessing.managers` 모듈에 정의되어 있습니다 :"

#: ../../library/multiprocessing.rst:1739
msgid "Create a BaseManager object."
msgstr "BaseManager 객체를 만듭니다."

#: ../../library/multiprocessing.rst:1741
msgid ""
"Once created one should call :meth:`start` or "
"``get_server().serve_forever()`` to ensure that the manager object refers"
" to a started manager process."
msgstr ""
"일단 생성되면 관리자 객체가 시작된 관리자 프로세스를 참조하게 하려고 :meth:`start` 또는 "
"``get_server().serve_forever()`` 를 호출해야 합니다."

#: ../../library/multiprocessing.rst:1744
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* 는 관리자 프로세스가 새 연결을 리슨하는 주소입니다. *address* 가 ``None`` 이면 임의의 것이 "
"선택됩니다."

#: ../../library/multiprocessing.rst:1747
msgid ""
"*authkey* is the authentication key which will be used to check the "
"validity of incoming connections to the server process.  If *authkey* is "
"``None`` then ``current_process().authkey`` is used. Otherwise *authkey* "
"is used and it must be a byte string."
msgstr ""
"*authkey* 는 서버 프로세스로 들어오는 연결의 유효성을 검사하는 데 사용되는 인증 키입니다. *authkey* 가 "
"``None`` 이면 ``current_process().authkey`` 가 사용됩니다. 그렇지 않으면 *authkey* 가 "
"사용되며 바이트열이어야 합니다."

#: ../../library/multiprocessing.rst:1752
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""

#: ../../library/multiprocessing.rst:1755
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the"
" :func:`get_context` function."
msgstr ""

#: ../../library/multiprocessing.rst:1758
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process"
" used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process"
" also times out, the process is killed."
msgstr ""

#: ../../library/multiprocessing.rst:1763
#, fuzzy
msgid "Added the *shutdown_timeout* parameter."
msgstr "*daemon* 인자가 추가되었습니다."

#: ../../library/multiprocessing.rst:1768
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not "
"``None`` then the subprocess will call ``initializer(*initargs)`` when it"
" starts."
msgstr ""
"관리자를 시작시키기 위해 서브 프로세스를 시작합니다. *initializer* 가 ``None`` 이 아닌 경우, 서브 프로세스는 "
"시작할 때 ``initializer(*initargs)`` 를 호출합니다."

#: ../../library/multiprocessing.rst:1773
msgid ""
"Returns a :class:`Server` object which represents the actual server under"
" the control of the Manager. The :class:`Server` object supports the "
":meth:`serve_forever` method::"
msgstr ""
"Manager의 제어를 받는 실제 서버를 나타내는 :class:`Server` 객체를 반환합니다. :class:`Server` "
"객체는 :meth:`serve_forever` 메서드를 지원합니다::"

#: ../../library/multiprocessing.rst:1777
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""

#: ../../library/multiprocessing.rst:1782
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` 는 추가로 :attr:`address` 어트리뷰트를 가지고 있습니다."

#: ../../library/multiprocessing.rst:1786
msgid "Connect a local manager object to a remote manager process::"
msgstr "지역 관리자 객체를 원격 관리자 프로세스에 연결합니다::"

#: ../../library/multiprocessing.rst:1788
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"
msgstr ""

#: ../../library/multiprocessing.rst:1794
msgid ""
"Stop the process used by the manager.  This is only available if "
":meth:`start` has been used to start the server process."
msgstr "관리자가 사용하는 프로세스를 중지합니다. :meth:`start`\\를 사용하여 서버 프로세스를 시작한 경우에만 사용할 수 있습니다."

#: ../../library/multiprocessing.rst:1797
msgid "This can be called multiple times."
msgstr "여러 번 호출 될 수 있습니다."

#: ../../library/multiprocessing.rst:1801
msgid ""
"A classmethod which can be used for registering a type or callable with "
"the manager class."
msgstr "관리자 클래스에 형이나 콜러블을 등록하는데 사용할 수 있는 클래스 메서드."

#: ../../library/multiprocessing.rst:1804
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* 는 특정 형의 공유 객체를 식별하는 데 사용되는 \"형 식별자\" 입니다. 문자열이어야 합니다."

#: ../../library/multiprocessing.rst:1807
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is "
"``False`` then this can be left as ``None``."
msgstr ""
"*callable* 은 이 형 식별자에 대한 객체를 만드는 데 사용되는 콜러블 객체입니다. 관리자 인스턴스가 "
":meth:`connect` 메서드를 사용하여 서버에 연결되거나, *create_method* 인자가 ``False`` 면 "
"``None`` 으로 남겨 둘 수 있습니다."

#: ../../library/multiprocessing.rst:1813
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* 은, 이 *typeid* 의 공유 객체의 프락시를 만드는 데 사용되는 :class:`BaseProxy` 의 "
"서브 클래스입니다. ``None`` 이면 프락시 클래스가 자동으로 생성됩니다."

#: ../../library/multiprocessing.rst:1817
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for"
" this typeid should be allowed to access using "
":meth:`BaseProxy._callmethod`.  (If *exposed* is ``None`` then "
":attr:`proxytype._exposed_` is used instead if it exists.)  In the case "
"where no exposed list is specified, all \"public methods\" of the shared "
"object will be accessible.  (Here a \"public method\" means any attribute"
" which has a :meth:`~object.__call__` method and whose name does not "
"begin with ``'_'``.)"
msgstr ""
"*exposed* 는 이 typeid에 대한 프락시가 :meth:`BaseProxy._callmethod` 를 사용하여 액세스 할 "
"수 있도록 허용해야 하는 메서드 이름의 시퀀스를 지정하는 데 사용됩니다. (만약 *exposed* 가 ``None`` 이면, "
"존재하는 경우, :attr:`proxytype._exposed_` 가 대신 사용됩니다.) exposed 리스트가 지정되지 않은 "
"경우, 공유 객체의 모든 \"공용 메서드\" 에 액세스 할 수 있습니다. (여기서 \"공용 메서드\" 는 "
":meth:`~object.__call__` 메서드가 있고 그 이름이 ``'_'`` 로 시작하지 않는 어트리뷰트를 의미합니다.)"

#: ../../library/multiprocessing.rst:1826
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to "
"typeid strings.  (If *method_to_typeid* is ``None`` then "
":attr:`proxytype._method_to_typeid_` is used instead if it exists.)  If a"
" method's name is not a key of this mapping or if the mapping is ``None``"
" then the object returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* 는 프락시를 반환해야 하는 노출된 메서드의 반환형을 지정하는 데 사용되는 매핑입니다. 메서드 "
"이름을 typeid 문자열로 매핑합니다. (만일 *method_to_typeid* 가 ``None`` 이면, 존재한다면, "
":attr:`proxytype._method_to_typeid_` 가 대신 사용됩니다.) 메서드의 이름이 이 매핑의 키가 아니거나 "
"매핑이 ``None`` 이면, 메서드에 의해 반환된 객체는 값으로 복사됩니다."

#: ../../library/multiprocessing.rst:1833
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new "
"shared object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* 는 이름이 *typeid* 인 메서드를 만들어야 하는지를 결정합니다. 이 메서드는 서버 프로세스에 새 "
"공유 객체를 만들고 프락시를 반환하도록 지시하는 데 사용될 수 있습니다. 기본적으로 ``True`` 입니다."

#: ../../library/multiprocessing.rst:1837
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` 인스턴스는 읽기 전용 프로퍼티를 하나 가지고 있습니다:"

#: ../../library/multiprocessing.rst:1841
msgid "The address used by the manager."
msgstr "관리자가 사용하는 주소."

#: ../../library/multiprocessing.rst:1843
msgid ""
"Manager objects support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the "
"server process (if it has not already started) and then returns the "
"manager object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"관리자 객체는 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보세요. "
":meth:`~contextmanager.__enter__` 는 서버 프로세스를 시작하고 (아직 시작하지 않았다면), 관리자 객체를"
" 반환합니다. :meth:`~contextmanager.__exit__` 는 :meth:`shutdown`\\을 호출합니다."

#: ../../library/multiprocessing.rst:1849
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"이전 버전에서 :meth:`~contextmanager.__enter__` 는 관리자의 서버 프로세스가 아직 시작되지 않았을 때 "
"시작시키지 않았습니다."

#: ../../library/multiprocessing.rst:1854
msgid ""
"A subclass of :class:`BaseManager` which can be used for the "
"synchronization of processes.  Objects of this type are returned by "
":func:`multiprocessing.Manager`."
msgstr ""
"프로세스의 동기화에 사용할 수 있는 :class:`BaseManager` 의 서브 클래스입니다. 이 형의 객체는 "
":func:`multiprocessing.Manager` 에 의해 반환됩니다."

#: ../../library/multiprocessing.rst:1858
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. "
"This notably includes shared lists and dictionaries."
msgstr ""
"이 클래스의 메서드는 여러 프로세스에서 동기화 할 수 있도록 일반적으로 사용되는 많은 데이터형을 생성하고 :ref"
":`multiprocessing-proxy_objects`\\를 반환합니다. 특히 공유 리스트와 딕셔너리가 포함됩니다."

#: ../../library/multiprocessing.rst:1864
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for "
"it."
msgstr "공유 :class:`threading.Barrier` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1871
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "공유 :class:`threading.BoundedSemaphore` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1876
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy "
"for it."
msgstr "공유 :class:`threading.Condition` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1879
msgid ""
"If *lock* is supplied then it should be a proxy for a "
":class:`threading.Lock` or :class:`threading.RLock` object."
msgstr ""
"*lock* 이 제공되면 :class:`threading.Lock` 또는 :class:`threading.RLock` 객체에 대한 "
"프락시여야 합니다."

#: ../../library/multiprocessing.rst:1887
msgid "Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "공유 :class:`threading.Event` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1891
msgid "Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "공유 :class:`threading.Lock` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1895
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "공유 :class:`Namespace` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1899
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr "공유 :class:`queue.Queue` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1903
msgid "Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "공유 :class:`threading.RLock` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1907
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy "
"for it."
msgstr "공유 :class:`threading.Semaphore` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1912
msgid "Create an array and return a proxy for it."
msgstr "배열을 만들고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1916
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy "
"for it."
msgstr "쓰기 가능한 ``value`` 어트리뷰트를 가진 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1923
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "공유 :class:`dict` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1928
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "공유 :class:`list` 객체를 생성하고 프락시를 반환합니다."

#: ../../library/multiprocessing.rst:1930
msgid ""
"Shared objects are capable of being nested.  For example, a shared "
"container object such as a shared list can contain other shared objects "
"which will all be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"공유 객체는 중첩될 수 있습니다. 예를 들어, 공유 리스트와 같은 공유 컨테이너 객체는, :class:`SyncManager` 에 "
"의해 모두 관리되고 동기화되는 다른 공유 객체를 포함 할 수 있습니다."

#: ../../library/multiprocessing.rst:1937
msgid "A type that can register with :class:`SyncManager`."
msgstr ":class:`SyncManager` 로 등록 할 수 있는 형입니다."

#: ../../library/multiprocessing.rst:1939
msgid ""
"A namespace object has no public methods, but does have writable "
"attributes. Its representation shows the values of its attributes."
msgstr "이름 공간 객체에는 공용 메서드가 없지만, 쓰기 가능한 어트리뷰트가 있습니다. repr 은 그것의 어트리뷰트 값을 보여줍니다."

#: ../../library/multiprocessing.rst:1942
msgid ""
"However, when using a proxy for a namespace object, an attribute "
"beginning with ``'_'`` will be an attribute of the proxy and not an "
"attribute of the referent:"
msgstr ""
"그러나, 이름 공간 객체의 프락시를 사용할 때, ``'_'`` 로 시작하는 어트리뷰트는 프락시의 어트리뷰트가 되며 참조 대상의 "
"어트리뷰트가 아닙니다:"

#: ../../library/multiprocessing.rst:1946
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"
msgstr ""

#: ../../library/multiprocessing.rst:1959
msgid "Customized managers"
msgstr "사용자 정의 관리자"

#: ../../library/multiprocessing.rst:1961
msgid ""
"To create one's own manager, one creates a subclass of "
":class:`BaseManager` and uses the :meth:`~BaseManager.register` "
"classmethod to register new types or callables with the manager class.  "
"For example::"
msgstr ""
"자신만의 관리자를 만들려면, :class:`BaseManager` 의 서브 클래스를 만들고 "
":meth:`~BaseManager.register` 클래스 메서드를 사용하여 새로운 형이나 콜러블을 관리자 클래스에 등록합니다. "
"예를 들면::"

#: ../../library/multiprocessing.rst:1965
msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # prints 7\n"
"        print(maths.mul(7, 8))         # prints 56"
msgstr ""

#: ../../library/multiprocessing.rst:1986
msgid "Using a remote manager"
msgstr "원격 관리자 사용하기"

#: ../../library/multiprocessing.rst:1988
msgid ""
"It is possible to run a manager server on one machine and have clients "
"use it from other machines (assuming that the firewalls involved allow "
"it)."
msgstr ""
"한 기계에서 관리자 서버를 실행하고 다른 기계의 클라이언트가 관리자 서버를 사용하도록 할 수 있습니다 (관련된 방화벽이 허용한다고 "
"가정합니다)."

#: ../../library/multiprocessing.rst:1991
msgid ""
"Running the following commands creates a server for a single shared queue"
" which remote clients can access::"
msgstr "다음 명령을 실행하면 원격 클라이언트가 액세스 할 수 있는 단일 공유 큐를 위한 서버가 만들어집니다::"

#: ../../library/multiprocessing.rst:1994
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""

#: ../../library/multiprocessing.rst:2003
msgid "One client can access the server as follows::"
msgstr "한 클라이언트는 다음과 같이 서버에 액세스 할 수 있습니다::"

#: ../../library/multiprocessing.rst:2005
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""

#: ../../library/multiprocessing.rst:2013
msgid "Another client can also use it::"
msgstr "또 다른 클라이언트도 사용할 수 있습니다::"

#: ../../library/multiprocessing.rst:2015
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""

#: ../../library/multiprocessing.rst:2024
msgid ""
"Local processes can also access that queue, using the code from above on "
"the client to access it remotely::"
msgstr "지역 프로세스 역시, 위의 클라이언트가 원격으로 액세스하는 코드를 사용하여 같은 큐에 액세스 할 수 있습니다::"

#: ../../library/multiprocessing.rst:2027
msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""

#: ../../library/multiprocessing.rst:2049
msgid "Proxy Objects"
msgstr "프락시 객체"

#: ../../library/multiprocessing.rst:2051
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the"
" *referent* of the proxy.  Multiple proxy objects may have the same "
"referent."
msgstr ""
"프락시는 (아마도) 다른 프로세스에 있는 공유 객체를 *가리키는* 객체입니다. 공유 객체는 프락시의 *지시 대상* 이라고 합니다. "
"여러 프락시 객체는 같은 지시 대상을 가질 수 있습니다."

#: ../../library/multiprocessing.rst:2055
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like"
" its referent can:"
msgstr ""
"프락시 객체에는 지시 대상의 해당 메서드를 호출하는 메서드가 있습니다 (그러나 지시 대상의 모든 메서드가 반드시 프락시를 통해 "
"사용할 수 있는 것은 아닙니다). 이런 식으로, 프락시는 지시 대상처럼 사용될 수 있습니다:"

#: ../../library/multiprocessing.rst:2059
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""

#: ../../library/multiprocessing.rst:2073
msgid ""
"Notice that applying :func:`str` to a proxy will return the "
"representation of the referent, whereas applying :func:`repr` will return"
" the representation of the proxy."
msgstr ""
"프락시에 :func:`str` 을 적용하면 지시 대상의 표현이 반환되는 반면, :func:`repr` 을 적용하면 프락시의 표현이 "
"반환됩니다."

#: ../../library/multiprocessing.rst:2077
msgid ""
"An important feature of proxy objects is that they are picklable so they "
"can be passed between processes.  As such, a referent can contain :ref"
":`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"프락시 객체의 중요한 특징은, 피클 가능해서 프로세스 간에 전달될 수 있다는 것입니다. 지시 대상은 :ref"
":`multiprocessing-proxy_objects`\\를 포함 할 수 있습니다. 이것은 관리된 리스트, 딕셔너리 및 다른 "
":ref:`multiprocessing-proxy_objects` 의 중첩을 허용합니다:"

#: ../../library/multiprocessing.rst:2082
msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"
msgstr ""

#: ../../library/multiprocessing.rst:2093
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "비슷하게, 딕셔너리와 리스트 프락시는 서로 중첩될 수 있습니다::"

#: ../../library/multiprocessing.rst:2095
#, python-brace-format
msgid ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"
msgstr ""

#: ../../library/multiprocessing.rst:2106
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are "
"contained in a referent, modifications to those mutable values will not "
"be propagated through the manager because the proxy has no way of knowing"
" when the values contained within are modified.  However, storing a value"
" in a container proxy (which triggers a ``__setitem__`` on the proxy "
"object) does propagate through the manager and so to effectively modify "
"such an item, one could re-assign the modified value to the container "
"proxy::"
msgstr ""
"(프락시가 아닌) 표준 :class:`list` 또는 :class:`dict` 객체가 지시 대상에 포함되어있는 경우, 이 가변 "
"값들에 대한 수정은 관리자를 통해 전파되지 않습니다. 포함된 값이 언제 수정되는지 프락시가 알 방법이 없기 때문입니다. 그러나 "
"컨테이너 프락시에 값을 저장하는 것(프락시 객체의 ``__setitem__`` 을 호출합니다)은 관리자를 통해 전파되므로, 그 "
"항목을 효과적으로 수정하기 위해, 수정된 값을 컨테이너 프락시에 다시 대입할 수 있습니다::"

#: ../../library/multiprocessing.rst:2114
#, python-brace-format
msgid ""
"# create a list proxy and append a mutable object (a dictionary)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# now mutate the dictionary\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# at this point, the changes to d are not yet synced, but by\n"
"# updating the dictionary, the proxy is notified of the change\n"
"lproxy[0] = d"
msgstr ""

#: ../../library/multiprocessing.rst:2125
msgid ""
"This approach is perhaps less convenient than employing nested :ref"
":`multiprocessing-proxy_objects` for most use cases but also demonstrates"
" a level of control over the synchronization."
msgstr ""
"이 접근법은 아마도 대부분의 사용 사례에서 중첩된 :ref:`multiprocessing-proxy_objects`\\를 사용하는 "
"것보다 불편하지만, 동기화에 대한 제어 수준을 보여줍니다."

#: ../../library/multiprocessing.rst:2131
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support "
"comparisons by value.  So, for instance, we have:"
msgstr ""
":mod:`multiprocessing` 의 프락시 형은 값으로 비교하는 것을 지원하지 않습니다. 그래서, 예를 들어, 이런 결과를"
" 얻습니다:"

#: ../../library/multiprocessing.rst:2134
msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""

#: ../../library/multiprocessing.rst:2139
msgid ""
"One should just use a copy of the referent instead when making "
"comparisons."
msgstr "비교할 때는 지시 대상의 사본을 대신 사용해야 합니다."

#: ../../library/multiprocessing.rst:2143
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "프락시 객체는 :class:`BaseProxy` 의 서브 클래스의 인스턴스입니다."

#: ../../library/multiprocessing.rst:2147
msgid "Call and return the result of a method of the proxy's referent."
msgstr "프락시의 지시 대상 메서드를 호출하고 결과를 반환합니다."

#: ../../library/multiprocessing.rst:2149
msgid "If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "``proxy`` 가 프락시이고, 그 지시 대상이 ``obj`` 면, 표현식 ::"

#: ../../library/multiprocessing.rst:2151
msgid "proxy._callmethod(methodname, args, kwds)"
msgstr ""

#: ../../library/multiprocessing.rst:2153
msgid "will evaluate the expression ::"
msgstr "은 표현식 ::"

#: ../../library/multiprocessing.rst:2155
msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr ""

#: ../../library/multiprocessing.rst:2157
msgid "in the manager's process."
msgstr "을 관리자 프로세스에서 평가합니다."

#: ../../library/multiprocessing.rst:2159
msgid ""
"The returned value will be a copy of the result of the call or a proxy to"
" a new shared object -- see documentation for the *method_to_typeid* "
"argument of :meth:`BaseManager.register`."
msgstr ""
"반환된 값은 호출 결과의 복사본이거나 새 공유 객체에 대한 프락시입니다 -- :meth:`BaseManager.register` 의"
" *method_to_typeid* 인자에 대한 설명서를 보십시오."

#: ../../library/multiprocessing.rst:2163
msgid ""
"If an exception is raised by the call, then is re-raised by "
":meth:`_callmethod`.  If some other exception is raised in the manager's "
"process then this is converted into a :exc:`RemoteError` exception and is"
" raised by :meth:`_callmethod`."
msgstr ""
"호출 때문에 예외가 발생하면, :meth:`_callmethod` 가 다시 일으킵니다. 관리자 프로세스에서 다른 예외가 발생하면 "
":exc:`RemoteError` 예외로 변환되어 :meth:`_callmethod` 가 일으킵니다."

#: ../../library/multiprocessing.rst:2168
msgid ""
"Note in particular that an exception will be raised if *methodname* has "
"not been *exposed*."
msgstr "특히, *methodname* 이 *노출되지* 않았으면 예외가 발생합니다."

#: ../../library/multiprocessing.rst:2171
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` 사용법의 예:"

#: ../../library/multiprocessing.rst:2173
msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""

#: ../../library/multiprocessing.rst:2187
msgid "Return a copy of the referent."
msgstr "지시 대상의 복사본을 반환합니다."

#: ../../library/multiprocessing.rst:2189
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "지시 대상이 피클 가능하지 않으면 예외가 발생합니다."

#: ../../library/multiprocessing.rst:2193
msgid "Return a representation of the proxy object."
msgstr "프락시 객체의 표현을 반환합니다."

#: ../../library/multiprocessing.rst:2197
msgid "Return the representation of the referent."
msgstr "지시 대상의 표현을 반환합니다."

#: ../../library/multiprocessing.rst:2201
msgid "Cleanup"
msgstr "정리"

#: ../../library/multiprocessing.rst:2203
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr "프락시 객체는 weakref 콜백을 사용해서 가비지 수집 시 자신의 지시 대상을 소유한 관리자에서 자신을 등록 취소합니다."

#: ../../library/multiprocessing.rst:2206
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "더는 참조하는 프락시가 없는 경우 공유 객체는 관리자 프로세스에서 삭제됩니다."

#: ../../library/multiprocessing.rst:2211
msgid "Process Pools"
msgstr "프로세스 풀"

#: ../../library/multiprocessing.rst:2216
msgid ""
"One can create a pool of processes which will carry out tasks submitted "
"to it with the :class:`Pool` class."
msgstr ":class:`Pool` 클래스를 사용하여, 제출된 작업을 수행할 프로세스 풀을 만들 수 있습니다."

#: ../../library/multiprocessing.rst:2221
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts "
"and callbacks and has a parallel map implementation."
msgstr ""
"작업을 제출할 수 있는 작업자 프로세스 풀을 제어하는 프로세스 풀 객체. 제한 시간과 콜백을 사용하는 비동기 결과를 지원하고 병렬 "
"map 구현을 제공합니다."

#: ../../library/multiprocessing.rst:2225
#, fuzzy
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is "
"used."
msgstr ""
"*processes* 는 사용할 작업자 프로세스 수입니다. *processes* 가 ``None`` 이면 "
":func:`os.cpu_count` 에 의해 반환되는 수가 사용됩니다."

#: ../../library/multiprocessing.rst:2228
#: ../../library/multiprocessing.rst:2792
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"*initializer* 가 ``None`` 이 아니면, 각 작업자 프로세스는 시작할 때 "
"``initializer(*initargs)`` 를 호출합니다."

#: ../../library/multiprocessing.rst:2231
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to "
"enable unused resources to be freed. The default *maxtasksperchild* is "
"``None``, which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* 는, 사용되지 않는 자원을 해제할 수 있도록, 작업 프로세스가 종료되고 새 작업 프로세스로 "
"교체되기 전에 완료할 수 있는 작업 수입니다. 기본 *maxtasksperchild* 는 ``None`` 입니다. 이는 작업자 "
"프로세스가 풀만큼 오래감을 의미합니다."

#: ../../library/multiprocessing.rst:2236
msgid ""
"*context* can be used to specify the context used for starting the worker"
" processes.  Usually a pool is created using the function "
":func:`multiprocessing.Pool` or the :meth:`Pool` method of a context "
"object.  In both cases *context* is set appropriately."
msgstr ""
"*context* 는 작업자 프로세스를 시작하는 데 사용되는 컨텍스트를 지정하는 데 사용할 수 있습니다. 보통 풀은 "
":func:`multiprocessing.Pool` 또는 컨텍스트 객체의 :meth:`Pool` 메서드를 사용하여 생성됩니다. 두 "
"경우 모두 *context* 가 적절하게 설정됩니다."

#: ../../library/multiprocessing.rst:2242
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "풀 객체의 메서드는 풀을 생성한 프로세스에 의해서만 호출되어야 합니다."

#: ../../library/multiprocessing.rst:2246
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need "
"to be properly managed (like any other resource) by using the pool as a "
"context manager or by calling :meth:`close` and :meth:`terminate` "
"manually. Failure to do this can lead to the process hanging on "
"finalization."
msgstr ""
":class:`multiprocessing.pool` 객체에는 풀을 컨텍스트 관리자로 사용하거나 :meth:`close`\\와 "
":meth:`terminate`\\를 수동으로 호출하여 (다른 자원과 마찬가지로) 올바르게 관리해야 하는 내부 자원이 있습니다. "
"이를 수행하지 않으면 파이널리제이션 때 프로세스가 멈출 수 있습니다."

#: ../../library/multiprocessing.rst:2251
#, fuzzy
msgid ""
"Note that it is **not correct** to rely on the garbage collector to "
"destroy the pool as CPython does not assure that the finalizer of the "
"pool will be called (see :meth:`object.__del__` for more information)."
msgstr ""
"CPython이 풀의 파이널라이저가 호출될 것을 보장하지 않기 때문에 가비지 수거기가 풀을 파괴하는 것에 의존하는 것은 **올바르지"
" 않음**\\에 유의하십시오 (자세한 내용은 :meth:`object.__del__`\\을 참조하십시오)."

#: ../../library/multiprocessing.rst:2255
#, fuzzy
msgid "Added the *maxtasksperchild* parameter."
msgstr "*maxtasksperchild*"

#: ../../library/multiprocessing.rst:2258
#, fuzzy
msgid "Added the *context* parameter."
msgstr "*daemon* 인자가 추가되었습니다."

#: ../../library/multiprocessing.rst:2261
msgid ""
"*processes* uses :func:`os.process_cpu_count` by default, instead of "
":func:`os.cpu_count`."
msgstr ""

#: ../../library/multiprocessing.rst:2267
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other "
"systems (such as Apache, mod_wsgi, etc) to free resources held by workers"
" is to allow a worker within a pool to complete only a set amount of work"
" before being exiting, being cleaned up and a new process spawned to "
"replace the old one. The *maxtasksperchild* argument to the :class:`Pool`"
" exposes this ability to the end user."
msgstr ""
":class:`Pool` 내의 작업자 프로세스는 일반적으로 Pool의 작업 큐의 전체 지속 기간 지속합니다. 작업자가 잡은 자원을 "
"해제하기 위해 다른 시스템 (가령 Apache, mod_wsgi 등)에서 흔히 사용되는 패턴은, 풀 내에 있는 작업자가 종료되고 새"
" 프로세스가 스폰 되어 예전 것을 교체하기 전에 일정한 분량의 작업만 완료하도록 하는 것입니다. :class:`Pool` 의 "
"*maxtasksperchild* 인자는 이 기능을 일반 사용자에게 노출합니다."

#: ../../library/multiprocessing.rst:2277
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It "
"blocks until the result is ready. Given this blocks, :meth:`apply_async` "
"is better suited for performing work in parallel. Additionally, *func* is"
" only executed in one of the workers of the pool."
msgstr ""
"인자 *args* 및 키워드 인자 *kwds* 를 사용하여 *func* 를 호출합니다. 결과가 준비될 때까지 블록 됩니다. 이 블록"
" 때문에, :meth:`apply_async` 가 병렬로 작업을 수행하는 데 더 적합합니다. 또한 *func* 는 풀의 작업자 중 "
"하나에서만 실행됩니다."

#: ../../library/multiprocessing.rst:2284
msgid ""
"A variant of the :meth:`apply` method which returns a "
":class:`~multiprocessing.pool.AsyncResult` object."
msgstr ""
":class:`~multiprocessing.pool.AsyncResult` 객체를 반환하는 :meth:`apply` 메서드의 "
"변형입니다."

#: ../../library/multiprocessing.rst:2287
#: ../../library/multiprocessing.rst:2318
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to "
"it, that is unless the call failed, in which case the *error_callback* is"
" applied instead."
msgstr ""
"*callback* 이 지정되면 단일 인자를 받아들이는 콜러블이어야 합니다. 결과가 준비되면 *callback* 을 이 결과를 "
"인자로 호출합니다. 실패한 결과면 *error_callback* 이 대신 적용됩니다."

#: ../../library/multiprocessing.rst:2292
#: ../../library/multiprocessing.rst:2323
msgid ""
"If *error_callback* is specified then it should be a callable which "
"accepts a single argument.  If the target function fails, then the "
"*error_callback* is called with the exception instance."
msgstr ""
"*error_callback* 이 지정되면 단일 인자를 허용하는 콜러블이어야 합니다. 대상 함수가 실패하면, "
"*error_callback* 이 예외 인스턴스를 인자로 호출됩니다."

#: ../../library/multiprocessing.rst:2296
#: ../../library/multiprocessing.rst:2327
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr "콜백은 즉시 완료되어야 합니다. 그렇지 않으면 결과를 처리하는 스레드가 블록 됩니다."

#: ../../library/multiprocessing.rst:2301
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports "
"only one *iterable* argument though, for multiple iterables see "
":meth:`starmap`). It blocks until the result is ready."
msgstr ""
":func:`map` 내장 함수의 병렬 버전입니다 (하지만 하나의 *iterable* 인자만 지원합니다, 여러 이터러블에 대해서는 "
":meth:`starmap`\\을 참조하십시오). 결과가 준비될 때까지 블록 됩니다."

#: ../../library/multiprocessing.rst:2305
msgid ""
"This method chops the iterable into a number of chunks which it submits "
"to the process pool as separate tasks.  The (approximate) size of these "
"chunks can be specified by setting *chunksize* to a positive integer."
msgstr ""
"이 메서드는 iterable을 여러 묶음으로 잘라서 별도의 작업으로 프로세스 풀에 제출합니다. 이러한 묶음의 (대략적인) 크기는 "
"*chunksize* 를 양의 정수로 설정하여 지정할 수 있습니다."

#: ../../library/multiprocessing.rst:2309
msgid ""
"Note that it may cause high memory usage for very long iterables. "
"Consider using :meth:`imap` or :meth:`imap_unordered` with explicit "
"*chunksize* option for better efficiency."
msgstr ""
"매우 긴 이터러블은 높은 메모리 사용을 유발할 수 있습니다. 더 나은 효율성을 위해, 명시적인 *chunksize* 옵션으로 "
":meth:`imap`\\이나 :meth:`imap_unordered`\\를 사용하는 것을 고려하십시오."

#: ../../library/multiprocessing.rst:2315
msgid ""
"A variant of the :meth:`.map` method which returns a "
":class:`~multiprocessing.pool.AsyncResult` object."
msgstr ""
":class:`~multiprocessing.pool.AsyncResult` 객체를 반환하는 :meth:`.map` 메서드의 "
"변형입니다."

#: ../../library/multiprocessing.rst:2332
msgid "A lazier version of :meth:`.map`."
msgstr ":meth:`.map` 의 느긋한 버전."

#: ../../library/multiprocessing.rst:2334
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of "
"``1``."
msgstr ""
"*chunksize* 인자는 :meth:`.map` 메서드에서 사용된 인자와 같습니다. 매우 긴 iterable의 경우 "
"*chunksize* 에 큰 값을 사용하면 기본값 ``1`` 을 사용하는 것보다 작업을 **많이** 빠르게 완료 할 수 있습니다."

#: ../../library/multiprocessing.rst:2339
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the "
"iterator returned by the :meth:`imap` method has an optional *timeout* "
"parameter: ``next(timeout)`` will raise "
":exc:`multiprocessing.TimeoutError` if the result cannot be returned "
"within *timeout* seconds."
msgstr ""
"또한 *chunksize* 가 ``1`` 이면 :meth:`imap` 메서드에 의해 반환된 이터레이터의 :meth:`!next` "
"메서드는 선택적 *timeout* 매개 변수를 가집니다: ``next(timeout)`` 은 결과가 *timeout* 초 내에 "
"반환될 수 없는 경우 :exc:`multiprocessing.TimeoutError` 를 발생시킵니다."

#: ../../library/multiprocessing.rst:2346
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the"
" returned iterator should be considered arbitrary.  (Only when there is "
"only one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
":meth:`imap`\\과 같지만, 반환된 이터레이터가 제공하는 결과의 순서가 임의적인 것으로 간주하여야 합니다. (단 하나의 "
"작업자 프로세스가 있는 경우에만 순서가 \"올바름\" 이 보장됩니다."

#: ../../library/multiprocessing.rst:2352
#, fuzzy
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of "
"the *iterable* are expected to be iterables that are unpacked as "
"arguments."
msgstr ":meth:`map`\\과 같지만, *iterable* 의 요소가 인자로 언팩 될 이터러블일 것으로 기대합니다."

#: ../../library/multiprocessing.rst:2356
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"따라서 *iterable* 이 ``[(1,2), (3, 4)]`` 미면 결과는 ``[func(1,2), func(3,4)]`` 가 "
"됩니다."

#: ../../library/multiprocessing.rst:2363
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over"
" *iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
":meth:`starmap` 과 :meth:`map_async` 의 조합으로 이터러블의 *iterable* 을 이터레이트하고 "
"이터러블을 언팩해서 *func* 를 호출합니다. 결과 객체를 반환합니다."

#: ../../library/multiprocessing.rst:2371
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "더는 작업이 풀에 제출되지 않도록 합니다. 모든 작업이 완료되면 작업자 프로세스가 종료됩니다."

#: ../../library/multiprocessing.rst:2376
msgid ""
"Stops the worker processes immediately without completing outstanding "
"work.  When the pool object is garbage collected :meth:`terminate` will "
"be called immediately."
msgstr ""
"계류 중인 작업을 완료하지 않고 즉시 작업자 프로세스를 중지합니다. 풀 객체가 가비지 수집될 때 :meth:`terminate` 가"
" 즉시 호출됩니다."

#: ../../library/multiprocessing.rst:2382
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or "
":meth:`terminate` before using :meth:`join`."
msgstr ""
"작업자 프로세스가 종료될 때까지 기다립니다. :meth:`join` 호출 전에 반드시 :meth:`close` 나 "
":meth:`terminate`\\를 호출해야합니다 ."

#: ../../library/multiprocessing.rst:2385
msgid ""
"Pool objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the"
" pool object, and :meth:`~contextmanager.__exit__` calls "
":meth:`terminate`."
msgstr ""
"풀 객체는 이제 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보십시오. "
":meth:`~contextmanager.__enter__` 는 풀 객체를 반환하고, "
":meth:`~contextmanager.__exit__` 는 :meth:`terminate`\\를 호출합니다."

#: ../../library/multiprocessing.rst:2393
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and "
":meth:`Pool.map_async`."
msgstr ":meth:`Pool.apply_async`\\와 :meth:`Pool.map_async` 에 의해 반환되는 결과의 클래스."

#: ../../library/multiprocessing.rst:2398
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then "
":exc:`multiprocessing.TimeoutError` is raised.  If the remote call raised"
" an exception then that exception will be reraised by :meth:`get`."
msgstr ""
"결과가 도착할 때 반환합니다. *timeout* 이 ``None`` 이 아니고 결과가 *timeout* 초 내에 도착하지 않으면 "
":exc:`multiprocessing.TimeoutError` 가 발생합니다. 원격 호출이 예외를 발생시키는 경우 해당 예외는 "
":meth:`get` 에 의해 다시 발생합니다."

#: ../../library/multiprocessing.rst:2405
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "결과가 사용 가능할 때까지 또는 *timeout* 초가 지날 때까지 기다립니다."

#: ../../library/multiprocessing.rst:2409
msgid "Return whether the call has completed."
msgstr "호출이 완료했는지를 돌려줍니다."

#: ../../library/multiprocessing.rst:2413
msgid ""
"Return whether the call completed without raising an exception.  Will "
"raise :exc:`ValueError` if the result is not ready."
msgstr "예외를 발생시키지 않고 호출이 완료되었는지를 돌려줍니다. 결과가 준비되지 않았으면 :exc:`ValueError` 를 발생시킵니다."

#: ../../library/multiprocessing.rst:2416
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of "
":exc:`AssertionError`."
msgstr "결과가 준비되지 않았으면, :exc:`AssertionError` 대신 :exc:`ValueError`\\가 발생합니다."

#: ../../library/multiprocessing.rst:2420
msgid "The following example demonstrates the use of a pool::"
msgstr "다음 예제는 풀 사용 방법을 보여줍니다.::"

#: ../../library/multiprocessing.rst:2422
msgid ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" "
"asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., "
"81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises "
"multiprocessing.TimeoutError"
msgstr ""

#: ../../library/multiprocessing.rst:2447
msgid "Listeners and Clients"
msgstr "리스너와 클라이언트"

#: ../../library/multiprocessing.rst:2452
msgid ""
"Usually message passing between processes is done using queues or by "
"using :class:`~Connection` objects returned by "
":func:`~multiprocessing.Pipe`."
msgstr ""
"보통 프로세스 간 메시지 전달은 큐를 사용하거나 :func:`~multiprocessing.Pipe` 가 반환하는 "
":class:`~Connection` 객체를 사용하여 수행됩니다."

#: ../../library/multiprocessing.rst:2456
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"그러나, :mod:`multiprocessing.connection` 모듈은 약간의 추가적인 유연성을 허용합니다. 기본적으로 "
"소켓이나 윈도우의 이름있는 파이프를 다루는 높은 수준의 메시지 지향 API를 제공합니다. 또한 :mod:`hmac` 모듈을 사용한 "
"*다이제스트 인증* 과 다중 연결을 동시에 폴링하는 방법을 지원합니다."

#: ../../library/multiprocessing.rst:2465
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "무작위로 생성된 메시지를 연결의 다른 쪽 끝으로 보내고 응답을 기다립니다."

#: ../../library/multiprocessing.rst:2468
msgid ""
"If the reply matches the digest of the message using *authkey* as the key"
" then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"응답이 *authkey* 를 키로 사용하는 메시지의 다이제스트와 일치하면 환영 메시지가 연결의 다른 끝으로 전송됩니다. 그렇지 "
"않으면 :exc:`~multiprocessing.AuthenticationError` 가 발생합니다."

#: ../../library/multiprocessing.rst:2474
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as"
" the key, and then send the digest back."
msgstr "메시지를 수신하고, *authkey* 를 키로 사용하여 메시지의 다이제스트를 계산한 다음, 다이제스트를 다시 보냅니다."

#: ../../library/multiprocessing.rst:2477
msgid ""
"If a welcome message is not received, then "
":exc:`~multiprocessing.AuthenticationError` is raised."
msgstr "환영 메시지가 수신되지 않으면, :exc:`~multiprocessing.AuthenticationError` 가 발생합니다."

#: ../../library/multiprocessing.rst:2482
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr "주소 *address* 를 사용하는 리스너에 대한 연결을 설정하려고 시도하고, :class:`~Connection`\\을 반환합니다."

#: ../../library/multiprocessing.rst:2485
msgid ""
"The type of the connection is determined by *family* argument, but this "
"can generally be omitted since it can usually be inferred from the format"
" of *address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"연결 유형은 *family* 인자에 의해 결정되지만, 일반적으로 *address* 형식에서 유추 할 수 있으므로 일반적으로 생략 할"
" 수 있습니다. (:ref:`multiprocessing-address-formats`\\를 참조하세요)"

#: ../../library/multiprocessing.rst:2489
#: ../../library/multiprocessing.rst:2524
#, fuzzy
msgid ""
"If *authkey* is given and not ``None``, it should be a byte string and "
"will be used as the secret key for an HMAC-based authentication "
"challenge. No authentication is done if *authkey* is ``None``. "
":exc:`~multiprocessing.AuthenticationError` is raised if authentication "
"fails. See :ref:`multiprocessing-auth-keys`."
msgstr ""
"*authkey* 가 주어지고 None이 아니라면, 바이트열이어야 하며 HMAC 기반 인증 챌린지의 비밀 키로 사용됩니다. "
"*authkey* 가 None이면, 인증이 수행되지 않습니다. 인증이 실패하면 "
":exc:`~multiprocessing.AuthenticationError` 가 발생합니다. :ref"
":`multiprocessing-auth-keys`\\를 보세요."

#: ../../library/multiprocessing.rst:2497
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' "
"for connections."
msgstr "연결을 '리스닝' 하는 바인드된 소켓이나 윈도우의 이름있는 파이프에 대한 래퍼입니다."

#: ../../library/multiprocessing.rst:2500
msgid ""
"*address* is the address to be used by the bound socket or named pipe of "
"the listener object."
msgstr "*address* 는 리스너 객체의 바인드된 소켓이나 이름있는 파이프가 사용할 주소입니다."

#: ../../library/multiprocessing.rst:2505
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable"
" end point on Windows. If you require a connectable end-point, you should"
" use '127.0.0.1'."
msgstr ""
"주소가 '0.0.0.0' 인 경우, 주소는 윈도우에서 연결 가능한 끝점이 아닙니다. 연결할 수 있는 끝점이 필요한 경우, "
"'127.0.0.1'\\을 사용해야 합니다."

#: ../../library/multiprocessing.rst:2509
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one "
"of the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a "
"Unix domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of "
"these only the first is guaranteed to be available.  If *family* is "
"``None`` then the family is inferred from the format of *address*.  If "
"*address* is also ``None`` then a default is chosen.  This default is the"
" family which is assumed to be the fastest available.  See :ref"
":`multiprocessing-address-formats`.  Note that if *family* is "
"``'AF_UNIX'`` and address is ``None`` then the socket will be created in "
"a private temporary directory created using :func:`tempfile.mkstemp`."
msgstr ""
"*family* 는 사용할 소켓(또는 이름있는 파이프)의 유형입니다. 문자열 ``'AF_INET'`` (TCP 소켓), "
"``'AF_UNIX'`` (유닉스 도메인 소켓), ``'AF_PIPE'`` (윈도우 이름있는 파이프) 중 하나일 수 있습니다. 이 "
"중 오직 첫 번째 것만 항상 사용할 수 있음이 보장됩니다. *family* 가 ``None`` 이면, *address* 의 "
"형식으로부터 유추됩니다. *address* 역시 ``None`` 이면, 기본값이 선택됩니다. 이 기본값은 사용 가능한 것 중 가장 "
"빠른 것으로 기대되는 것입니다. :ref:`multiprocessing-address-formats`\\를 참조하세요. "
"*family* 가 ``'AF_UNIX'`` 이고 주소가 ``None`` 이면, 소켓은 :func:`tempfile.mkstemp`"
" 를 사용하여 만들어진 비공개 임시 디렉터리에 생성됩니다."

#: ../../library/multiprocessing.rst:2520
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is "
"passed to the :meth:`~socket.socket.listen` method of the socket once it "
"has been bound."
msgstr ""
"리스너 객체가 소켓을 사용하면, *backlog* (기본적으로 1) 는 소켓이 바인드되면 소켓의 "
":meth:`~socket.socket.listen` 메서드에 전달됩니다."

#: ../../library/multiprocessing.rst:2532
msgid ""
"Accept a connection on the bound socket or named pipe of the listener "
"object and return a :class:`~Connection` object. If authentication is "
"attempted and fails, then :exc:`~multiprocessing.AuthenticationError` is "
"raised."
msgstr ""
"리스너 객체의 바인드된 소켓 또는 이름있는 파이프에 대한 연결을 수락하고 :class:`~Connection` 객체를 반환합니다. "
"인증이 시도되고 실패하면 :exc:`~multiprocessing.AuthenticationError` 가 발생합니다."

#: ../../library/multiprocessing.rst:2539
msgid ""
"Close the bound socket or named pipe of the listener object.  This is "
"called automatically when the listener is garbage collected.  However it "
"is advisable to call it explicitly."
msgstr ""
"리스너 객체의 바운드된 소켓 또는 이름있는 파이프를 닫습니다. 리스너가 가비지 수집될 때 자동으로 호출됩니다. 그러나 명시적으로 "
"호출하는 것이 좋습니다."

#: ../../library/multiprocessing.rst:2543
msgid "Listener objects have the following read-only properties:"
msgstr "리스너 객체는 다음과 같은 읽기 전용 프로퍼티를 가집니다:"

#: ../../library/multiprocessing.rst:2547
msgid "The address which is being used by the Listener object."
msgstr "리스너 객체에서 사용 중인 주소."

#: ../../library/multiprocessing.rst:2551
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "마지막으로 수락한 연결이 온 주소. 없으면 ``None`` 입니다."

#: ../../library/multiprocessing.rst:2554
msgid ""
"Listener objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the"
" listener object, and :meth:`~contextmanager.__exit__` calls "
":meth:`close`."
msgstr ""
"리스너 객체는 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보세요. "
":meth:`~contextmanager.__enter__` 는 리스너 객체를 반환하고, "
":meth:`~contextmanager.__exit__` 는 :meth:`close`\\를 호출합니다."

#: ../../library/multiprocessing.rst:2561
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those"
" objects in *object_list* which are ready.  If *timeout* is a float then "
"the call blocks for at most that many seconds.  If *timeout* is ``None`` "
"then it will block for an unlimited period. A negative timeout is "
"equivalent to a zero timeout."
msgstr ""
"*object_list* 에 있는 객체가 준비될 때까지 기다립니다. *object_list* 에 있는 객체 중 준비된 것들의 "
"리스트를 반환합니다. *timeout* 이 float면, 호출이 최대 지정된 초만큼 블록 됩니다. *timeout* 이 "
"``None`` 이면, 시간제한 없이 블록 됩니다. 음수 timeout은 0과 같습니다."

#: ../../library/multiprocessing.rst:2567
#, fuzzy
msgid "For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr "유닉스와 윈도우에서 모두, *object_list* 에 등장할 수 있는 객체는 다음과 같습니다."

#: ../../library/multiprocessing.rst:2570
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "읽기 가능한 :class:`~multiprocessing.connection.Connection` 객체;"

#: ../../library/multiprocessing.rst:2571
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "연결되고 읽기 가능한 :class:`socket.socket` 객체; 또는"

#: ../../library/multiprocessing.rst:2572
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a "
":class:`~multiprocessing.Process` object."
msgstr ""
":class:`~multiprocessing.Process` 객체의 "
":attr:`~multiprocessing.Process.sentinel` 어트리뷰트."

#: ../../library/multiprocessing.rst:2575
msgid ""
"A connection or socket object is ready when there is data available to be"
" read from it, or the other end has been closed."
msgstr "연결이나 소켓 객체는 읽을 수 있는 데이터가 있거나 반대편 끝이 닫히면 준비가 됩니다."

#: ../../library/multiprocessing.rst:2578
#, fuzzy
msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent "
"``select.select(object_list, [], [], timeout)``.  The difference is that,"
" if :func:`select.select` is interrupted by a signal, it can raise "
":exc:`OSError` with an error number of ``EINTR``, whereas :func:`wait` "
"will not."
msgstr ""
"**유닉스**: ``wait(object_list, timeout)`` 은 ``select.select(object_list, "
"[], [], timeout)``\\과 거의 동등합니다. 차이점은, :func:`select.select` 가 시그널에 의해 "
"인터럽트 되면, 에러 번호 ``EINTR`` 로 :exc:`OSError` 를 일으키지만, :func:`wait` 는 예외를 "
"일으키지 않는다는 것입니다."

#: ../../library/multiprocessing.rst:2584
#, fuzzy
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle "
"which is waitable (according to the definition used by the documentation "
"of the Win32 function ``WaitForMultipleObjects()``) or it can be an "
"object with a :meth:`~io.IOBase.fileno` method which returns a socket "
"handle or pipe handle.  (Note that pipe handles and socket handles are "
"**not** waitable handles.)"
msgstr ""
"**윈도우**: *object_list* 의 항목은 (Win32 함수 ``WaitForMultipleObjects()`` 의 "
"설명서에서 사용된 정의에 따라) 대기 가능한 정수 핸들이거나, 소켓 핸들이나 파이프 핸들을 반환하는 :meth:`fileno` "
"메서드가 있는 개체입니다. (파이프 핸들과 소켓 핸들은 대기 가능한 핸들이 **아님** 에 유의하십시오.)"

#: ../../library/multiprocessing.rst:2594
msgid "**Examples**"
msgstr "**예제**"

#: ../../library/multiprocessing.rst:2596
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and"
" sends some data to the client::"
msgstr ""
"다음 서버 코드는 인증 키로 ``'secret password'`` 를 사용하는 리스너를 만듭니다. 그런 다음 연결을 기다리고 어떤"
" 데이터를 클라이언트로 보냅니다.::"

#: ../../library/multiprocessing.rst:2600
msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"
msgstr ""

#: ../../library/multiprocessing.rst:2615
msgid ""
"The following code connects to the server and receives some data from the"
" server::"
msgstr "다음 코드는 서버에 연결하고 서버로부터 어떤 데이터를 받습니다::"

#: ../../library/multiprocessing.rst:2618
msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, "
"0])"
msgstr ""

#: ../../library/multiprocessing.rst:2632
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait "
"for messages from multiple processes at once::"
msgstr ""
"다음 코드는 :func:`~multiprocessing.connection.wait` 을 사용하여 여러 프로세스로부터 오는 메시지를"
" 한 번에 기다립니다::"

#: ../../library/multiprocessing.rst:2635
msgid ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # We close the writable end of the pipe now to be sure that\n"
"        # p is the only process which owns a handle for it.  This\n"
"        # ensures that when p closes its handle for the writable end,\n"
"        # wait() will promptly report the readable end as being ready.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"
msgstr ""

#: ../../library/multiprocessing.rst:2670
msgid "Address Formats"
msgstr "주소 형식"

#: ../../library/multiprocessing.rst:2672
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` "
"where *hostname* is a string and *port* is an integer."
msgstr ""
"``'AF_INET'`` 주소는 ``(hostname, port)`` 형식의 튜플입니다. *hostname* 은 문자열이고, "
"*port* 는 정수입니다."

#: ../../library/multiprocessing.rst:2675
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` 주소는 파일 시스템의 파일 이름을 나타내는 문자열입니다."

#: ../../library/multiprocessing.rst:2678
#, fuzzy, python-brace-format
msgid ""
"An ``'AF_PIPE'`` address is a string of the form "
":samp:`r'\\\\\\\\\\\\.\\\\pipe\\\\\\\\{PipeName}'`.  To use "
":func:`Client` to connect to a named pipe on a remote computer called "
"*ServerName* one should use an address of the form "
":samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"``'AF_PIPE'`` 주소는 형식 :samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'` 의 문자열입니다."
" :func:`Client` 를 사용하여 *ServerName* 이라는 원격 컴퓨터의 이름있는 파이프에 연결하려면, 대신 "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` 형식의 주소를 사용해야 합니다."

#: ../../library/multiprocessing.rst:2683
msgid ""
"Note that any string beginning with two backslashes is assumed by default"
" to be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr "두 개의 역 슬래시로 시작하는 문자열은 기본적으로 ``'AF_UNIX'`` 주소가 아니라 ``'AF_PIPE'`` 주소로 간주합니다."

#: ../../library/multiprocessing.rst:2690
msgid "Authentication keys"
msgstr "인증 키"

#: ../../library/multiprocessing.rst:2692
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data "
"received is automatically unpickled. Unfortunately unpickling data from "
"an untrusted source is a security risk. Therefore :class:`Listener` and "
":func:`Client` use the :mod:`hmac` module to provide digest "
"authentication."
msgstr ""
":meth:`Connection.recv <Connection.recv>` 를 사용할 때, 수신된 데이터는 자동으로 언 피클 "
"됩니다. 안타깝게도, 신뢰할 수 없는 출처의 데이터를 언 피클 하는 것은 보안상의 위험입니다. 때문에 "
":class:`Listener`\\와 :func:`Client` 는 :mod:`hmac` 모듈을 사용하여 다이제스트 인증을 "
"제공합니다."

#: ../../library/multiprocessing.rst:2698
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof "
"that the other knows the authentication key.  (Demonstrating that both "
"ends are using the same key does **not** involve sending the key over the"
" connection.)"
msgstr ""
"인증 키는 암호로 여겨질 수 있는 바이트열입니다: 일단 연결이 이루어지면 양 끝은 다른 쪽이 인증 키를 알고 있음을 증명하도록 "
"요구합니다. (양쪽 끝이 같은 키를 사용하고 있음을 증명하는 데는 연결을 통해 키를 보내는 것을 수반하지 **않습니다**.)"

#: ../../library/multiprocessing.rst:2704
msgid ""
"If authentication is requested but no authentication key is specified "
"then the return value of ``current_process().authkey`` is used (see "
":class:`~multiprocessing.Process`).  This value will be automatically "
"inherited by any :class:`~multiprocessing.Process` object that the "
"current process creates. This means that (by default) all processes of a "
"multi-process program will share a single authentication key which can be"
" used when setting up connections between themselves."
msgstr ""
"인증이 요청되었지만 인증 키가 지정되지 않으면, ``current_process().authkey`` 의 반환 값이 사용됩니다 "
"(:class:`~multiprocessing.Process` 를 보세요). 이 값은 현재 프로세스가 생성하는 "
":class:`~multiprocessing.Process` 객체에 의해 자동으로 상속됩니다. 이것은 다중 프로세스 프로그램의 모든"
" 프로세스는 (기본적으로) 자신들 간의 연결을 설정할 때 사용할 수 있는 하나의 인증 키를 공유한다는 것을 뜻합니다."

#: ../../library/multiprocessing.rst:2712
msgid ""
"Suitable authentication keys can also be generated by using "
":func:`os.urandom`."
msgstr "적절한 인증 키는 :func:`os.urandom` 을 사용하여 생성할 수도 있습니다."

#: ../../library/multiprocessing.rst:2716
msgid "Logging"
msgstr "로깅"

#: ../../library/multiprocessing.rst:2718
msgid ""
"Some support for logging is available.  Note, however, that the "
":mod:`logging` package does not use process shared locks so it is "
"possible (depending on the handler type) for messages from different "
"processes to get mixed up."
msgstr ""
"로깅에 대한 일부 지원이 제공됩니다. 그러나, :mod:`logging` 패키지는 프로세스 공유 록을 사용하지 않으므로 (처리기형에"
" 따라) 다른 프로세스의 메시지가 뒤섞일 가능성이 있습니다."

#: ../../library/multiprocessing.rst:2725
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new "
"one will be created."
msgstr ":mod:`multiprocessing`\\에서 사용되는 로거를 반환합니다. 필요하다면, 새로운 것이 만들어집니다."

#: ../../library/multiprocessing.rst:2728
#, fuzzy
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default "
"propagate to the root logger."
msgstr ""
"로거가 처음 생성되면 수준 :data:`logging.NOTSET` 을 가지며 기본 처리기가 없습니다. 이 로거로 보낸 메시지는 "
"기본적으로 루트 로거에 전파되지 않습니다."

#: ../../library/multiprocessing.rst:2732
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not"
" be inherited."
msgstr "윈도우에서 자식 프로세스는 부모 프로세스의 로거의 수준만 상속받습니다 -- 그 밖의 다른 로거 사용자 지정은 상속되지 않습니다."

#: ../../library/multiprocessing.rst:2739
#, fuzzy, python-format
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends"
" output to :data:`sys.stderr` using format "
"``'[%(levelname)s/%(processName)s] %(message)s'``. You can modify "
"``levelname`` of the logger by passing a ``level`` argument."
msgstr ""
"이 함수는 :func:`get_logger`\\를 호출하지만, get_logger에 의해 생성된 로거를 반환하는 것 외에, "
"``'[%(levelname)s/%(processName)s] %(message)s'`` 포맷을 사용하여 "
":data:`sys.stderr` 에 출력을 전송하는 처리기를 추가합니다."

#: ../../library/multiprocessing.rst:2745
msgid "Below is an example session with logging turned on::"
msgstr "다음은 로깅이 켜져 있는 예제 세션입니다::"

#: ../../library/multiprocessing.rst:2747
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""

#: ../../library/multiprocessing.rst:2760
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "로깅 수준의 전체 표는 :mod:`logging` 모듈을 참조하십시오."

#: ../../library/multiprocessing.rst:2764
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` 모듈"

#: ../../library/multiprocessing.rst:2769
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing`"
" but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` 는 :mod:`multiprocessing` 의 API를 복제하지만 "
":mod:`threading` 모듈에 대한 래퍼일 뿐입니다."

#: ../../library/multiprocessing.rst:2774
msgid ""
"In particular, the ``Pool`` function provided by "
":mod:`multiprocessing.dummy` returns an instance of :class:`ThreadPool`, "
"which is a subclass of :class:`Pool` that supports all the same method "
"calls but uses a pool of worker threads rather than worker processes."
msgstr ""
"특히, :mod:`multiprocessing.dummy`\\에서 제공하는 ``Pool`` 함수는 같은 메서드 호출을 모두 "
"지원하지만, 작업자 프로세스가 아닌 작업자 스레드 풀을 사용하는 :class:`Pool`\\의 서브 클래스인 "
":class:`ThreadPool`\\의 인스턴스를 반환합니다."

#: ../../library/multiprocessing.rst:2782
msgid ""
"A thread pool object which controls a pool of worker threads to which "
"jobs can be submitted.  :class:`ThreadPool` instances are fully interface"
" compatible with :class:`Pool` instances, and their resources must also "
"be properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and "
":meth:`~multiprocessing.pool.Pool.terminate` manually."
msgstr ""
"작업을 제출할 수 있는 작업자 스레드 풀을 제어하는 스레드 풀 객체. :class:`ThreadPool` 인스턴스는 "
":class:`Pool` 인스턴스와 완전히 호환되며, 해당 리소스는 컨텍스트 관리자로 풀을 사용하거나 "
":meth:`~multiprocessing.pool.Pool.close`\\와 "
":meth:`~multiprocessing.pool.Pool.terminate`\\를 수동으로 호출하여 적절하게 관리해야 합니다."

#: ../../library/multiprocessing.rst:2789
#, fuzzy
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is "
"used."
msgstr ""
"*processes* 는 사용할 작업자 스레드 수입니다. *processes* 가 ``None`` 이면 "
":func:`os.cpu_count` 에 의해 반환되는 수가 사용됩니다."

#: ../../library/multiprocessing.rst:2795
msgid "Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ":class:`Pool`\\과 달리, *maxtasksperchild*\\와 *context*\\는 제공할 수 없습니다."

#: ../../library/multiprocessing.rst:2799
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which "
"is designed around a pool of processes and predates the introduction of "
"the :class:`concurrent.futures` module.  As such, it inherits some "
"operations that don't make sense for a pool backed by threads, and it has"
" its own type for representing the status of asynchronous jobs, "
":class:`AsyncResult`, that is not understood by any other libraries."
msgstr ""
":class:`ThreadPool`\\은 프로세스 풀을 중심으로 설계되고 :class:`concurrent.futures` 모듈 "
"도입 이전에 설계된 :class:`Pool`\\과 같은 인터페이스를 공유합니다. 따라서, 스레드가 지원하는 풀에 적합하지 않은 일부"
" 연산을 상속하고, 비동기 작업의 상태를 나타내는 자체 형 :class:`AsyncResult`\\를 가지고 있는데 다른 "
"라이브러리에서는 이해하지 못합니다."

#: ../../library/multiprocessing.rst:2806
msgid ""
"Users should generally prefer to use "
":class:`concurrent.futures.ThreadPoolExecutor`, which has a simpler "
"interface that was designed around threads from the start, and which "
"returns :class:`concurrent.futures.Future` instances that are compatible "
"with many other libraries, including :mod:`asyncio`."
msgstr ""
"사용자는 일반적으로 처음부터 스레드를 중심으로 설계되고 :mod:`asyncio`\\를 포함한 다른 많은 라이브러리와 호환되는 "
":class:`concurrent.futures.Future` 인스턴스를 반환하는 더 간단한 인터페이스를 가진 "
":class:`concurrent.futures.ThreadPoolExecutor`\\를 사용하는 것을 선호해야 합니다."

#: ../../library/multiprocessing.rst:2816
msgid "Programming guidelines"
msgstr "프로그래밍 지침"

#: ../../library/multiprocessing.rst:2818
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ":mod:`multiprocessing`\\를 사용할 때 준수해야 할 지침과 관용구가 있습니다."

#: ../../library/multiprocessing.rst:2823
msgid "All start methods"
msgstr "모든 시작 방법"

#: ../../library/multiprocessing.rst:2825
msgid "The following applies to all start methods."
msgstr "다음은 모든 시작 방법에 적용됩니다."

#: ../../library/multiprocessing.rst:2827
msgid "Avoid shared state"
msgstr "공유 상태를 피하세요"

#: ../../library/multiprocessing.rst:2829
msgid ""
"As far as possible one should try to avoid shifting large amounts of data"
" between processes."
msgstr "가능한 한 프로세스 간에 많은 양의 데이터가 이동하지 않도록 해야 합니다."

#: ../../library/multiprocessing.rst:2832
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr "저수준 동기화 프리미티브를 사용하기보다, 프로세스 간 통신을 위해 큐나 파이프를 사용하는 것이 아마도 최선입니다."

#: ../../library/multiprocessing.rst:2836
msgid "Picklability"
msgstr "피클 가능성"

#: ../../library/multiprocessing.rst:2838
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "프락시 메서드에 대한 인자가 피클 가능한지 확인하십시오."

#: ../../library/multiprocessing.rst:2840
msgid "Thread safety of proxies"
msgstr "프락시의 스레드 안전성"

#: ../../library/multiprocessing.rst:2842
msgid ""
"Do not use a proxy object from more than one thread unless you protect it"
" with a lock."
msgstr "록으로 보호하지 않는 한 둘 이상의 스레드에서 프락시 객체를 사용하지 마십시오."

#: ../../library/multiprocessing.rst:2845
msgid ""
"(There is never a problem with different processes using the *same* "
"proxy.)"
msgstr "(여러 프로세스가 *같은* 프락시를 사용하는 문제는 존재하지 않습니다.)"

#: ../../library/multiprocessing.rst:2847
msgid "Joining zombie processes"
msgstr "좀비 프로세스 조인하기"

#: ../../library/multiprocessing.rst:2849
#, fuzzy
msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all "
"completed processes which have not yet been joined will be joined.  Also "
"calling a finished process's :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` will join the process.  Even so it is"
" probably good practice to explicitly join all the processes that you "
"start."
msgstr ""
"유닉스에서 프로세스가 끝났지만 조인되지 않으면 좀비가 됩니다. 너무 많이 생기지는 않아야 하는데, 새로운 프로세스가 시작될 때마다 "
"(또는 :func:`~multiprocessing.active_children` 이 호출 되면) 아직 조인되지 않은 모든 완료된 "
"프로세스를 조인하기 때문입니다. 또한, 완료된 프로세스의 :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` 를 호출하면 조인합니다. 그렇다고 하더라도 여러분이 시작시키는 모든"
" 프로세스를 명시적으로 조인하는 것이 좋습니다."

#: ../../library/multiprocessing.rst:2857
msgid "Better to inherit than pickle/unpickle"
msgstr "피클/언 피클보다 상속하는 것이 더 좋습니다."

#: ../../library/multiprocessing.rst:2859
msgid ""
"When using the *spawn* or *forkserver* start methods many types from "
":mod:`multiprocessing` need to be picklable so that child processes can "
"use them.  However, one should generally avoid sending shared objects to "
"other processes using pipes or queues. Instead you should arrange the "
"program so that a process which needs access to a shared resource created"
" elsewhere can inherit it from an ancestor process."
msgstr ""
"*spawn* 이나 *forkserver* 시작 방법을 사용할 때, :mod:`multiprocessing` 의 여러 형은 자식 "
"프로세스가 사용할 수 있도록 피클 가능할 필요가 있습니다. 그러나, 일반적으로 파이프나 큐를 사용하여 공유 객체를 다른 프로세스로 "
"보내는 것을 피해야 합니다. 대신 다른 곳에 만들어진 공유 자원에 접근해야 하는 프로세스가 조상 프로세스에서 그것들을 상속받을 수 "
"있도록 프로그램을 배치해야 합니다."

#: ../../library/multiprocessing.rst:2867
msgid "Avoid terminating processes"
msgstr "프로세스 강제 종료를 피하세요"

#: ../../library/multiprocessing.rst:2869
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as"
" locks, semaphores, pipes and queues) currently being used by the process"
" to become broken or unavailable to other processes."
msgstr ""
":meth:`Process.terminate <multiprocessing.Process.terminate>` 메서드를 사용해서 "
"프로세스를 정지시키는 것은, 그 프로세스가 현재 사용하고 있는 공유 자원(가령 록, 세마포어, 파이프, 큐)을 손상하거나 다른 "
"프로세스에서 사용할 수 없게 만들 수 있습니다."

#: ../../library/multiprocessing.rst:2875
msgid ""
"Therefore it is probably best to only consider using "
":meth:`Process.terminate <multiprocessing.Process.terminate>` on "
"processes which never use any shared resources."
msgstr ""
"따라서, 아마도 어떤 공유 자원도 사용하지 않는 프로세스에만 :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` 사용을 고려하는 것이 최선일 겁니다."

#: ../../library/multiprocessing.rst:2879
msgid "Joining processes that use queues"
msgstr "큐를 사용하는 프로세스 조인하기"

#: ../../library/multiprocessing.rst:2881
msgid ""
"Bear in mind that a process that has put items in a queue will wait "
"before terminating until all the buffered items are fed by the \"feeder\""
" thread to the underlying pipe.  (The child process can call the "
":meth:`Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` method of the queue to avoid "
"this behaviour.)"
msgstr ""
"큐에 항목을 넣은 프로세스는 종료되기 전에 버퍼링 된 모든 항목이 \"피더\" 스레드에 의해 하부 파이프로 공급될 때까지 "
"대기합니다. (자식 프로세스는 :meth:`Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` 메서드를 호출해서 이 동작을 회피할 수 있습니다.)"

#: ../../library/multiprocessing.rst:2887
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before "
"the process is joined.  Otherwise you cannot be sure that processes which"
" have put items on the queue will terminate.  Remember also that non-"
"daemonic processes will be joined automatically."
msgstr ""
"이것은, 큐를 사용할 때마다 큐에 넣은 모든 항목이 결국 프로세스가 조인되기 전에 제거되도록 해야 함을 의미합니다. 그렇지 않으면 "
"큐에 항목을 넣은 프로세스가 종료되리라고 보장할 수 없습니다. 데몬이 아닌 프로세스가 자동으로 조인된다는 것도 기억하세요."

#: ../../library/multiprocessing.rst:2893
msgid "An example which will deadlock is the following::"
msgstr "교착 상태에 빠지는 예는 다음과 같습니다::"

#: ../../library/multiprocessing.rst:2895
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""

#: ../../library/multiprocessing.rst:2907
msgid ""
"A fix here would be to swap the last two lines (or simply remove the "
"``p.join()`` line)."
msgstr "이 문제를 고치는 방법은 마지막 두 줄의 순서를 바꾸는 것입니다 (또는 간단히 ``p.join()`` 줄을 지우는 것입니다)."

#: ../../library/multiprocessing.rst:2910
msgid "Explicitly pass resources to child processes"
msgstr "자식 프로세스에 자원을 명시적으로 전달하세요."

#: ../../library/multiprocessing.rst:2912
#, fuzzy
msgid ""
"On POSIX using the *fork* start method, a child process can make use of a"
" shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the "
"constructor for the child process."
msgstr ""
"*fork* 시작 방법을 사용하는 유닉스에서, 자식 프로세스는 전역 자원을 사용하여 부모 프로세스에서 생성된 공유 자원을 사용할 수"
" 있습니다. 그러나 자식 프로세스의 생성자에 객체를 인자로 전달하는 것이 더 좋습니다."

#: ../../library/multiprocessing.rst:2917
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process "
"is still alive the object will not be garbage collected in the parent "
"process.  This might be important if some resource is freed when the "
"object is garbage collected in the parent process."
msgstr ""
"윈도우 및 다른 시작 방법과 (잠재적으로) 호환될 수 있는 코드를 만드는 것 외에도, 이것은 자식 프로세스가 아직 살아있는 동안 "
"객체가 부모 프로세스에서 가비지 수집되지 않음을 보장합니다. 부모 프로세스에서 그 객체가 가비지 수집될 때 일부 자원이 해제되면 "
"이것이 중요 할 수 있습니다."

#: ../../library/multiprocessing.rst:2924
msgid "So for instance ::"
msgstr "그래서 예를 들면 ::"

#: ../../library/multiprocessing.rst:2926
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""

#: ../../library/multiprocessing.rst:2936
msgid "should be rewritten as ::"
msgstr "는 다음과 같이 다시 써야 합니다 ::"

#: ../../library/multiprocessing.rst:2938
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""

#: ../../library/multiprocessing.rst:2948
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ":data:`sys.stdin` 을 \"파일류 객체\"로 교체할 때 조심하세요"

#: ../../library/multiprocessing.rst:2950
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing`\\은 원래 무조건 다음과 같이 호출했습니다 ::"

#: ../../library/multiprocessing.rst:2952
msgid "os.close(sys.stdin.fileno())"
msgstr ""

#: ../../library/multiprocessing.rst:2954
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this "
"resulted in issues with processes-in-processes. This has been changed "
"to::"
msgstr ""
":meth:`multiprocessing.Process._bootstrap` 메서드에서 하는 작업입니다 --- 이것은 손자 "
"프로세스와 관련된 문제로 이어졌습니다. 이것은 다음과 같이 변경되었습니다::"

#: ../../library/multiprocessing.rst:2957
msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"
msgstr ""

#: ../../library/multiprocessing.rst:2960
#, fuzzy
msgid ""
"Which solves the fundamental issue of processes colliding with each other"
" resulting in a bad file descriptor error, but introduces a potential "
"danger to applications which replace :func:`sys.stdin` with a \"file-like"
" object\" with output buffering.  This danger is that if multiple "
"processes call :meth:`~io.IOBase.close` on this file-like object, it "
"could result in the same data being flushed to the object multiple times,"
" resulting in corruption."
msgstr ""
"이것은 프로세스가 서로 충돌해서 파일 기술자 에러를 일으키는 근본적인 문제를 해결하지만, :func:`sys.stdin` 을 출력 "
"버퍼링을 사용하는 \"파일과 유사한 객체\"로 교체하는 응용 프로그램에 잠재적 위험을 만듭니다. 이 위험은, 다중 프로세스가 이 "
"파일류 객체에 :meth:`~io.IOBase.close()`\\를 호출하면, 같은 데이터가 객체에 여러 번 플러시 되도록 만들어 "
"손상을 일으킬 수 있다는 것입니다."

#: ../../library/multiprocessing.rst:2967
msgid ""
"If you write a file-like object and implement your own caching, you can "
"make it fork-safe by storing the pid whenever you append to the cache, "
"and discarding the cache when the pid changes. For example::"
msgstr ""
"파일류 객체를 작성하고 여러분 자신의 캐싱을 구현하면, 캐시에 추가할 때마다 pid를 저장하고, pid가 변경되면 캐시를 버려서 "
"포크에 안전하게 만들 수 있습니다. 예를 들면::"

#: ../../library/multiprocessing.rst:2971
msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""

#: ../../library/multiprocessing.rst:2979
msgid "For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "자세한 내용은 :issue:`5155`, :issue:`5313` 및 :issue:`5331`\\을 참조하십시오."

#: ../../library/multiprocessing.rst:2982
msgid "The *spawn* and *forkserver* start methods"
msgstr "*spawn* 과 *forkserver* 시작 방법"

#: ../../library/multiprocessing.rst:2984
#, fuzzy
msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr "*fork* 시작 방법에는 적용되지 않는 몇 가지 추가 제한 사항이 있습니다."

#: ../../library/multiprocessing.rst:2987
msgid "More picklability"
msgstr "더 높은 피클 가능성"

#: ../../library/multiprocessing.rst:2989
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. "
"Also, if you subclass :class:`~multiprocessing.Process` then make sure "
"that instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
":meth:`Process.__init__` 에 대한 모든 인자가 피클 가능한지 확인하십시오. 또한, "
":class:`~multiprocessing.Process` 의 서브 클래스를 만들면, :meth:`Process.start "
"<multiprocessing.Process.start>` 메서드가 호출될 때 그 인스턴스가 피클 가능하도록 해야 합니다."

#: ../../library/multiprocessing.rst:2994
msgid "Global variables"
msgstr "전역 변수"

#: ../../library/multiprocessing.rst:2996
msgid ""
"Bear in mind that if code run in a child process tries to access a global"
" variable, then the value it sees (if any) may not be the same as the "
"value in the parent process at the time that :meth:`Process.start "
"<multiprocessing.Process.start>` was called."
msgstr ""
"자식 프로세스에서 실행되는 코드가 전역 변수에 접근하려고 시도하면, 그 값은 (있는 경우) :meth:`Process.start "
"<multiprocessing.Process.start>` 가 호출되는 시점의 부모 프로세스의 값과 같지 않을 수 있습니다."

#: ../../library/multiprocessing.rst:3001
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "하지만, 모듈 수준의 상수인 전역 변수는 문제가 되지 않습니다."

#: ../../library/multiprocessing.rst:3006
msgid "Safe importing of main module"
msgstr "메인 모듈의 안전한 임포트"

#: ../../library/multiprocessing.rst:3008
#, fuzzy
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a "
"new process)."
msgstr ""
"메인 모듈이 의도하지 않은 부작용(가령 새 프로세스 시작)을 일으키지 않고 새 파이썬 인터프리터가 안전하게 임포트 할 수 있는지 "
"확인하십시오."

#: ../../library/multiprocessing.rst:3012
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"예를 들어, *spawn* 또는 *forkserver* 시작 방법을 사용해서 다음 모듈을 실행하면 "
":exc:`RuntimeError` 로 실패합니다::"

#: ../../library/multiprocessing.rst:3016
msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""

#: ../../library/multiprocessing.rst:3024
msgid ""
"Instead one should protect the \"entry point\" of the program by using "
"``if __name__ == '__main__':`` as follows::"
msgstr ""
"대신 다음과 같이 ``if __name__ == '__main__':`` 을 사용하여 프로그램의 \"진입 지점\"을 보호해야 "
"합니다::"

#: ../../library/multiprocessing.rst:3027
msgid ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""

#: ../../library/multiprocessing.rst:3038
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "(``freeze_support()`` 줄은 프로그램이 프로즌 되지 않고 정상적으로 실행될 경우 생략될 수 있습니다.)"

#: ../../library/multiprocessing.rst:3041
msgid ""
"This allows the newly spawned Python interpreter to safely import the "
"module and then run the module's ``foo()`` function."
msgstr "이것은 새로 스폰 된 파이썬 인터프리터가 모듈을 안전하게 임포트 한 다음 모듈의 ``foo()`` 함수를 실행할 수 있게 해줍니다."

#: ../../library/multiprocessing.rst:3044
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "메인 모듈에서 풀이나 관리자를 만들면 비슷한 제한이 적용됩니다."

#: ../../library/multiprocessing.rst:3051
msgid "Examples"
msgstr "예제"

#: ../../library/multiprocessing.rst:3053
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr "사용자 정의된 관리자와 프락시를 만들고 사용하는 방법에 대한 시연:"

#: ../../library/multiprocessing.rst:3055
#, python-format
msgid ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make "
"proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../library/multiprocessing.rst:3059
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ":class:`~multiprocessing.pool.Pool` 사용하기:"

#: ../../library/multiprocessing.rst:3061
#, python-format
msgid ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till "
"complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from "
"pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')"
"\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from "
"list(pool.imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from "
"IMapIterator.next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../library/multiprocessing.rst:3065
msgid ""
"An example showing how to use queues to feed tasks to a collection of "
"worker processes and collect the results:"
msgstr "큐를 사용하여 작업을 작업자 프로세스 집단에 제공하고 결과를 수집하는 방법을 보여주는 예:"

#: ../../library/multiprocessing.rst:3068
#, python-format
msgid ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, "
"freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#~ msgid "Queues are thread and process safe."
#~ msgstr "큐는 스레드와 프로세스에 안전합니다."

#~ msgid "By default, no arguments are passed to *target*."
#~ msgstr "기본적으로, 아무 인자도 *target* 에 전달되지 않습니다."

#~ msgid "May raise :exc:`NotImplementedError`."
#~ msgstr ":exc:`NotImplementedError`\\를 일으킬 수 있습니다."

#~ msgid ":func:`os.cpu_count`"
#~ msgstr ":func:`os.cpu_count`"

#~ msgid ""
#~ "Set the method which should be "
#~ "used to start child processes. *method*"
#~ " can be ``'fork'``, ``'spawn'`` or "
#~ "``'forkserver'``."
#~ msgstr ""
#~ "자식 프로세스를 시작하는 데 사용해야 하는 방법을 "
#~ "설정합니다. *method* 는 ``'fork'``, ``'spawn'`` "
#~ "또는 ``'forkserver'`` 일 수 있습니다."

#~ msgid ""
#~ "If the SIGINT signal generated by "
#~ ":kbd:`Ctrl-C` arrives while the main "
#~ "thread is blocked by a call to "
#~ ":meth:`BoundedSemaphore.acquire`, :meth:`Lock.acquire`, "
#~ ":meth:`RLock.acquire`, :meth:`Semaphore.acquire`, "
#~ ":meth:`Condition.acquire` or :meth:`Condition.wait` "
#~ "then the call will be immediately "
#~ "interrupted and :exc:`KeyboardInterrupt` will "
#~ "be raised."
#~ msgstr ""
#~ "메인 스레드가 :meth:`BoundedSemaphore.acquire`, "
#~ ":meth:`Lock.acquire`, :meth:`RLock.acquire`, "
#~ ":meth:`Semaphore.acquire`, :meth:`Condition.acquire` 또는"
#~ " :meth:`Condition.wait` 호출 때문에 블록 된 "
#~ "동안, :kbd:`Ctrl-C` 에 의해 만들어진 SIGINT "
#~ "시그널이 도착하면, 호출이 즉시 중단되고 "
#~ ":exc:`KeyboardInterrupt` 가 발생합니다."

#~ msgid ""
#~ "This differs from the behaviour of "
#~ ":mod:`threading` where SIGINT will be "
#~ "ignored while the equivalent blocking "
#~ "calls are in progress."
#~ msgstr "이것은 :mod:`threading` 의 동작과는 다른데, SIGINT는 해당 블로킹 호출이 진행되는 동안 무시됩니다."

#~ msgid "*context*"
#~ msgstr "*context*"

