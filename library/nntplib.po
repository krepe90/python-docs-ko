# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/nntplib.rst:2
#, fuzzy
msgid ":mod:`!nntplib` --- NNTP protocol client"
msgstr ":mod:`nntplib` --- NNTP 프로토콜 클라이언트"

#: ../../library/nntplib.rst:10
msgid ""
"This module is no longer part of the Python standard library. It was "
":ref:`removed in Python 3.13 <whatsnew313-pep594>` after being deprecated"
" in Python 3.11.  The removal was decided in :pep:`594`."
msgstr ""

#: ../../library/nntplib.rst:14
msgid ""
"The last version of Python that provided the :mod:`!nntplib` module was "
"`Python 3.12 <https://docs.python.org/3.12/library/nntplib.html>`_."
msgstr ""

#~ msgid "**Source code:** :source:`Lib/nntplib.py`"
#~ msgstr "**소스 코드:** :source:`Lib/nntplib.py`"

#~ msgid ""
#~ "This module defines the class "
#~ ":class:`NNTP` which implements the client "
#~ "side of the Network News Transfer "
#~ "Protocol.  It can be used to "
#~ "implement a news reader or poster, "
#~ "or automated news processors.  It is "
#~ "compatible with :rfc:`3977` as well as"
#~ " the older :rfc:`977` and :rfc:`2980`."
#~ msgstr ""
#~ "이 모듈은 네트워크 뉴스 전송 프로토콜(Network News"
#~ " Transfer Protocol)의 클라이언트 측을 구현하는 "
#~ "클래스 :class:`NNTP`\\를 정의합니다. 뉴스 리더나 포스터"
#~ " 또는 자동화된 뉴스 프로세서를 구현하는 데 사용할"
#~ " 수 있습니다. 이전 :rfc:`977`\\과 :rfc:`2980`\\뿐만"
#~ " 아니라 :rfc:`3977`\\과 호환됩니다."

#~ msgid ""
#~ "Here are two small examples of how"
#~ " it can be used.  To list some"
#~ " statistics about a newsgroup and "
#~ "print the subjects of the last 10"
#~ " articles::"
#~ msgstr ""
#~ "다음은 사용 방법에 대한 두 가지 작은 예입니다."
#~ " 뉴스 그룹에 대한 일부 통계를 나열하고 최근 "
#~ "10개 기사의 제목(subject)을 인쇄하려면 이렇게 합니다::"

#~ msgid ""
#~ "To post an article from a binary"
#~ " file (this assumes that the article"
#~ " has valid headers, and that you "
#~ "have right to post on the "
#~ "particular newsgroup)::"
#~ msgstr "바이너리 파일에서 기사를 게시하려면 (기사에 유효한 헤더가 있고 특정 뉴스 그룹에 게시할 권한이 있다고 가정합니다)::"

#~ msgid "The module itself defines the following classes:"
#~ msgstr "모듈 자체는 다음 클래스를 정의합니다:"

#~ msgid ""
#~ "Return a new :class:`NNTP` object, "
#~ "representing a connection to the NNTP"
#~ " server running on host *host*, "
#~ "listening at port *port*. An optional"
#~ " *timeout* can be specified for the"
#~ " socket connection. If the optional "
#~ "*user* and *password* are provided, or"
#~ " if suitable credentials are present "
#~ "in :file:`/.netrc` and the optional flag"
#~ " *usenetrc* is true, the ``AUTHINFO "
#~ "USER`` and ``AUTHINFO PASS`` commands "
#~ "are used to identify and authenticate"
#~ " the user to the server.  If "
#~ "the optional flag *readermode* is true,"
#~ " then a ``mode reader`` command is"
#~ " sent before authentication is performed."
#~ "  Reader mode is sometimes necessary "
#~ "if you are connecting to an NNTP"
#~ " server on the local machine and "
#~ "intend to call reader-specific commands,"
#~ " such as ``group``.  If you get "
#~ "unexpected :exc:`NNTPPermanentError`\\ s, you "
#~ "might need to set *readermode*. The "
#~ ":class:`NNTP` class supports the "
#~ ":keyword:`with` statement to unconditionally "
#~ "consume :exc:`OSError` exceptions and to "
#~ "close the NNTP connection when done, "
#~ "e.g.:"
#~ msgstr ""
#~ "*port* 포트에서 리스닝하면서 호스트 *host*\\에서 실행 "
#~ "중인 NNTP 서버에 대한 연결을 나타내는 새 "
#~ ":class:`NNTP` 객체를 반환합니다. 소켓 연결에 대한 "
#~ "선택적 *timeout*\\을 지정할 수 있습니다. 선택적 "
#~ "*user*\\와 *password*\\가 제공되거나, :file:`/.netrc`\\에"
#~ " 적합한 자격 증명이 존재하고 선택적 플래그 "
#~ "*usenetrc*\\가 참이면, ``AUTHINFO USER``\\와 "
#~ "``AUTHINFO PASS`` 명령이 서버에 사용자를 식별하고 "
#~ "인증하는 데 사용됩니다. 선택적 플래그 *readermode*\\가"
#~ " 참이면, 인증이 수행되기 전에 ``mode reader`` "
#~ "명령이 전송됩니다. 로컬 시스템의 NNTP 서버에 연결하고"
#~ " ``group``\\과 같은 리더 특정 명령을 호출하려면 "
#~ "때때로 리더 모드가 필요합니다. 예기치 않은 "
#~ ":exc:`NNTPPermanentError` 가 발생하면, *readermode*\\를"
#~ " 설정해야 합니다. :class:`NNTP` 클래스는 "
#~ ":exc:`OSError` 예외를 조건 없이 소비하고 완료 시"
#~ " NNTP 연결을 닫는 :keyword:`with` 문을 "
#~ "지원합니다. 예를 들면:"

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``nntplib.connect`` with arguments ``self``, "
#~ "``host``, ``port``."
#~ msgstr ""
#~ "인자 ``self``, ``host``, ``port``\\로 :ref:`감사"
#~ " 이벤트 <auditing>` ``nntplib.connect``\\를 발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``nntplib.putline`` with arguments ``self``, "
#~ "``line``."
#~ msgstr ""
#~ "인자 ``self``, ``line``\\으로 :ref:`감사 이벤트 "
#~ "<auditing>` ``nntplib.putline``\\을 발생시킵니다."

#~ msgid ""
#~ "All commands will raise an "
#~ ":ref:`auditing event <auditing>` ``nntplib.putline``"
#~ " with arguments ``self`` and ``line``, "
#~ "where ``line`` is the bytes about "
#~ "to be sent to the remote host."
#~ msgstr ""
#~ "모든 명령은 ``self``\\와 ``line`` 인자로 :ref:`감사"
#~ " 이벤트 <auditing>` ``nntplib.putline``\\을 발생시킵니다."
#~ " 여기서 ``line``\\은 원격 호스트로 전송될 바이트열입니다."

#~ msgid "*usenetrc* is now ``False`` by default."
#~ msgstr "*usenetrc*\\는 이제 기본적으로 ``False``\\입니다."

#~ msgid "Support for the :keyword:`with` statement was added."
#~ msgstr ":keyword:`with` 문에 대한 지원이 추가되었습니다."

#~ msgid ""
#~ "If the *timeout* parameter is set "
#~ "to be zero, it will raise a "
#~ ":class:`ValueError` to prevent the creation"
#~ " of a non-blocking socket."
#~ msgstr ""
#~ "*timeout* 매개 변수가 0으로 설정되면, 비 블로킹"
#~ " 소켓이 만들어지지 않도록 :class:`ValueError`\\가 "
#~ "발생합니다."

#~ msgid ""
#~ "Return a new :class:`NNTP_SSL` object, "
#~ "representing an encrypted connection to "
#~ "the NNTP server running on host "
#~ "*host*, listening at port *port*.  "
#~ ":class:`NNTP_SSL` objects have the same "
#~ "methods as :class:`NNTP` objects.  If "
#~ "*port* is omitted, port 563 (NNTPS) "
#~ "is used. *ssl_context* is also optional,"
#~ " and is a :class:`~ssl.SSLContext` object."
#~ " Please read :ref:`ssl-security` for "
#~ "best practices. All other parameters "
#~ "behave the same as for :class:`NNTP`."
#~ msgstr ""
#~ "*port* 포트에서 리스닝하면서 *host* 호스트에서 실행 "
#~ "중인 NNTP 서버에 대한 암호화 된 연결을 "
#~ "나타내는 새 :class:`NNTP_SSL` 객체를 반환합니다. "
#~ ":class:`NNTP_SSL` 객체는 :class:`NNTP` 객체와 같은 "
#~ "메서드를 갖습니다. *port*\\를 생략하면, 포트 "
#~ "563(NNTPS)이 사용됩니다. *ssl_context*\\도 선택적이며, "
#~ ":class:`~ssl.SSLContext` 객체입니다. 모범 사례를 보려면 "
#~ ":ref:`ssl-security`\\을 읽으십시오. 다른 모든 매개"
#~ " 변수는 :class:`NNTP`\\와 같게 작동합니다."

#~ msgid ""
#~ "Note that SSL-on-563 is discouraged "
#~ "per :rfc:`4642`, in favor of STARTTLS"
#~ " as described below.  However, some "
#~ "servers only support the former."
#~ msgstr ""
#~ "SSL-on-563은 :rfc:`4642`\\에 따라 권장되지 않고,"
#~ " 아래 설명된 STARTTLS로 대체합니다. 그러나, 일부 "
#~ "서버는 전자만 지원합니다."

#~ msgid ""
#~ "The class now supports hostname check"
#~ " with :attr:`ssl.SSLContext.check_hostname` and "
#~ "*Server Name Indication* (see "
#~ ":data:`ssl.HAS_SNI`)."
#~ msgstr ""
#~ "이 클래스는 이제 :attr:`ssl.SSLContext.check_hostname`\\과"
#~ " *서버 이름 표시(Server Name "
#~ "Indication)*\\(:data:`ssl.HAS_SNI`\\를 참조하십시오)로 호스트명 "
#~ "확인을 지원합니다."

#~ msgid ""
#~ "Derived from the standard exception "
#~ ":exc:`Exception`, this is the base class"
#~ " for all exceptions raised by the "
#~ ":mod:`nntplib` module.  Instances of this "
#~ "class have the following attribute:"
#~ msgstr ""
#~ "표준 예외 :exc:`Exception`\\에서 파생된 이 클래스는"
#~ " :mod:`nntplib` 모듈이 발생시키는 모든 예외의 베이스"
#~ " 클래스입니다. 이 클래스의 인스턴스는 다음과 같은 "
#~ "어트리뷰트를 갖습니다:"

#~ msgid "The response of the server if available, as a :class:`str` object."
#~ msgstr "사용할 수 있으면 서버의 응답, :class:`str` 객체."

#~ msgid "Exception raised when an unexpected reply is received from the server."
#~ msgstr "서버에서 예기치 않은 응답이 수신될 때 발생하는 예외."

#~ msgid ""
#~ "Exception raised when a response code"
#~ " in the range 400--499 is "
#~ "received."
#~ msgstr "400--499 범위의 응답 코드가 수신될 때 발생하는 예외."

#~ msgid ""
#~ "Exception raised when a response code"
#~ " in the range 500--599 is "
#~ "received."
#~ msgstr "500--599 범위의 응답 코드가 수신될 때 발생하는 예외."

#~ msgid ""
#~ "Exception raised when a reply is "
#~ "received from the server that does "
#~ "not begin with a digit in the "
#~ "range 1--5."
#~ msgstr "서버에서 1--5 범위의 숫자로 시작하지 않는 응답을 수신할 때 발생하는 예외."

#~ msgid "Exception raised when there is some error in the response data."
#~ msgstr "응답 데이터에 에러가 있을 때 발생하는 예외."

#~ msgid "NNTP Objects"
#~ msgstr "NNTP 객체"

#~ msgid ""
#~ "When connected, :class:`NNTP` and "
#~ ":class:`NNTP_SSL` objects support the "
#~ "following methods and attributes."
#~ msgstr ""
#~ "연결되었을 때, :class:`NNTP`\\와 :class:`NNTP_SSL` "
#~ "객체는 다음과 같은 메서드와 어트리뷰트를 지원합니다."

#~ msgid "Attributes"
#~ msgstr "어트리뷰트"

#~ msgid ""
#~ "An integer representing the version of"
#~ " the NNTP protocol supported by the"
#~ " server.  In practice, this should be"
#~ " ``2`` for servers advertising :rfc:`3977`"
#~ " compliance and ``1`` for others."
#~ msgstr ""
#~ "서버에서 지원하는 NNTP 프로토콜 버전을 나타내는 정수."
#~ " 실제로, :rfc:`3977` 준수를 광고하는 서버의 경우 "
#~ "``2``\\이고 다른 서버의 경우 ``1``\\이어야 합니다."

#~ msgid ""
#~ "A string describing the software name"
#~ " and version of the NNTP server, "
#~ "or :const:`None` if not advertised by"
#~ " the server."
#~ msgstr "NNTP 서버의 소프트웨어 이름과 버전을 기술하는 문자열, 또는 서버가 알리지 않으면 :const:`None`."

#~ msgid "Methods"
#~ msgstr "메서드"

#~ msgid ""
#~ "The *response* that is returned as "
#~ "the first item in the return tuple"
#~ " of almost all methods is the "
#~ "server's response: a string beginning "
#~ "with a three-digit code.  If the"
#~ " server's response indicates an error, "
#~ "the method raises one of the above"
#~ " exceptions."
#~ msgstr ""
#~ "거의 모든 메서드의 반환 튜플에서 첫 번째 항목으로"
#~ " 반환되는 *response*\\는 서버의 응답입니다: 3 자리"
#~ " 숫자 코드로 시작하는 문자열. 서버의 응답이 에러를"
#~ " 가리키면, 메서드는 위의 예외 중 하나를 발생시킵니다."

#~ msgid ""
#~ "Many of the following methods take "
#~ "an optional keyword-only argument "
#~ "*file*. When the *file* argument is "
#~ "supplied, it must be either a "
#~ ":term:`file object` opened for binary "
#~ "writing, or the name of an on-"
#~ "disk file to be written to. The"
#~ " method will then write any data "
#~ "returned by the server (except for "
#~ "the response line and the terminating"
#~ " dot) to the file; any list of"
#~ " lines, tuples or objects that the"
#~ " method normally returns will be "
#~ "empty."
#~ msgstr ""
#~ "다음 메서드 중 다수는 선택적 키워드 전용 인자"
#~ " *file*\\을 취합니다. *file* 인자가 제공될 때,"
#~ " 바이너리 쓰기를 위해 열린 :term:`파일 객체 "
#~ "<file object>`\\이거나, 기록될 디스크에 있는 파일의 "
#~ "이름이어야 합니다. 그러면 메서드는 서버가 반환한 모든 "
#~ "데이터를 (응답 줄과 종료 점을 제외하고) 파일에 "
#~ "기록합니다; 메서드가 일반적으로 반환하는 줄, 튜플 또는"
#~ " 객체의 리스트는 비어 있습니다."

#~ msgid ""
#~ "Many of the following methods have "
#~ "been reworked and fixed, which makes "
#~ "them incompatible with their 3.1 "
#~ "counterparts."
#~ msgstr "다음 메서드 중 많은 부분이 재작업 및 수정되어, 3.1과 호환되지 않습니다."

#~ msgid ""
#~ "Send a ``QUIT`` command and close "
#~ "the connection.  Once this method has"
#~ " been called, no other methods of "
#~ "the NNTP object should be called."
#~ msgstr ""
#~ "``QUIT`` 명령을 전송하고 연결을 닫습니다. 일단, 이"
#~ " 메서드가 호출되면, NNTP 객체의 다른 메서드를 "
#~ "호출하면 안 됩니다."

#~ msgid ""
#~ "Return the welcome message sent by "
#~ "the server in reply to the initial"
#~ " connection.  (This message sometimes "
#~ "contains disclaimers or help information "
#~ "that may be relevant to the user.)"
#~ msgstr ""
#~ "초기 연결에 대한 응답으로 서버에서 보낸 환영 "
#~ "메시지를 반환합니다. (이 메시지에는 때때로 사용자와 관련될"
#~ " 수 있는 고지 사항이나 도움말 정보가 포함되어 "
#~ "있습니다.)"

#~ msgid ""
#~ "Return the :rfc:`3977` capabilities advertised"
#~ " by the server, as a :class:`dict`"
#~ " instance mapping capability names to "
#~ "(possibly empty) lists of values. On "
#~ "legacy servers which don't understand "
#~ "the ``CAPABILITIES`` command, an empty "
#~ "dictionary is returned instead."
#~ msgstr ""
#~ "서버가 광고한 :rfc:`3977` 기능을 기능 이름을 값"
#~ " 리스트(비어있을 수 있습니다)로 매핑하는 :class:`dict` "
#~ "인스턴스로 반환합니다. ``CAPABILITIES`` 명령을 이해하지 "
#~ "못하는 레거시 서버에서는, 빈 딕셔너리가 대신 반환됩니다."

#~ msgid ""
#~ "Send ``AUTHINFO`` commands with the user"
#~ " name and password.  If *user* and"
#~ " *password* are ``None`` and *usenetrc* "
#~ "is true, credentials from ``~/.netrc`` "
#~ "will be used if possible."
#~ msgstr ""
#~ "사용자 이름과 비밀번호로 ``AUTHINFO`` 명령을 보냅니다. "
#~ "*user*\\와 *password*\\가 ``None``\\이고 *usenetrc*\\가"
#~ " 참이면 가능한 경우 ``~/.netrc``\\의 자격 증명이"
#~ " 사용됩니다."

#~ msgid ""
#~ "Unless intentionally delayed, login is "
#~ "normally performed during the :class:`NNTP`"
#~ " object initialization and separately "
#~ "calling this function is unnecessary.  "
#~ "To force authentication to be delayed,"
#~ " you must not set *user* or "
#~ "*password* when creating the object, and"
#~ " must set *usenetrc* to False."
#~ msgstr ""
#~ "의도적으로 지연되지 않는 한, 일반적으로 :class:`NNTP` "
#~ "객체 초기화 중에 로그인이 수행되며 별도로 이 "
#~ "함수를 호출할 필요가 없습니다. 인증을 강제로 지연시키려면,"
#~ " 객체를 만들 때 *user*\\나 *password*\\를 "
#~ "설정하지 말고, *usenetrc*\\를 False로 설정해야 합니다."

#~ msgid ""
#~ "Send a ``STARTTLS`` command.  This will"
#~ " enable encryption on the NNTP "
#~ "connection.  The *context* argument is "
#~ "optional and should be a "
#~ ":class:`ssl.SSLContext` object.  Please read "
#~ ":ref:`ssl-security` for best practices."
#~ msgstr ""
#~ "``STARTTLS`` 명령을 보냅니다. 이것은 NNTP 연결에서 "
#~ "암호화를 활성화합니다. *context* 인자는 선택적이며 "
#~ ":class:`ssl.SSLContext` 객체여야 합니다. 모범 사례를 "
#~ "보려면 :ref:`ssl-security`\\을 읽으십시오."

#~ msgid ""
#~ "Note that this may not be done "
#~ "after authentication information has been "
#~ "transmitted, and authentication occurs by "
#~ "default if possible during a "
#~ ":class:`NNTP` object initialization.  See "
#~ ":meth:`NNTP.login` for information on "
#~ "suppressing this behavior."
#~ msgstr ""
#~ "인증 정보가 전송된 후에는 이 작업이 수행되지 않을"
#~ " 수 있으며, :class:`NNTP` 객체 초기화 중에 "
#~ "가능한 경우 기본적으로 인증이 수행됩니다. 이 동작을 "
#~ "억제하는 것에 대한 정보는 :meth:`NNTP.login`\\을 "
#~ "참조하십시오."

#~ msgid ""
#~ "The method now supports hostname check"
#~ " with :attr:`ssl.SSLContext.check_hostname` and "
#~ "*Server Name Indication* (see "
#~ ":data:`ssl.HAS_SNI`)."
#~ msgstr ""
#~ "이 메서드는 이제 :attr:`ssl.SSLContext.check_hostname`\\과"
#~ " *서버 이름 표시(Server Name "
#~ "Indication)*\\(:data:`ssl.HAS_SNI`\\를 참조하십시오)로 호스트명 "
#~ "확인을 지원합니다."

#~ msgid ""
#~ "Send a ``NEWGROUPS`` command.  The "
#~ "*date* argument should be a "
#~ ":class:`datetime.date` or :class:`datetime.datetime` "
#~ "object. Return a pair ``(response, "
#~ "groups)`` where *groups* is a list "
#~ "representing the groups that are new "
#~ "since the given *date*. If *file* "
#~ "is supplied, though, then *groups* will"
#~ " be empty."
#~ msgstr ""
#~ "``NEWGROUPS`` 명령을 보냅니다. *date* 인자는 "
#~ ":class:`datetime.date`\\나 :class:`datetime.datetime` 객체여야"
#~ " 합니다. ``(response, groups)`` 쌍을 반환합니다. "
#~ "여기서 *groups*\\는 지정된 *date* 이후의 새로운 "
#~ "그룹을 나타내는 리스트입니다. 그러나 *file*\\이 제공되면, "
#~ "*groups*\\는 비어 있습니다."

#~ msgid ""
#~ "Send a ``NEWNEWS`` command.  Here, "
#~ "*group* is a group name or "
#~ "``'*'``, and *date* has the same "
#~ "meaning as for :meth:`newgroups`.  Return "
#~ "a pair ``(response, articles)`` where "
#~ "*articles* is a list of message "
#~ "ids."
#~ msgstr ""
#~ "``NEWNEWS`` 명령을 보냅니다. 여기서 *group*\\은 그룹"
#~ " 이름이나 ``'*'``\\이며, *date*\\는 "
#~ ":meth:`newgroups`\\에서와 같은 의미입니다. ``(response, "
#~ "articles)`` 쌍을 반환합니다. 여기서 *articles*\\는 "
#~ "메시지 id의 리스트입니다."

#~ msgid "This command is frequently disabled by NNTP server administrators."
#~ msgstr "이 명령은 NNTP 서버 관리자가 자주 비활성화합니다."

#~ msgid ""
#~ "Send a ``LIST`` or ``LIST ACTIVE`` "
#~ "command.  Return a pair ``(response, "
#~ "list)`` where *list* is a list of"
#~ " tuples representing all the groups "
#~ "available from this NNTP server, "
#~ "optionally matching the pattern string "
#~ "*group_pattern*.  Each tuple has the "
#~ "form ``(group, last, first, flag)``, "
#~ "where *group* is a group name, "
#~ "*last* and *first* are the last "
#~ "and first article numbers, and *flag*"
#~ " usually takes one of these values:"
#~ msgstr ""
#~ "``LIST``\\나 ``LIST ACTIVE`` 명령을 전송합니다. 쌍"
#~ " ``(response, list)``\\를 반환합니다. 여기서 "
#~ "*list*\\는 이 NNTP 서버에서 사용 가능한 모든"
#~ " 그룹을 나타내는 튜플 리스트이며, 선택적으로 패턴 "
#~ "문자열 *group_pattern*\\과 일치합니다. 각 튜플의 형식은"
#~ " ``(group, last, first, flag)``\\입니다. 여기서"
#~ " *group*\\은 그룹 이름이고 *last*\\와 *first*\\는"
#~ " 마지막과 첫 번째 기사 번호이며, *flag*\\는 "
#~ "일반적으로 다음 값 중 하나를 취합니다:"

#~ msgid "``y``: Local postings and articles from peers are allowed."
#~ msgstr "``y``: 로컬 게시물과 동료의 기사가 허용됩니다."

#~ msgid "``m``: The group is moderated and all postings must be approved."
#~ msgstr "``m``: 그룹이 조정되며 모든 게시가 승인되어야 합니다."

#~ msgid "``n``: No local postings are allowed, only articles from peers."
#~ msgstr "``n``: 로컬 게시물이 허용되지 않으며, 동료의 기사만 허용됩니다."

#~ msgid "``j``: Articles from peers are filed in the junk group instead."
#~ msgstr "``j``: 동료의 기사가 대신 정크 그룹에 보관됩니다."

#~ msgid "``x``: No local postings, and articles from peers are ignored."
#~ msgstr "``x``: 로컬 게시물이 없으며, 동료의 기사는 무시됩니다."

#~ msgid "``=foo.bar``: Articles are filed in the ``foo.bar`` group instead."
#~ msgstr "``=foo.bar``: 기사가 ``foo.bar`` 그룹에 대신 보관됩니다."

#~ msgid ""
#~ "If *flag* has another value, then "
#~ "the status of the newsgroup should "
#~ "be considered unknown."
#~ msgstr "*flag*\\에 다른 값이 있으면, 뉴스 그룹의 상태를 알 수 없는 것으로 간주해야 합니다."

#~ msgid ""
#~ "This command can return very large "
#~ "results, especially if *group_pattern* is "
#~ "not specified.  It is best to "
#~ "cache the results offline unless you "
#~ "really need to refresh them."
#~ msgstr ""
#~ "이 명령은 특히 *group_pattern*\\이 지정되지 않으면 "
#~ "매우 큰 결과를 반환할 수 있습니다. 실제로 새로"
#~ " 고칠 필요가 없으면 결과를 오프라인으로 캐시 하는"
#~ " 것이 가장 좋습니다."

#~ msgid "*group_pattern* was added."
#~ msgstr "*group_pattern*\\이 추가되었습니다."

#~ msgid ""
#~ "Send a ``LIST NEWSGROUPS`` command, "
#~ "where *grouppattern* is a wildmat string"
#~ " as specified in :rfc:`3977` (it's "
#~ "essentially the same as DOS or "
#~ "UNIX shell wildcard strings).  Return a"
#~ " pair ``(response, descriptions)``, where "
#~ "*descriptions* is a dictionary mapping "
#~ "group names to textual descriptions."
#~ msgstr ""
#~ "*grouppattern*\\이 :rfc:`3977`\\에 지정된 와일드 "
#~ "매트(wildmat) 문자열(DOS나 UNIX 셸 와일드카드 문자열과"
#~ " 본질적으로 동일합니다)인, ``LIST NEWSGROUPS`` 명령을 "
#~ "전송합니다. ``(response, descriptions)`` 쌍을 반환합니다."
#~ " 여기서 *descriptions*\\는 그룹 이름을 텍스트 설명에"
#~ " 매핑하는 딕셔너리입니다."

#~ msgid ""
#~ "Get a description for a single "
#~ "group *group*.  If more than one "
#~ "group matches (if 'group' is a "
#~ "real wildmat string), return the first"
#~ " match.   If no group matches, return"
#~ " an empty string."
#~ msgstr ""
#~ "단일 그룹 *group*\\에 대한 설명을 가져옵니다. 둘"
#~ " 이상의 그룹이 일치하면 ('group'이 실제 와일드 "
#~ "매트 문자열이면), 첫 번째 일치를 반환합니다. 일치하는"
#~ " 그룹이 없으면, 빈 문자열을 반환합니다."

#~ msgid ""
#~ "This elides the response code from "
#~ "the server.  If the response code "
#~ "is needed, use :meth:`descriptions`."
#~ msgstr "이것은 서버에서 온 응답 코드를 제거합니다. 응답 코드가 필요하면, :meth:`descriptions`\\를 사용하십시오."

#~ msgid ""
#~ "Send a ``GROUP`` command, where *name*"
#~ " is the group name.  The group "
#~ "is selected as the current group, "
#~ "if it exists.  Return a tuple "
#~ "``(response, count, first, last, name)`` "
#~ "where *count* is the (estimated) number"
#~ " of articles in the group, *first*"
#~ " is the first article number in "
#~ "the group, *last* is the last "
#~ "article number in the group, and "
#~ "*name* is the group name."
#~ msgstr ""
#~ "``GROUP`` 명령을 전송합니다. 여기서 *name*\\은 그룹"
#~ " 이름입니다. 존재하면, 그룹이 현재 그룹으로 선택됩니다. "
#~ "튜플 ``(response, count, first, last, "
#~ "name)``\\을 반환합니다. 여기서 *count*\\는 그룹의 "
#~ "(추정된) 기사 수, *first*\\는 그룹의 첫 번째"
#~ " 기사 번호, *last*\\는 그룹의 마지막 기사 "
#~ "번호, *name*\\은 그룹 이름입니다."

#~ msgid ""
#~ "Send an ``OVER`` command, or an "
#~ "``XOVER`` command on legacy servers. "
#~ "*message_spec* can be either a string"
#~ " representing a message id, or a "
#~ "``(first, last)`` tuple of numbers "
#~ "indicating a range of articles in "
#~ "the current group, or a ``(first, "
#~ "None)`` tuple indicating a range of "
#~ "articles starting from *first* to the"
#~ " last article in the current group,"
#~ " or :const:`None` to select the "
#~ "current article in the current group."
#~ msgstr ""
#~ "``OVER`` 명령이나 레거시 서버에서는 ``XOVER`` 명령을"
#~ " 보냅니다. *message_spec*\\은 메시지 id를 나타내는 "
#~ "문자열이거나, 현재 그룹의 기사 범위를 나타내는 "
#~ "``(first, last)`` 튜플, 또는 현재 그룹의 "
#~ "*first*\\에서 마지막 기사까지의 기사 범위를 나타내는 "
#~ "``(first, None)`` 튜플이거나, 또는 현재 그룹에서 "
#~ "현재 기사를 선택하는 :const:`None`\\입니다."

#~ msgid ""
#~ "Return a pair ``(response, overviews)``.  "
#~ "*overviews* is a list of "
#~ "``(article_number, overview)`` tuples, one for"
#~ " each article selected by *message_spec*."
#~ "  Each *overview* is a dictionary "
#~ "with the same number of items, but"
#~ " this number depends on the server."
#~ "  These items are either message "
#~ "headers (the key is then the "
#~ "lower-cased header name) or metadata "
#~ "items (the key is then the "
#~ "metadata name prepended with ``\":\"``).  "
#~ "The following items are guaranteed to"
#~ " be present by the NNTP "
#~ "specification:"
#~ msgstr ""
#~ "쌍 ``(response, overviews)``\\를 반환합니다. "
#~ "*overviews*\\는 *message_spec*\\으로 선택한 기사마다 하나씩"
#~ " ``(article_number, overview)`` 튜플의 리스트입니다. "
#~ "각 *overview*\\는 같은 수의 항목을 가진 "
#~ "딕셔너리이지만, 이 숫자는 서버에 따라 다릅니다. 이러한"
#~ " 항목은 메시지 헤더(키는 소문자 헤더 이름이 됩니다)나"
#~ " 메타 데이터 항목(키는 ``\":\"``\\이 앞에 붙은 "
#~ "메타 데이터 이름이 됩니다)입니다. 다음 항목은 NNTP"
#~ " 명세에 따라 제공됨이 보장됩니다:"

#~ msgid ""
#~ "the ``subject``, ``from``, ``date``, "
#~ "``message-id`` and ``references`` headers"
#~ msgstr "``subject``, ``from``, ``date``, ``message-id`` 및 ``references`` 헤더"

#~ msgid ""
#~ "the ``:bytes`` metadata: the number of"
#~ " bytes in the entire raw article "
#~ "(including headers and body)"
#~ msgstr "``:bytes`` 메타 데이터: 전체 원본 아티클의 바이트 수 (헤더와 본문을 포함합니다)"

#~ msgid "the ``:lines`` metadata: the number of lines in the article body"
#~ msgstr "``:lines`` 메타 데이터: 기사 본문의 줄 수"

#~ msgid ""
#~ "The value of each item is either"
#~ " a string, or :const:`None` if not"
#~ " present."
#~ msgstr "각 항목의 값은 문자열이거나, 존재하지 않으면 :const:`None`\\입니다."

#~ msgid ""
#~ "It is advisable to use the "
#~ ":func:`decode_header` function on header "
#~ "values when they may contain non-"
#~ "ASCII characters::"
#~ msgstr "비 ASCII 문자를 포함할 수 있는 헤더 값에 :func:`decode_header` 함수를 사용하는 것이 좋습니다::"

#~ msgid ""
#~ "Send a ``HELP`` command.  Return a "
#~ "pair ``(response, list)`` where *list* "
#~ "is a list of help strings."
#~ msgstr ""
#~ "``HELP`` 명령을 보냅니다. *list*\\가 도움말 문자열의"
#~ " 리스트인 ``(response, list)`` 쌍을 반환합니다."

#~ msgid ""
#~ "Send a ``STAT`` command, where "
#~ "*message_spec* is either a message id"
#~ " (enclosed in ``'<'`` and ``'>'``) or"
#~ " an article number in the current "
#~ "group. If *message_spec* is omitted or"
#~ " :const:`None`, the current article in "
#~ "the current group is considered.  Return"
#~ " a triple ``(response, number, id)`` "
#~ "where *number* is the article number "
#~ "and *id* is the message id."
#~ msgstr ""
#~ "``STAT`` 명령을 보냅니다. 여기서 *message_spec*\\은 "
#~ "메시지 id(``'<'``\\과 ``'>'``\\로 감싼)이거나 현재 "
#~ "그룹의 기사 번호입니다. *message_spec*\\이 생략되거나 "
#~ ":const:`None`\\이면, 현재 그룹의 현재 기사가 고려됩니다."
#~ " *number*\\가 기사 번호이고 *id*\\는 메시지 id인"
#~ " 트리플 ``(response, number, id)``\\를 반환합니다."

#~ msgid "Send a ``NEXT`` command.  Return as for :meth:`.stat`."
#~ msgstr "``NEXT`` 명령을 보냅니다. :meth:`.stat`\\과 같은 것을 반환합니다."

#~ msgid "Send a ``LAST`` command.  Return as for :meth:`.stat`."
#~ msgstr "``LAST`` 명령을 보냅니다. :meth:`.stat`\\과 같은 것을 반환합니다."

#~ msgid ""
#~ "Send an ``ARTICLE`` command, where "
#~ "*message_spec* has the same meaning as"
#~ " for :meth:`.stat`.  Return a tuple "
#~ "``(response, info)`` where *info* is a"
#~ " :class:`~collections.namedtuple` with three "
#~ "attributes *number*, *message_id* and *lines*"
#~ " (in that order).  *number* is the"
#~ " article number in the group (or "
#~ "0 if the information is not "
#~ "available), *message_id* the message id "
#~ "as a string, and *lines* a list"
#~ " of lines (without terminating newlines)"
#~ " comprising the raw message including "
#~ "headers and body."
#~ msgstr ""
#~ "``ARTICLE`` 명령을 보냅니다. 여기서 *message_spec*\\은"
#~ " :meth:`.stat`\\에서와 같은 의미입니다. 튜플 "
#~ "``(response, info)``\\를 반환합니다. 여기서 *info*\\는"
#~ " 3개의 어트리뷰트 *number*, *message_id* 및 "
#~ "*lines*\\(순서대로)가 있는 :class:`~collections.namedtuple`\\입니다."
#~ " *number*\\는 그룹의 기사 번호 (또는 정보가 "
#~ "없으면 0), *message_id*\\는 문자열 메시지 id, "
#~ "*lines*\\는 헤더와 본문을 포함하는 원시 메시지를 "
#~ "구성하는 (종료 줄 바꿈 없는) 줄의 리스트입니다."

#~ msgid ""
#~ "Same as :meth:`article()`, but sends a"
#~ " ``HEAD`` command.  The *lines* returned"
#~ " (or written to *file*) will only "
#~ "contain the message headers, not the "
#~ "body."
#~ msgstr ""
#~ ":meth:`article()`\\과 같지만, ``HEAD`` 명령을 보냅니다."
#~ " 반환된 (또는 *file*\\에 기록되는) *lines*\\는 "
#~ "본문이 아닌 메시지 헤더만 포함합니다."

#~ msgid ""
#~ "Same as :meth:`article()`, but sends a"
#~ " ``BODY`` command.  The *lines* returned"
#~ " (or written to *file*) will only "
#~ "contain the message body, not the "
#~ "headers."
#~ msgstr ""
#~ ":meth:`article()`\\과 같지만, ``BODY`` 명령을 보냅니다."
#~ " 반환된 (또는 *file*\\에 기록되는) *lines*\\는 "
#~ "헤더가 아닌 메시지 본문만 포함합니다."

#~ msgid ""
#~ "Post an article using the ``POST`` "
#~ "command.  The *data* argument is either"
#~ " a :term:`file object` opened for "
#~ "binary reading, or any iterable of "
#~ "bytes objects (representing raw lines of"
#~ " the article to be posted).  It "
#~ "should represent a well-formed news "
#~ "article, including the required headers.  "
#~ "The :meth:`post` method automatically escapes"
#~ " lines beginning with ``.`` and "
#~ "appends the termination line."
#~ msgstr ""
#~ "``POST`` 명령을 사용하여 기사를 게시합니다. *data* "
#~ "인자는 바이너리 읽기를 위해 열린 :term:`파일 객체"
#~ " <file object>`, 또는 바이트열 객체의 이터러블(게시할"
#~ " 기사의 원시 줄을 나타냅니다)입니다. 필수 헤더를 "
#~ "포함하여 올바르게 구성된 뉴스 기사를 나타내야 합니다. "
#~ ":meth:`post` 메서드는 ``.``\\으로 시작하는 줄을 자동으로"
#~ " 이스케이프하고 종료 줄을 추가합니다."

#~ msgid ""
#~ "If the method succeeds, the server's "
#~ "response is returned.  If the server "
#~ "refuses posting, a :class:`NNTPReplyError` is"
#~ " raised."
#~ msgstr ""
#~ "메서드가 성공하면, 서버의 응답이 반환됩니다. 서버가 게시를"
#~ " 거부하면, :class:`NNTPReplyError` 가 발생합니다."

#~ msgid ""
#~ "Send an ``IHAVE`` command. *message_id* "
#~ "is the id of the message to "
#~ "send to the server (enclosed in  "
#~ "``'<'`` and ``'>'``).  The *data* "
#~ "parameter and the return value are "
#~ "the same as for :meth:`post()`."
#~ msgstr ""
#~ "``IHAVE`` 명령을 보냅니다. *message_id*\\는 서버로 "
#~ "보낼 메시지의 id입니다 (``'<'``\\과 ``'>'``\\로 "
#~ "감쌉니다). *data* 매개 변수와 반환 값은 "
#~ ":meth:`post()`\\와 같습니다."

#~ msgid ""
#~ "Return a pair ``(response, date)``.  "
#~ "*date* is a :class:`~datetime.datetime` object"
#~ " containing the current date and time"
#~ " of the server."
#~ msgstr ""
#~ "쌍 ``(response, date)``\\를 반환합니다. *date*\\는 "
#~ "서버의 현재 날짜와 시간을 포함하는 "
#~ ":class:`~datetime.datetime` 객체입니다."

#~ msgid "Send a ``SLAVE`` command.  Return the server's *response*."
#~ msgstr "``SLAVE`` 명령을 보냅니다. 서버의 *응답*\\을 반환합니다."

#~ msgid ""
#~ "Set the instance's debugging level.  "
#~ "This controls the amount of debugging"
#~ " output printed.  The default, ``0``, "
#~ "produces no debugging output.  A value"
#~ " of ``1`` produces a moderate amount"
#~ " of debugging output, generally a "
#~ "single line per request or response."
#~ "  A value of ``2`` or higher "
#~ "produces the maximum amount of debugging"
#~ " output, logging each line sent and"
#~ " received on the connection (including "
#~ "message text)."
#~ msgstr ""
#~ "인스턴스의 디버깅 수준을 설정합니다. 인쇄되는 디버깅 출력량을"
#~ " 제어합니다. 기본 ``0``\\은 디버깅 출력을 생성하지 "
#~ "않습니다. ``1`` 값은 요청이나 응답마다 한 줄씩 "
#~ "적당한 양의 디버깅 출력을 생성합니다. ``2`` 이상의"
#~ " 값은 최대량의 디버깅 출력을 생성하여, 연결에서 "
#~ "주고받은 각 줄(메시지 텍스트를 포함합니다)을 로깅 합니다."

#~ msgid ""
#~ "The following are optional NNTP "
#~ "extensions defined in :rfc:`2980`.  Some "
#~ "of them have been superseded by "
#~ "newer commands in :rfc:`3977`."
#~ msgstr ""
#~ "다음은 :rfc:`2980`\\에 정의된 선택적 NNTP 확장입니다."
#~ " 이 중 일부는 :rfc:`3977`\\에서 새로운 명령으로 "
#~ "대체되었습니다."

#~ msgid ""
#~ "Send an ``XHDR`` command.  The *hdr* "
#~ "argument is a header keyword, e.g. "
#~ "``'subject'``.  The *str* argument should "
#~ "have the form ``'first-last'`` where "
#~ "*first* and *last* are the first "
#~ "and last article numbers to search. "
#~ "Return a pair ``(response, list)``, "
#~ "where *list* is a list of pairs"
#~ " ``(id, text)``, where *id* is an "
#~ "article number (as a string) and "
#~ "*text* is the text of the "
#~ "requested header for that article. If"
#~ " the *file* parameter is supplied, "
#~ "then the output of the  ``XHDR`` "
#~ "command is stored in a file.  If"
#~ " *file* is a string, then the "
#~ "method will open a file with that"
#~ " name, write to it  then close "
#~ "it. If *file* is a :term:`file "
#~ "object`, then it will start calling "
#~ ":meth:`write` on it to store the "
#~ "lines of the command output. If "
#~ "*file* is supplied, then the returned"
#~ " *list* is an empty list."
#~ msgstr ""
#~ "``XHDR`` 명령을 보냅니다. *hdr* 인자는 헤더 "
#~ "키워드입니다, 예를 들어 ``'subject'``. *str* 인자는"
#~ " ``'first-last'`` 형식이어야 합니다. 여기서 "
#~ "*first*\\와 *last*\\는 검색할 첫 번째와 마지막 "
#~ "기사 번호입니다. 쌍 ``(response, list)``\\를 "
#~ "반환합니다. 여기서 *list*\\는 쌍 ``(id, text)``\\의"
#~ " 리스이고, *id*\\는 기사 번호(문자열)이고, *text*\\는 "
#~ "해당 기사에 대해 요청된 헤더의 텍스트입니다. *file*"
#~ " 매개 변수가 제공되면, ``XHDR`` 명령의 출력이 "
#~ "파일에 저장됩니다. *file*\\이 문자열이면, 메서드는 해당 "
#~ "이름의 파일을 열고, 쓰고 나서 닫습니다. *file*\\이"
#~ " :term:`파일 객체 <file object>`\\이면 "
#~ ":meth:`write`\\를 호출하여 명령 출력의 줄을 저장합니다."
#~ " *file*\\이 제공되면, 반환된 *list*\\는 빈 "
#~ "리스트입니다."

#~ msgid ""
#~ "Send an ``XOVER`` command.  *start* and"
#~ " *end* are article numbers delimiting "
#~ "the range of articles to select.  "
#~ "The return value is the same of"
#~ " for :meth:`over()`.  It is recommended "
#~ "to use :meth:`over()` instead, since it"
#~ " will automatically use the newer "
#~ "``OVER`` command if available."
#~ msgstr ""
#~ "``XOVER`` 명령을 보냅니다. *start*\\와 *end*\\는 "
#~ "선택할 기사 범위를 정하는 기사 번호입니다. 반환 "
#~ "값은 :meth:`over()`\\와 같습니다. 사용할 수 있으면 "
#~ "최신 ``OVER`` 명령을 자동으로 사용하므로 "
#~ ":meth:`over()`\\를 대신 사용하는 것이 좋습니다."

#~ msgid "Utility functions"
#~ msgstr "유틸리티 함수"

#~ msgid "The module also defines the following utility function:"
#~ msgstr "이 모듈은 다음과 같은 유틸리티 함수도 정의합니다:"

#~ msgid ""
#~ "Decode a header value, un-escaping "
#~ "any escaped non-ASCII characters. "
#~ "*header_str* must be a :class:`str` "
#~ "object.  The unescaped value is "
#~ "returned.  Using this function is "
#~ "recommended to display some headers in"
#~ " a human readable form::"
#~ msgstr ""
#~ "모든 이스케이프 된 비 ASCII 문자를 역 "
#~ "이스케이프 하여, 헤더 값을 디코딩합니다. *header_str*\\은"
#~ " :class:`str` 객체여야 합니다. 이스케이프 처리되지 않은"
#~ " 값이 반환됩니다. 사람이 읽을 수 있는 형식으로 "
#~ "일부 헤더를 표시하려면 이 함수를 사용하는 것이 "
#~ "좋습니다::"

