# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/pickle.rst:2
#, fuzzy
msgid ":mod:`!pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- 파이썬 객체 직렬화"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**소스 코드:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and "
"de-serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a "
":term:`binary file` or :term:`bytes-like object`) is converted back into "
"an object hierarchy.  Pickling (and unpickling) is alternatively known as"
" \"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
":mod:`pickle` 모듈은 파이썬 객체 구조의 직렬화와 역 직렬화를 위한 바이너리 프로토콜을 구현합니다. "
"*\"피클링(pickling)\"*\\은 파이썬 객체 계층 구조가 바이트 스트림으로 변환되는 절차이며, *\"역 "
"피클링(unpickling)\"*\\은 반대 연산으로, (:term:`바이너리 파일 <binary file>` 이나 "
":term:`바이트열류 객체 <bytes-like object>`\\로 부터의) 바이트 스트림을 객체 계층 구조로 복원합니다. "
"피클링(그리고 역 피클링)은 \"직렬화(serialization)\", \"마샬링(marshalling)\" [#]_ 또는 "
"\"평탄화(flattening)\" 라고도 합니다; 그러나, 혼란을 피하고자, 여기에서 사용된 용어는 \"피클링\" 과 \"역 "
"피클링\" 입니다."

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr "``pickle`` 모듈은 **안전하지 않습니다**. 신뢰할 수 있는 데이터만 언 피클 하십시오."

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have "
"come from an untrusted source, or that could have been tampered with."
msgstr ""
"**언 피클 시 임의의 코드를 실행하는** 악의적인 피클 데이터를 구성할 수 있습니다. 신뢰할 수 없는 출처에서 왔거나 변조되었을 "
"수 있는 데이터를 절대로 언 피클 하지 마십시오."

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has "
"not been tampered with."
msgstr "변조되지 않았음을 보장하려면 :mod:`hmac`\\으로 데이터에 서명하는 것을 고려하십시오."

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate "
"if you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"신뢰할 수 없는 데이터를 처리한다면, :mod:`json`\\과 같은 안전한 직렬화 형식이 더 적합 할 수 있습니다. :ref"
":`comparison-with-json`\\를 참조하십시오."

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "다른 파이썬 모듈과의 관계"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "``marshal`` 과의 비교"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, "
"but in general :mod:`pickle` should always be the preferred way to "
"serialize Python objects.  :mod:`marshal` exists primarily to support "
"Python's :file:`.pyc` files."
msgstr ""
"파이썬이 :mod:`marshal` 이라 불리는 좀 더 원시적인 직렬화 모듈을 가지고 있지만, 일반적으로 :mod:`pickle` "
"은 항상 파이썬 객체를 직렬화하기 위해 선호되는 방법이어야 합니다. :mod:`marshal` 은 주로 파이썬의 "
":file:`.pyc` 파일을 지원하기 위해 존재합니다."

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several "
"significant ways:"
msgstr ":mod:`pickle` 모듈은 :mod:`marshal`\\과 몇 가지 중요한 점에서 다릅니다:"

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be "
"serialized again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` 모듈은 이미 직렬화된 객체를 추적하므로 나중에 같은 객체에 대한 참조가 다시 직렬화되지 않습니다. "
":mod:`marshal` 은 이렇게 하지 않습니다."

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  "
"These are not handled by marshal, and in fact, attempting to marshal "
"recursive objects will crash your Python interpreter.  Object sharing "
"happens when there are multiple references to the same object in "
"different places in the object hierarchy being serialized.  :mod:`pickle`"
" stores such objects only once, and ensures that all other references "
"point to the master copy.  Shared objects remain shared, which can be "
"very important for mutable objects."
msgstr ""
"이는 재귀 객체와 객체 공유에 모두 관련이 있습니다. 재귀 객체는 자신에 대한 참조를 포함하는 객체입니다. 이것은 마샬에 의해 "
"처리되지 않으며, 실제로 재귀 객체를 마샬 하려고 하면 파이썬 인터프리터가 충돌합니다. 객체 공유는 직렬화되는 객체 계층의 다른 "
"위치에서 같은 객체에 대한 다중 참조가 있을 때 발생합니다. :mod:`pickle` 은 그러한 객체를 한 번만 저장하고, 다른 "
"모든 참조가 마스터 복사본을 가리키도록 만듭니다. 공유 객체는 공유된 상태로 유지되는데, 가변 객체의 경우 매우 중요할 수 "
"있습니다."

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their"
" instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live "
"in the same module as when the object was stored."
msgstr ""
":mod:`marshal`\\은 사용자 정의 클래스와 인스턴스를 직렬화하는 데 사용할 수 없습니다. :mod:`pickle` 은 "
"클래스 인스턴스를 투명하게 저장하고 복원할 수 있지만, 클래스 정의는 객체를 저장할 때와 같은 모듈에 존재하고 임포트 할 수 있어야"
" 합니다."

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support "
":file:`.pyc` files, the Python implementers reserve the right to change "
"the serialization format in non-backwards compatible ways should the need"
" arise. The :mod:`pickle` serialization format is guaranteed to be "
"backwards compatible across Python releases provided a compatible pickle "
"protocol is chosen and pickling and unpickling code deals with Python 2 "
"to Python 3 type differences if your data is crossing that unique "
"breaking change language boundary."
msgstr ""
":mod:`marshal` 직렬화 형식은 파이썬 버전 간에 이식성이 보장되지 않습니다. 가장 중요한 일은 :file:`.pyc` "
"파일을 지원하는 것이므로, 파이썬 구현자는 필요할 때 직렬화 형식을 과거 호환되지 않는 방식으로 변경할 권리를 갖습니다. "
":mod:`pickle` 직렬화 형식은, 호환성 있는 피클 프로토콜이 선택되고 여러분의 데이터가 파이썬 2와 파이썬 3의 호환되지 "
"않는 언어 경계를 가로지를 때 피클링과 역 피클링 코드가 두 파이썬 형의 차이점을 다루는 한, 파이썬 배포 간의 과거 호환성을 "
"보장합니다."

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "``json`` 과의 비교"

#: ../../library/pickle.rst:92
#, fuzzy
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"pickle 프로토콜과 `JSON (JavaScript Object Notation) <http://json.org>`_ 간에는 "
"근본적인 차이가 있습니다:"

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although "
"most of the time it is then encoded to ``utf-8``), while pickle is a "
"binary serialization format;"
msgstr ""
"JSON은 텍스트 직렬화 형식(유니코드 텍스트를 출력하지만, 대개는 ``utf-8`` 으로 인코딩됩니다)인 반면, pickle은 "
"바이너리 직렬화 형식입니다."

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON은 사람이 읽을 수 있지만, 피클은 그렇지 않습니다."

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, "
"while pickle is Python-specific;"
msgstr "JSON은 상호 운용이 가능하며 파이썬 생태계 외부에서 널리 사용되는 반면, 피클은 파이썬으로만 한정됩니다."

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in "
"types, and no custom classes; pickle can represent an extremely large "
"number of Python types (many of them automatically, by clever usage of "
"Python's introspection facilities; complex cases can be tackled by "
"implementing :ref:`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON은, 기본적으로, 파이썬 내장형 일부만 표시할 수 있으며 사용자 정의 클래스는 표시할 수 없습니다; 피클은 매우 많은 수의 "
"파이썬 형을 나타낼 수 있습니다 (그중 많은 것들은 파이썬의 인트로스펙션 기능을 영리하게 사용하여 자동으로; 복잡한 경우는 "
":ref:`특정 객체 API <pickle-inst>` 를 구현해서 해결할 수 있습니다);"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr "pickle과 달리, 신뢰할 수 없는 JSON의 역 직렬화는 그 자체로 임의 코드 실행 취약점을 만들지는 않습니다."

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` 모듈: JSON 직렬화와 역 직렬화를 가능하게 하는 표준 라이브러리 모듈."

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "데이터 스트림 형식"

#: ../../library/pickle.rst:126
#, fuzzy
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards "
"such as JSON (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
":mod:`pickle` 이 사용하는 데이터 형식은 파이썬에 고유합니다. 이것은 JSON 또는 XDR (포인터 공유를 나타낼 수 "
"없음)과 같은 외부 표준에 의해 부과된 제약이 없다는 장점이 있습니다. 그러나 비 파이썬 프로그램은 피클 된 파이썬 객체를 재구성할"
" 수 없다는 것을 의미합니다."

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact "
"binary representation.  If you need optimal size characteristics, you can"
" efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"기본적으로, :mod:`pickle` 데이터 포맷은 상대적으로 간결한 바이너리 표현을 사용합니다. 최적의 크기 특성이 필요하다면, "
"피클 된 데이터를 효율적으로 :doc:`압축 <archiving>` 할 수 있습니다."

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive"
" comments about opcodes used by pickle protocols."
msgstr ""
"모듈 :mod:`pickletools` 에는 :mod:`pickle` 에 의해 생성된 데이터 스트림을 분석하는 도구가 있습니다. "
":mod:`pickletools` 소스 코드에는 피클 프로토콜에서 사용되는 옵코드(opcode)에 대한 광범위한 주석이 있습니다."

#: ../../library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling."
" The higher the protocol used, the more recent the version of Python "
"needed to read the pickle produced."
msgstr ""
"현재 피클링에 쓸 수 있는 6가지 프로토콜이 있습니다. 사용된 프로토콜이 높을수록, 생성된 피클을 읽으려면 더 최신 파이썬 버전이 "
"필요합니다."

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "프로토콜 버전 0은 최초의 \"사람이 읽을 수 있는\" 프로토콜이며 이전 버전의 파이썬과 과거 호환됩니다."

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "프로토콜 버전 1은 역시 이전 버전의 파이썬과 호환되는 오래된 바이너리 형식입니다."

#: ../../library/pickle.rst:149
#, fuzzy
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer"
" to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"프로토콜 버전 2는 파이썬 2.3에서 소개되었습니다. 그것은 훨씬 더 효율적인 :term:`뉴스타일 클래스 <new-style "
"class>`\\의 피클링을 제공합니다. 프로토콜 2에 의해 개선된 사항에 대한 정보는 :pep:`307`\\을 참조하십시오."

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for "
":class:`bytes` objects and cannot be unpickled by Python 2.x.  This was "
"the default protocol in Python 3.0--3.7."
msgstr ""
"프로토콜 버전 3은 파이썬 3.0에서 추가되었습니다. 명시적으로 :class:`bytes` 객체를 지원하며 파이썬 2.x에서 역 "
"피클 될 수 없습니다. 이것은 파이썬 3.0--3.7에서 기본 프로토콜이었습니다."

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very "
"large objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. "
"Refer to :pep:`3154` for information about improvements brought by "
"protocol 4."
msgstr ""
"프로토콜 버전 4가 파이썬 3.4에 추가되었습니다. 매우 큰 객체, 더 많은 종류의 객체에 대한 피클링, 일부 데이터 형식 최적화에"
" 대한 지원을 추가합니다. 파이썬 3.8부터 이것이 기본 프로토콜입니다. 프로토콜 4에 의해 개선된 사항에 대한 정보는 "
":pep:`3154`\\를 참조하십시오."

#: ../../library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-"
"band data and speedup for in-band data.  Refer to :pep:`574` for "
"information about improvements brought by protocol 5."
msgstr ""
"프로토콜 버전 5는 파이썬 3.8에서 추가되었습니다. 아웃 오브 밴드 데이터에 대한 지원과 인 밴드 데이터에 대한 속도 향상을 "
"추가합니다. 프로토콜 5의 개선 사항에 대한 정보는 :pep:`574`\\를 참조하십시오."

#: ../../library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although "
":mod:`pickle` reads and writes file objects, it does not handle the issue"
" of naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the "
"byte stream into an object with the same internal structure.  Perhaps the"
" most obvious thing to do with these byte streams is to write them onto a"
" file, but it is also conceivable to send them across a network or store "
"them in a database.  The :mod:`shelve` module provides a simple interface"
" to pickle and unpickle objects on DBM-style database files."
msgstr ""
"직렬화는 지속성보다 더 원시적인 개념입니다; :mod:`pickle` 이 파일 객체를 읽거나 쓰기는 하지만, 지속적인 객체의 이름 "
"지정도 (더 복잡한) 지속적인 객체에 대한 동시 액세스 문제도 처리하지 않습니다. :mod:`pickle` 모듈은 복잡한 객체를 "
"바이트 스트림으로 변환할 수 있고 바이트 스트림을 같은 내부 구조를 가진 객체로 변환할 수 있습니다. 아마도 이러한 바이트 "
"스트림으로 할 가장 분명한 작업은 파일에 쓰는 것이겠지만, 네트워크를 통해 보내거나 데이터베이스에 저장하는 것도 고려할 수 "
"있습니다. :mod:`shelve` 모듈은 DBM 스타일의 데이터베이스 파일에 객체를 피클/역 피클 하는 간단한 인터페이스를 "
"제공합니다."

#: ../../library/pickle.rst:181
msgid "Module Interface"
msgstr "모듈 인터페이스"

#: ../../library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the "
":func:`loads` function. However, if you want more control over "
"serialization and de-serialization, you can create a :class:`Pickler` or "
"an :class:`Unpickler` object, respectively."
msgstr ""
"객체 계층 구조를 직렬화하려면, 단순히 :func:`dumps` 함수를 호출하면 됩니다. 마찬가지로, 데이터 스트림을 역 "
"직렬화하려면 :func:`loads` 함수를 호출합니다. 그러나, 직렬화와 역 직렬화에 대한 더 많은 제어를 원하면, 각각 "
":class:`Pickler` 나 :class:`Unpickler` 객체를 만들 수 있습니다."

#: ../../library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` 모듈은 다음과 같은 상수를 제공합니다:"

#: ../../library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions "
":func:`dump` and :func:`dumps` as well as the :class:`Pickler` "
"constructor."
msgstr ""
"정수, 사용 가능한 가장 높은 :ref:`프로토콜 버전 <pickle-protocols>`. 이 값은 함수 "
":func:`dump`\\와 :func:`dumps` 그리고 :class:`Pickler` 생성자에 *protocol* 값으로 "
"전달될 수 있습니다."

#: ../../library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used "
"for pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the "
"default protocol is 4, first introduced in Python 3.4 and incompatible "
"with previous versions."
msgstr ""
"정수, 피클링에 사용되는 기본 :ref:`프로토콜 버전 <pickle-protocols>`. "
":data:`HIGHEST_PROTOCOL` 보다 작을 수 있습니다. 현재 기본 프로토콜은 4인데, 파이썬 3.4에서 처음 "
"소개되었으며 이전 버전과 호환되지 않습니다."

#: ../../library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "기본 프로토콜은 3입니다."

#: ../../library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "기본 프로토콜은 4입니다."

#: ../../library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ":mod:`pickle` 모듈은 피클링 절차를 보다 편리하게 하려고 다음과 같은 함수를 제공합니다:"

#: ../../library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open "
":term:`file object` *file*.  This is equivalent to ``Pickler(file, "
"protocol).dump(obj)``."
msgstr ""
"객체 *obj* 의 피클 된 표현을 열린 :term:`파일 객체 <file object>` *file* 에 씁니다. 이것은 "
"``Pickler(file, protocol).dump(obj)`` 와 동등합니다."

#: ../../library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have "
"the same meaning as in the :class:`Pickler` constructor."
msgstr ""
"인자 *file*, *protocol*, *fix_imports* 및 *buffer_callback*\\은 "
":class:`Pickler` 생성자에서와 같은 의미입니다."

#: ../../library/pickle.rst:225 ../../library/pickle.rst:236
#: ../../library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "*buffer_callback* 인자가 추가되었습니다."

#: ../../library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes`"
" object, instead of writing it to a file."
msgstr "객체 *obj*\\의 피클 된 표현을 파일에 쓰는 대신 :class:`bytes` 객체로 반환합니다."

#: ../../library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"인자 *protocol*, *fix_imports* 및 *buffer_callback*\\은 :class:`Pickler` "
"생성자에서와 같은 의미입니다."

#: ../../library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"열린 :term:`파일 객체 <file object>` *file* 에서 객체의 피클 된 표현을 읽고, 그 안에 지정된 객체 계층 "
"구조를 재구성하여 반환합니다. 이것은 ``Unpickler(file).load()`` 와 동등합니다."

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no "
"protocol argument is needed.  Bytes past the pickled representation of "
"the object are ignored."
msgstr "피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다. 객체의 피클 된 표현 뒤에 남는 바이트열은 무시됩니다."

#: ../../library/pickle.rst:249
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"인자 *file*, *fix_imports*, *encoding*, *errors*, *strict* 및 *buffers*\\는 "
":class:`Unpickler` 생성자에서와 같은 의미입니다."

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
#: ../../library/pickle.rst:433
msgid "The *buffers* argument was added."
msgstr "*buffers* 인자가 추가되었습니다."

#: ../../library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"객체의 피클 된 표현 *data*\\의 재구성된 객체 계층 구조를 반환합니다. *data*\\는 :term:`바이트열류 객체 "
"<bytes-like object>`\\여야 합니다."

#: ../../library/pickle.rst:264
#, fuzzy
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* "
"have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"인자 *file*, *fix_imports*, *encoding*, *errors*, *strict* 및 *buffers*\\는 "
":class:`Unpickler` 생성자에서와 같은 의미입니다."

#: ../../library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` 모듈은 세 가지 예외를 정의합니다:"

#: ../../library/pickle.rst:275
#, fuzzy
msgid ""
"Common base class for the other pickling exceptions.  It inherits from "
":exc:`Exception`."
msgstr "다른 피클링 예외의 공통 베이스 클래스입니다. :exc:`Exception`\\을 상속합니다."

#: ../../library/pickle.rst:280
#, fuzzy
msgid ""
"Error raised when an unpicklable object is encountered by "
":class:`Pickler`. It inherits from :exc:`PickleError`."
msgstr ""
":class:`Pickler` 가 피클 가능하지 않은 객체를 만날 때 발생하는 에러. :exc:`PickleError` 를 "
"상속합니다."

#: ../../library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr "어떤 종류의 객체가 피클 될 수 있는지 배우려면 :ref:`pickle-picklable`\\를 참조하십시오."

#: ../../library/pickle.rst:288
#, fuzzy
msgid ""
"Error raised when there is a problem unpickling an object, such as a data"
" corruption or a security violation.  It inherits from "
":exc:`PickleError`."
msgstr ""
"데이터 손상 또는 보안 위반과 같이 객체를 역 피클 할 때 문제가 있으면 발생하는 에러. :exc:`PickleError` 를 "
"상속합니다."

#: ../../library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, "
"including (but not necessarily limited to) AttributeError, EOFError, "
"ImportError, and IndexError."
msgstr ""
"역 피클링 중에 다른 예외도 발생할 수 있음에 유의하십시오. AttributeError, EOFError, ImportError, "
"IndexError 등이 발생할 수 있지만, 이에 국한되지는 않습니다."

#: ../../library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, "
":class:`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
":mod:`pickle` 모듈은 세 개의 클래스를 노출합니다, :class:`Pickler`, :class:`Unpickler` 및"
" :class:`PickleBuffer`:"

#: ../../library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr "피클 데이터 스트림을 쓸 바이너리 파일을 받아들입니다."

#: ../../library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use "
"the given protocol; supported protocols are 0 to "
":data:`HIGHEST_PROTOCOL`. If not specified, the default is "
":data:`DEFAULT_PROTOCOL`.  If a negative number is specified, "
":data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"선택적 *protocol* 인자(정수)는 피클러가 주어진 프로토콜을 사용하도록 지시합니다; 지원되는 프로토콜은 0부터 "
":data:`HIGHEST_PROTOCOL` 입니다. 지정하지 않으면 기본값은 :data:`DEFAULT_PROTOCOL` 입니다."
" 음수가 지정되면, :data:`HIGHEST_PROTOCOL` 이 선택됩니다."

#: ../../library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single "
"bytes argument.  It can thus be an on-disk file opened for binary "
"writing, an :class:`io.BytesIO` instance, or any other custom object that"
" meets this interface."
msgstr ""
"*file* 인자에는 단일 바이트열 인자를 받아들이는 write() 메서드가 있어야 합니다. 따라서 바이너리 쓰기를 위해 열린 "
"디스크 상의 파일, :class:`io.BytesIO` 인스턴스 또는 이 인터페이스를 충족시키는 다른 사용자 정의 객체일 수 "
"있습니다."

#: ../../library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try "
"to map the new Python 3 names to the old module names used in Python 2, "
"so that the pickle data stream is readable with Python 2."
msgstr ""
"*fix_imports* 가 참이고 *protocol* 이 3보다 작으면, pickle은 새로운 파이썬 3 이름을 파이썬 2에서 "
"사용된 이전 모듈 이름에 매핑하려고 시도하여, 파이썬 2에서 피클 데이터 스트림을 읽을 수 있도록 합니다."

#: ../../library/pickle.rst:317
#, fuzzy
msgid ""
"If *buffer_callback* is ``None`` (the default), buffer views are "
"serialized into *file* as part of the pickle stream."
msgstr "*buffer_callback*\\이 None(기본값)이면, 버퍼 뷰는 피클 스트림의 일부로 *file*\\로 직렬화됩니다."

#: ../../library/pickle.rst:320
#, fuzzy
msgid ""
"If *buffer_callback* is not ``None``, then it can be called any number of"
" times with a buffer view.  If the callback returns a false value (such "
"as ``None``), the given buffer is :ref:`out-of-band <pickle-oob>`; "
"otherwise the buffer is serialized in-band, i.e. inside the pickle "
"stream."
msgstr ""
"*buffer_callback*\\이 None이 아니면, 버퍼 뷰로 여러 번 호출될 수 있습니다. 콜백이 거짓 값(가령 None)을"
" 반환하면, 주어진 버퍼는 :ref:`아웃 오브 밴드 <pickle-oob>`\\입니다; 그렇지 않으면 버퍼는 인 밴드, 즉 피클 "
"스트림 내부에 직렬화됩니다."

#: ../../library/pickle.rst:325
#, fuzzy
msgid ""
"It is an error if *buffer_callback* is not ``None`` and *protocol* is "
"``None`` or smaller than 5."
msgstr "*buffer_callback*\\이 None이 아니고 *protocol*\\이 None이거나 5보다 작으면 에러입니다."

#: ../../library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given "
"in the constructor."
msgstr "생성자에 주어진 열린 파일 객체에 *obj* 의 피클 된 표현을 씁니다."

#: ../../library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr "기본적으로 아무것도 하지 않습니다. 이것은 서브 클래스가 재정의할 수 있게 하려고 존재합니다."

#: ../../library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  "
"Any other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value "
"returned by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
":meth:`persistent_id` 가 ``None`` 을 반환하면, *obj* 는 보통 때처럼 피클 됩니다. 다른 값은 "
":class:`Pickler` 가 *obj* 의 지속성(persistent) ID로 반환 값을 출력하도록 합니다. 이 지속성 ID의"
" 의미는 :meth:`Unpickler.persistent_load` 에 의해 정의되어야 합니다. "
":meth:`persistent_id` 에 의해 반환된 값 자체는 지속성 ID를 가질 수 없음에 유의하십시오."

#: ../../library/pickle.rst:346 ../../library/pickle.rst:451
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "자세한 내용과 사용 예는 :ref:`pickle-persistent`\\를 참조하십시오."

#: ../../library/pickle.rst:348
msgid ""
"Add the default implementation of this method in the C implementation of "
":class:`!Pickler`."
msgstr ""

#: ../../library/pickle.rst:354
#, fuzzy
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* "
"of the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions."
"  A reduction function takes a single argument of the associated class "
"and should conform to the same interface as a :meth:`~object.__reduce__` "
"method."
msgstr ""
"피클러 객체의 디스패치 테이블은 :func:`copyreg.pickle` 을 사용하여 선언할 수 있는 *환원 함수(reduction"
" functions)* 의 등록소입니다. 키가 클래스이고 값이 환원 함수인 매핑입니다. 환원 함수는 관련 클래스의 단일 인자를 "
"취하며 :meth:`__reduce__` 메서드와 같은 인터페이스를 따라야 합니다."

#: ../../library/pickle.rst:362
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by "
"the :mod:`copyreg` module. However, to customize the pickling for a "
"specific pickler object one can set the :attr:`dispatch_table` attribute "
"to a dict-like object.  Alternatively, if a subclass of :class:`Pickler` "
"has a :attr:`dispatch_table` attribute then this will be used as the "
"default dispatch table for instances of that class."
msgstr ""
"기본적으로, 피클러 객체는 :attr:`dispatch_table` 어트리뷰트를 가지지 않을 것이고, 대신 "
":mod:`copyreg` 모듈에 의해 관리되는 전역 디스패치 테이블을 사용할 것입니다. 그러나 특정 피클러 객체의 피클링을 사용자"
" 정의하기 위해서 :attr:`dispatch_table` 어트리뷰트를 딕셔너리류 객체로 설정할 수 있습니다. 또는, "
":class:`Pickler` 의 서브 클래스가 :attr:`dispatch_table` 어트리뷰트를 가지고 있다면, 이 클래스의 "
"인스턴스를 위한 기본 디스패치 테이블로 사용됩니다."

#: ../../library/pickle.rst:371
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "사용 예는 :ref:`pickle-dispatch`\\을 참조하십시오."

#: ../../library/pickle.rst:377
#, fuzzy
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`~object.__reduce__` "
"method, and can optionally return :data:`NotImplemented` to fallback on "
":attr:`dispatch_table`-registered reducers to pickle ``obj``."
msgstr ""
":class:`Pickler` 서브 클래스에서 정의할 수 있는 특수 환원기(reducer). 이 메서드는 "
":attr:`dispatch_table`\\에 있는 모든 감속기보다 우선순위가 높습니다. :meth:`__reduce__` 메서드와"
" 같은 인터페이스를 따라야 하며, 선택적으로 ``NotImplemented``\\를 반환하여 ``obj``\\를 피클 하기 위해 "
":attr:`dispatch_table` 등록 환원기로 폴백(fallback)하도록 할 수 있습니다."

#: ../../library/pickle.rst:383
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "자세한 예는 :ref:`reducer_override`\\을 참조하십시오."

#: ../../library/pickle.rst:389
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode "
"disables the usage of memo, therefore speeding the pickling process by "
"not generating superfluous PUT opcodes.  It should not be used with self-"
"referential objects, doing otherwise will cause :class:`Pickler` to "
"recurse infinitely."
msgstr ""
"폐지되었습니다. 참값으로 설정된 경우 빠른 모드를 활성화합니다. 빠른 모드는 메모 사용을 비활성화하므로, 불필요한 PUT 옵코드를 "
"생성하지 않아 피클링 절차의 속도를 높입니다. 자신을 참조하는 객체에 사용되면 안 됩니다. 그렇지 않으면 "
":class:`Pickler` 가 무한 재귀에 빠집니다."

#: ../../library/pickle.rst:395
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr "더 간결한 피클이 필요하면 :func:`pickletools.optimize` 를 사용하십시오."

#: ../../library/pickle.rst:400
msgid "This takes a binary file for reading a pickle data stream."
msgstr "피클 데이터 스트림을 읽는 데 사용될 바이너리 파일을 받아들입니다."

#: ../../library/pickle.rst:402
msgid ""
"The protocol version of the pickle is detected automatically, so no "
"protocol argument is needed."
msgstr "피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다."

#: ../../library/pickle.rst:405
msgid ""
"The argument *file* must have three methods, a read() method that takes "
"an integer argument, a readinto() method that takes a buffer argument and"
" a readline() method that requires no arguments, as in the "
":class:`io.BufferedIOBase` interface.  Thus *file* can be an on-disk file"
" opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""
"인자 *file* 에는 세 가지 메서드가 있어야 합니다, :class:`io.BufferedIOBase` 인터페이스 처럼, 정수 "
"인자를 받아들이는 read() 메서드, 버퍼 인자를 받아들이는 readinto() 메서드 그리고 인자가 없는 readline() "
"메서드. 따라서 *file* 은 바이너리 읽기를 위해 열린 디스크 상의 파일, :class:`io.BytesIO` 객체 또는 이 "
"인터페이스를 만족하는 다른 사용자 정의 객체일 수 있습니다."

#: ../../library/pickle.rst:412
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to"
" control compatibility support for pickle stream generated by Python 2. "
"If *fix_imports* is true, pickle will try to map the old Python 2 names "
"to the new names used in Python 3.  The *encoding* and *errors* tell "
"pickle how to decode 8-bit string instances pickled by Python 2; these "
"default to 'ASCII' and 'strict', respectively.  The *encoding* can be "
"'bytes' to read these 8-bit string instances as bytes objects. Using "
"``encoding='latin1'`` is required for unpickling NumPy arrays and "
"instances of :class:`~datetime.datetime`, :class:`~datetime.date` and "
":class:`~datetime.time` pickled by Python 2."
msgstr ""
"선택적 인자 *fix_imports*, *encoding* 및 *errors*\\는 파이썬 2에서 생성된 피클 스트림에 대한 호환성"
" 지원을 제어하는 데 사용됩니다. *fix_imports* 가 참이면, pickle은 이전 파이썬 2 이름을 파이썬 3에서 사용된 "
"새로운 이름으로 매핑하려고 합니다. *encoding* 과 *errors* 는 파이썬 2에 의해 피클 된 8비트 문자열 인스턴스를 "
"디코딩하는 방법을 pickle에게 알려줍니다. 기본값은 각각 'ASCII'\\와 'strict' 입니다. *encoding* 은 "
"'bytes' 가 될 수 있는데, 8비트 문자열 인스턴스를 바이트열 객체로 읽습니다. NumPy 배열과 파이썬 2에서 피클 된 "
":class:`~datetime.datetime`, :class:`~datetime.date` 및 "
":class:`~datetime.time` 인스턴스를 역 피클링하려면 ``encoding='latin1'``\\을 사용해야 합니다."

#: ../../library/pickle.rst:423
#, fuzzy
msgid ""
"If *buffers* is ``None`` (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that "
"the *buffer_callback* argument was ``None`` when a :class:`Pickler` was "
"instantiated (or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"*buffers*\\가 None(기본값)이면, 역 직렬화에 필요한 모든 데이터가 피클 스트림에 포함되어야 합니다. 이것은 "
":class:`Pickler`\\가 인스턴스 화 될 때 (또는 :func:`dump`\\나 :func:`dumps`\\가 호출될 "
"때) *buffer_callback* 인자가 None이었음을 뜻합니다."

#: ../../library/pickle.rst:428
#, fuzzy
msgid ""
"If *buffers* is not ``None``, it should be an iterable of buffer-enabled "
"objects that is consumed each time the pickle stream references an :ref"
":`out-of-band <pickle-oob>` buffer view.  Such buffers have been given in"
" order to the *buffer_callback* of a Pickler object."
msgstr ""
"*buffers*\\가 None이 아니면, 피클 스트림이 :ref:`아웃 오브 밴드 <pickle-oob>` 버퍼 뷰를 참조할 "
"때마다 소비되는 버퍼가 활성화된 객체의 이터러블이어야 합니다. 이러한 버퍼는 Pickler 객체의 "
"*buffer_callback*\\에 순서대로 제공되었습니다."

#: ../../library/pickle.rst:438
msgid ""
"Read the pickled representation of an object from the open file object "
"given in the constructor, and return the reconstituted object hierarchy "
"specified therein.  Bytes past the pickled representation of the object "
"are ignored."
msgstr ""
"생성자에 주어진 열린 파일 객체에서 객체의 피클 된 표현을 읽고, 그 안에 지정된 객체 계층 구조를 재구성하여 반환합니다. 객체의 "
"피클 된 표현 뒤에 남는 바이트열은 무시됩니다."

#: ../../library/pickle.rst:445
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "기본적으로 :exc:`UnpicklingError`\\를 발생시킵니다."

#: ../../library/pickle.rst:447
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by"
" the persistent ID *pid*.  If an invalid persistent ID is encountered, an"
" :exc:`UnpicklingError` should be raised."
msgstr ""
"정의되면, :meth:`persistent_load` 는 지속성 ID *pid* 로 지정된 객체를 반환해야 합니다. 유효하지 않은 "
"지속성 ID가 발견되면 :exc:`UnpicklingError`\\를 일으켜야 합니다."

#: ../../library/pickle.rst:453
msgid ""
"Add the default implementation of this method in the C implementation of "
":class:`!Unpickler`."
msgstr ""

#: ../../library/pickle.rst:459
msgid ""
"Import *module* if necessary and return the object called *name* from it,"
" where the *module* and *name* arguments are :class:`str` objects.  Note,"
" unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"필요하면 *module* 을 임포트하고 거기에서 *name* 이라는 객체를 반환합니다. 여기서 *module* 및 *name* "
"인자는 :class:`str` 객체입니다. 그 이름이 제시하는 것과는 달리, :meth:`find_class` 는 함수를 찾는 "
"데에도 사용됨에 유의하십시오."

#: ../../library/pickle.rst:464
msgid ""
"Subclasses may override this to gain control over what type of objects "
"and how they can be loaded, potentially reducing security risks. Refer to"
" :ref:`pickle-restrict` for details."
msgstr ""
"로드되는 객체의 형과 로드 방법을 제어하기 위해 서브 클래스는 이것을 재정의할 수 있고, 잠재적으로 보안 위험을 감소시킵니다. "
"자세한 내용은 :ref:`pickle-restrict`\\를 참조하십시오."

#: ../../library/pickle.rst:468
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"``module``, ``name``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``pickle.find_class``\\를 발생시킵니다."

#: ../../library/pickle.rst:472
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a "
":ref:`buffer-providing <bufferobjects>` object, such as a :term:`bytes-"
"like object` or a N-dimensional array."
msgstr ""
"피클 가능한 데이터를 나타내는 버퍼의 래퍼. *buffer*\\는 :term:`바이트열류 객체 <bytes-like "
"object>`\\나 N-차원 배열과 같은 :ref:`버퍼 제공 <bufferobjects>` 객체여야 합니다."

#: ../../library/pickle.rst:476
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is "
"possible to pass it to other APIs expecting a buffer-providing object, "
"such as :class:`memoryview`."
msgstr ""
":class:`PickleBuffer` 자체가 버퍼 제공자이므로, :class:`memoryview`\\와 같은 버퍼 제공 객체를 "
"기대하는 다른 API로 전달할 수 있습니다."

#: ../../library/pickle.rst:480
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle "
"protocol 5 or higher.  They are eligible for :ref:`out-of-band "
"serialization <pickle-oob>`."
msgstr ""
":class:`PickleBuffer` 객체는 피클 프로토콜 5 이상만 사용하여 직렬화할 수 있습니다. 그들은 :ref:`아웃 오브"
" 밴드 직렬화 <pickle-oob>` 대상입니다."

#: ../../library/pickle.rst:488
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. "
"The returned object is a one-dimensional, C-contiguous memoryview with "
"format ``B`` (unsigned bytes).  :exc:`BufferError` is raised if the "
"buffer is neither C- nor Fortran-contiguous."
msgstr ""
"이 버퍼의 하부 메모리 영역의 :class:`memoryview`\\를 반환합니다. 반환된 객체는 ``B`` (부호 없는 바이트) "
"형식의 1-차원 C 연속 메모리 뷰입니다. 버퍼가 C나 포트란 연속적이지 않으면 :exc:`BufferError`\\가 발생합니다."

#: ../../library/pickle.rst:495
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr "PickleBuffer 객체에 의해 노출된 하부 버퍼를 해제합니다."

#: ../../library/pickle.rst:501
msgid "What can be pickled and unpickled?"
msgstr "어떤 것이 피클 되고 역 피클 될 수 있을까요?"

#: ../../library/pickle.rst:503
msgid "The following types can be pickled:"
msgstr "다음 형을 피클 할 수 있습니다:"

#: ../../library/pickle.rst:505
msgid ""
"built-in constants (``None``, ``True``, ``False``, ``Ellipsis``, and "
":data:`NotImplemented`);"
msgstr ""

#: ../../library/pickle.rst:508
#, fuzzy
msgid "integers, floating-point numbers, complex numbers;"
msgstr "정수, 실수, 복소수"

#: ../../library/pickle.rst:510
#, fuzzy
msgid "strings, bytes, bytearrays;"
msgstr "문자열, 바이트열, 바이트 배열(bytearray)"

#: ../../library/pickle.rst:512
#, fuzzy
msgid "tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr "피클 가능한 객체만 포함하는 튜플, 리스트, 집합과 딕셔너리"

#: ../../library/pickle.rst:514
#, fuzzy
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr "모듈의 최상위 수준에서 정의된 함수 (:keyword:`lambda` 가 아니라 :keyword:`def` 를 사용하는)"

#: ../../library/pickle.rst:517
#, fuzzy
msgid "classes accessible from the top level of a module;"
msgstr "모듈의 최상위 수준에서 정의된 클래스"

#: ../../library/pickle.rst:519
#, fuzzy
msgid ""
"instances of such classes whose the result of calling "
":meth:`~object.__getstate__` is picklable  (see section :ref:`pickle-"
"inst` for details)."
msgstr ""
"그런 클래스의 인스턴스 중에서 :attr:`~object.__dict__` 나 :meth:`__getstate__` 를 호출한 "
"결과가 피클 가능한 것들 (자세한 내용은 :ref:`pickle-inst` 절을 참조하세요)."

#: ../../library/pickle.rst:522
msgid ""
"Attempts to pickle unpicklable objects will raise the "
":exc:`PicklingError` exception; when this happens, an unspecified number "
"of bytes may have already been written to the underlying file.  Trying to"
" pickle a highly recursive data structure may exceed the maximum "
"recursion depth, a :exc:`RecursionError` will be raised in this case.  "
"You can carefully raise this limit with :func:`sys.setrecursionlimit`."
msgstr ""
"피클 가능하지 않은 객체를 피클 하려고 하면 :exc:`PicklingError` 예외가 발생합니다; 이런 일이 일어났을 때, "
"특정할 수 없는 길이의 바이트열이 하부 파일에 이미 기록되었을 수 있습니다. 매우 재귀적인 데이터 구조를 피클 하려고 하면 최대 "
"재귀 깊이를 초과할 수 있고, 이때 :exc:`RecursionError` 가 발생합니다. "
":func:`sys.setrecursionlimit` 을 사용하여 이 제한을 조심스럽게 올릴 수 있습니다."

#: ../../library/pickle.rst:529
#, fuzzy
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully "
":term:`qualified name`, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the containing module "
"and classes.  Neither the function's code, nor any of its function "
"attributes are pickled.  Thus the defining module must be importable in "
"the unpickling environment, and the module must contain the named object,"
" otherwise an exception will be raised. [#]_"
msgstr ""
"함수(내장 및 사용자 정의)는 값이 아니라 \"완전히 정규화된\" 이름 참조로 피클 됨에 유의하십시오. [#]_ 이것은 함수가 "
"정의된 모듈의 이름과 함께 함수의 이름만 피클 된다는 것을 의미합니다. 함수의 코드도 함수 어트리뷰트도 피클 되지 않습니다. 따라서"
" 정의하는 모듈은 역 피클 환경에서 임포트 가능해야 하며, 모듈에는 그 이름의 객체가 있어야 합니다. 그렇지 않으면 예외가 "
"발생합니다. [#]_"

#: ../../library/pickle.rst:536
#, fuzzy
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"마찬가지로, 클래스는 이름 참조로 피클 되므로 역 피클링 환경에서 같은 제한이 적용됩니다. 클래스의 코드 나 데이터가 피클 되지 "
"않음에 유의하세요. 그래서 다음 예제에서 클래스 어트리뷰트 ``attr`` 은 역 피클링 환경에서 복원되지 않습니다::"

#: ../../library/pickle.rst:541
msgid ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"
msgstr ""

#: ../../library/pickle.rst:546
#, fuzzy
msgid ""
"These restrictions are why picklable functions and classes must be "
"defined at the top level of a module."
msgstr "이러한 제한이 피클 가능한 함수와 클래스가 모듈의 최상위 수준에서 정의되어야 하는 이유입니다."

#: ../../library/pickle.rst:549
#, fuzzy
msgid ""
"Similarly, when class instances are pickled, their class's code and data "
"are not pickled along with them.  Only the instance data are pickled.  "
"This is done on purpose, so you can fix bugs in a class or add methods to"
" the class and still load objects that were created with an earlier "
"version of the class.  If you plan to have long-lived objects that will "
"see many versions of a class, it may be worthwhile to put a version "
"number in the objects so that suitable conversions can be made by the "
"class's :meth:`~object.__setstate__` method."
msgstr ""
"마찬가지로, 클래스 인스턴스가 피클 될 때, 클래스의 코드와 데이터는 함께 피클 되지 않습니다. 인스턴스 데이터만 피클 됩니다. "
"이는 의도한 것으로, 클래스의 버그를 수정하거나 클래스에 메서드를 추가할 수 있고, 이전 버전의 클래스로 만들어진 객체를 여전히 "
"로드 할 수 있습니다. 여러 버전의 클래스에 걸치는 수명이 긴 객체를 만들 계획이라면, 클래스의 "
":meth:`__setstate__` 메서드로 적절한 변환을 할 수 있도록 객체에 버전 번호를 넣는 것이 좋습니다."

#: ../../library/pickle.rst:561
msgid "Pickling Class Instances"
msgstr "클래스 인스턴스 피클링"

#: ../../library/pickle.rst:565
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and "
"unpickled."
msgstr "이 절에서는 클래스 인스턴스를 피클 및 역 피클 하는 방법을 정의, 사용자 정의 및 제어할 수 있는 일반적인 메커니즘을 설명합니다."

#: ../../library/pickle.rst:568
#, fuzzy
msgid ""
"In most cases, no additional code is needed to make instances picklable."
"  By default, pickle will retrieve the class and the attributes of an "
"instance via introspection. When a class instance is unpickled, its "
":meth:`~object.__init__` method is usually *not* invoked.  The default "
"behaviour first creates an uninitialized instance and then restores the "
"saved attributes.  The following code shows an implementation of this "
"behaviour::"
msgstr ""
"대부분은, 인스턴스를 피클 가능하게 만드는 데 추가 코드가 필요하지 않습니다. 기본적으로, pickle은 인트로스펙션을 통해 "
"인스턴스의 클래스와 어트리뷰트를 조회합니다. 클래스 인스턴스가 역 피클 될 때, :meth:`__init__` 메서드는 보통 "
"호출되지 *않습니다*. 기본 동작은, 먼저 초기화되지 않은 인스턴스를 만든 다음 저장된 어트리뷰트를 복원합니다. 다음 코드는 이 "
"동작의 구현을 보여줍니다::"

#: ../../library/pickle.rst:575
msgid ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"
msgstr ""

#: ../../library/pickle.rst:583
msgid ""
"Classes can alter the default behaviour by providing one or several "
"special methods:"
msgstr "클래스는 다음과 같은 하나 이상의 특수 메서드를 제공하여 기본 동작을 변경할 수 있습니다:"

#: ../../library/pickle.rst:588
msgid ""
"In protocols 2 and newer, classes that implements the "
":meth:`__getnewargs_ex__` method can dictate the values passed to the "
":meth:`__new__` method upon unpickling.  The method must return a pair "
"``(args, kwargs)`` where *args* is a tuple of positional arguments and "
"*kwargs* a dictionary of named arguments for constructing the object.  "
"Those will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"프로토콜 2 이상에서, :meth:`__getnewargs_ex__` 메서드를 구현하는 클래스는 역 피클링 때 "
":meth:`__new__` 메서드에 전달되는 값을 지시할 수 있습니다. 이 메서드는 ``(args, kwargs)`` 쌍을 "
"반환해야 합니다. *args* 는 위치 인자의 튜플이고 *kwargs* 는 이름있는 인자의 딕셔너리인데, 객체를 구성하는 데 "
"사용됩니다. 그것들은 역 피클링 때 :meth:`__new__` 메서드로 전달될 것입니다."

#: ../../library/pickle.rst:596
msgid ""
"You should implement this method if the :meth:`__new__` method of your "
"class requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"클래스의 :meth:`__new__` 메서드에 키워드 전용 인자가 필요하면 이 메서드를 구현해야 합니다. 그렇지 않으면 호환성을 "
"위해 :meth:`__getnewargs__` 를 구현하는 것이 좋습니다."

#: ../../library/pickle.rst:600
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` 는 이제 프로토콜 2와 3에서 사용됩니다."

#: ../../library/pickle.rst:606
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon "
"unpickling."
msgstr ""
"이 메서드는 :meth:`__getnewargs_ex__` 와 비슷한 목적을 수행하지만, 위치 인자만 지원합니다. 역 피클링 때 "
":meth:`__new__` 메서드에 전달될 인자의 튜플 ``args`` 를 반환해야 합니다."

#: ../../library/pickle.rst:610
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is"
" defined."
msgstr ":meth:`__getnewargs_ex__` 가 정의되면 :meth:`__getnewargs__` 는 호출되지 않습니다."

#: ../../library/pickle.rst:613
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of "
":meth:`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"파이썬 3.6 이전에는, 프로토콜 2와 3에서 :meth:`__getnewargs_ex__` 대신 "
":meth:`__getnewargs__` 가 호출되었습니다."

#: ../../library/pickle.rst:620
#, fuzzy
msgid ""
"Classes can further influence how their instances are pickled by "
"overriding the method :meth:`__getstate__`.  It is called and the "
"returned object is pickled as the contents for the instance, instead of a"
" default state. There are several cases:"
msgstr ""
"클래스는 인스턴스가 피클 되는 방식에 더 많은 영향을 줄 수 있습니다; 클래스가 메서드 :meth:`__getstate__` 를 "
"정의하면, 인스턴스의 딕셔너리 내용 대신, 이 메서드가 호출되고 반환된 객체를 인스턴스의 내용으로 피클 합니다. "
":meth:`__getstate__` 메서드가 없다면, 인스턴스의 :attr:`~object.__dict__` 가 평소와 같이 피클"
" 됩니다."

#: ../../library/pickle.rst:625
msgid ""
"For a class that has no instance :attr:`~object.__dict__` and no "
":attr:`~object.__slots__`, the default state is ``None``."
msgstr ""

#: ../../library/pickle.rst:628
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and no "
":attr:`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""

#: ../../library/pickle.rst:631
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and "
":attr:`~object.__slots__`, the default state is a tuple consisting of two"
" dictionaries:  ``self.__dict__``, and a dictionary mapping slot names to"
" slot values.  Only slots that have a value are included in the latter."
msgstr ""

#: ../../library/pickle.rst:637
msgid ""
"For a class that has :attr:`~object.__slots__` and no instance "
":attr:`~object.__dict__`, the default state is a tuple whose first item "
"is ``None`` and whose second item is a dictionary mapping slot names to "
"slot values described in the previous bullet."
msgstr ""

#: ../../library/pickle.rst:642
msgid ""
"Added the default implementation of the ``__getstate__()`` method in the "
":class:`object` class."
msgstr ""

#: ../../library/pickle.rst:649
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"역 피클링 때, 클래스가 :meth:`__setstate__` 를 정의하면, 그것은 역 피클 된 상태(state)로 호출됩니다. 이"
" 경우 상태 객체가 딕셔너리일 필요는 없습니다. 그렇지 않으면, 피클 된 상태는 딕셔너리 여야하고 그 항목이 새 인스턴스의 "
"딕셔너리에 삽입됩니다."

#: ../../library/pickle.rst:656
#, fuzzy
msgid ""
"If :meth:`__reduce__` returns a state with value ``None`` at pickling, "
"the :meth:`__setstate__` method will not be called upon unpickling."
msgstr ""
":meth:`__getstate__` 가 거짓 값을 반환하면, :meth:`__setstate__` 메서드가 역 피클링 때 호출되지"
" 않습니다."

#: ../../library/pickle.rst:660
#, fuzzy
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how "
"to use the methods :meth:`~object.__getstate__` and "
":meth:`~object.__setstate__`."
msgstr ""
":meth:`__getstate__` 와 :meth:`__setstate__` 메서드를 사용하는 방법에 대한 더 자세한 정보는 "
":ref:`pickle-state` 절을 참조하십시오."

#: ../../library/pickle.rst:665
#, fuzzy
msgid ""
"At unpickling time, some methods like :meth:`~object.__getattr__`, "
":meth:`~object.__getattribute__`, or :meth:`~object.__setattr__` may be "
"called upon the instance.  In case those methods rely on some internal "
"invariant being true, the type should implement :meth:`~object.__new__` "
"to establish such an invariant, as :meth:`~object.__init__` is not called"
" when unpickling an instance."
msgstr ""
"역 피클링 시간에, :meth:`__getattr__`, :meth:`__getattribute__`, 또는 "
":meth:`__setattr__` 같은 메서드가 인스턴스에 호출될 수 있습니다. 그러한 메서드들이 어떤 내부 불변성이 참인 것에 "
"의존하는 경우, 형은 그런 불변성을 유지하기 위해 :meth:`__new__` 를 구현해야 합니다, 인스턴스를 역 피클링할 때 "
":meth:`__init__`\\가 호출되지 않기 때문입니다."

#: ../../library/pickle.rst:674
#, fuzzy
msgid ""
"As we shall see, pickle does not use directly the methods described "
"above.  In fact, these methods are part of the copy protocol which "
"implements the :meth:`~object.__reduce__` special method.  The copy "
"protocol provides a unified interface for retrieving the data necessary "
"for pickling and copying objects. [#]_"
msgstr ""
"앞으로 살펴보겠지만, 피클은 위에서 설명한 메서드를 직접 사용하지 않습니다. 사실, 이 메서드들은 :meth:`__reduce__`"
" 특수 메서드를 구현하는 복사 프로토콜의 일부입니다. 복사 프로토콜은 객체를 피클 하고 복사하는 데 필요한 데이터를 조회하기 위한 "
"통일된 인터페이스를 제공합니다. [#]_"

#: ../../library/pickle.rst:680
#, fuzzy
msgid ""
"Although powerful, implementing :meth:`~object.__reduce__` directly in "
"your classes is error prone.  For this reason, class designers should use"
" the high-level interface (i.e., :meth:`~object.__getnewargs_ex__`, "
":meth:`~object.__getstate__` and :meth:`~object.__setstate__`) whenever "
"possible.  We will show, however, cases where using :meth:`!__reduce__` "
"is the only option or leads to more efficient pickling or both."
msgstr ""
"강력하기는 하지만, 여러분의 클래스에서 직접 :meth:`__reduce__` 를 구현하면 잘못되기 쉽습니다. 이런 이유로, 클래스"
" 설계자는 가능하면 고수준 인터페이스(즉, :meth:`__getnewargs_ex__`, :meth:`__getstate__` 및"
" :meth:`__setstate__`)를 사용해야 합니다. 하지만, 우리는 :meth:`__reduce__` 를 사용하는 것이 "
"유일한 옵션이거나 더 효율적인 피클링을 제공하거나 혹은 둘 다인 경우를 보여줄 것입니다."

#: ../../library/pickle.rst:689
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a"
" tuple (the returned object is often referred to as the \"reduce "
"value\")."
msgstr ""
"인터페이스는 현재 다음과 같이 정의됩니다. :meth:`__reduce__` 메서드는 아무런 인자도 받아들이지 않으며 문자열이나 "
"바람직하게는 튜플을 반환합니다 (반환된 객체는 흔히 \"환원 값(reduce value)\"이라고 불립니다)."

#: ../../library/pickle.rst:693
msgid ""
"If a string is returned, the string should be interpreted as the name of "
"a global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"문자열이 반환되면, 문자열은 전역 변수의 이름으로 해석되어야 합니다. 모듈에 상대적인 객체의 지역 이름이어야 합니다; pickle "
"모듈은 객체의 모듈을 결정하기 위해 모듈 이름 공간을 검색합니다. 이 동작은 일반적으로 싱글톤에 유용합니다."

#: ../../library/pickle.rst:698
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as "
"their value.  The semantics of each item are in order:"
msgstr ""
"튜플이 반환될 때는, 길이가 2나 6이 되어야 합니다. 선택적인 항목은 생략되거나 ``None`` 이 값으로 제공될 수 있습니다. "
"각 항목의 의미는 순서대로 다음과 같습니다:"

#: ../../library/pickle.rst:704
msgid ""
"A callable object that will be called to create the initial version of "
"the object."
msgstr "객체의 초기 버전을 만들기 위해 호출할 콜러블 객체."

#: ../../library/pickle.rst:707
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be "
"given if the callable does not accept any argument."
msgstr "콜러블 객체에 대한 인자의 튜플. 콜러블 객체가 인자를 받아들이지 않으면 빈 튜플을 제공해야 합니다."

#: ../../library/pickle.rst:710
msgid ""
"Optionally, the object's state, which will be passed to the object's "
":meth:`__setstate__` method as previously described.  If the object has "
"no such method then, the value must be a dictionary and it will be added "
"to the object's :attr:`~object.__dict__` attribute."
msgstr ""
"선택적으로, 객체의 상태. 앞에서 설명한 대로 객체의 :meth:`__setstate__` 메서드에 전달됩니다. 객체에 그런 "
"메서드가 없다면, 그 값은 딕셔너리 여야 하며 객체의 :attr:`~object.__dict__` 어트리뷰트에 추가됩니다."

#: ../../library/pickle.rst:715
#, fuzzy
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using "
"``obj.append(item)`` or, in batch, using ``obj.extend(list_of_items)``. "
"This is primarily used for list subclasses, but may be used by other "
"classes as long as they have :ref:`append and extend methods <typesseq-"
"common>` with the appropriate signature.  (Whether :meth:`!append` or "
":meth:`!extend` is used depends on which pickle protocol version is used "
"as well as the number of items to append, so both must be supported.)"
msgstr ""
"선택적으로, 연속적인 항목을 생성하는 이터레이터(시퀀스가 아닙니다). 이 항목들은 ``obj.append(item)`` 을 "
"사용하거나 한꺼번에 ``obj.extend(list_of_items)`` 를 사용하여 객체에 추가될 것입니다. 이것은 주로 리스트 "
"서브 클래스에 사용되지만, 적절한 서명을 갖는 :meth:`append`\\와 :meth:`extend` 메서드가 있는 한 다른 "
"클래스에서 사용될 수 있습니다. (:meth:`append` 나 :meth:`extend` 중 어느 것이 사용되는지는 어떤 피클 "
"프로토콜 버전이 사용되는가와 추가 할 항목의 수에 따라 달려있으므로 둘 다 지원되어야 합니다.)"

#: ../../library/pickle.rst:725
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be "
"used by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"선택적으로, 연속적인 키-값 쌍을 생성하는 이터레이터(시퀀스가 아닙니다). 이 항목들은 ``obj[key] = value`` 를 "
"사용하여 객체에 저장됩니다. 이것은 주로 딕셔너리 서브 클래스에 사용되지만, :meth:`__setitem__` 을 구현하는 한 "
"다른 클래스에서 사용될 수 있습니다."

#: ../../library/pickle.rst:730
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior "
"of a specific object, instead of using ``obj``'s static "
":meth:`__setstate__` method. If not ``None``, this callable will have "
"priority over ``obj``'s :meth:`__setstate__`."
msgstr ""
"선택적으로, ``(obj, state)`` 서명을 가진 콜러블. 이 콜러블은 ``obj``\\의 정적 "
":meth:`__setstate__` 메서드 대신에 특정 객체의 상태 갱신 동작을 프로그래밍 방식으로 제어할 수 있도록 합니다. "
"``None``\\이 아니면, 이 콜러블은 ``obj``\\의 :meth:`__setstate__`\\보다 우선 합니다."

#: ../../library/pickle.rst:736
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "선택적인 여섯 번째 튜플 항목 ``(obj, state)``\\가 추가되었습니다."

#: ../../library/pickle.rst:742
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the "
":meth:`__reduce__` method.  In addition, :meth:`__reduce__` automatically"
" becomes a synonym for the extended version.  The main use for this "
"method is to provide backwards-compatible reduce values for older Python "
"releases."
msgstr ""
"또는, :meth:`__reduce_ex__` 메서드를 정의할 수 있습니다. 유일한 차이점은 이 메서드가 프로토콜 버전인 단일 정수"
" 인자를 받아들여야 한다는 것입니다. 정의되면, pickle은 :meth:`__reduce__` 메서드보다 선호합니다. 또한, "
":meth:`__reduce__` 는 자동으로 확장 버전의 동의어가 됩니다. 이 메서드의 주된 용도는 구형 파이썬 배포를 위해 과거"
" 호환성 있는 환원 값을 제공하는 것입니다."

#: ../../library/pickle.rst:754
msgid "Persistence of External Objects"
msgstr "외부 객체의 지속성"

#: ../../library/pickle.rst:760
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports "
"the notion of a reference to an object outside the pickled data stream.  "
"Such objects are referenced by a persistent ID, which should be either a "
"string of alphanumeric characters (for protocol 0) [#]_ or just an "
"arbitrary object (for any newer protocol)."
msgstr ""
"객체 지속성의 효용을 위해, :mod:`pickle` 모듈은 피클 된 데이터 스트림 밖의 객체에 대한 참조 개념을 지원합니다. "
"이러한 객체는 지속성 ID에 의해 참조되며, 영숫자 문자열(프로토콜 0의 경우) [#]_ 또는 임의의 객체(모든 최신 프로토콜의 "
"경우)여야 합니다."

#: ../../library/pickle.rst:766
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle`"
" module; it will delegate this resolution to the user-defined methods on "
"the pickler and unpickler, :meth:`~Pickler.persistent_id` and "
":meth:`~Unpickler.persistent_load` respectively."
msgstr ""
"그러한 지속성 ID의 해석은 :mod:`pickle` 모듈에 의해 정의되지 않습니다; 이 해석을 피클러와 역 피클러의 사용자 정의 "
"메서드에 위임합니다, 각각 :meth:`~Pickler.persistent_id`\\와 "
":meth:`~Unpickler.persistent_load`."

#: ../../library/pickle.rst:771
msgid ""
"To pickle objects that have an external persistent ID, the pickler must "
"have a custom :meth:`~Pickler.persistent_id` method that takes an object "
"as an argument and returns either ``None`` or the persistent ID for that "
"object. When ``None`` is returned, the pickler simply pickles the object "
"as normal. When a persistent ID string is returned, the pickler will "
"pickle that object, along with a marker so that the unpickler will "
"recognize it as a persistent ID."
msgstr ""
"지속성 ID를 가진 객체를 피클 하기 위해서, 피클러는 객체를 인자로 받아서 그 객체에 대해 ``None`` 또는 지속성 ID를 "
"반환하는 사용자 정의 :meth:`~Pickler.persistent_id` 메서드가 있어야 합니다. ``None`` 이 반환되면,"
" 피클러는 단순히 객체를 피클 합니다. 지속성 ID 문자열이 반환되면, 피클러는 마커와 함께 해당 객체를 피클 하여 역 피클러가 "
"이를 지속성 ID로 인식하게 합니다."

#: ../../library/pickle.rst:778
msgid ""
"To unpickle external objects, the unpickler must have a custom "
":meth:`~Unpickler.persistent_load` method that takes a persistent ID "
"object and returns the referenced object."
msgstr ""
"외부 객체를 역 피클 하려면, 역 피클러는 지속성 ID 객체를 받아들여 참조된 객체를 반환하는 사용자 정의 "
":meth:`~Unpickler.persistent_load` 메서드를 가져야 합니다."

#: ../../library/pickle.rst:782
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used "
"to pickle external objects by reference."
msgstr "다음은 지속성 ID를 외부 객체를 참조로 피클 하는데 사용하는 방법을 보여주는 포괄적인 예입니다."

#: ../../library/pickle.rst:785
msgid ""
"# Simple example presenting how persistent ID can be used to pickle\n"
"# external objects by reference.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we "
"emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag"
" and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This "
"means obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered."
"\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return "
"it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct "
"object.\n"
"            # Otherwise, the unpickler will think None is the object "
"referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent "
"object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task "
"TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")"
"\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: ../../library/pickle.rst:790
msgid "Dispatch Tables"
msgstr "디스패치 테이블"

#: ../../library/pickle.rst:792
msgid ""
"If one wants to customize pickling of some classes without disturbing any"
" other code which depends on pickling, then one can create a pickler with"
" a private dispatch table."
msgstr ""
"피클링에 의존하는 다른 코드를 방해하지 않고 일부 클래스의 피클링을 사용자 정의하려면, 사설 디스패치 테이블을 갖는 피클러를 만들 "
"수 있습니다."

#: ../../library/pickle.rst:796
#, fuzzy
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is "
"available as :data:`!copyreg.dispatch_table`.  Therefore, one may choose "
"to use a modified copy of :data:`!copyreg.dispatch_table` as a private "
"dispatch table."
msgstr ""
":mod:`copyreg` 모듈에 의해 관리되는 전역 디스패치 테이블은 :data:`copyreg.dispatch_table`\\로"
" 사용 가능합니다. 그러므로, 사설 디스패치 테이블로 :data:`copyreg.dispatch_table` 의 수정된 복사본을 "
"사용할 수 있습니다."

#: ../../library/pickle.rst:801
msgid "For example ::"
msgstr "예를 들면 ::"

#: ../../library/pickle.rst:803
msgid ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"
msgstr ""

#: ../../library/pickle.rst:808
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch "
"table which handles the ``SomeClass`` class specially.  Alternatively, "
"the code ::"
msgstr ""
"는 ``SomeClass`` 클래스를 특별히 처리하는 사설 디스패치 테이블을 갖는 :class:`pickle.Pickler` 의 "
"인스턴스를 생성합니다. 또는, 코드 ::"

#: ../../library/pickle.rst:812
msgid ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"
msgstr ""

#: ../../library/pickle.rst:818
#, fuzzy
msgid ""
"does the same but all instances of ``MyPickler`` will by default share "
"the private dispatch table.  On the other hand, the code ::"
msgstr ""
"가 같은 일을 하지만, ``MyPickler`` 의 모든 인스턴스는 기본적으로 같은 디스패치 테이블을 공유합니다. "
":mod:`copyreg` 모듈을 사용하는 동등한 코드는 다음과 같습니다 ::"

#: ../../library/pickle.rst:821
msgid ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"
msgstr ""

#: ../../library/pickle.rst:825
msgid ""
"modifies the global dispatch table shared by all users of the "
":mod:`copyreg` module."
msgstr ""

#: ../../library/pickle.rst:830
msgid "Handling Stateful Objects"
msgstr "상태 저장 객체 처리"

#: ../../library/pickle.rst:836
#, fuzzy
msgid ""
"Here's an example that shows how to modify pickling behavior for a class."
" The :class:`!TextReader` class below opens a text file, and returns the "
"line number and line contents each time its :meth:`!readline` method is "
"called. If a :class:`!TextReader` instance is pickled, all attributes "
"*except* the file object member are saved. When the instance is "
"unpickled, the file is reopened, and reading resumes from the last "
"location. The :meth:`!__setstate__` and :meth:`!__getstate__` methods are"
" used to implement this behavior. ::"
msgstr ""
"다음은 클래스의 피클 동작을 수정하는 방법을 보여주는 예제입니다. :class:`TextReader` 클래스는 텍스트 파일을 열고,"
" :meth:`!readline` 메서드가 호출될 때마다 줄 번호와 줄 내용을 반환합니다. :class:`TextReader` "
"인스턴스가 피클 되면, 파일 객체 멤버를 *제외한* 모든 어트리뷰트가 저장됩니다. 인스턴스가 역 피클 될 때, 파일이 다시 열리고,"
" 마지막 위치에서 읽기가 다시 시작됩니다. :meth:`__setstate__` 와 :meth:`__getstate__` 메서드가 "
"이 행동을 구현하는 데 사용됩니다. ::"

#: ../../library/pickle.rst:844
#, python-format
msgid ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need "
"to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"
msgstr ""

#: ../../library/pickle.rst:882
msgid "A sample usage might be something like this::"
msgstr "사용 예는 다음과 같은 식입니다::"

#: ../../library/pickle.rst:884
msgid ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"
msgstr ""

#: ../../library/pickle.rst:896
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "형, 함수 및 기타 객체에 대한 사용자 정의 환원"

#: ../../library/pickle.rst:900
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In"
" particular we may want to customize pickling based on another criterion "
"than the object's type, or we may want to customize the pickling of "
"functions and classes."
msgstr ""
"때로, :attr:`~Pickler.dispatch_table`\\이 충분히 유연하지 않을 수 있습니다. 특히 객체의 형이 아닌 "
"다른 기준에 따라 피클링을 사용자 정의하거나, 함수와 클래스 피클링을 사용자 정의하고 싶을 수 있습니다."

#: ../../library/pickle.rst:905
#, fuzzy
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` "
"class and implement a :meth:`~Pickler.reducer_override` method. This "
"method can return an arbitrary reduction tuple (see "
":meth:`~object.__reduce__`). It can alternatively return "
":data:`NotImplemented` to fallback to the traditional behavior."
msgstr ""
"이럴 때, :class:`Pickler` 클래스의 서브 클래스를 만들고 :meth:`~Pickler.reducer_override`"
" 메서드를 구현할 수 있습니다. 이 메서드는 임의의 환원 튜플을 반환할 수 있습니다 (:meth:`__reduce__`\\를 "
"참조하십시오). 또는 ``NotImplemented``\\를 반환하여 전통적인 동작으로 폴백(fallback)할 수 있습니다."

#: ../../library/pickle.rst:910
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and "
":meth:`~Pickler.reducer_override` are defined, then "
":meth:`~Pickler.reducer_override` method takes priority."
msgstr ""
":attr:`~Pickler.dispatch_table`\\과 :meth:`~Pickler.reducer_override`\\가 "
"모두 정의되면, :meth:`~Pickler.reducer_override` 메서드가 우선합니다."

#: ../../library/pickle.rst:915
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be "
"called for the following objects: ``None``, ``True``, ``False``, and "
"exact instances of :class:`int`, :class:`float`, :class:`bytes`, "
":class:`str`, :class:`dict`, :class:`set`, :class:`frozenset`, "
":class:`list` and :class:`tuple`."
msgstr ""
"성능상의 이유로, 다음과 같은 객체에 대해서는 :meth:`~Pickler.reducer_override`\\가 호출되지 않을 수 "
"있습니다: ``None``, ``True``, ``False`` 및 :class:`int`, :class:`float`, "
":class:`bytes`, :class:`str`, :class:`dict`, :class:`set`, "
":class:`frozenset`, :class:`list` 및 :class:`tuple`\\의 정확한(exact) 인스턴스."

#: ../../library/pickle.rst:921
msgid ""
"Here is a simple example where we allow pickling and reconstructing a "
"given class::"
msgstr "다음은 주어진 클래스를 피클링하고 재구성할 수 있도록 하는 간단한 예제입니다::"

#: ../../library/pickle.rst:924
#, python-brace-format
msgid ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"
msgstr ""

#: ../../library/pickle.rst:956
msgid "Out-of-band Buffers"
msgstr "아웃 오브 밴드 버퍼"

#: ../../library/pickle.rst:960
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number "
"of memory copies, to preserve performance and resource consumption.  "
"However, normal operation of the :mod:`pickle` module, as it transforms a"
" graph-like structure of objects into a sequential stream of bytes, "
"intrinsically involves copying data to and from the pickle stream."
msgstr ""
"일부 상황에서는, :mod:`pickle` 모듈을 사용하여 많은 양의 데이터를 전송합니다. 따라서 성능과 자원 소비를 보존하기 위해"
" 메모리 복사 횟수를 최소화하는 것이 중요할 수 있습니다. 그러나, :mod:`pickle` 모듈의 정상적인 작동은, 객체의 "
"그래프(graph)적인 구조를 순차적인 바이트 스트림으로 변환하기 때문에, 본질적으로 피클 스트림과의 데이터 복사를 수반합니다."

#: ../../library/pickle.rst:967
msgid ""
"This constraint can be eschewed if both the *provider* (the "
"implementation of the object types to be transferred) and the *consumer* "
"(the implementation of the communications system) support the out-of-band"
" transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"*제공자(provider)*\\(전송될 객체 형의 구현)와 *소비자(consumer)*\\(통신 시스템의 구현)가 모두 피클 "
"프로토콜 5 이상에서 제공되는 아웃 오브 밴드 전송 기능을 지원하면 이 제약 조건을 피할 수 있습니다."

#: ../../library/pickle.rst:973
msgid "Provider API"
msgstr "제공자 API"

#: ../../library/pickle.rst:975
#, fuzzy
msgid ""
"The large data objects to be pickled must implement a "
":meth:`~object.__reduce_ex__` method specialized for protocol 5 and "
"higher, which returns a :class:`PickleBuffer` instance (instead of e.g. a"
" :class:`bytes` object) for any large data."
msgstr ""
"피클 될 대형 데이터 객체는 프로토콜 5 이상에 특화된 :meth:`__reduce_ex__` 메서드를 구현해야 합니다. 이 "
"메서드는 대형 데이터에 대해 (예를 들어 :class:`bytes` 객체 대신) :class:`PickleBuffer` 인스턴스를 "
"반환합니다."

#: ../../library/pickle.rst:980
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can "
"also opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
":class:`PickleBuffer` 객체는 하부 버퍼가 아웃 오브 밴드 전송 대상이라는 *신호를 보냅니다*. 이러한 객체는 "
":mod:`pickle` 모듈의 일반적인 사용과 호환됩니다. 그러나, 소비자는 :mod:`pickle`\\에게 그 버퍼를 스스로 "
"처리하겠다고 알릴 수도 있습니다."

#: ../../library/pickle.rst:987
msgid "Consumer API"
msgstr "소비자 API"

#: ../../library/pickle.rst:989
msgid ""
"A communications system can enable custom handling of the "
":class:`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"통신 시스템은 객체 그래프를 직렬화할 때 생성된 :class:`PickleBuffer` 객체의 사용자 정의 처리를 활성화할 수 "
"있습니다."

#: ../../library/pickle.rst:992
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to "
":class:`Pickler` (or to the :func:`dump` or :func:`dumps` function), "
"which will be called with each :class:`PickleBuffer` generated while "
"pickling the object graph.  Buffers accumulated by the *buffer_callback* "
"will not see their data copied into the pickle stream, only a cheap "
"marker will be inserted."
msgstr ""
"송신 측에서는, *buffer_callback* 인자를 :class:`Pickler` (또는 :func:`dump`\\나 "
":func:`dumps` 함수)에 전달해야 합니다. 이 인자는 객체 그래프를 피클링할 때 생성된 각 "
":class:`PickleBuffer`\\로 호출됩니다. *buffer_callback*\\에 의해 누적된 버퍼는 피클 스트림으로 "
"복사되지 않고, 저렴한 마커만 삽입됩니다."

#: ../../library/pickle.rst:999
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to "
":class:`Unpickler` (or to the :func:`load` or :func:`loads` function), "
"which is an iterable of the buffers which were passed to "
"*buffer_callback*. That iterable should produce buffers in the same order"
" as they were passed to *buffer_callback*.  Those buffers will provide "
"the data expected by the reconstructors of the objects whose pickling "
"produced the original :class:`PickleBuffer` objects."
msgstr ""
"수신 측에서는, *buffer_callback*\\에 전달된 버퍼의 이터러블인 *buffers* 인자를 "
":class:`Unpickler` (또는 :func:`load`\\나 :func:`loads` 함수)에 전달해야 합니다. 그 "
"이터러블은 *buffer_callback*\\에 전달된 것과 같은 순서로 버퍼를 만들어야 합니다. 이러한 버퍼는 피클링이 원래 "
":class:`PickleBuffer` 객체를 생성한 객체의 재구성자가 기대하는 데이터를 제공합니다."

#: ../../library/pickle.rst:1007
msgid ""
"Between the sending side and the receiving side, the communications "
"system is free to implement its own transfer mechanism for out-of-band "
"buffers. Potential optimizations include the use of shared memory or "
"datatype-dependent compression."
msgstr ""
"송신 측과 수신 측 사이에서, 통신 시스템은 아웃 오브 밴드 버퍼를 위한 자체 전송 메커니즘을 자유롭게 구현할 수 있습니다. "
"잠재적인 최적화에는 공유 메모리나 데이터 유형에 따른 압축이 포함됩니다."

#: ../../library/pickle.rst:1013
msgid "Example"
msgstr "예제"

#: ../../library/pickle.rst:1015
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` "
"subclass able to participate in out-of-band buffer pickling::"
msgstr "다음은 아웃 오브 버퍼 피클링에 참여할 수 있는 :class:`bytearray` 서브 클래스를 구현하는 간단한 예제입니다::"

#: ../../library/pickle.rst:1018
msgid ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return "
"it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"
msgstr ""

#: ../../library/pickle.rst:1039
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the "
"buffer's providing object if it has the right type.  This is an easy way "
"to simulate zero-copy behaviour on this toy example."
msgstr ""
"재구성자(``_reconstruct`` 클래스 메서드)는 올바른 형이면 버퍼를 제공하는 객체를 반환합니다. 이것은 이 장난감 "
"예제에서 제로-복사 동작을 흉내 내는 손쉬운 방법입니다."

#: ../../library/pickle.rst:1043
msgid ""
"On the consumer side, we can pickle those objects the usual way, which "
"when unserialized will give us a copy of the original object::"
msgstr "소비자 측에서는, 그 객체들을 일반적인 방법으로 피클 할 수 있습니다. 역 직렬화될 때 원래 객체의 사본을 제공합니다::"

#: ../../library/pickle.rst:1046
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"
msgstr ""

#: ../../library/pickle.rst:1052
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"그러나 *buffer_callback*\\을 전달하고 역 직렬화할 때 누적된 버퍼를 돌려주면, 원래의 객체를 다시 얻을 수 "
"있습니다::"

#: ../../library/pickle.rst:1055
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"
msgstr ""

#: ../../library/pickle.rst:1062
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its"
" own memory: you cannot create a :class:`bytearray` instance that is "
"backed by another object's memory.  However, third-party datatypes such "
"as NumPy arrays do not have this limitation, and allow use of zero-copy "
"pickling (or making as few copies as possible) when transferring between "
"distinct processes or systems."
msgstr ""
"이 예제는 :class:`bytearray`\\가 자체 메모리를 할당한다는 사실로 인해 제한됩니다: 즉, 다른 객체의 메모리를 "
"사용하는 :class:`bytearray` 인스턴스를 만들 수 없습니다. 그러나, NumPy 배열과 같은 제삼자 데이터형에는 이러한"
" 제한이 없으며, 별개의 프로세스나 시스템 간에 전송할 때 제로-복사 피클링(또는 최소한의 복사)을 사용할 수 있습니다."

#: ../../library/pickle.rst:1069
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- 아웃 오브 밴드 데이터를 포함하는 피클 프로토콜 5"

#: ../../library/pickle.rst:1075
msgid "Restricting Globals"
msgstr "전역 제한하기"

#: ../../library/pickle.rst:1080
msgid ""
"By default, unpickling will import any class or function that it finds in"
" the pickle data.  For many applications, this behaviour is unacceptable "
"as it permits the unpickler to import and invoke arbitrary code.  Just "
"consider what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"기본적으로, 역 피클링은 피클 데이터에서 찾은 모든 클래스나 함수를 임포트 합니다. 많은 응용 프로그램에서는, 역 피클러가 임의 "
"코드를 임포트하고 호출할 수 있으므로, 이 동작을 받아들일 수 없습니다. 이 손으로 만든 피클 데이터 스트림이 로드될 때 하는 일을"
" 생각해보십시오::"

#: ../../library/pickle.rst:1085
msgid ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"
msgstr ""

#: ../../library/pickle.rst:1090
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and"
" then apply the string argument \"echo hello world\".  Although this "
"example is inoffensive, it is not difficult to imagine one that could "
"damage your system."
msgstr ""
"이 예제에서, 역 피클러는 :func:`os.system` 함수를 임포트하고 문자열 인자 \"echo hello world\"를 "
"적용합니다. 이 예제가 공격적이지는 않지만, 어떤 것들은 시스템을 손상할 수 있다고 상상하기 어렵지 않습니다."

#: ../../library/pickle.rst:1094
msgid ""
"For this reason, you may want to control what gets unpickled by "
"customizing :meth:`Unpickler.find_class`.  Unlike its name suggests, "
":meth:`Unpickler.find_class` is called whenever a global (i.e., a class "
"or a function) is requested.  Thus it is possible to either completely "
"forbid globals or restrict them to a safe subset."
msgstr ""
"이런 이유로, 여러분은 :meth:`Unpickler.find_class`\\를 사용자 정의하여 언 피클 되는 것을 제어하고 싶을 "
"수 있습니다. 이름이 제안하는 것과는 달리, :meth:`Unpickler.find_class` 는 전역(즉, 클래스나 함수)이 "
"요청될 때마다 호출됩니다. 따라서 전역을 완전히 금지하거나 안전한 부분집합으로 제한할 수 있습니다."

#: ../../library/pickle.rst:1100
msgid ""
"Here is an example of an unpickler allowing only few safe classes from "
"the :mod:`builtins` module to be loaded::"
msgstr "다음은 :mod:`builtins` 모듈에서 몇 가지 안전한 클래스만 로드되도록 허용하는 역 피클러의 예입니다::"

#: ../../library/pickle.rst:1103
#, python-brace-format, python-format
msgid ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"
msgstr ""

#: ../../library/pickle.rst:1129
#, fuzzy
msgid "A sample usage of our unpickler working as intended::"
msgstr "우리의 역 피클러 작업이 의도한 사용 예::"

#: ../../library/pickle.rst:1131
msgid ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"
msgstr ""

#: ../../library/pickle.rst:1148
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or "
"third-party solutions."
msgstr ""
"예를 통해 알 수 있듯이, 역 피클을 허락하는 것에 주의를 기울여야 합니다. 따라서 보안이 중요하다면, "
":mod:`xmlrpc.client` 나 제삼자 솔루션의 마샬링 API 같은 대안을 고려할 수 있습니다."

#: ../../library/pickle.rst:1155
msgid "Performance"
msgstr "성능"

#: ../../library/pickle.rst:1157
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) "
"feature efficient binary encodings for several common features and built-"
"in types. Also, the :mod:`pickle` module has a transparent optimizer "
"written in C."
msgstr ""
"최신 버전의 피클 프로토콜(프로토콜 2 이상)은 몇 가지 공통 기능 및 내장형에 대한 효율적인 바이너리 인코딩을 제공합니다. 또한,"
" :mod:`pickle` 모듈은 C로 작성된 투명한 최적화기를 가지고 있습니다."

#: ../../library/pickle.rst:1165
msgid "Examples"
msgstr "예제"

#: ../../library/pickle.rst:1167
msgid "For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr "가장 간단한 코드로, :func:`dump`\\와 :func:`load` 함수를 사용하십시오. ::"

#: ../../library/pickle.rst:1169
#, python-brace-format
msgid ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"
msgstr ""

#: ../../library/pickle.rst:1183
msgid "The following example reads the resulting pickled data. ::"
msgstr "다음 예제는 결과로 나온 피클 데이터를 읽습니다. ::"

#: ../../library/pickle.rst:1185
msgid ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"
msgstr ""

#: ../../library/pickle.rst:1199
msgid "Module :mod:`copyreg`"
msgstr "모듈 :mod:`copyreg`"

#: ../../library/pickle.rst:1200
msgid "Pickle interface constructor registration for extension types."
msgstr "확장형에 대한 피클 인터페이스 생성자 등록"

#: ../../library/pickle.rst:1202
msgid "Module :mod:`pickletools`"
msgstr "모듈 :mod:`pickletools`"

#: ../../library/pickle.rst:1203
msgid "Tools for working with and analyzing pickled data."
msgstr "피클 된 데이터로 작업하고 분석하는 도구."

#: ../../library/pickle.rst:1205
msgid "Module :mod:`shelve`"
msgstr "모듈 :mod:`shelve`"

#: ../../library/pickle.rst:1206
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "객체의 인덱싱 된 데이터베이스; :mod:`pickle`\\을 사용합니다."

#: ../../library/pickle.rst:1208
msgid "Module :mod:`copy`"
msgstr "모듈 :mod:`copy`"

#: ../../library/pickle.rst:1209
msgid "Shallow and deep object copying."
msgstr "얕거나 깊은 객체 복사."

#: ../../library/pickle.rst:1211
msgid "Module :mod:`marshal`"
msgstr "모듈 :mod:`marshal`"

#: ../../library/pickle.rst:1212
msgid "High-performance serialization of built-in types."
msgstr "내장형의 고성능 직렬화."

#: ../../library/pickle.rst:1216
msgid "Footnotes"
msgstr "각주"

#: ../../library/pickle.rst:1217
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "이것을 :mod:`marshal` 모듈과 혼동하지 마십시오."

#: ../../library/pickle.rst:1219
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all "
":keyword:`!lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"이것이 :keyword:`!lambda` 함수가 pickle 될 수 없는 이유입니다: 모든 :keyword:`lambda` 함수는 "
"같은 이름을 공유합니다: ``<lambda>``."

#: ../../library/pickle.rst:1222
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an "
":exc:`AttributeError` but it could be something else."
msgstr ""
"발생하는 예외는 :exc:`ImportError` 나 :exc:`AttributeError` 일 가능성이 크지만, 그 밖의 다른 "
"것일 수 있습니다."

#: ../../library/pickle.rst:1225
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ":mod:`copy` 모듈은 얕거나 깊은 복사 연산에 이 프로토콜을 사용합니다."

#: ../../library/pickle.rst:1228
#, fuzzy
msgid ""
"The limitation on alphanumeric characters is due to the fact that "
"persistent IDs in protocol 0 are delimited by the newline character.  "
"Therefore if any kind of newline characters occurs in persistent IDs, the"
" resulting pickled data will become unreadable."
msgstr ""
"영숫자 문자의 제한은 프로토콜 0에서 지속성 ID가 개행 문자로 구분되기 때문입니다. 따라서 지속성 ID에 개행 문자가 포함되면 "
"결과 피클을 읽을 수 없게 됩니다."

#: ../../library/pickle.rst:12
msgid "persistence"
msgstr ""

#: ../../library/pickle.rst:12
msgid "persistent"
msgstr ""

#: ../../library/pickle.rst:12
msgid "objects"
msgstr ""

#: ../../library/pickle.rst:12
msgid "serializing"
msgstr ""

#: ../../library/pickle.rst:12
msgid "marshalling"
msgstr ""

#: ../../library/pickle.rst:12
msgid "flattening"
msgstr ""

#: ../../library/pickle.rst:12
msgid "pickling"
msgstr ""

#: ../../library/pickle.rst:123
msgid "External Data Representation"
msgstr ""

#: ../../library/pickle.rst:672
msgid "copy"
msgstr ""

#: ../../library/pickle.rst:672
msgid "protocol"
msgstr ""

#: ../../library/pickle.rst:756
msgid "persistent_id (pickle protocol)"
msgstr ""

#: ../../library/pickle.rst:756
msgid "persistent_load (pickle protocol)"
msgstr ""

#: ../../library/pickle.rst:832
msgid "__getstate__() (copy protocol)"
msgstr ""

#: ../../library/pickle.rst:832
msgid "__setstate__() (copy protocol)"
msgstr ""

#: ../../library/pickle.rst:1077
msgid "find_class() (pickle protocol)"
msgstr ""

#~ msgid "``None``, ``True``, and ``False``"
#~ msgstr "``None``, ``True`` 와 ``False``"

#~ msgid "built-in functions defined at the top level of a module"
#~ msgstr "모듈의 최상위 수준에서 정의된 내장 함수"

