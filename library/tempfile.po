# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/tempfile.rst:2
#, fuzzy
msgid ":mod:`!tempfile` --- Generate temporary files and directories"
msgstr ":mod:`tempfile` --- 임시 파일과 디렉터리 생성"

#: ../../library/tempfile.rst:9
msgid "**Source code:** :source:`Lib/tempfile.py`"
msgstr "**소스 코드:** :source:`Lib/tempfile.py`"

#: ../../library/tempfile.rst:17
#, fuzzy
msgid ""
"This module creates temporary files and directories.  It works on all "
"supported platforms. :class:`TemporaryFile`, :class:`NamedTemporaryFile`,"
" :class:`TemporaryDirectory`, and :class:`SpooledTemporaryFile` are high-"
"level interfaces which provide automatic cleanup and can be used as "
":term:`context managers <context manager>`. :func:`mkstemp` and "
":func:`mkdtemp` are lower-level functions which require manual cleanup."
msgstr ""
"이 모듈은 임시 파일과 디렉터리를 만듭니다. 지원되는 모든 플랫폼에서 작동합니다. :class:`TemporaryFile`, "
":class:`NamedTemporaryFile`, :class:`TemporaryDirectory` 및 "
":class:`SpooledTemporaryFile`\\은 자동 정리를 제공하고 컨텍스트 관리자로 사용할 수 있는 고수준 "
"인터페이스입니다. :func:`mkstemp`\\와 :func:`mkdtemp`\\는 수동 정리가 필요한 저수준 함수입니다."

#: ../../library/tempfile.rst:24
msgid ""
"All the user-callable functions and constructors take additional "
"arguments which allow direct control over the location and name of "
"temporary files and directories. Files names used by this module include "
"a string of random characters which allows those files to be securely "
"created in shared temporary directories. To maintain backward "
"compatibility, the argument order is somewhat odd; it is recommended to "
"use keyword arguments for clarity."
msgstr ""
"사용자가 호출할 수 있는 모든 함수와 생성자는 임시 파일과 디렉터리의 위치와 이름을 직접 제어할 수 있도록 하는 추가 인자를 "
"취합니다. 이 모듈에서 사용하는 파일 이름에는 무작위 문자의 문자열이 포함되어있어 공유 임시 디렉터리에서 해당 파일을 안전하게 만들"
" 수 있도록 합니다. 이전 버전과의 호환성을 유지하기 위해, 인자 순서는 다소 이상합니다; 명확성을 위해 키워드 인자를 사용하는 "
"것이 좋습니다."

#: ../../library/tempfile.rst:32
msgid "The module defines the following user-callable items:"
msgstr "이 모듈은 다음과 같은 사용자 호출 가능 항목을 정의합니다:"

#: ../../library/tempfile.rst:36
msgid ""
"Return a :term:`file-like object` that can be used as a temporary storage"
" area. The file is created securely, using the same rules as "
":func:`mkstemp`. It will be destroyed as soon as it is closed (including "
"an implicit close when the object is garbage collected).  Under Unix, the"
" directory entry for the file is either not created at all or is removed "
"immediately after the file is created.  Other platforms do not support "
"this; your code should not rely on a temporary file created using this "
"function having or not having a visible name in the file system."
msgstr ""
"임시 저장 영역으로 사용할 수 있는 :term:`파일류 객체 <file-like object>`\\를 반환합니다. "
":func:`mkstemp`\\와 같은 규칙을 사용하여 파일이 안전하게 만들어집니다. 닫히는 즉시 삭제됩니다 (객체가 가비지 수집될"
" 때 묵시적인 닫기를 포함합니다). 유닉스에서, 파일의 디렉터리 항목은 전혀 만들어지지 않거나 파일이 만들어진 직후에 제거됩니다. "
"다른 플랫폼은 이를 지원하지 않습니다; 코드는 이 함수를 사용하여 만들어진 임시 파일이 파일 시스템에서 보이는 이름이 있거나 "
"없는지에 의존해서는 안 됩니다."

#: ../../library/tempfile.rst:44
#, fuzzy
msgid ""
"The resulting object can be used as a :term:`context manager` (see :ref"
":`tempfile-examples`).  On completion of the context or destruction of "
"the file object the temporary file will be removed from the filesystem."
msgstr ""
"결과 객체는 컨텍스트 관리자로 사용할 수 있습니다 (:ref:`tempfile-examples`\\를 참조하십시오). 컨텍스트가 "
"완료되거나 파일 객체가 파괴되면 임시 파일이 파일 시스템에서 제거됩니다."

#: ../../library/tempfile.rst:49
msgid ""
"The *mode* parameter defaults to ``'w+b'`` so that the file created can "
"be read and written without being closed.  Binary mode is used so that it"
" behaves consistently on all platforms without regard for the data that "
"is stored.  *buffering*, *encoding*, *errors* and *newline* are "
"interpreted as for :func:`open`."
msgstr ""
"*mode* 매개 변수는 기본적으로 ``'w+b'``\\로 설정되므로 만들어진 파일을 닫지 않고 읽고 쓸 수 있습니다. 저장된 "
"데이터와 관계없이 모든 플랫폼에서 일관되게 작동하도록 바이너리 모드가 사용됩니다. *buffering*, *encoding*, "
"*errors* 및 *newline*\\은 :func:`open`\\처럼 해석됩니다."

#: ../../library/tempfile.rst:55
msgid ""
"The *dir*, *prefix* and *suffix* parameters have the same meaning and "
"defaults as with :func:`mkstemp`."
msgstr "*dir*, *prefix* 및 *suffix* 매개 변수는 :func:`mkstemp`\\와 같은 의미와 기본값을 갖습니다."

#: ../../library/tempfile.rst:58
msgid ""
"The returned object is a true file object on POSIX platforms.  On other "
"platforms, it is a file-like object whose :attr:`!file` attribute is the "
"underlying true file object."
msgstr ""
"반환된 객체는 POSIX 플랫폼에서 실제 파일 객체입니다. 다른 플랫폼에서는, :attr:`!file` 어트리뷰트가 하부 실제 파일"
" 객체인 파일류 객체입니다."

#: ../../library/tempfile.rst:62
#, fuzzy
msgid ""
"The :py:const:`os.O_TMPFILE` flag is used if it is available and works "
"(Linux-specific, requires Linux kernel 3.11 or later)."
msgstr ""
":py:data:`os.O_TMPFILE` 플래그는 사용할 수 있고 작동하면 사용됩니다 (리눅스 특정, 리눅스 커널 3.11 이상이"
" 필요합니다)."

#: ../../library/tempfile.rst:65
msgid ""
"On platforms that are neither Posix nor Cygwin, TemporaryFile is an alias"
" for NamedTemporaryFile."
msgstr ""

#: ../../library/tempfile.rst:68 ../../library/tempfile.rst:137
#: ../../library/tempfile.rst:264
msgid ""
"Raises an :ref:`auditing event <auditing>` ``tempfile.mkstemp`` with "
"argument ``fullpath``."
msgstr ""
"인자 ``fullpath``\\로 :ref:`감사 이벤트 <auditing>` ``tempfile.mkstemp``\\를 "
"발생시킵니다."

#: ../../library/tempfile.rst:72
#, fuzzy
msgid "The :py:const:`os.O_TMPFILE` flag is now used if available."
msgstr "사용할 수 있으면 :py:data:`os.O_TMPFILE` 플래그가 사용됩니다."

#: ../../library/tempfile.rst:74 ../../library/tempfile.rst:139
#: ../../library/tempfile.rst:169
msgid "Added *errors* parameter."
msgstr "*errors* 매개 변수를 추가했습니다."

#: ../../library/tempfile.rst:80
msgid ""
"This function operates exactly as :func:`TemporaryFile` does, except the "
"following differences:"
msgstr ""

#: ../../library/tempfile.rst:83
msgid ""
"This function returns a file that is guaranteed to have a visible name in"
" the file system."
msgstr ""

#: ../../library/tempfile.rst:85
msgid ""
"To manage the named file, it extends the parameters of "
":func:`TemporaryFile` with *delete* and *delete_on_close* parameters that"
" determine whether and how the named file should be automatically "
"deleted."
msgstr ""

#: ../../library/tempfile.rst:89
msgid ""
"The returned object is always a :term:`file-like object` whose "
":attr:`!file` attribute is the underlying true file object. This file-"
"like object can be used in a :keyword:`with` statement, just like a "
"normal file.  The name of the temporary file can be retrieved from the "
":attr:`!name` attribute of the returned file-like object. On Unix, unlike"
" with the :func:`TemporaryFile`, the directory entry does not get "
"unlinked immediately after the file creation."
msgstr ""

#: ../../library/tempfile.rst:97
msgid ""
"If *delete* is true (the default) and *delete_on_close* is true (the "
"default), the file is deleted as soon as it is closed. If *delete* is "
"true and *delete_on_close* is false, the file is deleted on context "
"manager exit only, or else when the :term:`file-like object` is "
"finalized. Deletion is not always guaranteed in this case (see "
":meth:`object.__del__`). If *delete* is false, the value of "
"*delete_on_close* is ignored."
msgstr ""

#: ../../library/tempfile.rst:104
msgid ""
"Therefore to use the name of the temporary file to reopen the file after "
"closing it, either make sure not to delete the file upon closure (set the"
" *delete* parameter to be false) or, in case the temporary file is "
"created in a :keyword:`with` statement, set the *delete_on_close* "
"parameter to be false. The latter approach is recommended as it provides "
"assistance in automatic cleaning of the temporary file upon the context "
"manager exit."
msgstr ""

#: ../../library/tempfile.rst:111
msgid ""
"Opening the temporary file again by its name while it is still open works"
" as follows:"
msgstr ""

#: ../../library/tempfile.rst:114
msgid "On POSIX the file can always be opened again."
msgstr ""

#: ../../library/tempfile.rst:115
msgid ""
"On Windows, make sure that at least one of the following conditions are "
"fulfilled:"
msgstr ""

#: ../../library/tempfile.rst:118
msgid "*delete* is false"
msgstr ""

#: ../../library/tempfile.rst:119
msgid ""
"additional open shares delete access (e.g. by calling :func:`os.open` "
"with the flag ``O_TEMPORARY``)"
msgstr ""

#: ../../library/tempfile.rst:121
msgid ""
"*delete* is true but *delete_on_close* is false. Note, that in this case "
"the additional opens that do not share delete access (e.g. created via "
"builtin :func:`open`) must be closed before exiting the context manager, "
"else the :func:`os.unlink` call on context manager exit will fail with a "
":exc:`PermissionError`."
msgstr ""

#: ../../library/tempfile.rst:127
msgid ""
"On Windows, if *delete_on_close* is false, and the file is created in a "
"directory for which the user lacks delete access, then the "
":func:`os.unlink` call on exit of the context manager will fail with a "
":exc:`PermissionError`. This cannot happen when *delete_on_close* is true"
" because delete access is requested by the open, which fails immediately "
"if the requested access is not granted."
msgstr ""

#: ../../library/tempfile.rst:134
msgid ""
"On POSIX (only), a process that is terminated abruptly with SIGKILL "
"cannot automatically delete any NamedTemporaryFiles it created."
msgstr ""

#: ../../library/tempfile.rst:142
#, fuzzy
msgid "Added *delete_on_close* parameter."
msgstr "*errors* 매개 변수를 추가했습니다."

#: ../../library/tempfile.rst:148
#, fuzzy
msgid ""
"This class operates exactly as :func:`TemporaryFile` does, except that "
"data is spooled in memory until the file size exceeds *max_size*, or "
"until the file's :func:`~io.IOBase.fileno` method is called, at which "
"point the contents are written to disk and operation proceeds as with "
":func:`TemporaryFile`."
msgstr ""
"이 함수는 파일 크기가 *max_size*\\를 초과할 때까지, 또는 파일의 :func:`fileno` 메서드가 호출될 때까지 "
"데이터가 메모리에 스풀링 되는 것을 제외하고는 :func:`TemporaryFile`\\과 똑같이 작동합니다. 이 시점에서 내용은 "
"디스크에 기록되고 :func:`TemporaryFile`\\처럼 작업이 진행됩니다."

#: ../../library/tempfile.rst:156
#, fuzzy
msgid ""
"The resulting file has one additional method, :meth:`!rollover`, which "
"causes the file to roll over to an on-disk file regardless of its size."
msgstr ""
"결과 파일에는 추가 메서드인 :func:`rollover`\\가 있으며, 파일 크기와 관계없이 파일을 디스크 상의 파일로 "
"롤오버(roll over) 합니다."

#: ../../library/tempfile.rst:159
#, fuzzy
msgid ""
"The returned object is a file-like object whose :attr:`!_file` attribute "
"is either an :class:`io.BytesIO` or :class:`io.TextIOWrapper` object "
"(depending on whether binary or text *mode* was specified) or a true file"
" object, depending on whether :meth:`rollover` has been called.  This "
"file-like object can be used in a :keyword:`with` statement, just like a "
"normal file."
msgstr ""
"반환된 객체는 파일류 객체인데, :func:`rollover`\\가 호출되었는지에 따라 :attr:`_file` 어트리뷰트는 "
":class:`io.BytesIO`\\나 :class:`io.TextIOWrapper` 객체(바이너리나 텍스트 *mode*\\가 "
"지정되었는지에 따라)이거나 실제 파일 객체입니다. 이 파일류 객체는 일반 파일과 마찬가지로 :keyword:`with` 문에서 "
"사용할 수 있습니다."

#: ../../library/tempfile.rst:166
#, fuzzy
msgid "the truncate method now accepts a *size* argument."
msgstr "truncate 메서드는 이제 ``size`` 인자를 허용합니다."

#: ../../library/tempfile.rst:172
msgid ""
"Fully implements the :class:`io.BufferedIOBase` and "
":class:`io.TextIOBase` abstract base classes (depending on whether binary"
" or text *mode* was specified)."
msgstr ""

#: ../../library/tempfile.rst:180
#, fuzzy
msgid ""
"This class securely creates a temporary directory using the same rules as"
" :func:`mkdtemp`. The resulting object can be used as a :term:`context "
"manager` (see :ref:`tempfile-examples`).  On completion of the context or"
" destruction of the temporary directory object, the newly created "
"temporary directory and all its contents are removed from the filesystem."
msgstr ""
"이 함수는 :func:`mkdtemp`\\와 같은 규칙을 사용하여 임시 디렉터리를 안전하게 만듭니다. 결과 객체는 컨텍스트 관리자로"
" 사용할 수 있습니다 (:ref:`tempfile-examples`\\를 참조하십시오). 컨텍스트가 완료되거나 임시 디렉터리 객체가"
" 파괴되면 새로 만들어진 임시 디렉터리와 모든 내용이 파일 시스템에서 제거됩니다."

#: ../../library/tempfile.rst:188
#, fuzzy
msgid ""
"The directory name can be retrieved from the :attr:`!name` attribute of "
"the returned object.  When the returned object is used as a "
":term:`context manager`, the :attr:`!name` will be assigned to the target"
" of the :keyword:`!as` clause in the :keyword:`with` statement, if there "
"is one."
msgstr ""
"반환된 객체의 :attr:`name` 어트리뷰트에서 디렉터리 이름을 꺼낼 수 있습니다. 반환된 객체가 컨텍스트 관리자로 사용될 때,"
" :attr:`name`\\은 :keyword:`with` 문의 :keyword:`!as` 절의 대상에 (있다면) 대입됩니다."

#: ../../library/tempfile.rst:195
msgid ""
"The directory can be explicitly cleaned up by calling the "
":meth:`!cleanup` method. If *ignore_cleanup_errors* is true, any "
"unhandled exceptions during explicit or implicit cleanup (such as a "
":exc:`PermissionError` removing open files on Windows) will be ignored, "
"and the remaining removable items deleted on a \"best-effort\" basis. "
"Otherwise, errors will be raised in whatever context cleanup occurs (the "
":meth:`!cleanup` call, exiting the context manager, when the object is "
"garbage-collected or during interpreter shutdown)."
msgstr ""

#: ../../library/tempfile.rst:204
msgid ""
"The *delete* parameter can be used to disable cleanup of the directory "
"tree upon exiting the context.  While it may seem unusual for a context "
"manager to disable the action taken when exiting the context, it can be "
"useful during debugging or when you need your cleanup behavior to be "
"conditional based on other logic."
msgstr ""

#: ../../library/tempfile.rst:210 ../../library/tempfile.rst:290
msgid ""
"Raises an :ref:`auditing event <auditing>` ``tempfile.mkdtemp`` with "
"argument ``fullpath``."
msgstr ""
"인자 ``fullpath``\\로 :ref:`감사 이벤트 <auditing>` ``tempfile.mkdtemp``\\를 "
"발생시킵니다."

#: ../../library/tempfile.rst:214
#, fuzzy
msgid "Added *ignore_cleanup_errors* parameter."
msgstr "*errors* 매개 변수를 추가했습니다."

#: ../../library/tempfile.rst:217
#, fuzzy
msgid "Added the *delete* parameter."
msgstr "*errors* 매개 변수를 추가했습니다."

#: ../../library/tempfile.rst:223
msgid ""
"Creates a temporary file in the most secure manner possible.  There are "
"no race conditions in the file's creation, assuming that the platform "
"properly implements the :const:`os.O_EXCL` flag for :func:`os.open`.  The"
" file is readable and writable only by the creating user ID.  If the "
"platform uses permission bits to indicate whether a file is executable, "
"the file is executable by no one.  The file descriptor is not inherited "
"by child processes."
msgstr ""
"가장 안전한 방식으로 임시 파일을 만듭니다. 플랫폼이 :func:`os.open`\\에서 :const:`os.O_EXCL` 플래그를"
" 올바르게 구현한다고 가정할 때, 파일 생성에 경쟁 조건이 없습니다. 파일은 만드는 사용자 ID만 읽고 쓸 수 있습니다. 플랫폼이 "
"권한 비트를 사용하여 파일이 실행 가능한지를 나타내면, 파일은 아무도 실행할 수 없습니다. 파일 기술자는 자식 프로세스에 의해 "
"상속되지 않습니다."

#: ../../library/tempfile.rst:231
msgid ""
"Unlike :func:`TemporaryFile`, the user of :func:`mkstemp` is responsible "
"for deleting the temporary file when done with it."
msgstr ""
":func:`TemporaryFile`\\과 달리, :func:`mkstemp`\\의 사용자는 임시 파일로의 작업을 끝내면 파일을 "
"삭제해야 합니다."

#: ../../library/tempfile.rst:234
msgid ""
"If *suffix* is not ``None``, the file name will end with that suffix, "
"otherwise there will be no suffix.  :func:`mkstemp` does not put a dot "
"between the file name and the suffix; if you need one, put it at the "
"beginning of *suffix*."
msgstr ""
"*suffix*\\가 ``None``\\이 아니면, 파일 이름은 해당 접미사로 끝납니다, 그렇지 않으면 접미사가 없습니다. "
":func:`mkstemp`\\는 파일 이름과 접미사 사이에 점을 넣지 않습니다; 필요하면 *suffix*\\의 시작 부분에 "
"넣으십시오."

#: ../../library/tempfile.rst:239
msgid ""
"If *prefix* is not ``None``, the file name will begin with that prefix; "
"otherwise, a default prefix is used.  The default is the return value of "
":func:`gettempprefix` or :func:`gettempprefixb`, as appropriate."
msgstr ""
"*prefix*\\가 ``None``\\이 아니면, 파일 이름은 해당 접두사로 시작합니다; 그렇지 않으면 기본 접두사가 사용됩니다."
" 기본값은 :func:`gettempprefix`\\나 :func:`gettempprefixb` 중 적절한 것의 반환 값입니다."

#: ../../library/tempfile.rst:243
msgid ""
"If *dir* is not ``None``, the file will be created in that directory; "
"otherwise, a default directory is used.  The default directory is chosen "
"from a platform-dependent list, but the user of the application can "
"control the directory location by setting the *TMPDIR*, *TEMP* or *TMP* "
"environment variables.  There is thus no guarantee that the generated "
"filename will have any nice properties, such as not requiring quoting "
"when passed to external commands via ``os.popen()``."
msgstr ""
"*dir*\\이 ``None``\\이 아니면, 파일은 해당 디렉터리에 만들어집니다; 그렇지 않으면 기본 디렉터리가 사용됩니다. 기본"
" 디렉터리는 플랫폼별 목록에서 선택되지만, 응용 프로그램 사용자는 *TMPDIR*, *TEMP* 또는 *TMP* 환경 변수를 "
"설정하여 디렉터리 위치를 제어할 수 있습니다. 따라서 생성된 파일명이 ``os.popen()``\\을 통해 외부 명령에 전달될 때 "
"따옴표 처리할 필요가 없는 것과 같은 멋진 속성을 가질 것이라는 보장은 없습니다."

#: ../../library/tempfile.rst:251
msgid ""
"If any of *suffix*, *prefix*, and *dir* are not ``None``, they must be "
"the same type. If they are bytes, the returned name will be bytes instead"
" of str. If you want to force a bytes return value with otherwise default"
" behavior, pass ``suffix=b''``."
msgstr ""
"*suffix*, *prefix* 및 *dir* 중 어느 것이라도 ``None``\\이 아니면, 그들은 같은 형이어야 합니다. "
"이들이 바이트열이면, 반환되는 이름은 str 대신 바이트열입니다. 기본 동작으로 바이트열 반환 값을 강제하려면 "
"``suffix=b''``\\를 전달하십시오."

#: ../../library/tempfile.rst:257
msgid ""
"If *text* is specified and true, the file is opened in text mode. "
"Otherwise, (the default) the file is opened in binary mode."
msgstr "*text*\\가 지정되고 참이면, 파일은 텍스트 모드로 열립니다. 그렇지 않으면 (기본값) 파일은 바이너리 모드로 열립니다."

#: ../../library/tempfile.rst:260
msgid ""
":func:`mkstemp` returns a tuple containing an OS-level handle to an open "
"file (as would be returned by :func:`os.open`) and the absolute pathname "
"of that file, in that order."
msgstr ""
":func:`mkstemp`\\는 열린 파일에 대한 OS 수준 핸들(:func:`os.open`\\에서 반환하는 것)과 해당 파일의"
" 절대 경로를 이 순서대로 포함하는 튜플을 반환합니다."

#: ../../library/tempfile.rst:266 ../../library/tempfile.rst:292
msgid ""
"*suffix*, *prefix*, and *dir* may now be supplied in bytes in order to "
"obtain a bytes return value.  Prior to this, only str was allowed. "
"*suffix* and *prefix* now accept and default to ``None`` to cause an "
"appropriate default value to be used."
msgstr ""
"바이트열 반환 값을 얻기 위해 *suffix*, *prefix* 및 *dir*\\를 이제 바이트열로 제공할 수 있습니다. 이전에는,"
" str만 허용되었습니다. *suffix*\\와 *prefix*\\는 이제 기본값이 ``None``\\이고 적절한 기본값이 "
"사용되도록 합니다."

#: ../../library/tempfile.rst:272 ../../library/tempfile.rst:298
msgid "The *dir* parameter now accepts a :term:`path-like object`."
msgstr "*dir* 매개 변수는 이제 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/tempfile.rst:278
msgid ""
"Creates a temporary directory in the most secure manner possible. There "
"are no race conditions in the directory's creation.  The directory is "
"readable, writable, and searchable only by the creating user ID."
msgstr ""
"가장 안전한 방식으로 임시 디렉터리를 만듭니다. 디렉터리 생성에 경쟁 조건이 없습니다. 디렉터리는 만드는 사용자 ID만 읽고 쓰고 "
"검색할 수 있습니다."

#: ../../library/tempfile.rst:282
msgid ""
"The user of :func:`mkdtemp` is responsible for deleting the temporary "
"directory and its contents when done with it."
msgstr ":func:`mkdtemp`\\의 사용자는 임시 디렉터리로의 작업을 끝내면 임시 디렉터리와 디렉터리의 내용을 삭제해야 합니다."

#: ../../library/tempfile.rst:285
msgid ""
"The *prefix*, *suffix*, and *dir* arguments are the same as for "
":func:`mkstemp`."
msgstr "*prefix*, *suffix* 및 *dir* 인자는 :func:`mkstemp`\\와 같습니다."

#: ../../library/tempfile.rst:288
msgid ":func:`mkdtemp` returns the absolute pathname of the new directory."
msgstr ":func:`mkdtemp`\\는 새 디렉터리의 절대 경로명을 반환합니다."

#: ../../library/tempfile.rst:301
#, fuzzy
msgid ""
":func:`mkdtemp` now always returns an absolute path, even if *dir* is "
"relative."
msgstr ":func:`mkdtemp`\\는 새 디렉터리의 절대 경로명을 반환합니다."

#: ../../library/tempfile.rst:307
msgid ""
"Return the name of the directory used for temporary files. This defines "
"the default value for the *dir* argument to all functions in this module."
msgstr "임시 파일에 사용된 디렉터리 이름을 반환합니다. 이것은 이 모듈의 모든 함수에 대한 *dir* 인자의 기본값을 정의합니다."

#: ../../library/tempfile.rst:311
msgid ""
"Python searches a standard list of directories to find one which the "
"calling user can create files in.  The list is:"
msgstr "파이썬은 표준 디렉터리 목록을 검색하여 호출하는 사용자가 파일을 만들 수 있는 디렉터리를 찾습니다. 목록은 다음과 같습니다:"

#: ../../library/tempfile.rst:314
msgid "The directory named by the :envvar:`TMPDIR` environment variable."
msgstr ":envvar:`TMPDIR` 환경 변수로 명명된 디렉터리."

#: ../../library/tempfile.rst:316
msgid "The directory named by the :envvar:`TEMP` environment variable."
msgstr ":envvar:`TEMP` 환경 변수로 명명된 디렉터리."

#: ../../library/tempfile.rst:318
msgid "The directory named by the :envvar:`TMP` environment variable."
msgstr ":envvar:`TMP` 환경 변수로 명명된 디렉터리."

#: ../../library/tempfile.rst:320
msgid "A platform-specific location:"
msgstr "플랫폼별 위치:"

#: ../../library/tempfile.rst:322
msgid ""
"On Windows, the directories :file:`C:\\\\TEMP`, :file:`C:\\\\TMP`, "
":file:`\\\\TEMP`, and :file:`\\\\TMP`, in that order."
msgstr ""
"윈도우에서, 디렉터리 :file:`C:\\\\TEMP`, :file:`C:\\\\TMP`, :file:`\\\\TEMP` 및 "
":file:`\\\\TMP`, 이 순서대로."

#: ../../library/tempfile.rst:325
msgid ""
"On all other platforms, the directories :file:`/tmp`, :file:`/var/tmp`, "
"and :file:`/usr/tmp`, in that order."
msgstr ""
"다른 모든 플랫폼에서, 디렉터리 :file:`/tmp`, :file:`/var/tmp` 및 :file:`/usr/tmp`, 이 "
"순서대로."

#: ../../library/tempfile.rst:328
msgid "As a last resort, the current working directory."
msgstr "최후의 수단으로, 현재 작업 디렉터리."

#: ../../library/tempfile.rst:330
msgid ""
"The result of this search is cached, see the description of "
":data:`tempdir` below."
msgstr "이 검색 결과는 캐시 됩니다, 아래 :data:`tempdir` 설명을 참조하십시오."

#: ../../library/tempfile.rst:335
msgid ""
"Always returns a str.  Previously it would return any :data:`tempdir` "
"value regardless of type so long as it was not ``None``."
msgstr ""

#: ../../library/tempfile.rst:340
msgid "Same as :func:`gettempdir` but the return value is in bytes."
msgstr ":func:`gettempdir`\\과 같지만, 반환 값이 바이트열입니다."

#: ../../library/tempfile.rst:346
msgid ""
"Return the filename prefix used to create temporary files.  This does not"
" contain the directory component."
msgstr "임시 파일을 만드는 데 사용된 파일명 접두사를 반환합니다. 디렉터리 구성 요소가 포함되어 있지 않습니다."

#: ../../library/tempfile.rst:351
msgid "Same as :func:`gettempprefix` but the return value is in bytes."
msgstr ":func:`gettempprefix`\\와 같지만, 반환 값이 바이트열입니다."

#: ../../library/tempfile.rst:355
#, fuzzy
msgid ""
"The module uses a global variable to store the name of the directory used"
" for temporary files returned by :func:`gettempdir`.  It can be set "
"directly to override the selection process, but this is discouraged. All "
"functions in this module take a *dir* argument which can be used to "
"specify the directory. This is the recommended approach that does not "
"surprise other unsuspecting code by changing global API behavior."
msgstr ""
"모듈은 전역 변수를 사용하여 :func:`gettempdir`\\이 반환한 임시 파일에 사용되는 디렉터리의 이름을 저장합니다. 선택"
" 절차를 무시하도록 직접 설정할 수 있지만, 권장하지 않습니다. 이 모듈의 모든 함수는 디렉터리를 지정하는 데 사용할 수 있는 "
"*dir* 인자를 사용하며 이는 권장되는 방법입니다."

#: ../../library/tempfile.rst:364
#, fuzzy
msgid ""
"When set to a value other than ``None``, this variable defines the "
"default value for the *dir* argument to the functions defined in this "
"module, including its type, bytes or str.  It cannot be a :term:`path-"
"like object`."
msgstr "``None`` 이외의 값으로 설정되면, 이 변수는 이 모듈에 정의된 함수의 *dir* 인자의 기본값을 정의합니다."

#: ../../library/tempfile.rst:369
msgid ""
"If ``tempdir`` is ``None`` (the default) at any call to any of the above "
"functions except :func:`gettempprefix` it is initialized following the "
"algorithm described in :func:`gettempdir`."
msgstr ""
":func:`gettempprefix`\\를 제외한 위의 함수를 호출할 때 ``tempdir``\\이 "
"``None``\\(기본값)이면 :func:`gettempdir`\\에 설명된 알고리즘에 따라 초기화됩니다."

#: ../../library/tempfile.rst:375
msgid ""
"Beware that if you set ``tempdir`` to a bytes value, there is a nasty "
"side effect: The global default return type of :func:`mkstemp` and "
":func:`mkdtemp` changes to bytes when no explicit ``prefix``, ``suffix``,"
" or ``dir`` arguments of type str are supplied. Please do not write code "
"expecting or depending on this. This awkward behavior is maintained for "
"compatibility with the historical implementation."
msgstr ""

#: ../../library/tempfile.rst:386
msgid "Examples"
msgstr "예"

#: ../../library/tempfile.rst:388
msgid "Here are some examples of typical usage of the :mod:`tempfile` module::"
msgstr "다음은 :mod:`tempfile` 모듈의 일반적인 사용법에 대한 몇 가지 예입니다::"

#: ../../library/tempfile.rst:390
msgid ""
">>> import tempfile\n"
"\n"
"# create a temporary file and write some data to it\n"
">>> fp = tempfile.TemporaryFile()\n"
">>> fp.write(b'Hello world!')\n"
"# read data from file\n"
">>> fp.seek(0)\n"
">>> fp.read()\n"
"b'Hello world!'\n"
"# close the file, it will be removed\n"
">>> fp.close()\n"
"\n"
"# create a temporary file using a context manager\n"
">>> with tempfile.TemporaryFile() as fp:\n"
"...     fp.write(b'Hello world!')\n"
"...     fp.seek(0)\n"
"...     fp.read()\n"
"b'Hello world!'\n"
">>>\n"
"# file is now closed and removed\n"
"\n"
"# create a temporary file using a context manager\n"
"# close the file, use the name to open the file again\n"
">>> with tempfile.NamedTemporaryFile(delete_on_close=False) as fp:\n"
"...     fp.write(b'Hello world!')\n"
"...     fp.close()\n"
"... # the file is closed, but not removed\n"
"... # open the file again by using its name\n"
"...     with open(fp.name, mode='rb') as f:\n"
"...         f.read()\n"
"b'Hello world!'\n"
">>>\n"
"# file is now removed\n"
"\n"
"# create a temporary directory using the context manager\n"
">>> with tempfile.TemporaryDirectory() as tmpdirname:\n"
"...     print('created temporary directory', tmpdirname)\n"
">>>\n"
"# directory and contents have been removed"
msgstr ""

#: ../../library/tempfile.rst:433
msgid "Deprecated functions and variables"
msgstr "폐지된 함수와 변수"

#: ../../library/tempfile.rst:435
msgid ""
"A historical way to create temporary files was to first generate a file "
"name with the :func:`mktemp` function and then create a file using this "
"name. Unfortunately this is not secure, because a different process may "
"create a file with this name in the time between the call to "
":func:`mktemp` and the subsequent attempt to create the file by the first"
" process. The solution is to combine the two steps and create the file "
"immediately. This approach is used by :func:`mkstemp` and the other "
"functions described above."
msgstr ""
"임시 파일을 만드는 역사적인 방법은 먼저 :func:`mktemp` 함수를 사용하여 파일 이름을 생성한 다음 이 이름을 사용하여 "
"파일을 만드는 것입니다. 불행히도 :func:`mktemp` 호출과 파일을 만들려는 후속 시도 사이에 다른 프로세스가 이 이름으로 "
"파일을 만들 수 있어서 이 방법은 안전하지 않습니다. 해결책은 두 단계를 결합하고 파일을 즉시 만드는 것입니다. 이 접근법이 "
":func:`mkstemp`\\와 위에서 설명한 다른 함수에서 사용됩니다."

#: ../../library/tempfile.rst:446
msgid "Use :func:`mkstemp` instead."
msgstr "대신 :func:`mkstemp`\\를 사용하십시오."

#: ../../library/tempfile.rst:449
msgid ""
"Return an absolute pathname of a file that did not exist at the time the "
"call is made.  The *prefix*, *suffix*, and *dir* arguments are similar to"
" those of :func:`mkstemp`, except that bytes file names, ``suffix=None`` "
"and ``prefix=None`` are not supported."
msgstr ""
"호출하는 시점에 존재하지 않는 파일의 절대 경로명을 반환합니다. *prefix*, *suffix* 및 *dir* 인자는 바이트열 "
"파일 이름, ``suffix=None`` 및 ``prefix=None``\\이 지원되지 않는다는 점을 제외하고 "
":func:`mkstemp`\\의 같은 인자와 유사합니다."

#: ../../library/tempfile.rst:456
msgid ""
"Use of this function may introduce a security hole in your program.  By "
"the time you get around to doing anything with the file name it returns, "
"someone else may have beaten you to the punch.  :func:`mktemp` usage can "
"be replaced easily with :func:`NamedTemporaryFile`, passing it the "
"``delete=False`` parameter::"
msgstr ""
"이 함수를 사용하면 프로그램에 보안 허점이 생길 수 있습니다. 반환된 파일 이름으로 무언가를 하면서 시간을 보내는 동안, 다른 "
"누군가가 당신에게 펀치를 날릴 수 있습니다. :func:`mktemp` 사용은 ``delete=False`` 매개 변수를 전달하여 "
":func:`NamedTemporaryFile`\\로 쉽게 대체할 수 있습니다::"

#: ../../library/tempfile.rst:462
msgid ""
">>> f = NamedTemporaryFile(delete=False)\n"
">>> f.name\n"
"'/tmp/tmptjujjt'\n"
">>> f.write(b\"Hello World!\\n\")\n"
"13\n"
">>> f.close()\n"
">>> os.unlink(f.name)\n"
">>> os.path.exists(f.name)\n"
"False"
msgstr ""

#: ../../library/tempfile.rst:11
msgid "temporary"
msgstr ""

#: ../../library/tempfile.rst:11
msgid "file name"
msgstr ""

#: ../../library/tempfile.rst:11
msgid "file"
msgstr ""

#~ msgid ""
#~ "This function operates exactly as "
#~ ":func:`TemporaryFile` does, except that the"
#~ " file is guaranteed to have a "
#~ "visible name in the file system "
#~ "(on Unix, the directory entry is "
#~ "not unlinked).  That name can be "
#~ "retrieved from the :attr:`name` attribute "
#~ "of the returned file-like object.  "
#~ "Whether the name can be used to"
#~ " open the file a second time, "
#~ "while the named temporary file is "
#~ "still open, varies across platforms (it"
#~ " can be so used on Unix; it "
#~ "cannot on Windows NT or later).  "
#~ "If *delete* is true (the default), "
#~ "the file is deleted as soon as "
#~ "it is closed. The returned object "
#~ "is always a file-like object whose"
#~ " :attr:`!file` attribute is the underlying"
#~ " true file object. This file-like "
#~ "object can be used in a "
#~ ":keyword:`with` statement, just like a "
#~ "normal file."
#~ msgstr ""
#~ "이 함수는 파일이 파일 시스템에서 보이는 이름을 "
#~ "갖는다는 것을 제외하고는 :func:`TemporaryFile`\\과 똑같이 "
#~ "작동합니다 (유닉스에서, 디렉터리 항목이 삭제되지 않습니다). "
#~ "이 이름은 반환된 파일류 객체의 :attr:`name` "
#~ "어트리뷰트에서 꺼낼 수 있습니다. 이름 붙은 임시 "
#~ "파일이 여전히 열려있는 동안 이 이름을 사용하여 "
#~ "파일을 다시 열 수 있는지는 플랫폼에 따라 다릅니다"
#~ " (유닉스에서는 가능합니다; 윈도우 NT 이상에서는 그럴 "
#~ "수 없습니다). *delete*\\가 참(기본값)이면, 파일은 닫히자마자"
#~ " 삭제됩니다. 반환된 객체는 항상 :attr:`!file` "
#~ "어트리뷰트가 하부 실제 파일 객체인 파일류 객체입니다. "
#~ "이 파일류 객체는 일반 파일과 마찬가지로 "
#~ ":keyword:`with` 문에서 사용할 수 있습니다."

#~ msgid ""
#~ "The directory can be explicitly cleaned"
#~ " up by calling the :func:`cleanup` "
#~ "method."
#~ msgstr ":func:`cleanup` 메서드를 호출하여 디렉터리를 명시적으로 정리할 수 있습니다."

