# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/base64.rst:2
msgid ":mod:`!base64` --- Base16, Base32, Base64, Base85 Data Encodings"
msgstr ":mod:`!base64` --- Base16, Base32, Base64, Base85 데이터 인코딩"

#: ../../library/base64.rst:8
msgid "**Source code:** :source:`Lib/base64.py`"
msgstr "**소스 코드:** :source:`Lib/base64.py`"

#: ../../library/base64.rst:16
msgid ""
"This module provides functions for encoding binary data to printable "
"ASCII characters and decoding such encodings back to binary data. It "
"provides encoding and decoding functions for the encodings specified in "
":rfc:`4648`, which defines the Base16, Base32, and Base64 algorithms, and"
" for the de-facto standard Ascii85 and Base85 encodings."
msgstr ""
"이 모듈은 바이너리 데이터를 인쇄 가능한 ASCII 문자로 인코딩하고 이러한 인코딩을 다시 바이너리 데이터로 디코딩하는 함수를 "
"제공합니다. Base16, Base32 및 Base64 알고리즘을 정의하는 :rfc:`4648`\\에 지정된 인코딩과 사실상의 "
"표준인 Ascii85와 Base85 인코딩에 대한 인코딩과 디코딩 함수를 제공합니다."

#: ../../library/base64.rst:22
msgid ""
"The :rfc:`4648` encodings are suitable for encoding binary data so that "
"it can be safely sent by email, used as parts of URLs, or included as "
"part of an HTTP POST request.  The encoding algorithm is not the same as "
"the :program:`uuencode` program."
msgstr ""
":rfc:`4648` 인코딩은 전자 우편으로 안전하게 보내거나, URL의 일부로 사용하거나, HTTP POST 요청의 일부로 포함 "
"할 수 있도록 바이너리 데이터를 인코딩하는 데 적합합니다. 인코딩 알고리즘은 :program:`uuencode` 프로그램과 "
"다릅니다."

#: ../../library/base64.rst:27
msgid ""
"There are two interfaces provided by this module.  The modern interface "
"supports encoding :term:`bytes-like objects <bytes-like object>` to ASCII"
" :class:`bytes`, and decoding :term:`bytes-like objects <bytes-like "
"object>` or strings containing ASCII to :class:`bytes`.  Both base-64 "
"alphabets defined in :rfc:`4648` (normal, and URL- and filesystem-safe) "
"are supported."
msgstr ""
"이 모듈은 두 개의 인터페이스를 제공합니다. 최신 인터페이스는 :term:`바이트열류 객체 <bytes-like "
"object>`\\를 ASCII :class:`bytes`\\로 인코딩하고, :term:`바이트열류 객체 <bytes-like "
"object>`\\나 ASCII를 포함하는 문자열을 :class:`bytes`\\로 디코딩하는 것을 지원합니다. "
":rfc:`4648`\\에 정의된 두 가지(일반, 그리고 URL과 파일 시스템에서 안전한) base-64 알파벳이 모두 지원됩니다."

#: ../../library/base64.rst:33
msgid ""
"The legacy interface does not support decoding from strings, but it does "
"provide functions for encoding and decoding to and from :term:`file "
"objects <file object>`.  It only supports the Base64 standard alphabet, "
"and it adds newlines every 76 characters as per :rfc:`2045`.  Note that "
"if you are looking for :rfc:`2045` support you probably want to be "
"looking at the :mod:`email` package instead."
msgstr ""
"레거시 인터페이스는 문자열로부터의 디코딩을 지원하지 않지만, :term:`파일 객체 <file object>`\\에서 인코딩과 "
"디코딩하는 함수를 제공합니다. Base64 표준 알파벳만 지원하며, :rfc:`2045`\\에 따라 76자마다 개행 문자를 "
"추가합니다. :rfc:`2045` 지원을 원한다면 아마도 대신 :mod:`email` 패키지를 보고 싶을 것입니다."

#: ../../library/base64.rst:41
msgid ""
"ASCII-only Unicode strings are now accepted by the decoding functions of "
"the modern interface."
msgstr "ASCII 전용 유니코드 문자열은 이제 최신 인터페이스의 디코딩 함수가 받아들입니다."

#: ../../library/base64.rst:45
msgid ""
"Any :term:`bytes-like objects <bytes-like object>` are now accepted by "
"all encoding and decoding functions in this module.  Ascii85/Base85 "
"support added."
msgstr ""
"모든 :term:`바이트열류 객체 <bytes-like object>`\\는 이제 이 모듈의 모든 인코딩과 디코딩 함수가 "
"받아들입니다. Ascii85/Base85 지원이 추가되었습니다."

#: ../../library/base64.rst:49
msgid "The modern interface provides:"
msgstr "최신 인터페이스는 다음과 같은 것들을 제공합니다:"

#: ../../library/base64.rst:53
msgid ""
"Encode the :term:`bytes-like object` *s* using Base64 and return the "
"encoded :class:`bytes`."
msgstr ""
"Base64를 사용하여 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 인코딩하고 인코딩된 "
":class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:56
msgid ""
"Optional *altchars* must be a :term:`bytes-like object` of length 2 which"
" specifies an alternative alphabet for the ``+`` and ``/`` characters. "
"This allows an application to e.g. generate URL or filesystem safe Base64"
" strings.  The default is ``None``, for which the standard Base64 "
"alphabet is used."
msgstr ""
"선택적 *altchars*\\는 ``+``\\와 ``/`` 문자의 대체 알파벳을 지정하는 길이 2의 :term:`바이트열류 객체 "
"<bytes-like object>`\\여야 합니다. 이를 통해 응용 프로그램은 URL이나 파일 시스템에서 안전한 Base64 "
"문자열을 생성할 수 있습니다. 기본값은 ``None``\\이며, 표준 Base64 알파벳이 사용됩니다."

#: ../../library/base64.rst:61
msgid ""
"May assert or raise a :exc:`ValueError` if the length of *altchars* is "
"not 2.  Raises a :exc:`TypeError` if *altchars* is not a :term:`bytes-"
"like object`."
msgstr ""

#: ../../library/base64.rst:67
msgid ""
"Decode the Base64 encoded :term:`bytes-like object` or ASCII string *s* "
"and return the decoded :class:`bytes`."
msgstr ""
"Base64로 인코딩된 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 *s*\\를 "
"디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:70
msgid ""
"Optional *altchars* must be a :term:`bytes-like object` or ASCII string "
"of length 2 which specifies the alternative alphabet used instead of the "
"``+`` and ``/`` characters."
msgstr ""
"선택적 *altchars*\\는 ``+``\\와 ``/`` 문자 대신에 사용되는 대체 알파벳을 지정하는 길이 2의 "
":term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열이어야 합니다."

#: ../../library/base64.rst:74
msgid "A :exc:`binascii.Error` exception is raised if *s* is incorrectly padded."
msgstr "*s*\\가 잘못 채워지면(padded) :exc:`binascii.Error` 예외가 발생합니다."

#: ../../library/base64.rst:77
msgid ""
"If *validate* is ``False`` (the default), characters that are neither in "
"the normal base-64 alphabet nor the alternative alphabet are discarded "
"prior to the padding check.  If *validate* is ``True``, these non-"
"alphabet characters in the input result in a :exc:`binascii.Error`."
msgstr ""
"*validate*\\가 ``False``\\(기본값)면, 일반 base-64 알파벳도 대체 알파벳도 아닌 문자는 "
"채우기(padding) 검사 전에 버려집니다. *validate*\\가 ``True``\\면, 입력에 이 알파벳이 아닌 문자가 "
"있으면 :exc:`binascii.Error`\\가 발생합니다."

#: ../../library/base64.rst:83
msgid ""
"For more information about the strict base64 check, see "
":func:`binascii.a2b_base64`"
msgstr ""

#: ../../library/base64.rst:85
msgid ""
"May assert or raise a :exc:`ValueError` if the length of *altchars* is "
"not 2."
msgstr ""

#: ../../library/base64.rst:89
msgid ""
"Encode :term:`bytes-like object` *s* using the standard Base64 alphabet "
"and return the encoded :class:`bytes`."
msgstr ""
"표준 Base64 알파벳을 사용하여 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 인코딩하고 "
"인코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:95
msgid ""
"Decode :term:`bytes-like object` or ASCII string *s* using the standard "
"Base64 alphabet and return the decoded :class:`bytes`."
msgstr ""
"표준 Base64 알파벳을 사용하여 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 "
"*s*\\를 디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:101
msgid ""
"Encode :term:`bytes-like object` *s* using the URL- and filesystem-safe "
"alphabet, which substitutes ``-`` instead of ``+`` and ``_`` instead of "
"``/`` in the standard Base64 alphabet, and return the encoded "
":class:`bytes`.  The result can still contain ``=``."
msgstr ""
"표준 Base64 알파벳에서 ``+`` 대신 ``-``\\를, ``/`` 대신 ``_``\\를 사용하도록 대체한 URL과 파일 "
"시스템에서 안전한 알파벳을 사용하여 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 인코딩하고, "
"인코딩된 :class:`bytes`\\를 반환합니다. 결과에는 여전히 ``=``\\가 포함될 수 있습니다."

#: ../../library/base64.rst:110
msgid ""
"Decode :term:`bytes-like object` or ASCII string *s* using the URL- and "
"filesystem-safe alphabet, which substitutes ``-`` instead of ``+`` and "
"``_`` instead of ``/`` in the standard Base64 alphabet, and return the "
"decoded :class:`bytes`."
msgstr ""
"표준 Base64 알파벳에서 ``+`` 대신 ``-``\\를, ``/`` 대신 ``_``\\를 사용하도록 대체한 URL과 파일 "
"시스템에서 안전한 알파벳을 사용하여 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 "
"*s*\\를 디코딩하고, 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:119
msgid ""
"Encode the :term:`bytes-like object` *s* using Base32 and return the "
"encoded :class:`bytes`."
msgstr ""
"Base32를 사용하여 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 인코딩하고 인코딩된 "
":class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:125
msgid ""
"Decode the Base32 encoded :term:`bytes-like object` or ASCII string *s* "
"and return the decoded :class:`bytes`."
msgstr ""
"Base32로 인코딩된 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 *s*\\를 "
"디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:128 ../../library/base64.rst:176
msgid ""
"Optional *casefold* is a flag specifying whether a lowercase alphabet is "
"acceptable as input.  For security purposes, the default is ``False``."
msgstr ""
"선택적 *casefold*\\는 소문자 알파벳을 입력으로 사용할 수 있는지를 지정하는 플래그입니다. 보안을 위해, 기본값은 "
"``False``\\입니다."

#: ../../library/base64.rst:132
msgid ""
":rfc:`4648` allows for optional mapping of the digit 0 (zero) to the "
"letter O (oh), and for optional mapping of the digit 1 (one) to either "
"the letter I (eye) or letter L (el).  The optional argument *map01* when "
"not ``None``, specifies which letter the digit 1 should be mapped to "
"(when *map01* is not ``None``, the digit 0 is always mapped to the letter"
" O).  For security purposes the default is ``None``, so that 0 and 1 are "
"not allowed in the input."
msgstr ""
":rfc:`4648`\\은 숫자 0(영)을 글자 O(오)로 선택적으로 매핑하고, 숫자 1(일)을 글자 I(아이)나 글자 L(엘)로 "
"선택적으로 매핑할 수 있게 합니다. 선택적 인자 *map01*\\이 ``None``\\이 아니면, 숫자 1이 매핑되어야 하는 글자를"
" 지정합니다 (*map01*\\이 ``None``\\이 아닐 때, 숫자 0은 항상 글자 O로 매핑됩니다). 보안상의 이유로 기본값은"
" ``None``\\이고, 0과 1은 입력에 허용되지 않습니다."

#: ../../library/base64.rst:139 ../../library/base64.rst:180
msgid ""
"A :exc:`binascii.Error` is raised if *s* is incorrectly padded or if "
"there are non-alphabet characters present in the input."
msgstr ""
"*s*\\가 잘못 채워졌거나(padded) 입력에 알파벳이 아닌 문자가 있으면 :exc:`binascii.Error`\\가 "
"발생합니다."

#: ../../library/base64.rst:146
msgid ""
"Similar to :func:`b32encode` but uses the Extended Hex Alphabet, as "
"defined in :rfc:`4648`."
msgstr ""

#: ../../library/base64.rst:154
msgid ""
"Similar to :func:`b32decode` but uses the Extended Hex Alphabet, as "
"defined in :rfc:`4648`."
msgstr ""

#: ../../library/base64.rst:157
msgid ""
"This version does not allow the digit 0 (zero) to the letter O (oh) and "
"digit 1 (one) to either the letter I (eye) or letter L (el) mappings, all"
" these characters are included in the Extended Hex Alphabet and are not "
"interchangeable."
msgstr ""

#: ../../library/base64.rst:167
msgid ""
"Encode the :term:`bytes-like object` *s* using Base16 and return the "
"encoded :class:`bytes`."
msgstr ""
"Base16을 사용하여 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 인코딩하고 인코딩된 "
":class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:173
msgid ""
"Decode the Base16 encoded :term:`bytes-like object` or ASCII string *s* "
"and return the decoded :class:`bytes`."
msgstr ""
"Base16으로 인코딩된 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 *s*\\를 "
"디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:187
msgid ""
"Encode the :term:`bytes-like object` *b* using Ascii85 and return the "
"encoded :class:`bytes`."
msgstr ""
"Ascii85를 사용하여 :term:`바이트열류 객체 <bytes-like object>` *b*\\를 인코딩하고 인코딩된 "
":class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:190
msgid ""
"*foldspaces* is an optional flag that uses the special short sequence 'y'"
" instead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. "
"This feature is not supported by the \"standard\" Ascii85 encoding."
msgstr ""
"*foldspaces*\\는 'btoa' 가 지원하듯이 4개의 연속된 스페이스 (ASCII 0x20) 대신 특수한 짧은 시퀀스 "
"'y' 를 사용하는 선택적 플래그입니다. 이 기능은 \"표준\" Ascii85 인코딩에서 지원되지 않습니다."

#: ../../library/base64.rst:194
msgid ""
"*wrapcol* controls whether the output should have newline (``b'\\n'``) "
"characters added to it. If this is non-zero, each output line will be at "
"most this many characters long, excluding the trailing newline."
msgstr ""
"*wrapcol*\\은 출력에 줄 바꿈 (``b'\\n'``) 문자가 추가되어야 하는지를 제어합니다. 이것이 0이 아니면, 각 출력"
" 줄의 길이는 후행 줄 바꿈을 제외하고 이 문자 수를 넘지 않습니다."

#: ../../library/base64.rst:198
msgid ""
"*pad* controls whether the input is padded to a multiple of 4 before "
"encoding. Note that the ``btoa`` implementation always pads."
msgstr "*pad*\\는 인코딩하기 전에 입력이 4의 배수로 채워졌는지를 제어합니다. ``btoa`` 구현은 항상 채운다는 것에 유의하십시오."

#: ../../library/base64.rst:201
msgid ""
"*adobe* controls whether the encoded byte sequence is framed with ``<~`` "
"and ``~>``, which is used by the Adobe implementation."
msgstr ""
"*adobe*\\는 인코딩된 바이트 시퀀스가 Adobe 구현에서 사용되는 ``<~``\\와 ``~>``\\로 프레임화되는지를 "
"제어합니다."

#: ../../library/base64.rst:209
msgid ""
"Decode the Ascii85 encoded :term:`bytes-like object` or ASCII string *b* "
"and return the decoded :class:`bytes`."
msgstr ""
"Ascii85로 인코딩된 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 *b*\\를 "
"디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:212
msgid ""
"*foldspaces* is a flag that specifies whether the 'y' short sequence "
"should be accepted as shorthand for 4 consecutive spaces (ASCII 0x20). "
"This feature is not supported by the \"standard\" Ascii85 encoding."
msgstr ""
"*foldspaces*\\는 짧은 시퀀스 'y' 를 4개의 연속 된 스페이스(ASCII 0x20)에 대한 축약으로 받아들여야 "
"하는지를 지정하는 플래그입니다. 이 기능은 \"표준\" Ascii85 인코딩에서 지원되지 않습니다."

#: ../../library/base64.rst:216
msgid ""
"*adobe* controls whether the input sequence is in Adobe Ascii85 format "
"(i.e. is framed with <~ and ~>)."
msgstr "*adobe*\\는 입력 시퀀스가 Adobe Ascii85 형식인지(즉 <~ 와 ~> 로 프레임화되었는지)를 제어합니다."

#: ../../library/base64.rst:219
msgid ""
"*ignorechars* should be a :term:`bytes-like object` or ASCII string "
"containing characters to ignore from the input. This should only contain "
"whitespace characters, and by default contains all whitespace characters "
"in ASCII."
msgstr ""
"*ignorechars*\\는 입력에서 무시할 문자가 포함된 :term:`바이트열류 객체 <bytes-like object>`\\나"
" ASCII 문자열이어야 합니다. 여기에는 공백 문자만 포함되어야 하며, 기본적으로 ASCII의 모든 공백 문자가 포함됩니다."

#: ../../library/base64.rst:229
msgid ""
"Encode the :term:`bytes-like object` *b* using base85 (as used in e.g. "
"git-style binary diffs) and return the encoded :class:`bytes`."
msgstr ""
"base85를 사용하여 :term:`바이트열류 객체 <bytes-like object>` *b*\\를 인코딩하고 (예를 들어 git"
" 스타일 바이너리 diff에서 사용되는 것처럼), 인코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:232
msgid ""
"If *pad* is true, the input is padded with ``b'\\0'`` so its length is a "
"multiple of 4 bytes before encoding."
msgstr "*pad*\\가 참이면, 입력은 ``b'\\0'``\\으로 채워져서 길이는 인코딩 전에 4바이트의 배수가 됩니다."

#: ../../library/base64.rst:240
msgid ""
"Decode the base85-encoded :term:`bytes-like object` or ASCII string *b* "
"and return the decoded :class:`bytes`.  Padding is implicitly removed, if"
" necessary."
msgstr ""
"base85로 인코딩된 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 *b*\\를 "
"디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다. 필요하면, 채우기는 묵시적으로 제거됩니다."

#: ../../library/base64.rst:249
msgid ""
"Encode the :term:`bytes-like object` *s* using Z85 (as used in ZeroMQ) "
"and return the encoded :class:`bytes`.  See `Z85  specification "
"<https://rfc.zeromq.org/spec/32/>`_ for more information."
msgstr ""
"(ZeroMQ 에서 사용된) Z85를 사용하여 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 "
"인코딩하고, 인코딩된 :class:`bytes`\\를 반환합니다. 더 자세한 내용은 `Z85 명세 "
"<https://rfc.zeromq.org/spec/32/>`_\\를 참조하세요."

#: ../../library/base64.rst:258
msgid ""
"Decode the Z85-encoded :term:`bytes-like object` or ASCII string *s* and "
"return the decoded :class:`bytes`.  See `Z85  specification "
"<https://rfc.zeromq.org/spec/32/>`_ for more information."
msgstr ""
"Z85로 인코딩된 :term:`바이트열류 객체 <bytes-like object>`\\나 ASCII 문자열 *s*\\를 디코딩하고 "
"디코딩된 :class:`bytes`\\를 반환합니다. 더 자세한 내용은 `Z85 명세 "
"<https://rfc.zeromq.org/spec/32/>`_\\를 참조하세요."

#: ../../library/base64.rst:265
msgid "The legacy interface:"
msgstr "레거시 인터페이스:"

#: ../../library/base64.rst:269
msgid ""
"Decode the contents of the binary *input* file and write the resulting "
"binary data to the *output* file. *input* and *output* must be "
":term:`file objects <file object>`. *input* will be read until "
"``input.readline()`` returns an empty bytes object."
msgstr ""
"바이너리 *input* 파일의 내용을 디코딩하고 결과 바이너리 데이터를 *output* 파일에 씁니다. *input*\\과 "
"*output*\\은 :term:`파일 객체 <file object>`\\여야 합니다. *input*\\은 "
"``input.readline()``\\이 빈 바이트열 객체를 반환할 때까지 읽힙니다."

#: ../../library/base64.rst:277
msgid ""
"Decode the :term:`bytes-like object` *s*, which must contain one or more "
"lines of base64 encoded data, and return the decoded :class:`bytes`."
msgstr ""
"하나 이상의 base64 인코딩된 데이터 줄을 포함해야 하는 :term:`바이트열류 객체 <bytes-like object>` "
"*s*\\를 디코딩하고 디코딩된 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:285
msgid ""
"Encode the contents of the binary *input* file and write the resulting "
"base64 encoded data to the *output* file. *input* and *output* must be "
":term:`file objects <file object>`. *input* will be read until "
"``input.read()`` returns an empty bytes object. :func:`encode` inserts a "
"newline character (``b'\\n'``) after every 76 bytes of the output, as "
"well as ensuring that the output always ends with a newline, as per "
":rfc:`2045` (MIME)."
msgstr ""
"바이너리 *input* 파일의 내용을 인코딩하고 base64로 인코딩된 결과 데이터를 *output* 파일에 씁니다. "
"*input*\\과 *output*\\은 :term:`파일 객체 <file object>`\\여야 합니다. *input*\\은 "
"``input.read()``\\이 빈 바이트열 객체를 반환할 때까지 읽힙니다. :func:`encode`\\는 "
":rfc:`2045`\\(MIME)에 따라 출력의 76바이트마다 개행 문자(``b'\\n'``)를 삽입할 뿐만 아니라, 항상 출력이"
" 개행 문자로 끝나도록 합니다."

#: ../../library/base64.rst:295
msgid ""
"Encode the :term:`bytes-like object` *s*, which can contain arbitrary "
"binary data, and return :class:`bytes` containing the base64-encoded "
"data, with newlines (``b'\\n'``) inserted after every 76 bytes of output,"
" and ensuring that there is a trailing newline, as per :rfc:`2045` "
"(MIME)."
msgstr ""
"임의의 바이너리 데이터를 포함할 수 있는 :term:`바이트열류 객체 <bytes-like object>` *s*\\를 인코딩하고,"
" :rfc:`2045` (MIME)에 따라 76바이트의 출력마다 개행(``b'\\n'``)이 삽입되고, 후행 개행이 붙은 "
"base64 인코딩된 데이터를 포함하는 :class:`bytes`\\를 반환합니다."

#: ../../library/base64.rst:303
msgid "An example usage of the module:"
msgstr "모듈 사용 예:"

#: ../../library/base64.rst:316
msgid "Security Considerations"
msgstr ""

#: ../../library/base64.rst:318
msgid ""
"A new security considerations section was added to :rfc:`4648` (section "
"12); it's recommended to review the security section for any code "
"deployed to production."
msgstr ""

#: ../../library/base64.rst:323
msgid "Module :mod:`binascii`"
msgstr "모듈 :mod:`binascii`"

#: ../../library/base64.rst:324
msgid "Support module containing ASCII-to-binary and binary-to-ASCII conversions."
msgstr "ASCII에서 바이너리로, 바이너리에서 ASCII로의 변환이 포함된 지원 모듈."

#: ../../library/base64.rst:326
msgid ""
":rfc:`1521` - MIME (Multipurpose Internet Mail Extensions) Part One: "
"Mechanisms for Specifying and Describing the Format of Internet Message "
"Bodies"
msgstr ""
":rfc:`1521` - MIME (Multipurpose Internet Mail Extensions) Part One: "
"Mechanisms for Specifying and Describing the Format of Internet Message "
"Bodies"

#: ../../library/base64.rst:327
msgid ""
"Section 5.2, \"Base64 Content-Transfer-Encoding,\" provides the "
"definition of the base64 encoding."
msgstr "5.2 절, \"Base64 Content-Transfer-Encoding\" 은 base64 인코딩의 정의를 제공합니다."

#: ../../library/base64.rst:10
msgid "base64"
msgstr "base64"

#: ../../library/base64.rst:10
msgid "encoding"
msgstr "인코딩"

#: ../../library/base64.rst:10
msgid "MIME"
msgstr "MIME"

#: ../../library/base64.rst:10
msgid "base64 encoding"
msgstr "base64 인코딩"

