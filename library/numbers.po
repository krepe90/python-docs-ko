# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Hae-sun Park <haesunrpark@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/numbers.rst:2
#, fuzzy
msgid ":mod:`!numbers` --- Numeric abstract base classes"
msgstr ":mod:`numbers` --- 숫자 추상 베이스 클래스"

#: ../../library/numbers.rst:7
msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**소스 코드:** :source:`Lib/numbers.py`"

#: ../../library/numbers.rst:11
#, fuzzy
msgid ""
"The :mod:`!numbers` module (:pep:`3141`) defines a hierarchy of numeric "
":term:`abstract base classes <abstract base class>` which progressively "
"define more operations.  None of the types defined in this module are "
"intended to be instantiated."
msgstr ""
":mod:`numbers` 모듈(:pep:`3141`)은 숫자에 대한 :term:`추상 베이스 클래스 <abstract base "
"class>` 의 계층 구조를 정의합니다. 계층 구조가 깊어질수록 더 많은 연산이 정의되어 있습니다. 이 모듈에 정의된 모든 형은 "
"인스턴스로 만들 수 없습니다."

#: ../../library/numbers.rst:18
msgid ""
"The root of the numeric hierarchy. If you just want to check if an "
"argument *x* is a number, without caring what kind, use ``isinstance(x, "
"Number)``."
msgstr ""
"숫자 계층의 최상위 클래스입니다. 형에 상관없이 인자 *x* 가 숫자인지 확인하려면 ``isinstance(x, Number)`` "
"를 사용하세요."

#: ../../library/numbers.rst:23
msgid "The numeric tower"
msgstr "숫자 계층"

#: ../../library/numbers.rst:27
#, fuzzy
msgid ""
"Subclasses of this type describe complex numbers and include the "
"operations that work on the built-in :class:`complex` type. These are: "
"conversions to :class:`complex` and :class:`bool`, :attr:`.real`, "
":attr:`.imag`, ``+``, ``-``, ``*``, ``/``, ``**``, :func:`abs`, "
":meth:`conjugate`, ``==``, and ``!=``. All except ``-`` and ``!=`` are "
"abstract."
msgstr ""
"이 서브 클래스는 복소수를 표현하고 내장 :class:`complex` 형에 사용되는 연산을 포함합니다. 여기에는 "
":class:`complex` 와 :class:`bool` 형으로의 변환과 :attr:`.real`, :attr:`.imag`, "
"``+``, ``-``, ``*``, ``/``, :func:`abs`, :meth:`conjugate`, ``==``, "
"``!=`` 이 포함됩니다. ``-`` 와 ``!=`` 를 제외하고는 모두 추상입니다. "

#: ../../library/numbers.rst:35
msgid "Abstract. Retrieves the real component of this number."
msgstr "추상. 복소수의 실수부를 반환합니다."

#: ../../library/numbers.rst:39
msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "추상. 복소수의 허수부를 반환합니다."

#: ../../library/numbers.rst:44
msgid ""
"Abstract. Returns the complex conjugate. For example, "
"``(1+3j).conjugate() == (1-3j)``."
msgstr "추상 메서드. 켤레 복소수를 반환합니다. 예를 들어 ``(1+3j).conjugate() == (1-3j)`` 입니다."

#: ../../library/numbers.rst:49
#, fuzzy
msgid ""
"To :class:`Complex`, :class:`!Real` adds the operations that work on real"
" numbers."
msgstr ":class:`Real` 클래스는 :class:`Complex` 클래스에 실수 연산을 추가합니다."

#: ../../library/numbers.rst:52
msgid ""
"In short, those are: a conversion to :class:`float`, :func:`math.trunc`, "
":func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, "
"``//``, ``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"요약하면 :class:`float` 로의 변환과 :func:`math.trunc`, :func:`round`, "
":func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, ``%``, "
"``<``, ``<=``, ``>``, ``>=`` 가 포함됩니다."

#: ../../library/numbers.rst:56
msgid ""
"Real also provides defaults for :func:`complex`, :attr:`~Complex.real`, "
":attr:`~Complex.imag`, and :meth:`~Complex.conjugate`."
msgstr ""
"이 클래스는 또한 :func:`complex`, :attr:`~Complex.real`, :attr:`~Complex.imag`, "
":meth:`~Complex.conjugate` 를 위한 기본값을 제공합니다."

#: ../../library/numbers.rst:62
#, fuzzy
msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` and "
":attr:`~Rational.denominator` properties. It also provides a default for "
":func:`float`."
msgstr ""
":class:`Real` 의 하위 형이고 :attr:`~Rational.numerator` 와 "
":attr:`~Rational.denominator` 프로퍼티가 추가됩니다. 이 프로퍼티는 기약 분수의 값이어야 합니다. 또한 "
":func:`float` 함수를 위한 기본값으로 사용됩니다."

#: ../../library/numbers.rst:66
msgid ""
"The :attr:`~Rational.numerator` and :attr:`~Rational.denominator` values "
"should be instances of :class:`Integral` and should be in lowest terms "
"with :attr:`~Rational.denominator` positive."
msgstr ""

#: ../../library/numbers.rst:72 ../../library/numbers.rst:76
msgid "Abstract."
msgstr "프로퍼티(추상 메서드)"

#: ../../library/numbers.rst:81
#, fuzzy
msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  "
"Provides defaults for :func:`float`, :attr:`~Rational.numerator`, and "
":attr:`~Rational.denominator`.  Adds abstract methods for :func:`pow` "
"with modulus and bit-string operations: ``<<``, ``>>``, ``&``, ``^``, "
"``|``, ``~``."
msgstr ""
":class:`Rational` 의 하위 형이고 :class:`int` 클래스로 변환 기능이 추가됩니다. :func:`float`,"
" :attr:`~Rational.numerator`, :attr:`~Rational.denominator` 를 위한 기본값을 "
"제공합니다. ``**`` 를 위한 메서드와 비트 연산 ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~`` "
"를 추가합니다."

#: ../../library/numbers.rst:89
#, fuzzy
msgid "Notes for type implementers"
msgstr "형 구현을 위한 주의 사항"

#: ../../library/numbers.rst:91
#, fuzzy
msgid ""
"Implementers should be careful to make equal numbers equal and hash them "
"to the same values. This may be subtle if there are two different "
"extensions of the real numbers. For example, :class:`fractions.Fraction` "
"implements :func:`hash` as follows::"
msgstr ""
"구현자는 동일한 숫자가 같게 취급되고 같은 값으로 해싱되도록 해야 합니다. 만약 종류가 다른 실수의 하위 형이 있는 경우 조금 "
"까다로울 수 있습니다. 예를 들어 :class:`fractions.Fraction` 클래스는 :func:`hash` 함수를 다음과 "
"같이 구현합니다::"

#: ../../library/numbers.rst:96
msgid ""
"def __hash__(self):\n"
"    if self.denominator == 1:\n"
"        # Get integers right.\n"
"        return hash(self.numerator)\n"
"    # Expensive check, but definitely correct.\n"
"    if self == float(self):\n"
"        return hash(float(self))\n"
"    else:\n"
"        # Use tuple's hash to avoid a high collision rate on\n"
"        # simple fractions.\n"
"        return hash((self.numerator, self.denominator))"
msgstr ""

#: ../../library/numbers.rst:110
msgid "Adding More Numeric ABCs"
msgstr "더 많은 숫자 추상 베이스 클래스(ABC) 추가"

#: ../../library/numbers.rst:112
msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a"
" poor hierarchy if it precluded the possibility of adding those. You can "
"add ``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"물론 숫자를 위한 ABC를 추가하는 것이 가능합니다. 그렇지 않으면 엉망으로 상속 계층이 구현될 것입니다. "
":class:`Complex` 와 :class:`Real` 사이에 다음과 같이 ``MyFoo`` 를 추가할 수 있습니다::"

#: ../../library/numbers.rst:117
msgid ""
"class MyFoo(Complex): ...\n"
"MyFoo.register(Real)"
msgstr ""

#: ../../library/numbers.rst:124
msgid "Implementing the arithmetic operations"
msgstr "산술 연산 구현"

#: ../../library/numbers.rst:126
#, fuzzy
msgid ""
"We want to implement the arithmetic operations so that mixed-mode "
"operations either call an implementation whose author knew about the "
"types of both arguments, or convert both to the nearest built in type and"
" do the operation there. For subtypes of :class:`Integral`, this means "
"that :meth:`~object.__add__` and :meth:`~object.__radd__` should be "
"defined as::"
msgstr ""
"다른 형에 대한 연산은 두 인자의 형에 관해 알고 있는 구현을 호출하거나 두 인자를 가장 비슷한 내장형으로 변환하여 연산하도록 산술"
" 연산을 구현하는 것이 좋습니다. :class:`Integral` 클래스의 하위 형일 경우에 :meth:`__add__` 와 "
":meth:`__radd__` 메서드는 다음과 같이 정의되어야 함을 의미합니다::"

#: ../../library/numbers.rst:133
msgid ""
"class MyIntegral(Integral):\n"
"\n"
"    def __add__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(self, other)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(self, other)\n"
"        else:\n"
"            return NotImplemented\n"
"\n"
"    def __radd__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(other, self)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(other, self)\n"
"        elif isinstance(other, Integral):\n"
"            return int(other) + int(self)\n"
"        elif isinstance(other, Real):\n"
"            return float(other) + float(self)\n"
"        elif isinstance(other, Complex):\n"
"            return complex(other) + complex(self)\n"
"        else:\n"
"            return NotImplemented"
msgstr ""

#: ../../library/numbers.rst:158
msgid ""
"There are 5 different cases for a mixed-type operation on subclasses of "
":class:`Complex`. I'll refer to all of the above code that doesn't refer "
"to ``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` "
"will be an instance of ``A``, which is a subtype of :class:`Complex` (``a"
" : A <: Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
":class:`Complex` 클래스의 서브클래스에는 다섯 가지의 서로 다른 혼합형 연산이 있습니다. 위의 코드에서 "
"``MyIntegral`` 와 ``OtherTypeIKnowAbout`` 를 제외한 나머지를 기본구조라고 하겠습니다. ``a`` 는"
" :class:`Complex` 의 하위 형인 ``A`` 의 인스턴스입니다(즉 ``a : A <: Complex`` 입니다). "
"비슷하게 ``b : B <: Complex`` 입니다. ``a + b`` 인 경우를 생각해 보겠습니다:"

#: ../../library/numbers.rst:165
#, fuzzy
msgid ""
"If ``A`` defines an :meth:`~object.__add__` which accepts ``b``, all is "
"well."
msgstr "만약 ``A`` 가 ``b`` 를 받는 :meth:`__add__` 메서드를 정의했다면 모든 것이 문제없이 처리됩니다."

#: ../../library/numbers.rst:167
#, fuzzy
msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a "
"value from :meth:`~object.__add__`, we'd miss the possibility that ``B`` "
"defines a more intelligent :meth:`~object.__radd__`, so the boilerplate "
"should return :data:`NotImplemented` from :meth:`!__add__`. (Or ``A`` may"
" not implement :meth:`!__add__` at all.)"
msgstr ""
"``A`` 가 기본구조 코드로 진입하고 :meth:`__add__`\\로 부터 어떤 값을 반환한다면 ``B`` 가 똑똑하게 정의한 "
":meth:`__radd__` 메서드를 놓칠 수 있습니다. 이를 피하려면 기본구조는 :meth:`__add__` 에서 "
":const:`NotImplemented` 를 반환해야 합니다. (또는 ``A`` 가 :meth:`__add__` 메서드를 전혀 "
"구현하지 않을 수도 있습니다.)"

#: ../../library/numbers.rst:173
#, fuzzy
msgid ""
"Then ``B``'s :meth:`~object.__radd__` gets a chance. If it accepts ``a``,"
" all is well."
msgstr ""
"그다음 ``B`` 의 :meth:`__radd__` 메서드가 기회를 얻습니다. 이 메서드가 ``a`` 를 받을 수 있다면 모든 것이"
" 문제없이 처리됩니다."

#: ../../library/numbers.rst:175
msgid ""
"If it falls back to the boilerplate, there are no more possible methods "
"to try, so this is where the default implementation should live."
msgstr "기본구조 코드로 돌아온다면 더 시도해 볼 수 있는 메서드가 없으므로 기본적으로 수행될 구현을 작성해야 합니다."

#: ../../library/numbers.rst:178
msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is "
"ok, because it was implemented with knowledge of ``A``, so it can handle "
"those instances before delegating to :class:`Complex`."
msgstr ""
"만약 ``B <: A`` 라면 파이썬은 ``A.__add__`` 메서드 전에 ``B.__radd__`` 를 시도합니다. ``A`` "
"에 대해서 알고 ``B`` 가 구현되었기 때문에 이런 행동은 문제없습니다. 따라서 :class:`Complex` 에 위임하기 전에 "
"이 인스턴스를 처리할 수 있습니다."

#: ../../library/numbers.rst:183
#, fuzzy
msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other "
"knowledge, then the appropriate shared operation is the one involving the"
" built in :class:`complex`, and both :meth:`~object.__radd__` s land "
"there, so ``a+b == b+a``."
msgstr ""
"만약 어떤 것도 공유하지 않는 ``A <: Complex`` 와 ``B <: Real`` 라면 적절한 공유 연산(shared "
"operation)은 내장 :class:`complex` 클래스에 연관된 것입니다. 양쪽의 :meth:`__radd__` 메서드가 "
"여기에 해당하므로 ``a+b == b+a`` 가 됩니다."

#: ../../library/numbers.rst:188
msgid ""
"Because most of the operations on any given type will be very similar, it"
" can be useful to define a helper function which generates the forward "
"and reverse instances of any given operator. For example, "
":class:`fractions.Fraction` uses::"
msgstr ""
"대부분 주어진 어떤 형에 대한 연산은 매우 비슷하므로, 주어진 연산자의 정방향(forward) 인스턴스와 역방향(reverse) "
"인스턴스를 생성하는 헬퍼 함수를 정의하는 것이 유용합니다. 예를 들어 :class:`fractions.Fraction` 클래스는 "
"다음과 같이 사용합니다::"

#: ../../library/numbers.rst:193
msgid ""
"def _operator_fallbacks(monomorphic_operator, fallback_operator):\n"
"    def forward(a, b):\n"
"        if isinstance(b, (int, Fraction)):\n"
"            return monomorphic_operator(a, b)\n"
"        elif isinstance(b, float):\n"
"            return fallback_operator(float(a), b)\n"
"        elif isinstance(b, complex):\n"
"            return fallback_operator(complex(a), b)\n"
"        else:\n"
"            return NotImplemented\n"
"    forward.__name__ = '__' + fallback_operator.__name__ + '__'\n"
"    forward.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    def reverse(b, a):\n"
"        if isinstance(a, Rational):\n"
"            # Includes ints.\n"
"            return monomorphic_operator(a, b)\n"
"        elif isinstance(a, Real):\n"
"            return fallback_operator(float(a), float(b))\n"
"        elif isinstance(a, Complex):\n"
"            return fallback_operator(complex(a), complex(b))\n"
"        else:\n"
"            return NotImplemented\n"
"    reverse.__name__ = '__r' + fallback_operator.__name__ + '__'\n"
"    reverse.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    return forward, reverse\n"
"\n"
"def _add(a, b):\n"
"    \"\"\"a + b\"\"\"\n"
"    return Fraction(a.numerator * b.denominator +\n"
"                    b.numerator * a.denominator,\n"
"                    a.denominator * b.denominator)\n"
"\n"
"__add__, __radd__ = _operator_fallbacks(_add, operator.add)\n"
"\n"
"# ..."
msgstr ""

