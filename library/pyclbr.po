# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/pyclbr.rst:2
msgid ":mod:`!pyclbr` --- Python module browser support"
msgstr ":mod:`!pyclbr` --- 파이썬 모듈 브라우저 지원"

#: ../../library/pyclbr.rst:9
msgid "**Source code:** :source:`Lib/pyclbr.py`"
msgstr "**소스 코드:** :source:`Lib/pyclbr.py`"

#: ../../library/pyclbr.rst:13
msgid ""
"The :mod:`pyclbr` module provides limited information about the "
"functions, classes, and methods defined in a Python-coded module.  The "
"information is sufficient to implement a module browser.  The information"
" is extracted from the Python source code rather than by importing the "
"module, so this module is safe to use with untrusted code. This "
"restriction makes it impossible to use this module with modules not "
"implemented in Python, including all standard and optional extension "
"modules."
msgstr ""
":mod:`pyclbr` 모듈은 파이썬 코드 모듈에 정의된 함수, 클래스 및 메서드에 대한 제한된 정보를 제공합니다. 이 정보는 "
"모듈 브라우저를 구현하기에 충분합니다. 정보는 모듈을 임포트 하기보다는 파이썬 소스 코드에서 추출되므로 이 모듈은 신뢰할 수 없는 "
"코드와 함께 사용하는 것이 안전합니다. 이 제한으로 인해 이 모듈을 모든 표준 및 선택 확장 모듈을 포함하여 파이썬으로 구현되지 "
"않은 모듈에 사용할 수 없습니다."

#: ../../library/pyclbr.rst:25
msgid ""
"Return a dictionary mapping module-level class names to class "
"descriptors.  If possible, descriptors for imported base classes are "
"included.  Parameter *module* is a string with the name of the module to "
"read; it may be the name of a module within a package.  If given, *path* "
"is a sequence of directory paths prepended to ``sys.path``, which is used"
" to locate the module source code."
msgstr ""
"모듈 수준의 클래스 이름을 클래스 설명자에 매핑하는 딕셔너리를 돌려줍니다. 가능하면, 임포트 된 베이스 클래스에 관한 설명자가 "
"포함됩니다. 매개 변수 *module*\\은 읽을 모듈 이름이 들어있는 문자열입니다; 패키지 내의 모듈 이름일 수 있습니다. "
"주어지면, *path*\\는 ``sys.path`` 앞에 추가된 디렉터리 경로 시퀀스인데, 모듈 소스 코드의 위치를 찾는 데 "
"사용됩니다."

#: ../../library/pyclbr.rst:32
msgid ""
"This function is the original interface and is only kept for back "
"compatibility.  It returns a filtered version of the following."
msgstr "이 함수는 원래 인터페이스이며 이전 버전과의 호환성을 위해서만 유지됩니다. 다음 함수의 필터링 된 버전을 반환합니다."

#: ../../library/pyclbr.rst:38
msgid ""
"Return a dictionary-based tree containing a function or class descriptors"
" for each function and class defined in the module with a ``def`` or "
"``class`` statement.  The returned dictionary maps module-level function "
"and class names to their descriptors.  Nested objects are entered into "
"the children dictionary of their parent.  As with readmodule, *module* "
"names the module to be read and *path* is prepended to sys.path.  If the "
"module being read is a package, the returned dictionary has a key "
"``'__path__'`` whose value is a list containing the package search path."
msgstr ""
"``def`` 나 ``class`` 문을 사용하여 모듈에 정의된 각 함수 및 클래스에 대한 함수나 클래스 설명자를 포함하는 딕셔너리"
" 기반 트리를 반환합니다. 반환된 딕셔너리는 모듈 수준의 함수와 클래스 이름을 해당 설명자에 대응합니다. 중첩된 객체는 그들의 "
"parent의 children 딕셔너리에 들어갑니다. readmodule과 마찬가지로, *module*\\은 읽을 모듈의 이름을 "
"지정하고 *path*\\는 sys.path의 앞에 추가됩니다. 읽히는 모듈이 패키지면, 반환된 딕셔너리는 키 "
"``'__path__'``\\를 가지는데, 값은 패키지 검색 경로를 포함하는 리스트입니다."

#: ../../library/pyclbr.rst:48
msgid ""
"Descriptors for nested definitions.  They are accessed through the new "
"children attribute.  Each has a new parent attribute."
msgstr ""
"중첩된 정의에 대한 설명자. 새로운 children 어트리뷰트를 통해 액세스할 수 있습니다. 각에는 새로운 parent 어트리뷰트가"
" 있습니다."

#: ../../library/pyclbr.rst:52
msgid ""
"The descriptors returned by these functions are instances of Function and"
" Class classes.  Users are not expected to create instances of these "
"classes."
msgstr ""
"이러한 함수에 의해 반환되는 설명자는 Function과 Class 클래스의 인스턴스입니다. 사용자가 이러한 클래스의 인스턴스를 만들"
" 것으로 기대하지 않습니다."

#: ../../library/pyclbr.rst:60
msgid "Function Objects"
msgstr "Function 객체"

#: ../../library/pyclbr.rst:64
msgid ""
"Class :class:`!Function` instances describe functions defined by def "
"statements.  They have the following attributes:"
msgstr ""
"클래스 :class:`!Function` 인스턴스는 def 문으로 정의된 함수를 설명합니다. 다음과 같은 어트리뷰트를 가지고 "
"있습니다 :"

#: ../../library/pyclbr.rst:70
msgid "Name of the file in which the function is defined."
msgstr "함수가 정의된 파일의 이름."

#: ../../library/pyclbr.rst:75
msgid "The name of the module defining the function described."
msgstr "설명된 함수를 정의하는 모듈의 이름."

#: ../../library/pyclbr.rst:80
msgid "The name of the function."
msgstr "함수의 이름."

#: ../../library/pyclbr.rst:85 ../../library/pyclbr.rst:140
msgid "The line number in the file where the definition starts."
msgstr "정의가 시작되는 파일의 줄 번호."

#: ../../library/pyclbr.rst:90
msgid "For top-level functions, ``None``.  For nested functions, the parent."
msgstr "최상위 함수면, ``None``. 중첩된 함수면, 부모."

#: ../../library/pyclbr.rst:97
msgid ""
"A :class:`dictionary <dict>` mapping names to descriptors for nested "
"functions and classes."
msgstr "이름을 중첩된 함수와 클래스에 관한 설명자로 매핑하는 :class:`딕셔너리 <dict>`."

#: ../../library/pyclbr.rst:105
msgid ""
"``True`` for functions that are defined with the :keyword:`async <async "
"def>` prefix, ``False`` otherwise."
msgstr ""

#: ../../library/pyclbr.rst:114
msgid "Class Objects"
msgstr "Class 객체"

#: ../../library/pyclbr.rst:118
msgid ""
"Class :class:`!Class` instances describe classes defined by class "
"statements.  They have the same attributes as :class:`Functions "
"<Function>` and two more."
msgstr ""
"클래스 :class:`!Class` 인스턴스는 class 문으로 정의된 클래스를 설명합니다. :class:`Function "
"<Function>`\\과 같은 어트리뷰트에 더해 두 개의 어트리뷰트가 더 있습니다."

#: ../../library/pyclbr.rst:125
msgid "Name of the file in which the class is defined."
msgstr "클래스가 정의된 파일의 이름."

#: ../../library/pyclbr.rst:130
msgid "The name of the module defining the class described."
msgstr "설명된 클래스를 정의하는 모듈의 이름."

#: ../../library/pyclbr.rst:135
msgid "The name of the class."
msgstr "클래스의 이름."

#: ../../library/pyclbr.rst:145
msgid "For top-level classes, ``None``.  For nested classes, the parent."
msgstr "최상위 클래스면, ``None``. 중첩된 클래스면, 부모."

#: ../../library/pyclbr.rst:152
msgid ""
"A dictionary mapping names to descriptors for nested functions and "
"classes."
msgstr "이름을 중첩된 함수와 클래스에 관한 설명자로 매핑하는 딕셔너리."

#: ../../library/pyclbr.rst:160
msgid ""
"A list of :class:`!Class` objects which describe the immediate base "
"classes of the class being described.  Classes which are named as "
"superclasses but which are not discoverable by :func:`readmodule_ex` are "
"listed as a string with the class name instead of as :class:`!Class` "
"objects."
msgstr ""
"설명되는 클래스의 직접적인 베이스 클래스를 설명하는 :class:`!Class` 객체의 리스트. 슈퍼 클래스로 명명되었지만 "
":func:`readmodule_ex`\\가 찾을 수 없는 클래스는 :class:`!Class` 객체가 아니라 클래스 이름을 담은 "
"문자열로 나열됩니다."

#: ../../library/pyclbr.rst:169
msgid ""
"A :class:`dictionary <dict>` mapping method names to line numbers. This "
"can be derived from the newer :attr:`children` dictionary, but remains "
"for back-compatibility."
msgstr ""
"메서드 이름을 줄 번호에 매핑하는 :class:`딕셔너리 <dict>`. 최신 :attr:`children` 딕셔너리에서 파생될 수"
" 있지만, 이전 버전과의 호환성을 위해 남아있습니다."

