# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/gettext.rst:2
#, fuzzy
msgid ":mod:`!gettext` --- Multilingual internationalization services"
msgstr ":mod:`gettext` --- 다국어 국제화 서비스"

#: ../../library/gettext.rst:10
msgid "**Source code:** :source:`Lib/gettext.py`"
msgstr "**소스 코드:** :source:`Lib/gettext.py`"

#: ../../library/gettext.rst:14
msgid ""
"The :mod:`gettext` module provides internationalization (I18N) and "
"localization (L10N) services for your Python modules and applications. It"
" supports both the GNU :program:`gettext` message catalog API and a "
"higher level, class-based API that may be more appropriate for Python "
"files.  The interface described below allows you to write your module and"
" application messages in one natural language, and provide a catalog of "
"translated messages for running under different natural languages."
msgstr ""
":mod:`gettext` 모듈은 파이썬 모듈과 응용 프로그램을 위한 국제화(I18N)와 현지화(L10N) 서비스를 제공합니다. "
"GNU :program:`gettext` 메시지 카탈로그 API와 파이썬 파일에 더 적합한 고수준 클래스 기반 API를 모두 "
"지원합니다. 아래 설명된 인터페이스를 사용하면 모듈과 응용 프로그램 메시지를 하나의 자연어로 작성하고, 다른 자연어로 실행하기 위해"
" 번역된 메시지 카탈로그를 제공할 수 있습니다."

#: ../../library/gettext.rst:22
msgid ""
"Some hints on localizing your Python modules and applications are also "
"given."
msgstr "파이썬 모듈과 응용 프로그램을 현지화하는 데 대한 힌트도 제공됩니다."

#: ../../library/gettext.rst:26
msgid "GNU :program:`gettext` API"
msgstr "GNU :program:`gettext` API"

#: ../../library/gettext.rst:28
msgid ""
"The :mod:`gettext` module defines the following API, which is very "
"similar to the GNU :program:`gettext` API.  If you use this API you will "
"affect the translation of your entire application globally.  Often this "
"is what you want if your application is monolingual, with the choice of "
"language dependent on the locale of your user.  If you are localizing a "
"Python module, or if your application needs to switch languages on the "
"fly, you probably want to use the class-based API instead."
msgstr ""
":mod:`gettext` 모듈은 GNU :program:`gettext` API와 매우 유사한 다음 API를 정의합니다. 이 "
"API를 사용하면 전체 응용 프로그램의 번역에 전역적으로 영향을 미칩니다. 응용 프로그램이 단일 언어라면 사용자의 로케일에 따라 "
"언어를 선택할 수 있는 것과 함께 종종 이것이 여러분이 원하는 것입니다. 파이썬 모듈을 현지화하거나, 응용 프로그램에서 언어를 실행"
" 중에 전환해야 한다면, 아마도 클래스 기반 API를 대신 사용하고 싶을 것입니다."

#: ../../library/gettext.rst:39
#, python-brace-format
msgid ""
"Bind the *domain* to the locale directory *localedir*.  More concretely, "
":mod:`gettext` will look for binary :file:`.mo` files for the given "
"domain using the path (on Unix): "
":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`, where *language* "
"is searched for in the environment variables :envvar:`LANGUAGE`, "
":envvar:`LC_ALL`, :envvar:`LC_MESSAGES`, and :envvar:`LANG` respectively."
msgstr ""
"*domain*\\을 로케일 디렉터리 *localedir*\\에 바인드합니다. 보다 구체적으로, :mod:`gettext`\\는 "
"경로 (유닉스에서) :file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`\\를 사용하여"
" 지정된 도메인(domain)에 대한 바이너리 :file:`.mo` 파일을 찾습니다. 여기서 *language*\\는 환경 변수 "
":envvar:`LANGUAGE`, :envvar:`LC_ALL`, :envvar:`LC_MESSAGES` 및 "
":envvar:`LANG`\\에서 각각 검색됩니다."

#: ../../library/gettext.rst:45
msgid ""
"If *localedir* is omitted or ``None``, then the current binding for "
"*domain* is returned. [#]_"
msgstr "*localedir*\\이 생략되거나 ``None``\\이면, *domain*\\에 대한 현재 바인딩이 반환됩니다. [#]_"

#: ../../library/gettext.rst:51
msgid ""
"Change or query the current global domain.  If *domain* is ``None``, then"
" the current global domain is returned, otherwise the global domain is "
"set to *domain*, which is returned."
msgstr ""
"현재 전역 도메인을 변경하거나 조회합니다. *domain*\\이 ``None``\\이면, 현재 전역 도메인이 반환되고, 그렇지 "
"않으면 전역 도메인이 *domain*\\으로 설정되어 반환됩니다."

#: ../../library/gettext.rst:59
#, fuzzy
msgid ""
"Return the localized translation of *message*, based on the current "
"global domain, language, and locale directory.  This function is usually "
"aliased as :func:`!_` in the local namespace (see examples below)."
msgstr ""
"현재 전역 도메인, 언어 및 로케일 디렉터리를 기반으로, *message*\\의 현지화 된 번역을 반환합니다. 이 함수는 일반적으로"
" 지역 이름 공간에서 :func:`_`\\로 별칭이 지정됩니다 (아래 예를 참조하십시오)."

#: ../../library/gettext.rst:66
msgid "Like :func:`.gettext`, but look the message up in the specified *domain*."
msgstr ":func:`.gettext`\\와 비슷하지만, 지정된 *domain*\\에서 메시지를 찾습니다."

#: ../../library/gettext.rst:71
msgid ""
"Like :func:`.gettext`, but consider plural forms. If a translation is "
"found, apply the plural formula to *n*, and return the resulting message "
"(some languages have more than two plural forms). If no translation is "
"found, return *singular* if *n* is 1; return *plural* otherwise."
msgstr ""
":func:`.gettext`\\와 비슷하지만, 복수형(plural forms)을 고려합니다. 번역이 발견되면, 복수 공식을 "
"*n*\\에 적용하고, 결과 메시지를 반환합니다 (일부 언어는 복수형이 두 개 이상입니다). 번역이 없으면, *n*\\이 1이면 "
"*singular*\\를 반환합니다; 그렇지 않으면 *plural*\\을 반환합니다."

#: ../../library/gettext.rst:76
msgid ""
"The Plural formula is taken from the catalog header. It is a C or Python "
"expression that has a free variable *n*; the expression evaluates to the "
"index of the plural in the catalog. See `the GNU gettext documentation "
"<https://www.gnu.org/software/gettext/manual/gettext.html>`__ for the "
"precise syntax to be used in :file:`.po` files and the formulas for a "
"variety of languages."
msgstr ""
"복수 공식은 카탈로그 헤더에서 취합니다. 자유 변수 *n*\\을 갖는 C나 파이썬 표현식입니다. 이 표현식은 카탈로그에서 복수의 "
"인덱스로 평가됩니다. :file:`.po` 파일에 사용되는 정확한 문법과 다양한 언어의 공식은 `GNU gettext 설명서 "
"<https://www.gnu.org/software/gettext/manual/gettext.html>`__\\를 참조하십시오."

#: ../../library/gettext.rst:86
msgid "Like :func:`ngettext`, but look the message up in the specified *domain*."
msgstr ":func:`ngettext`\\와 비슷하지만, 지정된 *domain*\\에서 메시지를 찾습니다."

#: ../../library/gettext.rst:94
msgid ""
"Similar to the corresponding functions without the ``p`` in the prefix "
"(that is, :func:`gettext`, :func:`dgettext`, :func:`ngettext`, "
":func:`dngettext`), but the translation is restricted to the given "
"message *context*."
msgstr ""
"접두사에 ``p``\\가 없는 해당 함수(즉, :func:`gettext`, :func:`dgettext`, "
":func:`ngettext`, :func:`dngettext`)와 유사하지만, 번역은 지정된 메시지 *context*\\로 "
"제한됩니다."

#: ../../library/gettext.rst:101
#, fuzzy
msgid ""
"Note that GNU :program:`gettext` also defines a :func:`!dcgettext` "
"method, but this was deemed not useful and so it is currently "
"unimplemented."
msgstr ""
"GNU :program:`gettext`\\가 :func:`dcgettext` 메서드도 정의하지만, 이것을 유용하지 않은 것으로 "
"간주해서 현재 구현되지 않았음에 유의하십시오."

#: ../../library/gettext.rst:104
msgid "Here's an example of typical usage for this API::"
msgstr "이 API의 일반적인 사용 예는 다음과 같습니다::"

#: ../../library/gettext.rst:106
msgid ""
"import gettext\n"
"gettext.bindtextdomain('myapplication', '/path/to/my/language/directory')"
"\n"
"gettext.textdomain('myapplication')\n"
"_ = gettext.gettext\n"
"# ...\n"
"print(_('This is a translatable string.'))"
msgstr ""

#: ../../library/gettext.rst:115
msgid "Class-based API"
msgstr "클래스 기반 API"

#: ../../library/gettext.rst:117
#, fuzzy
msgid ""
"The class-based API of the :mod:`gettext` module gives you more "
"flexibility and greater convenience than the GNU :program:`gettext` API."
"  It is the recommended way of localizing your Python applications and "
"modules.  :mod:`!gettext` defines a :class:`GNUTranslations` class which "
"implements the parsing of GNU :file:`.mo` format files, and has methods "
"for returning strings. Instances of this class can also install "
"themselves in the built-in namespace as the function :func:`!_`."
msgstr ""
":mod:`gettext` 모듈의 클래스 기반 API는 GNU :program:`gettext` API보다 더 많은 유연성과 "
"편리성을 제공합니다. 파이썬 응용 프로그램과 모듈을 현지화하는 권장되는 방법입니다. :mod:`!gettext`\\는 GNU "
":file:`.mo` 형식 파일의 구문 분석을 구현하고 문자열을 반환하는 메서드가 있는 :class:`GNUTranslations`"
" 클래스를 정의합니다. 이 클래스의 인스턴스는 내장 이름 공간에 함수 :func:`_`\\로 자신을 설치할 수도 있습니다."

#: ../../library/gettext.rst:127
msgid ""
"This function implements the standard :file:`.mo` file search algorithm."
"  It takes a *domain*, identical to what :func:`textdomain` takes.  "
"Optional *localedir* is as in :func:`bindtextdomain`. Optional "
"*languages* is a list of strings, where each string is a language code."
msgstr ""
"이 함수는 표준 :file:`.mo` 파일 검색 알고리즘을 구현합니다. :func:`textdomain`\\이 취하는 것과 동일한 "
"*domain*\\을 취합니다. 선택적 *localedir*\\은 :func:`bindtextdomain`\\에서와 같습니다. "
"선택적 *languages*\\는 문자열 리스트이며, 각 문자열은 언어 코드입니다."

#: ../../library/gettext.rst:132
msgid ""
"If *localedir* is not given, then the default system locale directory is "
"used. [#]_  If *languages* is not given, then the following environment "
"variables are searched: :envvar:`LANGUAGE`, :envvar:`LC_ALL`, "
":envvar:`LC_MESSAGES`, and :envvar:`LANG`.  The first one returning a "
"non-empty value is used for the *languages* variable. The environment "
"variables should contain a colon separated list of languages, which will "
"be split on the colon to produce the expected list of language code "
"strings."
msgstr ""
"*localedir*\\이 제공되지 않으면, 기본 시스템 로케일 디렉터리가 사용됩니다. [#]_ *languages*\\가 제공되지"
" 않으면, 다음과 같은 환경 변수가 검색됩니다: :envvar:`LANGUAGE`, :envvar:`LC_ALL`, "
":envvar:`LC_MESSAGES` 및 :envvar:`LANG`. 비어 있지 않은 값을 반환하는 첫 번째 것이 "
"*languages* 변수에 사용됩니다. 환경 변수는 콜론으로 구분된 언어 목록을 포함해야 하며, 콜론에서 분할되어 예상되는 언어 "
"코드 문자열 리스트를 생성합니다."

#: ../../library/gettext.rst:140
msgid ""
":func:`find` then expands and normalizes the languages, and then iterates"
" through them, searching for an existing file built of these components:"
msgstr ""
"그런 다음 :func:`find`\\는 언어를 확장하고 정규화한 다음, 다음 구성 요소로 구성된 기존 파일을 검색하면서, 이들을 "
"이터레이트 합니다:"

#: ../../library/gettext.rst:143
#, python-brace-format
msgid ":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`"
msgstr ":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`"

#: ../../library/gettext.rst:145
msgid ""
"The first such file name that exists is returned by :func:`find`. If no "
"such file is found, then ``None`` is returned. If *all* is given, it "
"returns a list of all file names, in the order in which they appear in "
"the languages list or the environment variables."
msgstr ""
"존재하는 첫 번째 파일 이름이 :func:`find`\\에 의해 반환됩니다. 그러한 파일이 없으면, ``None``\\이 "
"반환됩니다. *all*\\이 제공되면, 언어 리스트나 환경 변수에 나타나는 순서대로 모든 파일 이름의 리스트를 반환합니다."

#: ../../library/gettext.rst:153
#, fuzzy
msgid ""
"Return a ``*Translations`` instance based on the *domain*, *localedir*, "
"and *languages*, which are first passed to :func:`find` to get a list of "
"the associated :file:`.mo` file paths.  Instances with identical "
":file:`.mo` file names are cached.  The actual class instantiated is "
"*class_* if provided, otherwise :class:`GNUTranslations`.  The class's "
"constructor must take a single :term:`file object` argument."
msgstr ""
"*domain*, *localedir* 및 *languages*\\를 기반으로 하는 :class:`*Translations` "
"인스턴스를 반환합니다. 이 인스턴스는 연관된 :file:`.mo` 파일 경로 리스트를 얻기 위해 먼저 :func:`find`\\로 "
"전달됩니다. 동일한 :file:`.mo` 파일 이름을 갖는 인스턴스는 캐시 됩니다. 인스턴스화되는 실제 클래스는 제공된다면 "
"*class_*\\이고, 그렇지 않으면 :class:`GNUTranslations`\\입니다. 클래스의 생성자는 단일 "
":term:`파일 객체 <file object>` 인자를 취해야 합니다. 제공되면, *codeset*\\은 "
":meth:`~NullTranslations.lgettext`\\와 :meth:`~NullTranslations.lngettext`"
" 메서드에서 번역된 문자열을 인코딩하는 데 사용되는 문자 집합을 변경합니다."

#: ../../library/gettext.rst:160
msgid ""
"If multiple files are found, later files are used as fallbacks for "
"earlier ones. To allow setting the fallback, :func:`copy.copy` is used to"
" clone each translation object from the cache; the actual instance data "
"is still shared with the cache."
msgstr ""
"여러 파일이 발견되면, 이후 파일은 이전 파일에 대한 폴 백으로 사용됩니다. 폴 백을 설정하는 것을 허락하기 위해, "
":func:`copy.copy`\\를 사용하여 캐시에서 각 번역 객체를 복제합니다; 실제 인스턴스 데이터는 여전히 캐시와 "
"공유됩니다."

#: ../../library/gettext.rst:165
msgid ""
"If no :file:`.mo` file is found, this function raises :exc:`OSError` if "
"*fallback* is false (which is the default), and returns a "
":class:`NullTranslations` instance if *fallback* is true."
msgstr ""
":file:`.mo` 파일이 없으면, 이 함수는 *fallback*\\이 거짓(기본값)이면 :exc:`OSError`\\를 "
"발생시키고, *fallback*\\이 참이면 :class:`NullTranslations` 인스턴스를 반환합니다."

#: ../../library/gettext.rst:169
#, fuzzy
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`OSError` 대신 :exc:`IOError`\\를 발생시킵니다."

#: ../../library/gettext.rst:172
#, fuzzy
msgid "*codeset* parameter is removed."
msgstr "*codeset* 매개 변수."

#: ../../library/gettext.rst:177
#, fuzzy
msgid ""
"This installs the function :func:`!_` in Python's builtins namespace, "
"based on *domain* and *localedir* which are passed to the function "
":func:`translation`."
msgstr ""
":func:`translation`\\에 전달되는 *domain*, *localedir* 및 *codeset*\\을 기반으로, "
"파이썬의 내장 이름 공간에 :func:`_` 함수를 설치합니다."

#: ../../library/gettext.rst:180
msgid ""
"For the *names* parameter, please see the description of the translation "
"object's :meth:`~NullTranslations.install` method."
msgstr ""
"*names* 매개 변수에 대해서는, 번역 객체의 :meth:`~NullTranslations.install` 메서드에 대한 설명을"
" 참조하십시오."

#: ../../library/gettext.rst:183
#, fuzzy
msgid ""
"As seen below, you usually mark the strings in your application that are "
"candidates for translation, by wrapping them in a call to the :func:`!_` "
"function, like this::"
msgstr ""
"아래에서 볼 수 있듯이, 일반적으로 다음과 같이 :func:`_` 함수에 대한 호출로 래핑하여, 응용 프로그램에 있는 번역 후보 "
"문자열을 표시합니다::"

#: ../../library/gettext.rst:187
msgid "print(_('This string will be translated.'))"
msgstr ""

#: ../../library/gettext.rst:189
#, fuzzy
msgid ""
"For convenience, you want the :func:`!_` function to be installed in "
"Python's builtins namespace, so it is easily accessible in all modules of"
" your application."
msgstr ""
"편의상, :func:`_` 함수를 파이썬의 내장 이름 공간에 설치하여, 응용 프로그램의 모든 모듈에서 쉽게 액세스할 수 있도록 "
"합니다."

#: ../../library/gettext.rst:193
msgid "*names* is now a keyword-only parameter."
msgstr ""

#: ../../library/gettext.rst:197
msgid "The :class:`NullTranslations` class"
msgstr ":class:`NullTranslations` 클래스"

#: ../../library/gettext.rst:199
msgid ""
"Translation classes are what actually implement the translation of "
"original source file message strings to translated message strings. The "
"base class used by all translation classes is :class:`NullTranslations`; "
"this provides the basic interface you can use to write your own "
"specialized translation classes.  Here are the methods of "
":class:`!NullTranslations`:"
msgstr ""
"번역 클래스는 원본 소스 파일 메시지 문자열을 번역된 메시지 문자열로 실제로 구현합니다. 모든 번역 클래스에서 사용하는 베이스 "
"클래스는 :class:`NullTranslations`\\입니다; 여러분 자신의 특수화된 번역 클래스를 작성하는 데 사용할 수 있는"
" 기본 인터페이스를 제공합니다. :class:`!NullTranslations`\\의 메서드는 다음과 같습니다:"

#: ../../library/gettext.rst:208
msgid ""
"Takes an optional :term:`file object` *fp*, which is ignored by the base "
"class. Initializes \"protected\" instance variables *_info* and "
"*_charset* which are set by derived classes, as well as *_fallback*, "
"which is set through :meth:`add_fallback`.  It then calls "
"``self._parse(fp)`` if *fp* is not ``None``."
msgstr ""
"베이스 클래스에서 무시되는, 선택적인 :term:`파일 객체 <file object>` *fp*\\를 취합니다. 파생 클래스에 의해"
" 설정되는 \"보호되는\" 인스턴스 변수 *_info*\\와 *_charset* 뿐만 아니라 "
":meth:`add_fallback`\\을 통해 설정되는 *_fallback*\\을 초기화합니다. 그런 다음 *fp*\\가 "
"``None``\\이 아니면 ``self._parse(fp)``\\를 호출합니다."

#: ../../library/gettext.rst:216
msgid ""
"No-op in the base class, this method takes file object *fp*, and reads "
"the data from the file, initializing its message catalog.  If you have an"
" unsupported message catalog file format, you should override this method"
" to parse your format."
msgstr ""
"베이스 클래스에서 아무런 일도 하지 않는 이 메서드는 파일 객체 *fp*\\를 취하고, 이 파일에서 데이터를 읽고, 메시지 "
"카탈로그를 초기화합니다. 지원되지 않는 메시지 카탈로그 파일 형식이 있으면, 이 메서드를 재정의하여 형식을 구문 분석해야 합니다."

#: ../../library/gettext.rst:224
msgid ""
"Add *fallback* as the fallback object for the current translation object."
" A translation object should consult the fallback if it cannot provide a "
"translation for a given message."
msgstr ""
"현재 번역 객체의 폴 백 객체로 *fallback*\\을 추가합니다. 주어진 메시지에 대한 번역을 제공할 수 없으면 번역 개체는 폴"
" 백을 참조해야 합니다."

#: ../../library/gettext.rst:231
msgid ""
"If a fallback has been set, forward :meth:`!gettext` to the fallback. "
"Otherwise, return *message*.  Overridden in derived classes."
msgstr ""
"폴 백이 설정되었으면, :meth:`!gettext`\\를 폴 백으로 전달합니다. 그렇지 않으면, *message*\\를 "
"반환합니다. 파생 클래스에서 재정의됩니다."

#: ../../library/gettext.rst:237
msgid ""
"If a fallback has been set, forward :meth:`!ngettext` to the fallback. "
"Otherwise, return *singular* if *n* is 1; return *plural* otherwise. "
"Overridden in derived classes."
msgstr ""
"폴 백이 설정되었으면, :meth:`!ngettext`\\를 폴 백으로 전달합니다. 그렇지 않으면, *n*\\이 1이면 "
"*singular*\\를 반환합니다; 그렇지 않으면 *plural*\\을 반환합니다. 파생 클래스에서 재정의됩니다."

#: ../../library/gettext.rst:244
msgid ""
"If a fallback has been set, forward :meth:`pgettext` to the fallback. "
"Otherwise, return the translated message.  Overridden in derived classes."
msgstr ""
"폴 백이 설정되었으면, :meth:`pgettext`\\를 폴 백으로 전달합니다. 그렇지 않으면, 번역된 메시지를 반환합니다. 파생"
" 클래스에서 재정의됩니다."

#: ../../library/gettext.rst:252
msgid ""
"If a fallback has been set, forward :meth:`npgettext` to the fallback. "
"Otherwise, return the translated message.  Overridden in derived classes."
msgstr ""
"폴 백이 설정되었으면, :meth:`npgettext`\\를 폴 백으로 전달합니다. 그렇지 않으면, 번역된 메시지를 반환합니다. "
"파생 클래스에서 재정의됩니다."

#: ../../library/gettext.rst:260
#, fuzzy
msgid ""
"Return a dictionary containing the metadata found in the message catalog "
"file."
msgstr "메시지 카탈로그 파일에서 발견된 메타 데이터를 포함하는 딕셔너리인, \"보호된\" :attr:`_info` 변수를 반환합니다."

#: ../../library/gettext.rst:266
msgid "Return the encoding of the message catalog file."
msgstr "메시지 카탈로그 파일의 인코딩을 반환합니다."

#: ../../library/gettext.rst:271
msgid ""
"This method installs :meth:`.gettext` into the built-in namespace, "
"binding it to ``_``."
msgstr "이 메서드는 :meth:`.gettext`\\를 내장 이름 공간에 설치하여, ``_``\\에 연결합니다."

#: ../../library/gettext.rst:274
#, fuzzy
msgid ""
"If the *names* parameter is given, it must be a sequence containing the "
"names of functions you want to install in the builtins namespace in "
"addition to :func:`!_`.  Supported names are ``'gettext'``, "
"``'ngettext'``, ``'pgettext'``, and ``'npgettext'``."
msgstr ""
"*names* 매개 변수가 제공되면, :func:`_`\\에 더해서 내장 이름 공간에 설치하려는 함수 이름이 포함된 시퀀스여야 "
"합니다. 지원되는 이름은 ``'gettext'``, ``'ngettext'``, ``'pgettext'``, "
"``'npgettext'``, ``'lgettext'`` 및 ``'lngettext'`` 입니다."

#: ../../library/gettext.rst:279
#, fuzzy
msgid ""
"Note that this is only one way, albeit the most convenient way, to make "
"the :func:`!_` function available to your application.  Because it "
"affects the entire application globally, and specifically the built-in "
"namespace, localized modules should never install :func:`!_`. Instead, "
"they should use this code to make :func:`!_` available to their module::"
msgstr ""
"이것은 :func:`_` 함수를 응용 프로그램에서 사용할 수 있게 하는 가장 편리한 방법이지만, 한 가지 방법일 뿐입니다. 전체 "
"응용 프로그램, 특히 내장 이름 공간에 영향을 주기 때문에, 현지화된 모듈은 절대 :func:`_`\\를 설치하지 않아야 합니다. "
"대신, 다음과 같은 코드를 사용하여 :func:`_`\\를 모듈에서 사용할 수 있게 해야 합니다::"

#: ../../library/gettext.rst:285
msgid ""
"import gettext\n"
"t = gettext.translation('mymodule', ...)\n"
"_ = t.gettext"
msgstr ""

#: ../../library/gettext.rst:289
#, fuzzy
msgid ""
"This puts :func:`!_` only in the module's global namespace and so only "
"affects calls within this module."
msgstr "이는 :func:`_`\\를 모듈의 전역 이름 공간에만 넣기 때문에 이 모듈 내에서의 호출에만 영향을 줍니다."

#: ../../library/gettext.rst:292
msgid "Added ``'pgettext'`` and ``'npgettext'``."
msgstr "``'pgettext'``\\와 ``'npgettext'``\\를 추가했습니다."

#: ../../library/gettext.rst:297
msgid "The :class:`GNUTranslations` class"
msgstr ":class:`GNUTranslations` 클래스"

#: ../../library/gettext.rst:299
#, fuzzy
msgid ""
"The :mod:`!gettext` module provides one additional class derived from "
":class:`NullTranslations`: :class:`GNUTranslations`.  This class "
"overrides :meth:`!_parse` to enable reading GNU :program:`gettext` format"
" :file:`.mo` files in both big-endian and little-endian format."
msgstr ""
":mod:`gettext` 모듈은 :class:`NullTranslations`\\에서 파생된 클래스를 하나 더 제공합니다: "
":class:`GNUTranslations`. 이 클래스는 :meth:`_parse`\\를 재정의하여 빅 엔디안과 리틀 엔디안 "
"형식의 GNU :program:`gettext` 형식 :file:`.mo` 파일을 읽을 수 있도록 합니다."

#: ../../library/gettext.rst:304
#, fuzzy
msgid ""
":class:`GNUTranslations` parses optional metadata out of the translation "
"catalog. It is convention with GNU :program:`gettext` to include metadata"
" as the translation for the empty string. This metadata is in "
":rfc:`822`\\ -style ``key: value`` pairs, and should contain the "
"``Project-Id-Version`` key.  If the key ``Content-Type`` is found, then "
"the ``charset`` property is used to initialize the \"protected\" "
":attr:`!_charset` instance variable, defaulting to ``None`` if not found."
"  If the charset encoding is specified, then all message ids and message "
"strings read from the catalog are converted to Unicode using this "
"encoding, else ASCII is assumed."
msgstr ""
":class:`GNUTranslations`\\는 번역 카탈로그에서 선택적 메타 데이터를 구문 분석합니다. 빈 문자열의 번역으로 "
"메타 데이터를 포함하는 것이 GNU :program:`gettext`\\의 관례입니다. 이 메타 데이터는 :rfc:`822` 스타일"
" ``key: value`` 쌍이며, ``Project-Id-Version`` 키를 포함해야 합니다. 키 ``Content-"
"Type``\\이 발견되면, ``charset`` 프로퍼티를 사용하여 \"보호된\" :attr:`_charset` 인스턴스 변수를 "
"초기화하고, 찾을 수 없으면 기본값은 ``None``\\입니다. 문자 집합 인코딩이 지정되면, 카탈로그에서 읽은 모든 메시지 id와"
" 메시지 문자열이 이 인코딩을 사용하여 유니코드로 변환되고, 그렇지 않으면 ASCII로 가정합니다."

#: ../../library/gettext.rst:314
#, fuzzy
msgid ""
"Since message ids are read as Unicode strings too, all ``*gettext()`` "
"methods will assume message ids as Unicode strings, not byte strings."
msgstr ""
"메시지 id도 유니코드 문자열로 읽기 때문에, 모든 :meth:`*gettext` 메서드는 메시지 id를 바이트 문자열이 아닌 "
"유니코드 문자열로 가정합니다."

#: ../../library/gettext.rst:317
#, fuzzy
msgid ""
"The entire set of key/value pairs are placed into a dictionary and set as"
" the \"protected\" :attr:`!_info` instance variable."
msgstr "키/값 쌍의 전체 집합이 딕셔너리에 배치되고 \"보호된\" :attr:`_info` 인스턴스 변수로 설정됩니다."

#: ../../library/gettext.rst:320
msgid ""
"If the :file:`.mo` file's magic number is invalid, the major version "
"number is unexpected, or if other problems occur while reading the file, "
"instantiating a :class:`GNUTranslations` class can raise :exc:`OSError`."
msgstr ""
":file:`.mo` 파일의 매직 번호가 유효하지 않거나, 주 버전 번호가 예상치 못한 값이거나, 파일을 읽는 동안 다른 문제가 "
"발생하면 :class:`GNUTranslations` 클래스를 인스턴스 화할 때 :exc:`OSError`\\가 발생할 수 "
"있습니다."

#: ../../library/gettext.rst:326
msgid "The following methods are overridden from the base class implementation:"
msgstr "베이스 클래스 구현에서 다음 메서드가 재정의되었습니다:"

#: ../../library/gettext.rst:330
msgid ""
"Look up the *message* id in the catalog and return the corresponding "
"message string, as a Unicode string.  If there is no entry in the catalog"
" for the *message* id, and a fallback has been set, the look up is "
"forwarded to the fallback's :meth:`~NullTranslations.gettext` method.  "
"Otherwise, the *message* id is returned."
msgstr ""
"카탈로그에서 *message* id를 찾아 해당 메시지 문자열을 유니코드 문자열로 반환합니다. 카탈로그에 *message* id에 "
"대한 항목이 없고, 폴 백이 설정되었으면, 조회는 폴 백의 :meth:`~NullTranslations.gettext` 메서드로 "
"전달됩니다. 그렇지 않으면, *message* id가 반환됩니다."

#: ../../library/gettext.rst:339
msgid ""
"Do a plural-forms lookup of a message id.  *singular* is used as the "
"message id for purposes of lookup in the catalog, while *n* is used to "
"determine which plural form to use.  The returned message string is a "
"Unicode string."
msgstr ""
"메시지 id의 복수형 조회를 수행합니다. *singular*\\는 카탈로그에서 찾기 위해 메시지 id로 사용되는 반면, *n*\\은"
" 사용할 복수형을 결정하는 데 사용됩니다. 반환된 메시지 문자열은 유니코드 문자열입니다."

#: ../../library/gettext.rst:343
msgid ""
"If the message id is not found in the catalog, and a fallback is "
"specified, the request is forwarded to the fallback's "
":meth:`~NullTranslations.ngettext` method.  Otherwise, when *n* is 1 "
"*singular* is returned, and *plural* is returned in all other cases."
msgstr ""
"카탈로그에서 메시지 id를 찾을 수 없고, 폴 백이 지정되었으면, 요청은 폴 백의 "
":meth:`~NullTranslations.ngettext` 메서드로 전달됩니다. 그렇지 않으면, *n*\\이 1이면 "
"*singular*\\가 반환되고, 다른 모든 경우에는 *plural*\\이 반환됩니다."

#: ../../library/gettext.rst:348
msgid "Here is an example::"
msgstr "예를 들면 다음과 같습니다::"

#: ../../library/gettext.rst:350
#, python-brace-format, python-format
msgid ""
"n = len(os.listdir('.'))\n"
"cat = GNUTranslations(somefile)\n"
"message = cat.ngettext(\n"
"    'There is %(num)d file in this directory',\n"
"    'There are %(num)d files in this directory',\n"
"    n) % {'num': n}"
msgstr ""

#: ../../library/gettext.rst:360
msgid ""
"Look up the *context* and *message* id in the catalog and return the "
"corresponding message string, as a Unicode string.  If there is no entry "
"in the catalog for the *message* id and *context*, and a fallback has "
"been set, the look up is forwarded to the fallback's :meth:`pgettext` "
"method.  Otherwise, the *message* id is returned."
msgstr ""
"카탈로그에서 *context*\\와 *message* id를 찾아 해당 메시지 문자열을 유니코드 문자열로 반환합니다. 카탈로그에 "
"*message* id와 *context*\\에 대한 항목이 없고, 폴 백이 설정되었으면, 조회는 폴 백의 "
":meth:`pgettext` 메서드로 전달됩니다. 그렇지 않으면, *message* id가 반환됩니다."

#: ../../library/gettext.rst:371
msgid ""
"Do a plural-forms lookup of a message id.  *singular* is used as the "
"message id for purposes of lookup in the catalog, while *n* is used to "
"determine which plural form to use."
msgstr ""
"메시지 ID의 복수형 조회를 수행합니다. *singular*\\는 카탈로그에서 찾기 위해 메시지 id로 사용되는 반면, *n*\\은"
" 사용할 복수형을 결정하는 데 사용됩니다."

#: ../../library/gettext.rst:375
msgid ""
"If the message id for *context* is not found in the catalog, and a "
"fallback is specified, the request is forwarded to the fallback's "
":meth:`npgettext` method.  Otherwise, when *n* is 1 *singular* is "
"returned, and *plural* is returned in all other cases."
msgstr ""
"*context*\\의 메시지 id가 카탈로그에 없고, 폴 백이 지정되었으면, 요청은 폴 백의 :meth:`npgettext` "
"메서드로 전달됩니다. 그렇지 않으면, *n*\\이 1이면 *singular*\\가 반환되고, 다른 모든 경우에는 "
"*plural*\\이 반환됩니다."

#: ../../library/gettext.rst:384
msgid "Solaris message catalog support"
msgstr "Solaris 메시지 카탈로그 지원"

#: ../../library/gettext.rst:386
msgid ""
"The Solaris operating system defines its own binary :file:`.mo` file "
"format, but since no documentation can be found on this format, it is not"
" supported at this time."
msgstr ""
"Solaris 운영 체제는 자체 바이너리 :file:`.mo` 파일 형식을 정의하지만, 이 형식에 대한 설명서를 찾을 수 없어서, "
"현재 지원되지 않습니다."

#: ../../library/gettext.rst:392
msgid "The Catalog constructor"
msgstr "Catalog 생성자"

#: ../../library/gettext.rst:396
msgid ""
"GNOME uses a version of the :mod:`gettext` module by James Henstridge, "
"but this version has a slightly different API.  Its documented usage "
"was::"
msgstr ""
"GNOME은 James Henstridge의 :mod:`gettext` 모듈 버전을 사용하지만, 이 버전은 API가 약간 다릅니다."
" 설명된 사용법은 다음과 같습니다::"

#: ../../library/gettext.rst:399
msgid ""
"import gettext\n"
"cat = gettext.Catalog(domain, localedir)\n"
"_ = cat.gettext\n"
"print(_('hello world'))"
msgstr ""

#: ../../library/gettext.rst:404
#, fuzzy
msgid ""
"For compatibility with this older module, the function :func:`!Catalog` "
"is an alias for the :func:`translation` function described above."
msgstr ""
"이 이전 모듈과의 호환성을 위해, 함수 :func:`Catalog`\\는 위에서 설명한 :func:`translation` 함수의 "
"별칭입니다."

#: ../../library/gettext.rst:407
msgid ""
"One difference between this module and Henstridge's: his catalog objects "
"supported access through a mapping API, but this appears to be unused and"
" so is not currently supported."
msgstr ""
"이 모듈과 Henstridge 버전의 한 가지 차이점: 그의 카탈로그 객체는 매핑 API를 통한 액세스를 지원했지만, 사용되지 않는"
" 것으로 보여서 현재 지원되지 않습니다."

#: ../../library/gettext.rst:414
msgid "Internationalizing your programs and modules"
msgstr "프로그램과 모듈의 국제화"

#: ../../library/gettext.rst:416
msgid ""
"Internationalization (I18N) refers to the operation by which a program is"
" made aware of multiple languages.  Localization (L10N) refers to the "
"adaptation of your program, once internationalized, to the local language"
" and cultural habits. In order to provide multilingual messages for your "
"Python programs, you need to take the following steps:"
msgstr ""
"국제화(I18N)는 프로그램이 여러 언어를 인식하도록 하는 작업을 말합니다. 현지화(L10N)는 일단 국제화된 프로그램이 현지 "
"언어와 문화적 습관에 적응하는 것을 말합니다. 파이썬 프로그램에 다국어 메시지를 제공하려면, 다음 단계를 수행해야 합니다:"

#: ../../library/gettext.rst:422
msgid "prepare your program or module by specially marking translatable strings"
msgstr "번역 가능한 문자열을 특별히 표시하여 프로그램이나 모듈을 준비합니다"

#: ../../library/gettext.rst:424
msgid ""
"run a suite of tools over your marked files to generate raw messages "
"catalogs"
msgstr "표시된 파일에 대해 도구 모음을 실행하여 원시 메시지 카탈로그를 생성합니다"

#: ../../library/gettext.rst:426
msgid "create language-specific translations of the message catalogs"
msgstr "메시지 카탈로그의 언어별 번역을 만듭니다"

#: ../../library/gettext.rst:428
msgid ""
"use the :mod:`gettext` module so that message strings are properly "
"translated"
msgstr "메시지 문자열이 올바르게 번역되도록 :mod:`gettext` 모듈을 사용합니다"

#: ../../library/gettext.rst:430
#, fuzzy
msgid ""
"In order to prepare your code for I18N, you need to look at all the "
"strings in your files.  Any string that needs to be translated should be "
"marked by wrapping it in ``_('...')`` --- that is, a call to the function"
" :func:`_ <gettext>`.  For example::"
msgstr ""
"I18N을 위해 여러분의 코드를 준비하려면, 파일의 모든 문자열을 확인해야 합니다. 번역해야 할 모든 문자열은 "
"``_('...')``\\로 감싸서 표시해야 합니다 --- 즉, 함수 :func:`_`\\에 대한 호출. 예를 들면::"

#: ../../library/gettext.rst:434
msgid ""
"filename = 'mylog.txt'\n"
"message = _('writing a log message')\n"
"with open(filename, 'w') as fp:\n"
"    fp.write(message)"
msgstr ""

#: ../../library/gettext.rst:439
msgid ""
"In this example, the string ``'writing a log message'`` is marked as a "
"candidate for translation, while the strings ``'mylog.txt'`` and ``'w'`` "
"are not."
msgstr ""
"이 예에서, 문자열 ``'writing a log message'``\\는 번역 후보로 표시되지만, 문자열 "
"``'mylog.txt'``\\와 ``'w'``\\는 그렇지 않습니다."

#: ../../library/gettext.rst:442
#, fuzzy
msgid ""
"There are a few tools to extract the strings meant for translation. The "
"original GNU :program:`gettext` only supported C or C++ source code but "
"its extended version :program:`xgettext` scans code written in a number "
"of languages, including Python, to find strings marked as translatable.  "
"`Babel <https://babel.pocoo.org/>`__ is a Python internationalization "
"library that includes a :file:`pybabel` script to extract and compile "
"message catalogs.  François Pinard's program called :program:`xpot` does "
"a similar job and is available as part of his `po-utils package "
"<https://github.com/pinard/po-utils>`__."
msgstr ""
"번역을 위한 문자열을 추출하는 몇 가지 도구가 있습니다. 원래 GNU :program:`gettext`\\는 C나 C++ 소스 "
"코드만 지원했지만, 확장 버전 :program:`xgettext`\\는 파이썬을 포함하여 여러 언어로 작성된 코드를 스캔하여 번역 "
"가능으로 표시된 문자열을 찾습니다. `Babel <http://babel.pocoo.org/>`__\\은 메시지 카탈로그를 추출하고"
" 컴파일하는 :file:`pybabel` 스크립트를 포함하는 파이썬 국제화 라이브러리입니다. :program:`xpot`\\이라는 "
"François Pinard의 프로그램도 비슷한 작업을 수행하며 그의 `po-utils 패키지 "
"<https://github.com/pinard/po-utils>`__\\의 일부로 제공됩니다."

#: ../../library/gettext.rst:452
msgid ""
"(Python also includes pure-Python versions of these programs, called "
":program:`pygettext.py` and :program:`msgfmt.py`; some Python "
"distributions will install them for you.  :program:`pygettext.py` is "
"similar to :program:`xgettext`, but only understands Python source code "
"and cannot handle other programming languages such as C or C++. "
":program:`pygettext.py` supports a command-line interface similar to "
":program:`xgettext`; for details on its use, run ``pygettext.py --help``."
"  :program:`msgfmt.py` is binary compatible with GNU :program:`msgfmt`.  "
"With these two programs, you may not need the GNU :program:`gettext` "
"package to internationalize your Python applications.)"
msgstr ""
"(파이썬에는 :program:`pygettext.py`\\와 :program:`msgfmt.py`\\라고 하는 이러한 프로그램의 "
"순수 파이썬 버전도 포함되어 있습니다; 일부 파이썬 배포판은 이 프로그램들을 설치합니다. "
":program:`pygettext.py`\\는 :program:`xgettext`\\와 유사하지만, 파이썬 소스 코드만 이해하며 "
"C나 C++ 와 같은 다른 프로그래밍 언어를 처리할 수 없습니다. :program:`pygettext.py`\\는 "
":program:`xgettext`\\와 유사한 명령 줄 인터페이스를 지원합니다; 사용에 대한 자세한 내용을 보려면, "
"``pygettext.py --help``\\를 실행하십시오. :program:`msgfmt.py`\\는 GNU "
":program:`msgfmt`\\와 바이너리 호환됩니다. 이 두 프로그램을 사용하면, 파이썬 응용 프로그램을 국제화하기 위해 "
"GNU :program:`gettext` 패키지가 필요하지 않을 수 있습니다.)"

#: ../../library/gettext.rst:464
msgid ""
":program:`xgettext`, :program:`pygettext`, and similar tools generate "
":file:`.po` files that are message catalogs.  They are structured human-"
"readable files that contain every marked string in the source code, along"
" with a placeholder for the translated versions of these strings."
msgstr ""
":program:`xgettext`, :program:`pygettext` 및 유사한 도구는 메시지 카탈로그인 :file:`.po`"
" 파일을 생성합니다. 이 파일은 소스 코드에 표시된 모든 문자열과 이러한 문자열의 번역된 버전에 대한 자리를 포함하는 사람이 읽을 "
"수 있는 파일입니다."

#: ../../library/gettext.rst:470
msgid ""
"Copies of these :file:`.po` files are then handed over to the individual "
"human translators who write translations for every supported natural "
"language.  They send back the completed language-specific versions as a "
":file:`<language-name>.po` file that's compiled into a machine-readable "
":file:`.mo` binary catalog file using the :program:`msgfmt` program.  The"
" :file:`.mo` files are used by the :mod:`gettext` module for the actual "
"translation processing at run-time."
msgstr ""
"이 :file:`.po` 파일의 사본은 지원되는 모든 자연어에 대한 번역을 작성하는 개별 인간 번역가에게 전달됩니다. 완성된 언어별"
" 버전을 :file:`<language-name>.po` 파일로 다시 보내고, 이는 :program:`msgfmt` 프로그램을 "
"사용하여 기계가 읽을 수 있는 :file:`.mo` 바이너리 카탈로그 파일로 컴파일됩니다. :file:`.mo` 파일은 실행 시간에"
" 실제 번역 처리를 위해 :mod:`gettext` 모듈에서 사용됩니다."

#: ../../library/gettext.rst:479
msgid ""
"How you use the :mod:`gettext` module in your code depends on whether you"
" are internationalizing a single module or your entire application. The "
"next two sections will discuss each case."
msgstr ""
"코드에서 :mod:`gettext` 모듈을 사용하는 방법은 단일 모듈을 국제화하는지 또는 전체 응용 프로그램을 국제화하는지에 따라 "
"다릅니다. 다음 두 섹션에서는 각 사례에 관해 설명합니다."

#: ../../library/gettext.rst:485
msgid "Localizing your module"
msgstr "모듈 현지화"

#: ../../library/gettext.rst:487
msgid ""
"If you are localizing your module, you must take care not to make global "
"changes, e.g. to the built-in namespace. You should not use the GNU "
":program:`gettext` API but instead the class-based API."
msgstr ""
"모듈을 현지화한다면, 전역적인 변경을 가하지 않도록 주의해야 합니다, 예를 들어, 내장 이름 공간. GNU "
":program:`gettext` API 대신 클래스 기반 API를 사용해야 합니다."

#: ../../library/gettext.rst:491
msgid ""
"Let's say your module is called \"spam\" and the module's various natural"
" language translation :file:`.mo` files reside in "
":file:`/usr/share/locale` in GNU :program:`gettext` format.  Here's what "
"you would put at the top of your module::"
msgstr ""
"모듈이 \"spam\"이고 모듈의 다양한 자연어 번역 :file:`.mo` 파일이 "
":file:`/usr/share/locale`\\에 GNU :program:`gettext` 형식으로 존재한다고 가정해 봅시다. "
"다음은 모듈 맨 위에 들어갈 내용입니다::"

#: ../../library/gettext.rst:496
msgid ""
"import gettext\n"
"t = gettext.translation('spam', '/usr/share/locale')\n"
"_ = t.gettext"
msgstr ""

#: ../../library/gettext.rst:502
msgid "Localizing your application"
msgstr "응용 프로그램 현지화"

#: ../../library/gettext.rst:504
#, fuzzy
msgid ""
"If you are localizing your application, you can install the :func:`!_` "
"function globally into the built-in namespace, usually in the main driver"
" file of your application.  This will let all your application-specific "
"files just use ``_('...')`` without having to explicitly install it in "
"each file."
msgstr ""
"응용 프로그램을 현지화한다면, :func:`_` 함수를 전역적으로 내장 이름 공간에 설치할 수 있습니다, 일반적으로 응용 프로그램의"
" 메인 드라이버 파일에서. 이렇게 하면 모든 응용 프로그램별 파일이 각 파일에 명시적으로 설치하지 않고도 "
"``_('...')``\\를 사용할 수 있습니다."

#: ../../library/gettext.rst:509
msgid ""
"In the simple case then, you need only add the following bit of code to "
"the main driver file of your application::"
msgstr "간단한 경우에는, 응용 프로그램의 메인 드라이버 파일에 다음 코드만 추가하면 됩니다::"

#: ../../library/gettext.rst:512
msgid ""
"import gettext\n"
"gettext.install('myapplication')"
msgstr ""

#: ../../library/gettext.rst:515
msgid ""
"If you need to set the locale directory, you can pass it into the "
":func:`install` function::"
msgstr "로케일 디렉터리를 설정해야 하면, :func:`install` 함수로 전달할 수 있습니다::"

#: ../../library/gettext.rst:518
msgid ""
"import gettext\n"
"gettext.install('myapplication', '/usr/share/locale')"
msgstr ""

#: ../../library/gettext.rst:523
msgid "Changing languages on the fly"
msgstr "실행 중 언어 변경"

#: ../../library/gettext.rst:525
msgid ""
"If your program needs to support many languages at the same time, you may"
" want to create multiple translation instances and then switch between "
"them explicitly, like so::"
msgstr "프로그램에서 동시에 여러 언어를 지원해야 하면, 다음과 같은 식으로 여러 번역 인스턴스를 만든 다음 명시적으로 전환할 수 있습니다::"

#: ../../library/gettext.rst:529
msgid ""
"import gettext\n"
"\n"
"lang1 = gettext.translation('myapplication', languages=['en'])\n"
"lang2 = gettext.translation('myapplication', languages=['fr'])\n"
"lang3 = gettext.translation('myapplication', languages=['de'])\n"
"\n"
"# start by using language1\n"
"lang1.install()\n"
"\n"
"# ... time goes by, user selects language 2\n"
"lang2.install()\n"
"\n"
"# ... more time goes by, user selects language 3\n"
"lang3.install()"
msgstr ""

#: ../../library/gettext.rst:546
msgid "Deferred translations"
msgstr "지연된 번역"

#: ../../library/gettext.rst:548
msgid ""
"In most coding situations, strings are translated where they are coded. "
"Occasionally however, you need to mark strings for translation, but defer"
" actual translation until later.  A classic example is::"
msgstr ""
"대부분의 코딩 상황에서, 문자열은 코딩된 위치에서 번역됩니다. 그러나 때때로, 번역을 위해 문자열을 표시하지만, 실제 번역을 뒤로 "
"연기할 필요가 있습니다. 전형적인 예는 다음과 같습니다::"

#: ../../library/gettext.rst:552
msgid ""
"animals = ['mollusk',\n"
"           'albatross',\n"
"           'rat',\n"
"           'penguin',\n"
"           'python', ]\n"
"# ...\n"
"for a in animals:\n"
"    print(a)"
msgstr ""

#: ../../library/gettext.rst:561
msgid ""
"Here, you want to mark the strings in the ``animals`` list as being "
"translatable, but you don't actually want to translate them until they "
"are printed."
msgstr ""
"여기서, ``animals`` 리스트의 문자열을 번역 가능한 것으로 표시하려고 하지만, 실제로 인쇄될 때까지 번역하고 싶지는 "
"않습니다."

#: ../../library/gettext.rst:565
msgid "Here is one way you can handle this situation::"
msgstr "이 상황을 처리 할 수 있는 한 가지 방법은 다음과 같습니다::"

#: ../../library/gettext.rst:567
msgid ""
"def _(message): return message\n"
"\n"
"animals = [_('mollusk'),\n"
"           _('albatross'),\n"
"           _('rat'),\n"
"           _('penguin'),\n"
"           _('python'), ]\n"
"\n"
"del _\n"
"\n"
"# ...\n"
"for a in animals:\n"
"    print(_(a))"
msgstr ""

#: ../../library/gettext.rst:581
#, fuzzy
msgid ""
"This works because the dummy definition of :func:`!_` simply returns the "
"string unchanged.  And this dummy definition will temporarily override "
"any definition of :func:`!_` in the built-in namespace (until the "
":keyword:`del` command). Take care, though if you have a previous "
"definition of :func:`!_` in the local namespace."
msgstr ""
"이것이 작동하는 이유는 :func:`_`\\의 더미 정의가 단순히 문자열을 변경하지 않고 반환하기 때문입니다. 그리고 이 더미 "
"정의는 내장 이름 공간에서 :func:`_`\\의 정의를 일시적으로 재정의합니다 (:keyword:`del` 명령까지). 지역 이름"
" 공간에 :func:`_`\\의 이전 정의가 있다면 주의하십시오."

#: ../../library/gettext.rst:587
#, fuzzy
msgid ""
"Note that the second use of :func:`!_` will not identify \"a\" as being "
"translatable to the :program:`gettext` program, because the parameter is "
"not a string literal."
msgstr ""
":func:`_`\\의 두 번째 사용은 매개 변수가 문자열 리터럴이 아니기 때문에 :program:`gettext` 프로그램이 "
"\"a\"를 번역 가능하다고 식별하지 않음에 유의하십시오."

#: ../../library/gettext.rst:591
msgid "Another way to handle this is with the following example::"
msgstr "이를 처리하는 다른 방법은 다음 예제를 사용하는 것입니다::"

#: ../../library/gettext.rst:593
msgid ""
"def N_(message): return message\n"
"\n"
"animals = [N_('mollusk'),\n"
"           N_('albatross'),\n"
"           N_('rat'),\n"
"           N_('penguin'),\n"
"           N_('python'), ]\n"
"\n"
"# ...\n"
"for a in animals:\n"
"    print(_(a))"
msgstr ""

#: ../../library/gettext.rst:605
#, fuzzy
msgid ""
"In this case, you are marking translatable strings with the function "
":func:`!N_`, which won't conflict with any definition of :func:`!_`. "
"However, you will need to teach your message extraction program to look "
"for translatable strings marked with :func:`!N_`. :program:`xgettext`, "
":program:`pygettext`, ``pybabel extract``, and :program:`xpot` all "
"support this through the use of the :option:`!-k` command-line switch. "
"The choice of :func:`!N_` here is totally arbitrary; it could have just "
"as easily been :func:`!MarkThisStringForTranslation`."
msgstr ""
"이 경우, 번역 가능한 문자열을 :func:`N_` 함수로 표시하는데, :func:`_`\\의 정의와 충돌하지 않습니다. 그러나, "
":func:`N_`\\로 표시된 번역 가능한 문자열을 찾도록 메시지 추출 프로그램을 가르쳐야 할 필요가 있습니다. "
":program:`xgettext`, :program:`pygettext`, ``pybabel extract`` 및 "
":program:`xpot`\\은 모두 :option:`!-k` 명령 줄 스위치를 사용하여 이를 지원합니다. 여기서 "
":func:`N_`\\의 선택은 완전히 임의적입니다; :func:`MarkThisStringForTranslation`\\처럼 "
"무엇이든 될 수 있습니다."

#: ../../library/gettext.rst:616
msgid "Acknowledgements"
msgstr "감사의 말"

#: ../../library/gettext.rst:618
msgid ""
"The following people contributed code, feedback, design suggestions, "
"previous implementations, and valuable experience to the creation of this"
" module:"
msgstr "다음 분들은 이 모듈을 만드는 데 코드, 피드백, 디자인 제안, 이전 구현 및 귀중한 경험을 제공했습니다:"

#: ../../library/gettext.rst:621
msgid "Peter Funk"
msgstr "Peter Funk"

#: ../../library/gettext.rst:623
msgid "James Henstridge"
msgstr "James Henstridge"

#: ../../library/gettext.rst:625
msgid "Juan David Ibáñez Palomar"
msgstr "Juan David Ibáñez Palomar"

#: ../../library/gettext.rst:627
msgid "Marc-André Lemburg"
msgstr "Marc-André Lemburg"

#: ../../library/gettext.rst:629
msgid "Martin von Löwis"
msgstr "Martin von Löwis"

#: ../../library/gettext.rst:631
msgid "François Pinard"
msgstr "François Pinard"

#: ../../library/gettext.rst:633
msgid "Barry Warsaw"
msgstr "Barry Warsaw"

#: ../../library/gettext.rst:635
msgid "Gustavo Niemeyer"
msgstr "Gustavo Niemeyer"

#: ../../library/gettext.rst:638
msgid "Footnotes"
msgstr "각주"

#: ../../library/gettext.rst:639
#, fuzzy, python-brace-format
msgid ""
"The default locale directory is system dependent; for example, on Red Hat"
" Linux it is :file:`/usr/share/locale`, but on Solaris it is "
":file:`/usr/lib/locale`. The :mod:`!gettext` module does not try to "
"support these system dependent defaults; instead its default is "
":file:`{sys.base_prefix}/share/locale` (see :data:`sys.base_prefix`). For"
" this reason, it is always best to call :func:`bindtextdomain` with an "
"explicit absolute path at the start of your application."
msgstr ""
"기본 로케일 디렉터리는 시스템에 따라 다릅니다; 예를 들어 RedHat 리눅스에서는 "
":file:`/usr/share/locale`\\이지만, Solaris에서는 :file:`/usr/lib/locale`\\입니다. "
":mod:`gettext` 모듈은 이러한 시스템 종속 기본값을 지원하려고 하지 않습니다; 대신 기본값은 "
":file:`{sys.base_prefix}/share/locale`\\입니다 (:data:`sys.base_prefix`\\를 "
"참조하십시오). 이런 이유로, 항상 응용 프로그램 시작 시 명시적 절대 경로를 사용하여 "
":func:`bindtextdomain`\\을 호출하는 것이 가장 좋습니다."

#: ../../library/gettext.rst:647
msgid "See the footnote for :func:`bindtextdomain` above."
msgstr "위의 :func:`bindtextdomain`\\에 대한 각주를 참조하십시오."

#: ../../library/gettext.rst:56
msgid "_ (underscore)"
msgstr ""

#: ../../library/gettext.rst:56
msgid "gettext"
msgstr ""

#: ../../library/gettext.rst:394
msgid "GNOME"
msgstr ""

#~ msgid ""
#~ "Bind the *domain* to *codeset*, changing"
#~ " the encoding of byte strings "
#~ "returned by the :func:`lgettext`, "
#~ ":func:`ldgettext`, :func:`lngettext` and "
#~ ":func:`ldngettext` functions. If *codeset* is"
#~ " omitted, then the current binding is"
#~ " returned."
#~ msgstr ""
#~ "*domain*\\을 *codeset*\\에 바인드하여, :func:`lgettext`,"
#~ " :func:`ldgettext`, :func:`lngettext` 및 "
#~ ":func:`ldngettext` 함수에 의해 반환되는 바이트 문자열의"
#~ " 인코딩을 변경합니다. *codeset*\\이 생략되면, 현재 "
#~ "바인딩이 반환됩니다."

#~ msgid ""
#~ "Equivalent to the corresponding functions "
#~ "without the ``l`` prefix (:func:`.gettext`,"
#~ " :func:`dgettext`, :func:`ngettext` and "
#~ ":func:`dngettext`), but the translation is "
#~ "returned as a byte string encoded "
#~ "in the preferred system encoding if "
#~ "no other encoding was explicitly set "
#~ "with :func:`bind_textdomain_codeset`."
#~ msgstr ""
#~ "``l`` 접두어가 없는 해당 함수(:func:`.gettext`, "
#~ ":func:`dgettext`, :func:`ngettext` 및 "
#~ ":func:`dngettext`)와 동등하지만, "
#~ ":func:`bind_textdomain_codeset`\\으로 명시적으로 설정된 다른 "
#~ "인코딩이 없으면 선호하는 시스템 인코딩으로 인코딩된 바이트"
#~ " 문자열로 번역이 반환됩니다."

#~ msgid ""
#~ "These functions should be avoided in "
#~ "Python 3, because they return encoded"
#~ " bytes.  It's much better to use "
#~ "alternatives which return Unicode strings "
#~ "instead, since most Python applications "
#~ "will want to manipulate human readable"
#~ " text as strings instead of bytes."
#~ "  Further, it's possible that you may"
#~ " get unexpected Unicode-related exceptions"
#~ " if there are encoding problems with"
#~ " the translated strings."
#~ msgstr ""
#~ "이 함수는 인코딩된 바이트열을 반환해서, 파이썬 3에서는"
#~ " 피해야 합니다. 대부분의 파이썬 응용 프로그램은 사람이"
#~ " 읽을 수 있는 텍스트를 바이트열 대신 문자열로 "
#~ "조작하기를 원하기 때문에, 유니코드 문자열을 반환하는 대안을"
#~ " 사용하는 것이 훨씬 좋습니다. 또한, 번역된 문자열에"
#~ " 인코딩 문제가 있으면 예기치 않은 유니코드 관련 "
#~ "예외가 발생할 수 있습니다."

#~ msgid ""
#~ "Equivalent to :meth:`.gettext` and "
#~ ":meth:`.ngettext`, but the translation is "
#~ "returned as a byte string encoded "
#~ "in the preferred system encoding if "
#~ "no encoding was explicitly set with "
#~ ":meth:`set_output_charset`. Overridden in derived"
#~ " classes."
#~ msgstr ""
#~ ":meth:`.gettext` 및 :meth:`.ngettext`\\와 동등하지만, "
#~ ":meth:`set_output_charset`\\으로 인코딩을 명시적으로 설정하지 "
#~ "않았으면 선호하는 시스템 인코딩으로 인코딩된 바이트 문자열로"
#~ " 번역이 반환됩니다. 파생 클래스에서 재정의됩니다."

#~ msgid ""
#~ "These methods should be avoided in "
#~ "Python 3.  See the warning for the"
#~ " :func:`lgettext` function."
#~ msgstr "이 메서드들은 파이썬 3에서 피해야 합니다. :func:`lgettext` 함수에 대한 경고를 참조하십시오."

#~ msgid ""
#~ "Return the encoding used to return "
#~ "translated messages in :meth:`.lgettext` and"
#~ " :meth:`.lngettext`."
#~ msgstr ""
#~ ":meth:`.lgettext`\\와 :meth:`.lngettext`\\에서 번역된 메시지를"
#~ " 반환하는 데 사용되는 인코딩을 반환합니다."

#~ msgid "Change the encoding used to return translated messages."
#~ msgstr "번역된 메시지를 반환하는 데 사용되는 인코딩을 변경합니다."

#~ msgid ""
#~ "Equivalent to :meth:`.gettext` and "
#~ ":meth:`.ngettext`, but the translation is "
#~ "returned as a byte string encoded "
#~ "in the preferred system encoding if "
#~ "no encoding  was explicitly set with "
#~ ":meth:`~NullTranslations.set_output_charset`."
#~ msgstr ""
#~ ":meth:`.gettext`\\와 :meth:`.ngettext`\\와 동등하지만, "
#~ ":meth:`~NullTranslations.set_output_charset`\\으로 인코딩이 "
#~ "명시적으로 설정되지 않았으면 선호하는 시스템 인코딩으로 "
#~ "인코딩된 바이트 문자열로 번역이 반환됩니다."

