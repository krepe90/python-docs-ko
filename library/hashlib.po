# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/hashlib.rst:2
#, fuzzy
msgid ":mod:`!hashlib` --- Secure hashes and message digests"
msgstr ":mod:`hashlib` --- 보안 해시와 메시지 요약"

#: ../../library/hashlib.rst:10
msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**소스 코드:** :source:`Lib/hashlib.py`"

#: ../../library/hashlib.rst:23
#, fuzzy
msgid ""
"This module implements a common interface to many different secure hash "
"and message digest algorithms.  Included are the FIPS secure hash "
"algorithms SHA1, SHA224, SHA256, SHA384, SHA512, (defined in `the FIPS "
"180-4 standard`_), the SHA-3 series (defined in `the FIPS 202 standard`_)"
" as well as RSA's MD5 algorithm (defined in internet :rfc:`1321`).  The "
"terms \"secure hash\" and \"message digest\" are interchangeable.  Older "
"algorithms were called message digests.  The modern term is secure hash."
msgstr ""
"이 모듈은 다양한 보안 해시(secure hash)와 메시지 요약(message digest) 알고리즘에 대한 공통 인터페이스를 "
"구현합니다. RSA의 MD5 알고리즘(Internet :rfc:`1321`\\에서 정의됩니다)뿐만 아니라 FIPS 보안 해시 "
"알고리즘 SHA1, SHA224, SHA256, SHA384 및 SHA512(FIPS 180-2에 정의됩니다)가 포함됩니다. "
"\"보안 해시\"와 \"메시지 다이제스트\"라는 용어는 서로 바꿔 사용할 수 있습니다. 오래된 알고리즘들은 메시지 요약이라고 "
"불립니다. 현대 용어는 보안 해시입니다."

#: ../../library/hashlib.rst:33
msgid ""
"If you want the adler32 or crc32 hash functions, they are available in "
"the :mod:`zlib` module."
msgstr "adler32나 crc32 해시 함수를 원한다면, :mod:`zlib` 모듈에 있습니다."

#: ../../library/hashlib.rst:40
msgid "Hash algorithms"
msgstr "해시 알고리즘"

#: ../../library/hashlib.rst:42
#, fuzzy
msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use "
":func:`sha256` to create a SHA-256 hash object. You can now feed this "
"object with :term:`bytes-like objects <bytes-like object>` (normally "
":class:`bytes`) using the :meth:`update<hash.update>` method.  At any "
"point you can ask it for the :dfn:`digest` of the concatenation of the "
"data fed to it so far using the :meth:`digest()<hash.digest>` or "
":meth:`hexdigest()<hash.hexdigest>` methods."
msgstr ""
":dfn:`해시(hash)`\\의 유형마다 이름이 지정된 생성자 메서드가 있습니다. 모두 같은 간단한 인터페이스를 갖는 해시 객체를"
" 반환합니다. 예를 들어: SHA-256 해시 객체를 만들려면 :func:`sha256`\\을 사용하십시오. 이제 "
":meth:`update` 메서드를 사용하여 이 객체에 :term:`바이트열류 객체 <bytes-like object>`\\(보통 "
":class:`bytes`)를 공급할 수 있습니다. 언제든지 :meth:`digest`\\나 :meth:`hexdigest` "
"메서드를 사용하여 지금까지 공급된 데이터의 연결에 대한 :dfn:`요약(digest)`\\을 요청할 수 있습니다."

#: ../../library/hashlib.rst:50
msgid ""
"To allow multithreading, the Python :term:`GIL` is released while "
"computing a hash supplied more than 2047 bytes of data at once in its "
"constructor or :meth:`.update<hash.update>` method."
msgstr ""

#: ../../library/hashlib.rst:57
#, fuzzy
msgid ""
"Constructors for hash algorithms that are always present in this module "
"are :func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, "
":func:`sha512`, :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, "
":func:`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:`blake2b`, "
"and :func:`blake2s`. :func:`md5` is normally available as well, though it"
" may be missing or blocked if you are using a rare \"FIPS compliant\" "
"build of Python. These correspond to :data:`algorithms_guaranteed`."
msgstr ""
"이 모듈에 항상 존재하는 해시 알고리즘의 생성자는 :func:`sha1`, :func:`sha224`, :func:`sha256`,"
" :func:`sha384`, :func:`sha512`, :func:`blake2b` 및 :func:`blake2s`\\입니다. "
":func:`md5`\\는 일반적으로 사용할 수 있지만, 드문 \"FIPS 호환\" 파이썬 빌드를 사용하는 경우에는 빠지거나 차단될"
" 수 있습니다. 파이썬이 플랫폼에서 사용하는 OpenSSL 라이브러리에 따라 추가 알고리즘을 사용할 수도 있습니다. 대부분의 "
"플랫폼에서 :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, "
":func:`sha3_512`, :func:`shake_128`, :func:`shake_256`\\도 사용할 수 있습니다."

#: ../../library/hashlib.rst:65
msgid ""
"Additional algorithms may also be available if your Python distribution's"
" :mod:`hashlib` was linked against a build of OpenSSL that provides "
"others. Others *are not guaranteed available* on all installations and "
"will only be accessible by name via :func:`new`.  See "
":data:`algorithms_available`."
msgstr ""

#: ../../library/hashlib.rst:72
#, fuzzy
msgid ""
"Some algorithms have known hash collision weaknesses (including MD5 and "
"SHA1). Refer to `Attacks on cryptographic hash algorithms`_ and the "
"`hashlib-seealso`_ section at the end of this document."
msgstr ""
"일부 알고리즘은 해시 충돌 약점(hash collision weaknesses)이 알려져 있습니다, 끝에 있는 \"더 보기\" "
"섹션을 참조하십시오."

#: ../../library/hashlib.rst:76
#, fuzzy
msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, "
":func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` "
"were added. :func:`blake2b` and :func:`blake2s` were added."
msgstr ""
"SHA3(Keccak)과 SHAKE 생성자 :func:`sha3_224`, :func:`sha3_256`, "
":func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."

#: ../../library/hashlib.rst:84
msgid ""
"All hashlib constructors take a keyword-only argument *usedforsecurity* "
"with default value ``True``. A false value allows the use of insecure and"
" blocked hashing algorithms in restricted environments. ``False`` "
"indicates that the hashing algorithm is not used in a security context, "
"e.g. as a non-cryptographic one-way compression function."
msgstr ""
"모든 hashlib 생성자는 기본값이 ``True``\\인 키워드 전용 인자 *usedforsecurity*\\를 취합니다. 값이 "
"거짓이면 제한된 환경에서 안전하지 않고 차단된 해싱 알고리즘 사용을 허락합니다. ``False``\\는 해싱 알고리즘이 보안 "
"문맥에서 사용되지 않음을 나타냅니다, 예를 들어 암호화가 아닌 단방향 압축 함수로."

#: ../../library/hashlib.rst:91
#, fuzzy
msgid "Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it."
msgstr "Hashlib는 이제 OpenSSL 1.1.1 이상의 SHA3와 SHAKE를 사용합니다."

#: ../../library/hashlib.rst:94
msgid ""
"For any of the MD5, SHA1, SHA2, or SHA3 algorithms that the linked "
"OpenSSL does not provide we fall back to a verified implementation from "
"the `HACL\\* project`_."
msgstr ""

#: ../../library/hashlib.rst:100
msgid "Usage"
msgstr ""

#: ../../library/hashlib.rst:102
#, fuzzy
msgid ""
"To obtain the digest of the byte string ``b\"Nobody inspects the spammish"
" repetition\"``::"
msgstr ""
"예를 들어, 바이트 문자열 ``b'Nobody inspects the spammish repetition'``\\의 요약을 얻으려면"
" 다음을 수행하십시오::"

#: ../../library/hashlib.rst:105
msgid ""
">>> import hashlib\n"
">>> m = hashlib.sha256()\n"
">>> m.update(b\"Nobody inspects\")\n"
">>> m.update(b\" the spammish repetition\")\n"
">>> m.digest()\n"
"b'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'"
"\n"
">>> m.hexdigest()\n"
"'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'"
msgstr ""

#: ../../library/hashlib.rst:114
msgid "More condensed:"
msgstr "더 압축하면:"

#: ../../library/hashlib.rst:120
#, fuzzy
msgid "Constructors"
msgstr "상수"

#: ../../library/hashlib.rst:124
#, fuzzy
msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer."
msgstr ""
"원하는 알고리즘의 문자열 *name*\\을 첫 번째 매개 변수로 취하는 일반 생성자입니다. 또한 위에 나열된 해시뿐만 아니라 "
"OpenSSL 라이브러리가 제공할 수 있는 다른 알고리즘에 대한 액세스를 허용하기 위해 존재합니다. 이름 붙은 생성자는 "
":func:`new`\\보다 훨씬 빠르므로 선호해야 합니다."

#: ../../library/hashlib.rst:129
#, fuzzy
msgid "Using :func:`new` with an algorithm name:"
msgstr "OpenSSL에서 제공하는 알고리즘으로 :func:`new` 사용하기:"

#: ../../library/hashlib.rst:148
msgid ""
"Named constructors such as these are faster than passing an algorithm "
"name to :func:`new`."
msgstr ""

#: ../../library/hashlib.rst:152
msgid "Attributes"
msgstr ""

#: ../../library/hashlib.rst:154
#, fuzzy
msgid "Hashlib provides the following constant module attributes:"
msgstr "hashlib는 다음과 같은 상수 어트리뷰트를 제공합니다:"

#: ../../library/hashlib.rst:158
msgid ""
"A set containing the names of the hash algorithms guaranteed to be "
"supported by this module on all platforms.  Note that 'md5' is in this "
"list despite some upstream vendors offering an odd \"FIPS compliant\" "
"Python build that excludes it."
msgstr ""
"모든 플랫폼에서 이 모듈이 지원하도록 보장된 해시 알고리즘의 이름을 포함하는 집합. 'md5'는 일부 업스트림 공급자가 이를 "
"제외하는 이상한 \"FIPS 호환\" 파이썬 빌드를 제공하지만, 이 목록에 있음에 유의하십시오."

#: ../../library/hashlib.rst:167
msgid ""
"A set containing the names of the hash algorithms that are available in "
"the running Python interpreter.  These names will be recognized when "
"passed to :func:`new`.  :attr:`algorithms_guaranteed` will always be a "
"subset.  The same algorithm may appear multiple times in this set under "
"different names (thanks to OpenSSL)."
msgstr ""
"실행 중인 파이썬 인터프리터에서 사용 가능한 해시 알고리즘의 이름이 포함된 집합. 이 이름들은 :func:`new`\\에 전달될 때"
" 인식됩니다. :attr:`algorithms_guaranteed`\\는 항상 부분 집합입니다. 이 집합에서 같은 알고리즘이 다른 "
"이름으로 여러 번 나타날 수 있습니다 (OpenSSL 덕분입니다)."

#: ../../library/hashlib.rst:176
#, fuzzy
msgid "Hash Objects"
msgstr "해시 객체 만들기"

#: ../../library/hashlib.rst:178
msgid ""
"The following values are provided as constant attributes of the hash "
"objects returned by the constructors:"
msgstr "다음 값은 생성자가 반환한 해시 객체의 상수 어트리뷰트로 제공됩니다:"

#: ../../library/hashlib.rst:183
msgid "The size of the resulting hash in bytes."
msgstr "결과 해시의 바이트 단위의 크기."

#: ../../library/hashlib.rst:187
msgid "The internal block size of the hash algorithm in bytes."
msgstr "해시 알고리즘의 바이트 단위의 내부 블록 크기."

#: ../../library/hashlib.rst:189
msgid "A hash object has the following attributes:"
msgstr "해시 객체에는 다음과 같은 어트리뷰트가 있습니다:"

#: ../../library/hashlib.rst:193
msgid ""
"The canonical name of this hash, always lowercase and always suitable as "
"a parameter to :func:`new` to create another hash of this type."
msgstr ""
"이 해시의 규범적 이름, 항상 소문자이며 항상 이 유형의 다른 해시를 만들기 위한 :func:`new`\\에 대한 매개 변수로 "
"적합합니다."

#: ../../library/hashlib.rst:196
msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"name 어트리뷰트는 처음부터 CPython에 존재했지만, 파이썬 3.4 이전에는 공식적으로 지정되지 않아서, 일부 플랫폼에는 "
"존재하지 않을 수 있습니다."

#: ../../library/hashlib.rst:201
msgid "A hash object has the following methods:"
msgstr "해시 객체에는 다음과 같은 메서드가 있습니다:"

#: ../../library/hashlib.rst:206
msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls"
" are equivalent to a single call with the concatenation of all the "
"arguments: ``m.update(a); m.update(b)`` is equivalent to "
"``m.update(a+b)``."
msgstr ""
":term:`바이트열류 객체 <bytes-like object>`\\로 해시 객체를 갱신합니다. 반복되는 호출은 모든 인자를 "
"이어붙인 단일 호출과 동등합니다: ``m.update(a); m.update(b)``\\는 ``m.update(a+b)``\\와 "
"동등합니다."

#: ../../library/hashlib.rst:214
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far."
" This is a bytes object of size :attr:`digest_size` which may contain "
"bytes in the whole range from 0 to 255."
msgstr ""
"지금까지 :meth:`update` 메서드에 전달된 데이터의 요약을 반환합니다. 이것은 :attr:`digest_size` 크기의 "
"바이트열 객체이며 0에서 255까지의 전체 범위에 있는 바이트를 포함할 수 있습니다."

#: ../../library/hashlib.rst:221
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
":meth:`digest`\\와 유사하지만, 요약은 16진수 숫자만 포함하는 두 배 길이의 문자열 객체로 반환됩니다. 전자 메일이나"
" 기타 바이너리가 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다."

#: ../../library/hashlib.rst:228
msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial "
"substring."
msgstr ""
"해시 객체의 사본(\"복제본\")을 반환합니다. 이것은 공통된 초기 부분 문자열을 공유하는 데이터의 요약을 효율적으로 계산하는 데 "
"사용될 수 있습니다."

#: ../../library/hashlib.rst:233
msgid "SHAKE variable length digests"
msgstr "SHAKE 가변 길이 요약"

#: ../../library/hashlib.rst:238
msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. "
"As such, their digest methods require a length. Maximum length is not "
"limited by the SHAKE algorithm."
msgstr ""
":func:`shake_128`\\과 :func:`shake_256` 알고리즘은 length_in_bits//2 (최대 128이나 "
"256) 비트의 보안성으로 가변 길이 요약을 제공합니다. 따라서 digest 메서드에는 길이(length)가 필요합니다. 최대 "
"길이는 SHAKE 알고리즘에 의해 제한되지 않습니다."

#: ../../library/hashlib.rst:245
#, fuzzy
msgid ""
"Return the digest of the data passed to the :meth:`~hash.update` method "
"so far. This is a bytes object of size *length* which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"지금까지 :meth:`update` 메서드에 전달된 데이터의 요약을 반환합니다. 이것은 *length* 크기의 바이트열 객체이며 "
"0에서 255까지의 전체 범위에 있는 바이트를 포함할 수 있습니다."

#: ../../library/hashlib.rst:252
#, fuzzy
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value in email or other non-binary environments."
msgstr ""
":meth:`digest`\\와 유사하지만, 요약은 16진수 숫자만 포함하는 두 배 길이의 문자열 객체로 반환됩니다. 전자 메일이나"
" 기타 바이너리가 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다."

#: ../../library/hashlib.rst:256
#, fuzzy
msgid "Example use:"
msgstr "예"

#: ../../library/hashlib.rst:263
#, fuzzy
msgid "File hashing"
msgstr "간단한 해싱"

#: ../../library/hashlib.rst:265
msgid ""
"The hashlib module provides a helper function for efficient hashing of a "
"file or file-like object."
msgstr ""

#: ../../library/hashlib.rst:270
msgid "Return a digest object that has been updated with contents of file object."
msgstr ""

#: ../../library/hashlib.rst:272
msgid ""
"*fileobj* must be a file-like object opened for reading in binary mode. "
"It accepts file objects from  builtin :func:`open`, :class:`~io.BytesIO` "
"instances, SocketIO objects from :meth:`socket.socket.makefile`, and "
"similar. The function may bypass Python's I/O and use the file descriptor"
" from :meth:`~io.IOBase.fileno` directly. *fileobj* must be assumed to be"
" in an unknown state after this function returns or raises. It is up to "
"the caller to close *fileobj*."
msgstr ""

#: ../../library/hashlib.rst:280
msgid ""
"*digest* must either be a hash algorithm name as a *str*, a hash "
"constructor, or a callable that returns a hash object."
msgstr ""

#: ../../library/hashlib.rst:283
#, fuzzy
msgid "Example:"
msgstr "예"

#: ../../library/hashlib.rst:306
msgid "Key derivation"
msgstr "키 파생"

#: ../../library/hashlib.rst:308
#, python-format
msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function "
"must be tunable, slow, and include a `salt "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_."
msgstr ""
"키 파생(key derivation)과 키 확장(key stretching) 알고리즘은 안전한 암호 해싱을 위해 설계되었습니다. "
"``sha1(password)``\\와 같은 순진한 알고리즘은 무차별 대입 공격에 내성이 없습니다. 올바른 암호 해싱 함수는 조정할"
" 수 있고, 느리고, `솔트(salt) "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_\\를 포함해야 합니다."

#: ../../library/hashlib.rst:316
msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It"
" uses HMAC as pseudorandom function."
msgstr "이 함수는 PKCS#5 암호 기반 키 파생 함수 2를 제공합니다. 의사 난수 함수로 HMAC을 사용합니다."

#: ../../library/hashlib.rst:319
msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm "
"for HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted "
"as buffers of bytes. Applications and libraries should limit *password* "
"to a sensible length (e.g. 1024). *salt* should be about 16 or more bytes"
" from a proper source, e.g. :func:`os.urandom`."
msgstr ""
"문자열 *hash_name*\\은 원하는 HMAC을 위한 해시 요약 알고리즘의 이름입니다, 예를 들어 'sha1'이나 "
"'sha256'. *password*\\와 *salt*\\는 바이트 버퍼로 해석됩니다. 응용 프로그램과 라이브러리는 "
"*password*\\를 적당한 길이(예를 들어 1024)로 제한해야 합니다. *salt*\\는 적절한 소스(예를 들어 "
":func:`os.urandom`)로부터 온 약 16이나 그 이상의 바이트여야 합니다."

#: ../../library/hashlib.rst:325
msgid ""
"The number of *iterations* should be chosen based on the hash algorithm "
"and computing power. As of 2022, hundreds of thousands of iterations of "
"SHA-256 are suggested. For rationale as to why and how to choose what is "
"best for your application, read *Appendix A.2.2* of NIST-SP-800-132_. The"
" answers on the `stackexchange pbkdf2 iterations question`_ explain in "
"detail."
msgstr ""

#: ../../library/hashlib.rst:331
#, fuzzy
msgid ""
"*dklen* is the length of the derived key in bytes. If *dklen* is ``None``"
" then the digest size of the hash algorithm *hash_name* is used, e.g. 64 "
"for SHA-512."
msgstr ""
"*dklen*\\은 파생 키의 길이입니다. *dklen*\\이 ``None``\\이면 해시 알고리즘 *hash_name*\\의 요약"
" 크기가 사용됩니다, 예를 들어 SHA-512의 경우 64."

#: ../../library/hashlib.rst:340
msgid "Function only available when Python is compiled with OpenSSL."
msgstr ""

#: ../../library/hashlib.rst:344
msgid ""
"Function now only available when Python is built with OpenSSL. The slow "
"pure Python implementation has been removed."
msgstr ""

#: ../../library/hashlib.rst:350
msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr "이 함수는 :rfc:`7914`\\에 정의된 대로 scrypt 암호 기반 키 파생 함수를 제공합니다."

#: ../../library/hashlib.rst:353
msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024).  *salt* should be about 16 or more bytes "
"from a proper source, e.g. :func:`os.urandom`."
msgstr ""
"*password*\\와 *salt*\\는 :term:`바이트열류 객체 <bytes-like object>`\\여야 합니다. 응용 "
"프로그램과 라이브러리는 *password*\\를 적당한 길이(예를 들어 1024)로 제한해야 합니다. *salt*\\는 적절한 "
"소스(예를 들어 :func:`os.urandom`)로부터 온 약 16이나 그 이상의 바이트여야 합니다."

#: ../../library/hashlib.rst:358
#, fuzzy
msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* "
"parallelization factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults"
" to 32 MiB). *dklen* is the length of the derived key in bytes."
msgstr ""
"*n*\\은 CPU/ 메모리 비용 계수, *r*\\은 블록 크기, *p*\\는 병렬화 계수이고 *maxmem*\\은 메모리를 "
"제한합니다 (OpenSSL 1.1.0의 기본값은 32 MiB 입니다). *dklen*\\은 파생 키의 길이입니다."

#: ../../library/hashlib.rst:368
msgid "BLAKE2"
msgstr "BLAKE2"

#: ../../library/hashlib.rst:375
msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that "
"comes in two flavors:"
msgstr "BLAKE2_\\는 :rfc:`7693`\\에 정의된 암호화 해시 함수로, 두 가지 방식으로 제공됩니다:"

#: ../../library/hashlib.rst:378
msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any "
"size between 1 and 64 bytes,"
msgstr "**BLAKE2b**, 64비트 플랫폼에 최적화되어 있으며 1에서 64바이트 사이의 모든 크기의 요약을 생성합니다,"

#: ../../library/hashlib.rst:381
msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of"
" any size between 1 and 32 bytes."
msgstr "**BLAKE2s**, 8비트에서 32비트 플랫폼에 최적화되어 있으며 1에서 32바이트 사이의 모든 크기의 요약을 생성합니다."

#: ../../library/hashlib.rst:384
msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for "
"HMAC_), **salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2는 **키 모드(keyed mode)** (HMAC_\\의 더 빠르고 간단한 대체), **솔트 해싱(salted "
"hashing)**, **개인화(personalization)** 및 **트리 해싱(tree hashing)**\\을 지원합니다."

#: ../../library/hashlib.rst:387
msgid ""
"Hash objects from this module follow the API of standard library's "
":mod:`hashlib` objects."
msgstr "이 모듈의 해시 객체는 표준 라이브러리의 :mod:`hashlib` 객체의 API를 따릅니다."

#: ../../library/hashlib.rst:392
msgid "Creating hash objects"
msgstr "해시 객체 만들기"

#: ../../library/hashlib.rst:394
msgid "New hash objects are created by calling constructor functions:"
msgstr "생성자 함수를 호출하여 새 해시 객체를 만듭니다:"

#: ../../library/hashlib.rst:408
msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"이 함수는 BLAKE2b나 BLAKE2s를 계산하기위한 해당 해시 객체를 반환합니다. 선택적으로 다음과 같은 일반 매개 변수를 "
"취합니다:"

#: ../../library/hashlib.rst:411
msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data*: 해시 할 초기 데이터 청크, :term:`바이트열류 객체 <bytes-like object>`\\여야 합니다. 위치 "
"인자로만 전달될 수 있습니다."

#: ../../library/hashlib.rst:414
msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: 바이트 단위의 출력 요약 크기."

#: ../../library/hashlib.rst:416
msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes "
"for BLAKE2s)."
msgstr "*key*: 키 해싱을 위한 키 (BLAKE2b의 경우 최대 64바이트, BLAKE2s의 경우 최대 32바이트)."

#: ../../library/hashlib.rst:419
msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr "*salt*: 무작위 해싱을 위한 솔트 (BLAKE2b의 경우 최대 16바이트, BLAKE2s의 경우 최대 8바이트)."

#: ../../library/hashlib.rst:422
msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr "*person*: 개인화 문자열 (BLAKE2b의 경우 최대 16바이트, BLAKE2s의 경우 최대 8바이트)."

#: ../../library/hashlib.rst:425
msgid "The following table shows limits for general parameters (in bytes):"
msgstr "다음 표는 일반 매개 변수의 제한(바이트 단위)을 보여줍니다:"

#: ../../library/hashlib.rst:428
msgid "Hash"
msgstr "해시"

#: ../../library/hashlib.rst:428
msgid "digest_size"
msgstr "digest_size"

#: ../../library/hashlib.rst:428
msgid "len(key)"
msgstr "len(key)"

#: ../../library/hashlib.rst:428
msgid "len(salt)"
msgstr "len(salt)"

#: ../../library/hashlib.rst:428
msgid "len(person)"
msgstr "len(person)"

#: ../../library/hashlib.rst:430
msgid "BLAKE2b"
msgstr "BLAKE2b"

#: ../../library/hashlib.rst:430
msgid "64"
msgstr "64"

#: ../../library/hashlib.rst:430
msgid "16"
msgstr "16"

#: ../../library/hashlib.rst:431
msgid "BLAKE2s"
msgstr "BLAKE2s"

#: ../../library/hashlib.rst:431
msgid "32"
msgstr "32"

#: ../../library/hashlib.rst:431
msgid "8"
msgstr "8"

#: ../../library/hashlib.rst:436
msgid ""
"BLAKE2 specification defines constant lengths for salt and "
"personalization parameters, however, for convenience, this implementation"
" accepts byte strings of any size up to the specified length. If the "
"length of the parameter is less than specified, it is padded with zeros, "
"thus, for example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. "
"(This is not the case for *key*.)"
msgstr ""
"BLAKE2 명세는 솔트와 개인화 매개 변수에 대해 상수 길이를 정의하지만, 편의상, 이 구현에서는 지정된 길이까지 모든 크기의 "
"바이트 문자열을 받아들입니다. 매개 변수의 길이가 지정된 길이보다 작으면, 0으로 채워지므로, 예를 들어 ``b'salt'``\\와"
" ``b'salt\\x00'``\\은 같은 값입니다. (*key*\\의 경우에는 해당하지 않습니다.)"

#: ../../library/hashlib.rst:443
msgid "These sizes are available as module `constants`_ described below."
msgstr "이 크기는 아래 설명된 모듈 `상수 <constants_>`_\\로 제공됩니다."

#: ../../library/hashlib.rst:445
msgid "Constructor functions also accept the following tree hashing parameters:"
msgstr "생성자 함수는 다음 트리 해싱 매개 변수도 받아들입니다:"

#: ../../library/hashlib.rst:447
msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr "*fanout*: 팬아웃 (0에서 255, 무제한이면 0, 순차적 모드(sequential mode)이면 1)."

#: ../../library/hashlib.rst:449
msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in "
"sequential mode)."
msgstr "*depth*: 트리의 최대 깊이 (1에서 255, 무제한이면 255, 순차적 모드이면 1)."

#: ../../library/hashlib.rst:452
#, fuzzy
msgid ""
"*leaf_size*: maximal byte length of leaf (0 to ``2**32-1``, 0 if "
"unlimited or in sequential mode)."
msgstr "*leaf_size*: 리프의 최대 바이트 길이 (0에서 2**32-1, 무제한이거나 순차적 모드이면 0)."

#: ../../library/hashlib.rst:455
#, fuzzy
msgid ""
"*node_offset*: node offset (0 to ``2**64-1`` for BLAKE2b, 0 to "
"``2**48-1`` for BLAKE2s, 0 for the first, leftmost, leaf, or in "
"sequential mode)."
msgstr ""
"*node_offset*: 노드 오프셋 (BLAKE2b의 경우 0에서 2**64-1, BLAKE2s의 경우 0에서 2**48-1, "
"첫 번째, 가장 왼쪽, 리프 또는 순차적 모드이면 0)."

#: ../../library/hashlib.rst:458
msgid "*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr "*node_depth*: 노드 깊이 (0에서 255, 리프나 순차적 모드이면 0)."

#: ../../library/hashlib.rst:460
msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for "
"BLAKE2s, 0 in sequential mode)."
msgstr ""
"*inner_size*: 내부 요약 크기 (BLAKE2b의 경우 0에서 64, BLAKE2s의 경우 0에서 32, 순차적 모드이면 "
"0)."

#: ../../library/hashlib.rst:463
#, fuzzy
msgid ""
"*last_node*: boolean indicating whether the processed node is the last "
"one (``False`` for sequential mode)."
msgstr "*last_node*: 처리된 노드가 마지막 노드인지를 나타내는 불리언 (순차적 모드이면 `False`)."

#: ../../library/hashlib.rst:466
msgid "Explanation of tree mode parameters."
msgstr ""

#: ../../library/hashlib.rst:470
#, fuzzy
msgid ""
"See section 2.10 in `BLAKE2 specification "
"<https://www.blake2.net/blake2_20130129.pdf>`_ for comprehensive review "
"of tree hashing."
msgstr ""
"트리 해싱에 대한 포괄적인 리뷰는 `BLAKE2 명세 "
"<https://blake2.net/blake2_20130129.pdf>`_\\의 섹션 2.10을 참조하십시오."

#: ../../library/hashlib.rst:476
msgid "Constants"
msgstr "상수"

#: ../../library/hashlib.rst:481
msgid "Salt length (maximum length accepted by constructors)."
msgstr "솔트 길이 (생성자가 허용하는 최대 길이)."

#: ../../library/hashlib.rst:487
msgid "Personalization string length (maximum length accepted by constructors)."
msgstr "개인화 문자열 길이 (생성자가 허용하는 최대 길이)."

#: ../../library/hashlib.rst:493
msgid "Maximum key size."
msgstr "최대 키 크기."

#: ../../library/hashlib.rst:499
msgid "Maximum digest size that the hash function can output."
msgstr "해시 함수가 출력할 수 있는 최대 요약 크기."

#: ../../library/hashlib.rst:503
msgid "Examples"
msgstr "예"

#: ../../library/hashlib.rst:506
msgid "Simple hashing"
msgstr "간단한 해싱"

#: ../../library/hashlib.rst:508
#, fuzzy
msgid ""
"To calculate hash of some data, you should first construct a hash object "
"by calling the appropriate constructor function (:func:`blake2b` or "
":func:`blake2s`), then update it with the data by calling "
":meth:`~hash.update` on the object, and, finally, get the digest out of "
"the object by calling :meth:`~hash.digest` (or :meth:`~hash.hexdigest` "
"for hex-encoded string)."
msgstr ""
"어떤 데이터의 해시를 계산하려면, 먼저 적절한 생성자 함수(:func:`blake2b`\\나 :func:`blake2s`)를 "
"호출하여 해시 객체를 생성한 다음, 객체에서 :meth:`update`\\를 호출하여 데이터로 갱신하고, 마지막으로 "
":meth:`digest`\\(또는 16진수 인코딩 문자열의 경우 :meth:`hexdigest`)를 호출하여 객체에서 요약을 "
"가져와야 합니다."

#: ../../library/hashlib.rst:521
msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to"
" the constructor as the positional argument:"
msgstr "줄여서, 첫 번째 데이터 청크를 위치 인자로 생성자에 전달하여 직접 갱신할 수 있습니다:"

#: ../../library/hashlib.rst:528
msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively"
" update the hash:"
msgstr "해시를 반복적으로 갱신하는 데 필요한 만큼 :meth:`hash.update`\\를 호출할 수 있습니다:"

#: ../../library/hashlib.rst:542
msgid "Using different digest sizes"
msgstr "다른 요약 크기 사용하기"

#: ../../library/hashlib.rst:544
msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up"
" to 32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b "
"without changing the size of output, we can tell BLAKE2b to produce "
"20-byte digests:"
msgstr ""
"BLAKE2는 BLAKE2b의 경우 최대 64바이트, BLAKE2s의 경우 최대 32바이트까지 요약 크기를 구성할 수 있습니다. "
"예를 들어, 출력 크기를 변경하지 않고 SHA-1을 BLAKE2b로 바꾸려면, BLAKE2b에 20바이트 요약을 생성하도록 지시할 "
"수 있습니다:"

#: ../../library/hashlib.rst:558
msgid ""
"Hash objects with different digest sizes have completely different "
"outputs (shorter hashes are *not* prefixes of longer hashes); BLAKE2b and"
" BLAKE2s produce different outputs even if the output length is the same:"
msgstr ""
"요약 크기가 다른 해시 객체의 출력은 완전히 다릅니다 (짧은 해시는 긴 해시의 접두사가 *아닙니다*); BLAKE2b와 "
"BLAKE2s는 출력 길이가 같더라도 다른 출력을 생성합니다:"

#: ../../library/hashlib.rst:574
msgid "Keyed hashing"
msgstr "키 해싱"

#: ../../library/hashlib.rst:576
#, fuzzy
msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code "
"<https://en.wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 can be securely "
"used in prefix-MAC mode thanks to the indifferentiability property "
"inherited from BLAKE."
msgstr ""
"키 해싱(keyed hashing)은 `해시 기반 메시지 인증 코드(HMAC - Hash-based message "
"authentication code) <https://en.wikipedia.org/wiki/Hash-"
"based_message_authentication_code>`_\\을 더 빠르고 간단하게 대체하는 인증에 사용할 수 있습니다. "
"BLAKE2는 BLAKE에서 상속된 비구별성(indifferentiability) 속성 덕분에 접두사-MAC 모드에서 안전하게 "
"사용할 수 있습니다."

#: ../../library/hashlib.rst:582
msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code"
" for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"이 예는 키 ``b'pseudorandom key'``\\로 메시지 ``b'message data'``\\에 대한 (16진 "
"인코딩된) 128비트 인증 코드를 얻는 방법을 보여줍니다::"

#: ../../library/hashlib.rst:585
msgid ""
">>> from hashlib import blake2b\n"
">>> h = blake2b(key=b'pseudorandom key', digest_size=16)\n"
">>> h.update(b'message data')\n"
">>> h.hexdigest()\n"
"'3d363ff7401e02026f4a4687d4863ced'"
msgstr ""

#: ../../library/hashlib.rst:592
msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered "
"with::"
msgstr "실용적인 예로, 웹 응용 프로그램은 사용자에게 전송된 쿠키에 대칭적으로 서명한 후 나중에 변조되지 않았는지 확인할 수 있습니다::"

#: ../../library/hashlib.rst:595
#, python-brace-format
msgid ""
">>> from hashlib import blake2b\n"
">>> from hmac import compare_digest\n"
">>>\n"
">>> SECRET_KEY = b'pseudorandomly generated server secret key'\n"
">>> AUTH_SIZE = 16\n"
">>>\n"
">>> def sign(cookie):\n"
"...     h = blake2b(digest_size=AUTH_SIZE, key=SECRET_KEY)\n"
"...     h.update(cookie)\n"
"...     return h.hexdigest().encode('utf-8')\n"
">>>\n"
">>> def verify(cookie, sig):\n"
"...     good_sig = sign(cookie)\n"
"...     return compare_digest(good_sig, sig)\n"
">>>\n"
">>> cookie = b'user-alice'\n"
">>> sig = sign(cookie)\n"
">>> print(\"{0},{1}\".format(cookie.decode('utf-8'), sig))\n"
"user-alice,b'43b3c982cf697e0c5ab22172d1ca7421'\n"
">>> verify(cookie, sig)\n"
"True\n"
">>> verify(b'user-bob', sig)\n"
"False\n"
">>> verify(cookie, b'0102030405060708090a0b0c0d0e0f00')\n"
"False"
msgstr ""

#: ../../library/hashlib.rst:621
msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, "
"be used in HMAC construction with :mod:`hmac` module::"
msgstr "네이티브 키 해싱 모드가 있더라도, 물론 BLAKE2를 :mod:`hmac` 모듈을 사용하여 HMAC 구성에 사용할 수 있습니다::"

#: ../../library/hashlib.rst:624
msgid ""
">>> import hmac, hashlib\n"
">>> m = hmac.new(b'secret key', digestmod=hashlib.blake2s)\n"
">>> m.update(b'message')\n"
">>> m.hexdigest()\n"
"'e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142'"
msgstr ""

#: ../../library/hashlib.rst:632
msgid "Randomized hashing"
msgstr "무작위 해싱"

#: ../../library/hashlib.rst:634
msgid ""
"By setting *salt* parameter users can introduce randomization to the hash"
" function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"*salt* 매개 변수를 설정하면 해시 함수에 무작위화를 도입할 수 있습니다. 무작위 해싱은 디지털 서명에 사용된 해시 함수에 대한"
" 충돌 공격(collision attacks)을 방지하는 데 유용합니다."

#: ../../library/hashlib.rst:638
msgid ""
"Randomized hashing is designed for situations where one party, the "
"message preparer, generates all or part of a message to be signed by a "
"second party, the message signer. If the message preparer is able to find"
" cryptographic hash function collisions (i.e., two messages producing the"
" same hash value), then they might prepare meaningful versions of the "
"message that would produce the same hash value and digital signature, but"
" with different results (e.g., transferring $1,000,000 to an account, "
"rather than $10). Cryptographic hash functions have been designed with "
"collision resistance as a major goal, but the current concentration on "
"attacking cryptographic hash functions may result in a given "
"cryptographic hash function providing less collision resistance than "
"expected. Randomized hashing offers the signer additional protection by "
"reducing the likelihood that a preparer can generate two or more messages"
" that ultimately yield the same hash value during the digital signature "
"generation process --- even if it is practical to find collisions for the"
" hash function. However, the use of randomized hashing may reduce the "
"amount of security provided by a digital signature when all portions of "
"the message are prepared by the signer."
msgstr ""
"무작위 해싱은 한 당사자(메시지 준비자)가 두 번째 당사자(메시지 서명자)가 서명할 메시지의 전부나 일부를 생성하는 상황을 위해 "
"설계되었습니다. 메시지 준비자가 암호화 해시 함수 충돌(즉, 같은 해시값을 생성하는 두 메시지)을 찾을 수 있으면, 같은 해시값과 "
"디지털 서명을 생성하는 의미 있는 메시지 버전을 준비할 수 있지만, 결과는 다릅니다 (예를 들어, 계정으로 $10 대신에 "
"$1,000,000을 이체하는 행위). 암호화 해시 함수는 주요 목표로 충돌 내성을 갖도록 설계되었지만, 현재 암호화 해시 함수 "
"공격에 대한 집중으로 인해 주어진 암호화 해시 함수가 예상보다 적은 충돌 내성을 제공할 수 있습니다. 무작위 해싱은 준비자가 디지털"
" 서명 생성 프로세스 동안 궁극적으로 같은 해시값을 산출하는 두 개 이상의 메시지를 생성할 가능성을 줄여서, 서명자에게 추가적인 "
"보호를 제공합니다 -- 설사 해시 함수의 충돌을 찾는 것이 실용적이더라도. 그러나, 무작위 해싱을 사용하면 메시지의 모든 부분을 "
"서명자가 준비할 때 디지털 서명이 제공하는 보안의 양을 줄일 수 있습니다."

#: ../../library/hashlib.rst:657
#, fuzzy
msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" "
"<https://csrc.nist.gov/pubs/sp/800/106/final>`_)"
msgstr ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" "
"<https://csrc.nist.gov/publications/detail/sp/800-106/final>`_)"

#: ../../library/hashlib.rst:660
msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression "
"function."
msgstr "BLAKE2에서 솔트는 각 압축 함수에 대한 입력이 아니라 초기화 중에 해시 함수에 대한 일회성 입력으로 처리됩니다."

#: ../../library/hashlib.rst:665
#, fuzzy
msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-"
"purpose cryptographic hash function, such as SHA-256, is not suitable for"
" hashing passwords.  See `BLAKE2 FAQ <https://www.blake2.net/#qa>`_ for "
"more information."
msgstr ""
"BLAKE2나 SHA-256과 같은 기타 범용 암호화 해시 함수를 사용하는 *솔트 해싱(salted hashing)*\\(또는 그냥"
" 해싱)은 암호(password) 해싱에 적합하지 않습니다. 자세한 정보는 `BLAKE2 FAQ "
"<https://blake2.net/#qa>`_\\를 참조하십시오."

#: ../../library/hashlib.rst:688
msgid "Personalization"
msgstr "개인화"

#: ../../library/hashlib.rst:690
msgid ""
"Sometimes it is useful to force hash function to produce different "
"digests for the same input for different purposes. Quoting the authors of"
" the Skein hash function:"
msgstr ""
"때로는 해시 함수가 다른 목적으로 같은 입력에 대해 다른 요약을 생성하도록 강제하는 것이 유용합니다. Skein 해시 함수의 저자를"
" 인용합니다:"

#: ../../library/hashlib.rst:694
msgid ""
"We recommend that all application designers seriously consider doing "
"this; we have seen many protocols where a hash that is computed in one "
"part of the protocol can be used in an entirely different part because "
"two hash computations were done on similar or related data, and the "
"attacker can force the application to make the hash inputs the same. "
"Personalizing each hash function used in the protocol summarily stops "
"this type of attack."
msgstr ""
"모든 응용 프로그램 설계자는 이렇게 하는 것을 진지하게 고려하도록 권장합니다; 우리는 유사하거나 관련된 데이터에 대해 두 해시 "
"계산이 수행되었기 때문에, 프로토콜의 한 부분에서 계산된 해시가 완전히 다른 부분에서 사용될 수 있는 프로토콜을 많이 보았으며, "
"공격자는 응용 프로그램이 해시 입력을 갖게 만들도록 강제할 수 있습니다. 프로토콜에 사용된 각 해시 함수를 개인화하면 이러한 유형의"
" 공격이 중단됩니다."

#: ../../library/hashlib.rst:701
#, fuzzy
msgid ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-"
"content/uploads/2016/02/skein.pdf>`_, p. 21)"
msgstr ""
"(`The Skein Hash Function Family <http://www.skein-"
"hash.info/sites/default/files/skein1.3.pdf>`_, p. 21)"

#: ../../library/hashlib.rst:705
msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2는 바이트열을 *person* 인자에 전달하여 개인화할 수 있습니다::"

#: ../../library/hashlib.rst:707
msgid ""
">>> from hashlib import blake2b\n"
">>> FILES_HASH_PERSON = b'MyApp Files Hash'\n"
">>> BLOCK_HASH_PERSON = b'MyApp Block Hash'\n"
">>> h = blake2b(digest_size=32, person=FILES_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'\n"
">>> h = blake2b(digest_size=32, person=BLOCK_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'"
msgstr ""

#: ../../library/hashlib.rst:719
msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr "키 모드와 함께 개인화를 사용하여, 한 키에서 다른 키들을 파생시킬 수도 있습니다."

#: ../../library/hashlib.rst:733
msgid "Tree mode"
msgstr "트리 모드"

#: ../../library/hashlib.rst:735
msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr "다음은 두 개의 리프 노드를 갖는 최소 트리를 해싱하는 예입니다::"

#: ../../library/hashlib.rst:737
msgid ""
"  10\n"
" /  \\\n"
"00  01"
msgstr ""

#: ../../library/hashlib.rst:741
msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final"
" digest::"
msgstr "이 예는 64바이트 내부 요약을 사용하고, 32바이트 최종 요약을 반환합니다::"

#: ../../library/hashlib.rst:744
msgid ""
">>> from hashlib import blake2b\n"
">>>\n"
">>> FANOUT = 2\n"
">>> DEPTH = 2\n"
">>> LEAF_SIZE = 4096\n"
">>> INNER_SIZE = 64\n"
">>>\n"
">>> buf = bytearray(6000)\n"
">>>\n"
">>> # Left leaf\n"
"... h00 = blake2b(buf[0:LEAF_SIZE], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=0, last_node=False)\n"
">>> # Right leaf\n"
"... h01 = blake2b(buf[LEAF_SIZE:], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=1, node_depth=0, last_node=True)\n"
">>> # Root node\n"
"... h10 = blake2b(digest_size=32, fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=1, last_node=True)\n"
">>> h10.update(h00.digest())\n"
">>> h10.update(h01.digest())\n"
">>> h10.hexdigest()\n"
"'3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa'"
msgstr ""

#: ../../library/hashlib.rst:771
msgid "Credits"
msgstr "크레딧"

#: ../../library/hashlib.rst:773
msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist "
"BLAKE_ created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*,"
" and *Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_\\는 *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier* 및 "
"*Raphael C.-W. Phan*\\이 만든 SHA-3_ 파이널리스트 BLAKE_\\를 기반으로 *Jean-Philippe "
"Aumasson*, *Samuel Neves*, *Zooko Wilcox-O'Hearn* 및 *Christian "
"Winnerlein*\\이 설계했습니다."

#: ../../library/hashlib.rst:778
msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr "*Daniel J.  Bernstein*\\이 설계한 ChaCha_ 암호(cipher)의 핵심 알고리즘을 사용합니다."

#: ../../library/hashlib.rst:780
msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by"
" *Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. "
"The documentation was copied from pyblake2_ and written by *Dmitry "
"Chestnykh*."
msgstr ""
"표준 라이브러리 구현은 pyblake2_ 모듈에 기반합니다. 이것은 *Samuel Neves*\\가 작성한 C 구현을 기반으로 "
"*Dmitry Chestnykh*\\가 작성했습니다. 이 설명서는 pyblake2_\\에서 복사했으며 *Dmitry "
"Chestnykh*\\가 작성했습니다."

#: ../../library/hashlib.rst:784
msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr "C 코드는 *Christian Heimes*\\가 파이썬 용으로 부분적으로 재작성했습니다."

#: ../../library/hashlib.rst:786
msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr "다음 공개 도메인 기부는 C 해시 함수 구현, 확장 코드 및 이 설명서 모두에 적용됩니다:"

#: ../../library/hashlib.rst:789
msgid ""
"To the extent possible under law, the author(s) have dedicated all "
"copyright and related and neighboring rights to this software to the "
"public domain worldwide. This software is distributed without any "
"warranty."
msgstr ""
"법률에 따라 가능한 범위 내에서, 저자(들)는 이 소프트웨어에 대한 모든 저작권과 관련되고 둘러싼 권리를 전 세계 공개 도메인에 "
"기부했습니다. 이 소프트웨어는 보증 없이 배포됩니다."

#: ../../library/hashlib.rst:793
msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along"
" with this software. If not, see "
"https://creativecommons.org/publicdomain/zero/1.0/."
msgstr ""
"이 소프트웨어와 함께 CC0 Public Domain Dedication의 사본을 받았어야 합니다. 그렇지 않으면, "
"https://creativecommons.org/publicdomain/zero/1.0/ 을 참조하십시오."

#: ../../library/hashlib.rst:797
msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"다음과 같은 사람들은 Creative Commons Public Domain Dedication 1.0 Universal에 따라 "
"개발을 돕거나 프로젝트와 공개 도메인에 변경에 기여했습니다:"

#: ../../library/hashlib.rst:801
msgid "*Alexandr Sokolovskiy*"
msgstr "*Alexandr Sokolovskiy*"

#: ../../library/hashlib.rst:821
msgid "Module :mod:`hmac`"
msgstr "모듈 :mod:`hmac`"

#: ../../library/hashlib.rst:822
msgid "A module to generate message authentication codes using hashes."
msgstr "해시를 사용하여 메시지 인증 코드를 생성하는 모듈."

#: ../../library/hashlib.rst:824
msgid "Module :mod:`base64`"
msgstr "모듈 :mod:`base64`"

#: ../../library/hashlib.rst:825
msgid "Another way to encode binary hashes for non-binary environments."
msgstr "바이너리가 아닌 환경을 위해 바이너리 해시를 인코딩하는 다른 방법."

#: ../../library/hashlib.rst:827
msgid "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"
msgstr ""

#: ../../library/hashlib.rst:828
#, fuzzy
msgid "The FIPS 180-4 publication on Secure Hash Algorithms."
msgstr "Secure Hash Algorithms에 관한 FIPS 180-2 발행물."

#: ../../library/hashlib.rst:830
msgid "https://csrc.nist.gov/pubs/fips/202/final"
msgstr ""

#: ../../library/hashlib.rst:831
#, fuzzy
msgid "The FIPS 202 publication on the SHA-3 Standard."
msgstr "Secure Hash Algorithms에 관한 FIPS 180-2 발행물."

#: ../../library/hashlib.rst:833
#, fuzzy
msgid "https://www.blake2.net/"
msgstr "https://blake2.net"

#: ../../library/hashlib.rst:834
msgid "Official BLAKE2 website."
msgstr "공식 BLAKE2 웹 사이트."

#: ../../library/hashlib.rst:836
#, fuzzy
msgid "https://en.wikipedia.org/wiki/Cryptographic_hash_function"
msgstr "https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms"

#: ../../library/hashlib.rst:837
msgid ""
"Wikipedia article with information on which algorithms have known issues "
"and what that means regarding their use."
msgstr "어떤 알고리즘에 알려진 문제가 있고 그것이 사용에 어떤 의미가 있는지에 대한 정보가 포함된 위키피디아 기사."

#: ../../library/hashlib.rst:840
#, fuzzy
msgid "https://www.ietf.org/rfc/rfc8018.txt"
msgstr "https://www.ietf.org/rfc/rfc2898.txt"

#: ../../library/hashlib.rst:841
#, fuzzy
msgid "PKCS #5: Password-Based Cryptography Specification Version 2.1"
msgstr "PKCS #5: Password-Based Cryptography Specification Version 2.0"

#: ../../library/hashlib.rst:843
msgid "https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"
msgstr ""

#: ../../library/hashlib.rst:844
msgid "NIST Recommendation for Password-Based Key Derivation."
msgstr ""

#: ../../library/hashlib.rst:12
msgid "message digest, MD5"
msgstr ""

#: ../../library/hashlib.rst:12
msgid ""
"secure hash algorithm, SHA1, SHA2, SHA224, SHA256, SHA384, SHA512, SHA3, "
"Shake, Blake2"
msgstr ""

#: ../../library/hashlib.rst:55
msgid "OpenSSL"
msgstr ""

#: ../../library/hashlib.rst:55
msgid "(use in module hashlib)"
msgstr ""

#: ../../library/hashlib.rst:372
#, fuzzy
msgid "blake2b, blake2s"
msgstr "BLAKE2s"

#~ msgid ""
#~ "For better multithreading performance, the "
#~ "Python :term:`GIL` is released for data"
#~ " larger than 2047 bytes at object "
#~ "creation or on update."
#~ msgstr ""
#~ "다중 스레딩 성능을 향상하기 위해, 객체 생성이나 "
#~ "갱신 시 2047바이트보다 큰 데이터에 대해 파이썬 "
#~ ":term:`GIL`\\이 해제됩니다."

#~ msgid ""
#~ "Feeding string objects into :meth:`update` "
#~ "is not supported, as hashes work "
#~ "on bytes, not on characters."
#~ msgstr "해시는 문자가 아닌 바이트에서 작동하므로, 문자열 객체를 :meth:`update`\\에 공급하는 것은 지원되지 않습니다."

#~ msgid ":func:`blake2b` and :func:`blake2s` were added."
#~ msgstr ":func:`blake2b`\\와 :func:`blake2s`\\가 추가되었습니다."

#~ msgid ""
#~ "The Python GIL is released to "
#~ "allow other threads to run while "
#~ "hash updates on data larger than "
#~ "2047 bytes is taking place when "
#~ "using hash algorithms supplied by "
#~ "OpenSSL."
#~ msgstr ""
#~ "파이썬 GIL은 OpenSSL에서 제공하는 해시 알고리즘을 "
#~ "사용할 때 2047바이트보다 큰 데이터에 대한 해시 "
#~ "갱신이 수행되는 동안 다른 스레드를 실행할 수 "
#~ "있도록 해제됩니다."

#~ msgid ""
#~ "The number of *iterations* should be "
#~ "chosen based on the hash algorithm "
#~ "and computing power. As of 2013, "
#~ "at least 100,000 iterations of SHA-256"
#~ " are suggested."
#~ msgstr ""
#~ "*iterations*\\의 수는 해시 알고리즘과 컴퓨팅 성능에 "
#~ "따라 선택해야 합니다. 2013년 현재, 적어도 "
#~ "100,000회의 SHA-256 반복이 제안됩니다."

#~ msgid ""
#~ "A fast implementation of *pbkdf2_hmac* "
#~ "is available with OpenSSL.  The Python"
#~ " implementation uses an inline version "
#~ "of :mod:`hmac`. It is about three "
#~ "times slower and doesn't release the "
#~ "GIL."
#~ msgstr ""
#~ "*pbkdf2_hmac*\\의 빠른 구현은 OpenSSL에서 제공됩니다. "
#~ "파이썬 구현은 인라인 버전의 :mod:`hmac`\\을 사용합니다."
#~ " 약 3배 느리고 GIL을 해제하지 않습니다."

#~ msgid ":ref:`Availability <availability>`: OpenSSL 1.1+."
#~ msgstr ":ref:`가용성 <availability>`: OpenSSL 1.1+."

#~ msgid "https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf"
#~ msgstr "https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf"

