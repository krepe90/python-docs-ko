# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/email.examples.rst:4
msgid ":mod:`email`: Examples"
msgstr ":mod:`email`: 예제"

#: ../../library/email.examples.rst:6
msgid ""
"Here are a few examples of how to use the :mod:`email` package to read, "
"write, and send simple email messages, as well as more complex MIME "
"messages."
msgstr ""
"다음은 :mod:`email` 패키지를 사용하여 간단한 전자 우편 메시지뿐만 아니라 더 복잡한 MIME 메시지를 읽고 쓰고 보내는 "
"방법에 대한 몇 가지 예입니다."

#: ../../library/email.examples.rst:9
msgid ""
"First, let's see how to create and send a simple text message (both the "
"text content and the addresses may contain unicode characters):"
msgstr "먼저 간단한 텍스트 메시지를 만들고 보내는 방법을 살펴보겠습니다 (텍스트 내용과 주소에 유니코드 문자가 포함될 수 있습니다):"

#: ../../library/email.examples.rst:12
#, python-brace-format
msgid ""
"# Import smtplib for the actual sending function\n"
"import smtplib\n"
"\n"
"# Import the email modules we'll need\n"
"from email.message import EmailMessage\n"
"\n"
"# Open the plain text file whose name is in textfile for reading.\n"
"with open(textfile) as fp:\n"
"    # Create a text/plain message\n"
"    msg = EmailMessage()\n"
"    msg.set_content(fp.read())\n"
"\n"
"# me == the sender's email address\n"
"# you == the recipient's email address\n"
"msg['Subject'] = f'The contents of {textfile}'\n"
"msg['From'] = me\n"
"msg['To'] = you\n"
"\n"
"# Send the message via our own SMTP server.\n"
"s = smtplib.SMTP('localhost')\n"
"s.send_message(msg)\n"
"s.quit()\n"
msgstr ""

#: ../../library/email.examples.rst:15
msgid ""
"Parsing :rfc:`822` headers can easily be done by the using the classes "
"from the :mod:`~email.parser` module:"
msgstr ":mod:`~email.parser` 모듈의 클래스를 사용하여 :rfc:`822` 헤더를 쉽게 구문 분석할 수 있습니다:"

#: ../../library/email.examples.rst:18
#, python-brace-format
msgid ""
"# Import the email modules we'll need\n"
"#from email.parser import BytesParser\n"
"from email.parser import Parser\n"
"from email.policy import default\n"
"\n"
"# If the e-mail headers are in a file, uncomment these two lines:\n"
"# with open(messagefile, 'rb') as fp:\n"
"#     headers = BytesParser(policy=default).parse(fp)\n"
"\n"
"#  Or for parsing headers in a string (this is an uncommon operation), "
"use:\n"
"headers = Parser(policy=default).parsestr(\n"
"        'From: Foo Bar <user@example.com>\\n'\n"
"        'To: <someone_else@example.com>\\n'\n"
"        'Subject: Test message\\n'\n"
"        '\\n'\n"
"        'Body would go here\\n')\n"
"\n"
"#  Now the header items can be accessed as a dictionary:\n"
"print('To: {}'.format(headers['to']))\n"
"print('From: {}'.format(headers['from']))\n"
"print('Subject: {}'.format(headers['subject']))\n"
"\n"
"# You can also access the parts of the addresses:\n"
"print('Recipient username: "
"{}'.format(headers['to'].addresses[0].username))\n"
"print('Sender name: "
"{}'.format(headers['from'].addresses[0].display_name))\n"
msgstr ""

#: ../../library/email.examples.rst:21
msgid ""
"Here's an example of how to send a MIME message containing a bunch of "
"family pictures that may be residing in a directory:"
msgstr "다음은 디렉터리에 있을 수 있는 가족사진을 포함하는 MIME 메시지를 보내는 방법의 예입니다:"

#: ../../library/email.examples.rst:24
msgid ""
"# Import smtplib for the actual sending function.\n"
"import smtplib\n"
"\n"
"# Here are the email package modules we'll need.\n"
"from email.message import EmailMessage\n"
"\n"
"# Create the container email message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = 'Our family reunion'\n"
"# me == the sender's email address\n"
"# family = the list of all recipients' email addresses\n"
"msg['From'] = me\n"
"msg['To'] = ', '.join(family)\n"
"msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"# Open the files in binary mode.  You can also omit the subtype\n"
"# if you want MIMEImage to guess it.\n"
"for file in pngfiles:\n"
"    with open(file, 'rb') as fp:\n"
"        img_data = fp.read()\n"
"    msg.add_attachment(img_data, maintype='image',\n"
"                                 subtype='png')\n"
"\n"
"# Send the email via our own SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""

#: ../../library/email.examples.rst:27
msgid ""
"Here's an example of how to send the entire contents of a directory as an"
" email message: [1]_"
msgstr "다음은 디렉터리의 전체 내용을 전자 우편 메시지로 보내는 방법의 예입니다: [1]_"

#: ../../library/email.examples.rst:30
#, python-brace-format
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Send the contents of a directory as a MIME message.\"\"\"\n"
"\n"
"import os\n"
"import smtplib\n"
"# For guessing MIME type based on file name extension\n"
"import mimetypes\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"from email.message import EmailMessage\n"
"from email.policy import SMTP\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Send the contents of a directory as a MIME message.\n"
"Unless the -o option is given, the email is sent by forwarding to your "
"local\n"
"SMTP server, which then does the normal delivery process.  Your local "
"machine\n"
"must be running an SMTP server.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory',\n"
"                        help=\"\"\"Mail the contents of the specified "
"directory,\n"
"                        otherwise use the current directory.  Only the "
"regular\n"
"                        files in the directory are sent, and we don't "
"recurse to\n"
"                        subdirectories.\"\"\")\n"
"    parser.add_argument('-o', '--output',\n"
"                        metavar='FILE',\n"
"                        help=\"\"\"Print the composed message to FILE "
"instead of\n"
"                        sending the message to the SMTP server.\"\"\")\n"
"    parser.add_argument('-s', '--sender', required=True,\n"
"                        help='The value of the From: header (required)')\n"
"    parser.add_argument('-r', '--recipient', required=True,\n"
"                        action='append', metavar='RECIPIENT',\n"
"                        default=[], dest='recipients',\n"
"                        help='A To: header value (at least one "
"required)')\n"
"    args = parser.parse_args()\n"
"    directory = args.directory\n"
"    if not directory:\n"
"        directory = '.'\n"
"    # Create the message\n"
"    msg = EmailMessage()\n"
"    msg['Subject'] = f'Contents of directory "
"{os.path.abspath(directory)}'\n"
"    msg['To'] = ', '.join(args.recipients)\n"
"    msg['From'] = args.sender\n"
"    msg.preamble = 'You will not see this in a MIME-aware mail "
"reader.\\n'\n"
"\n"
"    for filename in os.listdir(directory):\n"
"        path = os.path.join(directory, filename)\n"
"        if not os.path.isfile(path):\n"
"            continue\n"
"        # Guess the content type based on the file's extension.  Encoding"
"\n"
"        # will be ignored, although we should check for simple things "
"like\n"
"        # gzip'd or compressed files.\n"
"        ctype, encoding = mimetypes.guess_file_type(path)\n"
"        if ctype is None or encoding is not None:\n"
"            # No guess could be made, or the file is encoded "
"(compressed), so\n"
"            # use a generic bag-of-bits type.\n"
"            ctype = 'application/octet-stream'\n"
"        maintype, subtype = ctype.split('/', 1)\n"
"        with open(path, 'rb') as fp:\n"
"            msg.add_attachment(fp.read(),\n"
"                               maintype=maintype,\n"
"                               subtype=subtype,\n"
"                               filename=filename)\n"
"    # Now send or store the message\n"
"    if args.output:\n"
"        with open(args.output, 'wb') as fp:\n"
"            fp.write(msg.as_bytes(policy=SMTP))\n"
"    else:\n"
"        with smtplib.SMTP('localhost') as s:\n"
"            s.send_message(msg)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: ../../library/email.examples.rst:33
msgid ""
"Here's an example of how to unpack a MIME message like the one above, "
"into a directory of files:"
msgstr "다음은 위와 같은 MIME 메시지를 디렉터리로 푸는 방법의 예입니다:"

#: ../../library/email.examples.rst:36
#, python-brace-format
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Unpack a MIME message into a directory of files.\"\"\"\n"
"\n"
"import os\n"
"import email\n"
"import mimetypes\n"
"\n"
"from email.policy import default\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Unpack a MIME message into a directory of files.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory', required=True,\n"
"                        help=\"\"\"Unpack the MIME message into the named"
"\n"
"                        directory, which will be created if it doesn't "
"already\n"
"                        exist.\"\"\")\n"
"    parser.add_argument('msgfile')\n"
"    args = parser.parse_args()\n"
"\n"
"    with open(args.msgfile, 'rb') as fp:\n"
"        msg = email.message_from_binary_file(fp, policy=default)\n"
"\n"
"    try:\n"
"        os.mkdir(args.directory)\n"
"    except FileExistsError:\n"
"        pass\n"
"\n"
"    counter = 1\n"
"    for part in msg.walk():\n"
"        # multipart/* are just containers\n"
"        if part.get_content_maintype() == 'multipart':\n"
"            continue\n"
"        # Applications should really sanitize the given filename so that "
"an\n"
"        # email message can't be used to overwrite important files\n"
"        filename = part.get_filename()\n"
"        if not filename:\n"
"            ext = mimetypes.guess_extension(part.get_content_type())\n"
"            if not ext:\n"
"                # Use a generic bag-of-bits extension\n"
"                ext = '.bin'\n"
"            filename = f'part-{counter:03d}{ext}'\n"
"        counter += 1\n"
"        with open(os.path.join(args.directory, filename), 'wb') as fp:\n"
"            fp.write(part.get_payload(decode=True))\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: ../../library/email.examples.rst:39
msgid ""
"Here's an example of how to create an HTML message with an alternative "
"plain text version.  To make things a bit more interesting, we include a "
"related image in the html part, and we save a copy of what we are going "
"to send to disk, as well as sending it."
msgstr ""
"다음은 대체 일반 텍스트 버전으로 HTML 메시지를 만드는 방법의 예입니다. 좀 더 흥미롭게 하기 위해, html 부분에 관련 "
"이미지를 포함하고, 보낼 뿐만 아니라, 보낼 것의 사본을 디스크에 저장합니다."

#: ../../library/email.examples.rst:44
#, python-brace-format
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"import smtplib\n"
"\n"
"from email.message import EmailMessage\n"
"from email.headerregistry import Address\n"
"from email.utils import make_msgid\n"
"\n"
"# Create the base text message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = \"Pourquoi pas des asperges pour ce midi ?\"\n"
"msg['From'] = Address(\"Pepé Le Pew\", \"pepe\", \"example.com\")\n"
"msg['To'] = (Address(\"Penelope Pussycat\", \"penelope\", "
"\"example.com\"),\n"
"             Address(\"Fabrette Pussycat\", \"fabrette\", "
"\"example.com\"))\n"
"msg.set_content(\"\"\"\\\n"
"Salut!\n"
"\n"
"Cette recette [1] sera sûrement un très bon repas.\n"
"\n"
"[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\n"
"\n"
"--Pepé\n"
"\"\"\")\n"
"\n"
"# Add the html version.  This converts the message into a "
"multipart/alternative\n"
"# container, with the original text message as the first part and the new"
" html\n"
"# message as the second part.\n"
"asparagus_cid = make_msgid()\n"
"msg.add_alternative(\"\"\"\\\n"
"<html>\n"
"  <head></head>\n"
"  <body>\n"
"    <p>Salut!</p>\n"
"    <p>Cette\n"
"        <a href=\"http://www.yummly.com/recipe/Roasted-Asparagus-"
"Epicurious-203718\">\n"
"            recette\n"
"        </a> sera sûrement un très bon repas.\n"
"    </p>\n"
"    <img src=\"cid:{asparagus_cid}\">\n"
"  </body>\n"
"</html>\n"
"\"\"\".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')\n"
"# note that we needed to peel the <> off the msgid for use in the html.\n"
"\n"
"# Now add the related image to the html part.\n"
"with open(\"roasted-asparagus.jpg\", 'rb') as img:\n"
"    msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',\n"
"                                     cid=asparagus_cid)\n"
"\n"
"# Make a local copy of what we are going to send.\n"
"with open('outgoing.msg', 'wb') as f:\n"
"    f.write(bytes(msg))\n"
"\n"
"# Send the message via local SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""

#: ../../library/email.examples.rst:47
msgid ""
"If we were sent the message from the last example, here is one way we "
"could process it:"
msgstr "마지막 예에서 메시지를 보냈다면, 다음은 그것을 처리하는 한 가지 방법입니다:"

#: ../../library/email.examples.rst:50
#, python-brace-format
msgid ""
"import os\n"
"import sys\n"
"import tempfile\n"
"import mimetypes\n"
"import webbrowser\n"
"\n"
"# Import the email modules we'll need\n"
"from email import policy\n"
"from email.parser import BytesParser\n"
"\n"
"\n"
"def magic_html_parser(html_text, partfiles):\n"
"    \"\"\"Return safety-sanitized html linked to partfiles.\n"
"\n"
"    Rewrite the href=\"cid:....\" attributes to point to the filenames in"
" partfiles.\n"
"    Though not trivial, this should be possible using html.parser.\n"
"    \"\"\"\n"
"    raise NotImplementedError(\"Add the magic needed\")\n"
"\n"
"\n"
"# In a real program you'd get the filename from the arguments.\n"
"with open('outgoing.msg', 'rb') as fp:\n"
"    msg = BytesParser(policy=policy.default).parse(fp)\n"
"\n"
"# Now the header items can be accessed as a dictionary, and any non-ASCII"
" will\n"
"# be converted to unicode:\n"
"print('To:', msg['to'])\n"
"print('From:', msg['from'])\n"
"print('Subject:', msg['subject'])\n"
"\n"
"# If we want to print a preview of the message content, we can extract "
"whatever\n"
"# the least formatted payload is and print the first three lines.  Of "
"course,\n"
"# if the message has no plain text part printing the first three lines of"
" html\n"
"# is probably useless, but this is just a conceptual example.\n"
"simplest = msg.get_body(preferencelist=('plain', 'html'))\n"
"print()\n"
"print(''.join(simplest.get_content().splitlines(keepends=True)[:3]))\n"
"\n"
"ans = input(\"View full message?\")\n"
"if ans.lower()[0] == 'n':\n"
"    sys.exit()\n"
"\n"
"# We can extract the richest alternative in order to display it:\n"
"richest = msg.get_body()\n"
"partfiles = {}\n"
"if richest['content-type'].maintype == 'text':\n"
"    if richest['content-type'].subtype == 'plain':\n"
"        for line in richest.get_content().splitlines():\n"
"            print(line)\n"
"        sys.exit()\n"
"    elif richest['content-type'].subtype == 'html':\n"
"        body = richest\n"
"    else:\n"
"        print(\"Don't know how to display "
"{}\".format(richest.get_content_type()))\n"
"        sys.exit()\n"
"elif richest['content-type'].content_type == 'multipart/related':\n"
"    body = richest.get_body(preferencelist=('html'))\n"
"    for part in richest.iter_attachments():\n"
"        fn = part.get_filename()\n"
"        if fn:\n"
"            extension = os.path.splitext(part.get_filename())[1]\n"
"        else:\n"
"            extension = "
"mimetypes.guess_extension(part.get_content_type())\n"
"        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) "
"as f:\n"
"            f.write(part.get_content())\n"
"            # again strip the <> to go from email form of cid to html "
"form.\n"
"            partfiles[part['content-id'][1:-1]] = f.name\n"
"else:\n"
"    print(\"Don't know how to display "
"{}\".format(richest.get_content_type()))\n"
"    sys.exit()\n"
"with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n"
"    f.write(magic_html_parser(body.get_content(), partfiles))\n"
"webbrowser.open(f.name)\n"
"os.remove(f.name)\n"
"for fn in partfiles.values():\n"
"    os.remove(fn)\n"
"\n"
"# Of course, there are lots of email messages that could break this "
"simple\n"
"# minded program, but it will handle the most common ones.\n"
msgstr ""

#: ../../library/email.examples.rst:52
msgid "Up to the prompt, the output from the above is:"
msgstr "프롬프트까지, 위의 출력은 다음과 같습니다:"

#: ../../library/email.examples.rst:54
msgid ""
"To: Penelope Pussycat <penelope@example.com>, Fabrette Pussycat "
"<fabrette@example.com>\n"
"From: Pepé Le Pew <pepe@example.com>\n"
"Subject: Pourquoi pas des asperges pour ce midi ?\n"
"\n"
"Salut!\n"
"\n"
"Cette recette [1] sera sûrement un très bon repas."
msgstr ""

#: ../../library/email.examples.rst:66
msgid "Footnotes"
msgstr "각주"

#: ../../library/email.examples.rst:67
msgid "Thanks to Matthew Dixon Cowles for the original inspiration and examples."
msgstr "영감과 예를 주신 Matthew Dixon Cowles에게 감사드립니다."

