# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/pyexpat.rst:2
msgid ":mod:`!xml.parsers.expat` --- Fast XML parsing using Expat"
msgstr ":mod:`!xml.parsers.expat` --- Expat을 사용한 빠른 XML 구문 분석"

#: ../../library/pyexpat.rst:21
msgid ""
"The :mod:`pyexpat` module is not secure against maliciously constructed "
"data.  If you need to parse untrusted or unauthenticated data see :ref"
":`xml-vulnerabilities`."
msgstr ""
":mod:`pyexpat` 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 "
"분석해야 하면 :ref:`xml-vulnerabilities`\\을 참조하십시오."

#: ../../library/pyexpat.rst:28
msgid ""
"The :mod:`xml.parsers.expat` module is a Python interface to the Expat "
"non-validating XML parser. The module provides a single extension type, "
":class:`xmlparser`, that represents the current state of an XML parser.  "
"After an :class:`xmlparser` object has been created, various attributes "
"of the object can be set to handler functions.  When an XML document is "
"then fed to the parser, the handler functions are called for the "
"character data and markup in the XML document."
msgstr ""
":mod:`xml.parsers.expat` 모듈은 Expat 유효성 검사 없는(non-validating) XML 구문 분석기에 "
"대한 파이썬 인터페이스입니다. 이 모듈은 XML 구문 분석기의 현재 상태를 나타내는 단일 확장형 "
":class:`xmlparser`\\를 제공합니다. :class:`xmlparser` 객체가 만들어진 후, 객체의 다양한 "
"어트리뷰트를 처리기 함수로 설정할 수 있습니다. 그런 다음 XML 문서가 구문 분석기에 공급되면, XML 문서에 있는 문자 데이터와"
" 마크업에 대해 처리기 함수가 호출됩니다."

#: ../../library/pyexpat.rst:38
msgid ""
"This module uses the :mod:`pyexpat` module to provide access to the Expat"
" parser.  Direct use of the :mod:`pyexpat` module is deprecated."
msgstr ""
"이 모듈은 :mod:`pyexpat` 모듈을 사용하여 Expat 구문 분석기에 대한 액세스를 제공합니다. :mod:`pyexpat`"
" 모듈의 직접적인 사용은 폐지되었습니다."

#: ../../library/pyexpat.rst:41
msgid "This module provides one exception and one type object:"
msgstr "이 모듈은 하나의 예외와 하나의 형 객체를 제공합니다:"

#: ../../library/pyexpat.rst:46
msgid ""
"The exception raised when Expat reports an error.  See section :ref"
":`expaterror-objects` for more information on interpreting Expat errors."
msgstr ""
"Expat이 에러를 보고할 때 발생하는 예외. Expat 에러 해석에 대한 자세한 정보는 섹션 :ref:`expaterror-"
"objects`\\를 참조하십시오."

#: ../../library/pyexpat.rst:52
msgid "Alias for :exc:`ExpatError`."
msgstr ":exc:`ExpatError`\\의 별칭."

#: ../../library/pyexpat.rst:57
msgid "The type of the return values from the :func:`ParserCreate` function."
msgstr ":func:`ParserCreate` 함수의 반환 값의 형."

#: ../../library/pyexpat.rst:59
msgid "The :mod:`xml.parsers.expat` module contains two functions:"
msgstr ":mod:`xml.parsers.expat` 모듈에는 두 가지 함수가 있습니다:"

#: ../../library/pyexpat.rst:64
msgid "Returns an explanatory string for a given error number *errno*."
msgstr "주어진 에러 번호 *errno*\\에 대한 설명 문자열을 반환합니다."

#: ../../library/pyexpat.rst:69
msgid ""
"Creates and returns a new :class:`xmlparser` object.   *encoding*, if "
"specified, must be a string naming the encoding  used by the XML data.  "
"Expat doesn't support as many encodings as Python does, and its "
"repertoire of encodings can't be extended; it supports UTF-8, UTF-16, "
"ISO-8859-1 (Latin1), and ASCII.  If *encoding* [1]_ is given it will "
"override the implicit or explicit encoding of the document."
msgstr ""
"새로운 :class:`xmlparser` 객체를 만들고 반환합니다. 지정되면, *encoding*\\은 XML 데이터가 사용하는 "
"인코딩의 이름을 지정하는 문자열이어야 합니다. Expat은 파이썬만큼 많은 인코딩을 지원하지 않으며, 인코딩 레퍼토리를 확장할 수 "
"없습니다; UTF-8, UTF-16, ISO-8859-1 (Latin1) 및 ASCII를 지원합니다. *encoding* [1]_ "
"이 제공되면 문서의 묵시적이나 명시적 인코딩을 대체합니다."

#: ../../library/pyexpat.rst:76
msgid ""
"Expat can optionally do XML namespace processing for you, enabled by "
"providing a value for *namespace_separator*.  The value must be a one-"
"character string; a :exc:`ValueError` will be raised if the string has an"
" illegal length (``None`` is considered the same as omission).  When "
"namespace processing is enabled, element type names and attribute names "
"that belong to a namespace will be expanded.  The element name passed to "
"the element handlers :attr:`StartElementHandler` and "
":attr:`EndElementHandler` will be the concatenation of the namespace URI,"
" the namespace separator character, and the local part of the name.  If "
"the namespace separator is a zero byte (``chr(0)``) then the namespace "
"URI and the local part will be concatenated without any separator."
msgstr ""
"Expat은 XML 이름 공간 처리를 선택적으로 수행할 수 있는데, *namespace_separator*\\에 값을 제공하는 "
"것으로 활성화됩니다. 값은 한 문자 문자열이어야 합니다; 문자열의 길이가 잘못되면 :exc:`ValueError`\\가 발생합니다 "
"(``None``\\은 생략과 같은 것으로 간주합니다). 이름 공간 처리가 활성화되면, 이름 공간에 속하는 엘리먼트 형 이름과 "
"어트리뷰트 이름이 확장됩니다. 엘리먼트 처리기 :attr:`StartElementHandler`\\와 "
":attr:`EndElementHandler` 에 전달된 엘리먼트 이름은 이름 공간 URI, 이름 공간 구분 문자 및 이름의 로컬 "
"부분의 이어붙이기입니다. 이름 공간 구분자가 0바이트(``chr(0)``)이면 이름 공간 URI와 로컬 부분이 구분자 없이 "
"연결됩니다."

#: ../../library/pyexpat.rst:88
msgid ""
"For example, if *namespace_separator* is set to a space character (``' "
"'``) and the following document is parsed:"
msgstr "예를 들어, *namespace_separator*\\가 스페이스 문자(``' '``)로 설정되고 다음 문서가 구문 분석되면:"

#: ../../library/pyexpat.rst:91
msgid ""
"<?xml version=\"1.0\"?>\n"
"<root xmlns    = \"http://default-namespace.org/\"\n"
"      xmlns:py = \"http://www.python.org/ns/\">\n"
"  <py:elem1 />\n"
"  <elem2 xmlns=\"\" />\n"
"</root>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<root xmlns    = \"http://default-namespace.org/\"\n"
"      xmlns:py = \"http://www.python.org/ns/\">\n"
"  <py:elem1 />\n"
"  <elem2 xmlns=\"\" />\n"
"</root>"

#: ../../library/pyexpat.rst:100
msgid ""
":attr:`StartElementHandler` will receive the following strings for each "
"element::"
msgstr ":attr:`StartElementHandler`\\는 각 엘리먼트에 대해 다음 문자열을 수신합니다::"

#: ../../library/pyexpat.rst:103
msgid ""
"http://default-namespace.org/ root\n"
"http://www.python.org/ns/ elem1\n"
"elem2"
msgstr ""
"http://default-namespace.org/ root\n"
"http://www.python.org/ns/ elem1\n"
"elem2"

#: ../../library/pyexpat.rst:107
msgid ""
"Due to limitations in the ``Expat`` library used by :mod:`pyexpat`, the "
":class:`xmlparser` instance returned can only be used to parse a single "
"XML document.  Call ``ParserCreate`` for each document to provide unique "
"parser instances."
msgstr ""
":mod:`pyexpat`\\에서 사용하는 ``Expat`` 라이브러리의 제한으로 인해, 반환된 :class:`xmlparser` "
"인스턴스는 단일 XML 문서를 구문 분석하는 데만 사용할 수 있습니다. 고유한 구문 분석기 인스턴스를 제공하려면 문서마다 "
"``ParserCreate``\\를 호출하십시오."

#: ../../library/pyexpat.rst:115
msgid "`The Expat XML Parser <http://www.libexpat.org/>`_"
msgstr "`Expat XML 구문 분석기 <http://www.libexpat.org/>`_"

#: ../../library/pyexpat.rst:116
msgid "Home page of the Expat project."
msgstr "Expat 프로젝트의 홈페이지."

#: ../../library/pyexpat.rst:122
msgid "XMLParser Objects"
msgstr "XMLParser 객체"

#: ../../library/pyexpat.rst:124
msgid ":class:`xmlparser` objects have the following methods:"
msgstr ":class:`xmlparser` 객체에는 다음과 같은 메서드가 있습니다:"

#: ../../library/pyexpat.rst:129
msgid ""
"Parses the contents of the string *data*, calling the appropriate handler"
" functions to process the parsed data.  *isfinal* must be true on the "
"final call to this method; it allows the parsing of a single file in "
"fragments, not the submission of multiple files. *data* can be the empty "
"string at any time."
msgstr ""
"문자열 *data*\\의 내용을 구문 분석하고, 구문 분석된 데이터를 처리하기 위해 적절한 처리기 함수를 호출합니다. 이 메서드에 "
"대한 최종 호출에서 *isfinal*\\은 참이어야 합니다; 여러 파일을 제출하는 것이 아니라, 단일 파일을 여러 조각으로 나누어 "
"구문 분석 할 수 있도록 합니다. *data*\\는 언제든지 빈 문자열이 될 수 있습니다."

#: ../../library/pyexpat.rst:138
msgid ""
"Parse XML data reading from the object *file*.  *file* only needs to "
"provide the ``read(nbytes)`` method, returning the empty string when "
"there's no more data."
msgstr ""
"*file* 객체에서 읽은 XML 데이터를 구문 분석합니다. *file*\\은 더는 데이터가 없을 때 빈 문자열을 반환하는 "
"``read(nbytes)`` 메서드만 제공하면 됩니다."

#: ../../library/pyexpat.rst:145
msgid ""
"Sets the base to be used for resolving relative URIs in system "
"identifiers in declarations.  Resolving relative identifiers is left to "
"the application: this value will be passed through as the *base* argument"
" to the :func:`ExternalEntityRefHandler`, :func:`NotationDeclHandler`, "
"and :func:`UnparsedEntityDeclHandler` functions."
msgstr ""
"선언에서 시스템 식별자에 있는 상대 URI를 결정하는 데 사용할 베이스를 설정합니다. 상대 식별자 결정은 응용 프로그램에 "
"맡겨집니다: 이 값은 *base* 인자로 :func:`ExternalEntityRefHandler`, "
":func:`NotationDeclHandler` 및 :func:`UnparsedEntityDeclHandler` 함수에 "
"전달됩니다."

#: ../../library/pyexpat.rst:154
msgid ""
"Returns a string containing the base set by a previous call to "
":meth:`SetBase`, or ``None`` if  :meth:`SetBase` hasn't been called."
msgstr ""
":meth:`SetBase`\\에 대한 이전 호출에 의해 설정된 베이스를 포함하는 문자열을 반환하거나, "
":meth:`SetBase`\\가 호출되지 않았으면 ``None``\\을 반환합니다."

#: ../../library/pyexpat.rst:160
msgid ""
"Returns the input data that generated the current event as a string. The "
"data is in the encoding of the entity which contains the text. When "
"called while an event handler is not active, the return value is "
"``None``."
msgstr ""
"현재 이벤트를 생성한 입력 데이터를 문자열로 반환합니다. 데이터는 텍스트를 포함하는 엔티티의 인코딩을 따릅니다. 이벤트 처리기가 "
"활성화되지 않은 상태에서 호출될 때, 반환 값은 ``None``\\입니다."

#: ../../library/pyexpat.rst:167
msgid ""
"Create a \"child\" parser which can be used to parse an external parsed "
"entity referred to by content parsed by the parent parser.  The *context*"
" parameter should be the string passed to the "
":meth:`ExternalEntityRefHandler` handler function, described below. The "
"child parser is created with the :attr:`ordered_attributes` and "
":attr:`specified_attributes` set to the values of this parser."
msgstr ""
"부모 구문 분석기가 구문 분석한 내용이 참조하는 외부 구문 분석된 엔티티를 구문 분석하는 데 사용할 수 있는 \"자식\" 구문 "
"분석기를 만듭니다. *context* 매개 변수는 아래 설명된 :meth:`ExternalEntityRefHandler` 처리기 "
"함수에 전달된 문자열이어야 합니다. 자식 구문 분석기는 :attr:`ordered_attributes`\\와 "
":attr:`specified_attributes`\\가 이 구문 분석기의 값으로 설정된 상태로 만들어집니다."

#: ../../library/pyexpat.rst:176
msgid ""
"Control parsing of parameter entities (including the external DTD "
"subset). Possible *flag* values are "
":const:`XML_PARAM_ENTITY_PARSING_NEVER`, "
":const:`XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE` and "
":const:`XML_PARAM_ENTITY_PARSING_ALWAYS`.  Return true if setting the "
"flag was successful."
msgstr ""
"매개 변수 엔티티(외부 DTD 부분 집합을 포함합니다)의 구문 분석을 제어합니다. 가능한 *flag* 값은 "
":const:`XML_PARAM_ENTITY_PARSING_NEVER`, "
":const:`XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE` 및 "
":const:`XML_PARAM_ENTITY_PARSING_ALWAYS`\\입니다. 플래그 설정에 성공하면 참을 반환합니다."

#: ../../library/pyexpat.rst:184
msgid ""
"Calling this with a true value for *flag* (the default) will cause Expat "
"to call the :attr:`ExternalEntityRefHandler` with :const:`None` for all "
"arguments to allow an alternate DTD to be loaded.  If the document does "
"not contain a document type declaration, the "
":attr:`ExternalEntityRefHandler` will still be called, but the "
":attr:`StartDoctypeDeclHandler` and :attr:`EndDoctypeDeclHandler` will "
"not be called."
msgstr ""
"*flag*\\에 대해 참값(기본값)으로 이를 호출하면 Expat이 대체 DTD를 로드할 수 있도록 모든 인자를 "
":const:`None`\\으로 :attr:`ExternalEntityRefHandler`\\를 호출하도록 합니다. 문서에 문서 형"
" 선언이 포함되어 있지 않으면, :attr:`ExternalEntityRefHandler`\\는 여전히 호출되지만, "
":attr:`StartDoctypeDeclHandler`\\와 :attr:`EndDoctypeDeclHandler`\\는 호출되지 "
"않습니다."

#: ../../library/pyexpat.rst:191
msgid ""
"Passing a false value for *flag* will cancel a previous call that passed "
"a true value, but otherwise has no effect."
msgstr "*flag*\\에 대해 거짓 값을 전달하면 참값을 전달한 이전 호출이 취소되지만, 그렇지 않으면 효과가 없습니다."

#: ../../library/pyexpat.rst:194
msgid ""
"This method can only be called before the :meth:`Parse` or "
":meth:`ParseFile` methods are called; calling it after either of those "
"have been called causes :exc:`ExpatError` to be raised with the "
":attr:`code` attribute set to "
"``errors.codes[errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]``."
msgstr ""
"이 메서드는 :meth:`Parse`\\나 :meth:`ParseFile` 메서드가 호출되기 전에만 호출 할 수 있습니다; 이들 중"
" 어느 것이라도 호출된 후에 호출하면 :attr:`code` 어트리뷰트가 "
"``errors.codes[errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]``\\로 "
"설정된 :exc:`ExpatError`\\가 발생합니다."

#: ../../library/pyexpat.rst:203
msgid ""
"Calling ``SetReparseDeferralEnabled(False)`` has security implications, "
"as detailed below; please make sure to understand these consequences "
"prior to using the ``SetReparseDeferralEnabled`` method."
msgstr ""

#: ../../library/pyexpat.rst:207
msgid ""
"Expat 2.6.0 introduced a security mechanism called \"reparse deferral\" "
"where instead of causing denial of service through quadratic runtime from"
" reparsing large tokens, reparsing of unfinished tokens is now delayed by"
" default until a sufficient amount of input is reached. Due to this "
"delay, registered handlers may — depending of the sizing of input chunks "
"pushed to Expat — no longer be called right after pushing new input to "
"the parser.  Where immediate feedback and taking over responsibility of "
"protecting against denial of service from large tokens are both wanted, "
"calling ``SetReparseDeferralEnabled(False)`` disables reparse deferral "
"for the current Expat parser instance, temporarily or altogether. Calling"
" ``SetReparseDeferralEnabled(True)`` allows re-enabling reparse deferral."
msgstr ""

#: ../../library/pyexpat.rst:220
msgid ""
"Note that :meth:`SetReparseDeferralEnabled` has been backported to some "
"prior releases of CPython as a security fix.  Check for availability of "
":meth:`SetReparseDeferralEnabled` using :func:`hasattr` if used in code "
"running across a variety of Python versions."
msgstr ""

#: ../../library/pyexpat.rst:229
msgid ""
"Returns whether reparse deferral is currently enabled for the given Expat"
" parser instance."
msgstr ""

#: ../../library/pyexpat.rst:235
msgid ":class:`xmlparser` objects have the following attributes:"
msgstr ":class:`xmlparser` 객체에는 다음과 같은 어트리뷰트가 있습니다:"

#: ../../library/pyexpat.rst:240
msgid ""
"The size of the buffer used when :attr:`buffer_text` is true. A new "
"buffer size can be set by assigning a new integer value to this "
"attribute. When the size is changed, the buffer will be flushed."
msgstr ""
":attr:`buffer_text`\\가 참일 때 사용되는 버퍼의 크기. 이 어트리뷰트에 새로운 정숫값을 대입하여 새로운 버퍼 "
"크기를 설정할 수 있습니다. 크기가 변경되면 버퍼가 플러시 됩니다."

#: ../../library/pyexpat.rst:248
msgid ""
"Setting this to true causes the :class:`xmlparser` object to buffer "
"textual content returned by Expat to avoid multiple calls to the "
":meth:`CharacterDataHandler` callback whenever possible.  This can "
"improve performance substantially since Expat normally breaks character "
"data into chunks at every line ending.  This attribute is false by "
"default, and may be changed at any time. Note that when it is false, data"
" that does not contain newlines may be chunked too."
msgstr ""
"이 값을 참으로 설정하면 :class:`xmlparser` 객체가 Expat에서 반환한 텍스트 내용을 버퍼링하여 가능할 때마다 "
":meth:`CharacterDataHandler` 콜백을 여러 번 호출하지 않도록 합니다. Expat은 일반적으로 모든 줄 끝에서"
" 문자 데이터를 덩어리로 나누기 때문에 성능을 크게 향상할 수 있습니다. 이 어트리뷰트는 기본적으로 거짓이며, 언제든지 변경될 수 "
"있습니다. 거짓일 때, 줄 넘김이 없는 데이터도 덩어리노 나뉠 수 있음에 유의하십시오."

#: ../../library/pyexpat.rst:259
msgid ""
"If :attr:`buffer_text` is enabled, the number of bytes stored in the "
"buffer. These bytes represent UTF-8 encoded text.  This attribute has no "
"meaningful interpretation when :attr:`buffer_text` is false."
msgstr ""
":attr:`buffer_text`\\가 활성화되면, 버퍼에 저장된 바이트 수. 이 바이트열은 UTF-8로 인코딩된 텍스트를 "
"나타냅니다. :attr:`buffer_text`\\가 거짓이면 이 어트리뷰트는 의미가 없습니다."

#: ../../library/pyexpat.rst:266
msgid ""
"Setting this attribute to a non-zero integer causes the attributes to be "
"reported as a list rather than a dictionary.  The attributes are "
"presented in the order found in the document text.  For each attribute, "
"two list entries are presented: the attribute name and the attribute "
"value.  (Older versions of this module also used this format.)  By "
"default, this attribute is false; it may be changed at any time."
msgstr ""
"이 어트리뷰트를 0이 아닌 정수로 설정하면 어트리뷰트가 딕셔너리가 아닌 리스트로 보고됩니다. 어트리뷰트는 문서 텍스트에서 발견된 "
"순서대로 표시됩니다. 각 어트리뷰트에 대해, 두 가지 리스트 항목이 표시됩니다: 어트리뷰트 이름과 어트리뷰트 값. (이 모듈의 이전"
" 버전도 이 형식을 사용했습니다.) 기본적으로, 이 어트리뷰트는 거짓입니다; 언제든지 변경될 수 있습니다."

#: ../../library/pyexpat.rst:276
msgid ""
"If set to a non-zero integer, the parser will report only those "
"attributes which were specified in the document instance and not those "
"which were derived from attribute declarations.  Applications which set "
"this need to be especially careful to use what additional information is "
"available from the declarations as needed to comply with the standards "
"for the behavior of XML processors.  By default, this attribute is false;"
" it may be changed at any time."
msgstr ""
"0이 아닌 정수로 설정되면, 구문 분석기는 문서 인스턴스에 지정된 어트리뷰트만 보고하고 어트리뷰트 선언에서 파생된 어트리뷰트는 "
"보고하지 않습니다. 이를 설정한 응용 프로그램은 XML 프로세서의 동작에 대한 표준을 준수하기 위해 선언에서 사용 가능한 추가 "
"정보를 사용할 때 특히 주의해야 합니다. 기본적으로, 이 어트리뷰트는 거짓입니다; 언제든지 변경될 수 있습니다."

#: ../../library/pyexpat.rst:284
msgid ""
"The following attributes contain values relating to the most recent error"
" encountered by an :class:`xmlparser` object, and will only have correct "
"values once a call to :meth:`Parse` or :meth:`ParseFile` has raised an "
":exc:`xml.parsers.expat.ExpatError` exception."
msgstr ""
"다음 어트리뷰트는 :class:`xmlparser` 객체가 만난 가장 최근 에러와 관련된 값을 포함하며, 일단 "
":meth:`Parse`\\나 :meth:`ParseFile`\\에 대한 호출이 "
":exc:`xml.parsers.expat.ExpatError` 예외를 발생시켰을 때만 올바른 값을 갖습니다."

#: ../../library/pyexpat.rst:292
msgid "Byte index at which an error occurred."
msgstr "에러가 발생한 바이트 인덱스."

#: ../../library/pyexpat.rst:297
msgid ""
"Numeric code specifying the problem.  This value can be passed to the "
":func:`ErrorString` function, or compared to one of the constants defined"
" in the ``errors`` object."
msgstr ""
"문제를 지정하는 숫자 코드. 이 값은 :func:`ErrorString` 함수에 전달되거나, ``errors`` 객체에 정의된 상수"
" 중 하나와 비교될 수 있습니다."

#: ../../library/pyexpat.rst:304
msgid "Column number at which an error occurred."
msgstr "에러가 발생한 열 번호."

#: ../../library/pyexpat.rst:309
msgid "Line number at which an error occurred."
msgstr "에러가 발생한 줄 번호."

#: ../../library/pyexpat.rst:311
msgid ""
"The following attributes contain values relating to the current parse "
"location in an :class:`xmlparser` object.  During a callback reporting a "
"parse event they indicate the location of the first of the sequence of "
"characters that generated the event.  When called outside of a callback, "
"the position indicated will be just past the last parse event (regardless"
" of whether there was an associated callback)."
msgstr ""
"다음 어트리뷰트는 :class:`xmlparser` 객체의 현재 구문 분석 위치와 관련된 값을 포함합니다. 구문 분석 이벤트를 "
"보고하는 콜백 중에, 이들은 이벤트를 생성한 첫 번째 문자 시퀀스의 위치를 나타냅니다. 콜백 외부에서 호출되면, 표시된 위치는 "
"마지막 구문 분석 이벤트 바로 다음입니다 (관련 콜백이 있는지에 관계없이)."

#: ../../library/pyexpat.rst:321
msgid "Current byte index in the parser input."
msgstr "구문 분석기 입력의 현재 바이트 인덱스."

#: ../../library/pyexpat.rst:326
msgid "Current column number in the parser input."
msgstr "구문 분석기 입력의 현재 열 번호."

#: ../../library/pyexpat.rst:331
msgid "Current line number in the parser input."
msgstr "구문 분석기 입력의 현재 줄 번호."

#: ../../library/pyexpat.rst:333
msgid ""
"Here is the list of handlers that can be set.  To set a handler on an "
":class:`xmlparser` object *o*, use ``o.handlername = func``.  "
"*handlername* must be taken from the following list, and *func* must be a"
" callable object accepting the correct number of arguments.  The "
"arguments are all strings, unless otherwise stated."
msgstr ""
"설정할 수 있는 처리기 목록은 다음과 같습니다. :class:`xmlparser` 객체 *o*\\에 처리기를 설정하려면, "
"``o.handlername = func``\\를 사용하십시오. *handlername*\\은 다음 목록에서 취해야 하며, "
"*func*\\는 올바른 수의 인자를 받아들이는 콜러블 객체여야 합니다. 달리 명시되지 않는 한, 인자는 모두 문자열입니다."

#: ../../library/pyexpat.rst:342
msgid ""
"Called when the XML declaration is parsed.  The XML declaration is the "
"(optional) declaration of the applicable version of the XML "
"recommendation, the encoding of the document text, and an optional "
"\"standalone\" declaration. *version* and *encoding* will be strings, and"
" *standalone* will be ``1`` if the document is declared standalone, ``0``"
" if it is declared not to be standalone, or ``-1`` if the standalone "
"clause was omitted. This is only available with Expat version 1.95.0 or "
"newer."
msgstr ""
"XML 선언이 구문 분석될 때 호출됩니다. XML 선언은 XML 권장 사항의 해당 버전에 대한 (선택적) 선언, 문서 텍스트의 "
"인코딩 및 선택적 \"독립형(standalone)\" 선언입니다. *version*\\과 *encoding*\\은 문자열이며, "
"*standalone*\\은 문서가 독립형으로 선언되면 ``1``\\이 되고, 독립형이 아닌 것으로 선언되면 ``0``\\이 "
"됩니다, 또는 독립형 절이 생략되면 ``-1``\\입니다. Expat 버전 1.95.0 이상에서만 사용할 수 있습니다."

#: ../../library/pyexpat.rst:353
msgid ""
"Called when Expat begins parsing the document type declaration "
"(``<!DOCTYPE ...``).  The *doctypeName* is provided exactly as presented."
"  The *systemId* and *publicId* parameters give the system and public "
"identifiers if specified, or ``None`` if omitted.  *has_internal_subset* "
"will be true if the document contains and internal document declaration "
"subset. This requires Expat version 1.2 or newer."
msgstr ""
"Expat이 문서 형 선언(``<!DOCTYPE ...``) 구문 분석을 시작할 때 호출됩니다. *doctypeName*\\은 "
"제시된 대로 정확하게 제공됩니다. *systemId*\\와 *publicId* 매개 변수는 지정되면 시스템(system)과 "
"공용(public) 식별자를, 생략되면 ``None``\\을 제공합니다. 문서에 내부 문서 선언 부분집합이 포함되어 있으면 "
"*has_internal_subset*\\은 참입니다. Expat 버전 1.2 이상이 필요합니다."

#: ../../library/pyexpat.rst:363
msgid ""
"Called when Expat is done parsing the document type declaration. This "
"requires Expat version 1.2 or newer."
msgstr "Expat이 문서 형 선언 구문 분석을 완료할 때 호출됩니다. Expat 버전 1.2 이상이 필요합니다."

#: ../../library/pyexpat.rst:369
msgid ""
"Called once for each element type declaration.  *name* is the name of the"
" element type, and *model* is a representation of the content model."
msgstr ""
"각 엘리먼트 형 선언마다 한 번씩 호출됩니다. *name*\\은 엘리먼트 형의 이름이고, *model*\\은 콘텐츠 모델의 "
"표현입니다."

#: ../../library/pyexpat.rst:375
msgid ""
"Called for each declared attribute for an element type.  If an attribute "
"list declaration declares three attributes, this handler is called three "
"times, once for each attribute.  *elname* is the name of the element to "
"which the declaration applies and *attname* is the name of the attribute "
"declared.  The attribute type is a string passed as *type*; the possible "
"values are ``'CDATA'``, ``'ID'``, ``'IDREF'``, ... *default* gives the "
"default value for the attribute used when the attribute is not specified "
"by the document instance, or ``None`` if there is no default value "
"(``#IMPLIED`` values).  If the attribute is required to be given in the "
"document instance, *required* will be true. This requires Expat version "
"1.95.0 or newer."
msgstr ""
"엘리먼트 형에 대해 선언된 어트리뷰트마다 호출됩니다. 어트리뷰트 리스트 선언이 세 개의 어트리뷰트를 선언하면 이 처리기는 "
"어트리뷰트마다 한 번씩 세 번 호출됩니다. *elname*\\은 선언이 적용되는 엘리먼트의 이름이고 *attname*\\은 선언된 "
"어트리뷰트의 이름입니다. 어트리뷰트 형은 *type*\\으로 전달된 문자열입니다; 가능한 값은 ``'CDATA'``, "
"``'ID'``, ``'IDREF'``, ... 입니다. *default*\\는 어트리뷰트가 문서 인스턴스에 의해 지정되지 않을 때"
" 사용되는 어트리뷰트의 기본값을 제공하거나, 기본값이 없으면 ``None``\\입니다 (``#IMPLIED`` 값). 문서 "
"인스턴스에서 어트리뷰트가 필수면, *required*\\는 참입니다. Expat 버전 1.95.0 이상이 필요합니다."

#: ../../library/pyexpat.rst:389
msgid ""
"Called for the start of every element.  *name* is a string containing the"
" element name, and *attributes* is the element attributes. If "
":attr:`ordered_attributes` is true, this is a list (see "
":attr:`ordered_attributes` for a full description). Otherwise it's a "
"dictionary mapping names to values."
msgstr ""
"모든 엘리먼트의 시작에서 호출됩니다. *name*\\은 엘리먼트 이름을 포함하는 문자열이고, *attributes*\\는 엘리먼트 "
"어트리뷰트입니다. :attr:`ordered_attributes`\\가 참이면, 이것은 리스트입니다 (자세한 설명은 "
":attr:`ordered_attributes`\\를 참조하십시오). 그렇지 않으면 이름을 값으로 매핑하는 딕셔너리입니다."

#: ../../library/pyexpat.rst:398
msgid "Called for the end of every element."
msgstr "모든 엘리먼트의 끝에서 호출됩니다."

#: ../../library/pyexpat.rst:403
msgid "Called for every processing instruction."
msgstr "모든 처리 명령어(processing instruction)에서 호출됩니다."

#: ../../library/pyexpat.rst:408
msgid ""
"Called for character data.  This will be called for normal character "
"data, CDATA marked content, and ignorable whitespace.  Applications which"
" must distinguish these cases can use the "
":attr:`StartCdataSectionHandler`, :attr:`EndCdataSectionHandler`, and "
":attr:`ElementDeclHandler` callbacks to collect the required information."
" Note that the character data may be chunked even if it is short and so "
"you may receive more than one call to :meth:`CharacterDataHandler`. Set "
"the :attr:`buffer_text` instance attribute to ``True`` to avoid that."
msgstr ""
"문자 데이터에 대해 호출됩니다. 일반 문자 데이터, CDATA 표시 내용 및 무시할 수 있는 공백에 대해 호출됩니다. 이들을 "
"구별해야 하는 응용 프로그램은 :attr:`StartCdataSectionHandler`, "
":attr:`EndCdataSectionHandler` 및 :attr:`ElementDeclHandler` 콜백을 사용하여 필요한 "
"정보를 수집할 수 있습니다. 문자 데이터는 짧더라도 덩어리로 묶일 수 있어서 "
":meth:`CharacterDataHandler`\\에 대한 호출을 여러 번 받을 수 있음에 유의하십시오. 이를 피하려면 "
":attr:`buffer_text` 인스턴스 어프리뷰트를 ``True``\\로 설정하십시오."

#: ../../library/pyexpat.rst:420
msgid ""
"Called for unparsed (NDATA) entity declarations.  This is only present "
"for version 1.2 of the Expat library; for more recent versions, use "
":attr:`EntityDeclHandler` instead.  (The underlying function in the Expat"
" library has been declared obsolete.)"
msgstr ""
"구문 분석되지 않은 (NDATA) 엔티티 선언에 대해 호출됩니다. 이것은 Expat 라이브러리 1.2 버전에만 존재합니다; 최신 "
"버전의 경우 :attr:`EntityDeclHandler`\\를 대신 사용하십시오. (Expat 라이브러리의 하부 함수는 더는 "
"사용되지 않는 것으로 선언되었습니다.)"

#: ../../library/pyexpat.rst:428
msgid ""
"Called for all entity declarations.  For parameter and internal entities,"
" *value* will be a string giving the declared contents of the entity; "
"this will be ``None`` for external entities.  The *notationName* "
"parameter will be ``None`` for parsed entities, and the name of the "
"notation for unparsed entities. *is_parameter_entity* will be true if the"
" entity is a parameter entity or false for general entities (most "
"applications only need to be concerned with general entities). This is "
"only available starting with version 1.95.0 of the Expat library."
msgstr ""
"모든 엔티티 선언에 대해 호출됩니다. 파라미터와 내부 엔티티의 경우, *value*\\는 엔티티의 선언된 내용을 제공하는 "
"문자열입니다; 외부 엔티티의 경우 ``None``\\이 됩니다. *notationName* 매개 변수는 구문 분석된 엔티티의 경우 "
"``None``\\이고, 구문 분석되지 않은 엔티티의 경우는 표기법 이름입니다. 엔티티가 파라미터 엔티티인 경우 "
"*is_parameter_entity*\\는 참이고, 일반 엔티티의 경우 거짓입니다 (대부분 응용 프로그램은 일반 엔티티만 고려하면"
" 됩니다). Expat 라이브러리 버전 1.95.0부터 사용 가능합니다."

#: ../../library/pyexpat.rst:440
msgid ""
"Called for notation declarations.  *notationName*, *base*, and "
"*systemId*, and *publicId* are strings if given.  If the public "
"identifier is omitted, *publicId* will be ``None``."
msgstr ""
"표기법 선언에 대해 호출됩니다. *notationName*, *base*, *systemId* 및 *publicId*\\는 주어지면"
" 문자열입니다. 공용 식별자를 생략하면, *publicId*\\는 ``None``\\이 됩니다."

#: ../../library/pyexpat.rst:447
msgid ""
"Called when an element contains a namespace declaration.  Namespace "
"declarations are processed before the :attr:`StartElementHandler` is "
"called for the element on which declarations are placed."
msgstr ""
"엘리먼트에 이름 공간 선언이 포함되어 있으면 호출됩니다. 이름 공간 선언은 선언이 배치된 엘리먼트에 대한 "
":attr:`StartElementHandler` 가 호출되기 전에 처리됩니다."

#: ../../library/pyexpat.rst:454
msgid ""
"Called when the closing tag is reached for an element  that contained a "
"namespace declaration.  This is called once for each namespace "
"declaration on the element in the reverse of the order for which the "
":attr:`StartNamespaceDeclHandler` was called to indicate the start of "
"each namespace declaration's scope.  Calls to this handler are made after"
" the corresponding :attr:`EndElementHandler` for the end of the element."
msgstr ""
"이름 공간 선언이 포함된 엘리먼트에 대해 닫기 태그에 도달하면 호출됩니다. 이는 각 이름 공간 선언 스코프의 시작을 나타내기 위해 "
":attr:`StartNamespaceDeclHandler` 가 호출된 순서와 반대로 엘리먼트의 각 이름 공간 선언에 대해 한 번씩"
" 호출됩니다. 이 처리기에 대한 호출은 엘리먼트의 끝을 위한 해당 :attr:`EndElementHandler` 이후에 수행됩니다."

#: ../../library/pyexpat.rst:464
msgid ""
"Called for comments.  *data* is the text of the comment, excluding the "
"leading ``'<!-``\\ ``-'`` and trailing ``'-``\\ ``->'``."
msgstr ""
"주석에 대해 호출됩니다. *data*\\는 주석의 텍스트이며, 선행 ``'<!-``\\ ``-'``\\와 후행 ``'-``\\ "
"``->'``\\를 제외합니다."

#: ../../library/pyexpat.rst:470
msgid ""
"Called at the start of a CDATA section.  This and "
":attr:`EndCdataSectionHandler` are needed to be able to identify the "
"syntactical start and end for CDATA sections."
msgstr ""
"CDATA 섹션의 시작에서 호출됩니다. CDATA 섹션의 구문적 시작과 종료를 식별할 수 있으려면 이것과 "
":attr:`EndCdataSectionHandler` 가 필요합니다."

#: ../../library/pyexpat.rst:477
msgid "Called at the end of a CDATA section."
msgstr "CDATA 섹션의 끝에서 호출됩니다."

#: ../../library/pyexpat.rst:482
msgid ""
"Called for any characters in the XML document for which no applicable "
"handler has been specified.  This means characters that are part of a "
"construct which could be reported, but for which no handler has been "
"supplied."
msgstr ""
"적용 가능한 처리기가 지정되지 않은 XML 문서의 모든 문자에 대해 호출됩니다. 이것은 보고될 수 있지만, 처리기가 제공되지 않은 "
"구성의 일부인 문자를 의미합니다."

#: ../../library/pyexpat.rst:489
msgid ""
"This is the same as the :func:`DefaultHandler`,  but doesn't inhibit "
"expansion of internal entities. The entity reference will not be passed "
"to the default handler."
msgstr ""
"이것은 :func:`DefaultHandler`\\와 같지만, 내부 엔티티의 확장을 막지 않습니다. 엔티티 참조는 기본 처리기로 "
"전달되지 않습니다."

#: ../../library/pyexpat.rst:496
msgid ""
"Called if the XML document hasn't been declared as being a standalone "
"document. This happens when there is an external subset or a reference to"
" a parameter entity, but the XML declaration does not set standalone to "
"``yes`` in an XML declaration.  If this handler returns ``0``, then the "
"parser will raise an :const:`XML_ERROR_NOT_STANDALONE` error.  If this "
"handler is not set, no exception is raised by the parser for this "
"condition."
msgstr ""
"XML 문서가 독립형 문서로 선언되지 않은 경우 호출됩니다. 외부 부분 집합이나 파라미터 엔티티에 대한 참조가 있지만, XML "
"선언에서 XML 선언이 standalone을 ``yes``\\로 설정하지 않은 경우에 발생합니다. 이 처리기가 ``0``\\을 "
"반환하면, 구문 분석기는 :const:`XML_ERROR_NOT_STANDALONE` 에러를 발생시킵니다. 이 처리기가 설정되지 "
"않으면, 이 조건에 대해 구문 분석기가 예외를 발생시키지 않습니다."

#: ../../library/pyexpat.rst:506
msgid ""
"Called for references to external entities.  *base* is the current base, "
"as set by a previous call to :meth:`SetBase`.  The public and system "
"identifiers, *systemId* and *publicId*, are strings if given; if the "
"public identifier is not given, *publicId* will be ``None``.  The "
"*context* value is opaque and should only be used as described below."
msgstr ""
"외부 엔티티에 대한 참조에 대해 호출됩니다. *base*\\는 :meth:`SetBase`\\에 대한 이전 호출에서 설정한 현재 "
"베이스입니다. 공용과 시스템 식별자, *systemId* 및 *publicId*\\는 지정되면 문자열입니다; 공용 식별자가 제공되지"
" 않으면 *publicId*\\는 ``None``\\이 됩니다. *context* 값은 불투명하며 아래 설명된 대로만 사용해야 "
"합니다."

#: ../../library/pyexpat.rst:512
msgid ""
"For external entities to be parsed, this handler must be implemented. It "
"is responsible for creating the sub-parser using "
"``ExternalEntityParserCreate(context)``, initializing it with the "
"appropriate callbacks, and parsing the entity.  This handler should "
"return an integer; if it returns ``0``, the parser will raise an "
":const:`XML_ERROR_EXTERNAL_ENTITY_HANDLING` error, otherwise parsing will"
" continue."
msgstr ""
"외부 엔티티를 구문 분석하려면, 이 처리기를 구현해야 합니다. "
"``ExternalEntityParserCreate(context)``\\를 사용하여 서브 구문 분석기를 만들고, 적절한 콜백으로 "
"초기화하고, 엔티티를 구문 분석해야 합니다. 이 처리기는 정수를 반환해야 합니다; ``0``\\을 반환하면, 구문 분석기는 "
":const:`XML_ERROR_EXTERNAL_ENTITY_HANDLING` 에러를 발생시키고, 그렇지 않으면 구문 분석이 "
"계속됩니다."

#: ../../library/pyexpat.rst:520
msgid ""
"If this handler is not provided, external entities are reported by the "
":attr:`DefaultHandler` callback, if provided."
msgstr "이 처리기가 제공되지 않으면, 외부 엔티티는 제공된다면 :attr:`DefaultHandler` 콜백에 의해 보고됩니다."

#: ../../library/pyexpat.rst:527
msgid "ExpatError Exceptions"
msgstr "ExpatError 예외"

#: ../../library/pyexpat.rst:532
msgid ":exc:`ExpatError` exceptions have a number of interesting attributes:"
msgstr ":exc:`ExpatError` 예외에는 여러 가지 흥미로운 어트리뷰트가 있습니다:"

#: ../../library/pyexpat.rst:537
msgid ""
"Expat's internal error number for the specific error.  The "
":data:`errors.messages <xml.parsers.expat.errors.messages>` dictionary "
"maps these error numbers to Expat's error messages.  For example::"
msgstr ""
"특정 에러에 대한 Expat의 내부 에러 번호. :data:`errors.messages "
"<xml.parsers.expat.errors.messages>` 딕셔너리는 이러한 에러 번호를 Expat의 에러 메시지에 "
"매핑합니다. 예를 들면::"

#: ../../library/pyexpat.rst:541
msgid ""
"from xml.parsers.expat import ParserCreate, ExpatError, errors\n"
"\n"
"p = ParserCreate()\n"
"try:\n"
"    p.Parse(some_xml_document)\n"
"except ExpatError as err:\n"
"    print(\"Error:\", errors.messages[err.code])"
msgstr ""
"from xml.parsers.expat import ParserCreate, ExpatError, errors\n"
"\n"
"p = ParserCreate()\n"
"try:\n"
"    p.Parse(some_xml_document)\n"
"except ExpatError as err:\n"
"    print(\"Error:\", errors.messages[err.code])"

#: ../../library/pyexpat.rst:549
msgid ""
"The :mod:`~xml.parsers.expat.errors` module also provides error message "
"constants and a dictionary :data:`~xml.parsers.expat.errors.codes` "
"mapping these messages back to the error codes, see below."
msgstr ""
":mod:`~xml.parsers.expat.errors` 모듈은 에러 메시지 상수와 이러한 메시지를 에러 코드로 역 매핑하는 "
"딕셔너리 :data:`~xml.parsers.expat.errors.codes`\\도 제공합니다, 아래를 참조하십시오."

#: ../../library/pyexpat.rst:556
msgid ""
"Line number on which the error was detected.  The first line is numbered "
"``1``."
msgstr "에러가 감지된 줄 번호. 첫 번째 줄은 ``1``\\로 번호가 매겨집니다."

#: ../../library/pyexpat.rst:561
msgid ""
"Character offset into the line where the error occurred.  The first "
"column is numbered ``0``."
msgstr "에러가 발생한 줄에서의 문자 오프셋. 첫 번째 열의 번호는 ``0``\\입니다."

#: ../../library/pyexpat.rst:568
msgid "Example"
msgstr "예"

#: ../../library/pyexpat.rst:570
msgid ""
"The following program defines three handlers that just print out their "
"arguments. ::"
msgstr "다음 프로그램은 인자를 출력하기만 하는 세 개의 처리기를 정의합니다. ::"

#: ../../library/pyexpat.rst:573
msgid ""
"import xml.parsers.expat\n"
"\n"
"# 3 handler functions\n"
"def start_element(name, attrs):\n"
"    print('Start element:', name, attrs)\n"
"def end_element(name):\n"
"    print('End element:', name)\n"
"def char_data(data):\n"
"    print('Character data:', repr(data))\n"
"\n"
"p = xml.parsers.expat.ParserCreate()\n"
"\n"
"p.StartElementHandler = start_element\n"
"p.EndElementHandler = end_element\n"
"p.CharacterDataHandler = char_data\n"
"\n"
"p.Parse(\"\"\"<?xml version=\"1.0\"?>\n"
"<parent id=\"top\"><child1 name=\"paul\">Text goes here</child1>\n"
"<child2 name=\"fred\">More text</child2>\n"
"</parent>\"\"\", 1)"
msgstr ""
"import xml.parsers.expat\n"
"\n"
"# 3개의 처리기 함수\n"
"def start_element(name, attrs):\n"
"    print('Start element:', name, attrs)\n"
"def end_element(name):\n"
"    print('End element:', name)\n"
"def char_data(data):\n"
"    print('Character data:', repr(data))\n"
"\n"
"p = xml.parsers.expat.ParserCreate()\n"
"\n"
"p.StartElementHandler = start_element\n"
"p.EndElementHandler = end_element\n"
"p.CharacterDataHandler = char_data\n"
"\n"
"p.Parse(\"\"\"<?xml version=\"1.0\"?>\n"
"<parent id=\"top\"><child1 name=\"paul\">Text goes here</child1>\n"
"<child2 name=\"fred\">More text</child2>\n"
"</parent>\"\"\", 1)"

#: ../../library/pyexpat.rst:594
msgid "The output from this program is::"
msgstr "이 프로그램의 출력은 다음과 같습니다::"

#: ../../library/pyexpat.rst:596
#, python-brace-format
msgid ""
"Start element: parent {'id': 'top'}\n"
"Start element: child1 {'name': 'paul'}\n"
"Character data: 'Text goes here'\n"
"End element: child1\n"
"Character data: '\\n'\n"
"Start element: child2 {'name': 'fred'}\n"
"Character data: 'More text'\n"
"End element: child2\n"
"Character data: '\\n'\n"
"End element: parent"
msgstr ""
"Start element: parent {'id': 'top'}\n"
"Start element: child1 {'name': 'paul'}\n"
"Character data: 'Text goes here'\n"
"End element: child1\n"
"Character data: '\\n'\n"
"Start element: child2 {'name': 'fred'}\n"
"Character data: 'More text'\n"
"End element: child2\n"
"Character data: '\\n'\n"
"End element: parent"

#: ../../library/pyexpat.rst:611
msgid "Content Model Descriptions"
msgstr "콘텐츠 모델 기술"

#: ../../library/pyexpat.rst:617
msgid ""
"Content models are described using nested tuples.  Each tuple contains "
"four values: the type, the quantifier, the name, and a tuple of children."
"  Children are simply additional content model descriptions."
msgstr ""
"콘텐츠 모델은 중첩된 튜플을 사용하여 기술됩니다. 각 튜플에는 네 가지 값이 있습니다: 형, 수량 지정자(quantifier), "
"이름 및 자식 튜플. 자식은 단순히 추가의 콘텐츠 모델 기술입니다."

#: ../../library/pyexpat.rst:621
msgid ""
"The values of the first two fields are constants defined in the "
":mod:`xml.parsers.expat.model` module.  These constants can be collected "
"in two groups: the model type group and the quantifier group."
msgstr ""
"처음 두 필드의 값은 :mod:`xml.parsers.expat.model` 모듈에 정의된 상수입니다. 이 상수는 두 그룹으로 모을"
" 수 있습니다: 모델 형 그룹과 수량 지정자 그룹."

#: ../../library/pyexpat.rst:625
msgid "The constants in the model type group are:"
msgstr "모델 형 그룹의 상수는 다음과 같습니다:"

#: ../../library/pyexpat.rst:631
msgid ""
"The element named by the model name was declared to have a content model "
"of ``ANY``."
msgstr "모델 이름으로 명명된 엘리먼트가 콘텐츠 모델 ``ANY``\\를 갖도록 선언되었습니다."

#: ../../library/pyexpat.rst:638
msgid ""
"The named element allows a choice from a number of options; this is used "
"for content models such as ``(A | B | C)``."
msgstr ""
"명명된 엘리먼트가 여러 옵션 중에서 선택할 수 있도록 합니다; 이것은 ``(A | B | C)``\\와 같은 콘텐츠 모델에 "
"사용됩니다."

#: ../../library/pyexpat.rst:645
msgid "Elements which are declared to be ``EMPTY`` have this model type."
msgstr "``EMPTY``\\로 선언된 엘리먼트는 이 모델 형을 갖습니다."

#: ../../library/pyexpat.rst:659
msgid ""
"Models which represent a series of models which follow one after the "
"other are indicated with this model type.  This is used for models such "
"as ``(A, B, C)``."
msgstr "일련의 모델이 차례로 나타나는 모델은 이 모델 형으로 표시됩니다. ``(A, B, C)``\\와 같은 모델에 사용됩니다."

#: ../../library/pyexpat.rst:662
msgid "The constants in the quantifier group are:"
msgstr "수량 지정자 그룹의 상수는 다음과 같습니다:"

#: ../../library/pyexpat.rst:668
msgid "No modifier is given, so it can appear exactly once, as for ``A``."
msgstr "수정자가 제공되지 않아서, ``A``\\와 같이, 정확히 한 번만 나타날 수 있습니다."

#: ../../library/pyexpat.rst:674
msgid "The model is optional: it can appear once or not at all, as for ``A?``."
msgstr "모델은 선택적입니다: ``A?`` 와 같이, 한 번만 나타나거나 전혀 나타나지 않을 수 있습니다."

#: ../../library/pyexpat.rst:680
msgid "The model must occur one or more times (like ``A+``)."
msgstr "모델은 한 번 이상 발생해야 합니다 (``A+``\\처럼)."

#: ../../library/pyexpat.rst:686
msgid "The model must occur zero or more times, as for ``A*``."
msgstr "``A*``\\와 같이, 모델은 0번 이상 나타나야 합니다."

#: ../../library/pyexpat.rst:692
msgid "Expat error constants"
msgstr "Expat 에러 상수"

#: ../../library/pyexpat.rst:696
#, python-brace-format
msgid ""
"The following constants are provided in the "
":mod:`xml.parsers.expat.errors` module.  These constants are useful in "
"interpreting some of the attributes of the :exc:`ExpatError` exception "
"objects raised when an error has occurred. Since for backwards "
"compatibility reasons, the constants' value is the error *message* and "
"not the numeric error *code*, you do this by comparing its :attr:`code` "
"attribute with :samp:`errors.codes[errors.XML_ERROR_{CONSTANT_NAME}]`."
msgstr ""
":mod:`xml.parsers.expat.errors` 모듈에는 다음과 같은 상수가 제공됩니다. 이 상수는 에러가 발생했을 때 "
"발생하는 :exc:`ExpatError` 예외 객체의 일부 어트리뷰트를 해석하는 데 유용합니다. 이전 버전과의 호환성을 위해, "
"상숫값은 숫자 에러 *code*\\가 아니라 에러 *message*\\이므로, :attr:`code` 어트리뷰트를 "
":samp:`errors.codes[errors.XML_ERROR_{CONSTANT_NAME}]`\\와 비교합니다."

#: ../../library/pyexpat.rst:704
msgid "The ``errors`` module has the following attributes:"
msgstr "``errors`` 모듈에는 다음과 같은 어트리뷰트가 있습니다:"

#: ../../library/pyexpat.rst:708
msgid "A dictionary mapping string descriptions to their error codes."
msgstr "문자열 설명을 에러 코드에 매핑하는 딕셔너리."

#: ../../library/pyexpat.rst:715
msgid "A dictionary mapping numeric error codes to their string descriptions."
msgstr "숫자 에러 코드를 문자열 설명에 매핑하는 딕셔너리."

#: ../../library/pyexpat.rst:725
msgid ""
"An entity reference in an attribute value referred to an external entity "
"instead of an internal entity."
msgstr "어트리뷰트 값의 엔티티 참조가 내부 엔티티 대신 외부 엔티티를 참조합니다."

#: ../../library/pyexpat.rst:731
msgid ""
"A character reference referred to a character which is illegal in XML "
"(for example, character ``0``, or '``&#0;``')."
msgstr "문자 참조가 XML에서 잘못된 문자를 가리킵니다 (예를 들어, 문자 ``0`` 또는 '``&#0;``')."

#: ../../library/pyexpat.rst:737
msgid ""
"An entity reference referred to an entity which was declared with a "
"notation, so cannot be parsed."
msgstr "엔티티 참조가 표기법으로 선언된 엔티티를 참조해서, 구문 분석할 수 없습니다."

#: ../../library/pyexpat.rst:743
msgid "An attribute was used more than once in a start tag."
msgstr "시작 태그에서 어트리뷰트가 두 번 이상 사용되었습니다."

#: ../../library/pyexpat.rst:751
msgid ""
"Raised when an input byte could not properly be assigned to a character; "
"for example, a NUL byte (value ``0``) in a UTF-8 input stream."
msgstr "입력 바이트를 문자에 올바르게 대입할 수 없을 때 발생합니다; 예를 들어, UTF-8 입력 스트림의 NUL 바이트(값 ``0``)."

#: ../../library/pyexpat.rst:757
msgid "Something other than whitespace occurred after the document element."
msgstr "문서 엘리먼트 다음에 공백 이외의 것이 나타났습니다."

#: ../../library/pyexpat.rst:762
msgid ""
"An XML declaration was found somewhere other than the start of the input "
"data."
msgstr "입력 데이터의 시작 이외의 곳에서 XML 선언이 발견되었습니다."

#: ../../library/pyexpat.rst:767
msgid ""
"The document contains no elements (XML requires all documents to contain "
"exactly one top-level element).."
msgstr "문서에 엘리먼트가 없습니다 (XML은 모든 문서에 정확히 하나의 최상위 엘리먼트가 포함되어야 함을 요구합니다)."

#: ../../library/pyexpat.rst:773
msgid "Expat was not able to allocate memory internally."
msgstr "Expat이 내부적으로 메모리를 할당하지 못했습니다."

#: ../../library/pyexpat.rst:778
msgid "A parameter entity reference was found where it was not allowed."
msgstr "파라미터 엔티티 참조가 허용되지 않는 위치에서 발견되었습니다."

#: ../../library/pyexpat.rst:783
msgid "An incomplete character was found in the input."
msgstr "입력에서 불완전한 문자가 발견되었습니다."

#: ../../library/pyexpat.rst:788
msgid ""
"An entity reference contained another reference to the same entity; "
"possibly via a different name, and possibly indirectly."
msgstr "엔티티 참조가 같은 엔티티에 대한 다른 참조를 포함합니다; 어쩌면 다른 이름을 통해서, 그리고 어쩌면 간접적으로."

#: ../../library/pyexpat.rst:794
msgid "Some unspecified syntax error was encountered."
msgstr "지정되지 않은 구문 에러를 만났습니다."

#: ../../library/pyexpat.rst:799
msgid "An end tag did not match the innermost open start tag."
msgstr "종료 태그가 가장 안쪽에 있는 시작 태그와 일치하지 않습니다."

#: ../../library/pyexpat.rst:804
msgid ""
"Some token (such as a start tag) was not closed before the end of the "
"stream or the next token was encountered."
msgstr "어떤 토큰이 (가령 시작 태그) 스트림이 끝나기 전에 닫히지 않았거나 다음 토큰을 만났습니다."

#: ../../library/pyexpat.rst:810
msgid "A reference was made to an entity which was not defined."
msgstr "정의되지 않은 엔티티를 참조했습니다."

#: ../../library/pyexpat.rst:815
msgid "The document encoding is not supported by Expat."
msgstr "문서 인코딩을 Expat에서 지원하지 않습니다."

#: ../../library/pyexpat.rst:820
msgid "A CDATA marked section was not closed."
msgstr "CDATA 표시 섹션이 닫히지 않았습니다."

#: ../../library/pyexpat.rst:828
msgid ""
"The parser determined that the document was not \"standalone\" though it "
"declared itself to be in the XML declaration, and the "
":attr:`NotStandaloneHandler` was set and returned ``0``."
msgstr ""
"문서가 XML 선언에서 자신을 \"독립형\"으로 선언했지만 구문 분석기가 독립형이 아니라고 결정했으며 "
":attr:`NotStandaloneHandler` 가 설정되고 ``0``\\을 반환했습니다."

#: ../../library/pyexpat.rst:841
msgid ""
"An operation was requested that requires DTD support to be compiled in, "
"but Expat was configured without DTD support.  This should never be "
"reported by a standard build of the :mod:`xml.parsers.expat` module."
msgstr ""
"DTD 지원이 컴파일되어 있어야 하는 작업이 요청되었지만, Expat이 DTD 지원 없이 구성되었습니다. "
":mod:`xml.parsers.expat` 모듈의 표준 빌드에서 이것이 보고되어서는 안 됩니다."

#: ../../library/pyexpat.rst:848
msgid ""
"A behavioral change was requested after parsing started that can only be "
"changed before parsing has started.  This is (currently) only raised by "
":meth:`UseForeignDTD`."
msgstr ""
"구문 분석이 시작된 후에 구문 분석이 시작되기 전에만 변경할 수 있는 동작 변경이 요청되었습니다. 이것은 (현재) "
":meth:`UseForeignDTD`\\에 의해서만 발생합니다."

#: ../../library/pyexpat.rst:855
msgid "An undeclared prefix was found when namespace processing was enabled."
msgstr "이름 공간 처리가 활성화되었을 때 선언되지 않은 접두사가 발견되었습니다."

#: ../../library/pyexpat.rst:860
msgid ""
"The document attempted to remove the namespace declaration associated "
"with a prefix."
msgstr "문서가 접두사와 연관된 이름 공간 선언을 제거하려고 했습니다."

#: ../../library/pyexpat.rst:866
msgid "A parameter entity contained incomplete markup."
msgstr "파라미터 엔티티에 불완전한 마크업이 포함되어 있습니다."

#: ../../library/pyexpat.rst:871
msgid "The document contained no document element at all."
msgstr "문서에 문서 엘리먼트가 전혀 없습니다."

#: ../../library/pyexpat.rst:876
msgid "There was an error parsing a text declaration in an external entity."
msgstr "외부 엔티티에 있는 텍스트 선언을 구문 분석하는 중 에러가 발생했습니다."

#: ../../library/pyexpat.rst:881
msgid "Characters were found in the public id that are not allowed."
msgstr "허용되지 않는 문자가 공용 id에서 발견되었습니다."

#: ../../library/pyexpat.rst:886
msgid ""
"The requested operation was made on a suspended parser, but isn't "
"allowed.  This includes attempts to provide additional input or to stop "
"the parser."
msgstr ""
"일시 중지된 구문 분석기에 작업이 요청되었지만, 허용되지 않습니다. 여기에는 추가 입력을 제공하거나 구문 분석기를 중지하려는 시도가"
" 포함됩니다."

#: ../../library/pyexpat.rst:892
msgid ""
"An attempt to resume the parser was made when the parser had not been "
"suspended."
msgstr "구문 분석기가 일시 중지되지 않았을 때 구문 분석기를 재개하려고 했습니다."

#: ../../library/pyexpat.rst:897 ../../library/pyexpat.rst:930
#: ../../library/pyexpat.rst:935
msgid "This should not be reported to Python applications."
msgstr "이것은 파이썬 응용 프로그램에 보고되어서는 안 됩니다."

#: ../../library/pyexpat.rst:902
msgid ""
"The requested operation was made on a parser which was finished parsing "
"input, but isn't allowed.  This includes attempts to provide additional "
"input or to stop the parser."
msgstr ""
"입력을 구문 분석하는 것을 종료한 구문 분석기에 작업을 요청했지만, 허용되지 않습니다. 여기에는 추가 입력을 제공하거나 구문 "
"분석기를 중지하려는 시도가 포함됩니다."

#: ../../library/pyexpat.rst:912
msgid ""
"An attempt was made to undeclare reserved namespace prefix ``xml`` or to "
"bind it to another namespace URI."
msgstr ""

#: ../../library/pyexpat.rst:919
msgid ""
"An attempt was made to declare or undeclare reserved namespace prefix "
"``xmlns``."
msgstr ""

#: ../../library/pyexpat.rst:924
msgid ""
"An attempt was made to bind the URI of one the reserved namespace "
"prefixes ``xml`` and ``xmlns`` to another namespace prefix."
msgstr ""

#: ../../library/pyexpat.rst:940
msgid ""
"The limit on input amplification factor (from DTD and entities) has been "
"breached."
msgstr ""

#: ../../library/pyexpat.rst:945
msgid "Footnotes"
msgstr "각주"

#: ../../library/pyexpat.rst:946
msgid ""
"The encoding string included in XML output should conform to the "
"appropriate standards. For example, \"UTF-8\" is valid, but \"UTF8\" is "
"not. See https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl "
"and https://www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"XML 출력에 포함된 인코딩 문자열은 적절한 표준을 준수해야 합니다. 예를 들어, \"UTF-8\"은 유효하지만, \"UTF8\"은"
" 유효하지 않습니다. https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-"
"EncodingDecl 과 https://www.iana.org/assignments/character-sets/character-"
"sets.xhtml 을 참조하십시오."

#: ../../library/pyexpat.rst:26
msgid "Expat"
msgstr "Expat"

#: ../../library/pyexpat.rst:36
msgid "module"
msgstr "모듈"

#: ../../library/pyexpat.rst:36
msgid "pyexpat"
msgstr "pyexpat"

