# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/binascii.rst:2
#, fuzzy
msgid ":mod:`!binascii` --- Convert between binary and ASCII"
msgstr ":mod:`binascii` --- 바이너리와 ASCII 간의 변환"

#: ../../library/binascii.rst:13
#, fuzzy
msgid ""
"The :mod:`binascii` module contains a number of methods to convert "
"between binary and various ASCII-encoded binary representations. "
"Normally, you will not use these functions directly but use wrapper "
"modules like :mod:`base64` instead. The :mod:`binascii` module contains "
"low-level functions written in C for greater speed that are used by the "
"higher-level modules."
msgstr ""
":mod:`binascii` 모듈에는 바이너리와 다양한 ASCII 인코딩 바이너리 표현 사이를 변환하는 여러 가지 방법이 포함되어 "
"있습니다. 일반적으로 이러한 함수는 직접 사용하지 않고, 대신 :mod:`uu`, :mod:`base64` 또는 "
":mod:`binhex`\\와 같은 래퍼 모듈을 사용합니다. :mod:`binascii` 모듈에는 고수준 모듈에서 사용하는 보다 "
"빠른 속도를 위해 C로 작성된 저수준 함수가 들어 있습니다."

#: ../../library/binascii.rst:22
msgid ""
"``a2b_*`` functions accept Unicode strings containing only ASCII "
"characters. Other functions only accept :term:`bytes-like objects <bytes-"
"like object>` (such as :class:`bytes`, :class:`bytearray` and other "
"objects that support the buffer protocol)."
msgstr ""
"``a2b_*`` 함수는 ASCII 문자만 포함하는 유니코드 문자열을 받아들입니다. 다른 함수는 :term:`바이트열류 객체 "
"<bytes-like object>`\\(가령 :class:`bytes`, :class:`bytearray` 및 버퍼 프로토콜을 "
"지원하는 다른 객체)만 받아들입니다."

#: ../../library/binascii.rst:27
msgid "ASCII-only unicode strings are now accepted by the ``a2b_*`` functions."
msgstr "ASCII로만 이루어진 유니코드 문자열은 이제 ``a2b_*`` 함수에서 허용됩니다."

#: ../../library/binascii.rst:31
msgid "The :mod:`binascii` module defines the following functions:"
msgstr ":mod:`binascii` 모듈은 다음 함수를 정의합니다:"

#: ../../library/binascii.rst:36
msgid ""
"Convert a single line of uuencoded data back to binary and return the "
"binary data. Lines normally contain 45 (binary) bytes, except for the "
"last line. Line data may be followed by whitespace."
msgstr ""
"한 줄의 UU 인코딩된 데이터 string을 바이너리로 역변환하고 바이너리 데이터를 반환합니다. 마지막 줄을 제외하고는, 줄은 보통"
" 45 (바이너리) 바이트를 포함합니다. 줄 데이터 뒤에는 공백 문자가 올 수 있습니다."

#: ../../library/binascii.rst:43
msgid ""
"Convert binary data to a line of ASCII characters, the return value is "
"the converted line, including a newline char. The length of *data* should"
" be at most 45. If *backtick* is true, zeros are represented by ``'`'`` "
"instead of spaces."
msgstr ""
"바이너리 data를 ASCII 문자의 줄로 변환합니다, 반환 값은 개행 문자를 포함하는 변환 된 줄입니다. *data*\\의 길이는"
" 최대 45이어야 합니다. *backtick*\\가 참이면, 0은 스페이스 대신 ``'`'``\\으로 표현됩니다."

#: ../../library/binascii.rst:47
msgid "Added the *backtick* parameter."
msgstr "*backtick* 매개 변수가 추가되었습니다."

#: ../../library/binascii.rst:53
msgid ""
"Convert a block of base64 data back to binary and return the binary data."
" More than one line may be passed at a time."
msgstr "base64 데이터 블록을 바이너리로 역변환하고 바이너리 데이터를 반환합니다. 한 번에 한 줄 이상을 전달할 수 있습니다."

#: ../../library/binascii.rst:56
msgid ""
"If *strict_mode* is true, only valid base64 data will be converted. "
"Invalid base64 data will raise :exc:`binascii.Error`."
msgstr ""

#: ../../library/binascii.rst:59
msgid "Valid base64:"
msgstr ""

#: ../../library/binascii.rst:61
msgid "Conforms to :rfc:`3548`."
msgstr ""

#: ../../library/binascii.rst:62
msgid "Contains only characters from the base64 alphabet."
msgstr ""

#: ../../library/binascii.rst:63
msgid ""
"Contains no excess data after padding (including excess padding, "
"newlines, etc.)."
msgstr ""

#: ../../library/binascii.rst:64
msgid "Does not start with a padding."
msgstr ""

#: ../../library/binascii.rst:66
#, fuzzy
msgid "Added the *strict_mode* parameter."
msgstr "*backtick* 매개 변수가 추가되었습니다."

#: ../../library/binascii.rst:72
msgid ""
"Convert binary data to a line of ASCII characters in base64 coding. The "
"return value is the converted line, including a newline char if *newline*"
" is true.  The output of this function conforms to :rfc:`3548`."
msgstr ""
"바이너리 data를 base64 코딩으로 ASCII 문자의 줄로 변환합니다. 반환 값은 변환된 줄인데, *newline*\\이 "
"참이면, 개행 문자를 포함합니다. 이 함수의 출력은 :rfc:`3548`\\을 따릅니다."

#: ../../library/binascii.rst:76
msgid "Added the *newline* parameter."
msgstr "*newline* 매개 변수가 추가되었습니다."

#: ../../library/binascii.rst:82
msgid ""
"Convert a block of quoted-printable data back to binary and return the "
"binary data. More than one line may be passed at a time. If the optional "
"argument *header* is present and true, underscores will be decoded as "
"spaces."
msgstr ""
"quoted-printable data 블록을 바이너리로 역변환하고 바이너리 데이터를 반환합니다. 한 번에 한 줄 이상을 전달할 수"
" 있습니다. 선택적 인자 *header*\\가 있고 참이면, 밑줄(underscore)은 스페이스로 디코딩됩니다."

#: ../../library/binascii.rst:89
msgid ""
"Convert binary data to a line(s) of ASCII characters in quoted-printable "
"encoding.  The return value is the converted line(s). If the optional "
"argument *quotetabs* is present and true, all tabs and spaces will be "
"encoded.   If the optional argument *istext* is present and true, "
"newlines are not encoded but trailing whitespace will be encoded. If the "
"optional argument *header* is present and true, spaces will be encoded as"
" underscores per :rfc:`1522`. If the optional argument *header* is "
"present and false, newline characters will be encoded as well; otherwise "
"linefeed conversion might corrupt the binary data stream."
msgstr ""
"바이너리 data를 quoted-printable 인코딩으로 ASCII 문자의 줄로 변환합니다. 반환 값은 변환된 줄입니다. 선택적"
" 인자 *quotetabs*\\가 있고 참이면, 모든 탭과 스페이스가 인코딩됩니다. 선택적 인자 *istext*\\가 있고 참이면,"
" 개행 문자는 인코딩되지 않지만, 후행 공백은 인코딩됩니다. 선택적 인자 *header*\\가 있고 참이면, 스페이스는 "
":rfc:`1522`\\에 따라 밑줄로 인코딩됩니다. 선택적 인자 *header*\\가 있고 거짓이면, 개행 문자도 함께 "
"인코딩됩니다; 그렇지 않으면 라인 피드(linefeed) 변환이 바이너리 데이터 스트림을 손상할 수 있습니다."

#: ../../library/binascii.rst:102
msgid ""
"Compute a 16-bit CRC value of *data*, starting with *value* as the "
"initial CRC, and return the result.  This uses the CRC-CCITT polynomial "
"*x*:sup:`16` + *x*:sup:`12` + *x*:sup:`5` + 1, often represented as "
"0x1021.  This CRC is used in the binhex4 format."
msgstr ""
"초기 CRC *value*\\로 시작하는, *data*\\의 16비트 CRC 값을 계산하고 결과를 반환합니다. 종종 0x1021로 "
"표시되는, CRC-CCITT 다항식 *x*:sup:`16` + *x*:sup:`12` + *x*:sup:`5` + 1을 사용합니다."
" 이 CRC는 binhex4 형식에서 사용됩니다."

#: ../../library/binascii.rst:110
#, fuzzy
msgid ""
"Compute CRC-32, the unsigned 32-bit checksum of *data*, starting with an "
"initial CRC of *value*.  The default initial CRC is zero.  The algorithm "
"is consistent with the ZIP file checksum.  Since the algorithm is "
"designed for use as a checksum algorithm, it is not suitable for use as a"
" general hash algorithm.  Use as follows::"
msgstr ""
"초기 CRC *value*\\로 시작하는, *data*\\의 32비트 체크섬인 CRC-32를 계산합니다. 기본 초기 CRC는 "
"0입니다. 이 알고리즘은 ZIP 파일 체크섬과 일치합니다. 이 알고리즘은 체크섬 알고리즘으로 사용하도록 설계되었으므로, 일반 해시 "
"알고리즘으로 사용하기에 적합하지 않습니다. 다음과 같이 사용하십시오::"

#: ../../library/binascii.rst:116
#, python-brace-format
msgid ""
"print(binascii.crc32(b\"hello world\"))\n"
"# Or, in two pieces:\n"
"crc = binascii.crc32(b\"hello\")\n"
"crc = binascii.crc32(b\" world\", crc)\n"
"print('crc32 = {:#010x}'.format(crc))"
msgstr ""

#: ../../library/binascii.rst:122
msgid "The result is always unsigned."
msgstr ""

#: ../../library/binascii.rst:128
msgid ""
"Return the hexadecimal representation of the binary *data*.  Every byte "
"of *data* is converted into the corresponding 2-digit hex representation."
"  The returned bytes object is therefore twice as long as the length of "
"*data*."
msgstr ""
"바이너리 *data*\\의 16진수 표현을 반환합니다. *data*\\의 모든 바이트는 해당 2자리 16진수 표현으로 변환됩니다. "
"따라서 반환된 바이트열 객체의 길이는 *data* 의 두 배입니다."

#: ../../library/binascii.rst:132
msgid ""
"Similar functionality (but returning a text string) is also conveniently "
"accessible using the :meth:`bytes.hex` method."
msgstr "비슷한 기능(하지만 텍스트 문자열을 반환하는)을 :meth:`bytes.hex` 메서드를 사용하여 편리하게 액세스할 수도 있습니다."

#: ../../library/binascii.rst:135
msgid ""
"If *sep* is specified, it must be a single character str or bytes object."
" It will be inserted in the output after every *bytes_per_sep* input "
"bytes. Separator placement is counted from the right end of the output by"
" default, if you wish to count from the left, supply a negative "
"*bytes_per_sep* value."
msgstr ""
"*sep*\\이 지정되면, 단일 문자 문자열이나 바이트열 객체여야 합니다. *bytes_per_sep* 입력 바이트마다 출력에 "
"삽입됩니다. 구분자 배치는 기본적으로 출력의 오른쪽 끝에서부터 계산됩니다. 왼쪽부터 계산하려면, 음수의 *bytes_per_sep*"
" 값을 제공하십시오."

#: ../../library/binascii.rst:150
msgid "The *sep* and *bytes_per_sep* parameters were added."
msgstr "*sep*\\과 *bytes_per_sep* 매개 변수가 추가되었습니다."

#: ../../library/binascii.rst:156
msgid ""
"Return the binary data represented by the hexadecimal string *hexstr*.  "
"This function is the inverse of :func:`b2a_hex`. *hexstr* must contain an"
" even number of hexadecimal digits (which can be upper or lower case), "
"otherwise an :exc:`Error` exception is raised."
msgstr ""
"16진수 문자열 *hexstr*\\로 표현된 바이너리 데이터를 반환합니다. 이 함수는 :func:`b2a_hex`\\의 "
"역함수입니다. *hexstr*\\는 짝수개의 16진수(대소문자 모두 가능합니다)를 포함해야 하며, 그렇지 않으면 "
":exc:`Error` 예외가 발생합니다."

#: ../../library/binascii.rst:161
msgid ""
"Similar functionality (accepting only text string arguments, but more "
"liberal towards whitespace) is also accessible using the "
":meth:`bytes.fromhex` class method."
msgstr ""
"비슷한 기능(텍스트 문자열 인자만 받아들이지만, 공백에 대해 더 느슨한)을 :meth:`bytes.fromhex` 클래스 메서드를 "
"사용하여 액세스할 수도 있습니다."

#: ../../library/binascii.rst:167
msgid "Exception raised on errors. These are usually programming errors."
msgstr "에러 시 발생하는 예외. 이들은 대개 프로그래밍 에러입니다."

#: ../../library/binascii.rst:172
msgid ""
"Exception raised on incomplete data. These are usually not programming "
"errors, but may be handled by reading a little more data and trying "
"again."
msgstr ""
"불완전한 데이터에서 발생하는 예외. 이들은 일반적으로 프로그래밍 에러가 아니지만, 조금 더 많은 데이터를 읽고 다시 시도하면 처리될"
" 수 있습니다."

#: ../../library/binascii.rst:178
msgid "Module :mod:`base64`"
msgstr "모듈 :mod:`base64`"

#: ../../library/binascii.rst:179
msgid ""
"Support for RFC compliant base64-style encoding in base 16, 32, 64, and "
"85."
msgstr "RFC 호환 base64 스타일 인코딩으로, 베이스 16, 32, 64 및 85를 지원합니다."

#: ../../library/binascii.rst:182
msgid "Module :mod:`quopri`"
msgstr "모듈 :mod:`quopri`"

#: ../../library/binascii.rst:183
msgid "Support for quoted-printable encoding used in MIME email messages."
msgstr "MIME 전자 우편 메시지에 사용되는 quoted-printable 인코딩 지원."

#: ../../library/binascii.rst:8
msgid "module"
msgstr ""

#: ../../library/binascii.rst:8
msgid "base64"
msgstr ""

#~ msgid ""
#~ "Convert binhex4 formatted ASCII data to"
#~ " binary, without doing RLE-decompression."
#~ " The string should contain a complete"
#~ " number of binary bytes, or (in "
#~ "case of the last portion of the"
#~ " binhex4 data) have the remaining "
#~ "bits zero."
#~ msgstr ""
#~ "RLE 압축 해제 없이 binhex4 형식의 ASCII "
#~ "data를 바이너리로 변환합니다. 이 문자열에는 완전한 "
#~ "바이너리 바이트가 포함되거나, (binhex4 데이터의 마지막 "
#~ "부분에서) 나머지 비트가 0이어야 합니다."

#~ msgid ""
#~ "Perform RLE-decompression on the data,"
#~ " as per the binhex4 standard. The "
#~ "algorithm uses ``0x90`` after a byte "
#~ "as a repeat indicator, followed by "
#~ "a count. A count of ``0`` "
#~ "specifies a byte value of ``0x90``. "
#~ "The routine returns the decompressed "
#~ "data, unless data input data ends "
#~ "in an orphaned repeat indicator, in "
#~ "which case the :exc:`Incomplete` exception "
#~ "is raised."
#~ msgstr ""
#~ "binhex4 표준에 따라, data에 대해 RLE 압축"
#~ " 해제를 수행합니다. 이 알고리즘은 바이트 다음에 오는"
#~ " ``0x90``\\을 반복 표시기로 사용하고, 그 뒤에 "
#~ "카운트가 옵니다. 카운트 ``0``\\은 바이트 값 "
#~ "``0x90``\\을 지정합니다. 이 루틴은 data 입력 "
#~ "데이터가 불완전한 반복 표시기로 끝나지 않는 한(이때는 "
#~ ":exc:`Incomplete` 예외가 발생합니다) 압축 해제된 데이터를"
#~ " 반환합니다."

#~ msgid "Accept only bytestring or bytearray objects as input."
#~ msgstr "바이트열이나 bytearray 객체만 입력으로 허용합니다."

#~ msgid "Perform binhex4 style RLE-compression on *data* and return the result."
#~ msgstr "binhex4 스타일의 RLE 압축을 *data*\\에 대해 수행하고 결과를 반환합니다."

#~ msgid ""
#~ "Perform hexbin4 binary-to-ASCII "
#~ "translation and return the resulting "
#~ "string. The argument should already be"
#~ " RLE-coded, and have a length "
#~ "divisible by 3 (except possibly the "
#~ "last fragment)."
#~ msgstr ""
#~ "hexbin4 바이너리에서 ASCII로의 변환을 수행하고 결과 "
#~ "문자열을 반환합니다. 인자는 이미 RLE로 코드화되어 있어야"
#~ " 하며, (마지막 조각을 제외하고) 길이가 3의 배수여야"
#~ " 합니다."

#~ msgid ""
#~ "The result is always unsigned. To "
#~ "generate the same numeric value across"
#~ " all Python versions and platforms, "
#~ "use ``crc32(data) & 0xffffffff``."
#~ msgstr ""
#~ "결과는 항상 부호 없는 정수입니다. 모든 파이썬 "
#~ "버전과 플랫폼에서 같은 숫자 값을 생성하려면, "
#~ "``crc32(data) & 0xffffffff``\\를 사용하십시오."

#~ msgid "Module :mod:`binhex`"
#~ msgstr "모듈 :mod:`binhex`"

#~ msgid "Support for the binhex format used on the Macintosh."
#~ msgstr "매킨토시에서 사용되는 binhex 형식 지원."

#~ msgid "Module :mod:`uu`"
#~ msgstr "모듈 :mod:`uu`"

#~ msgid "Support for UU encoding used on Unix."
#~ msgstr "유닉스에서 사용되는 UU 인코딩 지원."

