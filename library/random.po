# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/random.rst:2
#, fuzzy
msgid ":mod:`!random` --- Generate pseudo-random numbers"
msgstr ":mod:`random` --- 의사 난수 생성"

#: ../../library/random.rst:7
msgid "**Source code:** :source:`Lib/random.py`"
msgstr "**소스 코드:** :source:`Lib/random.py`"

#: ../../library/random.rst:11
msgid ""
"This module implements pseudo-random number generators for various "
"distributions."
msgstr "이 모듈은 다양한 분포에 대한 의사 난수 생성기를 구현합니다."

#: ../../library/random.rst:14
msgid ""
"For integers, there is uniform selection from a range. For sequences, "
"there is uniform selection of a random element, a function to generate a "
"random permutation of a list in-place, and a function for random sampling"
" without replacement."
msgstr ""
"정수에 대해서는, 범위에서 균일한 선택이 있습니다. 시퀀스에 대해서는, 무작위 요소의 균일한 선택, 리스트를 제자리(in-"
"place)에서 임의 순열을 생성하는 함수 및 중복 없는(without replacement) 무작위 표본 추출(sampling)을"
" 위한 함수가 있습니다."

#: ../../library/random.rst:19
msgid ""
"On the real line, there are functions to compute uniform, normal "
"(Gaussian), lognormal, negative exponential, gamma, and beta "
"distributions. For generating distributions of angles, the von Mises "
"distribution is available."
msgstr ""
"실수에 대해서는, 균일(uniform), 정규(normal) (가우시안(Gaussian)), 로그 정규(lognormal), 음의 "
"지수(negative exponential), 감마(gamma) 및 베타(beta) 분포를 계산하는 함수가 있습니다. 각도 분포를 "
"생성하기 위해, 폰 미제스(von Mises) 분포를 사용할 수 있습니다."

#: ../../library/random.rst:23
#, fuzzy
msgid ""
"Almost all module functions depend on the basic function :func:`.random`,"
" which generates a random float uniformly in the half-open range ``0.0 <="
" X < 1.0``. Python uses the Mersenne Twister as the core generator.  It "
"produces 53-bit precision floats and has a period of 2\\*\\*19937-1.  The"
" underlying implementation in C is both fast and threadsafe.  The "
"Mersenne Twister is one of the most extensively tested random number "
"generators in existence.  However, being completely deterministic, it is "
"not suitable for all purposes, and is completely unsuitable for "
"cryptographic purposes."
msgstr ""
"거의 모든 모듈 함수는 기본 함수 :func:`.random`\\에 의존하는데, 이 함수는 반 열린 구간(semi-open "
"range) [0.0, 1.0) 무작위 float를 균일하게 생성합니다. 파이썬은 메르센 트위스터(Mersenne Twister)를"
" 핵심 생성기로 사용합니다. 53비트 정밀도의 float를 생성하며, 주기는 2\\*\\*19937-1 입니다. C로 작성된 하부 "
"구현은 빠르고 스레드 안전합니다. 메르센 트위스터는 가장 광범위하게 테스트 된 난수 생성기 중 하나입니다. 그러나, 완전히 "
"결정적이므로, 모든 목적에 적합하지는 않으며, 암호화 목적에는 전혀 적합하지 않습니다."

#: ../../library/random.rst:32
msgid ""
"The functions supplied by this module are actually bound methods of a "
"hidden instance of the :class:`random.Random` class.  You can instantiate"
" your own instances of :class:`Random` to get generators that don't share"
" state."
msgstr ""
"이 모듈에서 제공하는 함수는 실제로는 :class:`random.Random` 클래스의 숨겨진 인스턴스에 대해 연결된 메서드입니다."
" :class:`Random` 인스턴스를 직접 인스턴스 화하여 상태를 공유하지 않는 생성기를 얻을 수 있습니다."

#: ../../library/random.rst:36
msgid ""
"Class :class:`Random` can also be subclassed if you want to use a "
"different basic generator of your own devising: see the documentation on "
"that class for more details."
msgstr ""

#: ../../library/random.rst:40
msgid ""
"The :mod:`random` module also provides the :class:`SystemRandom` class "
"which uses the system function :func:`os.urandom` to generate random "
"numbers from sources provided by the operating system."
msgstr ""
":mod:`random` 모듈은 운영 체제에서 제공하는 소스에서 난수를 생성하는 시스템 함수 :func:`os.urandom`\\을"
" 사용하는 :class:`SystemRandom` 클래스도 제공합니다."

#: ../../library/random.rst:46
msgid ""
"The pseudo-random generators of this module should not be used for "
"security purposes.  For security or cryptographic uses, see the "
":mod:`secrets` module."
msgstr ""
"이 모듈의 의사 난수 생성기를 보안 목적으로 사용해서는 안 됩니다. 보안이나 암호화 용도를 위해서는, :mod:`secrets` "
"모듈을 참조하십시오."

#: ../../library/random.rst:52
msgid ""
"M. Matsumoto and T. Nishimura, \"Mersenne Twister: A 623-dimensionally "
"equidistributed uniform pseudorandom number generator\", ACM Transactions"
" on Modeling and Computer Simulation Vol. 8, No. 1, January pp.3--30 "
"1998."
msgstr ""
"M. Matsumoto and T. Nishimura, \"Mersenne Twister: A 623-dimensionally "
"equidistributed uniform pseudorandom number generator\", ACM Transactions"
" on Modeling and Computer Simulation Vol. 8, No. 1, January pp.3--30 "
"1998."

#: ../../library/random.rst:57
#, fuzzy
msgid ""
"`Complementary-Multiply-with-Carry recipe "
"<https://code.activestate.com/recipes/576707-long-period-random-number-"
"generator/>`_ for a compatible alternative random number generator with a"
" long period and comparatively simple update operations."
msgstr ""
"긴 주기와 비교적 간단한 업데이트 연산을 하는 호환 가능한 대체 난수 생성기를 위한 `Complementary-Multiply-"
"with-Carry recipe <https://code.activestate.com/recipes/576707/>`_"

#: ../../library/random.rst:63
msgid ""
"The global random number generator and instances of :class:`Random` are "
"thread-safe. However, in the free-threaded build, concurrent calls to the"
" global generator or to the same instance of :class:`Random` may "
"encounter contention and poor performance. Consider using separate "
"instances of :class:`Random` per thread instead."
msgstr ""

#: ../../library/random.rst:70
msgid "Bookkeeping functions"
msgstr "관리 함수"

#: ../../library/random.rst:74
msgid "Initialize the random number generator."
msgstr "난수 생성기를 초기화합니다."

#: ../../library/random.rst:76
msgid ""
"If *a* is omitted or ``None``, the current system time is used.  If "
"randomness sources are provided by the operating system, they are used "
"instead of the system time (see the :func:`os.urandom` function for "
"details on availability)."
msgstr ""
"*a*\\가 생략되거나 ``None``\\이면, 현재 시스템 시간이 사용됩니다. 운영 체제에서 임의성 소스(randomness "
"sources)를 제공하면, 시스템 시간 대신 사용됩니다 (가용성에 대한 자세한 내용은 :func:`os.urandom` 함수를 "
"참조하십시오)."

#: ../../library/random.rst:81
msgid "If *a* is an int, it is used directly."
msgstr "*a*\\가 int이면, 직접 사용됩니다."

#: ../../library/random.rst:83
msgid ""
"With version 2 (the default), a :class:`str`, :class:`bytes`, or "
":class:`bytearray` object gets converted to an :class:`int` and all of "
"its bits are used."
msgstr ""
"버전(version) 2(기본값)에서는, :class:`str`, :class:`bytes` 또는 :class:`bytearray`"
" 객체가 :class:`int`\\로 변환되어 모든 비트가 사용됩니다."

#: ../../library/random.rst:86
msgid ""
"With version 1 (provided for reproducing random sequences from older "
"versions of Python), the algorithm for :class:`str` and :class:`bytes` "
"generates a narrower range of seeds."
msgstr ""
"버전(version) 1(이전 버전의 파이썬에서 온 임의의 시퀀스를 재현하기 위해 제공됩니다)에서는, :class:`str`\\과 "
":class:`bytes`\\를 위한 알고리즘은 더 좁은 범위의 시드(seed)를 생성합니다."

#: ../../library/random.rst:90
msgid "Moved to the version 2 scheme which uses all of the bits in a string seed."
msgstr "문자열 시드의 모든 비트를 사용하는 버전 2 체계로 이동했습니다."

#: ../../library/random.rst:93
#, fuzzy
msgid ""
"The *seed* must be one of the following types: ``None``, :class:`int`, "
":class:`float`, :class:`str`, :class:`bytes`, or :class:`bytearray`."
msgstr ""
"향후에, *seed*\\는 다음 형 중 하나여야 합니다: *NoneType*, :class:`int`, :class:`float`,"
" :class:`str`, :class:`bytes` 또는 :class:`bytearray`."

#: ../../library/random.rst:100
msgid ""
"Return an object capturing the current internal state of the generator.  "
"This object can be passed to :func:`setstate` to restore the state."
msgstr ""
"생성기의 현재 내부 상태를 포착하는 객체를 반환합니다. 이 객체는 :func:`setstate`\\로 전달되어 상태를 복원 할 수 "
"있습니다."

#: ../../library/random.rst:106
msgid ""
"*state* should have been obtained from a previous call to "
":func:`getstate`, and :func:`setstate` restores the internal state of the"
" generator to what it was at the time :func:`getstate` was called."
msgstr ""
"*state*\\는 :func:`getstate`\\에 대한 이전 호출에서 얻은 것이어야 하고, :func:`setstate`\\는"
" 생성기의 내부 상태를 :func:`getstate`\\가 호출될 당시의 상태로 복원합니다."

#: ../../library/random.rst:112
msgid "Functions for bytes"
msgstr "바이트열 함수"

#: ../../library/random.rst:116
msgid "Generate *n* random bytes."
msgstr "*n* 무작위 바이트를 생성합니다."

#: ../../library/random.rst:118
msgid ""
"This method should not be used for generating security tokens. Use "
":func:`secrets.token_bytes` instead."
msgstr "이 메서드를 사용하여 보안 토큰을 생성해서는 안 됩니다. 대신 :func:`secrets.token_bytes`\\를 사용하십시오."

#: ../../library/random.rst:125
msgid "Functions for integers"
msgstr "정수 함수"

#: ../../library/random.rst:130
msgid "Return a randomly selected element from ``range(start, stop, step)``."
msgstr ""

#: ../../library/random.rst:132
msgid ""
"This is roughly equivalent to ``choice(range(start, stop, step))`` but "
"supports arbitrarily large ranges and is optimized for common cases."
msgstr ""

#: ../../library/random.rst:135
msgid "The positional argument pattern matches the :func:`range` function."
msgstr ""

#: ../../library/random.rst:137
msgid ""
"Keyword arguments should not be used because they can be interpreted in "
"unexpected ways. For example ``randrange(start=100)`` is interpreted as "
"``randrange(0, 100, 1)``."
msgstr ""

#: ../../library/random.rst:141
msgid ""
":meth:`randrange` is more sophisticated about producing equally "
"distributed values.  Formerly it used a style like ``int(random()*n)`` "
"which could produce slightly uneven distributions."
msgstr ""
":meth:`randrange`\\는 균일하게 분포된 값을 생성하는 데 있어 더욱 정교합니다. 이전에는 약간 고르지 않은 분포를 "
"생성 할 수 있는 ``int(random()*n)``\\와 같은 스타일을 사용했습니다."

#: ../../library/random.rst:146
msgid ""
"Automatic conversion of non-integer types is no longer supported. Calls "
"such as ``randrange(10.0)`` and ``randrange(Fraction(10, 1))`` now raise "
"a :exc:`TypeError`."
msgstr ""

#: ../../library/random.rst:153
msgid ""
"Return a random integer *N* such that ``a <= N <= b``.  Alias for "
"``randrange(a, b+1)``."
msgstr "``a <= N <= b``\\를 만족하는 임의의 정수 *N*\\을 반환합니다. ``randrange(a, b+1)``\\의 별칭."

#: ../../library/random.rst:158
#, fuzzy
msgid ""
"Returns a non-negative Python integer with *k* random bits. This method "
"is supplied with the Mersenne Twister generator and some other generators"
" may also provide it as an optional part of the API. When available, "
":meth:`getrandbits` enables :meth:`randrange` to handle arbitrarily large"
" ranges."
msgstr ""
"*k* 임의의 비트를 갖는 음이 아닌 파이썬 정수를 반환합니다. 이 메서드는 메르센 트위스터(Mersenne Twister) "
"생성기와 함께 제공되며, 일부 다른 생성기도 API의 선택적 부분으로 제공할 수 있습니다. 사용 가능할 때, "
":meth:`getrandbits`\\는 :meth:`randrange`\\가 임의로 넓은 범위를 처리 할 수 있도록 합니다."

#: ../../library/random.rst:164
msgid "This method now accepts zero for *k*."
msgstr "이 메서드는 이제 *k*\\에 0을 허용합니다."

#: ../../library/random.rst:169
msgid "Functions for sequences"
msgstr "시퀀스 함수"

#: ../../library/random.rst:173
msgid ""
"Return a random element from the non-empty sequence *seq*. If *seq* is "
"empty, raises :exc:`IndexError`."
msgstr ""
"비어 있지 않은 시퀀스 *seq*\\에서 임의의 요소를 반환합니다. *seq*\\가 비어 있으면, "
":exc:`IndexError`\\를 발생시킵니다."

#: ../../library/random.rst:178
msgid ""
"Return a *k* sized list of elements chosen from the *population* with "
"replacement. If the *population* is empty, raises :exc:`IndexError`."
msgstr ""
"*population*\\에서 중복을 허락하면서(with replacement) 선택한 *k* 크기의 요소 리스트를 반환합니다. "
"*population*\\이 비어 있으면, :exc:`IndexError`\\를 발생시킵니다."

#: ../../library/random.rst:181
msgid ""
"If a *weights* sequence is specified, selections are made according to "
"the relative weights.  Alternatively, if a *cum_weights* sequence is "
"given, the selections are made according to the cumulative weights "
"(perhaps computed using :func:`itertools.accumulate`).  For example, the "
"relative weights ``[10, 5, 30, 5]`` are equivalent to the cumulative "
"weights ``[10, 15, 45, 50]``.  Internally, the relative weights are "
"converted to cumulative weights before making selections, so supplying "
"the cumulative weights saves work."
msgstr ""
"*weights* 시퀀스가 지정되면, 상대 가중치에 따라 선택됩니다. 대안적으로, *cum_weights* 시퀀스가 제공되면, "
"(아마도 :func:`itertools.accumulate`\\를 사용하여 계산된) 누적 가중치(cumulative "
"weights)에 따라 선택이 이루어집니다. 예를 들어, 상대 가중치 ``[10, 5, 30, 5]``\\는 누적 가중치 "
"``[10, 15, 45, 50]``\\과 동등합니다. 내부적으로, 상대 가중치는 선택하기 전에 누적 가중치로 변환되므로, 누적 "
"가중치를 제공하면 작업이 줄어듭니다."

#: ../../library/random.rst:190
msgid ""
"If neither *weights* nor *cum_weights* are specified, selections are made"
" with equal probability.  If a weights sequence is supplied, it must be "
"the same length as the *population* sequence.  It is a :exc:`TypeError` "
"to specify both *weights* and *cum_weights*."
msgstr ""
"*weights*\\나 *cum_weights*\\를 지정하지 않으면, 같은 확률로 선택됩니다. weights 시퀀스가 제공되면, "
"*population* 시퀀스와 길이가 같아야 합니다. *weights*\\와 *cum_weights*\\를 모두 지정하는 것은 "
":exc:`TypeError`\\입니다."

#: ../../library/random.rst:195
#, fuzzy
msgid ""
"The *weights* or *cum_weights* can use any numeric type that "
"interoperates with the :class:`float` values returned by :func:`random` "
"(that includes integers, floats, and fractions but excludes decimals).  "
"Weights are assumed to be non-negative and finite.  A :exc:`ValueError` "
"is raised if all weights are zero."
msgstr ""
"*weights*\\나 *cum_weights*\\는 :func:`random`\\이 반환하는 :class:`float` 값과 상호"
" 운용되는 모든 숫자 형을 사용할 수 있습니다 (정수, 부동 소수점(float) 및 유리수(fractions)는 포함하지만, "
"십진수(decimal)는 제외합니다). 가중치가 음수이면 동작이 정의되지 않습니다. 모든 가중치가 0이면 "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/random.rst:201
#, fuzzy
msgid ""
"For a given seed, the :func:`choices` function with equal weighting "
"typically produces a different sequence than repeated calls to "
":func:`choice`.  The algorithm used by :func:`choices` uses floating-"
"point arithmetic for internal consistency and speed.  The algorithm used "
"by :func:`choice` defaults to integer arithmetic with repeated selections"
" to avoid small biases from round-off error."
msgstr ""
"주어진 시드에 대해, 균등한 가중치를 갖는 :func:`choices` 함수는 일반적으로 :func:`choice`\\에 대한 반복"
" 호출과는 다른 시퀀스를 생성합니다. :func:`choices`\\에서 사용하는 알고리즘은 내부 일관성과 속도를 위해 부동 소수점"
" 산술을 사용합니다. :func:`choice`\\에서 사용하는 알고리즘은 자리 올림 오차로 인한 작은 바이어스(bias)를 "
"피하려고 반복 선택을 통한 정수 산술로 기본 설정됩니다."

#: ../../library/random.rst:210
msgid "Raises a :exc:`ValueError` if all weights are zero."
msgstr "모든 가중치가 0이면 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/random.rst:216
msgid "Shuffle the sequence *x* in place."
msgstr "시퀀스 *x*\\를 제자리에서 섞습니다."

#: ../../library/random.rst:218
msgid ""
"To shuffle an immutable sequence and return a new shuffled list, use "
"``sample(x, k=len(x))`` instead."
msgstr "불변 시퀀스를 섞고 새로운 섞인 리스트를 반환하려면, 대신 ``sample(x, k=len(x))``\\를 사용하십시오."

#: ../../library/random.rst:221
msgid ""
"Note that even for small ``len(x)``, the total number of permutations of "
"*x* can quickly grow larger than the period of most random number "
"generators. This implies that most permutations of a long sequence can "
"never be generated.  For example, a sequence of length 2080 is the "
"largest that can fit within the period of the Mersenne Twister random "
"number generator."
msgstr ""
"작은 ``len(x)``\\의 경우에조차, *x*\\의 총 순열 수는 대부분의 난수 생성기 주기보다 빠르게 커질 수 있습니다. "
"이것은 긴 시퀀스의 대부분 순열이 절대로 생성될 수 없음을 의미합니다. 예를 들어, 길이가 2080인 시퀀스가 메르센 트위스터 난수"
" 생성기의 주기 안에 들어갈 수 있는 최대입니다."

#: ../../library/random.rst:227
#, fuzzy
msgid "Removed the optional parameter *random*."
msgstr "선택적 매개 변수 *random*."

#: ../../library/random.rst:233
#, fuzzy
msgid ""
"Return a *k* length list of unique elements chosen from the population "
"sequence.  Used for random sampling without replacement."
msgstr ""
"population 시퀀스나 집합에서 선택한 고유한 요소의 *k* 길이 리스트를 반환합니다. 중복 없는(without "
"replacement) 무작위 표본 추출(sampling)에 사용됩니다."

#: ../../library/random.rst:236
msgid ""
"Returns a new list containing elements from the population while leaving "
"the original population unchanged.  The resulting list is in selection "
"order so that all sub-slices will also be valid random samples.  This "
"allows raffle winners (the sample) to be partitioned into grand prize and"
" second place winners (the subslices)."
msgstr ""
"원래 population을 변경하지 않고, population의 요소를 포함하는 새 리스트를 반환합니다. 결과 리스트는 선택 순서를"
" 따라서, 모든 서브 슬라이스도 유효한 임의의 표본이 됩니다. 이것은 추첨 당첨자(표본)를 대상(grand prize)과 "
"차점자들(서브 슬라이스)로 나눌 수 있도록 합니다."

#: ../../library/random.rst:242
msgid ""
"Members of the population need not be :term:`hashable` or unique.  If the"
" population contains repeats, then each occurrence is a possible "
"selection in the sample."
msgstr ""
"population의 멤버는 :term:`해시 가능 <hashable>`\\하거나 고유할 필요가 없습니다. population이 "
"반복을 포함하면, 각 등장(occurrence)은 표본에서 가능한 선택입니다."

#: ../../library/random.rst:245
msgid ""
"Repeated elements can be specified one at a time or with the optional "
"keyword-only *counts* parameter.  For example, ``sample(['red', 'blue'], "
"counts=[4, 2], k=5)`` is equivalent to ``sample(['red', 'red', 'red', "
"'red', 'blue', 'blue'], k=5)``."
msgstr ""
"반복되는 요소는 한 번에 하나씩 또는 선택적 키워드 전용 *counts* 매개 변수로 지정할 수 있습니다. 예를 들어 "
"``sample(['red', 'blue'], counts=[4, 2], k=5)``\\는 ``sample(['red', "
"'red', 'red', 'red', 'blue', 'blue'], k=5)``\\와 동등합니다."

#: ../../library/random.rst:250
msgid ""
"To choose a sample from a range of integers, use a :func:`range` object "
"as an argument.  This is especially fast and space efficient for sampling"
" from a large population:  ``sample(range(10000000), k=60)``."
msgstr ""
"정수 범위에서 표본을 선택하려면, :func:`range` 객체를 인자로 사용하십시오. 이는 큰 population에서 표본 추출할"
" 때 특히 빠르고 공간 효율적입니다: ``sample(range(10000000), k=60)``."

#: ../../library/random.rst:254
msgid ""
"If the sample size is larger than the population size, a "
":exc:`ValueError` is raised."
msgstr "표본 크기가 population 크기보다 크면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/random.rst:257
msgid "Added the *counts* parameter."
msgstr "*counts* 매개 변수를 추가했습니다."

#: ../../library/random.rst:262
msgid ""
"The *population* must be a sequence.  Automatic conversion of sets to "
"lists is no longer supported."
msgstr ""

#: ../../library/random.rst:266
#, fuzzy
msgid "Discrete distributions"
msgstr "실수 분포"

#: ../../library/random.rst:268
msgid "The following function generates a discrete distribution."
msgstr ""

#: ../../library/random.rst:272
msgid ""
"`Binomial distribution "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_. Return the "
"number of successes for *n* independent trials with the probability of "
"success in each trial being *p*:"
msgstr ""

#: ../../library/random.rst:277
msgid "Mathematically equivalent to::"
msgstr ""

#: ../../library/random.rst:279
msgid "sum(random() < p for i in range(n))"
msgstr ""

#: ../../library/random.rst:281
msgid ""
"The number of trials *n* should be a non-negative integer. The "
"probability of success *p* should be between ``0.0 <= p <= 1.0``. The "
"result is an integer in the range ``0 <= X <= n``."
msgstr ""

#: ../../library/random.rst:291
msgid "Real-valued distributions"
msgstr "실수 분포"

#: ../../library/random.rst:293
msgid ""
"The following functions generate specific real-valued distributions. "
"Function parameters are named after the corresponding variables in the "
"distribution's equation, as used in common mathematical practice; most of"
" these equations can be found in any statistics text."
msgstr ""
"다음 함수는 특정 실수 분포를 생성합니다. 함수 매개 변수는 일반적인 수학적 관행에 사용되는 분포 방정식에서 해당 변수의 이름을 "
"따서 명명됩니다; 이러한 방정식의 대부분은 모든 통계 교과서에서 찾을 수 있습니다."

#: ../../library/random.rst:301
#, fuzzy
msgid ""
"Return the next random floating-point number in the range ``0.0 <= X < "
"1.0``"
msgstr "[0.0, 1.0) 구간에서 다음 임의의 부동 소수점 숫자를 반환합니다."

#: ../../library/random.rst:306
#, fuzzy
msgid ""
"Return a random floating-point number *N* such that ``a <= N <= b`` for "
"``a <= b`` and ``b <= N <= a`` for ``b < a``."
msgstr ""
"``a <= b`` 일 때 ``a <= N <= b``, ``b < a`` 일 때 ``b <= N <= a``\\를 만족하는 임의의"
" 부동 소수점 숫자 *N*\\을 반환합니다."

#: ../../library/random.rst:309
#, fuzzy
msgid ""
"The end-point value ``b`` may or may not be included in the range "
"depending on floating-point rounding in the expression ``a + (b-a) * "
"random()``."
msgstr ""
"종단 값 ``b``\\는 방정식 ``a + (b-a) * random()``\\의 부동 소수점 자리 올림에 따라 범위에 포함되거나 "
"포함되지 않을 수 있습니다."

#: ../../library/random.rst:316
#, fuzzy
msgid ""
"Return a random floating-point number *N* such that ``low <= N <= high`` "
"and with the specified *mode* between those bounds.  The *low* and *high*"
" bounds default to zero and one.  The *mode* argument defaults to the "
"midpoint between the bounds, giving a symmetric distribution."
msgstr ""
"``low <= N <= high``\\를 만족하고 이 경계 사이에 지정된 *모드(mode)*\\를 갖는 임의의 부동 소수점 숫자 "
"*N*\\을 반환합니다. *low* 및 *high* 경계는 기본적으로 0과 1입니다. *mode* 인자는 기본적으로 경계 사이의 "
"중간 점으로, 대칭 분포를 제공합니다."

#: ../../library/random.rst:324
msgid ""
"Beta distribution.  Conditions on the parameters are ``alpha > 0`` and "
"``beta > 0``. Returned values range between 0 and 1."
msgstr "베타 분포. 매개 변수의 조건은 ``alpha > 0``\\과 ``beta > 0``\\입니다. 반환된 값의 범위는 0에서 1입니다."

#: ../../library/random.rst:330
msgid ""
"Exponential distribution.  *lambd* is 1.0 divided by the desired mean.  "
"It should be nonzero.  (The parameter would be called \"lambda\", but "
"that is a reserved word in Python.)  Returned values range from 0 to "
"positive infinity if *lambd* is positive, and from negative infinity to 0"
" if *lambd* is negative."
msgstr ""
"지수 분포. *lambd*\\는 1.0을 원하는 평균으로 나눈 값입니다. 0이 아니어야 합니다. (매개 변수는 "
"\"lambda\"라고 부르지만, 파이썬에서는 예약어입니다.) 반환된 값의 범위는, *lambd*\\가 양수이면 0에서 양의 "
"무한대이고, *lambd*\\가 음수이면 음의 무한대에서 0입니다."

#: ../../library/random.rst:336
msgid "Added the default value for ``lambd``."
msgstr ""

#: ../../library/random.rst:342
msgid ""
"Gamma distribution.  (*Not* the gamma function!)  The shape and scale "
"parameters, *alpha* and *beta*, must have positive values. (Calling "
"conventions vary and some sources define 'beta' as the inverse of the "
"scale)."
msgstr ""

#: ../../library/random.rst:347
msgid "The probability distribution function is::"
msgstr "확률 분포 함수는 다음과 같습니다::"

#: ../../library/random.rst:349
msgid ""
"          x ** (alpha - 1) * math.exp(-x / beta)\n"
"pdf(x) =  --------------------------------------\n"
"            math.gamma(alpha) * beta ** alpha"
msgstr ""

#: ../../library/random.rst:356
#, fuzzy
msgid ""
"Normal distribution, also called the Gaussian distribution. *mu* is the "
"mean, and *sigma* is the standard deviation.  This is slightly faster "
"than the :func:`normalvariate` function defined below."
msgstr ""
"가우시안 분포. *mu*\\는 평균이고, *sigma*\\는 표준 편차입니다. 이것은 아래에 정의된 "
":func:`normalvariate` 함수보다 약간 빠릅니다."

#: ../../library/random.rst:361
msgid ""
"Multithreading note:  When two threads call this function simultaneously,"
" it is possible that they will receive the same return value.  This can "
"be avoided in three ways. 1) Have each thread use a different instance of"
" the random number generator. 2) Put locks around all calls. 3) Use the "
"slower, but thread-safe :func:`normalvariate` function instead."
msgstr ""
"다중 스레딩 참고: 두 스레드가 이 함수를 동시에 호출하면, 같은 반환 값을 받을 수 있습니다. 이것은 세 가지 방법으로 피할 수 "
"있습니다. 1) 각 스레드가 난수 생성기의 다른 인스턴스를 사용하도록 합니다. 2) 모든 호출에 록을 둡니다. 3) 더 느리지만, "
"스레드 안전한 :func:`normalvariate` 함수를 대신 사용합니다."

#: ../../library/random.rst:368 ../../library/random.rst:384
msgid "*mu* and *sigma* now have default arguments."
msgstr ""

#: ../../library/random.rst:374
msgid ""
"Log normal distribution.  If you take the natural logarithm of this "
"distribution, you'll get a normal distribution with mean *mu* and "
"standard deviation *sigma*.  *mu* can have any value, and *sigma* must be"
" greater than zero."
msgstr ""
"로그 정규 분포. 이 분포의 자연로그를 취하면, 평균 *mu*\\와 표준 편차 *sigma*\\를 갖는 정규 분포를 얻게 됩니다. "
"*mu*\\는 아무 값이나 될 수 있으며, *sigma*\\는 0보다 커야 합니다."

#: ../../library/random.rst:382
msgid ""
"Normal distribution.  *mu* is the mean, and *sigma* is the standard "
"deviation."
msgstr "정규 분포. *mu*\\는 평균이고, *sigma*\\는 표준 편차입니다."

#: ../../library/random.rst:390
msgid ""
"*mu* is the mean angle, expressed in radians between 0 and 2\\*\\ *pi*, "
"and *kappa* is the concentration parameter, which must be greater than or"
" equal to zero.  If *kappa* is equal to zero, this distribution reduces "
"to a uniform random angle over the range 0 to 2\\*\\ *pi*."
msgstr ""
"*mu*\\는 0과 2\\*\\ *pi* 사이의 라디안으로 표현된 평균 각도이며, *kappa*\\는 0 이상이어야 하는 "
"집중도(concentration) 매개 변수입니다.  *kappa*\\가 0이면, 이 분포는 0에서 2\\*\\ *pi*\\에 걸친"
" 균등한 임의의 각도로 환원됩니다."

#: ../../library/random.rst:398
msgid "Pareto distribution.  *alpha* is the shape parameter."
msgstr "파레토 분포. *alpha*\\는 모양(shape) 매개 변수입니다."

#: ../../library/random.rst:403
msgid ""
"Weibull distribution.  *alpha* is the scale parameter and *beta* is the "
"shape parameter."
msgstr "베이불 분포. *alpha*\\는 크기(scale) 매개 변수이고 *beta*\\는 모양(shape) 매개 변수입니다."

#: ../../library/random.rst:408
msgid "Alternative Generator"
msgstr "대체 생성기"

#: ../../library/random.rst:412
msgid ""
"Class that implements the default pseudo-random number generator used by "
"the :mod:`random` module."
msgstr ":mod:`random` 모듈에서 사용하는 기본 의사 난수 생성기를 구현하는 클래스."

#: ../../library/random.rst:415
#, fuzzy
msgid ""
"Formerly the *seed* could be any hashable object.  Now it is limited to: "
"``None``, :class:`int`, :class:`float`, :class:`str`, :class:`bytes`, or "
":class:`bytearray`."
msgstr ""
"향후에, *seed*\\는 다음 형 중 하나여야 합니다: *NoneType*, :class:`int`, :class:`float`,"
" :class:`str`, :class:`bytes` 또는 :class:`bytearray`."

#: ../../library/random.rst:420
msgid ""
"Subclasses of :class:`!Random` should override the following methods if "
"they wish to make use of a different basic generator:"
msgstr ""

#: ../../library/random.rst:425
msgid ""
"Override this method in subclasses to customise the :meth:`~random.seed` "
"behaviour of :class:`!Random` instances."
msgstr ""

#: ../../library/random.rst:430
msgid ""
"Override this method in subclasses to customise the "
":meth:`~random.getstate` behaviour of :class:`!Random` instances."
msgstr ""

#: ../../library/random.rst:435
msgid ""
"Override this method in subclasses to customise the "
":meth:`~random.setstate` behaviour of :class:`!Random` instances."
msgstr ""

#: ../../library/random.rst:440
msgid ""
"Override this method in subclasses to customise the "
":meth:`~random.random` behaviour of :class:`!Random` instances."
msgstr ""

#: ../../library/random.rst:443
msgid ""
"Optionally, a custom generator subclass can also supply the following "
"method:"
msgstr ""

#: ../../library/random.rst:447
msgid ""
"Override this method in subclasses to customise the "
":meth:`~random.getrandbits` behaviour of :class:`!Random` instances."
msgstr ""

#: ../../library/random.rst:453
msgid ""
"Class that uses the :func:`os.urandom` function for generating random "
"numbers from sources provided by the operating system. Not available on "
"all systems. Does not rely on software state, and sequences are not "
"reproducible. Accordingly, the :meth:`seed` method has no effect and is "
"ignored. The :meth:`getstate` and :meth:`setstate` methods raise "
":exc:`NotImplementedError` if called."
msgstr ""
"운영 체제에서 제공하는 소스에서 난수를 생성하기 위해 :func:`os.urandom` 함수를 사용하는 클래스. 모든 시스템에서 "
"사용 가능한 것은 아닙니다. 소프트웨어 상태에 의존하지 않으며, 시퀀스는 재현되지 않습니다. 따라서, :meth:`seed` "
"메서드는 효과가 없으며, 무시됩니다. :meth:`getstate`\\와 :meth:`setstate` 메서드는 호출되면 "
":exc:`NotImplementedError`\\를 발생시킵니다."

#: ../../library/random.rst:462
msgid "Notes on Reproducibility"
msgstr "재현성에 대한 참고 사항"

#: ../../library/random.rst:464
#, fuzzy
msgid ""
"Sometimes it is useful to be able to reproduce the sequences given by a "
"pseudo-random number generator.  By reusing a seed value, the same "
"sequence should be reproducible from run to run as long as multiple "
"threads are not running."
msgstr ""
"때때로 의사 난수 생성기가 만든 시퀀스를 재현하는 것이 유용 할 수 있습니다. 시드 값을 재사용하면, 여러 스레드가 실행되고 있지 "
"않은 한 실행할 때마다 같은 시퀀스를 재현할 수 있어야 합니다."

#: ../../library/random.rst:468
msgid ""
"Most of the random module's algorithms and seeding functions are subject "
"to change across Python versions, but two aspects are guaranteed not to "
"change:"
msgstr ""
"random 모듈의 알고리즘과 시딩(seeding) 함수의 대부분은 파이썬 버전에 따라 변경될 수 있지만, 두 가지 측면은 변경되지"
" 않음이 보장됩니다:"

#: ../../library/random.rst:471
msgid ""
"If a new seeding method is added, then a backward compatible seeder will "
"be offered."
msgstr "새로운 시딩 메서드가 추가되면, 이전 버전과 호환되는 시더(seeder)가 제공될 것입니다."

#: ../../library/random.rst:474
msgid ""
"The generator's :meth:`~Random.random` method will continue to produce "
"the same sequence when the compatible seeder is given the same seed."
msgstr "호환 시더에 같은 시드가 제공되면 생성기의 :meth:`~Random.random` 메서드는 같은 시퀀스를 계속 생성할 것입니다."

#: ../../library/random.rst:480
msgid "Examples"
msgstr "예제"

#: ../../library/random.rst:482
msgid "Basic examples::"
msgstr "기본 예제::"

#: ../../library/random.rst:484
msgid ""
">>> random()                          # Random float:  0.0 <= x < 1.0\n"
"0.37444887175646646\n"
"\n"
">>> uniform(2.5, 10.0)                # Random float:  2.5 <= x <= 10.0\n"
"3.1800146073117523\n"
"\n"
">>> expovariate(1 / 5)                # Interval between arrivals "
"averaging 5 seconds\n"
"5.148957571865031\n"
"\n"
">>> randrange(10)                     # Integer from 0 to 9 inclusive\n"
"7\n"
"\n"
">>> randrange(0, 101, 2)              # Even integer from 0 to 100 "
"inclusive\n"
"26\n"
"\n"
">>> choice(['win', 'lose', 'draw'])   # Single random element from a "
"sequence\n"
"'draw'\n"
"\n"
">>> deck = 'ace two three four'.split()\n"
">>> shuffle(deck)                     # Shuffle a list\n"
">>> deck\n"
"['four', 'two', 'ace', 'three']\n"
"\n"
">>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement\n"
"[40, 10, 50, 30]"
msgstr ""

#: ../../library/random.rst:510
msgid "Simulations::"
msgstr "시뮬레이션::"

#: ../../library/random.rst:512
#, python-format
msgid ""
">>> # Six roulette wheel spins (weighted sampling with replacement)\n"
">>> choices(['red', 'black', 'green'], [18, 18, 2], k=6)\n"
"['red', 'green', 'black', 'black', 'red', 'black']\n"
"\n"
">>> # Deal 20 cards without replacement from a deck\n"
">>> # of 52 playing cards, and determine the proportion of cards\n"
">>> # with a ten-value:  ten, jack, queen, or king.\n"
">>> deal = sample(['tens', 'low cards'], counts=[16, 36], k=20)\n"
">>> deal.count('tens') / 20\n"
"0.15\n"
"\n"
">>> # Estimate the probability of getting 5 or more heads from 7 spins\n"
">>> # of a biased coin that settles on heads 60% of the time.\n"
">>> sum(binomialvariate(n=7, p=0.6) >= 5 for i in range(10_000)) / 10_000"
"\n"
"0.4169\n"
"\n"
">>> # Probability of the median of 5 samples being in middle two "
"quartiles\n"
">>> def trial():\n"
"...     return 2_500 <= sorted(choices(range(10_000), k=5))[2] < 7_500\n"
"...\n"
">>> sum(trial() for i in range(10_000)) / 10_000\n"
"0.7958"
msgstr ""

#: ../../library/random.rst:535
msgid ""
"Example of `statistical bootstrapping "
"<https://en.wikipedia.org/wiki/Bootstrapping_(statistics)>`_ using "
"resampling with replacement to estimate a confidence interval for the "
"mean of a sample::"
msgstr ""
"표본의 평균에 대한 신뢰 구간을 추정하기 위해 중복을 허용하는(with replacement) 재표본추출(resampling)을 "
"사용하는 `통계적 부트스트래핑(statistical bootstrapping) "
"<https://en.wikipedia.org/wiki/Bootstrapping_(statistics)>`_\\의 예::"

#: ../../library/random.rst:539
#, python-brace-format, python-format
msgid ""
"# https://www.thoughtco.com/example-of-bootstrapping-3126155\n"
"from statistics import fmean as mean\n"
"from random import choices\n"
"\n"
"data = [41, 50, 29, 37, 81, 30, 73, 63, 20, 35, 68, 22, 60, 31, 95]\n"
"means = sorted(mean(choices(data, k=len(data))) for i in range(100))\n"
"print(f'The sample mean of {mean(data):.1f} has a 90% confidence '\n"
"      f'interval from {means[5]:.1f} to {means[94]:.1f}')"
msgstr ""

#: ../../library/random.rst:548
msgid ""
"Example of a `resampling permutation test "
"<https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests>`_"
" to determine the statistical significance or `p-value "
"<https://en.wikipedia.org/wiki/P-value>`_ of an observed difference "
"between the effects of a drug versus a placebo::"
msgstr ""
"약물과 위약의 효과 간에 관찰된 차이의 통계적 유의성 또는 `p-값 "
"<https://en.wikipedia.org/wiki/P-value>`_\\을 결정하기 위한 `재표본추출 순열 "
"검증(resampling permutation test) "
"<https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests>`_\\의"
" 예::"

#: ../../library/random.rst:554
#, python-brace-format
msgid ""
"# Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson\n"
"from statistics import fmean as mean\n"
"from random import shuffle\n"
"\n"
"drug = [54, 73, 53, 70, 73, 68, 52, 65, 65]\n"
"placebo = [54, 51, 58, 44, 55, 52, 42, 47, 58, 46]\n"
"observed_diff = mean(drug) - mean(placebo)\n"
"\n"
"n = 10_000\n"
"count = 0\n"
"combined = drug + placebo\n"
"for i in range(n):\n"
"    shuffle(combined)\n"
"    new_diff = mean(combined[:len(drug)]) - mean(combined[len(drug):])\n"
"    count += (new_diff >= observed_diff)\n"
"\n"
"print(f'{n} label reshufflings produced only {count} instances with a "
"difference')\n"
"print(f'at least as extreme as the observed difference of "
"{observed_diff:.1f}.')\n"
"print(f'The one-sided p-value of {count / n:.4f} leads us to reject the "
"null')\n"
"print(f'hypothesis that there is no difference between the drug and the "
"placebo.')"
msgstr ""

#: ../../library/random.rst:575
msgid ""
"Simulation of arrival times and service deliveries for a multiserver "
"queue::"
msgstr "다중 서버 큐를 위한 도착 시간과 서비스 제공의 시뮬레이션::"

#: ../../library/random.rst:577
#, python-brace-format
msgid ""
"from heapq import heapify, heapreplace\n"
"from random import expovariate, gauss\n"
"from statistics import mean, quantiles\n"
"\n"
"average_arrival_interval = 5.6\n"
"average_service_time = 15.0\n"
"stdev_service_time = 3.5\n"
"num_servers = 3\n"
"\n"
"waits = []\n"
"arrival_time = 0.0\n"
"servers = [0.0] * num_servers  # time when each server becomes available\n"
"heapify(servers)\n"
"for i in range(1_000_000):\n"
"    arrival_time += expovariate(1.0 / average_arrival_interval)\n"
"    next_server_available = servers[0]\n"
"    wait = max(0.0, next_server_available - arrival_time)\n"
"    waits.append(wait)\n"
"    service_duration = max(0.0, gauss(average_service_time, "
"stdev_service_time))\n"
"    service_completed = arrival_time + wait + service_duration\n"
"    heapreplace(servers, service_completed)\n"
"\n"
"print(f'Mean wait: {mean(waits):.1f}   Max wait: {max(waits):.1f}')\n"
"print('Quartiles:', [round(q, 1) for q in quantiles(waits)])"
msgstr ""

#: ../../library/random.rst:604
msgid ""
"`Statistics for Hackers <https://www.youtube.com/watch?v=Iq9DzN6mvYA>`_ a"
" video tutorial by `Jake Vanderplas "
"<https://us.pycon.org/2016/speaker/profile/295/>`_ on statistical "
"analysis using just a few fundamental concepts including simulation, "
"sampling, shuffling, and cross-validation."
msgstr ""
"시뮬레이션(simulation), 표본 추출(sampling), 섞기(shuffling) 및 교차 검증(cross-"
"validation)을 포함하는 몇 가지 기본 개념만을 사용한, 통계 분석에 대한 `Jake Vanderplas "
"<https://us.pycon.org/2016/speaker/profile/295/>`_\\의 비디오 자습서 `Statistics"
" for Hackers <https://www.youtube.com/watch?v=Iq9DzN6mvYA>`_"

#: ../../library/random.rst:610
#, fuzzy
msgid ""
"`Economics Simulation "
"<https://nbviewer.org/url/norvig.com/ipython/Economics.ipynb>`_ a "
"simulation of a marketplace by `Peter Norvig "
"<https://norvig.com/bio.html>`_ that shows effective use of many of the "
"tools and distributions provided by this module (gauss, uniform, sample, "
"betavariate, choice, triangular, and randrange)."
msgstr ""
"`Economics Simulation "
"<http://nbviewer.jupyter.org/url/norvig.com/ipython/Economics.ipynb>`_ 이 "
"모듈에서 제공하는 많은 도구와 분포(gauss, uniform, sample, betavariate, choice, "
"triangular 및 randrange)의 효과적인 사용을 보여주는 `Peter Norvig "
"<http://norvig.com/bio.html>`_\\의 시장(marketplace) 시뮬레이션."

#: ../../library/random.rst:617
#, fuzzy
msgid ""
"`A Concrete Introduction to Probability (using Python) "
"<https://nbviewer.org/url/norvig.com/ipython/Probability.ipynb>`_ a "
"tutorial by `Peter Norvig <https://norvig.com/bio.html>`_ covering the "
"basics of probability theory, how to write simulations, and how to "
"perform data analysis using Python."
msgstr ""
"`A Concrete Introduction to Probability (using Python) "
"<http://nbviewer.jupyter.org/url/norvig.com/ipython/Probability.ipynb>`_ "
"확률 이론의 기초, 시뮬레이션 작성 방법 및 파이썬을 사용해서 데이터 분석을 수행하는 방법을 다루는 `Peter Norvig "
"<http://norvig.com/bio.html>`_\\의 자습서."

#: ../../library/random.rst:625
msgid "Recipes"
msgstr "조리법"

#: ../../library/random.rst:627
msgid ""
"These recipes show how to efficiently make random selections from the "
"combinatoric iterators in the :mod:`itertools` module:"
msgstr ""

#: ../../library/random.rst:630
msgid ""
"def random_product(*args, repeat=1):\n"
"    \"Random selection from itertools.product(*args, **kwds)\"\n"
"    pools = [tuple(pool) for pool in args] * repeat\n"
"    return tuple(map(random.choice, pools))\n"
"\n"
"def random_permutation(iterable, r=None):\n"
"    \"Random selection from itertools.permutations(iterable, r)\"\n"
"    pool = tuple(iterable)\n"
"    r = len(pool) if r is None else r\n"
"    return tuple(random.sample(pool, r))\n"
"\n"
"def random_combination(iterable, r):\n"
"    \"Random selection from itertools.combinations(iterable, r)\"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = sorted(random.sample(range(n), r))\n"
"    return tuple(pool[i] for i in indices)\n"
"\n"
"def random_combination_with_replacement(iterable, r):\n"
"    \"Choose r elements with replacement.  Order the result to match the "
"iterable.\"\n"
"    # Result will be in "
"set(itertools.combinations_with_replacement(iterable, r)).\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = sorted(random.choices(range(n), k=r))\n"
"    return tuple(pool[i] for i in indices)"
msgstr ""

#: ../../library/random.rst:659
msgid ""
"The default :func:`.random` returns multiples of 2⁻⁵³ in the range *0.0 ≤"
" x < 1.0*.  All such numbers are evenly spaced and are exactly "
"representable as Python floats.  However, many other representable floats"
" in that interval are not possible selections.  For example, "
"``0.05954861408025609`` isn't an integer multiple of 2⁻⁵³."
msgstr ""
"기본 :func:`.random`\\은 *0.0 ≤ x < 1.0* 범위에서 2⁻⁵³의 배수를 반환합니다. 이러한 모든 숫자는 균등"
" 간격으로 분포되어있고 파이썬 float로 정확하게 표현할 수 있습니다. 그러나, 해당 범위의 다른 많은 표현 가능한 부동 소수점은"
" 가능한 선택이 아닙니다. 예를 들어, ``0.05954861408025609``\\는 2⁻⁵³의 정수배가 아닙니다."

#: ../../library/random.rst:665
msgid ""
"The following recipe takes a different approach.  All floats in the "
"interval are possible selections.  The mantissa comes from a uniform "
"distribution of integers in the range *2⁵² ≤ mantissa < 2⁵³*.  The "
"exponent comes from a geometric distribution where exponents smaller than"
" *-53* occur half as often as the next larger exponent."
msgstr ""
"다음 조리법은 다른 접근 방식을 사용합니다. 범위의 모든 부동 소수점이 가능한 선택입니다. 가수(mantissa)는 *2⁵² ≤ "
"mantissa < 2⁵³* 범위에 있는 정수의 균등 분포(uniform distribution)에서 옵니다. "
"지수(exponent)는 *-53*\\보다 작은 지수가 다음으로 큰 지수의 절반만큼 자주 발생하는 기하 분포(geometric "
"distribution)에서 옵니다."

#: ../../library/random.rst:673
msgid ""
"from random import Random\n"
"from math import ldexp\n"
"\n"
"class FullRandom(Random):\n"
"\n"
"    def random(self):\n"
"        mantissa = 0x10_0000_0000_0000 | self.getrandbits(52)\n"
"        exponent = -53\n"
"        x = 0\n"
"        while not x:\n"
"            x = self.getrandbits(32)\n"
"            exponent += x.bit_length() - 32\n"
"        return ldexp(mantissa, exponent)"
msgstr ""

#: ../../library/random.rst:687
msgid ""
"All :ref:`real valued distributions <real-valued-distributions>` in the "
"class will use the new method::"
msgstr "클래스의 모든 :ref:`실숫값 분포 <real-valued-distributions>`\\는 새 메서드를 사용합니다::"

#: ../../library/random.rst:690
msgid ""
">>> fr = FullRandom()\n"
">>> fr.random()\n"
"0.05954861408025609\n"
">>> fr.expovariate(0.25)\n"
"8.87925541791544"
msgstr ""

#: ../../library/random.rst:696
msgid ""
"The recipe is conceptually equivalent to an algorithm that chooses from "
"all the multiples of 2⁻¹⁰⁷⁴ in the range *0.0 ≤ x < 1.0*.  All such "
"numbers are evenly spaced, but most have to be rounded down to the "
"nearest representable Python float.  (The value 2⁻¹⁰⁷⁴ is the smallest "
"positive unnormalized float and is equal to ``math.ulp(0.0)``.)"
msgstr ""
"조리법은 개념적으로 *0.0 ≤ x < 1.0* 범위의 2⁻¹⁰⁷⁴의 모든 배수에서 선택하는 알고리즘과 동등합니다. 이러한 모든 "
"숫자는 균등한 간격이지만, 대부분은 가장 가까운 표현 가능한 파이썬 부동 소수점으로 자리 내림해야 합니다. (값 2⁻¹⁰⁷⁴은 가장"
" 작은 양의 정규화되지 않은 부동 소수점이며 ``math.ulp(0.0)``\\과 같습니다.)"

#: ../../library/random.rst:705
msgid ""
"`Generating Pseudo-random Floating-Point Values "
"<https://allendowney.com/research/rand/downey07randfloat.pdf>`_ a paper "
"by Allen B. Downey describing ways to generate more fine-grained floats "
"than normally generated by :func:`.random`."
msgstr ""
"`Generating Pseudo-random Floating-Point Values "
"<https://allendowney.com/research/rand/downey07randfloat.pdf>`_ Allen B. "
"Downey의 논문은 :func:`.random`\\이 일반적으로 생성하는 것보다 더 세밀한 부동 소수점을 생성하는 방법을 "
"설명합니다."

#: ../../library/random.rst:713
msgid "Command-line usage"
msgstr ""

#: ../../library/random.rst:717
msgid "The :mod:`!random` module can be executed from the command line."
msgstr ""

#: ../../library/random.rst:719
msgid "python -m random [-h] [-c CHOICE [CHOICE ...] | -i N | -f N] [input ...]"
msgstr ""

#: ../../library/random.rst:723
msgid "The following options are accepted:"
msgstr ""

#: ../../library/random.rst:729
msgid "Show the help message and exit."
msgstr ""

#: ../../library/random.rst:734
msgid "Print a random choice, using :meth:`choice`."
msgstr ""

#: ../../library/random.rst:739
msgid "Print a random integer between 1 and N inclusive, using :meth:`randint`."
msgstr ""

#: ../../library/random.rst:744
msgid ""
"Print a random floating-point number between 0 and N inclusive, using "
":meth:`uniform`."
msgstr ""

#: ../../library/random.rst:747
msgid "If no options are given, the output depends on the input:"
msgstr ""

#: ../../library/random.rst:749
msgid "String or multiple: same as :option:`--choice`."
msgstr ""

#: ../../library/random.rst:750
msgid "Integer: same as :option:`--integer`."
msgstr ""

#: ../../library/random.rst:751
msgid "Float: same as :option:`--float`."
msgstr ""

#: ../../library/random.rst:756
msgid "Command-line example"
msgstr ""

#: ../../library/random.rst:758
msgid "Here are some examples of the :mod:`!random` command-line interface:"
msgstr ""

#: ../../library/random.rst:760
msgid ""
"$ # Choose one at random\n"
"$ python -m random egg bacon sausage spam \"Lobster Thermidor aux "
"crevettes with a Mornay sauce\"\n"
"Lobster Thermidor aux crevettes with a Mornay sauce\n"
"\n"
"$ # Random integer\n"
"$ python -m random 6\n"
"6\n"
"\n"
"$ # Random floating-point number\n"
"$ python -m random 1.8\n"
"1.7080016272295635\n"
"\n"
"$ # With explicit arguments\n"
"$ python  -m random --choice egg bacon sausage spam \"Lobster Thermidor "
"aux crevettes with a Mornay sauce\"\n"
"egg\n"
"\n"
"$ python -m random --integer 6\n"
"3\n"
"\n"
"$ python -m random --float 1.8\n"
"1.5666339105010318\n"
"\n"
"$ python -m random --integer 6\n"
"5\n"
"\n"
"$ python -m random --float 6\n"
"3.1942323316565915"
msgstr ""

#~ msgid ""
#~ "Class :class:`Random` can also be "
#~ "subclassed if you want to use a"
#~ " different basic generator of your "
#~ "own devising: in that case, override "
#~ "the :meth:`~Random.random`, :meth:`~Random.seed`, "
#~ ":meth:`~Random.getstate`, and :meth:`~Random.setstate` "
#~ "methods. Optionally, a new generator can"
#~ " supply a :meth:`~Random.getrandbits` method "
#~ "--- this allows :meth:`randrange` to "
#~ "produce selections over an arbitrarily "
#~ "large range."
#~ msgstr ""
#~ "스스로 고안한 다른 기본 생성기를 사용하기 원한다면, "
#~ "클래스 :class:`Random`\\을 서브 클래싱 할 수도 "
#~ "있습니다: 이 경우, :meth:`~Random.random`, "
#~ ":meth:`~Random.seed`, :meth:`~Random.getstate` 및 "
#~ ":meth:`~Random.setstate` 메서드를 재정의하십시오. 선택적으로, "
#~ "새로운 생성기는 :meth:`~Random.getrandbits` 메서드를 제공할"
#~ " 수 있습니다 --- 이것은 :meth:`randrange`\\가 "
#~ "임의로 넓은 범위에서 선택을 생성할 수 있도록 "
#~ "합니다."

#~ msgid ""
#~ "Return a randomly selected element from"
#~ " ``range(start, stop, step)``.  This is "
#~ "equivalent to ``choice(range(start, stop, "
#~ "step))``, but doesn't actually build a"
#~ " range object."
#~ msgstr ""
#~ "``range(start, stop, step)``\\에서 임의로 선택된 "
#~ "요소를 반환합니다. 이것은 ``choice(range(start, stop, "
#~ "step))``\\와 동등하지만, 실제로 range 객체를 만들지는"
#~ " 않습니다."

#~ msgid ""
#~ "The positional argument pattern matches "
#~ "that of :func:`range`.  Keyword arguments "
#~ "should not be used because the "
#~ "function may use them in unexpected "
#~ "ways."
#~ msgstr ""
#~ "위치 인자 패턴은 :func:`range`\\와 일치합니다. 함수가"
#~ " 예상치 못한 방식으로 키워드 인자를 사용할 수 "
#~ "있기 때문에 키워드 인자를 사용해서는 안 됩니다."

#~ msgid ""
#~ "The optional argument *random* is a "
#~ "0-argument function returning a random "
#~ "float in [0.0, 1.0); by default, "
#~ "this is the function :func:`.random`."
#~ msgstr ""
#~ "선택적 인자 *random*\\은 [0.0, 1.0) 구간에서 "
#~ "임의의 float를 반환하는 0-인자 함수입니다; 기본적으로 "
#~ "이것은 :func:`.random` 함수입니다."

#~ msgid ""
#~ "In the future, the *population* must "
#~ "be a sequence.  Instances of "
#~ ":class:`set` are no longer supported.  "
#~ "The set must first be converted to"
#~ " a :class:`list` or :class:`tuple`, "
#~ "preferably in a deterministic order so"
#~ " that the sample is reproducible."
#~ msgstr ""
#~ "향후에, *population*\\은 시퀀스여야 합니다. :class:`set`"
#~ " 인스턴스는 더는 지원되지 않습니다. 집합은 먼저 "
#~ ":class:`list`\\나 :class:`tuple`\\로 변환되어야 합니다, "
#~ "표본을 재현할 수 있도록 결정론적 순서가 선호됩니다."

#~ msgid ""
#~ "Gamma distribution.  (*Not* the gamma "
#~ "function!)  Conditions on the parameters "
#~ "are ``alpha > 0`` and ``beta > "
#~ "0``."
#~ msgstr ""
#~ "감마 분포. (*Not* 감마 함수가 *아닙*\\니다!) 매개"
#~ " 변수의 조건은 ``alpha > 0``\\과 ``beta "
#~ "> 0``\\입니다."

#~ msgid ""
#~ "In the future, the *seed* must be"
#~ " one of the following types: "
#~ ":class:`NoneType`, :class:`int`, :class:`float`, "
#~ ":class:`str`, :class:`bytes`, or :class:`bytearray`."
#~ msgstr ""
#~ "향후에, *seed*\\는 다음 형 중 하나여야 합니다:"
#~ " :class:`NoneType`, :class:`int`, :class:`float`, "
#~ ":class:`str`, :class:`bytes` 또는 :class:`bytearray`."

