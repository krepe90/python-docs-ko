# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/math.rst:2
#, fuzzy
msgid ":mod:`!math` --- Mathematical functions"
msgstr ":mod:`math` --- 수학 함수"

#: ../../library/math.rst:13
msgid ""
"This module provides access to the mathematical functions defined by the "
"C standard."
msgstr "이 모듈은 C 표준에서 정의된 수학 함수에 대한 액세스를 제공합니다."

#: ../../library/math.rst:16
msgid ""
"These functions cannot be used with complex numbers; use the functions of"
" the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex"
" numbers and those which don't is made since most users do not want to "
"learn quite as much mathematics as required to understand complex "
"numbers.  Receiving an exception instead of a complex result allows "
"earlier detection of the unexpected complex number used as a parameter, "
"so that the programmer can determine how and why it was generated in the "
"first place."
msgstr ""
"이 함수는 복소수와 함께 사용할 수 없습니다; 복소수를 지원해야 하면 :mod:`cmath` 모듈에 있는 같은 이름의 함수를 "
"사용하십시오. 대부분 사용자는 복소수를 이해하는 데 필요한 수준의 수학을 배우고 싶어 하지 않기 때문에 복소수를 지원하는 함수와 "
"그렇지 않은 함수를 구별했습니다. 복소수 결과 대신 예외를 수신하면 매개 변수로 사용된 예상치 못한 복소수를 조기에 감지할 수 있기"
" 때문에, 프로그래머는 처음 위치에서 생성된 경로와 원인을 파악할 수 있습니다."

#: ../../library/math.rst:25
msgid ""
"The following functions are provided by this module.  Except when "
"explicitly noted otherwise, all return values are floats."
msgstr "이 모듈에서 제공하는 함수는 다음과 같습니다. 달리 명시되지 않는 한 모든 반환 값은 float입니다."

#: ../../library/math.rst:30
#, fuzzy
msgid "**Number-theoretic functions**"
msgstr "수론 및 표현 함수"

#: ../../library/math.rst:32
msgid ":func:`comb(n, k) <comb>`"
msgstr ""

#: ../../library/math.rst:32
#, fuzzy
msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"without order"
msgstr "반복과 순서 없이 *n* 개의 항목에서 *k* 개의 항목을 선택하는 방법의 수를 반환합니다."

#: ../../library/math.rst:33
msgid ":func:`factorial(n) <factorial>`"
msgstr ""

#: ../../library/math.rst:33
msgid "*n* factorial"
msgstr ""

#: ../../library/math.rst:34
msgid ":func:`gcd(*integers) <gcd>`"
msgstr ""

#: ../../library/math.rst:34
msgid "Greatest common divisor of the integer arguments"
msgstr ""

#: ../../library/math.rst:35
msgid ":func:`isqrt(n) <isqrt>`"
msgstr ""

#: ../../library/math.rst:35
msgid "Integer square root of a nonnegative integer *n*"
msgstr ""

#: ../../library/math.rst:36
msgid ":func:`lcm(*integers) <lcm>`"
msgstr ""

#: ../../library/math.rst:36
msgid "Least common multiple of the integer arguments"
msgstr ""

#: ../../library/math.rst:37
msgid ":func:`perm(n, k) <perm>`"
msgstr ""

#: ../../library/math.rst:37
#, fuzzy
msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"with order"
msgstr "반복 없고 순서 있게 *n* 개의 항목에서 *k* 개의 항목을 선택하는 방법의 수를 반환합니다."

#: ../../library/math.rst:39
msgid "**Floating point arithmetic**"
msgstr ""

#: ../../library/math.rst:41
msgid ":func:`ceil(x) <ceil>`"
msgstr ""

#: ../../library/math.rst:41
msgid "Ceiling of *x*, the smallest integer greater than or equal to *x*"
msgstr ""

#: ../../library/math.rst:42
msgid ":func:`fabs(x) <fabs>`"
msgstr ""

#: ../../library/math.rst:42
#, fuzzy
msgid "Absolute value of *x*"
msgstr "*x*\\의 절댓값을 반환합니다."

#: ../../library/math.rst:43
msgid ":func:`floor(x)  <floor>`"
msgstr ""

#: ../../library/math.rst:43
msgid "Floor of *x*, the largest integer less than or equal to *x*"
msgstr ""

#: ../../library/math.rst:44
msgid ":func:`fma(x, y, z) <fma>`"
msgstr ""

#: ../../library/math.rst:44
msgid "Fused multiply-add operation: ``(x * y) + z``"
msgstr ""

#: ../../library/math.rst:45
msgid ":func:`fmod(x, y) <fmod>`"
msgstr ""

#: ../../library/math.rst:45
msgid "Remainder of division ``x / y``"
msgstr ""

#: ../../library/math.rst:46
msgid ":func:`modf(x) <modf>`"
msgstr ""

#: ../../library/math.rst:46
msgid "Fractional and integer parts of *x*"
msgstr ""

#: ../../library/math.rst:47
msgid ":func:`remainder(x, y) <remainder>`"
msgstr ""

#: ../../library/math.rst:47
msgid "Remainder of *x* with respect to *y*"
msgstr ""

#: ../../library/math.rst:48
msgid ":func:`trunc(x) <trunc>`"
msgstr ""

#: ../../library/math.rst:48
msgid "Integer part of *x*"
msgstr ""

#: ../../library/math.rst:50
msgid "**Floating point manipulation functions**"
msgstr ""

#: ../../library/math.rst:52
msgid ":func:`copysign(x, y) <copysign>`"
msgstr ""

#: ../../library/math.rst:52
msgid "Magnitude (absolute value) of *x* with the sign of *y*"
msgstr ""

#: ../../library/math.rst:53
msgid ":func:`frexp(x) <frexp>`"
msgstr ""

#: ../../library/math.rst:53
msgid "Mantissa and exponent of *x*"
msgstr ""

#: ../../library/math.rst:54
msgid ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"
msgstr ""

#: ../../library/math.rst:54
#, fuzzy
msgid "Check if the values *a* and *b* are close to each other"
msgstr "값 *a*\\와 *b*\\가 서로 가까이 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/math.rst:55
msgid ":func:`isfinite(x) <isfinite>`"
msgstr ""

#: ../../library/math.rst:55
msgid "Check if *x* is neither an infinity nor a NaN"
msgstr ""

#: ../../library/math.rst:56
msgid ":func:`isinf(x) <isinf>`"
msgstr ""

#: ../../library/math.rst:56
#, fuzzy
msgid "Check if *x* is a positive or negative infinity"
msgstr "*x*\\가 양 또는 음의 무한대이면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/math.rst:57
msgid ":func:`isnan(x) <isnan>`"
msgstr ""

#: ../../library/math.rst:57
#, fuzzy
msgid "Check if *x* is a NaN  (not a number)"
msgstr "*x*\\가 NaN(not a number)이면, *x*\\를 반환합니다."

#: ../../library/math.rst:58
msgid ":func:`ldexp(x, i) <ldexp>`"
msgstr ""

#: ../../library/math.rst:58
#, fuzzy
msgid "``x * (2**i)``, inverse of function :func:`frexp`"
msgstr "``x * (2**i)``\\를 반환합니다. 이것은 본질적으로 함수 :func:`frexp`\\의 역입니다."

#: ../../library/math.rst:59
msgid ":func:`nextafter(x, y, steps) <nextafter>`"
msgstr ""

#: ../../library/math.rst:59
#, fuzzy
msgid "Floating-point value *steps* steps after *x* towards *y*"
msgstr "*y*\\를 향한 *x* 다음의 부동 소수점 값을 반환합니다."

#: ../../library/math.rst:60
msgid ":func:`ulp(x) <ulp>`"
msgstr ""

#: ../../library/math.rst:60
#, fuzzy
msgid "Value of the least significant bit of *x*"
msgstr "float *x*\\의 최하위 비트 값을 반환합니다:"

#: ../../library/math.rst:62
#, fuzzy
msgid "**Power, exponential and logarithmic functions**"
msgstr "지수와 로그 함수"

#: ../../library/math.rst:64
msgid ":func:`cbrt(x) <cbrt>`"
msgstr ""

#: ../../library/math.rst:64
#, fuzzy
msgid "Cube root of *x*"
msgstr "*x*\\의 제곱근을 반환합니다."

#: ../../library/math.rst:65
msgid ":func:`exp(x) <exp>`"
msgstr ""

#: ../../library/math.rst:65
msgid "*e* raised to the power *x*"
msgstr ""

#: ../../library/math.rst:66
msgid ":func:`exp2(x) <exp2>`"
msgstr ""

#: ../../library/math.rst:66
msgid "*2* raised to the power *x*"
msgstr ""

#: ../../library/math.rst:67
msgid ":func:`expm1(x) <expm1>`"
msgstr ""

#: ../../library/math.rst:67
msgid "*e* raised to the power *x*, minus 1"
msgstr ""

#: ../../library/math.rst:68
msgid ":func:`log(x, base) <log>`"
msgstr ""

#: ../../library/math.rst:68
msgid "Logarithm of *x* to the given base (*e* by default)"
msgstr ""

#: ../../library/math.rst:69
msgid ":func:`log1p(x) <log1p>`"
msgstr ""

#: ../../library/math.rst:69
#, fuzzy
msgid "Natural logarithm of *1+x* (base *e*)"
msgstr "하나의 인자를 제공하면, *x*\\의 자연로그를 반환합니다 (밑 *e*)."

#: ../../library/math.rst:70
msgid ":func:`log2(x) <log2>`"
msgstr ""

#: ../../library/math.rst:70
msgid "Base-2 logarithm of *x*"
msgstr ""

#: ../../library/math.rst:71
msgid ":func:`log10(x) <log10>`"
msgstr ""

#: ../../library/math.rst:71
msgid "Base-10 logarithm of *x*"
msgstr ""

#: ../../library/math.rst:72
msgid ":func:`pow(x, y) <math.pow>`"
msgstr ""

#: ../../library/math.rst:72
msgid "*x* raised to the power *y*"
msgstr ""

#: ../../library/math.rst:73
msgid ":func:`sqrt(x) <sqrt>`"
msgstr ""

#: ../../library/math.rst:73
#, fuzzy
msgid "Square root of *x*"
msgstr "*x*\\의 제곱근을 반환합니다."

#: ../../library/math.rst:75
msgid "**Summation and product functions**"
msgstr ""

#: ../../library/math.rst:77
msgid ":func:`dist(p, q) <dist>`"
msgstr ""

#: ../../library/math.rst:77
#, fuzzy
msgid ""
"Euclidean distance between two points *p* and *q* given as an iterable of"
" coordinates"
msgstr ""
"각각 좌표 시퀀스(또는 이터러블)로 제공되는, 두 점 *p*\\와 *q* 사이의 유클리드 거리를 반환합니다. 두 점의 "
"차원(dimension)은 같아야 합니다."

#: ../../library/math.rst:78
msgid ":func:`fsum(iterable) <fsum>`"
msgstr ""

#: ../../library/math.rst:78
msgid "Sum of values in the input *iterable*"
msgstr ""

#: ../../library/math.rst:79
msgid ":func:`hypot(*coordinates) <hypot>`"
msgstr ""

#: ../../library/math.rst:79
msgid "Euclidean norm of an iterable of coordinates"
msgstr ""

#: ../../library/math.rst:80
msgid ":func:`prod(iterable, start) <prod>`"
msgstr ""

#: ../../library/math.rst:80
#, fuzzy
msgid "Product of elements in the input *iterable* with a *start* value"
msgstr "입력 *이터러블(iterable)*\\에 있는 모든 요소의 곱을 계산합니다. 곱의 기본 *start* 값은 ``1``\\입니다."

#: ../../library/math.rst:81
msgid ":func:`sumprod(p, q) <sumprod>`"
msgstr ""

#: ../../library/math.rst:81
msgid "Sum of products from two iterables *p* and *q*"
msgstr ""

#: ../../library/math.rst:83
#, fuzzy
msgid "**Angular conversion**"
msgstr "각도 변환"

#: ../../library/math.rst:85
msgid ":func:`degrees(x) <degrees>`"
msgstr ""

#: ../../library/math.rst:85
#, fuzzy
msgid "Convert angle *x* from radians to degrees"
msgstr "각도 *x*\\를 라디안에서 도(degree)로 변환합니다."

#: ../../library/math.rst:86
msgid ":func:`radians(x) <radians>`"
msgstr ""

#: ../../library/math.rst:86
#, fuzzy
msgid "Convert angle *x* from degrees to radians"
msgstr "각도 *x*\\를 도(degree)에서 라디안으로 변환합니다."

#: ../../library/math.rst:88
#, fuzzy
msgid "**Trigonometric functions**"
msgstr "삼각 함수"

#: ../../library/math.rst:90
msgid ":func:`acos(x) <acos>`"
msgstr ""

#: ../../library/math.rst:90
#, fuzzy
msgid "Arc cosine of *x*"
msgstr "*x*\\의 쌍곡 코사인(hyperbolic cosine)을 반환합니다."

#: ../../library/math.rst:91
msgid ":func:`asin(x) <asin>`"
msgstr ""

#: ../../library/math.rst:91
msgid "Arc sine of *x*"
msgstr ""

#: ../../library/math.rst:92
msgid ":func:`atan(x) <atan>`"
msgstr ""

#: ../../library/math.rst:92
#, fuzzy
msgid "Arc tangent of *x*"
msgstr "*x*\\의 쌍곡 탄젠트(hyperbolic tangent)를 반환합니다."

#: ../../library/math.rst:93
msgid ":func:`atan2(y, x) <atan2>`"
msgstr ""

#: ../../library/math.rst:93
msgid "``atan(y / x)``"
msgstr ""

#: ../../library/math.rst:94
msgid ":func:`cos(x) <cos>`"
msgstr ""

#: ../../library/math.rst:94
msgid "Cosine of *x*"
msgstr ""

#: ../../library/math.rst:95
msgid ":func:`sin(x) <sin>`"
msgstr ""

#: ../../library/math.rst:95
msgid "Sine of *x*"
msgstr ""

#: ../../library/math.rst:96
msgid ":func:`tan(x) <tan>`"
msgstr ""

#: ../../library/math.rst:96
msgid "Tangent of *x*"
msgstr ""

#: ../../library/math.rst:98
#, fuzzy
msgid "**Hyperbolic functions**"
msgstr "쌍곡선 함수"

#: ../../library/math.rst:100
msgid ":func:`acosh(x) <acosh>`"
msgstr ""

#: ../../library/math.rst:100
#, fuzzy
msgid "Inverse hyperbolic cosine of *x*"
msgstr "*x*\\의 역 쌍곡 코사인(inverse hyperbolic cosine)을 반환합니다."

#: ../../library/math.rst:101
msgid ":func:`asinh(x) <asinh>`"
msgstr ""

#: ../../library/math.rst:101
#, fuzzy
msgid "Inverse hyperbolic sine of *x*"
msgstr "*x*\\의 역 쌍곡 사인(inverse hyperbolic sine)을 반환합니다."

#: ../../library/math.rst:102
msgid ":func:`atanh(x) <atanh>`"
msgstr ""

#: ../../library/math.rst:102
#, fuzzy
msgid "Inverse hyperbolic tangent of *x*"
msgstr "*x*\\의 역 쌍곡 탄젠트(inverse hyperbolic tangent)를 반환합니다."

#: ../../library/math.rst:103
msgid ":func:`cosh(x) <cosh>`"
msgstr ""

#: ../../library/math.rst:103
#, fuzzy
msgid "Hyperbolic cosine of *x*"
msgstr "*x*\\의 쌍곡 코사인(hyperbolic cosine)을 반환합니다."

#: ../../library/math.rst:104
msgid ":func:`sinh(x) <sinh>`"
msgstr ""

#: ../../library/math.rst:104
#, fuzzy
msgid "Hyperbolic sine of *x*"
msgstr "*x*\\의 쌍곡 사인(hyperbolic sine)을 반환합니다."

#: ../../library/math.rst:105
msgid ":func:`tanh(x) <tanh>`"
msgstr ""

#: ../../library/math.rst:105
#, fuzzy
msgid "Hyperbolic tangent of *x*"
msgstr "*x*\\의 쌍곡 탄젠트(hyperbolic tangent)를 반환합니다."

#: ../../library/math.rst:107
#, fuzzy
msgid "**Special functions**"
msgstr "특수 함수"

#: ../../library/math.rst:109
msgid ":func:`erf(x) <erf>`"
msgstr ""

#: ../../library/math.rst:109
#, fuzzy
msgid "`Error function <https://en.wikipedia.org/wiki/Error_function>`_ at *x*"
msgstr ""
"*x*\\의 `오차 함수(error function) "
"<https://en.wikipedia.org/wiki/Error_function>`_\\를 반환합니다."

#: ../../library/math.rst:110
msgid ":func:`erfc(x) <erfc>`"
msgstr ""

#: ../../library/math.rst:110
#, fuzzy
msgid ""
"`Complementary error function "
"<https://en.wikipedia.org/wiki/Error_function>`_ at *x*"
msgstr ""
"*x*\\의 `오차 함수(error function) "
"<https://en.wikipedia.org/wiki/Error_function>`_\\를 반환합니다."

#: ../../library/math.rst:111
msgid ":func:`gamma(x) <gamma>`"
msgstr ""

#: ../../library/math.rst:111
#, fuzzy
msgid "`Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr ""
"*x*\\의 `감마 함수(Gamma function) "
"<https://en.wikipedia.org/wiki/Gamma_function>`_\\를 반환합니다."

#: ../../library/math.rst:112
msgid ":func:`lgamma(x) <lgamma>`"
msgstr ""

#: ../../library/math.rst:112
#, fuzzy
msgid ""
"Natural logarithm of the absolute value of the `Gamma function "
"<https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr ""
"*x*\\의 `감마 함수(Gamma function) "
"<https://en.wikipedia.org/wiki/Gamma_function>`_\\를 반환합니다."

#: ../../library/math.rst:114
#, fuzzy
msgid "**Constants**"
msgstr "상수"

#: ../../library/math.rst:116
msgid ":data:`pi`"
msgstr ""

#: ../../library/math.rst:116
msgid "*π* = 3.141592..."
msgstr ""

#: ../../library/math.rst:117
msgid ":data:`e`"
msgstr ""

#: ../../library/math.rst:117
msgid "*e* = 2.718281..."
msgstr ""

#: ../../library/math.rst:118
msgid ":data:`tau`"
msgstr ""

#: ../../library/math.rst:118
msgid "*τ* = 2\\ *π* = 6.283185..."
msgstr ""

#: ../../library/math.rst:119
msgid ":data:`inf`"
msgstr ""

#: ../../library/math.rst:119
msgid "Positive infinity"
msgstr ""

#: ../../library/math.rst:120
msgid ":data:`nan`"
msgstr ""

#: ../../library/math.rst:120
msgid "\"Not a number\" (NaN)"
msgstr ""

#: ../../library/math.rst:125
#, fuzzy
msgid "Number-theoretic functions"
msgstr "수론 및 표현 함수"

#: ../../library/math.rst:129
msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and without order."
msgstr "반복과 순서 없이 *n* 개의 항목에서 *k* 개의 항목을 선택하는 방법의 수를 반환합니다."

#: ../../library/math.rst:132
msgid ""
"Evaluates to ``n! / (k! * (n - k)!)`` when ``k <= n`` and evaluates to "
"zero when ``k > n``."
msgstr "``k <= n``\\이면 ``n! / (k! * (n - k)!)``\\로 평가되고, ``k > n``\\이면 0으로 평가됩니다."

#: ../../library/math.rst:135
#, fuzzy
msgid ""
"Also called the binomial coefficient because it is equivalent to the "
"coefficient of k-th term in polynomial expansion of ``(1 + x)ⁿ``."
msgstr ""
"식 ``(1 + x) ** n``\\의 다항식 전개에서 k 번째 항의 계수와 같기 때문에 이항 계수(binomial "
"coefficient)라고도 합니다."

#: ../../library/math.rst:139 ../../library/math.rst:205
msgid ""
"Raises :exc:`TypeError` if either of the arguments are not integers. "
"Raises :exc:`ValueError` if either of the arguments are negative."
msgstr ""
"인자 중 어느 하나라도 정수가 아니면 :exc:`TypeError`\\를 발생시킵니다. 인자 중 어느 하나라도 음수이면 "
":exc:`ValueError`\\를 발생시킵니다."

#: ../../library/math.rst:147
#, fuzzy
msgid ""
"Return *n* factorial as an integer.  Raises :exc:`ValueError` if *n* is "
"not integral or is negative."
msgstr ""
"*x* 계승(factorial)을 정수로 반환합니다. *x*\\가 정수(integral)가 아니거나 음수면 "
":exc:`ValueError`\\를 발생시킵니다."

#: ../../library/math.rst:150
#, fuzzy
msgid "Floats with integral values (like ``5.0``) are no longer accepted."
msgstr "정숫값 부동 소수점(``5.0``\\과 같은)을 허용하는 것은 폐지되었습니다."

#: ../../library/math.rst:156
msgid ""
"Return the greatest common divisor of the specified integer arguments. If"
" any of the arguments is nonzero, then the returned value is the largest "
"positive integer that is a divisor of all arguments.  If all arguments "
"are zero, then the returned value is ``0``.  ``gcd()`` without arguments "
"returns ``0``."
msgstr ""
"지정된 정수 인자의 최대 공약수를 반환합니다. 인자 중 하나가 0이 아니면, 반환된 값은 모든 인자를 나누는 가장 큰 양의 "
"정수입니다. 모든 인자가 0이면, 반환 값은 ``0``\\입니다. 인자가 없는 ``gcd()``\\는 ``0``\\을 반환합니다."

#: ../../library/math.rst:164
msgid ""
"Added support for an arbitrary number of arguments. Formerly, only two "
"arguments were supported."
msgstr "임의의 개수 인자에 대한 지원이 추가되었습니다. 이전에는, 단지 두 개의 인자만 지원되었습니다."

#: ../../library/math.rst:171
msgid ""
"Return the integer square root of the nonnegative integer *n*. This is "
"the floor of the exact square root of *n*, or equivalently the greatest "
"integer *a* such that *a*\\ ² |nbsp| ≤ |nbsp| *n*."
msgstr ""
"음이 아닌 정수 *n*\\의 정수 제곱근을 반환합니다. 이것은 *n*\\의 정확한 제곱근의 바닥(floor)입니다, 또는, "
"동등하게, *a*\\ ² |nbsp| ≤ |nbsp| *n*\\을 만족하는 가장 큰 정수 *a*\\입니다."

#: ../../library/math.rst:175
msgid ""
"For some applications, it may be more convenient to have the least "
"integer *a* such that *n* |nbsp| ≤ |nbsp| *a*\\ ², or in other words the "
"ceiling of the exact square root of *n*. For positive *n*, this can be "
"computed using ``a = 1 + isqrt(n - 1)``."
msgstr ""
"일부 응용 프로그램에서는, *n* |nbsp| ≤ |nbsp| *a*\\ ² 을 만족하는 가장 작은 정수 *a*, 즉 *n*\\의 "
"정확한 제곱근의 천장(ceiling)을 구하는 것이 더 편리합니다. 양의 *n*\\에 대해, 이것은 ``a = 1 + isqrt(n"
" - 1)``\\을 사용하여 계산할 수 있습니다."

#: ../../library/math.rst:185
msgid ""
"Return the least common multiple of the specified integer arguments. If "
"all arguments are nonzero, then the returned value is the smallest "
"positive integer that is a multiple of all arguments.  If any of the "
"arguments is zero, then the returned value is ``0``.  ``lcm()`` without "
"arguments returns ``1``."
msgstr ""
"지정된 정수 인자의 최소 공배수를 반환합니다. 모든 인자가 0이 아니면, 반환 값은 모든 인자의 배수인 가장 작은 양의 정수입니다."
" 인자 중 어느 하나가 0이면, 반환 값은 ``0``\\입니다. 인자가 없는 ``lcm()``\\은 ``1``\\을 반환합니다."

#: ../../library/math.rst:196
msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and with order."
msgstr "반복 없고 순서 있게 *n* 개의 항목에서 *k* 개의 항목을 선택하는 방법의 수를 반환합니다."

#: ../../library/math.rst:199
msgid ""
"Evaluates to ``n! / (n - k)!`` when ``k <= n`` and evaluates to zero when"
" ``k > n``."
msgstr "``k <= n``\\이면 ``n! / (n - k)!`` 로 평가되고, ``k > n``\\이면 0으로 평가됩니다."

#: ../../library/math.rst:202
#, fuzzy
msgid ""
"If *k* is not specified or is ``None``, then *k* defaults to *n* and the "
"function returns ``n!``."
msgstr "*k*\\가 지정되지 않거나 None이면, *k*\\의 기본값은 *n*\\이고 함수는 ``n!`` 을 반환합니다."

#: ../../library/math.rst:212
msgid "Floating point arithmetic"
msgstr ""

#: ../../library/math.rst:216
#, fuzzy
msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to :meth:`x.__ceil__ "
"<object.__ceil__>`, which should return an :class:`~numbers.Integral` "
"value."
msgstr ""
"*x*\\보다 크거나 같은 가장 작은 정수인 *x*\\의 천장값(ceiling)을 반환합니다. *x*\\가 float가 아니면, "
"``x.__ceil__()``\\에 위임하고, 이것은 :class:`~numbers.Integral` 값을 반환해야 합니다."

#: ../../library/math.rst:223
msgid "Return the absolute value of *x*."
msgstr "*x*\\의 절댓값을 반환합니다."

#: ../../library/math.rst:228
#, fuzzy
msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*.  "
"If *x* is not a float, delegates to :meth:`x.__floor__ "
"<object.__floor__>`, which should return an :class:`~numbers.Integral` "
"value."
msgstr ""
"*x*\\보다 작거나 같은 가장 큰 정수인 *x*\\의 바닥값(floor)을 반환합니다. *x*\\가 float가 아니면, "
"``x.__floor__()``\\에 위임하고, 이것은 :class:`~numbers.Integral` 값을 반환해야 합니다."

#: ../../library/math.rst:235
msgid ""
"Fused multiply-add operation. Return ``(x * y) + z``, computed as though "
"with infinite precision and range followed by a single round to the "
"``float`` format. This operation often provides better accuracy than the "
"direct expression ``(x * y) + z``."
msgstr ""

#: ../../library/math.rst:240
msgid ""
"This function follows the specification of the fusedMultiplyAdd operation"
" described in the IEEE 754 standard. The standard leaves one case "
"implementation-defined, namely the result of ``fma(0, inf, nan)`` and "
"``fma(inf, 0, nan)``. In these cases, ``math.fma`` returns a NaN, and "
"does not raise any exception."
msgstr ""

#: ../../library/math.rst:251
#, fuzzy, python-format
msgid ""
"Return the floating-point remainder of ``x / y``, as defined by the "
"platform C library function ``fmod(x, y)``. Note that the Python "
"expression ``x % y`` may not return the same result.  The intent of the C"
" standard is that ``fmod(x, y)`` be exactly (mathematically; to infinite "
"precision) equal to ``x - n*y`` for some integer *n* such that the result"
" has the same sign as *x* and magnitude less than ``abs(y)``.  Python's "
"``x % y`` returns a result with the sign of *y* instead, and may not be "
"exactly computable for float arguments. For example, ``fmod(-1e-100, "
"1e100)`` is ``-1e-100``, but the result of Python's ``-1e-100 % 1e100`` "
"is ``1e100-1e-100``, which cannot be represented exactly as a float, and "
"rounds to the surprising ``1e100``.  For this reason, function "
":func:`fmod` is generally preferred when working with floats, while "
"Python's ``x % y`` is preferred when working with integers."
msgstr ""
"플랫폼 C 라이브러리에서 정의한 대로 ``fmod(x, y)``\\를 반환합니다. 파이썬 표현식 ``x % y``\\가 같은 결과를"
" 반환하지 않을 수 있음에 유의하십시오. C 표준의 의도는 어떤 정수 *n*\\에 대해 ``fmod(x, y)``\\가 ``x - "
"n*y``\\와 정확히 (수학적으로; 무한 정밀도로) 같고, 결과는 *x*\\와 같은 부호를 가지며 크기(절댓값)는 "
"``abs(y)``\\보다 작아지도록 하는 것입니다. 파이썬의 ``x % y``\\는 대신 *y*\\의 부호를 갖는 결과를 반환하며"
" float 인자에 대해 정확하게 계산할 수 없을 수 있습니다. 예를 들어, ``fmod(-1e-100, 1e100)``\\는 "
"``-1e-100``\\이지만, 파이썬의 ``-1e-100 % 1e100``\\의 결과는 ``1e100-1e-100``\\이며, "
"부동 소수점으로 정확하게 표현할 수 없어서, 의외의 ``1e100``\\으로 반올림됩니다. 이러한 이유로, 함수 "
":func:`fmod`\\는 일반적으로 float로 작업할 때 선호되는 반면 파이썬의 ``x % y``\\는 정수로 작업할 때 "
"선호됩니다."

#: ../../library/math.rst:267
msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the "
"sign of *x* and are floats."
msgstr "*x*\\의 소수와 정수 부분을 반환합니다. 두 결과 모두 *x*\\의 부호를 가지며 float입니다."

#: ../../library/math.rst:270
#, fuzzy
msgid ""
"Note that :func:`modf` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, "
"rather than returning its second return value through an 'output "
"parameter' (there is no such thing in Python)."
msgstr ""
":func:`frexp`\\와 :func:`modf`\\는 C 대응물과는 다른 호출/반환 패턴을 가지고 있습니다: 두 번째 반환 "
"값을 '출력 매개 변수'로 반환하는 대신 (파이썬에는 그러한 것이 없습니다), 단일 인자를 받아서 값의 쌍을 반환합니다."

#: ../../library/math.rst:278
msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For "
"finite *x* and finite nonzero *y*, this is the difference ``x - n*y``, "
"where ``n`` is the closest integer to the exact value of the quotient ``x"
" / y``.  If ``x / y`` is exactly halfway between two consecutive "
"integers, the nearest *even* integer is used for ``n``.  The remainder "
"``r = remainder(x, y)`` thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"*y*\\에 대한 *x*\\의 IEEE 754 스타일 나머지를 반환합니다. 유한한 *x* 와 0이 아닌 유한한 *y*\\에 대해, "
"이것은 차이 ``x - n*y``\\입니다. 여기서 ``n``\\은 몫 ``x / y``\\의 정확한 값에 가장 가까운 정수입니다."
" ``x / y``\\가 두 개의 인접한 정수 사이의 정확히 중간이면, 가장 가까운 *짝수* 정수가 ``n``\\으로 사용됩니다. "
"따라서 나머지 ``r = remainder(x, y)``\\는 항상 ``abs(r) <= 0.5 * abs(y)``\\를 "
"만족합니다."

#: ../../library/math.rst:285
msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` "
"is *x* for any finite *x*, and ``remainder(x, 0)`` and "
"``remainder(math.inf, x)`` raise :exc:`ValueError` for any non-NaN *x*. "
"If the result of the remainder operation is zero, that zero will have the"
" same sign as *x*."
msgstr ""
"IEEE 754에 따른 특별한 경우: 특히, ``remainder(x, math.inf)``\\는 모든 유한한 *x*\\에 대해서는"
" *x*\\이고, ``remainder(x, 0)``\\과 ``remainder(math.inf, x)``\\는 모든 NaN이 아닌"
" *x*\\에 대해 :exc:`ValueError`\\를 발생시킵니다. 나머지 연산의 결과가 0이면, 해당 0은 *x* 와 같은 "
"부호를 갖습니다."

#: ../../library/math.rst:291
#, fuzzy
msgid ""
"On platforms using IEEE 754 binary floating point, the result of this "
"operation is always exactly representable: no rounding error is "
"introduced."
msgstr ""
"IEEE 754 이진 부동 소수점을 사용하는 플랫폼에서, 이 연산의 결과는 항상 정확하게 표현 가능합니다: 자리 올림 오차는 "
"발생하지 않습니다."

#: ../../library/math.rst:299
msgid ""
"Return *x* with the fractional part removed, leaving the integer part.  "
"This rounds toward 0: ``trunc()`` is equivalent to :func:`floor` for "
"positive *x*, and equivalent to :func:`ceil` for negative *x*. If *x* is "
"not a float, delegates to :meth:`x.__trunc__ <object.__trunc__>`, which "
"should return an :class:`~numbers.Integral` value."
msgstr ""

#: ../../library/math.rst:306
msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note "
"that *all* floating-point numbers of sufficiently large magnitude are "
"exact integers. Python floats typically carry no more than 53 bits of "
"precision (the same as the platform C double type), in which case any "
"float *x* with ``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""
":func:`ceil`, :func:`floor` 및 :func:`modf` 함수의 경우, 충분히 큰 절댓값을 갖는 *모든* 부동 "
"소수점 숫자는 정확한 정수입니다. 파이썬 float는 일반적으로 53비트 이하의 정밀도를 가지는데 (플랫폼 C double 형과 "
"같습니다), 이때 ``abs(x) >= 2**52``\\를 만족하는 모든 float *x*\\는 소수 비트를 갖지 않습니다."

#: ../../library/math.rst:314
msgid "Floating point manipulation functions"
msgstr ""

#: ../../library/math.rst:318
msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of"
" *y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"*x*\\의 크기(절댓값)와 *y*\\의 부호를 갖는 float를 반환합니다. 부호 있는 0을 지원하는 플랫폼에서, "
"``copysign(1.0, -0.0)``\\은 *-1.0*\\을 반환합니다."

#: ../../library/math.rst:325
msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a"
" float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* "
"is zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is "
"used to \"pick apart\" the internal representation of a float in a "
"portable way."
msgstr ""
"*x*\\의 가수(mantissa)와 지수(exponent)를 ``(m, e)`` 쌍으로 반환합니다. *m*\\은 float이고, "
"*e*\\는 정수이며, 정확히 ``x == m * 2**e``\\가 성립합니다. *x*\\가 0이면, ``(0.0, 0)``\\을 "
"반환하고, 그렇지 않으면 ``0.5 <= abs(m) < 1``\\입니다. 이것은 float의 내부 표현을 이식성 있는 방식으로 "
"\"분리\"하는 데 사용됩니다."

#: ../../library/math.rst:330
#, fuzzy
msgid ""
"Note that :func:`frexp` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, "
"rather than returning its second return value through an 'output "
"parameter' (there is no such thing in Python)."
msgstr ""
":func:`frexp`\\와 :func:`modf`\\는 C 대응물과는 다른 호출/반환 패턴을 가지고 있습니다: 두 번째 반환 "
"값을 '출력 매개 변수'로 반환하는 대신 (파이썬에는 그러한 것이 없습니다), 단일 인자를 받아서 값의 쌍을 반환합니다."

#: ../../library/math.rst:337
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr "값 *a*\\와 *b*\\가 서로 가까이 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/math.rst:340
#, fuzzy
msgid ""
"Whether or not two values are considered close is determined according to"
" given absolute and relative tolerances.  If no errors occur, the result "
"will be: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."
msgstr "두 값이 근접한 것으로 간주하는지는 주어진 절대와 상대 허용 오차에 따라 결정됩니다."

#: ../../library/math.rst:344
#, fuzzy
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed "
"difference between *a* and *b*, relative to the larger absolute value of "
"*a* or *b*. For example, to set a tolerance of 5%, pass ``rel_tol=0.05``."
"  The default tolerance is ``1e-09``, which assures that the two values "
"are the same within about 9 decimal digits.  *rel_tol* must be "
"nonnegative and less than ``1.0``."
msgstr ""
"*rel_tol*\\은 상대 허용 오차입니다 -- *a*\\와 *b* 중 더 큰 절댓값에 대해 상대적으로, *a*\\와 *b* 간에"
" 허용되는 최대 차이입니다. 예를 들어, 허용 오차를 5%로 설정하려면, ``rel_tol=0.05``\\를 전달하십시오. 기본 "
"허용 오차는 ``1e-09``\\이며, 두 값이 약 9자리 십진 숫자 내에서 같다는 것을 보장합니다. *rel_tol*\\은 0보다"
" 커야 합니다."

#: ../../library/math.rst:351
msgid ""
"*abs_tol* is the absolute tolerance; it defaults to ``0.0`` and it must "
"be nonnegative.  When comparing ``x`` to ``0.0``, ``isclose(x, 0)`` is "
"computed as ``abs(x) <= rel_tol  * abs(x)``, which is ``False`` for any "
"nonzero ``x`` and *rel_tol* less than ``1.0``.  So add an appropriate "
"positive *abs_tol* argument to the call."
msgstr ""

#: ../../library/math.rst:357
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered"
" close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are "
"only considered close to themselves."
msgstr ""
"IEEE 754 특수 값 ``NaN``, ``inf`` 및 ``-inf``\\는 IEEE 규칙에 따라 처리됩니다. 특히, "
"``NaN``\\은 ``NaN``\\을 포함하여 다른 어떤 값과도 근접한 것으로 간주하지 않습니다. ``inf``\\와 "
"``-inf``\\는 오직 자신과만 가까운 것으로 간주합니다."

#: ../../library/math.rst:366
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- 근사적 동등성을 검사하는 함수"

#: ../../library/math.rst:371
msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"*x*\\가 무한대나 NaN이 아니면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. (``0.0``\\은"
" *유한*\\한 것으로 간주합니다.)"

#: ../../library/math.rst:379
msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr "*x*\\가 양 또는 음의 무한대이면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/math.rst:385
msgid "Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr "*x*\\가 NaN(not a number)이면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/math.rst:390
msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function "
":func:`frexp`."
msgstr "``x * (2**i)``\\를 반환합니다. 이것은 본질적으로 함수 :func:`frexp`\\의 역입니다."

#: ../../library/math.rst:396
#, fuzzy
msgid "Return the floating-point value *steps* steps after *x* towards *y*."
msgstr "*y*\\를 향한 *x* 다음의 부동 소수점 값을 반환합니다."

#: ../../library/math.rst:398
#, fuzzy
msgid "If *x* is equal to *y*, return *y*, unless *steps* is zero."
msgstr "*x*\\가 *y*\\와 같으면, *y*\\를 반환합니다."

#: ../../library/math.rst:400
msgid "Examples:"
msgstr "예:"

#: ../../library/math.rst:402
msgid "``math.nextafter(x, math.inf)`` goes up: towards positive infinity."
msgstr "``math.nextafter(x, math.inf)``\\는 올라갑니다: 양의 무한대를 향해."

#: ../../library/math.rst:403
msgid "``math.nextafter(x, -math.inf)`` goes down: towards minus infinity."
msgstr "``math.nextafter(x, -math.inf)``\\는 내려갑니다: 음의 무한대를 향해."

#: ../../library/math.rst:404
msgid "``math.nextafter(x, 0.0)`` goes towards zero."
msgstr "``math.nextafter(x, 0.0)``\\는 0을 향합니다."

#: ../../library/math.rst:405
msgid "``math.nextafter(x, math.copysign(math.inf, x))`` goes away from zero."
msgstr "``math.nextafter(x, math.copysign(math.inf, x))``\\는 0에서 멀어집니다."

#: ../../library/math.rst:407
msgid "See also :func:`math.ulp`."
msgstr ":func:`math.ulp`\\도 참조하십시오."

#: ../../library/math.rst:411
msgid "Added the *steps* argument."
msgstr ""

#: ../../library/math.rst:417
msgid "Return the value of the least significant bit of the float *x*:"
msgstr "float *x*\\의 최하위 비트 값을 반환합니다:"

#: ../../library/math.rst:419
msgid "If *x* is a NaN (not a number), return *x*."
msgstr "*x*\\가 NaN(not a number)이면, *x*\\를 반환합니다."

#: ../../library/math.rst:420
msgid "If *x* is negative, return ``ulp(-x)``."
msgstr "*x*\\가 음수이면, ``ulp(-x)``\\를 반환합니다."

#: ../../library/math.rst:421
msgid "If *x* is a positive infinity, return *x*."
msgstr "*x*\\가 양의 무한대이면, *x*\\를 반환합니다."

#: ../../library/math.rst:422
msgid ""
"If *x* is equal to zero, return the smallest positive *denormalized* "
"representable float (smaller than the minimum positive *normalized* "
"float, :data:`sys.float_info.min <sys.float_info>`)."
msgstr ""
"*x*\\가 0과 같으면, 가장 작은 양의 *정규화되지 않은(denormalized)* 표현 가능한 float를 반환합니다 (가장 "
"작은 양의 *정규화된* float, :data:`sys.float_info.min <sys.float_info>`\\보다 "
"작습니다)."

#: ../../library/math.rst:425
msgid ""
"If *x* is equal to the largest positive representable float, return the "
"value of the least significant bit of *x*, such that the first float "
"smaller than *x* is ``x - ulp(x)``."
msgstr ""
"*x*\\가 가장 큰 양의 표현 가능한 float와 같으면, *x*\\보다 작은 첫 번째 float가 ``x - "
"ulp(x)``\\가 되도록, *x*\\의 최하위 비트 값을 반환합니다."

#: ../../library/math.rst:428
msgid ""
"Otherwise (*x* is a positive finite number), return the value of the "
"least significant bit of *x*, such that the first float bigger than *x* "
"is ``x + ulp(x)``."
msgstr ""
"그렇지 않으면 (*x*\\가 양의 유한 수이면), *x*\\보다 큰 첫 번째 float가 ``x + ulp(x)``\\가 되도록, "
"*x*\\의 최하위 비트 값을 반환합니다."

#: ../../library/math.rst:432
msgid "ULP stands for \"Unit in the Last Place\"."
msgstr "ULP는 \"Unit in the Last Place(마지막 자리의 단위)\"를 나타냅니다."

#: ../../library/math.rst:434
msgid ""
"See also :func:`math.nextafter` and :data:`sys.float_info.epsilon "
"<sys.float_info>`."
msgstr ""
":func:`math.nextafter`\\와 :data:`sys.float_info.epsilon "
"<sys.float_info>`\\도 참조하십시오."

#: ../../library/math.rst:441
#, fuzzy
msgid "Power, exponential and logarithmic functions"
msgstr "지수와 로그 함수"

#: ../../library/math.rst:445
#, fuzzy
msgid "Return the cube root of *x*."
msgstr "*x*\\의 제곱근을 반환합니다."

#: ../../library/math.rst:452
msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base "
"of natural logarithms.  This is usually more accurate than ``math.e ** "
"x`` or ``pow(math.e, x)``."
msgstr ""
"*e*\\의 *x* 거듭제곱을 반환합니다. 여기서 *e* = 2.718281... 는 자연로그의 밑(base)입니다. 일반적으로 "
"``math.e ** x``\\나 ``pow(math.e, x)``\\보다 정확합니다."

#: ../../library/math.rst:459
msgid "Return *2* raised to the power *x*."
msgstr ""

#: ../../library/math.rst:466
#, fuzzy
msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - "
"1`` can result in a `significant loss of precision "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; the "
":func:`expm1` function provides a way to compute this quantity to full "
"precision:"
msgstr ""
"*e*\\의 *x* 거듭제곱에서 1을 뺀 값을 반환합니다. 여기서 *e*\\는 자연로그의 밑(base)입니다. 작은 float "
"*x*\\의 경우, ``exp(x) - 1``\\의 뺄셈은 `상당한 정밀도 소실 "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\을 일으킬 수 있습니다; "
":func:`expm1` 함수는 이 양을 최대 정밀도로 계산하는 방법을 제공합니다::"

#: ../../library/math.rst:483
msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr "하나의 인자를 제공하면, *x*\\의 자연로그를 반환합니다 (밑 *e*)."

#: ../../library/math.rst:485
msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""
"두 개의 인자를 제공하면, 주어진 *밑(base)*\\으로 *x*\\의 로그를 반환합니다, "
"``log(x)/log(base)``\\로 계산합니다."

#: ../../library/math.rst:491
msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is "
"calculated in a way which is accurate for *x* near zero."
msgstr "*1+x*\\의 자연로그를 반환합니다 (밑 *e*). 결과는 0에 가까운 *x*\\에 대해 정확한 방식으로 계산됩니다."

#: ../../library/math.rst:497
msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr "*x*\\의 밑이 2인 로그를 반환합니다. 이것은 일반적으로 ``log(x, 2)``\\보다 정확합니다."

#: ../../library/math.rst:504
msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent "
"an integer in binary, excluding the sign and leading zeros."
msgstr ":meth:`int.bit_length`\\는 부호와 선행 0을 제외하고 정수를 이진수로 나타내는 데 필요한 비트 수를 반환합니다."

#: ../../library/math.rst:510
msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr "*x*\\의 밑이 10인 로그를 반환합니다. 이것은 일반적으로 ``log(x, 10)``\\보다 정확합니다."

#: ../../library/math.rst:516
#, fuzzy
msgid ""
"Return *x* raised to the power *y*.  Exceptional cases follow the IEEE "
"754 standard as far as possible.  In particular, ``pow(1.0, x)`` and "
"``pow(x, 0.0)`` always return ``1.0``, even when *x* is a zero or a NaN."
"  If both *x* and *y* are finite, *x* is negative, and *y* is not an "
"integer then ``pow(x, y)`` is undefined, and raises :exc:`ValueError`."
msgstr ""
"``x``\\의 ``y`` 거듭제곱을 반환합니다. 예외적인 경우는 최대한 C99 표준의 부록 'F'를 따릅니다. 특히, "
"``x``\\가 0이거나 NaN일 때도 ``pow(1.0, x)``\\와 ``pow(x, 0.0)``\\는 항상 ``1.0``\\을"
" 반환합니다. ``x`` 와 ``y``\\가 모두 유한하고, ``x``\\가 음수이고, ``y``\\가 정수가 아니면 "
"``pow(x, y)``\\는 정의되지 않고 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/math.rst:523
msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow`"
" function for computing exact integer powers."
msgstr ""
"내장 ``**`` 연산자와 달리, :func:`math.pow`\\는 두 인자를 모두 :class:`float` 형으로 변환합니다."
" 정확한 정수 거듭제곱을 계산하려면 ``**``\\나 내장 :func:`pow` 함수를 사용하십시오."

#: ../../library/math.rst:527
msgid ""
"The special cases ``pow(0.0, -inf)`` and ``pow(-0.0, -inf)`` were changed"
" to return ``inf`` instead of raising :exc:`ValueError`, for consistency "
"with IEEE 754."
msgstr ""

#: ../../library/math.rst:535
msgid "Return the square root of *x*."
msgstr "*x*\\의 제곱근을 반환합니다."

#: ../../library/math.rst:539
msgid "Summation and product functions"
msgstr ""

#: ../../library/math.rst:543
msgid ""
"Return the Euclidean distance between two points *p* and *q*, each given "
"as a sequence (or iterable) of coordinates.  The two points must have the"
" same dimension."
msgstr ""
"각각 좌표 시퀀스(또는 이터러블)로 제공되는, 두 점 *p*\\와 *q* 사이의 유클리드 거리를 반환합니다. 두 점의 "
"차원(dimension)은 같아야 합니다."

#: ../../library/math.rst:547 ../../library/math.rst:608
msgid "Roughly equivalent to::"
msgstr "대략 다음과 동등합니다::"

#: ../../library/math.rst:549
msgid "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"
msgstr ""

#: ../../library/math.rst:556
#, fuzzy
msgid ""
"Return an accurate floating-point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums."
msgstr ""
"이터러블(iterable)에 있는 값의 정확한(accurate) 부동 소수점 합을 반환합니다. 여러 중간 부분 합을 추적하여 정밀도"
" 손실을 방지합니다::"

#: ../../library/math.rst:559
msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and "
"the typical case where the rounding mode is half-even.  On some non-"
"Windows builds, the underlying C library uses extended precision addition"
" and may occasionally double-round an intermediate sum causing it to be "
"off in its least significant bit."
msgstr ""
"알고리즘의 정확도는 IEEE-754 산술의 보증과 자리 올림 모드가 짝수로 반올림(half-even)인 일반적인 경우에 의존합니다."
" 윈도우 이외의 일부 빌드에서, 하부 C 라이브러리는 확장 정밀도 덧셈을 사용하고, 때때로 중간 합을 이중 자리 올림(double-"
"round) 하여 최하위 비트(least significant bit)에서 분리할 수 있습니다."

#: ../../library/math.rst:565
#, fuzzy
msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating-point summation "
"<https://code.activestate.com/recipes/393090-binary-floating-point-"
"summation-accurate-to-full-p/>`_\\."
msgstr ""
"자세한 논의와 두 가지 대안은, `ASPN cookbook recipes for accurate floating point "
"summation <https://code.activestate.com/recipes/393090/>`_\\을 참조하십시오."

#: ../../library/math.rst:572
msgid ""
"Return the Euclidean norm, ``sqrt(sum(x**2 for x in coordinates))``. This"
" is the length of the vector from the origin to the point given by the "
"coordinates."
msgstr ""
"유클리드 크기(norm) ``sqrt(sum(x**2 for x in coordinates))``\\를 반환합니다. 원점에서 "
"coordinates로 지정된 점까지의 벡터의 길이입니다."

#: ../../library/math.rst:576
msgid ""
"For a two dimensional point ``(x, y)``, this is equivalent to computing "
"the hypotenuse of a right triangle using the Pythagorean theorem, "
"``sqrt(x*x + y*y)``."
msgstr ""
"2차원 점 ``(x, y)``\\의 경우, 피타고라스 정리를 사용하여 직각 삼각형의 빗변(hypotenuse)을 계산하는 것과 "
"동등합니다, ``sqrt(x*x + y*y)``."

#: ../../library/math.rst:580
msgid ""
"Added support for n-dimensional points. Formerly, only the two "
"dimensional case was supported."
msgstr "n 차원 점에 대한 지원이 추가되었습니다. 이전에는, 2차원인 경우만 지원되었습니다."

#: ../../library/math.rst:584
msgid ""
"Improved the algorithm's accuracy so that the maximum error is under 1 "
"ulp (unit in the last place).  More typically, the result is almost "
"always correctly rounded to within 1/2 ulp."
msgstr ""

#: ../../library/math.rst:592
msgid ""
"Calculate the product of all the elements in the input *iterable*. The "
"default *start* value for the product is ``1``."
msgstr "입력 *이터러블(iterable)*\\에 있는 모든 요소의 곱을 계산합니다. 곱의 기본 *start* 값은 ``1``\\입니다."

#: ../../library/math.rst:595
msgid ""
"When the iterable is empty, return the start value.  This function is "
"intended specifically for use with numeric values and may reject non-"
"numeric types."
msgstr ""
"iterable이 비어 있으면, start 값을 반환합니다. 이 함수는 숫자 값과 함께 사용하기 위한 것으로, 숫자가 아닌 형을 "
"거부 할 수 있습니다."

#: ../../library/math.rst:604
msgid "Return the sum of products of values from two iterables *p* and *q*."
msgstr ""

#: ../../library/math.rst:606
msgid "Raises :exc:`ValueError` if the inputs do not have the same length."
msgstr ""

#: ../../library/math.rst:610
msgid "sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))"
msgstr ""

#: ../../library/math.rst:612
msgid ""
"For float and mixed int/float inputs, the intermediate products and sums "
"are computed with extended precision."
msgstr ""

#: ../../library/math.rst:619
msgid "Angular conversion"
msgstr "각도 변환"

#: ../../library/math.rst:623
msgid "Convert angle *x* from radians to degrees."
msgstr "각도 *x*\\를 라디안에서 도(degree)로 변환합니다."

#: ../../library/math.rst:628
msgid "Convert angle *x* from degrees to radians."
msgstr "각도 *x*\\를 도(degree)에서 라디안으로 변환합니다."

#: ../../library/math.rst:632
msgid "Trigonometric functions"
msgstr "삼각 함수"

#: ../../library/math.rst:636
msgid ""
"Return the arc cosine of *x*, in radians. The result is between ``0`` and"
" ``pi``."
msgstr "*x*\\의 아크 코사인(arc cosine)을 라디안으로 반환합니다. 결과는 ``0``\\과 ``pi`` 사이입니다."

#: ../../library/math.rst:642
msgid ""
"Return the arc sine of *x*, in radians. The result is between ``-pi/2`` "
"and ``pi/2``."
msgstr "*x*\\의 아크 사인(arc sine)을 라디안으로 반환합니다. 결과는 ``-pi/2``\\와 ``pi/2`` 사이입니다."

#: ../../library/math.rst:648
msgid ""
"Return the arc tangent of *x*, in radians. The result is between "
"``-pi/2`` and ``pi/2``."
msgstr "*x*\\의 아크 탄젠트(arc tangent)를 라디안으로 반환합니다. 결과는 ``-pi/2``\\와 ``pi/2`` 사이입니다."

#: ../../library/math.rst:654
msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes"
" this angle with the positive X axis. The point of :func:`atan2` is that "
"the signs of both inputs are known to it, so it can compute the correct "
"quadrant for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are "
"both ``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""
"``atan(y / x)``\\를 라디안으로 반환합니다. 결과는 ``-pi``\\와 ``pi`` 사이입니다. 평면에 있는 원점에서 "
"점 ``(x, y)``\\까지의 벡터는 양의 X 축과 이 각도를 이룹니다. :func:`atan2`\\의 요점은 두 입력의 부호가 "
"모두 알려져 있기 때문에 각도에 대한 정확한 사분면을 계산할 수 있다는 것입니다. 예를 들어, ``atan(1)``\\과 "
"``atan2(1, 1)``\\은 모두 ``pi/4``\\이지만, ``atan2(-1, -1)``\\은 "
"``-3*pi/4``\\입니다."

#: ../../library/math.rst:664
msgid "Return the cosine of *x* radians."
msgstr "*x* 라디안의 코사인(cosine)을 반환합니다."

#: ../../library/math.rst:669
msgid "Return the sine of *x* radians."
msgstr "*x* 라디안의 사인(sine)을 반환합니다."

#: ../../library/math.rst:674
msgid "Return the tangent of *x* radians."
msgstr "*x* 라디안의 탄젠트(tangent)를 반환합니다."

#: ../../library/math.rst:678
msgid "Hyperbolic functions"
msgstr "쌍곡선 함수"

#: ../../library/math.rst:680
#, fuzzy
msgid ""
"`Hyperbolic functions "
"<https://en.wikipedia.org/wiki/Hyperbolic_functions>`_ are analogs of "
"trigonometric functions that are based on hyperbolas instead of circles."
msgstr ""
"`쌍곡선 함수 <https://en.wikipedia.org/wiki/Hyperbolic_function>`_\\는 원 대신 "
"쌍곡선을 기반으로 하는 삼각 함수의 동류(analog)입니다."

#: ../../library/math.rst:686
msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "*x*\\의 역 쌍곡 코사인(inverse hyperbolic cosine)을 반환합니다."

#: ../../library/math.rst:691
msgid "Return the inverse hyperbolic sine of *x*."
msgstr "*x*\\의 역 쌍곡 사인(inverse hyperbolic sine)을 반환합니다."

#: ../../library/math.rst:696
msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "*x*\\의 역 쌍곡 탄젠트(inverse hyperbolic tangent)를 반환합니다."

#: ../../library/math.rst:701
msgid "Return the hyperbolic cosine of *x*."
msgstr "*x*\\의 쌍곡 코사인(hyperbolic cosine)을 반환합니다."

#: ../../library/math.rst:706
msgid "Return the hyperbolic sine of *x*."
msgstr "*x*\\의 쌍곡 사인(hyperbolic sine)을 반환합니다."

#: ../../library/math.rst:711
msgid "Return the hyperbolic tangent of *x*."
msgstr "*x*\\의 쌍곡 탄젠트(hyperbolic tangent)를 반환합니다."

#: ../../library/math.rst:715
msgid "Special functions"
msgstr "특수 함수"

#: ../../library/math.rst:719
msgid ""
"Return the `error function "
"<https://en.wikipedia.org/wiki/Error_function>`_ at *x*."
msgstr ""
"*x*\\의 `오차 함수(error function) "
"<https://en.wikipedia.org/wiki/Error_function>`_\\를 반환합니다."

#: ../../library/math.rst:722
#, fuzzy
msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution "
"<https://en.wikipedia.org/wiki/Cumulative_distribution_function>`_::"
msgstr ""
":func:`erf` 함수는 `누적 표준 정규 분포 "
"<https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function>`_\\와"
" 같은 전통적인 통계 함수를 계산하는 데 사용할 수 있습니다::"

#: ../../library/math.rst:726
msgid ""
"def phi(x):\n"
"    'Cumulative distribution function for the standard normal "
"distribution'\n"
"    return (1.0 + erf(x / sqrt(2.0))) / 2.0"
msgstr ""

#: ../../library/math.rst:735
msgid ""
"Return the complementary error function at *x*.  The `complementary error"
" function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction"
" from one would cause a `loss of significance "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\."
msgstr ""
"*x*\\의 여오차 함수를 반환합니다. `여오차 함수(complementary error function) "
"<https://en.wikipedia.org/wiki/Error_function>`_\\는 ``1.0 - erf(x)``\\로 "
"정의됩니다. 뺄셈으로 인해 `유효 숫자의 소실 "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\이 발생하는 *x*\\의 큰 "
"값에 사용됩니다."

#: ../../library/math.rst:746
msgid ""
"Return the `Gamma function "
"<https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*."
msgstr ""
"*x*\\의 `감마 함수(Gamma function) "
"<https://en.wikipedia.org/wiki/Gamma_function>`_\\를 반환합니다."

#: ../../library/math.rst:754
msgid ""
"Return the natural logarithm of the absolute value of the Gamma function "
"at *x*."
msgstr "*x*\\의 감마 함수의 절댓값의 자연로그를 반환합니다."

#: ../../library/math.rst:761
msgid "Constants"
msgstr "상수"

#: ../../library/math.rst:765
msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr "사용 가능한 정밀도로, 수학 상수 *π* = 3.141592..."

#: ../../library/math.rst:770
msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr "사용 가능한 정밀도로, 수학 상수 *e* = 2.718281..."

#: ../../library/math.rst:775
msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau "
"is a circle constant equal to 2\\ *π*, the ratio of a circle's "
"circumference to its radius. To learn more about Tau, check out Vi Hart's"
" video `Pi is (still) Wrong "
"<https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, and start celebrating "
"`Tau day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""
"사용 가능한 정밀도로, 수학 상수 *τ* = 6.283185... 타우(tau)는 원주와 반지름의 비율인 2\\ *π*\\에 "
"해당하는 원 상수입니다. 타우에 대한 자세한 내용은, Vi Hart의 비디오 `Pi is (still) Wrong "
"<https://www.youtube.com/watch?v=jG7vhMMXagQ>`_\\dmf 확인하고, 두 배의 파이를 먹는 "
"것으로 `타우 데이(Tau day) <https://tauday.com/>`_\\를 축하하십시오!"

#: ../../library/math.rst:786
msgid ""
"A floating-point positive infinity.  (For negative infinity, use "
"``-math.inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""
"부동 소수점 양의 무한대. (음의 무한대는 ``-math.inf``\\를 사용하십시오.) ``float('inf')``\\의 출력과"
" 동등합니다."

#: ../../library/math.rst:794
msgid ""
"A floating-point \"not a number\" (NaN) value. Equivalent to the output "
"of ``float('nan')``. Due to the requirements of the `IEEE-754 standard "
"<https://en.wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` and "
"``float('nan')`` are not considered to equal to any other numeric value, "
"including themselves. To check whether a number is a NaN, use the "
":func:`isnan` function to test for NaNs instead of ``is`` or ``==``. "
"Example:"
msgstr ""

#: ../../library/math.rst:814
msgid "It is now always available."
msgstr ""

#: ../../library/math.rst:820
msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the "
"platform C math library functions.  Behavior in exceptional cases follows"
" Annex F of the C99 standard where appropriate.  The current "
"implementation will raise :exc:`ValueError` for invalid operations like "
"``sqrt(-1.0)`` or ``log(0.0)`` (where C99 Annex F recommends signaling "
"invalid operation or divide-by-zero), and :exc:`OverflowError` for "
"results that overflow (for example, ``exp(1000.0)``).  A NaN will not be "
"returned from any of the functions above unless one or more of the input "
"arguments was a NaN; in that case, most functions will return a NaN, but "
"(again following C99 Annex F) there are some exceptions to this rule, for"
" example ``pow(float('nan'), 0.0)`` or ``hypot(float('nan'), "
"float('inf'))``."
msgstr ""
":mod:`math` 모듈은 대부분 플랫폼 C 수학 라이브러리 함수 주위의 얇은 래퍼로 구성됩니다. 예외적인 경우의 행동은 적절한 "
"경우 C99 표준의 부록 F를 따릅니다. 현재 구현은 ``sqrt(-1.0)``\\이나 ``log(0.0)``\\과 같은 잘못된 "
"연산의 경우 :exc:`ValueError`\\를 발생시키고 (C99 부록 F에서 잘못된 연산이나 0으로 나누기를 신호를 주도록 "
"권장하는 경우), 오버플로 하는 결과(예를 들어, ``exp(1000.0)``)의 경우 :exc:`OverflowError`\\를 "
"발생시킵니다. 하나 이상의 입력 인자가 NaN이 아니면, NaN은 위의 함수에서 반환되지 않습니다; 입력 인자가 NaN이면 대부분 "
"함수는 NaN을 반환하지만, (다시 한번 C99 부록 F를 따라) 이 규칙에는 예를 들어 ``pow(float('nan'), "
"0.0)``\\이나 ``hypot(float('nan'), float('inf'))``\\와 같은 몇 가지 예외가 있습니다."

#: ../../library/math.rst:832
msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet"
" NaNs, and behavior for signaling NaNs remains unspecified. Typical "
"behavior is to treat all NaNs as though they were quiet."
msgstr ""
"파이썬은 신호를 주는 NaN(signaling NaN)을 조용한 NaN(quiet NaN)과 구별하기 위해 노력하지 않으며, 신호를"
" 주는 NaN의 동작은 지정되지 않은 상태로 남아 있습니다. 일반적인 동작은 모든 NaN을 조용한 것으로 취급하는 것입니다."

#: ../../library/math.rst:839
msgid "Module :mod:`cmath`"
msgstr "모듈 :mod:`cmath`"

#: ../../library/math.rst:840
msgid "Complex number versions of many of these functions."
msgstr "이 함수 중 많은 것들의 복소수 버전."

#~ msgid ""
#~ "*abs_tol* is the minimum absolute "
#~ "tolerance -- useful for comparisons near"
#~ " zero. *abs_tol* must be at least "
#~ "zero."
#~ msgstr ""
#~ "*abs_tol*\\은 최소 절대 허용 오차입니다 -- 0에"
#~ " 가까운 비교에 유용합니다. *abs_tol*\\은 0 이상이어야"
#~ " 합니다."

#~ msgid ""
#~ "If no errors occur, the result "
#~ "will be: ``abs(a-b) <= max(rel_tol * "
#~ "max(abs(a), abs(b)), abs_tol)``."
#~ msgstr ""
#~ "에러가 발생하지 않으면, 결과는 다음과 같습니다: "
#~ "``abs(a-b) <= max(rel_tol * max(abs(a), "
#~ "abs(b)), abs_tol)``."

#~ msgid ""
#~ "Return the :class:`~numbers.Real` value *x*"
#~ " truncated to an :class:`~numbers.Integral` "
#~ "(usually an integer). Delegates to "
#~ ":meth:`x.__trunc__() <object.__trunc__>`."
#~ msgstr ""
#~ ":class:`~numbers.Real` 값 *x*\\를 "
#~ ":class:`~numbers.Integral`\\(일반적으로 정수)로 자른 값을 "
#~ "반환합니다. :meth:`x.__trunc__() <object.__trunc__>`\\에 "
#~ "위임합니다."

#~ msgid ""
#~ "A floating-point \"not a number\" "
#~ "(NaN) value.  Equivalent to the output"
#~ " of ``float('nan')``."
#~ msgstr "부동 소수점 \"not a number\" (NaN) 값. ``float('nan')``\\의 출력과 동등합니다."

