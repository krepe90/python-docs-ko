# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/subprocess.rst:2
#, fuzzy
msgid ":mod:`!subprocess` --- Subprocess management"
msgstr ":mod:`subprocess` --- 서브 프로세스 관리"

#: ../../library/subprocess.rst:10
msgid "**Source code:** :source:`Lib/subprocess.py`"
msgstr "**소스 코드:** :source:`Lib/subprocess.py`"

#: ../../library/subprocess.rst:14
msgid ""
"The :mod:`subprocess` module allows you to spawn new processes, connect "
"to their input/output/error pipes, and obtain their return codes.  This "
"module intends to replace several older modules and functions::"
msgstr ""
":mod:`subprocess` 모듈은 새로운 프로세스를 생성하고, 그들의 입력/출력/에러 파이프에 연결하고, 반환 코드를 얻을 수"
" 있도록 합니다. 이 모듈은 몇 가지 이전 모듈과 함수를 대체하려고 합니다::"

#: ../../library/subprocess.rst:18
msgid ""
"os.system\n"
"os.spawn*"
msgstr ""

#: ../../library/subprocess.rst:21
msgid ""
"Information about how the :mod:`subprocess` module can be used to replace"
" these modules and functions can be found in the following sections."
msgstr ":mod:`subprocess` 모듈을 사용하여 이러한 모듈과 함수를 교체하는 방법에 대한 정보는 다음 섹션에서 확인할 수 있습니다."

#: ../../library/subprocess.rst:26
msgid ":pep:`324` -- PEP proposing the subprocess module"
msgstr ":pep:`324` -- subprocess 모듈을 제안하는 PEP"

#: ../../includes/wasm-mobile-notavail.rst:3 ../../library/subprocess.rst:598
#: ../../library/subprocess.rst:605 ../../library/subprocess.rst:615
#: ../../library/subprocess.rst:624 ../../library/subprocess.rst:633
#: ../../library/subprocess.rst:639 ../../library/subprocess.rst:1560
#: ../../library/subprocess.rst:1582
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""

#: ../../library/subprocess.rst:31
msgid "Using the :mod:`subprocess` Module"
msgstr ":mod:`subprocess` 모듈 사용하기"

#: ../../library/subprocess.rst:33
msgid ""
"The recommended approach to invoking subprocesses is to use the "
":func:`run` function for all use cases it can handle. For more advanced "
"use cases, the underlying :class:`Popen` interface can be used directly."
msgstr ""
"서브 프로세스 호출에 권장되는 접근법은 처리할 수 있는 모든 사용 사례에 :func:`run` 함수를 사용하는 것입니다. 고급 사용"
" 사례의 경우, 하부 :class:`Popen` 인터페이스를 직접 사용할 수 있습니다."

#: ../../library/subprocess.rst:43
msgid ""
"Run the command described by *args*.  Wait for command to complete, then "
"return a :class:`CompletedProcess` instance."
msgstr ""
"*args*\\가 기술하는 명령을 실행합니다. 명령이 완료될 때까지 기다린 다음, :class:`CompletedProcess` "
"인스턴스를 반환합니다."

#: ../../library/subprocess.rst:46
msgid ""
"The arguments shown above are merely the most common ones, described "
"below in :ref:`frequently-used-arguments` (hence the use of keyword-only "
"notation in the abbreviated signature). The full function signature is "
"largely the same as that of the :class:`Popen` constructor - most of the "
"arguments to this function are passed through to that interface. "
"(*timeout*,  *input*, *check*, and *capture_output* are not.)"
msgstr ""
"위에 표시된 인자는 가장 일반적인 인자로, 아래 :ref:`frequently-used-arguments`\\에서 설명됩니다 "
"(따라서 약식 서명에 키워드 전용 표기법을 사용합니다). 전체 함수 서명은 :class:`Popen` 생성자와 거의 같습니다 - 이"
" 함수에 대한 대부분의 인자는 해당 인터페이스로 전달됩니다. (*timeout*, *input*, *check* 및 "
"*capture_output*\\은 아닙니다.)"

#: ../../library/subprocess.rst:53
#, fuzzy
msgid ""
"If *capture_output* is true, stdout and stderr will be captured. When "
"used, the internal :class:`Popen` object is automatically created with "
"*stdout* and *stderr* both set to :data:`~subprocess.PIPE`. The *stdout* "
"and *stderr* arguments may not be supplied at the same time as "
"*capture_output*. If you wish to capture and combine both streams into "
"one, set *stdout* to :data:`~subprocess.PIPE` and *stderr* to "
":data:`~subprocess.STDOUT`, instead of using *capture_output*."
msgstr ""
"*capture_output*\\이 참이면, 표준 출력(stdout)과 표준 에러(stderr)가 캡처됩니다. 사용되면, 내부 "
":class:`Popen` 객체는 자동으로 ``stdout=PIPE``\\와 ``stderr=PIPE``\\로 만들어집니다. "
"*stdout*\\과 *stderr* 인자는 *capture_output*\\과 동시에 제공되지 않을 수 있습니다. 두 스트림을 "
"모두 캡처하여 하나로 결합하려면 *capture_output* 대신 ``stdout=PIPE``\\와 "
"``stderr=STDOUT``\\을 사용하십시오."

#: ../../library/subprocess.rst:62
#, fuzzy
msgid ""
"A *timeout* may be specified in seconds, it is internally passed on to "
":meth:`Popen.communicate`. If the timeout expires, the child process will"
" be killed and waited for. The :exc:`TimeoutExpired` exception will be "
"re-raised after the child process has terminated. The initial process "
"creation itself cannot be interrupted on many platform APIs so you are "
"not guaranteed to see a timeout exception until at least after however "
"long process creation takes."
msgstr ""
"*timeout* 인자는 :meth:`Popen.communicate`\\로 전달됩니다. 시간제한이 만료되면, 자식 프로세스를 "
"죽이고 기다립니다. 자식 프로세스가 종료된 후 :exc:`TimeoutExpired` 예외가 다시 발생합니다."

#: ../../library/subprocess.rst:70
#, fuzzy
msgid ""
"The *input* argument is passed to :meth:`Popen.communicate` and thus to "
"the subprocess's stdin.  If used it must be a byte sequence, or a string "
"if *encoding* or *errors* is specified or *text* is true.  When used, the"
" internal :class:`Popen` object is automatically created with *stdin* set"
" to :data:`~subprocess.PIPE`, and the *stdin* argument may not be used as"
" well."
msgstr ""
"*input* 인자는 :meth:`Popen.communicate`\\로 전달되고, 그래서 서브 프로세스의 표준 입력으로 "
"전달됩니다. 사용된다면 바이트 시퀀스이거나, *encoding*\\이나 *errors*\\가 지정되었거나 *text*\\가 참이면 "
"문자열이어야 합니다. 사용하면, 내부 :class:`Popen` 객체가 자동으로 ``stdin=PIPE``\\로 만들어지고 "
"*stdin* 인자는 사용되지 않을 수 있습니다."

#: ../../library/subprocess.rst:77
msgid ""
"If *check* is true, and the process exits with a non-zero exit code, a "
":exc:`CalledProcessError` exception will be raised. Attributes of that "
"exception hold the arguments, the exit code, and stdout and stderr if "
"they were captured."
msgstr ""
"*check*\\가 참이고, 프로세스가 0이 아닌 종료 코드로 종료되면, :exc:`CalledProcessError` 예외가 "
"발생합니다. 해당 예외의 어트리뷰트가 인자 및 종료 코드와 캡처되었다면 stdout과 stderr을 담습니다."

#: ../../library/subprocess.rst:82
msgid ""
"If *encoding* or *errors* are specified, or *text* is true, file objects "
"for stdin, stdout and stderr are opened in text mode using the specified "
"*encoding* and *errors* or the :class:`io.TextIOWrapper` default. The "
"*universal_newlines* argument is equivalent  to *text* and is provided "
"for backwards compatibility. By default, file objects are opened in "
"binary mode."
msgstr ""
"*encoding*\\이나 *errors*\\가 지정되거나, *text*\\가 참이면, stdin, stdout 및 stderr의 "
"파일 객체는 지정된 *encoding*\\과 *errors* 또는 :class:`io.TextIOWrapper` 기본값을 사용하여 "
"텍스트 모드로 열립니다. *universal_newlines* 인자는 *text*\\와 동등하고 이전 버전과의 호환성을 위해 "
"제공됩니다. 기본적으로, 파일 객체는 바이너리 모드로 열립니다."

#: ../../library/subprocess.rst:88
#, fuzzy
msgid ""
"If *env* is not ``None``, it must be a mapping that defines the "
"environment variables for the new process; these are used instead of the "
"default behavior of inheriting the current process' environment. It is "
"passed directly to :class:`Popen`. This mapping can be str to str on any "
"platform or bytes to bytes on POSIX platforms much like "
":data:`os.environ` or :data:`os.environb`."
msgstr ""
"*env*\\가 ``None``\\이 아니면, 새 프로세스의 환경 변수를 정의하는 매핑이어야 합니다; 이것은 현재 프로세스의 환경을"
" 상속하는 기본 동작 대신 사용됩니다. :class:`Popen`\\으로 직접 전달됩니다."

#: ../../library/subprocess.rst:95
msgid "Examples::"
msgstr "예::"

#: ../../library/subprocess.rst:97
msgid ""
">>> subprocess.run([\"ls\", \"-l\"])  # doesn't capture output\n"
"CompletedProcess(args=['ls', '-l'], returncode=0)\n"
"\n"
">>> subprocess.run(\"exit 1\", shell=True, check=True)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit "
"status 1\n"
"\n"
">>> subprocess.run([\"ls\", \"-l\", \"/dev/null\"], capture_output=True)\n"
"CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,\n"
"stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\\n', "
"stderr=b'')"
msgstr ""

#: ../../library/subprocess.rst:113
msgid "Added *encoding* and *errors* parameters"
msgstr "*encoding*\\과 *errors* 매개 변수를 추가했습니다"

#: ../../library/subprocess.rst:117
msgid ""
"Added the *text* parameter, as a more understandable alias of "
"*universal_newlines*. Added the *capture_output* parameter."
msgstr ""
"*universal_newlines*\\의 더 이해하기 쉬운 별칭으로 *text* 매개 변수를 추가했습니다. "
"*capture_output* 매개 변수를 추가했습니다."

#: ../../library/subprocess.rst:122 ../../library/subprocess.rst:506
#: ../../library/subprocess.rst:1214 ../../library/subprocess.rst:1254
#: ../../library/subprocess.rst:1317
msgid ""
"Changed Windows shell search order for ``shell=True``. The current "
"directory and ``%PATH%`` are replaced with ``%COMSPEC%`` and "
"``%SystemRoot%\\System32\\cmd.exe``. As a result, dropping a malicious "
"program named ``cmd.exe`` into a current directory no longer works."
msgstr ""

#: ../../library/subprocess.rst:130
msgid ""
"The return value from :func:`run`, representing a process that has "
"finished."
msgstr "완료된 프로세스를 나타내는, :func:`run`\\의 반환 값."

#: ../../library/subprocess.rst:134
msgid "The arguments used to launch the process. This may be a list or a string."
msgstr "프로세스를 시작하는 데 사용된 인자. 리스트나 문자열일 수 있습니다."

#: ../../library/subprocess.rst:138
msgid ""
"Exit status of the child process. Typically, an exit status of 0 "
"indicates that it ran successfully."
msgstr "자식 프로세스의 종료 상태. 일반적으로, 종료 상태 0은 성공적으로 실행되었음을 나타냅니다."

#: ../../library/subprocess.rst:141 ../../library/subprocess.rst:945
msgid ""
"A negative value ``-N`` indicates that the child was terminated by signal"
" ``N`` (POSIX only)."
msgstr "음수 값 ``-N``\\은 자식이 시그널 ``N``\\에 의해 종료되었음을 나타냅니다 (POSIX 전용)."

#: ../../library/subprocess.rst:146
msgid ""
"Captured stdout from the child process. A bytes sequence, or a string if "
":func:`run` was called with an encoding, errors, or text=True. ``None`` "
"if stdout was not captured."
msgstr ""
"자식 프로세스에서 캡처된 stdout. 바이트 시퀀스, 또는 :func:`run`\\이 encoding, errors, 또는 "
"text=True로 호출되었으면 문자열. stdout이 캡처되지 않았으면 ``None``."

#: ../../library/subprocess.rst:150
msgid ""
"If you ran the process with ``stderr=subprocess.STDOUT``, stdout and "
"stderr will be combined in this attribute, and :attr:`stderr` will be "
"``None``."
msgstr ""
"``stderr=subprocess.STDOUT``\\으로 프로세스를 실행했으면, stdout과 stderr이 이 어트리뷰트에 "
"결합하고, :attr:`stderr`\\은 ``None``\\이 됩니다."

#: ../../library/subprocess.rst:156
msgid ""
"Captured stderr from the child process. A bytes sequence, or a string if "
":func:`run` was called with an encoding, errors, or text=True. ``None`` "
"if stderr was not captured."
msgstr ""
"자식 프로세스에서 캡처된 stderr. 바이트 시퀀스, 또는 :func:`run`\\이 encoding, errors, 또는 "
"text=True로 호출되었으면 문자열. stderr이 캡처되지 않았으면 ``None``."

#: ../../library/subprocess.rst:162
msgid "If :attr:`returncode` is non-zero, raise a :exc:`CalledProcessError`."
msgstr ":attr:`returncode`\\가 0이 아니면, :exc:`CalledProcessError`\\를 발생시킵니다."

#: ../../library/subprocess.rst:168
msgid ""
"Special value that can be used as the *stdin*, *stdout* or *stderr* "
"argument to :class:`Popen` and indicates that the special file "
":data:`os.devnull` will be used."
msgstr ""
":class:`Popen`\\의 *stdin*, *stdout* 또는 *stderr* 인자로 사용할 수 있고 특수 파일 "
":data:`os.devnull`\\이 사용될 것임을 나타내는 특수 값."

#: ../../library/subprocess.rst:177
msgid ""
"Special value that can be used as the *stdin*, *stdout* or *stderr* "
"argument to :class:`Popen` and indicates that a pipe to the standard "
"stream should be opened.  Most useful with :meth:`Popen.communicate`."
msgstr ""
":class:`Popen`\\의 *stdin*, *stdout* 또는 *stderr* 인자로 사용할 수 있고 표준 스트림에 대한 "
"파이프를 열어야 함을 나타내는 특수 값. :meth:`Popen.communicate`\\에서 가장 유용합니다."

#: ../../library/subprocess.rst:184
msgid ""
"Special value that can be used as the *stderr* argument to :class:`Popen`"
" and indicates that standard error should go into the same handle as "
"standard output."
msgstr ""
":class:`Popen`\\의 *stderr* 인자로 사용할 수 있고 표준 에러가 표준 출력과 같은 핸들로 가야 함을 나타내는 "
"특수 값."

#: ../../library/subprocess.rst:191
msgid "Base class for all other exceptions from this module."
msgstr "이 모듈의 다른 모든 예외에 대한 베이스 클래스."

#: ../../library/subprocess.rst:198
msgid ""
"Subclass of :exc:`SubprocessError`, raised when a timeout expires while "
"waiting for a child process."
msgstr "자식 프로세스를 기다리는 동안 시간제한이 만료될 때 발생하는 :exc:`SubprocessError`\\의 서브 클래스."

#: ../../library/subprocess.rst:203 ../../library/subprocess.rst:247
msgid "Command that was used to spawn the child process."
msgstr "자식 프로세스를 생성하는 데 사용된 명령."

#: ../../library/subprocess.rst:207
msgid "Timeout in seconds."
msgstr "초 단위의 시간제한."

#: ../../library/subprocess.rst:211
msgid ""
"Output of the child process if it was captured by :func:`run` or "
":func:`check_output`.  Otherwise, ``None``.  This is always "
":class:`bytes` when any output was captured regardless of the "
"``text=True`` setting.  It may remain ``None`` instead of ``b''`` when no"
" output was observed."
msgstr ""

#: ../../library/subprocess.rst:219 ../../library/subprocess.rst:256
msgid "Alias for output, for symmetry with :attr:`stderr`."
msgstr "output의 별칭, :attr:`stderr`\\과의 대칭을 위한 것입니다."

#: ../../library/subprocess.rst:223
msgid ""
"Stderr output of the child process if it was captured by :func:`run`. "
"Otherwise, ``None``.  This is always :class:`bytes` when stderr output "
"was captured regardless of the ``text=True`` setting.  It may remain "
"``None`` instead of ``b''`` when no stderr output was observed."
msgstr ""

#: ../../library/subprocess.rst:230 ../../library/subprocess.rst:263
msgid "*stdout* and *stderr* attributes added"
msgstr "*stdout*\\과 *stderr* 어트리뷰트가 추가되었습니다"

#: ../../library/subprocess.rst:235
#, fuzzy
msgid ""
"Subclass of :exc:`SubprocessError`, raised when a process run by "
":func:`check_call`, :func:`check_output`, or :func:`run` (with "
"``check=True``) returns a non-zero exit status."
msgstr ""
":func:`check_call`\\이나 :func:`check_output`\\에 의해 실행되는 프로세스가 0이 아닌 종료 상태를"
" 반환할 때 발생하는 :exc:`SubprocessError` 의 서브 클래스."

#: ../../library/subprocess.rst:242
msgid ""
"Exit status of the child process.  If the process exited due to a signal,"
" this will be the negative signal number."
msgstr "자식 프로세스의 종료 상태. 시그널로 인해 프로세스가 종료되었으면, 음의 시그널 번호가 됩니다."

#: ../../library/subprocess.rst:251
msgid ""
"Output of the child process if it was captured by :func:`run` or "
":func:`check_output`.  Otherwise, ``None``."
msgstr ""
":func:`run`\\이나 :func:`check_output`\\에 의해 캡처되었다면 자식 프로세스의 출력. 그렇지 않으면, "
"``None``."

#: ../../library/subprocess.rst:260
msgid ""
"Stderr output of the child process if it was captured by :func:`run`. "
"Otherwise, ``None``."
msgstr ":func:`run`\\에 의해 캡처되었다면 자식 프로세스의 stderr 출력. 그렇지 않으면, ``None``."

#: ../../library/subprocess.rst:270
msgid "Frequently Used Arguments"
msgstr "자주 사용되는 인자"

#: ../../library/subprocess.rst:272
msgid ""
"To support a wide variety of use cases, the :class:`Popen` constructor "
"(and the convenience functions) accept a large number of optional "
"arguments. For most typical use cases, many of these arguments can be "
"safely left at their default values. The arguments that are most commonly"
" needed are:"
msgstr ""
"다양한 사용 사례를 지원하기 위해, :class:`Popen` 생성자(및 편의 함수)는 많은 선택적 인자를 받아들입니다. 가장 "
"일반적인 사용 사례에서, 이러한 인자 중 많은 부분을 기본값으로 안전하게 남겨둘 수 있습니다. 가장 흔히 필요한 인자는 다음과 "
"같습니다:"

#: ../../library/subprocess.rst:277
msgid ""
"*args* is required for all calls and should be a string, or a sequence of"
" program arguments. Providing a sequence of arguments is generally "
"preferred, as it allows the module to take care of any required escaping "
"and quoting of arguments (e.g. to permit spaces in file names). If "
"passing a single string, either *shell* must be :const:`True` (see below)"
" or else the string must simply name the program to be executed without "
"specifying any arguments."
msgstr ""
"*args*\\는 모든 호출에 필요하며 문자열 또는 프로그램 인자의 시퀀스여야 합니다. 인자의 시퀀스를 제공하는 것이 일반적으로 "
"선호되는데, 모듈이 필요한 인자의 이스케이프와 인용을 처리하도록 하기 때문입니다 (예를 들어 파일 이름에 공백을 허용하도록). 단일"
" 문자열을 전달하면, *shell*\\이 :const:`True`\\(아래를 참조하십시오)이거나, 그렇지 않으면 문자열은 단순히 "
"인자를 지정하지 않고 실행할 프로그램의 이름이어야 합니다."

#: ../../library/subprocess.rst:285
#, fuzzy
msgid ""
"*stdin*, *stdout* and *stderr* specify the executed program's standard "
"input, standard output and standard error file handles, respectively.  "
"Valid values are ``None``, :data:`PIPE`, :data:`DEVNULL`, an existing "
"file descriptor (a positive integer), and an existing :term:`file object`"
" with a valid file descriptor.  With the default settings of ``None``, no"
" redirection will occur.  :data:`PIPE` indicates that a new pipe to the "
"child should be created.  :data:`DEVNULL` indicates that the special file"
" :data:`os.devnull` will be used.  Additionally, *stderr* can be "
":data:`STDOUT`, which indicates that the stderr data from the child "
"process should be captured into the same file handle as for *stdout*."
msgstr ""
"*stdin*, *stdout* 및 *stderr*\\은 각각 실행된 프로그램의 표준 입력, 표준 출력 및 표준 에러 파일 핸들을 "
"지정합니다. 유효한 값은 :data:`PIPE`, :data:`DEVNULL`, 기존 파일 기술자 (양의 정수), 기존 파일 객체 "
"및 ``None``\\입니다. :data:`PIPE`\\는 자식에 대한 새 파이프를 만들어야 함을 나타냅니다. "
":data:`DEVNULL`\\은 특수 파일 :data:`os.devnull`\\이 사용될 것임을 나타냅니다. 기본 설정 "
"``None``\\으로는, 리디렉션이 발생하지 않습니다; 자식의 파일 핸들은 부모로부터 상속됩니다. 또한, *stderr*\\은 "
":data:`STDOUT`\\일 수 있으며, 이는 자식 프로세스의 stderr 데이터가 *stdout*\\과 같은 파일 핸들로 "
"캡처되어야 함을 나타냅니다."

#: ../../library/subprocess.rst:299
msgid ""
"If *encoding* or *errors* are specified, or *text* (also known as "
"*universal_newlines*) is true, the file objects *stdin*, *stdout* and "
"*stderr* will be opened in text mode using the *encoding* and *errors* "
"specified in the call or the defaults for :class:`io.TextIOWrapper`."
msgstr ""
"*encoding*\\이나 *errors*\\가 지정되거나, *text*\\(*universal_newlines*\\라고도 "
"합니다)가 참이면, 파일 객체 *stdin*, *stdout* 및 *stderr*\\은 호출에 지정된 *encoding*\\과 "
"*errors* 또는 :class:`io.TextIOWrapper`\\의 기본값을 사용하여 텍스트 모드로 열립니다."

#: ../../library/subprocess.rst:305
msgid ""
"For *stdin*, line ending characters ``'\\n'`` in the input will be "
"converted to the default line separator :data:`os.linesep`. For *stdout* "
"and *stderr*, all line endings in the output will be converted to "
"``'\\n'``.  For more information see the documentation of the "
":class:`io.TextIOWrapper` class when the *newline* argument to its "
"constructor is ``None``."
msgstr ""
"*stdin*\\의 경우, 입력의 줄 종료 문자 ``'\\n'``\\이 기본 줄 구분자 :data:`os.linesep`\\으로 "
"변환됩니다. *stdout*\\과 *stderr*\\의 경우, 출력의 모든 줄 종료가 ``'\\n'``\\으로 변환됩니다. 자세한 "
"정보는 생성자에 대한 *newline* 인자가 ``None``\\일 때에 관한 :class:`io.TextIOWrapper` "
"클래스의 설명서를 참조하십시오."

#: ../../library/subprocess.rst:311
msgid ""
"If text mode is not used, *stdin*, *stdout* and *stderr* will be opened "
"as binary streams. No encoding or line ending conversion is performed."
msgstr ""
"텍스트 모드를 사용하지 않으면, *stdin*, *stdout* 및 *stderr*\\이 바이너리 스트림으로 열립니다. 인코딩이나 "
"줄 종료 변환이 수행되지 않습니다."

#: ../../library/subprocess.rst:314 ../../library/subprocess.rst:1569
#: ../../library/subprocess.rst:1587
#, fuzzy
msgid "Added the *encoding* and *errors* parameters."
msgstr "*encoding*\\과 *errors* 매개 변수를 추가했습니다."

#: ../../library/subprocess.rst:317
msgid "Added the *text* parameter as an alias for *universal_newlines*."
msgstr "*text* 매개 변수를 *universal_newlines*\\의 별칭으로 추가했습니다."

#: ../../library/subprocess.rst:322
msgid ""
"The newlines attribute of the file objects :attr:`Popen.stdin`, "
":attr:`Popen.stdout` and :attr:`Popen.stderr` are not updated by the "
":meth:`Popen.communicate` method."
msgstr ""
"파일 객체 :attr:`Popen.stdin`, :attr:`Popen.stdout` 및 :attr:`Popen.stderr`\\의"
" newlines 어트리뷰트는 :meth:`Popen.communicate` 메서드에 의해 갱신되지 않습니다."

#: ../../library/subprocess.rst:326
msgid ""
"If *shell* is ``True``, the specified command will be executed through "
"the shell.  This can be useful if you are using Python primarily for the "
"enhanced control flow it offers over most system shells and still want "
"convenient access to other shell features such as shell pipes, filename "
"wildcards, environment variable expansion, and expansion of ``~`` to a "
"user's home directory.  However, note that Python itself offers "
"implementations of many shell-like features (in particular, :mod:`glob`, "
":mod:`fnmatch`, :func:`os.walk`, :func:`os.path.expandvars`, "
":func:`os.path.expanduser`, and :mod:`shutil`)."
msgstr ""
"*shell*\\이 ``True``\\이면, 지정된 명령이 셸을 통해 실행됩니다. 이것은 대부분의 시스템 셸에서 제공하는 것보다 "
"향상된 제어 흐름을 위해 파이썬을 주로 사용하면서, 여전히 셸 파이프, 파일명 와일드카드, 환경 변수 확장 및 사용자 홈 "
"디렉터리로의 ``~`` 확장과 같은 다른 셸 기능에 대한 편리한 액세스를 원할 때 유용할 수 있습니다. 그러나, 파이썬 자체가 많은"
" 셸과 유사한 기능의 구현을 제공함에 유의하십시오 (특히, :mod:`glob`, :mod:`fnmatch`, "
":func:`os.walk`, :func:`os.path.expandvars`, :func:`os.path.expanduser` 및"
" :mod:`shutil`)."

#: ../../library/subprocess.rst:336
msgid ""
"When *universal_newlines* is ``True``, the class uses the encoding "
":func:`locale.getpreferredencoding(False) <locale.getpreferredencoding>` "
"instead of ``locale.getpreferredencoding()``.  See the "
":class:`io.TextIOWrapper` class for more information on this change."
msgstr ""
"*universal_newlines*\\가 ``True``\\일 때, 클래스는 "
"``locale.getpreferredencoding()`` 대신 인코딩 "
":func:`locale.getpreferredencoding(False) "
"<locale.getpreferredencoding>`\\를 사용합니다. 이 변경에 대한 자세한 내용은 "
":class:`io.TextIOWrapper` 클래스를 참조하십시오."

#: ../../library/subprocess.rst:344 ../../library/subprocess.rst:465
msgid "Read the `Security Considerations`_ section before using ``shell=True``."
msgstr ""
"``shell=True``\\를 사용하기 전에 `보안 고려 사항 <Security Considerations_>`_ 섹션을 "
"읽으십시오."

#: ../../library/subprocess.rst:346
msgid ""
"These options, along with all of the other options, are described in more"
" detail in the :class:`Popen` constructor documentation."
msgstr "이러한 옵션들은, 다른 모든 옵션과 함께, :class:`Popen` 생성자 설명서에 더 자세히 설명되어 있습니다."

#: ../../library/subprocess.rst:351
msgid "Popen Constructor"
msgstr "Popen 생성자"

#: ../../library/subprocess.rst:353
msgid ""
"The underlying process creation and management in this module is handled "
"by the :class:`Popen` class. It offers a lot of flexibility so that "
"developers are able to handle the less common cases not covered by the "
"convenience functions."
msgstr ""
"이 모듈에서 하부 프로세스 생성과 관리는 :class:`Popen` 클래스에 의해 처리됩니다. 개발자가 편의 함수가 다루지 않는 덜"
" 일반적인 사례를 처리할 수 있도록 큰 유연성을 제공합니다."

#: ../../library/subprocess.rst:368
#, fuzzy
msgid ""
"Execute a child program in a new process.  On POSIX, the class uses "
":meth:`os.execvpe`-like behavior to execute the child program.  On "
"Windows, the class uses the Windows ``CreateProcess()`` function.  The "
"arguments to :class:`Popen` are as follows."
msgstr ""
"새 프로세스에서 자식 프로그램을 실행합니다. POSIX에서, 클래스는 자식 프로그램을 실행하는 데 "
":meth:`os.execvp`\\와 유사한 동작을 사용합니다. 윈도우에서 클래스는 윈도우 ``CreateProcess()`` "
"함수를 사용합니다. :class:`Popen`\\에 대한 인자는 다음과 같습니다."

#: ../../library/subprocess.rst:373
msgid ""
"*args* should be a sequence of program arguments or else a single string "
"or :term:`path-like object`. By default, the program to execute is the "
"first item in *args* if *args* is a sequence.  If *args* is a string, the"
" interpretation is platform-dependent and described below.  See the "
"*shell* and *executable* arguments for additional differences from the "
"default behavior.  Unless otherwise stated, it is recommended to pass "
"*args* as a sequence."
msgstr ""
"*args*\\는 프로그램 인자의 시퀀스이거나 그렇지 않으면 단일한 문자열이나 :term:`경로류 객체 <path-like "
"object>`\\여야 합니다. 기본적으로, *args*\\가 시퀀스이면 실행할 프로그램은 *args*\\의 첫 번째 항목입니다. "
"*args*\\가 문자열이면, 해석은 플랫폼에 따라 다르며 아래에 설명되어 있습니다. 기본 동작과의 추가 차이점에 관해서는 "
"*shell*\\과 *executable* 인자를 참조하십시오. 별도의 언급이 없는 한, *args*\\를 시퀀스로 전달하는 것이 "
"좋습니다."

#: ../../library/subprocess.rst:383
msgid ""
"For maximum reliability, use a fully qualified path for the executable. "
"To search for an unqualified name on :envvar:`PATH`, use "
":meth:`shutil.which`. On all platforms, passing :data:`sys.executable` is"
" the recommended way to launch the current Python interpreter again, and "
"use the ``-m`` command-line format to launch an installed module."
msgstr ""

#: ../../library/subprocess.rst:389
msgid ""
"Resolving the path of *executable* (or the first item of *args*) is "
"platform dependent. For POSIX, see :meth:`os.execvpe`, and note that when"
" resolving or searching for the executable path, *cwd* overrides the "
"current working directory and *env* can override the ``PATH`` environment"
" variable. For Windows, see the documentation of the "
"``lpApplicationName`` and ``lpCommandLine`` parameters of WinAPI "
"``CreateProcess``, and note that when resolving or searching for the "
"executable path with ``shell=False``, *cwd* does not override the current"
" working directory and *env* cannot override the ``PATH`` environment "
"variable. Using a full path avoids all of these variations."
msgstr ""

#: ../../library/subprocess.rst:400
msgid ""
"An example of passing some arguments to an external program as a sequence"
" is::"
msgstr "시퀀스로 외부 프로그램에 어떤 인자를 전달하는 예는 다음과 같습니다::"

#: ../../library/subprocess.rst:403
msgid "Popen([\"/usr/bin/git\", \"commit\", \"-m\", \"Fixes a bug.\"])"
msgstr ""

#: ../../library/subprocess.rst:405
msgid ""
"On POSIX, if *args* is a string, the string is interpreted as the name or"
" path of the program to execute.  However, this can only be done if not "
"passing arguments to the program."
msgstr ""
"POSIX에서, *args*\\가 문자열이면, 문자열은 실행할 프로그램의 이름이나 경로로 해석됩니다. 그러나, 이것은 프로그램에 "
"인자를 전달하지 않을 때만 수행할 수 있습니다."

#: ../../library/subprocess.rst:411
msgid ""
"It may not be obvious how to break a shell command into a sequence of "
"arguments, especially in complex cases. :meth:`shlex.split` can "
"illustrate how to determine the correct tokenization for *args*::"
msgstr ""
"특히 복잡한 경우에, 셸 명령을 인자의 시퀀스로 나누는 방법이 명확하지 않을 수 있습니다. :meth:`shlex.split`\\는"
" *args*\\의 올바른 토큰화를 결정하는 방법을 보여줄 수 있습니다::"

#: ../../library/subprocess.rst:415
msgid ""
">>> import shlex, subprocess\n"
">>> command_line = input()\n"
"/bin/vikings -input eggs.txt -output \"spam spam.txt\" -cmd \"echo "
"'$MONEY'\"\n"
">>> args = shlex.split(command_line)\n"
">>> print(args)\n"
"['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', "
"'-cmd', \"echo '$MONEY'\"]\n"
">>> p = subprocess.Popen(args) # Success!"
msgstr ""

#: ../../library/subprocess.rst:423
msgid ""
"Note in particular that options (such as *-input*) and arguments (such as"
" *eggs.txt*) that are separated by whitespace in the shell go in separate"
" list elements, while arguments that need quoting or backslash escaping "
"when used in the shell (such as filenames containing spaces or the *echo*"
" command shown above) are single list elements."
msgstr ""
"특히 셸에서 공백으로 구분된 옵션(가령 *-input*)과 인자(가령 *eggs.txt*)는 별도의 리스트 요소로 들어가지만, "
"셸에서 사용될 때 인용(quoting)이나 역 슬래시 이스케이프가 필요한 인자(가령 스페이스가 포함된 파일명이나 위에 표시된 "
"*echo* 명령)는 단일 리스트 요소임에 유의하십시오."

#: ../../library/subprocess.rst:429
msgid ""
"On Windows, if *args* is a sequence, it will be converted to a string in "
"a manner described in :ref:`converting-argument-sequence`.  This is "
"because the underlying ``CreateProcess()`` operates on strings."
msgstr ""
"윈도우에서, *args*\\가 시퀀스이면, :ref:`converting-argument-sequence`\\에 설명된 방식으로 "
"문자열로 변환됩니다. 하부 ``CreateProcess()``\\가 문자열에서 작동하기 때문입니다."

#: ../../library/subprocess.rst:433
msgid ""
"*args* parameter accepts a :term:`path-like object` if *shell* is "
"``False`` and a sequence containing path-like objects on POSIX."
msgstr ""
"POSIX에서, *args* 매개 변수는 *shell*\\이 ``False``\\이면 :term:`경로류 객체 <path-like "
"object>`\\나 경로류 객체를 포함하는 시퀀스를 받아들입니다."

#: ../../library/subprocess.rst:437
msgid ""
"*args* parameter accepts a :term:`path-like object` if *shell* is "
"``False`` and a sequence containing bytes and path-like objects on "
"Windows."
msgstr ""
"윈도우에서, *args* 매개 변수는 *shell*\\이 ``False``\\이면 :term:`경로류 객체 <path-like "
"object>`\\나 바이트열과 경로류 객체를 포함하는 시퀀스를 받아들입니다."

#: ../../library/subprocess.rst:442
msgid ""
"The *shell* argument (which defaults to ``False``) specifies whether to "
"use the shell as the program to execute.  If *shell* is ``True``, it is "
"recommended to pass *args* as a string rather than as a sequence."
msgstr ""
"*shell* 인자(기본값은 ``False``)는 셸을 실행할 프로그램으로 사용할지를 지정합니다. *shell*\\이 "
"``True``\\이면, *args*\\를 시퀀스가 아닌 문자열로 전달하는 것이 좋습니다."

#: ../../library/subprocess.rst:446
msgid ""
"On POSIX with ``shell=True``, the shell defaults to :file:`/bin/sh`.  If "
"*args* is a string, the string specifies the command to execute through "
"the shell.  This means that the string must be formatted exactly as it "
"would be when typed at the shell prompt.  This includes, for example, "
"quoting or backslash escaping filenames with spaces in them.  If *args* "
"is a sequence, the first item specifies the command string, and any "
"additional items will be treated as additional arguments to the shell "
"itself.  That is to say, :class:`Popen` does the equivalent of::"
msgstr ""
"POSIX에서 ``shell=True``\\일 때, 셸의 기본값은 :file:`/bin/sh`\\입니다. *args*\\가 "
"문자열이면, 문자열은 셸을 통해 실행할 명령을 지정합니다. 이것은 문자열이 프롬프트에서 입력할 때와 똑같이 포맷되어야 한다는 것을 "
"의미합니다. 예를 들어, 스페이스가 포함된 파일명을 인용하거나 역 슬래시 이스케이핑 하는 것을 포함합니다. *args*\\가 "
"시퀀스이면, 첫 번째 항목이 명령 문자열을 지정하고, 추가 항목은 셸 자체에 대한 추가 인자로 처리됩니다. 즉, "
":class:`Popen`\\은 다음과 동등한 것을 수행합니다::"

#: ../../library/subprocess.rst:455
msgid "Popen(['/bin/sh', '-c', args[0], args[1], ...])"
msgstr ""

#: ../../library/subprocess.rst:457
msgid ""
"On Windows with ``shell=True``, the :envvar:`COMSPEC` environment "
"variable specifies the default shell.  The only time you need to specify "
"``shell=True`` on Windows is when the command you wish to execute is "
"built into the shell (e.g. :command:`dir` or :command:`copy`).  You do "
"not need ``shell=True`` to run a batch file or console-based executable."
msgstr ""
"윈도우에서 ``shell=True``\\일 때, :envvar:`COMSPEC` 환경 변수는 기본 셸을 지정합니다. 윈도우에서 "
"``shell=True``\\를 지정해야 하는 유일한 경우는 실행하려는 명령이 셸에 내장되었을 때입니다 (예를 들어 "
":command:`dir`\\이나 :command:`copy`). 배치 파일이나 콘솔 기반 실행 파일을 실행하기 위해 "
"``shell=True``\\가 필요하지 않습니다."

#: ../../library/subprocess.rst:467
msgid ""
"*bufsize* will be supplied as the corresponding argument to the "
":func:`open` function when creating the stdin/stdout/stderr pipe file "
"objects:"
msgstr ""
"*bufsize*\\는 stdin/stdout/stderr 파이프 파일 객체를 만들 때 :func:`open` 함수에 해당 인자로 "
"제공됩니다:"

#: ../../library/subprocess.rst:471
#, fuzzy
msgid ""
"``0`` means unbuffered (read and write are one system call and can return"
" short)"
msgstr ":const:`0`\\은 버퍼링 되지 않음을 의미합니다 (읽기와 쓰기는 한 번의 시스템 호출이며 짧게 반환할 수 있습니다)"

#: ../../library/subprocess.rst:473
#, fuzzy
msgid ""
"``1`` means line buffered (only usable if ``text=True`` or "
"``universal_newlines=True``)"
msgstr ""
":const:`1`\\은 줄 버퍼링을 의미합니다 (``universal_newlines=True``\\인 경우, 즉 텍스트 "
"모드에서만 사용할 수 있습니다)"

#: ../../library/subprocess.rst:475
msgid "any other positive value means use a buffer of approximately that size"
msgstr "다른 양수 값은 대략 그 크기의 버퍼를 사용함을 의미합니다."

#: ../../library/subprocess.rst:477
msgid ""
"negative bufsize (the default) means the system default of "
"io.DEFAULT_BUFFER_SIZE will be used."
msgstr "음의 bufsize(기본값)는 시스템 기본값 io.DEFAULT_BUFFER_SIZE가 사용됨을 의미합니다."

#: ../../library/subprocess.rst:480
#, fuzzy
msgid ""
"*bufsize* now defaults to -1 to enable buffering by default to match the "
"behavior that most code expects.  In versions prior to Python 3.2.4 and "
"3.3.1 it incorrectly defaulted to ``0`` which was unbuffered and allowed "
"short reads.  This was unintentional and did not match the behavior of "
"Python 2 as most code expected."
msgstr ""
"*bufsize*\\의 기본값은 이제 -1이 되어 대부분의 코드가 기대하는 동작과 일치하도록 기본적으로 버퍼링을 활성화합니다. "
"파이썬 3.2.4\\와 3.3.1 이전 버전에서는 버퍼링 되지 않고 짧은 읽기를 허용하는 :const:`0`\\으로 기본값이 잘못 "
"설정되었습니다. 이것은 의도하지 않은 것이며 대부분의 코드가 기대하는 파이썬 2의 동작과 일치하지 않았습니다."

#: ../../library/subprocess.rst:487
msgid ""
"The *executable* argument specifies a replacement program to execute.   "
"It is very seldom needed.  When ``shell=False``, *executable* replaces "
"the program to execute specified by *args*.  However, the original *args*"
" is still passed to the program.  Most programs treat the program "
"specified by *args* as the command name, which can then be different from"
" the program actually executed.  On POSIX, the *args* name becomes the "
"display name for the executable in utilities such as :program:`ps`.  If "
"``shell=True``, on POSIX the *executable* argument specifies a "
"replacement shell for the default :file:`/bin/sh`."
msgstr ""
"*executable* 인자는 실행할 대체 프로그램을 지정합니다. 거의 필요하지 않습니다. ``shell=False``\\일 때, "
"*executable*\\은 *args*\\에 의해 지정된 프로그램을 대체합니다. 그러나, 원래 *args*\\는 여전히 "
"프로그램으로 전달됩니다. 대부분의 프로그램은 *args*\\에 의해 지정된 프로그램을 명령 이름으로 취급합니다, 그래서 실제로 "
"실행되는 프로그램과 다를 수 있습니다. POSIX에서, *args* 이름은 :program:`ps`\\와 같은 유틸리티에서 실행 "
"파일의 표시 이름이 됩니다. ``shell=True``\\이면, POSIX에서 *executable* 인자는 기본 "
":file:`/bin/sh`\\의 대체 셸을 지정합니다."

#: ../../library/subprocess.rst:497
msgid "*executable* parameter accepts a :term:`path-like object` on POSIX."
msgstr "POSIX에서 *executable* 매개 변수는 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/subprocess.rst:500
msgid ""
"*executable* parameter accepts a bytes and :term:`path-like object` on "
"Windows."
msgstr ""
"윈도우에서 *executable* 매개 변수는 바이트열과 :term:`경로류 객체 <path-like object>`\\를 "
"받아들입니다."

#: ../../library/subprocess.rst:512
#, fuzzy
msgid ""
"*stdin*, *stdout* and *stderr* specify the executed program's standard "
"input, standard output and standard error file handles, respectively.  "
"Valid values are ``None``, :data:`PIPE`, :data:`DEVNULL`, an existing "
"file descriptor (a positive integer), and an existing :term:`file object`"
" with a valid file descriptor.  With the default settings of ``None``, no"
" redirection will occur.  :data:`PIPE` indicates that a new pipe to the "
"child should be created.  :data:`DEVNULL` indicates that the special file"
" :data:`os.devnull` will be used.  Additionally, *stderr* can be "
":data:`STDOUT`, which indicates that the stderr data from the "
"applications should be captured into the same file handle as for "
"*stdout*."
msgstr ""
"*stdin*, *stdout* 및 *stderr*\\은 각각 실행된 프로그램의 표준 입력, 표준 출력 및 표준 에러 파일 핸들을 "
"지정합니다. 유효한 값은 :data:`PIPE`, :data:`DEVNULL`, 기존 파일 기술자 (양의 정수), 기존 "
":term:`파일 객체 <file object>` 및 ``None``\\입니다. :data:`PIPE`\\는 자식에 대한 새 "
"파이프를 만들어야 함을 나타냅니다. :data:`DEVNULL`\\은 특수 파일 :data:`os.devnull`\\이 사용될 "
"것임을 나타냅니다. 기본 설정 ``None``\\으로는, 리디렉션이 발생하지 않습니다; 자식의 파일 핸들은 부모로부터 상속됩니다. "
"또한, *stderr*\\은 :data:`STDOUT`\\일 수 있으며, 이는 응용 프로그램의 stderr 데이터가 stdout과 "
"같은 파일 핸들로 캡처되어야 함을 나타냅니다."

#: ../../library/subprocess.rst:523
msgid ""
"If *preexec_fn* is set to a callable object, this object will be called "
"in the child process just before the child is executed. (POSIX only)"
msgstr ""
"*preexec_fn*\\이 콜러블 객체로 설정되면, 이 객체는 자식 프로세스가 실행되기 직전에 자식 프로세스에서 호출됩니다. "
"(POSIX 전용)"

#: ../../library/subprocess.rst:529
#, fuzzy
msgid ""
"The *preexec_fn* parameter is NOT SAFE to use in the presence of threads "
"in your application.  The child process could deadlock before exec is "
"called."
msgstr ""
"*preexec_fn* 매개 변수는 응용 프로그램에 스레드가 있을 때 사용하기에 안전하지 않습니다. exec가 호출되기 전에 자식 "
"프로세스가 교착 상태에 빠질 수 있습니다. 반드시 사용해야 한다면, 단순하게 유지하십시오! 호출하는 라이브러리 수를 최소화하십시오."

#: ../../library/subprocess.rst:535
#, fuzzy
msgid ""
"If you need to modify the environment for the child use the *env* "
"parameter rather than doing it in a *preexec_fn*. The *start_new_session*"
" and *process_group* parameters should take the place of code using "
"*preexec_fn* to call :func:`os.setsid` or :func:`os.setpgid` in the "
"child."
msgstr ""
"자식의 환경을 수정해야 하면 *preexec_fn*\\에서 하지 말고 *env* 매개 변수를 사용하십시오. "
"*start_new_session* 매개 변수는 이전에 일반적으로 사용된 *preexec_fn*\\을 대신하여 자식에서 "
"os.setsid()를 호출할 수 있습니다."

#: ../../library/subprocess.rst:542
msgid ""
"The *preexec_fn* parameter is no longer supported in subinterpreters. The"
" use of the parameter in a subinterpreter raises :exc:`RuntimeError`. The"
" new restriction may affect applications that are deployed in mod_wsgi, "
"uWSGI, and other embedded environments."
msgstr ""
"서브 인터프리터에서 *preexec_fn* 매개 변수가 더는 지원되지 않습니다. 서브 인터프리터에서 매개 변수를 사용하면 "
":exc:`RuntimeError`\\가 발생합니다. 새로운 제약 사항은 mod_wsgi, uWSGI 및 기타 "
"내장(embedded) 환경에 배치된 응용 프로그램에 영향을 줄 수 있습니다."

#: ../../library/subprocess.rst:547
#, fuzzy
msgid ""
"If *close_fds* is true, all file descriptors except ``0``, ``1`` and "
"``2`` will be closed before the child process is executed.  Otherwise "
"when *close_fds* is false, file descriptors obey their inheritable flag "
"as described in :ref:`fd_inheritance`."
msgstr ""
"*close_fds*\\가 참이면, :const:`0`, :const:`1` 및 :const:`2`\\를 제외한 모든 파일 기술자가"
" 자식 프로세스가 실행되기 전에 닫힙니다. 그렇지 않고 *close_fds*\\가 거짓이면, 파일 기술자는 "
":ref:`fd_inheritance`\\에 설명된 대로 상속 가능 플래그를 따릅니다."

#: ../../library/subprocess.rst:552
msgid ""
"On Windows, if *close_fds* is true then no handles will be inherited by "
"the child process unless explicitly passed in the ``handle_list`` element"
" of :attr:`STARTUPINFO.lpAttributeList`, or by standard handle "
"redirection."
msgstr ""
"윈도우에서, *close_fds*\\가 참이면 :attr:`STARTUPINFO.lpAttributeList`\\의 "
"``handle_list`` 요소에 명시적으로 전달되거나 표준 핸들 리디렉션에 의하지 않는 한 자식 프로세스가 핸들을 상속하지 "
"않습니다."

#: ../../library/subprocess.rst:556
msgid ""
"The default for *close_fds* was changed from :const:`False` to what is "
"described above."
msgstr "*close_fds*\\의 기본값은 :const:`False`\\에서 위에서 설명한 것으로 변경되었습니다."

#: ../../library/subprocess.rst:560
msgid ""
"On Windows the default for *close_fds* was changed from :const:`False` to"
" :const:`True` when redirecting the standard handles. It's now possible "
"to set *close_fds* to :const:`True` when redirecting the standard "
"handles."
msgstr ""
"윈도우에서 표준 핸들을 리디렉션 할 때 *close_fds*\\의 기본값이 :const:`False`\\에서 "
":const:`True`\\로 변경되었습니다. 이제 표준 핸들을 리디렉션 할 때 *close_fds*\\를 "
":const:`True`\\로 설정할 수 있습니다."

#: ../../library/subprocess.rst:565
msgid ""
"*pass_fds* is an optional sequence of file descriptors to keep open "
"between the parent and child.  Providing any *pass_fds* forces "
"*close_fds* to be :const:`True`.  (POSIX only)"
msgstr ""
"*pass_fds*\\는 부모와 자식 사이에 열려있는 파일 기술자의 선택적 시퀀스입니다. *pass_fds*\\를 제공하면 "
"*close_fds*\\가 :const:`True`\\가 됩니다. (POSIX 전용)"

#: ../../library/subprocess.rst:569
msgid "The *pass_fds* parameter was added."
msgstr "*pass_fds* 매개 변수가 추가되었습니다."

#: ../../library/subprocess.rst:572
#, fuzzy
msgid ""
"If *cwd* is not ``None``, the function changes the working directory to "
"*cwd* before executing the child.  *cwd* can be a string, bytes or :term"
":`path-like <path-like object>` object.  On POSIX, the function looks for"
" *executable* (or for the first item in *args*) relative to *cwd* if the "
"executable path is a relative path."
msgstr ""
"*cwd*\\가 ``None``\\이 아니면, 함수는 자식을 실행하기 전에 작업 디렉터리를 *cwd*\\로 변경합니다. "
"*cwd*\\는 문자열, 바이트열 또는 :term:`경로류 <path-like object>` 객체일 수 있습니다. 특히, 함수는 "
"실행 파일 경로가 상대 경로이면 *cwd*\\를 기준으로 *executable*\\(또는 *args*\\의 첫 번째 항목)을 "
"찾습니다."

#: ../../library/subprocess.rst:578
msgid "*cwd* parameter accepts a :term:`path-like object` on POSIX."
msgstr "POSIX에서 *cwd* 매개 변수는 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/subprocess.rst:581
msgid "*cwd* parameter accepts a :term:`path-like object` on Windows."
msgstr "윈도우에서 *cwd* 매개 변수는 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../../library/subprocess.rst:584
msgid "*cwd* parameter accepts a bytes object on Windows."
msgstr "윈도우에서 *cwd* 매개 변수는 바이트열 객체를 받아들입니다."

#: ../../library/subprocess.rst:587
msgid ""
"If *restore_signals* is true (the default) all signals that Python has "
"set to SIG_IGN are restored to SIG_DFL in the child process before the "
"exec. Currently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals. "
"(POSIX only)"
msgstr ""
"*restore_signals*\\가 참(기본값)이면 파이썬이 SIG_IGN으로 설정한 모든 시그널은 실행 전에 자식 프로세스에서 "
"SIG_DFL로 복원됩니다. 현재 여기에는 SIGPIPE, SIGXFZ 및 SIGXFSZ 시그널이 포함됩니다. (POSIX 전용)"

#: ../../library/subprocess.rst:592
msgid "*restore_signals* was added."
msgstr "*restore_signals*\\가 추가되었습니다."

#: ../../library/subprocess.rst:595
#, fuzzy
msgid ""
"If *start_new_session* is true the ``setsid()`` system call will be made "
"in the child process prior to the execution of the subprocess."
msgstr ""
"*start_new_session*\\이 참이면 서브 프로세스를 실행하기 전에 자식 프로세스에서 setsid() 시스템 호출이 "
"수행됩니다. (POSIX 전용)"

#: ../../library/subprocess.rst:599
msgid "*start_new_session* was added."
msgstr "*start_new_session*\\이 추가되었습니다."

#: ../../library/subprocess.rst:602
#, fuzzy
msgid ""
"If *process_group* is a non-negative integer, the ``setpgid(0, value)`` "
"system call will be made in the child process prior to the execution of "
"the subprocess."
msgstr "*umask*\\가 음이 아니면, 서브 프로세스를 실행하기 전에 자식 프로세스에서 umask() 시스템 호출이 수행됩니다."

#: ../../library/subprocess.rst:606
#, fuzzy
msgid "*process_group* was added."
msgstr "*timeout*\\이 추가되었습니다."

#: ../../library/subprocess.rst:609
#, fuzzy
msgid ""
"If *group* is not ``None``, the setregid() system call will be made in "
"the child process prior to the execution of the subprocess. If the "
"provided value is a string, it will be looked up via :func:`grp.getgrnam`"
" and the value in ``gr_gid`` will be used. If the value is an integer, it"
" will be passed verbatim. (POSIX only)"
msgstr ""
"*group*\\이 ``None``\\이 아니면, 서브 프로세스를 실행하기 전에 자식 프로세스에서 setregid() 시스템 호출이"
" 수행됩니다. 제공된 값이 문자열이면, :func:`grp.getgrnam()`\\을 통해 조회되고 ``gr_gid``\\의 값이 "
"사용됩니다. 값이 정수이면, 그대로 전달됩니다. (POSIX 전용)"

#: ../../library/subprocess.rst:618
#, fuzzy
msgid ""
"If *extra_groups* is not ``None``, the setgroups() system call will be "
"made in the child process prior to the execution of the subprocess. "
"Strings provided in *extra_groups* will be looked up via "
":func:`grp.getgrnam` and the values in ``gr_gid`` will be used. Integer "
"values will be passed verbatim. (POSIX only)"
msgstr ""
"*extra_groups*\\가 ``None``\\이 아니면, 서브 프로세스를 실행하기 전에 자식 프로세스에서 setgroups()"
" 시스템 호출이 수행됩니다. *extra_groups*\\에 제공된 문자열은 :func:`grp.getgrnam()`\\을 통해 "
"조회되며 ``gr_gid``\\의 값이 사용됩니다. 정숫값은 그대로 전달됩니다. (POSIX 전용)"

#: ../../library/subprocess.rst:627
#, fuzzy
msgid ""
"If *user* is not ``None``, the setreuid() system call will be made in the"
" child process prior to the execution of the subprocess. If the provided "
"value is a string, it will be looked up via :func:`pwd.getpwnam` and the "
"value in ``pw_uid`` will be used. If the value is an integer, it will be "
"passed verbatim. (POSIX only)"
msgstr ""
"*user*\\가 ``None``\\이 아니면, 서브 프로세스를 실행하기 전에 자식 프로세스에서 setreuid() 시스템 호출이 "
"수행됩니다. 제공된 값이 문자열이면, :func:`pwd.getpwnam()`\\을 통해 조회되고 ``pw_uid``\\의 값이 "
"사용됩니다. 값이 정수이면, 그대로 전달됩니다. (POSIX 전용)"

#: ../../library/subprocess.rst:636
msgid ""
"If *umask* is not negative, the umask() system call will be made in the "
"child process prior to the execution of the subprocess."
msgstr "*umask*\\가 음이 아니면, 서브 프로세스를 실행하기 전에 자식 프로세스에서 umask() 시스템 호출이 수행됩니다."

#: ../../library/subprocess.rst:642
#, fuzzy
msgid ""
"If *env* is not ``None``, it must be a mapping that defines the "
"environment variables for the new process; these are used instead of the "
"default behavior of inheriting the current process' environment. This "
"mapping can be str to str on any platform or bytes to bytes on POSIX "
"platforms much like :data:`os.environ` or :data:`os.environb`."
msgstr ""
"*env*\\가 ``None``\\이 아니면, 새 프로세스의 환경 변수를 정의하는 매핑이어야 합니다; 이것은 현재 프로세스의 환경을"
" 상속하는 기본 동작 대신 사용됩니다. :class:`Popen`\\으로 직접 전달됩니다."

#: ../../library/subprocess.rst:650
msgid ""
"If specified, *env* must provide any variables required for the program "
"to execute.  On Windows, in order to run a `side-by-side assembly`_ the "
"specified *env* **must** include a valid :envvar:`SystemRoot`."
msgstr ""
"지정되면, *env*\\는 프로그램 실행에 필요한 모든 변수를 제공해야 합니다. 윈도우에서, `side-by-side "
"assembly`_\\를 실행하려면 지정된 *env*\\에 유효한 :envvar:`SystemRoot`\\가 **반드시** "
"포함되어야 합니다."

#: ../../library/subprocess.rst:656
#, fuzzy
msgid ""
"If *encoding* or *errors* are specified, or *text* is true, the file "
"objects *stdin*, *stdout* and *stderr* are opened in text mode with the "
"specified *encoding* and *errors*, as described above in :ref"
":`frequently-used-arguments`. The *universal_newlines* argument is "
"equivalent  to *text* and is provided for backwards compatibility. By "
"default, file objects are opened in binary mode."
msgstr ""
"*encoding*\\이나 *errors*\\가 지정되거나, *text*\\가 참이면, 파일 객체 *stdin*, *stdout* "
"및 *stderr*\\은 위의 :ref:`frequently-used-arguments`\\에서 설명한 대로 지정된 "
"encoding과 *errors*\\로 텍스트 모드로 열립니다. *universal_newlines* 인자는 *text*\\와 "
"동등하며 이전 버전과의 호환성을 위해 제공됩니다. 기본적으로, 파일 객체는 바이너리 모드로 열립니다."

#: ../../library/subprocess.rst:662
msgid "*encoding* and *errors* were added."
msgstr "*encoding*\\과 *errors*\\가 추가되었습니다."

#: ../../library/subprocess.rst:665 ../../library/subprocess.rst:1312
msgid "*text* was added as a more readable alias for *universal_newlines*."
msgstr "*text*\\가 *universal_newlines*\\의 더 가독성 있는 별칭으로 추가되었습니다."

#: ../../library/subprocess.rst:668
#, fuzzy
msgid ""
"If given, *startupinfo* will be a :class:`STARTUPINFO` object, which is "
"passed to the underlying ``CreateProcess`` function."
msgstr ""
"주어지면, *startupinfo*\\는 :class:`STARTUPINFO` 객체가 되며, 하부 ``CreateProcess`` "
"함수로 전달됩니다. 주어지면, *creationflags*\\는 다음 플래그 중 하나 이상일 수 있습니다:"

#: ../../library/subprocess.rst:671
msgid "If given, *creationflags*, can be one or more of the following flags:"
msgstr ""

#: ../../library/subprocess.rst:673
msgid ":data:`CREATE_NEW_CONSOLE`"
msgstr ":data:`CREATE_NEW_CONSOLE`"

#: ../../library/subprocess.rst:674
msgid ":data:`CREATE_NEW_PROCESS_GROUP`"
msgstr ":data:`CREATE_NEW_PROCESS_GROUP`"

#: ../../library/subprocess.rst:675
msgid ":data:`ABOVE_NORMAL_PRIORITY_CLASS`"
msgstr ":data:`ABOVE_NORMAL_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:676
msgid ":data:`BELOW_NORMAL_PRIORITY_CLASS`"
msgstr ":data:`BELOW_NORMAL_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:677
msgid ":data:`HIGH_PRIORITY_CLASS`"
msgstr ":data:`HIGH_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:678
msgid ":data:`IDLE_PRIORITY_CLASS`"
msgstr ":data:`IDLE_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:679
msgid ":data:`NORMAL_PRIORITY_CLASS`"
msgstr ":data:`NORMAL_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:680
msgid ":data:`REALTIME_PRIORITY_CLASS`"
msgstr ":data:`REALTIME_PRIORITY_CLASS`"

#: ../../library/subprocess.rst:681
msgid ":data:`CREATE_NO_WINDOW`"
msgstr ":data:`CREATE_NO_WINDOW`"

#: ../../library/subprocess.rst:682
msgid ":data:`DETACHED_PROCESS`"
msgstr ":data:`DETACHED_PROCESS`"

#: ../../library/subprocess.rst:683
msgid ":data:`CREATE_DEFAULT_ERROR_MODE`"
msgstr ":data:`CREATE_DEFAULT_ERROR_MODE`"

#: ../../library/subprocess.rst:684
msgid ":data:`CREATE_BREAKAWAY_FROM_JOB`"
msgstr ":data:`CREATE_BREAKAWAY_FROM_JOB`"

#: ../../library/subprocess.rst:686
msgid ""
"*pipesize* can be used to change the size of the pipe when :data:`PIPE` "
"is used for *stdin*, *stdout* or *stderr*. The size of the pipe is only "
"changed on platforms that support this (only Linux at this time of "
"writing). Other platforms will ignore this parameter."
msgstr ""

#: ../../library/subprocess.rst:691
#, fuzzy
msgid "Added the *pipesize* parameter."
msgstr "*encoding*\\과 *errors* 매개 변수를 추가했습니다."

#: ../../library/subprocess.rst:694
msgid ""
"Popen objects are supported as context managers via the :keyword:`with` "
"statement: on exit, standard file descriptors are closed, and the process"
" is waited for. ::"
msgstr ""
"Popen 객체는 :keyword:`with` 문을 통해 컨텍스트 관리자로 지원됩니다; 빠져나갈 때, 표준 파일 기술자가 닫히고 "
"프로세스를 기다립니다. ::"

#: ../../library/subprocess.rst:698
msgid ""
"with Popen([\"ifconfig\"], stdout=PIPE) as proc:\n"
"    log.write(proc.stdout.read())"
msgstr ""

#: ../../library/subprocess.rst:701 ../../library/subprocess.rst:703
msgid ""
"Popen and the other functions in this module that use it raise an "
":ref:`auditing event <auditing>` ``subprocess.Popen`` with arguments "
"``executable``, ``args``, ``cwd``, and ``env``. The value for ``args`` "
"may be a single string or a list of strings, depending on platform."
msgstr ""
"Popen과 이 모듈에서 이를 사용하는 다른 함수는 인자 ``executable``, ``args``, ``cwd`` 및 "
"``env``\\로 :ref:`감사 이벤트 <auditing>` ``subprocess.Popen``\\을 발생시킵니다. "
"``args``\\의 값은 플랫폼에 따라 단일 문자열이나 문자열 리스트일 수 있습니다."

#: ../../library/subprocess.rst:708
msgid "Added context manager support."
msgstr "컨텍스트 관리자 지원이 추가되었습니다."

#: ../../library/subprocess.rst:711
msgid ""
"Popen destructor now emits a :exc:`ResourceWarning` warning if the child "
"process is still running."
msgstr ""
"자식 프로세스가 여전히 실행 중이면 이제 Popen 파괴자(destructor)가 :exc:`ResourceWarning` 경고를 "
"발생시킵니다."

#: ../../library/subprocess.rst:715
msgid ""
"Popen can use :func:`os.posix_spawn` in some cases for better "
"performance. On Windows Subsystem for Linux and QEMU User Emulation, "
"Popen constructor using :func:`os.posix_spawn` no longer raise an "
"exception on errors like missing program, but the child process fails "
"with a non-zero :attr:`~Popen.returncode`."
msgstr ""
"Popen은 성능 향상을 위해 때에 따라 :func:`os.posix_spawn`\\을 사용할 수 있습니다. 리눅스용 윈도우 서브 "
"시스템(Windows Subsystem for Linux)과 QEMU 사용자 에뮬레이션(QEMU User Emulation)에서, "
":func:`os.posix_spawn`\\을 사용하는 Popen 생성자는 더는 프로그램 누락과 같은 에러에 대한 예외를 발생시키지"
" 않지만, 자식 프로세스는 0이 아닌 :attr:`~Popen.returncode`\\로 실패합니다."

#: ../../library/subprocess.rst:724
msgid "Exceptions"
msgstr "예외"

#: ../../library/subprocess.rst:726
msgid ""
"Exceptions raised in the child process, before the new program has "
"started to execute, will be re-raised in the parent."
msgstr "새 프로그램이 실행을 시작하기 전에 자식 프로세스에서 발생한 예외는 부모에서 다시 발생합니다."

#: ../../library/subprocess.rst:729
msgid ""
"The most common exception raised is :exc:`OSError`.  This occurs, for "
"example, when trying to execute a non-existent file.  Applications should"
" prepare for :exc:`OSError` exceptions. Note that, when ``shell=True``, "
":exc:`OSError` will be raised by the child only if the selected shell "
"itself was not found. To determine if the shell failed to find the "
"requested application, it is necessary to check the return code or output"
" from the subprocess."
msgstr ""

#: ../../library/subprocess.rst:736
msgid ""
"A :exc:`ValueError` will be raised if :class:`Popen` is called with "
"invalid arguments."
msgstr ":class:`Popen`\\이 유효하지 않은 인자로 호출되면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/subprocess.rst:739
msgid ""
":func:`check_call` and :func:`check_output` will raise "
":exc:`CalledProcessError` if the called process returns a non-zero return"
" code."
msgstr ""
"호출된 프로세스가 0이 아닌 반환 코드를 반환하면 :func:`check_call`\\과 :func:`check_output`\\은"
" :exc:`CalledProcessError`\\를 발생시킵니다."

#: ../../library/subprocess.rst:743
#, fuzzy
msgid ""
"All of the functions and methods that accept a *timeout* parameter, such "
"as :func:`run` and :meth:`Popen.communicate` will raise "
":exc:`TimeoutExpired` if the timeout expires before the process exits."
msgstr ""
":func:`call`\\과 :meth:`Popen.communicate`\\와 같은 *timeout* 매개 변수를 받아들이는 모든"
" 함수와 메서드는 프로세스가 종료되기 전에 시간제한이 만료되면 :exc:`TimeoutExpired`\\를 발생시킵니다."

#: ../../library/subprocess.rst:747
msgid "Exceptions defined in this module all inherit from :exc:`SubprocessError`."
msgstr "이 모듈에 정의된 예외는 모두 :exc:`SubprocessError`\\를 상속합니다."

#: ../../library/subprocess.rst:749
msgid "The :exc:`SubprocessError` base class was added."
msgstr ":exc:`SubprocessError` 베이스 클래스가 추가되었습니다."

#: ../../library/subprocess.rst:755
msgid "Security Considerations"
msgstr "보안 고려 사항"

#: ../../library/subprocess.rst:757
#, fuzzy
msgid ""
"Unlike some other popen functions, this library will not implicitly "
"choose to call a system shell.  This means that all characters, including"
" shell metacharacters, can safely be passed to child processes. If the "
"shell is invoked explicitly, via ``shell=True``, it is the application's "
"responsibility to ensure that all whitespace and metacharacters are "
"quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. On :ref:`some platforms <shlex-quote-warning>`, it is "
"possible to use :func:`shlex.quote` for this escaping."
msgstr ""
"다른 popen 함수와 달리, 이 구현은 절대로 시스템 셸을 묵시적으로 호출하지 않습니다. 이는 셸 메타 문자를 포함한 모든 문자를"
" 자식 프로세스로 안전하게 전달할 수 있음을 의미합니다. ``shell=True``\\를 통해 셸을 명시적으로 호출하면, `셸 주입"
" <https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ 취약점을 "
"피하고자 모든 공백과 메타 문자를 적절하게 인용하는 것은 응용 프로그램의 책임입니다."

#: ../../library/subprocess.rst:767
msgid ""
"On Windows, batch files (:file:`*.bat` or :file:`*.cmd`) may be launched "
"by the operating system in a system shell regardless of the arguments "
"passed to this library. This could result in arguments being parsed "
"according to shell rules, but without any escaping added by Python. If "
"you are intentionally launching a batch file with arguments from "
"untrusted sources, consider passing ``shell=True`` to allow Python to "
"escape special characters. See :gh:`114539` for additional discussion."
msgstr ""

#: ../../library/subprocess.rst:777
msgid "Popen Objects"
msgstr "Popen 객체"

#: ../../library/subprocess.rst:779
msgid "Instances of the :class:`Popen` class have the following methods:"
msgstr ":class:`Popen` 클래스의 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/subprocess.rst:784
msgid ""
"Check if child process has terminated.  Set and return "
":attr:`~Popen.returncode` attribute. Otherwise, returns ``None``."
msgstr ""
"자식 프로세스가 종료되었는지 확인합니다. :attr:`~Popen.returncode` 어트리뷰트를 설정하고 반환합니다. 그렇지 "
"않으면, ``None``\\을 반환합니다."

#: ../../library/subprocess.rst:790
msgid ""
"Wait for child process to terminate.  Set and return "
":attr:`~Popen.returncode` attribute."
msgstr "자식 프로세스가 종료될 때까지 기다립니다. :attr:`~Popen.returncode` 어트리뷰트를 설정하고 반환합니다."

#: ../../library/subprocess.rst:793
msgid ""
"If the process does not terminate after *timeout* seconds, raise a "
":exc:`TimeoutExpired` exception.  It is safe to catch this exception and "
"retry the wait."
msgstr ""
"*timeout* 초 후에 프로세스가 종료되지 않으면, :exc:`TimeoutExpired` 예외를 발생시킵니다. 이 예외를 잡고"
" 다시 기다리는 것은 안전합니다."

#: ../../library/subprocess.rst:799
msgid ""
"This will deadlock when using ``stdout=PIPE`` or ``stderr=PIPE`` and the "
"child process generates enough output to a pipe such that it blocks "
"waiting for the OS pipe buffer to accept more data. Use "
":meth:`Popen.communicate` when using pipes to avoid that."
msgstr ""
"이는 ``stdout=PIPE``\\나 ``stderr=PIPE``\\를 사용하고 자식 프로세스가 파이프에 너무 많은 출력을 보내서"
" OS 파이프 버퍼가 더 많은 데이터를 받아들일 때까지 기다리느라 블록하면 교착 상태에 빠집니다. 파이프를 사용할 때 이를 피하려면"
" :meth:`Popen.communicate`\\를 사용하십시오."

#: ../../library/subprocess.rst:806
#, fuzzy
msgid ""
"When the ``timeout`` parameter is not ``None``, then (on POSIX) the "
"function is implemented using a busy loop (non-blocking call and short "
"sleeps). Use the :mod:`asyncio` module for an asynchronous wait: see "
":class:`asyncio.create_subprocess_exec`."
msgstr ""
"이 함수는 비지 루프(비 블로킹 호출과 짧은 잠자기)를 사용하여 구현됩니다. 비동기 대기에는 :mod:`asyncio` 모듈을 "
"사용하십시오: :class:`asyncio.create_subprocess_exec`\\를 참조하십시오."

#: ../../library/subprocess.rst:811 ../../library/subprocess.rst:852
#: ../../library/subprocess.rst:1209 ../../library/subprocess.rst:1249
#: ../../library/subprocess.rst:1303
msgid "*timeout* was added."
msgstr "*timeout*\\이 추가되었습니다."

#: ../../library/subprocess.rst:816
msgid ""
"Interact with process: Send data to stdin.  Read data from stdout and "
"stderr, until end-of-file is reached.  Wait for process to terminate and "
"set the :attr:`~Popen.returncode` attribute.  The optional *input* "
"argument should be data to be sent to the child process, or ``None``, if "
"no data should be sent to the child.  If streams were opened in text "
"mode, *input* must be a string. Otherwise, it must be bytes."
msgstr ""
"프로세스와 상호 작용합니다: stdin에 데이터를 보냅니다. 파일 끝에 도달할 때까지 stdout과 stderr에서 데이터를 "
"읽습니다. 프로세스가 종료될 때까지 기다리고, :attr:`~Popen.returncode` 어트리뷰트를 설정합니다. 선택적 "
"*input* 인자는 자식 프로세스로 전송될 데이터이거나, 자식으로 데이터를 보내지 않으면 ``None``\\이어야 합니다. "
"스트림이 텍스트 모드로 열렸으면, *input*\\은 문자열이어야 합니다. 그렇지 않으면, 바이트열이어야 합니다."

#: ../../library/subprocess.rst:823
msgid ""
":meth:`communicate` returns a tuple ``(stdout_data, stderr_data)``. The "
"data will be strings if streams were opened in text mode; otherwise, "
"bytes."
msgstr ""
":meth:`communicate`\\는 튜플 ``(stdout_data, stderr_data)``\\를 반환합니다. 스트림이 "
"텍스트 모드로 열렸으면 데이터는 문자열이 됩니다. 그렇지 않으면 바이트열입니다."

#: ../../library/subprocess.rst:827
msgid ""
"Note that if you want to send data to the process's stdin, you need to "
"create the Popen object with ``stdin=PIPE``.  Similarly, to get anything "
"other than ``None`` in the result tuple, you need to give ``stdout=PIPE``"
" and/or ``stderr=PIPE`` too."
msgstr ""
"프로세스의 stdin으로 데이터를 보내려면, ``stdin=PIPE``\\를 사용하여 Popen 객체를 만들어야 함에 유의하십시오."
" 마찬가지로, 결과 튜플에서 ``None`` 이외의 것을 얻으려면, ``stdout=PIPE`` 및/또는 "
"``stderr=PIPE``\\도 제공해야 합니다."

#: ../../library/subprocess.rst:832
msgid ""
"If the process does not terminate after *timeout* seconds, a "
":exc:`TimeoutExpired` exception will be raised.  Catching this exception "
"and retrying communication will not lose any output."
msgstr ""
"*timeout* 초 후에 프로세스가 종료되지 않으면, :exc:`TimeoutExpired` 예외가 발생합니다. 이 예외를 잡고 "
"통신을 다시 시도해도 출력이 손실되지 않습니다."

#: ../../library/subprocess.rst:836
msgid ""
"The child process is not killed if the timeout expires, so in order to "
"cleanup properly a well-behaved application should kill the child process"
" and finish communication::"
msgstr ""
"시간제한이 만료되면 자식 프로세스를 죽이지 않습니다, 올바르게 정리하려면 제대로 작동하는 응용 프로그램은 자식 프로세스를 죽이고 "
"통신을 완료해야 합니다::"

#: ../../library/subprocess.rst:840
msgid ""
"proc = subprocess.Popen(...)\n"
"try:\n"
"    outs, errs = proc.communicate(timeout=15)\n"
"except TimeoutExpired:\n"
"    proc.kill()\n"
"    outs, errs = proc.communicate()"
msgstr ""

#: ../../library/subprocess.rst:849
msgid ""
"The data read is buffered in memory, so do not use this method if the "
"data size is large or unlimited."
msgstr "읽은 데이터는 메모리에 버퍼링 되므로, 데이터 크기가 크거나 무제한이면 이 메서드를 사용하지 마십시오."

#: ../../library/subprocess.rst:858
msgid "Sends the signal *signal* to the child."
msgstr "시그널 *signal*\\을 자식에게 보냅니다."

#: ../../library/subprocess.rst:860
msgid "Do nothing if the process completed."
msgstr "프로세스가 완료되었으면 아무것도 하지 않습니다."

#: ../../library/subprocess.rst:864
#, fuzzy
msgid ""
"On Windows, SIGTERM is an alias for :meth:`terminate`. CTRL_C_EVENT and "
"CTRL_BREAK_EVENT can be sent to processes started with a *creationflags* "
"parameter which includes ``CREATE_NEW_PROCESS_GROUP``."
msgstr ""
"윈도우에서, SIGTERM은 :meth:`terminate`\\의 별칭입니다. CTRL_C_EVENT와 "
"CTRL_BREAK_EVENT는 `CREATE_NEW_PROCESS_GROUP`\\을 포함하는 *creationflags* 매개 "
"변수로 시작된 프로세스로 보낼 수 있습니다."

#: ../../library/subprocess.rst:871
#, fuzzy
msgid ""
"Stop the child. On POSIX OSs the method sends :py:const:`~signal.SIGTERM`"
" to the child. On Windows the Win32 API function "
":c:func:`!TerminateProcess` is called to stop the child."
msgstr ""
"자식을 멈춥니다. POSIX OS에서 이 메서드는 SIGTERM을 자식에게 보냅니다. 윈도우에서는 자식을 중지하기 위해 Win32 "
"API 함수 :c:func:`TerminateProcess`\\가 호출됩니다."

#: ../../library/subprocess.rst:878
msgid ""
"Kills the child. On POSIX OSs the function sends SIGKILL to the child. On"
" Windows :meth:`kill` is an alias for :meth:`terminate`."
msgstr ""
"자식을 죽입니다. POSIX OS에서 이 함수는 SIGKILL을 자식에게 보냅니다. 윈도우에서 :meth:`kill`\\은 "
":meth:`terminate`\\의 별칭입니다."

#: ../../library/subprocess.rst:882
msgid ""
"The following attributes are also set by the class for you to access. "
"Reassigning them to new values is unsupported:"
msgstr ""

#: ../../library/subprocess.rst:887
msgid ""
"The *args* argument as it was passed to :class:`Popen` -- a sequence of "
"program arguments or else a single string."
msgstr ":class:`Popen`\\으로 전달된 *args* 인자 -- 프로그램 인자의 시퀀스거나 단일 문자열."

#: ../../library/subprocess.rst:894
#, fuzzy
msgid ""
"If the *stdin* argument was :data:`PIPE`, this attribute is a writeable "
"stream object as returned by :func:`open`. If the *encoding* or *errors* "
"arguments were specified or the *text* or *universal_newlines* argument "
"was ``True``, the stream is a text stream, otherwise it is a byte stream."
" If the *stdin* argument was not :data:`PIPE`, this attribute is "
"``None``."
msgstr ""
"*stdin* 인자가 :data:`PIPE`\\이면, 이 어트리뷰트는 :func:`open`\\이 반환한 쓰기 가능한 스트림 "
"객체입니다. *encoding*\\이나 *errors* 인자가 지정되었거나 *universal_newlines* 인자가 "
"``True``\\이면, 스트림은 텍스트 스트림이고, 그렇지 않으면 바이트 스트림입니다. *stdin* 인자가 "
":data:`PIPE`\\가 아니면, 이 어트리뷰트는 ``None``\\입니다."

#: ../../library/subprocess.rst:903
#, fuzzy
msgid ""
"If the *stdout* argument was :data:`PIPE`, this attribute is a readable "
"stream object as returned by :func:`open`. Reading from the stream "
"provides output from the child process. If the *encoding* or *errors* "
"arguments were specified or the *text* or *universal_newlines* argument "
"was ``True``, the stream is a text stream, otherwise it is a byte stream."
" If the *stdout* argument was not :data:`PIPE`, this attribute is "
"``None``."
msgstr ""
"*stdout* 인자가 :data:`PIPE`\\이면, 이 어트리뷰트는 :func:`open`\\이 반환한 읽기 가능한 스트림 "
"객체입니다. 스트림에서 읽으면 자식 프로세스의 출력을 제공합니다. *encoding*\\이나 *errors* 인자가 지정되었거나 "
"*universal_newlines* 인자가 ``True``\\이면, 스트림은 텍스트 스트림이고, 그렇지 않으면 바이트 "
"스트림입니다. *stdout* 인자가 :data:`PIPE`\\가 아니면, 이 어트리뷰트는 ``None``\\입니다."

#: ../../library/subprocess.rst:913
#, fuzzy
msgid ""
"If the *stderr* argument was :data:`PIPE`, this attribute is a readable "
"stream object as returned by :func:`open`. Reading from the stream "
"provides error output from the child process. If the *encoding* or "
"*errors* arguments were specified or the *text* or *universal_newlines* "
"argument was ``True``, the stream is a text stream, otherwise it is a "
"byte stream. If the *stderr* argument was not :data:`PIPE`, this "
"attribute is ``None``."
msgstr ""
"*stderr* 인자가 :data:`PIPE`\\이면, 이 어트리뷰트는 :func:`open`\\이 반환한 읽기 가능한 스트림 "
"객체입니다. 스트림에서 읽으면 자식 프로세스의 에러 출력을 제공합니다. *encoding*\\이나 *errors* 인자가 "
"지정되었거나 *universal_newlines* 인자가 ``True``\\이면, 스트림은 텍스트 스트림이고, 그렇지 않으면 바이트"
" 스트림입니다. *stderr* 인자가 :data:`PIPE`\\가 아니면, 어트리뷰트는 ``None``\\입니다."

#: ../../library/subprocess.rst:922
msgid ""
"Use :meth:`~Popen.communicate` rather than :attr:`.stdin.write "
"<Popen.stdin>`, :attr:`.stdout.read <Popen.stdout>` or "
":attr:`.stderr.read <Popen.stderr>` to avoid deadlocks due to any of the "
"other OS pipe buffers filling up and blocking the child process."
msgstr ""
"다른 OS 파이프 버퍼가 차고 자식 프로세스를 블로킹하는 것으로 인한 교착 상태를 피하려면 :attr:`.stdin.write "
"<Popen.stdin>`, :attr:`.stdout.read <Popen.stdout>` 또는 "
":attr:`.stderr.read <Popen.stderr>` 대신 :meth:`~Popen.communicate`\\를 "
"사용하십시오."

#: ../../library/subprocess.rst:930
msgid "The process ID of the child process."
msgstr "자식 프로세스의 프로세스 ID"

#: ../../library/subprocess.rst:932
msgid ""
"Note that if you set the *shell* argument to ``True``, this is the "
"process ID of the spawned shell."
msgstr "*shell* 인자를 ``True``\\로 설정하면, 이것은 생성된 셸의 프로세스 ID입니다."

#: ../../library/subprocess.rst:938
#, fuzzy
msgid ""
"The child return code. Initially ``None``, :attr:`returncode` is set by a"
" call to the :meth:`poll`, :meth:`wait`, or :meth:`communicate` methods "
"if they detect that the process has terminated."
msgstr ""
":meth:`poll`\\과 :meth:`wait`\\(그리고 :meth:`communicate`\\에 의해 간접적으로)로 설정된 "
"자식 반환 코드. ``None`` 값은 프로세스가 아직 종료되지 않았음을 나타냅니다."

#: ../../library/subprocess.rst:942
msgid ""
"A ``None`` value indicates that the process hadn't yet terminated at the "
"time of the last method call."
msgstr ""

#: ../../library/subprocess.rst:950
msgid "Windows Popen Helpers"
msgstr "윈도우 Popen 도우미"

#: ../../library/subprocess.rst:952
msgid ""
"The :class:`STARTUPINFO` class and following constants are only available"
" on Windows."
msgstr ":class:`STARTUPINFO` 클래스와 다음 상수는 윈도우에서만 사용 가능합니다."

#: ../../library/subprocess.rst:958
msgid ""
"Partial support of the Windows `STARTUPINFO <https://msdn.microsoft.com"
"/en-us/library/ms686331(v=vs.85).aspx>`__ structure is used for "
":class:`Popen` creation.  The following attributes can be set by passing "
"them as keyword-only arguments."
msgstr ""
"윈도우 `STARTUPINFO <https://msdn.microsoft.com/en-"
"us/library/ms686331(v=vs.85).aspx>`__ 구조체의 부분적인 지원이 :class:`Popen` 생성에 "
"사용됩니다. 다음 어트리뷰트는 키워드 전용 인자로 전달하여 설정할 수 있습니다."

#: ../../library/subprocess.rst:963
msgid "Keyword-only argument support was added."
msgstr "키워드 전용 인자 지원이 추가되었습니다."

#: ../../library/subprocess.rst:968
msgid ""
"A bit field that determines whether certain :class:`STARTUPINFO` "
"attributes are used when the process creates a window. ::"
msgstr "프로세스가 창을 만들 때 특정 :class:`STARTUPINFO` 어트리뷰트가 사용되는지를 결정하는 비트 필드. ::"

#: ../../library/subprocess.rst:971
msgid ""
"si = subprocess.STARTUPINFO()\n"
"si.dwFlags = subprocess.STARTF_USESTDHANDLES | "
"subprocess.STARTF_USESHOWWINDOW"
msgstr ""

#: ../../library/subprocess.rst:976
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESTDHANDLES`, this attribute"
" is the standard input handle for the process. If "
":data:`STARTF_USESTDHANDLES` is not specified, the default for standard "
"input is the keyboard buffer."
msgstr ""
":attr:`dwFlags`\\가 :data:`STARTF_USESTDHANDLES`\\를 지정하면, 이 어트리뷰트는 프로세스의 "
"표준 입력 핸들입니다. :data:`STARTF_USESTDHANDLES`\\가 지정되지 않으면, 표준 입력의 기본값은 키보드 "
"버퍼입니다."

#: ../../library/subprocess.rst:983
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESTDHANDLES`, this attribute"
" is the standard output handle for the process. Otherwise, this attribute"
" is ignored and the default for standard output is the console window's "
"buffer."
msgstr ""
":attr:`dwFlags`\\가 :data:`STARTF_USESTDHANDLES`\\를 지정하면, 이 어트리뷰트는 프로세스의 "
"표준 출력 핸들입니다. 그렇지 않으면, 이 어트리뷰트가 무시되고 표준 출력의 기본값은 콘솔 창의 버퍼입니다."

#: ../../library/subprocess.rst:990
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESTDHANDLES`, this attribute"
" is the standard error handle for the process. Otherwise, this attribute "
"is ignored and the default for standard error is the console window's "
"buffer."
msgstr ""
":attr:`dwFlags`\\가 :data:`STARTF_USESTDHANDLES`\\를 지정하면, 이 어트리뷰트는 프로세스의 "
"표준 에러 핸들입니다. 그렇지 않으면, 이 어트리뷰트는 무시되고 표준 에러의 기본값은 콘솔 창의 버퍼입니다."

#: ../../library/subprocess.rst:996
msgid ""
"If :attr:`dwFlags` specifies :data:`STARTF_USESHOWWINDOW`, this attribute"
" can be any of the values that can be specified in the ``nCmdShow`` "
"parameter for the `ShowWindow <https://msdn.microsoft.com/en-"
"us/library/ms633548(v=vs.85).aspx>`__ function, except for "
"``SW_SHOWDEFAULT``. Otherwise, this attribute is ignored."
msgstr ""
":attr:`dwFlags`\\가 :data:`STARTF_USESHOWWINDOW`\\를 지정하면, 이 어트리뷰트는 "
"``SW_SHOWDEFAULT``\\를 제외하고 `ShowWindow <https://msdn.microsoft.com/en-"
"us/library/ms633548(v=vs.85).aspx>`__ 함수의 ``nCmdShow`` 매개 변수에 지정할 수 있는 값 "
"중 어느 것이건 될 수 있습니다. 그렇지 않으면, 이 어트리뷰트는 무시됩니다."

#: ../../library/subprocess.rst:1003
msgid ""
":data:`SW_HIDE` is provided for this attribute. It is used when "
":class:`Popen` is called with ``shell=True``."
msgstr ""
"이 어트리뷰트에 :data:`SW_HIDE`\\가 제공됩니다. :class:`Popen`\\이 ``shell=True``\\와 함께"
" 호출될 때 사용됩니다."

#: ../../library/subprocess.rst:1008
msgid ""
"A dictionary of additional attributes for process creation as given in "
"``STARTUPINFOEX``, see `UpdateProcThreadAttribute "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms686880(v=vs.85).aspx>`__."
msgstr ""
"``STARTUPINFOEX``\\에 제공된 대로 프로세스 생성을 위한 추가 어트리뷰트 딕셔너리, "
"`UpdateProcThreadAttribute <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms686880(v=vs.85).aspx>`__\\를 참조하십시오."

#: ../../library/subprocess.rst:1012
msgid "Supported attributes:"
msgstr "지원되는 어트리뷰트:"

#: ../../library/subprocess.rst:1014
msgid "**handle_list**"
msgstr "**handle_list**"

#: ../../library/subprocess.rst:1015
msgid ""
"Sequence of handles that will be inherited. *close_fds* must be true if "
"non-empty."
msgstr "상속될 핸들의 시퀀스. 비어 있지 않으면 *close_fds*\\는 참이어야 합니다."

#: ../../library/subprocess.rst:1018
msgid ""
"The handles must be temporarily made inheritable by "
":func:`os.set_handle_inheritable` when passed to the :class:`Popen` "
"constructor, else :class:`OSError` will be raised with Windows error "
"``ERROR_INVALID_PARAMETER`` (87)."
msgstr ""
":class:`Popen` 생성자에 전달될 때 :func:`os.set_handle_inheritable`\\로 핸들을 일시적으로 "
"상속할 수 있도록 만들어야 합니다, 그렇지 않으면 윈도우 에러 ``ERROR_INVALID_PARAMETER`` (87) 로 "
":class:`OSError`\\가 발생합니다."

#: ../../library/subprocess.rst:1025
msgid ""
"In a multithreaded process, use caution to avoid leaking handles that are"
" marked inheritable when combining this feature with concurrent calls to "
"other process creation functions that inherit all handles such as "
":func:`os.system`.  This also applies to standard handle redirection, "
"which temporarily creates inheritable handles."
msgstr ""
"다중 스레드 프로세스에서, 이 기능을 :func:`os.system`\\과 같은 모든 핸들을 상속하는 다른 프로세스 생성 함수에 "
"대한 동시 호출과 결합할 때 상속 가능으로 표시된 핸들의 누수를 피하도록 주의하십시오. 이것은 일시적으로 상속 가능한 핸들을 만드는"
" 표준 핸들 리디렉션에도 적용됩니다."

#: ../../library/subprocess.rst:1035
msgid "Windows Constants"
msgstr "윈도우 상수"

#: ../../library/subprocess.rst:1037
msgid "The :mod:`subprocess` module exposes the following constants."
msgstr ":mod:`subprocess` 모듈은 다음 상수를 노출합니다."

#: ../../library/subprocess.rst:1041
msgid ""
"The standard input device. Initially, this is the console input buffer, "
"``CONIN$``."
msgstr "표준 입력 장치. 처음에는, 콘솔 입력 버퍼입니다, ``CONIN$``."

#: ../../library/subprocess.rst:1046
msgid ""
"The standard output device. Initially, this is the active console screen "
"buffer, ``CONOUT$``."
msgstr "표준 출력 장치. 처음에는, 활성 콘솔 화면 버퍼입니다, ``CONOUT$``."

#: ../../library/subprocess.rst:1051
msgid ""
"The standard error device. Initially, this is the active console screen "
"buffer, ``CONOUT$``."
msgstr "표준 에러 장치. 처음에는, 활성 콘솔 화면 버퍼입니다, ``CONOUT$``."

#: ../../library/subprocess.rst:1056
msgid "Hides the window. Another window will be activated."
msgstr "창을 숨깁니다. 다른 창이 활성화됩니다."

#: ../../library/subprocess.rst:1060
msgid ""
"Specifies that the :attr:`STARTUPINFO.hStdInput`, "
":attr:`STARTUPINFO.hStdOutput`, and :attr:`STARTUPINFO.hStdError` "
"attributes contain additional information."
msgstr ""
":attr:`STARTUPINFO.hStdInput`, :attr:`STARTUPINFO.hStdOutput` 및 "
":attr:`STARTUPINFO.hStdError` 어트리뷰트에 추가 정보가 포함되었음을 지정합니다."

#: ../../library/subprocess.rst:1066
msgid ""
"Specifies that the :attr:`STARTUPINFO.wShowWindow` attribute contains "
"additional information."
msgstr ":attr:`STARTUPINFO.wShowWindow` 어트리뷰트에 추가 정보가 포함되었음을 지정합니다."

#: ../../library/subprocess.rst:1071
msgid ""
"A :attr:`STARTUPINFO.dwFlags` parameter to specify that the *Working in "
"Background* mouse cursor will be displayed while a process is launching. "
"This is the default behavior for GUI processes."
msgstr ""

#: ../../library/subprocess.rst:1080
msgid ""
"A :attr:`STARTUPINFO.dwFlags` parameter to specify that the mouse cursor "
"will not be changed when launching a process."
msgstr ""

#: ../../library/subprocess.rst:1087
msgid ""
"The new process has a new console, instead of inheriting its parent's "
"console (the default)."
msgstr "새로운 프로세스는 부모의 콘솔을 상속(기본값)하는 대신 새로운 콘솔을 갖습니다."

#: ../../library/subprocess.rst:1092
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process group will be created. This flag is necessary for using "
":func:`os.kill` on the subprocess."
msgstr ""
"새 프로세스 그룹이 만들어지도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수. 이 플래그는 서브 "
"프로세스에 :func:`os.kill`\\을 사용하기 위해 필요합니다."

#: ../../library/subprocess.rst:1096
msgid "This flag is ignored if :data:`CREATE_NEW_CONSOLE` is specified."
msgstr ":data:`CREATE_NEW_CONSOLE`\\이 지정되면 이 플래그는 무시됩니다."

#: ../../library/subprocess.rst:1100
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will have an above average priority."
msgstr "새 프로세스가 평균 우선순위를 초과하도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수."

#: ../../library/subprocess.rst:1107
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will have a below average priority."
msgstr "새 프로세스가 평균 우선순위보다 낮도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수."

#: ../../library/subprocess.rst:1114
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will have a high priority."
msgstr "새 프로세스가 높은 우선순위를 갖도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수입니다."

#: ../../library/subprocess.rst:1121
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will have an idle (lowest) priority."
msgstr "새 프로세스가 유휴 (가장 낮은) 우선순위를 갖도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수."

#: ../../library/subprocess.rst:1128
#, fuzzy
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will have a normal priority. (default)"
msgstr "새 프로세스가 보통 우선순위를 갖도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수. (기본값)"

#: ../../library/subprocess.rst:1135
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will have realtime priority. You should almost never use "
"REALTIME_PRIORITY_CLASS, because this interrupts system threads that "
"manage mouse input, keyboard input, and background disk flushing. This "
"class can be appropriate for applications that \"talk\" directly to "
"hardware or that perform brief tasks that should have limited "
"interruptions."
msgstr ""
"새 프로세스가 실시간 우선순위를 갖도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수. "
"REALTIME_PRIORITY_CLASS를 사용하면 마우스 입력, 키보드 입력 및 백그라운드 디스크 플러시를 관리하는 시스템 "
"스레드가 중단되므로 거의 사용하지 않아야 합니다. 이 클래스는 하드웨어와 직접 \"대화\"하거나 중단이 제한되어야 하는 짧은 작업을"
" 수행하는 응용 프로그램에 적합할 수 있습니다."

#: ../../library/subprocess.rst:1146
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will not create a window."
msgstr "새 프로세스가 창을 만들지 않도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수."

#: ../../library/subprocess.rst:1153
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process will not inherit its parent's console. This value cannot be used "
"with CREATE_NEW_CONSOLE."
msgstr ""
"새 프로세스가 부모의 콘솔을 상속하지 않도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수. 이 "
"값은 CREATE_NEW_CONSOLE과 함께 사용할 수 없습니다."

#: ../../library/subprocess.rst:1161
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process does not inherit the error mode of the calling process. Instead, "
"the new process gets the default error mode. This feature is particularly"
" useful for multithreaded shell applications that run with hard errors "
"disabled."
msgstr ""
"새 프로세스가 호출하는 프로세스의 에러 모드를 상속하지 않도록 지정하는 :class:`Popen` ``creationflags`` "
"매개 변수. 대신, 새 프로세스는 기본 에러 모드를 갖습니다. 이 기능은 하드(hard) 에러가 비활성화된 상태로 실행되는 다중 "
"스레드 셸 응용 프로그램에 특히 유용합니다."

#: ../../library/subprocess.rst:1171
msgid ""
"A :class:`Popen` ``creationflags`` parameter to specify that a new "
"process is not associated with the job."
msgstr "새 프로세스가 잡(job)과 연관되지 않도록 지정하는 :class:`Popen` ``creationflags`` 매개 변수."

#: ../../library/subprocess.rst:1179
msgid "Older high-level API"
msgstr "오래된 고수준 API"

#: ../../library/subprocess.rst:1181
msgid ""
"Prior to Python 3.5, these three functions comprised the high level API "
"to subprocess. You can now use :func:`run` in many cases, but lots of "
"existing code calls these functions."
msgstr ""
"파이썬 3.5 이전에는, 이 세 가지 함수가 subprocess에 대한 고수준 API로 구성되었습니다. 이제 많은 경우에 "
":func:`run`\\을 사용할 수 있지만, 많은 기존 코드가 이러한 함수를 호출합니다."

#: ../../library/subprocess.rst:1188
msgid ""
"Run the command described by *args*.  Wait for command to complete, then "
"return the :attr:`~Popen.returncode` attribute."
msgstr ""
"*args*\\로 기술된 명령을 실행합니다. 명령이 완료될 때까지 기다린 후 :attr:`~Popen.returncode` "
"어트리뷰트를 반환합니다."

#: ../../library/subprocess.rst:1191 ../../library/subprocess.rst:1231
msgid "Code needing to capture stdout or stderr should use :func:`run` instead::"
msgstr "stdout이나 stderr을 캡처해야 하는 코드는 대신 :func:`run`\\을 사용해야 합니다::"

#: ../../library/subprocess.rst:1193
msgid "run(...).returncode"
msgstr ""

#: ../../library/subprocess.rst:1195 ../../library/subprocess.rst:1235
msgid "To suppress stdout or stderr, supply a value of :data:`DEVNULL`."
msgstr "stdout이나 stderr을 억제하려면, :data:`DEVNULL` 값을 제공하십시오."

#: ../../library/subprocess.rst:1197 ../../library/subprocess.rst:1237
msgid ""
"The arguments shown above are merely some common ones. The full function "
"signature is the same as that of the :class:`Popen` constructor - this "
"function passes all supplied arguments other than *timeout* directly "
"through to that interface."
msgstr ""
"위에 표시된 인자는 단지 몇 가지 일반적인 인자입니다. 전체 함수 서명은 :class:`Popen` 생성자의 서명과 같습니다 - 이"
" 함수는 *timeout* 이외의 모든 제공된 인자를 해당 인터페이스로 직접 전달합니다."

#: ../../library/subprocess.rst:1204 ../../library/subprocess.rst:1244
msgid ""
"Do not use ``stdout=PIPE`` or ``stderr=PIPE`` with this function.  The "
"child process will block if it generates enough output to a pipe to fill "
"up the OS pipe buffer as the pipes are not being read from."
msgstr ""
"이 함수에 ``stdout=PIPE``\\나 ``stderr=PIPE``\\를 사용하지 마십시오. 파이프를 읽지 않기 때문에 자식 "
"프로세스가 OS 파이프 버퍼를 가득 채우기 충분한 출력을 생성하면 자식 프로세스가 블록 됩니다."

#: ../../library/subprocess.rst:1224
#, fuzzy
msgid ""
"Run command with arguments.  Wait for command to complete. If the return "
"code was zero then return, otherwise raise :exc:`CalledProcessError`. The"
" :exc:`CalledProcessError` object will have the return code in the "
":attr:`~CalledProcessError.returncode` attribute. If :func:`check_call` "
"was unable to start the process it will propagate the exception that was "
"raised."
msgstr ""
"인자로 명령을 실행합니다. 명령이 완료될 때까지 기다립니다. 반환 코드가 0이면 반환합니다, 그렇지 않으면 "
":exc:`CalledProcessError`\\를 발생시킵니다. :exc:`CalledProcessError` 객체는 "
":attr:`~CalledProcessError.returncode` 어트리뷰트에 반환 코드를 갖습니다."

#: ../../library/subprocess.rst:1233
msgid "run(..., check=True)"
msgstr ""

#: ../../library/subprocess.rst:1266
msgid "Run command with arguments and return its output."
msgstr "인자로 명령을 실행하고 출력을 반환합니다."

#: ../../library/subprocess.rst:1268
msgid ""
"If the return code was non-zero it raises a :exc:`CalledProcessError`. "
"The :exc:`CalledProcessError` object will have the return code in the "
":attr:`~CalledProcessError.returncode` attribute and any output in the "
":attr:`~CalledProcessError.output` attribute."
msgstr ""
"반환 코드가 0이 아니면 :exc:`CalledProcessError` 가 발생합니다. "
":exc:`CalledProcessError` 객체는 :attr:`~CalledProcessError.returncode` "
"어트리뷰트에 반환 코드가 있고 :attr:`~CalledProcessError.output` 어트리뷰트에 출력이 있습니다."

#: ../../library/subprocess.rst:1273
msgid "This is equivalent to::"
msgstr "이것은 다음과 동등합니다::"

#: ../../library/subprocess.rst:1275
msgid "run(..., check=True, stdout=PIPE).stdout"
msgstr ""

#: ../../library/subprocess.rst:1277
msgid ""
"The arguments shown above are merely some common ones. The full function "
"signature is largely the same as that of :func:`run` - most arguments are"
" passed directly through to that interface. One API deviation from "
":func:`run` behavior exists: passing ``input=None`` will behave the same "
"as ``input=b''`` (or ``input=''``, depending on other arguments) rather "
"than using the parent's standard input file handle."
msgstr ""
"위에 표시된 인자는 단지 몇 가지 일반적인 인자입니다. 전체 함수 서명은 :func:`run`\\의 서명과 거의 같습니다 - "
"대부분의 인자는 해당 인터페이스로 직접 전달됩니다. :func:`run` 동작과 비교할 때 한가지 API 편차가 있습니다: "
"``input=None``\\을 전달하면 부모의 표준 입력 파일 핸들을 사용하는 대신 ``input=b''`` (또는 다른 인자에 "
"따라 ``input=''``) 와 같게 동작합니다."

#: ../../library/subprocess.rst:1284
msgid ""
"By default, this function will return the data as encoded bytes. The "
"actual encoding of the output data may depend on the command being "
"invoked, so the decoding to text will often need to be handled at the "
"application level."
msgstr ""
"기본적으로, 이 함수는 데이터를 인코딩된 바이트열로 반환합니다. 출력 데이터의 실제 인코딩은 호출되는 명령에 따라 달라질 수 "
"있어서, 텍스트로의 디코딩은 종종 응용 프로그램 수준에서 처리해야 합니다."

#: ../../library/subprocess.rst:1288
msgid ""
"This behaviour may be overridden by setting *text*, *encoding*, *errors*,"
" or *universal_newlines* to ``True`` as described in :ref:`frequently-"
"used-arguments` and :func:`run`."
msgstr ""
":ref:`frequently-used-arguments`\\와 :func:`run`\\에 설명된 대로 *text*, "
"*encoding*, *errors* 또는 *universal_newlines*\\를 ``True``\\로 설정하면 이 동작을 "
"재정의할 수 있습니다."

#: ../../library/subprocess.rst:1292
msgid ""
"To also capture standard error in the result, use "
"``stderr=subprocess.STDOUT``::"
msgstr "결과에서 표준 에러도 캡처하려면 ``stderr=subprocess.STDOUT``\\을 사용하십시오::"

#: ../../library/subprocess.rst:1295
msgid ""
">>> subprocess.check_output(\n"
"...     \"ls non_existent_file; exit 0\",\n"
"...     stderr=subprocess.STDOUT,\n"
"...     shell=True)\n"
"'ls: non_existent_file: No such file or directory\\n'"
msgstr ""

#: ../../library/subprocess.rst:1306
msgid "Support for the *input* keyword argument was added."
msgstr "*input* 키워드 인자에 대한 지원이 추가되었습니다."

#: ../../library/subprocess.rst:1309
msgid "*encoding* and *errors* were added.  See :func:`run` for details."
msgstr "*encoding*\\과 *errors*\\가 추가되었습니다. 자세한 내용은 :func:`run`\\을 참조하십시오."

#: ../../library/subprocess.rst:1327
msgid "Replacing Older Functions with the :mod:`subprocess` Module"
msgstr "이전 함수를 :mod:`subprocess` 모듈로 교체하기"

#: ../../library/subprocess.rst:1329
msgid ""
"In this section, \"a becomes b\" means that b can be used as a "
"replacement for a."
msgstr "이 섹션에서, \"a는 b가 됩니다\"는 b가 a의 대체로 사용될 수 있음을 의미합니다."

#: ../../library/subprocess.rst:1333
msgid ""
"All \"a\" functions in this section fail (more or less) silently if the "
"executed program cannot be found; the \"b\" replacements raise "
":exc:`OSError` instead."
msgstr ""
"이 섹션의 모든 \"a\" 함수는 실행되는 프로그램을 찾을 수 없으면 (다소간) 조용히 실패합니다; \"b\" 대체는 대신 "
":exc:`OSError`\\를 발생시킵니다."

#: ../../library/subprocess.rst:1337
msgid ""
"In addition, the replacements using :func:`check_output` will fail with a"
" :exc:`CalledProcessError` if the requested operation produces a non-zero"
" return code. The output is still available as the "
":attr:`~CalledProcessError.output` attribute of the raised exception."
msgstr ""
"또한, 요청된 연산이 0이 아닌 반환 코드를 생성하면 :func:`check_output`\\을 사용한 대체는 "
":exc:`CalledProcessError`\\로 실패합니다. 출력은 여전히 발생한 예외의 "
":attr:`~CalledProcessError.output` 어트리뷰트로 사용 가능합니다."

#: ../../library/subprocess.rst:1342
msgid ""
"In the following examples, we assume that the relevant functions have "
"already been imported from the :mod:`subprocess` module."
msgstr "다음 예에서는, 관련 함수들을 :mod:`subprocess` 모듈에서 이미 임포트 했다고 가정합니다."

#: ../../library/subprocess.rst:1347
msgid "Replacing :program:`/bin/sh` shell command substitution"
msgstr ":program:`/bin/sh` 셸 명령 치환 교체하기"

#: ../../library/subprocess.rst:1349
msgid "output=$(mycmd myarg)"
msgstr ""

#: ../../library/subprocess.rst:1353 ../../library/subprocess.rst:1364
#: ../../library/subprocess.rst:1381
msgid "becomes::"
msgstr "는 다음처럼 됩니다::"

#: ../../library/subprocess.rst:1355
msgid "output = check_output([\"mycmd\", \"myarg\"])"
msgstr ""

#: ../../library/subprocess.rst:1358
msgid "Replacing shell pipeline"
msgstr "셸 파이프라인 교체하기"

#: ../../library/subprocess.rst:1360 ../../library/subprocess.rst:1377
msgid "output=$(dmesg | grep hda)"
msgstr ""

#: ../../library/subprocess.rst:1366
msgid ""
"p1 = Popen([\"dmesg\"], stdout=PIPE)\n"
"p2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\n"
"p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.\n"
"output = p2.communicate()[0]"
msgstr ""

#: ../../library/subprocess.rst:1371
msgid ""
"The ``p1.stdout.close()`` call after starting the p2 is important in "
"order for p1 to receive a SIGPIPE if p2 exits before p1."
msgstr ""
"p2가 p1보다 먼저 종료될 때 p1이 SIGPIPE를 수신하려면 p2를 시작한 후 ``p1.stdout.close()`` 호출이 "
"중요합니다."

#: ../../library/subprocess.rst:1374
msgid ""
"Alternatively, for trusted input, the shell's own pipeline support may "
"still be used directly:"
msgstr "또는, 신뢰할 수 있는 입력의 경우, 셸의 자체 파이프라인 지원을 계속 사용할 수 있습니다:"

#: ../../library/subprocess.rst:1383
msgid "output = check_output(\"dmesg | grep hda\", shell=True)"
msgstr ""

#: ../../library/subprocess.rst:1387
msgid "Replacing :func:`os.system`"
msgstr ":func:`os.system` 교체하기"

#: ../../library/subprocess.rst:1391
msgid ""
"sts = os.system(\"mycmd\" + \" myarg\")\n"
"# becomes\n"
"retcode = call(\"mycmd\" + \" myarg\", shell=True)"
msgstr ""

#: ../../library/subprocess.rst:1395
msgid "Notes:"
msgstr "노트:"

#: ../../library/subprocess.rst:1397
msgid "Calling the program through the shell is usually not required."
msgstr "보통 셸을 통해 프로그램을 호출할 필요는 없습니다."

#: ../../library/subprocess.rst:1398
msgid ""
"The :func:`call` return value is encoded differently to that of "
":func:`os.system`."
msgstr ""

#: ../../library/subprocess.rst:1401
msgid ""
"The :func:`os.system` function ignores SIGINT and SIGQUIT signals while "
"the command is running, but the caller must do this separately when using"
" the :mod:`subprocess` module."
msgstr ""

#: ../../library/subprocess.rst:1405
msgid "A more realistic example would look like this::"
msgstr "더욱 현실적인 예는 다음과 같습니다::"

#: ../../library/subprocess.rst:1407
msgid ""
"try:\n"
"    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n"
"    if retcode < 0:\n"
"        print(\"Child was terminated by signal\", -retcode, "
"file=sys.stderr)\n"
"    else:\n"
"        print(\"Child returned\", retcode, file=sys.stderr)\n"
"except OSError as e:\n"
"    print(\"Execution failed:\", e, file=sys.stderr)"
msgstr ""

#: ../../library/subprocess.rst:1418
msgid "Replacing the :func:`os.spawn <os.spawnl>` family"
msgstr ":func:`os.spawn <os.spawnl>` 패밀리 교체하기"

#: ../../library/subprocess.rst:1420
msgid "P_NOWAIT example::"
msgstr "P_NOWAIT 예::"

#: ../../library/subprocess.rst:1422
msgid ""
"pid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n"
"==>\n"
"pid = Popen([\"/bin/mycmd\", \"myarg\"]).pid"
msgstr ""

#: ../../library/subprocess.rst:1426
msgid "P_WAIT example::"
msgstr "P_WAIT 예::"

#: ../../library/subprocess.rst:1428
msgid ""
"retcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n"
"==>\n"
"retcode = call([\"/bin/mycmd\", \"myarg\"])"
msgstr ""

#: ../../library/subprocess.rst:1432
msgid "Vector example::"
msgstr "벡터 예::"

#: ../../library/subprocess.rst:1434
msgid ""
"os.spawnvp(os.P_NOWAIT, path, args)\n"
"==>\n"
"Popen([path] + args[1:])"
msgstr ""

#: ../../library/subprocess.rst:1438
msgid "Environment example::"
msgstr "환경 예::"

#: ../../library/subprocess.rst:1440
#, python-brace-format
msgid ""
"os.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n"
"==>\n"
"Popen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})"
msgstr ""

#: ../../library/subprocess.rst:1447
msgid "Replacing :func:`os.popen`, :func:`os.popen2`, :func:`os.popen3`"
msgstr ":func:`os.popen`, :func:`os.popen2`, :func:`os.popen3` 교체하기"

#: ../../library/subprocess.rst:1451
msgid ""
"(child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)\n"
"==>\n"
"p = Popen(cmd, shell=True, bufsize=bufsize,\n"
"          stdin=PIPE, stdout=PIPE, close_fds=True)\n"
"(child_stdin, child_stdout) = (p.stdin, p.stdout)"
msgstr ""

#: ../../library/subprocess.rst:1459
msgid ""
"(child_stdin,\n"
" child_stdout,\n"
" child_stderr) = os.popen3(cmd, mode, bufsize)\n"
"==>\n"
"p = Popen(cmd, shell=True, bufsize=bufsize,\n"
"          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)\n"
"(child_stdin,\n"
" child_stdout,\n"
" child_stderr) = (p.stdin, p.stdout, p.stderr)"
msgstr ""

#: ../../library/subprocess.rst:1471
msgid ""
"(child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)\n"
"==>\n"
"p = Popen(cmd, shell=True, bufsize=bufsize,\n"
"          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)\n"
"(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)"
msgstr ""

#: ../../library/subprocess.rst:1477
msgid "Return code handling translates as follows::"
msgstr "반환 코드 처리는 다음과 같이 번역됩니다::"

#: ../../library/subprocess.rst:1479
msgid ""
"pipe = os.popen(cmd, 'w')\n"
"...\n"
"rc = pipe.close()\n"
"if rc is not None and rc >> 8:\n"
"    print(\"There were some errors\")\n"
"==>\n"
"process = Popen(cmd, stdin=PIPE)\n"
"...\n"
"process.stdin.close()\n"
"if process.wait() != 0:\n"
"    print(\"There were some errors\")"
msgstr ""

#: ../../library/subprocess.rst:1493
#, fuzzy
msgid "Replacing functions from the :mod:`!popen2` module"
msgstr ":mod:`popen2` 모듈의 함수 교체하기"

#: ../../library/subprocess.rst:1497
msgid ""
"If the cmd argument to popen2 functions is a string, the command is "
"executed through /bin/sh.  If it is a list, the command is directly "
"executed."
msgstr "popen2 함수에 대한 cmd 인자가 문자열이면, 명령은 /bin/sh 를 통해 실행됩니다. 리스트면, 명령이 직접 실행됩니다."

#: ../../library/subprocess.rst:1502
msgid ""
"(child_stdout, child_stdin) = popen2.popen2(\"somestring\", bufsize, "
"mode)\n"
"==>\n"
"p = Popen(\"somestring\", shell=True, bufsize=bufsize,\n"
"          stdin=PIPE, stdout=PIPE, close_fds=True)\n"
"(child_stdout, child_stdin) = (p.stdout, p.stdin)"
msgstr ""

#: ../../library/subprocess.rst:1510
msgid ""
"(child_stdout, child_stdin) = popen2.popen2([\"mycmd\", \"myarg\"], "
"bufsize, mode)\n"
"==>\n"
"p = Popen([\"mycmd\", \"myarg\"], bufsize=bufsize,\n"
"          stdin=PIPE, stdout=PIPE, close_fds=True)\n"
"(child_stdout, child_stdin) = (p.stdout, p.stdin)"
msgstr ""

#: ../../library/subprocess.rst:1516
msgid ""
":class:`popen2.Popen3` and :class:`popen2.Popen4` basically work as "
":class:`subprocess.Popen`, except that:"
msgstr ""
":class:`popen2.Popen3`\\과 :class:`popen2.Popen4`\\는 다음과 같은 점을 제외하고는 기본적으로"
" :class:`subprocess.Popen`\\처럼 작동합니다:"

#: ../../library/subprocess.rst:1519
msgid ":class:`Popen` raises an exception if the execution fails."
msgstr "실행이 실패하면 :class:`Popen`\\은 예외를 발생시킵니다."

#: ../../library/subprocess.rst:1521
msgid "The *capturestderr* argument is replaced with the *stderr* argument."
msgstr "*capturestderr* 인자는 *stderr* 인자로 대체됩니다."

#: ../../library/subprocess.rst:1523
msgid "``stdin=PIPE`` and ``stdout=PIPE`` must be specified."
msgstr "``stdin=PIPE``\\와 ``stdout=PIPE``\\를 반드시 지정해야 합니다."

#: ../../library/subprocess.rst:1525
msgid ""
"popen2 closes all file descriptors by default, but you have to specify "
"``close_fds=True`` with :class:`Popen` to guarantee this behavior on all "
"platforms or past Python versions."
msgstr ""
"popen2는 기본적으로 모든 파일 기술자를 닫지만, 모든 플랫폼이나 이전 파이썬 버전에서 이 동작을 보장하려면 "
":class:`Popen`\\에 ``close_fds=True``\\를 지정해야 합니다."

#: ../../library/subprocess.rst:1531
msgid "Legacy Shell Invocation Functions"
msgstr "레거시 셸 호출 함수"

#: ../../library/subprocess.rst:1533
msgid ""
"This module also provides the following legacy functions from the 2.x "
"``commands`` module. These operations implicitly invoke the system shell "
"and none of the guarantees described above regarding security and "
"exception handling consistency are valid for these functions."
msgstr ""
"이 모듈은 2.x ``commands`` 모듈의 다음과 같은 레거시 함수도 제공합니다. 이러한 연산은 시스템 셸을 묵시적으로 "
"호출하고 보안과 예외 처리 일관성과 관련하여 위에서 설명한 보증 중 어느 것도 이러한 함수에 유효하지 않습니다."

#: ../../library/subprocess.rst:1540
msgid "Return ``(exitcode, output)`` of executing *cmd* in a shell."
msgstr "셸에서 *cmd*\\를 실행한 후 ``(exitcode, output)``\\을 반환합니다."

#: ../../library/subprocess.rst:1542
#, fuzzy
msgid ""
"Execute the string *cmd* in a shell with :meth:`Popen.check_output` and "
"return a 2-tuple ``(exitcode, output)``. *encoding* and *errors* are used"
" to decode output; see the notes on :ref:`frequently-used-arguments` for "
"more details."
msgstr ""
":meth:`Popen.check_output`\\으로 셸에서 문자열 *cmd*\\를 실행하고 2-튜플 ``(exitcode, "
"output)``\\을 반환합니다. 로케일 인코딩이 사용됩니다; 자세한 내용은 :ref:`frequently-used-"
"arguments`\\에 대한 참고 사항을 참조하십시오."

#: ../../library/subprocess.rst:1547
msgid ""
"A trailing newline is stripped from the output. The exit code for the "
"command can be interpreted as the return code of subprocess.  Example::"
msgstr "후행 줄 바꿈이 출력에서 제거됩니다. 명령의 종료 코드는 서브 프로세스의 반환 코드로 해석될 수 있습니다. 예::"

#: ../../library/subprocess.rst:1551
msgid ""
">>> subprocess.getstatusoutput('ls /bin/ls')\n"
"(0, '/bin/ls')\n"
">>> subprocess.getstatusoutput('cat /bin/junk')\n"
"(1, 'cat: /bin/junk: No such file or directory')\n"
">>> subprocess.getstatusoutput('/bin/junk')\n"
"(127, 'sh: /bin/junk: not found')\n"
">>> subprocess.getstatusoutput('/bin/kill $$')\n"
"(-15, '')"
msgstr ""

#: ../../library/subprocess.rst:1562
msgid "Windows support was added."
msgstr "윈도우 지원이 추가되었습니다."

#: ../../library/subprocess.rst:1565
msgid ""
"The function now returns (exitcode, output) instead of (status, output) "
"as it did in Python 3.3.3 and earlier.  exitcode has the same value as "
":attr:`~Popen.returncode`."
msgstr ""
"이 함수는 이제 파이썬 3.3.3과 이전 버전에서와같이 (status, output) 대신 (exitcode, output) 을 "
"반환합니다. exitcode는 :attr:`~Popen.returncode`\\와 같은 값을 갖습니다."

#: ../../library/subprocess.rst:1574
msgid "Return output (stdout and stderr) of executing *cmd* in a shell."
msgstr "셸에서 *cmd*\\를 실행한 출력(stdout과 stderr)을 반환합니다."

#: ../../library/subprocess.rst:1576
msgid ""
"Like :func:`getstatusoutput`, except the exit code is ignored and the "
"return value is a string containing the command's output.  Example::"
msgstr ""
"종료 코드를 무시하고 반환 값은 명령의 출력을 포함하는 문자열인 것을 제외하고, :func:`getstatusoutput` 과 "
"유사합니다. 예::"

#: ../../library/subprocess.rst:1579
msgid ""
">>> subprocess.getoutput('ls /bin/ls')\n"
"'/bin/ls'"
msgstr ""

#: ../../library/subprocess.rst:1584
msgid "Windows support added"
msgstr "윈도우 지원이 추가되었습니다"

#: ../../library/subprocess.rst:1592
msgid "Notes"
msgstr "노트"

#: ../../library/subprocess.rst:1597
msgid "Converting an argument sequence to a string on Windows"
msgstr "윈도우에서 인자 시퀀스를 문자열로 변환하기"

#: ../../library/subprocess.rst:1599
msgid ""
"On Windows, an *args* sequence is converted to a string that can be "
"parsed using the following rules (which correspond to the rules used by "
"the MS C runtime):"
msgstr ""
"윈도우에서, *args* 시퀀스는 다음 규칙을 사용하여 구문 분석할 수 있는 문자열로 변환됩니다 (MS C 런타임에서 사용하는 "
"규칙에 해당합니다):"

#: ../../library/subprocess.rst:1603
msgid "Arguments are delimited by white space, which is either a space or a tab."
msgstr "인자는 스페이스나 탭인 공백으로 구분됩니다."

#: ../../library/subprocess.rst:1606
msgid ""
"A string surrounded by double quotation marks is interpreted as a single "
"argument, regardless of white space contained within.  A quoted string "
"can be embedded in an argument."
msgstr "큰따옴표로 묶인 문자열은 포함된 공백과 관계없이 단일 인자로 해석됩니다. 인용된 문자열을 인자에 포함할 수 있습니다."

#: ../../library/subprocess.rst:1611
msgid ""
"A double quotation mark preceded by a backslash is interpreted as a "
"literal double quotation mark."
msgstr "백 슬래시가 앞에 붙는 큰따옴표는 리터럴 큰따옴표로 해석됩니다."

#: ../../library/subprocess.rst:1614
msgid ""
"Backslashes are interpreted literally, unless they immediately precede a "
"double quotation mark."
msgstr "역 슬래시는 큰따옴표 바로 앞에 오지 않는 한 문자 그대로 해석됩니다."

#: ../../library/subprocess.rst:1617
msgid ""
"If backslashes immediately precede a double quotation mark, every pair of"
" backslashes is interpreted as a literal backslash.  If the number of "
"backslashes is odd, the last backslash escapes the next double quotation "
"mark as described in rule 3."
msgstr ""
"역 슬래시가 큰따옴표 바로 앞에 있으면, 모든 역 슬래시 쌍은 리터럴 역 슬래시로 해석됩니다. 역 슬래시 수가 홀수이면, 규칙 3에"
" 설명된 대로 마지막 역 슬래시는 다음 큰따옴표를 이스케이프 합니다."

#: ../../library/subprocess.rst:1626
msgid ":mod:`shlex`"
msgstr ":mod:`shlex`"

#: ../../library/subprocess.rst:1627
msgid "Module which provides function to parse and escape command lines."
msgstr "명령 줄을 구문 분석하고 이스케이프 하는 함수를 제공하는 모듈."

#: ../../library/subprocess.rst:1634
msgid "Disabling use of ``vfork()`` or ``posix_spawn()``"
msgstr ""

#: ../../library/subprocess.rst:1636
msgid ""
"On Linux, :mod:`subprocess` defaults to using the ``vfork()`` system call"
" internally when it is safe to do so rather than ``fork()``. This greatly"
" improves performance."
msgstr ""

#: ../../library/subprocess.rst:1640
msgid ""
"If you ever encounter a presumed highly unusual situation where you need "
"to prevent ``vfork()`` from being used by Python, you can set the "
":const:`subprocess._USE_VFORK` attribute to a false value."
msgstr ""

#: ../../library/subprocess.rst:1646
msgid "subprocess._USE_VFORK = False  # See CPython issue gh-NNNNNN."
msgstr ""

#: ../../library/subprocess.rst:1648
msgid ""
"Setting this has no impact on use of ``posix_spawn()`` which could use "
"``vfork()`` internally within its libc implementation.  There is a "
"similar :const:`subprocess._USE_POSIX_SPAWN` attribute if you need to "
"prevent use of that."
msgstr ""

#: ../../library/subprocess.rst:1655
msgid "subprocess._USE_POSIX_SPAWN = False  # See CPython issue gh-NNNNNN."
msgstr ""

#: ../../library/subprocess.rst:1657
msgid ""
"It is safe to set these to false on any Python version. They will have no"
" effect on older versions when unsupported. Do not assume the attributes "
"are available to read. Despite their names, a true value does not "
"indicate that the corresponding function will be used, only that it may "
"be."
msgstr ""

#: ../../library/subprocess.rst:1662
msgid ""
"Please file issues any time you have to use these private knobs with a "
"way to reproduce the issue you were seeing. Link to that issue from a "
"comment in your code."
msgstr ""

#: ../../library/subprocess.rst:1666
msgid "``_USE_POSIX_SPAWN``"
msgstr ""

#: ../../library/subprocess.rst:1667
msgid "``_USE_VFORK``"
msgstr ""

#: ../../library/subprocess.rst:296
msgid "universal newlines"
msgstr ""

#: ../../library/subprocess.rst:296
#, fuzzy
msgid "subprocess module"
msgstr ":mod:`subprocess` 모듈 사용하기"

#~ msgid ""
#~ "The :func:`run` function was added in"
#~ " Python 3.5; if you need to "
#~ "retain compatibility with older versions, "
#~ "see the :ref:`call-function-trio` "
#~ "section."
#~ msgstr ""
#~ ":func:`run` 함수는 파이썬 3.5에서 추가되었습니다. 이전"
#~ " 버전과의 호환성을 유지해야 하면, :ref:`call-"
#~ "function-trio` 섹션을 참조하십시오."

#~ msgid ":ref:`Availability <availability>`: POSIX"
#~ msgstr ":ref:`가용성 <availability>`: POSIX"

#~ msgid ""
#~ "If *env* is not ``None``, it must"
#~ " be a mapping that defines the "
#~ "environment variables for the new "
#~ "process; these are used instead of "
#~ "the default behavior of inheriting the"
#~ " current process' environment."
#~ msgstr ""
#~ "*env*\\가 ``None``\\이 아니면, 새 프로세스의 환경 "
#~ "변수를 정의하는 매핑이어야 합니다; 현재 프로세스 환경을"
#~ " 상속하는 기본 동작 대신 이것이 사용됩니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``subprocess.Popen`` with arguments ``executable``,"
#~ " ``args``, ``cwd``, ``env``."
#~ msgstr ""
#~ "인자 ``executable``, ``args``, ``cwd``, "
#~ "``env``\\로 :ref:`감사 이벤트 <auditing>` "
#~ "``subprocess.Popen``\\을 발생시킵니다."

#~ msgid ""
#~ "The most common exception raised is "
#~ ":exc:`OSError`.  This occurs, for example, "
#~ "when trying to execute a non-"
#~ "existent file.  Applications should prepare"
#~ " for :exc:`OSError` exceptions."
#~ msgstr ""
#~ "가장 흔한 예외는 :exc:`OSError`\\입니다. 예를 들어,"
#~ " 존재하지 않는 파일을 실행하려고 할 때 발생합니다."
#~ " 응용 프로그램은 :exc:`OSError` 예외에 대비해야 "
#~ "합니다."

#~ msgid ""
#~ "When using ``shell=True``, the "
#~ ":func:`shlex.quote` function can be used "
#~ "to properly escape whitespace and shell"
#~ " metacharacters in strings that are "
#~ "going to be used to construct "
#~ "shell commands."
#~ msgstr ""
#~ "``shell=True``\\를 사용할 때, :func:`shlex.quote` "
#~ "함수를 사용하여 셸 명령을 구성하는 데 사용될 "
#~ "문자열에 있는 공백과 셸 메타 문자를 올바르게 "
#~ "이스케이프 할 수 있습니다."

#~ msgid "The following attributes are also available:"
#~ msgstr "다음과 같은 어트리뷰트도 사용할 수 있습니다:"

#~ msgid ":ref:`Availability <availability>`: POSIX & Windows."
#~ msgstr ":ref:`가용성 <availability>`: POSIX & 윈도우."

