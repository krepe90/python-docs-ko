# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/ftplib.rst:2
msgid ":mod:`!ftplib` --- FTP protocol client"
msgstr ":mod:`!ftplib` --- FTP 프로토콜 클라이언트"

#: ../../library/ftplib.rst:7
msgid "**Source code:** :source:`Lib/ftplib.py`"
msgstr "**소스 코드:** :source:`Lib/ftplib.py`"

#: ../../library/ftplib.rst:15
msgid ""
"This module defines the class :class:`FTP` and a few related items. The "
":class:`FTP` class implements the client side of the FTP protocol.  You "
"can use this to write Python programs that perform a variety of automated"
" FTP jobs, such as mirroring other FTP servers.  It is also used by the "
"module :mod:`urllib.request` to handle URLs that use FTP.  For more "
"information on FTP (File Transfer Protocol), see internet :rfc:`959`."
msgstr ""
"이 모듈은 :class:`FTP` 클래스와 몇 가지 관련 항목을 정의합니다. :class:`FTP` 클래스는 FTP 프로토콜의 "
"클라이언트 쪽을 구현합니다. 이것을 사용하여 다른 FTP 서버 미러링과 같은 다양한 자동화된 FTP 작업을 수행하는 파이썬 "
"프로그램을 작성할 수 있습니다. 또한 :mod:`urllib.request` 모듈에서 FTP를 사용하는 URL을 처리하는 데 "
"사용됩니다. FTP(File Transfer Protocol)에 대한 자세한 내용은 인터넷 :rfc:`959`\\를 참조하십시오."

#: ../../library/ftplib.rst:22
msgid "The default encoding is UTF-8, following :rfc:`2640`."
msgstr ":rfc:`2640`\\에 따라, 기본 인코딩은 UTF-8입니다."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/ftplib.rst:26
msgid "Here's a sample session using the :mod:`ftplib` module::"
msgstr ":mod:`ftplib` 모듈을 사용한 샘플 세션은 다음과 같습니다::"

#: ../../library/ftplib.rst:28
msgid ""
">>> from ftplib import FTP\n"
">>> ftp = FTP('ftp.us.debian.org')  # connect to host, default port\n"
">>> ftp.login()                     # user anonymous, passwd anonymous@\n"
"'230 Login successful.'\n"
">>> ftp.cwd('debian')               # change into \"debian\" directory\n"
"'250 Directory successfully changed.'\n"
">>> ftp.retrlines('LIST')           # list directory contents\n"
"-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README\n"
"...\n"
"drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool\n"
"drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project\n"
"drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools\n"
"'226 Directory send OK.'\n"
">>> with open('README', 'wb') as fp:\n"
">>>     ftp.retrbinary('RETR README', fp.write)\n"
"'226 Transfer complete.'\n"
">>> ftp.quit()\n"
"'221 Goodbye.'"
msgstr ""
">>> from ftplib import FTP\n"
">>> ftp = FTP('ftp.us.debian.org')  # 기본 포트로 호스트에 연결합니다\n"
">>> ftp.login()                     # user anonymous, passwd anonymous@\n"
"'230 Login successful.'\n"
">>> ftp.cwd('debian')               # \"debian\" 디렉터리로 변경합니다\n"
"'250 Directory successfully changed.'\n"
">>> ftp.retrlines('LIST')           # 디렉터리 내용의 목록을 얻습니다\n"
"-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README\n"
"...\n"
"drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool\n"
"drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project\n"
"drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools\n"
"'226 Directory send OK.'\n"
">>> with open('README', 'wb') as fp:\n"
">>>     ftp.retrbinary('RETR README', fp.write)\n"
"'226 Transfer complete.'\n"
">>> ftp.quit()\n"
"'221 Goodbye.'"

#: ../../library/ftplib.rst:51
msgid "Reference"
msgstr "레퍼런스"

#: ../../library/ftplib.rst:56
msgid "FTP objects"
msgstr "FTP 객체"

#: ../../library/ftplib.rst:87
msgid "Return a new instance of the :class:`FTP` class."
msgstr ":class:`FTP` 클래스의 새 인스턴스를 반환합니다."

#: ../../library/ftplib.rst
msgid "Parameters"
msgstr "매개 변수"

#: ../../library/ftplib.rst:89 ../../library/ftplib.rst:461
msgid ""
"The hostname to connect to. If given, :code:`connect(host)` is implicitly"
" called by the constructor."
msgstr "연결할 호스트명. 주어지면, 생성자가 :code:`connect(host)`\\를 묵시적으로 호출합니다."

#: ../../library/ftplib.rst:93 ../../library/ftplib.rst:465
msgid ""
"|param_doc_user| If given, :code:`login(host, passwd, acct)` is "
"implicitly called by the constructor."
msgstr ""
"|param_doc_user| 주어지면, 생성자가 :code:`login(host, passwd, acct)`\\를 묵시적으로 "
"호출합니다."

#: ../../library/ftplib.rst:98 ../../library/ftplib.rst:212
#: ../../library/ftplib.rst:470
msgid "|param_doc_passwd|"
msgstr "|param_doc_passwd|"

#: ../../library/ftplib.rst:101 ../../library/ftplib.rst:215
#: ../../library/ftplib.rst:473
msgid "|param_doc_acct|"
msgstr "|param_doc_acct|"

#: ../../library/ftplib.rst:104
msgid ""
"A timeout in seconds for blocking operations like :meth:`connect` "
"(default: the global default timeout setting)."
msgstr ":meth:`connect`\\와 같은 블로킹 연산에 대한 시간제한을 초로 지정 (기본값: 전역 기본 시간제한 설정)."

#: ../../library/ftplib.rst:109 ../../library/ftplib.rst:183
#: ../../library/ftplib.rst:488
msgid "|param_doc_source_address|"
msgstr "|param_doc_source_address|"

#: ../../library/ftplib.rst:113 ../../library/ftplib.rst:492
msgid "|param_doc_encoding|"
msgstr "|param_doc_encoding|"

#: ../../library/ftplib.rst:116
msgid "The :class:`FTP` class supports the :keyword:`with` statement, e.g.:"
msgstr ":class:`FTP` 클래스는 :keyword:`with` 문을 지원합니다, 예를 들어:"

#: ../../library/ftplib.rst:130
msgid "Support for the :keyword:`with` statement was added."
msgstr ":keyword:`with` 문에 대한 지원이 추가되었습니다."

#: ../../library/ftplib.rst:133 ../../library/ftplib.rst:189
msgid "*source_address* parameter was added."
msgstr "*source_address* 매개 변수가 추가되었습니다."

#: ../../library/ftplib.rst:136 ../../library/ftplib.rst:505
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a "
":class:`ValueError` to prevent the creation of a non-blocking socket. The"
" *encoding* parameter was added, and the default was changed from Latin-1"
" to UTF-8 to follow :rfc:`2640`."
msgstr ""
"*timeout* 매개 변수가 0으로 설정되면, 비 블로킹 소켓이 만들어지지 않도록 :class:`ValueError`\\를 "
"발생시킵니다. *encoding* 매개 변수가 추가되었으며, 기본값은 Latin-1 에서 UTF-8로 변경되어 "
":rfc:`2640`\\을 따릅니다."

#: ../../library/ftplib.rst:142
msgid ""
"Several :class:`!FTP` methods are available in two flavors: one for "
"handling text files and another for binary files. The methods are named "
"for the command which is used followed by ``lines`` for the text version "
"or ``binary`` for the binary version."
msgstr ""
"여러 :class:`!FTP` 메서드가 두 가지 스타일로 제공됩니다: 텍스트 파일을 처리하는 것과 바이너리 파일을 위한 것. 명령 "
"뒤에 텍스트 버전의 경우 ``lines``, 바이너리 버전의 경우 ``binary``\\를 붙여서 이 메서드들의 이름을 "
"지정했습니다."

#: ../../library/ftplib.rst:147
msgid ":class:`FTP` instances have the following methods:"
msgstr ":class:`FTP` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/ftplib.rst:151
msgid ""
"Set the instance's debugging level as an :class:`int`. This controls the "
"amount of debugging output printed. The debug levels are:"
msgstr ""
"인스턴스의 디버깅 수준을 :class:`int`\\로 설정합니다. 인쇄되는 디버깅 출력의 양을 제어합니다. 디버깅 수준은 다음과 "
"같습니다:"

#: ../../library/ftplib.rst:155
msgid "``0`` (default): No debug output."
msgstr "``0`` (기본값): 디버깅 출력을 생성하지 않습니다."

#: ../../library/ftplib.rst:156
msgid ""
"``1``: Produce a moderate amount of debug output, generally a single line"
" per request."
msgstr "``1``: 적당한 양의 디버깅 출력, 일반적으로 요청당 한 줄을 생성합니다."

#: ../../library/ftplib.rst:158
msgid ""
"``2`` or higher: Produce the maximum amount of debugging output, logging "
"each line sent and received on the control connection."
msgstr "``2`` 이상: 제어 연결에서 보내고 받는 각 줄을 로깅하여 최대량의 디버깅 출력을 생성합니다."

#: ../../library/ftplib.rst:163
msgid ""
"Connect to the given host and port. This function should be called only "
"once for each instance; it should not be called if a *host* argument was "
"given when the :class:`FTP` instance was created. All other :class:`!FTP`"
" methods can only be called after a connection has successfully been "
"made."
msgstr ""
"주어진 host와 port에 연결합니다. 이 함수는 각 인스턴스에 대해 한 번만 호출해야 합니다; :class:`FTP` 인스턴스를"
" 만들 때 *host* 인자가 제공되었으면, 호출되지 않아야 합니다. 다른 모든 :class:`!FTP` 메서드는 연결이 성공적으로"
" 이루어진 후에만 호출할 수 있습니다."

#: ../../library/ftplib.rst:170
msgid "The host to connect to."
msgstr "연결할 호스트."

#: ../../library/ftplib.rst:173
msgid ""
"The TCP port to connect to (default: ``21``, as specified by the FTP "
"protocol specification). It is rarely needed to specify a different port "
"number."
msgstr "연결할 TCP 포트 (기본값: ``21``, FTP 프로토콜 명세에 지정된 대로). 다른 포트 번호를 지정할 필요는 거의 없습니다."

#: ../../library/ftplib.rst:178
msgid ""
"A timeout in seconds for the connection attempt (default: the global "
"default timeout setting)."
msgstr "연결 시도에 대한 시간제한 (기본값: 전역 기본 시간제한 설정)."

#: ../../library/ftplib.rst:187
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ftplib.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"인자 ``self``, ``host``, ``port``\\로 :ref:`감사 이벤트 <auditing>` "
"``ftplib.connect``\\를 발생시킵니다."

#: ../../library/ftplib.rst:195
msgid ""
"Return the welcome message sent by the server in reply to the initial "
"connection.  (This message sometimes contains disclaimers or help "
"information that may be relevant to the user.)"
msgstr ""
"초기 연결에 대한 응답으로 서버에서 보낸 환영 메시지를 반환합니다. (이 메시지에는 때때로 사용자와 관련될 수 있는 고지 사항이나 "
"도움말 정보가 포함되어 있습니다.)"

#: ../../library/ftplib.rst:202
msgid ""
"Log on to the connected FTP server. This function should be called only "
"once for each instance, after a connection has been established; it "
"should not be called if the *host* and *user* arguments were given when "
"the :class:`FTP` instance was created. Most FTP commands are only allowed"
" after the client has logged in."
msgstr ""
"연결된 FTP 서버로 로그인합니다. 이 함수는 연결이 설정된 후 각 인스턴스에 마다 한 번만 호출해야 합니다; "
":class:`FTP` 인스턴스가 만들어질 때 *host*\\와 *user* 인자가 제공되었으면 호출되지 않아야 합니다. 대부분의 "
"FTP 명령은 클라이언트가 로그인한 후에만 허용됩니다."

#: ../../library/ftplib.rst:209
msgid "|param_doc_user|"
msgstr "|param_doc_user|"

#: ../../library/ftplib.rst:221
msgid ""
"Abort a file transfer that is in progress.  Using this does not always "
"work, but it's worth a try."
msgstr "진행 중인 파일 전송을 중단합니다. 이것을 사용하는 것이 항상 동작하지는 않지만, 시도해 볼 가치가 있습니다."

#: ../../library/ftplib.rst:227
msgid "Send a simple command string to the server and return the response string."
msgstr "간단한 명령 문자열을 서버로 보내고 응답 문자열을 반환합니다."

#: ../../library/ftplib.rst:229 ../../library/ftplib.rst:238
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ftplib.sendcmd`` with "
"arguments ``self``, ``cmd``."
msgstr ""
"인자 ``self``, ``cmd``\\로 :ref:`감사 이벤트 <auditing>` ``ftplib.sendcmd``\\를 "
"발생시킵니다."

#: ../../library/ftplib.rst:234
msgid ""
"Send a simple command string to the server and handle the response.  "
"Return the response string if the response code corresponds to success "
"(codes in the range 200--299).  Raise :exc:`error_reply` otherwise."
msgstr ""
"간단한 명령 문자열을 서버로 보내고 응답을 처리합니다. 응답 코드가 성공(200--299 범위의 코드)에 해당하면 응답 문자열을 "
"반환합니다. 그렇지 않으면 :exc:`error_reply`\\를 발생시킵니다."

#: ../../library/ftplib.rst:243
msgid "Retrieve a file in binary transfer mode."
msgstr "바이너리 전송 모드로 파일을 가져옵니다."

#: ../../library/ftplib.rst:245
#, python-brace-format
msgid "An appropriate ``RETR`` command: :samp:`\"RETR {filename}\"`."
msgstr "적절한 ``RETR`` 명령: :samp:`\"RETR {filename}\"`."

#: ../../library/ftplib.rst:248
msgid ""
"A single parameter callable that is called for each block of data "
"received, with its single argument being the data as :class:`bytes`."
msgstr "수신된 각 데이터 블록에 대해 호출되는 단일 매개 변수 콜러블로, 단일 인자는 :class:`bytes` 형의 데이터입니다."

#: ../../library/ftplib.rst:254
msgid ""
"The maximum chunk size to read on the low-level :class:`~socket.socket` "
"object created to do the actual transfer. This also corresponds to the "
"largest size of data that will be passed to *callback*. Defaults to "
"``8192``."
msgstr ""
"실제 전송을 수행하기 위해 만들어진 저수준 :class:`~socket.socket` 객체에서 읽을 최대 청크 크기. "
"*callback*\\에 전달되는 데이터의 최대 크기에 해당하기도 합니다. 기본값은 ``8192``."

#: ../../library/ftplib.rst:261 ../../library/ftplib.rst:308
msgid ""
"A ``REST`` command to be sent to the server. See the documentation for "
"the *rest* parameter of the :meth:`transfercmd` method."
msgstr "서버로 전송할 ``REST`` 명령. :meth:`transfercmd` 메서드의 *rest* 매개 변수에 대한 설명서를 참조하세요."

#: ../../library/ftplib.rst:268
msgid ""
"Retrieve a file or directory listing in the encoding specified by the "
"*encoding* parameter at initialization. *cmd* should be an appropriate "
"``RETR`` command (see :meth:`retrbinary`) or a command such as ``LIST`` "
"or ``NLST`` (usually just the string ``'LIST'``). ``LIST`` retrieves a "
"list of files and information about those files. ``NLST`` retrieves a "
"list of file names. The *callback* function is called for each line with "
"a string argument containing the line with the trailing CRLF stripped.  "
"The default *callback* prints the line to :data:`sys.stdout`."
msgstr ""
"초기화 때 *encoding* 매개 변수로 지정된 인코딩으로 파일이나 디렉터리 목록을 가져옵니다. *cmd*\\는 적절한 "
"``RETR`` 명령(:meth:`retrbinary`\\를 참조하십시오)이거나 ``LIST``\\나 ``NLST``\\와 같은 "
"명령(보통 단지 문자열 ``'LIST'``)이어야 합니다. ``LIST``\\는 파일 목록과 해당 파일에 대한 정보를 가져옵니다. "
"``NLST``\\는 파일 이름 목록을 가져옵니다. *callback* 함수는 각 줄에 대해 호출되며, 후행 CRLF가 제거된 줄을"
" 포함하는 문자열을 인자로 제공합니다. 기본 *callback*\\은 줄을 :data:`sys.stdout`\\으로 인쇄합니다."

#: ../../library/ftplib.rst:281
msgid ""
"Enable \"passive\" mode if *val* is true, otherwise disable passive mode."
" Passive mode is on by default."
msgstr ""
"*val*\\이 참이면 \"수동(passive)\" 모드를 활성화하고, 그렇지 않으면 수동 모드를 비활성화합니다. 수동 모드는 "
"기본적으로 켜져 있습니다."

#: ../../library/ftplib.rst:287
msgid "Store a file in binary transfer mode."
msgstr "바이너리 전송 모드로 파일을 저장합니다."

#: ../../library/ftplib.rst:289
#, python-brace-format
msgid "An appropriate ``STOR`` command: :samp:`\"STOR {filename}\"`."
msgstr "적절한 ``STOR`` 명령: :samp:`\"STOR {filename}\"`."

#: ../../library/ftplib.rst:292
msgid ""
"A file object (opened in binary mode) which is read until EOF, using its "
":meth:`~io.RawIOBase.read` method in blocks of size *blocksize* to "
"provide the data to be stored."
msgstr ""
"(바이너리 모드로 열린) 파일 객체이며 저장될 데이터를 제공하기 위해 *blocksize* 크기의 블록으로 "
":meth:`~io.IOBase.read` 메서드를 사용하여 EOF까지 읽힙니다."

#: ../../library/ftplib.rst:298
msgid "The read block size. Defaults to ``8192``."
msgstr "읽기 블록 크기. 기본값은 ``8192``."

#: ../../library/ftplib.rst:302
msgid ""
"A single parameter callable that is called for each block of data sent, "
"with its single argument being the data as :class:`bytes`."
msgstr "전송된 각 데이터 블록에 대해 호출되는 단일 매개 변수 콜러블로, 단일 인자는 :class:`bytes` 형의 데이터입니다."

#: ../../library/ftplib.rst:312
msgid "The *rest* parameter was added."
msgstr "*rest* 매개 변수가 추가되었습니다."

#: ../../library/ftplib.rst:318
msgid ""
"Store a file in line mode.  *cmd* should be an appropriate ``STOR`` "
"command (see :meth:`storbinary`).  Lines are read until EOF from the "
":term:`file object` *fp* (opened in binary mode) using its "
":meth:`~io.IOBase.readline` method to provide the data to be stored.  "
"*callback* is an optional single parameter callable that is called on "
"each line after it is sent."
msgstr ""
"줄 모드로 파일을 저장합니다. *cmd*\\는 적절한 ``STOR`` 명령이어야 합니다 (:meth:`storbinary`\\를 "
"참조하십시오). 저장될 데이터를 제공하기 위해 :meth:`~io.IOBase.readline` 메서드를 사용하여 (바이너리 모드로"
" 열린) :term:`파일 객체 <file object>` *fp*\\에서 EOF까지 줄을 읽어 들입니다. *callback*\\은"
" 줄마다 보내진 다음에 호출되는 선택적 단일 매개 변수 콜러블입니다."

#: ../../library/ftplib.rst:327
msgid ""
"Initiate a transfer over the data connection.  If the transfer is active,"
" send an ``EPRT`` or  ``PORT`` command and the transfer command specified"
" by *cmd*, and accept the connection.  If the server is passive, send an "
"``EPSV`` or ``PASV`` command, connect to it, and start the transfer "
"command.  Either way, return the socket for the connection."
msgstr ""
"데이터 연결을 통해 전송을 시작합니다. 전송이 활성화되면, ``EPRT``\\나 ``PORT`` 명령과 *cmd*\\로 지정한 전송"
" 명령을 보내고 연결을 받아들입니다. 서버가 수동(passive)이면, ``EPSV``\\나 ``PASV`` 명령을 전송하고, "
"서버에 연결한 다음 전송 명령을 시작합니다. 어느 쪽이든, 연결 소켓을 반환합니다."

#: ../../library/ftplib.rst:333
msgid ""
"If optional *rest* is given, a ``REST`` command is sent to the server, "
"passing *rest* as an argument.  *rest* is usually a byte offset into the "
"requested file, telling the server to restart sending the file's bytes at"
" the requested offset, skipping over the initial bytes.  Note however "
"that the :meth:`transfercmd` method converts *rest* to a string with the "
"*encoding* parameter specified at initialization, but no check is "
"performed on the string's contents.  If the server does not recognize the"
" ``REST`` command, an :exc:`error_reply` exception will be raised.  If "
"this happens, simply call :meth:`transfercmd` without a *rest* argument."
msgstr ""
"선택적 *rest*\\가 제공되면, ``REST`` 명령이 서버로 전송되고 *rest*\\를 인자로 전달합니다. *rest*\\는 "
"일반적으로 요청된 파일에 대한 바이트 오프셋으로, 요청된 오프셋에서 파일 바이트 전송을 다시 시작하고 초기 바이트를 건너뛰도록 "
"서버에 지시합니다. 그러나 :meth:`transfercmd` 메서드는 초기화 때 지정된 *encoding* 매개 변수를 사용하여 "
"*rest*\\를 문자열로 변환하지만, 문자열의 내용은 점검하지 않음에 유의하십시오. 서버가 ``REST`` 명령을 인식하지 "
"못하면, :exc:`error_reply` 예외가 발생합니다. 이 경우, 단순히 *rest* 인자 없이 "
":meth:`transfercmd`\\를 호출하십시오."

#: ../../library/ftplib.rst:346
msgid ""
"Like :meth:`transfercmd`, but returns a tuple of the data connection and "
"the expected size of the data.  If the expected size could not be "
"computed, ``None`` will be returned as the expected size.  *cmd* and "
"*rest* means the same thing as in :meth:`transfercmd`."
msgstr ""
":meth:`transfercmd`\\와 비슷하지만, 데이터 연결과 데이터의 예상 크기의 튜플을 반환합니다. 예상 크기를 계산할 수"
" 없으면, ``None``\\이 예상 크기로 반환됩니다. *cmd*\\와 *rest*\\는 "
":meth:`transfercmd`\\에서와 같은 의미입니다."

#: ../../library/ftplib.rst:354
msgid ""
"List a directory in a standardized format by using ``MLSD`` command "
"(:rfc:`3659`).  If *path* is omitted the current directory is assumed. "
"*facts* is a list of strings representing the type of information desired"
" (e.g. ``[\"type\", \"size\", \"perm\"]``).  Return a generator object "
"yielding a tuple of two elements for every file found in path.  First "
"element is the file name, the second one is a dictionary containing facts"
" about the file name.  Content of this dictionary might be limited by the"
" *facts* argument but server is not guaranteed to return all requested "
"facts."
msgstr ""
"``MLSD`` 명령(:rfc:`3659`)을 사용하여 표준화된 형식으로 디렉터리를 나열합니다. *path*\\가 생략되면 현재 "
"디렉터리를 가정합니다. *facts*\\는 원하는 정보 유형을 나타내는 문자열의 리스트입니다 (예를 들어 ``[\"type\", "
"\"size\", \"perm\"]``). 경로에서 발견된 모든 파일에 대해 두 요소의 튜플을 산출하는 제너레이터 객체를 "
"반환합니다. 첫 번째 요소는 파일 이름이고, 두 번째 요소는 파일 이름에 대한 사실(facts)을 포함하는 딕셔너리입니다. 이 "
"딕셔너리의 내용은 *facts* 인자에 의해 제한될 수 있지만, 서버가 요청된 모든 사실을 반환한다고 보장하지는 않습니다."

#: ../../library/ftplib.rst:368
msgid ""
"Return a list of file names as returned by the ``NLST`` command.  The "
"optional *argument* is a directory to list (default is the current server"
" directory).  Multiple arguments can be used to pass non-standard options"
" to the ``NLST`` command."
msgstr ""
"``NLST`` 명령이 반환한 파일 이름 리스트를 반환합니다. 선택적 *argument*\\는 나열할 디렉터리입니다 (기본값은 현재"
" 서버 디렉터리입니다). 비표준 옵션을 ``NLST`` 명령에 전달하기 위해 여러 인자를 사용할 수 있습니다."

#: ../../library/ftplib.rst:373 ../../library/ftplib.rst:385
msgid "If your server supports the command, :meth:`mlsd` offers a better API."
msgstr "서버가 명령을 지원한다면, :meth:`mlsd`\\가 더 나은 API를 제공합니다."

#: ../../library/ftplib.rst:378
msgid ""
"Produce a directory listing as returned by the ``LIST`` command, printing"
" it to standard output.  The optional *argument* is a directory to list "
"(default is the current server directory).  Multiple arguments can be "
"used to pass non-standard options to the ``LIST`` command.  If the last "
"argument is a function, it is used as a *callback* function as for "
":meth:`retrlines`; the default prints to :data:`sys.stdout`.  This method"
" returns ``None``."
msgstr ""
"``LIST`` 명령이 반환한 디렉터리 목록을 생성하여 표준 출력으로 인쇄합니다. 선택적 *argument*\\는 나열할 "
"디렉터리입니다 (기본값은 현재 서버 디렉터리입니다). 비표준 옵션을 ``LIST`` 명령에 전달하기 위해 여러 인자를 사용할 수 "
"있습니다. 마지막 인자가 함수면, :meth:`retrlines`\\와 같이 *callback* 함수로 사용됩니다; 기본값은 "
":data:`sys.stdout`\\으로 인쇄합니다. 이 메서드는 ``None``\\을 반환합니다."

#: ../../library/ftplib.rst:390
msgid "Rename file *fromname* on the server to *toname*."
msgstr "서버의 파일 *fromname*\\을 *toname*\\으로 이름을 바꿉니다."

#: ../../library/ftplib.rst:395
msgid ""
"Remove the file named *filename* from the server.  If successful, returns"
" the text of the response, otherwise raises :exc:`error_perm` on "
"permission errors or :exc:`error_reply` on other errors."
msgstr ""
"서버에서 *filename*\\이라는 파일을 제거합니다. 성공하면, 응답 텍스트를 반환하고, 그렇지 않으면 권한 에러면 "
":exc:`error_perm`\\을, 다른 에러면 :exc:`error_reply`\\를 발생시킵니다."

#: ../../library/ftplib.rst:402
msgid "Set the current directory on the server."
msgstr "서버에서 현재 디렉터리를 설정합니다."

#: ../../library/ftplib.rst:407
msgid "Create a new directory on the server."
msgstr "서버에서 새 디렉터리를 만듭니다."

#: ../../library/ftplib.rst:412
msgid "Return the pathname of the current directory on the server."
msgstr "서버에서 현재 디렉터리의 경로명을 반환합니다."

#: ../../library/ftplib.rst:417
msgid "Remove the directory named *dirname* on the server."
msgstr "서버에서 *dirname*\\이라는 디렉터리를 제거합니다."

#: ../../library/ftplib.rst:422
msgid ""
"Request the size of the file named *filename* on the server.  On success,"
" the size of the file is returned as an integer, otherwise ``None`` is "
"returned. Note that the ``SIZE`` command is not  standardized, but is "
"supported by many common server implementations."
msgstr ""
"서버에서 *filename*\\이라는 파일의 크기를 요청합니다. 성공하면, 파일 크기가 정수로 반환되고, 그렇지 않으면 "
"``None``\\이 반환됩니다. ``SIZE`` 명령은 표준화되어 있지 않지만, 많은 일반적인 서버 구현에서 지원됨에 "
"유의하십시오."

#: ../../library/ftplib.rst:430
msgid ""
"Send a ``QUIT`` command to the server and close the connection. This is "
"the \"polite\" way to close a connection, but it may raise an exception "
"if the server responds with an error to the ``QUIT`` command.  This "
"implies a call to the :meth:`close` method which renders the :class:`FTP`"
" instance useless for subsequent calls (see below)."
msgstr ""
"``QUIT`` 명령을 서버로 보내고 연결을 닫습니다. 이는 연결을 닫는 \"정중한\" 방법이지만, 서버가 ``QUIT`` 명령에 "
"대해 에러로 응답하면 예외가 발생할 수 있습니다. 이것은 묵시적인 :meth:`close` 메서드 호출을 수반하며, 이는 후속 "
"호출에 :class:`FTP` 인스턴스를 쓸모없게 만듭니다 (아래를 참조하십시오)."

#: ../../library/ftplib.rst:439
msgid ""
"Close the connection unilaterally.  This should not be applied to an "
"already closed connection such as after a successful call to "
":meth:`~FTP.quit`. After this call the :class:`FTP` instance should not "
"be used any more (after a call to :meth:`close` or :meth:`~FTP.quit` you "
"cannot reopen the connection by issuing another :meth:`login` method)."
msgstr ""
"일방적으로 연결을 닫습니다. 이것은 이미 닫힌 연결에는 적용되지 않아야 합니다, 가령 :meth:`~FTP.quit`\\를 "
"성공적으로 호출한 후에. 이 호출 후 :class:`FTP` 인스턴스를 더는 사용하지 않아야 합니다 (:meth:`close`\\나"
" :meth:`~FTP.quit` 호출 후 다른 :meth:`login` 메서드를 사용해서 연결을 다시 열 수 없습니다)."

#: ../../library/ftplib.rst:447
msgid "FTP_TLS objects"
msgstr "FTP_TLS 객체"

#: ../../library/ftplib.rst:452
msgid ""
"An :class:`FTP` subclass which adds TLS support to FTP as described in "
":rfc:`4217`. Connect to port 21 implicitly securing the FTP control "
"connection before authenticating."
msgstr ""
":rfc:`4217`\\에 설명된 대로 FTP에 TLS 지원을 추가하는 :class:`FTP` 서브 클래스. 인증하기 전에 FTP "
"제어 연결을 묵시적으로 보안을 유지하면서 포트 21에 연결합니다."

#: ../../library/ftplib.rst:458
msgid ""
"The user must explicitly secure the data connection by calling the "
":meth:`prot_p` method."
msgstr "사용자는 :meth:`prot_p` 메서드를 호출하여 데이터 연결을 명시적으로 보호해야 합니다."

#: ../../library/ftplib.rst:476
msgid ""
"An SSL context object which allows bundling SSL configuration options, "
"certificates and private keys into a single, potentially long-lived, "
"structure. Please read :ref:`ssl-security` for best practices."
msgstr ""
"SSL 구성 옵션, 인증서 및 개인 키를 잠재적으로 오래 유지되는 단일 구조로 묶을 수 있는 SSL 컨텍스트 객체. 모범 사례를 "
"보려면 :ref:`ssl-security`\\을 읽으십시오."

#: ../../library/ftplib.rst:483
msgid ""
"A timeout in seconds for blocking operations like :meth:`~FTP.connect` "
"(default: the global default timeout setting)."
msgstr ":meth:`~FTP.connect`\\와 같은 블로킹 연산에 대한 시간제한을 초로 지정 (기본값: 전역 기본 시간제한 설정)"

#: ../../library/ftplib.rst:497
msgid "Added the *source_address* parameter."
msgstr "*source_address* 매개 변수가 추가되었습니다."

#: ../../library/ftplib.rst:500
msgid ""
"The class now supports hostname check with "
":attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see "
":const:`ssl.HAS_SNI`)."
msgstr ""
"이 클래스는 이제 :attr:`ssl.SSLContext.check_hostname`\\과 *서버 이름 표시(Server Name "
"Indication)*\\(:const:`ssl.HAS_SNI`\\를 참조하십시오)으로 호스트명 확인을 지원합니다."

#: ../../library/ftplib.rst:511
msgid "The deprecated *keyfile* and *certfile* parameters have been removed."
msgstr "폐지된 *keyfile*\\와 *certfile* 매개 변수를 제거했습니다."

#: ../../library/ftplib.rst:514
msgid "Here's a sample session using the :class:`FTP_TLS` class::"
msgstr ":class:`FTP_TLS` 클래스를 사용한 샘플 세션은 다음과 같습니다::"

#: ../../library/ftplib.rst:516
msgid ""
">>> ftps = FTP_TLS('ftp.pureftpd.org')\n"
">>> ftps.login()\n"
"'230 Anonymous user logged in'\n"
">>> ftps.prot_p()\n"
"'200 Data protection level set to \"private\"'\n"
">>> ftps.nlst()\n"
"['6jack', 'OpenBSD', 'antilink', 'blogbench', 'bsdcam', 'clockspeed', "
"'djbdns-jedi', 'docs', 'eaccelerator-jedi', 'favicon.ico', 'francotone', "
"'fugu', 'ignore', 'libpuzzle', 'metalog', 'minidentd', 'misc', 'mysql-"
"udf-global-user-variables', 'php-jenkins-hash', 'php-skein-hash', 'php-"
"webdav', 'phpaudit', 'phpbench', 'pincaster', 'ping', 'posto', 'pub', "
"'public', 'public_keys', 'pure-ftpd', 'qscan', 'qtc', 'sharedance', "
"'skycache', 'sound', 'tmp', 'ucarp']"
msgstr ""
">>> ftps = FTP_TLS('ftp.pureftpd.org')\n"
">>> ftps.login()\n"
"'230 Anonymous user logged in'\n"
">>> ftps.prot_p()\n"
"'200 Data protection level set to \"private\"'\n"
">>> ftps.nlst()\n"
"['6jack', 'OpenBSD', 'antilink', 'blogbench', 'bsdcam', 'clockspeed', "
"'djbdns-jedi', 'docs', 'eaccelerator-jedi', 'favicon.ico', 'francotone', "
"'fugu', 'ignore', 'libpuzzle', 'metalog', 'minidentd', 'misc', 'mysql-"
"udf-global-user-variables', 'php-jenkins-hash', 'php-skein-hash', 'php-"
"webdav', 'phpaudit', 'phpbench', 'pincaster', 'ping', 'posto', 'pub', "
"'public', 'public_keys', 'pure-ftpd', 'qscan', 'qtc', 'sharedance', "
"'skycache', 'sound', 'tmp', 'ucarp']"

#: ../../library/ftplib.rst:524
msgid ""
":class:`!FTP_TLS` class inherits from :class:`FTP`, defining these "
"additional methods and attributes:"
msgstr ":class:`!FTP_TLS` 클래스는 :class:`FTP`\\를 상속하여, 다음과 같은 추가 메서드와 어트리뷰트를 정의합니다:"

#: ../../library/ftplib.rst:529
msgid "The SSL version to use (defaults to :data:`ssl.PROTOCOL_SSLv23`)."
msgstr "사용할 SSL 버전 (기본값은 :data:`ssl.PROTOCOL_SSLv23`\\입니다)."

#: ../../library/ftplib.rst:533
msgid ""
"Set up a secure control connection by using TLS or SSL, depending on what"
" is specified in the :attr:`ssl_version` attribute."
msgstr ":attr:`ssl_version` 어트리뷰트에 지정된 내용에 따라, TLS나 SSL을 사용하여 보안 제어 연결을 설정합니다."

#: ../../library/ftplib.rst:536
msgid ""
"The method now supports hostname check with "
":attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see "
":const:`ssl.HAS_SNI`)."
msgstr ""
"이 메서드는 이제 :attr:`ssl.SSLContext.check_hostname`\\과 *서버 이름 표시(Server Name "
"Indication)*\\로 호스트명 확인을 지원합니다 (:const:`ssl.HAS_SNI`\\를 참조하십시오)."

#: ../../library/ftplib.rst:543
msgid ""
"Revert control channel back to plaintext.  This can be useful to take "
"advantage of firewalls that know how to handle NAT with non-secure FTP "
"without opening fixed ports."
msgstr ""
"제어 채널을 일반 텍스트로 되돌립니다. 고정 포트를 열지 않고 비보안 FTP로 NAT을 다루는 방법을 알고 있는 방화벽을 활용하는 "
"데 유용할 수 있습니다."

#: ../../library/ftplib.rst:551
msgid "Set up secure data connection."
msgstr "보안 데이터 연결을 설정합니다."

#: ../../library/ftplib.rst:555
msgid "Set up clear text data connection."
msgstr "일반 텍스트 데이터 연결을 설정합니다."

#: ../../library/ftplib.rst:559
msgid "Module variables"
msgstr "모듈 변수"

#: ../../library/ftplib.rst:563
msgid "Exception raised when an unexpected reply is received from the server."
msgstr "서버에서 예기치 않은 응답이 수신될 때 발생하는 예외."

#: ../../library/ftplib.rst:568
msgid ""
"Exception raised when an error code signifying a temporary error "
"(response codes in the range 400--499) is received."
msgstr "일시적 에러(400--499 범위의 응답 코드)를 나타내는 에러 코드가 수신될 때 발생하는 예외."

#: ../../library/ftplib.rst:574
msgid ""
"Exception raised when an error code signifying a permanent error "
"(response codes in the range 500--599) is received."
msgstr "영구 에러(500--599 범위의 응답 코드)를 나타내는 에러 코드가 수신될 때 발생하는 예외."

#: ../../library/ftplib.rst:580
msgid ""
"Exception raised when a reply is received from the server that does not "
"fit the response specifications of the File Transfer Protocol, i.e. begin"
" with a digit in the range 1--5."
msgstr ""
"서버로부터 FTP(File Transfer Protocol)의 응답 규격(즉, 1--5 범위의 숫자로 시작)에 맞지 않는 응답을 "
"수신할 때 발생하는 예외."

#: ../../library/ftplib.rst:587
msgid ""
"The set of all exceptions (as a tuple) that methods of :class:`FTP` "
"instances may raise as a result of problems with the FTP connection (as "
"opposed to programming errors made by the caller).  This set includes the"
" four exceptions listed above as well as :exc:`OSError` and "
":exc:`EOFError`."
msgstr ""
":class:`FTP` 인스턴스의 메서드가 (호출자로 인한 프로그래밍 에러가 아니라) FTP 연결 문제로 인해 발생시킬 수 있는 "
"모든 예외의 집합 (튜플). 이 집합에는 위에 나열된 네 가지 예외뿐만 아니라 :exc:`OSError`\\와 "
":exc:`EOFError`\\가 포함됩니다."

#: ../../library/ftplib.rst:595
msgid "Module :mod:`netrc`"
msgstr "모듈 :mod:`netrc`"

#: ../../library/ftplib.rst:596
msgid ""
"Parser for the :file:`.netrc` file format.  The file :file:`.netrc` is "
"typically used by FTP clients to load user authentication information "
"before prompting the user."
msgstr ""
":file:`.netrc` 파일 형식의 구문 분석기. :file:`.netrc` 파일은 일반적으로 FTP 클라이언트가 사용자에게 "
"프롬프트 하기 전에 사용자 인증 정보를 로드하는 데 사용됩니다."

#: ../../library/ftplib.rst:9
msgid "FTP"
msgstr "FTP"

#: ../../library/ftplib.rst:9
msgid "protocol"
msgstr "프로토콜"

#: ../../library/ftplib.rst:9
msgid "ftplib (standard module)"
msgstr "ftplib (표준 모듈)"

