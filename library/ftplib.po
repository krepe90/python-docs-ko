# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/ftplib.rst:2
#, fuzzy
msgid ":mod:`!ftplib` --- FTP protocol client"
msgstr ":mod:`ftplib` --- FTP 프로토콜 클라이언트"

#: ../../library/ftplib.rst:7
msgid "**Source code:** :source:`Lib/ftplib.py`"
msgstr "**소스 코드:** :source:`Lib/ftplib.py`"

#: ../../library/ftplib.rst:15
#, fuzzy
msgid ""
"This module defines the class :class:`FTP` and a few related items. The "
":class:`FTP` class implements the client side of the FTP protocol.  You "
"can use this to write Python programs that perform a variety of automated"
" FTP jobs, such as mirroring other FTP servers.  It is also used by the "
"module :mod:`urllib.request` to handle URLs that use FTP.  For more "
"information on FTP (File Transfer Protocol), see internet :rfc:`959`."
msgstr ""
"이 모듈은 :class:`FTP` 클래스와 몇 가지 관련 항목을 정의합니다. :class:`FTP` 클래스는 FTP 프로토콜의 "
"클라이언트 쪽을 구현합니다. 이것을 사용하여 다른 FTP 서버 미러링과 같은 다양한 자동화된 FTP 작업을 수행하는 파이썬 "
"프로그램을 작성할 수 있습니다. 또한 :mod:`urllib.request` 모듈에서 FTP를 사용하는 URL을 처리하는 데 "
"사용됩니다. FTP(File Transfer Protocol)에 대한 자세한 내용은 인터넷 :rfc:`959`\\를 참조하십시오."

#: ../../library/ftplib.rst:22
msgid "The default encoding is UTF-8, following :rfc:`2640`."
msgstr ":rfc:`2640`\\에 따라, 기본 인코딩은 UTF-8입니다."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/ftplib.rst:26
msgid "Here's a sample session using the :mod:`ftplib` module::"
msgstr ":mod:`ftplib` 모듈을 사용한 샘플 세션은 다음과 같습니다::"

#: ../../library/ftplib.rst:28
msgid ""
">>> from ftplib import FTP\n"
">>> ftp = FTP('ftp.us.debian.org')  # connect to host, default port\n"
">>> ftp.login()                     # user anonymous, passwd anonymous@\n"
"'230 Login successful.'\n"
">>> ftp.cwd('debian')               # change into \"debian\" directory\n"
"'250 Directory successfully changed.'\n"
">>> ftp.retrlines('LIST')           # list directory contents\n"
"-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README\n"
"...\n"
"drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool\n"
"drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project\n"
"drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools\n"
"'226 Directory send OK.'\n"
">>> with open('README', 'wb') as fp:\n"
">>>     ftp.retrbinary('RETR README', fp.write)\n"
"'226 Transfer complete.'\n"
">>> ftp.quit()\n"
"'221 Goodbye.'"
msgstr ""

#: ../../library/ftplib.rst:51
msgid "Reference"
msgstr ""

#: ../../library/ftplib.rst:56
#, fuzzy
msgid "FTP objects"
msgstr "FTP 객체"

#: ../../library/ftplib.rst:87
#, fuzzy
msgid "Return a new instance of the :class:`FTP` class."
msgstr ":class:`FTP_TLS` 클래스를 사용한 샘플 세션은 다음과 같습니다::"

#: ../../library/ftplib.rst
msgid "Parameters"
msgstr ""

#: ../../library/ftplib.rst:89 ../../library/ftplib.rst:461
msgid ""
"The hostname to connect to. If given, :code:`connect(host)` is implicitly"
" called by the constructor."
msgstr ""

#: ../../library/ftplib.rst:93 ../../library/ftplib.rst:465
msgid ""
"|param_doc_user| If given, :code:`login(host, passwd, acct)` is "
"implicitly called by the constructor."
msgstr ""

#: ../../library/ftplib.rst:98 ../../library/ftplib.rst:212
#: ../../library/ftplib.rst:470
msgid "|param_doc_passwd|"
msgstr ""

#: ../../library/ftplib.rst:101 ../../library/ftplib.rst:215
#: ../../library/ftplib.rst:473
msgid "|param_doc_acct|"
msgstr ""

#: ../../library/ftplib.rst:104
msgid ""
"A timeout in seconds for blocking operations like :meth:`connect` "
"(default: the global default timeout setting)."
msgstr ""

#: ../../library/ftplib.rst:109 ../../library/ftplib.rst:183
#: ../../library/ftplib.rst:488
msgid "|param_doc_source_address|"
msgstr ""

#: ../../library/ftplib.rst:113 ../../library/ftplib.rst:492
msgid "|param_doc_encoding|"
msgstr ""

#: ../../library/ftplib.rst:116
msgid "The :class:`FTP` class supports the :keyword:`with` statement, e.g.:"
msgstr ":class:`FTP` 클래스는 :keyword:`with` 문을 지원합니다, 예를 들어:"

#: ../../library/ftplib.rst:130
msgid "Support for the :keyword:`with` statement was added."
msgstr ":keyword:`with` 문에 대한 지원이 추가되었습니다."

#: ../../library/ftplib.rst:133 ../../library/ftplib.rst:189
msgid "*source_address* parameter was added."
msgstr "*source_address* 매개 변수가 추가되었습니다."

#: ../../library/ftplib.rst:136 ../../library/ftplib.rst:505
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a "
":class:`ValueError` to prevent the creation of a non-blocking socket. The"
" *encoding* parameter was added, and the default was changed from Latin-1"
" to UTF-8 to follow :rfc:`2640`."
msgstr ""
"*timeout* 매개 변수가 0으로 설정되면, 비 블로킹 소켓이 만들어지지 않도록 :class:`ValueError`\\를 "
"발생시킵니다. *encoding* 매개 변수가 추가되었으며, 기본값은 Latin-1 에서 UTF-8로 변경되어 "
":rfc:`2640`\\을 따릅니다."

#: ../../library/ftplib.rst:142
#, fuzzy
msgid ""
"Several :class:`!FTP` methods are available in two flavors: one for "
"handling text files and another for binary files. The methods are named "
"for the command which is used followed by ``lines`` for the text version "
"or ``binary`` for the binary version."
msgstr ""
"여러 메서드가 두 가지 스타일로 제공됩니다: 텍스트 파일을 처리하는 것과 바이너리 파일을 위한 것. 명령 뒤에 텍스트 버전의 경우 "
"``lines``, 바이너리 버전의 경우 ``binary``\\를 붙여서 이름을 지정합니다."

#: ../../library/ftplib.rst:147
msgid ":class:`FTP` instances have the following methods:"
msgstr ":class:`FTP` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/ftplib.rst:151
msgid ""
"Set the instance's debugging level as an :class:`int`. This controls the "
"amount of debugging output printed. The debug levels are:"
msgstr ""

#: ../../library/ftplib.rst:155
msgid "``0`` (default): No debug output."
msgstr ""

#: ../../library/ftplib.rst:156
msgid ""
"``1``: Produce a moderate amount of debug output, generally a single line"
" per request."
msgstr ""

#: ../../library/ftplib.rst:158
msgid ""
"``2`` or higher: Produce the maximum amount of debugging output, logging "
"each line sent and received on the control connection."
msgstr ""

#: ../../library/ftplib.rst:163
msgid ""
"Connect to the given host and port. This function should be called only "
"once for each instance; it should not be called if a *host* argument was "
"given when the :class:`FTP` instance was created. All other :class:`!FTP`"
" methods can only be called after a connection has successfully been "
"made."
msgstr ""

#: ../../library/ftplib.rst:170
msgid "The host to connect to."
msgstr ""

#: ../../library/ftplib.rst:173
msgid ""
"The TCP port to connect to (default: ``21``, as specified by the FTP "
"protocol specification). It is rarely needed to specify a different port "
"number."
msgstr ""

#: ../../library/ftplib.rst:178
msgid ""
"A timeout in seconds for the connection attempt (default: the global "
"default timeout setting)."
msgstr ""

#: ../../library/ftplib.rst:187
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ftplib.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"인자 ``self``, ``host``, ``port``\\로 :ref:`감사 이벤트 <auditing>` "
"``ftplib.connect``\\를 발생시킵니다."

#: ../../library/ftplib.rst:195
msgid ""
"Return the welcome message sent by the server in reply to the initial "
"connection.  (This message sometimes contains disclaimers or help "
"information that may be relevant to the user.)"
msgstr ""
"초기 연결에 대한 응답으로 서버에서 보낸 환영 메시지를 반환합니다. (이 메시지에는 때때로 사용자와 관련될 수 있는 고지 사항이나 "
"도움말 정보가 포함되어 있습니다.)"

#: ../../library/ftplib.rst:202
#, fuzzy
msgid ""
"Log on to the connected FTP server. This function should be called only "
"once for each instance, after a connection has been established; it "
"should not be called if the *host* and *user* arguments were given when "
"the :class:`FTP` instance was created. Most FTP commands are only allowed"
" after the client has logged in."
msgstr ""
"주어진 *user*\\로 로그인합니다. *passwd*\\와 *acct* 매개 변수는 선택 사항이며 기본값은 빈 문자열입니다. "
"*user*\\를 지정하지 않으면, 기본값은 ``'anonymous'``\\입니다. *user*\\가 "
"``'anonymous'``\\이면, 기본 *passwd*\\는 ``'anonymous@'``\\입니다. 이 함수는 연결이 설정된 "
"후 각 인스턴스에 마다 한 번만 호출해야 합니다; 인스턴스가 만들어질 때 host와 user가 제공되었으면 전혀 호출되지 않아야 "
"합니다. 대부분의 FTP 명령은 클라이언트가 로그인한 후에만 허용됩니다. *acct* 매개 변수는 \"계정 정보(accounting"
" information)\"를 제공합니다; 이를 구현하는 시스템은 거의 없습니다."

#: ../../library/ftplib.rst:209
msgid "|param_doc_user|"
msgstr ""

#: ../../library/ftplib.rst:221
msgid ""
"Abort a file transfer that is in progress.  Using this does not always "
"work, but it's worth a try."
msgstr "진행 중인 파일 전송을 중단합니다. 이것을 사용하는 것이 항상 동작하지는 않지만, 시도해 볼 가치가 있습니다."

#: ../../library/ftplib.rst:227
msgid "Send a simple command string to the server and return the response string."
msgstr "간단한 명령 문자열을 서버로 보내고 응답 문자열을 반환합니다."

#: ../../library/ftplib.rst:229 ../../library/ftplib.rst:238
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ftplib.sendcmd`` with "
"arguments ``self``, ``cmd``."
msgstr ""
"인자 ``self``, ``cmd``\\로 :ref:`감사 이벤트 <auditing>` ``ftplib.sendcmd``\\를 "
"발생시킵니다."

#: ../../library/ftplib.rst:234
#, fuzzy
msgid ""
"Send a simple command string to the server and handle the response.  "
"Return the response string if the response code corresponds to success "
"(codes in the range 200--299).  Raise :exc:`error_reply` otherwise."
msgstr ""
"간단한 명령 문자열을 서버로 보내고 응답을 처리합니다. 성공에 해당하는 응답 코드(200--299 범위의 코드)가 수신되면 아무것도"
" 반환하지 않습니다. 그렇지 않으면 :exc:`error_reply`\\를 발생시킵니다."

#: ../../library/ftplib.rst:243
msgid "Retrieve a file in binary transfer mode."
msgstr ""

#: ../../library/ftplib.rst:245
#, python-brace-format
msgid "An appropriate ``RETR`` command: :samp:`\"RETR {filename}\"`."
msgstr ""

#: ../../library/ftplib.rst:248
msgid ""
"A single parameter callable that is called for each block of data "
"received, with its single argument being the data as :class:`bytes`."
msgstr ""

#: ../../library/ftplib.rst:254
msgid ""
"The maximum chunk size to read on the low-level :class:`~socket.socket` "
"object created to do the actual transfer. This also corresponds to the "
"largest size of data that will be passed to *callback*. Defaults to "
"``8192``."
msgstr ""

#: ../../library/ftplib.rst:261 ../../library/ftplib.rst:308
msgid ""
"A ``REST`` command to be sent to the server. See the documentation for "
"the *rest* parameter of the :meth:`transfercmd` method."
msgstr ""

#: ../../library/ftplib.rst:268
#, fuzzy
msgid ""
"Retrieve a file or directory listing in the encoding specified by the "
"*encoding* parameter at initialization. *cmd* should be an appropriate "
"``RETR`` command (see :meth:`retrbinary`) or a command such as ``LIST`` "
"or ``NLST`` (usually just the string ``'LIST'``). ``LIST`` retrieves a "
"list of files and information about those files. ``NLST`` retrieves a "
"list of file names. The *callback* function is called for each line with "
"a string argument containing the line with the trailing CRLF stripped.  "
"The default *callback* prints the line to :data:`sys.stdout`."
msgstr ""
"초기화 때 *encoding* 매개 변수로 지정된 인코딩으로 파일이나 디렉터리 목록을 가져옵니다. *cmd*\\는 적절한 "
"``RETR`` 명령(:meth:`retrbinary`\\를 참조하십시오)이거나 ``LIST``\\나 ``NLST``\\와 같은 "
"명령(보통 단지 문자열 ``'LIST'``)이어야 합니다. ``LIST``\\는 파일 목록과 해당 파일에 대한 정보를 가져옵니다. "
"``NLST``\\는 파일 이름 목록을 가져옵니다. *callback* 함수는 각 줄에 대해 호출되며, 후행 CRLF가 제거된 줄을"
" 포함하는 문자열을 인자로 제공합니다. 기본 *callback*\\은 줄을 ``sys.stdout``\\으로 인쇄합니다."

#: ../../library/ftplib.rst:281
msgid ""
"Enable \"passive\" mode if *val* is true, otherwise disable passive mode."
" Passive mode is on by default."
msgstr ""
"*val*\\이 참이면 \"수동(passive)\" 모드를 활성화하고, 그렇지 않으면 수동 모드를 비활성화합니다. 수동 모드는 "
"기본적으로 켜져 있습니다."

#: ../../library/ftplib.rst:287
msgid "Store a file in binary transfer mode."
msgstr ""

#: ../../library/ftplib.rst:289
#, python-brace-format
msgid "An appropriate ``STOR`` command: :samp:`\"STOR {filename}\"`."
msgstr ""

#: ../../library/ftplib.rst:292
msgid ""
"A file object (opened in binary mode) which is read until EOF, using its "
":meth:`~io.RawIOBase.read` method in blocks of size *blocksize* to "
"provide the data to be stored."
msgstr ""

#: ../../library/ftplib.rst:298
msgid "The read block size. Defaults to ``8192``."
msgstr ""

#: ../../library/ftplib.rst:302
msgid ""
"A single parameter callable that is called for each block of data sent, "
"with its single argument being the data as :class:`bytes`."
msgstr ""

#: ../../library/ftplib.rst:312
#, fuzzy
msgid "The *rest* parameter was added."
msgstr "*rest* 매개 변수가 추가되었습니다."

#: ../../library/ftplib.rst:318
msgid ""
"Store a file in line mode.  *cmd* should be an appropriate ``STOR`` "
"command (see :meth:`storbinary`).  Lines are read until EOF from the "
":term:`file object` *fp* (opened in binary mode) using its "
":meth:`~io.IOBase.readline` method to provide the data to be stored.  "
"*callback* is an optional single parameter callable that is called on "
"each line after it is sent."
msgstr ""
"줄 모드로 파일을 저장합니다. *cmd*\\는 적절한 ``STOR`` 명령이어야 합니다 (:meth:`storbinary`\\를 "
"참조하십시오). 저장될 데이터를 제공하기 위해 :meth:`~io.IOBase.readline` 메서드를 사용하여 (바이너리 모드로"
" 열린) :term:`파일 객체 <file object>` *fp*\\에서 EOF까지 줄을 읽어 들입니다. *callback*\\은"
" 줄마다 보내진 다음에 호출되는 선택적 단일 매개 변수 콜러블입니다."

#: ../../library/ftplib.rst:327
msgid ""
"Initiate a transfer over the data connection.  If the transfer is active,"
" send an ``EPRT`` or  ``PORT`` command and the transfer command specified"
" by *cmd*, and accept the connection.  If the server is passive, send an "
"``EPSV`` or ``PASV`` command, connect to it, and start the transfer "
"command.  Either way, return the socket for the connection."
msgstr ""
"데이터 연결을 통해 전송을 시작합니다. 전송이 활성화되면, ``EPRT``\\나 ``PORT`` 명령과 *cmd*\\로 지정한 전송"
" 명령을 보내고 연결을 받아들입니다. 서버가 수동(passive)이면, ``EPSV``\\나 ``PASV`` 명령을 전송하고, "
"서버에 연결한 다음 전송 명령을 시작합니다. 어느 쪽이든, 연결 소켓을 반환합니다."

#: ../../library/ftplib.rst:333
msgid ""
"If optional *rest* is given, a ``REST`` command is sent to the server, "
"passing *rest* as an argument.  *rest* is usually a byte offset into the "
"requested file, telling the server to restart sending the file's bytes at"
" the requested offset, skipping over the initial bytes.  Note however "
"that the :meth:`transfercmd` method converts *rest* to a string with the "
"*encoding* parameter specified at initialization, but no check is "
"performed on the string's contents.  If the server does not recognize the"
" ``REST`` command, an :exc:`error_reply` exception will be raised.  If "
"this happens, simply call :meth:`transfercmd` without a *rest* argument."
msgstr ""
"선택적 *rest*\\가 제공되면, ``REST`` 명령이 서버로 전송되고 *rest*\\를 인자로 전달합니다. *rest*\\는 "
"일반적으로 요청된 파일에 대한 바이트 오프셋으로, 요청된 오프셋에서 파일 바이트 전송을 다시 시작하고 초기 바이트를 건너뛰도록 "
"서버에 지시합니다. 그러나 :meth:`transfercmd` 메서드는 초기화 때 지정된 *encoding* 매개 변수를 사용하여 "
"*rest*\\를 문자열로 변환하지만, 문자열의 내용은 점검하지 않음에 유의하십시오. 서버가 ``REST`` 명령을 인식하지 "
"못하면, :exc:`error_reply` 예외가 발생합니다. 이 경우, 단순히 *rest* 인자 없이 "
":meth:`transfercmd`\\를 호출하십시오."

#: ../../library/ftplib.rst:346
msgid ""
"Like :meth:`transfercmd`, but returns a tuple of the data connection and "
"the expected size of the data.  If the expected size could not be "
"computed, ``None`` will be returned as the expected size.  *cmd* and "
"*rest* means the same thing as in :meth:`transfercmd`."
msgstr ""
":meth:`transfercmd`\\와 비슷하지만, 데이터 연결과 데이터의 예상 크기의 튜플을 반환합니다. 예상 크기를 계산할 수"
" 없으면, ``None``\\이 예상 크기로 반환됩니다. *cmd*\\와 *rest*\\는 "
":meth:`transfercmd`\\에서와 같은 의미입니다."

#: ../../library/ftplib.rst:354
msgid ""
"List a directory in a standardized format by using ``MLSD`` command "
"(:rfc:`3659`).  If *path* is omitted the current directory is assumed. "
"*facts* is a list of strings representing the type of information desired"
" (e.g. ``[\"type\", \"size\", \"perm\"]``).  Return a generator object "
"yielding a tuple of two elements for every file found in path.  First "
"element is the file name, the second one is a dictionary containing facts"
" about the file name.  Content of this dictionary might be limited by the"
" *facts* argument but server is not guaranteed to return all requested "
"facts."
msgstr ""
"``MLSD`` 명령(:rfc:`3659`)을 사용하여 표준화된 형식으로 디렉터리를 나열합니다. *path*\\가 생략되면 현재 "
"디렉터리를 가정합니다. *facts*\\는 원하는 정보 유형을 나타내는 문자열의 리스트입니다 (예를 들어 ``[\"type\", "
"\"size\", \"perm\"]``). 경로에서 발견된 모든 파일에 대해 두 요소의 튜플을 산출하는 제너레이터 객체를 "
"반환합니다. 첫 번째 요소는 파일 이름이고, 두 번째 요소는 파일 이름에 대한 사실(facts)을 포함하는 딕셔너리입니다. 이 "
"딕셔너리의 내용은 *facts* 인자에 의해 제한될 수 있지만, 서버가 요청된 모든 사실을 반환한다고 보장하지는 않습니다."

#: ../../library/ftplib.rst:368
msgid ""
"Return a list of file names as returned by the ``NLST`` command.  The "
"optional *argument* is a directory to list (default is the current server"
" directory).  Multiple arguments can be used to pass non-standard options"
" to the ``NLST`` command."
msgstr ""
"``NLST`` 명령이 반환한 파일 이름 리스트를 반환합니다. 선택적 *argument*\\는 나열할 디렉터리입니다 (기본값은 현재"
" 서버 디렉터리입니다). 비표준 옵션을 ``NLST`` 명령에 전달하기 위해 여러 인자를 사용할 수 있습니다."

#: ../../library/ftplib.rst:373 ../../library/ftplib.rst:385
msgid "If your server supports the command, :meth:`mlsd` offers a better API."
msgstr "서버가 명령을 지원한다면, :meth:`mlsd`\\가 더 나은 API를 제공합니다."

#: ../../library/ftplib.rst:378
#, fuzzy
msgid ""
"Produce a directory listing as returned by the ``LIST`` command, printing"
" it to standard output.  The optional *argument* is a directory to list "
"(default is the current server directory).  Multiple arguments can be "
"used to pass non-standard options to the ``LIST`` command.  If the last "
"argument is a function, it is used as a *callback* function as for "
":meth:`retrlines`; the default prints to :data:`sys.stdout`.  This method"
" returns ``None``."
msgstr ""
"``LIST`` 명령이 반환한 디렉터리 목록을 생성하여 표준 출력으로 인쇄합니다. 선택적 *argument*\\는 나열할 "
"디렉터리입니다 (기본값은 현재 서버 디렉터리입니다). 비표준 옵션을 ``LIST`` 명령에 전달하기 위해 여러 인자를 사용할 수 "
"있습니다. 마지막 인자가 함수면, :meth:`retrlines`\\와 같이 *callback* 함수로 사용됩니다; 기본값은 "
"``sys.stdout``\\으로 인쇄합니다. 이 메서드는 ``None``\\을 반환합니다."

#: ../../library/ftplib.rst:390
msgid "Rename file *fromname* on the server to *toname*."
msgstr "서버의 파일 *fromname*\\을 *toname*\\으로 이름을 바꿉니다."

#: ../../library/ftplib.rst:395
msgid ""
"Remove the file named *filename* from the server.  If successful, returns"
" the text of the response, otherwise raises :exc:`error_perm` on "
"permission errors or :exc:`error_reply` on other errors."
msgstr ""
"서버에서 *filename*\\이라는 파일을 제거합니다. 성공하면, 응답 텍스트를 반환하고, 그렇지 않으면 권한 에러면 "
":exc:`error_perm`\\을, 다른 에러면 :exc:`error_reply`\\를 발생시킵니다."

#: ../../library/ftplib.rst:402
msgid "Set the current directory on the server."
msgstr "서버에서 현재 디렉터리를 설정합니다."

#: ../../library/ftplib.rst:407
msgid "Create a new directory on the server."
msgstr "서버에서 새 디렉터리를 만듭니다."

#: ../../library/ftplib.rst:412
msgid "Return the pathname of the current directory on the server."
msgstr "서버에서 현재 디렉터리의 경로명을 반환합니다."

#: ../../library/ftplib.rst:417
msgid "Remove the directory named *dirname* on the server."
msgstr "서버에서 *dirname*\\이라는 디렉터리를 제거합니다."

#: ../../library/ftplib.rst:422
msgid ""
"Request the size of the file named *filename* on the server.  On success,"
" the size of the file is returned as an integer, otherwise ``None`` is "
"returned. Note that the ``SIZE`` command is not  standardized, but is "
"supported by many common server implementations."
msgstr ""
"서버에서 *filename*\\이라는 파일의 크기를 요청합니다. 성공하면, 파일 크기가 정수로 반환되고, 그렇지 않으면 "
"``None``\\이 반환됩니다. ``SIZE`` 명령은 표준화되어 있지 않지만, 많은 일반적인 서버 구현에서 지원됨에 "
"유의하십시오."

#: ../../library/ftplib.rst:430
msgid ""
"Send a ``QUIT`` command to the server and close the connection. This is "
"the \"polite\" way to close a connection, but it may raise an exception "
"if the server responds with an error to the ``QUIT`` command.  This "
"implies a call to the :meth:`close` method which renders the :class:`FTP`"
" instance useless for subsequent calls (see below)."
msgstr ""
"``QUIT`` 명령을 서버로 보내고 연결을 닫습니다. 이는 연결을 닫는 \"정중한\" 방법이지만, 서버가 ``QUIT`` 명령에 "
"대해 에러로 응답하면 예외가 발생할 수 있습니다. 이것은 묵시적인 :meth:`close` 메서드 호출을 수반하며, 이는 후속 "
"호출에 :class:`FTP` 인스턴스를 쓸모없게 만듭니다 (아래를 참조하십시오)."

#: ../../library/ftplib.rst:439
msgid ""
"Close the connection unilaterally.  This should not be applied to an "
"already closed connection such as after a successful call to "
":meth:`~FTP.quit`. After this call the :class:`FTP` instance should not "
"be used any more (after a call to :meth:`close` or :meth:`~FTP.quit` you "
"cannot reopen the connection by issuing another :meth:`login` method)."
msgstr ""
"일방적으로 연결을 닫습니다. 이것은 이미 닫힌 연결에는 적용되지 않아야 합니다, 가령 :meth:`~FTP.quit`\\를 "
"성공적으로 호출한 후에. 이 호출 후 :class:`FTP` 인스턴스를 더는 사용하지 않아야 합니다 (:meth:`close`\\나"
" :meth:`~FTP.quit` 호출 후 다른 :meth:`login` 메서드를 사용해서 연결을 다시 열 수 없습니다)."

#: ../../library/ftplib.rst:447
#, fuzzy
msgid "FTP_TLS objects"
msgstr "FTP_TLS 객체"

#: ../../library/ftplib.rst:452
msgid ""
"An :class:`FTP` subclass which adds TLS support to FTP as described in "
":rfc:`4217`. Connect to port 21 implicitly securing the FTP control "
"connection before authenticating."
msgstr ""

#: ../../library/ftplib.rst:458
msgid ""
"The user must explicitly secure the data connection by calling the "
":meth:`prot_p` method."
msgstr ""

#: ../../library/ftplib.rst:476
msgid ""
"An SSL context object which allows bundling SSL configuration options, "
"certificates and private keys into a single, potentially long-lived, "
"structure. Please read :ref:`ssl-security` for best practices."
msgstr ""

#: ../../library/ftplib.rst:483
msgid ""
"A timeout in seconds for blocking operations like :meth:`~FTP.connect` "
"(default: the global default timeout setting)."
msgstr ""

#: ../../library/ftplib.rst:497
#, fuzzy
msgid "Added the *source_address* parameter."
msgstr "*source_address* 매개 변수가 추가되었습니다."

#: ../../library/ftplib.rst:500
#, fuzzy
msgid ""
"The class now supports hostname check with "
":attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see "
":const:`ssl.HAS_SNI`)."
msgstr ""
"이 클래스는 이제 :attr:`ssl.SSLContext.check_hostname`\\과 *서버 이름 표시(Server Name "
"Indication)*\\(:data:`ssl.HAS_SNI`\\를 참조하십시오)으로 호스트명 확인을 지원합니다."

#: ../../library/ftplib.rst:511
msgid "The deprecated *keyfile* and *certfile* parameters have been removed."
msgstr ""

#: ../../library/ftplib.rst:514
msgid "Here's a sample session using the :class:`FTP_TLS` class::"
msgstr ":class:`FTP_TLS` 클래스를 사용한 샘플 세션은 다음과 같습니다::"

#: ../../library/ftplib.rst:516
msgid ""
">>> ftps = FTP_TLS('ftp.pureftpd.org')\n"
">>> ftps.login()\n"
"'230 Anonymous user logged in'\n"
">>> ftps.prot_p()\n"
"'200 Data protection level set to \"private\"'\n"
">>> ftps.nlst()\n"
"['6jack', 'OpenBSD', 'antilink', 'blogbench', 'bsdcam', 'clockspeed', "
"'djbdns-jedi', 'docs', 'eaccelerator-jedi', 'favicon.ico', 'francotone', "
"'fugu', 'ignore', 'libpuzzle', 'metalog', 'minidentd', 'misc', 'mysql-"
"udf-global-user-variables', 'php-jenkins-hash', 'php-skein-hash', 'php-"
"webdav', 'phpaudit', 'phpbench', 'pincaster', 'ping', 'posto', 'pub', "
"'public', 'public_keys', 'pure-ftpd', 'qscan', 'qtc', 'sharedance', "
"'skycache', 'sound', 'tmp', 'ucarp']"
msgstr ""

#: ../../library/ftplib.rst:524
#, fuzzy
msgid ""
":class:`!FTP_TLS` class inherits from :class:`FTP`, defining these "
"additional methods and attributes:"
msgstr ":class:`FTP_TLS` 클래스는 :class:`FTP`\\를 상속하여, 다음과 같은 추가 객체를 정의합니다:"

#: ../../library/ftplib.rst:529
#, fuzzy
msgid "The SSL version to use (defaults to :data:`ssl.PROTOCOL_SSLv23`)."
msgstr "사용할 SSL 버전 (기본값은 :attr:`ssl.PROTOCOL_SSLv23`\\입니다)."

#: ../../library/ftplib.rst:533
msgid ""
"Set up a secure control connection by using TLS or SSL, depending on what"
" is specified in the :attr:`ssl_version` attribute."
msgstr ":attr:`ssl_version` 어트리뷰트에 지정된 내용에 따라, TLS나 SSL을 사용하여 보안 제어 연결을 설정합니다."

#: ../../library/ftplib.rst:536
#, fuzzy
msgid ""
"The method now supports hostname check with "
":attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see "
":const:`ssl.HAS_SNI`)."
msgstr ""
"이 메서드는 이제 :attr:`ssl.SSLContext.check_hostname`\\과 *서버 이름 표시(Server Name "
"Indication)*\\로 호스트명 확인을 지원합니다 (:data:`ssl.HAS_SNI`\\를 참조하십시오)."

#: ../../library/ftplib.rst:543
msgid ""
"Revert control channel back to plaintext.  This can be useful to take "
"advantage of firewalls that know how to handle NAT with non-secure FTP "
"without opening fixed ports."
msgstr ""
"제어 채널을 일반 텍스트로 되돌립니다. 고정 포트를 열지 않고 비보안 FTP로 NAT을 다루는 방법을 알고 있는 방화벽을 활용하는 "
"데 유용할 수 있습니다."

#: ../../library/ftplib.rst:551
msgid "Set up secure data connection."
msgstr "보안 데이터 연결을 설정합니다."

#: ../../library/ftplib.rst:555
msgid "Set up clear text data connection."
msgstr "일반 텍스트 데이터 연결을 설정합니다."

#: ../../library/ftplib.rst:559
msgid "Module variables"
msgstr ""

#: ../../library/ftplib.rst:563
msgid "Exception raised when an unexpected reply is received from the server."
msgstr "서버에서 예기치 않은 응답이 수신될 때 발생하는 예외."

#: ../../library/ftplib.rst:568
msgid ""
"Exception raised when an error code signifying a temporary error "
"(response codes in the range 400--499) is received."
msgstr "일시적 에러(400--499 범위의 응답 코드)를 나타내는 에러 코드가 수신될 때 발생하는 예외."

#: ../../library/ftplib.rst:574
msgid ""
"Exception raised when an error code signifying a permanent error "
"(response codes in the range 500--599) is received."
msgstr "영구 에러(500--599 범위의 응답 코드)를 나타내는 에러 코드가 수신될 때 발생하는 예외."

#: ../../library/ftplib.rst:580
msgid ""
"Exception raised when a reply is received from the server that does not "
"fit the response specifications of the File Transfer Protocol, i.e. begin"
" with a digit in the range 1--5."
msgstr ""
"서버로부터 FTP(File Transfer Protocol)의 응답 규격(즉, 1--5 범위의 숫자로 시작)에 맞지 않는 응답을 "
"수신할 때 발생하는 예외."

#: ../../library/ftplib.rst:587
msgid ""
"The set of all exceptions (as a tuple) that methods of :class:`FTP` "
"instances may raise as a result of problems with the FTP connection (as "
"opposed to programming errors made by the caller).  This set includes the"
" four exceptions listed above as well as :exc:`OSError` and "
":exc:`EOFError`."
msgstr ""
":class:`FTP` 인스턴스의 메서드가 (호출자로 인한 프로그래밍 에러가 아니라) FTP 연결 문제로 인해 발생시킬 수 있는 "
"모든 예외의 집합 (튜플). 이 집합에는 위에 나열된 네 가지 예외뿐만 아니라 :exc:`OSError`\\와 "
":exc:`EOFError`\\가 포함됩니다."

#: ../../library/ftplib.rst:595
msgid "Module :mod:`netrc`"
msgstr "모듈 :mod:`netrc`"

#: ../../library/ftplib.rst:596
msgid ""
"Parser for the :file:`.netrc` file format.  The file :file:`.netrc` is "
"typically used by FTP clients to load user authentication information "
"before prompting the user."
msgstr ""
":file:`.netrc` 파일 형식의 구문 분석기. :file:`.netrc` 파일은 일반적으로 FTP 클라이언트가 사용자에게 "
"프롬프트 하기 전에 사용자 인증 정보를 로드하는 데 사용됩니다."

#: ../../library/ftplib.rst:9
msgid "FTP"
msgstr ""

#: ../../library/ftplib.rst:9
msgid "protocol"
msgstr ""

#: ../../library/ftplib.rst:9
msgid "ftplib (standard module)"
msgstr ""

#~ msgid "The module defines the following items:"
#~ msgstr "모듈은 다음 항목을 정의합니다:"

#~ msgid ""
#~ "Return a new instance of the "
#~ ":class:`FTP` class.  When *host* is "
#~ "given, the method call ``connect(host)`` "
#~ "is made.  When *user* is given, "
#~ "additionally the method call ``login(user, "
#~ "passwd, acct)`` is made (where *passwd*"
#~ " and *acct* default to the empty "
#~ "string when not given).  The optional"
#~ " *timeout* parameter specifies a timeout"
#~ " in seconds for blocking operations "
#~ "like the connection attempt (if is "
#~ "not specified, the global default "
#~ "timeout setting will be used). "
#~ "*source_address* is a 2-tuple ``(host, "
#~ "port)`` for the socket to bind to"
#~ " as its source address before "
#~ "connecting. The *encoding* parameter specifies"
#~ " the encoding for directories and "
#~ "filenames."
#~ msgstr ""
#~ ":class:`FTP` 클래스의 새 인스턴스를 반환합니다. "
#~ "*host*\\가 주어지면, 메서드 호출 ``connect(host)``\\를"
#~ " 수행합니다. *user*\\가 주어지면, 추가로 메서드 호출"
#~ " ``login(user, passwd, acct)``\\를 수행합니다 "
#~ "(여기서 *passwd*\\와 *acct*\\는 지정하지 않을 때 "
#~ "기본적으로 빈 문자열이 됩니다). 선택적 *timeout* "
#~ "매개 변수는 연결 시도와 같은 블로킹 연산에 대한"
#~ " 시간제한을 초로 지정합니다 (지정하지 않으면, 전역 "
#~ "기본 시간제한 설정이 사용됩니다). *source_address*\\는 "
#~ "소켓이 연결하기 전에 소스 주소로 바인드 하는 "
#~ "2-튜플 ``(host, port)``\\입니다. *encoding* 매개 "
#~ "변수는 디렉터리와 파일명의 인코딩을 지정합니다."

#~ msgid ""
#~ "A :class:`FTP` subclass which adds TLS"
#~ " support to FTP as described in "
#~ ":rfc:`4217`. Connect as usual to port"
#~ " 21 implicitly securing the FTP "
#~ "control connection before authenticating. "
#~ "Securing the data connection requires "
#~ "the user to explicitly ask for it"
#~ " by calling the :meth:`prot_p` method.  "
#~ "*context* is a :class:`ssl.SSLContext` object"
#~ " which allows bundling SSL configuration"
#~ " options, certificates and private keys "
#~ "into a single (potentially long-lived)"
#~ " structure.  Please read :ref:`ssl-"
#~ "security` for best practices."
#~ msgstr ""
#~ ":rfc:`4217`\\에 설명된 대로 FTP에 TLS 지원을 "
#~ "추가하는 :class:`FTP` 서브 클래스. 인증하기 전에 "
#~ "FTP 제어 연결을 묵시적으로 보안을 유지하면서 포트 "
#~ "21에 평소와 같이 연결합니다. 데이터 연결의 보안을 "
#~ "유지하려면 사용자가 :meth:`prot_p` 메서드를 호출하여 "
#~ "명시적으로 요청해야 합니다. *context*\\는 SSL 구성 "
#~ "옵션, 인증서 및 개인 키를 단일 (잠재적으로 오래"
#~ " 유지되는) 구조로 번들링 할 수 있는 "
#~ ":class:`ssl.SSLContext` 객체입니다. 모범 사례를 보려면 "
#~ ":ref:`ssl-security`\\을 읽으십시오."

#~ msgid ""
#~ "*keyfile* and *certfile* are a legacy"
#~ " alternative to *context* -- they can"
#~ " point to PEM-formatted private key"
#~ " and certificate chain files (respectively)"
#~ " for the SSL connection."
#~ msgstr ""
#~ "*keyfile*\\과 *certfile*\\은 *context*\\에 대한 레거시"
#~ " 대안입니다 -- SSL 연결을 위한 (각각) PEM"
#~ " 형식 개인 키와 인증서 체인 파일을 가리킬 "
#~ "수 있습니다."

#~ msgid ""
#~ "*keyfile* and *certfile* are deprecated "
#~ "in favor of *context*. Please use "
#~ ":meth:`ssl.SSLContext.load_cert_chain` instead, or "
#~ "let :func:`ssl.create_default_context` select the"
#~ " system's trusted CA certificates for "
#~ "you."
#~ msgstr ""
#~ "*keyfile*\\과 *certfile*\\은 *context*\\로 대체되어 "
#~ "폐지되었습니다. 대신 :meth:`ssl.SSLContext.load_cert_chain`\\을 "
#~ "사용하거나, :func:`ssl.create_default_context`\\가 시스템의 "
#~ "신뢰할 수 있는 CA 인증서를 선택하도록 하십시오."

#~ msgid ""
#~ "Set the instance's debugging level.  "
#~ "This controls the amount of debugging"
#~ " output printed.  The default, ``0``, "
#~ "produces no debugging output.  A value"
#~ " of ``1`` produces a moderate amount"
#~ " of debugging output, generally a "
#~ "single line per request.  A value "
#~ "of ``2`` or higher produces the "
#~ "maximum amount of debugging output, "
#~ "logging each line sent and received "
#~ "on the control connection."
#~ msgstr ""
#~ "인스턴스의 디버깅 수준을 설정합니다. 인쇄되는 디버깅 출력의"
#~ " 양을 제어합니다. 기본값 ``0``\\은 디버깅 출력을 "
#~ "생성하지 않습니다. ``1`` 값은 적당한 양의 디버깅 "
#~ "출력, 일반적으로 요청당 한 줄을 생성합니다. ``2``"
#~ " 이상의 값은 제어 연결에서 보내고 받는 각 "
#~ "줄을 로깅하여 최대 디버깅 출력량을 생성합니다."

#~ msgid ""
#~ "Connect to the given host and "
#~ "port.  The default port number is "
#~ "``21``, as specified by the FTP "
#~ "protocol specification.  It is rarely "
#~ "needed to specify a different port "
#~ "number.  This function should be called"
#~ " only once for each instance; it "
#~ "should not be called at all if "
#~ "a host was given when the instance"
#~ " was created.  All other methods can"
#~ " only be used after a connection "
#~ "has been made. The optional *timeout*"
#~ " parameter specifies a timeout in "
#~ "seconds for the connection attempt. If"
#~ " no *timeout* is passed, the global"
#~ " default timeout setting will be "
#~ "used. *source_address* is a 2-tuple "
#~ "``(host, port)`` for the socket to "
#~ "bind to as its source address "
#~ "before connecting."
#~ msgstr ""
#~ "주어진 host와 port에 연결합니다. FTP 프로토콜 "
#~ "명세에 지정된 대로, 기본 포트 번호는 ``21``\\입니다."
#~ " 다른 포트 번호를 지정할 필요는 거의 없습니다. "
#~ "이 함수는 각 인스턴스에 대해 한 번만 호출해야"
#~ " 합니다; 인스턴스를 만들 때 host가 제공되었으면, "
#~ "전혀 호출되지 않아야 합니다. 다른 모든 메서드는 "
#~ "연결이 완료된 후에만 사용할 수 있습니다. 선택적 "
#~ "*timeout* 매개 변수는 연결 시도에 대한 시간제한을"
#~ " 초로 지정합니다. *timeout*\\이 전달되지 않으면, 전역"
#~ " 기본 시간제한 설정이 사용됩니다. *source_address*\\는 "
#~ "소켓이 연결하기 전에 소스 주소로 바인드 하는 "
#~ "2-튜플 ``(host, port)``\\입니다."

#~ msgid ""
#~ "Retrieve a file in binary transfer "
#~ "mode.  *cmd* should be an appropriate"
#~ " ``RETR`` command: ``'RETR filename'``. The"
#~ " *callback* function is called for "
#~ "each block of data received, with "
#~ "a single bytes argument giving the "
#~ "data block. The optional *blocksize* "
#~ "argument specifies the maximum chunk "
#~ "size to read on the low-level "
#~ "socket object created to do the "
#~ "actual transfer (which will also be "
#~ "the largest size of the data "
#~ "blocks passed to *callback*).  A "
#~ "reasonable default is chosen. *rest* "
#~ "means the same thing as in the "
#~ ":meth:`transfercmd` method."
#~ msgstr ""
#~ "바이너리 전송 모드로 파일을 가져옵니다. *cmd*\\는 "
#~ "적절한 ``RETR`` 명령이어야 합니다: ``'RETR "
#~ "filename'``. *callback* 함수는 수신된 각 데이터"
#~ " 블록에 대해 호출되며, 단일 바이트열 인자로 데이터"
#~ " 블록을 제공합니다. 선택적 *blocksize* 인자는 실제"
#~ " 전송을 수행하기 위해 만들어진 저수준 소켓 객체에서"
#~ " 읽을 최대 청크 크기를 지정합니다 (*callback*\\에"
#~ " 전달되는 데이터 블록의 최대 크기이기도 합니다). "
#~ "합리적인 기본값이 선택됩니다. *rest*\\는 :meth:`transfercmd`"
#~ " 메서드에서와 같은 의미입니다."

#~ msgid ""
#~ "Store a file in binary transfer "
#~ "mode.  *cmd* should be an appropriate"
#~ " ``STOR`` command: ``\"STOR filename\"``. "
#~ "*fp* is a :term:`file object` (opened"
#~ " in binary mode) which is read "
#~ "until EOF using its :meth:`~io.IOBase.read`"
#~ " method in blocks of size *blocksize*"
#~ " to provide the data to be "
#~ "stored. The *blocksize* argument defaults "
#~ "to 8192.  *callback* is an optional "
#~ "single parameter callable that is called"
#~ " on each block of data after it"
#~ " is sent. *rest* means the same "
#~ "thing as in the :meth:`transfercmd` "
#~ "method."
#~ msgstr ""
#~ "바이너리 전송 모드로 파일을 저장합니다. *cmd*\\는 "
#~ "적절한 ``STOR`` 명령이어야 합니다: ``\"STOR "
#~ "filename\"``. *fp*\\는 (바이너리 모드로 열린) "
#~ ":term:`파일 객체 <file object>`\\이며 저장될 데이터를"
#~ " 제공하기 위해 *blocksize* 크기의 블록으로 "
#~ ":meth:`~io.IOBase.read` 메서드를 사용하여 EOF까지 읽힙니다."
#~ " *blocksize* 인자의 기본값은 8192입니다. "
#~ "*callback*\\은 각 데이터 블록마다 보내진 다음에 "
#~ "호출되는 선택적 단일 매개 변수 콜러블입니다. "
#~ "*rest*\\는 :meth:`transfercmd` 메서드에서와 같은 의미입니다."

