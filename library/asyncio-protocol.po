# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "트랜스포트와 프로토콜"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "머리말"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs "
"such as :meth:`loop.create_connection`.  They use callback-based "
"programming style and enable high-performance implementations of network "
"or IPC protocols (e.g. HTTP)."
msgstr ""
"트랜스포트와 프로토콜은 :meth:`loop.create_connection`\\와 같은 **저수준** 이벤트 루프 API에서 "
"사용됩니다. 그들은 콜백 기반 프로그래밍 스타일을 사용하고 네트워크 나 IPC 프로토콜(예를 들어 HTTP)의 고성능 구현을 "
"가능하게 합니다."

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries "
"and frameworks and never in high-level asyncio applications."
msgstr ""
"본질에서 트랜스포트와 프로토콜은 라이브러리와 프레임워크에서만 사용되어야 하며 고수준 asyncio 응용 프로그램에서는 사용되지 "
"않아야 합니다."

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "이 문서 페이지는 `트랜스포트 <Transports_>`_\\와 `프로토콜 <Protocols_>`_\\을 모두 다룹니다."

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "소개"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and"
" to some extent when)."
msgstr ""
"최상위 수준에서, 트랜스포트는 *어떻게(how)* 바이트를 전송할지를 다루지만, 프로토콜은 *어떤(which)* 바이트를 전송할지를"
" 결정합니다 (그리고 어느 정도는 언제(when)도)."

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction "
"for a socket (or similar I/O endpoint) while a protocol is an abstraction"
" for an application, from the transport's point of view."
msgstr ""
"같은 것을 다른 식으로 말하면: 트랜스포트는 소켓(또는 유사한 I/O 엔드포인트)의 추상화지만, 프로토콜은 트랜스포트의 관점에서 "
"응용 프로그램의 추상화입니다."

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define"
" an abstract interface for using network I/O and interprocess I/O."
msgstr ""
"또 다른 시각은 트랜스포트와 프로토콜 인터페이스가 함께 네트워크 I/O와 프로세스 간 I/O를 사용하기 위한 추상 인터페이스를 "
"정의한다는 것입니다."

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol "
"objects: the protocol calls transport methods to send data, while the "
"transport calls protocol methods to pass it data that has been received."
msgstr ""
"트랜스포트 객체와 프로토콜 객체 간에는 항상 1:1 관계가 있습니다: 프로토콜은 트랜스포트 메서드를 호출하여 데이터를 보내지만, "
"트랜스포트는 프로토콜 메서드를 호출하여 받은 데이터를 전달합니다."

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as "
":meth:`loop.create_connection`) usually accept a *protocol_factory* "
"argument used to create a *Protocol* object for an accepted connection, "
"represented by a *Transport* object. Such methods usually return a tuple "
"of ``(transport, protocol)``."
msgstr ""
"대부분의 연결 지향 이벤트 루프 메서드(가령 :meth:`loop.create_connection`)는 *Transport* 객체로"
" 표현되는 받아들인 연결을 위한 *Protocol* 객체를 만드는 데 사용되는 *protocol_factory* 인자를 "
"받아들입니다. 이러한 메서드는 대개 ``(transport, protocol)``\\의 튜플을 반환합니다."

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "목차"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "이 설명서 페이지는 다음 절로 구성됩니다:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, "
":class:`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, "
":class:`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"`트랜스포트 <Transports_>`_ 절은 asyncio :class:`BaseTransport`, "
":class:`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, "
":class:`DatagramTransport` 및 :class:`SubprocessTransport` 클래스를 설명합니다."

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, "
":class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, "
"and :class:`SubprocessProtocol` classes."
msgstr ""
"`프로토콜 <Protocols_>`_ 절은 asyncio :class:`BaseProtocol`, :class:`Protocol`,"
" :class:`BufferedProtocol`, :class:`DatagramProtocol` 및 "
":class:`SubprocessProtocol` 클래스를 설명합니다."

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols,"
" and low-level event loop APIs."
msgstr "`예제 <Examples_>`_ 절은 트랜스포트, 프로토콜 및 저수준 이벤트 루프 API를 사용하는 방법을 보여줍니다."

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "트랜스포트"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**소스 코드:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr "트랜스포트는 다양한 종류의 통신 채널을 추상화하기 위해 :mod:`asyncio`\\에서 제공하는 클래스입니다."

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"트랜스포트 객체는 항상 :ref:`asyncio 이벤트 루프 <asyncio-event-loop>`\\에 의해 인스턴스로 "
"만들어집니다."

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. "
"The methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio는 TCP, UDP, SSL 및 서브 프로세스 파이프를 위한 트랜스포트를 구현합니다. 트랜스포트에서 사용할 수 있는 "
"메서드는 트랜스포트의 종류에 따라 다릅니다."

#: ../../library/asyncio-protocol.rst:85
msgid "The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr "트랜스포트 클래스는 :ref:`스레드 안전하지 않습니다 <asyncio-multithreading>`."

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "트랜스포트 계층 구조"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio "
"transports share."
msgstr "모든 트랜스포트의 베이스 클래스. 모든 asyncio 트랜스포트가 공유하는 메서드를 포함합니다."

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "쓰기 전용 연결을 위한 베이스 트랜스포트"

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the "
":meth:`loop.connect_write_pipe` event loop method and are also used by "
"subprocess-related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"*WriteTransport* 클래스의 인스턴스는 :meth:`loop.connect_write_pipe` 이벤트 루프 메서드에서 "
"반환되며 :meth:`loop.subprocess_exec`\\와 같은 서브 프로세스 관련 메서드에서도 사용됩니다."

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "읽기 전용 연결을 위한 베이스 트랜스포트"

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the "
":meth:`loop.connect_read_pipe` event loop method and are also used by "
"subprocess-related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"*ReadTransport* 클래스의 인스턴스는 :meth:`loop.connect_read_pipe` 이벤트 루프 메서드에서 "
"반환되며 :meth:`loop.subprocess_exec`\\와 같은 서브 프로세스 관련 메서드에서도 사용됩니다."

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP "
"connection."
msgstr "TCP 연결과 같은 양방향 트랜스포트를 나타내는 인터페이스."

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary "
"to create the transport and protocol."
msgstr ""
"사용자는 트랜스포트를 직접 인스턴스로 만들지 않습니다; 유틸리티 함수를 호출하고, 프로토콜 팩토리와 트랜스포트와 프로토콜을 만드는 "
"데 필요한 기타 정보를 전달합니다."

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event "
"loop methods like :meth:`loop.create_connection`, "
":meth:`loop.create_unix_connection`, :meth:`loop.create_server`, "
":meth:`loop.sendfile`, etc."
msgstr ""
"*Transport* 클래스의 인스턴스는 :meth:`loop.create_connection`, "
":meth:`loop.create_unix_connection`, :meth:`loop.create_server`, "
":meth:`loop.sendfile` 등과 같은 이벤트 루프 메서드에서 반환되거나 사용됩니다."

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "데이터 그램 (UDP) 연결을 위한 트랜스포트."

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the "
":meth:`loop.create_datagram_endpoint` event loop method."
msgstr ""
"*DatagramTransport* 클래스의 인스턴스는 :meth:`loop.create_datagram_endpoint` 이벤트 "
"루프 메서드에서 반환됩니다."

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child "
"OS process."
msgstr "부모와 그 자식 OS 프로세스 간의 연결을 나타내는 추상화."

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop"
" methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"*SubprocessTransport* 클래스의 인스턴스는 이벤트 루프 메서드 "
":meth:`loop.subprocess_shell`\\과 :meth:`loop.subprocess_exec`\\에서 반환됩니다."

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "베이스 트랜스포트"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "트랜스포트를 닫습니다."

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all "
"buffered data is flushed, the protocol's "
":meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` method "
"will be called with :const:`None` as its argument. The transport should "
"not be used once it is closed."
msgstr ""
"트랜스포트에 송신 데이터용 버퍼가 있으면, 버퍼 된 데이터는 비동기적으로 플러시 됩니다. 더는 데이터가 수신되지 않습니다. 버퍼 된"
" 모든 데이터가 플러시 된 후, 프로토콜의 :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` 메서드가 :const:`None`\\을 인자로 사용하여 호출됩니다. "
"트랜스포트가 닫힌 후에는 사용해서는 안 됩니다."

#: ../../library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "트랜스포트가 닫히는 중이거나 닫혔으면 ``True``\\를 반환합니다."

#: ../../library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr "트랜스포트나 그것이 사용하는 하부 자원에 대한 정보를 반환합니다."

#: ../../library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific "
"information to get."
msgstr "*name*\\은 얻고자 하는 트랜스포트 특정 정보의 조각을 나타내는 문자열입니다."

#: ../../library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or "
"if the transport does not support querying it with the given third-party "
"event loop implementation or on the current platform."
msgstr ""
"*default*\\는 정보가 없거나 트랜스포트가 제삼자 이벤트 루프 구현이나 현재 플랫폼에서 조회를 지원하지 않을 때 반환 할 "
"값입니다."

#: ../../library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket "
"object of the transport::"
msgstr "예를 들어, 다음 코드는 트랜스포트의 하부 소켓 객체를 가져오려고 시도합니다::"

#: ../../library/asyncio-protocol.rst:182
msgid ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"
msgstr ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"

#: ../../library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr "일부 트랜스포트에서 조회할 수 있는 정보의 범주:"

#: ../../library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "소켓:"

#: ../../library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, "
"result of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: 소켓이 연결된 원격 주소, :meth:`socket.socket.getpeername`\\의 결과 "
"(에러 시 ``None``)"

#: ../../library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` 인스턴스"

#: ../../library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of "
":meth:`socket.socket.getsockname`"
msgstr "``'sockname'``: 소켓 자체 주소, :meth:`socket.socket.getsockname`\\의 결과"

#: ../../library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "SSL 소켓:"

#: ../../library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of "
":meth:`ssl.SSLSocket.compression`"
msgstr ""
"``'compression'``: 문자열로 표현된 사용된 압축 알고리즘, 또는 연결이 압축되지 않았으면 ``None``; "
":meth:`ssl.SSLSocket.compression`\\의 결과"

#: ../../library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being"
" used, the version of the SSL protocol that defines its use, and the "
"number of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: 사용되는 암호 체계의 이름, 이의 사용을 정의하는 SSL 프로토콜의 버전 및 사용되는 비밀 비트의 수를 "
"포함하는 3-튜플; :meth:`ssl.SSLSocket.cipher`\\의 결과"

#: ../../library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of "
":meth:`ssl.SSLSocket.getpeercert`"
msgstr "``'peercert'``: 피어 인증서; :meth:`ssl.SSLSocket.getpeercert`\\의 결과"

#: ../../library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` 인스턴스"

#: ../../library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` "
"instance"
msgstr "``'ssl_object'``: :class:`ssl.SSLObject` 나 :class:`ssl.SSLSocket` 인스턴스"

#: ../../library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "파이프:"

#: ../../library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: 파이프 객체"

#: ../../library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "서브 프로세스:"

#: ../../library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` 인스턴스"

#: ../../library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "새 프로토콜을 설정합니다."

#: ../../library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented"
" to support the switch."
msgstr "프로토콜의 교환은 두 프로토콜이 교환을 지원한다고 문서화 되었을 때만 수행되어야 합니다."

#: ../../library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "현재 프로토콜을 반환합니다."

#: ../../library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "읽기 전용 트랜스포트"

#: ../../library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "트랜스 포트가 새로운 데이터를 받고 있으면 ``True``\\를 반환합니다."

#: ../../library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` "
"method until :meth:`resume_reading` is called."
msgstr ""
"트랜스포트의 수신 끝을 일시 중지합니다. :meth:`resume_reading`\\이 호출 될 때까지 프로토콜의 "
":meth:`protocol.data_received() <Protocol.data_received>` 메서드에 데이터가 전달되지 "
"않습니다."

#: ../../library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr "이 메서드는 멱등적(idempotent)입니다. 즉, 트랜스포트가 이미 일시 중지되거나 닫혔을 때도 호출할 수 있습니다."

#: ../../library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received()"
" <Protocol.data_received>` method will be called once again if some data "
"is available for reading."
msgstr ""
"수신 끝을 재개합니다. 읽을 수 있는 데이터가 있다면 프로토콜의 :meth:`protocol.data_received() "
"<Protocol.data_received>` 메서드가 다시 한번 호출됩니다."

#: ../../library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr "이 메서드는 멱등적(idempotent)입니다. 즉, 트랜스포트가 이미 읽고 있을 때도 호출할 수 있습니다."

#: ../../library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "쓰기 전용 트랜스포트"

#: ../../library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations "
"to complete.  Buffered data will be lost.  No more data will be received."
" The protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will eventually be called with "
":const:`None` as its argument."
msgstr ""
"계류 중인 작업이 완료될 때까지 기다리지 않고, 즉시 트랜스포트를 닫습니다. 버퍼 된 데이터는 손실됩니다. 더는 데이터가 수신되지 "
"않습니다. 프로토콜의 :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` 메서드는 결국 :const:`None`\\을 인자로 사용하여 호출됩니다."

#: ../../library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports "
":meth:`~WriteTransport.write_eof`, :const:`False` if not."
msgstr ""
"트랜스포트가 :meth:`~WriteTransport.write_eof`\\를 지원하면 :const:`True`\\를 반환하고, "
"그렇지 않으면 :const:`False`\\를 반환합니다."

#: ../../library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr "트랜스포트가 사용하는 출력 버퍼의 현재 크기를 반환합니다."

#: ../../library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a "
"tuple ``(low, high)`` where *low* and *high* are positive number of "
"bytes."
msgstr ""
"쓰기 흐름 제어를 위한 *high* 와 *low* 수위(watermark)를 가져옵니다. 튜플 ``(low, high)``\\를 "
"반환합니다. 여기서 *low* 와 *high*\\는 양의 바이트 수입니다."

#: ../../library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "제한을 설정하려면 :meth:`set_write_buffer_limits`\\를 사용하십시오."

#: ../../library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "쓰기 흐름 제어를 위한 *high* 와 *low* 수위(watermark)를 설정합니다."

#: ../../library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the "
"protocol's :meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` "
"and :meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` "
"methods are called. If specified, the low watermark must be less than or "
"equal to the high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"이 두 값(바이트 수로 측정)은 프로토콜의 :meth:`protocol.pause_writing() "
"<BaseProtocol.pause_writing>` 과 :meth:`protocol.resume_writing() "
"<BaseProtocol.resume_writing>` 메서드가 언제 호출될지를 제어합니다. 지정하면, low 수위는 high "
"수위보다 작거나 같아야 합니다. *high* 와 *low*\\는 음수가 될 수 없습니다."

#: ../../library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size "
"becomes greater than or equal to the *high* value. If writing has been "
"paused, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size becomes less than or equal to the *low* value."
msgstr ""
"버퍼 크기가 *high* 값보다 크거나 같아질 때 :meth:`~BaseProtocol.pause_writing`\\가 호출됩니다."
" 쓰기가 일시 중지되면, 버퍼 크기가 *low* 값보다 작거나 같아질 때 "
":meth:`~BaseProtocol.resume_writing`\\이 호출됩니다."

#: ../../library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value "
"less than or equal to the high watermark.  Setting *high* to zero forces "
"*low* to zero as well, and causes :meth:`~BaseProtocol.pause_writing` to "
"be called whenever the buffer becomes non-empty.  Setting *low* to zero "
"causes :meth:`~BaseProtocol.resume_writing` to be called only once the "
"buffer is empty. Use of zero for either limit is generally sub-optimal as"
" it reduces opportunities for doing I/O and computation concurrently."
msgstr ""
"기본값은 구현에 따라 다릅니다. high 수위만 주어지면, low 수위는 high 수위보다 작거나 같은 구현 특정 기본값이 "
"사용됩니다. *high*\\를 0으로 설정하면, *low*\\도 0으로 설정되고, 버퍼가 비어있지 않게 될 때마다 "
":meth:`~BaseProtocol.pause_writing`\\가 호출되도록 합니다. *low*\\를 0으로 설정하면 버퍼가 빌"
" 때만 :meth:`~BaseProtocol.resume_writing`\\이 호출됩니다. 두 제한 중 하나에 0을 사용하는 것은 "
"I/O와 계산을 동시에 수행할 기회를 줄이기 때문에 일반적으로 최선이 아닙니다."

#: ../../library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr "제한을 가져오려면 :meth:`~WriteTransport.get_write_buffer_limits`\\를 사용하십시오."

#: ../../library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "어떤 *data* 바이트열을 트랜스포트에 기록합니다."

#: ../../library/asyncio-protocol.rst:333
#: ../../library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be"
" sent out asynchronously."
msgstr "이 메서드는 블록하지 않습니다; 데이터를 버퍼하고 비동기적으로 전송되도록 배치합니다."

#: ../../library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded "
"by the iterable, but may be implemented more efficiently."
msgstr ""
"트랜스포트에 데이터 바이트열 리스트(또는 임의의 이터러블)를 기록합니다. 이것은 이터러블이 산출하는 각 요소에 대해 "
":meth:`write`\\를 호출하는 것과 기능 면에서 동등하지만, 더 효율적으로 구현될 수 있습니다."

#: ../../library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. "
"Data may still be received."
msgstr "버퍼 된 모든 데이터를 플러시 한 후 트랜스포트의 쓰기 끝을 닫습니다. 데이터가 여전히 수신될 수 있습니다."

#: ../../library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. "
"SSL) doesn't support half-closed connections."
msgstr ""
"이 메서드는 트랜스포트(예를 들어 SSL)가 반만 닫힌 연결을 지원하지 않으면 :exc:`NotImplementedError`\\를"
" 발생시킬 수 있습니다."

#: ../../library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "데이터 그램 트랜스포트"

#: ../../library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent "
"to the target address given on transport creation."
msgstr ""
"*addr*\\(트랜스포트 종속적인 대상 주소)에 의해 주어진 원격 피어로 *data* 바이트열을 보냅니다. *addr*\\가 "
":const:`None`\\이면, 트랜스포트를 만들 때 지정된 대상 주소로 data가 전송됩니다."

#: ../../library/asyncio-protocol.rst:365
msgid ""
"This method can be called with an empty bytes object to send a zero-"
"length datagram. The buffer size calculation used for flow control is "
"also updated to account for the datagram header."
msgstr ""

#: ../../library/asyncio-protocol.rst:372
msgid ""
"Close the transport immediately, without waiting for pending operations "
"to complete.  Buffered data will be lost. No more data will be received."
"  The protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will eventually be called with "
":const:`None` as its argument."
msgstr ""
"계류 중인 작업이 완료될 때까지 기다리지 않고, 즉시 트랜스포트를 닫습니다. 버퍼 된 데이터는 손실됩니다. 더는 데이터가 수신되지 "
"않습니다. 프로토콜의 :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` 메서드는 결국 :const:`None`\\을 인자로 사용하여 호출됩니다."

#: ../../library/asyncio-protocol.rst:382
msgid "Subprocess Transports"
msgstr "서브 프로세스 트랜스포트"

#: ../../library/asyncio-protocol.rst:386
msgid "Return the subprocess process id as an integer."
msgstr "서브 프로세스 ID를 정수로 반환합니다."

#: ../../library/asyncio-protocol.rst:390
msgid ""
"Return the transport for the communication pipe corresponding to the "
"integer file descriptor *fd*:"
msgstr "정수 파일 기술자 *fd*\\에 대응하는 통신 파이프의 트랜스포트를 돌려줍니다:"

#: ../../library/asyncio-protocol.rst:393
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or "
":const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: 표준 입력(*stdin*)의 읽을 수 있는 스트리밍 트랜스포트, 또는 서브 프로세스가 ``stdin=PIPE``\\로 "
"만들어지지 않았으면 :const:`None`"

#: ../../library/asyncio-protocol.rst:395
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or"
" :const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: 표준 출력(*stdout*)의 쓸 수 있는 스트리밍 트랜스포트, 또는 서브 프로세스가 ``stdout=PIPE``\\로"
" 만들어지지 않았으면 :const:`None`"

#: ../../library/asyncio-protocol.rst:397
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or "
":const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: 표준 오류(*stderr*)의 쓸 수 있는 스트리밍 트랜스포트, 또는 서브 프로세스가 ``stderr=PIPE``\\로"
" 만들어지지 않았으면 :const:`None`"

#: ../../library/asyncio-protocol.rst:399
msgid "other *fd*: :const:`None`"
msgstr "다른 *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:403
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the "
":attr:`subprocess.Popen.returncode` attribute."
msgstr ""
"서브 프로세스 반환 값을 정수로, 혹은 반환되지 않았으면 :const:`None`\\을 반환합니다. "
":attr:`subprocess.Popen.returncode` 어트리뷰트와 유사합니다."

#: ../../library/asyncio-protocol.rst:409
msgid "Kill the subprocess."
msgstr "서브 프로세스를 죽입니다."

#: ../../library/asyncio-protocol.rst:411
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On "
"Windows, this method is an alias for :meth:`terminate`."
msgstr ""
"POSIX 시스템에서, 이 함수는 SIGKILL을 서브 프로세스로 보냅니다. 윈도우에서, 이 메서드는 "
":meth:`terminate`\\의 별칭입니다."

#: ../../library/asyncio-protocol.rst:414
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr ":meth:`subprocess.Popen.kill`\\도 참조하십시오."

#: ../../library/asyncio-protocol.rst:418
msgid ""
"Send the *signal* number to the subprocess, as in "
":meth:`subprocess.Popen.send_signal`."
msgstr ":meth:`subprocess.Popen.send_signal`\\와 마찬가지로 *signal* 번호를 서브 프로세스로 보냅니다."

#: ../../library/asyncio-protocol.rst:423
msgid "Stop the subprocess."
msgstr "서브 프로세스를 중지합니다."

#: ../../library/asyncio-protocol.rst:425
msgid ""
"On POSIX systems, this method sends :py:const:`~signal.SIGTERM` to the "
"subprocess. On Windows, the Windows API function "
":c:func:`!TerminateProcess` is called to stop the subprocess."
msgstr ""
"POSIX 시스템에서, 이 메서드는 :py:const:`~signal.SIGTERM`\\을 서브 프로세스로 보냅니다. 윈도에서, "
"서브 프로세스를 중지하기 위해 윈도우 API 함수 :c:func:`!TerminateProcess`\\가 호출됩니다."

#: ../../library/asyncio-protocol.rst:429
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr ":meth:`subprocess.Popen.terminate`\\도 참조하십시오."

#: ../../library/asyncio-protocol.rst:433
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr ":meth:`kill` 메서드를 호출하여 서브 프로세스를 죽입니다."

#: ../../library/asyncio-protocol.rst:435
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr "서브 프로세스가 아직 반환하지 않았으면, *stdin*, *stdout* 및 *stderr* 파이프의 트랜스포트를 닫습니다."

#: ../../library/asyncio-protocol.rst:442
msgid "Protocols"
msgstr "프로토콜"

#: ../../library/asyncio-protocol.rst:444
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**소스 코드:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:448
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together"
" with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio는 네트워크 프로토콜을 구현하는 데 사용해야 하는 추상 베이스 클래스 집합을 제공합니다. 이러한 클래스는 "
":ref:`트랜스포트 <asyncio-transport>`\\와 함께 사용해야 합니다."

#: ../../library/asyncio-protocol.rst:452
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports "
"on certain events, for example when some data is received. A base "
"protocol method should be called by the corresponding transport."
msgstr ""
"추상 베이스 프로토콜 클래스의 서브 클래스는 일부 또는 모든 메서드를 구현할 수 있습니다. 이 모든 메서드는 콜백입니다: 이것들은 "
"특정 이벤트에서 트랜스포트에 의해 호출됩니다, 예를 들어 어떤 데이터가 수신될 때. 베이스 프로토콜 메서드는 해당 트랜스포트에 의해"
" 호출되어야 합니다."

#: ../../library/asyncio-protocol.rst:459
msgid "Base Protocols"
msgstr "베이스 프로토콜"

#: ../../library/asyncio-protocol.rst:463
msgid "Base protocol with methods that all protocols share."
msgstr "모든 프로토콜이 공유하는 메서드를 가진 베이스 프로토콜."

#: ../../library/asyncio-protocol.rst:467
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, "
"etc)."
msgstr "스트리밍 프로토콜(TCP, 유닉스 소켓 등)을 구현하기 위한 베이스 클래스."

#: ../../library/asyncio-protocol.rst:472
msgid ""
"A base class for implementing streaming protocols with manual control of "
"the receive buffer."
msgstr "수신 버퍼의 수동 제어로 스트리밍 프로토콜을 구현하기 위한 베이스 클래스."

#: ../../library/asyncio-protocol.rst:477
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "데이터 그램 (UDP) 프로토콜을 구현하기 위한 베이스 클래스."

#: ../../library/asyncio-protocol.rst:481
msgid ""
"The base class for implementing protocols communicating with child "
"processes (unidirectional pipes)."
msgstr "자식 프로세스와 통신하는 (단방향 파이프) 프로토콜을 구현하기 위한 베이스 클래스."

#: ../../library/asyncio-protocol.rst:486
msgid "Base Protocol"
msgstr "베이스 프로토콜"

#: ../../library/asyncio-protocol.rst:488
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr "모든 asyncio 프로토콜은 베이스 프로토콜 콜백을 구현할 수 있습니다."

#: ../../library/asyncio-protocol.rst:491
msgid "Connection Callbacks"
msgstr "연결 콜백"

#: ../../library/asyncio-protocol.rst:492
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"연결 콜백은 모든 프로토콜에서 성공적으로 연결될 때마다 정확히 한 번 호출됩니다. 다른 모든 프로토콜 콜백은 이 두 메서드 "
"사이에서만 호출될 수 있습니다."

#: ../../library/asyncio-protocol.rst:498
msgid "Called when a connection is made."
msgstr "연결이 이루어질 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:500
msgid ""
"The *transport* argument is the transport representing the connection.  "
"The protocol is responsible for storing the reference to its transport."
msgstr "*transport* 인자는 연결을 나타내는 트랜스포트입니다. 트랜스포트에 대한 참조를 저장하는 것은 프로토콜의 책임입니다."

#: ../../library/asyncio-protocol.rst:506
msgid "Called when the connection is lost or closed."
msgstr "연결이 끊어지거나 닫힐 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:508
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed "
"by this side of the connection."
msgstr ""
"인자는 예외 객체나 :const:`None`\\입니다. 후자는 정상적인 EOF가 수신되었거나, 연결의 이쪽에서 연결이 "
"중단(abort)되거나 닫혔다는 것을 의미합니다."

#: ../../library/asyncio-protocol.rst:514
msgid "Flow Control Callbacks"
msgstr "흐름 제어 콜백"

#: ../../library/asyncio-protocol.rst:515
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr "흐름 제어 콜백은 프로토콜에 의해 수행되는 쓰기를 일시 중지하거나 다시 시작하도록 트랜스포트에 의해 호출될 수 있습니다."

#: ../../library/asyncio-protocol.rst:518
msgid ""
"See the documentation of the "
":meth:`~WriteTransport.set_write_buffer_limits` method for more details."
msgstr "자세한 내용은 :meth:`~WriteTransport.set_write_buffer_limits` 메서드 설명서를 참조하십시오."

#: ../../library/asyncio-protocol.rst:523
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "트랜스포트 버퍼가 높은 수위를 넘을 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:527
msgid "Called when the transport's buffer drains below the low watermark."
msgstr "트랜스포트 버퍼가 낮은 수위 아래로 내려갈 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:529
msgid ""
"If the buffer size equals the high watermark, "
":meth:`~BaseProtocol.pause_writing` is not called: the buffer size must "
"go strictly over."
msgstr ""
"버퍼 크기가 높은 수위와 같으면, :meth:`~BaseProtocol.pause_writing`\\이 호출되지 않습니다: 버퍼 "
"크기는 엄격하게 초과해야 합니다."

#: ../../library/asyncio-protocol.rst:533
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the "
"buffer size is equal or lower than the low watermark.  These end "
"conditions are important to ensure that things go as expected when either"
" mark is zero."
msgstr ""
"반대로, :meth:`~BaseProtocol.resume_writing`\\은 버퍼 크기가 낮은 수위와 같거나 낮을 때 "
"호출됩니다. 이러한 종료 조건은 수위가 0일 때 예상대로 진행되게 하려면 중요합니다."

#: ../../library/asyncio-protocol.rst:540
msgid "Streaming Protocols"
msgstr "스트리밍 프로토콜"

#: ../../library/asyncio-protocol.rst:542
msgid ""
"Event methods, such as :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :meth:`loop.create_connection`, "
":meth:`loop.create_unix_connection`, "
":meth:`loop.connect_accepted_socket`, :meth:`loop.connect_read_pipe`, and"
" :meth:`loop.connect_write_pipe` accept factories that return streaming "
"protocols."
msgstr ""
":meth:`loop.create_server`, :meth:`loop.create_unix_server`, "
":meth:`loop.create_connection`, :meth:`loop.create_unix_connection`, "
":meth:`loop.connect_accepted_socket`, :meth:`loop.connect_read_pipe` 및 "
":meth:`loop.connect_write_pipe`\\와 같은 이벤트 메서드는 스트리밍 프로토콜을 반환하는 팩토리를 "
"받아들입니다."

#: ../../library/asyncio-protocol.rst:550
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr "어떤 데이터가 수신될 때 호출됩니다. *data*\\는 수신 데이터가 들어있는 비어 있지 않은 바이트열 객체입니다."

#: ../../library/asyncio-protocol.rst:553
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and "
"instead make your parsing generic and flexible. However, data is always "
"received in the correct order."
msgstr ""
"데이터가 버퍼 되고, 조각으로 나뉘고, 재조립되는지는 트랜스포트에 달려있습니다. 일반적으로, 특정 의미에 의존해서는 안 되며, 구문"
" 분석을 일반적이고 유연하게 만들어야 합니다. 그러나, 데이터는 항상 올바른 순서로 수신됩니다."

#: ../../library/asyncio-protocol.rst:558
msgid ""
"The method can be called an arbitrary number of times while a connection "
"is open."
msgstr "이 메서드는 연결이 열려있는 동안 임의의 횟수만큼 호출될 수 있습니다."

#: ../../library/asyncio-protocol.rst:561
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is "
"called at most once.  Once ``eof_received()`` is called, "
"``data_received()`` is not called anymore."
msgstr ""
"그러나, :meth:`protocol.eof_received() <Protocol.eof_received>`\\는 최대한 한 번만 "
"호출됩니다. 일단 ``eof_received()``\\가 호출되면, ``data_received()``\\는 더는 호출되지 "
"않습니다."

#: ../../library/asyncio-protocol.rst:567
msgid ""
"Called when the other end signals it won't send any more data (for "
"example by calling :meth:`transport.write_eof() "
"<WriteTransport.write_eof>`, if the other end also uses asyncio)."
msgstr ""
"다른 쪽 끝이 더는 데이터를 보내지 않을 것이라는 신호를 보낼 때 호출됩니다 (예를 들어, 다른 쪽 끝도 asyncio를 사용하면,"
" :meth:`transport.write_eof() <WriteTransport.write_eof>`\\를 호출하여)."

#: ../../library/asyncio-protocol.rst:572
msgid ""
"This method may return a false value (including ``None``), in which case "
"the transport will close itself.  Conversely, if this method returns a "
"true value, the protocol used determines whether to close the transport. "
"Since the default implementation returns ``None``, it implicitly closes "
"the connection."
msgstr ""
"이 메서드는 거짓 값(``None`` 포함)을 반환할 수 있으며, 이때 트랜스포트는 스스로 닫힙니다. 반대로, 이 메서드가 참값을 "
"반환하면, 사용된 프로토콜이 트랜스포트를 닫을지를 결정합니다. 기본 구현이 ``None``\\을 반환하기 때문에, 묵시적으로 연결을"
" 닫습니다."

#: ../../library/asyncio-protocol.rst:578
msgid ""
"Some transports, including SSL, don't support half-closed connections, in"
" which case returning true from this method will result in the connection"
" being closed."
msgstr "SSL을 포함한 일부 트랜스포트는, 반만 닫힌 연결을 지원하지 않습니다. 이때, 이 메서드에서 참을 반환하면 연결이 닫힙니다."

#: ../../library/asyncio-protocol.rst:583
#: ../../library/asyncio-protocol.rst:641
msgid "State machine:"
msgstr "상태 기계:"

#: ../../library/asyncio-protocol.rst:585
msgid ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"

#: ../../library/asyncio-protocol.rst:594
msgid "Buffered Streaming Protocols"
msgstr "버퍼 된 스트리밍 프로토콜"

#: ../../library/asyncio-protocol.rst:598
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"버퍼 된 프로토콜은 `스트리밍 프로토콜 <Streaming Protocols_>`_\\을 지원하는 모든 이벤트 루프 메서드와 함께 "
"사용할 수 있습니다."

#: ../../library/asyncio-protocol.rst:601
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and"
" control of the receive buffer.  Event loops can then use the buffer "
"provided by the protocol to avoid unnecessary data copies.  This can "
"result in noticeable performance improvement for protocols that receive "
"big amounts of data.  Sophisticated protocol implementations can "
"significantly reduce the number of buffer allocations."
msgstr ""
"``BufferedProtocol`` 구현은 수신 버퍼의 명시적 수동 할당과 제어를 허용합니다. 이벤트 루프는 프로토콜에서 제공하는"
" 버퍼를 사용하여 불필요한 데이터 복사를 피할 수 있습니다. 이로 인해 대량의 데이터를 수신하는 프로토콜의 성능이 크게 향상될 수 "
"있습니다. 정교한 프로토콜 구현은 버퍼 할당 수를 크게 줄일 수 있습니다."

#: ../../library/asyncio-protocol.rst:608
msgid "The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr "다음 콜백은 :class:`BufferedProtocol` 인스턴스에 호출됩니다.:"

#: ../../library/asyncio-protocol.rst:613
msgid "Called to allocate a new receive buffer."
msgstr "새로운 수신 버퍼를 할당하기 위해서 호출됩니다."

#: ../../library/asyncio-protocol.rst:615
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It "
"is acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an "
"error to return a buffer with a zero size."
msgstr ""
"*sizehint*\\는 반환되는 버퍼에 대해 권장되는 최소 크기입니다. *sizehint*\\가 제안하는 것보다 더 작거나 큰 "
"버퍼를 반환하는 것이 허용됩니다. -1로 설정하면 버퍼 크기는 임의적일 수 있습니다. 크기가 0인 버퍼를 반환하는 것은 에러입니다."

#: ../../library/asyncio-protocol.rst:620
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr "``get_buffer()``\\는 :ref:`버퍼 프로토콜 <bufferobjects>`\\을 구현하는 객체를 반환해야 합니다."

#: ../../library/asyncio-protocol.rst:625
msgid "Called when the buffer was updated with the received data."
msgstr "수신된 데이터로 버퍼가 갱신될 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:627
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes*\\는 버퍼에 기록된 총 바이트 수입니다."

#: ../../library/asyncio-protocol.rst:631
msgid ""
"See the documentation of the :meth:`protocol.eof_received() "
"<Protocol.eof_received>` method."
msgstr ":meth:`protocol.eof_received() <Protocol.eof_received>` 메서드의 설명서를 참조하십시오."

#: ../../library/asyncio-protocol.rst:635
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of"
" times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, "
":meth:`~BufferedProtocol.get_buffer` and "
":meth:`~BufferedProtocol.buffer_updated` won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer`\\는 연결 중에 임의의 횟수만큼 호출될 수 있습니다. 그러나, "
":meth:`protocol.eof_received() <Protocol.eof_received>`\\는 최대한 한 번만 호출되며,"
" 호출되면 :meth:`~BufferedProtocol.get_buffer`\\와 "
":meth:`~BufferedProtocol.buffer_updated`\\는 그 이후로 호출되지 않습니다."

#: ../../library/asyncio-protocol.rst:643
msgid ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"

#: ../../library/asyncio-protocol.rst:654
msgid "Datagram Protocols"
msgstr "데이터 그램 프로토콜"

#: ../../library/asyncio-protocol.rst:656
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"데이터 그램 프로토콜 인스턴스는 :meth:`loop.create_datagram_endpoint` 메서드에 전달된 프로토콜 "
"팩토리에 의해 만들어져야 합니다."

#: ../../library/asyncio-protocol.rst:661
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing "
"the incoming data.  *addr* is the address of the peer sending the data; "
"the exact format depends on the transport."
msgstr ""
"데이터 그램이 수신될 때 호출됩니다. *data*\\는 수신 데이터를 포함하는 바이트열 객체입니다. *addr*\\는 데이터를 "
"보내는 피어의 주소입니다; 정확한 형식은 트랜스포트에 따라 다릅니다."

#: ../../library/asyncio-protocol.rst:667
msgid ""
"Called when a previous send or receive operation raises an "
":class:`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"이전의 송신이나 수신 연산이 :class:`OSError`\\를 일으킬 때 호출됩니다. *exc*\\는 "
":class:`OSError` 인스턴스입니다."

#: ../../library/asyncio-protocol.rst:670
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"이 메서드는 드문 조건에서 호출됩니다, 트랜스포트(예를 들어 UDP)가 데이터 그램을 수신자에게 전달할 수 없음을 감지했을 "
"때입니다. 하지만 대부분 전달할 수 없는 데이터 그램은 조용히 삭제됩니다."

#: ../../library/asyncio-protocol.rst:677
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send "
"failures caused by writing too many packets."
msgstr ""
"BSD 시스템(macOS, FreeBSD 등)에서는, 너무 많은 패킷을 쓰는 것으로 인한 전송 실패를 감지하는 신뢰성 있는 방법이 "
"없으므로 데이터 그램 프로토콜에 대한 흐름 제어가 지원되지 않습니다."

#: ../../library/asyncio-protocol.rst:681
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An "
":class:`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may "
"not be raised; if it is raised, it will be reported to "
":meth:`DatagramProtocol.error_received` but otherwise ignored."
msgstr ""
"소켓은 항상 'ready'로 나타나고 여분의 패킷은 삭제됩니다. ``errno``\\가 "
":const:`errno.ENOBUFS`\\로 설정된 :class:`OSError`\\가 발생할 수도 그렇지 않을 수도 있습니다; "
"발생하면, :meth:`DatagramProtocol.error_received`\\에게 보고되지만 그렇지 않으면 무시됩니다."

#: ../../library/asyncio-protocol.rst:690
msgid "Subprocess Protocols"
msgstr "서브 프로세스 프로토콜"

#: ../../library/asyncio-protocol.rst:692
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories"
" passed to the :meth:`loop.subprocess_exec` and "
":meth:`loop.subprocess_shell` methods."
msgstr ""
"서브 프로세스 프로토콜 인스턴스는 :meth:`loop.subprocess_exec` 와 "
":meth:`loop.subprocess_shell` 메서드에 전달된 프로토콜 팩토리에 의해 만들어져야 합니다."

#: ../../library/asyncio-protocol.rst:698
msgid "Called when the child process writes data into its stdout or stderr pipe."
msgstr "자식 프로세스가 stdout 이나 stderr 파이프에 데이터를 쓸 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:701
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd*\\는 파이프의 정수 파일 기술자입니다."

#: ../../library/asyncio-protocol.rst:703
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data*\\는 수신 된 데이터를 포함하는 비어 있지 않은 바이트열 객체입니다."

#: ../../library/asyncio-protocol.rst:707
msgid ""
"Called when one of the pipes communicating with the child process is "
"closed."
msgstr "자식 프로세스와 통신하는 파이프 중 하나가 닫히면 호출됩니다."

#: ../../library/asyncio-protocol.rst:710
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd*\\는 닫힌 정수 파일 기술자입니다."

#: ../../library/asyncio-protocol.rst:714
msgid "Called when the child process has exited."
msgstr "자식 프로세스가 종료할 때 호출됩니다."

#: ../../library/asyncio-protocol.rst:716
msgid ""
"It can be called before :meth:`~SubprocessProtocol.pipe_data_received` "
"and :meth:`~SubprocessProtocol.pipe_connection_lost` methods."
msgstr ""

#: ../../library/asyncio-protocol.rst:721
msgid "Examples"
msgstr "예제"

#: ../../library/asyncio-protocol.rst:726
msgid "TCP Echo Server"
msgstr "TCP 메아리 서버"

#: ../../library/asyncio-protocol.rst:728
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, "
"send back received data, and close the connection::"
msgstr ""
":meth:`loop.create_server` 메서드를 사용하여 TCP 메아리 서버를 만들고, 받은 데이터를 다시 보내고, 연결을"
" 닫습니다::"

#: ../../library/asyncio-protocol.rst:731
#, python-brace-format
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # 저수준 API를 사용할 계획이므로\n"
"    # 이벤트 루프에 대한 참조를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:769
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-"
"streams>` example uses the high-level :func:`asyncio.start_server` "
"function."
msgstr ""
":ref:`스트림을 사용하는 TCP 메아리 서버 <asyncio-tcp-echo-server-streams>` 예제는 고수준 "
":func:`asyncio.start_server` 함수를 사용합니다."

#: ../../library/asyncio-protocol.rst:775
msgid "TCP Echo Client"
msgstr "TCP 메아리 클라이언트"

#: ../../library/asyncio-protocol.rst:777
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
":meth:`loop.create_connection` 메서드를 사용하는 TCP 메아리 클라이언트, 데이터를 보내고 연결이 닫힐 "
"때까지 기다립니다::"

#: ../../library/asyncio-protocol.rst:780
#, python-brace-format
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Wait until the protocol signals that the connection\n"
"    # is lost and close the transport.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # 저수준 API를 사용할 계획이므로\n"
"    # 이벤트 루프에 대한 참조를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # 프로토콜이 연결이 끊어졌음을 알릴 때까지 기다리고\n"
"    # 트랜스포트를 닫습니다.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:825
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-"
"streams>` example uses the high-level :func:`asyncio.open_connection` "
"function."
msgstr ""
":ref:`스트림을 사용하는 TCP 메아리 클라이언트 <asyncio-tcp-echo-client-streams>` 예제는 고수준 "
":func:`asyncio.open_connection` 함수를 사용합니다."

#: ../../library/asyncio-protocol.rst:832
msgid "UDP Echo Server"
msgstr "UDP 메아리 서버"

#: ../../library/asyncio-protocol.rst:834
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` "
"method, sends back received data::"
msgstr ""
":meth:`loop.create_datagram_endpoint` 메서드를 사용하는 UDP 메아리 서버, 수신된 데이터를 다시 "
"보냅니다::"

#: ../../library/asyncio-protocol.rst:837
#, python-format
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # One protocol instance will be created to serve all\n"
"    # client requests.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # Serve for 1 hour.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # 저수준 API를 사용할 계획이므로\n"
"    # 이벤트 루프에 대한 참조를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # 모든 클라이언트 요청을 처리할\n"
"    # 하나의 프로토콜 인스턴스가 만들어집니다.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # 1시간 동안 서비스합니다.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:876
msgid "UDP Echo Client"
msgstr "UDP 메아리 클라이언트"

#: ../../library/asyncio-protocol.rst:878
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` "
"method, sends data and closes the transport when it receives the answer::"
msgstr ""
":meth:`loop.create_datagram_endpoint` 메서드를 사용하는 UDP 메아리 클라이언트, 데이터를 보내고 "
"응답을 받으면 트랜스포트를 닫습니다::"

#: ../../library/asyncio-protocol.rst:881
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # 저수준 API를 사용할 계획이므로\n"
"    # 이벤트 루프에 대한 참조를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:933
msgid "Connecting Existing Sockets"
msgstr "기존 소켓 연결하기"

#: ../../library/asyncio-protocol.rst:935
msgid ""
"Wait until a socket receives data using the "
":meth:`loop.create_connection` method with a protocol::"
msgstr "프로토콜과 함께 :meth:`loop.create_connection` 메서드를 사용하여 소켓이 데이터를 수신할 때까지 기다립니다::"

#: ../../library/asyncio-protocol.rst:938
msgid ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport;\n"
"        # connection_lost() will be called automatically.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the socket to wait for data.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # 작업을 완료했습니다: 트랜스포트를 닫습니다;\n"
"        # connection_lost()가 자동으로 호출됩니다.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # 소켓이 닫혔습니다\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # 저수준 API를 사용할 계획이므로\n"
"    # 이벤트 루프에 대한 참조를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # 연결된 소켓 쌍을 만듭니다\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # 데이터를 기다릴 소켓을 등록합니다.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # 네트워크로부터의 데이터 수신을 흉내 냅니다.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:989
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level "
":meth:`loop.add_reader` method to register an FD."
msgstr ""
":ref:`파일 기술자에서 읽기 이벤트를 관찰하기 <asyncio_example_watch_fd>` 예제는 저수준의 "
":meth:`loop.add_reader` 메서드를 사용하여 FD를 등록합니다."

#: ../../library/asyncio-protocol.rst:993
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level "
"streams created by the :func:`open_connection` function in a coroutine."
msgstr ""
":ref:`스트림을 사용하여 데이터를 기다리는 열린 소켓 등록 <asyncio_example_create_connection-"
"streams>` 예제는 코루틴에서 :func:`open_connection` 함수에 의해 생성된 고수준 스트림을 사용합니다."

#: ../../library/asyncio-protocol.rst:1000
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() 와 SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:1002
msgid ""
"An example of a subprocess protocol used to get the output of a "
"subprocess and to wait for the subprocess exit."
msgstr "서브 프로세스의 출력을 가져오고 서브 프로세스가 끝날 때까지 대기하는 데 사용되는 서브 프로세스 프로토콜의 예."

#: ../../library/asyncio-protocol.rst:1005
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "서브 프로세스는 :meth:`loop.subprocess_exec` 메서드에 의해 만들어집니다::"

#: ../../library/asyncio-protocol.rst:1007
#, python-brace-format
msgid ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # process_exited() method can be called before\n"
"        # pipe_connection_lost() method: wait until both methods are\n"
"        # called.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Create the subprocess controlled by DateProtocol;\n"
"    # redirect the standard output into a pipe.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Wait for the subprocess exit using the process_exited()\n"
"    # method of the protocol.\n"
"    await exit_future\n"
"\n"
"    # Close the stdout pipe.\n"
"    transport.close()\n"
"\n"
"    # Read the output which was collected by the\n"
"    # pipe_data_received() method of the protocol.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"
msgstr ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # pipe_connection_lost() 메서드 전에\n"
"        # process_exited() 메서드가 호출될 수 있습니다:\n"
"        # 두 메서드가 모두 호출될 때까지 기다립니다.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # 저수준 API를 사용할 계획이므로\n"
"    # 이벤트 루프에 대한 참조를 얻습니다.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # DateProtocol이 제어하는 서브 프로세스를 만듭니다;\n"
"    # 표준 출력을 파이프로 리디렉트합니다.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # 프로토콜의 process_exited() 메서드를 사용하여\n"
"    # 서브 프로세스 종료를 기다립니다.\n"
"    await exit_future\n"
"\n"
"    # stdout 파이프를 닫습니다.\n"
"    transport.close()\n"
"\n"
"    # 프로토콜의 pipe_data_received() 메서드로\n"
"    # 수집된 출력을 읽습니다.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"

#: ../../library/asyncio-protocol.rst:1065
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>`"
" written using high-level APIs."
msgstr ""
"고수준 API를 사용하여 작성된 :ref:`같은 예제 "
"<asyncio_example_create_subprocess_exec>`\\도 참조하십시오."

#~ msgid ""
#~ "**Important:** this has been added to"
#~ " asyncio in Python 3.7 *on a "
#~ "provisional basis*!  This is as an "
#~ "experimental API that might be changed"
#~ " or removed completely in Python 3.8."
#~ msgstr ""
#~ "**중요:** 이것은 파이썬 3.7에서 *잠정적으로* asyncio에"
#~ " 추가되었습니다! 이것은 실험용 API로서, 파이썬 3.8에서"
#~ " 변경되거나 완전히 제거될 수 있습니다."

