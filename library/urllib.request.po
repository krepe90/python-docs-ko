# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/urllib.request.rst:2
#, fuzzy
msgid ":mod:`!urllib.request` --- Extensible library for opening URLs"
msgstr ":mod:`urllib.request` --- URL을 열기 위한 확장 가능한 라이브러리"

#: ../../library/urllib.request.rst:11
msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**소스 코드:** :source:`Lib/urllib/request.py`"

#: ../../library/urllib.request.rst:15
msgid ""
"The :mod:`urllib.request` module defines functions and classes which help"
" in opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
":mod:`urllib.request` 모듈은 복잡한 세계에서 URL(대부분 HTTP)을 여는 데 도움이 되는 함수와 클래스를 "
"정의합니다 --- 기본(basic)과 다이제스트 인증, 리디렉션, 쿠키 등."

#: ../../library/urllib.request.rst:21
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"더 고수준 HTTP 클라이언트 인터페이스로 `Requests 패키지 "
"<https://requests.readthedocs.io/en/master/>`_\\를 권장합니다."

#: ../../library/urllib.request.rst:26
msgid ""
"On macOS it is unsafe to use this module in programs using "
":func:`os.fork` because the :func:`getproxies` implementation for macOS "
"uses a higher-level system API. Set the environment variable ``no_proxy``"
" to ``*`` to avoid this problem (e.g. ``os.environ[\"no_proxy\"] = "
"\"*\"``)."
msgstr ""

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/urllib.request.rst:34
msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr ":mod:`urllib.request` 모듈은 다음 함수를 정의합니다:"

#: ../../library/urllib.request.rst:39
#, fuzzy
msgid ""
"Open *url*, which can be either a string containing a valid, properly "
"encoded URL, or a :class:`Request` object."
msgstr "문자열이나 :class:`Request` 객체일 수 있는, URL *url*\\을 엽니다."

#: ../../library/urllib.request.rst:42
msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data*\\는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 ``None``\\이어야 "
"합니다. 자세한 내용은 :class:`Request`\\를 참조하십시오."

#: ../../library/urllib.request.rst:46
msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` "
"header in its HTTP requests."
msgstr "urllib.request 모듈은 HTTP/1.1을 사용하고 HTTP 요청에 ``Connection:close`` 헤더를 포함합니다."

#: ../../library/urllib.request.rst:49
msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for "
"blocking operations like the connection attempt (if not specified, the "
"global default timeout setting will be used).  This actually only works "
"for HTTP, HTTPS and FTP connections."
msgstr ""
"선택적 *timeout* 매개 변수는 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 "
"전역 기본 시간제한 설정이 사용됩니다). 이것은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다."

#: ../../library/urllib.request.rst:54
msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See "
":class:`~http.client.HTTPSConnection` for more details."
msgstr ""
"*context*\\가 지정되면, 다양한 SSL 옵션을 기술하는 :class:`ssl.SSLContext` 인스턴스이어야 합니다. "
"자세한 내용은 :class:`~http.client.HTTPSConnection`\\을 참조하십시오."

#: ../../library/urllib.request.rst:58
msgid ""
"This function always returns an object which can work as a :term:`context"
" manager` and has the properties *url*, *headers*, and *status*. See "
":class:`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"이 함수는 항상 :term:`컨텍스트 관리자 <context manager>`\\로 작동할 수 있고 *url*, *headers* "
"및 *status* 프로퍼티를 가진 객체를 반환합니다. 이러한 프로퍼티에 대한 자세한 내용은 "
":class:`urllib.response.addinfourl`\\을 참조하십시오."

#: ../../library/urllib.request.rst:62
msgid ""
"For HTTP and HTTPS URLs, this function returns a "
":class:`http.client.HTTPResponse` object slightly modified. In addition "
"to the three new methods above, the msg attribute contains the same "
"information as the :attr:`~http.client.HTTPResponse.reason` attribute ---"
" the reason phrase returned by server --- instead of the response headers"
" as it is specified in the documentation for "
":class:`~http.client.HTTPResponse`."
msgstr ""
"HTTP 및 HTTPS URL의 경우, 이 함수는 약간 수정된 :class:`http.client.HTTPResponse` 객체를 "
"반환합니다. 위의 세 가지 새로운 메서드 외에도, msg 어트리뷰트에는 "
":class:`~http.client.HTTPResponse` 설명서에 지정된 대로 응답 헤더 대신 "
":attr:`~http.client.HTTPResponse.reason` 어트리뷰트와 --- 서버가 반환한 이유 문구 --- 같은 "
"정보가 포함됩니다."

#: ../../library/urllib.request.rst:70
msgid ""
"For FTP, file, and data URLs and requests explicitly handled by legacy "
":class:`URLopener` and :class:`FancyURLopener` classes, this function "
"returns a :class:`urllib.response.addinfourl` object."
msgstr ""
"FTP, 파일 및 데이터 URL과 레거시 :class:`URLopener`\\와 :class:`FancyURLopener` "
"클래스에서 명시적으로 처리된 요청의 경우, 이 함수는 :class:`urllib.response.addinfourl` 객체를 "
"반환합니다."

#: ../../library/urllib.request.rst:74
msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr "프로토콜 에러 시 :exc:`~urllib.error.URLError`\\를 발생시킵니다."

#: ../../library/urllib.request.rst:76
msgid ""
"Note that ``None`` may be returned if no handler handles the request "
"(though the default installed global :class:`OpenerDirector` uses "
":class:`UnknownHandler` to ensure this never happens)."
msgstr ""
"아무런 처리기도 요청을 처리하지 않으면 ``None``\\이 반환될 수 있습니다 (기본 설치된 전역 "
":class:`OpenerDirector`\\는 :class:`UnknownHandler`\\를 사용하여 이러한 상황이 발생하지 "
"않도록 합니다)."

#: ../../library/urllib.request.rst:80
#, fuzzy
msgid ""
"In addition, if proxy settings are detected (for example, when a "
"``*_proxy`` environment variable like :envvar:`!http_proxy` is set), "
":class:`ProxyHandler` is default installed and makes sure the requests "
"are handled through the proxy."
msgstr ""
"또한, 프락시 설정이 감지되면 (예를 들어, :envvar:`http_proxy`\\와 같은 ``*_proxy`` 환경 변수가 "
"설정될 때), :class:`ProxyHandler`\\가 기본적으로 설치되어 프락시를 통해 요청이 처리되도록 합니다."

#: ../../library/urllib.request.rst:85
msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has "
"been discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a "
"dictionary parameter to ``urllib.urlopen``, can be obtained by using "
":class:`ProxyHandler` objects."
msgstr ""
"파이썬 2.6 및 이전 버전의 레거시 ``urllib.urlopen`` 함수는 중단되었습니다; "
":func:`urllib.request.urlopen`\\는 이전 ``urllib2.urlopen``\\에 해당합니다. 딕셔너리 "
"매개 변수를 ``urllib.urlopen``\\에 전달하여 수행되었던 프락시 처리는 :class:`ProxyHandler` 객체를"
" 사용하여 얻을 수 있습니다."

#: ../../library/urllib.request.rst:91 ../../library/urllib.request.rst:93
msgid ""
"The default opener raises an :ref:`auditing event <auditing>` "
"``urllib.Request`` with arguments ``fullurl``, ``data``, ``headers``, "
"``method`` taken from the request object."
msgstr ""
"기본 오프너는 요청 객체에서 취한 인자 ``fullurl``, ``data``, ``headers``, ``method``\\로 "
":ref:`감사 이벤트 <auditing>` ``urllib.Request``\\를 발생시킵니다."

#: ../../library/urllib.request.rst:97
msgid "*cafile* and *capath* were added."
msgstr "*cafile*\\과 *capath*\\가 추가되었습니다."

#: ../../library/urllib.request.rst:100
#, fuzzy
msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if "
":const:`ssl.HAS_SNI` is true)."
msgstr "가능하다면 (즉, :data:`ssl.HAS_SNI`\\가 참이라면) HTTPS 가상 호스트가 지원됩니다."

#: ../../library/urllib.request.rst:103
msgid "*data* can be an iterable object."
msgstr "*data*\\는 이터러블 객체일 수 있습니다."

#: ../../library/urllib.request.rst:105
msgid "*cadefault* was added."
msgstr "*cadefault*\\가 추가되었습니다."

#: ../../library/urllib.request.rst:108
msgid "*context* was added."
msgstr "*context*\\가 추가되었습니다."

#: ../../library/urllib.request.rst:111
msgid ""
"HTTPS connection now send an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN"
" protocols with :meth:`~ssl.SSLContext.set_alpn_protocols`."
msgstr ""

#: ../../library/urllib.request.rst:116
msgid ""
"Remove *cafile*, *capath* and *cadefault* parameters: use the *context* "
"parameter instead."
msgstr ""

#: ../../library/urllib.request.rst:123
msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener."
" Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of "
":func:`~urllib.request.urlopen`.  The code does not check for a real "
":class:`OpenerDirector`, and any class with the appropriate interface "
"will work."
msgstr ""
":class:`OpenerDirector` 인스턴스를 기본 전역 오프너로 설치합니다. 오프너 설치는 urlopen이 해당 오프너를 "
"사용하도록 하려는 경우에만 필요합니다; 그렇지 않으면 단순히 :func:`~urllib.request.urlopen` 대신 "
":meth:`OpenerDirector.open`\\을 호출하십시오. 코드는 실제 :class:`OpenerDirector`\\를 "
"확인하지 않으며, 적절한 인터페이스를 가진 클래스면 모두 작동합니다."

#: ../../library/urllib.request.rst:133
msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in "
"the order given. *handler*\\s can be either instances of "
":class:`BaseHandler`, or subclasses of :class:`BaseHandler` (in which "
"case it must be possible to call the constructor without any parameters)."
"  Instances of the following classes will be in front of the "
"*handler*\\s, unless the *handler*\\s contain them, instances of them or "
"subclasses of them: :class:`ProxyHandler` (if proxy settings are "
"detected), :class:`UnknownHandler`, :class:`HTTPHandler`, "
":class:`HTTPDefaultErrorHandler`, :class:`HTTPRedirectHandler`, "
":class:`FTPHandler`, :class:`FileHandler`, :class:`HTTPErrorProcessor`."
msgstr ""
"주어진 순서대로 처리기를 연결하는 :class:`OpenerDirector` 인스턴스를 반환합니다. *handler*\\는 "
":class:`BaseHandler`\\의 인스턴스이거나 :class:`BaseHandler`\\의 서브 클래스(이 경우 매개 변수"
" 없이 생성자를 호출할 수 있어야 합니다)일 수 있습니다. 다음과 같은 클래스들의 인스턴스는 *handler*\\에 그들, 그들의 "
"인스턴스 또는 그들의 서브 클래스가 포함되지 않는 한 *handler* 앞에 있습니다: :class:`ProxyHandler` "
"(프락시 설정이 감지되는 경우), :class:`UnknownHandler`, :class:`HTTPHandler`, "
":class:`HTTPDefaultErrorHandler`, :class:`HTTPRedirectHandler`, "
":class:`FTPHandler`, :class:`FileHandler`, :class:`HTTPErrorProcessor`."

#: ../../library/urllib.request.rst:143
msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` "
"module can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"파이썬 설치에 SSL 지원이 있으면 (즉, :mod:`ssl` 모듈을 임포트 할 수 있으면) "
":class:`HTTPSHandler`\\도 추가됩니다."

#: ../../library/urllib.request.rst:146
msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order`"
" attribute to modify its position in the handlers list."
msgstr ""
":class:`BaseHandler` 서브 클래스는 또한 :attr:`handler_order` 어트리뷰트를 변경하여 처리기 "
"리스트에서 자신의 위치를 수정할 수 있습니다."

#: ../../library/urllib.request.rst:152
msgid ""
"Convert the given local path to a ``file:`` URL. This function uses "
":func:`~urllib.parse.quote` function to encode the path. For historical "
"reasons, the return value omits the ``file:`` scheme prefix. This example"
" shows the function being used on Windows::"
msgstr ""

#: ../../library/urllib.request.rst:157
#, python-format
msgid ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> 'file:' + pathname2url(path)\n"
"'file:///C:/Program%20Files'"
msgstr ""

#: ../../library/urllib.request.rst:165
msgid ""
"Convert the given ``file:`` URL to a local path. This function uses "
":func:`~urllib.parse.unquote` to decode the URL. For historical reasons, "
"the given value *must* omit the ``file:`` scheme prefix. This example "
"shows the function being used on Windows::"
msgstr ""

#: ../../library/urllib.request.rst:170
#, python-format
msgid ""
">>> from urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url.removeprefix('file:'))\n"
"'C:\\\\Program Files'"
msgstr ""

#: ../../library/urllib.request.rst:177
#, fuzzy
msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named "
"``<scheme>_proxy``, in a case insensitive approach, for all operating "
"systems first, and when it cannot find it, looks for proxy information "
"from System Configuration for macOS and Windows Systems Registry for "
"Windows. If both lowercase and uppercase environment variables exist (and"
" disagree), lowercase is preferred."
msgstr ""
"이 도우미 함수는 스킴에서 프락시 서버 URL로 매핑하는 딕셔너리를 반환합니다. 먼저 모든 운영 체제에서 대소 문자를 구분하지 않는"
" 방식으로 ``<scheme>_proxy``\\라는 변수를 환경에서 스캔하고, 찾을 수 없으면 맥 OS X의 맥 OSX 시스템 "
"구성과 윈도우의 윈도우 시스템 레지스트리에서 프락시 정보를 찾습니다. 소문자와 대문자 환경 변수가 모두 존재하면 (그리고 다른 값을"
" 가지면), 소문자가 선호됩니다."

#: ../../library/urllib.request.rst:187
msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" "
"HTTP header. If you need to use an HTTP proxy in a CGI environment, "
"either use ``ProxyHandler`` explicitly, or make sure the variable name is"
" in lowercase (or at least the ``_proxy`` suffix)."
msgstr ""
"일반적으로 스크립트가 CGI 환경에서 실행 중임을 나타내는 환경 변수 ``REQUEST_METHOD``\\가 설정되면, 환경 변수 "
"``HTTP_PROXY``\\(대문자 ``_PROXY``)는 무시됩니다. 이 변수는 \"Proxy:\" HTTP 헤더를 사용하여 "
"클라이언트가 주입할 수 있기 때문입니다. CGI 환경에서 HTTP 프락시를 사용해야 하면, ``ProxyHandler``\\를 "
"명시적으로 사용하거나 변수 이름이 소문자(또는 적어도 ``_proxy`` 접미사)가 되도록 하십시오."

#: ../../library/urllib.request.rst:196
msgid "The following classes are provided:"
msgstr "다음과 같은 클래스가 제공됩니다:"

#: ../../library/urllib.request.rst:200
msgid "This class is an abstraction of a URL request."
msgstr "이 클래스는 URL 요청의 추상화입니다."

#: ../../library/urllib.request.rst:202
#, fuzzy
msgid "*url* should be a string containing a valid, properly encoded URL."
msgstr "*url*\\은 유효한 URL을 포함하는 문자열이어야 합니다."

#: ../../library/urllib.request.rst:204
msgid ""
"*data* must be an object specifying additional data to send to the "
"server, or ``None`` if no such data is needed.  Currently HTTP requests "
"are the only ones that use *data*.  The supported object types include "
"bytes, file-like objects, and iterables of bytes-like objects. If no "
"``Content-Length`` nor ``Transfer-Encoding`` header field has been "
"provided, :class:`HTTPHandler` will set these headers according to the "
"type of *data*.  ``Content-Length`` will be used to send bytes objects, "
"while ``Transfer-Encoding: chunked`` as specified in :rfc:`7230`, Section"
" 3.3.1 will be used to send files and other iterables."
msgstr ""
"*data*\\는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 ``None``\\이어야 "
"합니다. 현재 HTTP 요청은 *data*\\를 사용하는 유일한 요청입니다. 지원되는 객체 형에는 바이트열, 파일류 객체 및 "
"바이트열류 객체의 이터러블이 포함됩니다. ``Content-Length``\\와 ``Transfer-Encoding`` 헤더 필드가"
" 모두 제공되지 않으면, :class:`HTTPHandler`\\는 *data*\\의 형에 따라 이러한 헤더를 설정합니다. "
"``Content-Length``\\는 바이트열 객체를 보내는 데 사용되는 반면, :rfc:`7230`, 섹션 3.3.1에 지정된 "
"``Transfer-Encoding: chunked``\\는 파일과 다른 이터러블을 보내는 데 사용됩니다."

#: ../../library/urllib.request.rst:214
msgid ""
"For an HTTP POST request method, *data* should be a buffer in the "
"standard :mimetype:`application/x-www-form-urlencoded` format.  The "
":func:`urllib.parse.urlencode` function takes a mapping or sequence of "
"2-tuples and returns an ASCII string in this format. It should be encoded"
" to bytes before being used as the *data* parameter."
msgstr ""
"HTTP POST 요청 메서드의 경우, *data*\\는 표준 :mimetype:`application/x-www-form-"
"urlencoded` 형식의 버퍼여야 합니다. :func:`urllib.parse.urlencode` 함수는 매핑이나 2-튜플의 "
"시퀀스를 취하고 이 형식의 ASCII 문자열을 반환합니다. *data* 매개 변수로 사용되기 전에 바이트열로 인코딩되어야 합니다."

#: ../../library/urllib.request.rst:220
#, fuzzy
msgid ""
"*headers* should be a dictionary, and will be treated as if "
":meth:`add_header` was called with each key and value as arguments. This "
"is often used to \"spoof\" the ``User-Agent`` header value, which is used"
" by a browser to identify itself -- some HTTP servers only allow requests"
" coming from common browsers as opposed to scripts. For example, Mozilla "
"Firefox may identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) "
"Gecko/20071127 Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user "
"agent string is ``\"Python-urllib/2.6\"`` (on Python 2.6). All header "
"keys are sent in camel case."
msgstr ""
"*headers*\\는 딕셔너리이어야 하며, 각 키와 값을 인자로 사용하여 :meth:`add_header`\\가 호출된 것처럼 "
"처리됩니다. 이것은 종종 브라우저가 자신을 식별하는 데 사용하는 ``User-Agent`` 헤더 값을 \"스푸핑\" 하는 데 "
"사용됩니다 -- 일부 HTTP 서버는 스크립트가 아닌 일반 브라우저에서 오는 요청만 허용합니다. 예를 들어, Mozilla "
"Firefox는 자신을 ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``\\로 식별하는 반면, :mod:`urllib`\\의 기본 사용자 에이전트 문자열은 "
"``\"Python-urllib/2.6\"`` (파이썬 2.6에서) 입니다."

#: ../../library/urllib.request.rst:231
#, fuzzy
msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is "
"not ``None``, ``Content-Type: application/x-www-form-urlencoded`` will be"
" added as a default."
msgstr ""
"*data* 인자가 있으면 적절한 ``Content-Type`` 헤더가 포함되어야 합니다. 이 헤더가 제공되지 않고 "
"*data*\\가 None이 아니면, ``Content-Type: application/x-www-form-"
"urlencoded``\\가 기본값으로 추가됩니다."

#: ../../library/urllib.request.rst:236
msgid ""
"The next two arguments are only of interest for correct handling of "
"third-party HTTP cookies:"
msgstr "다음 두 인자는 제삼자 HTTP 쿠키를 올바르게 처리하는 데에만 관심이 있습니다:"

#: ../../library/urllib.request.rst:239
msgid ""
"*origin_req_host* should be the request-host of the origin transaction, "
"as defined by :rfc:`2965`.  It defaults to "
"``http.cookiejar.request_host(self)``.  This is the host name or IP "
"address of the original request that was initiated by the user. For "
"example, if the request is for an image in an HTML document, this should "
"be the request-host of the request for the page containing the image."
msgstr ""
"*origin_req_host*\\는 :rfc:`2965`\\에 의해 정의된 대로 오리진 트랜잭션의 요청 호스트여야 합니다. "
"기본값은 ``http.cookiejar.request_host(self)``\\입니다. 이것은 사용자가 시작한 원래 요청의 호스트 "
"이름이나 IP 주소입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이면, 이미지가 포함된 페이지에 대한 요청의 요청 "
"호스트여야 합니다."

#: ../../library/urllib.request.rst:247
msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable "
"request is one whose URL the user did not have the option to approve.  "
"For example, if the request is for an image in an HTML document, and the "
"user had no option to approve the automatic fetching of the image, this "
"should be true."
msgstr ""
"*unverifiable*\\은 :rfc:`2965`\\에서 정의한 대로 요청을 확인할 수 없는지를 표시해야 합니다. 기본값은 "
"``False``\\입니다. 확인할 수 없는 요청은 사용자에게 URL에 대한 승인 옵션이 없는 요청입니다. 예를 들어, HTML "
"문서의 이미지에 대한 요청이고, 사용자에게 이미지의 자동 가져오기를 승인할 수 있는 옵션이 없으면, 이것은 참이어야 합니다."

#: ../../library/urllib.request.rst:254
#, fuzzy
msgid ""
"*method* should be a string that indicates the HTTP request method that "
"will be used (e.g. ``'HEAD'``).  If provided, its value is stored in the "
":attr:`~Request.method` attribute and is used by :meth:`get_method`. The "
"default is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. "
"Subclasses may indicate a different default method by setting the "
":attr:`~Request.method` attribute in the class itself."
msgstr ""
"*method*\\는 사용될 HTTP 요청 메서드를 나타내는 문자열이어야 합니다 (예를 들어 ``'HEAD'``). 제공되면, 해당"
" 값은 :attr:`~Request.method` 어트리뷰트에 저장되고 :meth:`get_method()`\\에서 사용됩니다. "
"기본값은 *data*\\가 ``None``\\이면 ``'GET'``\\이고, 그렇지 않으면 ``'POST'``\\입니다. 서브 "
"클래스는 클래스 자체에서 :attr:`~Request.method` 어트리뷰트를 설정하여 다른 기본 메서드를 나타낼 수 있습니다."

#: ../../library/urllib.request.rst:262
msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP "
"redirects or authentication.  The *data* is sent to the HTTP server right"
" away after the headers.  There is no support for a 100-continue "
"expectation in the library."
msgstr ""
"data 객체가 콘텐츠를 두 번 이상 (예를 들어 콘텐츠를 한 번만 생성 할 수 있는 파일이나 이터러블) 전달할 수 없고 요청이 "
"HTTP 리디렉션이나 인증을 위해 재시도되는 경우, 요청이 예상대로 작동하지 않습니다. *data*\\는 헤더 바로 다음에 HTTP"
" 서버로 전송됩니다. 라이브러리에서 100-continue 예상(expectation)을 지원하지 않습니다."

#: ../../library/urllib.request.rst:269
msgid ":attr:`Request.method` argument is added to the Request class."
msgstr ":attr:`Request.method` 인자가 Request 클래스에 추가됩니다."

#: ../../library/urllib.request.rst:272
msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr "클래스 수준에서 기본 :attr:`Request.method`\\를 지정할 수 있습니다."

#: ../../library/urllib.request.rst:275
msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and"
" *data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"``Content-Length``\\가 제공되지 않고 *data*\\가 ``None``\\이나 바이트열 객체가 아닐 때 에러를 "
"발생시키지 앖습니다. 대신 청크 전송 인코딩(chunked transfer encoding)으로 폴백 합니다."

#: ../../library/urllib.request.rst:282
msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s"
" chained together. It manages the chaining of handlers, and recovery from"
" errors."
msgstr ""
":class:`OpenerDirector` 클래스는 서로 연결된 :class:`BaseHandler`\\들을 통해 URL을 엽니다."
" 처리기 연결과 에러 복구를 관리합니다."

#: ../../library/urllib.request.rst:288
msgid ""
"This is the base class for all registered handlers --- and handles only "
"the simple mechanics of registration."
msgstr "이것은 등록된 모든 처리기의 베이스 클래스이며 --- 간단한 등록 메커니즘만 처리합니다."

#: ../../library/urllib.request.rst:294
msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr ""
"HTTP 에러 응답에 대한 기본 처리기를 정의하는 클래스; 모든 응답은 :exc:`~urllib.error.HTTPError` "
"예외로 바뀝니다."

#: ../../library/urllib.request.rst:300
msgid "A class to handle redirections."
msgstr "리디렉션을 처리하는 클래스."

#: ../../library/urllib.request.rst:305
msgid "A class to handle HTTP Cookies."
msgstr "HTTP 쿠키를 처리하는 클래스."

#: ../../library/urllib.request.rst:310
#, fuzzy
msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a"
" dictionary mapping protocol names to URLs of proxies. The default is to "
"read the list of proxies from the environment variables "
"``<protocol>_proxy``.  If no proxy environment variables are set, then in"
" a Windows environment proxy settings are obtained from the registry's "
"Internet Settings section, and in a macOS environment proxy information "
"is retrieved from the System Configuration Framework."
msgstr ""
"요청이 프락시를 거치게 합니다. *proxies*\\가 제공되면, 프로토콜 이름을 프락시 URL로 매핑하는 딕셔너리여야 합니다. "
"기본값은 환경 변수 ``<protocol>_proxy``\\에서 프락시 목록을 읽는 것입니다. 프락시 환경 변수가 설정되어 있지 "
"않으면, 윈도우 환경에서는 레지스트리의 인터넷 설정 섹션에서 프락시 설정을 가져오고, 맥 OS X 환경에서는 프락시 정보를 OS X"
" 시스템 구성 프레임워크에서 가져옵니다."

#: ../../library/urllib.request.rst:318
msgid "To disable autodetected proxy pass an empty dictionary."
msgstr "자동 감지 프락시를 비활성화하려면 빈 딕셔너리를 전달하십시오."

#: ../../library/urllib.request.rst:320
msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-"
"separated list of hostname suffixes, optionally with ``:port`` appended, "
"for example ``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
":envvar:`no_proxy` 환경 변수를 사용하여 프락시를 통해 도달해서는 안 되는 호스트를 지정할 수 있습니다; 설정되면, "
"쉼표로 구분된 호스트 이름 접미사의 목록이어야 하며, 선택적으로 ``:port``\\가 추가됩니다, 예를 들어 "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."

#: ../../library/urllib.request.rst:327
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; "
"see the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"변수 ``REQUEST_METHOD``\\가 설정되면 ``HTTP_PROXY``\\는 무시됩니다; "
":func:`~urllib.request.getproxies`\\의 설명서를 참조하십시오."

#: ../../library/urllib.request.rst:333
msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr "``(realm, uri) -> (user, password)`` 매핑 데이터베이스를 유지합니다."

#: ../../library/urllib.request.rst:338
msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A "
"realm of ``None`` is considered a catch-all realm, which is searched if "
"no other realm fits."
msgstr ""
"``(realm, uri) -> (user, password)`` 매핑 데이터베이스를 유지합니다. ``None`` realm은 포괄"
"(catch-all) 영역으로 간주하며 다른 영역에 맞지 않으면 검색됩니다."

#: ../../library/urllib.request.rst:345
msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
"``uri -> is_authenticated`` 매핑 데이터베이스도 포함하는 "
":class:`HTTPPasswordMgrWithDefaultRealm`\\의 변형. BasicAuth 처리기에서 ``401`` "
"응답을 먼저 기다리는 대신 인증 자격 증명을 언제 보낼 것인지 결정하는 데 사용할 수 있습니다."

#: ../../library/urllib.request.rst:355
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something"
" that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref"
":`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials "
"are not sent, and then if a ``401`` response is received the request is "
"re-sent with the authentication credentials.  If authentication succeeds,"
" ``update_authenticated`` is called to set ``is_authenticated`` ``True`` "
"for the URI, so that subsequent requests to the URI or any of its super-"
"URIs will automatically include the authentication credentials."
msgstr ""
"원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. *password_mgr*\\이 주어지면 "
":class:`HTTPPasswordMgr` 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 :ref"
":`http-password-mgr`\\를 참조하십시오. *passwd_mgr*\\이 ``is_authenticated``\\와 "
"``update_authenticated`` 메서드도 제공하면 (:ref:`http-password-mgr-with-prior-"
"auth`\\를 참조하십시오), 처리기는 지정된 URI에 대해 ``is_authenticated`` 결과를 사용하여 요청과 함께 "
"인증 자격 증명을 보낼지를 판별합니다. ``is_authenticated``\\가 URI에 대해 ``True``\\를 반환하면, "
"자격 증명이 전송됩니다. ``is_authenticated``\\가 ``False``\\이면, 자격 증명이 전송되지 않으며, 그런 "
"다음 ``401`` 응답이 수신되면 요청이 인증 자격 증명과 함께 다시 전송됩니다. 인증이 성공하면, 이 URI에 대해 "
"``is_authenticated``\\를 ``True``\\로 설정하기 위해 ``update_authenticated``\\가 "
"호출되어서, 이 URI나 모든 슈퍼 URI에 대한 후속 요청에 인증 자격 증명이 자동으로 포함됩니다."

#: ../../library/urllib.request.rst:372
msgid "Added ``is_authenticated`` support."
msgstr "``is_authenticated`` 지원이 추가되었습니다."

#: ../../library/urllib.request.rst:378
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, "
"should be something that is compatible with :class:`HTTPPasswordMgr`; "
"refer to section :ref:`http-password-mgr` for information on the "
"interface that must be supported. HTTPBasicAuthHandler will raise a "
":exc:`ValueError` when presented with a wrong Authentication scheme."
msgstr ""
"원격 호스트와의 인증을 처리합니다. *password_mgr*\\이 주어지면 :class:`HTTPPasswordMgr` 과 "
"호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 :ref:`http-password-mgr`\\를 "
"참조하십시오. 잘못된 인증 스킴(Authentication scheme)을 제시하면 HTTPBasicAuthHandler 가 "
":exc:`ValueError`\\를 발생시킵니다."

#: ../../library/urllib.request.rst:387 ../../library/urllib.request.rst:421
msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be"
" something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that "
"must be supported."
msgstr ""
"프락시와의 인증을 처리합니다. *password_mgr*\\이 주어지면 :class:`HTTPPasswordMgr` 과 호환되는 "
"것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 :ref:`http-password-mgr`\\를 참조하십시오."

#: ../../library/urllib.request.rst:395
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something"
" that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref"
":`http-password-mgr` for information on the interface that must be "
"supported."
msgstr ""
"원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. *password_mgr*\\이 주어지면 "
":class:`HTTPPasswordMgr` 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 :ref"
":`http-password-mgr`\\를 참조하십시오."

#: ../../library/urllib.request.rst:404
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, "
"should be something that is compatible with :class:`HTTPPasswordMgr`; "
"refer to section :ref:`http-password-mgr` for information on the "
"interface that must be supported. When both Digest Authentication Handler"
" and Basic Authentication Handler are both added, Digest Authentication "
"is always tried first. If the Digest Authentication returns a 40x "
"response again, it is sent to Basic Authentication handler to Handle.  "
"This Handler method will raise a :exc:`ValueError` when presented with an"
" authentication scheme other than Digest or Basic."
msgstr ""
"원격 호스트와의 인증을 처리합니다. *password_mgr*\\이 주어지면 :class:`HTTPPasswordMgr` 과 "
"호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 :ref:`http-password-mgr`\\를 "
"참조하십시오. 다이제스트 인증 처리기와 기본 인증 처리기가 모두 추가되면, 다이제스트 인증이 항상 먼저 시도됩니다. 다이제스트 "
"인증이 다시 40x 응답을 반환하면, 기본 인증 처리기로 보내 처리됩니다. 이 처리기 메서드는 Digest나 Basic 이외의 인증"
" 스킴(authentication scheme)이 제공될 때 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/urllib.request.rst:414
msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "지원되지 않는 인증 스킴에 대해 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/urllib.request.rst:429
msgid "A class to handle opening of HTTP URLs."
msgstr "HTTP URL 열기를 처리하는 클래스."

#: ../../library/urllib.request.rst:434
msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"HTTPS URL 열기를 처리하는 클래스. *context*\\와 *check_hostname*\\은 "
":class:`http.client.HTTPSConnection`\\과 같은 의미입니다."

#: ../../library/urllib.request.rst:437
msgid "*context* and *check_hostname* were added."
msgstr "*context*\\와 *check_hostname*\\이 추가되었습니다."

#: ../../library/urllib.request.rst:443
msgid "Open local files."
msgstr "로컬 파일을 엽니다."

#: ../../library/urllib.request.rst:447
msgid "Open data URLs."
msgstr "데이터 URL을 엽니다."

#: ../../library/urllib.request.rst:453
msgid "Open FTP URLs."
msgstr "FTP URL을 엽니다."

#: ../../library/urllib.request.rst:458
msgid "Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr "지연 시간을 최소화하기 위해 열린 FTP 연결의 캐시를 유지하면서, FTP URL을 엽니다."

#: ../../library/urllib.request.rst:463
msgid "A catch-all class to handle unknown URLs."
msgstr "알 수 없는 URL을 처리하기 위한 포괄적인(catch-all) 클래스."

#: ../../library/urllib.request.rst:468 ../../library/urllib.request.rst:1174
msgid "Process HTTP error responses."
msgstr "HTTP 에러 응답을 처리합니다."

#: ../../library/urllib.request.rst:474
msgid "Request Objects"
msgstr "Request 객체"

#: ../../library/urllib.request.rst:476
msgid ""
"The following methods describe :class:`Request`'s public interface, and "
"so all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"다음 메서드는 :class:`Request`\\의 공용 인터페이스를 설명하므로, 서브 클래스에서 모두 재정의될 수 있습니다. 또한 "
"클라이언트가 구문 분석된 요청을 검사하는 데 사용할 수 있는 몇 가지 공용 어트리뷰트를 정의합니다."

#: ../../library/urllib.request.rst:483
msgid "The original URL passed to the constructor."
msgstr "생성자에 전달된 원래 URL."

#: ../../library/urllib.request.rst:487
msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting"
" :attr:`~Request.full_url` returns the original request URL with the "
"fragment, if it was present."
msgstr ""
"Request.full_url은 setter, getter 및 deleter가 있는 프로퍼티입니다. "
":attr:`~Request.full_url`\\을 읽으면 프래그먼트가 있는 원래 요청 URL을 반환합니다 (있다면)."

#: ../../library/urllib.request.rst:493
msgid "The URI scheme."
msgstr "URI 스킴."

#: ../../library/urllib.request.rst:497
msgid ""
"The URI authority, typically a host, but may also contain a port "
"separated by a colon."
msgstr "URI 주체(authority), 일반적으로 호스트이지만 콜론으로 구분된 포트를 포함할 수도 있습니다."

#: ../../library/urllib.request.rst:502
msgid "The original host for the request, without port."
msgstr "포트가 없는, 요청의 원래 호스트."

#: ../../library/urllib.request.rst:506
msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will "
"be the full URL that is passed to the proxy."
msgstr "URI 경로. :class:`Request`\\가 프락시를 사용하면, selector는 프락시로 전달되는 전체 URL이 됩니다."

#: ../../library/urllib.request.rst:511
msgid "The entity body for the request, or ``None`` if not specified."
msgstr "요청의 엔티티 바디, 또는 지정되지 않으면 ``None``."

#: ../../library/urllib.request.rst:513
msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" "
"header if it was previously set or calculated."
msgstr ""
":attr:`Request.data`\\의 값을 변경하면 이제 \"Content-Length\" 헤더가 이전에 설정되거나 "
"계산되었다면 삭제됩니다."

#: ../../library/urllib.request.rst:519
msgid ""
"boolean, indicates whether the request is unverifiable as defined by "
":rfc:`2965`."
msgstr "불리언, :rfc:`2965`\\에서 정의한 대로 요청을 확인할 수 없는지를 나타냅니다."

#: ../../library/urllib.request.rst:524
msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal "
"computation of the method to be used.  Its value can be set (thus "
"overriding the default computation in :meth:`~Request.get_method`) either"
" by providing a default value by setting it at the class level in a "
":class:`Request` subclass, or by passing a value in to the "
":class:`Request` constructor via the *method* argument."
msgstr ""
"사용할 HTTP 요청 메서드. 기본적으로 값은 :const:`None`\\입니다. 이는 "
":meth:`~Request.get_method`\\가 사용될 메서드의 일반적인 계산을 수행함을 뜻합니다. "
":class:`Request` 서브 클래스의 클래스 수준에서 값을 설정해서 기본값을 제공하거나, *method* 인자를 통해 "
":class:`Request` 생성자에 값을 전달하여 값을 설정할 수 있습니다 (그래서 "
":meth:`~Request.get_method`\\의 기본 계산을 무시합니다)."

#: ../../library/urllib.request.rst:534
msgid ""
"A default value can now be set in subclasses; previously it could only be"
" set via the constructor argument."
msgstr "서브 클래스에서 이제 기본값을 설정할 수 있습니다; 이전에는 생성자 인자를 통해서만 설정할 수 있었습니다."

#: ../../library/urllib.request.rst:541
msgid ""
"Return a string indicating the HTTP request method.  If "
":attr:`Request.method` is not ``None``, return its value, otherwise "
"return ``'GET'`` if :attr:`Request.data` is ``None``, or ``'POST'`` if "
"it's not. This is only meaningful for HTTP requests."
msgstr ""
"HTTP 요청 메서드를 나타내는 문자열을 반환합니다. :attr:`Request.method`\\가 ``None``\\이 아니면, "
"그 값을 반환하고, 그렇지 않으면 :attr:`Request.data`\\가 ``None``\\이면 ``'GET'``\\을 "
"반환하거나 그렇지 않으면 ``'POST'``\\를 반환합니다. 이것은 HTTP 요청에만 의미가 있습니다."

#: ../../library/urllib.request.rst:546
msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "get_method는 이제 :attr:`Request.method`\\의 값을 조사합니다."

#: ../../library/urllib.request.rst:552
#, fuzzy
msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of "
"headers sent to the server.  Note that there cannot be more than one "
"header with the same name, and later calls will overwrite previous calls "
"in case the *key* collides. Currently, this is no loss of HTTP "
"functionality, since all headers which have meaning when used more than "
"once have a (header-specific) way of gaining the same functionality using"
" only one header.  Note that headers added using this method are also "
"added to redirected requests."
msgstr ""
"요청에 다른 헤더를 추가합니다. 헤더는 현재 HTTP 처리기를 제외한 모든 처리기에서 무시되며, HTTP 처리기에서는 서버로 "
"전송되는 헤더 리스트에 추가됩니다. 같은 이름을 가진 헤더를 두 개 이상 가질 수 없으며, *key*\\가 충돌하는 경우 후속 "
"호출은 이전 호출을 덮어씁니다. 현재, 두 번 이상 사용될 때 의미가 있는 모든 헤더는 하나의 헤더만 사용하여 같은 기능을 얻는 "
"(헤더 별) 방식을 가지므로 HTTP 기능의 손실은 없습니다."

#: ../../library/urllib.request.rst:564
msgid "Add a header that will not be added to a redirected request."
msgstr "리디렉션 된 요청에 추가되지 않을 헤더를 추가합니다."

#: ../../library/urllib.request.rst:569
msgid ""
"Return whether the instance has the named header (checks both regular and"
" unredirected)."
msgstr "인스턴스에 명명된 헤더가 있는지를 반환합니다 (일반과 리디렉션되지 않는 것을 모두 확인합니다)."

#: ../../library/urllib.request.rst:575
msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr "요청 인스턴스에서 명명된 헤더를 제거합니다 (일반과 리디렉션되지 않은 헤더 모두)."

#: ../../library/urllib.request.rst:583
msgid "Return the URL given in the constructor."
msgstr "생성자에 제공된 URL을 반환합니다."

#: ../../library/urllib.request.rst:587
msgid "Returns :attr:`Request.full_url`"
msgstr ":attr:`Request.full_url`\\을 반환합니다"

#: ../../library/urllib.request.rst:592
msgid ""
"Prepare the request by connecting to a proxy server. The *host* and "
"*type* will replace those of the instance, and the instance's selector "
"will be the original URL given in the constructor."
msgstr ""
"프락시 서버에 연결하여 요청을 준비합니다. *host*\\와 *type*\\은 인스턴스의 것을 대체하고, 인스턴스의 "
"selector는 생성자에 제공된 원래 URL이 됩니다."

#: ../../library/urllib.request.rst:599
msgid ""
"Return the value of the given header. If the header is not present, "
"return the default value."
msgstr "지정된 헤더의 값을 반환합니다. 헤더가 없으면, default 값을 반환합니다."

#: ../../library/urllib.request.rst:605
msgid ""
"Return a list of tuples (header_name, header_value) of the Request "
"headers."
msgstr "요청 헤더의 튜플 (header_name, header_value) 리스트를 반환합니다."

#: ../../library/urllib.request.rst:607
msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were "
"deprecated since 3.3 have been removed."
msgstr ""
"3.3부터 폐지된 add_data, has_data, get_data, get_type, get_host, get_selector,"
" get_origin_req_host 및 is_unverifiable 요청 메서드가 제거되었습니다."

#: ../../library/urllib.request.rst:616
msgid "OpenerDirector Objects"
msgstr "OpenerDirector 객체"

#: ../../library/urllib.request.rst:618
msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr ":class:`OpenerDirector` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/urllib.request.rst:623
msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* "
"should be replaced with the actual protocol to handle, for example "
":meth:`http_response` would be the HTTP protocol response handler.  Also "
"*type* should be replaced with the actual HTTP code, for example "
":meth:`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler*\\는 :class:`BaseHandler`\\의 인스턴스여야 합니다. 다음 메서드가 검색되어, 가능한 체인에 "
"추가됩니다 (HTTP 에러는 특별한 경우임에 유의하십시오). 다음에서 *protocol*\\은 처리할 실제 프로토콜로 바꿔야 "
"합니다, 예를 들어 :meth:`http_response`\\는 HTTP 프로토콜 응답 처리기입니다. 또한 *type*\\은 실제 "
"HTTP 코드로 대체해야 합니다, 예를 들어 :meth:`http_error_404`\\는 HTTP 404 에러를 처리합니다."

#: ../../library/urllib.request.rst:631
#, fuzzy
msgid ""
":meth:`!<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ":meth:`<protocol>_open` --- 처리기가 *protocol* URL을 여는 방법을 알고 있음을 알립니다."

#: ../../library/urllib.request.rst:634
msgid "See |protocol_open|_ for more information."
msgstr "자세한 정보는 |protocol_open|_\\을 참조하십시오."

#: ../../library/urllib.request.rst:636
#, fuzzy
msgid ""
":meth:`!http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""
":meth:`http_error_\\<type\\>` --- 처리기가 HTTP 에러 코드 *type*\\을 갖는 HTTP 에러를 "
"처리하는 방법을 알고 있음을 알립니다."

#: ../../library/urllib.request.rst:639
msgid "See |http_error_nnn|_ for more information."
msgstr "자세한 정보는 |http_error_nnn|_\\을 참조하십시오."

#: ../../library/urllib.request.rst:641
#, fuzzy
msgid ""
":meth:`!<protocol>_error` --- signal that the handler knows how to handle"
" errors from (non-\\ ``http``) *protocol*."
msgstr ""
":meth:`<protocol>_error` --- 처리기가 (``http``\\가 아닌) *protocol*\\의 에러를 처리하는"
" 방법을 알고 있음을 알립니다."

#: ../../library/urllib.request.rst:644
#, fuzzy
msgid ""
":meth:`!<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ""
":meth:`<protocol>_request` --- 처리기가 *protocol* 요청을 전처리(pre-process)하는 방법을"
" 알고 있음을 알립니다."

#: ../../library/urllib.request.rst:647
msgid "See |protocol_request|_ for more information."
msgstr "자세한 정보는 |protocol_request|_\\를 참조하십시오."

#: ../../library/urllib.request.rst:649
#, fuzzy
msgid ""
":meth:`!<protocol>_response` --- signal that the handler knows how to "
"post-process *protocol* responses."
msgstr ""
":meth:`<protocol>_response` --- 처리기가 *protocol* 응답을 후처리(post-process)하는 "
"방법을 알고 있음을 알립니다."

#: ../../library/urllib.request.rst:652
msgid "See |protocol_response|_ for more information."
msgstr "자세한 정보는 |protocol_response|_\\를 참조하십시오."

#: ../../library/urllib.request.rst:661
#, fuzzy
msgid ""
"Open the given *url* (which can be a request object or a string), "
"optionally passing the given *data*. Arguments, return values and "
"exceptions raised are the same as those of :func:`urlopen` (which simply "
"calls the :meth:`open` method on the currently installed global "
":class:`OpenerDirector`).  The optional *timeout* parameter specifies a "
"timeout in seconds for blocking operations like the connection attempt "
"(if not specified, the global default timeout setting will be used). The "
"timeout feature actually works only for HTTP, HTTPS and FTP connections."
msgstr ""
"주어진 *url*\\(요청 객체나 문자열일 수 있습니다)을 열고, 선택적으로 주어진 *data*\\를 전달합니다. 인자, 반환 값 "
"및 발생하는 예외는 :func:`urlopen`\\과 같습니다 (단순히 현재 설치된 전역 "
":class:`OpenerDirector`\\의 :meth:`open` 메서드를 호출합니다). 선택적 *timeout* 매개 변수는"
" 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간제한 설정이 "
"사용됩니다). 시간제한 기능은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다."

#: ../../library/urllib.request.rst:673
#, fuzzy
msgid ""
"Handle an error of the given protocol.  This will call the registered "
"error handlers for the given protocol with the given arguments (which are"
" protocol specific).  The HTTP protocol is a special case which uses the "
"HTTP response code to determine the specific error handler; refer to the "
":meth:`!http_error_\\<type\\>` methods of the handler classes."
msgstr ""
"주어진 프로토콜의 에러를 처리합니다. 이것은 주어진 프로토콜에 대해 등록된 에러 처리기를 주어진 인자(프로토콜 특정입니다)로 "
"호출합니다. HTTP 프로토콜은 HTTP 응답 코드를 사용하여 특정 에러 처리기를 결정하는 특수한 경우입니다; 처리기 클래스의 "
":meth:`http_error_\\<type\\>` 메서드를 참조하십시오."

#: ../../library/urllib.request.rst:679
msgid ""
"Return values and exceptions raised are the same as those of "
":func:`urlopen`."
msgstr "반환 값과 발생하는 예외는 :func:`urlopen`\\과 같습니다."

#: ../../library/urllib.request.rst:681
msgid "OpenerDirector objects open URLs in three stages:"
msgstr "OpenerDirector 객체는 다음 3단계로 URL을 엽니다:"

#: ../../library/urllib.request.rst:683
msgid ""
"The order in which these methods are called within each stage is "
"determined by sorting the handler instances."
msgstr "각 단계에서 이러한 메서드가 호출되는 순서는 처리기 인스턴스를 정렬하여 결정됩니다."

#: ../../library/urllib.request.rst:686
#, fuzzy
msgid ""
"Every handler with a method named like :meth:`!<protocol>_request` has "
"that method called to pre-process the request."
msgstr ""
":meth:`<protocol>_request`\\와 같은 이름의 메서드를 가진 모든 처리기가 요청을 전처리하기 위해 해당 메서드가"
" 호출됩니다."

#: ../../library/urllib.request.rst:689
#, fuzzy
msgid ""
"Handlers with a method named like :meth:`!<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a "
"non-\\ :const:`None` value (ie. a response), or raises an exception "
"(usually :exc:`~urllib.error.URLError`).  Exceptions are allowed to "
"propagate."
msgstr ""
":meth:`<protocol>_open`\\과 같은 이름의 메서드를 가진 처리기가 요청을 처리하기 위해 호출됩니다. 이 단계는 "
"처리기가 :const:`None`\\이 아닌 값(즉, 응답)을 반환하거나, 예외(보통 "
":exc:`~urllib.error.URLError`)를 발생시킬 때 종료됩니다. 예외 전파가 허용됩니다."

#: ../../library/urllib.request.rst:694
#, fuzzy
msgid ""
"In fact, the above algorithm is first tried for methods named "
":meth:`~BaseHandler.default_open`.  If all such methods return "
":const:`None`, the algorithm is repeated for methods named like "
":meth:`!<protocol>_open`.  If all such methods return :const:`None`, the "
"algorithm is repeated for methods named "
":meth:`~BaseHandler.unknown_open`."
msgstr ""
"사실, 위의 알고리즘은 :meth:`default_open`\\이라는 메서드를 먼저 시도됩니다. 이러한 모든 메서드가 "
":const:`None`\\을 반환하면, 알고리즘은 :meth:`<protocol>_open`\\과 같은 이름의 메서드에 대해 "
"반복합니다. 이러한 모든 메서드가 :const:`None`\\을 반환하면, 알고리즘은 :meth:`unknown_open`\\이라는"
" 메서드에 대해 반복합니다."

#: ../../library/urllib.request.rst:700
msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` "
"and :meth:`~OpenerDirector.error` methods."
msgstr ""
"이러한 메서드의 구현은 부모 :class:`OpenerDirector` 인스턴스의 "
":meth:`~OpenerDirector.open`\\과 :meth:`~OpenerDirector.error` 메서드의 호출을 "
"수반할 수 있음에 유의하십시오."

#: ../../library/urllib.request.rst:704
#, fuzzy
msgid ""
"Every handler with a method named like :meth:`!<protocol>_response` has "
"that method called to post-process the response."
msgstr ""
":meth:`<protocol>_response`\\와 같은 이름의 메서드가 있는 모든 처리기는 응답을 후처리하기 위해 해당 "
"메서드가 호출됩니다."

#: ../../library/urllib.request.rst:711
msgid "BaseHandler Objects"
msgstr "BaseHandler 객체"

#: ../../library/urllib.request.rst:713
msgid ""
":class:`BaseHandler` objects provide a couple of methods that are "
"directly useful, and others that are meant to be used by derived classes."
"  These are intended for direct use:"
msgstr ""
":class:`BaseHandler` 객체는 직접적으로 유용한 몇 가지 메서드와 파생 클래스에서 사용하기 위한 다른 메서드를 "
"제공합니다. 다음은 직접 사용하기 위한 것입니다:"

#: ../../library/urllib.request.rst:720
msgid "Add a director as parent."
msgstr "director를 부모로 추가합니다."

#: ../../library/urllib.request.rst:725
msgid "Remove any parents."
msgstr "모든 부모를 제거합니다."

#: ../../library/urllib.request.rst:727
msgid ""
"The following attribute and methods should only be used by classes "
"derived from :class:`BaseHandler`."
msgstr "다음 어트리뷰트와 메서드는 :class:`BaseHandler`\\에서 파생된 클래스에서만 사용해야 합니다."

#: ../../library/urllib.request.rst:732
#, fuzzy
msgid ""
"The convention has been adopted that subclasses defining "
":meth:`!<protocol>_request` or :meth:`!<protocol>_response` methods are "
"named :class:`!\\*Processor`; all others are named :class:`!\\*Handler`."
msgstr ""
":meth:`<protocol>_request`\\나 :meth:`<protocol>_response` 메서드를 정의하는 서브 "
"클래스는 :class:`\\*Processor`\\라고 이름 붙이는 규칙이 채택되었습니다; 다른 모든 것들의 이름은 "
":class:`\\*Handler`\\입니다."

#: ../../library/urllib.request.rst:739
msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a "
"different protocol, or handle errors."
msgstr "다른 프로토콜을 사용하여 열거나 에러를 처리하는 데 사용할 수 있는 유효한 :class:`OpenerDirector`."

#: ../../library/urllib.request.rst:745
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses "
"should define it if they want to catch all URLs."
msgstr ""
"이 메서드는 :class:`BaseHandler`\\에 정의되지 *않았지만*, 서브 클래스가 모든 URL을 포착하려면 이를 정의해야"
" 합니다."

#: ../../library/urllib.request.rst:748
#, fuzzy
msgid ""
"This method, if implemented, will be called by the parent "
":class:`OpenerDirector`.  It should return a file-like object as "
"described in the return value of the :meth:`~OpenerDirector.open` method "
"of :class:`OpenerDirector`, or ``None``. It should raise "
":exc:`~urllib.error.URLError`, unless a truly exceptional thing happens "
"(for example, :exc:`MemoryError` should not be mapped to "
":exc:`~urllib.error.URLError`)."
msgstr ""
"구현되면 이 메서드는 부모 :class:`OpenerDirector`\\에 의해 호출됩니다. "
":class:`OpenerDirector`\\의 :meth:`open`\\의 반환 값에 설명된 대로 파일류 객체를 반환하거나 "
"``None``\\을 반환해야 합니다. 진짜 예외적인 상황이 발생하지 않는 한  (예를 들어, "
":exc:`MemoryError`\\는 :exc:`URLError`\\로 매핑하지 않아야 합니다), "
":exc:`~urllib.error.URLError`\\를 발생해야 합니다."

#: ../../library/urllib.request.rst:755
msgid "This method will be called before any protocol-specific open method."
msgstr "이 메서드는 프로토콜별 open 메서드보다 먼저 호출됩니다."

#: ../../library/urllib.request.rst:762
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses "
"should define it if they want to handle URLs with the given protocol."
msgstr ""
"이 메서드는 :class:`BaseHandler` 에 정의되지 *않았지만*, 서브 클래스가 주어진 프로토콜로 URL을 처리하려면 "
"이를 정의해야 합니다."

#: ../../library/urllib.request.rst:765
#, fuzzy
msgid ""
"This method, if defined, will be called by the parent "
":class:`OpenerDirector`. Return values should be the same as for  "
":meth:`~BaseHandler.default_open`."
msgstr ""
"정의되면, 이 메서드는 부모 :class:`OpenerDirector`\\에 의해 호출됩니다. 반환 값은 "
":meth:`default_open`\\과 같아야 합니다."

#: ../../library/urllib.request.rst:771
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses "
"should define it if they want to catch all URLs with no specific "
"registered handler to open it."
msgstr ""
"이 메서드는 :class:`BaseHandler` 에 정의되지 *않았지만*, 서브 클래스는 등록된 특정 처리기가 없는 모든 URL을"
" 잡아서 열려면 이를 정의해야 합니다."

#: ../../library/urllib.request.rst:775
msgid ""
"This method, if implemented, will be called by the :attr:`parent` "
":class:`OpenerDirector`.  Return values should be the same as for "
":meth:`default_open`."
msgstr ""
"구현되면, 이 메서드는 :attr:`parent` :class:`OpenerDirector`\\에 의해 호출됩니다. 반환 값은 "
":meth:`default_open`\\과 같아야 합니다."

#: ../../library/urllib.request.rst:782
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses "
"should override it if they intend to provide a catch-all for otherwise "
"unhandled HTTP errors.  It will be called automatically by the  "
":class:`OpenerDirector` getting the error, and should not normally be "
"called in other circumstances."
msgstr ""
"이 메서드는 :class:`BaseHandler` 에 정의되지 *않았지만*, 서브 클래스는 달리 처리되지 않은 HTTP 에러에 대해"
" 포괄적인 처리를 제공하려면 이를 재정의해야 합니다. 에러가 발생하는 :class:`OpenerDirector`\\에 의해 자동으로"
" 호출되며, 다른 상황에서는 일반적으로 호출되지 않아야 합니다."

#: ../../library/urllib.request.rst:787
msgid ""
"*req* will be a :class:`Request` object, *fp* will be a file-like object "
"with the HTTP error body, *code* will be the three-digit code of the "
"error, *msg* will be the user-visible explanation of the code and *hdrs* "
"will be a mapping object with the headers of the error."
msgstr ""
"*req*\\는 :class:`Request` 객체, *fp*\\는 HTTP 에러 바디가 있는 파일류 객체, *code*\\는 "
"에러의 3자리 코드, *msg*\\는 사용자가 볼 수 있는 코드 설명, *hdrs*\\는 에러의 헤더가 있는 매핑 객체가 됩니다."

#: ../../library/urllib.request.rst:792
msgid ""
"Return values and exceptions raised should be the same as those of "
":func:`urlopen`."
msgstr "반환 값과 발생하는 예외는 :func:`urlopen`\\의 것과 같아야 합니다."

#: ../../library/urllib.request.rst:799
msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn*\\은 3자리 HTTP 에러 코드여야 합니다. 이 메서드도 :class:`BaseHandler` 에 정의되어 있지 않지만,"
" 존재한다면 코드가 *nnn* 인 HTTP 에러가 발생할 때 서브 클래스의 인스턴스에 대해 호출됩니다."

#: ../../library/urllib.request.rst:803
msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr "특정 HTTP 에러를 처리하려면 서브 클래스가 이 메서드를 재정의해야 합니다."

#: ../../library/urllib.request.rst:805
#, fuzzy
msgid ""
"Arguments, return values and exceptions raised should be the same as for "
":meth:`~BaseHandler.http_error_default`."
msgstr "인자, 반환 값 및 발생하는 예외는 :meth:`http_error_default`\\와 같아야 합니다."

#: ../../library/urllib.request.rst:813
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses "
"should define it if they want to pre-process requests of the given "
"protocol."
msgstr ""
"이 메서드는 :class:`BaseHandler` 에 정의되지 *않았지만*, 서브 클래스는 주어진 프로토콜의 요청을 전처리하려면 "
"이를 정의해야 합니다."

#: ../../library/urllib.request.rst:816
msgid ""
"This method, if defined, will be called by the parent "
":class:`OpenerDirector`. *req* will be a :class:`Request` object. The "
"return value should be a :class:`Request` object."
msgstr ""
"정의되면, 이 메서드는 부모 상위 :class:`OpenerDirector`\\에 의해 호출됩니다. *req*\\는 "
":class:`Request` 객체가 됩니다. 반환 값은 :class:`Request` 객체여야 합니다."

#: ../../library/urllib.request.rst:825
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses "
"should define it if they want to post-process responses of the given "
"protocol."
msgstr ""
"이 메서드는 :class:`BaseHandler` 에 정의되지 *않았지만*, 서브 클래스는 주어진 프로토콜의 응답을 후처리하려면 "
"이를 정의해야 합니다."

#: ../../library/urllib.request.rst:828
msgid ""
"This method, if defined, will be called by the parent "
":class:`OpenerDirector`. *req* will be a :class:`Request` object. "
"*response* will be an object implementing the same interface as the "
"return value of :func:`urlopen`.  The return value should implement the "
"same interface as the return value of :func:`urlopen`."
msgstr ""
"정의되면, 이 메서드는 부모 :class:`OpenerDirector`\\에 의해 호출됩니다. *req*\\는 "
":class:`Request` 객체가 됩니다. *response*\\는 :func:`urlopen`\\의 반환 값과 같은 "
"인터페이스를 구현하는 객체가 됩니다. 반환 값은 :func:`urlopen`\\의 반환 값과 같은 인터페이스를 구현해야 합니다."

#: ../../library/urllib.request.rst:838
msgid "HTTPRedirectHandler Objects"
msgstr "HTTPRedirectHandler 객체"

#: ../../library/urllib.request.rst:842
msgid ""
"Some HTTP redirections require action from this module's client code.  If"
" this is the case, :exc:`~urllib.error.HTTPError` is raised.  See "
":rfc:`2616` for details of the precise meanings of the various "
"redirection codes."
msgstr ""
"일부 HTTP 리디렉션은 이 모듈의 클라이언트 코드로부터의 액션을 요구합니다. 이 경우, "
":exc:`~urllib.error.HTTPError`\\가 발생합니다. 다양한 리디렉션 코드의 정확한 의미에 대한 자세한 내용은 "
":rfc:`2616`\\을 참조하십시오."

#: ../../library/urllib.request.rst:846
#, fuzzy
msgid ""
"An :exc:`~urllib.error.HTTPError` exception raised as a security "
"consideration if the HTTPRedirectHandler is presented with a redirected "
"URL which is not an HTTP, HTTPS or FTP URL."
msgstr ""
"HTTPRedirectHandler 에 HTTP, HTTPS 또는 FTP URL이 아닌 리디렉션 된 URL이 제공되면 보안을 "
"고려하여 :class:`HTTPError` 예외가 발생했습니다."

#: ../../library/urllib.request.rst:853
#, fuzzy
msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`!http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection"
" should take place, return a new :class:`Request` to allow "
":meth:`!http_error_30\\*` to perform the redirect to *newurl*.  "
"Otherwise, raise :exc:`~urllib.error.HTTPError` if no other handler "
"should try to handle this URL, or return ``None`` if you can't but "
"another handler might."
msgstr ""
"리디렉션에 대한 응답으로 :class:`Request`\\나 ``None``\\을 반환합니다. 이것은 서버로부터 리디렉션이 수신될 "
"때 :meth:`http_error_30\\*` 메서드의 기본 구현에 의해 호출됩니다. 리디렉션이 일어나야 하면, "
":meth:`http_error_30\\*`\\이 *newurl*\\로 리디렉션을 수행할 수 있도록 새 "
":class:`Request`\\를 반환합니다. 그렇지 않으면 다른 처리기가 이 URL을 처리하려고 시도하지 않아야 한다면 "
":exc:`~urllib.error.HTTPError`\\를 발생시키고, 자신은 할 수 없지만 다른 처리기가 처리할 수 있다면 "
"``None``\\을 반환합니다."

#: ../../library/urllib.request.rst:863
msgid ""
"The default implementation of this method does not strictly follow "
":rfc:`2616`, which says that 301 and 302 responses to ``POST`` requests "
"must not be automatically redirected without confirmation by the user.  "
"In reality, browsers do allow automatic redirection of these responses, "
"changing the POST to a ``GET``, and the default implementation reproduces"
" this behavior."
msgstr ""
"이 메서드의 기본 구현은 :rfc:`2616`\\을 엄격하게 따르지 않습니다. 즉, ``POST`` 요청에 대한 301과 302 "
"응답은 사용자의 확인 없이 자동으로 리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 ``GET``\\으로 변경하여 "
"이러한 응답의 자동 리디렉션을 허용하며, 기본 구현은 이 동작을 재현합니다."

#: ../../library/urllib.request.rst:872
msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by "
"the parent :class:`OpenerDirector` when getting an HTTP 'moved "
"permanently' response."
msgstr ""
"``Location:``\\이나 ``URI:`` URL로 리디렉션 합니다. 이 메서드는 HTTP 'moved "
"permanently(영구적으로 이전했음)' 응답을 받을 때 부모 :class:`OpenerDirector`\\에 의해 호출됩니다."

#: ../../library/urllib.request.rst:878
msgid "The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr ":meth:`http_error_301`\\과 같지만, 'found(발견됨)' 응답에 대해 호출됩니다."

#: ../../library/urllib.request.rst:883
msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' "
"response."
msgstr ":meth:`http_error_301`\\과 같지만, 'see other(다른 곳을 보세요)' 응답에 대해 호출됩니다."

#: ../../library/urllib.request.rst:888
#, fuzzy
msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary "
"redirect' response. It does not allow changing the request method from "
"``POST`` to ``GET``."
msgstr ":meth:`http_error_301`\\과 같지만, 'temporary redirect(임시 리디렉션)' 응답에 대해 호출됩니다."

#: ../../library/urllib.request.rst:895
#, fuzzy
msgid ""
"The same as :meth:`http_error_301`, but called for the 'permanent "
"redirect' response. It does not allow changing the request method from "
"``POST`` to ``GET``."
msgstr ":meth:`http_error_301`\\과 같지만, 'temporary redirect(임시 리디렉션)' 응답에 대해 호출됩니다."

#: ../../library/urllib.request.rst:905
msgid "HTTPCookieProcessor Objects"
msgstr "HTTPCookieProcessor 객체"

#: ../../library/urllib.request.rst:907
msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr ":class:`HTTPCookieProcessor` 인스턴스에는 하나의 어트리뷰트가 있습니다:"

#: ../../library/urllib.request.rst:911
msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr "쿠키가 저장되는 :class:`http.cookiejar.CookieJar`."

#: ../../library/urllib.request.rst:917
msgid "ProxyHandler Objects"
msgstr "ProxyHandler 객체"

#: ../../library/urllib.request.rst:923
#, fuzzy
msgid ""
"The :class:`ProxyHandler` will have a method :meth:`!<protocol>_open` for"
" every *protocol* which has a proxy in the *proxies* dictionary given in "
"the constructor.  The method will modify requests to go through the "
"proxy, by calling ``request.set_proxy()``, and call the next handler in "
"the chain to actually execute the protocol."
msgstr ""
":class:`ProxyHandler`\\에는 생성자에 지정된 *proxies* 딕셔너리에 프락시가 있는 모든 "
"*protocol*\\에 대해 :meth:`<protocol>_open` 메서드가 있습니다. 이 메서드는 "
"``request.set_proxy()``\\를 호출하여 요청이 프락시를 통과하도록 수정하고, 체인에 있는 다음 처리기를 호출하여 "
"실제로 프로토콜을 실행합니다."

#: ../../library/urllib.request.rst:933
msgid "HTTPPasswordMgr Objects"
msgstr "HTTPPasswordMgr 객체"

#: ../../library/urllib.request.rst:935
msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and "
":class:`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"이 메서드는 :class:`HTTPPasswordMgr` 과 "
":class:`HTTPPasswordMgrWithDefaultRealm` 객체에서 사용 가능합니다."

#: ../../library/urllib.request.rst:941
msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* "
"and *passwd* must be strings. This causes ``(user, passwd)`` to be used "
"as authentication tokens when authentication for *realm* and a super-URI "
"of any of the given URIs is given."
msgstr ""
"*uri*\\는 단일 URI이거나 URI의 시퀀스일 수 있습니다. *realm*, *user* 및 *passwd*\\는 문자열이어야"
" 합니다. 이는 *realm*\\과 지정된 URI 중 어느 하나의 슈퍼 URI에 대한 인증이 주어질 때 ``(user, "
"passwd)``\\가 인증 토큰으로 사용되도록 합니다."

#: ../../library/urllib.request.rst:949
msgid ""
"Get user/password for given realm and URI, if any.  This method will "
"return ``(None, None)`` if there is no matching user/password."
msgstr ""
"주어진 realm과 URI에 대한 사용자/암호를 (있다면) 가져옵니다. 일치하는 사용자/암호가 없으면 이 메서드는 ``(None, "
"None)``\\을 반환합니다."

#: ../../library/urllib.request.rst:952
msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
":class:`HTTPPasswordMgrWithDefaultRealm` 객체의 경우, 주어진 *realm*\\에 일치하는 "
"사용자/암호가 없으면 영역 ``None``\\이 검색됩니다."

#: ../../library/urllib.request.rst:959
msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "HTTPPasswordMgrWithPriorAuth 객체"

#: ../../library/urllib.request.rst:961
msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to"
" support tracking URIs for which authentication credentials should always"
" be sent."
msgstr ""
"이 암호 관리자는 :class:`HTTPPasswordMgrWithDefaultRealm`\\를 확장하여 인증 자격 증명을 항상 "
"보내야 하는 URI를 추적하는 것을 지원합니다."

#: ../../library/urllib.request.rst:968
msgid ""
"*realm*, *uri*, *user*, *passwd* are as for "
":meth:`HTTPPasswordMgr.add_password`.  *is_authenticated* sets the "
"initial value of the ``is_authenticated`` flag for the given URI or list "
"of URIs. If *is_authenticated* is specified as ``True``, *realm* is "
"ignored."
msgstr ""
"*realm*, *uri*, *user*, *passwd*\\는 "
":meth:`HTTPPasswordMgr.add_password`\\와 같습니다. *is_authenticated*\\는 주어진 "
"URI나 URI 리스트에 대한 ``is_authenticated`` 플래그의 초깃값을 설정합니다. "
"*is_authenticated*\\가 ``True``\\로 지정되면, *realm*\\는 무시됩니다."

#: ../../library/urllib.request.rst:976
msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr ":class:`HTTPPasswordMgrWithDefaultRealm` 객체와 같습니다"

#: ../../library/urllib.request.rst:982
msgid "Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr "주어진 *uri*\\나 URI 리스트에 대해 ``is_authenticated`` 플래그를 갱신합니다."

#: ../../library/urllib.request.rst:988
msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given "
"URI."
msgstr "주어진 URI에 대한 ``is_authenticated`` 플래그의 현재 상태를 반환합니다."

#: ../../library/urllib.request.rst:995
msgid "AbstractBasicAuthHandler Objects"
msgstr "AbstractBasicAuthHandler 객체"

#: ../../library/urllib.request.rst:1000
msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the"
" information about the realm is included in the request, *host* specifies"
" the URL and path to authenticate for, *req* should be the (failed) "
":class:`Request` object, and *headers* should be the error headers."
msgstr ""
"사용자/암호 쌍을 가져오고 요청을 다시 시도하여 인증 요청을 처리합니다. *authreq*\\는 영역(realm)에 대한 정보가 "
"요청에 포함된 헤더의 이름이어야 하고, *host*\\는 인증할 URL과 경로를 지정하고, *req*\\는 (실패한) "
":class:`Request` 객체여야 하며, *headers*\\는 에러 헤더여야 합니다."

#: ../../library/urllib.request.rst:1006
msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL "
"containing an authority component (e.g. ``\"http://python.org/\"``). In "
"either case, the authority must not contain a userinfo component (so, "
"``\"python.org\"`` and ``\"python.org:80\"`` are fine, "
"``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host*\\는 주체(예를 들어 ``\"python.org\"``)거나 주체 구성 요소를 포함하는 URL(예를 들어 "
"``\"http://python.org/\"``)입니다. 어느 경우이든, 주체는 userinfo 구성 요소를 포함하지 않아야 합니다"
" (따라서, ``\"python.org\"``\\와 ``\"python.org:80\"``\\은 좋지만, "
"``\"joe:password@python.org\"``\\는 유효하지 않습니다)."

#: ../../library/urllib.request.rst:1015
msgid "HTTPBasicAuthHandler Objects"
msgstr "HTTPBasicAuthHandler 객체"

#: ../../library/urllib.request.rst:1020 ../../library/urllib.request.rst:1031
#: ../../library/urllib.request.rst:1056 ../../library/urllib.request.rst:1067
msgid "Retry the request with authentication information, if available."
msgstr "가능하다면 인증 정보로 요청을 재시도합니다."

#: ../../library/urllib.request.rst:1026
msgid "ProxyBasicAuthHandler Objects"
msgstr "ProxyBasicAuthHandler 객체"

#: ../../library/urllib.request.rst:1037
msgid "AbstractDigestAuthHandler Objects"
msgstr "AbstractDigestAuthHandler 객체"

#: ../../library/urllib.request.rst:1042
msgid ""
"*authreq* should be the name of the header where the information about "
"the realm is included in the request, *host* should be the host to "
"authenticate to, *req* should be the (failed) :class:`Request` object, "
"and *headers* should be the error headers."
msgstr ""
"*authreq*\\는 영역(realm)에 대한 정보가 요청에 포함된 헤더의 이름이어야 하고, *host*\\는 인증할 호스트여야 "
"하고, *req*\\는 (실패한) :class:`Request` 객체여야 하며, *headers*\\는 에러 헤더여야 합니다."

#: ../../library/urllib.request.rst:1051
msgid "HTTPDigestAuthHandler Objects"
msgstr "HTTPDigestAuthHandler 객체"

#: ../../library/urllib.request.rst:1062
msgid "ProxyDigestAuthHandler Objects"
msgstr "ProxyDigestAuthHandler 객체"

#: ../../library/urllib.request.rst:1073
msgid "HTTPHandler Objects"
msgstr "HTTPHandler 객체"

#: ../../library/urllib.request.rst:1078
msgid ""
"Send an HTTP request, which can be either GET or POST, depending on "
"``req.has_data()``."
msgstr "HTTP 요청을 보냅니다. ``req.has_data()``\\에 따라, GET이나 POST일 수 있습니다."

#: ../../library/urllib.request.rst:1085
msgid "HTTPSHandler Objects"
msgstr "HTTPSHandler 객체"

#: ../../library/urllib.request.rst:1090
msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on "
"``req.has_data()``."
msgstr "HTTPS 요청을 보냅니다. ``req.has_data()``\\에 따라, GET이나 POST일 수 있습니다."

#: ../../library/urllib.request.rst:1097
msgid "FileHandler Objects"
msgstr "FileHandler 객체"

#: ../../library/urllib.request.rst:1102
msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr "호스트 이름이 없거나, 호스트 이름이 ``'localhost'``\\인 경우 파일을 로컬에서 엽니다."

#: ../../library/urllib.request.rst:1105
#, fuzzy
msgid ""
"This method is applicable only for local hostnames.  When a remote "
"hostname is given, a :exc:`~urllib.error.URLError` is raised."
msgstr ""
"이 메서드는 로컬 호스트 명에만 적용할 수 있습니다. 원격 호스트 이름이 제공되면, "
":exc:`~urllib.error.URLError`\\가 발생합니다."

#: ../../library/urllib.request.rst:1113
msgid "DataHandler Objects"
msgstr "DataHandler 객체"

#: ../../library/urllib.request.rst:1117
#, fuzzy
msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL"
" itself. The data URL syntax is specified in :rfc:`2397`. This "
"implementation ignores white spaces in base64 encoded data URLs so the "
"URL may be wrapped in whatever source file it comes from. But even though"
" some browsers don't mind about a missing padding at the end of a base64 "
"encoded data URL, this implementation will raise a :exc:`ValueError` in "
"that case."
msgstr ""
"데이터 URL을 읽습니다. 이러한 종류의 URL에는 URL 자체에 인코딩된 콘텐츠가 포함됩니다. 데이터 URL 문법은 "
":rfc:`2397`\\에 지정되어 있습니다. 이 구현은 base64로 인코딩된 데이터 URL의 공백을 무시하기 때문에 URL은 "
"소스 파일과 관계없이 줄 넘김 될 수 있습니다. 그러나 일부 브라우저가 base64로 인코딩된 데이터 URL 끝에 패딩이 누락된 "
"것에 대해 신경 쓰지 않지만, 이 구현은 이 경우 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/urllib.request.rst:1128
msgid "FTPHandler Objects"
msgstr "FTPHandler 객체"

#: ../../library/urllib.request.rst:1133
msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty"
" username and password."
msgstr "*req*\\로 표시된 FTP 파일을 엽니다. 로그인은 항상 빈 사용자 이름과 암호로 수행됩니다."

#: ../../library/urllib.request.rst:1140
msgid "CacheFTPHandler Objects"
msgstr "CacheFTPHandler 객체"

#: ../../library/urllib.request.rst:1142
msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the"
" following additional methods:"
msgstr ":class:`CacheFTPHandler` 객체는 다음과 같은 추가 메서드가 있는 :class:`FTPHandler` 객체입니다:"

#: ../../library/urllib.request.rst:1148
msgid "Set timeout of connections to *t* seconds."
msgstr "연결 시간제한을 *t* 초로 설정합니다."

#: ../../library/urllib.request.rst:1153
msgid "Set maximum number of cached connections to *m*."
msgstr "캐시 된 최대 연결 수를 *m*\\으로 설정합니다."

#: ../../library/urllib.request.rst:1159
msgid "UnknownHandler Objects"
msgstr "UnknownHandler 객체"

#: ../../library/urllib.request.rst:1164
msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr ":exc:`~urllib.error.URLError` 예외를 발생시킵니다."

#: ../../library/urllib.request.rst:1170
msgid "HTTPErrorProcessor Objects"
msgstr "HTTPErrorProcessor 객체"

#: ../../library/urllib.request.rst:1176
msgid "For 200 error codes, the response object is returned immediately."
msgstr "200 에러 코드의 경우, 응답 객체가 즉시 반환됩니다."

#: ../../library/urllib.request.rst:1178
#, fuzzy
msgid ""
"For non-200 error codes, this simply passes the job on to the "
":meth:`!http_error_\\<type\\>` handler methods, via "
":meth:`OpenerDirector.error`. Eventually, "
":class:`HTTPDefaultErrorHandler` will raise an "
":exc:`~urllib.error.HTTPError` if no other handler handles the error."
msgstr ""
"200이 아닌 에러 코드의 경우, :meth:`OpenerDirector.error`\\를 통해 단순히 작업을 "
":meth:`http_error_\\<type\\>` 처리기 메서드로 전달합니다. 결국, 다른 처리기가 에러를 처리하지 않으면 "
":class:`HTTPDefaultErrorHandler`\\는 :exc:`~urllib.error.HTTPError`\\를 "
"발생시킵니다."

#: ../../library/urllib.request.rst:1186
msgid "Process HTTPS error responses."
msgstr "HTTPS 에러 응답을 처리합니다."

#: ../../library/urllib.request.rst:1188
msgid "The behavior is same as :meth:`http_response`."
msgstr "동작은 :meth:`http_response`\\와 같습니다."

#: ../../library/urllib.request.rst:1194
msgid "Examples"
msgstr "예"

#: ../../library/urllib.request.rst:1196
msgid ""
"In addition to the examples below, more examples are given in :ref"
":`urllib-howto`."
msgstr "아래 예 외에도 :ref:`urllib-howto`\\에는 더 많은 예가 나와 있습니다."

#: ../../library/urllib.request.rst:1199
#, fuzzy
msgid ""
"This example gets the python.org main page and displays the first 300 "
"bytes of it::"
msgstr "이 예제는 python.org 메인 페이지를 가져와서 첫 300바이트를 표시합니다. ::"

#: ../../library/urllib.request.rst:1202
msgid ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 "
"lt-ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js"
" ie7 lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html "
"class=\"no-js ie8 lt-ie9\">"
msgstr ""

#: ../../library/urllib.request.rst:1208
msgid ""
"Note that urlopen returns a bytes object.  This is because there is no "
"way for urlopen to automatically determine the encoding of the byte "
"stream it receives from the HTTP server. In general, a program will "
"decode the returned bytes object to string once it determines or guesses "
"the appropriate encoding."
msgstr ""
"urlopen은 바이트열 객체를 반환함에 유의하십시오. 이는 urlopen이 HTTP 서버로부터 수신한 바이트 스트림의 인코딩을 "
"자동으로 결정할 방법이 없기 때문입니다. 일반적으로, 프로그램은 일단 적절한 인코딩을 결정하거나 추측하면 반환된 바이트열 객체를 "
"문자열로 디코딩합니다."

#: ../../library/urllib.request.rst:1214
#, fuzzy
msgid ""
"The following HTML spec document, https://html.spec.whatwg.org/#charset, "
"lists the various ways in which an HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"다음 W3C 문서 https://www.w3.org/International/O-charset\\ 는 (X)HTML이나 XML "
"문서가 인코딩 정보를 지정할 수 있는 다양한 방법을 나열합니다."

#: ../../library/urllib.request.rst:1218
msgid ""
"For additional information, see the W3C document: "
"https://www.w3.org/International/questions/qa-html-encoding-declarations."
msgstr ""

#: ../../library/urllib.request.rst:1220
#, fuzzy
msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object::"
msgstr ""
"python.org 웹 사이트는 메타 태그에 지정된 대로 *utf-8* 인코딩을 사용하므로, 바이트열 객체를 디코딩할 때도 이를 "
"사용합니다. ::"

#: ../../library/urllib.request.rst:1223
msgid ""
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   "
"<![endif]-->\n"
"<!-"
msgstr ""

#: ../../library/urllib.request.rst:1230
#, fuzzy
msgid ""
"It is also possible to achieve the same result without using the "
":term:`context manager` approach::"
msgstr ":term:`컨텍스트 관리자 <context manager>` 방식을 사용하지 않고도 같은 결과를 얻을 수 있습니다. ::"

#: ../../library/urllib.request.rst:1233
msgid ""
">>> import urllib.request\n"
">>> f = urllib.request.urlopen('http://www.python.org/')\n"
">>> try:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"... finally:\n"
"...     f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   "
"<![endif]-->\n"
"<!--"
msgstr ""

#: ../../library/urllib.request.rst:1244
msgid ""
"In the following example, we are sending a data-stream to the stdin of a "
"CGI and reading the data it returns to us. Note that this example will "
"only work when the Python installation supports SSL. ::"
msgstr ""
"다음 예에서는, CGI의 표준 입력으로 데이터 스트림을 전송하고 반환되는 데이터를 읽습니다. 이 예제는 파이썬 설치가 SSL을 "
"지원할 때만 작동함에 유의하십시오. ::"

#: ../../library/urllib.request.rst:1248
msgid ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-"
"bin/test.cgi',\n"
"...                       data=b'This data is passed to stdin of the "
"CGI')\n"
">>> with urllib.request.urlopen(req) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"...\n"
"Got Data: \"This data is passed to stdin of the CGI\""
msgstr ""

#: ../../library/urllib.request.rst:1256
msgid "The code for the sample CGI used in the above example is::"
msgstr "위 예제에서 사용한 샘플 CGI의 코드는 다음과 같습니다::"

#: ../../library/urllib.request.rst:1258
#, python-format
msgid ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"
msgstr ""

#: ../../library/urllib.request.rst:1263
msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr "다음은 :class:`Request`\\를 사용하여 ``PUT`` 요청을 수행하는 예입니다::"

#: ../../library/urllib.request.rst:1265
msgid ""
"import urllib.request\n"
"DATA = b'some data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, "
"method='PUT')\n"
"with urllib.request.urlopen(req) as f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"
msgstr ""

#: ../../library/urllib.request.rst:1273
msgid "Use of Basic HTTP Authentication::"
msgstr "기본 HTTP 인증 사용::"

#: ../../library/urllib.request.rst:1275
msgid ""
"import urllib.request\n"
"# Create an OpenerDirector with support for Basic HTTP Authentication...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...and install it globally so it can be used with urlopen.\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""

#: ../../library/urllib.request.rst:1288
#, fuzzy
msgid ""
":func:`build_opener` provides many handlers by default, including a "
":class:`ProxyHandler`.  By default, :class:`ProxyHandler` uses the "
"environment variables named ``<scheme>_proxy``, where ``<scheme>`` is the"
" URL scheme involved.  For example, the :envvar:`!http_proxy` environment"
" variable is read to obtain the HTTP proxy's URL."
msgstr ""
":func:`build_opener`\\는 기본적으로 :class:`ProxyHandler`\\를 포함하여 많은 처리기를 "
"제공합니다. 기본적으로, :class:`ProxyHandler`\\는 ``<scheme>_proxy``\\라는 이름의 환경 변수를 "
"사용합니다, 여기서 ``<scheme>``\\은 관련된 URL 스킴입니다. 예를 들어, HTTP 프락시의 URL을 얻기 위해 "
":envvar:`http_proxy` 환경 변수를 읽습니다."

#: ../../library/urllib.request.rst:1294
#, fuzzy
msgid ""
"This example replaces the default :class:`ProxyHandler` with one that "
"uses programmatically supplied proxy URLs, and adds proxy authorization "
"support with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""
"이 예는 기본 :class:`ProxyHandler`\\를 프로그래밍 방식으로 제공되는 프락시 URL을 사용하는 것으로 대체하고, "
":class:`ProxyBasicAuthHandler`\\로 프락시 인증 지원을 추가합니다. ::"

#: ../../library/urllib.request.rst:1298
#, python-brace-format
msgid ""
"proxy_handler = urllib.request.ProxyHandler({'http': "
"'http://www.example.com:3128/'})\n"
"proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\n"
"proxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n"
"\n"
"opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n"
"# This time, rather than install the OpenerDirector, we use it directly:\n"
"with opener.open('http://www.example.com/login.html') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""

#: ../../library/urllib.request.rst:1307
msgid "Adding HTTP headers:"
msgstr "HTTP 헤더 추가하기:"

#: ../../library/urllib.request.rst:1309
msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr ":class:`Request` 생성자에 *headers* 인자를 사용하십시오, 또는::"

#: ../../library/urllib.request.rst:1311
msgid ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# Customize the default User-Agent header value:\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')\n"
"with urllib.request.urlopen(req) as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""

#: ../../library/urllib.request.rst:1320
msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` "
"header to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector`\\는 모든 :class:`Request`\\에 :mailheader:`User-"
"Agent` 헤더를 자동으로 추가합니다. 이것을 바꾸려면::"

#: ../../library/urllib.request.rst:1323
msgid ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"with opener.open('http://www.example.com/') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""

#: ../../library/urllib.request.rst:1329
msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`,"
" :mailheader:`Content-Type` and :mailheader:`Host`) are added when the "
":class:`Request` is passed to :func:`urlopen` (or "
":meth:`OpenerDirector.open`)."
msgstr ""
"또한, :class:`Request`\\가 :func:`urlopen`\\(또는 "
":meth:`OpenerDirector.open`)으로 전달될 때 몇 가지 표준 헤더(:mailheader:`Content-"
"Length`, :mailheader:`Content-Type` 및 :mailheader:`Host`)가 추가됨을 기억하십시오."

#: ../../library/urllib.request.rst:1336
msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL"
" containing parameters::"
msgstr "다음은 ``GET`` 메서드를 사용하여 파라미터가 포함된 URL을 가져오는 예제 세션입니다::"

#: ../../library/urllib.request.rst:1339
#, python-brace-format, python-format
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""

#: ../../library/urllib.request.rst:1347
msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as"
" data::"
msgstr ""
"다음 예제는 대신 ``POST`` 메서드를 사용합니다. urlencode의 파라미터 출력이 데이터로 urlopen에 보내기 전에 "
"바이트열로 인코딩됨에 유의하십시오::"

#: ../../library/urllib.request.rst:1350
#, python-brace-format
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as"
" f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""

#: ../../library/urllib.request.rst:1358
msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding"
" environment settings::"
msgstr "다음 예제는 명시적으로 지정된 HTTP 프락시를 사용하여 환경 설정을 대체합니다::"

#: ../../library/urllib.request.rst:1361
#, python-brace-format
msgid ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.FancyURLopener(proxies)\n"
">>> with opener.open(\"http://www.python.org\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""

#: ../../library/urllib.request.rst:1368
msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr "다음 예제는 프락시를 전혀 사용하지 않도록 환경 설정을 대체합니다::"

#: ../../library/urllib.request.rst:1370
#, python-brace-format
msgid ""
">>> import urllib.request\n"
">>> opener = urllib.request.FancyURLopener({})\n"
">>> with opener.open(\"http://www.python.org/\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""

#: ../../library/urllib.request.rst:1378
msgid "Legacy interface"
msgstr "레거시 인터페이스"

#: ../../library/urllib.request.rst:1380
msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr ""
"다음 함수와 클래스는 파이썬 2 모듈 ``urllib``\\(``urllib2``\\가 아니라)에서 이식됩니다. 나중에 언젠가 "
"폐지될 수 있습니다."

#: ../../library/urllib.request.rst:1386
#, fuzzy
msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points"
" to a local file, the object will not be copied unless filename is "
"supplied. Return a tuple ``(filename, headers)`` where *filename* is the "
"local file name under which the object can be found, and *headers* is "
"whatever the :meth:`!info` method of the object returned by "
":func:`urlopen` returned (for a remote object). Exceptions are the same "
"as for :func:`urlopen`."
msgstr ""
"URL로 표시된 네트워크 객체를 로컬 파일로 복사합니다. URL이 로컬 파일을 가리키면, 파일 이름을 제공하지 않는 한 객체가 "
"복사되지 않습니다. 튜플 ``(filename, headers)``\\를 반환합니다. 여기서 *filename*\\은 객체를 찾을 "
"수 있는 로컬 파일 이름이며, *headers*\\는 (원격 객체에 대해) :func:`urlopen`\\이 반환한 객체의 "
":meth:`info` 메서드가 반환한 것입니다. 예외는 :func:`urlopen`\\과 같습니다."

#: ../../library/urllib.request.rst:1393
msgid ""
"The second argument, if present, specifies the file location to copy to "
"(if absent, the location will be a tempfile with a generated name). The "
"third argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of "
"blocks transferred so far, a block size in bytes, and the total size of "
"the file.  The third argument may be ``-1`` on older FTP servers which do"
" not return a file size in response to a retrieval request."
msgstr ""
"있다면, 두 번째 인자는 복사할 파일 위치를 지정합니다 (없으면, 위치는 생성된 이름을 가진 임시 파일이 됩니다). 있다면, 세 "
"번째 인자는 네트워크 연결이 이루어질 때 한 번 호출되고 그 이후에 각 블록을 읽을 때마다 한 번씩 호출되는 콜러블입니다. "
"콜러블에는 세 개의 인자가 전달됩니다; 지금까지 전송된 블록 수, 바이트 단위의 블록 크기 및 파일의 전체 크기. 세 번째 인자는 "
"가져오기 요청에 대한 응답으로 파일 크기를 반환하지 않는 구형 FTP 서버에서 ``-1``\\일 수 있습니다."

#: ../../library/urllib.request.rst:1402
msgid "The following example illustrates the most common usage scenario::"
msgstr "다음 예는 가장 일반적인 사용 시나리오를 보여줍니다::"

#: ../../library/urllib.request.rst:1404
msgid ""
">>> import urllib.request\n"
">>> local_filename, headers = "
"urllib.request.urlretrieve('http://python.org/')\n"
">>> html = open(local_filename)\n"
">>> html.close()"
msgstr ""

#: ../../library/urllib.request.rst:1409
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional "
"*data* argument may be given to specify a ``POST`` request (normally the "
"request type is ``GET``).  The *data* argument must be a bytes object in "
"standard :mimetype:`application/x-www-form-urlencoded` format; see the "
":func:`urllib.parse.urlencode` function."
msgstr ""
"*url*\\이 :file:`http:` 스킴 식별자를 사용하면, ``POST`` 요청을 지정하기 위해 선택적 *data* 인자가 "
"제공될 수 있습니다 (일반적으로 요청형은 ``GET``\\입니다). *data* 인자는 표준 "
":mimetype:`application/x-www-form-urlencoded` 형식의 바이트열 객체여야 합니다; "
":func:`urllib.parse.urlencode` 함수를 참조하십시오."

#: ../../library/urllib.request.rst:1415
#, fuzzy
msgid ""
":func:`urlretrieve` will raise :exc:`~urllib.error.ContentTooShortError` "
"when it detects that the amount of data available  was less than the "
"expected amount (which is the size reported by a  *Content-Length* "
"header). This can occur, for example, when the  download is interrupted."
msgstr ""
":func:`urlretrieve`\\는 사용 가능한 데이터양이 예상 양(*Content-Length* 헤더에 의해 보고된 "
"크기)보다 작은 것을 감지하면 :exc:`ContentTooShortError`\\를 발생시킵니다. 예를 들어, 다운로드가 중단된 "
"경우에 발생할 수 있습니다."

#: ../../library/urllib.request.rst:1420
msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  "
"to read, urlretrieve reads more data, but if less data is available,  it "
"raises the exception."
msgstr ""
"*Content-Length*\\는 하한값으로 취급됩니다: 읽을 데이터가 더 있으면, urlretrieve는 더 많은 데이터를 "
"읽지만, 사용 가능한 데이터가 부족하면 예외가 발생합니다."

#: ../../library/urllib.request.rst:1424
#, fuzzy
msgid ""
"You can still retrieve the downloaded data in this case, it is stored in "
"the :attr:`!content` attribute of the exception instance."
msgstr "이 경우에도 다운로드된 데이터를 여전히 가져올 수 있으며, 예외 인스턴스의 :attr:`content` 어트리뷰트에 저장됩니다."

#: ../../library/urllib.request.rst:1427
msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the"
" size of the data it has downloaded, and just returns it.  In this case "
"you just have to assume that the download was successful."
msgstr ""
"*Content-Length* 헤더가 제공되지 않으면, urlretrieve는 다운로드 한 데이터의 크기를 확인할 수 없고, 그냥 "
"반환합니다. 이 경우 다운로드가 성공했다고 가정해야 합니다."

#: ../../library/urllib.request.rst:1433
msgid ""
"Cleans up temporary files that may have been left behind by previous "
"calls to :func:`urlretrieve`."
msgstr ":func:`urlretrieve`\\에 대한 이전 호출로 남겨졌을 수 있는 임시 파일을 정리합니다."

#: ../../library/urllib.request.rst:1440
msgid ""
"Base class for opening and reading URLs.  Unless you need to support "
"opening objects using schemes other than :file:`http:`, :file:`ftp:`, or "
":file:`file:`, you probably want to use :class:`FancyURLopener`."
msgstr ""
"URL을 열고 읽는 베이스 클래스. :file:`http:`, :file:`ftp:` 또는 :file:`file:` 이외의 스킴을 "
"사용하여 객체 열기를 지원할 필요가 있지 않은 한, 아마도 :class:`FancyURLopener`\\를 사용하고 싶을 것입니다."

#: ../../library/urllib.request.rst:1444
msgid ""
"By default, the :class:`URLopener` class sends a :mailheader:`User-Agent`"
" header of ``urllib/VVV``, where *VVV* is the :mod:`urllib` version "
"number. Applications can define their own :mailheader:`User-Agent` header"
" by subclassing :class:`URLopener` or :class:`FancyURLopener` and setting"
" the class attribute :attr:`version` to an appropriate string value in "
"the subclass definition."
msgstr ""
"기본적으로, :class:`URLopener` 클래스는 :mailheader:`User-Agent` 헤더로 "
"``urllib/VVV``\\를 전송합니다. 여기서 *VVV*\\는 :mod:`urllib` 버전 번호입니다. 응용 프로그램은 "
":class:`URLopener`\\나 :class:`FancyURLopener`\\를 서브 클래싱하고 클래스 어트리뷰트 "
":attr:`version`\\을 서브 클래스 정의에서 적절한 문자열 값으로 설정하여 자체 :mailheader:`User-"
"Agent` 헤더를 정의할 수 있습니다."

#: ../../library/urllib.request.rst:1450
msgid ""
"The optional *proxies* parameter should be a dictionary mapping scheme "
"names to proxy URLs, where an empty dictionary turns proxies off "
"completely.  Its default value is ``None``, in which case environmental "
"proxy settings will be used if present, as discussed in the definition of"
" :func:`urlopen`, above."
msgstr ""
"선택적 *proxies* 매개 변수는 스킴 이름을 프락시 URL로 매핑하는 딕셔너리여야 합니다. 여기서 빈 딕셔너리는 프락시를 "
"완전히 끕니다. 기본값은 ``None``\\이며, 이 경우 위의 :func:`urlopen` 정의에서 설명한 대로 환경 프락시 "
"설정이 있으면 사용됩니다."

#: ../../library/urllib.request.rst:1455
msgid ""
"Additional keyword parameters, collected in *x509*, may be used for "
"authentication of the client when using the :file:`https:` scheme.  The "
"keywords *key_file* and *cert_file* are supported to provide an  SSL key "
"and certificate; both are needed to support client authentication."
msgstr ""
"*x509*\\로 수집된 추가 키워드 매개 변수는 :file:`https:` 스킴을 사용할 때 클라이언트의 인증에 사용될 수 "
"있습니다. 키워드 *key_file*\\과 *cert_file*\\은 SSL 키와 인증서를 제공하기 위해 지원됩니다; 클라이언트 "
"인증을 지원하려면 둘 다 필요합니다."

#: ../../library/urllib.request.rst:1460
msgid ""
":class:`URLopener` objects will raise an :exc:`OSError` exception if the "
"server returns an error code."
msgstr "서버가 에러 코드를 반환하면 :class:`URLopener` 객체는 :exc:`OSError` 예외를 발생시킵니다."

#: ../../library/urllib.request.rst:1465
msgid ""
"Open *fullurl* using the appropriate protocol.  This method sets up cache"
" and proxy information, then calls the appropriate open method with its "
"input arguments.  If the scheme is not recognized, :meth:`open_unknown` "
"is called. The *data* argument has the same meaning as the *data* "
"argument of :func:`urlopen`."
msgstr ""
"적절한 프로토콜을 사용하여 *fullurl*\\을 엽니다. 이 메서드는 캐시와 프락시 정보를 설정한 다음, 입력 인자로 적절한 "
"open 메서드를 호출합니다. 스킴이 인식되지 않으면, :meth:`open_unknown`\\이 호출됩니다. *data* 인자는 "
":func:`urlopen`\\의 *data* 인자와 같은 의미입니다."

#: ../../library/urllib.request.rst:1471
msgid "This method always quotes *fullurl* using :func:`~urllib.parse.quote`."
msgstr "이 메서드는 항상 :func:`~urllib.parse.quote`\\를 사용하여 *fullurl*\\을 인용합니다."

#: ../../library/urllib.request.rst:1475
msgid "Overridable interface to open unknown URL types."
msgstr "알 수 없는 URL 유형을 여는 재정의 가능한 인터페이스."

#: ../../library/urllib.request.rst:1480
msgid ""
"Retrieves the contents of *url* and places it in *filename*.  The return "
"value is a tuple consisting of a local filename and either an "
":class:`email.message.Message` object containing the response headers "
"(for remote URLs) or ``None`` (for local URLs).  The caller must then "
"open and read the contents of *filename*.  If *filename* is not given and"
" the URL refers to a local file, the input filename is returned.  If the "
"URL is non-local and *filename* is not given, the filename is the output "
"of :func:`tempfile.mktemp` with a suffix that matches the suffix of the "
"last path component of the input URL.  If *reporthook* is given, it must "
"be a function accepting three numeric parameters: A chunk number, the "
"maximum size chunks are read in and the total size of the download (-1 if"
" unknown).  It will be called once at the start and after each chunk of "
"data is read from the network.  *reporthook* is ignored for local URLs."
msgstr ""
"*url*\\의 내용을 가져와서 *filename*\\에 배치합니다. 반환 값은 로컬 파일명과 응답 헤더를 포함하는 "
":class:`email.message.Message` 객체 (원격 URL의 경우) 또는 ``None``\\(로컬 URL의 "
"경우)으로 구성된 튜플입니다. 그러면 호출자는 *filename*\\의 내용을 열고 읽어야 합니다. *filename*\\이 "
"제공되지 않고 URL이 로컬 파일을 참조하면, 입력 파일명이 반환됩니다. URL이 로컬이 아니고 *filename*\\이 제공되지 "
"않으면, 파일 이름은 입력 URL의 마지막 경로 구성 요소의 접미사와 일치하는 접미사로 :func:`tempfile.mktemp` "
"한 출력입니다. *reporthook*\\이 제공되면, 세 개의 숫자 매개 변수를 받아들이는 함수여야 합니다: 청크 번호, 청크를 "
"읽을 최대 크기 및 다운로드의 전체 크기 (알 수 없으면 -1). 처음에 한 번 호출되고 네트워크에서 각 데이터 청크를 읽은 후에 "
"한 번씩 호출됩니다. 로컬 URL의 경우 *reporthook*\\은 무시됩니다."

#: ../../library/urllib.request.rst:1493
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional "
"*data* argument may be given to specify a ``POST`` request (normally the "
"request type is ``GET``).  The *data* argument must in standard "
":mimetype:`application/x-www-form-urlencoded` format; see the "
":func:`urllib.parse.urlencode` function."
msgstr ""
"*url*\\이 :file:`http:` 스킴 식별자를 사용하면, ``POST`` 요청을 지정하기 위해 선택적 *data* 인자가 "
"제공될 수 있습니다 (일반적으로 요청형은 ``GET``\\입니다). *data* 인자는 표준 "
":mimetype:`application/x-www-form-urlencoded` 형식이어야 합니다; "
":func:`urllib.parse.urlencode` 함수를 참조하십시오."

#: ../../library/urllib.request.rst:1502
msgid ""
"Variable that specifies the user agent of the opener object.  To get "
":mod:`urllib` to tell servers that it is a particular user agent, set "
"this in a subclass as a class variable or in the constructor before "
"calling the base constructor."
msgstr ""
"오프너 객체의 사용자 에이전트를 지정하는 변수. :mod:`urllib`\\가 서버에 특정 사용자 에이전트임을 알리려면, 서브 "
"클래스에서 클래스 변수로 설정하거나 생성자에서 베이스 생성자를 호출하기 전에 이를 설정하십시오."

#: ../../library/urllib.request.rst:1512
msgid ""
":class:`FancyURLopener` subclasses :class:`URLopener` providing default "
"handling for the following HTTP response codes: 301, 302, 303, 307 and "
"401.  For the 30x response codes listed above, the :mailheader:`Location`"
" header is used to fetch the actual URL.  For 401 response codes "
"(authentication required), basic HTTP authentication is performed.  For "
"the 30x response codes, recursion is bounded by the value of the "
"*maxtries* attribute, which defaults to 10."
msgstr ""
":class:`FancyURLopener`\\는 다음 HTTP 응답 코드에 대한 기본 처리를 제공하는 "
":class:`URLopener` 서브 클래스입니다: 301, 302, 303, 307 및 401. 위에 나열된 30x 응답 코드의"
" 경우, 실제 URL을 가져오는 데 :mailheader:`Location` 헤더가 사용됩니다. 401 응답 "
"코드(authentication required - 인증 필요)의 경우, 기본 HTTP 인증이 수행됩니다. 30x 응답 코드의 "
"경우, 재귀는 *maxtries* 어트리뷰트 값에 의해 제한되며, 기본값은 10입니다."

#: ../../library/urllib.request.rst:1519
#, fuzzy
msgid ""
"For all other response codes, the method "
":meth:`~BaseHandler.http_error_default` is called which you can override "
"in subclasses to handle the error appropriately."
msgstr ""
"다른 모든 응답 코드의 경우, 에러를 적절하게 처리하기 위해 서브 클래스에서 재정의할 수 있는 메서드 "
":meth:`http_error_default`\\가 호출됩니다."

#: ../../library/urllib.request.rst:1524
msgid ""
"According to the letter of :rfc:`2616`, 301 and 302 responses to POST "
"requests must not be automatically redirected without confirmation by the"
" user.  In reality, browsers do allow automatic redirection of these "
"responses, changing the POST to a GET, and :mod:`urllib` reproduces this "
"behaviour."
msgstr ""
":rfc:`2616`\\의 편지(letter)에 따르면, POST 요청에 대한 301과 302 응답은 사용자의 확인 없이 자동으로 "
"리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 GET으로 변경하여 이러한 응답의 자동 리디렉션을 허용하고, "
":mod:`urllib`\\는 이 동작을 재현합니다."

#: ../../library/urllib.request.rst:1529
msgid ""
"The parameters to the constructor are the same as those for "
":class:`URLopener`."
msgstr "생성자의 매개 변수는 :class:`URLopener`\\의 매개 변수와 같습니다."

#: ../../library/urllib.request.rst:1533
msgid ""
"When performing basic authentication, a :class:`FancyURLopener` instance "
"calls its :meth:`prompt_user_passwd` method.  The default implementation "
"asks the users for the required information on the controlling terminal."
"  A subclass may override this method to support more appropriate "
"behavior if needed."
msgstr ""
"기본 인증을 수행할 때, :class:`FancyURLopener` 인스턴스는 :meth:`prompt_user_passwd` "
"메서드를 호출합니다. 기본 구현은 사용자에게 제어 터미널에서 필요한 정보를 요청합니다. 필요하면 서브 클래스가 이 메서드를 "
"재정의하여 더 적절한 동작을 지원할 수 있습니다."

#: ../../library/urllib.request.rst:1538
msgid ""
"The :class:`FancyURLopener` class offers one additional method that "
"should be overloaded to provide the appropriate behavior:"
msgstr ":class:`FancyURLopener` 클래스는 적절한 동작을 제공하기 위해 재정의되어야 하는 하나의 추가 메서드를 제공합니다:"

#: ../../library/urllib.request.rst:1543
msgid ""
"Return information needed to authenticate the user at the given host in "
"the specified security realm.  The return value should be a tuple, "
"``(user, password)``, which can be used for basic authentication."
msgstr ""
"지정된 보안 영역(realm)의 지정된 호스트에서 사용자를 인증하는 데 필요한 정보를 반환합니다. 반환 값은 기본 인증에 사용될 수"
" 있는 튜플 ``(user, password)``\\여야 합니다."

#: ../../library/urllib.request.rst:1547
msgid ""
"The implementation prompts for this information on the terminal; an "
"application should override this method to use an appropriate interaction"
" model in the local environment."
msgstr ""
"구현은 터미널에서 이 정보를 요구합니다; 로컬 환경에서 적절한 상호 작용 모델을 사용하려면 응용 프로그램이 이 메서드를 재정의해야 "
"합니다."

#: ../../library/urllib.request.rst:1553
msgid ":mod:`urllib.request` Restrictions"
msgstr ":mod:`urllib.request` 제약 사항"

#: ../../library/urllib.request.rst:1559
msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9"
" and 1.0), FTP, local files, and data URLs."
msgstr "현재, 다음과 같은 프로토콜만 지원됩니다: HTTP (버전 0.9와 1.0), FTP, 로컬 파일 및 데이터 URL."

#: ../../library/urllib.request.rst:1562
msgid "Added support for data URLs."
msgstr "데이터 URL에 대한 지원이 추가되었습니다."

#: ../../library/urllib.request.rst:1564
msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until "
"someone finds the time to hack proper processing of Expiration time "
"headers."
msgstr ""
":func:`urlretrieve`\\의 캐싱 기능은 누군가가 만료 시간 헤더의 적절한 처리를 해킹할 시간을 찾을 때까지 "
"비활성화되었습니다."

#: ../../library/urllib.request.rst:1567
msgid ""
"There should be a function to query whether a particular URL is in the "
"cache."
msgstr "특정 URL이 캐시에 있는지를 조회하는 함수가 있어야 합니다."

#: ../../library/urllib.request.rst:1569
msgid ""
"For backward compatibility, if a URL appears to point to a local file but"
" the file can't be opened, the URL is re-interpreted using the FTP "
"protocol.  This can sometimes cause confusing error messages."
msgstr ""
"이전 버전과의 호환성을 위해, URL이 로컬 파일을 가리키는 것으로 보이지만 파일을 열 수 없으면, FTP 프로토콜을 사용하여 "
"URL을 다시 해석합니다. 이로 인해 때때로 혼란스러운 에러 메시지가 발생할 수 있습니다."

#: ../../library/urllib.request.rst:1573
#, fuzzy
msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause "
"arbitrarily long delays while waiting for a network connection to be set "
"up.  This means that it is difficult to build an interactive web client "
"using these functions without using threads."
msgstr ""
":func:`urlopen`\\과 :func:`urlretrieve` 함수는 네트워크 연결이 이루어지기를 기다리는 동안 임의의 긴 "
"지연을 유발할 수 있습니다. 이는 스레드를 사용하지 않고 이러한 함수를 사용하여 대화식 웹 클라이언트를 구축하기 어렵다는 것을 "
"뜻합니다."

#: ../../library/urllib.request.rst:1582
msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw "
"data returned by the server.  This may be binary data (such as an image),"
" plain text or (for example) HTML.  The HTTP protocol provides type "
"information in the reply header, which can be inspected by looking at the"
" :mailheader:`Content-Type` header.  If the returned data is HTML, you "
"can use the module :mod:`html.parser` to parse it."
msgstr ""
":func:`urlopen`\\이나 :func:`urlretrieve`\\가 반환한 데이터는 서버가 반환한 원시 데이터입니다. "
"바이너리 데이터 (가령 이미지), 평문 텍스트 또는 (예를 들어) HTML일 수 있습니다. HTTP 프로토콜은 응답 헤더에 유형 "
"정보를 제공하는데, :mailheader:`Content-Type` 헤더를 통해 검사할 수 있습니다. 반환된 데이터가 HTML이면,"
" :mod:`html.parser` 모듈을 사용하여 구문 분석할 수 있습니다."

#: ../../library/urllib.request.rst:1591
msgid ""
"The code handling the FTP protocol cannot differentiate between a file "
"and a directory.  This can lead to unexpected behavior when attempting to"
" read a URL that points to a file that is not accessible.  If the URL "
"ends in a ``/``, it is assumed to refer to a directory and will be "
"handled accordingly.  But if an attempt to read a file leads to a 550 "
"error (meaning the URL cannot be found or is not accessible, often for "
"permission reasons), then the path is treated as a directory in order to "
"handle the case when a directory is specified by a URL but the trailing "
"``/`` has been left off.  This can cause misleading results when you try "
"to fetch a file whose read permissions make it inaccessible; the FTP code"
" will try to read it, fail with a 550 error, and then perform a directory"
" listing for the unreadable file. If fine-grained control is needed, "
"consider using the :mod:`ftplib` module, subclassing "
":class:`FancyURLopener`, or changing *_urlopener* to meet your needs."
msgstr ""
"FTP 프로토콜을 처리하는 코드는 파일과 디렉터리를 구별할 수 없습니다. 이는 액세스 할 수 없는 파일을 가리키는 URL을 읽으려고"
" 할 때 예기치 않은 동작을 일으킬 수 있습니다. URL이 ``/``\\로 끝나면, 디렉터리를 참조하는 것으로 간주하고 그에 따라 "
"처리됩니다. 그러나 파일을 읽으려는 시도가 550 에러를 일으키면 (URL을 찾을 수 없거나 액세스할 수 없다는 뜻인데, 종종 권한"
" 문제입니다), URL이 디렉터리를 지정하지만, 후행 ``/``\\를 붙이지 않은 경우를 처리하기 위해 경로가 디렉터리로 "
"처리됩니다. 이는 읽기 권한이 액세스할 수 없도록 지정된 파일을 가져오려고 시도할 때 잘못된 결과를 만들 수 있도록 합니다; FTP"
" 코드가 이를 읽으려고 시도하고, 550 에러로 실패한 다음, 읽을 수 없는 파일에 대해 디렉터리 리스팅을 수행합니다. 세밀한 "
"제어가 필요하면, :mod:`ftplib` 모듈 사용, :class:`FancyURLopener` 서브 클래싱 또는 필요에 맞게 "
"*_urlopener*\\를 변경하는 것을 고려하십시오."

#: ../../library/urllib.request.rst:1608
msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- urllib가 사용하는 응답 클래스"

#: ../../library/urllib.request.rst:1613
msgid ""
"The :mod:`urllib.response` module defines functions and classes which "
"define a minimal file-like interface, including ``read()`` and "
"``readline()``. Functions defined by this module are used internally by "
"the :mod:`urllib.request` module. The typical response object is a "
":class:`urllib.response.addinfourl` instance:"
msgstr ""
":mod:`urllib.response` 모듈은 ``read()``\\와 ``readline()``\\을 포함하여 최소한의 파일류 "
"인터페이스를 정의하는 함수와 클래스를 정의합니다. 이 모듈에 의해 정의된 함수는 :mod:`urllib.request` 모듈에 의해"
" 내부적으로 사용됩니다. 일반적인 응답 객체는 :class:`urllib.response.addinfourl` 인스턴스입니다:"

#: ../../library/urllib.request.rst:1622
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect "
"was followed."
msgstr "가져온 자원의 URL, 일반적으로 리디렉션을 따라갔는지 판별하는 데 사용됩니다."

#: ../../library/urllib.request.rst:1626
msgid ""
"Returns the headers of the response in the form of an "
":class:`~email.message.EmailMessage` instance."
msgstr ":class:`~email.message.EmailMessage` 인스턴스 형식으로 응답의 헤더를 반환합니다."

#: ../../library/urllib.request.rst:1632
msgid "Status code returned by server."
msgstr "서버가 반환한 상태 코드."

#: ../../library/urllib.request.rst:1636
msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "폐지되었고 :attr:`~addinfourl.url`\\로 대체되었습니다."

#: ../../library/urllib.request.rst:1641
msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "폐지되었고 :attr:`~addinfourl.headers`\\로 대체되었습니다."

#: ../../library/urllib.request.rst:1646 ../../library/urllib.request.rst:1651
msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "폐지되었고 :attr:`~addinfourl.status`\\로 대체되었습니다."

#: ../../library/urllib.request.rst:1555 ../../library/urllib.request.rst:1578
msgid "HTTP"
msgstr ""

#: ../../library/urllib.request.rst:1555 ../../library/urllib.request.rst:1578
msgid "protocol"
msgstr ""

#: ../../library/urllib.request.rst:1555 ../../library/urllib.request.rst:1589
msgid "FTP"
msgstr ""

#: ../../library/urllib.request.rst:1578
msgid "HTML"
msgstr ""

#~ msgid ""
#~ "The optional *cafile* and *capath* "
#~ "parameters specify a set of trusted "
#~ "CA certificates for HTTPS requests.  "
#~ "*cafile* should point to a single "
#~ "file containing a bundle of CA "
#~ "certificates, whereas *capath* should point"
#~ " to a directory of hashed certificate"
#~ " files.  More information can be "
#~ "found in :meth:`ssl.SSLContext.load_verify_locations`."
#~ msgstr ""
#~ "선택적 *cafile*\\과 *capath* 매개 변수는 HTTPS"
#~ " 요청을 위한 신뢰할 수 있는 CA 인증서 "
#~ "집합을 지정합니다. *cafile*\\은 CA 인증서 번들을 "
#~ "포함하는 단일 파일을 가리켜야 하지만, *capath*\\는 "
#~ "해시 된 인증서 파일의 디렉터리를 가리켜야 합니다. "
#~ "자세한 정보는 :meth:`ssl.SSLContext.load_verify_locations`\\에서"
#~ " 찾을 수 있습니다."

#~ msgid "The *cadefault* parameter is ignored."
#~ msgstr "*cadefault* 매개 변수는 무시됩니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``urllib.Request`` with arguments ``fullurl``, "
#~ "``data``, ``headers``, ``method``."
#~ msgstr ""
#~ "인자 ``fullurl``, ``data``, ``headers``, "
#~ "``method``\\로 :ref:`감사 이벤트 <auditing>` "
#~ "``urllib.Request``\\를 발생시킵니다."

#~ msgid ""
#~ "*cafile*, *capath* and *cadefault* are "
#~ "deprecated in favor of *context*. Please"
#~ " use :meth:`ssl.SSLContext.load_cert_chain` instead,"
#~ " or let :func:`ssl.create_default_context` select"
#~ " the system's trusted CA certificates "
#~ "for you."
#~ msgstr ""
#~ "*cafile*, *capath* 및 *cadefault*\\는 폐지되어 "
#~ "*context*\\로 대체되었습니다. 대신 "
#~ ":meth:`ssl.SSLContext.load_cert_chain`\\을 사용하거나, "
#~ ":func:`ssl.create_default_context`\\가 시스템의 신뢰할 수 "
#~ "있는 CA 인증서를 선택하도록 하십시오."

#~ msgid ""
#~ "Convert the pathname *path* from the "
#~ "local syntax for a path to the "
#~ "form used in the path component of"
#~ " a URL.  This does not produce "
#~ "a complete URL.  The return value "
#~ "will already be quoted using the "
#~ ":func:`~urllib.parse.quote` function."
#~ msgstr ""
#~ "경로명 *path*\\를 경로의 로컬 구문에서 URL의 경로"
#~ " 구성 요소에 사용된 형식으로 변환합니다. 완전한 "
#~ "URL을 생성하지는 않습니다. 반환 값은 "
#~ ":func:`~urllib.parse.quote` 함수를 사용하여 이미 "
#~ "인용되었습니다."

#~ msgid ""
#~ "Convert the path component *path* from"
#~ " a percent-encoded URL to the "
#~ "local syntax for a path.  This "
#~ "does not accept a complete URL.  "
#~ "This function uses :func:`~urllib.parse.unquote` "
#~ "to decode *path*."
#~ msgstr ""
#~ "경로 구성 요소 *path*\\를 퍼센트 인코딩된 URL에서"
#~ " 경로의 로컬 구문으로 변환합니다. 완전한 URL을 "
#~ "받아들이지 않습니다. 이 함수는 "
#~ ":func:`~urllib.parse.unquote`\\를 사용하여 *path*\\를 "
#~ "디코딩합니다."

