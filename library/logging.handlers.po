# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/logging.handlers.rst:2
#, fuzzy
msgid ":mod:`!logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- 로깅 처리기"

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**소스 코드:** :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
msgid "This page contains only reference information. For tutorials, please see"
msgstr "이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`기초 자습서 <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`고급 자습서 <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`로깅 요리책 <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that "
"three of the handlers (:class:`StreamHandler`, :class:`FileHandler` and "
":class:`NullHandler`) are actually defined in the :mod:`logging` module "
"itself, but have been documented here along with the other handlers."
msgstr ""
"다음과 같은 유용한 처리기가 패키지에서 제공됩니다. 3개의 처리기(:class:`StreamHandler`, "
":class:`FileHandler`, :class:`NullHandler`)는 실제로는 :mod:`logging` 모듈 자체에 "
"정의되어 있지만, 다른 처리기들과 함께 여기에서 설명합니다."

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, "
"*sys.stderr* or any file-like object (or, more precisely, any object "
"which supports :meth:`write` and :meth:`flush` methods)."
msgstr ""
"핵심 :mod:`logging` 패키지에 있는 :class:`StreamHandler` 클래스는 *sys.stdout*, "
"*sys.stderr* 또는 임의의 파일류 객체(또는 더 정확하게, :meth:`write`\\와 :meth:`flush` 메서드를"
" 지원하는 모든 객체)와 같은 스트림으로 로깅 출력을 보냅니다."

#: ../../library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* "
"is specified, the instance will use it for logging output; otherwise, "
"*sys.stderr* will be used."
msgstr ""
":class:`StreamHandler` 클래스의 새로운 인스턴스를 반환합니다. *stream* 이 지정되면, 인스턴스는 그것을 "
"로그 출력용으로 사용합니다; 그렇지 않으면, *sys.stderr* 이 사용됩니다."

#: ../../library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record "
"is then written to the stream followed by :attr:`terminator`. If "
"exception information is present, it is formatted using "
":func:`traceback.print_exception` and appended to the stream."
msgstr ""
"포매터가 지정되면, 레코드를 포맷하는 데 사용됩니다. 그런 다음 레코드는 :attr:`terminator`\\를 붙여 스트림에 "
"기록됩니다. 예외 정보가 있으면, :func:`traceback.print_exception`\\을 사용하여 포맷한 후 스트림에 "
"덧붙입니다."

#: ../../library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the "
":meth:`close` method is inherited from :class:`~logging.Handler` and so "
"does no output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"스트림의 :meth:`flush` 메서드를 호출해서 플러시 합니다. :meth:`close` 메서드는 "
":class:`~logging.Handler` 에서 상속되고, 출력이 없으므로, 명시적 :meth:`flush` 호출이 필요할 수도"
" 있습니다."

#: ../../library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. "
"The old stream is flushed before the new stream is set."
msgstr ""
"지정한 값이 현재 값과 다르면, 인스턴스의 스트림을 지정된 값으로 설정합니다. 새 스트림이 설정되기 전에 이전 스트림이 플러시 "
"됩니다."

#: ../../library/logging.handlers.rst
msgid "Parameters"
msgstr "매개 변수"

#: ../../library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "처리기가 사용할 스트림."

#: ../../library/logging.handlers.rst
msgid "Returns"
msgstr "반환"

#: ../../library/logging.handlers.rst:69
#, fuzzy
msgid "the old stream, if the stream was changed, or ``None`` if it wasn't."
msgstr "스트림이 변경되면 이전 스트림, 그렇지 않으면 *None*."

#: ../../library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a "
"stream. Default value is ``'\\n'``."
msgstr "포맷된 레코드를 스트림에 쓸 때 종결자로 사용되는 문자열. 기본값은 ``'\\n'``\\입니다."

#: ../../library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler "
"instance's ``terminator`` attribute to the empty string."
msgstr "줄 바꿈 종료를 원하지 않으면, 처리기 인스턴스의 ``terminator`` 어트리뷰트를 빈 문자열로 설정할 수 있습니다."

#: ../../library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr "이전 버전에서는, 종결자가 ``'\\n'``\\으로 하드 코딩되었습니다."

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` "
"package, sends logging output to a disk file.  It inherits the output "
"functionality from :class:`StreamHandler`."
msgstr ""
"핵심 :mod:`logging` 패키지에 있는 :class:`FileHandler` 클래스는 로깅 출력을 디스크 파일로 보냅니다. "
":class:`StreamHandler` 에서 출력 기능을 상속받습니다."

#: ../../library/logging.handlers.rst:98
#, fuzzy
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified "
"file is opened and used as the stream for logging. If *mode* is not "
"specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used to"
" open the file with that encoding.  If *delay* is true, then file opening"
" is deferred until the first call to :meth:`emit`. By default, the file "
"grows indefinitely. If *errors* is specified, it's used to determine how "
"encoding errors are handled."
msgstr ""
":class:`FileHandler` 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 스트림으로 "
"사용됩니다. *mode* 가 지정되지 않으면, :const:`'a'` 가 사용됩니다. *encoding* 이 ``None`` 이 "
"아니면, *encoding*\\을 사용하여 파일을 엽니다. *delay* 가 참이면, 파일 열기는 :meth:`emit`\\의 첫 "
"번째 호출이 있을 때까지 연기됩니다. 기본적으로, 파일은 제한 없이 커집니다. *errors*\\가 지정되면, 인코딩 에러 처리 "
"방법을 결정합니다."

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:190
#: ../../library/logging.handlers.rst:338
#: ../../library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also "
"accepted for the *filename* argument."
msgstr "문자열 값뿐만 아니라, :class:`~pathlib.Path` 객체도 *filename* 인자로 허용됩니다."

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:194
#: ../../library/logging.handlers.rst:342
#: ../../library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "*errors* 매개 변수가 추가되었습니다."

#: ../../library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "파일을 닫습니다."

#: ../../library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "레코드를 파일에 출력합니다."

#: ../../library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr ""

#: ../../library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` "
"package, does not do any formatting or output. It is essentially a 'no-"
"op' handler for use by library developers."
msgstr ""
"핵심 :mod:`logging` 패키지에 있는 :class:`NullHandler` 클래스는 포맷이나 출력을 일절 하지 않습니다. "
"기본적으로 라이브러리 개발자가 사용하는 'no-op' 처리기입니다."

#: ../../library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr ":class:`NullHandler` 클래스의 새로운 인스턴스를 반환합니다."

#: ../../library/logging.handlers.rst:141
#: ../../library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "이 메서드는 아무것도 하지 않습니다."

#: ../../library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying "
"I/O to which access needs to be serialized."
msgstr "액세스를 직렬화해야 하는 하부 I/O가 없으므로, 이 메서드는 록으로 ``None`` 을 반환합니다."

#: ../../library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use "
":class:`NullHandler`."
msgstr ":class:`NullHandler` 사용법에 대한 더 많은 정보는 :ref:`library-config`\\를 참조하세요."

#: ../../library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the "
":mod:`logging.handlers` module, is a :class:`FileHandler` which watches "
"the file it is logging to. If the file changes, it is closed and reopened"
" using the file name."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`WatchedFileHandler` 클래스는 로깅 중인 파일을"
" 감시하는 :class:`FileHandler` 입니다. 파일이 변경되면, 닫은 후에 같은 이름의 파일을 다시 엽니다."

#: ../../library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog*"
" and *logrotate* which perform log file rotation. This handler, intended "
"for use under Unix/Linux, watches the file to see if it has changed since"
" the last emit. (A file is deemed to have changed if its device or inode "
"have changed.) If the file has changed, the old file stream is closed, "
"and the file opened to get a new stream."
msgstr ""
"로그 파일 회전을 수행하는 *newsyslog* 나 *logrotate* 와 같은 프로그램의 사용으로 인해 파일이 변경될 수 "
"있습니다. 유닉스/리눅스에서 사용하기 위한 이 처리기는 마지막 출력 이후에 파일이 변경되었는지 감시합니다. (파일의 장치나 "
"inode가 변경되면 파일이 변경된 것으로 간주합니다.) 파일이 변경되면, 이전 파일 스트림이 닫히고, 새 스트림을 얻기 위해 "
"파일을 엽니다."

#: ../../library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under "
"Windows open log files cannot be moved or renamed - logging opens the "
"files with exclusive locks - and so there is no need for such a handler. "
"Furthermore, *ST_INO* is not supported under Windows; :func:`~os.stat` "
"always returns zero for this value."
msgstr ""
"이 처리기는 윈도우에서 사용하기에 적합하지 않습니다. 윈도우에서는 열린 로그 파일을 이동하거나 이름을 변경할 수 없어서 - "
"logging은 파일을 배타적 록으로 엽니다 - 이런 처리기가 필요하지 않기 때문입니다. 또한 *ST_INO* 는 윈도우에서 "
"지원되지 않습니다; :func:`~os.stat`\\는 항상 이 값에 대해 0을 반환합니다."

#: ../../library/logging.handlers.rst:183
#, fuzzy
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is"
" not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, "
"the file grows indefinitely. If *errors* is provided, it determines how "
"encoding errors are handled."
msgstr ""
":class:`FileHandler` 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 스트림으로 "
"사용됩니다. *mode* 가 지정되지 않으면, :const:`'a'` 가 사용됩니다. *encoding* 이 ``None`` 이 "
"아니면, *encoding*\\을 사용하여 파일을 엽니다. *delay* 가 참이면, 파일 열기는 :meth:`emit`\\의 첫 "
"번째 호출이 있을 때까지 연기됩니다. 기본적으로, 파일은 제한 없이 커집니다. *errors*\\가 제공되면, 인코딩 에러 처리 "
"방법을 결정합니다."

#: ../../library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is"
" flushed and closed and the file opened again, typically as a precursor "
"to outputting the record to the file."
msgstr ""
"파일이 변경되었는지 확인합니다. 그렇다면, 기존 스트림을 플러시 한 후 닫고, 파일을 다시 엽니다. 일반적으로 레코드를 파일로 "
"출력하기 전에 수행합니다."

#: ../../library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to"
" reopen the file if it has changed."
msgstr "레코드를 파일에 출력하지만, 파일이 변경되었을 때 다시 열기 위해 :meth:`reopenIfNeeded`\\를 먼저 호출합니다."

#: ../../library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the "
":mod:`logging.handlers` module, is the base class for the rotating file "
"handlers, :class:`RotatingFileHandler` and "
":class:`TimedRotatingFileHandler`. You should not need to instantiate "
"this class, but it has attributes and methods you may need to override."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`BaseRotatingHandler` 클래스는 회전하는 파일 "
"처리기들(:class:`RotatingFileHandler`\\와 :class:`TimedRotatingFileHandler`)의 "
"베이스 클래스입니다. 이 클래스의 인스턴스를 만들 필요는 없지만, 재정의가 필요할 수 있는 어트리뷰트와 메서드가 있습니다."

#: ../../library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "매개 변수는 :class:`FileHandler` 와 같습니다. 어트리뷰트는 다음과 같습니다:"

#: ../../library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` "
"method delegates to this callable. The parameters passed to the callable "
"are those passed to :meth:`rotation_filename`."
msgstr ""
"이 어트리뷰트가 콜러블로 설정되면, :meth:`rotation_filename` 메서드는 이 콜러블에 위임합니다. 콜러블로 "
"전달되는 매개 변수는 :meth:`rotation_filename`\\로 전달되는 것입니다."

#: ../../library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it "
"should be as simple and as fast as possible. It should also return the "
"same output every time for a given input, otherwise the rollover "
"behaviour may not work as expected."
msgstr ""
"namer 함수는 롤오버 중에 꽤 자주 호출되므로, 가능한 한 간단하고 빨라야 합니다. 또한, 주어진 입력에 대해 매번 같은 출력을"
" 반환해야 합니다, 그렇지 않으면 롤오버 동작이 예상대로 작동하지 않을 수 있습니다."

#: ../../library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during "
"rotation. For example, :class:`RotatingFileHandler` expects to have a set"
" of log files whose names contain successive integers, so that rotation "
"works as expected, and :class:`TimedRotatingFileHandler` deletes old log "
"files (based on the ``backupCount`` parameter passed to the handler's "
"initializer) by determining the oldest files to delete. For this to "
"happen, the filenames should be sortable using the date/time portion of "
"the filename, and a namer needs to respect this. (If a namer is wanted "
"that doesn't respect this scheme, it will need to be used in a subclass "
"of :class:`TimedRotatingFileHandler` which overrides the "
":meth:`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with "
"the custom naming scheme.)"
msgstr ""

#: ../../library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method "
"delegates to this callable.  The parameters passed to the callable are "
"those passed to :meth:`rotate`."
msgstr ""
"이 어트리뷰트가 콜러블로 설정되면, :meth:`rotate` 메서드는 이 콜러블에 위임합니다. 콜러블로 전달되는 매개 변수는 "
":meth:`rotate`\\로 전달되는 것입니다."

#: ../../library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr "회전할 때 로그 파일의 파일명을 수정합니다."

#: ../../library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr "사용자 정의 파일명을 제공할 수 있게 하려고 제공됩니다."

#: ../../library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if"
" it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"기본 구현은 처리기의 'namer' 어트리뷰트를(콜러블이라면) 호출하는데, 기본 이름을 전달합니다. 어트리뷰트가 콜러블이 아니면 "
"(기본값은 ``None`` 입니다), 이름은 변경되지 않고 반환됩니다."

#: ../../library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "로그 파일의 기본 이름."

#: ../../library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "회전할 때, 현재 로그를 회전합니다."

#: ../../library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, "
"if it's callable, passing the source and dest arguments to it. If the "
"attribute isn't callable (the default is ``None``), the source is simply "
"renamed to the destination."
msgstr ""
"기본 구현은 처리기의 'rotator' 어트리뷰트를(콜러블이라면) 호출하는데, source와 dest 인자를 전달합니다. "
"어트리뷰트가 콜러블이 아니면 (기본값은 ``None`` 입니다), source를 dest 로 단순히 이름을 바꿉니다."

#: ../../library/logging.handlers.rst:285
msgid "The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr "소스 파일명. 이것은 일반적으로 기본 파일명입니다, 예를 들어 'test.log'."

#: ../../library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to,"
" e.g. 'test.log.1'."
msgstr "대상 파일명. 이것은 일반적으로 소스가 회전되는 곳입니다, 예를 들어 'test.log.1'."

#: ../../library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you "
"can use the same callables for instances of :class:`RotatingFileHandler` "
"and :class:`TimedRotatingFileHandler`. If either the namer or rotator "
"callable raises an exception, this will be handled in the same way as any"
" other exception during an :meth:`emit` call, i.e. via the "
":meth:`handleError` method of the handler."
msgstr ""
"어트리뷰트가 존재하는 이유는 서브 클래싱해야 할 필요를 줄이는 것입니다 - :class:`RotatingFileHandler`\\와"
" :class:`TimedRotatingFileHandler` 의 인스턴스에 같은 콜러블을 사용할 수 있습니다. namer 나 "
"rotator 콜러블이 예외를 발생시키면, :meth:`emit` 동안 발생하는 다른 예외와 같은 방식으로 처리됩니다, 즉 처리기의"
" :meth:`handleError` 메서드를 통해."

#: ../../library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you "
"can override the methods."
msgstr "회전 처리를 더 크게 변경해야 하면, 메서드를 재정의할 수 있습니다."

#: ../../library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "예는 :ref:`cookbook-rotator-namer`\\를 보십시오."

#: ../../library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the "
":mod:`logging.handlers` module, supports rotation of disk log files."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`RotatingFileHandler` 클래스는 디스크 로그 "
"파일 회전을 지원합니다."

#: ../../library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is"
" not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, "
"the file grows indefinitely. If *errors* is provided, it determines how "
"encoding errors are handled."
msgstr ""
":class:`RotatingFileHandler` 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 "
"스트림으로 사용됩니다. *mode* 가 지정되지 않으면, ``'a'`` 가 사용됩니다. *encoding* 이 ``None`` 이 "
"아니면, *encoding*\\을 사용하여 파일을 엽니다. *delay* 가 참이면, 파일 열기는 :meth:`emit`\\의 첫 "
"번째 호출이 있을 때까지 연기됩니다. 기본적으로, 파일은 제한 없이 커집니다. *errors*\\가 제공되면, 인코딩 에러 처리 "
"방법을 결정합니다."

#: ../../library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to "
":dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for "
"output. Rollover occurs whenever the current log file is nearly "
"*maxBytes* in length; but if either of *maxBytes* or *backupCount* is "
"zero, rollover never occurs, so you generally want to set *backupCount* "
"to at least 1, and have a non-zero *maxBytes*. When *backupCount* is non-"
"zero, the system will save old log files by appending the extensions "
"'.1', '.2' etc., to the filename. For example, with a *backupCount* of 5 "
"and a base file name of :file:`app.log`, you would get :file:`app.log`, "
":file:`app.log.1`, :file:`app.log.2`, up to :file:`app.log.5`. The file "
"being written to is always :file:`app.log`.  When this file is filled, it"
" is closed and renamed to :file:`app.log.1`, and if files "
":file:`app.log.1`, :file:`app.log.2`, etc. exist, then they are renamed "
"to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"미리 결정된 크기에서 파일을 :dfn:`롤오버 (rollover)` 하기 위해 *maxBytes* 와 *backupCount* 값을"
" 사용할 수 있습니다. 크기가 초과하려고 할 때, 파일이 닫히고 출력을 위해 새 파일이 조용히 열립니다. 롤오버는 현재 로그 파일이"
" 거의 *maxBytes* 길이일 때마다 발생합니다; 그러나 *maxBytes* 나 *backupCount* 가 0이면 롤오버가 "
"발생하지 않으므로, 일반적으로 *backupCount* 를 1 이상으로 설정하고, 0이 아닌 *maxBytes*\\를 사용하기를 "
"원할 겁니다. *backupCount* 가 0이 아니면, 시스템은 파일명에 확장자 '.1', '.2' 등을 추가하여 지난 로그 "
"파일을 저장합니다. 예를 들어, *backupCount* 가 5이고 기본 파일명이 :file:`app.log` 면, "
":file:`app.log`, :file:`app.log.1`, :file:`app.log.2`\\부터 "
":file:`app.log.5` 까지의 파일을 얻게 됩니다. 기록되는 파일은 항상 :file:`app.log` 입니다. 이 파일이 "
"채워지면, 닫히고 :file:`app.log.1` 로 이름이 변경됩니다, 그리고 파일 :file:`app.log.1`, "
":file:`app.log.2` 등이 존재하면, 이것들도 각기 :file:`app.log.2`, :file:`app.log.3` "
"등으로 이름이 변경됩니다."

#: ../../library/logging.handlers.rst:347
#: ../../library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "위에서 설명한 대로 롤오버를 수행합니다."

#: ../../library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "앞에서 설명한 대로 롤오버를 처리하면서, 파일에 레코드를 출력합니다."

#: ../../library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the "
":mod:`logging.handlers` module, supports rotation of disk log files at "
"certain timed intervals."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`TimedRotatingFileHandler` 클래스는 특정 "
"시간 간격의 디스크 로그 파일 회전을 지원합니다."

#: ../../library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. "
"The specified file is opened and used as the stream for logging. On "
"rotating it also sets the filename suffix. Rotating happens based on the "
"product of *when* and *interval*."
msgstr ""
":class:`TimedRotatingFileHandler` 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 "
"위한 스트림으로 사용됩니다. 회전 시 파일명 접미사도 설정합니다. *when* 과 *interval* 에 따라 회전이 일어납니다."

#: ../../library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"*when* 을 사용하여 *interval* 의 유형을 지정할 수 있습니다. 가능한 값의 목록은 아래와 같습니다. 대소 문자를 "
"구분하지 않는다는 것에 유의하세요."

#: ../../library/logging.handlers.rst:376
msgid "Value"
msgstr "값"

#: ../../library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "interval의 유형"

#: ../../library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "*atTime* 이 사용되는지와 사용되는 방식"

#: ../../library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:378
msgid "Seconds"
msgstr "초"

#: ../../library/logging.handlers.rst:378
#: ../../library/logging.handlers.rst:380
#: ../../library/logging.handlers.rst:382
#: ../../library/logging.handlers.rst:384
msgid "Ignored"
msgstr "무시됩니다"

#: ../../library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:380
msgid "Minutes"
msgstr "분"

#: ../../library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:382
msgid "Hours"
msgstr "시간"

#: ../../library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:384
msgid "Days"
msgstr "일"

#: ../../library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "요일 (0=월요일)"

#: ../../library/logging.handlers.rst:386
#: ../../library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "최초 롤오버 시간을 계산하는 데 사용됩니다"

#: ../../library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:389
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr "*atTime* 을 지정하지 않으면 자정에, 그렇지 않으면 *atTime* 에 롤오버 합니다"

#: ../../library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed "
"for *interval* isn't used."
msgstr ""
"요일 기반 회전을 사용할 때, 월요일은 'W0', 화요일은 'W1', 등등 일요일은 'W6'까지 지정하십시오. 이 경우, "
"*interval* 에 전달된 값은 사용되지 않습니다."

#: ../../library/logging.handlers.rst:398
#, python-format
msgid ""
"The system will save old log files by appending extensions to the "
"filename. The extensions are date-and-time based, using the strftime "
"format ``%Y-%m-%d_%H-%M-%S`` or a leading portion thereof, depending on "
"the rollover interval."
msgstr ""
"시스템은 파일명에 확장자를 추가하여 지난 로그 파일을 저장합니다. 확장자는 날짜와 시간 기반이며, 롤오버 간격에 따라 "
"strftime 형식 ``%Y-%m-%d_%H-%M-%S`` 이나 그 앞부분을 사용합니다."

#: ../../library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the "
"handler is created), the last modification time of an existing log file, "
"or else the current time, is used to compute when the next rotation will "
"occur."
msgstr ""
"다음 롤오버 시간을 처음 계산할 때 (처리기가 만들어질 때), 기존 로그 파일의 마지막 수정 시간 또는 (없으면) 현재 시각이 다음"
" 회전이 발생할 때를 계산하는 데 사용됩니다."

#: ../../library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local"
" time is used."
msgstr "*utc* 인자가 참이면, UTC 시간이 사용됩니다; 그렇지 않으면 현지 시간이 사용됩니다."

#: ../../library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, "
"and if more would be created when rollover occurs, the oldest one is "
"deleted. The deletion logic uses the interval to determine which files to"
" delete, so changing the interval may leave old files lying around."
msgstr ""
"*backupCount* 가 0이 아니면, 최대 *backupCount* 개의 파일이 보관되고, 롤오버가 발생할 때 더 많은 파일이"
" 생성되면 가장 오래된 파일이 삭제됩니다. 삭제 논리는 interval을 사용하여 삭제할 파일을 결정하므로, interval을 "
"변경하면 오래된 파일이 남아있을 수 있습니다."

#: ../../library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to"
" :meth:`emit`."
msgstr "*delay* 가 참이면, 파일 열기는 :meth:`emit`\\에 대한 첫 번째 호출까지 지연됩니다."

#: ../../library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance "
"which specifies the time of day when rollover occurs, for the cases where"
" rollover is set to happen \"at midnight\" or \"on a particular "
"weekday\". Note that in these cases, the *atTime* value is effectively "
"used to compute the *initial* rollover, and subsequent rollovers would be"
" calculated via the normal interval calculation."
msgstr ""
"*atTime* 이 ``None`` 이 아니면, 반드시 ``datetime.time`` 인스턴스여야 하는데, 롤오버가 \"자정에\""
" 또는 \"특정 요일에\" 발생하도록 설정된 경우에 롤오버가 발생하는 시간을 지정합니다. 이 경우, *atTime* 값은 *최초* "
"롤오버를 계산하는 데 사용되며, 이후 롤오버는 일반적인 간격 계산을 통해 계산됩니다."

#: ../../library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr "*errors*\\가 지정되면, 인코딩 에러 처리 방법을 결정하는 데 사용됩니다."

#: ../../library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this "
"is not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always "
"see log files with times (in the filename) separated by a minute; if, "
"during application execution, logging output is generated more frequently"
" than once a minute, *then* you can expect to see log files with times "
"separated by a minute. If, on the other hand, logging messages are only "
"output once every five minutes (say), then there will be gaps in the file"
" times corresponding to the minutes where no output (and hence no "
"rollover) occurred."
msgstr ""
"최초 롤오버 시간의 계산은 처리기가 초기화될 때 수행됩니다. 후속 롤오버 시간 계산은 롤오버가 발생하는 경우에만 수행되며, 롤오버는"
" 출력을 내보낼 때만 발생합니다. 이것을 명심하지 않으면, 혼란이 생길 수 있습니다. 예를 들어, \"매분\" 간격을 설정하면, "
"이것이 항상 1분 간격의 (파일명을 갖는) 로그 파일들을 보게 된다는 것을 뜻하지는 않습니다; 응용 프로그램을 실행하는 동안, 로그"
" 출력이 1분당 한 번보다 더 자주 *발생하면*, 1분 간격의 로그 파일을 볼 것으로 예상할 수 있습니다. 반면, (가령) 로깅 "
"메시지가 5분마다 한 번만 출력되면, 출력이 없는 (따라서 롤오버가 없는) 분에 해당하는 파일 시간의 틈이 생깁니다."

#: ../../library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "*atTime* 매개 변수가 추가되었습니다."

#: ../../library/logging.handlers.rst:457
msgid "Outputs the record to the file, catering for rollover as described above."
msgstr "위에서 설명한 대로 롤오버를 처리하면서, 파일에 레코드를 출력합니다."

#: ../../library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by "
"the handler."
msgstr ""

#: ../../library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a "
"TCP socket."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`SocketHandler` 클래스는 로깅 출력을 네트워크 "
"소켓에 보냅니다. 베이스 클래스는 TCP 소켓을 사용합니다."

#: ../../library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"*host* 와 *port*\\로 주어진 주소의 원격 기계와 통신하기 위한, :class:`SocketHandler` 클래스의 "
"새로운 인스턴스를 반환합니다."

#: ../../library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created "
"using the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"``port``\\가 ``None``\\으로 지정되면, ``host``\\의 값을 사용하여 유닉스 도메인 소켓이 만들어집니다 - "
"그렇지 않으면 TCP 소켓이 만들어집니다."

#: ../../library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr "소켓을 닫습니다."

#: ../../library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a "
":class:`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` "
"function."
msgstr ""
"레코드의 어트리뷰트 딕셔너리를 피클하고 바이너리 형식으로 소켓에 씁니다. 소켓에 에러가 있으면 조용히 패킷을 버립니다. 이전에 "
"연결이 끊어졌으면, 연결을 다시 맺습니다. 수신 단에서 레코드를 :class:`~logging.LogRecord`\\로 역 피클 "
"하려면, :func:`~logging.makeLogRecord` 함수를 사용하십시오."

#: ../../library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the"
" next event."
msgstr ""
":meth:`emit` 중에 발생한 에러를 처리합니다. 가장 큰 원인은 연결이 끊어지는 것입니다. 다음 이벤트에서 다시 시도할 수 "
"있도록 소켓을 닫습니다."

#: ../../library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise "
"type of socket they want. The default implementation creates a TCP socket"
" (:const:`socket.SOCK_STREAM`)."
msgstr ""
"이것은 서브 클래스가 원하는 소켓의 정확한 유형을 정의 할 수 있게 하는 팩토리 메서드입니다. 기본 구현은 TCP "
"소켓(:const:`socket.SOCK_STREAM`)을 만듭니다."

#: ../../library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The "
"details of this operation are equivalent to::"
msgstr ""
"레코드의 어트리뷰트 딕셔너리를 바이너리 형식으로 피클하고 길이를 앞에 붙여서, 소켓을 통해 전송할 준비가 된 상태로 반환합니다. 이"
" 연산의 세부 사항은 다음과 동등합니다::"

#: ../../library/logging.handlers.rst:517
msgid ""
"data = pickle.dumps(record_attr_dict, 1)\n"
"datalen = struct.pack('>L', len(data))\n"
"return datalen + data"
msgstr ""

#: ../../library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure"
" mechanism. For example, you can sign pickles using HMAC and then verify "
"them on the receiving end, or alternatively you can disable unpickling of"
" global objects on the receiving end."
msgstr ""
"피클은 완전히 안전하지 않습니다. 보안이 염려되면, 이 메서드를 재정의하여 더욱 안전한 메커니즘을 구현할 수 있습니다. 예를 들어,"
" HMAC를 사용하여 피클에 서명한 다음 수신 단에서 확인하거나, 수신 단에서 전역 객체의 역 피클링을 비활성화할 수 있습니다."

#: ../../library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent"
" byte-string is as described in the documentation for "
":meth:`~SocketHandler.makePickle`."
msgstr ""
"피클 된 바이트열 *packet* 을 소켓으로 보냅니다. 보내진 바이트열의 형식은 "
":meth:`~SocketHandler.makePickle`\\의 설명서에 있습니다."

#: ../../library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network"
" is busy."
msgstr "이 함수는 네트워크가 붐빌 때 발생할 수 있는 부분 전송을 허용합니다."

#: ../../library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same "
"instance, it will not try connecting until some time has passed.  The "
"default parameters are such that the initial delay is one second, and if "
"after that delay the connection still can't be made, the handler will "
"double the delay each time up to a maximum of 30 seconds."
msgstr ""
"소켓을 만들려고 합니다; 실패 시, 지수 백 오프 알고리즘을 사용합니다. 최초 실패 시 처리기는 보내려는 메시지를 버립니다. 후속 "
"메시지가 같은 인스턴스에 의해 처리될 때, 일정한 시간이 지날 때까지 연결을 시도하지 않습니다. 기본 파라미터를 쓸 때, 최초 "
"지연은 1초이고, 지연 후에도 연결을 만들 수 없으면, 처리기가 최대 30초가 될 때까지 매번 지연 시간을 두 배로 늘립니다."

#: ../../library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "이 동작은 다음 처리기 어트리뷰트에 의해 제어됩니다:"

#: ../../library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (최초 지연, 기본값은 1.0 초)."

#: ../../library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (배율, 기본값은 2.0)."

#: ../../library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (최대 지연, 기본값은 30.0 초)."

#: ../../library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt "
"a connection until the delay has elapsed, but just silently drop messages"
" during the delay period)."
msgstr ""
"이것은, 처리기가 사용된 *후에* 원격 수신기가 시작되면, 메시지가 손실될 수 있음을 뜻합니다 (처리기가 지연이 경과 할 때까지 "
"연결을 시도하지조차 않고, 지연 기간에 메시지를 조용히 버리기 때문입니다)."

#: ../../library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the "
":mod:`logging.handlers` module, inherits from :class:`SocketHandler` to "
"support sending logging messages over UDP sockets."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`DatagramHandler` 클래스는 UDP 소켓을 통해 "
"로깅 메시지를 보낼 수 있도록 :class:`SocketHandler`\\를 상속합니다."

#: ../../library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"*host* 와 *port*\\로 주어진 주소의 원격 기계와 통신하기 위한, :class:`DatagramHandler` 클래스의 "
"새로운 인스턴스를 반환합니다."

#: ../../library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when "
"using a network socket, a DNS lookup might have to be made each time an "
"event is logged, which can introduce some latency into the system. If "
"this affects you, you can do a lookup yourself and initialize this "
"handler using the looked-up IP address rather than the hostname."
msgstr ""

#: ../../library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created "
"using the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"``port``\\가 ``None``\\으로 지정되면, ``host``\\의 값을 사용하여 유닉스 도메인 소켓이 만들어집니다 - "
"그렇지 않으면 UDP 소켓이 만들어집니다."

#: ../../library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a "
":class:`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` "
"function."
msgstr ""
"레코드의 어트리뷰트 딕셔너리를 피클하고 바이너리 형식으로 소켓에 씁니다. 소켓에 에러가 있으면 조용히 패킷을 버립니다. 수신 단에서"
" 레코드를 :class:`~logging.LogRecord`\\로 역 피클 하려면, "
":func:`~logging.makeLogRecord` 함수를 사용하십시오."

#: ../../library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create"
" a UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"UDP 소켓(:const:`socket.SOCK_DGRAM`)을 만들기 위해 :class:`SocketHandler`\\의 팩토리 "
"메서드가 여기에서 재정의되었습니다."

#: ../../library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-"
"string is as described in the documentation for "
":meth:`SocketHandler.makePickle`."
msgstr ""
"피클 된 바이트열을 소켓으로 보냅니다. 보낸 바이트열의 형식은 :meth:`SocketHandler.makePickle` 설명서에 "
"있습니다."

#: ../../library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix "
"syslog."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`SysLogHandler` 클래스는 원격 또는 로컬 유닉스 "
"syslog로 로깅 메시지를 보내는 것을 지원합니다."

#: ../../library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by "
"*address* in the form of a ``(host, port)`` tuple.  If *address* is not "
"specified, ``('localhost', 514)`` is used.  The address is used to open a"
" socket.  An alternative to providing a ``(host, port)`` tuple is "
"providing an address as a string, for example '/dev/log'. In this case, a"
" Unix domain socket is used to send the message to the syslog. If "
"*facility* is not specified, :const:`LOG_USER` is used. The type of "
"socket opened depends on the *socktype* argument, which defaults to "
":const:`socket.SOCK_DGRAM` and thus opens a UDP socket. To open a TCP "
"socket (for use with the newer syslog daemons such as rsyslog), specify a"
" value of :const:`socket.SOCK_STREAM`."
msgstr ""
"``(host, port)`` 튜플 형태의 *address*\\로 주어진 주소의 원격 유닉스 기계와 통신하기 위한 "
":class:`SysLogHandler` 클래스의 새 인스턴스를 돌려줍니다. *address* 를 지정하지 않으면 "
"``('localhost', 514)``\\가 사용됩니다. 주소는 소켓을 여는 데 사용됩니다. ``(host, port)`` 튜플을"
" 제공하는 대신, 주소를 문자열로 제공할 수 있습니다, 예를 들어 '/dev/log'. 이 경우, 메시지를 syslog로 보내는데 "
"유닉스 도메인 소켓이 사용됩니다. *facility* 가 지정되지 않으면, :const:`LOG_USER`\\가 사용됩니다. 열리는"
" 소켓의 유형은 *socktype* 인자에 따라 달라지며, 기본값은 :const:`socket.SOCK_DGRAM`\\이고, 따라서"
" UDP 소켓이 열립니다. TCP 소켓을 열려면 (rsyslog와 같은 최신 syslog 데몬을 사용할 때), "
":const:`socket.SOCK_STREAM` 값을 지정하십시오."

#: ../../library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, "
":class:`SysLogHandler` may appear not to work. In that case, check what "
"address you should be using for a domain socket - it's system dependent. "
"For example, on Linux it's usually '/dev/log' but on OS/X it's "
"'/var/run/syslog'. You'll need to check your platform and use the "
"appropriate address (you may need to do this check at runtime if your "
"application needs to run on several platforms). On Windows, you pretty "
"much have to use the UDP option."
msgstr ""
"서버가 UDP 포트 514에서 수신을 기다리지 않으면, :class:`SysLogHandler`\\가 작동하지 않는 것처럼 보일 수"
" 있습니다. 이 경우, 도메인 소켓에 대해 사용해야 하는 주소를 확인하십시오 - 이는 시스템에 따라 다릅니다. 예를 들어 "
"리눅스에서는 보통 '/dev/log' 이지만 OS/X에서는 '/var/run/syslog' 입니다. 플랫폼을 확인하고 적절한 주소를"
" 사용해야 합니다 (응용 프로그램을 여러 플랫폼에서 실행해야 하는 경우 실행 시간에 검사를 수행해야 할 수도 있습니다). "
"윈도우에서는, UDP 옵션을 사용해야 합니다."

#: ../../library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog"
" daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""

#: ../../library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr ""

#: ../../library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "*socktype* 이 추가되었습니다."

#: ../../library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr "원격 호스트로의 소켓을 닫습니다."

#: ../../library/logging.handlers.rst:655
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it "
"to the other end. This method is called during handler initialization, "
"but it's not regarded as an error if the other end isn't listening at "
"this point - the method will be called again when emitting an event, if "
"there is no socket at that point."
msgstr ""

#: ../../library/logging.handlers.rst:665
msgid ""
"The record is formatted, and then sent to the syslog server. If exception"
" information is present, it is *not* sent to the server."
msgstr "레코드가 포맷된 다음, syslog 서버로 전송됩니다. 예외 정보가 있으면, 서버로 보내 지지 *않습니다*."

#: ../../library/logging.handlers.rst:668
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the "
"syslog daemons was always terminated with a NUL byte, because early "
"versions of these daemons expected a NUL terminated message - even though"
" it's not in the relevant specification (:rfc:`5424`). More recent "
"versions of these daemons don't expect the NUL byte but strip it off if "
"it's there, and even more recent daemons (which adhere more closely to "
"RFC 5424) pass the NUL byte on as part of the message."
msgstr ""
"(:issue:`12168`\\를 보세요.) 이전 버전에서, syslog 데몬으로 보낸 메시지는 NUL 바이트로 항상 종료되었는데,"
" 이전 버전의 데몬에서 관련 사양(:rfc:`5424`)에 없는데도 불구하고 NUL 종료 메시지를 요구했기 때문입니다. 최신 버전의"
" 데몬은 NUL 바이트를 기대하지는 않지만, 있는 경우 이를 제거하고, 더 최근의 (RFC 5424와 더 가깝게 일치하는) 데몬은 "
"NUL 바이트를 메시지 일부로 전달합니다."

#: ../../library/logging.handlers.rst:677
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``."
" This defaults to ``True`` (preserving the existing behaviour) but can be"
" set to ``False`` on a ``SysLogHandler`` instance in order for that "
"instance to *not* append the NUL terminator."
msgstr ""
"이러한 모든 다른 데몬 동작에 직면하여 syslog 메시지를 더욱 쉽게 처리할 수 있도록, NUL 바이트를 추가하는 작업은 클래스 "
"수준 어트리뷰트 ``append_nul``\\을 사용하여 구성할 수 있게 만들었습니다. 기본값은 ``True``\\(기존 동작 "
"유지)이지만, 특정 인스턴스가 NUL 종결자를 추가하지 *않도록* ``SysLogHandler`` 인스턴스에서 "
"``False``\\로 설정할 수 있습니다."

#: ../../library/logging.handlers.rst:684
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This "
"can now be specified using a class-level attribute, defaulting to "
"``\"\"`` to preserve existing behaviour, but which can be overridden on a"
" ``SysLogHandler`` instance in order for that instance to prepend the "
"ident to every message handled. Note that the provided ident must be "
"text, not bytes, and is prepended to the message exactly as is."
msgstr ""
"(:issue:`12419`\\를 보세요.) 이전 버전에서는, 메시지 소스를 식별하는 \"ident\" 나 \"tag\" 접두사를 "
"위한 기능이 없었습니다. 이제는 클래스 수준의 어트리뷰트를 사용하여 지정할 수 있습니다, ``\"\"``\\을 기본값으로 사용하여 "
"기존 동작을 유지하지만, ``SysLogHandler`` 인스턴스에서 재정의하여 해당 인스턴스가 처리하는 모든 메시지에 ident를"
" 추가하도록 할 수 있습니다. 제공된 ident는 바이트열이 아닌 텍스트여야 하며 그대로 메시지 앞에 추가됩니다."

#: ../../library/logging.handlers.rst:695
msgid ""
"Encodes the facility and priority into an integer. You can pass in "
"strings or integers - if strings are passed, internal mapping "
"dictionaries are used to convert them to integers."
msgstr ""
"시설(facility)과 우선순위를 정수로 인코딩합니다. 문자열이나 정수를 전달할 수 있습니다 - 문자열이 전달되면, 내부 매핑 "
"딕셔너리를 사용하여 정수로 변환합니다."

#: ../../library/logging.handlers.rst:699
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"``LOG_`` 기호 값은 :class:`SysLogHandler`\\에 정의되고 ``sys/syslog.h`` 헤더 파일에 정의된"
" 값을 그대로 옮깁니다."

#: ../../library/logging.handlers.rst:702
msgid "**Priorities**"
msgstr "**우선순위**"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Name (string)"
msgstr "이름 (문자열)"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Symbolic value"
msgstr "기호 값"

#: ../../library/logging.handlers.rst:707
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:707
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:709
msgid "``crit`` or ``critical``"
msgstr "``crit`` 또는 ``critical``"

#: ../../library/logging.handlers.rst:709
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:711
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:711
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:713
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` 또는 ``panic``"

#: ../../library/logging.handlers.rst:713
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:715
msgid "``err`` or ``error``"
msgstr "``err`` 또는 ``error``"

#: ../../library/logging.handlers.rst:715
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:717
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:717
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:719
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:719
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:721
msgid "``warn`` or ``warning``"
msgstr "``warn`` 또는 ``warning``"

#: ../../library/logging.handlers.rst:721
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:724
msgid "**Facilities**"
msgstr "**시설**"

#: ../../library/logging.handlers.rst:729
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:729
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:731
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:731
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:733
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:733
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:735
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:735
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:737
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:737
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:739
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:739
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:741
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:741
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:743
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:743
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:745
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:745
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:747
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:747
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:749
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:749
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:751
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:751
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:753
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:753
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:755
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:755
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:757
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:757
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:759
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:759
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:761
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:761
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:763
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:763
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:765
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:765
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:767
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:767
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:772
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm"
" is not suitable for your needs. The default algorithm maps ``DEBUG``, "
"``INFO``, ``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent "
"syslog names, and all other level names to 'warning'."
msgstr ""
"로깅 수준 이름을 syslog 우선순위 이름으로 매핑합니다. 사용자 정의 수준을 사용하거나 기본 알고리즘이 여러분의 요구에 적합하지"
" 않으면, 이 값을 재정의해야 할 수 있습니다. 기본 알고리즘은 ``DEBUG``, ``INFO``, ``WARNING``, "
"``ERROR`` 및 ``CRITICAL``\\을 동등한 syslog 이름으로 매핑하고, 다른 모든 수준 이름은 "
"'warning'으로 매핑합니다."

#: ../../library/logging.handlers.rst:782
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:784
msgid ""
"The :class:`NTEventLogHandler` class, located in the "
":mod:`logging.handlers` module, supports sending logging messages to a "
"local Windows NT, Windows 2000 or Windows XP event log. Before you can "
"use it, you need Mark Hammond's Win32 extensions for Python installed."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`NTEventLogHandler` 클래스는 로깅 메시지를 로컬"
" 윈도우 NT, 윈도우 2000 또는 윈도우 XP 이벤트 로그로 보내는 것을 지원합니다. 사용할 수 있으려면 먼저 Mark "
"Hammond의 파이썬 용 Win32 확장이 설치되어 있어야 합니다."

#: ../../library/logging.handlers.rst:792
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the "
"event log. An appropriate registry entry is created using this name. The "
"*dllname* should give the fully qualified pathname of a .dll or .exe "
"which contains message definitions to hold in the log (if not specified, "
"``'win32service.pyd'`` is used - this is installed with the Win32 "
"extensions and contains some basic placeholder message definitions. Note "
"that use of these placeholders will make your event logs big, as the "
"entire message source is held in the log. If you want slimmer logs, you "
"have to pass in the name of your own .dll or .exe which contains the "
"message definitions you want to use in the event log). The *logtype* is "
"one of ``'Application'``, ``'System'`` or ``'Security'``, and defaults to"
" ``'Application'``."
msgstr ""
":class:`NTEventLogHandler` 클래스의 새 인스턴스를 반환합니다. *appname* 은 이벤트 로그에 나타나는 "
"응용 프로그램 이름을 정의하는 데 사용됩니다. 이 이름을 사용하여 적절한 레지스트리 항목이 만들어집니다. *dllname* 은 "
"로그에 보관할 메시지 정의를 포함하는 .dll 또는 .exe의 완전히 정규화된 경로명을 제공해야 합니다 (지정되지 않으면, "
"``'win32service.pyd'``\\이 사용됩니다 - 이것은 Win32 확장과 함께 설치되며 몇 가지 기본 자리 표시자 "
"메시지 정의를 포함합니다. 이 자리 표시자를 사용하면 전체 메시지 소스가 로그에 보관되므로 이벤트 로그가 커진다는 것에 "
"유의하십시오. 간략한 로그를 원하면, 이벤트 로그에서 사용할 원하는 메시지 정의가 포함된 .dll 또는 .exe의 이름을 전달해야 "
"합니다). *logtype* 은 ``'Application'``, ``'System'`` 또는 ``'Security'`` 중 "
"하나이며, 기본값은 ``'Application'``\\입니다."

#: ../../library/logging.handlers.rst:808
msgid ""
"At this point, you can remove the application name from the registry as a"
" source of event log entries. However, if you do this, you will not be "
"able to see the events as you intended in the Event Log Viewer - it needs"
" to be able to access the registry to get the .dll name. The current "
"version does not do this."
msgstr ""
"이 시점에서, 이벤트 로그 항목의 소스로서의 응용 프로그램 이름을 레지스트리에서 제거할 수 있습니다. 그러나, 이렇게 하면, 이벤트"
" 로그 뷰어에서 의도한 대로 이벤트를 볼 수 없게 됩니다 - 이벤트 로그 뷰어는 .dll 이름을 가져오기 위해 레지스트리에 액세스할"
" 수 있어야 합니다. 현재 버전은 그렇게 하지 않습니다."

#: ../../library/logging.handlers.rst:817
msgid ""
"Determines the message ID, event category and event type, and then logs "
"the message in the NT event log."
msgstr "메시지 ID, 이벤트 범주 및 이벤트 유형을 결정한 다음, 메시지를 NT 이벤트 로그에 기록합니다."

#: ../../library/logging.handlers.rst:823
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr "레코드의 이벤트 범주를 반환합니다. 여러분 자신의 범주를 지정하려면, 이것을 재정의하십시오. 이 버전은 0을 반환합니다."

#: ../../library/logging.handlers.rst:829
msgid ""
"Returns the event type for the record. Override this if you want to "
"specify your own types. This version does a mapping using the handler's "
"typemap attribute, which is set up in :meth:`__init__` to a dictionary "
"which contains mappings for :const:`DEBUG`, :const:`INFO`, "
":const:`WARNING`, :const:`ERROR` and :const:`CRITICAL`. If you are using "
"your own levels, you will either need to override this method or place a "
"suitable dictionary in the handler's *typemap* attribute."
msgstr ""
"레코드의 이벤트 유형을 반환합니다. 여러분 자신의 유형을 지정하려면, 이것을 재정의하십시오. 이 버전은 처리기의 typemap "
"어트리뷰트를 사용하여 매핑하는데, :meth:`__init__`\\에서 :const:`DEBUG`, :const:`INFO`, "
":const:`WARNING`, :const:`ERROR` 및 :const:`CRITICAL`\\에 대한 매핑이 포함된 딕셔너리로 "
"설정됩니다. 여러분 자신의 수준을 사용한다면, 이 메서드를 재정의하거나 처리기의 *typemap* 어트리뷰트에 적절한 딕셔너리를 "
"배치해야 합니다."

#: ../../library/logging.handlers.rst:840
msgid ""
"Returns the message ID for the record. If you are using your own "
"messages, you could do this by having the *msg* passed to the logger "
"being an ID rather than a format string. Then, in here, you could use a "
"dictionary lookup to get the message ID. This version returns 1, which is"
" the base message ID in :file:`win32service.pyd`."
msgstr ""
"레코드의 메시지 ID를 반환합니다. 여러분 자신의 메시지를 사용한다면, 로거에 전달된 *msg*\\를 포맷 문자열이 아닌 ID로 "
"사용할 수 있습니다. 그런 다음 여기에서 딕셔너리 조회를 사용하여 메시지 ID를 가져올 수 있습니다. 이 버전은 "
":file:`win32service.pyd`\\의 기본 메시지 ID인 1을 반환합니다."

#: ../../library/logging.handlers.rst:849
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:851
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`SMTPHandler` 클래스는 SMTP를 통해 전자 메일 "
"주소로 로깅 메시지를 보내는 것을 지원합니다."

#: ../../library/logging.handlers.rst:857
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is"
" initialized with the from and to addresses and subject line of the "
"email. The *toaddrs* should be a list of strings. To specify a non-"
"standard SMTP port, use the (host, port) tuple format for the *mailhost* "
"argument. If you use a string, the standard SMTP port is used. If your "
"SMTP server requires authentication, you can specify a (username, "
"password) tuple for the *credentials* argument."
msgstr ""
":class:`SMTPHandler` 클래스의 새 인스턴스를 반환합니다. 인스턴스는 전자 메일의 보내는 주소, 받는 주소와 제목 "
"줄을 사용하여 초기화됩니다. *toaddrs* 는 문자열 리스트여야 합니다. 비표준 SMTP 포트를 지정하려면, *mailhost*"
" 인자에 (host, port) 튜플 형식을 사용하십시오. 문자열을 사용하면 표준 SMTP 포트가 사용됩니다. SMTP 서버가 "
"인증을 요구하면, *credentials* 인자에 (username, password) 튜플을 지정할 수 있습니다."

#: ../../library/logging.handlers.rst:864
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials"
" are supplied. The tuple should be either an empty tuple, or a single-"
"value tuple with the name of a keyfile, or a 2-value tuple with the names"
" of the keyfile and certificate file. (This tuple is passed to the "
":meth:`smtplib.SMTP.starttls` method.)"
msgstr ""
"보안 프로토콜(TLS)의 사용을 지정하려면, *secure* 인자에 튜플을 전달하십시오. 이것은 인증 자격 "
"증명(credentials)이 제공될 때만 사용됩니다. 튜플은 빈 튜플이거나, 키 파일 이름을 가진 단일 값 튜플이거나, 키 파일과"
" 인증서 파일의 이름을 가진 2-튜플이어야 합니다. (이 튜플은 :meth:`smtplib.SMTP.starttls` 메서드에 "
"전달됩니다.)"

#: ../../library/logging.handlers.rst:871
msgid ""
"A timeout can be specified for communication with the SMTP server using "
"the *timeout* argument."
msgstr "*timeout* 인자를 사용하여 SMTP 서버와의 통신에 시간제한을 지정할 수 있습니다."

#: ../../library/logging.handlers.rst:874
#, fuzzy
msgid "Added the *timeout* parameter."
msgstr "*timeout* 인자가 추가되었습니다."

#: ../../library/logging.handlers.rst:879
msgid "Formats the record and sends it to the specified addressees."
msgstr "레코드를 포맷하고 지정된 주소로 보냅니다."

#: ../../library/logging.handlers.rst:884
msgid ""
"If you want to specify a subject line which is record-dependent, override"
" this method."
msgstr "레코드에 종속적인 제목 줄을 지정하려면, 이 메서드를 재정의하십시오."

#: ../../library/logging.handlers.rst:890
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:892
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is "
"seen."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`MemoryHandler` 클래스는 메모리에 로깅 레코드를 "
"버퍼링하고, 주기적으로 :dfn:`대상 (target)` 처리기로 플러시 하는 것을 지원합니다. 플러시는 버퍼가 꽉 찼거나 특정 "
"심각도 이상의 이벤트가 발생할 때마다 발생합니다."

#: ../../library/logging.handlers.rst:897
msgid ""
":class:`MemoryHandler` is a subclass of the more general "
":class:`BufferingHandler`, which is an abstract class. This buffers "
"logging records in memory. Whenever each record is added to the buffer, a"
" check is made by calling :meth:`shouldFlush` to see if the buffer should"
" be flushed.  If it should, then :meth:`flush` is expected to do the "
"flushing."
msgstr ""
":class:`MemoryHandler`\\는 추상 클래스이면서, 더 일반적인 :class:`BufferingHandler`\\의 "
"서브 클래스입니다. 이것은 레코드 로깅을 메모리에 버퍼링합니다. 각 레코드가 버퍼에 추가될 때마다, "
":meth:`shouldFlush`\\를 호출하여 버퍼를 플러시 할지 확인합니다. 필요하면, :meth:`flush`\\가 플러시를"
" 수행할 것으로 기대합니다."

#: ../../library/logging.handlers.rst:906
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"지정된 용량(capacity)의 버퍼로 처리기를 초기화합니다. 여기서 *capacity*\\는 버퍼링 된 로깅 레코드 수를 "
"의미합니다."

#: ../../library/logging.handlers.rst:912
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, "
"call :meth:`flush` to process the buffer."
msgstr ""
"레코드를 버퍼에 추가합니다. :meth:`shouldFlush`\\가 참을 반환하면 :meth:`flush`\\를 호출하여 버퍼를 "
"처리합니다."

#: ../../library/logging.handlers.rst:918
msgid ""
"For a :class:`BufferingHandler` instance, flushing means that it sets the"
" buffer to an empty list. This method can be overwritten to implement "
"more useful flushing behavior."
msgstr ""

#: ../../library/logging.handlers.rst:925
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr "버퍼의 용량이 찼으면 ``True``\\를 반환합니다. 이 메서드는 사용자 정의 플러시 전략을 구현하기 위해 재정의될 수 있습니다."

#: ../../library/logging.handlers.rst:931
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance "
"is initialized with a buffer size of *capacity* (number of records "
"buffered). If *flushLevel* is not specified, :const:`ERROR` is used. If "
"no *target* is specified, the target will need to be set using "
":meth:`setTarget` before this handler does anything useful. If "
"*flushOnClose* is specified as ``False``, then the buffer is *not* "
"flushed when the handler is closed. If not specified or specified as "
"``True``, the previous behaviour of flushing the buffer will occur when "
"the handler is closed."
msgstr ""
":class:`MemoryHandler` 클래스의 새 인스턴스를 반환합니다. 인스턴스는 *capacity*\\(버퍼 된 레코드 "
"수)의 버퍼 크기로 초기화됩니다. *flushLevel*\\을 지정하지 않으면, :const:`ERROR`\\가 사용됩니다. "
"*target* 이 지정되지 않으면, 이 처리기가 유용한 것을 하기 전에, :meth:`setTarget`\\를 사용해 대상을 "
"설정할 필요가 있습니다. *flushOnClose* 가 ``False``\\로 지정되면, 처리기가 닫힐 때 버퍼가 플러시 되지 "
"*않습니다*. 지정되지 않거나 ``True``\\로 지정되면, 처리기가 닫힐 때 버퍼를 플러시 하는 이전 동작이 발생합니다."

#: ../../library/logging.handlers.rst:940
msgid "The *flushOnClose* parameter was added."
msgstr "*flushOnClose* 매개 변수가 추가되었습니다."

#: ../../library/logging.handlers.rst:946
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ":meth:`flush`\\를 호출하고, 대상(target)을 ``None``\\으로 설정하고, 버퍼를 비웁니다."

#: ../../library/logging.handlers.rst:952
#, fuzzy
msgid ""
"For a :class:`MemoryHandler` instance, flushing means just sending the "
"buffered records to the target, if there is one. The buffer is also "
"cleared when buffered records are sent to the target. Override if you "
"want different behavior."
msgstr ""
":class:`MemoryHandler`\\의 경우, 플러시는 버퍼링 된 레코드가 있다면 대상으로 보내는 것을 뜻합니다. 이때 "
"버퍼도 지워집니다. 다른 행동을 원하면 재정의하십시오."

#: ../../library/logging.handlers.rst:959
msgid "Sets the target handler for this handler."
msgstr "이 처리기의 대상 처리기를 설정합니다."

#: ../../library/logging.handlers.rst:964
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr "버퍼 가득 참이나 레코드가 *flushLevel* 이상을 만드는지 확인합니다."

#: ../../library/logging.handlers.rst:970
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:972
#, fuzzy
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`HTTPHandler` 클래스는 ``GET`` 또는 "
"``POST`` 를 사용해서 로깅 메시지를 웹 서버로 보내는 것을 지원합니다."

#: ../../library/logging.handlers.rst:979
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can "
"be of the form ``host:port``, should you need to use a specific port "
"number.  If no *method* is specified, ``GET`` is used. If *secure* is "
"true, a HTTPS connection will be used. The *context* parameter may be set"
" to a :class:`ssl.SSLContext` instance to configure the SSL settings used"
" for the HTTPS connection. If *credentials* is specified, it should be a "
"2-tuple consisting of userid and password, which will be placed in a HTTP"
" 'Authorization' header using Basic authentication. If you specify "
"credentials, you should also specify secure=True so that your userid and "
"password are not passed in cleartext across the wire."
msgstr ""
":class:`HTTPHandler` 클래스의 새 인스턴스를 반환합니다. *host* 는 특정 포트 번호를 사용해야 하면 "
"``host:port`` 형식일 수 있습니다. *method* 를 지정하지 않으면 ``GET``\\이 사용됩니다. *secure* "
"가 참이면, HTTPS 연결이 사용됩니다. *context* 매개 변수는 :class:`ssl.SSLContext` 인스턴스로 "
"설정되어, HTTPS 연결에 사용되는 SSL 설정을 구성할 수 있습니다. *credentials* 가 지정되면, 기본 인증을 "
"사용하여 HTTP 'Authorization' 헤더에 배치되는 사용자 ID와 암호로 구성된 2-튜플이어야 합니다. "
"credentials를 지정하면, 사용자 ID와 암호가 단순 텍스트로 전달되지 않도록 secure=True를 지정해야 합니다."

#: ../../library/logging.handlers.rst:990
msgid "The *context* parameter was added."
msgstr "*context* 매개 변수가 추가되었습니다."

#: ../../library/logging.handlers.rst:995
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded "
"and sent to the web server. The default implementation just returns "
"``record.__dict__``. This method can be overridden if e.g. only a subset "
"of :class:`~logging.LogRecord` is to be sent to the web server, or if "
"more specific customization of what's sent to the server is required."
msgstr ""
"URL 인코딩되어 웹 서버로 전송되는, ``record``\\에 기반한 딕셔너리를 제공합니다. 기본 구현은 "
"``record.__dict__``\\를 반환합니다. 이 메서드는 재정의할 수 있는데, 예를 들어 "
":class:`~logging.LogRecord`\\의 일부만 웹 서버로 보내지거나, 서버로 보내는 내용에 대한 보다 구체적인 "
"사용자 정의가 필요한 경우입니다."

#: ../../library/logging.handlers.rst:1003
#, fuzzy
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The "
":meth:`mapLogRecord` method is used to convert the record to the "
"dictionary to be sent."
msgstr ""
"URL 인코딩된 딕셔너리로 웹 서버에 레코드를 보냅니다. :meth:`mapLogRecord` 메서드가 레코드를 전송할 딕셔너리로 "
"변환하는 데 사용됩니다."

#: ../../library/logging.handlers.rst:1007
#, fuzzy
msgid ""
"Since preparing a record for sending it to a web server is not the same "
"as a generic formatting operation, using "
":meth:`~logging.Handler.setFormatter` to specify a "
":class:`~logging.Formatter` for a :class:`HTTPHandler` has no effect. "
"Instead of calling :meth:`~logging.Handler.format`, this handler calls "
":meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""
"웹 서버로 보내기 위해 레코드를 준비하는 것은, 일반 포매팅 연산과 같지 않으므로, "
":meth:`~logging.Handler.setFormatter`\\를 사용해서 :class:`HTTPHandler`\\의 "
":class:`~logging.Formatter`\\를 지정하는 것은 효과가 없습니다. "
":meth:`~logging.Handler.format`\\을 호출하는 대신, 이 처리기는 "
":meth:`mapLogRecord`\\를 호출한 다음, :func:`urllib.parse.urlencode`\\를 호출하여 웹 "
"서버로 보내기에 적합한 형식으로 딕셔너리를 인코딩합니다."

#: ../../library/logging.handlers.rst:1020
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:1024
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`QueueHandler` 클래스는, :mod:`queue` 나"
" :mod:`multiprocessing` 모듈에 구현된 것과 같은 큐에 로깅 메시지를 보내는 것을 지원합니다."

#: ../../library/logging.handlers.rst:1028
#, fuzzy
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be"
" used to let handlers do their work on a separate thread from the one "
"which does the logging. This is important in web applications and also "
"other service applications where threads servicing clients need to "
"respond as quickly as possible, while any potentially slow operations "
"(such as sending an email via :class:`SMTPHandler`) are done on a "
"separate thread."
msgstr ""
":class:`QueueListener` 클래스와 함께, :class:`QueueHandler`\\를 사용하여 처리기가 로깅을 "
"수행하는 스레드와 다른 스레드에서 작업을 수행하도록 할 수 있습니다. 이는 클라이언트를 처리하는 스레드가 가능한 한 신속하게 "
"응답하고, 느린 작업(가령 :class:`SMTPHandler`\\를 통해 전자 메일 보내기)은 별도의 스레드에서 수행되어야 하는 "
"웹 응용 프로그램과 다른 서비스 응용 프로그램에서 중요합니다."

#: ../../library/logging.handlers.rst:1037
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance "
"is initialized with the queue to send messages to. The *queue* can be any"
" queue-like object; it's used as-is by the :meth:`enqueue` method, which "
"needs to know how to send messages to it. The queue is not *required* to "
"have the task tracking API, which means that you can use "
":class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
":class:`QueueHandler` 클래스의 새 인스턴스를 반환합니다. 인스턴스는 메시지를 보낼 큐로 초기화됩니다. "
"*queue*\\는 임의의 큐류(queue-like) 객체일 수 있습니다; 메시지를 보내는 방법을 알아야 하는 "
":meth:`enqueue` 메서드가 있는 그대로 사용합니다. 큐는 작업 추적 API를 갖도록 *요구되지* 않아서, "
"*queue*\\에 :class:`~queue.SimpleQueue` 인스턴스를 사용할 수 있습니다."

#: ../../library/logging.handlers.rst:1044
#: ../../library/logging.handlers.rst:1133
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using "
":class:`~queue.SimpleQueue` and instead use "
":class:`multiprocessing.Queue`."
msgstr ""

#: ../../library/logging.handlers.rst:1049
#, fuzzy
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur"
" (e.g. because a bounded queue has filled up), the "
":meth:`~logging.Handler.handleError` method is called to handle the "
"error. This can result in the record silently being dropped (if "
":data:`logging.raiseExceptions` is ``False``) or a message printed to "
"``sys.stderr`` (if :data:`logging.raiseExceptions` is ``True``)."
msgstr ""
"LogRecord를 준비한 결과를 큐에 넣습니다. 예외가 발생하면 (예를 들어, 유한(bounded) 큐가 다 차서), "
":meth:`~logging.Handler.handleError` 메서드가 호출되어 에러를 처리합니다. 이로 인해 레코드가 조용히 "
"버려지거나 (:attr:`logging.raiseExceptions`\\가 ``False`` 인 경우), 메시지가 "
"``sys.stderr``\\에 인쇄됩니다 (:attr:`logging.raiseExceptions`\\가 ``True`` 인 "
"경우)."

#: ../../library/logging.handlers.rst:1058
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr "큐에 넣기 위해 레코드를 준비합니다. 이 메서드에 의해 반환된 객체는 큐에 들어갑니다."

#: ../../library/logging.handlers.rst:1061
msgid ""
"The base implementation formats the record to merge the message, "
"arguments, exception and stack information, if present.  It also removes "
"unpickleable items from the record in-place. Specifically, it overwrites "
"the record's :attr:`msg` and :attr:`message` attributes with the merged "
"message (obtained by calling the handler's :meth:`format` method), and "
"sets the :attr:`args`, :attr:`exc_info` and :attr:`exc_text` attributes "
"to ``None``."
msgstr ""

#: ../../library/logging.handlers.rst:1069
msgid ""
"You might want to override this method if you want to convert the record "
"to a dict or JSON string, or send a modified copy of the record while "
"leaving the original intact."
msgstr ""
"레코드를 dict 나 JSON 문자열로 변환하거나, 원본을 그대로 두고 레코드의 수정 된 복사본을 보내길 원한다면 이 메서드를 "
"재정의할 수 있습니다."

#: ../../library/logging.handlers.rst:1073
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to"
" prevent further attempts at formatting. This means that a handler on the"
" :class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler``"
" and override this method to e.g. avoid setting ``exc_text`` to ``None``."
" Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note"
" that you may have to consider not only your own code but also code in "
"any libraries that you use.)"
msgstr ""

#: ../../library/logging.handlers.rst:1089
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"``put_nowait()``\\를 사용하여 큐에 레코드를 넣습니다; 블로킹 동작이나 시간제한이나, 사용자 정의 큐 구현을 "
"사용하려면 이 메서드를 재정의할 수 있습니다."

#: ../../library/logging.handlers.rst:1095
msgid ""
"When created via configuration using :func:`~logging.config.dictConfig`, "
"this attribute will contain a :class:`QueueListener` instance for use "
"with this handler. Otherwise, it will be ``None``."
msgstr ""

#: ../../library/logging.handlers.rst:1104
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1108
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on "
"the same thread, to one or more handlers for processing. While "
":class:`QueueListener` is not itself a handler, it is documented here "
"because it works hand-in-hand with :class:`QueueHandler`."
msgstr ""
":mod:`logging.handlers` 모듈에 있는 :class:`QueueListener` 클래스는 :mod:`queue` 나"
" :mod:`multiprocessing` 모듈에 구현된 것과 같은 큐에서 로깅 메시지를 수신하는 것을 지원합니다. 메시지는 내부 "
"스레드의 큐에서 수신되고 처리를 위해 같은 스레드에서 하나 이상의 처리기로 전달됩니다. :class:`QueueListener` "
"자체는 처리기가 아니지만, :class:`QueueHandler` 와 함께 사용되기 때문에 여기에 설명되어 있습니다."

#: ../../library/logging.handlers.rst:1116
#, fuzzy
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be"
" used to let handlers do their work on a separate thread from the one "
"which does the logging. This is important in web applications and also "
"other service applications where threads servicing clients need to "
"respond as quickly as possible, while any potentially slow operations "
"(such as sending an email via :class:`SMTPHandler`) are done on a "
"separate thread."
msgstr ""
":class:`QueueHandler` 클래스와 함께, :class:`QueueListener`\\를 사용하여 처리기가 로깅을 "
"수행하는 스레드와 다른 스레드에서 작업을 수행하도록 할 수 있습니다. 이는 클라이언트를 처리하는 스레드가 가능한 한 신속하게 "
"응답하고, 느린 작업(가령 :class:`SMTPHandler`\\를 통해 전자 메일 보내기)은 별도의 스레드에서 수행되어야 하는 "
"웹 응용 프로그램과 다른 서비스 응용 프로그램에서 중요합니다."

#: ../../library/logging.handlers.rst:1125
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance "
"is initialized with the queue to send messages to and a list of handlers "
"which will handle entries placed on the queue. The queue can be any "
"queue-like object; it's passed as-is to the :meth:`dequeue` method, which"
" needs to know how to get messages from it. The queue is not *required* "
"to have the task tracking API (though it's used if available), which "
"means that you can use :class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
":class:`QueueListener` 클래스의 새 인스턴스를 반환합니다. 인스턴스는 메시지를 보내는 큐와 큐에 있는 항목을 "
"처리할 처리기의 리스트로 초기화됩니다. 큐는 임의의 큐류(queue-like) 객체일 수 있습니다; 메시지를 꺼내는 방법을 알아야 "
"하는 :meth:`dequeue` 메서드가 있는 그대로 사용합니다. 큐는 작업 추적 API를 갖도록 *요구되지* 않아서 (가능하면 "
"사용됩니다), *queue*\\에 :class:`~queue.SimpleQueue` 인스턴스를 사용할 수 있습니다."

#: ../../library/logging.handlers.rst:1136
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous "
"Python versions - to always pass each message to each handler."
msgstr ""
"``respect_handler_level``\\이 ``True`` 면, 처리기에 메시지를 전달할지를 결정할 때, 처리기의 수준이 "
"존중됩니다 (메시지의 수준과 비교); 그렇지 않으면, 이전 파이썬 버전과 같게 동작합니다 - 항상 각 메시지를 모든 처리기에 "
"전달합니다."

#: ../../library/logging.handlers.rst:1141
msgid "The ``respect_handler_level`` argument was added."
msgstr "``respect_handler_level`` 인자가 추가되었습니다."

#: ../../library/logging.handlers.rst:1146
msgid "Dequeues a record and return it, optionally blocking."
msgstr "레코드를 큐에서 꺼내 반환합니다. 선택적으로 블록 됩니다."

#: ../../library/logging.handlers.rst:1148
msgid ""
"The base implementation uses ``get()``. You may want to override this "
"method if you want to use timeouts or work with custom queue "
"implementations."
msgstr ""
"기본 구현은 ``get()``\\을 사용합니다. 시간제한을 사용하거나 사용자 정의 큐 구현을 사용하려면 이 메서드를 재정의할 수 "
"있습니다."

#: ../../library/logging.handlers.rst:1154
msgid "Prepare a record for handling."
msgstr "처리를 위해 레코드를 준비합니다."

#: ../../library/logging.handlers.rst:1156
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"이 구현은 단지 전달된 레코드를 반환합니다. 사용자 정의 직렬화를 수행하거나 처리기에 전달하기 전에 레코드를 조작해야 하면, 이 "
"메서드를 재정의할 수 있습니다."

#: ../../library/logging.handlers.rst:1162
msgid "Handle a record."
msgstr "레코드를 처리합니다."

#: ../../library/logging.handlers.rst:1164
msgid ""
"This just loops through the handlers offering them the record to handle. "
"The actual object passed to the handlers is that which is returned from "
":meth:`prepare`."
msgstr "이것은 단지 모든 처리기로 레코드를 제공합니다. 처리기에 전달되는 실제 객체는 :meth:`prepare`\\에서 반환된 객체입니다."

#: ../../library/logging.handlers.rst:1170
msgid "Starts the listener."
msgstr "수신기를 시작합니다."

#: ../../library/logging.handlers.rst:1172
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to"
" process."
msgstr "이것은 처리하기 위해 큐에서 LogRecord를 관찰하는 배경 스레드를 시작합니다."

#: ../../library/logging.handlers.rst:1175
msgid "Raises :exc:`RuntimeError` if called and the listener is already running."
msgstr ""

#: ../../library/logging.handlers.rst:1181
msgid "Stops the listener."
msgstr "수신기를 정지합니다."

#: ../../library/logging.handlers.rst:1183
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note "
"that if you don't call this before your application exits, there may be "
"some records still left on the queue, which won't be processed."
msgstr ""
"스레드가 종료하도록 요청한 다음, 스레드가 종료할 때까지 대기합니다. 응용 프로그램이 종료되기 전에 이 함수를 호출하지 않으면, "
"레코드가 큐에 남아있을 수 있고, 이것들은 처리되지 않습니다."

#: ../../library/logging.handlers.rst:1189
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this "
"method if you want to use timeouts or work with custom queue "
"implementations."
msgstr ""
"수신자에게 종료하도록 알리기 위해 큐에 종료 신호(sentinel)를 씁니다. 이 구현은 ``put_nowait()``\\를 "
"사용합니다. 시간제한을 사용하거나 사용자 정의 큐 구현을 사용하려면 이 메서드를 재정의할 수 있습니다."

#: ../../library/logging.handlers.rst:1199
msgid "Module :mod:`logging`"
msgstr "모듈 :mod:`logging`"

#: ../../library/logging.handlers.rst:1200
msgid "API reference for the logging module."
msgstr "logging 모듈에 관한 API 레퍼런스."

#: ../../library/logging.handlers.rst:1202
msgid "Module :mod:`logging.config`"
msgstr "모듈 :mod:`logging.config`"

#: ../../library/logging.handlers.rst:1203
msgid "Configuration API for the logging module."
msgstr "logging 모듈용 구성 API."

#~ msgid ""
#~ "You can override this to implement "
#~ "custom flushing behavior. This version "
#~ "just zaps the buffer to empty."
#~ msgstr "사용자 정의 플러시 동작을 구현하기 위해 재정의할 수 있습니다. 이 버전은 버퍼를 비우기만 합니다."

#~ msgid ""
#~ "The base implementation formats the "
#~ "record to merge the message, arguments,"
#~ " and exception information, if present."
#~ "  It also removes unpickleable items "
#~ "from the record in-place."
#~ msgstr ""
#~ "기본 구현은 메시지, 인자와 있다면 예외 정보를 "
#~ "병합하도록 레코드를 포맷합니다. 또한, 역 피클 할 "
#~ "수 없는 항목들을 레코드에서 직접(in-place) "
#~ "제거합니다."

