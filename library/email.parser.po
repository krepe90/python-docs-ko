# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/email.parser.rst:2
#, fuzzy
msgid ":mod:`!email.parser`: Parsing email messages"
msgstr ":mod:`email.parser`: 전자 메일 메시지 구문 분석"

#: ../../library/email.parser.rst:7
msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**소스 코드:** :source:`Lib/email/parser.py`"

#: ../../library/email.parser.rst:11
msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by creating an "
":class:`~email.message.EmailMessage` object, adding headers using the "
"dictionary interface, and adding payload(s) using "
":meth:`~email.message.EmailMessage.set_content` and related methods, or "
"they can be created by parsing a serialized representation of the email "
"message."
msgstr ""
"메시지 객체 구조는 두 가지 방법으로 만들 수 있습니다: :class:`~email.message.EmailMessage` 객체를 "
"만들고, 딕셔너리 인터페이스를 사용하여 헤더를 추가하고, "
":meth:`~email.message.EmailMessage.set_content`\\와 관련 메서드를 사용하여 페이 로드를 "
"추가하여 아예 새로 만들 수 있습니다. 또는 전자 메일 메시지의 직렬화된 표현을 구문 분석해서 만들 수 있습니다."

#: ../../library/email.parser.rst:18
msgid ""
"The :mod:`email` package provides a standard parser that understands most"
" email document structures, including MIME documents.  You can pass the "
"parser a bytes, string or file object, and the parser will return to you "
"the root :class:`~email.message.EmailMessage` instance of the object "
"structure.  For simple, non-MIME messages the payload of this root object"
" will likely be a string containing the text of the message.  For MIME "
"messages, the root object will return ``True`` from its "
":meth:`~email.message.EmailMessage.is_multipart` method, and the subparts"
" can be accessed via the payload manipulation methods, such as "
":meth:`~email.message.EmailMessage.get_body`, "
":meth:`~email.message.EmailMessage.iter_parts`, and "
":meth:`~email.message.EmailMessage.walk`."
msgstr ""
":mod:`email` 패키지는 MIME 문서를 포함한 대부분의 전자 우편 문서 구조를 이해하는 표준 구문 분석기를 제공합니다. "
"구문 분석기에 바이트열, 문자열 또는 파일 객체를 전달하면 구문 분석기가 객체 구조의 루트 "
":class:`~email.message.EmailMessage` 인스턴스를 반환합니다. MIME이 아닌 간단한 메시지의 경우 이 "
"루트 객체의 페이 로드는 메시지의 텍스트를 포함하는 문자열일 수 있습니다. MIME 메시지의 경우 루트 객체는 "
":meth:`~email.message.EmailMessage.is_multipart` 메서드가 ``True``\\를 반환하고, "
":meth:`~email.message.EmailMessage.get_body`, "
":meth:`~email.message.EmailMessage.iter_parts` 및 "
":meth:`~email.message.EmailMessage.walk`\\와 같은 페이 로드 조작 메서드를 통해 서브 파트에 "
"액세스 할 수 있습니다."

#: ../../library/email.parser.rst:30
msgid ""
"There are actually two parser interfaces available for use, the "
":class:`Parser` API and the incremental :class:`FeedParser` API.  The "
":class:`Parser` API is most useful if you have the entire text of the "
"message in memory, or if the entire message lives in a file on the file "
"system.  :class:`FeedParser` is more appropriate when you are reading the"
" message from a stream which might block waiting for more input (such as "
"reading an email message from a socket).  The :class:`FeedParser` can "
"consume and parse the message incrementally, and only returns the root "
"object when you close the parser."
msgstr ""
"실제로 사용 가능한 두 가지 구문 분석기 인터페이스가 있습니다, :class:`Parser` API와 증분 "
":class:`FeedParser` API. :class:`Parser` API는 메시지의 전체 텍스트가 메모리에 있거나 전체 "
"메시지가 파일 시스템의 파일에 있을 때 가장 유용합니다. 더 많은 입력을 기다리기 위해 블록할 수 있는 스트림에서 메시지를 읽을 "
"때는 :class:`FeedParser`\\가 더 적합합니다 (가령 소켓에서 전자 메일 메시지를 읽을 때). "
":class:`FeedParser`\\는 메시지를 증분 적으로 소비하고 구문 분석 할 수 있으며, 구문 분석기를 닫을 때만 루트 "
"객체를 반환합니다."

#: ../../library/email.parser.rst:39
#, fuzzy
msgid ""
"Note that the parser can be extended in limited ways, and of course you "
"can implement your own parser completely from scratch.  All of the logic "
"that connects the :mod:`email` package's bundled parser and the "
":class:`~email.message.EmailMessage` class is embodied in the "
":class:`~email.policy.Policy` class, so a custom parser can create "
"message object trees any way it finds necessary by implementing custom "
"versions of the appropriate :class:`!Policy` methods."
msgstr ""
"구문 분석기는 제한적인 방식으로 확장될 수 있음에 유의하십시오. 물론 구문 분석기는 처음부터 새로 구현할 수 있습니다. "
":mod:`email` 패키지에 포함된 구문 분석기와 :class:`~email.message.EmailMessage` 클래스를 "
"연결하는 모든 로직은 :mod:`policy` 클래스에 내장되므로, 사용자 정의 구문 분석기는 적절한 :mod:`policy` "
"메서드의 사용자 정의 버전을 구현하여 필요한 방식으로 메시지 객체 트리를 만들 수 있습니다."

#: ../../library/email.parser.rst:49
msgid "FeedParser API"
msgstr "FeedParser API"

#: ../../library/email.parser.rst:51
msgid ""
"The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` "
"module, provides an API that is conducive to incremental parsing of email"
" messages, such as would be necessary when reading the text of an email "
"message from a source that can block (such as a socket).  The "
":class:`BytesFeedParser` can of course be used to parse an email message "
"fully contained in a :term:`bytes-like object`, string, or file, but the "
":class:`BytesParser` API may be more convenient for such use cases.  The "
"semantics and results of the two parser APIs are identical."
msgstr ""
":mod:`email.feedparser` 모듈에서 임포트 한 :class:`BytesFeedParser`\\는 전자 메일 메시지의"
" 증분 구문 분석에 도움이 되는 API를 제공합니다. 블록할 수 있는 소스(가령 소켓)에서 전자 메일 메시지의 텍스트를 읽을 때 "
"필요합니다. 물론 :class:`BytesFeedParser`\\는 :term:`바이트열류 객체 <bytes-like "
"object>`, 문자열 또는 파일에 완전히 포함된 전자 메일 메시지를 구문 분석하는 데 사용될 수 있지만, "
":class:`BytesParser` API가 이러한 사용 사례에서는 더 편리 할 수 있습니다. 두 구문 분석기 API의 의미와 "
"결과는 같습니다."

#: ../../library/email.parser.rst:60
msgid ""
"The :class:`BytesFeedParser`'s API is simple; you create an instance, "
"feed it a bunch of bytes until there's no more to feed it, then close the"
" parser to retrieve the root message object.  The "
":class:`BytesFeedParser` is extremely accurate when parsing standards-"
"compliant messages, and it does a very good job of parsing non-compliant "
"messages, providing information about how a message was deemed broken.  "
"It will populate a message object's "
":attr:`~email.message.EmailMessage.defects` attribute with a list of any "
"problems it found in a message.  See the :mod:`email.errors` module for "
"the list of defects that it can find."
msgstr ""
":class:`BytesFeedParser`\\의 API는 간단합니다; 인스턴스를 만들고, 더는 공급할 것이 없을 때까지 바이트열을"
" 공급한 다음 구문 분석기를 닫아 루트 메시지 객체를 얻습니다. :class:`BytesFeedParser`\\는 표준 호환 "
"메시지를 구문 분석할 때 매우 정확하고, 미준수 메시지를 구문 분석하는 데 매우 효과적이며 메시지를 어떻게 손상되었다고 간주하는지에"
" 대한 정보를 제공합니다. 메시지에서 발견된 문제점 리스트로 메시지 객체의 "
":attr:`~email.message.EmailMessage.defects` 어트리뷰트를 채웁니다. 찾을 수 있는 결함 목록은 "
":mod:`email.errors` 모듈을 참조하십시오."

#: ../../library/email.parser.rst:70
msgid "Here is the API for the :class:`BytesFeedParser`:"
msgstr ":class:`BytesFeedParser` API는 다음과 같습니다:"

#: ../../library/email.parser.rst:75
msgid ""
"Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a no-"
"argument callable; if not specified use the "
":attr:`~email.policy.Policy.message_factory` from the *policy*.  Call "
"*_factory* whenever a new message object is needed."
msgstr ""
":class:`BytesFeedParser` 인스턴스를 만듭니다. 선택적 *_factory*\\는 인자 없는 콜러블입니다; 지정되지"
" 않으면 *policy*\\의 :attr:`~email.policy.Policy.message_factory`\\를 사용합니다. "
"새로운 메시지 객체가 필요할 때마다 *_factory*\\를 호출합니다."

#: ../../library/email.parser.rst:80
msgid ""
"If *policy* is specified use the rules it specifies to update the "
"representation of the message.  If *policy* is not set, use the "
":class:`compat32 <email.policy.Compat32>` policy, which maintains "
"backward compatibility with the Python 3.2 version of the email package "
"and provides :class:`~email.message.Message` as the default factory.  All"
" other policies provide :class:`~email.message.EmailMessage` as the "
"default *_factory*. For more information on what else *policy* controls, "
"see the :mod:`~email.policy` documentation."
msgstr ""
"*policy*\\가 지정되면, 그것이 지정하는 규칙을 사용하여 메시지 표시를 갱신합니다. *policy*\\가 설정되지 않으면, "
":class:`compat32 <email.policy.Compat32>` 정책을 사용합니다. 이 정책은 파이썬 3.2 버전의 "
"email 패키지와의 호환성을 유지하고 :class:`~email.message.Message`\\를 기본 팩토리로 제공합니다. "
"다른 모든 정책은 :class:`~email.message.EmailMessage`\\를 기본 *_factory*\\로 제공합니다."
" *policy*\\가 제어하는 다른 기능에 대한 자세한 내용은 :mod:`~email.policy` 설명서를 참조하십시오."

#: ../../library/email.parser.rst:89 ../../library/email.parser.rst:145
msgid ""
"Note: **The policy keyword should always be specified**; The default will"
" change to :data:`email.policy.default` in a future version of Python."
msgstr ""
"참고: **policy 키워드는 항상 지정해야 합니다**; 이후 버전의 파이썬에서는 기본값이 "
":data:`email.policy.default`\\로 변경됩니다."

#: ../../library/email.parser.rst:94 ../../library/email.parser.rst:122
msgid "Added the *policy* keyword."
msgstr "*policy* 키워드를 추가했습니다."

#: ../../library/email.parser.rst:95
msgid "*_factory* defaults to the policy ``message_factory``."
msgstr "*_factory*\\는 기본적으로 정책 ``message_factory``\\입니다."

#: ../../library/email.parser.rst:100
msgid ""
"Feed the parser some more data.  *data* should be a :term:`bytes-like "
"object` containing one or more lines.  The lines can be partial and the "
"parser will stitch such partial lines together properly.  The lines can "
"have any of the three common line endings: carriage return, newline, or "
"carriage return and newline (they can even be mixed)."
msgstr ""
"구문 분석기에 데이터를 더 공급합니다. *data*\\는 하나 이상의 줄을 포함하는 :term:`바이트열류 객체 <bytes-"
"like object>`\\여야 합니다. 줄은 부분적일 수 있고 구문 분석기는 그러한 부분적인 줄을 올바르게 이어붙입니다. 줄은 세"
" 가지 일반 줄 종료 중 어느 것이라도 될 수 있습니다: 캐리지 리턴(carriage return), 줄 바꿈(newline) 또는"
" 캐리지 리턴과 줄 바꿈 (이것들을 혼합할 수도 있습니다)."

#: ../../library/email.parser.rst:109
msgid ""
"Complete the parsing of all previously fed data and return the root "
"message object.  It is undefined what happens if :meth:`~feed` is called "
"after this method has been called."
msgstr ""
"이전에 제공된 모든 데이터의 구문 분석을 완료하고 루트 메시지 객체를 반환합니다. 이 메서드가 호출된 후 "
":meth:`~feed`\\가 호출되면 어떻게 되는지는 정의되지 않습니다."

#: ../../library/email.parser.rst:116
msgid ""
"Works like :class:`BytesFeedParser` except that the input to the "
":meth:`~BytesFeedParser.feed` method must be a string.  This is of "
"limited utility, since the only way for such a message to be valid is for"
" it to contain only ASCII text or, if :attr:`~email.policy.Policy.utf8` "
"is ``True``, no binary attachments."
msgstr ""
":meth:`~BytesFeedParser.feed` 메서드에 대한 입력이 문자열이어야 한다는 점을 제외하고는 "
":class:`BytesFeedParser`\\와 같게 작동합니다. 이러한 메시지가 유효할 수 있는 유일한 방법은 ASCII "
"텍스트만 포함하거나 :attr:`~email.policy.Policy.utf8`\\가 ``True``\\일 때 바이너리 첨부 파일을"
" 포함하지 않는 것이라서, 이것의 용도는 제한적입니다."

#: ../../library/email.parser.rst:126
msgid "Parser API"
msgstr "Parser API"

#: ../../library/email.parser.rst:128
msgid ""
"The :class:`BytesParser` class, imported from the :mod:`email.parser` "
"module, provides an API that can be used to parse a message when the "
"complete contents of the message are available in a :term:`bytes-like "
"object` or file.  The :mod:`email.parser` module also provides "
":class:`Parser` for parsing strings, and header-only parsers, "
":class:`BytesHeaderParser` and :class:`HeaderParser`, which can be used "
"if you're only interested in the headers of the message.  "
":class:`BytesHeaderParser` and :class:`HeaderParser` can be much faster "
"in these situations, since they do not attempt to parse the message body,"
" instead setting the payload to the raw body."
msgstr ""
":mod:`email.parser` 모듈에서 임포트 한 :class:`BytesParser` 클래스는 메시지의 전체 내용이 "
":term:`바이트열류 객체 <bytes-like object>`\\나 파일로 있을 때 메시지를 구문 분석하는 데 사용할 수 있는 "
"API를 제공합니다. :mod:`email.parser` 모듈은 또한 문자열 구문 분석을 위한 :class:`Parser`\\와 "
"메시지 헤더에만 관심이 있을 때 사용할 수 있는 헤더 전용 구문 분석기인 :class:`BytesHeaderParser`\\와 "
":class:`HeaderParser`\\를 제공합니다. :class:`BytesHeaderParser`\\와 "
":class:`HeaderParser`\\는 메시지 본문을 구문 분석하지 않고 페이 로드를 원시 본문으로 설정하기 때문에 이러한 "
"상황에서 훨씬 더 빠를 수 있습니다."

#: ../../library/email.parser.rst:141
msgid ""
"Create a :class:`BytesParser` instance.  The *_class* and *policy* "
"arguments have the same meaning and semantics as the *_factory* and "
"*policy* arguments of :class:`BytesFeedParser`."
msgstr ""
":class:`BytesParser` 인스턴스를 만듭니다. *_class*\\와 *policy* 인자는 "
":class:`BytesFeedParser` 의 *_factory*\\와 *policy* 인자와 같은 의미입니다."

#: ../../library/email.parser.rst:148
msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr "2.4에서 폐지된 *strict* 인자를 제거했습니다. *policy* 키워드를 추가했습니다."

#: ../../library/email.parser.rst:151 ../../library/email.parser.rst:200
#: ../../library/email.parser.rst:280
msgid "*_class* defaults to the policy ``message_factory``."
msgstr "*_class*\\는 기본적으로 정책 ``message_factory``\\입니다."

#: ../../library/email.parser.rst:156
msgid ""
"Read all the data from the binary file-like object *fp*, parse the "
"resulting bytes, and return the message object.  *fp* must support both "
"the :meth:`~io.IOBase.readline` and the :meth:`~io.IOBase.read` methods."
msgstr ""
"바이너리 파일류 객체 *fp*\\에서 모든 데이터를 읽고, 결과 바이트열을 구문 분석한 후, 메시지 객체를 반환합니다. "
"*fp*\\는 :meth:`~io.IOBase.readline`\\과 :meth:`~io.IOBase.read` 메서드를 모두 "
"지원해야 합니다."

#: ../../library/email.parser.rst:161
msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`5322` "
"(or, if :attr:`~email.policy.Policy.utf8` is ``True``, :rfc:`6532`) style"
" headers and header continuation lines, optionally preceded by an "
"envelope header.  The header block is terminated either by the end of the"
" data or by a blank line.  Following the header block is the body of the "
"message (which may contain MIME-encoded subparts, including subparts with"
" a :mailheader:`Content-Transfer-Encoding` of ``8bit``)."
msgstr ""
"*fp*\\에 포함된 바이트열은 :rfc:`5322`\\(또는 :attr:`~email.policy.Policy.utf8`\\가 "
"``True``\\이면, :rfc:`6532`) 블록 스타일 헤더와 헤더 연장 줄들로 포맷되어야 하며, 선택적으로 봉투 헤더가 앞에"
" 올 수 있습니다. 헤더 블록은 데이터 끝이나 빈 줄로 종료됩니다. 헤더 블록 다음에는 메시지 본문이 있습니다 "
"(:mailheader:`Content-Transfer-Encoding`\\이 ``8bit``\\인 서브 파트를 포함하여 MIME "
"인코딩된 서브 파트를 포함할 수 있습니다)."

#: ../../library/email.parser.rst:169
msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after"
" reading the headers or not.  The default is ``False``, meaning it parses"
" the entire contents of the file."
msgstr ""
"선택적 *headersonly*\\는 헤더를 읽은 후에 구문 분석을 중지할지를 지정하는 플래그입니다. 기본값은 "
"``False``\\이며 파일의 전체 내용을 구문 분석합니다."

#: ../../library/email.parser.rst:176
msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method on a :term"
":`bytes-like object` is equivalent to wrapping *bytes* in a "
":class:`~io.BytesIO` instance first and calling :meth:`parse`."
msgstr ""
"파일류 객체 대신 :term:`바이트열류 객체 <bytes-like object>`\\를 취한다는 점을 제외하고는 "
":meth:`parse` 메서드와 유사합니다. :term:`바이트열류 객체 <bytes-like object>`\\로 이 메서드를 "
"호출하는 것은 :class:`~io.BytesIO` 인스턴스로 *bytes*\\를 먼저 감싸고 :meth:`parse`\\를 "
"호출하는 것과 동등합니다."

#: ../../library/email.parser.rst:181 ../../library/email.parser.rst:221
msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr "선택적 *headersonly*\\는 :meth:`parse` 메서드와 같습니다."

#: ../../library/email.parser.rst:188
msgid ""
"Exactly like :class:`BytesParser`, except that *headersonly* defaults to "
"``True``."
msgstr ""
"*headersonly*\\의 기본값이 ``True``\\라는 점을 제외하고는 :class:`BytesParser`\\와 정확히 "
"같습니다."

#: ../../library/email.parser.rst:196
msgid "This class is parallel to :class:`BytesParser`, but handles string input."
msgstr "이 클래스는 :class:`BytesParser`\\와 유사하지만, 문자열 입력을 처리합니다."

#: ../../library/email.parser.rst:198 ../../library/email.parser.rst:245
#: ../../library/email.parser.rst:258 ../../library/email.parser.rst:268
#: ../../library/email.parser.rst:278
msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr "*strict* 인자를 제거했습니다. *policy* 키워드를 추가했습니다."

#: ../../library/email.parser.rst:205
msgid ""
"Read all the data from the text-mode file-like object *fp*, parse the "
"resulting text, and return the root message object.  *fp* must support "
"both the :meth:`~io.TextIOBase.readline` and the "
":meth:`~io.TextIOBase.read` methods on file-like objects."
msgstr ""
"텍스트 모드 파일류 객체 *fp*\\에서 모든 데이터를 읽고, 결과 텍스트를 구문 분석한 후, 루트 메시지 객체를 반환합니다. "
"*fp*\\는 파일류 객체의 :meth:`~io.TextIOBase.readline`\\과 "
":meth:`~io.TextIOBase.read` 메서드를 모두 지원해야 합니다."

#: ../../library/email.parser.rst:210
msgid ""
"Other than the text mode requirement, this method operates like "
":meth:`BytesParser.parse`."
msgstr "텍스트 모드 요구 사항 외에, 이 메서드는 :meth:`BytesParser.parse`\\처럼 작동합니다."

#: ../../library/email.parser.rst:216
msgid ""
"Similar to the :meth:`parse` method, except it takes a string object "
"instead of a file-like object.  Calling this method on a string is "
"equivalent to wrapping *text* in a :class:`~io.StringIO` instance first "
"and calling :meth:`parse`."
msgstr ""
"파일류 객체 대신 문자열 객체를 취한다는 점을 제외하고는 :meth:`parse` 메서드와 유사합니다. 문자열로 이 메서드를 "
"호출하는 것은 :class:`~io.StringIO` 인스턴스로 *text*\\를 먼저 감싸고 :meth:`parse`\\를 "
"호출하는 것과 동등합니다."

#: ../../library/email.parser.rst:226
msgid ""
"Exactly like :class:`Parser`, except that *headersonly* defaults to "
"``True``."
msgstr "*headersonly*\\의 기본값이 ``True``\\라는 점을 제외하고는 :class:`Parser`\\와 정확히 같습니다."

#: ../../library/email.parser.rst:230
msgid ""
"Since creating a message object structure from a string or a file object "
"is such a common task, four functions are provided as a convenience.  "
"They are available in the top-level :mod:`email` package namespace."
msgstr ""
"문자열이나 파일 객체로부터 메시지 객체 구조를 만드는 것이 일반적인 작업이기 때문에, 편의상 4가지 함수가 제공됩니다. 최상위 "
":mod:`email` 패키지 이름 공간에 있습니다."

#: ../../library/email.parser.rst:239
msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This"
" is equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and"
" *policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
":term:`바이트열류 객체 <bytes-like object>`\\로부터 메시지 객체 구조를 반환합니다. 이것은 "
"``BytesParser().parsebytes(s)``\\와 동등합니다. 선택적 *_class*\\와 *policy*\\는 "
":class:`~email.parser.BytesParser` 클래스 생성자에서처럼 해석됩니다."

#: ../../library/email.parser.rst:252
msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* "
"and *policy* are interpreted as with the "
":class:`~email.parser.BytesParser` class constructor."
msgstr ""
"열린 바이너리 :term:`파일 객체 <file object>`\\로부터 메시지 객체 구조 트리를 반환합니다. 이것은 "
"``BytesParser().parse(fp)``\\와 동등합니다. *_class*\\와 *policy*\\는 "
":class:`~email.parser.BytesParser` 클래스 생성자에서처럼 해석됩니다."

#: ../../library/email.parser.rst:264
msgid ""
"Return a message object structure from a string.  This is equivalent to "
"``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with "
"the :class:`~email.parser.Parser` class constructor."
msgstr ""
"문자열로부터 메시지 객체 구조 트리를 반환합니다. 이것은 ``Parser().parsestr(s)``\\와 동등합니다. "
"*_class*\\와 *policy*\\는 :class:`~email.parser.Parser` 클래스 생성자에서처럼 해석됩니다."

#: ../../library/email.parser.rst:274
msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are "
"interpreted as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"열린 :term:`파일 객체 <file object>`\\로부터 메시지 객체 구조 트리를 반환합니다. 이것은 "
"``Parser().parse(fp)``\\와 동등합니다. *_class*\\와 *policy*\\는 "
":class:`~email.parser.Parser` 클래스 생성자에서처럼 해석됩니다."

#: ../../library/email.parser.rst:283
msgid ""
"Here's an example of how you might use :func:`message_from_bytes` at an "
"interactive Python prompt::"
msgstr "대화식 파이썬 프롬프트에서 :func:`message_from_bytes`\\를 사용하는 방법의 예는 다음과 같습니다::"

#: ../../library/email.parser.rst:286
msgid ""
">>> import email\n"
">>> msg = email.message_from_bytes(myBytes)"
msgstr ""

#: ../../library/email.parser.rst:291
msgid "Additional notes"
msgstr "추가 사항"

#: ../../library/email.parser.rst:293
msgid "Here are some notes on the parsing semantics:"
msgstr "구문 분석 의미에 대한 참고 사항은 다음과 같습니다:"

#: ../../library/email.parser.rst:295
msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return "
"``False`` for :meth:`~email.message.EmailMessage.is_multipart`, and "
":meth:`~email.message.EmailMessage.iter_parts` will yield an empty list."
msgstr ""
"대부분의 :mimetype:`multipart`\\가 아닌 유형의 메시지는 문자열 페이 로드가 있는 단일 메시지 객체로 구문 "
"분석됩니다. 이 객체는 :meth:`~email.message.EmailMessage.is_multipart`\\가 "
"``False``\\를 반환하고 :meth:`~email.message.EmailMessage.iter_parts`\\는 빈 목록을"
" 산출합니다."

#: ../../library/email.parser.rst:300
msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The"
" outer container message will return ``True`` for "
":meth:`~email.message.EmailMessage.is_multipart`, and "
":meth:`~email.message.EmailMessage.iter_parts` will yield a list of "
"subparts."
msgstr ""
"모든 :mimetype:`multipart` 유형 메시지는 서브 메시지 객체 리스트 페이 로드가 있는 컨테이너 메시지 객체로 구문 "
"분석됩니다. 바깥 컨테이너 메시지는 :meth:`~email.message.EmailMessage.is_multipart`\\가 "
"``True``\\를 반환하고 :meth:`~email.message.EmailMessage.iter_parts`\\는 서브 파트 "
"목록을 산출합니다."

#: ../../library/email.parser.rst:306
msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (such as "
":mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will "
"also be parsed as container object containing a list payload of length 1."
"  Their :meth:`~email.message.EmailMessage.is_multipart` method will "
"return ``True``. The single element yielded by "
":meth:`~email.message.EmailMessage.iter_parts` will be a sub-message "
"object."
msgstr ""
"콘텐츠 유형이 :mimetype:`message/\\*`\\(가령 :mimetype:`message/delivery-"
"status`\\와 :mimetype:`message/rfc822`)인 대부분의 메시지는 길이가 1인 리스트 페이 로드를 포함하는 "
"컨테이너 객체로 구문 분석됩니다. :meth:`~email.message.EmailMessage.is_multipart` 메서드는 "
"``True``\\를 반환합니다. :meth:`~email.message.EmailMessage.iter_parts`\\가 산출하는"
" 단일 요소가 서브 메시지 객체입니다."

#: ../../library/email.parser.rst:313
msgid ""
"Some non-standards-compliant messages may not be internally consistent "
"about their :mimetype:`multipart`\\ -edness.  Such messages may have a "
":mailheader:`Content-Type` header of type :mimetype:`multipart`, but "
"their :meth:`~email.message.EmailMessage.is_multipart` method may return "
"``False``. If such messages were parsed with the "
":class:`~email.parser.FeedParser`, they will have an instance of the "
":class:`~email.errors.MultipartInvariantViolationDefect` class in their "
"*defects* attribute list.  See :mod:`email.errors` for details."
msgstr ""
"일부 표준을 준수하지 않는 메시지는 :mimetype:`multipart` 처리에 대해 내부적으로 일관성이 없을 수 있습니다. "
"이러한 메시지는 :mimetype:`multipart` 유형의 :mailheader:`Content-Type` 헤더를 가지면서도 "
":meth:`~email.message.EmailMessage.is_multipart` 메서드가 ``False``\\를 반환할 수 "
"있습니다. 이러한 메시지가 :class:`~email.parser.FeedParser`\\로 구문 분석되었다면, *defects* "
"어트리뷰트 리스트에 :class:`~email.errors.MultipartInvariantViolationDefect` 클래스의 "
"인스턴스가 있습니다. 자세한 내용은 :mod:`email.errors`\\를 참조하십시오."

