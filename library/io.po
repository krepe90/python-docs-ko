# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/io.rst:2
#, fuzzy
msgid ":mod:`!io` --- Core tools for working with streams"
msgstr ":mod:`io` --- 스트림 작업을 위한 핵심 도구"

#: ../../library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**소스 코드:** :source:`Lib/io.py`"

#: ../../library/io.rst:22
msgid "Overview"
msgstr "개요"

#: ../../library/io.rst:27
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging"
" to any of these categories is called a :term:`file object`.  Other "
"common terms are *stream* and *file-like object*."
msgstr ""
":mod:`io` 모듈은 다양한 유형의 I/O를 처리하기 위한 파이썬의 주 장치를 제공합니다. I/O에는 세 가지 주요 유형이 "
"있습니다: *텍스트(text) I/O*, *바이너리(binary) I/O* 및 *원시(raw) I/O*. 이들은 일반적인 범주이며 "
"다양한 배경 저장소를 각각에 사용할 수 있습니다. 이러한 범주 중 하나에 속하는 구상 객체를 :term:`파일 객체 <file "
"object>`\\라고 합니다. 다른 일반적인 용어는 *스트림(stream)*\\과 *파일류 객체(file-like "
"object)*\\입니다."

#: ../../library/io.rst:34
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It "
"can also allow arbitrary random access (seeking forwards or backwards to "
"any location), or only sequential access (for example in the case of a "
"socket or pipe)."
msgstr ""
"범주와 상관없이, 각 구상 스트림 객체에는 다양한 기능이 있습니다: 읽기 전용, 쓰기 전용 또는 읽고-쓰기일 수 있습니다. 또한 "
"임의의 무작위 액세스(임의의 위치로 전방이나 후방 탐색)를 허용하거나 순차적 액세스(예를 들어 소켓이나 파이프의 경우)만 허용할 수"
" 있습니다."

#: ../../library/io.rst:40
#, fuzzy
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the :meth:`!write` method of a "
"binary stream will raise a :exc:`TypeError`.  So will giving a "
":class:`bytes` object to the :meth:`!write` method of a text stream."
msgstr ""
"모든 스트림은 그것에 제공하는 데이터형에 주의를 기울입니다. 예를 들어 :class:`str` 객체를 바이너리 스트림의 "
"``write()`` 메서드에 제공하면 :exc:`TypeError`\\가 발생합니다. 텍스트 스트림의 ``write()`` "
"메서드에 :class:`bytes` 객체를 제공해도 마찬가지입니다."

#: ../../library/io.rst:45
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, "
"since :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
":exc:`IOError`\\가 이제는 :exc:`OSError`\\의 별칭이라서, :exc:`IOError`\\를 발생시켰던 "
"연산은 이제 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/io.rst:51 ../../library/io.rst:855 ../../library/io.rst:1149
msgid "Text I/O"
msgstr "텍스트 I/O"

#: ../../library/io.rst:53
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case"
" of a file), encoding and decoding of data is made transparently as well "
"as optional translation of platform-specific newline characters."
msgstr ""
"텍스트 I/O는 :class:`str` 객체를 기대하고 생성합니다. 이는 배경 저장소가 네이티브 하게 바이트열로 구성되었을 때마다 "
"(가령 파일의 경우), 플랫폼별 줄 넘김 문자의 선택적 변환뿐만 아니라 데이터의 인코딩과 디코딩이 투명하게 이루어짐을 의미합니다."

#: ../../library/io.rst:58
#, fuzzy
msgid ""
"The easiest way to create a text stream is with :meth:`open`, optionally "
"specifying an encoding::"
msgstr "텍스트 스트림을 만드는 가장 쉬운 방법은 :meth:`open()`\\을 사용하는 것이고, 선택적으로 인코딩을 지정합니다::"

#: ../../library/io.rst:61
msgid "f = open(\"myfile.txt\", \"r\", encoding=\"utf-8\")"
msgstr ""

#: ../../library/io.rst:63
msgid "In-memory text streams are also available as :class:`StringIO` objects::"
msgstr "인 메모리 텍스트 스트림도 :class:`StringIO` 객체로 제공됩니다::"

#: ../../library/io.rst:65
msgid "f = io.StringIO(\"some initial text data\")"
msgstr ""

#: ../../library/io.rst:67
msgid ""
"The text stream API is described in detail in the documentation of "
":class:`TextIOBase`."
msgstr "텍스트 스트림 API는 :class:`TextIOBase`\\의 설명서에 자세히 설명되어 있습니다."

#: ../../library/io.rst:72 ../../library/io.rst:1137
msgid "Binary I/O"
msgstr "바이너리 I/O"

#: ../../library/io.rst:74
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects"
" <bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams "
"can be used for all kinds of non-text data, and also when manual control "
"over the handling of text data is desired."
msgstr ""
"바이너리 I/O(*버퍼링 된(buffered) I/O*\\라고도 합니다)는 :term:`바이트열류 객체 <bytes-like "
"object>`\\를 기대하고 :class:`bytes` 객체를 생성합니다. 인코딩, 디코딩 또는 줄 넘김 변환이 수행되지 "
"않습니다. 이 범주의 스트림은 모든 종류의 텍스트가 아닌 데이터에 사용할 수 있으며, 텍스트 데이터 처리를 수동으로 제어해야 할 "
"때도 사용할 수 있습니다."

#: ../../library/io.rst:80
#, fuzzy
msgid ""
"The easiest way to create a binary stream is with :meth:`open` with "
"``'b'`` in the mode string::"
msgstr ""
"바이너리 스트림을 만드는 가장 쉬운 방법은 모드 문자열에 ``'b'``\\를 제공하여 :meth:`open()`\\을 사용하는 "
"것입니다::"

#: ../../library/io.rst:83
msgid "f = open(\"myfile.jpg\", \"rb\")"
msgstr ""

#: ../../library/io.rst:85
msgid "In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr "인 메모리 바이너리 스트림도 :class:`BytesIO` 객체로 제공됩니다::"

#: ../../library/io.rst:87
msgid "f = io.BytesIO(b\"some initial binary data: \\x00\\x01\")"
msgstr ""

#: ../../library/io.rst:89
msgid ""
"The binary stream API is described in detail in the docs of "
":class:`BufferedIOBase`."
msgstr "바이너리 스트림 API는 :class:`BufferedIOBase` 설명서에 자세히 설명되어 있습니다."

#: ../../library/io.rst:92
msgid ""
"Other library modules may provide additional ways to create text or "
"binary streams.  See :meth:`socket.socket.makefile` for example."
msgstr ""
"다른 라이브러리 모듈은 텍스트나 바이너리 스트림을 만드는 다른 방법을 제공할 수 있습니다. 예를 들어 "
":meth:`socket.socket.makefile`\\을 참조하십시오."

#: ../../library/io.rst:97
msgid "Raw I/O"
msgstr "원시 I/O"

#: ../../library/io.rst:99
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to "
"directly manipulate a raw stream from user code.  Nevertheless, you can "
"create a raw stream by opening a file in binary mode with buffering "
"disabled::"
msgstr ""
"원시 I/O(*버퍼링 되지 않은(unbuffered) I/O*\\라고도 합니다)는 일반적으로 바이너리와 텍스트 스트림을 위한 저수준"
" 빌딩 블록으로 사용됩니다; 사용자 코드에서 원시 스트림을 직접 조작하는 것은 거의 유용하지 않습니다. 그런데도, 버퍼링을 "
"비활성화해서 바이너리 모드로 파일을 열어 원시 스트림을 만들 수 있습니다::"

#: ../../library/io.rst:104
msgid "f = open(\"myfile.jpg\", \"rb\", buffering=0)"
msgstr ""

#: ../../library/io.rst:106
msgid ""
"The raw stream API is described in detail in the docs of "
":class:`RawIOBase`."
msgstr "원시 스트림 API는 :class:`RawIOBase` 설명서에 자세히 설명되어 있습니다."

#: ../../library/io.rst:112
msgid "Text Encoding"
msgstr ""

#: ../../library/io.rst:114
msgid ""
"The default encoding of :class:`TextIOWrapper` and :func:`open` is "
"locale-specific (:func:`locale.getencoding`)."
msgstr ""

#: ../../library/io.rst:117
msgid ""
"However, many developers forget to specify the encoding when opening text"
" files encoded in UTF-8 (e.g. JSON, TOML, Markdown, etc...) since most "
"Unix platforms use UTF-8 locale by default. This causes bugs because the "
"locale encoding is not UTF-8 for most Windows users. For example::"
msgstr ""

#: ../../library/io.rst:122
msgid ""
"# May not work on Windows when non-ASCII characters in the file.\n"
"with open(\"README.md\") as f:\n"
"    long_description = f.read()"
msgstr ""

#: ../../library/io.rst:126
msgid ""
"Accordingly, it is highly recommended that you specify the encoding "
"explicitly when opening text files. If you want to use UTF-8, pass "
"``encoding=\"utf-8\"``. To use the current locale encoding, "
"``encoding=\"locale\"`` is supported since Python 3.10."
msgstr ""

#: ../../library/io.rst:133
msgid ":ref:`utf8-mode`"
msgstr ""

#: ../../library/io.rst:134
msgid ""
"Python UTF-8 Mode can be used to change the default encoding to UTF-8 "
"from locale-specific encoding."
msgstr ""

#: ../../library/io.rst:137
msgid ":pep:`686`"
msgstr ""

#: ../../library/io.rst:138
msgid "Python 3.15 will make :ref:`utf8-mode` default."
msgstr ""

#: ../../library/io.rst:143
msgid "Opt-in EncodingWarning"
msgstr ""

#: ../../library/io.rst:145
msgid "See :pep:`597` for more details."
msgstr ""

#: ../../library/io.rst:148
msgid ""
"To find where the default locale encoding is used, you can enable the "
":option:`-X warn_default_encoding <-X>` command line option or set the "
":envvar:`PYTHONWARNDEFAULTENCODING` environment variable, which will emit"
" an :exc:`EncodingWarning` when the default encoding is used."
msgstr ""

#: ../../library/io.rst:153
msgid ""
"If you are providing an API that uses :func:`open` or "
":class:`TextIOWrapper` and passes ``encoding=None`` as a parameter, you "
"can use :func:`text_encoding` so that callers of the API will emit an "
":exc:`EncodingWarning` if they don't pass an ``encoding``. However, "
"please consider using UTF-8 by default (i.e. ``encoding=\"utf-8\"``) for "
"new APIs."
msgstr ""

#: ../../library/io.rst:162
msgid "High-level Module Interface"
msgstr "고수준 모듈 인터페이스"

#: ../../library/io.rst:166
msgid ""
"An int containing the default buffer size used by the module's buffered "
"I/O classes.  :func:`open` uses the file's blksize (as obtained by "
":func:`os.stat`) if possible."
msgstr ""
"모듈의 버퍼링 된 I/O 클래스에서 사용하는 기본 버퍼 크기를 포함하는 int. :func:`open`\\은 가능하면 파일의 "
"blksize(:func:`os.stat`\\으로 얻은)를 사용합니다."

#: ../../library/io.rst:173
msgid "This is an alias for the builtin :func:`open` function."
msgstr "이것은 내장 :func:`open` 함수의 별칭입니다."

#: ../../library/io.rst:175 ../../library/io.rst:177
#, fuzzy
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments *path*, *mode* and *flags*. The *mode* and *flags* arguments "
"may have been modified or inferred from the original call."
msgstr ""
"이 함수는 인자 ``path``, ``mode`` 및 ``flags``\\로 :ref:`감사 이벤트 <auditing>` "
"``open``\\을 발생시킵니다. ``mode``\\와 ``flags`` 인자는 원래 호출에서 수정되었거나 유추되었을 수 "
"있습니다."

#: ../../library/io.rst:184
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr "제공된 파일을 ``'rb'`` 모드로 엽니다. 이 함수는 내용을 실행 코드로 취급하려고 할 때 사용해야 합니다."

#: ../../library/io.rst:187
#, fuzzy
msgid "*path* should be a :class:`str` and an absolute path."
msgstr "``path``\\는 :class:`str`\\이고 절대 경로여야 합니다."

#: ../../library/io.rst:189
#, fuzzy
msgid ""
"The behavior of this function may be overridden by an earlier call to the"
" :c:func:`PyFile_SetOpenCodeHook`. However, assuming that *path* is a "
":class:`str` and an absolute path, ``open_code(path)`` should always "
"behave the same as ``open(path, 'rb')``. Overriding the behavior is "
"intended for additional validation or preprocessing of the file."
msgstr ""
"이 함수의 동작은 :c:func:`PyFile_SetOpenCodeHook` 에 대한 이전 호출로 재정의될 수 있습니다. 하지만, "
"``path``\\가 :class:`str`\\이고 절대 경로임을 가정할 때, ``open_code(path)``\\는 항상 "
"``open(path, 'rb')``\\와 같게 동작해야 합니다. 동작의 재정의는 파일의 추가 유효성 검사나 사전 처리를 위한 "
"것입니다."

#: ../../library/io.rst:200
msgid ""
"This is a helper function for callables that use :func:`open` or "
":class:`TextIOWrapper` and have an ``encoding=None`` parameter."
msgstr ""

#: ../../library/io.rst:203
msgid ""
"This function returns *encoding* if it is not ``None``. Otherwise, it "
"returns ``\"locale\"`` or ``\"utf-8\"`` depending on :ref:`UTF-8 Mode "
"<utf8-mode>`."
msgstr ""

#: ../../library/io.rst:207
msgid ""
"This function emits an :class:`EncodingWarning` if "
":data:`sys.flags.warn_default_encoding <sys.flags>` is true and "
"*encoding* is ``None``. *stacklevel* specifies where the warning is "
"emitted. For example::"
msgstr ""

#: ../../library/io.rst:212
msgid ""
"def read_text(path, encoding=None):\n"
"    encoding = io.text_encoding(encoding)  # stacklevel=2\n"
"    with open(path, encoding) as f:\n"
"        return f.read()"
msgstr ""

#: ../../library/io.rst:217
msgid ""
"In this example, an :class:`EncodingWarning` is emitted for the caller of"
" ``read_text()``."
msgstr ""

#: ../../library/io.rst:220
msgid "See :ref:`io-text-encoding` for more information."
msgstr ""

#: ../../library/io.rst:224
msgid ""
":func:`text_encoding` returns \"utf-8\" when UTF-8 mode is enabled and "
"*encoding* is ``None``."
msgstr ""

#: ../../library/io.rst:231
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr "이것은 내장 :exc:`BlockingIOError` 예외에 대한 호환 별칭입니다."

#: ../../library/io.rst:237
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is "
"raised when an unsupported operation is called on a stream."
msgstr ""
"지원되지 않는 연산이 스트림에서 호출될 때 발생하는 :exc:`OSError`\\와 :exc:`ValueError`\\를 상속하는 "
"예외."

#: ../../library/io.rst:243
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../../library/io.rst:244
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, "
"and :data:`sys.stderr`."
msgstr ""
"표준 IO 스트림을 포함합니다: :data:`sys.stdin`, :data:`sys.stdout` 및 "
":data:`sys.stderr`."

#: ../../library/io.rst:249
msgid "Class hierarchy"
msgstr "클래스 위계"

#: ../../library/io.rst:251
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes."
"  First :term:`abstract base classes <abstract base class>` (ABCs), which"
" are used to specify the various categories of streams, then concrete "
"classes providing the standard stream implementations."
msgstr ""
"I/O 스트림의 구현은 클래스의 위계(hierarchy)로 구성됩니다. 먼저 다양한 범주의 스트림을 지정하는 데 사용되는 "
":term:`추상 베이스 클래스 <abstract base class>`\\(ABC)가 있고, 그다음으로 표준 스트림 구현을 "
"제공하는 구상 클래스가 있습니다."

#: ../../library/io.rst:258
#, fuzzy
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of "
":meth:`!readinto` and :meth:`!readline`."
msgstr ""
"추상 베이스 클래스는 또한 구상 스트림 클래스의 구현을 돕기 위해 일부 메서드의 기본 구현을 제공합니다. 예를 들어, "
":class:`BufferedIOBase`\\는 최적화되지 않은 :meth:`~IOBase.readinto`\\와 "
":meth:`~IOBase.readline` 구현을 제공합니다."

#: ../../library/io.rst:263
msgid ""
"At the top of the I/O hierarchy is the abstract base class "
":class:`IOBase`.  It defines the basic interface to a stream.  Note, "
"however, that there is no separation between reading and writing to "
"streams; implementations are allowed to raise :exc:`UnsupportedOperation`"
" if they do not support a given operation."
msgstr ""
"I/O 위계의 맨 위에는 추상 베이스 클래스 :class:`IOBase`\\가 있습니다. 스트림에 대한 기본 인터페이스를 "
"정의합니다. 그러나 스트림에 대한 읽기와 쓰기가 분리되지 않음에 유의하십시오; 구현은 주어진 연산을 지원하지 않으면 "
":exc:`UnsupportedOperation`\\을 발생시킬 수 있습니다."

#: ../../library/io.rst:268
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses "
":class:`RawIOBase` to provide an interface to files in the machine's file"
" system."
msgstr ""
":class:`RawIOBase` ABC는 :class:`IOBase`\\를 확장합니다. 스크림에 대한 바이트열의 읽기와 쓰기를 "
"처리합니다. :class:`FileIO`\\는 :class:`RawIOBase`\\를 서브 클래싱하여 기계의 파일 시스템에 있는 "
"파일에 대한 인터페이스를 제공합니다."

#: ../../library/io.rst:272
#, fuzzy
msgid ""
"The :class:`BufferedIOBase` ABC extends :class:`IOBase`.  It deals with "
"buffering on a raw binary stream (:class:`RawIOBase`).  Its subclasses, "
":class:`BufferedWriter`, :class:`BufferedReader`, and "
":class:`BufferedRWPair` buffer raw binary streams that are writable, "
"readable, and both readable and writable, respectively. "
":class:`BufferedRandom` provides a buffered interface to seekable "
"streams. Another :class:`BufferedIOBase` subclass, :class:`BytesIO`, is a"
" stream of in-memory bytes."
msgstr ""
":class:`BufferedIOBase` ABC는 :class:`IOBase`\\를 확장합니다. 원시 바이너리 "
"스트림(:class:`RawIOBase`)에 대한 버퍼링을 다룹니다. 이것의 서브 클래스, "
":class:`BufferedWriter`, :class:`BufferedReader` 및 "
":class:`BufferedRWPair`\\는 각각 읽을 수 있는, 쓸 수 있는, 그리고 읽고 쓸 수 있는 원시 바이너리 스트림을"
" 버퍼링합니다. :class:`BufferedRandom`\\은 탐색할 수 있는 (seekable) 스트림에 버퍼 인터페이스를 "
"제공합니다. 또 다른 :class:`BufferedIOBase` 서브 클래스 :class:`BytesIO`\\는 인 메모리 "
"바이트열의 스트림입니다."

#: ../../library/io.rst:280
msgid ""
"The :class:`TextIOBase` ABC extends :class:`IOBase`.  It deals with "
"streams whose bytes represent text, and handles encoding and decoding to "
"and from strings.  :class:`TextIOWrapper`, which extends "
":class:`TextIOBase`, is a buffered text interface to a buffered raw "
"stream (:class:`BufferedIOBase`).  Finally, :class:`StringIO` is an in-"
"memory stream for text."
msgstr ""
":class:`TextIOBase` ABC는 :class:`IOBase`\\를 확장합니다. 이것은 바이트가 텍스트를 나타내는 "
"스트림을 다루고, 문자열과의 인코딩과 디코딩을 처리합니다. :class:`TextIOBase`\\를 확장하는 "
":class:`TextIOWrapper`\\는 버퍼링 된 원시 스트림(:class:`BufferedIOBase`)에 대한 버퍼링 된"
" 텍스트 인터페이스입니다. 마지막으로, :class:`StringIO`\\는 텍스트에 대한 인 메모리 스트림입니다."

#: ../../library/io.rst:286
msgid ""
"Argument names are not part of the specification, and only the arguments "
"of :func:`open` are intended to be used as keyword arguments."
msgstr "인자 이름은 명세의 일부가 아니며, :func:`open`\\의 인자는 키워드 인자로만 사용하려는 의도입니다."

#: ../../library/io.rst:289
msgid "The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr "다음 표는 :mod:`io` 모듈에서 제공하는 ABC를 요약합니다:"

#: ../../library/io.rst:294
msgid "ABC"
msgstr "ABC"

#: ../../library/io.rst:294
msgid "Inherits"
msgstr "상속"

#: ../../library/io.rst:294
msgid "Stub Methods"
msgstr "스텁(stub) 메서드"

#: ../../library/io.rst:294
msgid "Mixin Methods and Properties"
msgstr "믹스 인 메서드와 프로퍼티"

#: ../../library/io.rst:296 ../../library/io.rst:301 ../../library/io.rst:303
#: ../../library/io.rst:305
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../../library/io.rst:296
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``, ``seek`` 및 ``truncate``"

#: ../../library/io.rst:296
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, "
"``isatty``, ``__iter__``, ``__next__``, ``readable``, ``readline``, "
"``readlines``, ``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, "
"``isatty``, ``__iter__``, ``__next__``, ``readable``, ``readline``, "
"``readlines``, ``seekable``, ``tell``, ``writable`` 및 ``writelines``"

#: ../../library/io.rst:301
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../../library/io.rst:301
msgid "``readinto`` and ``write``"
msgstr "``readinto``\\와 ``write``"

#: ../../library/io.rst:301
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "상속된 :class:`IOBase` 메서드, ``read`` 및 ``readall``"

#: ../../library/io.rst:303
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../../library/io.rst:303
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``, ``read``, ``read1`` 및 ``write``"

#: ../../library/io.rst:303
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "상속된 :class:`IOBase` 메서드, ``readinto`` 및 ``readinto1``"

#: ../../library/io.rst:305
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../../library/io.rst:305
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``, ``read``, ``readline`` 및 ``write``"

#: ../../library/io.rst:305
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and "
"``newlines``"
msgstr "상속된 :class:`IOBase` 메서드, ``encoding``, ``errors`` 및 ``newlines``"

#: ../../library/io.rst:312
msgid "I/O Base Classes"
msgstr "I/O 베이스 클래스"

#: ../../library/io.rst:316
msgid "The abstract base class for all I/O classes."
msgstr ""

#: ../../library/io.rst:318
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""
"이 클래스는 파생 클래스가 선택적으로 재정의할 수 있는 많은 메서드에 대해 빈 추상 구현을 제공합니다; 기본 구현은 읽거나 쓰거나 "
"탐색할 수 없는 파일을 나타냅니다."

#: ../../library/io.rst:323
#, fuzzy
msgid ""
"Even though :class:`IOBase` does not declare :meth:`!read` or "
":meth:`!write` because their signatures will vary, implementations and "
"clients should consider those methods part of the interface.  Also, "
"implementations may raise a :exc:`ValueError` (or "
":exc:`UnsupportedOperation`) when operations they do not support are "
"called."
msgstr ""
":class:`IOBase`\\가 서명이 다양하기 때문에 :meth:`read`\\나 :meth:`write`\\를 선언하지 "
"않더라도, 구현과 클라이언트는 해당 메서드를 인터페이스의 일부로 고려해야 합니다. 또한, 지원하지 않는 연산이 호출될 때 구현은 "
":exc:`ValueError`\\(또는 :exc:`UnsupportedOperation`)를 발생시킬 수 있습니다."

#: ../../library/io.rst:329
msgid ""
"The basic type used for binary data read from or written to a file is "
":class:`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are"
" accepted as method arguments too.  Text I/O classes work with "
":class:`str` data."
msgstr ""
"파일에서 읽거나 파일에 쓰는 바이너리 데이터에 사용되는 기본형은 :class:`bytes`\\입니다. 다른 :term:`바이트열류 "
"객체 <bytes-like object>`\\도 메서드 인자로 허용됩니다. 텍스트 I/O 클래스는 :class:`str` 데이터로 "
"작동합니다."

#: ../../library/io.rst:333
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr ""
"닫힌 스트림에 대한 모든 메서드(조회조차도) 호출은 정의되어 있지 않습니다. 이 경우 구현은 :exc:`ValueError`\\를 "
"발생시킬 수 있습니다."

#: ../../library/io.rst:336
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, "
"meaning that an :class:`IOBase` object can be iterated over yielding the "
"lines in a stream.  Lines are defined slightly differently depending on "
"whether the stream is a binary stream (yielding bytes), or a text stream "
"(yielding character strings).  See :meth:`~IOBase.readline` below."
msgstr ""
":class:`IOBase`\\(및 그 서브 클래스)는 이터레이터 프로토콜을 지원합니다. 즉, 스트림에서 줄을 산출하면서 "
":class:`IOBase` 객체를 이터레이트 할 수 있습니다. 스트림이 바이너리 스트림(바이트열을 산출합니다)인지 텍스트 "
"스트림(문자열을 산출합니다)인지에 따라 줄은 약간 다르게 정의됩니다. 아래 :meth:`~IOBase.readline`\\을 "
"참조하십시오."

#: ../../library/io.rst:342
msgid ""
":class:`IOBase` is also a context manager and therefore supports the "
":keyword:`with` statement.  In this example, *file* is closed after the "
":keyword:`!with` statement's suite is finished---even if an exception "
"occurs::"
msgstr ""
":class:`IOBase`\\는 컨텍스트 관리자이기도 해서, :keyword:`with` 문을 지원합니다. 이 예에서, "
"*file*\\은 :keyword:`!with` 문의 스위트가 완료된 후에 닫힙니다 --- 예외가 발생하더라도::"

#: ../../library/io.rst:346
msgid ""
"with open('spam.txt', 'w') as file:\n"
"    file.write('Spam and eggs!')"
msgstr ""

#: ../../library/io.rst:349
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase`\\는 다음 데이터 어트리뷰트와 메서드를 제공합니다:"

#: ../../library/io.rst:353
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""
"이 스트림을 플러시하고 닫습니다. 파일이 이미 닫혔으면 이 메서드는 효과가 없습니다. 일단 파일이 닫히면, 파일에 대한 모든 "
"연산(예를 들어 읽기나 쓰기)이 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/io.rst:357
msgid ""
"As a convenience, it is allowed to call this method more than once; only "
"the first call, however, will have an effect."
msgstr "편의상, 이 메서드를 두 번 이상 호출할 수 있습니다; 그러나 첫 번째 호출만 효과가 있습니다."

#: ../../library/io.rst:362
msgid "``True`` if the stream is closed."
msgstr "스트림이 닫혔으면 ``True``."

#: ../../library/io.rst:366
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file"
" descriptor."
msgstr ""
"존재한다면 스트림의 하부 파일 기술자(정수)를 반환합니다. IO 객체가 파일 기술자를 사용하지 않으면 "
":exc:`OSError`\\가 발생합니다."

#: ../../library/io.rst:372
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing "
"for read-only and non-blocking streams."
msgstr "해당하면 스트림의 쓰기 버퍼를 플러시합니다. 이것은 읽기 전용과 비 블로킹 스트림에 대해서는 아무것도 하지 않습니다."

#: ../../library/io.rst:377
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a "
"terminal/tty device)."
msgstr "스트림이 대화형이면 (즉, 터미널/tty 장치에 연결되었으면) ``True``\\를 반환합니다."

#: ../../library/io.rst:382
#, fuzzy
msgid ""
"Return ``True`` if the stream can be read from. If ``False``, "
":meth:`!read` will raise :exc:`OSError`."
msgstr ""
"스트림을 읽을 수 있으면 ``True``\\를 반환합니다. ``False``\\이면, :meth:`read`\\는 "
":exc:`OSError`\\를 발생시킵니다."

#: ../../library/io.rst:387
msgid ""
"Read and return one line from the stream.  If *size* is specified, at "
"most *size* bytes will be read."
msgstr "스트림에서 한 줄을 읽고 반환합니다. *size*\\가 지정되면, 최대 *size* 바이트를 읽습니다."

#: ../../library/io.rst:390
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text "
"files, the *newline* argument to :func:`open` can be used to select the "
"line terminator(s) recognized."
msgstr ""
"줄 종결자는 바이너리 파일의 경우 항상 ``b'\\n'``\\입니다; 텍스트 파일의 경우, :func:`open`\\에 대한 "
"*newline* 인자를 사용하여 인식되는 줄 종결자를 선택할 수 있습니다."

#: ../../library/io.rst:396
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified"
" to control the number of lines read: no more lines will be read if the "
"total size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"스트림에서 줄 리스트를 읽고 반환합니다. *hint*\\는 읽을 줄 수를 제어하도록 지정할 수 있습니다: 지금까지 모든 줄의 총 "
"크기(바이트/문자 단위)가 *hint*\\를 초과하면 더는 줄을 읽지 않습니다."

#: ../../library/io.rst:400
msgid ""
"*hint* values of ``0`` or less, as well as ``None``, are treated as no "
"hint."
msgstr ""

#: ../../library/io.rst:403
#, fuzzy
msgid ""
"Note that it's already possible to iterate on file objects using ``for "
"line in file: ...`` without calling :meth:`!file.readlines`."
msgstr ""
"``file.readlines()``\\를 호출하지 않고 ``for line in file: ...``\\을 사용하여 파일 객체를 "
"이미 이터레이트 할 수 있음에 유의하십시오."

#: ../../library/io.rst:408
#, fuzzy
msgid ""
"Change the stream position to the given byte *offset*, interpreted "
"relative to the position indicated by *whence*, and return the new "
"absolute position. Values for *whence* are:"
msgstr ""
"스트림 위치를 지정된 바이트 *offset*\\으로 변경합니다. *offset*\\은 *whence*\\가 가리키는 위치를 기준으로"
" 해석됩니다. *whence*\\의 기본값은 :data:`SEEK_SET`\\입니다. *whence*\\의 값은 다음과 같습니다:"

#: ../../library/io.rst:413
#, fuzzy
msgid ""
":data:`os.SEEK_SET` or ``0`` -- start of the stream (the default); "
"*offset* should be zero or positive"
msgstr ":data:`SEEK_SET` 또는 ``0`` -- 스트림의 시작(기본값); *offset*\\은 0이거나 양수여야 합니다"

#: ../../library/io.rst:415
#, fuzzy
msgid ""
":data:`os.SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ":data:`SEEK_CUR` 또는 ``1`` -- 현재 스트림 위치; *offset*\\은 음수일 수 있습니다"

#: ../../library/io.rst:417
#, fuzzy
msgid ""
":data:`os.SEEK_END` or ``2`` -- end of the stream; *offset* is usually "
"negative"
msgstr ":data:`SEEK_END` 또는 ``2`` -- 스트림의 끝; *offset*\\은 일반적으로 음수입니다"

#: ../../library/io.rst:420 ../../library/io.rst:930
#, fuzzy
msgid "The :data:`!SEEK_*` constants."
msgstr "``SEEK_*`` 상수."

#: ../../library/io.rst:423
#, fuzzy
msgid ""
"Some operating systems could support additional values, like "
":const:`os.SEEK_HOLE` or :const:`os.SEEK_DATA`. The valid values for a "
"file could depend on it being open in text or binary mode."
msgstr ""
"일부 운영 체제는 :data:`os.SEEK_HOLE`\\이나 :data:`os.SEEK_DATA`\\와 같은 추가 값을 지원할 수"
" 있습니다. 파일에 대해 유효한 값은 그것이 텍스트나 바이너리 모드 중 어느 것으로 열렸는지에 따라 달라질 수 있습니다."

#: ../../library/io.rst:430
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, "
":meth:`seek`, :meth:`tell` and :meth:`truncate` will raise "
":exc:`OSError`."
msgstr ""
"스트림이 무작위 액세스를 지원하면 ``True``\\를 반환합니다. ``False``\\이면, :meth:`seek`, "
":meth:`tell` 및 :meth:`truncate`\\가 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/io.rst:435
msgid "Return the current stream position."
msgstr "현재의 스트림 위치를 반환합니다."

#: ../../library/io.rst:439
msgid ""
"Resize the stream to the given *size* in bytes (or the current position "
"if *size* is not specified).  The current stream position isn't changed. "
"This resizing can extend or reduce the current file size.  In case of "
"extension, the contents of the new file area depend on the platform (on "
"most systems, additional bytes are zero-filled).  The new file size is "
"returned."
msgstr ""
"바이트 단위로 지정된 *size*\\로 스트림 크기를 조정합니다 (또는 *size*\\가 지정되지 않으면 현재 위치). 현재 스트림"
" 위치는 변경되지 않습니다. 이 크기 조정은 현재 파일 크기를 늘리거나 줄일 수 있습니다. 확장의 경우, 새 파일 영역의 내용은 "
"플랫폼에 따라 다릅니다 (대부분의 시스템에서, 추가 바이트는 0으로 채워집니다). 새 파일 크기가 반환됩니다."

#: ../../library/io.rst:446
msgid "Windows will now zero-fill files when extending."
msgstr "윈도우는 이제 확장 시 파일을 0으로 채웁니다."

#: ../../library/io.rst:451
#, fuzzy
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, "
":meth:`!write` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"스트림이 쓰기를 지원하면 ``True``\\를 반환합니다. ``False``\\이면, :meth:`write`\\와 "
":meth:`truncate`\\는 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/io.rst:456
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so "
"it is usual for each of the lines provided to have a line separator at "
"the end."
msgstr "스트림에 줄 리스트를 씁니다. 줄 구분자는 추가되지 않아서, 제공된 각 줄 끝에 줄 구분자가 있는 것이 일반적입니다."

#: ../../library/io.rst:462
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's "
":meth:`~IOBase.close` method."
msgstr ""
"객체 파괴를 준비합니다. :class:`IOBase`\\는 인스턴스의 :meth:`~IOBase.close` 메서드를 호출하는 이 "
"메서드의 기본 구현을 제공합니다."

#: ../../library/io.rst:469
#, fuzzy
msgid "Base class for raw binary streams.  It inherits from :class:`IOBase`."
msgstr "원시 바이너리 스트림의 베이스 클래스. :class:`IOBase`\\를 상속합니다. 공개 생성자가 없습니다."

#: ../../library/io.rst:471
msgid ""
"Raw binary streams typically provide low-level access to an underlying OS"
" device or API, and do not try to encapsulate it in high-level primitives"
" (this functionality is done at a higher-level in buffered binary streams"
" and text streams, described later in this page)."
msgstr ""
"원시 바이너리 스트림은 일반적으로 하부 OS 장치나 API에 대한 저수준 액세스를 제공하며, 이것을 고수준 프리미티브로 캡슐화하려고"
" 하지 않습니다 (이 기능은 이 페이지에서 나중에 설명할 버퍼링 된 바이너리 스트림과 텍스트 스트림에서 고수준으로 수행됩니다)."

#: ../../library/io.rst:476
msgid ""
":class:`RawIOBase` provides these methods in addition to those from "
":class:`IOBase`:"
msgstr ":class:`RawIOBase`\\는 :class:`IOBase`\\에서 온 것 외에 이 메서드를 제공합니다:"

#: ../../library/io.rst:481
msgid ""
"Read up to *size* bytes from the object and return them.  As a "
"convenience, if *size* is unspecified or -1, all bytes until EOF are "
"returned. Otherwise, only one system call is ever made.  Fewer than "
"*size* bytes may be returned if the operating system call returns fewer "
"than *size* bytes."
msgstr ""
"객체에서 최대 *size* 바이트를 읽고 반환합니다. 편의상, *size*\\가 지정되지 않거나 -1이면, EOF까지의 모든 "
"바이트가 반환됩니다. 그렇지 않으면, 하나의 시스템 호출만 수행됩니다. 운영 체제 시스템 호출이 *size* 바이트 미만을 반환하면"
" *size* 바이트 미만이 반환될 수 있습니다."

#: ../../library/io.rst:486
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of "
"file. If the object is in non-blocking mode and no bytes are available, "
"``None`` is returned."
msgstr ""
"0바이트가 반환되고, *size*\\가 0이 아니면, 파일의 끝을 나타냅니다. 객체가 비 블로킹 모드이고 사용 가능한 바이트가 "
"없으면 ``None``\\이 반환됩니다."

#: ../../library/io.rst:490
msgid "The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr "기본 구현은 :meth:`readall`\\과 :meth:`readinto`\\로 위임합니다."

#: ../../library/io.rst:495
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr "필요한 경우 스트림에 대한 다중 호출을 사용하여, EOF까지 스트림의 모든 바이트를 읽고 반환합니다."

#: ../../library/io.rst:500
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"and return the number of bytes read.  For example, *b* might be a "
":class:`bytearray`. If the object is in non-blocking mode and no bytes "
"are available, ``None`` is returned."
msgstr ""
"미리 할당되고, 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>` *b*\\로 바이트를 읽고 읽은 "
"바이트 수를 반환합니다. 예를 들어, *b*\\는 :class:`bytearray`\\일 수 있습니다. 객체가 비 블로킹 모드이고 "
"사용 가능한 바이트가 없으면, ``None``\\이 반환됩니다."

#: ../../library/io.rst:508
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than "
"the length of *b* in bytes, depending on specifics of the underlying raw "
"stream, and especially if it is in non-blocking mode.  ``None`` is "
"returned if the raw stream is set not to block and no single byte could "
"be readily written to it.  The caller may release or mutate *b* after "
"this method returns, so the implementation should only access *b* during "
"the method call."
msgstr ""
"주어진 :term:`바이트열류 객체 <bytes-like object>`, *b*\\를 하부 원시 스트림에 쓰고, 쓴 바이트 수를 "
"반환합니다. 하부 원시 스트림의 특성에 따라, 특히 비 블로킹 모드이면 바이트 단위로 *b*\\의 길이보다 짧을 수 있습니다. 원시"
" 스트림이 블록 하지 않도록 설정되었고 단일 바이트를 당장 쓸 수 없으면 ``None``\\이 반환됩니다. 호출자는 이 메서드가 "
"반환된 후 *b*\\를 해제하거나 변경할 수 있어서, 구현은 메서드 호출 중에만 *b*\\에 액세스해야 합니다."

#: ../../library/io.rst:521
#, fuzzy
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits from :class:`IOBase`."
msgstr ""
"어떤 종류의 버퍼링을 지원하는 바이너리 스트림의 베이스 클래스. :class:`IOBase`\\를 상속합니다. 공개 생성자가 "
"없습니다."

#: ../../library/io.rst:524
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`,"
" :meth:`readinto` and :meth:`write` will try (respectively) to read as "
"much input as requested or to consume all given output, at the expense of"
" making perhaps more than one system call."
msgstr ""
":class:`RawIOBase`\\와의 주요 차이점은 메서드 :meth:`read`, :meth:`readinto` 및 "
":meth:`write`\\는 요청된 만큼 많은 입력을 읽거나 주어진 출력을 모두 소비하려고 시도한다는 것입니다, 아마도 하나 "
"이상의 시스템 호출을 하는 비용을 치르고서라도."

#: ../../library/io.rst:529
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give "
"enough data; unlike their :class:`RawIOBase` counterparts, they will "
"never return ``None``."
msgstr ""
"또한, 하부 원시 스트림이 비 블로킹 모드에 있고 충분한 데이터를 취하거나 제공할 수 없으면 이러한 메서드들은 "
":exc:`BlockingIOError`\\를 발생시킬 수 있습니다; :class:`RawIOBase`\\의 메서드들과는 달리 "
"``None``\\을 반환하지 않습니다."

#: ../../library/io.rst:534
msgid ""
"Besides, the :meth:`read` method does not have a default implementation "
"that defers to :meth:`readinto`."
msgstr "또한, :meth:`read` 메서드에는 :meth:`readinto`\\로 위임하는 기본 구현이 없습니다."

#: ../../library/io.rst:537
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from "
"a :class:`RawIOBase` implementation, but wrap one, like "
":class:`BufferedWriter` and :class:`BufferedReader` do."
msgstr ""
"일반적인 :class:`BufferedIOBase` 구현은 :class:`RawIOBase` 구현에서 상속하지 말고, "
":class:`BufferedWriter`\\와 :class:`BufferedReader`\\처럼 감싸야 합니다."

#: ../../library/io.rst:541
msgid ""
":class:`BufferedIOBase` provides or overrides these data attributes and "
"methods in addition to those from :class:`IOBase`:"
msgstr ""
":class:`BufferedIOBase`\\는 :class:`IOBase`\\에서 온 것 외에 다음 데이터 어트리뷰트와 메서드를 "
"제공하거나 재정의합니다:"

#: ../../library/io.rst:546
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that "
":class:`BufferedIOBase` deals with.  This is not part of the "
":class:`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
":class:`BufferedIOBase` 가 다루는 하부 원시 스트림 (:class:`RawIOBase` 인스턴스). 이것은 "
":class:`BufferedIOBase` API의 일부가 아니며 일부 구현에는 없을 수 있습니다."

#: ../../library/io.rst:552
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "하부 원시 스트림을 버퍼에서 분리하고 반환합니다."

#: ../../library/io.rst:554
msgid ""
"After the raw stream has been detached, the buffer is in an unusable "
"state."
msgstr "원시 스트림이 분리된 후에는, 버퍼가 사용할 수 없는 상태가 됩니다."

#: ../../library/io.rst:557
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single "
"raw stream to return from this method.  They raise "
":exc:`UnsupportedOperation`."
msgstr ""
":class:`BytesIO`\\와 같은 일부 버퍼에는 이 메서드가 반환할 단일 원시 스트림 개념이 없습니다. 그들은 "
":exc:`UnsupportedOperation`\\을 발생시킵니다."

#: ../../library/io.rst:565
msgid ""
"Read and return up to *size* bytes.  If the argument is omitted, "
"``None``, or negative, data is read and returned until EOF is reached.  "
"An empty :class:`bytes` object is returned if the stream is already at "
"EOF."
msgstr ""
"최대 *size* 바이트를 읽고 반환합니다. 인자가 생략되거나, ``None``\\이거나 음수이면, EOF에 도달할 때까지 데이터를"
" 읽고 반환합니다. 스트림이 이미 EOF에 있으면 빈 :class:`bytes` 객체가 반환됩니다."

#: ../../library/io.rst:569
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most "
"one raw read will be issued, and a short result does not imply that EOF "
"is imminent."
msgstr ""
"인자가 양수이고, 하부 원시 스트림이 대화식이 아니면, 바이트 수를 충족시키기 위해 여러 원시 읽기가 수행될 수 있습니다 (EOF에"
" 먼저 도달하지 않는 한). 그러나 대화식 원시 스트림의 경우, 최대 하나의 원시 읽기가 수행되고 짧은 결과가 EOF가 임박했음을 "
"의미하지는 않습니다."

#: ../../library/io.rst:575 ../../library/io.rst:598 ../../library/io.rst:608
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non"
" blocking-mode, and has no data available at the moment."
msgstr "하부 원시 스트림이 비 블로킹 모드이고, 현재 사용 가능한 데이터가 없으면 :exc:`BlockingIOError` 가 발생합니다."

#: ../../library/io.rst:580
msgid ""
"Read and return up to *size* bytes, with at most one call to the "
"underlying raw stream's :meth:`~RawIOBase.read` (or "
":meth:`~RawIOBase.readinto`) method.  This can be useful if you are "
"implementing your own buffering on top of a :class:`BufferedIOBase` "
"object."
msgstr ""
"하부 원시 스트림의 :meth:`~RawIOBase.read` (또는 :meth:`~RawIOBase.readinto`) 메서드를 "
"최대 한 번만 호출하여, 최대 *size* 바이트를 읽고 반환합니다. :class:`BufferedIOBase` 객체 위에 자체 "
"버퍼링을 구현하는 경우 유용할 수 있습니다."

#: ../../library/io.rst:586
msgid ""
"If *size* is ``-1`` (the default), an arbitrary number of bytes are "
"returned (more than zero unless EOF is reached)."
msgstr "*size*\\가 ``-1``\\(기본값)이면, 임의의 수의 바이트가 반환됩니다 (EOF에 도달하지 않았으면 0보다 큽니다)."

#: ../../library/io.rst:591
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* "
"and return the number of bytes read. For example, *b* might be a "
":class:`bytearray`."
msgstr ""
"미리 할당되고, 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>` *b*\\로 바이트를 읽고 읽은 "
"바이트 수를 반환합니다. 예를 들어, *b*\\는 :class:`bytearray`\\일 수 있습니다."

#: ../../library/io.rst:595
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr ":meth:`read`\\와 마찬가지로, 하부 원시 스트림이 대화식이 아닌 한, 여러 읽기가 수행될 수 있습니다."

#: ../../library/io.rst:603
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's "
":meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) method. Return "
"the number of bytes read."
msgstr ""
"하부 원시 스트림의 :meth:`~RawIOBase.read` (또는 :meth:`~RawIOBase.readinto`) 메서드를 "
"최대 한 번만 호출하여, 미리 할당된 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>` *b*\\로 "
"바이트를 읽습니다. 읽은 바이트 수를 반환합니다."

#: ../../library/io.rst:615
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying "
"stream, or held in a buffer for performance and latency reasons."
msgstr ""
"주어진 :term:`바이트열류 객체 <bytes-like object>`, *b*\\를 쓰고 기록된 바이트 수를 반환합니다 (쓰기에"
" 실패하면 :exc:`OSError`\\가 발생하기 때문에 항상 바이트 단위로 *b* 길이와 같습니다). 실제 구현에 따라, 이러한"
" 바이트는 하부 스트림에 쉽게 쓸 수 있거나, 성능과 지연 이유로 버퍼에 보관될 수 있습니다."

#: ../../library/io.rst:622
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data"
" needed to be written to the raw stream but it couldn't accept all the "
"data without blocking."
msgstr ""
"비 블로킹 모드에서, 데이터를 원시 스트림에 기록해야 하지만 원시 스트림이 블로킹 없이 모든 데이터를 받아들일 수 없으면, "
":exc:`BlockingIOError` 가 발생합니다."

#: ../../library/io.rst:626
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "호출자는 이 메서드가 반환된 후 *b*\\를 해제하거나 변경할 수 있어서, 구현은 메서드 호출 중에만 *b*\\에 액세스해야 합니다."

#: ../../library/io.rst:631
msgid "Raw File I/O"
msgstr "원시 파일 I/O"

#: ../../library/io.rst:635
#, fuzzy
msgid ""
"A raw binary stream representing an OS-level file containing bytes data."
"  It inherits from :class:`RawIOBase`."
msgstr "바이트열 데이터를 포함하는 OS 수준 파일을 나타내는 원시 바이너리 스트림. :class:`RawIOBase`\\를 상속합니다."

#: ../../library/io.rst:638
msgid "The *name* can be one of two things:"
msgstr "*name*\\은 다음 두 가지 중 하나일 수 있습니다:"

#: ../../library/io.rst:640
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"열릴 파일의 경로를 나타내는 문자열이나 :class:`bytes` 객체. 이 경우 closefd는 ``True``\\(기본값)이어야"
" 합니다. 그렇지 않으면 에러가 발생합니다."

#: ../../library/io.rst:643
msgid ""
"an integer representing the number of an existing OS-level file "
"descriptor to which the resulting :class:`FileIO` object will give "
"access. When the FileIO object is closed this fd will be closed as well, "
"unless *closefd* is set to ``False``."
msgstr ""
"결과 :class:`FileIO` 객체가 액세스할 기존 OS 수준 파일 기술자의 번호를 나타내는 정수. FileIO 객체가 닫힐 "
"때, *closefd*\\가 ``False``\\로 설정되어 있지 않은 한 이 fd도 닫힙니다."

#: ../../library/io.rst:648
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will"
" be truncated when opened for writing. :exc:`FileExistsError` will be "
"raised if it already exists when opened for creating. Opening a file for "
"creating implies writing, so this mode behaves in a similar way to "
"``'w'``. Add a ``'+'`` to the mode to allow simultaneous reading and "
"writing."
msgstr ""
"*mode*\\는 읽기(기본값), 쓰기, 배타적 생성 또는 덧붙이기를 위해 ``'r'``, ``'w'``, ``'x'`` 또는 "
"``'a'``\\일 수 있습니다. 쓰기나 덧붙이기로 열 때 파일이 존재하지 않으면 만들어집니다; 쓰기 위해 열면 파일이 잘립니다. "
"생성을 위해 열었을 때 파일이 이미 존재하면 :exc:`FileExistsError` 가 발생합니다. 생성하기 위해 파일을 여는 "
"것은 쓰기를 의미하므로, 이 모드는 ``'w'``\\와 유사한 방식으로 작동합니다. 읽기와 쓰기를 동시에 허락하려면 "
"``'+'``\\를 모드에 추가하십시오."

#: ../../library/io.rst:656
#, fuzzy
msgid ""
"The :meth:`~RawIOBase.read` (when called with a positive argument), "
":meth:`~RawIOBase.readinto` and :meth:`~RawIOBase.write` methods on this "
"class will only make one system call."
msgstr ""
"이 클래스의 :meth:`read` (양수 인자로 호출되었을 때), :meth:`readinto` 및 :meth:`write` "
"메서드는 하나의 시스템 호출만 수행합니다."

#: ../../library/io.rst:660
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by "
"calling *opener* with (*name*, *flags*). *opener* must return an open "
"file descriptor (passing :mod:`os.open` as *opener* results in "
"functionality similar to passing ``None``)."
msgstr ""
"콜러블을 *opener*\\로 전달하여 사용자 정의 오프너를 사용할 수 있습니다. 그러면 파일 객체의 하부 파일 기술자는 "
"(*name*, *flags*)로 *opener*\\를 호출하여 얻습니다. *opener*\\는 열린 파일 기술자를 반환해야 합니다"
" (:mod:`os.open`\\을 *opener*\\로 전달하면 ``None``\\을 전달하는 것과 유사한 기능이 됩니다)."

#: ../../library/io.rst:666
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "새로 만들어진 파일은 :ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../../library/io.rst:668
msgid ""
"See the :func:`open` built-in function for examples on using the *opener*"
" parameter."
msgstr "*opener* 매개 변수 사용에 대한 예는 :func:`open` 내장 함수를 참조하십시오."

#: ../../library/io.rst:671
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr "*opener* 매개 변수가 추가되었습니다. ``'x'`` 모드가 추가되었습니다."

#: ../../library/io.rst:675
msgid "The file is now non-inheritable."
msgstr "이제 파일이 상속 불가능합니다."

#: ../../library/io.rst:678
msgid ""
":class:`FileIO` provides these data attributes in addition to those from "
":class:`RawIOBase` and :class:`IOBase`:"
msgstr ""
":class:`FileIO`\\는 :class:`RawIOBase`\\와 :class:`IOBase`\\에서 온 것 외에 다음 "
"데이터 어트리뷰트를 제공합니다:"

#: ../../library/io.rst:683
msgid "The mode as given in the constructor."
msgstr "생성자에 제공된 모드."

#: ../../library/io.rst:687
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr "파일 이름. 생성자에 이름이 지정되지 않으면 파일의 파일 기술자입니다."

#: ../../library/io.rst:692
msgid "Buffered Streams"
msgstr "버퍼링 된 스트림"

#: ../../library/io.rst:694
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device "
"than raw I/O does."
msgstr "버퍼링 된 I/O 스트림은 원시 I/O보다 I/O 장치에 대한 더 고수준의 인터페이스를 제공합니다."

#: ../../library/io.rst:699
#, fuzzy
msgid ""
"A binary stream using an in-memory bytes buffer.  It inherits from "
":class:`BufferedIOBase`.  The buffer is discarded when the "
":meth:`~IOBase.close` method is called."
msgstr ""
"인 메모리 바이트 버퍼를 사용하는 바이너리 스트림. :class:`BufferedIOBase`\\를 상속합니다. "
":meth:`~IOBase.close` 메서드가 호출될 때 버퍼가 폐기됩니다."

#: ../../library/io.rst:703
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that"
" contains initial data."
msgstr ""
"선택적 인자 *initial_bytes*\\는 초기 데이터를 포함하는 :term:`바이트열류 객체 <bytes-like "
"object>`\\입니다."

#: ../../library/io.rst:706
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those"
" from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BytesIO`\\는 :class:`BufferedIOBase`\\와 :class:`IOBase`\\의 메서드 외에 "
"다음 메서드를 제공하거나 재정의합니다:"

#: ../../library/io.rst:711
msgid ""
"Return a readable and writable view over the contents of the buffer "
"without copying them.  Also, mutating the view will transparently update "
"the contents of the buffer::"
msgstr ""
"복사하지 않고 버퍼의 내용에 대한 읽을 수 있고 쓸 수 있는 뷰를 반환합니다. 또한, 뷰를 변경하면 버퍼의 내용이 투명하게 "
"갱신됩니다::"

#: ../../library/io.rst:715
msgid ""
">>> b = io.BytesIO(b\"abcdef\")\n"
">>> view = b.getbuffer()\n"
">>> view[2:4] = b\"56\"\n"
">>> b.getvalue()\n"
"b'ab56ef'"
msgstr ""

#: ../../library/io.rst:722
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized"
" or closed."
msgstr "뷰가 존재하는 한, :class:`BytesIO` 객체의 크기를 조정하거나 닫을 수 없습니다."

#: ../../library/io.rst:729
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr "버퍼의 전체 내용을 포함하는 :class:`bytes`\\를 반환합니다."

#: ../../library/io.rst:734
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr ":class:`BytesIO`\\에서, 이것은 :meth:`~BufferedIOBase.read`\\와 같습니다."

#: ../../library/io.rst:736 ../../library/io.rst:779
msgid "The *size* argument is now optional."
msgstr "*size* 인자는 이제 선택적입니다."

#: ../../library/io.rst:741
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr ":class:`BytesIO`\\에서, 이것은 :meth:`~BufferedIOBase.readinto`\\와 같습니다."

#: ../../library/io.rst:747
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to a readable, non"
" seekable :class:`RawIOBase` raw binary stream.  It inherits from "
":class:`BufferedIOBase`."
msgstr ""
"읽을 수 있고 탐색할 수 없는(non seekable) :class:`RawIOBase` 원시 바이너리 스트림에 대한 고수준의 "
"액세스를 제공하는 버퍼링 된 바이너리 스트림. :class:`BufferedIOBase`\\를 상속합니다."

#: ../../library/io.rst:751
msgid ""
"When reading data from this object, a larger amount of data may be "
"requested from the underlying raw stream, and kept in an internal buffer."
" The buffered data can then be returned directly on subsequent reads."
msgstr ""
"이 객체에서 데이터를 읽을 때, 하부 원시 스트림에서 더 많은 양의 데이터가 요청되어, 내부 버퍼에 보관될 수 있습니다. 버퍼링 된"
" 데이터는 후속 읽기에서 직접 반환될 수 있습니다."

#: ../../library/io.rst:755
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, "
":data:`DEFAULT_BUFFER_SIZE` is used."
msgstr ""
"생성자는 주어진 읽을 수 있는 *raw* 스트림과 *buffer_size*\\에 대해 "
":class:`BufferedReader`\\를 만듭니다. *buffer_size*\\를 생략하면, "
":data:`DEFAULT_BUFFER_SIZE`\\가 사용됩니다."

#: ../../library/io.rst:759
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition "
"to those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedReader`\\는 :class:`BufferedIOBase`\\와 :class:`IOBase`\\의 "
"메서드 외에 다음 메서드를 제공하거나 재정의합니다:"

#: ../../library/io.rst:764
msgid ""
"Return bytes from the stream without advancing the position.  At most one"
" single read on the raw stream is done to satisfy the call. The number of"
" bytes returned may be less or more than requested."
msgstr ""
"위치를 전진시키지 않고 스트림에서 바이트열을 반환합니다. 호출을 충족시키기 위해 원시 스트림에서 최대 하나의 단일 읽기가 "
"수행됩니다. 반환된 바이트 수는 요청된 것보다 적거나 많을 수 있습니다."

#: ../../library/io.rst:770
msgid ""
"Read and return *size* bytes, or if *size* is not given or negative, "
"until EOF or if the read call would block in non-blocking mode."
msgstr ""
"*size* 바이트를, *size*\\가 주어지지 않았거나 음수이면, EOF까지 혹은 읽기 호출이 비 블로킹 모드에서 블록 되기 "
"전까지 읽고 반환합니다."

#: ../../library/io.rst:775
msgid ""
"Read and return up to *size* bytes with only one call on the raw stream. "
"If at least one byte is buffered, only buffered bytes are returned. "
"Otherwise, one raw stream read call is made."
msgstr ""
"원시 스트림에 대한 한 번의 호출로 최대 *size* 바이트를 읽고 반환합니다. 적어도 1바이트가 버퍼링 되어 있으면, 버퍼링 된 "
"바이트만 반환됩니다. 그렇지 않으면, 하나의 원시 스트림 읽기 호출이 수행됩니다."

#: ../../library/io.rst:785
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to a writeable, "
"non seekable :class:`RawIOBase` raw binary stream.  It inherits from "
":class:`BufferedIOBase`."
msgstr ""
"쓸 수 있고 탐색할 수 없는(non seekable) :class:`RawIOBase` 원시 바이너리 스트림에 대한 고수준 액세스를"
" 제공하는 버퍼링 된 바이너리 스트림. :class:`BufferedIOBase`\\를 상속합니다."

#: ../../library/io.rst:789
msgid ""
"When writing to this object, data is normally placed into an internal "
"buffer.  The buffer will be written out to the underlying "
":class:`RawIOBase` object under various conditions, including:"
msgstr ""
"이 객체에 쓸 때, 데이터는 일반적으로 내부 버퍼에 배치됩니다. 버퍼는 다음과 같은 다양한 조건에서 하부 "
":class:`RawIOBase` 객체에 기록됩니다:"

#: ../../library/io.rst:793
msgid "when the buffer gets too small for all pending data;"
msgstr "계류 중인 모든 데이터에 비해 버퍼가 너무 작아질 때;"

#: ../../library/io.rst:794
#, fuzzy
msgid "when :meth:`flush` is called;"
msgstr ":meth:`flush()`\\가 호출될 때;"

#: ../../library/io.rst:795
#, fuzzy
msgid ""
"when a :meth:`~IOBase.seek` is requested (for :class:`BufferedRandom` "
"objects);"
msgstr ":meth:`seek()`\\이 요청될 때 (:class:`BufferedRandom` 객체의 경우);"

#: ../../library/io.rst:796
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr ":class:`BufferedWriter` 객체가 닫히거나 파괴될 때."

#: ../../library/io.rst:798
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable"
" *raw* stream.  If the *buffer_size* is not given, it defaults to "
":data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"생성자는 주어진 쓰기 가능한 *raw* 스트림에 대해 :class:`BufferedWriter`\\를 만듭니다. "
"*buffer_size*\\가 제공되지 않으면, 기본값은 :data:`DEFAULT_BUFFER_SIZE`\\입니다."

#: ../../library/io.rst:802
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition "
"to those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedWriter`\\는 :class:`BufferedIOBase`\\와 :class:`IOBase`\\의 "
"메서드 외에 다음 메서드를 제공하거나 재정의합니다:"

#: ../../library/io.rst:807
msgid ""
"Force bytes held in the buffer into the raw stream.  A "
":exc:`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""
"버퍼에 있는 바이트를 원시 스트림으로 강제 출력합니다. 원시 스트림이 블록되면 :exc:`BlockingIOError`\\를 "
"발생시켜야 합니다."

#: ../../library/io.rst:812
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` is raised "
"if the buffer needs to be written out but the raw stream blocks."
msgstr ""
":term:`바이트열류 객체 <bytes-like object>`, *b*\\를 쓰고 쓴 바이트 수를 반환합니다. 비 블로킹 모드일"
" 때, 버퍼를 기록해야 하지만 원시 스트림이 블록하면 :exc:`BlockingIOError` 가 발생합니다."

#: ../../library/io.rst:820
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to a seekable "
":class:`RawIOBase` raw binary stream.  It inherits from "
":class:`BufferedReader` and :class:`BufferedWriter`."
msgstr ""
"탐색할 수 있는 (seekable) :class:`RawIOBase` 원시 바이너리 스트림에 고수준의 액세스를 제공하는 버퍼링 된 "
"바이너리 스트림. :class:`BufferedReader`\\와 :class:`BufferedWriter`\\를 상속합니다."

#: ../../library/io.rst:824
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, "
"given in the first argument.  If the *buffer_size* is omitted it defaults"
" to :data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"생성자는 첫 번째 인자로 주어진 탐색 가능한 원시 스트림에 대한 판독기(reader)와 기록기(writer)를 만듭니다. "
"*buffer_size*\\를 생략하면 기본값은 :data:`DEFAULT_BUFFER_SIZE`\\입니다."

#: ../../library/io.rst:828
#, fuzzy
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or"
" :class:`BufferedWriter` can do.  In addition, :meth:`~IOBase.seek` and "
":meth:`~IOBase.tell` are guaranteed to be implemented."
msgstr ""
":class:`BufferedRandom`\\은 :class:`BufferedReader`\\나 "
":class:`BufferedWriter`\\가 수행 할 수 있는 모든 작업을 수행할 수 있습니다. 또한, "
":meth:`seek`\\과 :meth:`tell`\\이 구현되도록 보장됩니다."

#: ../../library/io.rst:835
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to two non "
"seekable :class:`RawIOBase` raw binary streams---one readable, the other "
"writeable. It inherits from :class:`BufferedIOBase`."
msgstr ""
"하나는 읽을 수 있고, 다른 하나는 쓸 수 있는, 두 개의 탐색할 수 없는 (non seekable) "
":class:`RawIOBase` 원시 바이너리 스트림에 대한 고수준 액세스를 제공하는 버퍼링 된 바이너리 스트림. "
":class:`BufferedIOBase`\\를 상속합니다."

#: ../../library/io.rst:839
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable "
"and writeable respectively.  If the *buffer_size* is omitted it defaults "
"to :data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"*reader*\\와 *writer*\\는 각각 읽고 쓸 수 있는 :class:`RawIOBase` 객체입니다. "
"*buffer_size*\\가 생략되면 기본값은 :data:`DEFAULT_BUFFER_SIZE`\\입니다."

#: ../../library/io.rst:843
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises "
":exc:`UnsupportedOperation`."
msgstr ""
":class:`BufferedRWPair`\\는 :exc:`UnsupportedOperation`\\을 발생시키는 "
":meth:`~BufferedIOBase.detach`\\를 제외한 모든 :class:`BufferedIOBase` 의 메서드를 "
"구현합니다."

#: ../../library/io.rst:849
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader"
" and writer; use :class:`BufferedRandom` instead."
msgstr ""
":class:`BufferedRWPair`\\는 하부 원시 스트림에 대한 동기화된 액세스를 시도하지 않습니다. reader와 "
"writer로 같은 객체를 전달해서는 안 됩니다; 대신 :class:`BufferedRandom`\\을 사용하십시오."

#: ../../library/io.rst:859
#, fuzzy
msgid ""
"Base class for text streams.  This class provides a character and line "
"based interface to stream I/O.  It inherits from :class:`IOBase`."
msgstr ""
"텍스트 스트림의 베이스 클래스. 이 클래스는 스트림 I/O를 위한 문자와 줄 기반 인터페이스를 제공합니다. "
":class:`IOBase`\\를 상속합니다. 공개 생성자가 없습니다."

#: ../../library/io.rst:862
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and "
"methods in addition to those from :class:`IOBase`:"
msgstr ""
":class:`TextIOBase`\\는 :class:`IOBase`\\에서 온 것 외에 다음 데이터 어트리뷰트와 메서드를 "
"제공하거나 재정의합니다:"

#: ../../library/io.rst:867
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, "
"and to encode strings into bytes."
msgstr "스트림의 바이트열을 문자열로 디코딩하고, 문자열을 바이트열로 인코딩하는 데 사용되는 인코딩의 이름."

#: ../../library/io.rst:872
msgid "The error setting of the decoder or encoder."
msgstr "디코더나 인코더의 에러 설정."

#: ../../library/io.rst:876
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr ""
"지금까지 번역된 줄 넘김을 나타내는, 문자열, 문자열 튜플 또는 ``None``. 구현과 초기 생성자 플래그에 따라, 사용하지 못할"
" 수 있습니다."

#: ../../library/io.rst:882
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that "
":class:`TextIOBase` deals with.  This is not part of the "
":class:`TextIOBase` API and may not exist in some implementations."
msgstr ""
":class:`TextIOBase`\\가 다루는 하부 바이너리 버퍼 (:class:`BufferedIOBase` 인스턴스). 이것은"
" :class:`TextIOBase` API의 일부가 아니며 일부 구현에는 없을 수 있습니다."

#: ../../library/io.rst:888
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr "하부 바이너리 버퍼를 :class:`TextIOBase`\\와 분리하여 반환합니다."

#: ../../library/io.rst:891
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is"
" in an unusable state."
msgstr "하부 버퍼가 분리된 후에는, :class:`TextIOBase`\\는 사용할 수 없는 상태가 됩니다."

#: ../../library/io.rst:894
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not"
" have the concept of an underlying buffer and calling this method will "
"raise :exc:`UnsupportedOperation`."
msgstr ""
":class:`StringIO`\\와 같은 일부 :class:`TextIOBase` 구현에는 하부 버퍼 개념이 없을 수 있으며 이 "
"메서드를 호출하면 :exc:`UnsupportedOperation`\\이 발생합니다."

#: ../../library/io.rst:902
msgid ""
"Read and return at most *size* characters from the stream as a single "
":class:`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr ""
"스트림에서 최대 *size* 문자를 단일 :class:`str`\\로 읽고 반환합니다. *size*\\가 음수이거나 "
"``None``\\이면 EOF까지 읽습니다."

#: ../../library/io.rst:907
#, fuzzy
msgid ""
"Read until newline or EOF and return a single :class:`str`.  If the "
"stream is already at EOF, an empty string is returned."
msgstr "줄 넘김이나 EOF까지 읽고 단일 ``str``\\을 반환합니다. 스트림이 이미 EOF에 있으면, 빈 문자열이 반환됩니다."

#: ../../library/io.rst:910
msgid "If *size* is specified, at most *size* characters will be read."
msgstr "*size*\\가 지정되면, 최대 *size* 문자를 읽습니다."

#: ../../library/io.rst:914
#, fuzzy
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on "
"the *whence* parameter.  The default value for *whence* is "
":data:`!SEEK_SET`."
msgstr ""
"스트림 위치를 지정된 *offset*\\으로 변경합니다. 동작은 *whence* 매개 변수에 따라 다릅니다. *whence*\\의 "
"기본값은 :data:`SEEK_SET`\\입니다."

#: ../../library/io.rst:918
#, fuzzy
msgid ""
":data:`!SEEK_SET` or ``0``: seek from the start of the stream (the "
"default); *offset* must either be a number returned by "
":meth:`TextIOBase.tell`, or zero.  Any other *offset* value produces "
"undefined behaviour."
msgstr ""
":data:`SEEK_SET`\\이나 ``0``: 스트림의 시작부터 탐색합니다 (기본값); *offset*\\은 "
":meth:`TextIOBase.tell`\\이 반환한 숫자이거나 0이어야 합니다. 다른 *offset* 값은 정의되지 않은 동작을"
" 생성합니다."

#: ../../library/io.rst:922
#, fuzzy
msgid ""
":data:`!SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* "
"must be zero, which is a no-operation (all other values are unsupported)."
msgstr ""
":data:`SEEK_CUR`\\이나 ``1``: 현재 위치로 \"seek\" 합니다; *offset*\\은 0이어야 하며, 이는 "
"아무런 일도 하지 않습니다 (다른 모든 값은 지원되지 않습니다)."

#: ../../library/io.rst:925
#, fuzzy
msgid ""
":data:`!SEEK_END` or ``2``: seek to the end of the stream; *offset* must "
"be zero (all other values are unsupported)."
msgstr ""
":data:`SEEK_END`\\나 ``2``: 스트림의 끝으로 seek 합니다; *offset*\\은 0이어야 합니다 (다른 모든"
" 값은 지원되지 않습니다)."

#: ../../library/io.rst:928
msgid "Return the new absolute position as an opaque number."
msgstr "새로운 절대 위치를 불투명한 숫자로 반환합니다."

#: ../../library/io.rst:935
msgid ""
"Return the current stream position as an opaque number.  The number does "
"not usually represent a number of bytes in the underlying binary storage."
msgstr "현재 스트림 위치를 불투명한 숫자로 반환합니다. 숫자는 일반적으로 하부 바이너리 저장소의 바이트 수를 나타내지 않습니다."

#: ../../library/io.rst:941
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr "문자열 *s*\\를 스트림에 쓰고 쓴 문자 수를 반환합니다."

#: ../../library/io.rst:948
#, fuzzy
msgid ""
"A buffered text stream providing higher-level access to a "
":class:`BufferedIOBase` buffered binary stream.  It inherits from "
":class:`TextIOBase`."
msgstr ""
":class:`BufferedIOBase` 버퍼링 된 바이너리 스트림에 대한 고수준의 액세스를 제공하는 버퍼링 된 텍스트 스트림. "
":class:`TextIOBase`\\를 상속합니다."

#: ../../library/io.rst:952
#, fuzzy
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded"
" or encoded with.  It defaults to :func:`locale.getencoding`. "
"``encoding=\"locale\"`` can be used to specify the current locale's "
"encoding explicitly. See :ref:`io-text-encoding` for more information."
msgstr ""
"*encoding*\\은 스트림이 디코딩이나 인코딩될 인코딩의 이름을 제공합니다. 기본값은 "
":func:`locale.getpreferredencoding(False) "
"<locale.getpreferredencoding>`\\입니다."

#: ../../library/io.rst:957
#, python-brace-format
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError`"
" exception if there is an encoding error (the default of ``None`` has the"
" same effect), or pass ``'ignore'`` to ignore errors.  (Note that "
"ignoring encoding errors can lead to data loss.)  ``'replace'`` causes a "
"replacement marker (such as ``'?'``) to be inserted where there is "
"malformed data. ``'backslashreplace'`` causes malformed data to be "
"replaced by a backslashed escape sequence.  When writing, "
"``'xmlcharrefreplace'`` (replace with the appropriate XML character "
"reference)  or ``'namereplace'`` (replace with ``\\N{...}`` escape "
"sequences) can be used.  Any other error handling name that has been "
"registered with :func:`codecs.register_error` is also valid."
msgstr ""
"*errors*\\는 인코딩과 디코딩 에러 처리 방법을 지정하는 선택적 문자열입니다. 인코딩 에러가 있을 때 "
":exc:`ValueError` 예외를 발생시키려면 ``'strict'``\\를 전달하고 (기본값 ``None``\\은 같은 효과를"
" 줍니다), 에러를 무시하려면 ``'ignore'``\\를 전달하십시오. (인코딩 에러를 무시하면 데이터가 손실될 수 있음에 "
"유의하십시오.) ``'replace'``\\는 잘못된 데이터가 있는 곳에 대체 마커(가령 ``'?'``)가 삽입되도록 합니다. "
"``'backslashreplace'``\\는 잘못된 데이터를 역 슬래시 이스케이프 시퀀스로 대체합니다. 기록할 때, "
"``'xmlcharrefreplace'``\\(적절한 XML 문자 참조로 대체합니다)나 "
"``'namereplace'``\\(``\\N{...}`` 이스케이프 시퀀스로 대체합니다)를 사용할 수 있습니다. "
":func:`codecs.register_error`\\로 등록된 다른 에러 처리 이름도 유효합니다."

#: ../../library/io.rst:973
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline*\\은 줄 끝 처리 방법을 제어합니다. ``None``, ``''``, ``'\\n'``, ``'\\r'`` 및 "
"``'\\r\\n'`` 일 수 있습니다. 다음과 같이 작동합니다:"

#: ../../library/io.rst:976
msgid ""
"When reading input from the stream, if *newline* is ``None``, "
":term:`universal newlines` mode is enabled.  Lines in the input can end "
"in ``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If *newline* is ``''``, "
"universal newlines mode is enabled, but line endings are returned to the "
"caller untranslated.  If *newline* has any of the other legal values, "
"input lines are only terminated by the given string, and the line ending "
"is returned to the caller untranslated."
msgstr ""
"스트림에서 입력을 읽을 때, *newline*\\이 ``None``\\이면, :term:`유니버설 줄 넘김 <universal "
"newlines>` 모드가 활성화됩니다. 입력의 줄은 ``'\\n'``, ``'\\r'`` 또는 ``'\\r\\n'``\\으로 끝날"
" 수 있으며, 호출자에게 반환되기 전에 ``'\\n'``\\으로 변환됩니다. *newline*\\이 ``''``\\이면, 유니버설 "
"줄 넘김 모드가 활성화되지만, 줄 끝은 변환되지 않은 상태로 호출자에게 반환됩니다. *newline*\\이 다른 유효한 값이면, "
"입력 줄은 주어진 문자열로만 끝나고, 줄 끝은 변환되지 않은 상태로 호출자에게 반환됩니다."

#: ../../library/io.rst:985
msgid ""
"When writing output to the stream, if *newline* is ``None``, any "
"``'\\n'`` characters written are translated to the system default line "
"separator, :data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no "
"translation takes place.  If *newline* is any of the other legal values, "
"any ``'\\n'`` characters written are translated to the given string."
msgstr ""
"스트림에 출력을 기록할 때, *newline*\\이 ``None``\\이면, 기록되는 모든 ``'\\n'`` 문자는 시스템 기본 줄"
" 구분자 :data:`os.linesep`\\으로 변환됩니다. *newline*\\이 ``''``\\이나 ``'\\n'``\\이면,"
" 변환이 수행되지 않습니다. *newline*\\이 다른 유효한 값이면, 기록되는 모든 ``'\\n'`` 문자는 주어진 문자열로 "
"변환됩니다."

#: ../../library/io.rst:991
#, fuzzy
msgid ""
"If *line_buffering* is ``True``, :meth:`~IOBase.flush` is implied when a "
"call to write contains a newline character or a carriage return."
msgstr ""
"*line_buffering*\\이 ``True``\\이면, write 호출에 줄 넘김 문자나 캐리지 리턴이 포함되어 있으면 "
":meth:`flush`\\가 암시됩니다."

#: ../../library/io.rst:994
#, fuzzy
msgid ""
"If *write_through* is ``True``, calls to :meth:`~BufferedIOBase.write` "
"are guaranteed not to be buffered: any data written on the "
":class:`TextIOWrapper` object is immediately handled to its underlying "
"binary *buffer*."
msgstr ""
"*write_through*\\가 ``True``\\이면, :meth:`write`\\에 대한 호출은 버퍼링 되지 않음이 "
"보장됩니다: :class:`TextIOWrapper` 객체에 기록된 모든 데이터는 즉시 하부 바이너리 *buffer*\\로 "
"처리됩니다."

#: ../../library/io.rst:998
msgid "The *write_through* argument has been added."
msgstr "*write_through* 인자가 추가되었습니다."

#: ../../library/io.rst:1001
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` "
"instead of ``locale.getpreferredencoding()``. Don't change temporary the "
"locale encoding using :func:`locale.setlocale`, use the current locale "
"encoding instead of the user preferred encoding."
msgstr ""
"기본 *encoding*\\은 이제 ``locale.getpreferredencoding()`` 대신 "
"``locale.getpreferredencoding(False)``\\입니다. :func:`locale.setlocale`\\을 "
"사용하여 임시 로케일 인코딩을 변경하지 않고, 사용자가 선호하는 인코딩 대신 현재 로케일 인코딩을 사용합니다."

#: ../../library/io.rst:1007
msgid ""
"The *encoding* argument now supports the ``\"locale\"`` dummy encoding "
"name."
msgstr ""

#: ../../library/io.rst:1010
msgid ""
":class:`TextIOWrapper` provides these data attributes and methods in "
"addition to those from :class:`TextIOBase` and :class:`IOBase`:"
msgstr ""
":class:`TextIOWrapper`\\는 :class:`TextIOBase`\\와 :class:`IOBase`\\에서 온 것 "
"외에 다음 데이터 어트리뷰트와 메서드를 제공합니다:"

#: ../../library/io.rst:1015
msgid "Whether line buffering is enabled."
msgstr "줄 버퍼링이 활성화되었는지 여부."

#: ../../library/io.rst:1019
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr "쓰기가 하부 바이너리 버퍼로 즉시 전달되는지 여부."

#: ../../library/io.rst:1027
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*,"
" *newline*, *line_buffering* and *write_through*."
msgstr ""
"*encoding*, *errors*, *newline*, *line_buffering* 및 *write_through*\\에 대한"
" 새로운 설정을 사용하여 이 텍스트 스트림을 재구성합니다."

#: ../../library/io.rst:1030
msgid ""
"Parameters not specified keep current settings, except "
"``errors='strict'`` is used when *encoding* is specified but *errors* is "
"not specified."
msgstr ""
"*encoding*\\이 지정되었지만, *errors*\\가 지정되지 않았을 때 ``errors='strict'``\\가 사용되는 "
"것을 제외하고, 지정되지 않은 매개 변수는 현재 설정을 유지합니다."

#: ../../library/io.rst:1034
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr ""
"스트림에서 일부 데이터를 이미 읽었다면 encoding이나 newline을 변경할 수 없습니다. 반면에, 기록 후의 encoding"
" 변경은 가능합니다."

#: ../../library/io.rst:1038
msgid ""
"This method does an implicit stream flush before setting the new "
"parameters."
msgstr "이 메서드는 새 매개 변수를 설정하기 전에 묵시적 스트림 플러시를 수행합니다."

#: ../../library/io.rst:1043
msgid "The method supports ``encoding=\"locale\"`` option."
msgstr ""

#: ../../library/io.rst:1048
msgid ""
"Set the stream position. Return the new stream position as an "
":class:`int`."
msgstr ""

#: ../../library/io.rst:1051
msgid ""
"Four operations are supported, given by the following argument "
"combinations:"
msgstr ""

#: ../../library/io.rst:1054
msgid "``seek(0, SEEK_SET)``: Rewind to the start of the stream."
msgstr ""

#: ../../library/io.rst:1055
msgid ""
"``seek(cookie, SEEK_SET)``: Restore a previous position; *cookie* **must "
"be** a number returned by :meth:`tell`."
msgstr ""

#: ../../library/io.rst:1057
msgid "``seek(0, SEEK_END)``: Fast-forward to the end of the stream."
msgstr ""

#: ../../library/io.rst:1058
#, fuzzy
msgid "``seek(0, SEEK_CUR)``: Leave the current stream position unchanged."
msgstr "현재의 스트림 위치를 반환합니다."

#: ../../library/io.rst:1060
msgid "Any other argument combinations are invalid, and may raise exceptions."
msgstr ""

#: ../../library/io.rst:1065
msgid ":data:`os.SEEK_SET`, :data:`os.SEEK_CUR`, and :data:`os.SEEK_END`."
msgstr ""

#: ../../library/io.rst:1069
msgid ""
"Return the stream position as an opaque number. The return value of "
":meth:`!tell` can be given as input to :meth:`seek`, to restore a "
"previous stream position."
msgstr ""

#: ../../library/io.rst:1076
#, fuzzy
msgid ""
"A text stream using an in-memory text buffer.  It inherits from "
":class:`TextIOBase`."
msgstr "인 메모리 텍스트 버퍼를 사용하는 텍스트 스트림. :class:`TextIOBase`\\를 상속합니다."

#: ../../library/io.rst:1079
msgid ""
"The text buffer is discarded when the :meth:`~IOBase.close` method is "
"called."
msgstr ":meth:`~IOBase.close` 메서드가 호출될 때 텍스트 버퍼가 폐기됩니다."

#: ../../library/io.rst:1082
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. "
"If newline translation is enabled, newlines will be encoded as if by "
":meth:`~TextIOBase.write`.  The stream is positioned at the start of the "
"buffer which emulates opening an existing file in a ``w+`` mode, making "
"it ready for an immediate write from the beginning or for a write that "
"would overwrite the initial value.  To emulate opening a file in an "
"``a+`` mode ready for appending, use ``f.seek(0, io.SEEK_END)`` to "
"reposition the stream at the end of the buffer."
msgstr ""

#: ../../library/io.rst:1091
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`, except "
"that when writing output to the stream, if *newline* is ``None``, "
"newlines are written as ``\\n`` on all platforms."
msgstr ""
"출력을 스트림에 쓸 때, *newline*\\이 ``None``\\이면, 모든 플랫폼에서 줄 넘김이 ``\\n``\\로 기록된다는 "
"점을 제외하고는, *newline* 인자는 :class:`TextIOWrapper`\\에서 처럼 작동합니다."

#: ../../library/io.rst:1095
msgid ""
":class:`StringIO` provides this method in addition to those from "
":class:`TextIOBase` and :class:`IOBase`:"
msgstr ""
":class:`StringIO`\\는 :class:`TextIOBase`\\와 :class:`IOBase`\\의 메서드 외에 이 "
"메서드를 제공합니다:"

#: ../../library/io.rst:1100
#, fuzzy
msgid ""
"Return a :class:`str` containing the entire contents of the buffer. "
"Newlines are decoded as if by :meth:`~TextIOBase.read`, although the "
"stream position is not changed."
msgstr ""
"버퍼의 전체 내용을 포함하는 ``str``\\을 반환합니다. 스트림 위치는 변경되지 않지만, 줄 넘김은 "
":meth:`~TextIOBase.read`\\와 같이 디코딩됩니다."

#: ../../library/io.rst:1104
msgid "Example usage::"
msgstr "사용 예::"

#: ../../library/io.rst:1106
msgid ""
"import io\n"
"\n"
"output = io.StringIO()\n"
"output.write('First line.\\n')\n"
"print('Second line.', file=output)\n"
"\n"
"# Retrieve file contents -- this will be\n"
"# 'First line.\\nSecond line.\\n'\n"
"contents = output.getvalue()\n"
"\n"
"# Close object and discard memory buffer --\n"
"# .getvalue() will now raise an exception.\n"
"output.close()"
msgstr ""

#: ../../library/io.rst:1126
#, fuzzy
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode."
" It inherits from :class:`codecs.IncrementalDecoder`."
msgstr ""
":term:`유니버설 줄 넘김 <universal newlines>` 모드의 줄 넘김 디코딩을 하는 도우미 코덱. "
":class:`codecs.IncrementalDecoder`\\를 상속합니다."

#: ../../library/io.rst:1131
msgid "Performance"
msgstr "성능"

#: ../../library/io.rst:1133
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr "이 섹션에서는 제공된 구상 I/O 구현의 성능에 대해 논합니다."

#: ../../library/io.rst:1139
msgid ""
"By reading and writing only large chunks of data even when the user asks "
"for a single byte, buffered I/O hides any inefficiency in calling and "
"executing the operating system's unbuffered I/O routines.  The gain "
"depends on the OS and the kind of I/O which is performed.  For example, "
"on some modern OSes such as Linux, unbuffered disk I/O can be as fast as "
"buffered I/O.  The bottom line, however, is that buffered I/O offers "
"predictable performance regardless of the platform and the backing "
"device.  Therefore, it is almost always preferable to use buffered I/O "
"rather than unbuffered I/O for binary data."
msgstr ""
"사용자가 단일 바이트를 요청할 때조차 큰 데이터 청크만 읽고 써서, 버퍼링 된 I/O는 운영 체제의 버퍼링 되지 않은 I/O 루틴을"
" 호출하고 실행할 때의 비효율성을 숨깁니다. 이득은 OS 와 수행되는 I/O 종류에 따라 다릅니다. 예를 들어, 리눅스와 같은 일부"
" 최신 OS에서는, 버퍼링 되지 않은 디스크 I/O는 버퍼링 된 I/O만큼 빠를 수 있습니다. 그러나 요점은 버퍼링 된 I/O가 "
"플랫폼과 배경 장치와 관계없이 예측 가능한 성능을 제공한다는 것입니다. 따라서, 바이너리 데이터에는 버퍼링 되지 않은 I/O보다는 "
"버퍼링 된 I/O를 사용하는 것이 거의 항상 바람직합니다."

#: ../../library/io.rst:1151
#, fuzzy
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower "
"than binary I/O over the same storage, because it requires conversions "
"between unicode and binary data using a character codec.  This can become"
" noticeable handling huge amounts of text data like large log files.  "
"Also, :meth:`~TextIOBase.tell` and :meth:`~TextIOBase.seek` are both "
"quite slow due to the reconstruction algorithm used."
msgstr ""
"바이너리 저장소(가령 파일)에 대한 텍스트 I/O는 같은 저장소에 대한 바이너리 I/O보다 상당히 느린데, 문자 코덱을 사용하여 "
"유니코드와 바이너리 데이터 간의 변환이 필요하기 때문입니다. 이것은 큰 로그 파일과 같은 많은 양의 텍스트 데이터를 처리할 때 "
"드러날 수 있습니다. 또한, :meth:`TextIOWrapper.tell`\\과 "
":meth:`TextIOWrapper.seek`\\은 사용된 재구성 알고리즘으로 인해 상당히 느립니다."

#: ../../library/io.rst:1158
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and "
"will exhibit similar speed to :class:`BytesIO`."
msgstr ""
"그러나, :class:`StringIO`\\는 네이티브 인 메모리 유니코드 컨테이너이며 :class:`BytesIO`\\와 비슷한 "
"속도를 나타냅니다."

#: ../../library/io.rst:1162
msgid "Multi-threading"
msgstr "다중 스레드"

#: ../../library/io.rst:1164
#, fuzzy
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as :manpage:`read(2)` under Unix) they wrap are "
"thread-safe too."
msgstr ":class:`FileIO` 객체는 감싼 운영 체제 호출(가령 유닉스의 ``read(2)``)이 스레드 안전하다면 스레드 안전합니다."

#: ../../library/io.rst:1167
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) protect their internal structures using a lock; "
"it is therefore safe to call them from multiple threads at once."
msgstr ""
"바이너리 버퍼링 된 객체(:class:`BufferedReader`, :class:`BufferedWriter`, "
":class:`BufferedRandom` 및 :class:`BufferedRWPair` 의 인스턴스)는 록을 사용하여 내부 구조를"
" 보호합니다; 따라서 여러 스레드에서 동시에 호출하는 것이 안전합니다."

#: ../../library/io.rst:1172
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ":class:`TextIOWrapper` 객체는 스레드 안전하지 않습니다."

#: ../../library/io.rst:1175
msgid "Reentrancy"
msgstr "재진입"

#: ../../library/io.rst:1177
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, "
":class:`BufferedWriter`, :class:`BufferedRandom` and "
":class:`BufferedRWPair`) are not reentrant.  While reentrant calls will "
"not happen in normal situations, they can arise from doing I/O in a "
":mod:`signal` handler.  If a thread tries to re-enter a buffered object "
"which it is already accessing, a :exc:`RuntimeError` is raised.  Note "
"this doesn't prohibit a different thread from entering the buffered "
"object."
msgstr ""
"바이너리 버퍼링 된 객체(:class:`BufferedReader`, :class:`BufferedWriter`, "
":class:`BufferedRandom` 및 :class:`BufferedRWPair` 의 인스턴스)는 재진입할 수 없습니다. "
"재진입 호출이 정상적인 상황에서는 발생하지 않지만, :mod:`signal` 처리기에서 I/O를 수행한다면 발생할 수 있습니다. "
"스레드가 이미 액세스 중인 버퍼링 된 객체에 다시 진입하려고 하면, :exc:`RuntimeError`\\가 발생합니다. 이것이 "
"다른 스레드가 버퍼링 된 객체에 진입하는 것을 막는 것은 아님에 유의하십시오."

#: ../../library/io.rst:1185
#, fuzzy
msgid ""
"The above implicitly extends to text files, since the :func:`open` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  "
"This includes standard streams and therefore affects the built-in "
":func:`print` function as well."
msgstr ""
":func:`open()` 함수는 버퍼링 된 객체를 :class:`TextIOWrapper` 안에 감싸기 때문에, 위의 내용은 "
"텍스트 파일에도 묵시적으로 확장됩니다. 여기에는 표준 스트림이 포함되므로 내장 :func:`print()` 함수에도 영향을 줍니다."

#: ../../library/io.rst:24
msgid "file object"
msgstr ""

#: ../../library/io.rst:24
msgid "io module"
msgstr ""

#: ../../library/io.rst:970 ../../library/io.rst:1121
msgid "universal newlines"
msgstr ""

#: ../../library/io.rst:970
msgid "io.TextIOWrapper class"
msgstr ""

#: ../../library/io.rst:1121
msgid "io.IncrementalNewlineDecoder class"
msgstr ""

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``open`` with arguments ``path``, ``mode``,"
#~ " ``flags``."
#~ msgstr ""
#~ "인자 ``path``, ``mode``, ``flags``\\로 :ref:`감사"
#~ " 이벤트 <auditing>` ``open``\\을 발생시킵니다."

#~ msgid ""
#~ "The abstract base class for all "
#~ "I/O classes, acting on streams of "
#~ "bytes. There is no public constructor."
#~ msgstr "바이트 스트림에 작용하는, 모든 I/O 클래스의 추상 베이스 클래스. 공개 생성자가 없습니다."

#~ msgid "Return the new absolute position."
#~ msgstr "새로운 절대 위치를 반환합니다."

#~ msgid ""
#~ "The initial value of the buffer "
#~ "can be set by providing *initial_value*."
#~ " If newline translation is enabled, "
#~ "newlines will be encoded as if by"
#~ " :meth:`~TextIOBase.write`.  The stream is "
#~ "positioned at the start of the "
#~ "buffer."
#~ msgstr ""
#~ "버퍼의 초깃값은 *initial_value*\\를 제공하여 설정할 수"
#~ " 있습니다. 줄 바꿈 변환이 활성화되면, 줄 바꿈은"
#~ " :meth:`~TextIOBase.write` 한 것처럼 인코딩됩니다. "
#~ "스트림은 버퍼의 시작 부분에 위치합니다."

