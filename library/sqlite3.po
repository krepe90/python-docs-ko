# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/sqlite3.rst:2
#, fuzzy
msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- SQLite 데이터베이스용 DB-API 2.0 인터페이스"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**소스 코드:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:25
msgid ""
"SQLite is a C library that provides a lightweight disk-based database "
"that doesn't require a separate server process and allows accessing the "
"database using a nonstandard variant of the SQL query language. Some "
"applications can use SQLite for internal data storage.  It's also "
"possible to prototype an application using SQLite and then port the code "
"to a larger database such as PostgreSQL or Oracle."
msgstr ""
"SQLite는 별도의 서버 프로세스가 필요 없고 SQL 질의 언어의 비표준 변형을 사용하여 데이터베이스에 액세스할 수 있는 경량 "
"디스크 기반 데이터베이스를 제공하는 C 라이브러리입니다. 일부 응용 프로그램은 내부 데이터 저장을 위해 SQLite를 사용할 수 "
"있습니다. SQLite를 사용하여 응용 프로그램을 프로토타입 한 다음 PostgreSQL 이나 Oracle과 같은 더 큰 "
"데이터베이스로 코드를 이식할 수도 있습니다."

#: ../../library/sqlite3.rst:32
#, fuzzy
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an"
" SQL interface compliant with the DB-API 2.0 specification described by "
":pep:`249`, and requires SQLite 3.15.2 or newer."
msgstr ""
"sqlite3 모듈은 Gerhard Häring이 썼습니다. :pep:`249`\\에서 설명하는 DB-API 2.0 명세를 준수하는"
" SQL 인터페이스를 제공합니다."

#: ../../library/sqlite3.rst:36
msgid "This document includes four main sections:"
msgstr ""

#: ../../library/sqlite3.rst:38
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ""

#: ../../library/sqlite3.rst:39
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""

#: ../../library/sqlite3.rst:41
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ""

#: ../../library/sqlite3.rst:42
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:48
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite 웹 페이지; 설명서는 지원되는 SQL 언어에 대한 문법과 사용 가능한 데이터형을 설명합니다."

#: ../../library/sqlite3.rst:51
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:52
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "SQL 문법 학습을 위한 자습서, 레퍼런스 및 예제"

#: ../../library/sqlite3.rst:54
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - 데이터베이스 API 명세 2.0"

#: ../../library/sqlite3.rst:55
msgid "PEP written by Marc-André Lemburg."
msgstr "Marc-André Lemburg가 작성한 PEP."

#: ../../library/sqlite3.rst:68
msgid "Tutorial"
msgstr ""

#: ../../library/sqlite3.rst:70
msgid ""
"In this tutorial, you will create a database of Monty Python movies using"
" basic :mod:`!sqlite3` functionality. It assumes a fundamental "
"understanding of database concepts, including `cursors`_ and "
"`transactions`_."
msgstr ""

#: ../../library/sqlite3.rst:75
msgid ""
"First, we need to create a new database and open a database connection to"
" allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""

#: ../../library/sqlite3.rst:81
msgid ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"
msgstr ""

#: ../../library/sqlite3.rst:86
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection"
" to the on-disk database."
msgstr ""

#: ../../library/sqlite3.rst:89
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we"
" will need to use a database cursor. Call :meth:`con.cursor() "
"<Connection.cursor>` to create the :class:`Cursor`:"
msgstr ""

#: ../../library/sqlite3.rst:93
msgid "cur = con.cursor()"
msgstr ""

#: ../../library/sqlite3.rst:97
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review"
" score. For simplicity, we can just use column names in the table "
"declaration -- thanks to the `flexible typing`_ feature of SQLite, "
"specifying the data types is optional. Execute the ``CREATE TABLE`` "
"statement by calling :meth:`cur.execute(...) <Cursor.execute>`:"
msgstr ""

#: ../../library/sqlite3.rst:106
msgid "cur.execute(\"CREATE TABLE movie(title, year, score)\")"
msgstr ""

#: ../../library/sqlite3.rst:113
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) "
"<Cursor.execute>`, assign the result to ``res``, and call "
":meth:`res.fetchone() <Cursor.fetchone>` to fetch the resulting row:"
msgstr ""

#: ../../library/sqlite3.rst:121
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"
msgstr ""

#: ../../library/sqlite3.rst:127
msgid ""
"We can see that the table has been created, as the query returns a "
":class:`tuple` containing the table's name. If we query ``sqlite_master``"
" for a non-existent table ``spam``, :meth:`!res.fetchone` will return "
"``None``:"
msgstr ""

#: ../../library/sqlite3.rst:132
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE "
"name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"
msgstr ""

#: ../../library/sqlite3.rst:138
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) "
"<Cursor.execute>`:"
msgstr ""

#: ../../library/sqlite3.rst:142
msgid ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"
msgstr ""

#: ../../library/sqlite3.rst:150
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to "
"be committed before changes are saved in the database (see :ref:`sqlite3"
"-controlling-transactions` for details). Call :meth:`con.commit() "
"<Connection.commit>` on the connection object to commit the transaction:"
msgstr ""

#: ../../library/sqlite3.rst:156
msgid "con.commit()"
msgstr ""

#: ../../library/sqlite3.rst:160
msgid ""
"We can verify that the data was inserted correctly by executing a "
"``SELECT`` query. Use the now-familiar :meth:`cur.execute(...) "
"<Cursor.execute>` to assign the result to ``res``, and call "
":meth:`res.fetchall() <Cursor.fetchall>` to return all resulting rows:"
msgstr ""

#: ../../library/sqlite3.rst:166
msgid ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"
msgstr ""

#: ../../library/sqlite3.rst:172
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, "
"each containing that row's ``score`` value."
msgstr ""

#: ../../library/sqlite3.rst:175
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) "
"<Cursor.executemany>`:"
msgstr ""

#: ../../library/sqlite3.rst:178
msgid ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Remember to commit the transaction after executing INSERT."
msgstr ""

#: ../../library/sqlite3.rst:188
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-"
"formatting>` to bind Python values to SQL statements, to avoid `SQL "
"injection attacks`_ (see :ref:`sqlite3-placeholders` for more details)."
msgstr ""

#: ../../library/sqlite3.rst:194
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""

#: ../../library/sqlite3.rst:198
msgid ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"
msgstr ""

#: ../../library/sqlite3.rst:208
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""

#: ../../library/sqlite3.rst:211
msgid ""
"Finally, verify that the database has been written to disk by calling "
":meth:`con.close() <Connection.close>` to close the existing connection, "
"opening a new one, creating a new cursor, then querying the database:"
msgstr ""

#: ../../library/sqlite3.rst:216
#, python-brace-format
msgid ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released"
" in {year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy "
"Grail', released in 1975\n"
">>> new_con.close()"
msgstr ""

#: ../../library/sqlite3.rst:227
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ""

#: ../../library/sqlite3.rst:241
msgid ":ref:`sqlite3-placeholders`"
msgstr ""

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-adapters`"
msgstr ""

#: ../../library/sqlite3.rst:243
#, fuzzy
msgid ":ref:`sqlite3-converters`"
msgstr "변환기를 사용하십시오."

#: ../../library/sqlite3.rst:244 ../../library/sqlite3.rst:618
#, fuzzy
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr "컨텍스트 관리자로 연결 사용하기"

#: ../../library/sqlite3.rst:245
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ""

#: ../../library/sqlite3.rst:247
msgid ":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""

#: ../../library/sqlite3.rst:252
msgid "Reference"
msgstr ""

#: ../../library/sqlite3.rst:260
#, fuzzy
msgid "Module functions"
msgstr "모듈 함수와 상수"

#: ../../library/sqlite3.rst:268
msgid "Open a connection to an SQLite database."
msgstr ""

#: ../../library/sqlite3.rst
msgid "Parameters"
msgstr ""

#: ../../library/sqlite3.rst:270
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"``"
" to create an `SQLite database existing only in memory "
"<https://sqlite.org/inmemorydb.html>`_, and open a connection to it."
msgstr ""

#: ../../library/sqlite3.rst:277
msgid ""
"How many seconds the connection should wait before raising an "
":exc:`OperationalError` when a table is locked. If another connection "
"opens a transaction to modify a table, that table will be locked until "
"the transaction is committed. Default five seconds."
msgstr ""

#: ../../library/sqlite3.rst:284
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite"
" <sqlite3-types>` are looked up to be converted to Python types, using "
"the converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and "
":const:`PARSE_COLNAMES` to enable this. Column names takes precedence "
"over declared types if both flags are set. By default (``0``), type "
"detection is disabled."
msgstr ""

#: ../../library/sqlite3.rst:295
msgid ""
"Control legacy transaction handling behaviour. See "
":attr:`Connection.isolation_level` and :ref:`sqlite3-transaction-control-"
"isolation-level` for more information. Can be ``\"DEFERRED\"`` (default),"
" ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable opening "
"transactions implicitly. Has no effect unless "
":attr:`Connection.autocommit` is set to "
":const:`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""

#: ../../library/sqlite3.rst:305
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created "
"it. If ``False``, the connection may be accessed in multiple threads; "
"write operations may need to be serialized by the user to avoid data "
"corruption. See :attr:`threadsafety` for more information."
msgstr ""

#: ../../library/sqlite3.rst:314
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, "
"if not the default :class:`Connection` class."
msgstr ""

#: ../../library/sqlite3.rst:318
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for"
" this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""

#: ../../library/sqlite3.rst:323
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""

#: ../../library/sqlite3.rst:332
msgid ""
"Control :pep:`249` transaction handling behaviour. See "
":attr:`Connection.autocommit` and :ref:`sqlite3-transaction-control-"
"autocommit` for more information. *autocommit* currently defaults to "
":const:`~sqlite3.LEGACY_TRANSACTION_CONTROL`. The default will change to "
"``False`` in a future Python release."
msgstr ""

#: ../../library/sqlite3.rst
#, fuzzy
msgid "Return type"
msgstr "파이썬 형"

#: ../../library/sqlite3.rst:343
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with "
"argument ``database``."
msgstr ""
"인자 ``database``\\로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``sqlite3.connect``\\를 발생시킵니다."

#: ../../library/sqlite3.rst:344
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` "
"with argument ``connection_handle``."
msgstr ""
"인자 ``database``\\로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``sqlite3.connect``\\를 발생시킵니다."

#: ../../library/sqlite3.rst:346
msgid "Added the *uri* parameter."
msgstr "*uri* 매개 변수가 추가되었습니다."

#: ../../library/sqlite3.rst:349
msgid "*database* can now also be a :term:`path-like object`, not only a string."
msgstr "*database*\\는 이제 문자열뿐만 아니라 :term:`경로류 객체 <path-like object>` 일 수도 있습니다."

#: ../../library/sqlite3.rst:352
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:355
#, fuzzy
msgid "Added the *autocommit* parameter."
msgstr "*uri* 매개 변수가 추가되었습니다."

#: ../../library/sqlite3.rst:358
msgid ""
"Positional use of the parameters *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements*, "
"and *uri* is deprecated. They will become keyword-only parameters in "
"Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:366
#, fuzzy
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind"
" is performed, other than checking that there are no unclosed string "
"literals and the statement is terminated by a semicolon."
msgstr ""
"문자열 *sql*\\에 세미콜론으로 끝나는 하나 이상의 완전한 SQL 문이 포함되어 있으면 :const:`True`\\를 "
"반환합니다. SQL이 문법적으로 올바른지 확인하지는 않습니다. 닫히지 않은 문자열 리터럴이 없고 명령문이 세미콜론으로 끝나는지만 "
"확인합니다."

#: ../../library/sqlite3.rst:372
#, fuzzy
msgid "For example:"
msgstr "예:"

#: ../../library/sqlite3.rst:374
msgid ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"
msgstr ""

#: ../../library/sqlite3.rst:381
msgid ""
"This function may be useful during command-line input to determine if the"
" entered text seems to form a complete SQL statement, or if additional "
"input is needed before calling :meth:`~Cursor.execute`."
msgstr ""

#: ../../library/sqlite3.rst:385
msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-"
"world use."
msgstr ""

#: ../../library/sqlite3.rst:390
#, fuzzy
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with"
" *flag* set to ``True``. Afterwards, you will get tracebacks from "
"callbacks on :data:`sys.stderr`. Use ``False`` to disable the feature "
"again."
msgstr ""
"기본적으로 사용자 정의 함수, 집계(aggregates), 변환기, 인가(authorizer) 콜백 등에서는 트레이스백을 얻지 "
"못합니다. 디버깅하려면 *flag*\\를 ``True``\\로 설정하여 이 함수를 호출할 수 있습니다. 그러면, "
"``sys.stderr``\\로 콜백의 트레이스백을 얻게 됩니다. 기능을 다시 비활성화하려면 :const:`False`\\를 "
"사용하십시오."

#: ../../library/sqlite3.rst:399
msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` "
"for introspection of the failed callback."
msgstr ""

#: ../../library/sqlite3.rst:405
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* "
"into an SQLite type. The adapter is called with a Python object of type "
"*type* as its sole argument, and must return a value of a :ref:`type that"
" SQLite natively understands <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:413
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of "
"type *typename* into a Python object of a specific type. The converter is"
" invoked for all SQLite values of type *typename*; it is passed a "
":class:`bytes` object and should return an object of the desired Python "
"type. Consult the parameter *detect_types* of :func:`connect` for "
"information regarding how type detection works."
msgstr ""

#: ../../library/sqlite3.rst:421
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""

#: ../../library/sqlite3.rst:428
#, fuzzy
msgid "Module constants"
msgstr "모듈 함수와 상수"

#: ../../library/sqlite3.rst:432
msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style "
"(pre-Python 3.12) transaction control behaviour. See :ref:`sqlite3"
"-transaction-control-isolation-level` for more information."
msgstr ""

#: ../../library/sqlite3.rst:438
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` "
"to look up a converter function using the declared types for each column."
" The types are declared when the database table is created. "
":mod:`!sqlite3` will look up a converter function using the first word of"
" the declared type as the converter dictionary key. For example:"
msgstr ""

#: ../../library/sqlite3.rst:446
msgid ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"
msgstr ""

#: ../../library/sqlite3.rst:454
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""

#: ../../library/sqlite3.rst:459
msgid ""
"Generated fields (for example ``MAX(p)``) are returned as :class:`str`. "
"Use :const:`!PARSE_COLNAMES` to enforce types for such queries."
msgstr ""

#: ../../library/sqlite3.rst:464
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` "
"to look up a converter function by using the type name, parsed from the "
"query column name, as the converter dictionary key. The query column name"
" must be wrapped in double quotes (``\"``) and the type name must be "
"wrapped in square brackets (``[]``)."
msgstr ""

#: ../../library/sqlite3.rst:471
msgid ""
"SELECT MAX(p) as \"p [point]\" FROM test;  ! will look up converter "
"\"point\""
msgstr ""

#: ../../library/sqlite3.rst:475
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""

#: ../../library/sqlite3.rst:482
msgid ""
"Flags that should be returned by the *authorizer_callback* "
":term:`callable` passed to :meth:`Connection.set_authorizer`, to indicate"
" whether:"
msgstr ""

#: ../../library/sqlite3.rst:485
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr ""

#: ../../library/sqlite3.rst:486
msgid "The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""

#: ../../library/sqlite3.rst:487
msgid "The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""

#: ../../library/sqlite3.rst:491
msgid ""
"String constant stating the supported DB-API level. Required by the DB-"
"API. Hard-coded to ``\"2.0\"``."
msgstr ""

#: ../../library/sqlite3.rst:496
msgid ""
"String constant stating the type of parameter marker formatting expected "
"by the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""

#: ../../library/sqlite3.rst:502
msgid "The ``named`` DB-API parameter style is also supported."
msgstr ""

#: ../../library/sqlite3.rst:506
#, fuzzy
msgid "Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr "런타임 SQLite 라이브러리의 버전 번호(문자열)."

#: ../../library/sqlite3.rst:510
#, fuzzy
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of "
":class:`integers <int>`."
msgstr "런타임 SQLite 라이브러리의 버전 번호(정수들의 튜플)."

#: ../../library/sqlite3.rst:515
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based "
"on the default `threading mode <https://sqlite.org/threadsafe.html>`_ the"
" underlying SQLite library is compiled with. The SQLite threading modes "
"are:"
msgstr ""

#: ../../library/sqlite3.rst:520
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""

#: ../../library/sqlite3.rst:522
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used "
"simultaneously in two or more threads."
msgstr ""

#: ../../library/sqlite3.rst:525
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple"
" threads with no restriction."
msgstr ""

#: ../../library/sqlite3.rst:528
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety "
"levels are as follows:"
msgstr ""

#: ../../library/sqlite3.rst:532
msgid "SQLite threading mode"
msgstr ""

#: ../../library/sqlite3.rst:532
msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ""

#: ../../library/sqlite3.rst:532
msgid "`SQLITE_THREADSAFE`_"
msgstr ""

#: ../../library/sqlite3.rst:532
msgid "DB-API 2.0 meaning"
msgstr ""

#: ../../library/sqlite3.rst:535
msgid "single-thread"
msgstr ""

#: ../../library/sqlite3.rst:535
msgid "0"
msgstr ""

#: ../../library/sqlite3.rst:535
msgid "Threads may not share the module"
msgstr ""

#: ../../library/sqlite3.rst:538
msgid "multi-thread"
msgstr ""

#: ../../library/sqlite3.rst:538 ../../library/sqlite3.rst:541
msgid "1"
msgstr ""

#: ../../library/sqlite3.rst:538
msgid "2"
msgstr ""

#: ../../library/sqlite3.rst:538
msgid "Threads may share the module, but not connections"
msgstr ""

#: ../../library/sqlite3.rst:541
msgid "serialized"
msgstr ""

#: ../../library/sqlite3.rst:541
msgid "3"
msgstr ""

#: ../../library/sqlite3.rst:541
msgid "Threads may share the module, connections and cursors"
msgstr ""

#: ../../library/sqlite3.rst:547
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""

#: ../../library/sqlite3.rst:552
#, fuzzy
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the"
" version of the SQLite library."
msgstr "이 모듈의 버전 번호(문자열). SQLite 라이브러리의 버전이 아닙니다."

#: ../../library/sqlite3.rst:555 ../../library/sqlite3.rst:565
msgid ""
"This constant used to reflect the version number of the ``pysqlite`` "
"package, a third-party library which used to upstream changes to "
":mod:`!sqlite3`. Today, it carries no meaning or practical value."
msgstr ""

#: ../../library/sqlite3.rst:562
#, fuzzy
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr "이 모듈의 버전 번호(정수들의 튜플). SQLite 라이브러리의 버전이 아닙니다."

#: ../../library/sqlite3.rst:589
msgid ""
"These constants are used for the :meth:`Connection.setconfig` and "
":meth:`~Connection.getconfig` methods."
msgstr ""

#: ../../library/sqlite3.rst:592
msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr ""

#: ../../library/sqlite3.rst:599
msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr ""

#: ../../library/sqlite3.rst:600
msgid "SQLite docs: Database Connection Configuration Options"
msgstr ""

#: ../../library/sqlite3.rst:606
#, fuzzy
msgid "Connection objects"
msgstr "Connection 객체"

#: ../../library/sqlite3.rst:610
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, "
"which is created using :func:`sqlite3.connect`. Their main purpose is "
"creating :class:`Cursor` objects, and :ref:`sqlite3-controlling-"
"transactions`."
msgstr ""

#: ../../library/sqlite3.rst:617
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ""

#: ../../library/sqlite3.rst:623
msgid ""
"A :exc:`ResourceWarning` is emitted if :meth:`close` is not called before"
" a :class:`!Connection` object is deleted."
msgstr ""

#: ../../library/sqlite3.rst:626
#, fuzzy
msgid "An SQLite database connection has the following attributes and methods:"
msgstr "SQLite 데이터베이스 연결에는 다음과 같은 어트리뷰트와 메서드가 있습니다:"

#: ../../library/sqlite3.rst:630
#, fuzzy
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a "
":term:`callable` returning an instance of :class:`Cursor` or its "
"subclasses."
msgstr ""
"cursor 메서드는 단일 선택적 매개 변수 *factory*\\를 받아들입니다. 제공되면, 이것은 :class:`Cursor` 나"
" 그 서브 클래스의 인스턴스를 반환하는 콜러블이어야 합니다."

#: ../../library/sqlite3.rst:637
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""

#: ../../library/sqlite3.rst:640
msgid "The name of the table where the blob is located."
msgstr ""

#: ../../library/sqlite3.rst:643
msgid "The name of the column where the blob is located."
msgstr ""

#: ../../library/sqlite3.rst:646
msgid "The name of the row where the blob is located."
msgstr ""

#: ../../library/sqlite3.rst:649
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""

#: ../../library/sqlite3.rst:654
msgid ""
"The name of the database where the blob is located. Defaults to "
"``\"main\"``."
msgstr ""

#: ../../library/sqlite3.rst
msgid "Raises"
msgstr ""

#: ../../library/sqlite3.rst:658
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr ""

#: ../../library/sqlite3.rst:665
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the "
"SQL function ``zeroblob`` to create a blob with a fixed size."
msgstr ""

#: ../../library/sqlite3.rst:672
msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If "
":attr:`!autocommit` is ``False``, a new transaction is implicitly opened "
"if a pending transaction was committed by this method."
msgstr ""

#: ../../library/sqlite3.rst:680
msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` "
"is ``True``, or there is no open transaction, this method does nothing. "
"If :attr:`!autocommit` is ``False``, a new transaction is implicitly "
"opened if a pending transaction was rolled back by this method."
msgstr ""

#: ../../library/sqlite3.rst:688
msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""

#: ../../library/sqlite3.rst:698
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""

#: ../../library/sqlite3.rst:704
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` "
"on it with the given *sql* and *parameters*. Return the new cursor "
"object."
msgstr ""

#: ../../library/sqlite3.rst:710
msgid ""
"Create a new :class:`Cursor` object and call "
":meth:`~Cursor.executescript` on it with the given *sql_script*. Return "
"the new cursor object."
msgstr ""

#: ../../library/sqlite3.rst:716
#, fuzzy
msgid "Create or remove a user-defined SQL function."
msgstr "사용자 정의 집계(aggregate) 함수를 만듭니다."

#: ../../library/sqlite3.rst:718
msgid "The name of the SQL function."
msgstr ""

#: ../../library/sqlite3.rst:721
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may "
"take any number of arguments."
msgstr ""

#: ../../library/sqlite3.rst:725
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite "
"<sqlite3-types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""

#: ../../library/sqlite3.rst:732
msgid ""
"If ``True``, the created SQL function is marked as `deterministic "
"<https://sqlite.org/deterministic.html>`_, which allows SQLite to perform"
" additional optimizations."
msgstr ""

#: ../../library/sqlite3.rst:737
#, fuzzy
msgid "Added the *deterministic* parameter."
msgstr "*uri* 매개 변수가 추가되었습니다."

#: ../../library/sqlite3.rst:740 ../../library/sqlite3.rst:784
#: ../../library/sqlite3.rst:852 ../../library/sqlite3.rst:1131
#: ../../library/sqlite3.rst:1553 ../../library/sqlite3.rst:1596
msgid "Example:"
msgstr "예:"

#: ../../library/sqlite3.rst:742
msgid ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:756
msgid ""
"Passing *name*, *narg*, and *func* as keyword arguments is deprecated. "
"These parameters will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:762
#, fuzzy
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "사용자 정의 집계(aggregate) 함수를 만듭니다."

#: ../../library/sqlite3.rst:764
#, fuzzy
msgid "The name of the SQL aggregate function."
msgstr "사용자 정의 집계(aggregate) 함수를 만듭니다."

#: ../../library/sqlite3.rst:767
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``,"
" it may take any number of arguments."
msgstr ""

#: ../../library/sqlite3.rst:771
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to"
" the aggregate. * ``finalize()``: Return the final result of the "
"aggregate as   :ref:`a type natively supported by SQLite "
"<sqlite3-types>`.  The number of arguments that the ``step()`` method "
"must accept is controlled by *n_arg*.  Set to ``None`` to remove an "
"existing SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:772
#, fuzzy
msgid "A class must implement the following methods:"
msgstr ":class:`Cursor` 인스턴스에는 다음과 같은 어트리뷰트와 메서드가 있습니다."

#: ../../library/sqlite3.rst:774
msgid "``step()``: Add a row to the aggregate."
msgstr ""

#: ../../library/sqlite3.rst:775 ../../library/sqlite3.rst:836
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:778
msgid ""
"The number of arguments that the ``step()`` method must accept is "
"controlled by *n_arg*."
msgstr ""

#: ../../library/sqlite3.rst:781
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: ../../library/sqlite3.rst:786
msgid ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:815
msgid ""
"Passing *name*, *n_arg*, and *aggregate_class* as keyword arguments is "
"deprecated. These parameters will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:821
#, fuzzy
msgid "Create or remove a user-defined aggregate window function."
msgstr "사용자 정의 집계(aggregate) 함수를 만듭니다."

#: ../../library/sqlite3.rst:823
msgid "The name of the SQL aggregate window function to create or remove."
msgstr ""

#: ../../library/sqlite3.rst:826
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""

#: ../../library/sqlite3.rst:830
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a "
"row to the current window. * ``value()``: Return the current value of the"
" aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a "
"type natively supported by SQLite <sqlite3-types>`.  The number of "
"arguments that the ``step()`` and ``value()`` methods must accept is "
"controlled by *num_params*.  Set to ``None`` to remove an existing SQL "
"aggregate window function."
msgstr ""

#: ../../library/sqlite3.rst:831
msgid "A class that must implement the following methods:"
msgstr ""

#: ../../library/sqlite3.rst:833
msgid "``step()``: Add a row to the current window."
msgstr ""

#: ../../library/sqlite3.rst:834
msgid "``value()``: Return the current value of the aggregate."
msgstr ""

#: ../../library/sqlite3.rst:835
msgid "``inverse()``: Remove a row from the current window."
msgstr ""

#: ../../library/sqlite3.rst:839
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""

#: ../../library/sqlite3.rst:842
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr ""

#: ../../library/sqlite3.rst:844
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not "
"support aggregate window functions."
msgstr ""

#: ../../library/sqlite3.rst:854
msgid ""
"# Example taken from "
"https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:908
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""

#: ../../library/sqlite3.rst:912
msgid "``1`` if the first is ordered higher than the second"
msgstr ""

#: ../../library/sqlite3.rst:913
msgid "``-1`` if the first is ordered lower than the second"
msgstr ""

#: ../../library/sqlite3.rst:914
msgid "``0`` if they are ordered equal"
msgstr ""

#: ../../library/sqlite3.rst:916
#, fuzzy
msgid "The following example shows a reverse sorting collation:"
msgstr "다음 예제는 \"잘못된 방법\"으로 정렬하는 사용자 정의 정렬법을 보여줍니다:"

#: ../../library/sqlite3.rst:918
msgid ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:944
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""

#: ../../library/sqlite3.rst:946
msgid ""
"The collation name can contain any Unicode character.  Earlier, only "
"ASCII characters were allowed."
msgstr ""

#: ../../library/sqlite3.rst:953
#, fuzzy
msgid ""
"Call this method from a different thread to abort any queries that might "
"be executing on the connection. Aborted queries will raise an "
":exc:`OperationalError`."
msgstr ""
"연결에서 실행 중일 수 있는 모든 질의를 중단하려면, 이 메서드를 다른 스레드에서 호출할 수 있습니다. 그러면 질의가 중단되고 "
"호출자는 예외를 받습니다."

#: ../../library/sqlite3.rst:960
#, fuzzy
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback "
"should return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or "
":const:`SQLITE_IGNORE` to signal how access to the column should be "
"handled by the underlying SQLite library."
msgstr ""
"이 루틴은 콜백을 등록합니다. 콜백은 데이터베이스의 테이블 열에 액세스할 때마다 호출됩니다. 콜백은 액세스가 허용되면 "
":const:`SQLITE_OK`\\를 반환하고, 전체 SQL 문을 에러를 일으키며 중단해야 하면 "
":const:`SQLITE_DENY`\\를, 열을 NULL 값으로 처리하려면 :const:`SQLITE_IGNORE`\\를 반환해야"
" 합니다. 이 상수들은 :mod:`sqlite3` 모듈에 있습니다."

#: ../../library/sqlite3.rst:967
#, fuzzy
msgid ""
"The first argument to the callback signifies what kind of operation is to"
" be authorized. The second and third argument will be arguments or "
"``None`` depending on the first argument. The 4th argument is the name of"
" the database (\"main\", \"temp\", etc.) if applicable. The 5th argument "
"is the name of the inner-most trigger or view that is responsible for the"
" access attempt or ``None`` if this access attempt is directly from input"
" SQL code."
msgstr ""
"콜백의 첫 번째 인자는 어떤 종류의 연산이 인가받으려 하는지를 나타냅니다. 두 번째와 세 번째 인자는 첫 번째 인자에 따라 "
"인자이거나 :const:`None`\\이 됩니다. 네 번째 인자는 해당하면 데이터베이스 이름(\"main\", \"temp\" "
"등)입니다. 다섯 번째 인자는 액세스 시도를 담당하는 가장 안쪽의 트리거나 뷰의 이름이거나, 이 액세스 시도가 입력 SQL 코드에서"
" 직접 발생했으면 :const:`None`\\입니다."

#: ../../library/sqlite3.rst:974
#, fuzzy
msgid ""
"Please consult the SQLite documentation about the possible values for the"
" first argument and the meaning of the second and third argument "
"depending on the first one. All necessary constants are available in the "
":mod:`!sqlite3` module."
msgstr ""
"첫 번째 인자에 가능한 값과 첫 번째 인자에 의존하는 두 번째 및 세 번째 인자의 의미에 대해서는 SQLite 문서를 참조하십시오."
" 필요한 모든 상수는 :mod:`sqlite3` 모듈에 있습니다."

#: ../../library/sqlite3.rst:978
#, fuzzy
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr ":const:`None`\\을 *trace_callback*\\로 전달하면 추적 콜백을 비활성화합니다."

#: ../../library/sqlite3.rst:980
msgid "Added support for disabling the authorizer using ``None``."
msgstr ""

#: ../../library/sqlite3.rst:983
msgid ""
"Passing *authorizer_callback* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:990
#, fuzzy
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to"
" get called from SQLite during long-running operations, for example to "
"update a GUI."
msgstr ""
"이 루틴은 콜백을 등록합니다. 콜백은 SQLite 가상 머신의 매 *n*\\개의 명령어마다 호출됩니다. 장시간 실행되는 작업 중에 "
"SQLite로부터 호출되기를 원할 때 유용합니다, 예를 들어 GUI를 갱신하는데 사용할 수 있습니다."

#: ../../library/sqlite3.rst:995
#, fuzzy
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr "이전에 설치된 모든 진행 처리기를 지우려면 *handler*\\로 :const:`None`\\을 사용하여 메서드를 호출하십시오."

#: ../../library/sqlite3.rst:998
#, fuzzy
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr ""
"처리기 함수에서 0이 아닌 값을 반환하면 현재 실행 중인 질의가 종료되고 :exc:`OperationalError` 예외가 "
"발생합니다."

#: ../../library/sqlite3.rst:1002
msgid ""
"Passing *progress_handler* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:1009
#, fuzzy
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr "SQLite 백 엔드가 실제로 실행하는 각 SQL 문마다 호출할 *trace_callback*\\을 등록합니다."

#: ../../library/sqlite3.rst:1012
#, fuzzy
msgid ""
"The only argument passed to the callback is the statement (as "
":class:`str`) that is being executed. The return value of the callback is"
" ignored. Note that the backend does not only run statements passed to "
"the :meth:`Cursor.execute` methods.  Other sources include the "
":ref:`transaction management <sqlite3-controlling-transactions>` of the "
":mod:`!sqlite3` module and the execution of triggers defined in the "
"current database."
msgstr ""
"콜백에 전달되는 유일한 인자는 실행 중인 문장(문자열)입니다. 콜백의 반환 값은 무시됩니다. 백 엔드는 "
":meth:`Cursor.execute` 메서드에 전달된 명령문만 실행하는 것은 아님에 유의하시기 바랍니다. 다른 소스로는 파이썬 "
"모듈의 트랜잭션 관리와 현재 데이터베이스에 정의된 트리거의 실행이 있습니다."

#: ../../library/sqlite3.rst:1020
#, fuzzy
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ":const:`None`\\을 *trace_callback*\\로 전달하면 추적 콜백을 비활성화합니다."

#: ../../library/sqlite3.rst:1023
msgid ""
"Exceptions raised in the trace callback are not propagated. As a "
"development and debugging aid, use "
":meth:`~sqlite3.enable_callback_tracebacks` to enable printing tracebacks"
" from exceptions raised in the trace callback."
msgstr ""

#: ../../library/sqlite3.rst:1030
msgid ""
"Passing *trace_callback* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: ../../library/sqlite3.rst:1037
#, fuzzy
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries "
"if *enabled* is ``True``; else, disallow loading SQLite extensions. "
"SQLite extensions can define new functions, aggregates or whole new "
"virtual table implementations.  One well-known extension is the fulltext-"
"search extension distributed with SQLite."
msgstr ""
"이 루틴은 SQLite 엔진이 공유 라이브러리에서 SQLite 확장을 로드하는 것을 허용/불허합니다. SQLite 확장은 새 함수,"
" 집계 또는 완전히 새로운 가상 테이블 구현을 정의할 수 있습니다. 잘 알려진 확장 중 하나는 SQLite와 함께 배포되는 전체 "
"텍스트 검색 확장입니다."

#: ../../library/sqlite3.rst:1046
#, fuzzy
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support "
"by default, because some platforms (notably macOS) have SQLite libraries "
"which are compiled without this feature. To get loadable extension "
"support, you must pass the :option:`--enable-loadable-sqlite-extensions` "
"option to :program:`configure`."
msgstr ""
"기본적으로 sqlite3 모듈은 로드 가능한 확장을 지원하도록 빌드되지 않습니다. 일부 플랫폼(특히 맥 OS X)에는 이 기능 없이"
" 컴파일된 SQLite 라이브러리가 있기 때문입니다. 로드 가능한 확장 지원을 받으려면, configure에 ``--enable-"
"loadable-sqlite-extensions``\\를 전달해야 합니다."

#: ../../library/sqlite3.rst:1053
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``sqlite3.enable_load_extension`` with arguments ``connection``, "
"``enabled``."
msgstr ""
"인자 ``database``\\로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``sqlite3.connect``\\를 발생시킵니다."

#: ../../library/sqlite3.rst:1057
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:1063
msgid ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, "
"ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', "
"'broccoli peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', "
"'pumpkin onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', "
"'broccoli cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin"
" sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe "
"WHERE name MATCH 'pie'\"):\n"
"    print(row)"
msgstr ""

#: ../../library/sqlite3.rst:1089
#, fuzzy
msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr ""
"이 루틴은 공유 라이브러리에서 SQLite 확장을 로드합니다. 이 루틴을 사용하려면 먼저 "
":meth:`enable_load_extension`\\로 확장 로드를 활성화해야 합니다."

#: ../../library/sqlite3.rst:1093
msgid "The path to the SQLite extension."
msgstr ""

#: ../../library/sqlite3.rst:1097
msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ "
"for details."
msgstr ""

#: ../../library/sqlite3.rst:1106
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` "
"with arguments ``connection``, ``path``."
msgstr ""
"인자 ``database``\\로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``sqlite3.connect``\\를 발생시킵니다."

#: ../../library/sqlite3.rst:1110
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr ""

#: ../../library/sqlite3.rst:1113
#, fuzzy
msgid "Added the *entrypoint* parameter."
msgstr "*uri* 매개 변수가 추가되었습니다."

#: ../../library/sqlite3.rst:1120
#, fuzzy
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. "
"Useful when saving an in-memory database for later restoration. Similar "
"to the ``.dump`` command in the :program:`sqlite3` shell."
msgstr ""
"SQL 텍스트 형식으로 데이터베이스를 덤프하는 이터레이터를 반환합니다. 나중에 복원할 수 있도록 메모리 데이터베이스를 저장할 때 "
"유용합니다. 이 함수는 :program:`sqlite3` 셸의 :kbd:`.dump` 명령과 같은 기능을 제공합니다."

#: ../../library/sqlite3.rst:1124
msgid ""
"An optional ``LIKE`` pattern for database objects to dump, e.g. "
"``prefix_%``. If ``None`` (the default), all database objects will be "
"included."
msgstr ""

#: ../../library/sqlite3.rst:1133
#, python-format
msgid ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:1144 ../../library/sqlite3.rst:1218
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ""

#: ../../library/sqlite3.rst:1146
#, fuzzy
msgid "Added the *filter* parameter."
msgstr "*uri* 매개 변수가 추가되었습니다."

#: ../../library/sqlite3.rst:1151
msgid "Create a backup of an SQLite database."
msgstr ""

#: ../../library/sqlite3.rst:1153
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""

#: ../../library/sqlite3.rst:1156
msgid "The database connection to save the backup to."
msgstr ""

#: ../../library/sqlite3.rst:1159
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, "
"the entire database is copied in a single step. Defaults to ``-1``."
msgstr ""

#: ../../library/sqlite3.rst:1165
#, fuzzy
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments "
"for every backup iteration: the *status* of the last iteration, the "
"*remaining* number of pages still to be copied, and the *total* number of"
" pages. Defaults to ``None``."
msgstr ""
"*progress*\\가 지정되면, ``None`` 또는 매 이터레이션마다 세 개의 정수 인자로 실행되는 콜러블 객체여야 합니다. "
"세 인자는 각각 직전 이터레이션의 *상태(status)*, 아직 복사해야 할 *남은(remaining)* 페이지 수, "
"*전체(total)* 페이지 수입니다."

#: ../../library/sqlite3.rst:1174
#, fuzzy
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) "
"for the main database, ``\"temp\"`` for the temporary database, or the "
"name of a custom database as attached using the ``ATTACH DATABASE`` SQL "
"statement."
msgstr ""
"*name* 인자는 복사할 데이터베이스 이름을 지정합니다: main 데이터베이스를 나타내는 ``\"main\"``, 기본값, 임시 "
"데이터베이스를 나타내는 ``\"temp\"`` 또는 첨부된 데이터베이스를 위한 ``ATTACH DATABASE`` 문에서 "
"``AS`` 키워드 뒤에 지정된 이름을 포함하는 문자열이어야 합니다."

#: ../../library/sqlite3.rst:1181
#, fuzzy
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""
"*sleep* 인자는 남은 페이지를 백업하는 연속적인 시도 사이에서 잠잘 시간을 초 단위로 지정하며, 정수 또는 부동 소수점 값으로"
" 지정할 수 있습니다."

#: ../../library/sqlite3.rst:1185
#, fuzzy
msgid "Example 1, copy an existing database into another:"
msgstr "예제 1, 기존 데이터베이스를 다른 데이터베이스로 복사::"

#: ../../library/sqlite3.rst:1187
#, python-brace-format
msgid ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"
msgstr ""

#: ../../library/sqlite3.rst:1204
#, fuzzy
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "예제 2, 기존 데이터베이스를 임시 복사본으로 복사::"

#: ../../library/sqlite3.rst:1206
msgid ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"
msgstr ""

#: ../../library/sqlite3.rst:1222
msgid "Get a connection runtime limit."
msgstr ""

#: ../../library/sqlite3.rst:1224
msgid "The `SQLite limit category`_ to be queried."
msgstr ""

#: ../../library/sqlite3.rst:1229 ../../library/sqlite3.rst:1266
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:1232
msgid ""
"Example, query the maximum length of an SQL statement for "
":class:`Connection` ``con`` (the default is 1000000000):"
msgstr ""

#: ../../library/sqlite3.rst:1242
msgid ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"
msgstr ""

#: ../../library/sqlite3.rst:1252
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its "
"hard upper bound are silently truncated to the hard upper bound. "
"Regardless of whether or not the limit was changed, the prior value of "
"the limit is returned."
msgstr ""

#: ../../library/sqlite3.rst:1257
msgid "The `SQLite limit category`_ to be set."
msgstr ""

#: ../../library/sqlite3.rst:1260
msgid "The value of the new limit. If negative, the current limit is unchanged."
msgstr ""

#: ../../library/sqlite3.rst:1269
msgid ""
"Example, limit the number of attached databases to 1 for "
":class:`Connection` ``con`` (the default limit is 10):"
msgstr ""

#: ../../library/sqlite3.rst:1272
msgid ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"
msgstr ""

#: ../../library/sqlite3.rst:1290
msgid "Query a boolean connection configuration option."
msgstr ""

#: ../../library/sqlite3.rst:1292 ../../library/sqlite3.rst:1303
msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr ""

#: ../../library/sqlite3.rst:1301
msgid "Set a boolean connection configuration option."
msgstr ""

#: ../../library/sqlite3.rst:1306
msgid ""
"``True`` if the configuration option should be enabled (default); "
"``False`` if it should be disabled."
msgstr ""

#: ../../library/sqlite3.rst:1314
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-"
"disk database file, the serialization is just a copy of the disk file.  "
"For an in-memory database or a \"temp\" database, the serialization is "
"the same sequence of bytes which would be written to disk if that "
"database were backed up to disk."
msgstr ""

#: ../../library/sqlite3.rst:1320
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr ""

#: ../../library/sqlite3.rst:1328
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""

#: ../../library/sqlite3.rst:1336
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a "
":class:`Connection`. This method causes the database connection to "
"disconnect from database *name*, and reopen *name* as an in-memory "
"database based on the serialization contained in *data*."
msgstr ""

#: ../../library/sqlite3.rst:1342
msgid "A serialized database."
msgstr ""

#: ../../library/sqlite3.rst:1345
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr ""

#: ../../library/sqlite3.rst:1349
msgid ""
"If the database connection is currently involved in a read transaction or"
" a backup operation."
msgstr ""

#: ../../library/sqlite3.rst:1353
msgid "If *data* does not contain a valid SQLite database."
msgstr ""

#: ../../library/sqlite3.rst:1356
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr ""

#: ../../library/sqlite3.rst:1361
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""

#: ../../library/sqlite3.rst:1368
msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. "
":attr:`!autocommit` has three allowed values:"
msgstr ""

#: ../../library/sqlite3.rst:1371
msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying "
"that :mod:`!sqlite3` ensures a transaction is always open. Use "
":meth:`commit` and :meth:`rollback` to close transactions."
msgstr ""

#: ../../library/sqlite3.rst:1375
msgid "This is the recommended value of :attr:`!autocommit`."
msgstr ""

#: ../../library/sqlite3.rst:1377
msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and "
":meth:`rollback` have no effect in this mode."
msgstr ""

#: ../../library/sqlite3.rst:1380
msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 "
"(non-:pep:`249`-compliant) transaction control. See "
":attr:`isolation_level` for more details."
msgstr ""

#: ../../library/sqlite3.rst:1384
msgid "This is currently the default value of :attr:`!autocommit`."
msgstr ""

#: ../../library/sqlite3.rst:1386
msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, "
"and changing it to ``True`` will commit any pending transaction."
msgstr ""

#: ../../library/sqlite3.rst:1389
msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr ""

#: ../../library/sqlite3.rst:1393
msgid ""
"The :attr:`isolation_level` attribute has no effect unless "
":attr:`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""

#: ../../library/sqlite3.rst:1400
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""

#: ../../library/sqlite3.rst:1403
#, fuzzy
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"트랜잭션이 활성화 상태면(커밋되지 않은 변경 사항이 있으면) :const:`True`, 그렇지 않으면 :const:`False`. "
"읽기 전용 어트리뷰트."

#: ../../library/sqlite3.rst:1410
msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of "
"``\"DEFERRED\"``, ``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding "
"to the underlying `SQLite transaction behaviour`_, :ref:`implicit "
"transaction management <sqlite3-transaction-control-isolation-level>` is "
"performed."
msgstr ""

#: ../../library/sqlite3.rst:1418
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, "
"the default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""

#: ../../library/sqlite3.rst:1423
msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended "
"over using :attr:`!isolation_level`. :attr:`!isolation_level` has no "
"effect unless :attr:`autocommit` is set to "
":data:`LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""

#: ../../library/sqlite3.rst:1430
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects "
"created from this connection. Assigning to this attribute does not affect"
" the :attr:`!row_factory` of existing cursors belonging to this "
"connection, only new ones. Is ``None`` by default, meaning each row is "
"returned as a :class:`tuple`."
msgstr ""

#: ../../library/sqlite3.rst:1437 ../../library/sqlite3.rst:1723
#: ../../library/sqlite3.rst:1746
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr ""

#: ../../library/sqlite3.rst:1441
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with"
" the ``TEXT`` data type. By default, this attribute is set to "
":class:`str`."
msgstr ""

#: ../../library/sqlite3.rst:1446
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr ""

#: ../../library/sqlite3.rst:1450
#, fuzzy
msgid ""
"Return the total number of database rows that have been modified, "
"inserted, or deleted since the database connection was opened."
msgstr "데이터베이스 연결이 열린 후 수정, 삽입 또는 삭제된 데이터베이스 행의 총수를 반환합니다."

#: ../../library/sqlite3.rst:1457
#, fuzzy
msgid "Cursor objects"
msgstr "Cursor 객체"

#: ../../library/sqlite3.rst:1459
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to "
"execute SQL statements, and manage the context of a fetch operation. "
"Cursors are created using :meth:`Connection.cursor`, or by using any of "
"the :ref:`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""

#: ../../library/sqlite3.rst:1466
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you "
":meth:`~Cursor.execute` a ``SELECT`` query, you can simply iterate over "
"the cursor to fetch the resulting rows:"
msgstr ""

#: ../../library/sqlite3.rst:1477
msgid ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"
msgstr ""

#: ../../library/sqlite3.rst:1491
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` 인스턴스에는 다음과 같은 어트리뷰트와 메서드가 있습니다."

#: ../../library/sqlite3.rst:1498
msgid ""
"Execute a single SQL statement, optionally binding Python values using "
":ref:`placeholders <sqlite3-placeholders>`."
msgstr ""

#: ../../library/sqlite3.rst:1502
msgid "A single SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:1505
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named"
" placeholders are used. A :term:`!sequence` if unnamed placeholders are "
"used. See :ref:`sqlite3-placeholders`."
msgstr ""

#: ../../library/sqlite3.rst:1512
msgid "If *sql* contains more than one SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:1515
msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, "
":attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there "
"is no open transaction, a transaction is implicitly opened before "
"executing *sql*."
msgstr ""

#: ../../library/sqlite3.rst:1524
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders "
"<sqlite3-placeholders>` are used and *parameters* is a sequence instead "
"of a :class:`dict`. Starting with Python 3.14, :exc:`ProgrammingError` "
"will be raised instead."
msgstr ""

#: ../../library/sqlite3.rst:1530
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr ""

#: ../../library/sqlite3.rst:1534
msgid ""
"For every item in *parameters*, repeatedly execute the "
":ref:`parameterized <sqlite3-placeholders>` :abbr:`DML (Data Manipulation"
" Language)` SQL statement *sql*."
msgstr ""

#: ../../library/sqlite3.rst:1538
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""

#: ../../library/sqlite3.rst:1540
msgid "A single SQL DML statement."
msgstr ""

#: ../../library/sqlite3.rst:1543
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in "
"*sql*. See :ref:`sqlite3-placeholders`."
msgstr ""

#: ../../library/sqlite3.rst:1549
msgid "If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr ""

#: ../../library/sqlite3.rst:1555
msgid ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"
msgstr ""

#: ../../library/sqlite3.rst:1570
msgid ""
"Any resulting rows are discarded, including DML statements with "
"`RETURNING clauses`_."
msgstr ""

#: ../../library/sqlite3.rst:1577
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders "
"<sqlite3-placeholders>` are used and the items in *parameters* are "
"sequences instead of :class:`dict`\\s. Starting with Python 3.14, "
":exc:`ProgrammingError` will be raised instead."
msgstr ""

#: ../../library/sqlite3.rst:1586
msgid ""
"Execute the SQL statements in *sql_script*. If the "
":attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and "
"there is a pending transaction, an implicit ``COMMIT`` statement is "
"executed first. No other implicit transaction control is performed; any "
"transaction control must be added to *sql_script*."
msgstr ""

#: ../../library/sqlite3.rst:1594
#, fuzzy
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script*\\는 :class:`str`\\의 인스턴스가 될 수 있습니다."

#: ../../library/sqlite3.rst:1598
msgid ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"
msgstr ""

#: ../../library/sqlite3.rst:1611
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query "
"result set as a :class:`tuple`. Else, pass it to the row factory and "
"return its result. Return ``None`` if no more data is available."
msgstr ""

#: ../../library/sqlite3.rst:1619
#, fuzzy
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return "
"an empty list if no more rows are available."
msgstr "질의 결과의 다음 행 집합을 가져와서, 리스트를 반환합니다. 행이 더 없으면 빈 목록이 반환됩니다."

#: ../../library/sqlite3.rst:1622
#, fuzzy
msgid ""
"The number of rows to fetch per call is specified by the *size* "
"parameter. If *size* is not given, :attr:`arraysize` determines the "
"number of rows to be fetched. If fewer than *size* rows are available, as"
" many rows as are available are returned."
msgstr ""
"호출 당 가져오는 행의 수는 *size* 매개 변수로 지정됩니다. 지정되어 않으면, 커서의 arraysize가 가져올 행의 수를 "
"결정합니다. 이 메서드는 size 매개 변수가 나타내는 수만큼의 행을 가져오려고 해야 합니다. 지정된 수의 행이 없어서 이것이 "
"가능하지 않다면, 더 적은 행이 반환될 수 있습니다."

#: ../../library/sqlite3.rst:1628
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the "
"arraysize attribute. If the *size* parameter is used, then it is best for"
" it to retain the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"*size* 매개 변수와 관련된 성능 고려 사항이 있습니다. 최적의 성능을 위해서, 일반적으로 arraysize 어트리뷰트를 "
"사용하는 것이 가장 좋습니다. *size* 매개 변수가 사용되면, :meth:`fetchmany` 호출마다 같은 값을 유지하는 것이"
" 가장 좋습니다."

#: ../../library/sqlite3.rst:1635
#, fuzzy
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return "
"an empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"질의 결과의 모든 (남은) 행을 가져와서 리스트를 반환합니다. 커서의 arraysize 어트리뷰트는 이 연산의 성능에 영향을 줄 수"
" 있습니다. 행이 없으면 빈 리스트가 반환됩니다."

#: ../../library/sqlite3.rst:1642
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "(``__del__``\\이 호출 될 때가 아니라) 지금 커서를 닫습니다."

#: ../../library/sqlite3.rst:1644
msgid ""
"The cursor will be unusable from this point forward; a "
":exc:`ProgrammingError` exception will be raised if any operation is "
"attempted with the cursor."
msgstr ""
"이 시점부터는 커서를 사용할 수 없습니다; 커서로 어떤 연산이건 시도하면 :exc:`ProgrammingError` 예외가 "
"발생합니다."

#: ../../library/sqlite3.rst:1649 ../../library/sqlite3.rst:1653
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr ""

#: ../../library/sqlite3.rst:1657
msgid ""
"Read/write attribute that controls the number of rows returned by "
":meth:`fetchmany`. The default value is 1 which means a single row would "
"be fetched per call."
msgstr ""
":meth:`fetchmany`\\에 의해 반환되는 행의 수를 제어하는 읽기/쓰기 어트리뷰트. 기본값은 1입니다. 이는 호출 당 "
"하나의 행을 가져오는 것을 뜻합니다."

#: ../../library/sqlite3.rst:1662
#, fuzzy
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection`"
" belonging to the cursor.  A :class:`Cursor` object created by calling "
":meth:`con.cursor() <Connection.cursor>` will have a :attr:`connection` "
"attribute that refers to *con*:"
msgstr ""
"이 읽기 전용 어트리뷰트는 :class:`Cursor` 객체가 사용하는 SQLite 데이터베이스 "
":class:`Connection`\\을 제공합니다. :meth:`con.cursor() <Connection.cursor>`\\를"
" 호출하여 생성된 :class:`Cursor` 객체는 *con*\\을 참조하는 :attr:`connection` 어트리뷰트를 "
"가집니다::"

#: ../../library/sqlite3.rst:1667
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:1677
#, fuzzy
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"이 읽기 전용 어트리뷰트는 마지막 질의의 열 이름을 제공합니다. 파이썬 DB API와의 호환성을 유지하기 위해, 각 열마다 "
"7-튜플을 반환하는데, 각 튜플의 마지막 6개 항목은 :const:`None` 입니다."

#: ../../library/sqlite3.rst:1681
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr "일치하는 행이 없는 ``SELECT`` 문에도 설정됩니다."

#: ../../library/sqlite3.rst:1685
#, fuzzy
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It"
" is only updated after successful ``INSERT`` or ``REPLACE`` statements "
"using the :meth:`execute` method.  For other statements, after "
":meth:`executemany` or :meth:`executescript`, or if the insertion failed,"
" the value of ``lastrowid`` is left unchanged.  The initial value of "
"``lastrowid`` is ``None``."
msgstr ""
"이 읽기 전용 어트리뷰트는 마지막으로 수정된 행의 rowid를 제공합니다. :meth:`execute` 메서드를 사용하여 "
"``INSERT`` 나 ``REPLACE`` 문을 실행했을 때만 설정됩니다. ``INSERT`` 나 ``REPLACE`` 이외의 "
"연산이나 :meth:`executemany`\\가 호출될 때, :attr:`lastrowid`\\는 :const:`None`\\으로"
" 설정됩니다."

#: ../../library/sqlite3.rst:1693
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr ""

#: ../../library/sqlite3.rst:1695
msgid "Added support for the ``REPLACE`` statement."
msgstr "``REPLACE`` 문에 대한 지원이 추가되었습니다."

#: ../../library/sqlite3.rst:1700
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1``"
" for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and "
":meth:`executemany` methods, after the statement has run to completion. "
"This means that any resulting rows must be fetched in order for "
":attr:`!rowcount` to be updated."
msgstr ""

#: ../../library/sqlite3.rst:1711
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row "
"values, and returns a custom object representing an SQLite row."
msgstr ""

#: ../../library/sqlite3.rst:1718
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the "
":class:`!Cursor` was created. Assigning to this attribute does not affect"
" :attr:`Connection.row_factory` of the parent connection."
msgstr ""

#: ../../library/sqlite3.rst:1734
#, fuzzy
msgid "Row objects"
msgstr "Row 객체"

#: ../../library/sqlite3.rst:1738
#, fuzzy
msgid ""
"A :class:`!Row` instance serves as a highly optimized "
":attr:`~Connection.row_factory` for :class:`Connection` objects. It "
"supports iteration, equality testing, :func:`len`, and :term:`mapping` "
"access by column name and index."
msgstr ""
":class:`Row` 인스턴스는 :class:`Connection` 객체에 대해 고도로 최적화된 "
":attr:`~Connection.row_factory` 역할을 합니다. 대부분 기능에서 튜플을 모방하려고 합니다."

#: ../../library/sqlite3.rst:1743
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column "
"names and values."
msgstr ""

#: ../../library/sqlite3.rst:1750
#, fuzzy
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in "
":attr:`Cursor.description`."
msgstr ""
"이 메서드는 열 이름 리스트를 반환합니다. 질의 직후, :attr:`Cursor.description`\\에 있는 각 튜플의 첫 "
"번째 멤버입니다."

#: ../../library/sqlite3.rst:1754
msgid "Added support of slicing."
msgstr "슬라이싱 지원이 추가되었습니다."

#: ../../library/sqlite3.rst:1761
#, fuzzy
msgid "Blob objects"
msgstr "Row 객체"

#: ../../library/sqlite3.rst:1767
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call "
":func:`len(blob) <len>` to get the size (number of bytes) of the blob. "
"Use indices and :term:`slices <slice>` for direct access to the blob "
"data."
msgstr ""

#: ../../library/sqlite3.rst:1772
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the "
"blob handle is closed after use."
msgstr ""

#: ../../library/sqlite3.rst:1775
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:1803
msgid "Close the blob."
msgstr ""

#: ../../library/sqlite3.rst:1805
#, fuzzy
msgid ""
"The blob will be unusable from this point onward.  An "
":class:`~sqlite3.Error` (or subclass) exception will be raised if any "
"further operation is attempted with the blob."
msgstr ""
"이 시점부터는 커서를 사용할 수 없습니다; 커서로 어떤 연산이건 시도하면 :exc:`ProgrammingError` 예외가 "
"발생합니다."

#: ../../library/sqlite3.rst:1811
msgid ""
"Read *length* bytes of data from the blob at the current offset position."
" If the end of the blob is reached, the data up to :abbr:`EOF (End of "
"File)` will be returned.  When *length* is not specified, or is negative,"
" :meth:`~Blob.read` will read until the end of the blob."
msgstr ""

#: ../../library/sqlite3.rst:1819
msgid ""
"Write *data* to the blob at the current offset.  This function cannot "
"change the blob length.  Writing beyond the end of the blob will raise "
":exc:`ValueError`."
msgstr ""

#: ../../library/sqlite3.rst:1825
msgid "Return the current access position of the blob."
msgstr ""

#: ../../library/sqlite3.rst:1829
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). "
"Other values for *origin* are :const:`os.SEEK_CUR` (seek relative to the "
"current position) and :const:`os.SEEK_END` (seek relative to the blob’s "
"end)."
msgstr ""

#: ../../library/sqlite3.rst:1837
msgid "PrepareProtocol objects"
msgstr ""

#: ../../library/sqlite3.rst:1841
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style"
" adaption protocol for objects that can :ref:`adapt themselves "
"<sqlite3-conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:1849
msgid "Exceptions"
msgstr "예외"

#: ../../library/sqlite3.rst:1851
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr ""

#: ../../library/sqlite3.rst:1855
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but"
" may be raised by applications using :mod:`!sqlite3`, for example if a "
"user-defined function truncates data while inserting. ``Warning`` is a "
"subclass of :exc:`Exception`."
msgstr ""

#: ../../library/sqlite3.rst:1862
#, fuzzy
msgid ""
"The base class of the other exceptions in this module. Use this to catch "
"all errors with one single :keyword:`except` statement. ``Error`` is a "
"subclass of :exc:`Exception`."
msgstr "이 모듈에 있는 다른 예외의 베이스 클래스. :exc:`Exception`\\의 서브 클래스입니다."

#: ../../library/sqlite3.rst:1866
msgid ""
"If the exception originated from within the SQLite library, the following"
" two attributes are added to the exception:"
msgstr ""

#: ../../library/sqlite3.rst:1871
msgid ""
"The numeric error code from the `SQLite API "
"<https://sqlite.org/rescode.html>`_"
msgstr ""

#: ../../library/sqlite3.rst:1878
msgid ""
"The symbolic name of the numeric error code from the `SQLite API "
"<https://sqlite.org/rescode.html>`_"
msgstr ""

#: ../../library/sqlite3.rst:1885
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other "
"words, if this exception is raised, it probably indicates a bug in the "
":mod:`!sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""

#: ../../library/sqlite3.rst:1892
msgid ""
"Exception raised for errors that are related to the database. This serves"
" as the base exception for several types of database errors. It is only "
"raised implicitly through the specialised subclasses. ``DatabaseError`` "
"is a subclass of :exc:`Error`."
msgstr ""

#: ../../library/sqlite3.rst:1899
msgid ""
"Exception raised for errors caused by problems with the processed data, "
"like numeric values out of range, and strings which are too long. "
"``DataError`` is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1905
#, fuzzy
msgid ""
"Exception raised for errors that are related to the database's operation,"
" and not necessarily under the control of the programmer. For example, "
"the database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"데이터베이스 연산과 관련되고 프로그래머의 제어하에 있지 않은 에러에 관한 오류. 예를 들어, 예기치 않은 단절이 발생하거나, 데이터"
" 소스 이름을 찾을 수 없거나, 트랜잭션이 진행될 수 없을 때 등. :exc:`DatabaseError`\\의 서브 클래스입니다."

#: ../../library/sqlite3.rst:1913
msgid ""
"Exception raised when the relational integrity of the database is "
"affected, e.g. a foreign key check fails.  It is a subclass of "
":exc:`DatabaseError`."
msgstr ""
"데이터베이스의 관계형 무결성이 영향을 받을 때 발생하는 예외. 예를 들어, 외부 키(foreign key) 검사가 실패할 때. "
":exc:`DatabaseError`\\의 서브 클래스입니다."

#: ../../library/sqlite3.rst:1918
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1925
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate "
"on a closed :class:`Connection`. ``ProgrammingError`` is a subclass of "
":exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:1932
#, fuzzy
msgid ""
"Exception raised in case a method or database API is not supported by the"
" underlying SQLite library. For example, setting *deterministic* to "
"``True`` in :meth:`~Connection.create_function`, if the underlying SQLite"
" library does not support deterministic functions. ``NotSupportedError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"데이터베이스에서 지원하지 않는 메서드나 데이터베이스 API가 사용될 때 발생하는 예외. 예를 들어, 트랜잭션을 지원하지 않는 "
"연결에서 :meth:`~Connection.rollback` 메서드를 호출할 때. :exc:`DatabaseError`\\의 서브 "
"클래스입니다."

#: ../../library/sqlite3.rst:1942
msgid "SQLite and Python types"
msgstr "SQLite 와 파이썬 형"

#: ../../library/sqlite3.rst:1944
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite는 기본적으로 다음 형을 지원합니다: ``NULL``, ``INTEGER``, ``REAL``, ``TEXT``, "
"``BLOB``."

#: ../../library/sqlite3.rst:1947
msgid "The following Python types can thus be sent to SQLite without any problem:"
msgstr "따라서 다음과 같은 파이썬 형을 아무 문제 없이 SQLite로 보낼 수 있습니다:"

#: ../../library/sqlite3.rst:1950 ../../library/sqlite3.rst:1967
msgid "Python type"
msgstr "파이썬 형"

#: ../../library/sqlite3.rst:1950 ../../library/sqlite3.rst:1967
msgid "SQLite type"
msgstr "SQLite 형"

#: ../../library/sqlite3.rst:1952 ../../library/sqlite3.rst:1969
#, fuzzy
msgid "``None``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1952 ../../library/sqlite3.rst:1969
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1954 ../../library/sqlite3.rst:1971
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1954 ../../library/sqlite3.rst:1971
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1956 ../../library/sqlite3.rst:1973
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1956 ../../library/sqlite3.rst:1973
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1958
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1958 ../../library/sqlite3.rst:1975
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1960 ../../library/sqlite3.rst:1978
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1960 ../../library/sqlite3.rst:1978
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1964
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "이것은 SQLite 형이 기본적으로 파이썬 형으로 변환되는 방법입니다:"

#: ../../library/sqlite3.rst:1975
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ":attr:`~Connection.text_factory`\\에 따라 다릅니다, 기본적으로 :class:`str`."

#: ../../library/sqlite3.rst:1981
#, fuzzy
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: "
"you can store additional Python types in an SQLite database via "
":ref:`object adapters <sqlite3-adapters>`, and you can let the "
":mod:`!sqlite3` module convert SQLite types to Python types via "
":ref:`converters <sqlite3-converters>`."
msgstr ""
":mod:`sqlite3` 모듈의 형 시스템은 두 가지 방식으로 확장 가능합니다: 객체 어댑터를 통해 SQLite 데이터베이스에 "
"추가 파이썬 형을 저장할 수 있으며 변환기를 통해 :mod:`sqlite3` 모듈에서 SQLite 형을 다른 파이썬 형으로 변환할 "
"수 있습니다."

#: ../../library/sqlite3.rst:1991
#, fuzzy
msgid "Default adapters and converters (deprecated)"
msgstr "기본 어댑터와 변환기"

#: ../../library/sqlite3.rst:1995
msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them"
" to your needs."
msgstr ""

#: ../../library/sqlite3.rst:1999
#, fuzzy
msgid "The deprecated default adapters and converters consist of:"
msgstr "기본 어댑터와 변환기"

#: ../../library/sqlite3.rst:2001
msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` "
"in `ISO 8601`_ format."
msgstr ""

#: ../../library/sqlite3.rst:2003
msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr ""

#: ../../library/sqlite3.rst:2005
msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to "
":class:`datetime.date` objects."
msgstr ""

#: ../../library/sqlite3.rst:2007
msgid ""
"A converter for declared \"timestamp\" types to "
":class:`datetime.datetime` objects. Fractional parts will be truncated to"
" 6 digits (microsecond precision)."
msgstr ""

#: ../../library/sqlite3.rst:2013
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database "
"and always returns a naive :class:`datetime.datetime` object. To preserve"
" UTC offsets in timestamps, either leave converters disabled, or register"
" an offset-aware converter with :func:`register_converter`."
msgstr ""

#: ../../library/sqlite3.rst:2026
msgid "Command-line interface"
msgstr ""

#: ../../library/sqlite3.rst:2028
msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""

#: ../../library/sqlite3.rst:2033
msgid "python -m sqlite3 [-h] [-v] [filename] [sql]"
msgstr ""

#: ../../library/sqlite3.rst:2035
msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr ""

#: ../../library/sqlite3.rst:2041
msgid "Print CLI help."
msgstr ""

#: ../../library/sqlite3.rst:2045
msgid "Print underlying SQLite library version."
msgstr ""

#: ../../library/sqlite3.rst:2053
msgid "How-to guides"
msgstr ""

#: ../../library/sqlite3.rst:2058
msgid "How to use placeholders to bind values in SQL queries"
msgstr ""

#: ../../library/sqlite3.rst:2060
msgid ""
"SQL operations usually need to use values from Python variables. However,"
" beware of using Python's string operations to assemble queries, as they "
"are vulnerable to `SQL injection attacks`_. For example, an attacker can "
"simply close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""

#: ../../library/sqlite3.rst:2065
#, python-format
msgid ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"
msgstr ""

#: ../../library/sqlite3.rst:2073
#, fuzzy, python-format
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable "
"into a query string, use a placeholder in the string, and substitute the "
"actual values into the query by providing them as a :class:`tuple` of "
"values to the second argument of the cursor's :meth:`~Cursor.execute` "
"method."
msgstr ""
"대신 DB-API의 매개 변수 치환을 사용하십시오. 값을 사용하고자 할 때마다 ``?``\\를 자리 표시자로 넣은 다음, 커서의 "
":meth:`~Cursor.execute` 메서드에 두 번째 인자로 값들의 튜플을 제공하십시오. (다른 데이터베이스 모듈은 다른 "
"자리 표시자를 사용할 수 있습니다, 가령 ``%s`` 나 ``:1``.) 예를 들면::"

#: ../../library/sqlite3.rst:2078
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks"
" (qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the "
"number of placeholders, or a :exc:`ProgrammingError` is raised. For the "
"named style, *parameters* must be an instance of a :class:`dict` (or a "
"subclass), which must contain keys for all named parameters; any extra "
"items are ignored. Here's an example of both styles:"
msgstr ""

#: ../../library/sqlite3.rst:2089
#, python-brace-format
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2116
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will "
"be interpreted as named placeholders."
msgstr ""

#: ../../library/sqlite3.rst:2123
#, fuzzy
msgid "How to adapt custom Python types to SQLite values"
msgstr "어댑터를 사용하여 SQLite 데이터베이스에 추가 파이썬 형을 저장하기"

#: ../../library/sqlite3.rst:2125
msgid ""
"SQLite supports only a limited set of data types natively. To store "
"custom Python types in SQLite databases, *adapt* them to one of the "
":ref:`Python types SQLite natively understands <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:2129
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take"
" precedence above the former. For a library that exports a custom type, "
"it may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""

#: ../../library/sqlite3.rst:2141
msgid "How to write adaptable objects"
msgstr ""

#: ../../library/sqlite3.rst:2143
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding "
"a ``__conform__(self, protocol)`` method which returns the adapted value."
" The object passed to *protocol* will be of type "
":class:`PrepareProtocol`."
msgstr ""

#: ../../library/sqlite3.rst:2151
#, python-brace-format
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2175
#, fuzzy
msgid "How to register adapter callables"
msgstr "어댑터 콜러블 등록하기"

#: ../../library/sqlite3.rst:2177
#, fuzzy
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered"
" using :func:`register_adapter`."
msgstr ""
"또 다른 가능성은 형을 문자열 표현으로 변환하는 함수를 만들고. 그 함수를 :meth:`register_adapter`\\로 "
"등록하는 것입니다."

#: ../../library/sqlite3.rst:2181
#, python-brace-format
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2208
#, fuzzy
msgid "How to convert SQLite values to custom Python types"
msgstr "SQLite 값을 사용자 정의 파이썬 형으로 변환하기"

#: ../../library/sqlite3.rst:2210
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* "
"SQLite values. To be able to convert *from* SQLite values *to* custom "
"Python types, we use *converters*."
msgstr ""

#: ../../library/sqlite3.rst:2215
#, fuzzy
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ":class:`Point` 클래스로 돌아갑시다. 세미콜론으로 분리된 x와 y 좌표를 SQLite에 문자열로 저장했습니다."

#: ../../library/sqlite3.rst:2218
#, fuzzy
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr "먼저, 문자열을 매개 변수로 받아들이고 이것으로부터 :class:`Point` 객체를 만드는 변환기 함수를 정의합니다."

#: ../../library/sqlite3.rst:2223
#, fuzzy
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no "
"matter the underlying SQLite data type."
msgstr "변환기 함수는 **항상** SQLite로 보낸 값의 데이터형에 상관없이 :class:`bytes` 객체로 호출됩니다."

#: ../../library/sqlite3.rst:2226
msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""

#: ../../library/sqlite3.rst:2232
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite"
" value. This is done when connecting to a database, using the "
"*detect_types* parameter of :func:`connect`. There are three options:"
msgstr ""

#: ../../library/sqlite3.rst:2236
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr ""

#: ../../library/sqlite3.rst:2237
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr ""

#: ../../library/sqlite3.rst:2238
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``. Column names take precedence over declared "
"types."
msgstr ""

#: ../../library/sqlite3.rst:2242
#, fuzzy
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr "다음 예는 두 가지 접근법을 보여줍니다."

#: ../../library/sqlite3.rst:2244
#, python-brace-format
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)"
"\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2295
#, fuzzy
msgid "Adapter and converter recipes"
msgstr "기본 어댑터와 변환기"

#: ../../library/sqlite3.rst:2297
msgid "This section shows recipes for common adapters and converters."
msgstr ""

#: ../../library/sqlite3.rst:2299
msgid ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Convert ISO 8601 date to datetime.date object.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Convert ISO 8601 datetime to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\""
"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"
msgstr ""

#: ../../library/sqlite3.rst:2359
#, fuzzy
msgid "How to use connection shortcut methods"
msgstr "바로 가기 메서드 사용하기"

#: ../../library/sqlite3.rst:2361
#, fuzzy
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, "
"and :meth:`~Connection.executescript` methods of the :class:`Connection` "
"class, your code can be written more concisely because you don't have to "
"create the (often superfluous) :class:`Cursor` objects explicitly. "
"Instead, the :class:`Cursor` objects are created implicitly and these "
"shortcut methods return the cursor objects. This way, you can execute a "
"``SELECT`` statement and iterate over it directly using only a single "
"call on the :class:`Connection` object."
msgstr ""
":class:`Connection` 객체의 비표준 :meth:`execute`, :meth:`executemany` 및 "
":meth:`executescript` 메서드를 사용하면, (종종 불필요한) :class:`Cursor` 객체를 명시적으로 만들 "
"필요가 없으므로, 코드를 더 간결하게 작성할 수 있습니다. 대신, :class:`Cursor` 객체가 묵시적으로 만들어지며 이러한 "
"바로 가기 메서드는 커서 객체를 반환합니다. 이런 방법으로, :class:`Connection` 객체에 대한 단일 호출만 사용하여 "
"``SELECT`` 문을 실행하고 직접 이터레이트할 수 있습니다."

#: ../../library/sqlite3.rst:2370
msgid ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2402
#, fuzzy
msgid "How to use the connection context manager"
msgstr "컨텍스트 관리자로 연결 사용하기"

#: ../../library/sqlite3.rst:2404
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the "
"body of the context manager. If the body of the :keyword:`with` statement"
" finishes without exceptions, the transaction is committed. If this "
"commit fails, or if the body of the ``with`` statement raises an uncaught"
" exception, the transaction is rolled back. If "
":attr:`~Connection.autocommit` is ``False``, a new transaction is "
"implicitly opened after committing or rolling back."
msgstr ""

#: ../../library/sqlite3.rst:2415
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""

#: ../../library/sqlite3.rst:2420
msgid ""
"The context manager neither implicitly opens a new transaction nor closes"
" the connection. If you need a closing context manager, consider using "
":meth:`contextlib.closing`."
msgstr ""

#: ../../library/sqlite3.rst:2424
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an "
"exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks "
"transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2454
msgid "How to work with SQLite URIs"
msgstr ""

#: ../../library/sqlite3.rst:2456
msgid "Some useful URI tricks include:"
msgstr ""

#: ../../library/sqlite3.rst:2458
msgid "Open a database in read-only mode:"
msgstr ""

#: ../../library/sqlite3.rst:2460
msgid ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2468
msgid ""
"Do not implicitly create a new database file if it does not already "
"exist; will raise :exc:`~sqlite3.OperationalError` if unable to create a "
"new file:"
msgstr ""

#: ../../library/sqlite3.rst:2471
msgid ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"
msgstr ""

#: ../../library/sqlite3.rst:2478
msgid "Create a shared named in-memory database:"
msgstr ""

#: ../../library/sqlite3.rst:2480
msgid ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"
msgstr ""

#: ../../library/sqlite3.rst:2494
#, fuzzy
msgid ""
"More information about this feature, including a list of parameters, can "
"be found in the `SQLite URI documentation`_."
msgstr ""
"인식되는 옵션 목록을 포함하여, 이 기능에 대한 자세한 내용은 `SQLite URI documentation "
"<https://www.sqlite.org/uri.html>`_\\에서 찾을 수 있습니다."

#: ../../library/sqlite3.rst:2503
msgid "How to create and use row factories"
msgstr ""

#: ../../library/sqlite3.rst:2505
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a"
" :class:`!tuple` does not suit your needs, you can use the "
":class:`sqlite3.Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""

#: ../../library/sqlite3.rst:2510
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the "
":class:`Cursor` and the :class:`Connection`, it is recommended to set "
":class:`Connection.row_factory`, so all cursors created from the "
"connection will use the same row factory."
msgstr ""

#: ../../library/sqlite3.rst:2515
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to "
"columns, with minimal memory overhead and performance impact over a "
":class:`!tuple`. To use :class:`!Row` as a row factory, assign it to the "
":attr:`!row_factory` attribute:"
msgstr ""

#: ../../library/sqlite3.rst:2520
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"
msgstr ""

#: ../../library/sqlite3.rst:2525
#, fuzzy
msgid "Queries now return :class:`!Row` objects:"
msgstr "이제 우리는 :class:`Row`\\를 연결합니다::"

#: ../../library/sqlite3.rst:2527
msgid ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2543
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the"
" above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""

#: ../../library/sqlite3.rst:2548
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row"
" as a :class:`dict`, with column names mapped to values:"
msgstr ""

#: ../../library/sqlite3.rst:2551
#, python-brace-format
msgid ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"
msgstr ""

#: ../../library/sqlite3.rst:2557
msgid ""
"Using it, queries now return a :class:`!dict` instead of a "
":class:`!tuple`:"
msgstr ""

#: ../../library/sqlite3.rst:2559
#, python-brace-format
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2568
msgid "The following row factory returns a :term:`named tuple`:"
msgstr ""

#: ../../library/sqlite3.rst:2570
msgid ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"
msgstr ""

#: ../../library/sqlite3.rst:2579
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ""

#: ../../library/sqlite3.rst:2581
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"
msgstr ""

#: ../../library/sqlite3.rst:2595
msgid ""
"With some adjustments, the above recipe can be adapted to use a "
":class:`~dataclasses.dataclass`, or any other custom class, instead of a "
":class:`~collections.namedtuple`."
msgstr ""

#: ../../library/sqlite3.rst:2603
msgid "How to handle non-UTF-8 text encodings"
msgstr ""

#: ../../library/sqlite3.rst:2605
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with"
" the ``TEXT`` data type. This works well for UTF-8 encoded text, but it "
"might fail for other encodings and invalid UTF-8. You can use a custom "
":attr:`~Connection.text_factory` to handle such cases."
msgstr ""

#: ../../library/sqlite3.rst:2611
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings,"
" or even arbitrary data. To demonstrate, let's assume we have a database "
"with ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-"
"English dictionary entries. Assuming we now have a :class:`Connection` "
"instance :py:data:`!con` connected to this database, we can decode the "
"Latin-2 encoded text using this :attr:`~Connection.text_factory`:"
msgstr ""

#: ../../library/sqlite3.rst:2620
msgid "con.text_factory = lambda data: str(data, encoding=\"latin2\")"
msgstr ""

#: ../../library/sqlite3.rst:2624
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, "
"you can use the following technique, borrowed from the :ref:`unicode-"
"howto`:"
msgstr ""

#: ../../library/sqlite3.rst:2627
msgid "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"
msgstr ""

#: ../../library/sqlite3.rst:2633
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""

#: ../../library/sqlite3.rst:2638
msgid ":ref:`unicode-howto`"
msgstr ""

#: ../../library/sqlite3.rst:2644
#, fuzzy
msgid "Explanation"
msgstr "예외"

#: ../../library/sqlite3.rst:2650
msgid "Transaction control"
msgstr ""

#: ../../library/sqlite3.rst:2652
msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and "
"how database transactions are opened and closed. :ref:`sqlite3"
"-transaction-control-autocommit` is recommended, while :ref:`sqlite3"
"-transaction-control-isolation-level` retains the pre-Python 3.12 "
"behaviour."
msgstr ""

#: ../../library/sqlite3.rst:2661
msgid "Transaction control via the ``autocommit`` attribute"
msgstr ""

#: ../../library/sqlite3.rst:2663
msgid ""
"The recommended way of controlling transaction behaviour is through the "
":attr:`Connection.autocommit` attribute, which should preferably be set "
"using the *autocommit* parameter of :func:`connect`."
msgstr ""

#: ../../library/sqlite3.rst:2668
msgid ""
"It is suggested to set *autocommit* to ``False``, which implies "
":pep:`249`-compliant transaction control. This means:"
msgstr ""

#: ../../library/sqlite3.rst:2672
msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so "
":func:`connect`, :meth:`Connection.commit`, and "
":meth:`Connection.rollback` will implicitly open a new transaction "
"(immediately after closing the pending one, for the latter two). "
":mod:`!sqlite3` uses ``BEGIN DEFERRED`` statements when opening "
"transactions."
msgstr ""

#: ../../library/sqlite3.rst:2677
msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr ""

#: ../../library/sqlite3.rst:2678
msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr ""

#: ../../library/sqlite3.rst:2679
msgid ""
"An implicit rollback is performed if the database is "
":meth:`~Connection.close`-ed with pending changes."
msgstr ""

#: ../../library/sqlite3.rst:2682
msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In "
"this mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have"
" no effect. Note that SQLite's autocommit mode is distinct from the "
":pep:`249`-compliant :attr:`Connection.autocommit` attribute; use "
":attr:`Connection.in_transaction` to query the low-level SQLite "
"autocommit mode."
msgstr ""

#: ../../library/sqlite3.rst:2690
msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave "
"transaction control behaviour to the :attr:`Connection.isolation_level` "
"attribute. See :ref:`sqlite3-transaction-control-isolation-level` for "
"more information."
msgstr ""

#: ../../library/sqlite3.rst:2699
msgid "Transaction control via the ``isolation_level`` attribute"
msgstr ""

#: ../../library/sqlite3.rst:2703
msgid ""
"The recommended way of controlling transactions is via the "
":attr:`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-"
"control-autocommit`."
msgstr ""

#: ../../library/sqlite3.rst:2707
msgid ""
"If :attr:`Connection.autocommit` is set to "
":data:`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour "
"is controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""

#: ../../library/sqlite3.rst:2713
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before "
":meth:`~Cursor.execute` and :meth:`~Cursor.executemany` executes "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statements; for other "
"statements, no implicit transaction handling is performed. Use the "
":meth:`~Connection.commit` and :meth:`~Connection.rollback` methods to "
"respectively commit and roll back pending transactions. You can choose "
"the underlying `SQLite transaction behaviour`_ — that is, whether and "
"what type of ``BEGIN`` statements :mod:`!sqlite3` implicitly executes – "
"via the :attr:`~Connection.isolation_level` attribute."
msgstr ""

#: ../../library/sqlite3.rst:2726
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no "
"transactions are implicitly opened at all. This leaves the underlying "
"SQLite library in `autocommit mode`_, but also allows the user to perform"
" their own transaction handling using explicit SQL statements. The "
"underlying SQLite library autocommit mode can be queried using the "
":attr:`~Connection.in_transaction` attribute."
msgstr ""

#: ../../library/sqlite3.rst:2734
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""

#: ../../library/sqlite3.rst:2738
#, fuzzy
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ":mod:`sqlite3`\\는 DDL 문 앞에서 열린 트랜잭션을 묵시적으로 커밋했습니다. 더는 그렇지 않습니다."

#: ../../library/sqlite3.rst:2742
msgid ""
"The recommended way of controlling transactions is now via the "
":attr:`~Connection.autocommit` attribute."
msgstr ""

#: ../../library/sqlite3.rst:1493
msgid "? (question mark)"
msgstr ""

#: ../../library/sqlite3.rst:1493 ../../library/sqlite3.rst:1494
msgid "in SQL statements"
msgstr ""

#: ../../library/sqlite3.rst:1494
msgid ": (colon)"
msgstr ""

#~ msgid ""
#~ "To use the module, you must first"
#~ " create a :class:`Connection` object that"
#~ " represents the database.  Here the "
#~ "data will be stored in the "
#~ ":file:`example.db` file::"
#~ msgstr ""
#~ "모듈을 사용하려면, 먼저 데이터베이스를 나타내는 "
#~ ":class:`Connection` 객체를 만들어야 합니다. 여기서 "
#~ "데이터는 :file:`example.db` 파일에 저장됩니다 ::"

#~ msgid ""
#~ "You can also supply the special "
#~ "name ``:memory:`` to create a database"
#~ " in RAM."
#~ msgstr "특수 이름 ``:memory:``\\를 제공하여 램에 데이터베이스를 만들 수도 있습니다."

#~ msgid ""
#~ "Once you have a :class:`Connection`, you"
#~ " can create a :class:`Cursor`  object "
#~ "and call its :meth:`~Cursor.execute` method"
#~ " to perform SQL commands::"
#~ msgstr ""
#~ "일단 :class:`Connection`\\를 얻으면, :class:`Cursor` "
#~ "객체를 만들고 :meth:`~Cursor.execute` 메서드를 호출하여 "
#~ "SQL 명령을 수행할 수 있습니다.::"

#~ msgid ""
#~ "The data you've saved is persistent "
#~ "and is available in subsequent "
#~ "sessions::"
#~ msgstr "저장한 데이터는 영구적이며 이후 세션에서 사용할 수 있습니다::"

#~ msgid ""
#~ "Usually your SQL operations will need"
#~ " to use values from Python variables."
#~ "  You shouldn't assemble your query "
#~ "using Python's string operations because "
#~ "doing so is insecure; it makes "
#~ "your program vulnerable to an SQL "
#~ "injection attack (see https://xkcd.com/327/ "
#~ "for humorous example of what can "
#~ "go wrong)."
#~ msgstr ""
#~ "일반적으로 SQL 연산은 파이썬 변수의 값을 사용해야 "
#~ "합니다. 파이썬의 문자열 연산을 사용하여 질의를 조합해서는"
#~ " 안 됩니다. 그렇게 하는 것은 안전하지 않기 "
#~ "때문입니다; 프로그램이 SQL 인젝션 공격에 취약하게 만듭니다"
#~ " (잘못될 수 있는 유머러스한 예를 보려면 "
#~ "https://xkcd.com/327/ 를 참조하십시오)."

#~ msgid ""
#~ "To retrieve data after executing a "
#~ "SELECT statement, you can either treat"
#~ " the cursor as an :term:`iterator`, "
#~ "call the cursor's :meth:`~Cursor.fetchone` "
#~ "method to retrieve a single matching "
#~ "row, or call :meth:`~Cursor.fetchall` to "
#~ "get a list of the matching rows."
#~ msgstr ""
#~ "SELECT 문을 실행한 후 데이터를 꺼내려면, 커서를 "
#~ ":term:`이터레이터 <iterator>`\\로 취급하거나, 커서의 "
#~ ":meth:`~Cursor.fetchone` 메서드를 호출하여 일치하는 단일 "
#~ "행을 꺼내거나, :meth:`~Cursor.fetchall`\\를 호출하여 일치하는"
#~ " 행의 리스트를 가져올 수 있습니다."

#~ msgid "This example uses the iterator form::"
#~ msgstr "이 예제는 이터레이터 방식을 사용합니다::"

#~ msgid ""
#~ "This constant is meant to be used"
#~ " with the *detect_types* parameter of "
#~ "the :func:`connect` function."
#~ msgstr "이 상수는 :func:`connect` 함수의 *detect_types* 매개 변수에 사용됩니다."

#~ msgid ""
#~ "Setting it makes the :mod:`sqlite3` "
#~ "module parse the declared type for "
#~ "each column it returns.  It will "
#~ "parse out the first word of the"
#~ " declared type, i. e.  for \"integer"
#~ " primary key\", it will parse out "
#~ "\"integer\", or for \"number(10)\" it "
#~ "will parse out \"number\". Then for "
#~ "that column, it will look into the"
#~ " converters dictionary and use the "
#~ "converter function registered for that "
#~ "type there."
#~ msgstr ""
#~ "이것을 설정하면 :mod:`sqlite3` 모듈은 반환되는 각 "
#~ "열에 대해 선언된 형을 구문 분석합니다. 선언된 "
#~ "형의 첫 번째 단어를 구문 분석합니다, 즉 "
#~ "\"integer primary key\"에서는 \"integer\"를, "
#~ "\"number (10)\"에서는 \"number\"를 구문 분석합니다. "
#~ "그런 다음 해당 열에 대해, 변환기 딕셔너리를 "
#~ "조사하고 그 형에 대해 등록된 변환기 함수를 "
#~ "사용합니다."

#~ msgid ""
#~ "Setting this makes the SQLite interface"
#~ " parse the column name for each "
#~ "column it returns.  It will look "
#~ "for a string formed [mytype] in "
#~ "there, and then decide that 'mytype' "
#~ "is the type of the column. It "
#~ "will try to find an entry of "
#~ "'mytype' in the converters dictionary "
#~ "and then use the converter function "
#~ "found there to return the value. "
#~ "The column name found in "
#~ ":attr:`Cursor.description` does not include "
#~ "the type, i. e. if you use "
#~ "something like ``'as \"Expiration date "
#~ "[datetime]\"'`` in your SQL, then we "
#~ "will parse out everything until the "
#~ "first ``'['`` for the column name "
#~ "and strip the preceeding space: the "
#~ "column name would simply be \"Expiration"
#~ " date\"."
#~ msgstr ""
#~ "이것을 설정하면 SQLite 인터페이스는 반환되는 각 열의"
#~ " 열 이름을 구문 분석합니다. 거기에서 [mytype] "
#~ "형태의 문자열을 찾은 다음 'mytype'을 열의 형으로"
#~ " 결정합니다. 변환기 딕셔너리에서 'mytype' 항목을 찾은"
#~ " 다음 거기에 있는 변환기 함수를 사용하여 값을 "
#~ "반환하려고 시도합니다. :attr:`Cursor.description`\\에서 발견되는 "
#~ "열 이름은 형 이름을 포함하지 않습니다, 즉, "
#~ "SQL에서 ``'as \"Expiration date "
#~ "[datetime]\"'``\\와 같은 것을 사용하면, 열 이름의 "
#~ "첫 번째 ``'['``\\까지 모든 것을 구문 분석하고 "
#~ "앞에 오는 공백을 제거합니다: 열 이름은 단순히 "
#~ "\"Expiration date\" 가 됩니다."

#~ msgid ""
#~ "Opens a connection to the SQLite "
#~ "database file *database*. By default "
#~ "returns a :class:`Connection` object, unless"
#~ " a custom *factory* is given."
#~ msgstr ""
#~ "SQLite 데이터베이스 파일 *database*\\에 대한 연결을"
#~ " 엽니다. 사용자 정의 *factory*\\가 주어지지 않는 "
#~ "한, 기본적으로 :class:`Connection` 객체를 반환합니다."

#~ msgid ""
#~ "*database* is a :term:`path-like object`"
#~ " giving the pathname (absolute or "
#~ "relative to the current  working "
#~ "directory) of the database file to "
#~ "be opened. You can use ``\":memory:\"``"
#~ " to open a database connection to "
#~ "a database that resides in RAM "
#~ "instead of on disk."
#~ msgstr ""
#~ "*database*\\는 열릴 데이터베이스 파일의 경로명(절대 혹은"
#~ " 현재 작업 디렉터리에 대한 상대)을 제공하는 "
#~ ":term:`경로류 객체 <path-like object>`\\입니다. "
#~ "``\":memory:\"``\\를 사용하여 디스크 대신 램(RAM)에 "
#~ "있는 데이터베이스에 대한 데이터베이스 연결을 열 수 "
#~ "있습니다."

#~ msgid ""
#~ "When a database is accessed by "
#~ "multiple connections, and one of the "
#~ "processes modifies the database, the "
#~ "SQLite database is locked until that "
#~ "transaction is committed. The *timeout* "
#~ "parameter specifies how long the "
#~ "connection should wait for the lock "
#~ "to go away until raising an "
#~ "exception. The default for the timeout"
#~ " parameter is 5.0 (five seconds)."
#~ msgstr ""
#~ "데이터베이스가 여러 연결을 통해 액세스 되고, 프로세스 "
#~ "중 하나가 데이터베이스를 수정할 때, 해당 트랜잭션이 "
#~ "커밋될 때까지 SQLite 데이터베이스가 잠깁니다. *timeout*"
#~ " 매개 변수는 예외를 일으키기 전에 잠금이 해제되기를"
#~ " 연결이 기다려야 하는 시간을 지정합니다. timeout "
#~ "매개 변수의 기본값은 5.0(5초)입니다."

#~ msgid ""
#~ "For the *isolation_level* parameter, please"
#~ " see the :attr:`~Connection.isolation_level` "
#~ "property of :class:`Connection` objects."
#~ msgstr ""
#~ "*isolation_level* 매개 변수는 :class:`Connection` "
#~ "객체의 :attr:`~Connection.isolation_level` 프로퍼티를 "
#~ "참조하십시오."

#~ msgid ""
#~ "SQLite natively supports only the types"
#~ " TEXT, INTEGER, REAL, BLOB and NULL."
#~ " If you want to use other types"
#~ " you must add support for them "
#~ "yourself. The *detect_types* parameter and "
#~ "the using custom **converters** registered "
#~ "with the module-level "
#~ ":func:`register_converter` function allow you "
#~ "to easily do that."
#~ msgstr ""
#~ "SQLite는 기본적으로 TEXT, INTEGER, REAL, BLOB"
#~ " 및 NULL 형만 지원합니다. 다른 형을 사용하려면"
#~ " 직접 지원을 추가해야 합니다. *detect_types* 매개"
#~ " 변수와 모듈 수준 :func:`register_converter` 함수로"
#~ " 등록된 사용자 정의 **변환기**\\를 사용하면 쉽게 "
#~ "할 수 있습니다."

#~ msgid ""
#~ "*detect_types* defaults to 0 (i. e. "
#~ "off, no type detection), you can "
#~ "set it to any combination of "
#~ ":const:`PARSE_DECLTYPES` and :const:`PARSE_COLNAMES` "
#~ "to turn type detection on. Due to"
#~ " SQLite behaviour, types can't be "
#~ "detected for generated fields (for "
#~ "example ``max(data)``), even when "
#~ "*detect_types* parameter is set. In such"
#~ " case, the returned type is "
#~ ":class:`str`."
#~ msgstr ""
#~ "*detect_types*\\의 기본값은 0입니다 (즉, 형 감지가"
#~ " 없습니다). :const:`PARSE_DECLTYPES`\\와 "
#~ ":const:`PARSE_COLNAMES`\\의 조합으로 설정하여 형 감지를 "
#~ "켤 수 있습니다. SQLite 동작으로 인해, "
#~ "*detect_types* 매개 변수가 설정되어 있을 때조차, "
#~ "생성된 필드(예를 들어 ``max(data)``)에 대해 형을 "
#~ "감지할 수 없습니다. 이 경우, 반환되는 형은 "
#~ ":class:`str` 입니다."

#~ msgid ""
#~ "By default, *check_same_thread* is "
#~ ":const:`True` and only the creating "
#~ "thread may use the connection. If "
#~ "set :const:`False`, the returned connection"
#~ " may be shared across multiple "
#~ "threads. When using multiple threads "
#~ "with the same connection writing "
#~ "operations should be serialized by the"
#~ " user to avoid data corruption."
#~ msgstr ""
#~ "기본적으로 *check_same_thread*\\는 :const:`True`\\며, 만들고"
#~ " 있는 스레드 만 이 연결을 사용할 수 "
#~ "있습니다. :const:`False`\\로 설정하면 반환된 연결을 여러"
#~ " 스레드에서 공유할 수 있습니다. 여러 스레드에서 같은"
#~ " 연결을 사용할 때, 데이터 손상을 피하려면 쓰기 "
#~ "연산을 사용자가 직렬화해야 합니다."

#~ msgid ""
#~ "By default, the :mod:`sqlite3` module "
#~ "uses its :class:`Connection` class for "
#~ "the connect call.  You can, however, "
#~ "subclass the :class:`Connection` class and "
#~ "make :func:`connect` use your class "
#~ "instead by providing your class for "
#~ "the *factory* parameter."
#~ msgstr ""
#~ "기본적으로, :mod:`sqlite3` 모듈은 connect 호출에 "
#~ ":class:`Connection` 클래스를 사용합니다. 그러나, "
#~ ":class:`Connection` 클래스의 서브 클래스를 만들고 "
#~ "*factory* 매개 변수에 클래스를 제공하면 "
#~ ":func:`connect`\\가 그 클래스를 사용하게 할 수 "
#~ "있습니다."

#~ msgid "Consult the section :ref:`sqlite3-types` of this manual for details."
#~ msgstr "자세한 내용은 이 설명서의 섹션 :ref:`sqlite3-types`\\을 참조하십시오."

#~ msgid ""
#~ "The :mod:`sqlite3` module internally uses "
#~ "a statement cache to avoid SQL "
#~ "parsing overhead. If you want to "
#~ "explicitly set the number of statements"
#~ " that are cached for the connection,"
#~ " you can set the *cached_statements* "
#~ "parameter. The currently implemented default"
#~ " is to cache 100 statements."
#~ msgstr ""
#~ ":mod:`sqlite3` 모듈은 내부적으로 SQL 구문 분석 "
#~ "오버헤드를 피하고자 명령문 캐시를 사용합니다. 연결에 대해"
#~ " 캐시 되는 명령문의 수를 명시적으로 설정하려면, "
#~ "*cached_statements* 매개 변수를 설정할 수 있습니다."
#~ " 현재 구현된 기본값은 100개의 명령문을 캐시 하는"
#~ " 것입니다."

#~ msgid ""
#~ "If *uri* is true, *database* is "
#~ "interpreted as a URI. This allows "
#~ "you to specify options. For example, "
#~ "to open a database in read-only"
#~ " mode you can use::"
#~ msgstr ""
#~ "*uri*\\가 참이면 *database*\\는 URI로 해석됩니다. "
#~ "이렇게 하면 옵션을 지정할 수 있습니다. 예를 "
#~ "들어, 읽기 전용 모드로 데이터베이스를 열려면 다음과 "
#~ "같이 할 수 있습니다::"

#~ msgid ""
#~ "Registers a callable to convert a "
#~ "bytestring from the database into a "
#~ "custom Python type. The callable will"
#~ " be invoked for all database values"
#~ " that are of the type *typename*. "
#~ "Confer the parameter *detect_types* of "
#~ "the :func:`connect` function for how the"
#~ " type detection works. Note that "
#~ "*typename* and the name of the "
#~ "type in your query are matched in"
#~ " case-insensitive manner."
#~ msgstr ""
#~ "데이터베이스의 바이트열을 사용자 정의 파이썬 형으로 변환할"
#~ " 수 있는 콜러블을 등록합니다. 콜러블은 형 "
#~ "*typename* 인 모든 데이터베이스 값에 대해 "
#~ "호출됩니다. 형 감지 작동 방식에 대해서는 "
#~ ":func:`connect` 함수의 매개 변수 *detect_types*\\를"
#~ " 참고하십시오. *typename*\\과 질의의 형 이름은 "
#~ "대/소문자를 구분하지 않고 일치시킴에 유의하십시오."

#~ msgid ""
#~ "Registers a callable to convert the "
#~ "custom Python type *type* into one "
#~ "of SQLite's supported types. The "
#~ "callable *callable* accepts as single "
#~ "parameter the Python value, and must "
#~ "return a value of the following "
#~ "types: int, float, str or bytes."
#~ msgstr ""
#~ "사용자 정의 파이썬 형 *type*\\을 SQLite의 "
#~ "지원되는 형 중 하나로 변환할 수 있는 콜러블을"
#~ " 등록합니다. 콜러블 *callable*\\은 단일 매개 변수로"
#~ " 파이썬 값을 받아들이고 다음 형들의 값을 반환해야"
#~ " 합니다: int, float, str 또는 bytes."

#~ msgid ""
#~ "This can be used to build a "
#~ "shell for SQLite, as in the "
#~ "following example:"
#~ msgstr "이것은 다음 예제와 같이, SQLite 용 셸을 만드는데 사용할 수 있습니다:"

#~ msgid ""
#~ "Get or set the current default "
#~ "isolation level. :const:`None` for autocommit"
#~ " mode or one of \"DEFERRED\", "
#~ "\"IMMEDIATE\" or \"EXCLUSIVE\". See section"
#~ " :ref:`sqlite3-controlling-transactions` for a"
#~ " more detailed explanation."
#~ msgstr ""
#~ "현재의 기본 격리 수준을 가져오거나 설정합니다. 자동 "
#~ "커밋 모드를 뜻하는 :const:`None` 이나 "
#~ "\"DEFERRED\", \"IMMEDIATE\" 또는 \"EXCLUSIVE\" 중"
#~ " 하나입니다. 자세한 설명은 :ref:`sqlite3-controlling-"
#~ "transactions` 절을 참조하십시오."

#~ msgid ""
#~ "This method commits the current "
#~ "transaction. If you don't call this "
#~ "method, anything you did since the "
#~ "last call to ``commit()`` is not "
#~ "visible from other database connections. "
#~ "If you wonder why you don't see"
#~ " the data you've written to the "
#~ "database, please check you didn't forget"
#~ " to call this method."
#~ msgstr ""
#~ "이 메서드는 현재 트랜잭션을 커밋합니다. 이 메서드를 "
#~ "호출하지 않으면, 마지막 ``commit()`` 호출 이후에 "
#~ "수행한 작업은 다른 데이터베이스 연결에서 볼 수 "
#~ "없습니다. 데이터베이스에 기록한 데이터가 왜 보이지 않는지"
#~ " 궁금하면, 이 메서드를 호출하는 것을 잊지 않았는지"
#~ " 확인하십시오."

#~ msgid ""
#~ "This method rolls back any changes "
#~ "to the database since the last "
#~ "call to :meth:`commit`."
#~ msgstr "이 메서드는 마지막 :meth:`commit` 호출 이후의 데이터베이스에 대한 모든 변경 사항을 되돌립니다."

#~ msgid ""
#~ "This closes the database connection. "
#~ "Note that this does not automatically"
#~ " call :meth:`commit`. If you just "
#~ "close your database connection without "
#~ "calling :meth:`commit` first, your changes "
#~ "will be lost!"
#~ msgstr ""
#~ "데이터베이스 연결을 닫습니다. 자동으로 :meth:`commit`\\을 "
#~ "호출하지 않음에 유의하십시오. :meth:`commit`\\를 먼저 "
#~ "호출하지 않고 데이터베이스 연결을 닫으면 변경 사항이 "
#~ "손실됩니다!"

#~ msgid ""
#~ "This is a nonstandard shortcut that "
#~ "creates a cursor object by calling "
#~ "the :meth:`~Connection.cursor` method, calls "
#~ "the cursor's :meth:`~Cursor.execute` method "
#~ "with the *parameters* given, and returns"
#~ " the cursor."
#~ msgstr ""
#~ "이것은 비표준 바로 가기인데, :meth:`~Connection.cursor`"
#~ " 메서드를 호출하여 커서 객체를 만들고, 지정된 "
#~ "*parameters*\\를 사용하여 커서의 :meth:`~Cursor.execute` "
#~ "메서드를 호출한 다음, 커서를 반환합니다."

#~ msgid ""
#~ "This is a nonstandard shortcut that "
#~ "creates a cursor object by calling "
#~ "the :meth:`~Connection.cursor` method, calls "
#~ "the cursor's :meth:`~Cursor.executemany` method "
#~ "with the *parameters* given, and returns"
#~ " the cursor."
#~ msgstr ""
#~ "이것은 비표준 바로 가기인데, :meth:`~Connection.cursor`"
#~ " 메서드를 호출하여 커서 객체를 만들고, 지정된 "
#~ "*parameters*\\를 사용하여 커서의 :meth:`~Cursor.executemany`"
#~ " 메서드를 호출한 다음, 커서를 반환합니다."

#~ msgid ""
#~ "This is a nonstandard shortcut that "
#~ "creates a cursor object by calling "
#~ "the :meth:`~Connection.cursor` method, calls "
#~ "the cursor's :meth:`~Cursor.executescript` method"
#~ " with the given *sql_script*, and "
#~ "returns the cursor."
#~ msgstr ""
#~ "이것은 비표준 바로 가기인데, :meth:`~Connection.cursor`"
#~ " 메서드를 호출하여 커서 객체를 만들고, 지정된 "
#~ "*sql_script*\\를 사용하여 커서의 "
#~ ":meth:`~Cursor.executescript` 메서드를 호출한 다음, 커서를"
#~ " 반환합니다."

#~ msgid ""
#~ "Creates a user-defined function that "
#~ "you can later use from within SQL"
#~ " statements under the function name "
#~ "*name*. *num_params* is the number of"
#~ " parameters the function accepts (if "
#~ "*num_params* is -1, the function may "
#~ "take any number of arguments), and "
#~ "*func* is a Python callable that "
#~ "is called as the SQL function. If"
#~ " *deterministic* is true, the created "
#~ "function is marked as `deterministic "
#~ "<https://sqlite.org/deterministic.html>`_, which allows"
#~ " SQLite to perform additional "
#~ "optimizations. This flag is supported by"
#~ " SQLite 3.8.3 or higher, "
#~ ":exc:`NotSupportedError` will be raised if "
#~ "used with older versions."
#~ msgstr ""
#~ "나중에 함수 이름 *name*\\으로 SQL 문에서 사용할"
#~ " 수 있는 사용자 정의 함수를 만듭니다. "
#~ "*num_params*\\는 함수가 받아들이는 매개 변수의 수입니다"
#~ " (*num_params*\\가 -1이면 함수는 임의의 인자를 취할"
#~ " 수 있습니다). *func*\\는 SQL 함수로 호출되는 "
#~ "파이썬 콜러블입니다. *deterministic*\\이 참이면, 만들어진 "
#~ "함수는 SQLite가 추가적인 최적화를 수행할 수 있도록"
#~ " `결정론적(deterministic) "
#~ "<https://sqlite.org/deterministic.html>`_\\으로 표시됩니다. 이 "
#~ "플래그는 SQLite 3.8.3 이상에서 지원됩니다, 이전 "
#~ "버전에서 사용되면 :exc:`NotSupportedError`\\가 발생합니다."

#~ msgid ""
#~ "The function can return any of the"
#~ " types supported by SQLite: bytes, "
#~ "str, int, float and ``None``."
#~ msgstr "함수는 SQLite가 지원하는 모든 형을 반환할 수 있습니다: bytes, str, int, float 및 ``None``."

#~ msgid "The *deterministic* parameter was added."
#~ msgstr "*deterministic* 매개 변수가 추가되었습니다."

#~ msgid ""
#~ "The aggregate class must implement a "
#~ "``step`` method, which accepts the "
#~ "number of parameters *num_params* (if "
#~ "*num_params* is -1, the function may "
#~ "take any number of arguments), and "
#~ "a ``finalize`` method which will return"
#~ " the final result of the aggregate."
#~ msgstr ""
#~ "매개 변수의 수 *num_params*\\(*num_params*\\가 -1이면"
#~ " 함수는 임의의 인자를 취할 수 있습니다)를 받아들이며,"
#~ " 집계 클래스는 ``step`` 메서드와 집계의 최종 "
#~ "결과를 반환하는 ``finalize`` 메서드를 구현해야 합니다."

#~ msgid ""
#~ "The ``finalize`` method can return any"
#~ " of the types supported by SQLite:"
#~ " bytes, str, int, float and ``None``."
#~ msgstr ""
#~ "``finalize`` 메서드는 SQLite가 지원하는 모든 형을 "
#~ "반환할 수 있습니다: bytes, str, int, float"
#~ " 및 ``None``."

#~ msgid ""
#~ "Creates a collation with the specified"
#~ " *name* and *callable*. The callable "
#~ "will be passed two string arguments. "
#~ "It should return -1 if the first"
#~ " is ordered lower than the second,"
#~ " 0 if they are ordered equal "
#~ "and 1 if the first is ordered "
#~ "higher than the second.  Note that "
#~ "this controls sorting (ORDER BY in "
#~ "SQL) so your comparisons don't affect"
#~ " other SQL operations."
#~ msgstr ""
#~ "지정된 *name* 과 *callable*\\로 정렬법(collation)을 "
#~ "만듭니다. 콜러블에는 두 개의 문자열 인자가 전달됩니다."
#~ " 첫째가 둘째보다 작은 순서면 -1, 같은 순서면 "
#~ "0, 첫째가 둘째보다 큰 순서면 1을 반환 해야"
#~ " 합니다. 이것은 정렬(SQL의 ORDER BY)을 제어하므로,"
#~ " 여러분의 비교는 다른 SQL 연산에 영향을 주지 "
#~ "않습니다."

#~ msgid ""
#~ "Note that the callable will get "
#~ "its parameters as Python bytestrings, "
#~ "which will normally be encoded in "
#~ "UTF-8."
#~ msgstr "콜러블 객체는 보통 UTF-8로 인코딩된 파이썬 바이트열로 매개 변수를 가져옵니다."

#~ msgid ""
#~ "To remove a collation, call "
#~ "``create_collation`` with ``None`` as "
#~ "callable::"
#~ msgstr "정렬법을 제거하려면 callable에 ``None``\\을 사용해서 ``create_collation``\\를 호출하십시오::"

#~ msgid "Loadable extensions are disabled by default. See [#f1]_."
#~ msgstr "로드 가능한 확장은 기본적으로 비활성화되어 있습니다. [#f1]_\\를 보세요."

#~ msgid ""
#~ "You can change this attribute to a"
#~ " callable that accepts the cursor and"
#~ " the original row as a tuple "
#~ "and will return the real result "
#~ "row.  This way, you can implement "
#~ "more advanced ways of returning results,"
#~ " such  as returning an object that"
#~ " can also access columns by name."
#~ msgstr ""
#~ "이 어트리뷰트를 커서와 원본 행을 튜플로 받아들이고 "
#~ "실제 결과 행을 반환하는 콜러블로 변경할 수 "
#~ "있습니다. 이렇게 하면, 이름으로 열을 액세스할 수 "
#~ "있는 객체를 반환하는 것과 같이, 결과를 반환하는 "
#~ "더 고급 방식을 구현할 수 있습니다."

#~ msgid ""
#~ "If returning a tuple doesn't suffice "
#~ "and you want name-based access to"
#~ " columns, you should consider setting "
#~ ":attr:`row_factory` to the highly-optimized"
#~ " :class:`sqlite3.Row` type. :class:`Row` provides"
#~ " both index-based and case-"
#~ "insensitive name-based access to columns"
#~ " with almost no memory overhead. It"
#~ " will probably be better than your"
#~ " own custom dictionary-based approach "
#~ "or even a db_row based solution."
#~ msgstr ""
#~ "튜플을 반환하는 것으로 충분하지 않고 열에 대한 "
#~ "이름 기반 액세스를 원하면, :attr:`row_factory`\\를 "
#~ "고도로 최적화된 :class:`sqlite3.Row` 형으로 설정하는 "
#~ "것을 고려해야 합니다. :class:`Row`\\는 메모리 오버헤드가"
#~ " 거의 없이 열에 대해 인덱스 기반과 대소 "
#~ "문자를 구분하지 않는 이름 기반 액세스를 제공합니다. "
#~ "아마도 여러분 자신의 사용자 정의 딕셔너리 기반 "
#~ "접근법이나 심지어 db_row 기반 해법보다 더 좋을 "
#~ "것입니다."

#~ msgid ""
#~ "Using this attribute you can control "
#~ "what objects are returned for the "
#~ "``TEXT`` data type. By default, this "
#~ "attribute is set to :class:`str` and "
#~ "the :mod:`sqlite3` module will return "
#~ "Unicode objects for ``TEXT``. If you "
#~ "want to return bytestrings instead, you"
#~ " can set it to :class:`bytes`."
#~ msgstr ""
#~ "이 어트리뷰트를 사용하면 ``TEXT`` 데이터형에 대해 "
#~ "반환되는 객체를 제어할 수 있습니다. 기본적으로, 이 "
#~ "어트리뷰트는 :class:`str`\\로 설정되고 :mod:`sqlite3` 모듈은"
#~ " ``TEXT``\\에 대해 유니코드 객체를 반환합니다. 대신"
#~ " 바이트열을 반환하려면, :class:`bytes`\\로 설정할 수 "
#~ "있습니다."

#~ msgid ""
#~ "You can also set it to any "
#~ "other callable that accepts a single "
#~ "bytestring parameter and returns the "
#~ "resulting object."
#~ msgstr "하나의 바이트열 매개 변수를 받아들이고 결과 객체를 반환하는 다른 콜러블 객체로 설정할 수도 있습니다."

#~ msgid "See the following example code for illustration:"
#~ msgstr "예시를 위해 다음 예제 코드를 참조하십시오:"

#~ msgid "Example::"
#~ msgstr "예::"

#~ msgid ""
#~ "This method makes a backup of a"
#~ " SQLite database even while it's "
#~ "being accessed by other clients, or "
#~ "concurrently by the same connection.  "
#~ "The copy will be written into the"
#~ " mandatory argument *target*, that must "
#~ "be another :class:`Connection` instance."
#~ msgstr ""
#~ "이 메서드는 SQLite 데이터베이스의 백업을 만드는데, 다른"
#~ " 클라이언트가 액세스하고 있거나 같은 연결로 동시에 "
#~ "액세스하고 있어도 됩니다. 복사본은 필수 인자 "
#~ "*target*\\에 기록되며, 이것은 다른 :class:`Connection`"
#~ " 인스턴스여야 합니다."

#~ msgid ""
#~ "By default, or when *pages* is "
#~ "either ``0`` or a negative integer, "
#~ "the entire database is copied in a"
#~ " single step; otherwise the method "
#~ "performs a loop copying up to "
#~ "*pages* pages at a time."
#~ msgstr ""
#~ "기본적으로, 또는 *pages*\\가 ``0`` 이나 음의 "
#~ "정수이면, 전체 데이터베이스가 단일 단계로 복사됩니다; 그렇지"
#~ " 않으면 이 메서드는 한 번에 최대 *pages* "
#~ "페이지만큼 복사하는 루프를 수행합니다."

#~ msgid "Availability: SQLite 3.6.11 or higher"
#~ msgstr "가용성: SQLite 3.6.11 이상"

#~ msgid ""
#~ "Executes an SQL statement. The SQL "
#~ "statement may be parameterized (i. e."
#~ " placeholders instead of SQL literals). "
#~ "The :mod:`sqlite3` module supports two "
#~ "kinds of placeholders: question marks "
#~ "(qmark style) and named placeholders "
#~ "(named style)."
#~ msgstr ""
#~ "SQL 문을 실행합니다. SQL 문을 매개 변수화(즉, "
#~ "SQL 리터럴 대신 자리 표시자)할 수 있습니다. "
#~ ":mod:`sqlite3` 모듈은 두 가지 자리 표시자를 "
#~ "지원합니다: 물음표(qmark 스타일)와 이름있는 자리 표시자(named"
#~ " 스타일)."

#~ msgid "Here's an example of both styles:"
#~ msgstr "다음은 두 스타일의 예입니다:"

#~ msgid ""
#~ ":meth:`execute` will only execute a "
#~ "single SQL statement. If you try "
#~ "to execute more than one statement "
#~ "with it, it will raise a "
#~ ":exc:`.Warning`. Use :meth:`executescript` if "
#~ "you want to execute multiple SQL "
#~ "statements with one call."
#~ msgstr ""
#~ ":meth:`execute`\\는 단일 SQL 문만 실행합니다. 하나"
#~ " 이상의 명령문을 실행하려고 하면 :exc:`.Warning`\\이 "
#~ "발생합니다. 하나의 호출로 여러 SQL 문을 실행하려면 "
#~ ":meth:`executescript`\\를 사용하십시오."

#~ msgid ""
#~ "Executes an SQL command against all "
#~ "parameter sequences or mappings found in"
#~ " the sequence *seq_of_parameters*.  The "
#~ ":mod:`sqlite3` module also allows using "
#~ "an :term:`iterator` yielding parameters "
#~ "instead of a sequence."
#~ msgstr ""
#~ "시퀀스 *seq_of_parameters*\\에 있는 모든 매개 변수"
#~ " 시퀀스나 매핑에 대해 SQL 명령을 실행합니다. "
#~ ":mod:`sqlite3` 모듈은 시퀀스 대신 매개 변수를 "
#~ "산출하는 :term:`이터레이터 <iterator>`\\도 허용합니다."

#~ msgid "Here's a shorter example using a :term:`generator`:"
#~ msgstr "다음은 :term:`제너레이터 <generator>`\\를 사용하는 간단한 예입니다:"

#~ msgid ""
#~ "This is a nonstandard convenience method"
#~ " for executing multiple SQL statements "
#~ "at once. It issues a ``COMMIT`` "
#~ "statement first, then executes the SQL"
#~ " script it gets as a parameter."
#~ msgstr ""
#~ "이것은 한 번에 여러 SQL 문을 실행하기 위한"
#~ " 비표준 편의 메서드입니다. 먼저 ``COMMIT`` 문을 "
#~ "실행한 다음, 매개 변수로 가져온 SQL 스크립트를 "
#~ "실행합니다."

#~ msgid ""
#~ "Fetches the next row of a query"
#~ " result set, returning a single "
#~ "sequence, or :const:`None` when no more"
#~ " data is available."
#~ msgstr ""
#~ "질의 결과 집합의 다음 행을 가져옵니다. 단일 "
#~ "시퀀스를 반환하거나, 데이터가 더 없을 때 "
#~ ":const:`None`\\을 반환합니다."

#~ msgid ""
#~ "Although the :class:`Cursor` class of "
#~ "the :mod:`sqlite3` module implements this "
#~ "attribute, the database engine's own "
#~ "support for the determination of \"rows"
#~ " affected\"/\"rows selected\" is quirky."
#~ msgstr ""
#~ ":mod:`sqlite3` 모듈의 :class:`Cursor` 클래스가 이 "
#~ "어트리뷰트를 구현하지만, \"영향을 받는 행\"/\"선택된 행\"의"
#~ " 판단을 위한 데이터베이스 엔진 자체 지원은 기이합니다."

#~ msgid ""
#~ "For :meth:`executemany` statements, the number"
#~ " of modifications are summed up into"
#~ " :attr:`rowcount`."
#~ msgstr ":meth:`executemany` 문에서, 수정 횟수는 :attr:`rowcount`\\에 합산됩니다."

#~ msgid ""
#~ "As required by the Python DB API"
#~ " Spec, the :attr:`rowcount` attribute \"is"
#~ " -1 in case no ``executeXX()`` has"
#~ " been performed on the cursor or "
#~ "the rowcount of the last operation "
#~ "is not determinable by the interface\"."
#~ " This includes ``SELECT`` statements "
#~ "because we cannot determine the number"
#~ " of rows a query produced until "
#~ "all rows were fetched."
#~ msgstr ""
#~ "파이썬 DB API 스펙에 따라, :attr:`rowcount` "
#~ "어트리뷰트는 커서에서 ``executeXX()``\\가 수행되지 않았거나 "
#~ "마지막 연산의 행 개수가 인터페이스에 의해 결정되지 "
#~ "않는 경우 -1입니다. 이런 경우는 ``SELECT`` 문을"
#~ " 포함하는데, 모든 행을 가져올 때까지 질의가 생성"
#~ " 한 행 수를 결정할 수 없기 때문입니다."

#~ msgid ""
#~ "With SQLite versions before 3.6.5, "
#~ ":attr:`rowcount` is set to 0 if "
#~ "you make a ``DELETE FROM table`` "
#~ "without any condition."
#~ msgstr ""
#~ "3.6.5 이전의 SQLite 버전에서는, 조건 없이 "
#~ "``DELETE FROM table``\\을 하면 "
#~ ":attr:`rowcount`\\가 0으로 설정됩니다."

#~ msgid ""
#~ "If the ``INSERT`` or ``REPLACE`` "
#~ "statement failed to insert the previous"
#~ " successful rowid is returned."
#~ msgstr "``INSERT`` 나 ``REPLACE`` 문이 삽입에 실패하면, 이전의 성공적인 rowid가 반환됩니다."

#~ msgid ""
#~ "It supports mapping access by column "
#~ "name and index, iteration, representation, "
#~ "equality testing and :func:`len`."
#~ msgstr "열 이름과 인덱스에 의한 매핑 액세스와, 이터레이션, 표현(repr), 동등성 검사 및 :func:`len`\\을 지원합니다."

#~ msgid ""
#~ "If two :class:`Row` objects have exactly"
#~ " the same columns and their members"
#~ " are equal, they compare equal."
#~ msgstr "두 개의 :class:`Row` 객체가 정확히 같은 열을 갖고 그 구성원이 같으면 같다고 비교됩니다."

#~ msgid "Let's assume we initialize a table as in the example given above::"
#~ msgstr "위에서 주어진 예제에서처럼 테이블을 초기화한다고 가정해 봅시다::"

#~ msgid "A subclass of :exc:`Exception`."
#~ msgstr ":exc:`Exception`\\의 서브 클래스."

#~ msgid "Exception raised for errors that are related to the database."
#~ msgstr "데이터베이스와 관련된 에러에 대해 발생하는 예외."

#~ msgid ""
#~ "Exception raised for programming errors, "
#~ "e.g. table not found or already "
#~ "exists, syntax error in the SQL "
#~ "statement, wrong number of parameters "
#~ "specified, etc.  It is a subclass "
#~ "of :exc:`DatabaseError`."
#~ msgstr ""
#~ "프로그래밍 에러에 대한 예외, 예를 들어, 테이블을 "
#~ "찾을 수 없거나 이미 존재 함, SQL 문의 "
#~ "문법 에러, 지정된 매개 변수 개수가 잘못됨 등."
#~ " :exc:`DatabaseError`\\의 서브 클래스입니다."

#~ msgid "Introduction"
#~ msgstr "소개"

#~ msgid ":const:`None`"
#~ msgstr ":const:`None`"

#~ msgid ""
#~ "As described before, SQLite supports "
#~ "only a limited set of types "
#~ "natively. To use other Python types "
#~ "with SQLite, you must **adapt** them "
#~ "to one of the sqlite3 module's "
#~ "supported types for SQLite: one of "
#~ "NoneType, int, float, str, bytes."
#~ msgstr ""
#~ "앞에서 설명한 것처럼, SQLite는 기본적으로 제한된 형"
#~ " 집합만 지원합니다. SQLite에 다른 파이썬 형을 "
#~ "사용하려면, SQLite에 대해 sqlite3 모듈이 지원하는 "
#~ "형 중 하나로 **어댑트** 해야 합니다: NoneType,"
#~ " int, float, str, bytes 중 하나."

#~ msgid ""
#~ "There are two ways to enable the"
#~ " :mod:`sqlite3` module to adapt a "
#~ "custom Python type to one of the"
#~ " supported ones."
#~ msgstr ""
#~ ":mod:`sqlite3` 모듈이 사용자 정의 파이썬 형을, "
#~ "지원되는 형 중 하나로 어댑트하도록 만드는 두 가지"
#~ " 방법이 있습니다."

#~ msgid "Letting your object adapt itself"
#~ msgstr "객체가 스스로 어댑트하도록 하기"

#~ msgid ""
#~ "This is a good approach if you "
#~ "write the class yourself. Let's suppose"
#~ " you have a class like this::"
#~ msgstr "여러분이 스스로 클래스를 작성한다면 이것이 좋은 접근법입니다. 다음과 같은 클래스가 있다고 가정해 봅시다::"

#~ msgid ""
#~ "Now you want to store the point"
#~ " in a single SQLite column.  First"
#~ " you'll have to choose one of "
#~ "the supported types to be used for"
#~ " representing the point. Let's just "
#~ "use str and separate the coordinates "
#~ "using a semicolon. Then you need "
#~ "to give your class a method "
#~ "``__conform__(self, protocol)`` which must "
#~ "return the converted value. The "
#~ "parameter *protocol* will be "
#~ ":class:`PrepareProtocol`."
#~ msgstr ""
#~ "이제 Point를 단일 SQLite 열에 저장하려고 합니다."
#~ " 먼저 포인트를 나타내는데 사용할 지원되는 형 중 "
#~ "하나를 선택해야 합니다. str을 사용하고 좌표를 세미콜론으로"
#~ " 분리하기로 합시다. 그런 다음 여러분의 클래스에 변환된"
#~ " 값을 반환하는 ``__conform__(self, protocol)`` "
#~ "메서드를 제공해야 합니다. 매개 변수 *protocol*\\은 "
#~ ":class:`PrepareProtocol`\\이 됩니다."

#~ msgid ""
#~ "The :mod:`sqlite3` module has two "
#~ "default adapters for Python's built-in"
#~ " :class:`datetime.date` and :class:`datetime.datetime`"
#~ " types.  Now let's suppose we want"
#~ " to store :class:`datetime.datetime` objects "
#~ "not in ISO representation, but as "
#~ "a Unix timestamp."
#~ msgstr ""
#~ ":mod:`sqlite3` 모듈에는 파이썬의 내장 "
#~ ":class:`datetime.date` 와 :class:`datetime.datetime` "
#~ "형에 대한 두 개의 기본 어댑터가 있습니다. 이제"
#~ " :class:`datetime.datetime` 객체를 ISO 표현이 아닌"
#~ " 유닉스 타임스탬프로 저장하려고 한다고 가정해 봅시다."

#~ msgid ""
#~ "Writing an adapter lets you send "
#~ "custom Python types to SQLite. But "
#~ "to make it really useful we need"
#~ " to make the Python to SQLite "
#~ "to Python roundtrip work."
#~ msgstr ""
#~ "어댑터를 작성하면 사용자 정의 파이썬 형을 SQLite로"
#~ " 보낼 수 있습니다. 그러나 실제로 유용하게 사용하려면"
#~ " 파이썬에서 SQLite를 거쳐 다시 파이썬으로 돌아오는 "
#~ "순환이 동작하게 할 필요가 있습니다."

#~ msgid ""
#~ "Now you need to make the "
#~ ":mod:`sqlite3` module know that what you"
#~ " select from the database is actually"
#~ " a point. There are two ways of"
#~ " doing this:"
#~ msgstr ""
#~ "이제 :mod:`sqlite3` 모듈이 데이터베이스에서 select 한"
#~ " 것이 실제로 Point임을 알게 해야 합니다. 이렇게"
#~ " 하는 두 가지 방법이 있습니다:"

#~ msgid "Implicitly via the declared type"
#~ msgstr "선언된 형을 통해 묵시적으로"

#~ msgid "Explicitly via the column name"
#~ msgstr "열 이름을 통해 명시적으로"

#~ msgid ""
#~ "Both ways are described in section "
#~ ":ref:`sqlite3-module-contents`, in the entries"
#~ " for the constants :const:`PARSE_DECLTYPES` "
#~ "and :const:`PARSE_COLNAMES`."
#~ msgstr ""
#~ "두 가지 방법은 섹션 :ref:`sqlite3-module-"
#~ "contents` 의 상수 :const:`PARSE_DECLTYPES` 와 "
#~ ":const:`PARSE_COLNAMES`\\에 대한 항목에서 설명합니다."

#~ msgid ""
#~ "There are default adapters for the "
#~ "date and datetime types in the "
#~ "datetime module. They will be sent "
#~ "as ISO dates/ISO timestamps to SQLite."
#~ msgstr ""
#~ "datetime 모듈의 date와 datetime 형에 대한 "
#~ "기본 어댑터가 있습니다. 이것들은 ISO 날짜/ISO "
#~ "타임스탬프로 SQLite로 보내집니다."

#~ msgid ""
#~ "The default converters are registered "
#~ "under the name \"date\" for "
#~ ":class:`datetime.date` and under the name "
#~ "\"timestamp\" for :class:`datetime.datetime`."
#~ msgstr ""
#~ "기본 변환기는 :class:`datetime.date`\\는 \"date\"라는 "
#~ "이름으로, :class:`datetime.datetime`\\은 \"timestamp\"라는 "
#~ "이름으로 등록됩니다."

#~ msgid ""
#~ "This way, you can use date/timestamps"
#~ " from Python without any additional "
#~ "fiddling in most cases. The format "
#~ "of the adapters is also compatible "
#~ "with the experimental SQLite date/time "
#~ "functions."
#~ msgstr ""
#~ "이런 방법으로, 대부분 추가 작업 없이 파이썬의 "
#~ "날짜/타임스탬프를 사용할 수 있습니다. 어댑터의 형식은 "
#~ "실험적인 SQLite 날짜/시간 함수와도 호환됩니다."

#~ msgid "The following example demonstrates this."
#~ msgstr "다음 예제는 이를 보여줍니다."

#~ msgid ""
#~ "If a timestamp stored in SQLite "
#~ "has a fractional part longer than "
#~ "6 numbers, its value will be "
#~ "truncated to microsecond precision by "
#~ "the timestamp converter."
#~ msgstr ""
#~ "SQLite에 저장된 타임스탬프가 6자리보다 긴 소수부가 "
#~ "있으면, 그 값은 타임스탬프 변환기에 의해 마이크로초 "
#~ "정밀도로 잘립니다."

#~ msgid "Controlling Transactions"
#~ msgstr "트랜잭션 제어"

#~ msgid ""
#~ "The underlying ``sqlite3`` library operates"
#~ " in ``autocommit`` mode by default, "
#~ "but the Python :mod:`sqlite3` module by"
#~ " default does not."
#~ msgstr ""
#~ "하부 ``sqlite3`` 라이브러리는 기본적으로 ``autocommit`` "
#~ "모드로 작동하지만, 파이썬 :mod:`sqlite3` 모듈은 기본적으로"
#~ " 그렇지 않습니다."

#~ msgid ""
#~ "``autocommit`` mode means that statements "
#~ "that modify the database take effect "
#~ "immediately.  A ``BEGIN`` or ``SAVEPOINT`` "
#~ "statement disables ``autocommit`` mode, and"
#~ " a ``COMMIT``, a ``ROLLBACK``, or a"
#~ " ``RELEASE`` that ends the outermost "
#~ "transaction, turns ``autocommit`` mode back"
#~ " on."
#~ msgstr ""
#~ "``autocommit`` 모드는 데이터베이스를 수정하는 명령문이 즉시"
#~ " 적용됨을 뜻합니다. ``BEGIN`` 이나 ``SAVEPOINT`` "
#~ "문은 ``autocommit`` 모드를 비활성화하고, 가장 바깥쪽 "
#~ "트랜잭션을 끝내는 ``COMMIT``, ``ROLLBACK`` 또는 "
#~ "``RELEASE``\\는 ``autocommit`` 모드를 다시 켭니다."

#~ msgid ""
#~ "The Python :mod:`sqlite3` module by "
#~ "default issues a ``BEGIN`` statement "
#~ "implicitly before a Data Modification "
#~ "Language (DML) statement (i.e. "
#~ "``INSERT``/``UPDATE``/``DELETE``/``REPLACE``)."
#~ msgstr ""
#~ "기본적으로 파이썬 :mod:`sqlite3` 모듈은 데이터 조작 "
#~ "언어(DML - Data Modification Language) 문"
#~ " (즉, ``INSERT``/``UPDATE``/``DELETE``/``REPLACE``) 앞에"
#~ " 암묵적으로 ``BEGIN`` 문을 넣습니다."

#~ msgid ""
#~ "You can control which kind of "
#~ "``BEGIN`` statements :mod:`sqlite3` implicitly "
#~ "executes via the *isolation_level* parameter"
#~ " to the :func:`connect` call, or via"
#~ " the :attr:`isolation_level` property of "
#~ "connections. If you specify no "
#~ "*isolation_level*, a plain ``BEGIN`` is "
#~ "used, which is equivalent to specifying"
#~ " ``DEFERRED``.  Other possible values are"
#~ " ``IMMEDIATE`` and ``EXCLUSIVE``."
#~ msgstr ""
#~ ":func:`connect` 호출의 *isolation_level* 매개 변수를"
#~ " 통해, 또는 연결의 :attr:`isolation_level` 프로퍼티를"
#~ " 통해, :mod:`sqlite3`\\가 묵시적으로 실행하는 ``BEGIN``"
#~ " 문의 종류를 제어할 수 있습니다. "
#~ "*isolation_level*\\을 지정하지 않으면, 단순한 "
#~ "``BEGIN``\\이 사용되며, 이는 ``DEFERRED``\\를 지정하는 "
#~ "것과 같습니다. 가능한 다른 값은 ``IMMEDIATE`` 와"
#~ " ``EXCLUSIVE``\\입니다."

#~ msgid ""
#~ "You can disable the :mod:`sqlite3` "
#~ "module's implicit transaction management by"
#~ " setting :attr:`isolation_level` to ``None``."
#~ "  This will leave the underlying "
#~ "``sqlite3`` library operating in "
#~ "``autocommit`` mode.  You can then "
#~ "completely control the transaction state "
#~ "by explicitly issuing ``BEGIN``, ``ROLLBACK``,"
#~ " ``SAVEPOINT``, and ``RELEASE`` statements "
#~ "in your code."
#~ msgstr ""
#~ ":attr:`isolation_level`\\를 ``None``\\로 설정하여 "
#~ ":mod:`sqlite3` 모듈의 묵시적 트랜잭션 관리를 비활성화할"
#~ " 수 있습니다. 그러면 하부 ``sqlite3`` 라이브러리가"
#~ " ``autocommit`` 모드로 작동합니다. 그런 다음 코드에서"
#~ " ``BEGIN``, ``ROLLBACK``, ``SAVEPOINT`` 및 "
#~ "``RELEASE`` 문을 명시적으로 실행하여 트랜잭션 상태를 "
#~ "완전히 제어할 수 있습니다."

#~ msgid "Using :mod:`sqlite3` efficiently"
#~ msgstr "효율적으로 :mod:`sqlite3` 사용하기"

#~ msgid "Accessing columns by name instead of by index"
#~ msgstr "인덱스 대신 이름으로 열 액세스하기"

#~ msgid ""
#~ "One useful feature of the :mod:`sqlite3`"
#~ " module is the built-in "
#~ ":class:`sqlite3.Row` class designed to be "
#~ "used as a row factory."
#~ msgstr ""
#~ ":mod:`sqlite3` 모듈의 유용한 기능 중 하나는 행"
#~ " 팩토리로 사용하도록 설계된 내장 :class:`sqlite3.Row` "
#~ "클래스입니다."

#~ msgid ""
#~ "Rows wrapped with this class can "
#~ "be accessed both by index (like "
#~ "tuples) and case-insensitively by name:"
#~ msgstr "이 클래스로 감싼 행은 인덱스(튜플처럼)와 대소 문자를 구분하지 않는 이름으로 액세스할 수 있습니다:"

#~ msgid ""
#~ "Connection objects can be used as "
#~ "context managers that automatically commit "
#~ "or rollback transactions.  In the event"
#~ " of an exception, the transaction is"
#~ " rolled back; otherwise, the transaction"
#~ " is committed:"
#~ msgstr ""
#~ "연결 객체는 트랜잭션을 자동으로 커밋하거나 롤백하는 컨텍스트"
#~ " 관리자로 사용할 수 있습니다. 예외가 발생하면, "
#~ "트랜잭션이 롤백 됩니다; 그렇지 않으면 트랜잭션이 커밋 "
#~ "됩니다:"

#~ msgid "Footnotes"
#~ msgstr "각주"

