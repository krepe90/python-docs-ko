# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/faulthandler.rst:2
msgid ":mod:`!faulthandler` --- Dump the Python traceback"
msgstr ":mod:`!faulthandler` --- 파이썬 트레이스백 덤프"

#: ../../library/faulthandler.rst:11
msgid ""
"This module contains functions to dump Python tracebacks explicitly, on a"
" fault, after a timeout, or on a user signal. Call "
":func:`faulthandler.enable` to install fault handlers for the "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS`, and "
":const:`~signal.SIGILL` signals. You can also enable them at startup by "
"setting the :envvar:`PYTHONFAULTHANDLER` environment variable or by using"
" the :option:`-X` ``faulthandler`` command line option."
msgstr ""
"이 모듈은 결함(fault) 시, 시간 초과 후 또는 사용자 시그널에 파이썬 트레이스백을 명시적으로 덤프하는 함수를 포함합니다. "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` 및 "
":const:`~signal.SIGILL` 시그널에 대한 결함 처리기를 설치하려면 "
":func:`faulthandler.enable`\\를 호출하십시오. :envvar:`PYTHONFAULTHANDLER` 환경 "
"변수를 설정하거나 :option:`-X` ``faulthandler`` 명령 줄 옵션을 사용하여 시작할 때 활성화할 수도 있습니다."

#: ../../library/faulthandler.rst:19
msgid ""
"The fault handler is compatible with system fault handlers like Apport or"
" the Windows fault handler. The module uses an alternative stack for "
"signal handlers if the :c:func:`!sigaltstack` function is available. This"
" allows it to dump the traceback even on a stack overflow."
msgstr ""
"결함 처리기는 Apport나 윈도우 결함 처리기(Windows fault handler)와 같은 시스템 결함 처리기와 호환됩니다. "
"이 모듈은 :c:func:`!sigaltstack` 함수를 사용할 수 있으면 시그널 처리기에 대체 스택을 사용합니다. 이것은 스택 "
"오버플로에서조차 트레이스백을 덤프할 수 있도록 합니다."

#: ../../library/faulthandler.rst:24
msgid ""
"The fault handler is called on catastrophic cases and therefore can only "
"use signal-safe functions (e.g. it cannot allocate memory on the heap). "
"Because of this limitation traceback dumping is minimal compared to "
"normal Python tracebacks:"
msgstr ""
"결함 처리기는 치명적일 때 호출되므로 시그널 안전한 함수만 사용할 수 있습니다 (예를 들어, 힙에 메모리를 할당할 수 없습니다). "
"이 제한 때문에 일반적인 파이썬 트레이스백에 비해 트레이스백 덤프는 최소화됩니다:"

#: ../../library/faulthandler.rst:29
msgid ""
"Only ASCII is supported. The ``backslashreplace`` error handler is used "
"on encoding."
msgstr "ASCII만 지원됩니다. 인코딩 시 ``backslashreplace`` 에러 처리기가 사용됩니다."

#: ../../library/faulthandler.rst:31
msgid "Each string is limited to 500 characters."
msgstr "각 문자열은 500자로 제한됩니다."

#: ../../library/faulthandler.rst:32
msgid ""
"Only the filename, the function name and the line number are displayed. "
"(no source code)"
msgstr "파일명, 함수 이름 및 줄 번호만 표시됩니다. (소스 코드 없음)"

#: ../../library/faulthandler.rst:34
msgid "It is limited to 100 frames and 100 threads."
msgstr "100프레임과 100스레드로 제한됩니다."

#: ../../library/faulthandler.rst:35
msgid "The order is reversed: the most recent call is shown first."
msgstr "순서가 뒤집힙니다: 가장 최근의 호출이 먼저 표시됩니다."

#: ../../library/faulthandler.rst:37
msgid ""
"By default, the Python traceback is written to :data:`sys.stderr`. To see"
" tracebacks, applications must be run in the terminal. A log file can "
"alternatively be passed to :func:`faulthandler.enable`."
msgstr ""
"기본적으로, 파이썬 트레이스백은 :data:`sys.stderr`\\에 기록됩니다. 트레이스백을 보려면, 응용 프로그램이 터미널에서"
" 실행되어야 합니다. 로그 파일을 :func:`faulthandler.enable`\\로 전달할 수도 있습니다."

#: ../../library/faulthandler.rst:41
msgid ""
"The module is implemented in C, so tracebacks can be dumped on a crash or"
" when Python is deadlocked."
msgstr "모듈은 C로 구현되어 있으므로, 충돌 시나 파이썬이 교착 상태에 빠질 때 트레이스백을 덤프할 수 있습니다."

#: ../../library/faulthandler.rst:44
msgid ""
"The :ref:`Python Development Mode <devmode>` calls "
":func:`faulthandler.enable` at Python startup."
msgstr ""
":ref:`파이썬 개발 모드 <devmode>`\\는 파이썬 시작 시 :func:`faulthandler.enable`\\을 "
"호출합니다."

#: ../../library/faulthandler.rst:49
msgid "Module :mod:`pdb`"
msgstr ""

#: ../../library/faulthandler.rst:50
msgid "Interactive source code debugger for Python programs."
msgstr ""

#: ../../library/faulthandler.rst:52
msgid "Module :mod:`traceback`"
msgstr ""

#: ../../library/faulthandler.rst:53
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""

#: ../../library/faulthandler.rst:56
msgid "Dumping the traceback"
msgstr "트레이스백 덤프하기"

#: ../../library/faulthandler.rst:60
msgid ""
"Dump the tracebacks of all threads into *file*. If *all_threads* is "
"``False``, dump only the current thread."
msgstr ""
"모든 스레드의 트레이스백을 *file*\\로 덤프합니다. *all_threads*\\가 ``False``\\면, 현재 스레드만 "
"덤프합니다."

#: ../../library/faulthandler.rst:63
msgid ":func:`traceback.print_tb`, which can be used to print a traceback object."
msgstr ""

#: ../../library/faulthandler.rst:65 ../../library/faulthandler.rst:84
#: ../../library/faulthandler.rst:123 ../../library/faulthandler.rst:148
msgid "Added support for passing file descriptor to this function."
msgstr "이 함수에 파일 기술자를 전달하는 지원이 추가되었습니다."

#: ../../library/faulthandler.rst:70
msgid "Fault handler state"
msgstr "결함 처리기 상태"

#: ../../library/faulthandler.rst:74
msgid ""
"Enable the fault handler: install handlers for the "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` and "
":const:`~signal.SIGILL` signals to dump the Python traceback. If "
"*all_threads* is ``True``, produce tracebacks for every running thread. "
"Otherwise, dump only the current thread."
msgstr ""
"결함 처리기를 활성화합니다: :const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` 및 "
":const:`~signal.SIGILL` 시그널에 대한 처리기를 설치하여 파이썬 트레이스백을 덤프합니다. "
"*all_threads*\\가 ``True``\\면 실행 중인 모든 스레드에 대한 트레이스백을 생성합니다. 그렇지 않으면, 현재 "
"스레드만 덤프합니다."

#: ../../library/faulthandler.rst:81
msgid ""
"The *file* must be kept open until the fault handler is disabled: see "
":ref:`issue with file descriptors <faulthandler-fd>`."
msgstr ""
"*file*\\은 결함 처리기가 비활성화될 때까지 열려 있어야 합니다: :ref:`파일 기술자 관련 문제 <faulthandler-"
"fd>`\\를 참조하십시오."

#: ../../library/faulthandler.rst:87
msgid "On Windows, a handler for Windows exception is also installed."
msgstr "윈도우에서는, 윈도우 예외(Windows exception) 처리기도 설치됩니다."

#: ../../library/faulthandler.rst:90
msgid ""
"The dump now mentions if a garbage collector collection is running if "
"*all_threads* is true."
msgstr ""

#: ../../library/faulthandler.rst:96
msgid ""
"Disable the fault handler: uninstall the signal handlers installed by "
":func:`enable`."
msgstr "결함 처리기를 비활성화합니다: :func:`enable`\\로 설치된 시그널 처리기를 제거합니다."

#: ../../library/faulthandler.rst:101
msgid "Check if the fault handler is enabled."
msgstr "결함 처리기가 활성화되었는지 검사합니다."

#: ../../library/faulthandler.rst:105
msgid "Dumping the tracebacks after a timeout"
msgstr "시간 초과 후에 트레이스백 덤프하기"

#: ../../library/faulthandler.rst:109
msgid ""
"Dump the tracebacks of all threads, after a timeout of *timeout* seconds,"
" or every *timeout* seconds if *repeat* is ``True``.  If *exit* is "
"``True``, call :c:func:`!_exit` with status=1 after dumping the "
"tracebacks.  (Note :c:func:`!_exit` exits the process immediately, which "
"means it doesn't do any cleanup like flushing file buffers.) If the "
"function is called twice, the new call replaces previous parameters and "
"resets the timeout. The timer has a sub-second resolution."
msgstr ""
"*timeout* 초의 시간제한 후, 또는 *repeat*\\가 ``True``\\면 매 *timeout* 초마다, 모든 스레드의 "
"트레이스백을 덤프합니다. *exit*\\가 ``True``\\면, 트레이스백을 덤프한 후 status=1 로 "
":c:func:`!_exit`\\를 호출합니다. (:c:func:`!_exit`\\가 프로세스를 즉시 종료함에 유의하십시오. 파일 "
"버퍼를 플러시 하는 것과 같은 정리 작업을 수행하지 않습니다.) 함수가 두 번 호출되면, 새 호출은 이전 매개 변수를 대체하고 "
"시간제한을 다시 설정합니다. 타이머는 1초 미만의 해상도를 갖습니다."

#: ../../library/faulthandler.rst:117
msgid ""
"The *file* must be kept open until the traceback is dumped or "
":func:`cancel_dump_traceback_later` is called: see :ref:`issue with file "
"descriptors <faulthandler-fd>`."
msgstr ""
"*file*\\은 트레이스백이 덤프 되거나 :func:`cancel_dump_traceback_later`\\가 호출될 때까지 열려"
" 있어야 합니다: :ref:`파일 기술자 관련 문제 <faulthandler-fd>`\\를 참조하십시오."

#: ../../library/faulthandler.rst:121
msgid "This function is implemented using a watchdog thread."
msgstr "이 함수는 워치독(watchdog) 스레드를 사용하여 구현됩니다."

#: ../../library/faulthandler.rst:126
msgid "This function is now always available."
msgstr "이 함수는 이제 항상 사용할 수 있습니다."

#: ../../library/faulthandler.rst:131
msgid "Cancel the last call to :func:`dump_traceback_later`."
msgstr "마지막 :func:`dump_traceback_later` 호출을 취소합니다."

#: ../../library/faulthandler.rst:135
msgid "Dumping the traceback on a user signal"
msgstr "사용자 시그널에 트레이스백 덤프하기"

#: ../../library/faulthandler.rst:139
msgid ""
"Register a user signal: install a handler for the *signum* signal to dump"
" the traceback of all threads, or of the current thread if *all_threads* "
"is ``False``, into *file*. Call the previous handler if chain is "
"``True``."
msgstr ""
"사용자 시그널을 등록합니다: *signum* 시그널에 대한 처리기를 설치해서, 모든 스레드, 또는 *all_threads*\\가 "
"``False``\\면 현재 스레드의, 트레이스백을 *file*\\로 덤프합니다. chain이 ``True``\\면 이전 처리기를 "
"호출합니다."

#: ../../library/faulthandler.rst:143
msgid ""
"The *file* must be kept open until the signal is unregistered by "
":func:`unregister`: see :ref:`issue with file descriptors <faulthandler-"
"fd>`."
msgstr ""
"*file*\\은 시그널이 :func:`unregister`\\로 등록 해지 될 때까지 열려 있어야 합니다: :ref:`파일 기술자"
" 관련 문제 <faulthandler-fd>`\\를 참조하십시오."

#: ../../library/faulthandler.rst:146 ../../library/faulthandler.rst:157
msgid "Not available on Windows."
msgstr "윈도우에서는 사용할 수 없습니다."

#: ../../library/faulthandler.rst:153
msgid ""
"Unregister a user signal: uninstall the handler of the *signum* signal "
"installed by :func:`register`. Return ``True`` if the signal was "
"registered, ``False`` otherwise."
msgstr ""
"사용자 시그널을 등록 해지합니다: :func:`register`\\로 설치된 *signum* 시그널 처리기를 제거합니다. 시그널이 "
"등록되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/faulthandler.rst:163
msgid "Issue with file descriptors"
msgstr "파일 기술자 관련 문제"

#: ../../library/faulthandler.rst:165
msgid ""
":func:`enable`, :func:`dump_traceback_later` and :func:`register` keep "
"the file descriptor of their *file* argument. If the file is closed and "
"its file descriptor is reused by a new file, or if :func:`os.dup2` is "
"used to replace the file descriptor, the traceback will be written into a"
" different file. Call these functions again each time that the file is "
"replaced."
msgstr ""
":func:`enable`, :func:`dump_traceback_later` 및 :func:`register`\\는 *file*"
" 인자의 파일 기술자를 유지합니다. 파일이 닫히고 파일 기술자가 새 파일에 의해 다시 사용되거나, :func:`os.dup2`\\가"
" 파일 기술자를 바꾸는 데 사용되면, 트레이스백이 다른 파일에 기록됩니다. 파일을 바꿀 때마다 이 함수들을 다시 호출하십시오."

#: ../../library/faulthandler.rst:173
msgid "Example"
msgstr "예제"

#: ../../library/faulthandler.rst:175
msgid ""
"Example of a segmentation fault on Linux with and without enabling the "
"fault handler:"
msgstr "리눅스에서 결함 처리기를 활성화하거나 그렇지 않았을 때의 세그멘테이션 결함 예제:"

#: ../../library/faulthandler.rst:178
msgid ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/home/python/cpython/Lib/ctypes/__init__.py\", line 486 in "
"string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"Segmentation fault"
msgstr ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/home/python/cpython/Lib/ctypes/__init__.py\", line 486 in "
"string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"Segmentation fault"

