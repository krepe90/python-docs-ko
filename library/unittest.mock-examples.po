# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/unittest.mock-examples.rst:2
#, fuzzy
msgid ":mod:`!unittest.mock` --- getting started"
msgstr ":mod:`unittest.mock` --- 시작하기"

#: ../../library/unittest.mock-examples.rst:27
msgid "Using Mock"
msgstr "모의 객체 사용하기"

#: ../../library/unittest.mock-examples.rst:30
msgid "Mock Patching Methods"
msgstr "메서드를 패치하는 모의 객체"

#: ../../library/unittest.mock-examples.rst:32
msgid "Common uses for :class:`Mock` objects include:"
msgstr ":class:`Mock` 객체의 일반적인 용도는 다음과 같습니다:"

#: ../../library/unittest.mock-examples.rst:34
msgid "Patching methods"
msgstr "메서드 패치하기"

#: ../../library/unittest.mock-examples.rst:35
msgid "Recording method calls on objects"
msgstr "객체에 대한 메서드 호출 기록하기"

#: ../../library/unittest.mock-examples.rst:37
msgid ""
"You might want to replace a method on an object to check that it is "
"called with the correct arguments by another part of the system:"
msgstr "객체의 메서드를 대체하여 시스템의 다른 부분에서 올바른 인자로 호출되었는지 확인할 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:45
msgid ""
"Once our mock has been used (``real.method`` in this example) it has "
"methods and attributes that allow you to make assertions about how it has"
" been used."
msgstr ""
"일단 모의 객체가 사용되면 (이 예제에서는 ``real.method``) 사용 방법에 대한 어서션을 만들 수 있도록 하는 메서드와 "
"어트리뷰트를 제공합니다."

#: ../../library/unittest.mock-examples.rst:50
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` "
"classes are interchangeable. As the ``MagicMock`` is the more capable "
"class it makes a sensible one to use by default."
msgstr ""
"이 예의 대부분에서 :class:`Mock`\\과 :class:`MagicMock` 클래스는 교환할 수 있습니다. "
"``MagicMock``\\이 더 유능한 클래스이기 때문에 기본 사용하기에 적합합니다."

#: ../../library/unittest.mock-examples.rst:54
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set "
"to ``True``. More importantly we can use the "
":meth:`~Mock.assert_called_with` or :meth:`~Mock.assert_called_once_with`"
" method to check that it was called with the correct arguments."
msgstr ""
"일단 모의 객체가 호출되면 그것의 :attr:`~Mock.called` 어트리뷰트가 ``True``\\로 설정됩니다. 더 중요하게 "
":meth:`~Mock.assert_called_with`\\나 :meth:`~Mock.assert_called_once_with`"
" 메서드를 사용하여 올바른 인자로 호출되었는지 확인할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:59
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a"
" call to the ``something`` method:"
msgstr ""
"이 예제는 ``ProductionClass().method``\\를 호출하면 ``something`` 메서드가 호출되는지 "
"테스트합니다:"

#: ../../library/unittest.mock-examples.rst:76
msgid "Mock for Method Calls on an Object"
msgstr "객체의 메서드 호출을 위한 모의 객체"

#: ../../library/unittest.mock-examples.rst:78
msgid ""
"In the last example we patched a method directly on an object to check "
"that it was called correctly. Another common use case is to pass an "
"object into a method (or some part of the system under test) and then "
"check that it is used in the correct way."
msgstr ""
"마지막 예제에서 우리는 객체에 메서드를 직접 패치하여 올바르게 호출되었는지 확인했습니다. 또 다른 일반적인 사용 사례는 객체를 "
"메서드(또는 테스트 중인 시스템의 일부)에 전달한 다음 올바른 방식으로 사용되는지 확인하는 것입니다."

#: ../../library/unittest.mock-examples.rst:83
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"아래의 간단한 ``ProductionClass``\\에는 ``closer`` 메서드가 있습니다. 객체로 호출되면 그것의 "
"``close``\\를 호출합니다."

#: ../../library/unittest.mock-examples.rst:91
msgid ""
"So to test it we need to pass in an object with a ``close`` method and "
"check that it was called correctly."
msgstr "따라서 테스트하려면 ``close`` 메서드를 가진 객체를 전달하고 올바르게 호출되었는지 확인해야 합니다."

#: ../../library/unittest.mock-examples.rst:99
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called "
"then accessing it in the test will create it, but "
":meth:`~Mock.assert_called_with` will raise a failure exception."
msgstr ""
"모의 객체에 'close' 메서드를 제공하기 위해 어떤 작업도 수행할 필요가 없습니다. close에 액세스하면 만들어집니다. "
"따라서, 'close'가 아직 호출되지 않았다면 테스트에서 액세스할 때 만들어지지만, "
":meth:`~Mock.assert_called_with`\\는 실패 예외를 발생시킵니다."

#: ../../library/unittest.mock-examples.rst:106
msgid "Mocking Classes"
msgstr "클래스 모킹하기"

#: ../../library/unittest.mock-examples.rst:108
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"일반적인 사용 사례는 테스트 중인 코드가 인스턴스 화하는 클래스를 모킹하는 것입니다. 클래스를 패치하면, 해당 클래스가 모의 객체로"
" 바뀝니다. 인스턴스는 *클래스를 호출해서* 만들어집니다. 이는 모킹된 클래스의 반환 값을 확인하여 \"모의 인스턴스\"에 "
"액세스한다는 것을 뜻합니다."

#: ../../library/unittest.mock-examples.rst:113
msgid ""
"In the example below we have a function ``some_function`` that "
"instantiates ``Foo`` and calls a method on it. The call to :func:`patch` "
"replaces the class ``Foo`` with a mock. The ``Foo`` instance is the "
"result of calling the mock, so it is configured by modifying the mock "
":attr:`~Mock.return_value`. ::"
msgstr ""
"아래 예제에는 ``Foo``\\를 인스턴스 화하고 그것의 메서드를 호출하는 ``some_function`` 함수가 있습니다. "
":func:`patch`\\에 대한 호출은 클래스 ``Foo``\\를 모의 객체로 대체합니다. ``Foo`` 인스턴스는 모의 객체를"
" 호출한 결과라서, 모의 객체 :attr:`~Mock.return_value`\\를 수정하여 구성됩니다. ::"

#: ../../library/unittest.mock-examples.rst:118
msgid ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"
msgstr ""

#: ../../library/unittest.mock-examples.rst:130
msgid "Naming your mocks"
msgstr "모의 객체 이름 붙이기"

#: ../../library/unittest.mock-examples.rst:132
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr"
" of the mock and can be helpful when the mock appears in test failure "
"messages. The name is also propagated to attributes or methods of the "
"mock:"
msgstr ""
"모의 객체에 이름을 지정하는 것이 유용할 수 있습니다. 이름은 모의 객체의 repr에 표시되며 모의 객체가 테스트 실패 메시지에 "
"나타날 때 유용할 수 있습니다. 이 이름은 모의 객체의 어트리뷰트나 메서드에도 전파됩니다:"

#: ../../library/unittest.mock-examples.rst:144
msgid "Tracking all Calls"
msgstr "모든 호출 추적하기"

#: ../../library/unittest.mock-examples.rst:146
msgid ""
"Often you want to track more than a single call to a method. The "
":attr:`~Mock.mock_calls` attribute records all calls to child attributes "
"of the mock - and also to their children."
msgstr ""
"메서드에 대한 단일 호출 이상을 추적하려는 경우가 종종 있습니다. :attr:`~Mock.mock_calls` 어트리뷰트는 모의 "
"객체의 자식 어트리뷰트에 대한 모든 호출을 기록합니다 - 그리고 그들의 자식에 대해서도 마찬가지입니다."

#: ../../library/unittest.mock-examples.rst:158
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as"
" well as asserting that the calls you expected have been made, you are "
"also checking that they were made in the right order and with no "
"additional calls:"
msgstr ""
"``mock_calls``\\에 대한 어서션을 만들고 예기치 않은 메서드가 호출되면, 어서션이 실패합니다. 이 기능은 예상한 호출이"
" 이루어졌음을 어서트 할 뿐만 아니라, 추가 호출 없이 올바른 순서로 호출되었는지 확인하기 때문에 유용합니다:"

#: ../../library/unittest.mock-examples.rst:163
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ":data:`call` 객체를 사용하여 ``mock_calls``\\와 비교할 리스트를 구성합니다:"

#: ../../library/unittest.mock-examples.rst:170
msgid ""
"However, parameters to calls that return mocks are not recorded, which "
"means it is not possible to track nested calls where the parameters used "
"to create ancestors are important:"
msgstr ""
"그러나, 모의 객체를 반환하는 호출에 대한 매개 변수는 기록되지 않아서, 조상을 만드는 데 사용되는 매개 변수가 중요한 중첩된 "
"호출을 추적할 수 없습니다:"

#: ../../library/unittest.mock-examples.rst:181
msgid "Setting Return Values and Attributes"
msgstr "반환 값과 어트리뷰트 설정하기"

#: ../../library/unittest.mock-examples.rst:183
msgid "Setting the return values on a mock object is trivially easy:"
msgstr "모의 객체에서 반환 값을 설정하는 것은 아주 간단합니다:"

#: ../../library/unittest.mock-examples.rst:190
msgid "Of course you can do the same for methods on the mock:"
msgstr "물론 모의 객체의 메서드에 대해서도 마찬가지입니다:"

#: ../../library/unittest.mock-examples.rst:197
msgid "The return value can also be set in the constructor:"
msgstr "생성자에서 반환 값을 설정할 수도 있습니다:"

#: ../../library/unittest.mock-examples.rst:203
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "모의 객체에 어트리뷰트 설정이 필요하면, 그냥 하면 됩니다:"

#: ../../library/unittest.mock-examples.rst:210
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this "
"call to return a list, then we have to configure the result of the nested"
" call."
msgstr ""
"때로는 예를 들어 ``mock.connection.cursor().execute(\"SELECT 1\")``\\와 같은 더 복잡한 "
"상황을 모킹하고 싶을 수도 있습니다. 이 호출이 리스트를 반환하도록 하려면, 중첩 호출의 결과를 구성해야 합니다."

#: ../../library/unittest.mock-examples.rst:214
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained "
"call\" like this for easy assertion afterwards:"
msgstr ""
":data:`call`\\을 사용하여 다음과 같이 \"연쇄 호출(chained call)\"로 일련의 호출 집합을 구성할 수 "
"있습니다:"

#: ../../library/unittest.mock-examples.rst:228
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list"
" of calls representing the chained calls."
msgstr "``.call_list()`` 호출이 호출 객체를 연쇄 호출을 나타내는 호출 리스트로 변환합니다."

#: ../../library/unittest.mock-examples.rst:233
msgid "Raising exceptions with mocks"
msgstr "모의 객체로 예외 발생시키기"

#: ../../library/unittest.mock-examples.rst:235
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the "
"mock is called."
msgstr ""
"유용한 어트리뷰트는 :attr:`~Mock.side_effect`\\입니다. 이것을 예외 클래스나 인스턴스로 설정하면 모의 객체가 "
"호출될 때 예외가 발생합니다."

#: ../../library/unittest.mock-examples.rst:247
msgid "Side effect functions and iterables"
msgstr "부작용 함수와 이터러블"

#: ../../library/unittest.mock-examples.rst:249
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use "
"case for ``side_effect`` as an iterable is where your mock is going to be"
" called several times, and you want each call to return a different "
"value. When you set ``side_effect`` to an iterable every call to the mock"
" returns the next value from the iterable:"
msgstr ""
"``side_effect``\\는 함수나 이터러블로 설정할 수도 있습니다. ``side_effect``\\의 이터러블로서의 사용 "
"사례는 모의 객체가 여러 번 호출되고, 각 호출이 다른 값을 반환하기를 원하는 곳입니다. ``side_effect``\\를 "
"이터러블로 설정하면 모의 객체에 대한 모든 호출은 이터러블에서 다음 값을 반환합니다:"

#: ../../library/unittest.mock-examples.rst:264
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the "
"mock. Whatever the function returns is what the call returns:"
msgstr ""
"모의 객체 호출에 전달되는 것에 따라 반환 값을 동적으로 변경하는 것과 같은 고급 사용 사례의 경우, "
"``side_effect``\\는 함수가 될 수 있습니다. 함수는 모의 객 체와 같은 인자로 호출됩니다. 함수가 반환하는 것을 "
"호출이 반환합니다:"

#: ../../library/unittest.mock-examples.rst:281
msgid "Mocking asynchronous iterators"
msgstr "비동기 이터레이터 모킹하기"

#: ../../library/unittest.mock-examples.rst:283
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock "
":ref:`async-iterators` through ``__aiter__``. The "
":attr:`~Mock.return_value` attribute of ``__aiter__`` can be used to set "
"the return values to be used for iteration."
msgstr ""
"파이썬 3.8부터, ``AsyncMock``\\과 ``MagicMock``\\은 ``__aiter__``\\를 통해 :ref"
":`async-iterators`\\를 모킹하는 것을 지원합니다. ``__aiter__``\\의 "
":attr:`~Mock.return_value` 어트리뷰트를 사용하여 이터레이션에 사용될 반환 값을 설정할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:298
msgid "Mocking asynchronous context manager"
msgstr "비동기 컨텍스트 관리자 모킹하기"

#: ../../library/unittest.mock-examples.rst:300
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock "
":ref:`async-context-managers` through ``__aenter__`` and ``__aexit__``. "
"By default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances "
"that return an async function."
msgstr ""
"파이썬 3.8부터, ``AsyncMock``\\과 ``MagicMock``\\은 ``__aenter__``\\와 "
"``__aexit__``\\를 통해 :ref:`async-context-managers`\\를 모킹하는 것을 지원합니다. "
"기본적으로, ``__aenter__``\\와 ``__aexit__``\\는 비동기 함수를 반환하는 ``AsyncMock`` "
"인스턴스입니다."

#: ../../library/unittest.mock-examples.rst:322
msgid "Creating a Mock from an Existing Object"
msgstr "기존 객체에서 모의 객체 만들기"

#: ../../library/unittest.mock-examples.rst:324
msgid ""
"One problem with over use of mocking is that it couples your tests to the"
" implementation of your mocks rather than your real code. Suppose you "
"have a class that implements ``some_method``. In a test for another "
"class, you provide a mock of this object that *also* provides "
"``some_method``. If later you refactor the first class, so that it no "
"longer has ``some_method`` - then your tests will continue to pass even "
"though your code is now broken!"
msgstr ""
"모킹을 과도하게 사용하는 한 가지 문제는 테스트를 실제 코드가 아닌 모킹의 구현에 연결한다는 것입니다. "
"``some_method``\\를 구현하는 클래스가 있다고 가정해봅시다. 다른 클래스에 대한 테스트에서, "
"``some_method``\\*도* 제공하는 이 객체의 모의 객체를 제공합니다. 나중에 첫 번째 클래스를 리팩토링하여, 더는 "
"``some_method``\\를 갖지 않습니다 - 그러면 이제 코드가 망가졌음에도 테스트는 계속 통과합니다!"

#: ../../library/unittest.mock-examples.rst:331
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes "
"on the mock that don't exist on your specification object will "
"immediately raise an attribute error. If you change the implementation of"
" your specification, then tests that use that class will start failing "
"immediately without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock`\\은 *spec* 키워드 인자를 사용하여, 모의 객체를 위한 사양으로 객체를 제공할 수 있도록 합니다. "
"사양 객체에 존재하지 않는 모의 객체의 메서드/어트리뷰트에 액세스하면 어트리뷰트 에러가 즉시 발생합니다. 사양의 구현을 변경하면, "
"해당 클래스를 사용하는 테스트는 해당 테스트에서 클래스를 인스턴스 화하지 않고도 즉시 실패하기 시작합니다."

#: ../../library/unittest.mock-examples.rst:344
msgid ""
"Using a specification also enables a smarter matching of calls made to "
"the mock, regardless of whether some parameters were passed as positional"
" or named arguments::"
msgstr ""
"또한 사양을 사용하면 일부 매개 변수가 위치 인자나 이름 붙인 인자 중 어느 것으로 전달되는지와 관계없이 모의 객체에 대한 호출을 "
"더 스마트하게 일치시킬 수 있도록 합니다:"

#: ../../library/unittest.mock-examples.rst:348
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""

#: ../../library/unittest.mock-examples.rst:355
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"이 더 스마트한 인치가 모의 객체에 대한 메서드 호출에서도 작동하게 하려면, :ref:`자동 사양 <auto-"
"speccing>`\\을 사용할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:358
msgid ""
"If you want a stronger form of specification that prevents the setting of"
" arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"임의의 어트리뷰트를 읽는 것뿐만 아니라 설정하지 못하게 하는 더 강력한 사양 형식을 원하면 *spec* 대신 "
"*spec_set*\\을 사용할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:364
msgid "Using side_effect to return per file content"
msgstr ""

#: ../../library/unittest.mock-examples.rst:366
msgid ""
":func:`mock_open` is used to patch :func:`open` method. "
":attr:`~Mock.side_effect` can be used to return a new Mock object per "
"call. This can be used to return different contents per file stored in a "
"dictionary::"
msgstr ""

#: ../../library/unittest.mock-examples.rst:370
#, python-brace-format
msgid ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""
msgstr ""

#: ../../library/unittest.mock-examples.rst:389
msgid "Patch Decorators"
msgstr "패치 데코레이터"

#: ../../library/unittest.mock-examples.rst:393
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace "
"where they are looked up. This is normally straightforward, but for a "
"quick guide read :ref:`where to patch <where-to-patch>`."
msgstr ""
":func:`patch`\\를 사용할 때는 그것이 조회되는 이름 공간에서 객체를 패치하는 것이 중요합니다. 이것은 일반적으로 "
"간단하지만, 빠른 안내를 위해 :ref:`패치할 곳 <where-to-patch>`\\을 읽으십시오."

#: ../../library/unittest.mock-examples.rst:398
msgid ""
"A common need in tests is to patch a class attribute or a module "
"attribute, for example patching a builtin or patching a class in a module"
" to test that it is instantiated. Modules and classes are effectively "
"global, so patching on them has to be undone after the test or the patch "
"will persist into other tests and cause hard to diagnose problems."
msgstr ""
"테스트에서 흔히 필요한 것은 클래스 어트리뷰트나 모듈 어트리뷰트를 패치하는 것입니다, 예를 들어 내장(builtin)을 패치하거나 "
"모듈에 있는 인스턴스 화 되는 클래스를 패치하는 것. 모듈과 클래스는 사실상 전역이라서, 테스트 후에 패치를 실행 취소해야 합니다,"
" 그렇지 않으면 패치가 다른 테스트로 지속하여, 진단하기 어려운 문제를 일으킵니다."

#: ../../library/unittest.mock-examples.rst:404
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, "
":func:`patch.object` and :func:`patch.dict`. ``patch`` takes a single "
"string, of the form ``package.module.Class.attribute`` to specify the "
"attribute you are patching. It also optionally takes a value that you "
"want the attribute (or class or whatever) to be replaced with. "
"'patch.object' takes an object and the name of the attribute you would "
"like patched, plus optionally the value to patch it with."
msgstr ""
"mock은 세 가지 편리한 데코레이터를 제공합니다: :func:`patch`, :func:`patch.object` 및 "
":func:`patch.dict`. ``patch``\\는 패치 할 어트리뷰트를 지정하기 위해 "
"``package.module.Class.attribute`` 형식의 단일 문자열을 취합니다. 또한 선택적으로 어트리뷰트(또는 "
"클래스나 무엇이건)를 바꾸려는 값을 취합니다. 'patch.object'는 객체와 패치하려는 어트리뷰트의 이름 및 선택적으로 패치 "
"할 값을 취합니다."

#: ../../library/unittest.mock-examples.rst:412
msgid "``patch.object``::"
msgstr "``patch.object``::"

#: ../../library/unittest.mock-examples.rst:414
msgid ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:429
msgid ""
"If you are patching a module (including :mod:`builtins`) then use "
":func:`patch` instead of :func:`patch.object`:"
msgstr ""
"모듈(:mod:`builtins`\\를 포함하는)을 패치하려면 :func:`patch.object` 대신 "
":func:`patch`\\를 사용하십시오:"

#: ../../library/unittest.mock-examples.rst:439
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if "
"needed::"
msgstr "필요하면 ``package.module`` 형식으로 모듈 이름을 '점으로 표시'할 수 있습니다::"

#: ../../library/unittest.mock-examples.rst:441
msgid ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:448
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "좋은 패턴은 실제로 테스트 메서드 자체를 데코레이트 하는 것입니다:"

#: ../../library/unittest.mock-examples.rst:459
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one"
" argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Mock으로 패치하려면, 하나의 인자만으로 :func:`patch`\\를 사용할 수 있습니다 (또는 두 개의 인자로 "
":func:`patch.object`). 모의 객체가 여러분을 위해 만들어지고 테스트 함수 / 메서드로 전달됩니다:"

#: ../../library/unittest.mock-examples.rst:471
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr "이 패턴을 사용하여 여러 패치 데코레이터를 쌓을 수 있습니다::"

#: ../../library/unittest.mock-examples.rst:473
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:482
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example"
" above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"패치 데코레이터를 중첩할 때 모의 객체는 적용한 순서와 같은 순서(데코레이터가 적용되는 일반적인 *파이썬* 순서)로 데코레이트 된 "
"함수로 전달됩니다. 이것은 밑에서 위로 올라가는 순서를 뜻해서, 위의 예에서 ``test_module.ClassName2``\\의 "
"모의 객체가 먼저 전달됩니다."

#: ../../library/unittest.mock-examples.rst:487
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when "
"the test ends:"
msgstr ""
"스코프 도중 딕셔너리에 값을 설정하고 테스트가 끝날 때 딕셔너리를 원래 상태로 복원하기 위한 :func:`patch.dict`\\도"
" 있습니다:"

#: ../../library/unittest.mock-examples.rst:498
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context"
" managers."
msgstr "``patch``, ``patch.object`` 및 ``patch.dict``\\는 모두 컨텍스트 관리자로 사용할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:500
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
":func:`patch`\\를 사용하여 모의 객체를 만드는 곳에서, with 문의 \"as\" 형식을 사용하여 모의 객체에 대한 "
"참조를 얻을 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:515
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be "
"used as class decorators. When used in this way it is the same as "
"applying the decorator individually to every method whose name starts "
"with \"test\"."
msgstr ""
"대안으로 ``patch``, ``patch.object`` 및 ``patch.dict``\\는 클래스 데코레이터로 사용될 수 "
"있습니다. 이런 식으로 사용될 때 이름이 \"test\"로 시작하는 모든 메서드에 데코레이터를 개별적으로 적용하는 것과 같습니다."

#: ../../library/unittest.mock-examples.rst:523
msgid "Further Examples"
msgstr "추가 예"

#: ../../library/unittest.mock-examples.rst:526
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "다음은 약간 더 고급 시나리오에 대한 몇 가지 예입니다."

#: ../../library/unittest.mock-examples.rst:530
msgid "Mocking chained calls"
msgstr "연쇄 호출 모킹하기"

#: ../../library/unittest.mock-examples.rst:532
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is "
"called for the first time, or you fetch its ``return_value`` before it "
"has been called, a new :class:`Mock` is created."
msgstr ""
"일단 :attr:`~Mock.return_value` 어트리뷰트를 이해하면 연쇄 호출 모킹은 모의 객체를 사용하면 실제로 "
"간단합니다. 모의 객체가 처음 호출되거나 호출되기 전에 ``return_value``\\를 가져오면, 새 "
":class:`Mock`\\이 만들어집니다."

#: ../../library/unittest.mock-examples.rst:537
msgid ""
"This means that you can see how the object returned from a call to a "
"mocked object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"이것은 ``return_value`` 모의 객체를 조사하여 모킹 된 객체에 대한 호출에서 반환된 객체가 어떻게 사용되었는지 확인할 "
"수 있음을 뜻합니다:"

#: ../../library/unittest.mock-examples.rst:545
msgid ""
"From here it is a simple step to configure and then make assertions about"
" chained calls. Of course another alternative is writing your code in a "
"more testable way in the first place..."
msgstr ""
"여기서부터는 구성하고 연쇄 호출에 대한 어서션을 만드는 간단한 단계입니다. 물론 또 다른 대안은 처음부터 더 테스트하기 쉬운 "
"방식으로 코드를 작성하는 것입니다..."

#: ../../library/unittest.mock-examples.rst:549
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "그래서, 다음과 같은 코드가 있다고 가정합시다:"

#: ../../library/unittest.mock-examples.rst:558
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# "
"more code`` uses the response object in the correct way."
msgstr ""
"``BackendProvider`` 가 이미 잘 테스트 되었다고 가정하면, ``method()``\\를 어떻게 테스트해야 할까요? "
"특히, 코드 섹션 ``# more code``\\가 response 객체를 올바른 방식으로 사용하는지 테스트하고 싶습니다."

#: ../../library/unittest.mock-examples.rst:562
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final"
" call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"이 호출의 연쇄는 인스턴스 어트리뷰트에서 이루어지기 때문에 ``Something`` 인스턴스에서 ``backend`` 어트리뷰트를 "
"몽키 패치 할 수 있습니다. 이 특별한 경우에는 ``start_call``\\에 대한 최종 호출의 반환 값에만 관심이 있어서 해야 "
"할 구성이 많지 않습니다. 반환하는 객체가 '파일류(file-like)'라고 가정하고, response 객체가 "
"``spec``\\으로 내장 :func:`open`\\을 사용하도록 할 것입니다."

#: ../../library/unittest.mock-examples.rst:569
msgid ""
"To do this we create a mock instance as our mock backend and create a "
"mock response object for it. To set the response as the return value for "
"that final ``start_call`` we could do this::"
msgstr ""
"이를 위해 모의 백 엔드로 모의 인스턴스를 만들고 모의 response 객체를 만듭니다. 응답을 최종 "
"``start_call``\\의 반환 값으로 설정하기 위해 다음을 수행할 수 있습니다::"

#: ../../library/unittest.mock-examples.rst:573
msgid ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call.return_value"
" = mock_response"
msgstr ""

#: ../../library/unittest.mock-examples.rst:575
msgid ""
"We can do that in a slightly nicer way using the "
":meth:`~Mock.configure_mock` method to directly set the return value for "
"us::"
msgstr ":meth:`~Mock.configure_mock` 메서드를 사용하여 약간 더 좋은 방법으로 반환 값을 직접 설정할 수 있습니다::"

#: ../../library/unittest.mock-examples.rst:578
#, python-brace-format
msgid ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = "
"{'get_endpoint.return_value.create_call.return_value.start_call.return_value':"
" mock_response}\n"
">>> mock_backend.configure_mock(**config)"
msgstr ""

#: ../../library/unittest.mock-examples.rst:584
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the"
" real call::"
msgstr "이것들로 우리는 \"모의 백 엔드\"를 몽키 패치하고 실제 호출을 할 수 있습니다::"

#: ../../library/unittest.mock-examples.rst:587
msgid ""
">>> something.backend = mock_backend\n"
">>> something.method()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:590
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a "
"single assert. A chained call is several calls in one line of code, so "
"there will be several entries in ``mock_calls``. We can use "
":meth:`call.call_list` to create this list of calls for us::"
msgstr ""
":attr:`~Mock.mock_calls`\\를 사용하면 단일 어서션으로 연쇄 호출을 확인할 수 있습니다. 연쇄 호출은 한 줄의 "
"코드에 있는 여러 번의 호출이라서, ``mock_calls``\\에는 여러 항목이 있게 됩니다. "
":meth:`call.call_list`\\를 사용하여 이 호출의 리스트를 만들 수 있습니다::"

#: ../../library/unittest.mock-examples.rst:595
msgid ""
">>> chained = call.get_endpoint('foobar').create_call('spam', "
"'eggs').start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"
msgstr ""

#: ../../library/unittest.mock-examples.rst:601
msgid "Partial mocking"
msgstr "부분 모킹"

#: ../../library/unittest.mock-examples.rst:603
#, fuzzy
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` "
"to return a known date, but I didn't want to prevent the code under test "
"from creating new date objects. Unfortunately :class:`datetime.date` is "
"written in C, and so I couldn't just monkey-patch out the static "
":meth:`datetime.date.today` method."
msgstr ""
"어떤 테스트에서 :meth:`datetime.date.today`\\에 대한 호출이 알려진 날짜를 반환하도록 모킹하려고 했지만, "
"테스트 중인 코드가 새로운 date 객체를 만들지 못하도록 막고 싶지 않았습니다. 불행히도 "
":class:`datetime.date`\\는 C로 작성되었고, 그래서 정적 :meth:`date.today` 메서드를 그저 몽키 "
"패치 할 수 없었습니다."

#: ../../library/unittest.mock-examples.rst:608
msgid ""
"I found a simple way of doing this that involved effectively wrapping the"
" date class with a mock, but passing through calls to the constructor to "
"the real class (and returning real instances)."
msgstr ""
"date 클래스를 모의 객체로 효과적으로 래핑하지만, 생성자 호출은 실제 클래스로 전달하는 (그리고 진짜 인스턴스를 반환하는) "
"간단한 방법을 찾았습니다."

#: ../../library/unittest.mock-examples.rst:612
#, fuzzy
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date``"
" class in the module under test. The :attr:`~Mock.side_effect` attribute "
"on the mock date class is then set to a lambda function that returns a "
"real date. When the mock date class is called a real date will be "
"constructed and returned by ``side_effect``. ::"
msgstr ""
":func:`patch 데코레이터 <patch>`\\는 여기서 테스트 중인 모듈에서 ``date`` 클래스를 모킹하는 데 "
"사용됩니다. 그런 다음 모의 date 클래스의 :attr:`side_effect` 어트리뷰트는 실제 날짜를 반환하는 람다 함수로 "
"설정됩니다. 모의 date 클래스가 호출되면 진짜 date가 생성되어 ``side_effect``\\에 의해 반환됩니다. ::"

#: ../../library/unittest.mock-examples.rst:618
msgid ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"
msgstr ""

#: ../../library/unittest.mock-examples.rst:626
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch "
"``date`` in the module that *uses* it. See :ref:`where to patch <where-"
"to-patch>`."
msgstr ""
":class:`datetime.date`\\를 전역적으로 패치하지 않았음에 유의하십시오. ``date``\\를 *사용하는* 모듈에서"
" 패치했습니다. :ref:`패치할 곳 <where-to-patch>`\\을 참조하십시오."

#: ../../library/unittest.mock-examples.rst:629
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to "
"the ``date(...)`` constructor still return normal dates. Without this you"
" can find yourself having to calculate an expected result using exactly "
"the same algorithm as the code under test, which is a classic testing "
"anti-pattern."
msgstr ""
"``date.today()``\\가 호출되면 알려진 날짜가 반환되지만, ``date(...)`` 생성자에 대한 호출은 여전히 일반 "
"date를 반환합니다. 이렇게 하지 않으면 테스트 중인 코드와 정확히 같은 알고리즘을 사용하여 예상 결과를 계산해야 할 수 "
"있습니다, 이는 고전적인 테스트 안티 패턴입니다."

#: ../../library/unittest.mock-examples.rst:634
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` "
"attributes (``call_count`` and friends) which may also be useful for your"
" tests."
msgstr ""
"date 생성자에 대한 호출은 ``mock_date`` 어트리뷰트(``call_count``\\와 그 친구들)에 기록되며 테스트에 "
"유용할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:637
msgid ""
"An alternative way of dealing with mocking dates, or other builtin "
"classes, is discussed in `this blog entry "
"<https://williambert.online/2011/07/how-to-unit-testing-in-django-with-"
"mocking-and-patching/>`_."
msgstr ""
"date나 기타 내장 클래스 모킹을 처리하는 다른 방법은 `이 블로그 페이지 "
"<https://williambert.online/2011/07/how-to-unit-testing-in-django-with-"
"mocking-and-patching/>`_\\에서 다루고 있습니다."

#: ../../library/unittest.mock-examples.rst:643
msgid "Mocking a Generator Method"
msgstr "제너레이터 메서드 모킹하기"

#: ../../library/unittest.mock-examples.rst:645
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield`"
" statement to return a series of values when iterated over [#]_."
msgstr "파이썬 제너레이터는 :keyword:`yield` 문을 사용하는 함수나 메서드로, 이터레이트 할 때 일련의 값을 반환합니다 [#]_."

#: ../../library/unittest.mock-examples.rst:648
msgid ""
"A generator method / function is called to return the generator object. "
"It is the generator object that is then iterated over. The protocol "
"method for iteration is :meth:`~container.__iter__`, so we can mock this "
"using a :class:`MagicMock`."
msgstr ""
"제너레이터 메서드 / 함수가 호출되면 제너레이터 객체를 반환합니다. 이터레이트 하는 대상은 제너레이터 객체입니다. 이터레이션을 위한"
" 프로토콜 메서드는 :meth:`~container.__iter__`\\이고, :class:`MagicMock`\\을 사용하여 이를"
" 모킹 할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:653
msgid ""
"Here's an example class with an \"iter\" method implemented as a "
"generator:"
msgstr "다음은 제너레이터로 구현된 \"iter\" 메서드를 갖는 예제 클래스입니다:"

#: ../../library/unittest.mock-examples.rst:665
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "이 클래스, 특히 \"iter\" 메서드를 어떻게 모킹할까요?"

#: ../../library/unittest.mock-examples.rst:667
msgid ""
"To configure the values returned from the iteration (implicit in the call"
" to :class:`list`), we need to configure the object returned by the call "
"to ``foo.iter()``."
msgstr ""
"이터레이션(:class:`list` 호출로 인해 묵시적으로 이루어집니다)에서 반환된 값을 구성하려면, ``foo.iter()`` "
"호출에 의해 반환된 객체를 구성해야 합니다."

#: ../../library/unittest.mock-examples.rst:675
msgid ""
"There are also generator expressions and more `advanced uses "
"<http://www.dabeaz.com/coroutines/index.html>`_ of generators, but we "
"aren't concerned about them here. A very good introduction to generators "
"and how powerful they are is: `Generator Tricks for Systems Programmers "
"<http://www.dabeaz.com/generators/>`_."
msgstr ""
"제너레이터 표현식과 제너레이터의 더 `고급 사용 "
"<http://www.dabeaz.com/coroutines/index.html>`_\\도 있지만, 여기서는 다루지 않습니다. "
"제너레이터와 이것이 얼마나 강력한지에 대한 아주 좋은 소개: `Generator Tricks for Systems "
"Programmers <http://www.dabeaz.com/generators/>`_."

#: ../../library/unittest.mock-examples.rst:683
msgid "Applying the same patch to every test method"
msgstr "모든 테스트 메서드에 같은 패치 적용하기"

#: ../../library/unittest.mock-examples.rst:685
#, fuzzy
msgid ""
"If you want several patches in place for multiple test methods the "
"obvious way is to apply the patch decorators to every method. This can "
"feel like unnecessary repetition. Instead, you can use :func:`patch` (in "
"all its various forms) as a class decorator. This applies the patches to "
"all test methods on the class. A test method is identified by methods "
"whose names start with ``test``::"
msgstr ""
"여러 테스트 메서드에 대해 여러 패치를 적용하려면 모든 메서드에 패치 데코레이터를 적용하는 것이 가장 확실한 방법입니다. 이것은 "
"불필요한 반복처럼 느낄 수 있습니다. 파이썬 2.6 이상에서는 :func:`patch`\\(이것의 모든 다양한 형태)를 클래스 "
"데코레이터로 사용할 수 있습니다. 이것은 클래스의 모든 테스트 메서드에 패치를 적용합니다. 테스트 메서드는 이름이 "
"``test``\\로 시작하는 메서드로 식별됩니다::"

#: ../../library/unittest.mock-examples.rst:692
msgid ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"
msgstr ""

#: ../../library/unittest.mock-examples.rst:709
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-"
"stop`. These allow you to move the patching into your ``setUp`` and "
"``tearDown`` methods. ::"
msgstr ""
"패치를 관리하는 다른 방법은 :ref:`start-and-stop`\\을 사용하는 것입니다. 이를 통해 패치를 "
"``setUp``\\과 ``tearDown`` 메서드로 옮길 수 있습니다. ::"

#: ../../library/unittest.mock-examples.rst:713
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:726
msgid ""
"If you use this technique you must ensure that the patching is \"undone\""
" by calling ``stop``. This can be fiddlier than you might think, because "
"if an exception is raised in the setUp then tearDown is not called. "
":meth:`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"이 기법을 사용하면 ``stop``\\을 호출하여 패치가 \"실행 취소\"되도록 해야 합니다. setUp에서 예외가 발생하면 "
"tearDown이 호출되지 않기 때문에, 생각보다 복잡할 수 있습니다. "
":meth:`unittest.TestCase.addCleanup`\\은 이것을 더 쉽게 만듭니다::"

#: ../../library/unittest.mock-examples.rst:731
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:744
msgid "Mocking Unbound Methods"
msgstr "연결되지 않은 메서드 모킹하기"

#: ../../library/unittest.mock-examples.rst:746
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* "
"(patching the method on the class rather than on the instance). I needed "
"self to be passed in as the first argument because I want to make asserts"
" about which objects were calling this particular method. The issue is "
"that you can't patch with a mock for this, because if you replace an "
"unbound method with a mock it doesn't become a bound method when fetched "
"from the instance, and so it doesn't get self passed in. The workaround "
"is to patch the unbound method with a real function instead. The "
":func:`patch` decorator makes it so simple to patch out methods with a "
"mock that having to create a real function becomes a nuisance."
msgstr ""
"오늘 테스트를 작성하는 동안 *연결되지 않은 메서드(unbound method)*\\를 패치해야 했습니다 (인스턴스가 아닌 클래스의"
" 메서드를 패치하는 것입니다). 어떤 객체가 이 특정 메서드를 호출했는지에 대한 어서션을 하고 싶기 때문에 첫 번째 인자로 "
"self가 전달되는 것이 필요했습니다. 문제는 이것을 위해 모의 객체로 패치 할 수 없다는 것인데, 연결되지 않은 메서드를 모의 "
"객체로 바꾸면 인스턴스에서 가져올 때 연결된 메서드가 되지 않아서, self가 전달되지 않기 때문입니다. 해결 방법은 연결되지 않은"
" 메서드를 실제 함수로 대신 패치하는 것입니다. :func:`patch` 데코레이터는 메서드를 모의 객체로 패치하기 너무 쉽게 "
"만들어서 실제 함수를 만들어야 하는 것이 성가십니다."

#: ../../library/unittest.mock-examples.rst:757
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as "
"the one it is replacing, but delegates to a mock under the hood. You "
"still get your mock auto-created in exactly the same way as before. What "
"it means though, is that if you use it to patch out an unbound method on "
"a class the mocked function will be turned into a bound method if it is "
"fetched from an instance. It will have ``self`` passed in as the first "
"argument, which is exactly what I wanted:"
msgstr ""
"``autospec=True``\\를 패치로 전달하면 *실제* 함수 객체로 패치가 수행됩니다. 이 함수 객체는 그것이 교체하는 것과"
" 같은 서명을 갖지만, 수면 아래에서 모의 객체로 위임합니다. 전과 똑같은 방식으로 여전히 자동 생성된 모의 객체를 얻습니다. "
"그것이 의미하는 것은, 클래스에서 연결되지 않은 메서드를 패치하는데 사용하면 모킹 된 함수가 인스턴스에서 꺼낼 때 연결된 메서드로 "
"바뀐다는 것입니다. ``self``\\가 첫 번째 인자로 전달되고, 정확히 제가 원하는 것입니다:"

#: ../../library/unittest.mock-examples.rst:778
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"``autospec=True``\\를 사용하지 않으면 연결되지 않은 메서드가 대신 Mock 인스턴스로 패치되고, "
"``self``\\로 호출되지 않습니다."

#: ../../library/unittest.mock-examples.rst:783
msgid "Checking multiple calls with mock"
msgstr "모의 객체로 여러 호출 확인하기"

#: ../../library/unittest.mock-examples.rst:785
msgid ""
"mock has a nice API for making assertions about how your mock objects are"
" used."
msgstr "mock에는 모의 객체가 어떻게 사용되는지에 대한 어서션을 만드는 데 유용한 API가 있습니다."

#: ../../library/unittest.mock-examples.rst:792
#, fuzzy
msgid ""
"If your mock is only being called once you can use the "
":meth:`~Mock.assert_called_once_with` method that also asserts that the "
":attr:`~Mock.call_count` is one."
msgstr ""
"모의 객체가 한 번만 호출되면 :attr:`call_count`\\가 1이라는 것도 어서트하는 "
":meth:`assert_called_once_with` 메서드를 사용할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:804
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make "
"assertions about the *most recent* call. If your mock is going to be "
"called several times, and you want to make assertions about *all* those "
"calls you can use :attr:`~Mock.call_args_list`:"
msgstr ""
"``assert_called_with``\\와 ``assert_called_once_with``\\는 모두 *가장 최근* 호출에 "
"대한 어서션을 합니다. 모의 객체가 여러 번 호출될 것이고, 이 호출 *모두*\\에 대해 어서션을 하고 싶다면 "
":attr:`~Mock.call_args_list`\\를 사용할 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:816
msgid ""
"The :data:`call` helper makes it easy to make assertions about these "
"calls. You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
":data:`call` 도우미를 사용하면 이러한 호출에 대한 어서션을 쉽게 할 수 있습니다. 예상 호출 리스트를 만들어서 "
"``call_args_list``\\와 비교할 수 있습니다. 이것은 ``call_args_list``\\의 repr과 매우 "
"유사합니다:"

#: ../../library/unittest.mock-examples.rst:826
msgid "Coping with mutable arguments"
msgstr "가변 인자에 대처하기"

#: ../../library/unittest.mock-examples.rst:828
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values "
"were when the mock was called."
msgstr ""
"드물지만 여러분을 괴롭힐 수 있는 또 다른 상황은 모의 객체가 가변 인자로 호출되는 경우입니다. ``call_args``\\와 "
"``call_args_list``\\는 인자에 대한 *참조*\\를 저장합니다. 테스트 중인 코드에 의해 인자가 변경되면 모의 객체가"
" 호출되었을 때의 값에 대해 더는 어서션 할 수 없습니다."

#: ../../library/unittest.mock-examples.rst:833
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr "다음은 문제를 보여주는 예제 코드입니다. 'mymodule'에 정의된 다음 함수를 상상해보십시오::"

#: ../../library/unittest.mock-examples.rst:836
msgid ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:844
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct "
"argument look what happens::"
msgstr "``grob``\\이 올바른 인자로 ``frob``\\을 호출하는지 테스트하려고 할 때 어떤 일이 발생하는지 보십시오::"

#: ../../library/unittest.mock-examples.rst:847
#, python-brace-format
msgid ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"
msgstr ""

#: ../../library/unittest.mock-examples.rst:859
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This"
" could then cause problems if you do assertions that rely on object "
"identity for equality."
msgstr ""
"한가지 가능성은 모의 객체가 전달한 인자를 복사하는 것일 수 있습니다. 그러면 동일성(equality)을 위해 객체 아이덴티티에 "
"의존하는 어서션을 수행하면 문제가 발생할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:863
#, fuzzy
msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` "
"functionality. If you provide a ``side_effect`` function for a mock then "
"``side_effect`` will be called with the same args as the mock. This gives"
" us an opportunity to copy the arguments and store them for later "
"assertions. In this example I'm using *another* mock to store the "
"arguments so that I can use the mock methods for doing the assertion. "
"Again a helper function sets this up for me. ::"
msgstr ""
"여기에 :attr:`side_effect` 함수를 사용하는 한 가지 해결책이 있습니다. 모의 객체에 ``side_effect`` "
"함수를 제공하면 모의 객체와 같은 인자로 ``side_effect``\\가 호출됩니다. 이는 인자를 복사하여 나중에 어서션을 위해 "
"저장할 기회를 제공합니다. 이 예제에서는 *다른* 모의 객체를 사용하여 인자를 저장해서 어서션을 수행하기 위해 모의 객체 메서드를 "
"사용할 수 있습니다. 다시 한번 도우미 함수가 이것을 설정합니다. ::"

#: ../../library/unittest.mock-examples.rst:871
#, python-brace-format
msgid ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"
msgstr ""

#: ../../library/unittest.mock-examples.rst:892
msgid ""
"``copy_call_args`` is called with the mock that will be called. It "
"returns a new mock that we do the assertion on. The ``side_effect`` "
"function makes a copy of the args and calls our ``new_mock`` with the "
"copy."
msgstr ""
"``copy_call_args``\\는 호출될 모의로 호출됩니다. 어서션을 수행할 새로운 모의 객체를 반환합니다. "
"``side_effect`` 함수는 인자의 사본을 만들고 사본으로 ``new_mock``\\을 호출합니다."

#: ../../library/unittest.mock-examples.rst:898
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"모의 객체를 한 번만 사용하려는 경우 호출 시점에서 인자를 확인하는 쉬운 방법이 있습니다. 단순히 ``side_effect`` 함수"
" 내에서 확인할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:912
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or "
":class:`MagicMock` that copies (using :func:`copy.deepcopy`) the "
"arguments. Here's an example implementation:"
msgstr ""
"다른 접근법은 인자를 복사(:func:`copy.deepcopy`\\를 사용해서)하는 :class:`Mock`\\이나 "
":class:`MagicMock`\\의 서브 클래스를 만드는 것입니다. 구현 예는 다음과 같습니다:"

#: ../../library/unittest.mock-examples.rst:937
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass "
"automatically. That means all children of a ``CopyingMock`` will also "
"have the type ``CopyingMock``."
msgstr ""
"``Mock``\\이나 ``MagicMock``\\을 서브 클래싱할 때 모든 동적으로 만들어진 어트리뷰트와 "
"``return_value``\\는 자동으로 서브 클래스를 사용합니다. 즉, ``CopyingMock``\\의 모든 자식도 "
"``CopyingMock`` 형이 됩니다."

#: ../../library/unittest.mock-examples.rst:943
msgid "Nesting Patches"
msgstr "중첩 패치"

#: ../../library/unittest.mock-examples.rst:945
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches "
"you can end up with nested with statements indenting further and further "
"to the right::"
msgstr ""
"patch를 컨텍스트 관리자로 것이 멋지기는 하지만, 여러 패치를 수행하면 오른쪽으로 점점 더 들여쓰기 되는 문장으로 중첩될 수 "
"있습니다::"

#: ../../library/unittest.mock-examples.rst:949
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"
msgstr ""

#: ../../library/unittest.mock-examples.rst:963
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created"
" mock for us::"
msgstr ""
"unittest ``cleanup`` 함수와 :ref:`start-and-stop`\\을 사용하면 중첩된 들여쓰기 없이 같은 효과를"
" 얻을 수 있습니다. 간단한 도우미 메서드인 ``create_patch``\\는 제 자리에서 패치를 설치하고 만들어진 모의 객체를 "
"반환합니다::"

#: ../../library/unittest.mock-examples.rst:968
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"
msgstr ""

#: ../../library/unittest.mock-examples.rst:991
msgid "Mocking a dictionary with MagicMock"
msgstr "MagicMock으로 딕셔너리 모킹하기"

#: ../../library/unittest.mock-examples.rst:993
msgid ""
"You may want to mock a dictionary, or other container object, recording "
"all access to it whilst having it still behave like a dictionary."
msgstr "딕셔너리나 다른 컨테이너 객체를 모킹하여, 여전히 딕셔너리처럼 동작하면서 이에 대한 모든 액세스를 기록하고 싶을 수 있습니다."

#: ../../library/unittest.mock-examples.rst:996
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a "
"dictionary, and using :data:`~Mock.side_effect` to delegate dictionary "
"access to a real underlying dictionary that is under our control."
msgstr ""
"딕셔너리처럼 동작하는 :class:`MagicMock`\\을 사용하고 :data:`~Mock.side_effect`\\가 딕셔너리 "
"액세스를 우리의 제어하에 있는 실제 하부 딕셔너리로 위임하게 해서 목적을 달성할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:1000
#, fuzzy
msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` "
"methods of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of "
"``__setitem__`` the value too). We can also control what is returned."
msgstr ""
"``MagicMock``\\의 :meth:`__getitem__`\\과 :meth:`__setitem__` 메서드가 호출될 때 "
"(일반 딕셔너리 액세스), ``side_effect``\\는 키로 호출됩니다 (그리고 ``__setitem__``\\의 경우는 "
"값도). 반환되는 것을 제어 할 수도 있습니다."

#: ../../library/unittest.mock-examples.rst:1005
msgid ""
"After the ``MagicMock`` has been used we can use attributes like "
":data:`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"``MagicMock``\\이 사용된 후에 :data:`~Mock.call_args_list`\\와 같은 어트리뷰트를 사용하여 "
"딕셔너리가 어떻게 사용되었는지를 어서트할 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:1021
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* "
"provide the magic methods you specifically want:"
msgstr "``MagicMock``\\을 사용하는 대신 ``Mock``\\을 사용하고 *오직* 원하는 매직 메서드만 제공할 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:1028
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only "
"has dictionary magic methods available:"
msgstr ""
"*세 번째* 옵션은 ``MagicMock``\\을 사용하지만, ``dict``\\를 *spec* (또는 *spec_set*) 인자로"
" 전달하여 만들어진 ``MagicMock``\\이 딕셔너리 매직 메서드 만 갖도록 하는 것입니다:"

#: ../../library/unittest.mock-examples.rst:1036
msgid ""
"With these side effect functions in place, the ``mock`` will behave like "
"a normal dictionary but recording the access. It even raises a "
":exc:`KeyError` if you try to access a key that doesn't exist."
msgstr ""
"이러한 부작용 함수가 제자리에 들어가면, ``mock``\\은 일반 딕셔너리처럼 작동하지만, 액세스를 기록합니다. 존재하지 않는 "
"키에 액세스하려고 하면 :exc:`KeyError`\\를 발생시키기조차 합니다."

#: ../../library/unittest.mock-examples.rst:1055
msgid ""
"After it has been used you can make assertions about the access using the"
" normal mock methods and attributes:"
msgstr "사용된 후에 일반적인 모의 객체 메서드와 어트리뷰트를 사용하여 액세스에 대한 어서션을 할 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:1067
msgid "Mock subclasses and their attributes"
msgstr "Mock 서브 클래스와 그 어트리뷰트"

#: ../../library/unittest.mock-examples.rst:1069
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. "
"One reason might be to add helper methods. Here's a silly example:"
msgstr ""
":class:`Mock`\\을 서브 클래싱하려는 여러 가지 이유가 있습니다. 한 가지 이유는 도우미 메서드를 추가하는 것입니다. "
"다음은 시시한 예입니다:"

#: ../../library/unittest.mock-examples.rst:1085
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on."
" This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add "
"helper methods then they'll also be available on the attributes and "
"return value mock of instances of your subclass."
msgstr ""
"``Mock`` 인스턴스의 표준 동작은 어트리뷰트와 반환 값 모의 객체가 액세스 되는 모의 객체의 형과 같은 형이라는 것입니다. "
"이를 통해 ``Mock`` 어트리뷰트는 ``Mock``\\이고 ``MagicMock`` 어트리뷰트는 ``MagicMock``\\이 "
"됩니다 [#]_. 따라서 도우미 메서드를 추가하기 위해 서브 클래싱하면 이 메서드는 서브 클래스 인스턴스의 어트리뷰트와 반환 값 "
"모의 객체에서도 사용할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:1101
#, fuzzy
msgid ""
"Sometimes this is inconvenient. For example, `one user "
"<https://code.google.com/archive/p/mock/issues/105>`_ is subclassing mock"
" to created a `Twisted adaptor "
"<https://twisted.org/documents/11.0.0/api/twisted.python.components.html>`_."
" Having this applied to attributes too actually causes errors."
msgstr ""
"때때로 이것은 불편합니다. 예를 들어, `한 사용자 "
"<https://code.google.com/archive/p/mock/issues/105>`_\\가 `Twisted adaptor"
" "
"<https://twistedmatrix.com/documents/11.0.0/api/twisted.python.components.html>`_"
" 를 만들기 위해 Mock을 서브 클래싱했습니다. 이것을 어트리뷰트에도 적용하면 실제로 에러가 발생합니다."

#: ../../library/unittest.mock-examples.rst:1107
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` "
"to create these \"sub-mocks\" for attributes and return values. You can "
"prevent your subclass being used for attributes by overriding this "
"method. The signature is that it takes arbitrary keyword arguments "
"(``**kwargs``) which are then passed onto the mock constructor:"
msgstr ""
"``Mock``\\(이것의 모든 종류에서)은 ``_get_child_mock``\\이라는 메서드를 사용하여 어트리뷰트와 반환 값을 "
"위한 이러한 \"서브 모의 객체\"를 만듭니다. 이 메서드를 재정의하여 서브 클래스가 어트리뷰트에 사용되지 않도록 할 수 있습니다."
" 서명은 모의 객체 생성자에 전달되는 임의의 키워드 인자(``**kwargs``)를 취하는 것입니다:"

#: ../../library/unittest.mock-examples.rst:1124
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have "
"callable methods."
msgstr ""
"이 규칙의 예외는 콜러블이 아닌 모의 객체입니다. 어트리뷰트는 콜러블 변형을 사용하는데, 그렇지 않으면 콜러블이 아닌 모의 객체가 "
"콜러블 메서드를 가질 수 없기 때문입니다."

#: ../../library/unittest.mock-examples.rst:1130
msgid "Mocking imports with patch.dict"
msgstr "patch.dict로 임포트를 모킹하기"

#: ../../library/unittest.mock-examples.rst:1132
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"모킹이 어려울 수 있는 한 가지 상황은 함수 내부에 지역 임포트가 있는 경우입니다. 이것들은 모킹하기가 더 어려운데, 우리가 패치 "
"할 수 있는 모듈 이름 공간의 객체를 사용하지 않기 때문입니다."

#: ../../library/unittest.mock-examples.rst:1136
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better"
" way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways "
"than an unconditional local import (store the module as a class or module"
" attribute and only do the import on first use)."
msgstr ""
"일반적으로 지역 임포트는 피해야 합니다. 그것들은 때때로 순환 의존성을 막기 위해 수행되는데, *보통* 문제를 해결하는 더 좋은 "
"방법(코드를 리팩터 하십시오)이 있습니다. 또는 임포트를 지연시켜서 \"선불 비용\"을 방지하기 위해 수행합니다. 이 또한 "
"무조건적인 지역 임포트보다 더 나은 방법으로 해결할 수 있습니다 (모듈을 클래스나 모듈 어트리뷰트로 저장하고 처음 사용할 때만 "
"임포트 합니다)."

#: ../../library/unittest.mock-examples.rst:1143
#, fuzzy
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module."
" Importing a module for the first time results in a module object being "
"put in ``sys.modules``, so usually when you import something you get a "
"module back. This need not be the case however."
msgstr ""
"그 외에도 ``mock``\\을 사용하여 임포트 결과에 영향을 주는 방법이 있습니다. 임포트는 :data:`sys.modules` "
"딕셔너리에서 *객체*\\를 가져옵니다. *객체*\\를 가져온다는 것에 유의하십시오, 이것이 모듈일 필요는 없습니다. 처음으로 모듈을"
" 임포트 하면 `sys.modules`\\에 모듈 객체가 배치되어서, 일반적으로 무언가를 임포트 할 때 모듈을 다시 받습니다. "
"그러나 반드시 그런 것은 아닙니다."

#: ../../library/unittest.mock-examples.rst:1150
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active "
"will fetch the mock. When the patch is complete (the decorated function "
"exits, the with statement body is complete or ``patcher.stop()`` is "
"called) then whatever was there previously will be restored safely."
msgstr ""
"즉, :func:`patch.dict`\\를 사용하여 *임시로* :data:`sys.modules`\\에 모의 객체를 넣을 수 "
"있습니다. 이 패치가 활성화되어있는 동안 모든 임포트는 모의 객체를 가져옵니다. 패치가 완료되면 (데코레이트 된 함수가 종료되거나,"
" with 문 본문이 완료되거나 ``patcher.stop()``\\이 호출되면) 이전에 있던 모든 것이 안전하게 복원됩니다."

#: ../../library/unittest.mock-examples.rst:1156
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "다음은 'fooble' 모듈을 모킹하는 예입니다."

#: ../../library/unittest.mock-examples.rst:1168
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"보시다시피 ``import fooble``\\은 성공하지만, 끝났을 때 :data:`sys.modules`\\에는 'fooble'이"
" 남아 있지 않습니다."

#: ../../library/unittest.mock-examples.rst:1171
msgid "This also works for the ``from module import name`` form:"
msgstr "이것은 ``from module import name`` 형식에서도 작동합니다:"

#: ../../library/unittest.mock-examples.rst:1181
msgid "With slightly more work you can also mock package imports:"
msgstr "약간의 추가 작업으로 패키지 임포트를 모킹 할 수도 있습니다:"

#: ../../library/unittest.mock-examples.rst:1194
msgid "Tracking order of calls and less verbose call assertions"
msgstr "호출 순서 추적과 덜 상세한 호출 어서션"

#: ../../library/unittest.mock-examples.rst:1196
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls "
"on your mock objects through the :attr:`~Mock.method_calls` attribute. "
"This doesn't allow you to track the order of calls between separate mock "
"objects, however we can use :attr:`~Mock.mock_calls` to achieve the same "
"effect."
msgstr ""
":class:`Mock` 클래스를 사용하면 :attr:`~Mock.method_calls` 어트리뷰트를 통해 모의 객체에서 메서드 "
"호출의 *순서*\\를 추적할 수 있습니다. 개별 모의 객체 간의 호출 순서를 추적할 수는 없지만, "
":attr:`~Mock.mock_calls`\\를 사용하여 같은 효과를 얻을 수 있습니다."

#: ../../library/unittest.mock-examples.rst:1201
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing"
" an arbitrary attribute of a mock creates a child mock, we can create our"
" separate mocks from a parent one. Calls to those child mock will then "
"all be recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"모의 객체들은 ``mock_calls``\\에서 자식 모의 객체에 대한 호출을 추적하고, 모의 객체의 임의 어트리뷰트에 액세스하면 "
"자식 모의 객체를 만들기 때문에, 부모 모의 객체로부터 개별 모의 객체를 만들 수 있습니다. 그러면 해당 자식 모의 객체에 대한 "
"호출은 부모의 ``mock_calls``\\에 순서대로 기록됩니다:"

#: ../../library/unittest.mock-examples.rst:1218
msgid ""
"We can then assert about the calls, including the order, by comparing "
"with the ``mock_calls`` attribute on the manager mock:"
msgstr "그런 다음 관리자 모의 객체의 ``mock_calls`` 어트리뷰트와 비교하여 순서를 포함하여 호출에 대해 어서션 할 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:1225
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method."
" After attaching calls will be recorded in ``mock_calls`` of the manager."
" ::"
msgstr ""
"``patch``\\가 모의 객체를 만들고 제자리에 배치하는 경우, :meth:`~Mock.attach_mock` 메서드를 사용하여"
" 모의 객체를 관리자 모의 객체에 연결할 수 있습니다. 연결 후 호출은 관리자의 ``mock_calls``\\에 기록됩니다. ::"

#: ../../library/unittest.mock-examples.rst:1229
msgid ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"
msgstr ""

#: ../../library/unittest.mock-examples.rst:1244
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the "
":meth:`~Mock.assert_has_calls` method. This takes a list of calls "
"(constructed with the :data:`call` object). If that sequence of calls are"
" in :attr:`~Mock.mock_calls` then the assert succeeds."
msgstr ""
"많은 호출이 이루어졌지만, 특정 시퀀스에만 관심이 있다면 대안은 :meth:`~Mock.assert_has_calls` 메서드를 "
"사용하는 것입니다. 이것은 호출 리스트를 취합니다 (:data:`call` 객체로 구성됩니다). 해당 호출 시퀀스가 "
":attr:`~Mock.mock_calls`\\에 있으면 어서션이 성공합니다."

#: ../../library/unittest.mock-examples.rst:1258
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only "
"calls that have been made to the mock, the assert still succeeds."
msgstr "연쇄 호출 ``m.one().two().three()``\\가 모의 객체에 대한 호출의 전부는 아니지만, 어서션이 여전히 성공합니다."

#: ../../library/unittest.mock-examples.rst:1261
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even "
"care about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"때로는 모의 객체에 여러 번의 호출이 있을 수 있고, 그 호출들의 *일부*\\에 대만 어서션에만 관심이 있을 수 있습니다. 순서에 "
"신경 쓰지 않을 수도 있습니다. 이 경우 ``any_order=True``\\를 ``assert_has_calls``\\로 전달할 "
"수 있습니다:"

#: ../../library/unittest.mock-examples.rst:1273
msgid "More complex argument matching"
msgstr "더 복잡한 인자 일치"

#: ../../library/unittest.mock-examples.rst:1275
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to "
"do more complex assertions on objects used as arguments to mocks."
msgstr ""
":data:`ANY`\\와 같은 기본 개념을 사용하여 모의 객체에 인자로 사용되는 객체에 대해 더 복잡한 어서션을 수행하도록 "
"매처(matchers)를 구현할 수 있습니다."

#: ../../library/unittest.mock-examples.rst:1278
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would "
"need to pass in the exact same object. If we are only interested in some "
"of the attributes of this object then we can create a matcher that will "
"check these attributes for us."
msgstr ""
"기본적으로 객체 아이덴티티에 기반하여 를 기준으로 같다고 비교되는 (이것이 사용자 정의 클래스의 파이썬 기본 동작입니다) 어떤 "
"객체가 모의 객체로 전달되기를 기대한다고 가정합시다. :meth:`~Mock.assert_called_with`\\를 사용하려면 "
"정확히 같은 객체를 전달해야 합니다. 이 객체의 일부 어트리뷰트에만 관심이 있다면 이러한 어트리뷰트를 확인하는 매처를 만들 수 "
"있습니다."

#: ../../library/unittest.mock-examples.rst:1285
msgid ""
"You can see in this example how a 'standard' call to "
"``assert_called_with`` isn't sufficient:"
msgstr "이 예에서 ``assert_called_with``\\에 대한 '표준' 호출이 충분하지 않다는 것을 볼 수 있습니다:"

#: ../../library/unittest.mock-examples.rst:1301
msgid ""
"A comparison function for our ``Foo`` class might look something like "
"this:"
msgstr "``Foo`` 클래스를 위한 비교 함수는 다음과 같습니다:"

#: ../../library/unittest.mock-examples.rst:1313
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr "그리고 동등 비교 연산에 이와 같은 비교 함수를 사용할 수 있는 매처 객체는 다음과 같습니다:"

#: ../../library/unittest.mock-examples.rst:1324
msgid "Putting all this together:"
msgstr "이 모든 것을 종합하면:"

#: ../../library/unittest.mock-examples.rst:1329
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo``"
" object we want to compare against. In ``assert_called_with`` the "
"``Matcher`` equality method will be called, which compares the object the"
" mock was called with against the one we created our matcher with. If "
"they match then ``assert_called_with`` passes, and if they don't an "
":exc:`AssertionError` is raised:"
msgstr ""
"``Matcher``\\는 compare 함수와 비교하려는 ``Foo`` 객체로 인스턴스 화 됩니다. "
"``assert_called_with``\\에서는 ``Matcher`` 동등 비교 메서드가 호출되는데, 이 메서드는 모의 객체가 "
"호출된 객체와 우리가 매처를 만들 때 제공한 객체를 비교합니다. 일치하면 ``assert_called_with``\\가 통과하고, "
"그렇지 않으면 :exc:`AssertionError`\\가 발생합니다:"

#: ../../library/unittest.mock-examples.rst:1342
msgid ""
"With a bit of tweaking you could have the comparison function raise the "
":exc:`AssertionError` directly and provide a more useful failure message."
msgstr ""
"약간의 조정만으로 비교 함수가 :exc:`AssertionError`\\를 직접 발생시키고 더 유용한 실패 메시지를 제공할 수 "
"있습니다."

#: ../../library/unittest.mock-examples.rst:1345
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest "
"<https://pyhamcrest.readthedocs.io/>`_ provides similar functionality, "
"that may be useful here, in the form of its equality matcher "
"(`hamcrest.library.integration.match_equality "
"<https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-"
"hamcrest.library.integration.match_equality>`_)."
msgstr ""
"버전 1.5부터, 파이썬 테스트 라이브러리 `PyHamcrest "
"<https://pyhamcrest.readthedocs.io/>`_\\는 여기에서 유용할 수 있는 유사한 기능을 동등 비교 매처의"
" 형태로 제공합니다 (`hamcrest.library.integration.match_equality "
"<https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-"
"hamcrest.library.integration.match_equality>`_)."

