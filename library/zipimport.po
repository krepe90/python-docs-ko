# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/zipimport.rst:2
msgid ":mod:`!zipimport` --- Import modules from Zip archives"
msgstr ":mod:`!zipimport` --- Zip 저장소에서 모듈 임포트"

#: ../../library/zipimport.rst:9
msgid "**Source code:** :source:`Lib/zipimport.py`"
msgstr "**소스 코드:** :source:`Lib/zipimport.py`"

#: ../../library/zipimport.rst:13
msgid ""
"This module adds the ability to import Python modules (:file:`\\*.py`, "
":file:`\\*.pyc`) and packages from ZIP-format archives. It is usually not"
" needed to use the :mod:`zipimport` module explicitly; it is "
"automatically used by the built-in :keyword:`import` mechanism for "
":data:`sys.path` items that are paths to ZIP archives."
msgstr ""
"이 모듈은 파이썬 모듈(:file:`\\*.py`, :file:`\\*.pyc`)과 패키지를 ZIP-형식 저장소에서 임포트하는 "
"기능을 추가합니다. 일반적으로 :mod:`zipimport` 모듈을 명시적으로 사용할 필요는 없습니다; ZIP 저장소 경로가 "
":data:`sys.path` 항목에 있으면 내장 :keyword:`import` 메커니즘에 의해 자동으로 사용됩니다."

#: ../../library/zipimport.rst:19
msgid ""
"Typically, :data:`sys.path` is a list of directory names as strings.  "
"This module also allows an item of :data:`sys.path` to be a string naming"
" a ZIP file archive. The ZIP archive can contain a subdirectory structure"
" to support package imports, and a path within the archive can be "
"specified to only import from a subdirectory.  For example, the path "
":file:`example.zip/lib/` would only import from the :file:`lib/` "
"subdirectory within the archive."
msgstr ""
"일반적으로, :data:`sys.path`\\는 문자열 디렉터리 이름의 리스트입니다. 이 모듈은 또한 :data:`sys.path`"
" 항목이 ZIP 파일 저장소를 명명하는 문자열이 될 수 있도록 합니다. ZIP 저장소에는 패키지 임포트를 지원하는 하위 디렉터리 "
"구조가 포함될 수 있으며, 저장소 내의 경로를 지정하여 하위 디렉터리에서만 임포트 되도록 할 수 있습니다. 예를 들어, 경로 "
":file:`example.zip/lib/`\\는 저장소 내의 :file:`lib/` 서브 디렉터리에서만 임포트하도록 합니다."

#: ../../library/zipimport.rst:26
msgid ""
"Any files may be present in the ZIP archive, but importers are only "
"invoked for :file:`.py` and :file:`.pyc` files.  ZIP import of dynamic "
"modules (:file:`.pyd`, :file:`.so`) is disallowed. Note that if an "
"archive only contains :file:`.py` files, Python will not attempt to "
"modify the archive by adding the corresponding :file:`.pyc` file, meaning"
" that if a ZIP archive doesn't contain :file:`.pyc` files, importing may "
"be rather slow."
msgstr ""
"어떤 파일이든 ZIP 저장소에 있을 수 있지만, 임포터는 :file:`.py` 와 :file:`.pyc` 파일에 대해서만 "
"호출됩니다. 동적 모듈(:file:`.pyd`, :file:`.so`)의 ZIP 임포트는 허용되지 않습니다. 저장소에 "
":file:`.py` 파일만 포함되어있으면, 파이썬은 해당 :file:`.pyc` 파일을 추가하여 저장소를 수정하지 않습니다. 즉,"
" ZIP 저장소에 :file:`.pyc` 파일이 포함되어 있지 않으면, 임포트가 다소 느릴 수 있습니다."

#: ../../library/zipimport.rst:33
msgid "ZIP64 is supported"
msgstr "ZIP64 를 지원합니다"

#: ../../library/zipimport.rst:36
msgid "Previously, ZIP archives with an archive comment were not supported."
msgstr "전에는, 저장소 주석이 포함된 ZIP 저장소는 지원되지 않았습니다."

#: ../../library/zipimport.rst:41
msgid ""
"`PKZIP Application Note "
"<https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT>`_"
msgstr ""
"`PKZIP Application Note "
"<https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT>`_"

#: ../../library/zipimport.rst:42
msgid ""
"Documentation on the ZIP file format by Phil Katz, the creator of the "
"format and algorithms used."
msgstr "사용된 형식과 알고리즘 저자인 Phil Katz의 ZIP 파일 형식에 관한 설명서."

#: ../../library/zipimport.rst:45
msgid ":pep:`273` - Import Modules from Zip Archives"
msgstr ":pep:`273` - Zip 저장소에서 모듈 임포트"

#: ../../library/zipimport.rst:46
msgid ""
"Written by James C. Ahlstrom, who also provided an implementation. Python"
" 2.3 follows the specification in :pep:`273`, but uses an implementation "
"written by Just van Rossum that uses the import hooks described in "
":pep:`302`."
msgstr ""
"구현도 제공한 James C. Ahlstrom이 작성했습니다. 파이썬 2.3은 :pep:`273`\\의 명세를 따르지만, Just "
"van Rossum이 작성한 구현을 사용하는데 :pep:`302`\\에 설명된 임포트 훅을 사용합니다."

#: ../../library/zipimport.rst:50
msgid ":mod:`importlib` - The implementation of the import machinery"
msgstr ""

#: ../../library/zipimport.rst:51
msgid "Package providing the relevant protocols for all importers to implement."
msgstr ""

#: ../../library/zipimport.rst:55
msgid "This module defines an exception:"
msgstr "이 모듈은 예외를 정의합니다:"

#: ../../library/zipimport.rst:59
msgid ""
"Exception raised by zipimporter objects. It's a subclass of "
":exc:`ImportError`, so it can be caught as :exc:`ImportError`, too."
msgstr ""
"zipimporter 객체가 발생시키는 예외. :exc:`ImportError`\\의 서브 클래스이므로, "
":exc:`ImportError`\\로도 잡힐 수 있습니다."

#: ../../library/zipimport.rst:66
msgid "zipimporter Objects"
msgstr "zipimporter 객체"

#: ../../library/zipimport.rst:68
msgid ":class:`zipimporter` is the class for importing ZIP files."
msgstr ":class:`zipimporter`\\는 ZIP 파일을 임포트하는 클래스입니다."

#: ../../library/zipimport.rst:72
msgid ""
"Create a new zipimporter instance. *archivepath* must be a path to a ZIP "
"file, or to a specific path within a ZIP file.  For example, an "
"*archivepath* of :file:`foo/bar.zip/lib` will look for modules in the "
":file:`lib` directory inside the ZIP file :file:`foo/bar.zip` (provided "
"that it exists)."
msgstr ""
"새로운 zipimporter 인스턴스를 만듭니다. *archivepath*\\는 ZIP 파일의 경로이거나, ZIP 파일 내의 특정 "
"경로여야 합니다. 예를 들어, *archivepath* :file:`foo/bar.zip/lib`\\는 ZIP 파일 "
":file:`foo/bar.zip` 내의 :file:`lib` 디렉터리에 있는 모듈을 찾습니다 (존재한다면)."

#: ../../library/zipimport.rst:77
msgid ""
":exc:`ZipImportError` is raised if *archivepath* doesn't point to a valid"
" ZIP archive."
msgstr "*archivepath*\\가 유효한 ZIP 저장소를 가리키지 않으면 :exc:`ZipImportError`\\가 발생합니다."

#: ../../library/zipimport.rst:82
msgid ""
"Methods ``find_loader()`` and ``find_module()``, deprecated in 3.10 are "
"now removed.  Use :meth:`find_spec` instead."
msgstr ""

#: ../../library/zipimport.rst:87
msgid ""
"Implementation of :meth:`importlib.abc.Loader.create_module` that returns"
" :const:`None` to explicitly request the default semantics."
msgstr ""

#: ../../library/zipimport.rst:95
msgid "Implementation of :meth:`importlib.abc.Loader.exec_module`."
msgstr ""

#: ../../library/zipimport.rst:102
msgid "An implementation of :meth:`importlib.abc.PathEntryFinder.find_spec`."
msgstr ""

#: ../../library/zipimport.rst:109
msgid ""
"Return the code object for the specified module. Raise "
":exc:`ZipImportError` if the module couldn't be imported."
msgstr "지정된 모듈의 코드 객체를 반환합니다. 모듈을 임포트할 수 없으면 :exc:`ZipImportError`\\를 발생시킵니다."

#: ../../library/zipimport.rst:115
msgid ""
"Return the data associated with *pathname*. Raise :exc:`OSError` if the "
"file wasn't found."
msgstr "*pathname*\\와 관련된 데이터를 반환합니다. 파일을 찾을 수 없으면 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/zipimport.rst:118
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`IOError` 를 발생시켜왔습니다, 이제 :exc:`OSError`\\의 별칭입니다."

#: ../../library/zipimport.rst:124
msgid ""
"Return the value ``__file__`` would be set to if the specified module was"
" imported. Raise :exc:`ZipImportError` if the module couldn't be "
"imported."
msgstr ""
"지정한 모듈이 임포트될 때 설정될 ``__file__``\\의 값을 반환합니다. 모듈을 임포트할 수 없으면 "
":exc:`ZipImportError`\\를 발생시킵니다."

#: ../../library/zipimport.rst:133
msgid ""
"Return the source code for the specified module. Raise "
":exc:`ZipImportError` if the module couldn't be found, return "
":const:`None` if the archive does contain the module, but has no source "
"for it."
msgstr ""
"지정된 모듈의 소스 코드를 반환합니다. 모듈을 찾을 수 없으면 :exc:`ZipImportError`\\를 발생시키고, 저장소에 "
"모듈이 있지만, 소스가 없으면 :const:`None`\\을 반환합니다."

#: ../../library/zipimport.rst:141
msgid ""
"Return ``True`` if the module specified by *fullname* is a package. Raise"
" :exc:`ZipImportError` if the module couldn't be found."
msgstr ""
"*fullname*\\으로 지정된 모듈이 패키지면 ``True``\\를 반환합니다. 모듈을 찾을 수 없으면 "
":exc:`ZipImportError`\\를 발생시킵니다."

#: ../../library/zipimport.rst:147
msgid ""
"Load the module specified by *fullname*. *fullname* must be the fully "
"qualified (dotted) module name. Returns the imported module on success, "
"raises :exc:`ZipImportError` on failure."
msgstr ""
"*fullname*\\으로 지정된 모듈을 로드 합니다. *fullname*\\은 완전히 정규화된 (점으로 구분된) 모듈 이름이어야 "
"합니다. 성공하면 임포트 된 모듈을 반환하고, 실패하면 :exc:`ZipImportError`\\를 발생시킵니다."

#: ../../library/zipimport.rst:153
msgid "Use :meth:`exec_module` instead."
msgstr ""

#: ../../library/zipimport.rst:158
msgid ""
"Clear out the internal cache of information about files found within the "
"ZIP archive."
msgstr ""

#: ../../library/zipimport.rst:166
msgid ""
"The file name of the importer's associated ZIP file, without a possible "
"subpath."
msgstr "있을 수도 있는 하위 경로를 제외한, 임포터와 연결된 ZIP 파일의 파일 이름."

#: ../../library/zipimport.rst:172
msgid ""
"The subpath within the ZIP file where modules are searched.  This is the "
"empty string for zipimporter objects which point to the root of the ZIP "
"file."
msgstr "모듈이 검색되는 ZIP 파일 내의 하위 경로. ZIP 파일의 루트를 가리키는 zipimporter 객체에서는 빈 문자열입니다."

#: ../../library/zipimport.rst:176
msgid ""
"The :attr:`archive` and :attr:`prefix` attributes, when combined with a "
"slash, equal the original *archivepath* argument given to the "
":class:`zipimporter` constructor."
msgstr ""
":attr:`archive`\\와 :attr:`prefix` 어트리뷰트는, 슬래시로 결합 될 때, "
":class:`zipimporter` 생성자에 지정된 원래 *archivepath* 인자와 같습니다."

#: ../../library/zipimport.rst:184
msgid "Examples"
msgstr "예제"

#: ../../library/zipimport.rst:186
msgid ""
"Here is an example that imports a module from a ZIP archive - note that "
"the :mod:`zipimport` module is not explicitly used."
msgstr ""
"다음은 ZIP 저장소에서 모듈을 임포트하는 예제입니다 - :mod:`zipimport` 모듈이 명시적으로 사용되지 않음에 "
"유의하십시오."

#: ../../library/zipimport.rst:189
msgid ""
"$ unzip -l example.zip\n"
"Archive:  example.zip\n"
"  Length     Date   Time    Name\n"
" --------    ----   ----    ----\n"
"     8467  11-26-02 22:30   jwzthreading.py\n"
" --------                   -------\n"
"     8467                   1 file\n"
"$ ./python\n"
"Python 2.3 (#1, Aug 1 2003, 19:54:32)\n"
">>> import sys\n"
">>> sys.path.insert(0, 'example.zip')  # Add .zip file to front of path\n"
">>> import jwzthreading\n"
">>> jwzthreading.__file__\n"
"'example.zip/jwzthreading.py'"
msgstr ""
"$ unzip -l example.zip\n"
"Archive:  example.zip\n"
"  Length     Date   Time    Name\n"
" --------    ----   ----    ----\n"
"     8467  11-26-02 22:30   jwzthreading.py\n"
" --------                   -------\n"
"     8467                   1 file\n"
"$ ./python\n"
"Python 2.3 (#1, Aug 1 2003, 19:54:32)\n"
">>> import sys\n"
">>> sys.path.insert(0, 'example.zip')  # .zip 파일을 path 앞에 추가합니다\n"
">>> import jwzthreading\n"
">>> jwzthreading.__file__\n"
"'example.zip/jwzthreading.py'"

#~ msgid ":pep:`302` - New Import Hooks"
#~ msgstr ":pep:`302` - 새 임포트 훅"

#~ msgid "The PEP to add the import hooks that help this module work."
#~ msgstr "이 모듈이 작동하는 데 도움이 되는 임포트 훅을 추가하는 PEP."

#~ msgid ""
#~ "Search for a module specified by "
#~ "*fullname*. *fullname* must be the fully"
#~ " qualified (dotted) module name. It "
#~ "returns the zipimporter instance itself "
#~ "if the module was found, or "
#~ ":const:`None` if it wasn't. The optional"
#~ " *path* argument is ignored---it's "
#~ "there for compatibility with the "
#~ "importer protocol."
#~ msgstr ""
#~ "*fullname*\\로 지정된 모듈을 검색합니다. *fullname*\\은 "
#~ "완전히 정규화된 (점으로 구분된) 모듈 이름이어야 합니다."
#~ " 모듈이 발견되면 zipimporter 인스턴스 자체를 반환하고,"
#~ " 그렇지 않으면 :const:`None`\\을 반환합니다. 선택적 "
#~ "*path* 인자는 무시됩니다---임포터 프로토콜과의 호환성을 "
#~ "위해 있습니다."

