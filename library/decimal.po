# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/decimal.rst:2
#, fuzzy
msgid ":mod:`!decimal` --- Decimal fixed-point and floating-point arithmetic"
msgstr ":mod:`decimal` --- 십진 고정 소수점 및 부동 소수점 산술"

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**소스 코드:** :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
#, fuzzy
msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating-point arithmetic. It offers several advantages over the "
":class:`float` datatype:"
msgstr ""
":mod:`decimal` 모듈은 빠르고 정확하게 자리 올림 하는 십진 부동 소수 산술을 지원합니다. :class:`float` "
"데이터형보다 다음과 같은 몇 가지 장점을 제공합니다:"

#: ../../library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with "
"people in mind, and necessarily has a paramount guiding principle -- "
"computers must provide an arithmetic that works in the same way as the "
"arithmetic that people learn at school.\" -- excerpt from the decimal "
"arithmetic specification."
msgstr ""
"Decimal \"은 사람을 염두에 두고 설계된 부동 소수점 모델에 기반하고, 필연적으로 최고 원리를 갖습니다 -- 컴퓨터는 "
"사람들이 학교에서 배우는 산술과 같은 방식으로 동작하는 산술을 반드시 제공해야 한다.\" -- 십진 산술 명세에서 발췌."

#: ../../library/decimal.rst:42
#, fuzzy
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
"``1.1`` and ``2.2`` do not have exact representations in binary floating "
"point. End users typically would not expect ``1.1 + 2.2`` to display as "
"``3.3000000000000003`` as it does with binary floating point."
msgstr ""
"Decimal 수는 정확하게 표현할 수 있습니다. 반면에, :const:`1.1`\\과 :const:`2.2`\\와 같은 수는, "
"이진 부동 소수점으로 정확히 표현할 수 없습니다. 최종 사용자는 일반적으로 이진 부동 소수점에서 그러하듯이 ``1.1 + 2.2``"
" 가 :const:`3.3000000000000003`\\처럼 표시되는 것을 기대하지 않을 것입니다."

#: ../../library/decimal.rst:47
#, fuzzy
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is ``5.5511151231257827e-017``.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting "
"applications which have strict equality invariants."
msgstr ""
"정확성은 산술에서도 유지됩니다. 십진 부동 소수점에서, ``0.1 + 0.1 + 0.1 - 0.3`` 는 정확하게 0과 같습니다. "
"이진 부동 소수점에서, 결과는 :const:`5.5511151231257827e-017` 입니다. 0에 가깝지만, 차이가 신뢰할 수"
" 있는 동등성 검사를 방해하고, 차이는 누적 될 수 있습니다. 이러한 이유로, 강한 동등성 불변 조건을 갖는 회계 응용 "
"프로그램에서는 decimal이 선호됩니다."

#: ../../library/decimal.rst:54
#, fuzzy
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is ``2.50``.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary "
"applications. For multiplication, the \"schoolbook\" approach uses all "
"the figures in the multiplicands.  For instance, ``1.3 * 1.2`` gives "
"``1.56`` while ``1.30 * 1.20`` gives ``1.5600``."
msgstr ""
"decimal 모듈은 유효 자릿수의 개념을 포함하고 있으므로 ``1.30 + 1.20`` 은 :const:`2.50` 입니다. 후행"
" 0은 유효성을 나타내기 위해 유지됩니다. 이것은 화폐 응용에서는 관례적인 표현입니다. 곱셈의 경우, \"교과서\" 접근법은 "
"피승수의 모든 숫자를 사용합니다. 예를 들어 ``1.3 * 1.2`` 는 :const:`1.56` 이고, ``1.30 * "
"1.20`` 은 :const:`1.5600` 입니다."

#: ../../library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a "
"user alterable precision (defaulting to 28 places) which can be as large "
"as needed for a given problem:"
msgstr ""
"하드웨어 기반 이진 부동 소수점과는 달리, decimal 모듈은 사용자가 변경할 수 있는 정밀도(기본값은 28자리)를 가지며, "
"주어진 문제에 따라 필요한 만큼 커질 수 있습니다:"

#: ../../library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of "
"published standards.  While the built-in float type exposes only a modest"
" portion of its capabilities, the decimal module exposes all required "
"parts of the standard. When needed, the programmer has full control over "
"rounding and signal handling. This includes an option to enforce exact "
"arithmetic by using exceptions to block any inexact operations."
msgstr ""
"이진 및 십진 부동 소수점 모두 출판된 표준에 따라 구현됩니다. 내장 float 형이 기능의 적당한 부분만을 드러내지만, "
"decimal 모듈은 표준의 모든 필수 부분을 노출합니다. 필요한 경우, 프로그래머는 자리 올림(rounding) 및 "
"신호(signal) 처리를 완전히 제어할 수 있습니다. 여기에는 정확하지 않은 연산을 차단하기 위한 예외를 사용하여 정확한 산술을 "
"강제하는 옵션이 포함됩니다."

#: ../../library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both "
"exact unrounded decimal arithmetic (sometimes called fixed-point "
"arithmetic) and rounded floating-point arithmetic.\"  -- excerpt from the"
" decimal arithmetic specification."
msgstr ""
"decimal 모듈은 \"편견 없이, (때로 고정 소수점 산술이라고도 불리는) 정확한 자리 올림 없는 십진 산술과 자리 올림 있는 "
"부동 소수점 산술을 모두\" 지원하도록 설계되었습니다. -- 십진 산술 명세에서 발췌."

#: ../../library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number,"
" the context for arithmetic, and signals."
msgstr "모듈 설계의 중심 개념은 세 가지입니다: 십진수, 산술을 위한 컨텍스트, 신호(signal)."

#: ../../library/decimal.rst:88
#, fuzzy
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an"
" exponent.  To preserve significance, the coefficient digits do not "
"truncate trailing zeros.  Decimals also include special values such as "
"``Infinity``, ``-Infinity``, and ``NaN``.  The standard also "
"differentiates ``-0`` from ``+0``."
msgstr ""
"decimal 수는 불변입니다. 부호(sign), 계수(coefficient digits) 및 지수(exponent)로 구성됩니다."
" 유효성을 유지하기 위해, 계수는 후행 0을 자르지 않습니다. Decimal은 또한 :const:`Infinity`, "
":const:`-Infinity`, :const:`NaN` 과 같은 특별한 값을 포함합니다. 표준은 또한 :const:`-0`\\을"
" :const:`+0`\\과 구별합니다."

#: ../../library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, "
"rounding rules, limits on exponents, flags indicating the results of "
"operations, and trap enablers which determine whether signals are treated"
" as exceptions.  Rounding options include :const:`ROUND_CEILING`, "
":const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, "
":const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:`ROUND_UP`, and "
":const:`ROUND_05UP`."
msgstr ""
"산술 컨텍스트는 정밀도, 자리 올림 규칙, 지수에 대한 제한, 연산 결과를 나타내는 플래그 및 신호가 예외로 처리될지를 결정하는 "
"트랩 활성화기(trap enabler)를 지정하는 환경입니다. 자리 올림 옵션에는 :const:`ROUND_CEILING`, "
":const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, "
":const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:`ROUND_UP` 및 "
":const:`ROUND_05UP` 가 있습니다."

#: ../../library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of"
" computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The "
"signals in the decimal module are: :const:`Clamped`, "
":const:`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, "
":const:`Rounded`, :const:`Subnormal`, :const:`Overflow`, "
":const:`Underflow` and :const:`FloatOperation`."
msgstr ""
"신호는 계산 과정에서 발생하는 예외적인 조건의 그룹입니다. 응용 프로그램의 필요에 따라, 신호가 무시되거나, 정보로 간주하거나, "
"예외로 처리될 수 있습니다. decimal 모듈의 신호는 :const:`Clamped`, "
":const:`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, "
":const:`Rounded`, :const:`Subnormal`, :const:`Overflow`, "
":const:`Underflow`, :const:`FloatOperation` 입니다."

#: ../../library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to "
"reset them before monitoring a calculation."
msgstr ""
"각 신호에는 플래그와 트랩 활성화기가 있습니다. 신호와 만났을 때, 플래그가 1로 설정되고 트랩 활성화기가 1로 설정된 경우, "
"예외가 발생합니다. 플래그는 상태가 유지되므로(sticky) 계산을 감시하기 전에 재설정할 필요가 있습니다."

#: ../../library/decimal.rst:116
#, fuzzy
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification "
"<https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"IBM의 일반 십진 산술 명세, `The General Decimal Arithmetic Specification "
"<http://speleotrove.com/decimal/decarith.html>`_."

#: ../../library/decimal.rst:125
msgid "Quick-start Tutorial"
msgstr "빠른 시작 자습서"

#: ../../library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"decimal을 사용하는 일반적인 시작은 모듈을 임포트하고, :func:`getcontext` 로 현재 컨텍스트를 보고, 필요하다면"
" 정밀도, 자리 올림 또는 활성화된 트랩에 대해 새 값을 설정하는 것입니다::"

#: ../../library/decimal.rst:131
msgid ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # Set a new precision"
msgstr ""

#: ../../library/decimal.rst:139
#, fuzzy
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact "
"conversion of the value of that integer or float.  Decimal numbers "
"include special values such as ``NaN`` which stands for \"Not a number\","
" positive and negative ``Infinity``, and ``-0``::"
msgstr ""
"Decimal 인스턴스는 정수, 문자열, 실수(float) 또는 튜플로 만들 수 있습니다. 정수 나 실수로 만들면 해당 정수 또는 "
"실수의 정확한 값 변환이 일어납니다. Decimal 수는 \"숫자가 아님(Not a number)\"을 나타내는 "
":const:`NaN`, 양과 음의 :const:`Infinity` 및 :const:`-0`\\과 같은 특수한 값을 포함합니다::"

#: ../../library/decimal.rst:145
msgid ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3.14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2.0 ** 0.5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"
msgstr ""

#: ../../library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
":exc:`FloatOperation` 신호를 트랩 하는 경우, 실수로 생성자나 대소비교에서 Decimal 수와 실수(float)를"
" 혼합하면 예외가 발생합니다::"

#: ../../library/decimal.rst:167
msgid ""
">>> c = getcontext()\n"
">>> c.traps[FloatOperation] = True\n"
">>> Decimal(3.14)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') < 3.7\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') == 3.5\n"
"True"
msgstr ""

#: ../../library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"새로운 Decimal의 유효 숫자는 입력된 숫자의 개수에 의해서만 결정됩니다. 컨텍스트 정밀도 및 자리 올림은 오직 산술 연산 "
"중에만 작용합니다."

#: ../../library/decimal.rst:186
msgid ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"
msgstr ""

#: ../../library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a "
"decimal raises :class:`InvalidOperation`::"
msgstr "C 버전의 내부 제한을 초과하면, Decimal 을 만들 때 :class:`InvalidOperation` 를 일으킵니다::"

#: ../../library/decimal.rst:202
msgid ""
">>> Decimal(\"1e9999999999999999999\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"
msgstr ""

#: ../../library/decimal.rst:209
#, fuzzy
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating-point flying circus:"
msgstr "Decimal은 파이썬의 다른 부분들과 잘 어울립니다. 다음은 십진 부동 소수점으로 부린 작은 묘기입니다:"

#: ../../library/decimal.rst:212
msgid ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 "
"9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> round(a, 1)\n"
"Decimal('1.3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"
msgstr ""

#: ../../library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr "그리고 Decimal에는 몇 가지 수학 함수도 있습니다:"

#: ../../library/decimal.rst:253
#, fuzzy
msgid ""
"The :meth:`~Decimal.quantize` method rounds a number to a fixed exponent."
"  This method is useful for monetary applications that often round "
"results to a fixed number of places:"
msgstr ""
":meth:`quantize` 메서드는 숫자를 고정된 지수로 자리 올림 합니다. 이 방법은 종종 결과를 고정된 자릿수로 자리 올림 "
"하는 화폐 응용에 유용합니다.:"

#: ../../library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current "
"context and allows the settings to be changed.  This approach meets the "
"needs of most applications."
msgstr ""
"위에서 보듯이, :func:`getcontext` 함수는 현재 컨텍스트에 액세스하고 설정을 변경할 수 있게 합니다. 이 방법은 "
"대부분 응용 프로그램의 요구를 충족시킵니다."

#: ../../library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts "
"using the Context() constructor.  To make an alternate active, use the "
":func:`setcontext` function."
msgstr ""
"고급 작업을 위해, Context() 생성자를 사용하여 대체 컨텍스트를 만드는 것이 유용할 수 있습니다. 대체 컨텍스트를 "
"활성화하려면, :func:`setcontext` 함수를 사용하십시오."

#: ../../library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and "
":const:`ExtendedContext`. The former is especially useful for debugging "
"because many of the traps are enabled:"
msgstr ""
"표준에 따라, :mod:`decimal` 모듈은 당장 사용할 수 있는 두 개의 표준 컨텍스트 :const:`BasicContext`"
" 와 :const:`ExtendedContext` 를 제공합니다. 특히 전자는 많은 트랩이 활성화되어있어 디버깅에 유용합니다:"

#: ../../library/decimal.rst:275
msgid ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')"
"\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""

#: ../../library/decimal.rst:299
#, fuzzy
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`~Context.clear_flags` method. ::"
msgstr ""
"컨텍스트에는 계산 중에 발생하는 예외 조건을 감시하기 위한 신호 플래그도 있습니다. 플래그는 명시적으로 지워질 때까지 설정된 상태로"
" 유지되므로, :meth:`clear_flags` 메서드를 사용하여 모니터링되는 각 계산 집합 앞에서 플래그를 지우는 것이 가장 "
"좋습니다. ::"

#: ../../library/decimal.rst:304
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])"
msgstr ""

#: ../../library/decimal.rst:312
#, fuzzy
msgid ""
"The *flags* entry shows that the rational approximation to pi was rounded"
" (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr ""
"*flags* 엔트리는 :const:`Pi` 에 대한 유리수 근삿값이 자리 올림 되었고 (컨텍스트 정밀도 이상의 숫자가 "
"버려졌습니다) 결과가 부정확하다는 (폐기된 숫자 일부는 0이 아닙니다) 것을 보여줍니다."

#: ../../library/decimal.rst:316
#, fuzzy
msgid ""
"Individual traps are set using the dictionary in the "
":attr:`~Context.traps` attribute of a context:"
msgstr "개별 트랩은 컨텍스트의 :attr:`traps` 필드에 있는 딕셔너리를 사용해서 설정합니다.:"

#: ../../library/decimal.rst:319
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""

#: ../../library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of "
"the program.  And, in many applications, data is converted to "
":class:`Decimal` with a single cast inside a loop.  With context set and "
"decimals created, the bulk of the program manipulates the data no "
"differently than with other Python numeric types."
msgstr ""
"대부분 프로그램은 프로그램 시작 시에 한 번만 현재 컨텍스트를 조정합니다. 그리고, 많은 응용 프로그램에서, 데이터는 루프 내에서 "
"단일형변환으로 :class:`Decimal`\\로 변환되어, 프로그램 대부분은 다른 파이썬 숫자 형과 별로 다르지 않게 데이터를 "
"조작합니다."

#: ../../library/decimal.rst:343
msgid "Decimal objects"
msgstr "Decimal 객체"

#: ../../library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "*value* 를 기반으로 새 :class:`Decimal` 객체를 만듭니다."

#: ../../library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another "
":class:`Decimal` object. If no *value* is given, returns "
"``Decimal('0')``.  If *value* is a string, it should conform to the "
"decimal numeric string syntax after leading and trailing whitespace "
"characters, as well as underscores throughout, are removed::"
msgstr ""
"*value* 는 정수, 문자열, 튜플, :class:`float` 또는 다른 :class:`Decimal` 객체일 수 있습니다. "
"*value* 가 주어지지 않으면, ``Decimal('0')`` 을 반환합니다. *value* 가 문자열이면, 앞뒤의 공백 문자 "
"및 밑줄이 제거된 후 십진수 문자열 문법에 맞아야 합니다::"

#: ../../library/decimal.rst:355
msgid ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' |"
" '9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"
msgstr ""

#: ../../library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth "
"digits ``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"위의 ``digit`` 가 나타나는 곳에는 다른 유니코드 십진수도 허용됩니다. 여기에는 다양한 다른 알파벳(예를 들어, "
"인도-아라비아와 데바나가리 숫자)의 십진수와 전각 숫자 ``'\\uff10'`` 에서 ``'\\uff19'`` 까지 포함됩니다."

#: ../../library/decimal.rst:371
#, fuzzy
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(``0`` for positive or ``1`` for negative), a :class:`tuple` of digits, "
"and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` "
"returns ``Decimal('1.414')``."
msgstr ""
"*value* 가 :class:`tuple` 이면, 세 개의 항목으로 구성되어야 합니다, 부호 (:const:`0` 은 양수, "
":const:`1` 은 음수), 숫자의 :class:`tuple`, 정수 지수. 예를 들어, ``Decimal((0, (1, 4, "
"1, 4), -3))`` 은 ``Decimal('1.414')`` 를 반환합니다."

#: ../../library/decimal.rst:376
#, fuzzy
msgid ""
"If *value* is a :class:`float`, the binary floating-point value is "
"losslessly converted to its exact decimal equivalent.  This conversion "
"can often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"*value* 가 :class:`float` 면, 이진 부동 소수점 값은 손실 없이 정확한 십진수로 변환됩니다. 이 변환에는 종종 "
"53자리 이상의 정밀도가 필요할 수 있습니다. 예를 들어, ``Decimal(float('1.1'))`` 은 "
"``Decimal('1.100000000000000088817841970012523233890533447265625')`` 로 "
"변환됩니다."

#: ../../library/decimal.rst:382
msgid ""
"The *context* precision does not affect how many digits are stored. That "
"is determined exclusively by the number of digits in *value*. For "
"example, ``Decimal('3.00000')`` records all five zeros even if the "
"context precision is only three."
msgstr ""
"*context* 정밀도는 저장되는 자릿수에 영향을 주지 않습니다. 저장되는 자릿수는 *value* 의 자릿수만으로 결정됩니다. "
"예를 들어 ``Decimal('3.00000')`` 은 컨텍스트 정밀도가 단지 3이라도 5개의 모든 0을 기록합니다."

#: ../../library/decimal.rst:387
#, fuzzy
msgid ""
"The purpose of the *context* argument is determining what to do if "
"*value* is a malformed string.  If the context traps "
":const:`InvalidOperation`, an exception is raised; otherwise, the "
"constructor returns a new Decimal with the value of ``NaN``."
msgstr ""
"*context* 인자의 목적은 *value* 가 잘못된 문자열인 경우 어떻게 해야할지를 결정하는 것입니다. 컨텍스트가 "
":const:`InvalidOperation` 을 트랩하면, 예외가 발생합니다; 그렇지 않으면, 생성자는 :const:`NaN` 의"
" 값을 갖는 새 Decimal을 반환합니다."

#: ../../library/decimal.rst:392
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "일단 만들어지면, :class:`Decimal` 객체는 불변입니다."

#: ../../library/decimal.rst:394
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr "생성자에 대한 인자는 이제 :class:`float` 인스턴스가 될 수 있습니다."

#: ../../library/decimal.rst:398
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
":class:`float` 인자는 :exc:`FloatOperation` 트랩이 설정되면 예외를 발생시킵니다. 기본적으로 트랩은 "
"꺼져 있습니다."

#: ../../library/decimal.rst:402
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point"
" literals in code."
msgstr "코드에서의 정수와 부동 소수점 리터럴과 마찬가지로, 밑줄로 무리 지을 수 있습니다."

#: ../../library/decimal.rst:406
#, fuzzy
msgid ""
"Decimal floating-point objects share many properties with the other "
"built-in numeric types such as :class:`float` and :class:`int`.  All of "
"the usual math operations and special methods apply.  Likewise, decimal "
"objects can be copied, pickled, printed, used as dictionary keys, used as"
" set elements, compared, sorted, and coerced to another type (such as "
":class:`float` or :class:`int`)."
msgstr ""
"십진 부동 소수점 객체는 :class:`float`\\나 :class:`int`\\와 같은 다른 내장 숫자 형과 많은 성질을 "
"공유합니다. 일반적인 수학 연산과 특수 메서드가 모두 적용됩니다. 마찬가지로, 십진 객체는 복사, 피클, 인쇄, 딕셔너리 키로 "
"사용, 집합 원소로 사용, 비교, 정렬 및 다른 형(가령 :class:`float` 또는 :class:`int`)으로 코어션될 수 "
"있습니다."

#: ../../library/decimal.rst:413
msgid ""
"There are some small differences between arithmetic on Decimal objects "
"and arithmetic on integers and floats.  When the remainder operator ``%``"
" is applied to Decimal objects, the sign of the result is the sign of the"
" *dividend* rather than the sign of the divisor::"
msgstr ""
"Decimal 객체에 대한 산술과 정수 및 실수에 대한 산술에는 약간의 차이가 있습니다. Decimal 객체에 나머지 연산자 "
"``%`` 가 적용될 때, 결과의 부호는 제수의 부호가 아닌 *피제수*\\의 부호가 됩니다::"

#: ../../library/decimal.rst:418
msgid ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"
msgstr ""

#: ../../library/decimal.rst:423
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than "
"its floor, so as to preserve the usual identity ``x == (x // y) * y + x %"
" y``::"
msgstr ""
"정수 나눗셈 연산자 ``//`` 의 동작 역시 비슷한 차이를 보입니다. 즉, 가장 가까운 정수로 내림하는 대신 실제 몫의 정수 "
"부(0을 향해 자르기)를 돌려줍니다. 그래서 일반적인 항등식 ``x == (x // y) * y + x % y`` 를 유지합니다::"

#: ../../library/decimal.rst:427
msgid ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"
msgstr ""

#: ../../library/decimal.rst:432
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"``%`` 와 ``//`` 연산자는 명세에 설명된 대로 각각 ``remainder`` 와 ``divide-integer`` 연산을 "
"구현합니다."

#: ../../library/decimal.rst:436
msgid ""
"Decimal objects cannot generally be combined with floats or instances of "
":class:`fractions.Fraction` in arithmetic operations: an attempt to add a"
" :class:`Decimal` to a :class:`float`, for example, will raise a "
":exc:`TypeError`.  However, it is possible to use Python's comparison "
"operators to compare a :class:`Decimal` instance ``x`` with another "
"number ``y``.  This avoids confusing results when doing equality "
"comparisons between numbers of different types."
msgstr ""
"Decimal 객체는 일반적으로 산술 연산에서 float 나 :class:`fractions.Fraction` 인스턴스와 결합 할 "
"수 없습니다: 예를 들어, :class:`float` 에 a :class:`Decimal`\\을 더하려고 하면 "
":exc:`TypeError` 를 일으킵니다. 그러나, 파이썬의 비교 연산자를 사용하여 :class:`Decimal` 인스턴스 "
"``x`` 와 다른 숫자 ``y`` 를 비교할 수 있습니다. 이렇게 해서 서로 다른 형의 숫자 간에 동등 비교를 할 때 혼란스러운 "
"결과를 피합니다."

#: ../../library/decimal.rst:444
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other "
"numeric types are now fully supported."
msgstr ":class:`Decimal` 인스턴스와 다른 숫자 형 사이의 혼합형 비교가 이제 완전히 지원됩니다."

#: ../../library/decimal.rst:448
#, fuzzy
msgid ""
"In addition to the standard numeric properties, decimal floating-point "
"objects also have a number of specialized methods:"
msgstr "표준 숫자 속성에 더해, 십진 부동 소수점 객체에는 여러 가지 특별한 메서드가 있습니다:"

#: ../../library/decimal.rst:454
msgid ""
"Return the adjusted exponent after shifting out the coefficient's "
"rightmost digits until only the lead digit remains: "
"``Decimal('321e+5').adjusted()`` returns seven.  Used for determining the"
" position of the most significant digit with respect to the decimal "
"point."
msgstr ""
"최상위 숫자만 남을 때까지 계수의 가장 오른쪽 숫자들을 밀어내도록 조정된 지수를 반환합니다. "
"``Decimal('321e+5').adjusted()`` 는 7을 반환합니다. 소수점으로부터의 최상위 유효 숫자의 위치를 결정하는"
" 데 사용됩니다."

#: ../../library/decimal.rst:461
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given "
":class:`Decimal` instance as a fraction, in lowest terms and with a "
"positive denominator::"
msgstr "주어진 :class:`Decimal` 인스턴스를, 분모가 양수인 기약 분수로 나타내는 정수의 쌍 ``(n, d)`` 을 돌려줍니다::"

#: ../../library/decimal.rst:465
msgid ""
">>> Decimal('-3.14').as_integer_ratio()\n"
"(-157, 50)"
msgstr ""

#: ../../library/decimal.rst:468
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and "
"ValueError on NaNs."
msgstr "변환은 정확합니다. 무한대는 OverflowError를, NaN 은 ValueError를 일으킵니다."

#: ../../library/decimal.rst:475
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"숫자의 :term:`네임드 튜플 <named tuple>` 표현을 반환합니다: ``DecimalTuple(sign, digits, "
"exponent)``."

#: ../../library/decimal.rst:481
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding "
"of a :class:`Decimal` instance is always canonical, so this operation "
"returns its argument unchanged."
msgstr ""
"인자의 규범적인 인코딩을 돌려줍니다. 현재 :class:`Decimal` 인스턴스의 인코딩은 항상 규범적이므로, 이 연산은 인자를 "
"변경하지 않고 반환합니다."

#: ../../library/decimal.rst:487
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a "
"NaN::"
msgstr ""
"두 Decimal 인스턴스의 값을 비교합니다. :meth:`compare` 는 Decimal 인스턴스를 반환하고, 피연산자 중 "
"하나가 NaN이면 결과는 NaN입니다::"

#: ../../library/decimal.rst:491
msgid ""
"a or b is a NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"
msgstr ""

#: ../../library/decimal.rst:498
msgid ""
"This operation is identical to the :meth:`compare` method, except that "
"all NaNs signal.  That is, if neither operand is a signaling NaN then any"
" quiet NaN operand is treated as though it were a signaling NaN."
msgstr ""
"이 연산은, 모든 NaN 이 신호를 준다는 것을 제외하면 :meth:`compare` 메서드와 같습니다. 즉, 피연산자가 모두 "
"신호를 주는 NaN이 아니면, 모든 조용한 NaN 피연산자가 마치 신호를 주는 NaN 인 것처럼 처리됩니다."

#: ../../library/decimal.rst:504
msgid ""
"Compare two operands using their abstract representation rather than "
"their numerical value.  Similar to the :meth:`compare` method, but the "
"result gives a total ordering on :class:`Decimal` instances.  Two "
":class:`Decimal` instances with the same numeric value but different "
"representations compare unequal in this ordering:"
msgstr ""
"두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교합니다. :meth:`compare` 메서드와 비슷하지만, 결과는 "
":class:`Decimal` 인스턴스에 대해 전 순서(total ordering)를 부여합니다. 같은 숫자 값을 갖지만 다른 "
"표현의 두 :class:`Decimal` 인스턴스는 이 순서에 의해 다른 것으로 비교됩니다:"

#: ../../library/decimal.rst:513
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the "
"same representation, ``Decimal('-1')`` if the first operand is lower in "
"the total order than the second, and ``Decimal('1')`` if the first "
"operand is higher in the total order than the second operand.  See the "
"specification for details of the total order."
msgstr ""
"조용한 NaN과 신호를 주는 NaN도 전 순서에 포함됩니다. 이 함수의 결과는, 두 피연산자가 같은 표현을 가질 때 "
"``Decimal('0')``, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 낮으면 ``Decimal('-1')``, 첫 "
"번째 피연산자가 전 순서에서 두 번째 피연산자보다 높으면 ``Decimal('1')`` 입니다. 전 순서에 대한 세부 사항은 명세를"
" 참조하십시오."

#: ../../library/decimal.rst:520 ../../library/decimal.rst:531
#: ../../library/decimal.rst:559 ../../library/decimal.rst:846
msgid ""
"This operation is unaffected by context and is quiet: no flags are "
"changed and no rounding is performed.  As an exception, the C version may"
" raise InvalidOperation if the second operand cannot be converted "
"exactly."
msgstr ""
"이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. "
"예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다."

#: ../../library/decimal.rst:526
msgid ""
"Compare two operands using their abstract representation rather than "
"their value as in :meth:`compare_total`, but ignoring the sign of each "
"operand. ``x.compare_total_mag(y)`` is equivalent to "
"``x.copy_abs().compare_total(y.copy_abs())``."
msgstr ""
":meth:`compare_total`\\처럼 두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교하지만, 각 피연산자의 "
"부호를 무시합니다. ``x.compare_total_mag(y)`` 는 "
"``x.copy_abs().compare_total(y.copy_abs())`` 와 동등합니다."

#: ../../library/decimal.rst:537
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr "그냥 self를 돌려줍니다. 이 메서드는 Decimal 명세를 준수하기 위한 것뿐입니다."

#: ../../library/decimal.rst:542
msgid ""
"Return the absolute value of the argument.  This operation is unaffected "
"by the context and is quiet: no flags are changed and no rounding is "
"performed."
msgstr ""
"인자의 절댓값을 반환합니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 "
"수행되지 않습니다."

#: ../../library/decimal.rst:548
msgid ""
"Return the negation of the argument.  This operation is unaffected by the"
" context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"인자의 음의 부정을 돌려줍니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 "
"올림도 수행되지 않습니다."

#: ../../library/decimal.rst:553
msgid ""
"Return a copy of the first operand with the sign set to be the same as "
"the sign of the second operand.  For example:"
msgstr "두 번째 피연산자의 부호와 같은 부호로 설정된 첫 번째 피연산자의 복사본을 반환합니다. 예를 들어:"

#: ../../library/decimal.rst:565
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the "
"given number.  The result is correctly rounded using the "
":const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"주어진 숫자에 대한 (자연) 지수 함수 ``e**x`` 의 값을 반환합니다. 결과는 :const:`ROUND_HALF_EVEN` "
"자리 올림 모드를 사용하여 올바르게 자리 올림 됩니다."

#: ../../library/decimal.rst:576
msgid ""
"Alternative constructor that only accepts instances of :class:`float` or "
":class:`int`."
msgstr ""

#: ../../library/decimal.rst:579
#, fuzzy
msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the "
"value is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""
"`Decimal.from_float(0.1)` 은 `Decimal('0.1')`\\과 같지 않음에 유의하십시오. 0.1은 이진 부동"
" 소수점에서 정확하게 표현할 수 없으므로, 값은 가장 가까운 표현 가능 값인 `0x1.999999999999ap-4`\\로 "
"저장됩니다. 십진수로 표시된 해당 값은 "
"`0.1000000000000000055511151231257827021181583404541015625` 입니다."

#: ../../library/decimal.rst:585
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be "
"constructed directly from a :class:`float`."
msgstr "파이썬 3.2 이후부터는, :class:`Decimal` 인스턴스를 :class:`float`\\에서 직접 생성할 수 있습니다."

#: ../../library/decimal.rst:588
msgid ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Infinity')"
msgstr ""

#: ../../library/decimal.rst:603
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"합성된 곱셈-덧셈(fused multiply-add). 중간값 self*other의 자리 올림 없이 self*other+third를"
" 반환합니다."

#: ../../library/decimal.rst:611
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, "
"so this operation always returns :const:`True`."
msgstr ""
"인자가 규범적이면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다. 현재 "
":class:`Decimal` 인스턴스는 항상 규범적이므로 이 연산은 항상 :const:`True`\\를 반환합니다."

#: ../../library/decimal.rst:617
msgid ""
"Return :const:`True` if the argument is a finite number, and "
":const:`False` if the argument is an infinity or a NaN."
msgstr "인자가 유한 수이면 :const:`True`\\를 반환하고, 인자가 무한대나 NaN 이면 :const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:622
msgid ""
"Return :const:`True` if the argument is either positive or negative "
"infinity and :const:`False` otherwise."
msgstr "인자가 양이나 음의 무한대면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:627
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and "
":const:`False` otherwise."
msgstr ""
"인자가 (조용한 또는 신호를 주는) NaN이면 :const:`True`\\를 반환하고, 그렇지 않으면 "
":const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:632
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return"
" :const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"인자가 *정상(normal)* 유한 수이면 :const:`True`\\를 반환합니다. 인자가 0, 비정상(subnormal), "
"무한대 또는 NaN 이면 :const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:637
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr "인자가 조용한 NaN이면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:642
msgid ""
"Return :const:`True` if the argument has a negative sign and "
":const:`False` otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"인자가 음의 부호를 가지면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다. 0과"
" NaN 모두 부호를 가질 수 있다는 것에 유의하세요."

#: ../../library/decimal.rst:647
msgid ""
"Return :const:`True` if the argument is a signaling NaN and "
":const:`False` otherwise."
msgstr "인자가 신호를 주는 NaN이면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:652
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"인자가 비정상(subnormal)이면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 "
"반환합니다."

#: ../../library/decimal.rst:657
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and"
" :const:`False` otherwise."
msgstr "인자가 (양 또는 음의) 0이면 :const:`True`\\를 반환하고, 그렇지 않으면 :const:`False`\\를 반환합니다."

#: ../../library/decimal.rst:662
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"피연산자의 자연로그(밑 e)를 반환합니다. 결과는 :const:`ROUND_HALF_EVEN` 자리 올림 모드를 사용하여 올바르게 "
"반올림됩니다."

#: ../../library/decimal.rst:667
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"피연산자의 상용로그를 반환합니다. 결과는 :const:`ROUND_HALF_EVEN` 자리 올림 모드를 사용하여 올바르게 "
"반올림됩니다."

#: ../../library/decimal.rst:672
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a "
":class:`Decimal` instance.  If the operand is a zero then "
"``Decimal('-Infinity')`` is returned and the :const:`DivisionByZero` flag"
" is raised.  If the operand is an infinity then ``Decimal('Infinity')`` "
"is returned."
msgstr ""
"0이 아닌 수의 경우, 피연산자의 조정된 지수를 :class:`Decimal` 인스턴스로 반환합니다. 피연산자가 0이면 "
"``Decimal('-Infinity')`` 가 반환되고 :const:`DivisionByZero` 플래그가 발생합니다. 피연산자가"
" 무한대면 ``Decimal('Infinity')`` 가 반환됩니다."

#: ../../library/decimal.rst:680
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-"
"wise ``and`` of the two operands."
msgstr ""
":meth:`logical_and` 는 두 개의 *논리적 피연산자*\\(:ref:`logical_operands_label`\\를 "
"보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 ``and`` 입니다."

#: ../../library/decimal.rst:686
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-"
"wise inversion of the operand."
msgstr ":meth:`logical_invert` 는 논리적 연산입니다. 결과는 피연산자의 자릿수별 반전입니다."

#: ../../library/decimal.rst:691
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-"
"wise ``or`` of the two operands."
msgstr ""
":meth:`logical_or` 는 두 개의 *논리적 피연산자*\\(:ref:`logical_operands_label`\\를 "
"보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 ``or`` 입니다."

#: ../../library/decimal.rst:697
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-"
"wise exclusive or of the two operands."
msgstr ""
":meth:`logical_xor`\\은 두 개의 *논리적 피연산자*\\(:ref:`logical_operands_label`\\를"
" 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 배타적 or입니다."

#: ../../library/decimal.rst:703
#, fuzzy
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is "
"applied before returning and that ``NaN`` values are either signaled or "
"ignored (depending on the context and whether they are signaling or "
"quiet)."
msgstr ""
"컨텍스트 자리 올림 규칙이 반환되기 전에 적용되고 :const:`NaN` 값이 (컨텍스트와 신호를 주는지 조용한지에 따라) 신호를 "
"주거나 무시되는 것을 제외하고 ``max(self, other)`` 와 같습니다."

#: ../../library/decimal.rst:710
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ":meth:`.max`\\와 비슷하지만, 피연산자의 절댓값을 사용하여 비교가 이루어집니다."

#: ../../library/decimal.rst:715
#, fuzzy
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is "
"applied before returning and that ``NaN`` values are either signaled or "
"ignored (depending on the context and whether they are signaling or "
"quiet)."
msgstr ""
"컨텍스트 자리 올림 규칙이 반환되기 전에 적용되고 :const:`NaN` 값이 (컨텍스트와 신호를 주는지 조용한지에 따라) 신호를 "
"주거나 무시되는 것을 제외하고 ``min(self, other)`` 와 같습니다."

#: ../../library/decimal.rst:722
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ":meth:`.min`\\과 비슷하지만, 피연산자의 절댓값을 사용하여 비교가 이루어집니다."

#: ../../library/decimal.rst:727
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the"
" given operand."
msgstr ""
"주어진 피연산자보다 작고, 주어진 컨텍스트(또는 context가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 큰 "
"수를 돌려줍니다."

#: ../../library/decimal.rst:733
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"주어진 피연산자보다 크고, 주어진 컨텍스트(또는 context가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 작은"
" 수를 돌려줍니다."

#: ../../library/decimal.rst:739
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set "
"to be the same as the sign of the second operand."
msgstr ""
"두 피연산자가 같지 않으면, 두 번째 피연산자의 방향으로 첫 번째 피연산자에 가장 가까운 숫자를 반환합니다. 두 피연산자가 수치로 "
"같으면, 첫 번째 피연산자의 복사본을 반환하는데, 부호를 두 번째 피연산자의 것으로 설정합니다."

#: ../../library/decimal.rst:746
msgid ""
"Used for producing canonical values of an equivalence class within either"
" the current context or the specified context."
msgstr ""

#: ../../library/decimal.rst:749
msgid ""
"This has the same semantics as the unary plus operation, except that if "
"the final result is finite it is reduced to its simplest form, with all "
"trailing zeros removed and its sign preserved. That is, while the "
"coefficient is non-zero and a multiple of ten the coefficient is divided "
"by ten and the exponent is incremented by 1. Otherwise (the coefficient "
"is zero) the exponent is set to 0. In all cases the sign is unchanged."
msgstr ""

#: ../../library/decimal.rst:756
msgid ""
"For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both "
"normalize to the equivalent value ``Decimal('32.1')``."
msgstr ""

#: ../../library/decimal.rst:759
msgid "Note that rounding is applied *before* reducing to simplest form."
msgstr ""

#: ../../library/decimal.rst:761
msgid ""
"In the latest versions of the specification, this operation is also known"
" as ``reduce``."
msgstr ""

#: ../../library/decimal.rst:766
msgid ""
"Return a string describing the *class* of the operand.  The returned "
"value is one of the following ten strings."
msgstr "피연산자의 *클래스* 를 설명하는 문자열을 반환합니다. 반환 값은 다음 10개의 문자열 중 하나입니다."

#: ../../library/decimal.rst:769
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, 피연산자가 음의 무한대임을 나타냅니다."

#: ../../library/decimal.rst:770
msgid "``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``, 피연산자가 음의 정상 수임을 나타냅니다."

#: ../../library/decimal.rst:771
msgid "``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"``, 피연산자가 음의 비정상 수임을 나타냅니다."

#: ../../library/decimal.rst:772
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, 피연산자가 음의 0임을 나타냅니다."

#: ../../library/decimal.rst:773
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, 피연산자가 양의 0임을 나타냅니다."

#: ../../library/decimal.rst:774
msgid "``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``, 피연산자가 양의 비정상 수임을 나타냅니다."

#: ../../library/decimal.rst:775
msgid "``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``, 피연산자가 양의 정상 수임을 나타냅니다."

#: ../../library/decimal.rst:776
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, 피연산자가 양의 무한대임을 나타냅니다."

#: ../../library/decimal.rst:777
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr "``\"NaN\"``, 피연산자가 조용한 NaN(Not a Number)임을 나타냅니다."

#: ../../library/decimal.rst:778
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, 피연산자가 신호를 주는 NaN임을 나타냅니다."

#: ../../library/decimal.rst:782
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr "자리 올림 후에 첫 번째 피연산자와 같고 두 번째 피연산자의 지수를 갖는 값을 반환합니다."

#: ../../library/decimal.rst:788
msgid ""
"Unlike other operations, if the length of the coefficient after the "
"quantize operation would be greater than precision, then an "
":const:`InvalidOperation` is signaled. This guarantees that, unless there"
" is an error condition, the quantized exponent is always equal to that of"
" the right-hand operand."
msgstr ""
"다른 연산과 달리, quantize 연산 후의 계수의 길이가 정밀도보다 크면, :const:`InvalidOperation` 신호를"
" 줍니다. 이는, 에러 조건이 없으면, quantize 된 지수가 항상 오른쪽 피연산자의 지수와 같음을 보장합니다."

#: ../../library/decimal.rst:794
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if "
"the result is subnormal and inexact."
msgstr ""
"또한, 다른 연산과는 달리, 결과가 비정상(subnormal)이고 부정확한 경우조차도, quantize는 결코 Underflow "
"신호를 보내지 않습니다."

#: ../../library/decimal.rst:797
msgid ""
"If the exponent of the second operand is larger than that of the first "
"then rounding may be necessary.  In this case, the rounding mode is "
"determined by the ``rounding`` argument if given, else by the given "
"``context`` argument; if neither argument is given the rounding mode of "
"the current thread's context is used."
msgstr ""
"두 번째 피연산자의 지수가 첫 번째 피연산자의 지수보다 크면 자리 올림이 필요할 수 있습니다. 이 경우, 자리 올림 모드는 "
"(주어지면) ``rounding`` 인자에 의해 결정됩니다. 그렇지 않으면 주어진 ``context`` 인자에 의해 결정됩니다; 두"
" 인자 모두 주어지지 않으면, 현재 스레드의 컨텍스트의 자리 올림 모드가 사용됩니다."

#: ../../library/decimal.rst:803
#, fuzzy
msgid ""
"An error is returned whenever the resulting exponent is greater than "
":attr:`~Context.Emax` or less than :meth:`~Context.Etiny`."
msgstr "결과 지수가 :attr:`Emax` 보다 크거나 :attr:`Etiny` 보다 작을 때마다 에러가 반환됩니다."

#: ../../library/decimal.rst:808
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` "
"class does all its arithmetic.  Included for compatibility with the "
"specification."
msgstr ""
":class:`Decimal` 클래스가 모든 산술을 수행하는 진수(기수)인 ``Decimal(10)`` 을 반환합니다. 명세와의 "
"호환성을 위해 포함됩니다."

#: ../../library/decimal.rst:814
#, python-format
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self "
"- n * other`` where ``n`` is the integer nearest to the exact value of "
"``self / other``, and if two integers are equally near then the even one "
"is chosen."
msgstr ""
"*self* 를 *other* 로 나눈 나머지를 반환합니다. 이것은 나머지의 절댓값을 최소화하기 위해 나머지의 부호가 선택된다는 "
"점에서 ``self % other`` 와 다릅니다. 좀 더 정확히 말하면, 반환 값은 ``self - n * other`` 인데, "
"여기서 ``n`` 은 ``self / other`` 의 정확한 값에 가장 가까운 정수이고, 두 개의 정수와의 거리가 같으면 짝수가 "
"선택됩니다."

#: ../../library/decimal.rst:821
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "결과가 0이면 그 부호는 *self* 의 부호가 됩니다."

#: ../../library/decimal.rst:832
msgid ""
"Return the result of rotating the digits of the first operand by an "
"amount specified by the second operand.  The second operand must be an "
"integer in the range -precision through precision.  The absolute value of"
" the second operand gives the number of places to rotate.  If the second "
"operand is positive then rotation is to the left; otherwise rotation is "
"to the right. The coefficient of the first operand is padded on the left "
"with zeros to length precision if necessary.  The sign and exponent of "
"the first operand are unchanged."
msgstr ""
"첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 회전한 결과를 반환합니다. 두 번째 피연산자는 -precision에서 "
"precision 범위의 정수여야 합니다. 두 번째 피연산자의 절댓값은 회전할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 "
"왼쪽으로 회전합니다; 그렇지 않으면 오른쪽으로 회전합니다. 필요하면 정밀도에 맞추기 위해 첫 번째 피연산자의 계수에 0이 왼쪽에 "
"채워집니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다."

#: ../../library/decimal.rst:843
#, fuzzy
msgid ""
"Test whether self and other have the same exponent or whether both are "
"``NaN``."
msgstr "self와 other가 같은 지수를 가졌는지 또는 둘 다 :const:`NaN` 인지 검사합니다."

#: ../../library/decimal.rst:852
msgid ""
"Return the first operand with exponent adjusted by the second. "
"Equivalently, return the first operand multiplied by ``10**other``.  The "
"second operand must be an integer."
msgstr ""
"첫 번째 피연산자의 지수를 두 번째 피연산자만큼 조정한 값을 반환합니다. 달리 표현하면, 첫 번째 피연산자에 "
"``10**other`` 를 곱한 값을 반환합니다. 두 번째 피연산자는 정수여야 합니다."

#: ../../library/decimal.rst:858
msgid ""
"Return the result of shifting the digits of the first operand by an "
"amount specified by the second operand.  The second operand must be an "
"integer in the range -precision through precision.  The absolute value of"
" the second operand gives the number of places to shift.  If the second "
"operand is positive then the shift is to the left; otherwise the shift is"
" to the right.  Digits shifted into the coefficient are zeros.  The sign "
"and exponent of the first operand are unchanged."
msgstr ""
"첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 이동한 결과를 반환합니다. 두 번째 피연산자는 -precision에서 "
"precision 범위의 정수여야 합니다. 두 번째 피연산자의 절댓값은 이동할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 "
"왼쪽으로 이동합니다; 그렇지 않으면 오른쪽으로 이동합니다. 이동으로 인해 계수에 들어오는 숫자는 0입니다. 첫 번째 피연산자의 "
"부호와 지수는 변경되지 않습니다."

#: ../../library/decimal.rst:868
msgid "Return the square root of the argument to full precision."
msgstr "인자의 제곱근을 완전한 정밀도로 반환합니다."

#: ../../library/decimal.rst:873 ../../library/decimal.rst:1510
msgid "Convert to a string, using engineering notation if an exponent is needed."
msgstr "문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다."

#: ../../library/decimal.rst:875 ../../library/decimal.rst:1512
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the"
" addition of either one or two trailing zeros."
msgstr ""
"공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3자리를 남기게 되고, 하나나 두 개의 후행 0을 추가해야 "
"할 수 있습니다."

#: ../../library/decimal.rst:879
msgid ""
"For example, this converts ``Decimal('123E+1')`` to "
"``Decimal('1.23E+3')``."
msgstr "예를 들어, 이 메서드는 ``Decimal('123E+1')`` 을 ``Decimal('1.23E+3')`` 으로 변환합니다."

#: ../../library/decimal.rst:883
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` "
"name has been kept for compatibility with older versions."
msgstr ""
":meth:`to_integral_value` 메서드와 같습니다. ``to_integral`` 이름은 이전 버전과의 호환성을 위해 "
"유지되었습니다."

#: ../../library/decimal.rst:888
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or "
":const:`Rounded` as appropriate if rounding occurs.  The rounding mode is"
" determined by the ``rounding`` parameter if given, else by the given "
"``context``.  If neither parameter is given then the rounding mode of the"
" current context is used."
msgstr ""
":const:`Inexact` 나 :const:`Rounded` 신호를 주면서 가장 가까운 정수로 자리 올림 합니다. 자리 올림 "
"모드는 (주어지면) ``rounding`` 매개 변수에 의해, 그렇지 않으면 그렇지 않으면 ``context`` 에 의해 "
"결정됩니다. 두 매개 변수 모두 지정되지 않으면, 현재 컨텍스트의 자리 올림 모드가 사용됩니다."

#: ../../library/decimal.rst:896
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or "
":const:`Rounded`.  If given, applies *rounding*; otherwise, uses the "
"rounding method in either the supplied *context* or the current context."
msgstr ""
":const:`Inexact` 나 :const:`Rounded` 신호를 주지 않고 가장 가까운 정수로 자리 올림 합니다. 주어지면,"
" *rounding* 을 적용합니다; 그렇지 않으면, 제공된 *context* 나 현재 컨텍스트의 자리 올림 방법을 사용합니다."

#: ../../library/decimal.rst:900
msgid "Decimal numbers can be rounded using the :func:`.round` function:"
msgstr ""

#: ../../library/decimal.rst:905
msgid ""
"If *ndigits* is not given or ``None``, returns the nearest :class:`int` "
"to *number*, rounding ties to even, and ignoring the rounding mode of the"
" :class:`Decimal` context.  Raises :exc:`OverflowError` if *number* is an"
" infinity or :exc:`ValueError` if it is a (quiet or signaling) NaN."
msgstr ""

#: ../../library/decimal.rst:911
msgid ""
"If *ndigits* is an :class:`int`, the context's rounding mode is respected"
" and a :class:`Decimal` representing *number* rounded to the nearest "
"multiple of ``Decimal('1E-ndigits')`` is returned; in this case, "
"``round(number, ndigits)`` is equivalent to ``self.quantize(Decimal('1E-"
"ndigits'))``.  Returns ``Decimal('NaN')`` if *number* is a quiet NaN.  "
"Raises :class:`InvalidOperation` if *number* is an infinity, a signaling "
"NaN, or if the length of the coefficient after the quantize operation "
"would be greater than the current context's precision.  In other words, "
"for the non-corner cases:"
msgstr ""

#: ../../library/decimal.rst:921
msgid ""
"if *ndigits* is positive, return *number* rounded to *ndigits* decimal "
"places;"
msgstr ""

#: ../../library/decimal.rst:923
msgid "if *ndigits* is zero, return *number* rounded to the nearest integer;"
msgstr ""

#: ../../library/decimal.rst:924
msgid ""
"if *ndigits* is negative, return *number* rounded to the nearest multiple"
" of ``10**abs(ndigits)``."
msgstr ""

#: ../../library/decimal.rst:927
msgid "For example::"
msgstr ""

#: ../../library/decimal.rst:929
msgid ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().rounding = ROUND_DOWN\n"
">>> round(Decimal('3.75'))     # context rounding ignored\n"
"4\n"
">>> round(Decimal('3.5'))      # round-ties-to-even\n"
"4\n"
">>> round(Decimal('3.75'), 0)  # uses the context rounding\n"
"Decimal('3')\n"
">>> round(Decimal('3.75'), 1)\n"
"Decimal('3.7')\n"
">>> round(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"
msgstr ""

#: ../../library/decimal.rst:946
msgid "Logical operands"
msgstr "논리적 피연산자"

#: ../../library/decimal.rst:948
#, fuzzy
msgid ""
"The :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, "
":meth:`~Decimal.logical_or`, and :meth:`~Decimal.logical_xor` methods "
"expect their arguments to be *logical operands*.  A *logical operand* is "
"a :class:`Decimal` instance whose exponent and sign are both zero, and "
"whose digits are all either ``0`` or ``1``."
msgstr ""
":meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`\\와 "
":meth:`logical_xor` 메서드는 인자가 *논리적 피연산자* 이길 기대합니다. *논리적 피연산자* 는 지수와 부호가 모두"
" 0이고 숫자는 모두 :const:`0` 또는 :const:`1` 인 :class:`Decimal` 인스턴스입니다."

#: ../../library/decimal.rst:960
msgid "Context objects"
msgstr "Context 객체"

#: ../../library/decimal.rst:962
msgid ""
"Contexts are environments for arithmetic operations.  They govern "
"precision, set rules for rounding, determine which signals are treated as"
" exceptions, and limit the range for exponents."
msgstr ""
"컨텍스트는 산술 연산을 위한 환경입니다. 정밀도를 제어하고, 자리 올림 규칙을 설정하며, 어떤 신호가 예외로 처리되는지 결정하고, "
"지수의 범위를 제한합니다."

#: ../../library/decimal.rst:966
msgid ""
"Each thread has its own current context which is accessed or changed "
"using the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"각 스레드는 자신만의 현재 컨텍스트를 가지는데, :func:`getcontext` 와 :func:`setcontext` 함수를 "
"사용하여 액세스하거나 변경합니다:"

#: ../../library/decimal.rst:972
msgid "Return the current context for the active thread."
msgstr "활성 스레드의 현재 컨텍스트를 돌려줍니다."

#: ../../library/decimal.rst:977
msgid "Set the current context for the active thread to *c*."
msgstr "활성 스레드의 현재 컨텍스트를 *c* 로 설정합니다."

#: ../../library/decimal.rst:979
msgid ""
"You can also use the :keyword:`with` statement and the "
":func:`localcontext` function to temporarily change the active context."
msgstr ""
"또한 :keyword:`with` 문과 :func:`localcontext` 함수를 사용하여 활성 컨텍스트를 일시적으로 변경할 수 "
"있습니다."

#: ../../library/decimal.rst:984
#, fuzzy
msgid ""
"Return a context manager that will set the current context for the active"
" thread to a copy of *ctx* on entry to the with-statement and restore the"
" previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used.  The *kwargs* argument "
"is used to set the attributes of the new context."
msgstr ""
"with-문으로 진입할 때 활성 스레드의 현재 컨텍스트를 *ctx* 의 복사본으로 설정하고, with-문을 빠져나올 때 이전의 "
"컨텍스트를 복원하는 컨텍스트 관리자를 돌려줍니다. 컨텍스트를 지정하지 않으면 현재 컨텍스트의 복사본이 사용됩니다."

#: ../../library/decimal.rst:990
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the "
"previous context::"
msgstr "예를 들어, 다음 코드는 현재 십진 정밀도를 42자리로 설정하고, 계산을 수행한 다음, 이전 컨텍스트를 자동으로 복원합니다::"

#: ../../library/decimal.rst:993
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # Perform a high precision calculation\n"
"    s = calculate_something()\n"
"s = +s  # Round the final result back to the default precision"
msgstr ""

#: ../../library/decimal.rst:1000
msgid "Using keyword arguments, the code would be the following::"
msgstr ""

#: ../../library/decimal.rst:1002
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext(prec=42) as ctx:\n"
"    s = calculate_something()\n"
"s = +s"
msgstr ""

#: ../../library/decimal.rst:1008
msgid ""
"Raises :exc:`TypeError` if *kwargs* supplies an attribute that "
":class:`Context` doesn't support.  Raises either :exc:`TypeError` or "
":exc:`ValueError` if *kwargs* supplies an invalid value for an attribute."
msgstr ""

#: ../../library/decimal.rst:1012
msgid ""
":meth:`localcontext` now supports setting context attributes through the "
"use of keyword arguments."
msgstr ""

#: ../../library/decimal.rst:1015
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made "
"contexts:"
msgstr ""
"아래에 설명된 :class:`Context` 생성자를 사용하여 새로운 컨텍스트를 만들 수도 있습니다. 또한, 이 모듈은 세 가지 "
"미리 만들어진 컨텍스트를 제공합니다:"

#: ../../library/decimal.rst:1021
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to "
":const:`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled "
"(treated as exceptions) except :const:`Inexact`, :const:`Rounded`, and "
":const:`Subnormal`."
msgstr ""
"이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 "
":const:`ROUND_HALF_UP`\\으로 설정됩니다. 모든 플래그가 지워집니다. 모든 트랩은 :const:`Inexact`,"
" :const:`Rounded`, :const:`Subnormal`\\을 제외하고는 활성화됩니다 (예외로 처리됩니다)."

#: ../../library/decimal.rst:1027
msgid ""
"Because many of the traps are enabled, this context is useful for "
"debugging."
msgstr "많은 트랩이 활성화되었으므로, 이 컨텍스트는 디버깅에 유용합니다."

#: ../../library/decimal.rst:1032
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to "
":const:`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled "
"(so that exceptions are not raised during computations)."
msgstr ""
"이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 "
":const:`ROUND_HALF_EVEN`\\으로 설정됩니다. 모든 플래그가 지워집니다. 아무 트랩도 활성화되지 않습니다 (그래서"
" 계산 중에 예외가 발생하지 않습니다)."

#: ../../library/decimal.rst:1037
#, fuzzy
msgid ""
"Because the traps are disabled, this context is useful for applications "
"that prefer to have result value of ``NaN`` or ``Infinity`` instead of "
"raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr ""
"트랩이 비활성화되었으므로, 이 컨텍스트는 예외를 발생시키기보다 :const:`NaN` 이나 :const:`Infinity` 의 "
"결괏값을 선호하는 응용 프로그램에 유용합니다. 이는 응용 프로그램이 그렇지 않으면 프로그램을 중단시킬 수 있는 조건이 있는 경우에도"
" 실행을 완료할 수 있도록 합니다."

#: ../../library/decimal.rst:1045
msgid ""
"This context is used by the :class:`Context` constructor as a prototype "
"for new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"이 컨텍스트는 새로운 컨텍스트의 프로토타입으로 :class:`Context` 생성자에 의해 사용됩니다. 필드(가령 정밀도)를 "
"변경하면 :class:`Context` 생성자에 의해 생성된 새로운 컨텍스트에 대한 기본값을 변경하는 효과가 있습니다."

#: ../../library/decimal.rst:1049
msgid ""
"This context is most useful in multi-threaded environments.  Changing one"
" of the fields before threads are started has the effect of setting "
"system-wide defaults.  Changing the fields after threads have started is "
"not recommended as it would require thread synchronization to prevent "
"race conditions."
msgstr ""
"이 컨텍스트는 다중 스레드 환경에서 가장 유용합니다. 스레드가 시작되기 전에 필드 중 하나를 변경하면 시스템 전체의 기본값을 "
"설정하는 효과가 있습니다. 스레드가 시작된 후에 필드를 변경하는 것은. 스레드 동기화를 통해 경쟁 조건을 방지해야 하므로 권장되지 "
"않습니다."

#: ../../library/decimal.rst:1054
msgid ""
"In single threaded environments, it is preferable to not use this context"
" at all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"단일 스레드 환경에서는, 이 컨텍스트를 아예 사용하지 않는 것이 좋습니다. 대신, 아래에 설명된 대로 명시적으로 컨텍스트를 "
"만드십시오."

#: ../../library/decimal.rst:1057
#, fuzzy
msgid ""
"The default values are :attr:`Context.prec`\\ =\\ ``28``, "
":attr:`Context.rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, and enabled "
"traps for :class:`Overflow`, :class:`InvalidOperation`, and "
":class:`DivisionByZero`."
msgstr ""
"기본값은 :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ =\\ "
":const:`ROUND_HALF_EVEN` 이고 :class:`Overflow`, :class:`InvalidOperation`,"
" :class:`DivisionByZero` 트랩이 활성화됩니다."

#: ../../library/decimal.rst:1062
msgid ""
"In addition to the three supplied contexts, new contexts can be created "
"with the :class:`Context` constructor."
msgstr "3개의 제공된 컨텍스트 외에도, 새로운 컨텍스트를 :class:`Context` 생성자를 사용하여 만들 수 있습니다."

#: ../../library/decimal.rst:1068
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, "
"the default values are copied from the :const:`DefaultContext`.  If the "
"*flags* field is not specified or is :const:`None`, all flags are "
"cleared."
msgstr ""
"새로운 컨텍스트를 만듭니다. 필드가 지정되지 않았거나 :const:`None` 이면, 기본값은 "
":const:`DefaultContext` 에서 복사됩니다. *flags* 필드가 지정되지 않았거나 :const:`None` 이면,"
" 모든 플래그가 지워집니다."

#: ../../library/decimal.rst:1072
#, fuzzy
msgid ""
"*prec* is an integer in the range [``1``, :const:`MAX_PREC`] that sets "
"the precision for arithmetic operations in the context."
msgstr ""
"*prec* 는 컨텍스트에서 산술 연산의 정밀도를 설정하는 [:const:`1`, :const:`MAX_PREC`] 범위의 "
"정수입니다."

#: ../../library/decimal.rst:1075
msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr "*rounding* 옵션은 `자리 올림 모드`_ 섹션에 나열된 상수 중 하나입니다."

#: ../../library/decimal.rst:1078
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new"
" contexts should only set traps and leave the flags clear."
msgstr ""
"*traps* 과 *flags* 필드는 설정할 신호를 나열합니다. 일반적으로, 새 컨텍스트는 트랩만 설정하고 플래그는 지워진 채로 "
"두어야 합니다."

#: ../../library/decimal.rst:1081
#, fuzzy
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [:const:`MIN_EMIN`, "
"``0``], *Emax* in the range [``0``, :const:`MAX_EMAX`]."
msgstr ""
"*Emin* 과 *Emax* 필드는 지수에 허용되는 한계를 지정하는 정수입니다. *Emin* 은 [:const:`MIN_EMIN`,"
" :const:`0`], *Emax* 는 [:const:`0`, :const:`MAX_EMAX`] 범위 내에 있어야 합니다."

#: ../../library/decimal.rst:1085
#, fuzzy
msgid ""
"The *capitals* field is either ``0`` or ``1`` (the default). If set to "
"``1``, exponents are printed with a capital ``E``; otherwise, a lowercase"
" ``e`` is used: ``Decimal('6.02e+23')``."
msgstr ""
"*capitals* 필드는 :const:`0` 또는 :const:`1`\\(기본값)입니다. :const:`1`\\로 설정하면, "
"지수는 대문자 :const:`E`\\와 함께 인쇄됩니다; 그렇지 않으면 소문자 :const:`e` 가 사용됩니다: "
":const:`Decimal('6.02e+23')`."

#: ../../library/decimal.rst:1089
#, fuzzy
msgid ""
"The *clamp* field is either ``0`` (the default) or ``1``. If set to "
"``1``, the exponent ``e`` of a :class:`Decimal` instance representable in"
" this context is strictly limited to the range ``Emin - prec + 1 <= e <= "
"Emax - prec + 1``.  If *clamp* is ``0`` then a weaker condition holds: "
"the adjusted exponent of the :class:`Decimal` instance is at most "
":attr:`~Context.Emax`.  When *clamp* is ``1``, a large normal number "
"will, where possible, have its exponent reduced and a corresponding "
"number of zeros added to its coefficient, in order to fit the exponent "
"constraints; this preserves the value of the number but loses information"
" about significant trailing zeros.  For example::"
msgstr ""
"*clamp* 필드는 :const:`0` (기본값) 또는 :const:`1` 입니다. :const:`1`\\로 설정하면, 이 "
"컨텍스트에서 표현할 수 있는 :class:`Decimal` 인스턴스의 지수 ``e`` 는 ``Emin - prec + 1 <= e "
"<= Emax - prec + 1`` 입니다. *clamp* 가 :const:`0` 이면 더 약한 조건이 유지됩니다: "
":class:`Decimal` 인스턴스의 조정된 최대 ``Emax`` 입니다. *clamp* 가 :const:`1` 일 때, 큰 "
"정상 수는, 가능할 때, 지수 제약 조건을 맞추기 위해 지수가 감소하고 해당 숫자만큼의 0이 계수에 더해집니다; 이것은 수의 값을 "
"보존하지만 유효한 후미 0에 대한 정보를 잃어버립니다. 예를 들면::"

#: ../../library/decimal.rst:1101
msgid ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"
msgstr ""

#: ../../library/decimal.rst:1104
#, fuzzy
msgid ""
"A *clamp* value of ``1`` allows compatibility with the fixed-width "
"decimal interchange formats specified in IEEE 754."
msgstr ":const:`1` 의 *clamp* 값은 IEEE 754에 명시된 고정 폭 십진수 교환 형식과 호환되도록 합니다."

#: ../../library/decimal.rst:1107
#, fuzzy
msgid ""
"The :class:`Context` class defines several general purpose methods as "
"well as a large number of methods for doing arithmetic directly in a "
"given context. In addition, for each of the :class:`Decimal` methods "
"described above (with the exception of the :meth:`~Decimal.adjusted` and "
":meth:`~Decimal.as_tuple` methods) there is a corresponding "
":class:`Context` method.  For example, for a :class:`Context` instance "
"``C`` and :class:`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to "
"``x.exp(context=C)``.  Each :class:`Context` method accepts a Python "
"integer (an instance of :class:`int`) anywhere that a Decimal instance is"
" accepted."
msgstr ""
":class:`Context` 클래스는 주어진 컨텍스트에서 직접 산술을 하는데 필요한 다수의 메서드뿐만 아니라 여러 가지 범용 "
"메서드를 정의합니다. 이에 더해, 위에서 설명한 :class:`Decimal` 메서드마다 (:meth:`adjusted`\\와 "
":meth:`as_tuple` 메서드는 예외입니다) 대응하는 :class:`Context` 메서드가 있습니다. 예를 들어, "
":class:`Context` 인스턴스 ``C`` 와 :class:`Decimal` 인스턴스 ``x`` 에 대해서, "
"``C.exp(x)`` 는 ``x.exp(context=C)`` 와 동등합니다. 각각 :class:`Context` 메서드는 "
"Decimal 인스턴스가 받아들여지는 곳 어디에서나 파이썬 정수(:class:`int` 의 인스턴스)를 받아들입니다."

#: ../../library/decimal.rst:1120
#, fuzzy
msgid "Resets all of the flags to ``0``."
msgstr "모든 플래그를 :const:`0`\\으로 재설정합니다."

#: ../../library/decimal.rst:1124
#, fuzzy
msgid "Resets all of the traps to ``0``."
msgstr "모든 트랩을 :const:`0`\\으로 재설정합니다."

#: ../../library/decimal.rst:1130
msgid "Return a duplicate of the context."
msgstr "컨텍스트의 복사본을 돌려줍니다."

#: ../../library/decimal.rst:1134
msgid "Return a copy of the Decimal instance num."
msgstr "Decimal 인스턴스 num의 복사본을 반환합니다."

#: ../../library/decimal.rst:1138
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"*self* 를 컨텍스트로 사용해서, *num* 으로 새 Decimal 인스턴스를 만듭니다. :class:`Decimal` 생성자와"
" 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다."

#: ../../library/decimal.rst:1142
msgid ""
"This is useful because constants are often given to a greater precision "
"than is needed by the application.  Another benefit is that rounding "
"immediately eliminates unintended effects from digits beyond the current "
"precision. In the following example, using unrounded inputs means that "
"adding zero to a sum can change the result:"
msgstr ""
"이는 상수가 보통 응용 프로그램에 필요한 것보다 더 큰 정밀도로 제공되기 때문에 유용합니다. 또 다른 이점은 자리 올림이 현재 "
"정밀도를 초과하는 자릿수로 인한 의도하지 않은 결과를 즉시 제거한다는 것입니다. 다음 예제에서, 자리 올림 되지 않은 입력을 "
"사용한다는 것은 합계에 0을 추가하면 결과가 달라질 수 있음을 의미합니다.:"

#: ../../library/decimal.rst:1148
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"
msgstr ""

#: ../../library/decimal.rst:1156
msgid ""
"This method implements the to-number operation of the IBM specification. "
"If the argument is a string, no leading or trailing whitespace or "
"underscores are permitted."
msgstr ""
"이 메서드는 IBM 명세의 to-number 연산을 구현합니다. 인자가 문자열이면, 선행 또는 후행 공백이나 밑줄이 허용되지 "
"않습니다."

#: ../../library/decimal.rst:1162
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self*"
" as the context.  Unlike the :meth:`Decimal.from_float` class method, the"
" context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"float *f* 로 새 Decimal 인스턴스를 만들지만, *self* 를 컨텍스트로 사용하여 자리 올림 합니다. "
":meth:`Decimal.from_float` 클래스 메서드와는 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 "
"변환에 적용됩니다."

#: ../../library/decimal.rst:1167
msgid ""
">>> context = Context(prec=5, rounding=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3.1415')\n"
">>> context = Context(prec=5, traps=[Inexact])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"decimal.Inexact: None"
msgstr ""

#: ../../library/decimal.rst:1182
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum "
"exponent value for subnormal results.  When underflow occurs, the "
"exponent is set to :const:`Etiny`."
msgstr ""
"비정상 결과에 대한 최소 지수 값인 ``Emin - prec + 1`` 과 같은 값을 반환합니다. 언더 플로우가 발생하면, 지수는 "
":const:`Etiny` 로 설정됩니다."

#: ../../library/decimal.rst:1188
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "``Emax - prec + 1`` 과 같은 값을 반환합니다."

#: ../../library/decimal.rst:1190
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal`"
" instances and then apply arithmetic operations which take place within "
"the current context for the active thread.  An alternative approach is to"
" use context methods for calculating within a specific context.  The "
"methods are similar to those for the :class:`Decimal` class and are only "
"briefly recounted here."
msgstr ""
"십진수로 작업하는 일반적인 접근법은 :class:`Decimal` 인스턴스를 생성한 다음 활성 스레드의 현재 컨텍스트 내에서 "
"진행되는 산술 연산을 적용하는 것입니다. 다른 방법은 특정 컨텍스트 내에서 계산하기 위해 컨텍스트 메서드를 사용하는 것입니다. "
"메서드는 :class:`Decimal` 클래스의 메서드와 비슷하며 여기에서는 간단히 설명합니다."

#: ../../library/decimal.rst:1200
msgid "Returns the absolute value of *x*."
msgstr "*x* 의 절댓값을 돌려줍니다."

#: ../../library/decimal.rst:1205
msgid "Return the sum of *x* and *y*."
msgstr "*x* 와 *y* 의 합을 돌려줍니다."

#: ../../library/decimal.rst:1210
msgid "Returns the same Decimal object *x*."
msgstr "같은 Decimal 객체 *x* 를 반환합니다."

#: ../../library/decimal.rst:1215
msgid "Compares *x* and *y* numerically."
msgstr "*x* 와 *y* 를 수치로 비교합니다."

#: ../../library/decimal.rst:1220
msgid "Compares the values of the two operands numerically."
msgstr "두 피연산자의 값을 수치로 비교합니다."

#: ../../library/decimal.rst:1225
msgid "Compares two operands using their abstract representation."
msgstr "추상 표현을 사용하여 두 피연산자를 비교합니다."

#: ../../library/decimal.rst:1230
msgid "Compares two operands using their abstract representation, ignoring sign."
msgstr "부호를 무시하고, 추상 표현을 사용하여 두 피연산자를 비교합니다."

#: ../../library/decimal.rst:1235
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "부호가 0으로 설정되어있는 *x* 의 복사본을 돌려줍니다."

#: ../../library/decimal.rst:1240
msgid "Returns a copy of *x* with the sign inverted."
msgstr "부호가 반전된 *x* 복사본을 반환합니다."

#: ../../library/decimal.rst:1245
msgid "Copies the sign from *y* to *x*."
msgstr "*y* 에서 *x* 로 부호를 복사합니다."

#: ../../library/decimal.rst:1250
msgid "Return *x* divided by *y*."
msgstr "*x* 를 *y* 로 나눈 값을 반환합니다."

#: ../../library/decimal.rst:1255
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "*x* 를 *y* 로 나눈 후 정수로 잘라낸 값을 반환합니다."

#: ../../library/decimal.rst:1260
msgid "Divides two numbers and returns the integer part of the result."
msgstr "두 숫자를 나누고 결과의 정수 부분을 반환합니다."

#: ../../library/decimal.rst:1265
#, fuzzy
msgid "Returns ``e ** x``."
msgstr "`e ** x`\\를 반환합니다."

#: ../../library/decimal.rst:1270
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "*x* 에 *y* 를 곱한 후 *z* 를 더한 값을 반환합니다."

#: ../../library/decimal.rst:1275
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr "*x* 가 규범적일 경우 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1280
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "*x* 가 유한이면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1285
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "*x* 가 무한대면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1290
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr "*x* 가 qNaN 이나 sNaN 이면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1295
msgid "Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr "*x* 가 정상 수면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1300
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr "*x* 가 조용한 NaN이면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1305
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr "*x* 가 음수면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1310
msgid "Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr "*x* 가 신호를 주는 NaN 이면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1315
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr "*x* 가 비정상이면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1320
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "*x* 가 0이면 ``True``\\를 반환합니다; 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/decimal.rst:1325
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "*x* 의 자연로그(밑 e)를 반환합니다."

#: ../../library/decimal.rst:1330
msgid "Returns the base 10 logarithm of *x*."
msgstr "*x* 의 상용로그를 반환합니다."

#: ../../library/decimal.rst:1335
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "피연산자의 최상위 유효 숫자의 크기의 지수를 반환합니다."

#: ../../library/decimal.rst:1340
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "각 피연산자의 자릿수별로 논리적 연산 *and* 를 적용합니다."

#: ../../library/decimal.rst:1345
msgid "Invert all the digits in *x*."
msgstr "*x* 의 모든 자릿수를 반전합니다."

#: ../../library/decimal.rst:1350
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "각 피연산자의 자릿수별로 논리적 연산 *or* 를 적용합니다."

#: ../../library/decimal.rst:1355
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "각 피연산자의 자릿수별로 논리적 연산 *xor* 를 적용합니다."

#: ../../library/decimal.rst:1360
msgid "Compares two values numerically and returns the maximum."
msgstr "두 값을 수치로 비교해, 최댓값을 돌려줍니다."

#: ../../library/decimal.rst:1365 ../../library/decimal.rst:1375
msgid "Compares the values numerically with their sign ignored."
msgstr "부호를 무시하고 값을 수치로 비교합니다."

#: ../../library/decimal.rst:1370
msgid "Compares two values numerically and returns the minimum."
msgstr "두 값을 수치로 비교해, 최솟값을 돌려줍니다."

#: ../../library/decimal.rst:1380
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "minus는 파이썬에서 단항 접두사 빼기 연산자에 해당합니다."

#: ../../library/decimal.rst:1385
msgid "Return the product of *x* and *y*."
msgstr "*x* 와 *y* 의 곱을 반환합니다."

#: ../../library/decimal.rst:1390
msgid "Returns the largest representable number smaller than *x*."
msgstr "*x* 보다 작고 표현 가능한 가장 큰 수를 반환합니다."

#: ../../library/decimal.rst:1395
msgid "Returns the smallest representable number larger than *x*."
msgstr "*x* 보다 크고 표현 가능한 가장 작은 수를 반환합니다."

#: ../../library/decimal.rst:1400
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "*y* 방향으로 *x* 에 가장 가까운 숫자를 반환합니다."

#: ../../library/decimal.rst:1405
msgid "Reduces *x* to its simplest form."
msgstr "*x* 를 가장 간단한 형태로 환원합니다."

#: ../../library/decimal.rst:1410
msgid "Returns an indication of the class of *x*."
msgstr "*x* 의 클래스를 가리키는 문자열을 돌려줍니다."

#: ../../library/decimal.rst:1415
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"plus는 파이썬에서 단항 접두사 더하기 연산자에 해당합니다. 이 연산은 컨텍스트 정밀도와 자리 올림을 적용하므로 항등 연산이 "
"*아닙니다*."

#: ../../library/decimal.rst:1422
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr "``x`` 의 ``y`` 거듭제곱을 돌려줍니다. 주어지면 ``modulo`` 모듈로로 환원합니다."

#: ../../library/decimal.rst:1424
#, fuzzy
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` "
"must be integral.  The result will be inexact unless ``y`` is integral "
"and the result is finite and can be expressed exactly in 'precision' "
"digits. The rounding mode of the context is used. Results are always "
"correctly rounded in the Python version."
msgstr ""
"두 인자로는 ``x**y`` 를 계산합니다. ``x`` 가 음수면 ``y`` 는 정수여야 합니다. ``y`` 가 정수이고 결과가 "
"유한하고 'precision' 자릿수로 정확하게 표현될 수 있지 않은 이상 결과는 부정확합니다. 컨텍스트의 자리 올림 모드가 "
"사용됩니다. 결과는 항상 파이썬 버전에서 정확하게 자리 올림 됩니다."

#: ../../library/decimal.rst:1430
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)``\\은 ``InvalidOperation``\\이 되며, "
"``InvalidOperation``\\가 트랩 되지 않으면, ``Decimal('NaN')``\\이 됩니다."

#: ../../library/decimal.rst:1433
#, fuzzy
msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded "
":meth:`exp` and :meth:`ln` functions. The result is well-defined but only"
" \"almost always correctly rounded\"."
msgstr ""
"C 모듈은 올바르게 자리 올림 된 :meth:`exp`\\와 :meth:`ln` 함수로 :meth:`power`\\를 계산합니다. "
"결과는 잘 정의되어 있지만 \"거의 항상 올바르게 자리 올림 될\" 뿐입니다."

#: ../../library/decimal.rst:1438
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three "
"argument form, the following restrictions on the arguments hold:"
msgstr "세 인자로는 ``(x**y) % modulo`` 를 계산합니다. 세 인자 형식의 경우, 인자에 다음과 같은 제한이 있습니다:"

#: ../../library/decimal.rst:1441
msgid "all three arguments must be integral"
msgstr "세 인자는 모두 정수여야 합니다."

#: ../../library/decimal.rst:1442
msgid "``y`` must be nonnegative"
msgstr "``y`` 는 음수가 아니어야 합니다."

#: ../../library/decimal.rst:1443
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "``x`` 나 ``y`` 중 적어도 하나는 0이 아니어야 합니다"

#: ../../library/decimal.rst:1444
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` 는 0이 아니고 최대 'precision' 자릿수를 가져야 합니다"

#: ../../library/decimal.rst:1446
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with "
"unbounded precision, but is computed more efficiently.  The exponent of "
"the result is zero, regardless of the exponents of ``x``, ``y`` and "
"``modulo``.  The result is always exact."
msgstr ""
"``Context.power(x, y, modulo)`` 의 결괏값은 무한 정밀도로 ``(x**y) % modulo`` 를 계산할 "
"때 얻을 수 있는 값과 같지만, 더 효율적으로 계산됩니다. 결과의 지수는 ``x``, ``y`` 및 ``modulo`` 의 지수와 "
"관계없이 0입니다. 결과는 항상 정확합니다."

#: ../../library/decimal.rst:1456
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "*y* 의 지수를 가지는 (자리 올림 된) *x* 와 같은 값을 반환합니다."

#: ../../library/decimal.rst:1461
msgid "Just returns 10, as this is Decimal, :)"
msgstr "Decimal이기 때문에 단지 10을 반환합니다, :)"

#: ../../library/decimal.rst:1466
msgid "Returns the remainder from integer division."
msgstr "정수 나눗셈의 나머지를 반환합니다."

#: ../../library/decimal.rst:1468
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr "결과가 0이 아닐 때, 결과의 부호는 원래의 피제수와 같습니다."

#: ../../library/decimal.rst:1474
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value "
"of ``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"``x - y * n`` 을 반환하는데, *n* 은 ``x / y`` 의 정확한 값에 가장 가까운 정수입니다 (결과가 0이면 그 "
"부호는 *x* 의 부호가 됩니다)."

#: ../../library/decimal.rst:1480
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "*x* 를 *y* 번 회전한 복사본을 반환합니다."

#: ../../library/decimal.rst:1485
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "두 피연산자의 지수가 같으면 ``True``\\를 반환합니다."

#: ../../library/decimal.rst:1490
msgid "Returns the first operand after adding the second value its exp."
msgstr "첫 번째 피연산자의 지수에 두 번째 값을 더해서 반환합니다."

#: ../../library/decimal.rst:1495
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "*x* 를 *y* 번 이동한 복사본을 반환합니다."

#: ../../library/decimal.rst:1500
msgid "Square root of a non-negative number to context precision."
msgstr "음이 아닌 수의 제곱근을 컨텍스트의 정밀도로 반환합니다."

#: ../../library/decimal.rst:1505
msgid "Return the difference between *x* and *y*."
msgstr "*x* 와 *y* 의 차를 돌려줍니다."

#: ../../library/decimal.rst:1519
msgid "Rounds to an integer."
msgstr "정수로 자리 올림 합니다."

#: ../../library/decimal.rst:1524
msgid "Converts a number to a string using scientific notation."
msgstr "과학 표기법을 사용하여 숫자를 문자열로 변환합니다."

#: ../../library/decimal.rst:1531
msgid "Constants"
msgstr "상수"

#: ../../library/decimal.rst:1533
msgid ""
"The constants in this section are only relevant for the C module. They "
"are also included in the pure Python version for compatibility."
msgstr "이 절의 상수는 C 모듈에서만 의미가 있습니다. 호환성을 위해 순수 파이썬 버전에도 포함되어 있습니다."

#: ../../library/decimal.rst:1537
msgid "32-bit"
msgstr "32-비트"

#: ../../library/decimal.rst:1537
msgid "64-bit"
msgstr "64-비트"

#: ../../library/decimal.rst:1539 ../../library/decimal.rst:1541
#, fuzzy
msgid "``425000000``"
msgstr ":const:`425000000`"

#: ../../library/decimal.rst:1539 ../../library/decimal.rst:1541
#, fuzzy
msgid "``999999999999999999``"
msgstr ":const:`999999999999999999`"

#: ../../library/decimal.rst:1543
#, fuzzy
msgid "``-425000000``"
msgstr ":const:`-425000000`"

#: ../../library/decimal.rst:1543
#, fuzzy
msgid "``-999999999999999999``"
msgstr ":const:`-999999999999999999`"

#: ../../library/decimal.rst:1545
#, fuzzy
msgid "``-849999999``"
msgstr ":const:`-849999999`"

#: ../../library/decimal.rst:1545
#, fuzzy
msgid "``-1999999999999999997``"
msgstr ":const:`-1999999999999999997`"

#: ../../library/decimal.rst:1551
msgid "The value is ``True``.  Deprecated, because Python now always has threads."
msgstr "값은 ``True``\\입니다. 이제 파이썬에는 항상 스레드가 있기 때문에, 폐지되었습니다."

#: ../../library/decimal.rst:1557
#, fuzzy
msgid ""
"The default value is ``True``. If Python is :option:`configured using the"
" --without-decimal-contextvar option <--without-decimal-contextvar>`, the"
" C version uses a thread-local rather than a coroutine-local context and "
"the value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"기본값은 ``True``\\입니다. 파이썬이 ``--without-decimal-contextvar``\\로 컴파일되면, C 버전은"
" 코루틴 로컬 컨텍스트 대신 스레드 로컬을 사용하며 값은 ``False``\\입니다. 일부 중첩된 컨텍스트 시나리오에서는 약간 더 "
"빠릅니다."

#: ../../library/decimal.rst:1566
msgid "Rounding modes"
msgstr "자리 올림 모드"

#: ../../library/decimal.rst:1570
#, fuzzy
msgid "Round towards ``Infinity``."
msgstr ":const:`Infinity`\\를 향해 올립니다."

#: ../../library/decimal.rst:1574
msgid "Round towards zero."
msgstr "0을 향해 자리 올림 합니다."

#: ../../library/decimal.rst:1578
#, fuzzy
msgid "Round towards ``-Infinity``."
msgstr ":const:`-Infinity`\\를 향해 내립니다."

#: ../../library/decimal.rst:1582
msgid "Round to nearest with ties going towards zero."
msgstr "가장 가까운 값으로 반올림하고, 동률이면 0에서 가까운 것을 선택합니다."

#: ../../library/decimal.rst:1586
msgid "Round to nearest with ties going to nearest even integer."
msgstr "가장 가까운 값으로 반올림하고, 동률이면 짝수를 선택합니다."

#: ../../library/decimal.rst:1590
msgid "Round to nearest with ties going away from zero."
msgstr "가장 가까운 값으로 반올림하고, 동률이면 0에서 먼 것을 선택합니다."

#: ../../library/decimal.rst:1594
msgid "Round away from zero."
msgstr "0에서 먼 쪽으로 자리 올림 합니다."

#: ../../library/decimal.rst:1598
msgid ""
"Round away from zero if last digit after rounding towards zero would have"
" been 0 or 5; otherwise round towards zero."
msgstr ""
"0을 향해 자리 올림 했을 때 마지막 숫자가 0이나 5면 0에서 먼 쪽으로 자리 올림 합니다. 그렇지 않으면 0을 향해 자리 올림 "
"합니다."

#: ../../library/decimal.rst:1605
msgid "Signals"
msgstr "신호"

#: ../../library/decimal.rst:1607
msgid ""
"Signals represent conditions that arise during computation. Each "
"corresponds to one context flag and one context trap enabler."
msgstr "신호는 계산 중 발생하는 조건을 나타냅니다. 각각은 하나의 컨텍스트 플래그와 하나의 컨텍스트 트랩 활성화기에 대응합니다."

#: ../../library/decimal.rst:1610
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for "
"instance, to determine whether a computation was exact). After checking "
"the flags, be sure to clear all flags before starting the next "
"computation."
msgstr ""
"컨텍스트 플래그는 조건이 발생할 때마다 설정됩니다. 계산 후에, 플래그는 정보를 얻기 위한 목적으로 확인될 수 있습니다 (예를 "
"들어, 계산이 정확한지를 판별하기 위해). 플래그를 확인한 후 다음 계산을 시작하기 전에 모든 플래그를 지우십시오."

#: ../../library/decimal.rst:1615
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the "
":class:`DivisionByZero` trap is set, then a :exc:`DivisionByZero` "
"exception is raised upon encountering the condition."
msgstr ""
"컨텍스트의 트랩 활성화기가 신호에 대해 설정되면, 조건은 파이썬 예외를 일으킵니다. 예를 들어, "
":class:`DivisionByZero` 트랩이 설정되면, 이 조건을 만날 때 :exc:`DivisionByZero` 예외가 "
"발생합니다."

#: ../../library/decimal.rst:1623
msgid "Altered an exponent to fit representation constraints."
msgstr "표현 제약 조건에 맞도록 지수를 변경했습니다."

#: ../../library/decimal.rst:1625
#, fuzzy
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's "
":attr:`~Context.Emin` and :attr:`~Context.Emax` limits.  If possible, the"
" exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""
"일반적으로, 지수가 컨텍스트의 :attr:`Emin`\\과 :attr:`Emax` 한계를 벗어날 때 클램핑이 발생합니다. 가능하면,"
" 계수에 0을 추가하여 지수를 줄입니다."

#: ../../library/decimal.rst:1632
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "다른 신호의 베이스 클래스이고 :exc:`ArithmeticError` 의 서브 클래스입니다."

#: ../../library/decimal.rst:1637
msgid "Signals the division of a non-infinite number by zero."
msgstr "무한대가 아닌 숫자를 0으로 나눴다는 신호를 줍니다."

#: ../../library/decimal.rst:1639
#, fuzzy
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns ``Infinity`` or "
"``-Infinity`` with the sign determined by the inputs to the calculation."
msgstr ""
"나눗셈, 모듈로 나눗셈 또는 음수로 숫자를 거듭제곱할 때 발생할 수 있습니다. 이 신호가 트랩 되지 않으면, 계산에 제공된 입력의 "
"부호에 따라 :const:`Infinity` 나 :const:`-Infinity`\\를 돌려줍니다."

#: ../../library/decimal.rst:1646
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "자리 올림이 발생했고 결과가 정확하지 않음을 나타냅니다."

#: ../../library/decimal.rst:1648
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when "
"results are inexact."
msgstr ""
"자리 올림 도중 0이 아닌 숫자가 삭제된 경우 신호를 줍니다. 자리 올림 된 결과가 반환됩니다. 신호 플래그나 트랩은 결과가 "
"정확하지 않을 때를 감지하는 데 사용됩니다."

#: ../../library/decimal.rst:1655
msgid "An invalid operation was performed."
msgstr "유효하지 않은 연산이 수행되었습니다."

#: ../../library/decimal.rst:1657
#, fuzzy
msgid ""
"Indicates that an operation was requested that does not make sense. If "
"not trapped, returns ``NaN``.  Possible causes include::"
msgstr ""
"의미가 없는 연산이 요청되었음을 나타냅니다. 트랩 되지 않으면, :const:`NaN` 을 반환합니다. 가능한 원인은 다음과 "
"같습니다::"

#: ../../library/decimal.rst:1660
#, python-format
msgid ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"sqrt(-x) and x > 0\n"
"0 ** 0\n"
"x ** (non-integer)\n"
"x ** Infinity"
msgstr ""

#: ../../library/decimal.rst:1673
msgid "Numerical overflow."
msgstr "수치적 오버플로."

#: ../../library/decimal.rst:1675
#, fuzzy
msgid ""
"Indicates the exponent is larger than :attr:`Context.Emax` after rounding"
" has occurred.  If not trapped, the result depends on the rounding mode, "
"either pulling inward to the largest representable finite number or "
"rounding outward to ``Infinity``.  In either case, :class:`Inexact` and "
":class:`Rounded` are also signaled."
msgstr ""
"자리 올림 후에 지수가 :attr:`Emax` 보다 큼을 나타냅니다. 트랩 되지 않으면, 결과는 자리 올림 모드에 따라 달라지는데,"
" 가장 큰 표현 가능한 유한 수로 안쪽으로 당기거나 :const:`Infinity`\\를 향해 바깥쪽으로 자리 올림 됩니다. 두 "
"경우 모두 :class:`Inexact`\\와 :class:`Rounded` 신호도 줍니다."

#: ../../library/decimal.rst:1684
msgid "Rounding occurred though possibly no information was lost."
msgstr "정보가 손실되지는 않았지만 자리 올림이 발생했습니다."

#: ../../library/decimal.rst:1686
#, fuzzy
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero"
" (such as rounding ``5.00`` to ``5.0``).  If not trapped, returns the "
"result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr ""
"자리 올림이 자릿수를 버릴 때마다 신호를 줍니다; 그 자릿수가 0일 때도 그렇습니다 (가령 :const:`5.00`\\을 "
":const:`5.0`\\으로 자리 올림). 트랩 되지 않으면, 결과를 그대로 반환합니다. 이 신호는 유효숫자의 손실을 감지하는 데"
" 사용됩니다."

#: ../../library/decimal.rst:1694
#, fuzzy
msgid "Exponent was lower than :attr:`~Context.Emin` prior to rounding."
msgstr "자리 올림 전에 지수가 :attr:`Emin` 보다 작습니다."

#: ../../library/decimal.rst:1696
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small)."
" If not trapped, returns the result unchanged."
msgstr "연산 결과가 비정상(지수가 너무 작음)일 때 발생합니다. 트랩 되지 않으면, 결과를 그대로 반환합니다."

#: ../../library/decimal.rst:1702
msgid "Numerical underflow with result rounded to zero."
msgstr "결과가 0으로 자리 올림 되는 수치적 언더플로."

#: ../../library/decimal.rst:1704
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. "
":class:`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"자리 올림에 의해 비정상 결과가 0으로 밀릴 때 발생합니다. :class:`Inexact`\\와 :class:`Subnormal` "
"신호도 줍니다."

#: ../../library/decimal.rst:1710
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr "float와 Decimal을 혼합하는 데 더 엄격한 의미를 사용합니다."

#: ../../library/decimal.rst:1712
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, "
":meth:`~decimal.Context.create_decimal` and all comparison operators. "
"Both conversion and comparisons are exact. Any occurrence of a mixed "
"operation is silently recorded by setting :exc:`FloatOperation` in the "
"context flags. Explicit conversions with "
":meth:`~decimal.Decimal.from_float` or "
":meth:`~decimal.Context.create_decimal_from_float` do not set the flag."
msgstr ""
"신호가 트랩되지 않으면 (기본값), :class:`~decimal.Decimal` 생성자, "
":meth:`~decimal.Context.create_decimal` 및 모든 비교 연산자에서 float와 Decimal을 혼합 "
"할 수 있습니다. 변환과 비교 모두 정확합니다. 복합 연산의 발생은 컨텍스트 플래그에 :exc:`FloatOperation` 을 "
"설정하여 조용히 기록됩니다. :meth:`~decimal.Decimal.from_float` 나 "
":meth:`~decimal.Context.create_decimal_from_float` 를 사용한 명시적 변환은 플래그를 "
"설정하지 않습니다."

#: ../../library/decimal.rst:1720
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit"
" conversions are silent. All other mixed operations raise "
":exc:`FloatOperation`."
msgstr ""
"그렇지 않으면 (신호가 트랩되면), 같음 비교와 명시적 변환만 조용히 수행됩니다. 다른 모든 혼합된 연산은 "
":exc:`FloatOperation` 을 발생시킵니다."

#: ../../library/decimal.rst:1724
msgid "The following table summarizes the hierarchy of signals::"
msgstr "다음 표는 신호의 계층 구조를 요약한 것입니다::"

#: ../../library/decimal.rst:1726
msgid ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, exceptions.TypeError)"
msgstr ""

#: ../../library/decimal.rst:1745
#, fuzzy
msgid "Floating-Point Notes"
msgstr "부동 소수점 노트"

#: ../../library/decimal.rst:1749
msgid "Mitigating round-off error with increased precision"
msgstr "증가시킨 정밀도로 자리 올림 오차 줄이기"

#: ../../library/decimal.rst:1751
#, fuzzy
msgid ""
"The use of decimal floating point eliminates decimal representation error"
" (making it possible to represent ``0.1`` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed "
"the fixed precision."
msgstr ""
"십진 부동 소수점을 사용하면 십진수 표현 오차가 없어집니다 (:const:`0.1`\\을 정확히 나타낼 수 있습니다); 그러나 0이"
" 아닌 숫자가 고정된 정밀도를 초과할 때 일부 연산은 여전히 자리 올림 오차를 일으킬 수 있습니다."

#: ../../library/decimal.rst:1755
#, fuzzy
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating-point arithmetic with insufficient precision causes the "
"breakdown of the associative and distributive properties of addition:"
msgstr ""
"자리 올림 오차의 효과는 거의 상쇄되는 양을 더하거나 빼는 것에 의해 증폭되어 유효숫자의 손실로 이어질 수 있습니다. Knuth는 "
"불충분한 정밀도로 자리 올림 된 부동 소수점 산술로 인해 덧셈의 결합 법칙과 배분 법칙이 파괴되는 두 가지 사례를 제공합니다:"

#: ../../library/decimal.rst:1761
msgid ""
"# Examples from Seminumerical Algorithms, Section 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), "
"Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""

#: ../../library/decimal.rst:1779
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ":mod:`decimal` 모듈은 유효숫자의 손실을 피할 수 있을 만큼 정밀도를 확장함으로써 항등 관계를 복구할 수 있게 합니다 :"

#: ../../library/decimal.rst:1782
msgid ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), "
"Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""

#: ../../library/decimal.rst:1799
msgid "Special values"
msgstr "특수 값"

#: ../../library/decimal.rst:1801
#, fuzzy
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, and two zeros, "
"``+0`` and ``-0``."
msgstr ""
":mod:`decimal` 모듈의 수 체계는 :const:`NaN`, :const:`sNaN`, :const:`-Infinity`,"
" :const:`Infinity`\\와 두 개의 0 :const:`+0`\\과 :const:`-0`\\을 포함하는 특수 값을 "
"제공합니다."

#: ../../library/decimal.rst:1805
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. "
"Also, they can arise from dividing by zero when the :exc:`DivisionByZero`"
" signal is not trapped.  Likewise, when the :exc:`Overflow` signal is not"
" trapped, infinity can result from rounding beyond the limits of the "
"largest representable number."
msgstr ""
"무한대는 다음과 같이 직접 생성될 수 있습니다: ``Decimal('Infinity')``. 또한, "
":exc:`DivisionByZero` 신호가 트랩 되지 않을 때 0으로 나눠서 발생할 수 있습니다. 마찬가지로, "
":exc:`Overflow` 신호가 트랩 되지 않을 때, 무한대는 표현 가능한 가장 큰 수의 한계를 넘어서 자리 올림 된 결과가 될"
" 수 있습니다."

#: ../../library/decimal.rst:1810
msgid ""
"The infinities are signed (affine) and can be used in arithmetic "
"operations where they get treated as very large, indeterminate numbers.  "
"For instance, adding a constant to infinity gives another infinite "
"result."
msgstr ""
"무한대는 부호가 있고 (아핀) 산술 연산에 사용될 수 있는데, 매우 크고 불확정적(indeterminate)인 숫자로 취급됩니다. "
"예를 들어, 무한대에 상수를 더하면 또 다른 무한대를 줍니다."

#: ../../library/decimal.rst:1814
#, fuzzy
msgid ""
"Some operations are indeterminate and return ``NaN``, or if the "
":exc:`InvalidOperation` signal is trapped, raise an exception.  For "
"example, ``0/0`` returns ``NaN`` which means \"not a number\".  This "
"variety of ``NaN`` is quiet and, once created, will flow through other "
"computations always resulting in another ``NaN``.  This behavior can be "
"useful for a series of computations that occasionally have missing inputs"
" --- it allows the calculation to proceed while flagging specific results"
" as invalid."
msgstr ""
"어떤 연산은 불확정적이고, :const:`NaN` 을 반환하거나, :exc:`InvalidOperation` 신호가 트랩 되면, "
"예외를 발생시킵니다. 예를 들어, ``0/0`` 은 \"숫자가 아님(not a number)\"을 의미하는 :const:`NaN` "
"을 반환합니다. 이 종류의 :const:`NaN` 은 조용하고, 한 번 만들어지면 다른 연산에 포함될 때 항상 다른 "
":const:`NaN` 을 생성합니다. 이 동작은 때때로 빠진 입력이 있는 일련의 계산에 유용할 수 있습니다 --- 특정 결과를 "
"잘못된 것으로 표시하면서 계산을 진행할 수 있도록 합니다."

#: ../../library/decimal.rst:1822
#, fuzzy
msgid ""
"A variant is ``sNaN`` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result "
"needs to interrupt a calculation for special handling."
msgstr ""
"다른 종류는 :const:`sNaN` 인데, 모든 연산 후에 조용히 남아 있는 대신 신호를 줍니다. 이것은 유효하지 않은 결과가 "
"특수한 처리를 위해 계산을 중단시켜야 할 때 유용한 반환 값입니다."

#: ../../library/decimal.rst:1826
#, fuzzy
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a ``NaN`` is involved.  A test for equality where one of the "
"operands is a quiet or signaling ``NaN`` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two "
"Decimals using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will "
"raise the :exc:`InvalidOperation` signal if either operand is a ``NaN``, "
"and return :const:`False` if this signal is not trapped.  Note that the "
"General Decimal Arithmetic specification does not specify the behavior of"
" direct comparisons; these rules for comparisons involving a ``NaN`` were"
" taken from the IEEE 854 standard (see Table 3 in section 5.7).  To "
"ensure strict standards-compliance, use the :meth:`~Decimal.compare` and "
":meth:`~Decimal.compare_signal` methods instead."
msgstr ""
"파이썬의 비교 연산자의 동작은 :const:`NaN` 이 관련되어있을 때 약간 의외일 수 있습니다. 피연산자 중 하나가 조용하거나 "
"신호를 주는 :const:`NaN` 일 때, 같음 검사는 항상 :const:`False`\\를 반환하고 (심지어 "
"``Decimal('NaN')==Decimal('NaN')`` 조차도), 다름 검사는 항상 :const:`True`\\를 "
"반환합니다. ``<``, ``<=``, ``>`` 또는 ``>=`` 연산자 중 하나를 사용하여 두 Decimal을 비교하려는 시도는"
" 피연산자 중 어느 것이 든 :const:`NaN` 이면 :exc:`InvalidOperation` 신호를 발생시킵니다. 이 신호가"
" 트랩 되지 않으면 :const:`False`\\를 반환합니다. 일반 십진 산술 명세는 직접 비교의 동작을 명시하지 않습니다; "
":const:`NaN` 을 포함하는 비교를 위한 이러한 규칙은 IEEE 854 표준(섹션 5.7의 표 3을 보세요)에서 가져온 "
"것입니다. 엄격한 표준 준수를 위해서는, 대신 :meth:`compare` 및 :meth:`compare-signal` 메서드를 "
"사용하십시오."

#: ../../library/decimal.rst:1839
msgid ""
"The signed zeros can result from calculations that underflow. They keep "
"the sign that would have resulted if the calculation had been carried out"
" to greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"부호 있는 0은 언더플로 하는 계산의 결과일 수 있습니다. 계산을 더 정밀하게 수행한다면 얻게 될 결과의 기호를 유지합니다. 크기가"
" 0이기 때문에, 양과 음의 0은 같다고 취급되며 부호는 정보 용입니다."

#: ../../library/decimal.rst:1844
#, fuzzy
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there "
"are various representations of zero with differing precisions yet "
"equivalent in value.  This takes a bit of getting used to.  For an eye "
"accustomed to normalized floating-point representations, it is not "
"immediately obvious that the following calculation returns a value equal "
"to zero:"
msgstr ""
"서로 다른 부호를 갖는 부호 있는 0이 같은 것에 더해, 여전히 동등한 값이지만 다른 정밀도를 갖는 여러 표현이 존재합니다. "
"익숙해지는데 약간 시간이 필요합니다. 정규화된 부동 소수점 표현에 익숙한 사람들에게는, 다음 계산이 0과 같은 값을 반환한다는 것이"
" 즉시 명백하지는 않습니다:"

#: ../../library/decimal.rst:1859
msgid "Working with threads"
msgstr "스레드로 작업하기"

#: ../../library/decimal.rst:1861
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` "
"object for each thread.  Having separate thread contexts means that "
"threads may make changes (such as ``getcontext().prec=10``) without "
"interfering with other threads."
msgstr ""
":func:`getcontext` 함수는 스레드마다 다른 :class:`Context` 객체에 접근합니다. 별도의 스레드 컨텍스트를"
" 갖는다는 것은 스레드가 다른 스레드를 방해하지 않고 변경할 수 있음을 의미합니다 (가령 "
"``getcontext().prec=10``)."

#: ../../library/decimal.rst:1865
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its "
"target to the current thread."
msgstr "마찬가지로, :func:`setcontext` 함수는 자동으로 대상을 현재 스레드에 할당합니다."

#: ../../library/decimal.rst:1868
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then"
" :func:`getcontext` will automatically create a new context for use in "
"the current thread."
msgstr ""
":func:`setcontext` 가 :func:`getcontext` 전에 호출되지 않았다면, :func:`getcontext` "
"는 현재 스레드에서 사용할 새로운 컨텍스트를 자동으로 생성합니다."

#: ../../library/decimal.rst:1872
msgid ""
"The new context is copied from a prototype context called "
"*DefaultContext*. To control the defaults so that each thread will use "
"the same values throughout the application, directly modify the "
"*DefaultContext* object. This should be done *before* any threads are "
"started so that there won't be a race condition between threads calling "
":func:`getcontext`. For example::"
msgstr ""
"새 컨텍스트는 *DefaultContext* 라는 프로토타입 컨텍스트에서 복사됩니다. 각 스레드가 응용 프로그램 전체에서 같은 값을"
" 사용하도록 기본값을 제어하려면, *DefaultContext* 객체를 직접 수정하십시오. :func:`getcontext` 를 "
"호출하는 스레드 사이에 경쟁 조건이 없도록, 어떤 스레드가 시작되기 *전에* 수행되어야 합니다. 예를 들면::"

#: ../../library/decimal.rst:1878
msgid ""
"# Set applicationwide defaults for all threads about to be launched\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Afterwards, the threads can be started\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."
msgstr ""

#: ../../library/decimal.rst:1897
msgid "Recipes"
msgstr "조리법"

#: ../../library/decimal.rst:1899
msgid ""
"Here are a few recipes that serve as utility functions and that "
"demonstrate ways to work with the :class:`Decimal` class::"
msgstr "다음은 유틸리티 함수로 사용되고 :class:`Decimal` 클래스로 작업하는 방법을 보여주는 몇 가지 조리법입니다::"

#: ../../library/decimal.rst:1902
msgid ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Convert Decimal to a money formatted string.\n"
"\n"
"    places:  required number of places after the decimal point\n"
"    curr:    optional currency symbol before the sign (may be blank)\n"
"    sep:     optional grouping separator (comma, period, space, or blank)"
"\n"
"    dp:      decimal point indicator (comma or period)\n"
"             only specify as blank when places is zero\n"
"    pos:     optional sign for positive numbers: '+', space or blank\n"
"    neg:     optional sign for negative numbers: '-', '(', space or blank"
"\n"
"    trailneg:optional trailing minus indicator:  '-', ')', space or blank"
"\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 places --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    if places:\n"
"        build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"Compute Pi to the current precision.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # extra digits for intermediate steps\n"
"    three = Decimal(3)      # substitute \"three=3.0\" for regular floats"
"\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # unary plus applies the new precision\n"
"\n"
"def exp(x):\n"
"    \"\"\"Return e raised to the power of x.  Result type matches input "
"type.\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Return the cosine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Return the sine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"
msgstr ""

#: ../../library/decimal.rst:2054
msgid "Decimal FAQ"
msgstr "Decimal FAQ"

#: ../../library/decimal.rst:2056
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a "
"way to minimize typing when using the interactive interpreter?"
msgstr ""
"Q. ``decimal.Decimal('1234.5')`` 라고 입력하는 것은 귀찮은 일입니다. 대화형 인터프리터를 사용할 때 "
"타자를 최소화할 방법이 있습니까?"

#: ../../library/decimal.rst:2059
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. 일부 사용자는 생성자를 하나의 문자로 축약합니다:"

#: ../../library/decimal.rst:2065
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have"
" many places and need to be rounded.  Others are not supposed to have "
"excess digits and need to be validated.  What methods should be used?"
msgstr ""
"Q. 소수점 두 자리의 고정 소수점 응용 프로그램에서, 일부 입력에 여러 자리가 있고 자리 올림 해야 합니다. 어떤 것은 여분의 "
"자릿수가 없다고 가정되지만, 유효성 검사가 필요합니다. 어떤 방법을 사용해야 합니까?"

#: ../../library/decimal.rst:2069
#, fuzzy
msgid ""
"A. The :meth:`~Decimal.quantize` method rounds to a fixed number of "
"decimal places. If the :const:`Inexact` trap is set, it is also useful "
"for validation:"
msgstr ""
"A. :meth:`quantize` 메서드는 고정된 소수 자릿수로 자리 올림 합니다. :const:`Inexact` 트랩이 "
"설정되면, 유효성 검사에도 유용합니다:"

#: ../../library/decimal.rst:2087
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr "Q. 일단 유효한 두 자리 입력이 있으면, 응용 프로그램 전체에서 해당 불변성을 어떻게 유지합니까?"

#: ../../library/decimal.rst:2090
#, fuzzy
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like"
" division and non-integer multiplication, will change the number of "
"decimal places and need to be followed-up with a "
":meth:`~Decimal.quantize` step:"
msgstr ""
"A. 정수로 더하기, 빼기 및 곱하기와 같은 일부 연산은 고정 소수점을 자동으로 보존합니다. 나눗셈과 정수가 아닌 수로 곱하는 것과"
" 같은 다른 연산은, 소수점 이하 자릿수를 바꿀 것이고, 뒤에 :meth:`quantize` 단계를 적용할 필요가 있습니다:"

#: ../../library/decimal.rst:2108
#, fuzzy
msgid ""
"In developing fixed-point applications, it is convenient to define "
"functions to handle the :meth:`~Decimal.quantize` step:"
msgstr "고정 소수점 응용 프로그램을 개발할 때, :meth:`quantize` 단계를 처리하는 함수를 정의하는 것이 편리합니다:"

#: ../../library/decimal.rst:2122
#, fuzzy
msgid ""
"Q. There are many ways to express the same value.  The numbers ``200``, "
"``200.000``, ``2E2``, and ``.02E+4`` all have the same value at various "
"precisions. Is there a way to transform them to a single recognizable "
"canonical value?"
msgstr ""
"Q. 같은 값을 표현하는 여러 가지 방법이 있습니다. 숫자 :const:`200`, :const:`200.000`, "
":const:`2E2`, 그리고 :const:`.02E+4` 는 모두 다양한 정밀도로 같은 값을 가집니다. 이것들은 단일하게 인식할"
" 수 있는 표준적인 값으로 변환할 방법이 있습니까?"

#: ../../library/decimal.rst:2127
#, fuzzy
msgid ""
"A. The :meth:`~Decimal.normalize` method maps all equivalent values to a "
"single representative:"
msgstr "A. the :meth:`normalize` 메서드는 모든 해당 값을 단일 표현으로 매핑합니다:"

#: ../../library/decimal.rst:2134
msgid "Q. When does rounding occur in a computation?"
msgstr ""

#: ../../library/decimal.rst:2136
msgid ""
"A. It occurs *after* the computation.  The philosophy of the decimal "
"specification is that numbers are considered exact and are created "
"independent of the current context.  They can even have greater precision"
" than current context.  Computations process with those exact inputs and "
"then rounding (or other context operations) is applied to the *result* of"
" the computation::"
msgstr ""

#: ../../library/decimal.rst:2143
msgid ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535')   # More than 5 digits\n"
">>> pi                             # All digits are retained\n"
"Decimal('3.1415926535')\n"
">>> pi + 0                         # Rounded after an addition\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005')        # Subtract unrounded numbers, then "
"round\n"
"Decimal('3.1415')\n"
">>> pi + 0 - Decimal('0.00005').   # Intermediate values are rounded\n"
"Decimal('3.1416')"
msgstr ""

#: ../../library/decimal.rst:2154
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there "
"a way to get a non-exponential representation?"
msgstr "Q. 일부 십진수 값은 항상 지수 표기법으로 인쇄됩니다. 지수가 아닌 표현을 얻을 방법이 있습니까?"

#: ../../library/decimal.rst:2157
#, fuzzy
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing"
" ``5.0E+3`` as ``5000`` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"A. 일부 값의 경우, 지수 표기법만이 계수에 있는 유효 숫자를 나타낼 수 있습니다. 예를 들어 :const:`5.0E+3`\\을 "
":const:`5000`\\으로 표현하면 값은 일정하게 유지되지만, 원본의 두 자리 유효숫자를 표시할 수 없습니다."

#: ../../library/decimal.rst:2162
msgid ""
"If an application does not care about tracking significance, it is easy "
"to remove the exponent and trailing zeroes, losing significance, but "
"keeping the value unchanged:"
msgstr ""
"응용 프로그램이 유효 숫자를 추적하는 데 신경 쓰지 않으면, 지수 및 후행 0을 제거하고 유효숫자를 잃지만, 값이 바뀌지 않도록 "
"하기는 쉽습니다:"

#: ../../library/decimal.rst:2172
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr "Q. 일반 float를 :class:`Decimal`\\로 변환하는 방법이 있습니까?"

#: ../../library/decimal.rst:2174
#, fuzzy
msgid ""
"A. Yes, any binary floating-point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition"
" would suggest:"
msgstr ""
"A. 그렇습니다. 모든 이진 부동 소수점은 Decimal로 정확히 표현될 수 있습니다. 하지만 정확한 변환이 취하는 정밀도는 직관이"
" 제안하는 것보다 더 클 수 있습니다:"

#: ../../library/decimal.rst:2178
msgid ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"
msgstr ""

#: ../../library/decimal.rst:2183
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't "
"gotten a spurious result because of insufficient precision or rounding "
"anomalies."
msgstr "Q. 복잡한 계산에서, 정밀도가 부족하거나 자리 올림 이상이 발생하여 엉터리 결과를 얻지는 않았는지 확인하려면 어떻게 해야 합니까?"

#: ../../library/decimal.rst:2186
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is "
"to re-run calculations using greater precision and with various rounding "
"modes. Widely differing results indicate insufficient precision, rounding"
" mode issues, ill-conditioned inputs, or a numerically unstable "
"algorithm."
msgstr ""
"A. decimal 모듈은 결과를 쉽게 테스트할 수 있게 합니다. 가장 좋은 방법은 더 높은 정밀도와 다양한 자리 올림 모드를 "
"사용하여 계산을 다시 실행하는 것입니다. 크게 다른 결과는 정밀도 부족, 자리 올림 모드 문제, 부적절한 입력 또는 수치가 불안정한"
" 알고리즘을 나타냅니다."

#: ../../library/decimal.rst:2191
msgid ""
"Q. I noticed that context precision is applied to the results of "
"operations but not to the inputs.  Is there anything to watch out for "
"when mixing values of different precisions?"
msgstr "컨텍스트 정밀도가 입력이 아닌 연산 결과에 적용된다는 사실을 확인했습니다. 다른 정밀도의 값을 혼합할 때 주의해야 할 것이 있습니까?"

#: ../../library/decimal.rst:2195
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and "
"so is the arithmetic on those values.  Only the results are rounded.  The"
" advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the "
"inputs haven't been rounded:"
msgstr ""
"A. 그렇습니다. 원칙은 모든 값이 정확한 것으로 간주하므로 해당 값에 대한 산술도 마찬가지라는 것입니다. 결과 만 자리 올림 "
"됩니다. 입력에 대한 이점은 \"입력하는 것이 얻는 것\"이라는 것입니다. 단점은 입력값을 자리 올림 하는 것을 잊어버리면 결과가 "
"이상하게 보일 수 있다는 점입니다:"

#: ../../library/decimal.rst:2200
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"
msgstr ""

#: ../../library/decimal.rst:2208
msgid ""
"The solution is either to increase precision or to force rounding of "
"inputs using the unary plus operation:"
msgstr "해법은 정밀도를 높이거나 단항 플러스 연산을 사용하여 입력의 자리 올림을 강제 수행하는 것입니다:"

#: ../../library/decimal.rst:2211
msgid ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # unary plus triggers rounding\n"
"Decimal('1.23')"
msgstr ""

#: ../../library/decimal.rst:2217
msgid ""
"Alternatively, inputs can be rounded upon creation using the "
":meth:`Context.create_decimal` method:"
msgstr ""
"다른 방법으로, 입력은 :meth:`Context.create_decimal` 메서드를 사용하여 생성 시에 자리 올림 될 수 "
"있습니다:"

#: ../../library/decimal.rst:2223
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "Q. CPython 구현은 커다란 수에서 빠릅니까?"

#: ../../library/decimal.rst:2225
#, fuzzy
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of"
" the decimal module integrate the high speed `libmpdec "
"<https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ library "
"for arbitrary precision correctly rounded decimal floating-point "
"arithmetic [#]_. ``libmpdec`` uses `Karatsuba multiplication "
"<https://en.wikipedia.org/wiki/Karatsuba_algorithm>`_ for medium-sized "
"numbers and the `Number Theoretic Transform "
"<https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general"
")#Number-theoretic_transform>`_ for very large numbers."
msgstr ""
"A. 예. CPython 과 PyPy3 구현에서, decimal 모듈의 C/CFFI 버전은 임의의 정밀도로 올바르게 자리 올림 되는"
" 십진 부동 소수점 산술을 위한 고속 `libmpdec "
"<https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ 라이브러리를 "
"통합합니다 [#]_. ``libmpdec``\\는 중간 크기의 숫자에는 `카라추바 곱셈(Karatsuba "
"multiplication) <https://en.wikipedia.org/wiki/Karatsuba_algorithm>`_\\을 "
"사용하고 매우 큰 숫자에는 `수론적 변환(Number Theoretic Transform) "
"<https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general"
")#Number-theoretic_transform>`_\\을 사용합니다."

#: ../../library/decimal.rst:2235
#, fuzzy
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. "
":attr:`~Context.Emin` and :attr:`~Context.Emax` should always be set to "
"the maximum values, :attr:`~Context.clamp` should always be 0 (the "
"default).  Setting :attr:`~Context.prec` requires some care."
msgstr ""
"컨텍스트는 정확한 임의 정밀도 산술에 맞게 조정되어야 합니다. :attr:`Emin`\\과 :attr:`Emax`\\는 항상 "
"최댓값으로 설정해야 하며, :attr:`clamp`\\는 항상 0(기본값)이어야 합니다. :attr:`prec`\\를 설정하려면 "
"약간의 주의가 필요합니다."

#: ../../library/decimal.rst:2239
#, fuzzy
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the "
"maximum value for :attr:`~Context.prec` as well [#]_::"
msgstr "큰 숫자 산술을 시도하는 가장 쉬운 방법은 :attr:`prec`\\의 최댓값도 사용하는 것입니다 [#]_::"

#: ../../library/decimal.rst:2242
msgid ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"
msgstr ""

#: ../../library/decimal.rst:2248
#, fuzzy
msgid ""
"For inexact results, :const:`MAX_PREC` is far too large on 64-bit "
"platforms and the available memory will be insufficient::"
msgstr ""
"부정확한 결과의 경우, 64비트 플랫폼에서 :attr:`MAX_PREC`\\는 너무 크고 사용 가능한 메모리가 충분하지 않을 "
"것입니다::"

#: ../../library/decimal.rst:2251
msgid ""
">>> Decimal(1) / 3\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"MemoryError"
msgstr ""

#: ../../library/decimal.rst:2256
#, fuzzy
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated "
"approach is to adjust :attr:`~Context.prec` to the amount of available "
"RAM.  Suppose that you have 8GB of RAM and expect 10 simultaneous "
"operands using a maximum of 500MB each::"
msgstr ""
"초과 할당(overallocation)이 있는 시스템(예를 들어 리눅스)에서, 더 정교한 접근 방식은 :attr:`prec`\\를 "
"사용 가능한 RAM의 양으로 조정하는 것입니다. RAM이 8GB이고 각각 최대 500MB를 사용하는 피연산자 10개가 동시에 있다고"
" 가정합시다::"

#: ../../library/decimal.rst:2260
msgid ""
">>> import sys\n"
">>>\n"
">>> # Maximum number of digits for a single operand using 500MB in 8-byte"
" words\n"
">>> # with 19 digits per word (4-byte and 9 digits for the 32-bit build):"
"\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # Check that this works:\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # Fill the available precision with nines:\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"
msgstr ""

#: ../../library/decimal.rst:2280
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` "
"trap if all calculations are expected to be exact."
msgstr ""
"일반적으로 (그리고 특히 초과 할당이 없는 시스템에서), 더 엄격한 경계를 추정하고 모든 계산이 정확할 것으로 예상되면 "
":attr:`Inexact` 트랩을 설정하는 것이 좋습니다."

#: ../../library/decimal.rst:2289
msgid ""
"This approach now works for all exact results except for non-integer "
"powers."
msgstr "이 접근법은 정수가 아닌 거듭제곱을 제외한 모든 정확한 결과에 적용됩니다."

#~ msgid "Classmethod that converts a float to a decimal number, exactly."
#~ msgstr "float를 십진수로 정확하게 변환하는 클래스 메서드."

#~ msgid ""
#~ "Normalize the number by stripping the"
#~ " rightmost trailing zeros and converting"
#~ " any result equal to :const:`Decimal('0')`"
#~ " to :const:`Decimal('0e0')`. Used for "
#~ "producing canonical values for attributes "
#~ "of an equivalence class. For example,"
#~ " ``Decimal('32.100')`` and ``Decimal('0.321000e+2')``"
#~ " both normalize to the equivalent "
#~ "value ``Decimal('32.1')``."
#~ msgstr ""
#~ "가장 오른쪽 끝에 오는 0을 제거하고 결과를 "
#~ ":const:`Decimal('0')`\\과 같은 모든 결과를 "
#~ ":const:`Decimal('0e0')`\\으로 변환하여 숫자를 정규화합니다. "
#~ "등가 클래스의 어트리뷰트에 대한 규범적인 값을 만드는 "
#~ "데 사용됩니다. 예를 들어, ``Decimal('32.100')`` 과"
#~ " ``Decimal('0.321000e+2')`` 는 모두 같은 값인 "
#~ "``Decimal('32.1')`` 로 정규화됩니다."

#~ msgid "backported to 3.7 and 3.8."
#~ msgstr "3.7과 3.8로 역 이식되었습니다."

