# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/selectors.rst:2
#, fuzzy
msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ":mod:`selectors` --- 고수준 I/O 다중화"

#: ../../library/selectors.rst:9
msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr "**소스 코드:** :source:`Lib/selectors.py`"

#: ../../library/selectors.rst:14
msgid "Introduction"
msgstr "소개"

#: ../../library/selectors.rst:16
msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon "
"the :mod:`select` module primitives. Users are encouraged to use this "
"module instead, unless they want precise control over the OS-level "
"primitives used."
msgstr ""
"이 모듈은 :mod:`select` 모듈 프리미티브에 기반하여 고수준의 효율적인 I/O 다중화를 가능하게 합니다. 사용되는 OS "
"수준 프리미티브를 정확하게 제어하고 싶지 않으면, 사용자는 이 모듈을 대신 사용하는 것이 좋습니다."

#: ../../library/selectors.rst:20
#, fuzzy
msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with "
"several concrete implementations (:class:`KqueueSelector`, "
":class:`EpollSelector`...), that can be used to wait for I/O readiness "
"notification on multiple file objects. In the following, \"file object\" "
"refers to any object with a :meth:`~io.IOBase.fileno` method, or a raw "
"file descriptor. See :term:`file object`."
msgstr ""
"여러 파일 객체에 대한 I/O 준비 알림을 기다리는 데 사용할 수 있는 몇 가지 구체적인 구현 "
"(:class:`KqueueSelector`, :class:`EpollSelector`...)과 함께 "
":class:`BaseSelector` 추상 베이스 클래스를 정의합니다. 다음에서 \"파일 객체\"는 :meth:`fileno()`"
" 메서드가 있는 모든 객체나 날 파일 기술자를 가리킵니다. :term:`파일 객체 <file object>`\\를 참조하십시오."

#: ../../library/selectors.rst:26
msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation"
" available on the current platform: this should be the default choice for"
" most users."
msgstr ""
":class:`DefaultSelector`\\는 현재 플랫폼에서 사용할 수 있는 가장 효율적인 구현의 별칭입니다: 대부분 사용자는"
" 기본적으로 이것을 선택해야 합니다."

#: ../../library/selectors.rst:31
msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported"
" (some other types may be supported as well, such as fifos or special "
"file devices)."
msgstr ""
"지원되는 파일 객체의 유형은 플랫폼에 따라 다릅니다: 윈도우에서는 소켓은 지원되지만, 파이프는 지원되지 않습니다. 반면에, "
"유닉스에서는 둘 다 지원됩니다 (fifo나 특수 파일 장치와 같은 다른 유형도 지원될 수 있습니다)."

#: ../../library/selectors.rst:38
msgid ":mod:`select`"
msgstr ":mod:`select`"

#: ../../library/selectors.rst:39
msgid "Low-level I/O multiplexing module."
msgstr "저수준 I/O 다중화 모듈."

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid "Availability"
msgstr "쓰기 가능"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/selectors.rst:44
msgid "Classes"
msgstr "클래스"

#: ../../library/selectors.rst:46
msgid "Classes hierarchy::"
msgstr "클래스 계층 구조::"

#: ../../library/selectors.rst:48
msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""

#: ../../library/selectors.rst:56
msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of "
"the modules constants below:"
msgstr ""
"다음에서, *events*\\는 주어진 파일 객체에서 어떤 I/O 이벤트를 기다려야 하는지를 나타내는 비트 마스크입니다. 다음 모듈"
" 상수의 조합일 수 있습니다:"

#: ../../library/selectors.rst:61
msgid "Constant"
msgstr "상수"

#: ../../library/selectors.rst:61
msgid "Meaning"
msgstr "의미"

#: ../../library/selectors.rst:63
msgid "Available for read"
msgstr "읽기 가능"

#: ../../library/selectors.rst:65
msgid "Available for write"
msgstr "쓰기 가능"

#: ../../library/selectors.rst:71
msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event"
" mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""
":class:`SelectorKey`\\는 파일 객체에 그것의 하부 파일 기술자, 선택한 이벤트 마스크 및 첨부된 데이터를 연결하는"
" 데 사용되는 :class:`~collections.namedtuple`\\입니다. 여러 :class:`BaseSelector` "
"메서드에 의해 반환됩니다."

#: ../../library/selectors.rst:78
msgid "File object registered."
msgstr "등록된 파일 객체."

#: ../../library/selectors.rst:82
msgid "Underlying file descriptor."
msgstr "하부 파일 기술자."

#: ../../library/selectors.rst:86
msgid "Events that must be waited for on this file object."
msgstr "이 파일 객체에서 기다려야 하는 이벤트."

#: ../../library/selectors.rst:90
msgid ""
"Optional opaque data associated to this file object: for example, this "
"could be used to store a per-client session ID."
msgstr "이 파일 객체에 연결된 선택적인 불투명한 데이터: 예를 들어, 이것은 클라이언트별 세션 ID를 저장하는 데 사용될 수 있습니다."

#: ../../library/selectors.rst:96
msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on "
"multiple file objects. It supports file stream registration, "
"unregistration, and a method to wait for I/O events on those streams, "
"with an optional timeout. It's an abstract base class, so cannot be "
"instantiated. Use :class:`DefaultSelector` instead, or one of "
":class:`SelectSelector`, :class:`KqueueSelector` etc. if you want to "
"specifically use an implementation, and your platform supports it. "
":class:`BaseSelector` and its concrete implementations support the "
":term:`context manager` protocol."
msgstr ""
":class:`BaseSelector`\\는 여러 파일 객체에 대한 I/O 이벤트 준비를 기다리는 데 사용됩니다. 파일 스트림 "
"등록, 등록 취소 및 선택적 제한 시간과 함께 해당 스트림에서 I/O 이벤트를 기다리는 메서드를 지원합니다. 추상 베이스 "
"클래스이므로, 인스턴스를 만들 수 없습니다. :class:`DefaultSelector`\\를 대신 사용하거나, 특정 구현을 "
"사용하고 싶고, 플랫폼에서 지원한다면 :class:`SelectSelector`, :class:`KqueueSelector` 등을 "
"사용하십시오. :class:`BaseSelector`\\와 그것의 구상 구현은 :term:`컨텍스트 관리자 <context "
"manager>` 프로토콜을 지원합니다."

#: ../../library/selectors.rst:109
msgid "Register a file object for selection, monitoring it for I/O events."
msgstr "I/O 이벤트를 셀렉트하고 감시하기 위한 파일 객체를 등록합니다."

#: ../../library/selectors.rst:111
msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer "
"file descriptor or an object with a ``fileno()`` method. *events* is a "
"bitwise mask of events to monitor. *data* is an opaque object."
msgstr ""
"*fileobj*\\는 감시할 파일 객체입니다. 정수 파일 기술자이거나 ``fileno()`` 메서드를 가진 객체일 수 있습니다. "
"*events*\\는 감시할 이벤트의 비트 마스크입니다. *data*\\는 불투명한 객체입니다."

#: ../../library/selectors.rst:116
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a "
":exc:`ValueError` in case of invalid event mask or file descriptor, or "
":exc:`KeyError` if the file object is already registered."
msgstr ""
"새로운 :class:`SelectorKey` 인스턴스를 반환하거나, 유효하지 않은 이벤트 마스크나 파일 기술자의 경우 "
":exc:`ValueError`\\를, 파일 객체가 이미 등록된 경우 :exc:`KeyError`\\를 발생시킵니다."

#: ../../library/selectors.rst:123
msgid ""
"Unregister a file object from selection, removing it from monitoring. A "
"file object shall be unregistered prior to being closed."
msgstr "셀렉트로부터 파일 객체를 등록 해지하고, 감시에서 삭제합니다. 파일 객체는 닫히기 전에 등록 해지되어야 합니다."

#: ../../library/selectors.rst:126
msgid "*fileobj* must be a file object previously registered."
msgstr "*fileobj*\\는 이전에 등록된 파일 객체여야 합니다."

#: ../../library/selectors.rst:128
msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises a "
":exc:`KeyError` if *fileobj* is not registered.  It will raise "
":exc:`ValueError` if *fileobj* is invalid (e.g. it has no ``fileno()`` "
"method or its ``fileno()`` method has an invalid return value)."
msgstr ""
"연결된 :class:`SelectorKey` 인스턴스를 반환하거나, *fileobj*\\가 등록되어 있지 않으면 "
":exc:`KeyError`\\를 발생시킵니다. *fileobj*\\가 유효하지 않으면 (예를 들어, ``fileno()`` "
"메서드가 없거나 ``fileno()`` 메서드가 유효하지 않은 반환 값을 가지면) :exc:`ValueError`\\가 발생합니다."

#: ../../library/selectors.rst:135
msgid "Change a registered file object's monitored events or attached data."
msgstr "등록된 파일 객체의 감시되는 이벤트나 첨부된 데이터를 변경합니다."

#: ../../library/selectors.rst:137
#, fuzzy
msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""
"이것은 더 효율적으로 구현될 수 있다는 점을 제외하면, :meth:`BaseSelector.unregister(fileobj)` "
"다음에 :meth:`BaseSelector.register(fileobj, events, data)`\\하는 것과 동등합니다."

#: ../../library/selectors.rst:141
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a "
":exc:`ValueError` in case of invalid event mask or file descriptor, or "
":exc:`KeyError` if the file object is not registered."
msgstr ""
"새로운 :class:`SelectorKey` 인스턴스를 반환하거나, 유효하지 않은 이벤트 마스크나 파일 기술자의 경우 "
":exc:`ValueError`\\를, 파일 객체가 등록되지 않았으면 :exc:`KeyError`\\를 발생시킵니다."

#: ../../library/selectors.rst:148
msgid ""
"Wait until some registered file objects become ready, or the timeout "
"expires."
msgstr "등록된 파일 객체의 일부가 준비될 때까지 기다리거나, 제한 시간이 만료됩니다."

#: ../../library/selectors.rst:151
msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently "
"ready file objects. If *timeout* is ``None``, the call will block until a"
" monitored file object becomes ready."
msgstr ""
"``timeout > 0`` 이면, 최대 대기 시간을 초로 지정합니다. ``timeout <= 0``\\이면, 호출은 블록하지 "
"않고, 현재 준비된 파일 객체를 보고합니다. *timeout*\\이 ``None``\\이면, 감시되는 파일 객체가 준비될 때까지 "
"호출이 블록 됩니다."

#: ../../library/selectors.rst:157
msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr "각 준비된 파일 객체마다 하나씩, ``(key, events)`` 튜플의 리스트를 반환합니다."

#: ../../library/selectors.rst:160
msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""
"*key*\\는 준비된 파일 객체에 해당하는 :class:`SelectorKey` 인스턴스입니다. *events*\\는 이 파일 "
"객체에서 준비된 이벤트의 비트 마스크입니다."

#: ../../library/selectors.rst:165
msgid ""
"This method can return before any file object becomes ready or the "
"timeout has elapsed if the current process receives a signal: in this "
"case, an empty list will be returned."
msgstr ""
"현재 프로세스가 시그널을 받으면, 이 메서드는 파일 객체가 준비되거나 제한 시간이 지나기 전에 반환할 수 있습니다: 이때는 빈 "
"리스트가 반환됩니다."

#: ../../library/selectors.rst:169
msgid ""
"The selector is now retried with a recomputed timeout when interrupted by"
" a signal if the signal handler did not raise an exception (see "
":pep:`475` for the rationale), instead of returning an empty list of "
"events before the timeout."
msgstr ""
"시그널에 의해 인터럽트 되었을 때, 셀렉터는 이제 시그널 처리기가 예외를 발생시키지 않으면, 제한 시간 이전에 빈 이벤트 리스트를 "
"반환하는 대신, 재계산 된 제한 시간으로 재 시도됩니다 (근거는 :pep:`475`\\를 참조하세요)."

#: ../../library/selectors.rst:177
msgid "Close the selector."
msgstr "셀렉터를 닫습니다."

#: ../../library/selectors.rst:179
msgid ""
"This must be called to make sure that any underlying resource is freed. "
"The selector shall not be used once it has been closed."
msgstr "모든 하부 자원을 해제하기 위해 이 메서드를 호출해야 합니다. 일단 닫은 후에는 셀렉터를 더는 사용하지 않아야 합니다."

#: ../../library/selectors.rst:184
msgid "Return the key associated with a registered file object."
msgstr "등록된 파일 객체에 연결된 키를 반환합니다."

#: ../../library/selectors.rst:186
msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""
"이 파일 객체에 연결된 :class:`SelectorKey` 인스턴스를 반환하거나, 파일 객체가 등록되지 않았으면 "
":exc:`KeyError`\\를 발생시킵니다."

#: ../../library/selectors.rst:192
msgid "Return a mapping of file objects to selector keys."
msgstr "파일 객체에서 셀렉터로의 매핑을 반환합니다."

#: ../../library/selectors.rst:194
msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping "
"registered file objects to their associated :class:`SelectorKey` "
"instance."
msgstr ""
"등록된 파일 객체를 연결된 :class:`SelectorKey` 인스턴스로 매핑하는 "
":class:`~collections.abc.Mapping` 인스턴스를 반환합니다."

#: ../../library/selectors.rst:201
msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""
"현재의 플랫폼에서 사용할 수 있는 가장 효율적인 구현을 사용하는 기본 셀렉터 클래스입니다. 대부분 사용자는 기본적으로 이것을 "
"선택해야 합니다."

#: ../../library/selectors.rst:208
msgid ":func:`select.select`-based selector."
msgstr ":func:`select.select` 기반 셀렉터."

#: ../../library/selectors.rst:213
msgid ":func:`select.poll`-based selector."
msgstr ":func:`select.poll` 기반 셀렉터."

#: ../../library/selectors.rst:218
msgid ":func:`select.epoll`-based selector."
msgstr ":func:`select.epoll` 기반 셀렉터."

#: ../../library/selectors.rst:222
msgid ""
"This returns the file descriptor used by the underlying "
":func:`select.epoll` object."
msgstr "하부 :func:`select.epoll` 객체에서 사용하는 파일 기술자를 반환합니다."

#: ../../library/selectors.rst:227
msgid ":func:`select.devpoll`-based selector."
msgstr ":func:`select.devpoll` 기반 셀렉터."

#: ../../library/selectors.rst:231
msgid ""
"This returns the file descriptor used by the underlying "
":func:`select.devpoll` object."
msgstr "하부 :func:`select.devpoll` 객체에서 사용하는 파일 기술자를 반환합니다."

#: ../../library/selectors.rst:238
msgid ":func:`select.kqueue`-based selector."
msgstr ":func:`select.kqueue` 기반 셀렉터."

#: ../../library/selectors.rst:242
msgid ""
"This returns the file descriptor used by the underlying "
":func:`select.kqueue` object."
msgstr "하부 :func:`select.kqueue` 객체에서 사용하는 파일 기술자를 반환합니다."

#: ../../library/selectors.rst:247
msgid "Examples"
msgstr "예제"

#: ../../library/selectors.rst:249
msgid "Here is a simple echo server implementation::"
msgstr "다음은 간단한 메아리 서버 구현입니다::"

#: ../../library/selectors.rst:251
msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""

#~ msgid ":const:`EVENT_READ`"
#~ msgstr ":const:`EVENT_READ`"

#~ msgid ":const:`EVENT_WRITE`"
#~ msgstr ":const:`EVENT_WRITE`"

