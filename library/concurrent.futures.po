# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/concurrent.futures.rst:2
#, fuzzy
msgid ":mod:`!concurrent.futures` --- Launching parallel tasks"
msgstr ":mod:`concurrent.futures` --- 병렬 작업 실행하기"

#: ../../library/concurrent.futures.rst:9
msgid ""
"**Source code:** :source:`Lib/concurrent/futures/thread.py` and "
":source:`Lib/concurrent/futures/process.py`"
msgstr ""
"**소스 코드:** :source:`Lib/concurrent/futures/thread.py`\\와 "
":source:`Lib/concurrent/futures/process.py`"

#: ../../library/concurrent.futures.rst:14
msgid ""
"The :mod:`concurrent.futures` module provides a high-level interface for "
"asynchronously executing callables."
msgstr ":mod:`concurrent.futures` 모듈은 비동기적으로 콜러블을 실행하는 고수준 인터페이스를 제공합니다."

#: ../../library/concurrent.futures.rst:17
msgid ""
"The asynchronous execution can be performed with threads, using "
":class:`ThreadPoolExecutor`, or separate processes, using "
":class:`ProcessPoolExecutor`.  Both implement the same interface, which "
"is defined by the abstract :class:`Executor` class."
msgstr ""
"비동기 실행은 (:class:`ThreadPoolExecutor`\\를 사용해서) 스레드나 "
"(:class:`ProcessPoolExecutor`\\를 사용해서) 별도의 프로세스로 수행 할 수 있습니다. 둘 다 추상 "
":class:`Executor` 클래스로 정의된 것과 같은 인터페이스를 구현합니다."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/concurrent.futures.rst:25
msgid "Executor Objects"
msgstr "Executor 객체"

#: ../../library/concurrent.futures.rst:29
msgid ""
"An abstract class that provides methods to execute calls asynchronously."
"  It should not be used directly, but through its concrete subclasses."
msgstr ""
"비동기적으로 호출을 실행하는 메서드를 제공하는 추상 클래스입니다. 직접 사용해서는 안 되며, 구체적인 하위 클래스를 통해 사용해야 "
"합니다."

#: ../../library/concurrent.futures.rst:34
#, fuzzy
msgid ""
"Schedules the callable, *fn*, to be executed as ``fn(*args, **kwargs)`` "
"and returns a :class:`Future` object representing the execution of the "
"callable. ::"
msgstr ""
"콜러블 *fn* 이 ``fn(*args **kwargs)`` 처럼 실행되도록 예약하고, 콜러블 객체의 실행을 나타내는 "
":class:`Future` 객체를 반환합니다. ::"

#: ../../library/concurrent.futures.rst:38
msgid ""
"with ThreadPoolExecutor(max_workers=1) as executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"
msgstr ""

#: ../../library/concurrent.futures.rst:44
#, fuzzy
msgid "Similar to :func:`map(fn, *iterables) <map>` except:"
msgstr ":func:`map(func, *iterables) <map>` 과 비슷하지만, 다음과 같은 차이가 있습니다:"

#: ../../library/concurrent.futures.rst:46
msgid "the *iterables* are collected immediately rather than lazily;"
msgstr "*iterables* 는 느긋하게 처리되는 것이 아니라 즉시 수집됩니다."

#: ../../library/concurrent.futures.rst:48
#, fuzzy
msgid ""
"*fn* is executed asynchronously and several calls to *fn* may be made "
"concurrently."
msgstr "*func* 는 비동기적으로 실행되며 *func* 에 대한 여러 호출이 동시에 이루어질 수 있습니다."

#: ../../library/concurrent.futures.rst:51
#, fuzzy
msgid ""
"The returned iterator raises a :exc:`TimeoutError` if "
":meth:`~iterator.__next__` is called and the result isn't available after"
" *timeout* seconds from the original call to :meth:`Executor.map`. "
"*timeout* can be an int or a float.  If *timeout* is not specified or "
"``None``, there is no limit to the wait time."
msgstr ""
"반환된 이터레이터는 :meth:`~iterator.__next__` 가 호출되었을 때, :meth:`Executor.map` 에 "
"대한 최초 호출에서 *timeout* 초 후에도 결과를 사용할 수 없는 경우 "
":exc:`concurrent.futures.TimeoutError` 를 발생시킵니다. *timeout* 은 int 또는 "
"float가 될 수 있습니다. *timeout* 이 지정되지 않았거나 ``None`` 인 경우, 대기 시간에는 제한이 없습니다."

#: ../../library/concurrent.futures.rst:57
#, fuzzy
msgid ""
"If a *fn* call raises an exception, then that exception will be raised "
"when its value is retrieved from the iterator."
msgstr "*func* 호출이 예외를 일으키면, 값을 이터레이터에서 꺼낼 때 해당 예외가 발생합니다."

#: ../../library/concurrent.futures.rst:60
msgid ""
"When using :class:`ProcessPoolExecutor`, this method chops *iterables* "
"into a number of chunks which it submits to the pool as separate tasks.  "
"The (approximate) size of these chunks can be specified by setting "
"*chunksize* to a positive integer.  For very long iterables, using a "
"large value for *chunksize* can significantly improve performance "
"compared to the default size of 1.  With :class:`ThreadPoolExecutor`, "
"*chunksize* has no effect."
msgstr ""
":class:`ProcessPoolExecutor`\\를 사용할 때, 이 메서드는 *iterables* 를 다수의 덩어리로 잘라서 "
"별도의 작업으로 풀에 제출합니다. 이러한 덩어리의 (대략적인) 크기는 *chunksize* 를 양의 정수로 설정하여 지정할 수 "
"있습니다. 매우 긴 이터러블의 경우 *chunksize* 에 큰 값을 사용하면 기본 크기인 1에 비해 성능이 크게 향상될 수 "
"있습니다. :class:`ThreadPoolExecutor` 의 경우, *chunksize* 는 아무런 효과가 없습니다."

#: ../../library/concurrent.futures.rst:68
msgid "Added the *chunksize* argument."
msgstr "*chunksize* 인자가 추가되었습니다."

#: ../../library/concurrent.futures.rst:73
msgid ""
"Signal the executor that it should free any resources that it is using "
"when the currently pending futures are done executing.  Calls to "
":meth:`Executor.submit` and :meth:`Executor.map` made after shutdown will"
" raise :exc:`RuntimeError`."
msgstr ""
"현재 계류 중인 퓨처가 실행 완료될 때, 사용 중인 모든 자원을 해제해야 한다는 것을 실행기에 알립니다. 종료(shutdown) "
"후에 이루어지는 :meth:`Executor.submit` 과 :meth:`Executor.map` 호출은 "
":exc:`RuntimeError` 를 발생시킵니다."

#: ../../library/concurrent.futures.rst:78
msgid ""
"If *wait* is ``True`` then this method will not return until all the "
"pending futures are done executing and the resources associated with the "
"executor have been freed.  If *wait* is ``False`` then this method will "
"return immediately and the resources associated with the executor will be"
" freed when all pending futures are done executing.  Regardless of the "
"value of *wait*, the entire Python program will not exit until all "
"pending futures are done executing."
msgstr ""
"*wait* 가 ``True`` 면, 계류 중인 모든 퓨처가 실행을 마치고 실행기와 관련된 자원이 해제될 때까지 이 메서드는 "
"돌아오지 않습니다. *wait* 가 ``False`` 면, 이 메서드는 즉시 돌아오고 실행기와 연관된 자원은 계류 중인 모든 퓨처가"
" 실행을 마칠 때 해제됩니다. *wait* 의 값과 관계없이, 모든 계류 중인 퓨처가 실행을 마칠 때까지 전체 파이썬 프로그램이 "
"종료되지 않습니다."

#: ../../library/concurrent.futures.rst:86
msgid ""
"If *cancel_futures* is ``True``, this method will cancel all pending "
"futures that the executor has not started running. Any futures that are "
"completed or running won't be cancelled, regardless of the value of "
"*cancel_futures*."
msgstr ""
"*cancel_futures*\\가 ``True``\\이면, 이 메서드는 실행기가 실행을 시작시키지 않은 계류 중인 모든 퓨처를 "
"취소합니다. *cancel_futures*\\의 값과 관계없이 완료되었거나 실행 중인 퓨처는 취소되지 않습니다."

#: ../../library/concurrent.futures.rst:91
msgid ""
"If both *cancel_futures* and *wait* are ``True``, all futures that the "
"executor has started running will be completed prior to this method "
"returning. The remaining futures are cancelled."
msgstr ""
"*cancel_futures*\\와 *wait*\\가 모두 ``True``\\이면, 이 메서드가 반환하기 전에 실행기가 실행을 "
"시작한 모든 퓨처가 완료됩니다. 나머지 퓨처는 취소됩니다."

#: ../../library/concurrent.futures.rst:95
msgid ""
"You can avoid having to call this method explicitly if you use the "
":keyword:`with` statement, which will shutdown the :class:`Executor` "
"(waiting as if :meth:`Executor.shutdown` were called with *wait* set to "
"``True``)::"
msgstr ""
":keyword:`with` 문을 사용하여 :class:`Executor`\\를 종료시키면 "
"(:meth:`Executor.shutdown` 를 *wait* 값 ``True`` 로 호출한 것처럼 대기합니다), 이 메서드를 "
"명시적으로 호출할 필요가 없어집니다.::"

#: ../../library/concurrent.futures.rst:100
msgid ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"
msgstr ""

#: ../../library/concurrent.futures.rst:107
msgid "Added *cancel_futures*."
msgstr "*cancel_futures*\\를 추가했습니다."

#: ../../library/concurrent.futures.rst:112
msgid "ThreadPoolExecutor"
msgstr "ThreadPoolExecutor"

#: ../../library/concurrent.futures.rst:114
msgid ""
":class:`ThreadPoolExecutor` is an :class:`Executor` subclass that uses a "
"pool of threads to execute calls asynchronously."
msgstr ""
":class:`ThreadPoolExecutor` 는 스레드 풀을 사용하여 호출을 비동기적으로 실행하는 "
":class:`Executor` 서브 클래스입니다."

#: ../../library/concurrent.futures.rst:117
msgid ""
"Deadlocks can occur when the callable associated with a :class:`Future` "
"waits on the results of another :class:`Future`.  For example::"
msgstr ""
":class:`Future`\\와 관련된 콜러블 객체가 다른 :class:`Future` 의 결과를 기다릴 때 교착 상태가 발생할 "
"수 있습니다. 예를 들면::"

#: ../../library/concurrent.futures.rst:120
msgid ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b will never complete because it is waiting on "
"a.\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a will never complete because it is waiting on "
"b.\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"
msgstr ""

#: ../../library/concurrent.futures.rst:136
msgid "And::"
msgstr "그리고::"

#: ../../library/concurrent.futures.rst:138
msgid ""
"def wait_on_future():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # This will never complete because there is only one worker thread "
"and\n"
"    # it is executing this function.\n"
"    print(f.result())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(wait_on_future)"
msgstr ""

#: ../../library/concurrent.futures.rst:150
msgid ""
"An :class:`Executor` subclass that uses a pool of at most *max_workers* "
"threads to execute calls asynchronously."
msgstr "최대 *max_workers* 스레드의 풀을 사용하여 호출을 비동기적으로 실행하는 :class:`Executor` 서브 클래스."

#: ../../library/concurrent.futures.rst:153
msgid ""
"All threads enqueued to ``ThreadPoolExecutor`` will be joined before the "
"interpreter can exit. Note that the exit handler which does this is "
"executed *before* any exit handlers added using ``atexit``. This means "
"exceptions in the main thread must be caught and handled in order to "
"signal threads to exit gracefully. For this reason, it is recommended "
"that ``ThreadPoolExecutor`` not be used for long-running tasks."
msgstr ""

#: ../../library/concurrent.futures.rst:160
msgid ""
"*initializer* is an optional callable that is called at the start of each"
" worker thread; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently "
"pending jobs will raise a "
":exc:`~concurrent.futures.thread.BrokenThreadPool`, as well as any "
"attempt to submit more jobs to the pool."
msgstr ""
"*initializer* 는 각 작업자 스레드의 시작 부분에서 호출되는 선택적 콜러블입니다; *initargs* 는 "
"initializer에 전달되는 인자들의 튜플입니다. *initializer* 가 예외를 발생시키는 경우, 현재 계류 중인 모든 "
"작업과 풀에 추가로 작업을 제출하려는 시도는 "
":exc:`~concurrent.futures.thread.BrokenThreadPool` 을 발생시킵니다."

#: ../../library/concurrent.futures.rst:166
msgid ""
"If *max_workers* is ``None`` or not given, it will default to the number "
"of processors on the machine, multiplied by ``5``, assuming that "
":class:`ThreadPoolExecutor` is often used to overlap I/O instead of CPU "
"work and the number of workers should be higher than the number of "
"workers for :class:`ProcessPoolExecutor`."
msgstr ""
"*max_workers* 가 ``None`` 이거나 주어지지 않았다면, 기본값으로 기계의 프로세서 수에 ``5`` 를 곱한 값을 "
"사용합니다. :class:`ThreadPoolExecutor` 가 CPU 작업보다는 I/O를 동시에 진행하는데 자주 쓰이고, "
"작업자의 수가 :class:`ProcessPoolExecutor` 보다 많아야 한다고 가정하고 있습니다."

#: ../../library/concurrent.futures.rst:174
#, fuzzy
msgid ""
"Added the *thread_name_prefix* parameter to allow users to control the "
":class:`threading.Thread` names for worker threads created by the pool "
"for easier debugging."
msgstr ""
"*thread_name_prefix* 인자가 추가되어, 디버깅 편의를 위해 사용자가 풀이 만드는 작업자 스레드의 "
":class:`threading.Thread` 이름을 제어 할 수 있습니다."

#: ../../library/concurrent.futures.rst:179
#: ../../library/concurrent.futures.rst:287
msgid "Added the *initializer* and *initargs* arguments."
msgstr "*initializer* 및 *initargs* 인자가 추가되었습니다."

#: ../../library/concurrent.futures.rst:182
msgid ""
"Default value of *max_workers* is changed to ``min(32, os.cpu_count() + "
"4)``. This default value preserves at least 5 workers for I/O bound "
"tasks. It utilizes at most 32 CPU cores for CPU bound tasks which release"
" the GIL. And it avoids using very large resources implicitly on many-"
"core machines."
msgstr ""
"*max_workers*\\의 기본값은 ``min(32, os.cpu_count() + 4)``\\로 변경됩니다. 이 기본값은 "
"I/O 병목 작업을 위해 최소 5개의 작업자를 유지합니다. GIL을 반납하는 CPU 병목 작업을 위해 최대 32개의 CPU 코어를 "
"사용합니다. 또한 많은 코어를 가진 시스템에서 매우 큰 자원을 묵시적으로 사용하는 것을 방지합니다."

#: ../../library/concurrent.futures.rst:188
msgid ""
"ThreadPoolExecutor now reuses idle worker threads before starting "
"*max_workers* worker threads too."
msgstr "ThreadPoolExecutor는 이제 *max_workers* 작업자 스레드를 시작하기 전에 유휴 작업자 스레드를 재사용합니다."

#: ../../library/concurrent.futures.rst:191
msgid ""
"Default value of *max_workers* is changed to ``min(32, "
"(os.process_cpu_count() or 1) + 4)``."
msgstr ""

#: ../../library/concurrent.futures.rst:199
msgid "ThreadPoolExecutor Example"
msgstr "ThreadPoolExecutor 예제"

#: ../../library/concurrent.futures.rst:202
#, python-brace-format, python-format
msgid ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistent-subdomain.python.org/']\n"
"\n"
"# Retrieve a single page and report the URL and contents\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# We can use a with statement to ensure threads are cleaned up promptly\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # Start the load operations and mark each future with its URL\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in "
"URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r generated an exception: %s' % (url, exc))\n"
"        else:\n"
"            print('%r page is %d bytes' % (url, len(data)))"
msgstr ""

#: ../../library/concurrent.futures.rst:231
msgid "ProcessPoolExecutor"
msgstr "ProcessPoolExecutor"

#: ../../library/concurrent.futures.rst:233
msgid ""
"The :class:`ProcessPoolExecutor` class is an :class:`Executor` subclass "
"that uses a pool of processes to execute calls asynchronously. "
":class:`ProcessPoolExecutor` uses the :mod:`multiprocessing` module, "
"which allows it to side-step the :term:`Global Interpreter Lock <global "
"interpreter lock>` but also means that only picklable objects can be "
"executed and returned."
msgstr ""
":class:`ProcessPoolExecutor` 클래스는 프로세스 풀을 사용하여 호출을 비동기적으로 실행하는 "
":class:`Executor` 서브 클래스입니다. :class:`ProcessPoolExecutor` 는 "
":mod:`multiprocessing` 모듈을 사용합니다. :term:`전역 인터프리터 록 <global interpreter "
"lock>` 을 피할 수 있도록 하지만, 오직 피클 가능한 객체만 실행되고 반환될 수 있음을 의미합니다."

#: ../../library/concurrent.futures.rst:240
msgid ""
"The ``__main__`` module must be importable by worker subprocesses. This "
"means that :class:`ProcessPoolExecutor` will not work in the interactive "
"interpreter."
msgstr ""
"``__main__`` 모듈은 작업자 서브 프로세스가 임포트 할 수 있어야 합니다. 즉, "
":class:`ProcessPoolExecutor` 는 대화형 인터프리터에서 작동하지 않습니다."

#: ../../library/concurrent.futures.rst:243
msgid ""
"Calling :class:`Executor` or :class:`Future` methods from a callable "
"submitted to a :class:`ProcessPoolExecutor` will result in deadlock."
msgstr ""
":class:`ProcessPoolExecutor` 에 제출된 콜러블에서 :class:`Executor` 나 "
":class:`Future` 메서드를 호출하면 교착 상태가 발생합니다."

#: ../../library/concurrent.futures.rst:248
#, fuzzy
msgid ""
"An :class:`Executor` subclass that executes calls asynchronously using a "
"pool of at most *max_workers* processes.  If *max_workers* is ``None`` or"
" not given, it will default to :func:`os.process_cpu_count`. If "
"*max_workers* is less than or equal to ``0``, then a :exc:`ValueError` "
"will be raised. On Windows, *max_workers* must be less than or equal to "
"``61``. If it is not then :exc:`ValueError` will be raised. If "
"*max_workers* is ``None``, then the default chosen will be at most "
"``61``, even if more processors are available. *mp_context* can be a "
":mod:`multiprocessing` context or ``None``. It will be used to launch the"
" workers. If *mp_context* is ``None`` or not given, the default "
":mod:`multiprocessing` context is used. See :ref:`multiprocessing-start-"
"methods`."
msgstr ""
"최대 *max_workers* 프로세스의 풀을 사용하여 호출을 비동기적으로 실행하는 :class:`Executor` 서브 클래스. "
"*max_workers* 가 ``None`` 이거나 주어지지 않았다면, 기계의 프로세서 수를 기본값으로 사용합니다. "
"*max_workers* 가 ``0`` 보다 작거나 같으면 :exc:`ValueError` 가 발생합니다. 윈도우에서, "
"*max_workers*\\는 ``61``\\보다 작거나 같아야 합니다. 그렇지 않으면 :exc:`ValueError`\\가 "
"발생합니다. *max_workers*\\가 ``None`` 이면, 더 많은 프로세서를 사용할 수 있다 할지라도 선택된 기본값은 최대"
" ``61``\\이 될 것입니다. *mp_context* 는 multiprocessing 컨텍스트이거나 None일 수 있습니다. "
"작업자들을 만드는데 사용될 것입니다. *mp_context* 가 ``None`` 이거나 주어지지 않으면 기본 "
"multiprocessing 컨텍스트가 사용됩니다."

#: ../../library/concurrent.futures.rst:262
msgid ""
"*initializer* is an optional callable that is called at the start of each"
" worker process; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently "
"pending jobs will raise a "
":exc:`~concurrent.futures.process.BrokenProcessPool`, as well as any "
"attempt to submit more jobs to the pool."
msgstr ""
"*initializer* 는 각 작업자 프로세스의 시작 부분에서 호출되는 선택적 콜러블입니다; *initargs* 는 "
"initializer에 전달되는 인자들의 튜플입니다. *initializer* 가 예외를 발생시키는 경우, 현재 계류 중인 모든 "
"작업과 풀에 추가로 작업을 제출하려는 시도는 "
":exc:`~concurrent.futures.process.BrokenProcessPool` 을 발생시킵니다."

#: ../../library/concurrent.futures.rst:268
msgid ""
"*max_tasks_per_child* is an optional argument that specifies the maximum "
"number of tasks a single process can execute before it will exit and be "
"replaced with a fresh worker process. By default *max_tasks_per_child* is"
" ``None`` which means worker processes will live as long as the pool. "
"When a max is specified, the \"spawn\" multiprocessing start method will "
"be used by default in absence of a *mp_context* parameter. This feature "
"is incompatible with the \"fork\" start method."
msgstr ""

#: ../../library/concurrent.futures.rst:276
#, fuzzy
msgid ""
"When one of the worker processes terminates abruptly, a "
":exc:`~concurrent.futures.process.BrokenProcessPool` error is now raised."
" Previously, behaviour was undefined but operations on the executor or "
"its futures would often freeze or deadlock."
msgstr ""
"작업자 프로세스 중 하나가 갑자기 종료되면, :exc:`BrokenProcessPool` 오류가 발생합니다. 이전에는, 동작이 "
"정의되지 않았지만, 실행기나 그 퓨처에 대한 연산이 종종 멈추거나 교착 상태에 빠졌습니다."

#: ../../library/concurrent.futures.rst:283
msgid ""
"The *mp_context* argument was added to allow users to control the "
"start_method for worker processes created by the pool."
msgstr "*mp_context* 인자가 추가되어 사용자가 풀에서 만드는 작업자 프로세스의 시작 방법을 제어 할 수 있습니다."

#: ../../library/concurrent.futures.rst:290
msgid ""
"The default :mod:`multiprocessing` start method (see :ref"
":`multiprocessing-start-methods`) will change away from *fork* in Python "
"3.14.  Code that requires *fork* be used for their "
":class:`ProcessPoolExecutor` should explicitly specify that by passing a "
"``mp_context=multiprocessing.get_context(\"fork\")`` parameter."
msgstr ""

#: ../../library/concurrent.futures.rst:297
#, fuzzy
msgid ""
"The *max_tasks_per_child* argument was added to allow users to control "
"the lifetime of workers in the pool."
msgstr "*mp_context* 인자가 추가되어 사용자가 풀에서 만드는 작업자 프로세스의 시작 방법을 제어 할 수 있습니다."

#: ../../library/concurrent.futures.rst:301
msgid ""
"On POSIX systems, if your application has multiple threads and the "
":mod:`multiprocessing` context uses the ``\"fork\"`` start method: The "
":func:`os.fork` function called internally to spawn workers may raise a "
":exc:`DeprecationWarning`. Pass a *mp_context* configured to use a "
"different start method. See the :func:`os.fork` documentation for further"
" explanation."
msgstr ""

#: ../../library/concurrent.futures.rst:309
msgid ""
"*max_workers* uses :func:`os.process_cpu_count` by default, instead of "
":func:`os.cpu_count`."
msgstr ""

#: ../../library/concurrent.futures.rst:316
msgid "ProcessPoolExecutor Example"
msgstr "ProcessPoolExecutor 예제"

#: ../../library/concurrent.futures.rst:319
#, python-format
msgid ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):"
"\n"
"            print('%d is prime: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../library/concurrent.futures.rst:354
msgid "Future Objects"
msgstr "Future 객체"

#: ../../library/concurrent.futures.rst:356
msgid ""
"The :class:`Future` class encapsulates the asynchronous execution of a "
"callable. :class:`Future` instances are created by "
":meth:`Executor.submit`."
msgstr ""
":class:`Future` 클래스는 콜러블 객체의 비동기 실행을 캡슐화합니다. :class:`Future` 인스턴스는 "
":meth:`Executor.submit` 에 의해 생성됩니다."

#: ../../library/concurrent.futures.rst:361
msgid ""
"Encapsulates the asynchronous execution of a callable.  :class:`Future` "
"instances are created by :meth:`Executor.submit` and should not be "
"created directly except for testing."
msgstr ""
"콜러블 객체의 비동기 실행을 캡슐화합니다. :class:`Future` 인스턴스는 :meth:`Executor.submit` 에 "
"의해 생성되며 테스트를 제외하고는 직접 생성되어서는 안 됩니다."

#: ../../library/concurrent.futures.rst:367
msgid ""
"Attempt to cancel the call.  If the call is currently being executed or "
"finished running and cannot be cancelled then the method will return "
"``False``, otherwise the call will be cancelled and the method will "
"return ``True``."
msgstr ""
"호출을 취소하려고 시도합니다. 호출이 현재 실행 중이거나 실행 종료했고 취소할 수 없는 경우 메서드는 ``False`` 를 "
"반환하고, 그렇지 않으면 호출이 취소되고 메서드는 ``True`` 를 반환합니다."

#: ../../library/concurrent.futures.rst:374
msgid "Return ``True`` if the call was successfully cancelled."
msgstr "호출이 성공적으로 취소되었으면 ``True`` 를 반환합니다."

#: ../../library/concurrent.futures.rst:378
msgid ""
"Return ``True`` if the call is currently being executed and cannot be "
"cancelled."
msgstr "호출이 현재 실행 중이고 취소할 수 없는 경우 ``True`` 를 반환합니다."

#: ../../library/concurrent.futures.rst:383
msgid ""
"Return ``True`` if the call was successfully cancelled or finished "
"running."
msgstr "호출이 성공적으로 취소되었거나 실행이 완료되었으면 ``True`` 를 반환합니다."

#: ../../library/concurrent.futures.rst:388
#, fuzzy
msgid ""
"Return the value returned by the call. If the call hasn't yet completed "
"then this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a :exc:`TimeoutError` will be "
"raised. *timeout* can be an int or float.  If *timeout* is not specified "
"or ``None``, there is no limit to the wait time."
msgstr ""
"호출이 반환한 값을 돌려줍니다. 호출이 아직 완료되지 않는 경우, 이 메서드는 *timeout* 초까지 대기합니다. "
"*timeout* 초 내에 호출이 완료되지 않으면 :exc:`concurrent.futures.TimeoutError` 가 "
"발생합니다. *timeout* 은 int 또는 float가 될 수 있습니다. *timeout* 이 지정되지 않았거나 ``None``"
" 인 경우, 대기 시간에는 제한이 없습니다."

#: ../../library/concurrent.futures.rst:395
#: ../../library/concurrent.futures.rst:409
msgid ""
"If the future is cancelled before completing then :exc:`.CancelledError` "
"will be raised."
msgstr "완료하기 전에 퓨처가 취소되면 :exc:`.CancelledError` 가 발생합니다."

#: ../../library/concurrent.futures.rst:398
#, fuzzy
msgid ""
"If the call raised an exception, this method will raise the same "
"exception."
msgstr "호출이 예외를 일으키는 경우, 이 메서드는 같은 예외를 발생시킵니다."

#: ../../library/concurrent.futures.rst:402
#, fuzzy
msgid ""
"Return the exception raised by the call.  If the call hasn't yet "
"completed then this method will wait up to *timeout* seconds.  If the "
"call hasn't completed in *timeout* seconds, then a :exc:`TimeoutError` "
"will be raised.  *timeout* can be an int or float.  If *timeout* is not "
"specified or ``None``, there is no limit to the wait time."
msgstr ""
"호출이 일으킨 예외를 돌려줍니다. 호출이 아직 완료되지 않는 경우, 이 메서드는 *timeout* 초까지 대기합니다. "
"*timeout* 초 내에 호출이 완료되지 않으면 :exc:`concurrent.futures.TimeoutError` 가 "
"발생합니다. *timeout* 은 int 또는 float가 될 수 있습니다. *timeout* 이 지정되지 않았거나 ``None``"
" 인 경우, 대기 시간에는 제한이 없습니다."

#: ../../library/concurrent.futures.rst:412
msgid "If the call completed without raising, ``None`` is returned."
msgstr "호출이 예외 없이 완료되면, ``None`` 이 반환됩니다."

#: ../../library/concurrent.futures.rst:416
msgid ""
"Attaches the callable *fn* to the future.  *fn* will be called, with the "
"future as its only argument, when the future is cancelled or finishes "
"running."
msgstr "콜러블 *fn* 을 퓨처에 연결합니다. *fn* 은 퓨처가 취소되거나 실행이 종료될 때 퓨처를 유일한 인자로 호출됩니다."

#: ../../library/concurrent.futures.rst:420
msgid ""
"Added callables are called in the order that they were added and are "
"always called in a thread belonging to the process that added them.  If "
"the callable raises an :exc:`Exception` subclass, it will be logged and "
"ignored.  If the callable raises a :exc:`BaseException` subclass, the "
"behavior is undefined."
msgstr ""
"추가된 콜러블은 추가된 순서대로 호출되며, 항상 콜러블을 추가한 프로세스에 속하는 스레드에서 호출됩니다. 콜러블이 "
":exc:`Exception` 서브 클래스를 발생시키면, 로그 되고 무시됩니다. 콜러블이 :exc:`BaseException` 서브"
" 클래스를 발생시키면, 동작은 정의되지 않습니다."

#: ../../library/concurrent.futures.rst:426
msgid ""
"If the future has already completed or been cancelled, *fn* will be "
"called immediately."
msgstr "퓨처가 이미 완료되었거나 취소된 경우 *fn* 이 즉시 호출됩니다."

#: ../../library/concurrent.futures.rst:429
msgid ""
"The following :class:`Future` methods are meant for use in unit tests and"
" :class:`Executor` implementations."
msgstr "다음 :class:`Future` 메서드는 단위 테스트와 :class:`Executor` 의 구현을 위한 것입니다."

#: ../../library/concurrent.futures.rst:434
msgid ""
"This method should only be called by :class:`Executor` implementations "
"before executing the work associated with the :class:`Future` and by unit"
" tests."
msgstr ""
"이 메서드는 :class:`Future`\\와 관련된 작업을 실행하기 전에 :class:`Executor` 구현에 의해서만 "
"호출되거나 단위 테스트에서만 호출되어야 합니다."

#: ../../library/concurrent.futures.rst:438
#, fuzzy
msgid ""
"If the method returns ``False`` then the :class:`Future` was cancelled, "
"i.e. :meth:`Future.cancel` was called and returned ``True``.  Any threads"
" waiting on the :class:`Future` completing (i.e. through "
":func:`as_completed` or :func:`wait`) will be woken up."
msgstr ""
"메서드가 ``False`` 를 반환하면, :class:`Future` 가 취소된 것입니다. 즉 "
":meth:`Future.cancel` 이 호출되었고 `True`\\를 반환했습니다. :class:`Future` 완료를 기다리는 "
"(즉, :func:`as_completed` 또는 :func:`wait`\\를 통해) 모든 스레드는 깨어납니다."

#: ../../library/concurrent.futures.rst:443
#, fuzzy
msgid ""
"If the method returns ``True`` then the :class:`Future` was not cancelled"
" and has been put in the running state, i.e. calls to "
":meth:`Future.running` will return ``True``."
msgstr ""
"메서드가 ``True`` 를 반환하면, :class:`Future` 가 취소되지 않았고 실행 상태로 진입했습니다. 즉 "
":meth:`Future.running` 을 호출하면 `True` 가 반환됩니다."

#: ../../library/concurrent.futures.rst:447
msgid ""
"This method can only be called once and cannot be called after "
":meth:`Future.set_result` or :meth:`Future.set_exception` have been "
"called."
msgstr ""
"이 메서드는 한 번만 호출 할 수 있으며, :meth:`Future.set_result` 또는 "
":meth:`Future.set_exception` 이 호출 된 후에는 호출할 수 없습니다."

#: ../../library/concurrent.futures.rst:453
msgid ""
"Sets the result of the work associated with the :class:`Future` to "
"*result*."
msgstr ":class:`Future`\\와 관련된 작업 결과를 *result* 로 설정합니다."

#: ../../library/concurrent.futures.rst:456
#: ../../library/concurrent.futures.rst:469
msgid ""
"This method should only be used by :class:`Executor` implementations and "
"unit tests."
msgstr "이 메서드는 :class:`Executor` 구현과 단위 테스트에서만 사용해야 합니다."

#: ../../library/concurrent.futures.rst:459
#: ../../library/concurrent.futures.rst:472
msgid ""
"This method raises :exc:`concurrent.futures.InvalidStateError` if the "
":class:`Future` is already done."
msgstr ""
"이 메서드는 :class:`Future`\\가 이미 완료되었으면 "
":exc:`concurrent.futures.InvalidStateError`\\를 발생시킵니다."

#: ../../library/concurrent.futures.rst:466
msgid ""
"Sets the result of the work associated with the :class:`Future` to the "
":class:`Exception` *exception*."
msgstr ":class:`Future`\\와 관련된 작업 결과를 :class:`Exception` *exception* 으로 설정합니다."

#: ../../library/concurrent.futures.rst:478
msgid "Module Functions"
msgstr "모듈 함수"

#: ../../library/concurrent.futures.rst:482
#, fuzzy
msgid ""
"Wait for the :class:`Future` instances (possibly created by different "
":class:`Executor` instances) given by *fs* to complete. Duplicate futures"
" given to *fs* are removed and will be returned only once. Returns a "
"named 2-tuple of sets.  The first set, named ``done``, contains the "
"futures that completed (finished or cancelled futures) before the wait "
"completed.  The second set, named ``not_done``, contains the futures that"
" did not complete (pending or running futures)."
msgstr ""
"*fs* 로 주어진 여러 (서로 다른 :class:`Executor` 인스턴스가 만든 것들도 가능합니다) "
":class:`Future` 인스턴스들이 완료할 때까지 기다립니다. 집합들의 이름있는 2-튜플을 돌려줍니다. ``done`` 이라는"
" 이름의 첫 번째 집합은 대기가 끝나기 전에 완료된 (끝났거나 취소된) 퓨처를 담고 있습니다. ``not_done`` 이라는 이름의"
" 두 번째 집합은 완료되지 않은 (계류 중이거나 실행 중인) 퓨처를 담고 있습니다."

#: ../../library/concurrent.futures.rst:490
msgid ""
"*timeout* can be used to control the maximum number of seconds to wait "
"before returning.  *timeout* can be an int or float.  If *timeout* is not"
" specified or ``None``, there is no limit to the wait time."
msgstr ""
"*timeout* 은 반환하기 전에 대기 할 최대 시간(초)을 제어하는 데 사용할 수 있습니다. *timeout* 은 int 또는 "
"float가 될 수 있습니다. *timeout* 이 지정되지 않았거나 ``None`` 인 경우, 대기 시간에는 제한이 없습니다."

#: ../../library/concurrent.futures.rst:494
msgid ""
"*return_when* indicates when this function should return.  It must be one"
" of the following constants:"
msgstr "*return_when* 은, 이 함수가 언제 반환되어야 하는지를 나타냅니다. 다음 상수 중 하나여야 합니다:"

#: ../../library/concurrent.futures.rst:500
msgid "Constant"
msgstr "상수"

#: ../../library/concurrent.futures.rst:501
msgid "Description"
msgstr "설명"

#: ../../library/concurrent.futures.rst:504
msgid "The function will return when any future finishes or is cancelled."
msgstr "퓨처가 어느 하나라도 끝나거나 취소될 때 함수가 반환됩니다."

#: ../../library/concurrent.futures.rst:507
#, fuzzy
msgid ""
"The function will return when any future finishes by raising an "
"exception. If no future raises an exception then it is equivalent to "
":const:`ALL_COMPLETED`."
msgstr ""
"어느 한 퓨처가 예외를 일으켜 완료하면 함수가 반환됩니다. 어떤 퓨처도 예외를 발생시키지 않으면 "
":const:`ALL_COMPLETED`\\와 같습니다."

#: ../../library/concurrent.futures.rst:512
msgid "The function will return when all futures finish or are cancelled."
msgstr "모든 퓨처가 끝나거나 취소되면 함수가 반환됩니다."

#: ../../library/concurrent.futures.rst:516
#, fuzzy
msgid ""
"Returns an iterator over the :class:`Future` instances (possibly created "
"by different :class:`Executor` instances) given by *fs* that yields "
"futures as they complete (finished or cancelled futures). Any futures "
"given by *fs* that are duplicated will be returned once. Any futures that"
" completed before :func:`as_completed` is called will be yielded first.  "
"The returned iterator raises a :exc:`TimeoutError` if "
":meth:`~iterator.__next__` is called and the result isn't available after"
" *timeout* seconds from the original call to :func:`as_completed`.  "
"*timeout* can be an int or float. If *timeout* is not specified or "
"``None``, there is no limit to the wait time."
msgstr ""
"*fs* 로 주어진 여러 (서로 다른 :class:`Executor` 인스턴스가 만든 것들도 가능합니다) 퓨처들이 완료되는 대로 "
"(끝났거나 취소된 퓨처) 일드 하는 :class:`Future` 인스턴스의 이터레이터를 반환합니다. *fs* 에 중복된 퓨처가 "
"들어있으면 한 번만 반환됩니다. :func:`as_completed` 가 호출되기 전에 완료한 모든 퓨처들이 먼저 일드 됩니다. "
"반환된 이터레이터는, :meth:`~iterator.__next__` 가 호출되고, :func:`as_completed` 호출 "
"시점으로부터 *timeout* 초 후에 결과를 얻을 수 없는 경우 "
":exc:`concurrent.futures.TimeoutError` 를 발생시킵니다. *timeout* 은 int 또는 "
"float가 될 수 있습니다. *timeout* 이 지정되지 않았거나 ``None`` 인 경우, 대기 시간에는 제한이 없습니다."

#: ../../library/concurrent.futures.rst:529
msgid ":pep:`3148` -- futures - execute computations asynchronously"
msgstr ":pep:`3148` -- 퓨처 - 계산을 비동기적으로 실행"

#: ../../library/concurrent.futures.rst:530
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "파이썬 표준 라이브러리에 포함하기 위해, 이 기능을 설명한 제안."

#: ../../library/concurrent.futures.rst:535
msgid "Exception classes"
msgstr "예외 클래스"

#: ../../library/concurrent.futures.rst:541
msgid "Raised when a future is cancelled."
msgstr "퓨처가 취소될 때 발생합니다."

#: ../../library/concurrent.futures.rst:545
#, fuzzy
msgid ""
"A deprecated alias of :exc:`TimeoutError`, raised when a future operation"
" exceeds the given timeout."
msgstr "퓨처 연산이 지정된 시간제한을 초과할 때 발생합니다."

#: ../../library/concurrent.futures.rst:550
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr ""

#: ../../library/concurrent.futures.rst:555
msgid ""
"Derived from :exc:`RuntimeError`, this exception class is raised when an "
"executor is broken for some reason, and cannot be used to submit or "
"execute new tasks."
msgstr ""
":exc:`RuntimeError` 에서 파생됩니다, 이 예외 클래스는 어떤 이유로 실행기가 망가져서 새 작업을 제출하거나 실행할 "
"수 없을 때 발생합니다."

#: ../../library/concurrent.futures.rst:563
msgid ""
"Raised when an operation is performed on a future that is not allowed in "
"the current state."
msgstr "퓨처에 현재 상태에서 허용되지 않는 연산이 수행될 때 발생합니다."

#: ../../library/concurrent.futures.rst:572
#, fuzzy
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor`, this exception "
"class is raised when one of the workers of a "
":class:`~concurrent.futures.ThreadPoolExecutor` has failed initializing."
msgstr ""
":exc:`~concurrent.futures.BrokenExecutor` 에서 파생됩니다, 이 예외 클래스는 "
":class:`ThreadPoolExecutor` 의 작업자 중 하나가 초기화에 실패했을 때 발생합니다."

#: ../../library/concurrent.futures.rst:583
#, fuzzy
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor` (formerly "
":exc:`RuntimeError`), this exception class is raised when one of the "
"workers of a :class:`~concurrent.futures.ProcessPoolExecutor` has "
"terminated in a non-clean fashion (for example, if it was killed from the"
" outside)."
msgstr ""
":exc:`~concurrent.futures.BrokenExecutor` 에서 파생됩니다 (예전에는 "
":exc:`RuntimeError`), 이 예외 클래스는 :class:`ProcessPoolExecutor` 의 작업자 중 하나가 "
"깨끗하지 못한 방식으로 (예를 들어, 외부에서 강제 종료된 경우) 종료되었을 때 발생합니다."

#~ msgid ":const:`FIRST_COMPLETED`"
#~ msgstr ":const:`FIRST_COMPLETED`"

#~ msgid ":const:`FIRST_EXCEPTION`"
#~ msgstr ":const:`FIRST_EXCEPTION`"

#~ msgid ":const:`ALL_COMPLETED`"
#~ msgstr ":const:`ALL_COMPLETED`"

