# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/enum.rst:2
#, fuzzy
msgid ":mod:`!enum` --- Support for enumerations"
msgstr ":mod:`enum` --- 열거형 지원"

#: ../../library/enum.rst:14
msgid "**Source code:** :source:`Lib/enum.py`"
msgstr "**소스 코드:** :source:`Lib/enum.py`"

#: ../../library/enum.rst:18
msgid ""
"This page contains the API reference information. For tutorial "
"information and discussion of more advanced topics, see"
msgstr ""

#: ../../library/enum.rst:21
msgid ":ref:`Basic Tutorial <enum-basic-tutorial>`"
msgstr ""

#: ../../library/enum.rst:22
msgid ":ref:`Advanced Tutorial <enum-advanced-tutorial>`"
msgstr ""

#: ../../library/enum.rst:23
msgid ":ref:`Enum Cookbook <enum-cookbook>`"
msgstr ""

#: ../../library/enum.rst:27
#, fuzzy
msgid "An enumeration:"
msgstr "파생된 열거형"

#: ../../library/enum.rst:29
msgid "is a set of symbolic names (members) bound to unique values"
msgstr ""

#: ../../library/enum.rst:30
msgid ""
"can be iterated over to return its canonical (i.e. non-alias) members in "
"definition order"
msgstr ""

#: ../../library/enum.rst:32
msgid "uses *call* syntax to return members by value"
msgstr ""

#: ../../library/enum.rst:33
msgid "uses *index* syntax to return members by name"
msgstr ""

#: ../../library/enum.rst:35
msgid ""
"Enumerations are created either by using :keyword:`class` syntax, or by "
"using function-call syntax::"
msgstr ""

#: ../../library/enum.rst:38
msgid ""
">>> from enum import Enum\n"
"\n"
">>> # class syntax\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"\n"
">>> # functional syntax\n"
">>> Color = Enum('Color', [('RED', 1), ('GREEN', 2), ('BLUE', 3)])"
msgstr ""

#: ../../library/enum.rst:49
#, fuzzy
msgid ""
"Even though we can use :keyword:`class` syntax to create Enums, Enums are"
" not normal Python classes.  See :ref:`How are Enums different? <enum-"
"class-differences>` for more details."
msgstr ""
":keyword:`class` 문법을 사용하여 Enum을 만들더라도, Enum은 일반적인 파이썬 클래스가 아닙니다. 자세한 내용은 "
"`열거형은 어떻게 다릅니까? <How are Enums different?_>`_ 를 참조하십시오."

#: ../../library/enum.rst:53
msgid "Nomenclature"
msgstr "명명법"

#: ../../library/enum.rst:55
#, fuzzy
msgid "The class :class:`!Color` is an *enumeration* (or *enum*)"
msgstr ":class:`Color` 클래스는 *열거형(enumeration)* (또는 *enum*) 입니다."

#: ../../library/enum.rst:56
#, fuzzy
msgid ""
"The attributes :attr:`!Color.RED`, :attr:`!Color.GREEN`, etc., are "
"*enumeration members* (or *members*) and are functionally constants."
msgstr ""
":attr:`Color.RED`, :attr:`Color.GREEN` 등의 어트리뷰트는 *열거형 멤버(enumeration "
"members)*\\(또는 *enum members*)이며 기능상 상수입니다."

#: ../../library/enum.rst:58
#, fuzzy
msgid ""
"The enum members have *names* and *values* (the name of "
":attr:`!Color.RED` is ``RED``, the value of :attr:`!Color.BLUE` is ``3``,"
" etc.)"
msgstr ""
"열거형 멤버에는 *이름(names)*\\과 *값(values)*\\이 있습니다 (:attr:`Color.RED`\\의 이름은 "
"``RED``, :attr:`Color.BLUE`\\의 값은 ``3``, 등)"

#: ../../library/enum.rst:65
msgid "Module Contents"
msgstr "모듈 내용"

#: ../../library/enum.rst:67
#, fuzzy
msgid ":class:`EnumType`"
msgstr ":class:`auto` 사용하기"

#: ../../library/enum.rst:69
msgid "The ``type`` for Enum and its subclasses."
msgstr ""

#: ../../library/enum.rst:71
#, fuzzy
msgid ":class:`Enum`"
msgstr ":class:`auto` 사용하기"

#: ../../library/enum.rst:73
#, fuzzy
msgid "Base class for creating enumerated constants."
msgstr ":class:`int`\\의 서브 클래스이기도 한 열거형 상수를 만들기 위한 베이스 클래스."

#: ../../library/enum.rst:75
#, fuzzy
msgid ":class:`IntEnum`"
msgstr "IntEnum"

#: ../../library/enum.rst:77
#, fuzzy
msgid ""
"Base class for creating enumerated constants that are also subclasses of "
":class:`int`. (`Notes`_)"
msgstr ":class:`int`\\의 서브 클래스이기도 한 열거형 상수를 만들기 위한 베이스 클래스."

#: ../../library/enum.rst:80
msgid ":class:`StrEnum`"
msgstr ""

#: ../../library/enum.rst:82
#, fuzzy
msgid ""
"Base class for creating enumerated constants that are also subclasses of "
":class:`str`. (`Notes`_)"
msgstr ":class:`int`\\의 서브 클래스이기도 한 열거형 상수를 만들기 위한 베이스 클래스."

#: ../../library/enum.rst:85
#, fuzzy
msgid ":class:`Flag`"
msgstr ":class:`auto` 사용하기"

#: ../../library/enum.rst:87
msgid ""
"Base class for creating enumerated constants that can be combined using "
"the bitwise operations without losing their :class:`Flag` membership."
msgstr ":class:`Flag` 멤버십을 잃지 않고 비트 연산을 사용하여 결합할 수 있는 열거형 상수를 만들기 위한 베이스 클래스."

#: ../../library/enum.rst:90
#, fuzzy
msgid ":class:`IntFlag`"
msgstr "예제 :class:`IntFlag` 클래스::"

#: ../../library/enum.rst:92
#, fuzzy
msgid ""
"Base class for creating enumerated constants that can be combined using "
"the bitwise operators without losing their :class:`IntFlag` membership. "
":class:`IntFlag` members are also subclasses of :class:`int`. (`Notes`_)"
msgstr ""
":class:`IntFlag` 멤버십을 잃지 않고 비트 연산자를 사용하여 결합할 수 있는 열거형 상수를 만들기 위한 베이스 클래스."
" :class:`IntFlag` 멤버도 :class:`int`\\의 서브 클래스입니다."

#: ../../library/enum.rst:96
msgid ":class:`ReprEnum`"
msgstr ""

#: ../../library/enum.rst:98
msgid ""
"Used by :class:`IntEnum`, :class:`StrEnum`, and :class:`IntFlag` to keep "
"the :class:`str() <str>` of the mixed-in type."
msgstr ""

#: ../../library/enum.rst:101
msgid ":class:`EnumCheck`"
msgstr ""

#: ../../library/enum.rst:103
msgid ""
"An enumeration with the values ``CONTINUOUS``, ``NAMED_FLAGS``, and "
"``UNIQUE``, for use with :func:`verify` to ensure various constraints are"
" met by a given enumeration."
msgstr ""

#: ../../library/enum.rst:107
msgid ":class:`FlagBoundary`"
msgstr ""

#: ../../library/enum.rst:109
msgid ""
"An enumeration with the values ``STRICT``, ``CONFORM``, ``EJECT``, and "
"``KEEP`` which allows for more fine-grained control over how invalid "
"values are dealt with in an enumeration."
msgstr ""

#: ../../library/enum.rst:113
#, fuzzy
msgid ":class:`EnumDict`"
msgstr ":class:`object` 사용하기"

#: ../../library/enum.rst:115
msgid "A subclass of :class:`dict` for use when subclassing :class:`EnumType`."
msgstr ""

#: ../../library/enum.rst:117
#, fuzzy
msgid ":class:`auto`"
msgstr ":class:`auto` 사용하기"

#: ../../library/enum.rst:119
msgid ""
"Instances are replaced with an appropriate value for Enum members. "
":class:`StrEnum` defaults to the lower-cased version of the member name, "
"while other Enums default to 1 and increase from there."
msgstr ""

#: ../../library/enum.rst:123
msgid ":func:`~enum.property`"
msgstr ""

#: ../../library/enum.rst:125
msgid ""
"Allows :class:`Enum` members to have attributes without conflicting with "
"member names.  The ``value`` and ``name`` attributes are implemented this"
" way."
msgstr ""

#: ../../library/enum.rst:129
msgid ":func:`unique`"
msgstr ""

#: ../../library/enum.rst:131
msgid "Enum class decorator that ensures only one name is bound to any one value."
msgstr "한 값에 하나의 이름 만 연결되도록 하는 Enum 클래스 데코레이터."

#: ../../library/enum.rst:133
msgid ":func:`verify`"
msgstr ""

#: ../../library/enum.rst:135
msgid ""
"Enum class decorator that checks user-selectable constraints on an "
"enumeration."
msgstr ""

#: ../../library/enum.rst:138
msgid ":func:`member`"
msgstr ""

#: ../../library/enum.rst:140
msgid "Make ``obj`` a member.  Can be used as a decorator."
msgstr ""

#: ../../library/enum.rst:142
msgid ":func:`nonmember`"
msgstr ""

#: ../../library/enum.rst:144
msgid "Do not make ``obj`` a member.  Can be used as a decorator."
msgstr ""

#: ../../library/enum.rst:146
msgid ":func:`global_enum`"
msgstr ""

#: ../../library/enum.rst:148
msgid ""
"Modify the :class:`str() <str>` and :func:`repr` of an enum to show its "
"members as belonging to the module instead of its class, and export the "
"enum members to the global namespace."
msgstr ""

#: ../../library/enum.rst:152
msgid ":func:`show_flag_values`"
msgstr ""

#: ../../library/enum.rst:154
msgid "Return a list of all power-of-two integers contained in a flag."
msgstr ""

#: ../../library/enum.rst:157
msgid "``Flag``, ``IntFlag``, ``auto``"
msgstr "``Flag``, ``IntFlag``, ``auto``"

#: ../../library/enum.rst:158
msgid ""
"``StrEnum``, ``EnumCheck``, ``ReprEnum``, ``FlagBoundary``, ``property``,"
" ``member``, ``nonmember``, ``global_enum``, ``show_flag_values``"
msgstr ""

#: ../../library/enum.rst:159
msgid "``EnumDict``"
msgstr ""

#: ../../library/enum.rst:164
msgid "Data Types"
msgstr ""

#: ../../library/enum.rst:169
msgid ""
"*EnumType* is the :term:`metaclass` for *enum* enumerations.  It is "
"possible to subclass *EnumType* -- see :ref:`Subclassing EnumType "
"<enumtype-examples>` for details."
msgstr ""

#: ../../library/enum.rst:173
msgid ""
"``EnumType`` is responsible for setting the correct :meth:`!__repr__`, "
":meth:`!__str__`, :meth:`!__format__`, and :meth:`!__reduce__` methods on"
" the final *enum*, as well as creating the enum members, properly "
"handling duplicates, providing iteration over the enum class, etc."
msgstr ""

#: ../../library/enum.rst:180
msgid "This method is called in two different ways:"
msgstr ""

#: ../../library/enum.rst:182
msgid "to look up an existing member:"
msgstr ""

#: ../../library/enum.rst
msgid "cls"
msgstr ""

#: ../../library/enum.rst:184 ../../library/enum.rst:190
msgid "The enum class being called."
msgstr ""

#: ../../library/enum.rst
msgid "value"
msgstr "value"

#: ../../library/enum.rst:185
msgid "The value to lookup."
msgstr ""

#: ../../library/enum.rst:187
msgid ""
"to use the ``cls`` enum to create a new enum (only if the existing enum "
"does not have any members):"
msgstr ""

#: ../../library/enum.rst:191
msgid "The name of the new Enum to create."
msgstr ""

#: ../../library/enum.rst
msgid "names"
msgstr "names"

#: ../../library/enum.rst:192
msgid "The names/values of the members for the new Enum."
msgstr ""

#: ../../library/enum.rst
msgid "module"
msgstr "module"

#: ../../library/enum.rst:193
#, fuzzy
msgid "The name of the module the new Enum is created in."
msgstr "새로운 Enum 클래스를 찾을 수 있는 모듈의 이름."

#: ../../library/enum.rst
msgid "qualname"
msgstr "qualname"

#: ../../library/enum.rst:194
#, fuzzy
msgid "The actual location in the module where this Enum can be found."
msgstr "새로운 Enum 클래스를 찾을 수 있는 모듈의 이름."

#: ../../library/enum.rst
msgid "type"
msgstr "type"

#: ../../library/enum.rst:195
msgid "A mix-in type for the new Enum."
msgstr ""

#: ../../library/enum.rst
msgid "start"
msgstr "start"

#: ../../library/enum.rst:196
msgid "The first integer value for the Enum (used by :class:`auto`)."
msgstr ""

#: ../../library/enum.rst
msgid "boundary"
msgstr ""

#: ../../library/enum.rst:197
msgid ""
"How to handle out-of-range values from bit operations (:class:`Flag` "
"only)."
msgstr ""

#: ../../library/enum.rst:201
msgid "Returns ``True`` if member belongs to the ``cls``::"
msgstr ""

#: ../../library/enum.rst:203
msgid ""
">>> some_var = Color.RED\n"
">>> some_var in Color\n"
"True\n"
">>> Color.RED.value in Color\n"
"True"
msgstr ""

#: ../../library/enum.rst:211
msgid ""
"Before Python 3.12, a ``TypeError`` is raised if a non-Enum-member is "
"used in a containment check."
msgstr ""

#: ../../library/enum.rst:216
msgid ""
"Returns ``['__class__', '__doc__', '__members__', '__module__']`` and the"
" names of the members in *cls*::"
msgstr ""

#: ../../library/enum.rst:219
msgid ""
">>> dir(Color)\n"
"['BLUE', 'GREEN', 'RED', '__class__', '__contains__', '__doc__', "
"'__getitem__', '__init_subclass__', '__iter__', '__len__', '__members__',"
" '__module__', '__name__', '__qualname__']"
msgstr ""

#: ../../library/enum.rst:224
msgid ""
"Returns the Enum member in *cls* matching *name*, or raises a "
":exc:`KeyError`::"
msgstr ""

#: ../../library/enum.rst:226
msgid ""
">>> Color['BLUE']\n"
"<Color.BLUE: 3>"
msgstr ""

#: ../../library/enum.rst:231
#, fuzzy
msgid "Returns each member in *cls* in definition order::"
msgstr "열거형은 정의 순서로 이터레이션을 지원합니다::"

#: ../../library/enum.rst:233
msgid ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>]"
msgstr ""

#: ../../library/enum.rst:238
msgid "Returns the number of member in *cls*::"
msgstr ""

#: ../../library/enum.rst:240
msgid ""
">>> len(Color)\n"
"3"
msgstr ""

#: ../../library/enum.rst:245
msgid "Returns a mapping of every enum name to its member, including aliases"
msgstr ""

#: ../../library/enum.rst:249
msgid "Returns each member in *cls* in reverse definition order::"
msgstr ""

#: ../../library/enum.rst:251
msgid ""
">>> list(reversed(Color))\n"
"[<Color.BLUE: 3>, <Color.GREEN: 2>, <Color.RED: 1>]"
msgstr ""

#: ../../library/enum.rst:256
msgid ""
"Adds a new name as an alias to an existing member.  Raises a "
":exc:`NameError` if the name is already assigned to a different member."
msgstr ""

#: ../../library/enum.rst:261
msgid ""
"Adds a new value as an alias to an existing member.  Raises a "
":exc:`ValueError` if the value is already linked with a different member."
msgstr ""

#: ../../library/enum.rst:266
msgid ""
"Before 3.11 ``EnumType`` was called ``EnumMeta``, which is still "
"available as an alias."
msgstr ""

#: ../../library/enum.rst:271
msgid "*Enum* is the base class for all *enum* enumerations."
msgstr ""

#: ../../library/enum.rst:275
msgid "The name used to define the ``Enum`` member::"
msgstr ""

#: ../../library/enum.rst:277
msgid ""
">>> Color.BLUE.name\n"
"'BLUE'"
msgstr ""

#: ../../library/enum.rst:282
msgid "The value given to the ``Enum`` member::"
msgstr ""

#: ../../library/enum.rst:284
msgid ""
">>> Color.RED.value\n"
"1"
msgstr ""

#: ../../library/enum.rst:287 ../../library/enum.rst:307
#, fuzzy
msgid "Value of the member, can be set in :meth:`~Enum.__new__`."
msgstr "``_value_`` -- 멤버의 값; ``__new__``\\에서 설정/수정할 수 있습니다"

#: ../../library/enum.rst:289
msgid "Enum member values"
msgstr "Enum 멤버 값"

#: ../../library/enum.rst:291
#, fuzzy
msgid ""
"Member values can be anything: :class:`int`, :class:`str`, etc.  If the "
"exact value is unimportant you may use :class:`auto` instances and an "
"appropriate value will be chosen for you.  See :class:`auto` for the "
"details."
msgstr ""
"멤버 값은 아무것이나 될 수 있습니다: :class:`int`, :class:`str` 등. 정확한 값이 중요하지 않다면, "
":class:`auto` 인스턴스를 사용할 수 있으며 적절한 값이 선택됩니다. :class:`auto`\\를 다른 값과 혼합 할 "
"경우 주의를 기울여야 합니다."

#: ../../library/enum.rst:296
msgid ""
"While mutable/unhashable values, such as :class:`dict`, :class:`list` or "
"a mutable :class:`~dataclasses.dataclass`, can be used, they will have a "
"quadratic performance impact during creation relative to the total number"
" of mutable/unhashable values in the enum."
msgstr ""

#: ../../library/enum.rst:303
#, fuzzy
msgid "Name of the member."
msgstr "Enum 멤버의 케이스"

#: ../../library/enum.rst:311
#, fuzzy
msgid ""
"No longer used, kept for backward compatibility. (class attribute, "
"removed during class creation)."
msgstr ""
"``_order_`` -- 파이썬 2/3 코드에서 멤버 순서의 일관성을 유지하기 위해 사용됩니다 (클래스 생성 중 제거되는 클래스 "
"어트리뷰트)"

#: ../../library/enum.rst:316
msgid ""
"``_ignore_`` is only used during creation and is removed from the "
"enumeration once creation is complete."
msgstr ""

#: ../../library/enum.rst:319
msgid ""
"``_ignore_`` is a list of names that will not become members, and whose "
"names will also be removed from the completed enumeration.  See "
":ref:`TimePeriod <enum-time-period>` for an example."
msgstr ""

#: ../../library/enum.rst:325
msgid ""
"Returns ``['__class__', '__doc__', '__module__', 'name', 'value']`` and "
"any public methods defined on *self.__class__*::"
msgstr ""

#: ../../library/enum.rst:328
#, python-format
msgid ""
">>> from datetime import date\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     @classmethod\n"
"...     def today(cls):\n"
"...         print('today is %s' % cls(date.today().isoweekday()).name)\n"
"...\n"
">>> dir(Weekday.SATURDAY)\n"
"['__class__', '__doc__', '__eq__', '__hash__', '__module__', 'name', "
"'today', 'value']"
msgstr ""

#: ../../library/enum.rst
#, fuzzy
msgid "name"
msgstr "names"

#: ../../library/enum.rst:346
msgid "The name of the member being defined (e.g. 'RED')."
msgstr ""

#: ../../library/enum.rst:347
msgid "The start value for the Enum; the default is 1."
msgstr ""

#: ../../library/enum.rst
msgid "count"
msgstr ""

#: ../../library/enum.rst:348
msgid "The number of members currently defined, not including this one."
msgstr ""

#: ../../library/enum.rst
#, fuzzy
msgid "last_values"
msgstr "value"

#: ../../library/enum.rst:349
msgid "A list of the previous values."
msgstr ""

#: ../../library/enum.rst:351
msgid ""
"A *staticmethod* that is used to determine the next value returned by "
":class:`auto`::"
msgstr ""

#: ../../library/enum.rst:354
msgid ""
">>> from enum import auto\n"
">>> class PowersOfThree(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return 3 ** (count + 1)\n"
"...     FIRST = auto()\n"
"...     SECOND = auto()\n"
"...\n"
">>> PowersOfThree.SECOND.value\n"
"9"
msgstr ""

#: ../../library/enum.rst:367
msgid ""
"By default, does nothing.  If multiple values are given in the member "
"assignment, those values become separate arguments to ``__init__``; e.g."
msgstr ""

#: ../../library/enum.rst:374
msgid ""
"``Weekday.__init__()`` would be called as ``Weekday.__init__(self, 1, "
"'Mon')``"
msgstr ""

#: ../../library/enum.rst:378
msgid ""
"A *classmethod* that is used to further configure subsequent subclasses. "
"By default, does nothing."
msgstr ""

#: ../../library/enum.rst:383
msgid ""
"A *classmethod* for looking up values not found in *cls*.  By default it "
"does nothing, but can be overridden to implement custom search behavior::"
msgstr ""

#: ../../library/enum.rst:386
msgid ""
">>> from enum import StrEnum\n"
">>> class Build(StrEnum):\n"
"...     DEBUG = auto()\n"
"...     OPTIMIZED = auto()\n"
"...     @classmethod\n"
"...     def _missing_(cls, value):\n"
"...         value = value.lower()\n"
"...         for member in cls:\n"
"...             if member.value == value:\n"
"...                 return member\n"
"...         return None\n"
"...\n"
">>> Build.DEBUG.value\n"
"'debug'\n"
">>> Build('deBUG')\n"
"<Build.DEBUG: 'debug'>"
msgstr ""

#: ../../library/enum.rst:405
msgid ""
"By default, doesn't exist.  If specified, either in the enum class "
"definition or in a mixin class (such as ``int``), all values given in the"
" member assignment will be passed; e.g."
msgstr ""

#: ../../library/enum.rst:413
msgid ""
"results in the call ``int('1a', 16)`` and a value of ``26`` for the "
"member."
msgstr ""

#: ../../library/enum.rst:417
msgid ""
"When writing a custom ``__new__``, do not use ``super().__new__`` -- call"
" the appropriate ``__new__`` instead."
msgstr ""

#: ../../library/enum.rst:422
msgid ""
"Returns the string used for *repr()* calls.  By default, returns the "
"*Enum* name, member name, and value, but can be overridden::"
msgstr ""

#: ../../library/enum.rst:425
#, python-brace-format
msgid ""
">>> class OtherStyle(Enum):\n"
"...     ALTERNATE = auto()\n"
"...     OTHER = auto()\n"
"...     SOMETHING_ELSE = auto()\n"
"...     def __repr__(self):\n"
"...         cls_name = self.__class__.__name__\n"
"...         return f'{cls_name}.{self.name}'\n"
"...\n"
">>> OtherStyle.ALTERNATE, str(OtherStyle.ALTERNATE), "
"f\"{OtherStyle.ALTERNATE}\"\n"
"(OtherStyle.ALTERNATE, 'OtherStyle.ALTERNATE', 'OtherStyle.ALTERNATE')"
msgstr ""

#: ../../library/enum.rst:438
msgid ""
"Returns the string used for *str()* calls.  By default, returns the "
"*Enum* name and member name, but can be overridden::"
msgstr ""

#: ../../library/enum.rst:441
#, python-brace-format
msgid ""
">>> class OtherStyle(Enum):\n"
"...     ALTERNATE = auto()\n"
"...     OTHER = auto()\n"
"...     SOMETHING_ELSE = auto()\n"
"...     def __str__(self):\n"
"...         return f'{self.name}'\n"
"...\n"
">>> OtherStyle.ALTERNATE, str(OtherStyle.ALTERNATE), "
"f\"{OtherStyle.ALTERNATE}\"\n"
"(<OtherStyle.ALTERNATE: 1>, 'ALTERNATE', 'ALTERNATE')"
msgstr ""

#: ../../library/enum.rst:453
msgid ""
"Returns the string used for *format()* and *f-string* calls.  By default,"
" returns :meth:`__str__` return value, but can be overridden::"
msgstr ""

#: ../../library/enum.rst:456
#, python-brace-format
msgid ""
">>> class OtherStyle(Enum):\n"
"...     ALTERNATE = auto()\n"
"...     OTHER = auto()\n"
"...     SOMETHING_ELSE = auto()\n"
"...     def __format__(self, spec):\n"
"...         return f'{self.name}'\n"
"...\n"
">>> OtherStyle.ALTERNATE, str(OtherStyle.ALTERNATE), "
"f\"{OtherStyle.ALTERNATE}\"\n"
"(<OtherStyle.ALTERNATE: 1>, 'OtherStyle.ALTERNATE', 'ALTERNATE')"
msgstr ""

#: ../../library/enum.rst:468
msgid ""
"Using :class:`auto` with :class:`Enum` results in integers of increasing "
"value, starting with ``1``."
msgstr ""

#: ../../library/enum.rst:471
msgid "Added :ref:`enum-dataclass-support`"
msgstr ""

#: ../../library/enum.rst:476
msgid ""
"*IntEnum* is the same as :class:`Enum`, but its members are also integers"
" and can be used anywhere that an integer can be used.  If any integer "
"operation is performed with an *IntEnum* member, the resulting value "
"loses its enumeration status."
msgstr ""

#: ../../library/enum.rst:497
msgid ""
"Using :class:`auto` with :class:`IntEnum` results in integers of "
"increasing value, starting with ``1``."
msgstr ""

#: ../../library/enum.rst:500
msgid ""
":meth:`~object.__str__` is now :meth:`!int.__str__` to better support the"
" *replacement of existing constants* use-case. :meth:`~object.__format__`"
" was already :meth:`!int.__format__` for that same reason."
msgstr ""

#: ../../library/enum.rst:507
msgid ""
"``StrEnum`` is the same as :class:`Enum`, but its members are also "
"strings and can be used in most of the same places that a string can be "
"used.  The result of any string operation performed on or with a "
"*StrEnum* member is not part of the enumeration."
msgstr ""

#: ../../library/enum.rst:513
msgid ""
"There are places in the stdlib that check for an exact :class:`str` "
"instead of a :class:`str` subclass (i.e. ``type(unknown) == str`` instead"
" of ``isinstance(unknown, str)``), and in those locations you will need "
"to use ``str(StrEnum.member)``."
msgstr ""

#: ../../library/enum.rst:520
msgid ""
"Using :class:`auto` with :class:`StrEnum` results in the lower-cased "
"member name as the value."
msgstr ""

#: ../../library/enum.rst:525
msgid ""
":meth:`~object.__str__` is :meth:`!str.__str__` to better support the "
"*replacement of existing constants* use-case.  :meth:`~object.__format__`"
" is likewise :meth:`!str.__format__` for that same reason."
msgstr ""

#: ../../library/enum.rst:533
msgid ""
"``Flag`` is the same as :class:`Enum`, but its members support the "
"bitwise operators ``&`` (*AND*), ``|`` (*OR*), ``^`` (*XOR*), and ``~`` "
"(*INVERT*); the results of those operations are (aliases of) members of "
"the enumeration."
msgstr ""

#: ../../library/enum.rst:539
msgid "Returns *True* if value is in self::"
msgstr ""

#: ../../library/enum.rst:541
msgid ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...\n"
">>> purple = Color.RED | Color.BLUE\n"
">>> white = Color.RED | Color.GREEN | Color.BLUE\n"
">>> Color.GREEN in purple\n"
"False\n"
">>> Color.GREEN in white\n"
"True\n"
">>> purple in white\n"
"True\n"
">>> white in purple\n"
"False"
msgstr ""

#: ../../library/enum.rst:560
msgid "Returns all contained non-alias members::"
msgstr ""

#: ../../library/enum.rst:562
msgid ""
">>> list(Color.RED)\n"
"[<Color.RED: 1>]\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 4>]"
msgstr ""

#: ../../library/enum.rst:571
msgid "Returns number of members in flag::"
msgstr ""

#: ../../library/enum.rst:573
msgid ""
">>> len(Color.GREEN)\n"
"1\n"
">>> len(white)\n"
"3"
msgstr ""

#: ../../library/enum.rst:582
msgid "Returns *True* if any members in flag, *False* otherwise::"
msgstr ""

#: ../../library/enum.rst:584
msgid ""
">>> bool(Color.GREEN)\n"
"True\n"
">>> bool(white)\n"
"True\n"
">>> black = Color(0)\n"
">>> bool(black)\n"
"False"
msgstr ""

#: ../../library/enum.rst:594
msgid "Returns current flag binary or'ed with other::"
msgstr ""

#: ../../library/enum.rst:596
msgid ""
">>> Color.RED | Color.GREEN\n"
"<Color.RED|GREEN: 3>"
msgstr ""

#: ../../library/enum.rst:601
msgid "Returns current flag binary and'ed with other::"
msgstr ""

#: ../../library/enum.rst:603
msgid ""
">>> purple & white\n"
"<Color.RED|BLUE: 5>\n"
">>> purple & Color.GREEN\n"
"<Color: 0>"
msgstr ""

#: ../../library/enum.rst:610
msgid "Returns current flag binary xor'ed with other::"
msgstr ""

#: ../../library/enum.rst:612
msgid ""
">>> purple ^ white\n"
"<Color.GREEN: 2>\n"
">>> purple ^ Color.GREEN\n"
"<Color.RED|GREEN|BLUE: 7>"
msgstr ""

#: ../../library/enum.rst:619
msgid "Returns all the flags in *type(self)* that are not in *self*::"
msgstr ""

#: ../../library/enum.rst:621
msgid ""
">>> ~white\n"
"<Color: 0>\n"
">>> ~purple\n"
"<Color.GREEN: 2>\n"
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"
msgstr ""

#: ../../library/enum.rst:630
msgid ""
"Function used to format any remaining unnamed numeric values.  Default is"
" the value's repr; common choices are :func:`hex` and :func:`oct`."
msgstr ""

#: ../../library/enum.rst:635
msgid ""
"Using :class:`auto` with :class:`Flag` results in integers that are "
"powers of two, starting with ``1``."
msgstr ""

#: ../../library/enum.rst:638
msgid "The *repr()* of zero-valued flags has changed.  It is now::"
msgstr ""

#: ../../library/enum.rst:646
msgid ""
"``IntFlag`` is the same as :class:`Flag`, but its members are also "
"integers and can be used anywhere that an integer can be used."
msgstr ""

#: ../../library/enum.rst:660
msgid ""
"If any integer operation is performed with an *IntFlag* member, the "
"result is not an *IntFlag*::"
msgstr ""

#: ../../library/enum.rst:663
msgid ""
">>> Color.RED + 2\n"
"3"
msgstr ""

#: ../../library/enum.rst:666
msgid "If a :class:`Flag` operation is performed with an *IntFlag* member and:"
msgstr ""

#: ../../library/enum.rst:668
msgid "the result is a valid *IntFlag*: an *IntFlag* is returned"
msgstr ""

#: ../../library/enum.rst:669
msgid ""
"the result is not a valid *IntFlag*: the result depends on the "
":class:`FlagBoundary` setting"
msgstr ""

#: ../../library/enum.rst:671
msgid "The :func:`repr` of unnamed zero-valued flags has changed.  It is now:"
msgstr ""

#: ../../library/enum.rst:678
msgid ""
"Using :class:`auto` with :class:`IntFlag` results in integers that are "
"powers of two, starting with ``1``."
msgstr ""

#: ../../library/enum.rst:683
msgid ""
":meth:`~object.__str__` is now :meth:`!int.__str__` to better support the"
" *replacement of existing constants* use-case.  "
":meth:`~object.__format__` was already :meth:`!int.__format__` for that "
"same reason."
msgstr ""

#: ../../library/enum.rst:687
msgid ""
"Inversion of an :class:`!IntFlag` now returns a positive value that is "
"the union of all flags not in the given flag, rather than a negative "
"value. This matches the existing :class:`Flag` behavior."
msgstr ""

#: ../../library/enum.rst:693
msgid ""
":class:`!ReprEnum` uses the :meth:`repr() <Enum.__repr__>` of "
":class:`Enum`, but the :class:`str() <str>` of the mixed-in data type:"
msgstr ""

#: ../../library/enum.rst:696
msgid ":meth:`!int.__str__` for :class:`IntEnum` and :class:`IntFlag`"
msgstr ""

#: ../../library/enum.rst:697
msgid ":meth:`!str.__str__` for :class:`StrEnum`"
msgstr ""

#: ../../library/enum.rst:699
msgid ""
"Inherit from :class:`!ReprEnum` to keep the :class:`str() <str>` / "
":func:`format` of the mixed-in data type instead of using the "
":class:`Enum`-default :meth:`str() <Enum.__str__>`."
msgstr ""

#: ../../library/enum.rst:708
msgid ""
"*EnumCheck* contains the options used by the :func:`verify` decorator to "
"ensure various constraints; failed constraints result in a "
":exc:`ValueError`."
msgstr ""

#: ../../library/enum.rst:713
msgid "Ensure that each value has only one name::"
msgstr ""

#: ../../library/enum.rst:715
msgid ""
">>> from enum import Enum, verify, UNIQUE\n"
">>> @verify(UNIQUE)\n"
"... class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     CRIMSON = 1\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: aliases found in <enum 'Color'>: CRIMSON -> RED"
msgstr ""

#: ../../library/enum.rst:729
msgid ""
"Ensure that there are no missing values between the lowest-valued member "
"and the highest-valued member::"
msgstr ""

#: ../../library/enum.rst:732
msgid ""
">>> from enum import Enum, verify, CONTINUOUS\n"
">>> @verify(CONTINUOUS)\n"
"... class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 5\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: invalid enum 'Color': missing values 3, 4"
msgstr ""

#: ../../library/enum.rst:744
msgid ""
"Ensure that any flag groups/masks contain only named flags -- useful when"
" values are specified instead of being generated by :func:`auto`::"
msgstr ""

#: ../../library/enum.rst:747
msgid ""
">>> from enum import Flag, verify, NAMED_FLAGS\n"
">>> @verify(NAMED_FLAGS)\n"
"... class Color(Flag):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     WHITE = 15\n"
"...     NEON = 31\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: invalid Flag 'Color': aliases WHITE and NEON are missing "
"combined values of 0x18 [use enum.show_flag_values(value) for details]"
msgstr ""

#: ../../library/enum.rst:761
msgid ""
"CONTINUOUS and NAMED_FLAGS are designed to work with integer-valued "
"members."
msgstr ""

#: ../../library/enum.rst:767
msgid ""
"``FlagBoundary`` controls how out-of-range values are handled in "
":class:`Flag` and its subclasses."
msgstr ""

#: ../../library/enum.rst:772
msgid ""
"Out-of-range values cause a :exc:`ValueError` to be raised. This is the "
"default for :class:`Flag`::"
msgstr ""

#: ../../library/enum.rst:775
msgid ""
">>> from enum import Flag, STRICT, auto\n"
">>> class StrictFlag(Flag, boundary=STRICT):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...\n"
">>> StrictFlag(2**2 + 2**4)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: <flag 'StrictFlag'> invalid value 20\n"
"    given 0b0 10100\n"
"  allowed 0b0 00111"
msgstr ""

#: ../../library/enum.rst:790
msgid ""
"Out-of-range values have invalid values removed, leaving a valid "
":class:`Flag` value::"
msgstr ""

#: ../../library/enum.rst:793
msgid ""
">>> from enum import Flag, CONFORM, auto\n"
">>> class ConformFlag(Flag, boundary=CONFORM):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...\n"
">>> ConformFlag(2**2 + 2**4)\n"
"<ConformFlag.BLUE: 4>"
msgstr ""

#: ../../library/enum.rst:804
msgid ""
"Out-of-range values lose their :class:`Flag` membership and revert to "
":class:`int`."
msgstr ""

#: ../../library/enum.rst:817
msgid ""
"Out-of-range values are kept, and the :class:`Flag` membership is kept. "
"This is the default for :class:`IntFlag`::"
msgstr ""

#: ../../library/enum.rst:820
msgid ""
">>> from enum import Flag, KEEP, auto\n"
">>> class KeepFlag(Flag, boundary=KEEP):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...\n"
">>> KeepFlag(2**2 + 2**4)\n"
"<KeepFlag.BLUE|16: 20>"
msgstr ""

#: ../../library/enum.rst:833
msgid ""
"*EnumDict* is a subclass of :class:`dict` that is used as the namespace "
"for defining enum classes (see :ref:`prepare`). It is exposed to allow "
"subclasses of :class:`EnumType` with advanced behavior like having "
"multiple values per member. It should be called with the name of the enum"
" class being created, otherwise private names and internal classes will "
"not be handled correctly."
msgstr ""

#: ../../library/enum.rst:840
msgid ""
"Note that only the :class:`~collections.abc.MutableMapping` interface "
"(:meth:`~object.__setitem__` and :meth:`~dict.update`) is overridden. It "
"may be possible to bypass the checks using other :class:`!dict` "
"operations like :meth:`|= <object.__ior__>`."
msgstr ""

#: ../../library/enum.rst:847
#, fuzzy
msgid "A list of member names."
msgstr "Enum 멤버의 케이스"

#: ../../library/enum.rst:854
msgid "Supported ``__dunder__`` names"
msgstr "지원되는 ``__dunder__`` 이름"

#: ../../library/enum.rst:856
#, fuzzy
msgid ""
":attr:`~EnumType.__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__`\\는 ``member_name``:``member`` 항목의 읽기 전용 순서 있는 매핑입니다. "
"클래스에서만 이용할 수 있습니다."

#: ../../library/enum.rst:859
#, fuzzy
msgid ""
":meth:`~Enum.__new__`, if specified, must create and return the enum "
"members; it is also a very good idea to set the member's :attr:`!_value_`"
" appropriately. Once all the members are created it is no longer used."
msgstr ""
"지정된다면, :meth:`__new__`\\는 열거형 멤버를 만들고 반환해야 합니다; 멤버의 :attr:`_value_`\\를 "
"적절하게 설정하는 것도 좋습니다. 일단 모든 멤버가 만들어지면 더는 사용되지 않습니다."

#: ../../library/enum.rst:865
msgid "Supported ``_sunder_`` names"
msgstr "지원되는 ``_sunder_`` 이름"

#: ../../library/enum.rst:867
msgid ""
":meth:`~EnumType._add_alias_` -- adds a new name as an alias to an "
"existing member."
msgstr ""

#: ../../library/enum.rst:869
msgid ""
":meth:`~EnumType._add_value_alias_` -- adds a new value as an alias to an"
" existing member."
msgstr ""

#: ../../library/enum.rst:871
#, fuzzy
msgid ":attr:`~Enum._name_` -- name of the member"
msgstr "``_name_`` -- 멤버의 이름"

#: ../../library/enum.rst:872
#, fuzzy
msgid ":attr:`~Enum._value_` -- value of the member; can be set in ``__new__``"
msgstr "``_value_`` -- 멤버의 값; ``__new__``\\에서 설정/수정할 수 있습니다"

#: ../../library/enum.rst:873
#, fuzzy
msgid ""
":meth:`~Enum._missing_` -- a lookup function used when a value is not "
"found; may be overridden"
msgstr "``_missing_`` -- 값을 찾을 수 없을 때 사용되는 조회 함수; 재정의할 수 있습니다"

#: ../../library/enum.rst:875
#, fuzzy
msgid ""
":attr:`~Enum._ignore_` -- a list of names, either as a :class:`list` or a"
" :class:`str`, that will not be transformed into members, and will be "
"removed from the final class"
msgstr ""
"``_ignore_`` -- 멤버로 변환되지 않고 최종 클래스에서 제거될 :class:`list`\\나 :class:`str` 형의"
" 이름 목록"

#: ../../library/enum.rst:878
#, fuzzy
msgid ""
":attr:`~Enum._order_` -- no longer used, kept for backward compatibility "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- 파이썬 2/3 코드에서 멤버 순서의 일관성을 유지하기 위해 사용됩니다 (클래스 생성 중 제거되는 클래스 "
"어트리뷰트)"

#: ../../library/enum.rst:880
#, fuzzy
msgid ""
":meth:`~Enum._generate_next_value_` -- used to get an appropriate value "
"for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- 열거형 멤버에 대한 적절한 값을 얻기 위해 `함수형 API <Functional"
" API_>`_\\와 :class:`auto`\\에서 사용합니다; 재정의할 수 있습니다"

#: ../../library/enum.rst:885
msgid ""
"For standard :class:`Enum` classes the next value chosen is the highest "
"value seen incremented by one."
msgstr ""

#: ../../library/enum.rst:888
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two."
msgstr ""

#: ../../library/enum.rst:891
msgid ""
"While ``_sunder_`` names are generally reserved for the further "
"development of the :class:`Enum` class and can not be used, some are "
"explicitly allowed:"
msgstr ""

#: ../../library/enum.rst:894
msgid "``_repr_*`` (e.g. ``_repr_html_``), as used in `IPython's rich display`_"
msgstr ""

#: ../../library/enum.rst:896
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../library/enum.rst:897
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../library/enum.rst:898
msgid "``_add_alias_``, ``_add_value_alias_``, ``_repr_*``"
msgstr ""

#: ../../library/enum.rst:904
msgid "Utilities and Decorators"
msgstr ""

#: ../../library/enum.rst:908
msgid ""
"*auto* can be used in place of a value.  If used, the *Enum* machinery "
"will call an :class:`Enum`'s :meth:`~Enum._generate_next_value_` to get "
"an appropriate value. For :class:`Enum` and :class:`IntEnum` that "
"appropriate value will be the last value plus one; for :class:`Flag` and "
":class:`IntFlag` it will be the first power-of-two greater than the "
"highest value; for :class:`StrEnum` it will be the lower-cased version of"
" the member's name.  Care must be taken if mixing *auto()* with manually "
"specified values."
msgstr ""

#: ../../library/enum.rst:916
msgid "*auto* instances are only resolved when at the top level of an assignment:"
msgstr ""

#: ../../library/enum.rst:918
msgid "``FIRST = auto()`` will work (auto() is replaced with ``1``);"
msgstr ""

#: ../../library/enum.rst:919
msgid ""
"``SECOND = auto(), -2`` will work (auto is replaced with ``2``, so ``2, "
"-2`` is used to create the ``SECOND`` enum member;"
msgstr ""

#: ../../library/enum.rst:921
msgid ""
"``THREE = [auto(), -3]`` will *not* work (``<auto instance>, -3`` is used"
" to create the ``THREE`` enum member)"
msgstr ""

#: ../../library/enum.rst:926
msgid ""
"In prior versions, ``auto()`` had to be the only thing on the assignment "
"line to work properly."
msgstr ""

#: ../../library/enum.rst:929
msgid ""
"``_generate_next_value_`` can be overridden to customize the values used "
"by *auto*."
msgstr ""

#: ../../library/enum.rst:932
msgid ""
"in 3.13 the default ``_generate_next_value_`` will always return the "
"highest member value incremented by 1, and will fail if any member is an "
"incompatible type."
msgstr ""

#: ../../library/enum.rst:938
msgid ""
"A decorator similar to the built-in *property*, but specifically for "
"enumerations.  It allows member attributes to have the same names as "
"members themselves."
msgstr ""

#: ../../library/enum.rst:942
msgid ""
"the *property* and the member must be defined in separate classes; for "
"example, the *value* and *name* attributes are defined in the *Enum* "
"class, and *Enum* subclasses can define members with the names ``value`` "
"and ``name``."
msgstr ""

#: ../../library/enum.rst:951
#, fuzzy
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  It searches "
"an enumeration's :attr:`~EnumType.__members__`, gathering any aliases it "
"finds; if any are found :exc:`ValueError` is raised with the details::"
msgstr ""
"열거형 용 :keyword:`class` 데코레이터입니다. 열거형의 :attr:`__members__`\\를 검색하여 별칭을 "
"수집합니다; 발견되면 :exc:`ValueError`\\가 세부 정보와 함께 발생합니다::"

#: ../../library/enum.rst:955
msgid ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"
msgstr ""

#: ../../library/enum.rst:969
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  Members from"
" :class:`EnumCheck` are used to specify which constraints should be "
"checked on the decorated enumeration."
msgstr ""

#: ../../library/enum.rst:977
msgid "A decorator for use in enums: its target will become a member."
msgstr ""

#: ../../library/enum.rst:983
msgid "A decorator for use in enums: its target will not become a member."
msgstr ""

#: ../../library/enum.rst:989
msgid ""
"A decorator to change the :class:`str() <str>` and :func:`repr` of an "
"enum to show its members as belonging to the module instead of its class."
" Should only be used when the enum members are exported to the module "
"global namespace (see :class:`re.RegexFlag` for an example)."
msgstr ""

#: ../../library/enum.rst:998
msgid "Return a list of all power-of-two integers contained in a flag *value*."
msgstr ""

#: ../../library/enum.rst:1006
#, fuzzy
msgid "Notes"
msgstr "기타"

#: ../../library/enum.rst:1008
msgid ":class:`IntEnum`, :class:`StrEnum`, and :class:`IntFlag`"
msgstr ""

#: ../../library/enum.rst:1010
msgid ""
"These three enum types are designed to be drop-in replacements for "
"existing integer- and string-based values; as such, they have extra "
"limitations:"
msgstr ""

#: ../../library/enum.rst:1013
msgid "``__str__`` uses the value and not the name of the enum member"
msgstr ""

#: ../../library/enum.rst:1015
msgid ""
"``__format__``, because it uses ``__str__``, will also use the value of "
"the enum member instead of its name"
msgstr ""

#: ../../library/enum.rst:1018
msgid ""
"If you do not need/want those limitations, you can either create your own"
" base class by mixing in the ``int`` or ``str`` type yourself::"
msgstr ""

#: ../../library/enum.rst:1021
msgid ""
">>> from enum import Enum\n"
">>> class MyIntEnum(int, Enum):\n"
"...     pass"
msgstr ""

#: ../../library/enum.rst:1025
msgid "or you can reassign the appropriate :meth:`str`, etc., in your enum::"
msgstr ""

#: ../../library/enum.rst:1027
msgid ""
">>> from enum import Enum, IntEnum\n"
">>> class MyIntEnum(IntEnum):\n"
"...     __str__ = Enum.__str__"
msgstr ""

#~ msgid ""
#~ "An enumeration is a set of "
#~ "symbolic names (members) bound to "
#~ "unique, constant values.  Within an "
#~ "enumeration, the members can be compared"
#~ " by identity, and the enumeration "
#~ "itself can be iterated over."
#~ msgstr ""
#~ "열거형(enumeration)은 고유한 상숫값에 연결된 기호 "
#~ "이름(멤버)의 집합입니다. 열거형 내에서, 멤버를 아이덴티티로 "
#~ "비교할 수 있고, 열거형 자체는 이터레이트 될 수"
#~ " 있습니다."

#~ msgid ""
#~ "Because Enums are used to represent "
#~ "constants we recommend using UPPER_CASE "
#~ "names for enum members, and will "
#~ "be using that style in our "
#~ "examples."
#~ msgstr ""
#~ "열거형은 상수를 나타내는 데 사용되기 때문에 열거형 "
#~ "멤버에 대해 대문자(UPPER_CASE) 이름을 사용하는 것이 "
#~ "좋으며, 예제에서는 이 스타일을 사용합니다."

#~ msgid ""
#~ "This module defines four enumeration "
#~ "classes that can be used to define"
#~ " unique sets of names and values: "
#~ ":class:`Enum`, :class:`IntEnum`, :class:`Flag`, and"
#~ " :class:`IntFlag`.  It also defines one "
#~ "decorator, :func:`unique`, and one helper, "
#~ ":class:`auto`."
#~ msgstr ""
#~ "이 모듈은 고유한 이름 집합과 값을 정의하는 데"
#~ " 사용할 수 있는 네 가지 열거형 클래스를 "
#~ "정의합니다: :class:`Enum`, :class:`IntEnum`, "
#~ ":class:`Flag` 및 :class:`IntFlag`. 또한 하나의 "
#~ "데코레이터 :func:`unique`\\와 하나의 도우미 "
#~ ":class:`auto`\\를 정의합니다."

#~ msgid ""
#~ "Base class for creating enumerated "
#~ "constants.  See section `Functional API`_ "
#~ "for an alternate construction syntax."
#~ msgstr ""
#~ "열거형 상수를 만들기 위한 베이스 클래스. 대체 "
#~ "구성 문법은 `함수형 API <Functional API_>`_ "
#~ "섹션을 참조하십시오."

#~ msgid ""
#~ "Instances are replaced with an "
#~ "appropriate value for Enum members.  By"
#~ " default, the initial value starts at"
#~ " 1."
#~ msgstr "인스턴스는 Enum 멤버에 적절한 값으로 바뀝니다. 기본적으로, 초깃값은 1부터 시작합니다."

#~ msgid "Creating an Enum"
#~ msgstr "Enum 만들기"

#~ msgid ""
#~ "Enumerations are created using the "
#~ ":keyword:`class` syntax, which makes them "
#~ "easy to read and write.  An "
#~ "alternative creation method is described "
#~ "in `Functional API`_.  To define an "
#~ "enumeration, subclass :class:`Enum` as "
#~ "follows::"
#~ msgstr ""
#~ "열거형은 :keyword:`class` 문법을 사용하여 작성되므로 쉽게"
#~ " 읽고 쓸 수 있습니다. 대체 작성 방법은 "
#~ "`함수형 API <Functional API_>`_\\에 설명되어 "
#~ "있습니다. 열거형을 정의하려면, 다음과 같이 "
#~ ":class:`Enum`\\을 서브 클래스 하십시오::"

#~ msgid "Enumeration members have human readable string representations::"
#~ msgstr "열거형 멤버는 사람이 읽을 수 있는 문자열 표현을 갖습니다::"

#~ msgid "...while their ``repr`` has more information::"
#~ msgstr "``repr``\\에는 더 자세한 정보가 있습니다::"

#~ msgid "The *type* of an enumeration member is the enumeration it belongs to::"
#~ msgstr "열거형 멤버의 *형*\\은 그것이 속한 열거형입니다::"

#~ msgid "Enum members also have a property that contains just their item name::"
#~ msgstr "Enum 멤버에는 항목 이름 만 포함하는 프로퍼티가 있습니다::"

#~ msgid ""
#~ "Enumeration members are hashable, so "
#~ "they can be used in dictionaries "
#~ "and sets::"
#~ msgstr "열거형 멤버는 해시 가능하므로, 딕셔너리와 집합에 사용할 수 있습니다::"

#~ msgid "Programmatic access to enumeration members and their attributes"
#~ msgstr "열거형 멤버와 그들의 어트리뷰트에 프로그래밍 방식으로 액세스하기"

#~ msgid ""
#~ "Sometimes it's useful to access members"
#~ " in enumerations programmatically (i.e. "
#~ "situations where ``Color.RED`` won't do "
#~ "because the exact color is not "
#~ "known at program-writing time).  "
#~ "``Enum`` allows such access::"
#~ msgstr ""
#~ "때로는 프로그래밍 방식으로 열거형의 멤버에 액세스하는 것이"
#~ " 유용합니다 (즉, 프로그램 작성 시간에 정확한 색상을"
#~ " 알 수 없어서 ``Color.RED``\\를 쓸 수 "
#~ "없는 상황). ``Enum``\\는 그런 액세스를 허용합니다::"

#~ msgid "If you want to access enum members by *name*, use item access::"
#~ msgstr "*이름(name)*\\으로 열거형 멤버에 액세스하려면, 항목 액세스를 사용하십시오::"

#~ msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
#~ msgstr "열거형 멤버가 있고 :attr:`name`\\이나 :attr:`value`\\가 필요하면::"

#~ msgid "Duplicating enum members and values"
#~ msgstr "열거형 멤버와 값 중복하기"

#~ msgid "Having two enum members with the same name is invalid::"
#~ msgstr "이름이 같은 열거형 멤버가 두 개 있는 것은 유효하지 않습니다::"

#~ msgid ""
#~ "However, two enum members are allowed"
#~ " to have the same value.  Given "
#~ "two members A and B with the "
#~ "same value (and A defined first), "
#~ "B is an alias to A.  By-"
#~ "value lookup of the value of A "
#~ "and B will return A.  By-name "
#~ "lookup of B will also return A::"
#~ msgstr ""
#~ "그러나, 두 열거형 멤버는 같은 값을 가질 수"
#~ " 있습니다. 같은 값을 가진 두 멤버 A와 "
#~ "B가 주어지면 (그리고 A가 먼저 정의되면), B는 "
#~ "A의 별칭입니다. A와 B의 값을 통한 조회는 A를"
#~ " 반환합니다. B의 이름을 통한 조회도 A를 "
#~ "반환합니다::"

#~ msgid ""
#~ "Attempting to create a member with "
#~ "the same name as an already "
#~ "defined attribute (another member, a "
#~ "method, etc.) or attempting to create"
#~ " an attribute with the same name "
#~ "as a member is not allowed."
#~ msgstr ""
#~ "이미 정의된 어트리뷰트(다른 멤버, 메서드 등)와 같은 "
#~ "이름의 멤버를 만들려고 하거나 멤버와 같은 이름의 "
#~ "어트리뷰트를 만들려는 시도는 허용되지 않습니다."

#~ msgid "Ensuring unique enumeration values"
#~ msgstr "고유한 열거형 값 보장하기"

#~ msgid ""
#~ "By default, enumerations allow multiple "
#~ "names as aliases for the same "
#~ "value. When this behavior isn't desired,"
#~ " the following decorator can be used"
#~ " to ensure each value is used "
#~ "only once in the enumeration:"
#~ msgstr ""
#~ "기본적으로, 열거형은 여러 이름을 같은 값에 대한 "
#~ "별칭으로 허용합니다. 이 동작이 바람직하지 않을 때, "
#~ "다음 데코레이터를 사용하여 각 값이 열거에서 한 "
#~ "번만 사용되도록 보장할 수 있습니다:"

#~ msgid "Using automatic values"
#~ msgstr "자동 값 사용하기"

#~ msgid "If the exact value is unimportant you can use :class:`auto`::"
#~ msgstr "정확한 값이 중요하지 않으면, :class:`auto`\\를 사용할 수 있습니다::"

#~ msgid ""
#~ "The values are chosen by "
#~ ":func:`_generate_next_value_`, which can be "
#~ "overridden::"
#~ msgstr "값은 :func:`_generate_next_value_`\\에 의해 선택되는데, 재정의할 수 있습니다::"

#~ msgid ""
#~ "The goal of the default "
#~ ":meth:`_generate_next_value_` method is to "
#~ "provide the next :class:`int` in "
#~ "sequence with the last :class:`int` "
#~ "provided, but the way it does this"
#~ " is an implementation detail and may"
#~ " change."
#~ msgstr ""
#~ "기본 :meth:`_generate_next_value_` 메서드의 목표는 제공된"
#~ " 마지막 :class:`int`\\와 연속되도록 다음 "
#~ ":class:`int`\\를 제공하는 것이지만, 이를 수행하는 방법은"
#~ " 구현 세부 사항이며 변경될 수 있습니다."

#~ msgid ""
#~ "The :meth:`_generate_next_value_` method must "
#~ "be defined before any members."
#~ msgstr ":meth:`_generate_next_value_` 메서드는 다른 멤버보다 먼저 정의되어야 합니다."

#~ msgid "Iteration"
#~ msgstr "이터레이션"

#~ msgid "Iterating over the members of an enum does not provide the aliases::"
#~ msgstr "열거형 멤버를 이터레이트 해도 별칭은 제공되지 않습니다::"

#~ msgid ""
#~ "The special attribute ``__members__`` is "
#~ "a read-only ordered mapping of "
#~ "names to members.  It includes all "
#~ "names defined in the enumeration, "
#~ "including the aliases::"
#~ msgstr ""
#~ "특수 어트리뷰트 ``__members__``\\는 이름에서 멤버로의 읽기"
#~ " 전용 순서 있는 매핑입니다. 별칭을 포함하여, 열거형에"
#~ " 정의된 모든 이름을 포함합니다::"

#~ msgid ""
#~ "The ``__members__`` attribute can be "
#~ "used for detailed programmatic access to"
#~ " the enumeration members.  For example, "
#~ "finding all the aliases::"
#~ msgstr ""
#~ "``__members__`` 어트리뷰트는 열거형 멤버에 대한 프로그래밍"
#~ " 방식의 자세한 액세스에 사용할 수 있습니다. 예를"
#~ " 들어, 모든 별칭 찾기::"

#~ msgid "Comparisons"
#~ msgstr "비교"

#~ msgid "Enumeration members are compared by identity::"
#~ msgstr "열거형 멤버는 아이덴티티로 비교됩니다::"

#~ msgid ""
#~ "Ordered comparisons between enumeration values"
#~ " are *not* supported.  Enum members "
#~ "are not integers (but see `IntEnum`_ "
#~ "below)::"
#~ msgstr ""
#~ "열거형 값 사이의 순서 비교는 지원되지 *않습니다*. "
#~ "열거형 멤버는 정수가 아닙니다 (그러나 아래의 "
#~ "`IntEnum`_\\을 참조하십시오)::"

#~ msgid "Equality comparisons are defined though::"
#~ msgstr "동등 비교는 정의됩니다::"

#~ msgid ""
#~ "Comparisons against non-enumeration values "
#~ "will always compare not equal (again,"
#~ " :class:`IntEnum` was explicitly designed "
#~ "to behave differently, see below)::"
#~ msgstr ""
#~ "열거형 값이 아닌 값과의 비교는 항상 다르다고 "
#~ "비교됩니다 (다시, :class:`IntEnum`\\은 다르게 동작하도록 "
#~ "명시적으로 설계되었습니다, 아래를 참조하십시오)::"

#~ msgid "Allowed members and attributes of enumerations"
#~ msgstr "열거형의 허용된 멤버와 어트리뷰트"

#~ msgid ""
#~ "The examples above use integers for "
#~ "enumeration values.  Using integers is "
#~ "short and handy (and provided by "
#~ "default by the `Functional API`_), but"
#~ " not strictly enforced.  In the vast"
#~ " majority of use-cases, one doesn't"
#~ " care what the actual value of "
#~ "an enumeration is.  But if the "
#~ "value *is* important, enumerations can "
#~ "have arbitrary values."
#~ msgstr ""
#~ "위의 예제는 열거형 값에 정수를 사용합니다. 정수 "
#~ "사용은 짧고 편리하지만 (`함수형 API <Functional "
#~ "API_>`_\\에서 기본적으로 제공합니다), 엄격하게 강제하지는 "
#~ "않습니다. 대다수의 사용 사례에서, 열거의 실제 값이 "
#~ "무엇인지 신경 쓰지 않습니다. 그러나 값이 *중요*\\하면,"
#~ " 열거형은 임의의 값을 가질 수 있습니다."

#~ msgid ""
#~ "Enumerations are Python classes, and can"
#~ " have methods and special methods as"
#~ " usual.  If we have this "
#~ "enumeration::"
#~ msgstr "열거형은 파이썬 클래스이며, 평소와 같이 메서드와 특수 메서드를 가질 수 있습니다. 이런 열거형이 있다고 합시다::"

#~ msgid "Then::"
#~ msgstr "그러면::"

#~ msgid ""
#~ "The rules for what is allowed are"
#~ " as follows: names that start and "
#~ "end with a single underscore are "
#~ "reserved by enum and cannot be "
#~ "used; all other attributes defined "
#~ "within an enumeration will become "
#~ "members of this enumeration, with the"
#~ " exception of special methods "
#~ "(:meth:`__str__`, :meth:`__add__`, etc.), "
#~ "descriptors (methods are also descriptors),"
#~ " and variable names listed in "
#~ ":attr:`_ignore_`."
#~ msgstr ""
#~ "허용되는 규칙은 다음과 같습니다: 단일 밑줄로 시작하고 "
#~ "끝나는 이름은 enum이 예약하고 있고 사용할 수 "
#~ "없습니다; 열거형 내에 정의된 다른 모든 어트리뷰트는 "
#~ "특수 메서드 (:meth:`__str__`, :meth:`__add__` 등),"
#~ " 디스크립터 (메서드도 디스크립터입니다) 및 "
#~ ":attr:`_ignore_`\\에 나열된 변수 이름을 제외하고 이"
#~ " 열거의 멤버가 됩니다."

#~ msgid ""
#~ "Note:  if your enumeration defines "
#~ ":meth:`__new__` and/or :meth:`__init__` then "
#~ "any value(s) given to the enum "
#~ "member will be passed into those "
#~ "methods. See `Planet`_ for an example."
#~ msgstr ""
#~ "참고: 열거형이 :meth:`__new__` 및/또는 "
#~ ":meth:`__init__`\\를 정의하면 열거형 멤버에 제공된 모든"
#~ " 값이 해당 메서드에 전달됩니다. 예제는 `행성 "
#~ "<Planet_>`_\\을 참조하십시오."

#~ msgid "Restricted Enum subclassing"
#~ msgstr "제한된 Enum 서브 클래싱"

#~ msgid ""
#~ "A new :class:`Enum` class must have "
#~ "one base Enum class, up to one "
#~ "concrete data type, and as many "
#~ ":class:`object`-based mixin classes as needed."
#~ "  The order of these base classes "
#~ "is::"
#~ msgstr ""
#~ "새로운 :class:`Enum` 클래스에는 하나의 베이스 Enum "
#~ "클래스, 최대 하나의 구상 데이터형 및 필요한 "
#~ "만큼의 :class:`object` 기반 믹스인 클래스가 있어야 "
#~ "합니다. 이 베이스 클래스의 순서는 다음과 같습니다::"

#~ msgid ""
#~ "Also, subclassing an enumeration is "
#~ "allowed only if the enumeration does "
#~ "not define any members.  So this "
#~ "is forbidden::"
#~ msgstr "또한, 열거형의 서브 클래싱은 열거형이 멤버를 정의하지 않았을 때만 허용됩니다. 따라서 다음과 같은 것은 금지되어 있습니다::"

#~ msgid "But this is allowed::"
#~ msgstr "그러나 이것은 허용됩니다::"

#~ msgid ""
#~ "Allowing subclassing of enums that "
#~ "define members would lead to a "
#~ "violation of some important invariants "
#~ "of types and instances.  On the "
#~ "other hand, it makes sense to "
#~ "allow sharing some common behavior "
#~ "between a group of enumerations. (See"
#~ " `OrderedEnum`_ for an example.)"
#~ msgstr ""
#~ "멤버를 정의하는 열거형의 서브 클래싱을 허용하면 형과 "
#~ "인스턴스의 중요한 불변성을 위반하게 됩니다. 반면에, 열거형"
#~ " 그룹 간에 공통적인 동작을 공유하도록 허락하는 것은"
#~ " 말이 됩니다. (예는 `OrderedEnum`_\\을 참조하십시오.)"

#~ msgid "Pickling"
#~ msgstr "피클링"

#~ msgid "Enumerations can be pickled and unpickled::"
#~ msgstr "열거형은 피클링 되거나 역 피클링 될 수 있습니다::"

#~ msgid ""
#~ "The usual restrictions for pickling "
#~ "apply: picklable enums must be defined"
#~ " in the top level of a module,"
#~ " since unpickling requires them to be"
#~ " importable from that module."
#~ msgstr ""
#~ "피클링에 대한 일반적인 제한 사항이 적용됩니다: 역 "
#~ "피클링은 열거형을 모듈에서 임포트 할 수 있어야 "
#~ "하므로, 피클 가능한 열거형은 모듈의 최상위 수준에서 "
#~ "정의해야 합니다."

#~ msgid ""
#~ "With pickle protocol version 4 it "
#~ "is possible to easily pickle enums "
#~ "nested in other classes."
#~ msgstr "피클 프로토콜 버전 4를 사용하면 다른 클래스에 중첩된 열거형을 쉽게 피클 할 수 있습니다."

#~ msgid ""
#~ "It is possible to modify how Enum"
#~ " members are pickled/unpickled by defining"
#~ " :meth:`__reduce_ex__` in the enumeration "
#~ "class."
#~ msgstr ""
#~ "열거형 클래스에 :meth:`__reduce_ex__`\\를 정의하여 Enum"
#~ " 멤버를 피클/역 피클 하는 방법을 수정할 수 "
#~ "있습니다."

#~ msgid "Functional API"
#~ msgstr "함수형 API"

#~ msgid ""
#~ "The :class:`Enum` class is callable, "
#~ "providing the following functional API::"
#~ msgstr ":class:`Enum` 클래스는 다음과 같은 함수형 API를 제공하는 콜러블입니다::"

#~ msgid ""
#~ "The semantics of this API resemble "
#~ ":class:`~collections.namedtuple`. The first argument"
#~ " of the call to :class:`Enum` is "
#~ "the name of the enumeration."
#~ msgstr ""
#~ "이 API의 의미는 :class:`~collections.namedtuple`\\과 "
#~ "유사합니다. :class:`Enum` 호출의 첫 번째 인자는 "
#~ "열거형의 이름입니다."

#~ msgid ""
#~ "The second argument is the *source* "
#~ "of enumeration member names.  It can "
#~ "be a whitespace-separated string of "
#~ "names, a sequence of names, a "
#~ "sequence of 2-tuples with key/value "
#~ "pairs, or a mapping (e.g. dictionary)"
#~ " of names to values.  The last "
#~ "two options enable assigning arbitrary "
#~ "values to enumerations; the others "
#~ "auto-assign increasing integers starting "
#~ "with 1 (use the ``start`` parameter "
#~ "to specify a different starting value)."
#~ "  A new class derived from "
#~ ":class:`Enum` is returned.  In other "
#~ "words, the above assignment to "
#~ ":class:`Animal` is equivalent to::"
#~ msgstr ""
#~ "두 번째 인자는 열거형 멤버 이름의 *소스*\\입니다. "
#~ "공백으로 구분된 이름의 문자열, 이름의 시퀀스, 키/값 "
#~ "쌍 2-튜플의 시퀀스 또는 이름에서 값으로의 매핑(예를 "
#~ "들어, 딕셔너리)일 수 있습니다. 마지막 두 옵션은 "
#~ "임의의 값을 열거형에 할당할 수 있게 합니다; "
#~ "나머지는 1부터 시작하여 증가하는 정수를 자동 할당합니다"
#~ " ( 다른 시작 값을 지정하려면 ``start`` 매개"
#~ " 변수를 사용하십시오). :class:`Enum`\\에서 파생된 새 "
#~ "클래스를 반환합니다. 즉, 위의 :class:`Animal` 대입은"
#~ " 다음과 동등합니다::"

#~ msgid ""
#~ "The reason for defaulting to ``1`` "
#~ "as the starting number and not "
#~ "``0`` is that ``0`` is ``False`` "
#~ "in a boolean sense, but enum "
#~ "members all evaluate to ``True``."
#~ msgstr ""
#~ "시작 번호로 ``0``\\이 아니라 ``1``\\을 기본값으로 "
#~ "설정하는 이유는 ``0``\\이 불리언 의미로 ``False``\\이지만"
#~ " 열거형 멤버는 모두 ``True``\\로 평가되기 때문입니다."

#~ msgid ""
#~ "Pickling enums created with the "
#~ "functional API can be tricky as "
#~ "frame stack implementation details are "
#~ "used to try and figure out which"
#~ " module the enumeration is being "
#~ "created in (e.g. it will fail if"
#~ " you use a utility function in "
#~ "separate module, and also may not "
#~ "work on IronPython or Jython). The "
#~ "solution is to specify the module "
#~ "name explicitly as follows::"
#~ msgstr ""
#~ "함수형 API로 만든 열거형을 피클 하는 것은 "
#~ "까다로울 수 있는데, 프레임 스택 구현 세부 사항을"
#~ " 사용하여 열거형이 만들어지고 있는 모듈을 파악하고 "
#~ "시도하기 때문입니다 (예를 들어, 별도의 모듈에 있는 "
#~ "유틸리티 함수를 사용하면 실패할 것이고. IronPython이나 "
#~ "Jython에서는 작동하지 않을 수 있습니다). 해결책은 "
#~ "다음과 같이 모듈 이름을 명시적으로 지정하는 것입니다::"

#~ msgid ""
#~ "If ``module`` is not supplied, and "
#~ "Enum cannot determine what it is, "
#~ "the new Enum members will not be"
#~ " unpicklable; to keep errors closer "
#~ "to the source, pickling will be "
#~ "disabled."
#~ msgstr ""
#~ "``module``\\이 제공되지 않고, Enum이 모듈을 판단할 "
#~ "수 없으면, 새 Enum 멤버는 역 피클 되지"
#~ " 않을 것입니다; 에러를 소스에 더 가깝게 유지하기"
#~ " 위해, 피클링이 비활성화됩니다."

#~ msgid ""
#~ "The new pickle protocol 4 also, in"
#~ " some circumstances, relies on "
#~ ":attr:`~definition.__qualname__` being set to "
#~ "the location where pickle will be "
#~ "able to find the class.  For "
#~ "example, if the class was made "
#~ "available in class SomeData in the "
#~ "global scope::"
#~ msgstr ""
#~ "새로운 피클 프로토콜 4는 일부 상황에서 "
#~ ":attr:`~definition.__qualname__`\\이 pickle이 클래스를 찾을"
#~ " 수 있는 위치로 설정되는 것에 의존합니다. 예를 "
#~ "들어, 클래스가 전역 스코프의 SomeData 클래스 내에"
#~ " 만들어지면::"

#~ msgid "The complete signature is::"
#~ msgstr "완전한 서명은 다음과 같습니다::"

#~ msgid "What the new Enum class will record as its name."
#~ msgstr "새 Enum 클래스가 자신의 이름으로 기록할 것."

#~ msgid ""
#~ "The Enum members.  This can be a"
#~ " whitespace or comma separated string "
#~ "(values will start at 1 unless "
#~ "otherwise specified)::"
#~ msgstr "Enum 멤버. 공백이나 쉼표로 구분된 문자열일 수 있습니다 (지정하지 않는 한 값은 1부터 시작합니다)::"

#~ msgid "or an iterator of names::"
#~ msgstr "또는 이름의 이터레이터::"

#~ msgid "or an iterator of (name, value) pairs::"
#~ msgstr "또는 (이름, 값) 쌍의 이터레이터::"

#~ msgid "or a mapping::"
#~ msgstr "또는 매핑::"

#~ msgid "where in module new Enum class can be found."
#~ msgstr "모듈에서 새로운 Enum 클래스를 찾을 수 있는 곳."

#~ msgid "type to mix in to new Enum class."
#~ msgstr "새로운 Enum 클래스와 혼합할 형."

#~ msgid "number to start counting at if only names are passed in."
#~ msgstr "이름 만 전달될 때 세기 시작할 숫자."

#~ msgid "The *start* parameter was added."
#~ msgstr "*start* 매개 변수가 추가되었습니다."

#~ msgid ""
#~ "The first variation of :class:`Enum` "
#~ "that is provided is also a "
#~ "subclass of :class:`int`.  Members of an"
#~ " :class:`IntEnum` can be compared to "
#~ "integers; by extension, integer enumerations"
#~ " of different types can also be "
#~ "compared to each other::"
#~ msgstr ""
#~ "제공되는 첫 번째 :class:`Enum`\\의 변형은 "
#~ ":class:`int`\\의 서브 클래스이기도 합니다. "
#~ ":class:`IntEnum`\\의 멤버는 정수와 비교할 수 있습니다;"
#~ " 확장하여, 다른 정수 열거형도 서로 비교할 수 "
#~ "있습니다::"

#~ msgid ""
#~ "However, they still can't be compared"
#~ " to standard :class:`Enum` enumerations::"
#~ msgstr "그러나, 여전히 표준 :class:`Enum` 열거형과 비교할 수는 없습니다::"

#~ msgid ""
#~ ":class:`IntEnum` values behave like integers"
#~ " in other ways you'd expect::"
#~ msgstr ":class:`IntEnum` 값은 여러분이 기대하는 다른 방식으로 정수처럼 동작합니다::"

#~ msgid "IntFlag"
#~ msgstr "IntFlag"

#~ msgid ""
#~ "The next variation of :class:`Enum` "
#~ "provided, :class:`IntFlag`, is also based "
#~ "on :class:`int`.  The difference being "
#~ ":class:`IntFlag` members can be combined "
#~ "using the bitwise operators (&, \\|, "
#~ "^, ~) and the result is still "
#~ "an :class:`IntFlag` member.  However, as "
#~ "the name implies, :class:`IntFlag` members "
#~ "also subclass :class:`int` and can be"
#~ " used wherever an :class:`int` is "
#~ "used.  Any operation on an "
#~ ":class:`IntFlag` member besides the bit-"
#~ "wise operations will lose the "
#~ ":class:`IntFlag` membership."
#~ msgstr ""
#~ "제공된 :class:`Enum`\\의 다음 변형인 "
#~ ":class:`IntFlag`\\도 :class:`int`\\를 기반으로 합니다. "
#~ "차이점은, :class:`IntFlag` 멤버는 비트 연산자(&, "
#~ "\\|, ^, ~)를 사용하여 결합할 수 있으며 "
#~ "결과는 여전히 :class:`IntFlag` 멤버라는 것입니다. 그러나,"
#~ " 이름에서 알 수 있듯이, :class:`IntFlag` 멤버는"
#~ " :class:`int`\\를 서브 클래스하고 :class:`int`\\가 "
#~ "사용되는 모든 곳에서 사용할 수 있습니다. 비트별 "
#~ "연산 이외의 :class:`IntFlag` 멤버에 대한 모든 "
#~ "연산은 :class:`IntFlag` 멤버 자격을 잃게 만듭니다."

#~ msgid "It is also possible to name the combinations::"
#~ msgstr "조합의 이름을 지정할 수도 있습니다::"

#~ msgid ""
#~ "Another important difference between "
#~ ":class:`IntFlag` and :class:`Enum` is that "
#~ "if no flags are set (the value "
#~ "is 0), its boolean evaluation is "
#~ ":data:`False`::"
#~ msgstr ""
#~ ":class:`IntFlag`\\과 :class:`Enum`\\의 또 다른 중요한"
#~ " 차이점은 아무런 플래그도 설정되지 않으면 (값이 "
#~ "0입니다) 불리언 평가가 :data:`False`\\가 된다는 "
#~ "것입니다::"

#~ msgid ""
#~ "Because :class:`IntFlag` members are also "
#~ "subclasses of :class:`int` they can be"
#~ " combined with them::"
#~ msgstr ":class:`IntFlag` 멤버도 :class:`int`\\의 서브 클래스이므로 정수와 결합할 수 있습니다::"

#~ msgid "Flag"
#~ msgstr "Flag"

#~ msgid ""
#~ "The last variation is :class:`Flag`.  "
#~ "Like :class:`IntFlag`, :class:`Flag` members "
#~ "can be combined using the bitwise "
#~ "operators (&, \\|, ^, ~).  Unlike "
#~ ":class:`IntFlag`, they cannot be combined "
#~ "with, nor compared against, any other"
#~ " :class:`Flag` enumeration, nor :class:`int`."
#~ "  While it is possible to specify "
#~ "the values directly it is recommended"
#~ " to use :class:`auto` as the value"
#~ " and let :class:`Flag` select an "
#~ "appropriate value."
#~ msgstr ""
#~ "마지막 변형은 :class:`Flag`\\입니다. :class:`IntFlag`\\와 "
#~ "마찬가지로, :class:`Flag` 멤버는 비트 연산자(&, \\|,"
#~ " ^, ~)를 사용하여 결합할 수 있습니다. "
#~ ":class:`IntFlag`\\와 달리, 다른 :class:`Flag` 열거형이나"
#~ " :class:`int`\\와 결합하거나 비교할 수 없습니다. 값을"
#~ " 직접 지정할 수는 있지만, :class:`auto`\\를 값으로"
#~ " 사용하고 :class:`Flag`\\가 적절한 값을 선택하도록 "
#~ "하는 것이 좋습니다."

#~ msgid ""
#~ "Like :class:`IntFlag`, if a combination "
#~ "of :class:`Flag` members results in no"
#~ " flags being set, the boolean "
#~ "evaluation is :data:`False`::"
#~ msgstr ""
#~ ":class:`IntFlag`\\와 마찬가지로, :class:`Flag` 멤버의 "
#~ "조합이 아무런 플래그도 설정하지 않으면, 불리언 평가는 "
#~ ":data:`False`\\입니다::"

#~ msgid ""
#~ "Individual flags should have values that"
#~ " are powers of two (1, 2, 4,"
#~ " 8, ...), while combinations of flags"
#~ " won't::"
#~ msgstr "개별 플래그는 2의 거듭제곱 값(1, 2, 4, 8, ...)을 가져야 하지만, 플래그의 조합은 그렇지 않습니다::"

#~ msgid ""
#~ "Giving a name to the \"no flags"
#~ " set\" condition does not change its"
#~ " boolean value::"
#~ msgstr "\"플래그 설정 없음\" 조건에 이름을 부여해도 불리언 값은 변경되지 않습니다::"

#~ msgid ""
#~ "For the majority of new code, "
#~ ":class:`Enum` and :class:`Flag` are strongly"
#~ " recommended, since :class:`IntEnum` and "
#~ ":class:`IntFlag` break some semantic promises"
#~ " of an enumeration (by being "
#~ "comparable to integers, and thus by "
#~ "transitivity to other unrelated enumerations)."
#~ "  :class:`IntEnum` and :class:`IntFlag` should"
#~ " be used only in cases where "
#~ ":class:`Enum` and :class:`Flag` will not "
#~ "do; for example, when integer constants"
#~ " are replaced with enumerations, or "
#~ "for interoperability with other systems."
#~ msgstr ""
#~ ":class:`IntEnum`\\과 :class:`IntFlag`\\는 열거형에 대한 "
#~ "의미론적 약속을 깨뜨리기 때문에 (정수와 비교할 수 "
#~ "있어서, 다른 관련되지 않은 열거형으로의 "
#~ "추이성(transitivity)으로 인해), 새로운 코드 대부분에는 "
#~ ":class:`Enum`\\과 :class:`Flag`\\를 강력히 권장합니다. "
#~ ":class:`IntEnum`\\과 :class:`IntFlag`\\는 :class:`Enum`\\과"
#~ " :class:`Flag`\\가 동작하지 않는 경우에만 사용해야 "
#~ "합니다; 예를 들어, 정수 상수가 열거형으로 대체되거나,"
#~ " 다른 시스템과의 상호 운용성을 위해."

#~ msgid ""
#~ "While :class:`IntEnum` is part of the"
#~ " :mod:`enum` module, it would be very"
#~ " simple to implement independently::"
#~ msgstr ":class:`IntEnum`\\은 :mod:`enum` 모듈의 일부이지만, 독립적으로 구현하는 것은 매우 간단합니다::"

#~ msgid ""
#~ "This demonstrates how similar derived "
#~ "enumerations can be defined; for example"
#~ " a :class:`StrEnum` that mixes in "
#~ ":class:`str` instead of :class:`int`."
#~ msgstr ""
#~ "이것은 유사한 파생된 열거형을 정의 할 수 있는"
#~ " 방법을 보여줍니다; 예를 들어 :class:`int` 대신 "
#~ ":class:`str`\\로 혼합되는 :class:`StrEnum`."

#~ msgid "Some rules:"
#~ msgstr "몇 가지 규칙:"

#~ msgid ""
#~ "When subclassing :class:`Enum`, mix-in "
#~ "types must appear before :class:`Enum` "
#~ "itself in the sequence of bases, "
#~ "as in the :class:`IntEnum` example "
#~ "above."
#~ msgstr ""
#~ ":class:`Enum`\\을 서브 클래싱 할 때, 위의 "
#~ ":class:`IntEnum` 예제에서처럼, 혼합(mix-in)형은 베이스 "
#~ "시퀀스에서 :class:`Enum` 앞에 나타나야 합니다."

#~ msgid ""
#~ "While :class:`Enum` can have members of"
#~ " any type, once you mix in an"
#~ " additional type, all the members "
#~ "must have values of that type, "
#~ "e.g. :class:`int` above.  This restriction "
#~ "does not apply to mix-ins which"
#~ " only add methods and don't specify"
#~ " another type."
#~ msgstr ""
#~ ":class:`Enum`\\은 모든 형의 멤버를 가질 수 "
#~ "있지만, 일단 추가 형을 혼합하면, 모든 멤버는 "
#~ "해당 형의 값을 가져야 합니다, 예를 들어 위의"
#~ " :class:`int`. 이 제한은 메서드만 추가할 뿐 "
#~ "다른 형을 지정하지 않는 믹스인에는 적용되지 않습니다."

#~ msgid ""
#~ "When another data type is mixed "
#~ "in, the :attr:`value` attribute is *not"
#~ " the same* as the enum member "
#~ "itself, although it is equivalent and"
#~ " will compare equal."
#~ msgstr ""
#~ "다른 데이터형이 혼합될 때, :attr:`value` 어트리뷰트는 "
#~ "열거형 멤버 자체와 *같지 않지*\\만, 동등하고 같다고"
#~ " 비교됩니다."

#~ msgid ""
#~ "%-style formatting:  `%s` and `%r` call"
#~ " the :class:`Enum` class's :meth:`__str__` "
#~ "and :meth:`__repr__` respectively; other codes"
#~ " (such as `%i` or `%h` for "
#~ "IntEnum) treat the enum member as "
#~ "its mixed-in type."
#~ msgstr ""
#~ "%-스타일 포매팅: `%s` 와 `%r` 은 각각 "
#~ ":class:`Enum` 클래스의 :meth:`__str__`\\과 "
#~ ":meth:`__repr__`\\을 호출합니다; 다른 코드(가령 IntEnum의"
#~ " 경우 `%i` 나 `%h`)는 열거형 멤버를 혼합형으로"
#~ " 취급합니다."

#~ msgid ""
#~ ":ref:`Formatted string literals <f-strings>`, "
#~ ":meth:`str.format`, and :func:`format` will "
#~ "use the mixed-in type's "
#~ ":meth:`__format__` unless :meth:`__str__` or "
#~ ":meth:`__format__` is overridden in the "
#~ "subclass, in which case the overridden"
#~ " methods or :class:`Enum` methods will "
#~ "be used. Use the !s and !r "
#~ "format codes to force usage of the"
#~ " :class:`Enum` class's :meth:`__str__` and "
#~ ":meth:`__repr__` methods."
#~ msgstr ""
#~ ":ref:`포맷 문자열 리터럴 <f-strings>`, "
#~ ":meth:`str.format` 및 :func:`format`\\은 혼합형의 "
#~ ":meth:`__format__`\\을 사용합니다. 하지만, 서브 클래스에서 "
#~ ":meth:`__str__`\\이나 :meth:`__format__`\\이 재정의되면, "
#~ "재정의된 메서드나 :class:`Enum` 메소드가 사용됩니다. "
#~ ":class:`Enum` 클래스의 :meth:`__str__`\\과 "
#~ ":meth:`__repr__` 메서드의 사용을 강제하려면 !s 과 "
#~ "!r 포맷 코드를 사용하십시오."

#~ msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
#~ msgstr ":meth:`__new__`\\나 :meth:`__init__`\\를 사용할 때"

#~ msgid ""
#~ ":meth:`__new__` must be used whenever "
#~ "you want to customize the actual "
#~ "value of the :class:`Enum` member.  Any"
#~ " other modifications may go in either"
#~ " :meth:`__new__` or :meth:`__init__`, with "
#~ ":meth:`__init__` being preferred."
#~ msgstr ""
#~ ":class:`Enum` 멤버의 실제 값을 사용자 정의하려면 "
#~ ":meth:`__new__`\\를 사용해야 합니다. 다른 수정은 "
#~ ":meth:`__new__`\\나 :meth:`__init__`\\를 사용할 수 "
#~ "있지만, :meth:`__init__`\\가 바람직합니다."

#~ msgid ""
#~ "For example, if you want to pass"
#~ " several items to the constructor, "
#~ "but only want one of them to "
#~ "be the value::"
#~ msgstr "예를 들어, 여러 항목을 생성자에 전달하고 싶지만, 그중 하나만 값이 되도록 하려면 다음과 같이 합니다::"

#~ msgid "Interesting examples"
#~ msgstr "흥미로운 예"

#~ msgid ""
#~ "While :class:`Enum`, :class:`IntEnum`, "
#~ ":class:`IntFlag`, and :class:`Flag` are "
#~ "expected to cover the majority of "
#~ "use-cases, they cannot cover them "
#~ "all.  Here are recipes for some "
#~ "different types of enumerations that can"
#~ " be used directly, or as examples "
#~ "for creating one's own."
#~ msgstr ""
#~ ":class:`Enum`, :class:`IntEnum`, :class:`IntFlag` 및"
#~ " :class:`Flag`\\는 대부분의 사용 사례를 포괄할 것으로"
#~ " 예상되지만, 모든 사용 사례를 포괄할 수는 없습니다."
#~ " 다음은 직접 혹은 자신의 것을 만드는 예제로 "
#~ "사용할 수 있는 여러 유형의 열거형에 대한 "
#~ "조리법입니다."

#~ msgid "Omitting values"
#~ msgstr "값 생략하기"

#~ msgid ""
#~ "In many use-cases one doesn't care"
#~ " what the actual value of an "
#~ "enumeration is. There are several ways"
#~ " to define this type of simple "
#~ "enumeration:"
#~ msgstr ""
#~ "많은 사용 사례에서 열거형의 실제 값이 무엇인지 "
#~ "신경 쓰지 않습니다. 이런 유형의 간단한 열거형을 "
#~ "정의하는 몇 가지 방법이 있습니다:"

#~ msgid "use instances of :class:`auto` for the value"
#~ msgstr ":class:`auto`\\의 인스턴스를 값으로 사용합니다"

#~ msgid "use instances of :class:`object` as the value"
#~ msgstr ":class:`object` 인스턴스를 값으로 사용합니다"

#~ msgid "use a descriptive string as the value"
#~ msgstr "설명 문자열을 값으로 사용합니다"

#~ msgid ""
#~ "use a tuple as the value and "
#~ "a custom :meth:`__new__` to replace the"
#~ " tuple with an :class:`int` value"
#~ msgstr "튜플을 값으로 사용하고 사용자 정의 :meth:`__new__`\\를 사용하여 튜플을 :class:`int` 값으로 대체합니다"

#~ msgid ""
#~ "Using any of these methods signifies "
#~ "to the user that these values are"
#~ " not important, and also enables one"
#~ " to add, remove, or reorder members"
#~ " without having to renumber the "
#~ "remaining members."
#~ msgstr ""
#~ "이러한 방법의 하나를 사용하는 것은 사용자에게 이러한 "
#~ "값이 중요하지 않다고 알리고, 나머지 멤버의 번호를 "
#~ "다시 매길 필요 없이 멤버를 추가, 제거 또는"
#~ " 재정렬 할 수 있도록 합니다."

#~ msgid ""
#~ "Whichever method you choose, you should"
#~ " provide a :meth:`repr` that also "
#~ "hides the (unimportant) value::"
#~ msgstr "어떤 방법을 선택하든, (중요하지 않은) 값을 숨기는 :meth:`repr`\\을 제공해야 합니다::"

#~ msgid "Using :class:`auto` would look like::"
#~ msgstr ":class:`auto`\\를 사용하면 이렇게 됩니다::"

#~ msgid "Using :class:`object` would look like::"
#~ msgstr ":class:`object`\\를 사용하면 이렇게 됩니다::"

#~ msgid "Using a descriptive string"
#~ msgstr "설명 문자열 사용하기"

#~ msgid "Using a string as the value would look like::"
#~ msgstr "문자열을 값으로 사용하면 이렇게 됩니다::"

#~ msgid "Using a custom :meth:`__new__`"
#~ msgstr "사용자 정의 :meth:`__new__` 사용하기"

#~ msgid "Using an auto-numbering :meth:`__new__` would look like::"
#~ msgstr "자동 번호 매기기 :meth:`__new__`\\를 사용하면 이렇게 됩니다::"

#~ msgid ""
#~ "To make a more general purpose "
#~ "``AutoNumber``, add ``*args`` to the "
#~ "signature::"
#~ msgstr "더 범용의 ``AutoNumber``\\를 만들려면, 서명에 ``*args``\\를 추가합니다::"

#~ msgid ""
#~ "Then when you inherit from "
#~ "``AutoNumber`` you can write your own"
#~ " ``__init__`` to handle any extra "
#~ "arguments::"
#~ msgstr ""
#~ "그런 다음 ``AutoNumber``\\에서 상속할 때 추가 "
#~ "인자를 처리하기 위해 자체 ``__init__``\\를 작성할 "
#~ "수 있습니다::"

#~ msgid ""
#~ "The :meth:`__new__` method, if defined, "
#~ "is used during creation of the "
#~ "Enum members; it is then replaced "
#~ "by Enum's :meth:`__new__` which is used"
#~ " after class creation for lookup of"
#~ " existing members."
#~ msgstr ""
#~ "정의되면, :meth:`__new__` 메서드는 Enum 멤버 생성"
#~ " 중에 사용됩니다; 그런 다음 Enum의 "
#~ ":meth:`__new__`\\로 대체되는데, 이것이 클래스 생성 후에"
#~ " 기존 멤버를 조회하기 위해 사용됩니다."

#~ msgid "OrderedEnum"
#~ msgstr "OrderedEnum"

#~ msgid ""
#~ "An ordered enumeration that is not "
#~ "based on :class:`IntEnum` and so "
#~ "maintains the normal :class:`Enum` invariants"
#~ " (such as not being comparable to "
#~ "other enumerations)::"
#~ msgstr ""
#~ ":class:`IntEnum`\\에 기반하지 않기 때문에 일반적인 "
#~ ":class:`Enum` 불변성(invariants) (가령 다른 열거형과 "
#~ "비교할 수 없다는 성질) 을 유지하는 순서 있는"
#~ " 열거형::"

#~ msgid "DuplicateFreeEnum"
#~ msgstr "DuplicateFreeEnum"

#~ msgid ""
#~ "Raises an error if a duplicate "
#~ "member name is found instead of "
#~ "creating an alias::"
#~ msgstr "중복된 멤버 이름이 발견되면 별칭을 만드는 대신 에러를 발생시킵니다::"

#~ msgid ""
#~ "This is a useful example for "
#~ "subclassing Enum to add or change "
#~ "other behaviors as well as disallowing"
#~ " aliases.  If the only desired change"
#~ " is disallowing aliases, the :func:`unique`"
#~ " decorator can be used instead."
#~ msgstr ""
#~ "이것은 별칭을 허락하지 않는 것뿐 아니라 Enum을 "
#~ "서브 클래싱하여 다른 동작을 추가하거나 변경하는 유용한 "
#~ "예입니다. 원하는 변경이 오직 별칭을 허용하지 않는 "
#~ "것이면, :func:`unique` 데코레이터를 대신 사용할 수 "
#~ "있습니다."

#~ msgid "Planet"
#~ msgstr "행성"

#~ msgid ""
#~ "If :meth:`__new__` or :meth:`__init__` is "
#~ "defined the value of the enum "
#~ "member will be passed to those "
#~ "methods::"
#~ msgstr ":meth:`__new__`\\나 :meth:`__init__`\\가 정의되면 열거형 멤버의 값이 해당 메서드로 전달됩니다::"

#~ msgid "TimePeriod"
#~ msgstr "TimePeriod"

#~ msgid "An example to show the :attr:`_ignore_` attribute in use::"
#~ msgstr ":attr:`_ignore_` 어트리뷰트의 사용을 보여주는 예::"

#~ msgid "How are Enums different?"
#~ msgstr "열거형은 어떻게 다릅니까?"

#~ msgid ""
#~ "Enums have a custom metaclass that "
#~ "affects many aspects of both derived "
#~ "Enum classes and their instances "
#~ "(members)."
#~ msgstr "열거형은 파생된 Enum 클래스와 그들의 인스턴스(멤버)의 여러 측면에 영향을 주는 사용자 정의 메타 클래스를 갖습니다."

#~ msgid "Enum Classes"
#~ msgstr "열거형 클래스"

#~ msgid ""
#~ "The :class:`EnumMeta` metaclass is responsible"
#~ " for providing the :meth:`__contains__`, "
#~ ":meth:`__dir__`, :meth:`__iter__` and other "
#~ "methods that allow one to do "
#~ "things with an :class:`Enum` class that"
#~ " fail on a typical class, such "
#~ "as `list(Color)` or `some_enum_var in "
#~ "Color`.  :class:`EnumMeta` is responsible for"
#~ " ensuring that various other methods "
#~ "on the final :class:`Enum` class are "
#~ "correct (such as :meth:`__new__`, "
#~ ":meth:`__getnewargs__`, :meth:`__str__` and "
#~ ":meth:`__repr__`)."
#~ msgstr ""
#~ ":class:`EnumMeta` 메타 클래스는 `list(Color)`\\나 "
#~ "`some_enum_var in Color`\\와 같은 일반적인 "
#~ "클래스에서 실패하는 연산을 :class:`Enum` 클래스로 할 "
#~ "수 있도록 하는 :meth:`__contains__`, "
#~ ":meth:`__dir__`, :meth:`__iter__` 및 기타 메서드를"
#~ " 제공합니다. :class:`EnumMeta`\\는 최종 :class:`Enum` "
#~ "클래스의 다양한 다른 메서드(가령 :meth:`__new__`, "
#~ ":meth:`__getnewargs__`, :meth:`__str__` 및 "
#~ ":meth:`__repr__`)가 올바른지 확인합니다."

#~ msgid "Enum Members (aka instances)"
#~ msgstr "열거형 멤버 (일명 인스턴스)"

#~ msgid ""
#~ "The most interesting thing about Enum"
#~ " members is that they are singletons."
#~ " :class:`EnumMeta` creates them all while"
#~ " it is creating the :class:`Enum` "
#~ "class itself, and then puts a "
#~ "custom :meth:`__new__` in place to "
#~ "ensure that no new ones are ever"
#~ " instantiated by returning only the "
#~ "existing member instances."
#~ msgstr ""
#~ "Enum 멤버에 대한 가장 흥미로운 점은 싱글톤이라는 "
#~ "것입니다. :class:`EnumMeta`\\는 :class:`Enum` 클래스 "
#~ "자체를 만드는 동안 멤버를 모두 만든 다음, 사용자"
#~ " 정의 :meth:`__new__`\\를 넣어서 기존 멤버 "
#~ "인스턴스만 반환하여 더는 새 인스턴스가 만들어지지 않도록"
#~ " 합니다."

#~ msgid "Finer Points"
#~ msgstr "세부 사항"

#~ msgid ""
#~ "To help keep Python 2 / Python "
#~ "3 code in sync an :attr:`_order_` "
#~ "attribute can be provided.  It will "
#~ "be checked against the actual order "
#~ "of the enumeration and raise an "
#~ "error if the two do not match::"
#~ msgstr ""
#~ "파이썬 2 / 파이썬 3 코드를 동기화 상태로"
#~ " 유지하기 위해 :attr:`_order_` 어트리뷰트를 제공 할"
#~ " 수 있습니다. 열거형의 실제 순서와 비교하여 확인되며"
#~ " 일치하지 않으면 에러가 발생합니다::"

#~ msgid ""
#~ "In Python 2 code the :attr:`_order_` "
#~ "attribute is necessary as definition "
#~ "order is lost before it can be "
#~ "recorded."
#~ msgstr "파이썬 2 코드에서는 정의 순서가 기록될 수 있기 전에 손실되기 때문에 :attr:`_order_` 어트리뷰트가 필요합니다."

#~ msgid "_Private__names"
#~ msgstr "_Private__names"

#~ msgid ""
#~ "Private names will be normal attributes"
#~ " in Python 3.10 instead of either "
#~ "an error or a member (depending on"
#~ " if the name ends with an "
#~ "underscore). Using these names in 3.9"
#~ " will issue a :exc:`DeprecationWarning`."
#~ msgstr ""
#~ "비공개 이름은 에러나 멤버 (이름이 밑줄로 끝나는지에 "
#~ "따라 다릅니다) 대신 파이썬 3.10 에서 일반 "
#~ "어트리뷰트가 될 것입니다. 3.9에서 이런 이름을 사용하면"
#~ " :exc:`DeprecationWarning`\\이 발행됩니다."

#~ msgid "``Enum`` member type"
#~ msgstr "``Enum`` 멤버 형"

#~ msgid ""
#~ ":class:`Enum` members are instances of "
#~ "their :class:`Enum` class, and are "
#~ "normally accessed as ``EnumClass.member``.  "
#~ "Under certain circumstances they can "
#~ "also be accessed as "
#~ "``EnumClass.member.member``, but you should "
#~ "never do this as that lookup may"
#~ " fail or, worse, return something "
#~ "besides the :class:`Enum` member you are"
#~ " looking for (this is another good"
#~ " reason to use all-uppercase names"
#~ " for members)::"
#~ msgstr ""
#~ ":class:`Enum` 멤버는 :class:`Enum` 클래스의 인스턴스이며,"
#~ " 일반적으로 ``EnumClass.member``\\로 액세스 됩니다. 특정"
#~ " 상황에서는 ``EnumClass.member.member``\\로 액세스 할 "
#~ "수 있지만, 조회가 실패하거나 더 나쁜 경우 찾고"
#~ " 있는 :class:`Enum` 멤버 이외의 것을 반환할 "
#~ "수 있기 때문에 이 작업을 수행해서는 안 됩니다"
#~ " (이것은 멤버에 모두 대문자로 구성된 이름을 사용하는"
#~ " 또 하나의 이유입니다)::"

#~ msgid "Boolean value of ``Enum`` classes and members"
#~ msgstr "``Enum`` 클래스와 멤버의 불리언 값"

#~ msgid ""
#~ ":class:`Enum` members that are mixed "
#~ "with non-:class:`Enum` types (such as "
#~ ":class:`int`, :class:`str`, etc.) are "
#~ "evaluated according to the mixed-in "
#~ "type's rules; otherwise, all members "
#~ "evaluate as :data:`True`.  To make your"
#~ " own Enum's boolean evaluation depend "
#~ "on the member's value add the "
#~ "following to your class::"
#~ msgstr ""
#~ "비 :class:`Enum` 형(가령 :class:`int`, "
#~ ":class:`str` 등)과 혼합된 :class:`Enum` 멤버는 "
#~ "혼합형의 규칙에 따라 평가됩니다; 그렇지 않으면, 모든 "
#~ "멤버가 :data:`True`\\로 평가됩니다. 여러분 자신의 Enum의"
#~ " 불리언 평가를 멤버의 값에 따르게 하려면 클래스에"
#~ " 다음을 추가하십시오::"

#~ msgid ":class:`Enum` classes always evaluate as :data:`True`."
#~ msgstr ":class:`Enum` 클래스는 항상 :data:`True`\\로 평가됩니다."

#~ msgid "``Enum`` classes with methods"
#~ msgstr "메서드가 있는 ``Enum`` 클래스"

#~ msgid ""
#~ "If you give your :class:`Enum` subclass"
#~ " extra methods, like the `Planet`_ "
#~ "class above, those methods will show "
#~ "up in a :func:`dir` of the member,"
#~ " but not of the class::"
#~ msgstr ""
#~ ":class:`Enum` 서브 클래스에 위의 `Planet`_ 클래스처럼"
#~ " 추가 메서드를 제공하면, 해당 메서드는 멤버의 "
#~ ":func:`dir`\\에 표시되지만, 클래스에서는 표시되지 않습니다::"

#~ msgid "Combining members of ``Flag``"
#~ msgstr "``Flag`` 멤버를 결합하기"

#~ msgid ""
#~ "If a combination of Flag members "
#~ "is not named, the :func:`repr` will "
#~ "include all named flags and all "
#~ "named combinations of flags that are "
#~ "in the value::"
#~ msgstr ""
#~ "Flag 멤버 조합의 이름이 지정되지 않으면, "
#~ ":func:`repr`\\은 모든 이름 지정된 플래그와 값에 "
#~ "있는 플래그의 모든 이름 지정된 조합을 포함합니다::"

