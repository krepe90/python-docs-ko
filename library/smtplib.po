# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/smtplib.rst:2
#, fuzzy
msgid ":mod:`!smtplib` --- SMTP protocol client"
msgstr ":mod:`smtplib` --- SMTP 프로토콜 클라이언트"

#: ../../library/smtplib.rst:9
msgid "**Source code:** :source:`Lib/smtplib.py`"
msgstr "**소스 코드:** :source:`Lib/smtplib.py`"

#: ../../library/smtplib.rst:17
#, fuzzy
msgid ""
"The :mod:`smtplib` module defines an SMTP client session object that can "
"be used to send mail to any internet machine with an SMTP or ESMTP "
"listener daemon.  For details of SMTP and ESMTP operation, consult "
":rfc:`821` (Simple Mail Transfer Protocol) and :rfc:`1869` (SMTP Service "
"Extensions)."
msgstr ""
":mod:`smtplib` 모듈은 SMTP나 ESMTP 리스너 데몬을 사용하여 모든 인터넷 기계로 메일을 보내는 데 사용할 수 있는"
" SMTP 클라이언트 세션 객체를 정의합니다. SMTP와 ESMTP 연산에 대한 자세한 내용은 :rfc:`821`\\(Simple "
"Mail Transfer Protocol)과 :rfc:`1869`\\(SMTP Service Extensions)를 참조하십시오."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/smtplib.rst:26
#, fuzzy
msgid ""
"An :class:`SMTP` instance encapsulates an SMTP connection.  It has "
"methods that support a full repertoire of SMTP and ESMTP operations. If "
"the optional *host* and *port* parameters are given, the SMTP "
":meth:`connect` method is called with those parameters during "
"initialization.  If specified, *local_hostname* is used as the FQDN of "
"the local host in the HELO/EHLO command.  Otherwise, the local hostname "
"is found using :func:`socket.getfqdn`.  If the :meth:`connect` call "
"returns anything other than a success code, an :exc:`SMTPConnectError` is"
" raised. The optional *timeout* parameter specifies a timeout in seconds "
"for blocking operations like the connection attempt (if not specified, "
"the global default timeout setting will be used).  If the timeout "
"expires, :exc:`TimeoutError` is raised.  The optional *source_address* "
"parameter allows binding to some specific source address in a machine "
"with multiple network interfaces, and/or to some specific source TCP "
"port. It takes a 2-tuple ``(host, port)``, for the socket to bind to as "
"its source address before connecting. If omitted (or if *host* or *port* "
"are ``''`` and/or ``0`` respectively) the OS default behavior will be "
"used."
msgstr ""
":class:`SMTP` 인스턴스는 SMTP 연결을 캡슐화합니다. SMTP와 ESMTP 연산의 전체 레퍼토리를 지원하는 메서드가 "
"있습니다. 선택적 호스트와 포트 매개 변수가 제공되면, 초기화 중에 해당 매개 변수로 SMTP :meth:`connect` 메서드가"
" 호출됩니다. 지정되면, HELO/EHLO 명령에서 *local_hostname*\\이 로컬 호스트의 FQDN으로 사용됩니다. "
"그렇지 않으면 :func:`socket.getfqdn`\\을 사용하여 로컬 호스트 이름을 찾습니다. :meth:`connect` "
"호출이 성공 코드 이외의 것을 반환하면 :exc:`SMTPConnectError`\\가 발생합니다. 선택적 *timeout* 매개 "
"변수는 연결 시도와 같은 블로킹 연산을 위한 시간제한을 초로 지정합니다 (지정하지 않으면, 전역 기본 시간제한 설정이 사용됩니다)."
" 시간제한이 만료되면 :exc:`socket.timeout`\\이 발생합니다. 선택적 source_address 매개 변수는 여러 "
"네트워크 인터페이스가 있는 기계의 특정 소스 주소 그리고/또는 특정 소스 TCP 포트에 바인딩 할 수 있도록 합니다. 연결 전에 "
"소켓이 소스 주소로 바인드 할 2-튜플 (host, port)를 취합니다. 생략되면 (또는 호스트나 포트가 각각 ``''`` "
"및/또는 0이면) OS 기본 동작이 사용됩니다."

#: ../../library/smtplib.rst:44
msgid ""
"For normal use, you should only require the initialization/connect, "
":meth:`sendmail`, and :meth:`SMTP.quit` methods. An example is included "
"below."
msgstr ""
"일반적인 사용을 위해서는, 초기화/연결, :meth:`sendmail` 및 :meth:`SMTP.quit` 메서드 만 필요합니다. "
"아래에 예가 포함되어 있습니다."

#: ../../library/smtplib.rst:48
msgid ""
"The :class:`SMTP` class supports the :keyword:`with` statement.  When "
"used like this, the SMTP ``QUIT`` command is issued automatically when "
"the :keyword:`!with` statement exits.  E.g.::"
msgstr ""
":class:`SMTP` 클래스는 :keyword:`with` 문을 지원합니다. 이처럼 사용되면, :keyword:`!with` "
"문이 종료될 때 SMTP ``QUIT`` 명령이 자동으로 발행됩니다. 예를 들어::"

#: ../../library/smtplib.rst:52
msgid ""
">>> from smtplib import SMTP\n"
">>> with SMTP(\"domain.org\") as smtp:\n"
"...     smtp.noop()\n"
"...\n"
"(250, b'Ok')\n"
">>>"
msgstr ""

#: ../../library/smtplib.rst:59 ../../library/smtplib.rst:61
msgid ""
"All commands will raise an :ref:`auditing event <auditing>` "
"``smtplib.SMTP.send`` with arguments ``self`` and ``data``, where "
"``data`` is the bytes about to be sent to the remote host."
msgstr ""
"모든 명령은 인자 ``self``\\와 ``data``\\로 :ref:`감사 이벤트 <auditing>` "
"``smtplib.SMTP.send``\\를 발생시킵니다. 여기서 ``data``\\는 원격 호스트로 전송될 바이트열입니다."

#: ../../library/smtplib.rst:65
msgid "Support for the :keyword:`with` statement was added."
msgstr ":keyword:`with` 문에 대한 지원이 추가되었습니다."

#: ../../library/smtplib.rst:68
#, fuzzy
msgid "*source_address* argument was added."
msgstr "source_address 인자가 추가되었습니다."

#: ../../library/smtplib.rst:71
msgid "The SMTPUTF8 extension (:rfc:`6531`) is now supported."
msgstr "SMTPUTF8 확장(:rfc:`6531`)이 이제 지원됩니다."

#: ../../library/smtplib.rst:74
#, fuzzy
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a "
":class:`ValueError` to prevent the creation of a non-blocking socket."
msgstr ""
"*timeout* 매개 변수가 0으로 설정되면, 비 블로킹 소켓을 만드는 것을 막기 위해 :class:`ValueError`\\가 "
"발생합니다."

#: ../../library/smtplib.rst:81
msgid ""
"An :class:`SMTP_SSL` instance behaves exactly the same as instances of "
":class:`SMTP`. :class:`SMTP_SSL` should be used for situations where SSL "
"is required from the beginning of the connection and using "
":meth:`starttls` is not appropriate. If *host* is not specified, the "
"local host is used. If *port* is zero, the standard SMTP-over-SSL port "
"(465) is used.  The optional arguments *local_hostname*, *timeout* and "
"*source_address* have the same meaning as they do in the :class:`SMTP` "
"class.  *context*, also optional, can contain a :class:`~ssl.SSLContext` "
"and allows configuring various aspects of the secure connection.  Please "
"read :ref:`ssl-security` for best practices."
msgstr ""
":class:`SMTP_SSL` 인스턴스는 :class:`SMTP` 인스턴스와 정확히 같게 작동합니다. 연결 시작 시 SSL이 "
"필요하고 :meth:`starttls` 사용이 적합하지 않은 상황에서는 :class:`SMTP_SSL`\\을 사용해야 합니다. "
"*host*\\를 지정하지 않으면, 로컬 호스트가 사용됩니다. *port*\\가 0이면, 표준 SMTP-over-SSL "
"포트(465)가 사용됩니다. 선택적 인자 *local_hostname*, *timeout* 및 *source_address*\\는 "
":class:`SMTP` 클래스에서와 같은 의미입니다. 역시 선택적인 *context*\\는 "
":class:`~ssl.SSLContext`\\를 포함할 수 있으며 보안 연결의 다양한 측면을 구성하도록 합니다. 모범 사례는 "
":ref:`ssl-security`\\을 읽으십시오."

#: ../../library/smtplib.rst:92 ../../library/smtplib.rst:415
msgid "*context* was added."
msgstr "*context*\\가 추가되었습니다."

#: ../../library/smtplib.rst:95
#, fuzzy
msgid "The *source_address* argument was added."
msgstr "source_address 인자가 추가되었습니다."

#: ../../library/smtplib.rst:98
#, fuzzy
msgid ""
"The class now supports hostname check with "
":attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see "
":const:`ssl.HAS_SNI`)."
msgstr ""
"이 클래스는 이제 :attr:`ssl.SSLContext.check_hostname`\\과 *서버 이름 표시(Server Name "
"Indication)*\\로 호스트 이름 확인을 지원합니다 (:data:`ssl.HAS_SNI`\\를 참조하십시오)."

#: ../../library/smtplib.rst:103
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a "
":class:`ValueError` to prevent the creation of a non-blocking socket"
msgstr ""
"*timeout* 매개 변수가 0으로 설정되면, 비 블로킹 소켓을 만드는 것을 막기 위해 :class:`ValueError`\\가 "
"발생합니다."

#: ../../library/smtplib.rst:107 ../../library/smtplib.rst:403
msgid "The deprecated *keyfile* and *certfile* parameters have been removed."
msgstr ""

#: ../../library/smtplib.rst:113
#, fuzzy
msgid ""
"The LMTP protocol, which is very similar to ESMTP, is heavily based on "
"the standard SMTP client. It's common to use Unix sockets for LMTP, so "
"our :meth:`connect` method must support that as well as a regular "
"host:port server. The optional arguments *local_hostname* and "
"*source_address* have the same meaning as they do in the :class:`SMTP` "
"class. To specify a Unix socket, you must use an absolute path for "
"*host*, starting with a '/'."
msgstr ""
"ESMTP와 매우 유사한 LMTP 프로토콜은 표준 SMTP 클라이언트를 기반으로 합니다. LMTP에 유닉스 소켓을 사용하는 것이 "
"일반적이라서, :meth:`connect` 메서드는 일반 host:port 서버뿐만 아니라 이를 지원해야 합니다. 선택적 인자 "
"local_hostname과 source_address는 :class:`SMTP` 클래스에서와 같은 의미입니다. 유닉스 소켓을 "
"지정하려면, *host*\\에 '/'로 시작하는 절대 경로를 사용해야 합니다."

#: ../../library/smtplib.rst:120
msgid ""
"Authentication is supported, using the regular SMTP mechanism. When using"
" a Unix socket, LMTP generally don't support or require any "
"authentication, but your mileage might vary."
msgstr ""
"일반 SMTP 메커니즘을 사용하여 인증이 지원됩니다. 유닉스 소켓을 사용할 때, LMTP는 일반적으로 인증을 지원하지 않거나 "
"요구하지 않지만, 여러분의 상황에서는 다를 수 있습니다."

#: ../../library/smtplib.rst:124
msgid "The optional *timeout* parameter was added."
msgstr "선택적 *timeout* 매개 변수가 추가되었습니다."

#: ../../library/smtplib.rst:128
msgid "A nice selection of exceptions is defined as well:"
msgstr "훌륭한 예외 모음도 정의되어 있습니다:"

#: ../../library/smtplib.rst:133
msgid ""
"Subclass of :exc:`OSError` that is the base exception class for all the "
"other exceptions provided by this module."
msgstr "이 모듈에서 제공하는 다른 모든 예외에 대한 베이스 예외 클래스인 :exc:`OSError`\\의 서브 클래스."

#: ../../library/smtplib.rst:136
msgid "SMTPException became subclass of :exc:`OSError`"
msgstr "SMTPException이 :exc:`OSError`\\의 서브 클래스가 되었습니다."

#: ../../library/smtplib.rst:142
msgid ""
"This exception is raised when the server unexpectedly disconnects, or "
"when an attempt is made to use the :class:`SMTP` instance before "
"connecting it to a server."
msgstr ""
"이 예외는 예기치 않게 서버와의 연결이 끊어지거나, 서버에 연결하기 전에 :class:`SMTP` 인스턴스를 사용하려고 할 때 "
"발생합니다."

#: ../../library/smtplib.rst:149
msgid ""
"Base class for all exceptions that include an SMTP error code. These "
"exceptions are generated in some instances when the SMTP server returns "
"an error code.  The error code is stored in the :attr:`smtp_code` "
"attribute of the error, and the :attr:`smtp_error` attribute is set to "
"the error message."
msgstr ""
"SMTP 에러 코드가 포함된 모든 예외의 베이스 클래스. 이러한 예외는 SMTP 서버가 에러 코드를 반환하는 일부 경우에 "
"생성됩니다. 에러 코드는 에러의 :attr:`smtp_code` 어트리뷰트에 저장되며, :attr:`smtp_error` "
"어트리뷰트는 에러 메시지로 설정됩니다."

#: ../../library/smtplib.rst:157
msgid ""
"Sender address refused.  In addition to the attributes set by on all "
":exc:`SMTPResponseException` exceptions, this sets 'sender' to the string"
" that the SMTP server refused."
msgstr ""
"발신자 주소가 거부되었습니다. 모든 :exc:`SMTPResponseException` 예외에 의해 설정된 어트리뷰트 외에도, "
"이것은 'sender'를 SMTP 서버가 거부한 문자열로 설정합니다."

#: ../../library/smtplib.rst:164
msgid ""
"All recipient addresses refused.  The errors for each recipient are "
"accessible through the attribute :attr:`recipients`, which is a "
"dictionary of exactly the same sort as :meth:`SMTP.sendmail` returns."
msgstr ""
"모든 수신자 주소가 거부되었습니다. 각 수신자의 에러는 :meth:`SMTP.sendmail`\\이 반환하는 것과 정확히 같은 "
"종류의 딕셔너리인 :attr:`recipients` 어트리뷰트를 통해 액세스 할 수 있습니다."

#: ../../library/smtplib.rst:171
msgid "The SMTP server refused to accept the message data."
msgstr "SMTP 서버가 메시지 데이터 수락을 거부했습니다."

#: ../../library/smtplib.rst:176
msgid "Error occurred during establishment of a connection  with the server."
msgstr "서버와의 연결을 설정하는 동안 에러가 발생했습니다."

#: ../../library/smtplib.rst:181
msgid "The server refused our ``HELO`` message."
msgstr "서버가 ``HELO`` 메시지를 거부했습니다."

#: ../../library/smtplib.rst:186
msgid "The command or option attempted is not supported by the server."
msgstr "시도한 명령이나 옵션이 서버에서 지원되지 않습니다."

#: ../../library/smtplib.rst:193
msgid ""
"SMTP authentication went wrong.  Most probably the server didn't accept "
"the username/password combination provided."
msgstr "SMTP 인증이 잘못되었습니다. 서버가 제공된 username/password 조합을 수락하지 않았을 가능성이 높습니다."

#: ../../library/smtplib.rst:199
msgid ":rfc:`821` - Simple Mail Transfer Protocol"
msgstr ":rfc:`821` - Simple Mail Transfer Protocol"

#: ../../library/smtplib.rst:200
msgid ""
"Protocol definition for SMTP.  This document covers the model, operating "
"procedure, and protocol details for SMTP."
msgstr "SMTP의 프로토콜 정의. 이 문서는 SMTP의 모델, 운영 절차 및 프로토콜 세부 사항을 다룹니다."

#: ../../library/smtplib.rst:203
msgid ":rfc:`1869` - SMTP Service Extensions"
msgstr ":rfc:`1869` - SMTP Service Extensions"

#: ../../library/smtplib.rst:204
msgid ""
"Definition of the ESMTP extensions for SMTP.  This describes a framework "
"for extending SMTP with new commands, supporting dynamic discovery of the"
" commands provided by the server, and defines a few additional commands."
msgstr ""
"SMTP를 위한 ESMTP 확장의 정의. 이 문서는 새로운 명령으로 SMTP를 확장하고 서버에서 제공하는 명령의 동적 발견을 "
"지원하는 프레임워크에 관해 설명하고, 몇 가지 추가 명령을 정의합니다."

#: ../../library/smtplib.rst:212
msgid "SMTP Objects"
msgstr "SMTP 객체"

#: ../../library/smtplib.rst:214
msgid "An :class:`SMTP` instance has the following methods:"
msgstr ":class:`SMTP` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/smtplib.rst:219
msgid ""
"Set the debug output level.  A value of 1 or ``True`` for *level* results"
" in debug messages for connection and for all messages sent to and "
"received from the server.  A value of 2 for *level* results in these "
"messages being timestamped."
msgstr ""
"디버그 출력 수준을 설정합니다. *level*\\의 값이 1이나 ``True``\\이면 연결과 서버와 주고받는 모든 메시지에 대한 "
"디버그 메시지가 생성됩니다. *level*\\의 값이 2이면 이러한 메시지에 타임 스탬프가 추가됩니다."

#: ../../library/smtplib.rst:224
msgid "Added debuglevel 2."
msgstr "디버그 수준 2를 추가했습니다."

#: ../../library/smtplib.rst:229
msgid ""
"Send a command *cmd* to the server.  The optional argument *args* is "
"simply concatenated to the command, separated by a space."
msgstr "서버에 *cmd* 명령을 전송합니다. 선택적 인자 *args*\\는 단순히 공백으로 구분하여 명령에 이어붙입니다."

#: ../../library/smtplib.rst:232
msgid ""
"This returns a 2-tuple composed of a numeric response code and the actual"
" response line (multiline responses are joined into one long line.)"
msgstr "숫자 응답 코드와 실제 응답 줄로 구성된 2-튜플을 반환합니다 (여러 줄 응답은 하나의 긴 줄로 결합합니다)."

#: ../../library/smtplib.rst:235
msgid ""
"In normal operation it should not be necessary to call this method "
"explicitly. It is used to implement other methods and may be useful for "
"testing private extensions."
msgstr ""
"일반적인 작업에서 이 메서드를 명시적으로 호출할 필요는 없습니다. 다른 메서드를 구현하는 데 사용되며 개인적인 확장을 테스트하는 데"
" 유용할 수 있습니다."

#: ../../library/smtplib.rst:239
msgid ""
"If the connection to the server is lost while waiting for the reply, "
":exc:`SMTPServerDisconnected` will be raised."
msgstr "응답을 기다리는 동안 서버와의 연결이 끊어지면, :exc:`SMTPServerDisconnected` 가 발생합니다."

#: ../../library/smtplib.rst:245
msgid ""
"Connect to a host on a given port.  The defaults are to connect to the "
"local host at the standard SMTP port (25). If the hostname ends with a "
"colon (``':'``) followed by a number, that suffix will be stripped off "
"and the number interpreted as the port number to use. This method is "
"automatically invoked by the constructor if a host is specified during "
"instantiation.  Returns a 2-tuple of the response code and message sent "
"by the server in its connection response."
msgstr ""
"지정된 포트(port)의 호스트(host)에 연결합니다. 기본값은 표준 SMTP 포트(25)로 로컬 호스트에 연결하는 것입니다. "
"호스트 이름이 콜론(``':'``)으로 끝나고 그 뒤에 숫자가 오면 해당 접미사가 제거되고 숫자는 사용할 포트 번호로 해석됩니다. "
"이 메서드는 인스턴스 화 중에 호스트가 지정되면 생성자에 의해 자동으로 호출됩니다. 연결 응답에서 서버가 보낸 응답 코드와 메시지의"
" 2-튜플을 반환합니다."

#: ../../library/smtplib.rst:253
msgid ""
"Raises an :ref:`auditing event <auditing>` ``smtplib.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"인자 ``self``, ``host``, ``port``\\로 :ref:`감사 이벤트 <auditing>` "
"``smtplib.connect``\\를 발생시킵니다."

#: ../../library/smtplib.rst:258
msgid ""
"Identify yourself to the SMTP server using ``HELO``.  The hostname "
"argument defaults to the fully qualified domain name of the local host. "
"The message returned by the server is stored as the :attr:`helo_resp` "
"attribute of the object."
msgstr ""
"``HELO`` 를 사용하여 SMTP 서버에 자신을 식별합니다. hostname 인자의 기본값은 로컬 호스트의 완전히 정규화된 "
"도메인 이름(fully qualified domain name)입니다. 서버가 반환한 메시지는 객체의 "
":attr:`helo_resp` 어트리뷰트로 저장됩니다."

#: ../../library/smtplib.rst:263
msgid ""
"In normal operation it should not be necessary to call this method "
"explicitly. It will be implicitly called by the :meth:`sendmail` when "
"necessary."
msgstr ""
"정상적인 작업에서는 이 메서드를 명시적으로 호출할 필요가 없습니다. 필요할 때 :meth:`sendmail`\\에 의해 묵시적으로 "
"호출됩니다."

#: ../../library/smtplib.rst:269
#, fuzzy
msgid ""
"Identify yourself to an ESMTP server using ``EHLO``.  The hostname "
"argument defaults to the fully qualified domain name of the local host.  "
"Examine the response for ESMTP option and store them for use by "
":meth:`has_extn`. Also sets several informational attributes: the message"
" returned by the server is stored as the :attr:`ehlo_resp` attribute, "
":attr:`does_esmtp` is set to ``True`` or ``False`` depending on whether "
"the server supports ESMTP, and :attr:`esmtp_features` will be a "
"dictionary containing the names of the SMTP service extensions this "
"server supports, and their parameters (if any)."
msgstr ""
"``EHLO``\\를 사용하여 ESMTP 서버에 자신을 식별합니다. hostname 인자의 기본값은 로컬 호스트의 완전히 정규화된 "
"도메인 이름(fully qualified domain name)입니다. ESMTP 옵션에 대한 응답을 검사하고 "
":meth:`has_extn`\\에서 사용할 수 있도록 저장합니다. 또한 여러 정보 어트리뷰트를 설정합니다: 서버가 반환한 메시지는"
" :attr:`ehlo_resp` 어트리뷰트로 저장되고, 서버가 ESMTP를 지원하는지에 따라 "
":attr:`does_esmtp`\\가 참이나 거짓으로 설정되며, :attr:`esmtp_features`\\는 이 서버가 지원하는"
" SMTP 서비스 확장의 이름과 그 매개 변수(있다면)를 포함하는 딕셔너리가 됩니다."

#: ../../library/smtplib.rst:279
msgid ""
"Unless you wish to use :meth:`has_extn` before sending mail, it should "
"not be necessary to call this method explicitly.  It will be implicitly "
"called by :meth:`sendmail` when necessary."
msgstr ""
"메일을 보내기 전에 :meth:`has_extn`\\을 사용하고 싶지 않은 한, 이 메서드를 명시적으로 호출할 필요는 없습니다. "
"필요할 때 :meth:`sendmail`\\에 의해 묵시적으로 호출됩니다."

#: ../../library/smtplib.rst:285
msgid ""
"This method calls :meth:`ehlo` and/or :meth:`helo` if there has been no "
"previous ``EHLO`` or ``HELO`` command this session.  It tries ESMTP "
"``EHLO`` first."
msgstr ""
"이 세션에서 앞선 ``EHLO``\\나 ``HELO`` 명령이 없으면, 이 메서드는 :meth:`ehlo` 및/또는 "
":meth:`helo`\\를 호출합니다. ESMTP ``EHLO``\\를 먼저 시도합니다."

#: ../../library/smtplib.rst:289 ../../library/smtplib.rst:318
#: ../../library/smtplib.rst:406 ../../library/smtplib.rst:475
msgid ":exc:`SMTPHeloError`"
msgstr ":exc:`SMTPHeloError`"

#: ../../library/smtplib.rst:290 ../../library/smtplib.rst:319
#: ../../library/smtplib.rst:407 ../../library/smtplib.rst:476
msgid "The server didn't reply properly to the ``HELO`` greeting."
msgstr "서버가 ``HELO`` 인사에 올바르게 응답하지 않았습니다."

#: ../../library/smtplib.rst:294
msgid ""
"Return :const:`True` if *name* is in the set of SMTP service extensions "
"returned by the server, :const:`False` otherwise. Case is ignored."
msgstr ""
"*name*\\이 서버가 반환한 SMTP 서비스 확장 집합에 있으면 :const:`True`\\를 반환하고, 그렇지 않으면 "
":const:`False`\\를 반환합니다. 대소 문자는 무시됩니다."

#: ../../library/smtplib.rst:300
msgid ""
"Check the validity of an address on this server using SMTP ``VRFY``. "
"Returns a tuple consisting of code 250 and a full :rfc:`822` address "
"(including human name) if the user address is valid. Otherwise returns an"
" SMTP error code of 400 or greater and an error string."
msgstr ""
"SMTP ``VRFY``\\를 사용하여 이 서버에서 주소의 유효성을 확인합니다. 사용자 주소가 유효하면 코드 250과 전체 "
":rfc:`822` 주소(사람 이름 포함)로 구성된 튜플을 반환합니다. 그렇지 않으면 400 이상의 SMTP 에러 코드와 에러 "
"문자열을 반환합니다."

#: ../../library/smtplib.rst:307
msgid "Many sites disable SMTP ``VRFY`` in order to foil spammers."
msgstr "많은 사이트에서 스패머를 제거하기 위해 SMTP ``VRFY``\\를 비활성화합니다."

#: ../../library/smtplib.rst:312
msgid ""
"Log in on an SMTP server that requires authentication. The arguments are "
"the username and the password to authenticate with. If there has been no "
"previous ``EHLO`` or ``HELO`` command this session, this method tries "
"ESMTP ``EHLO`` first. This method will return normally if the "
"authentication was successful, or may raise the following exceptions:"
msgstr ""
"인증이 필요한 SMTP 서버에 로그인합니다. 인자는 인증할 사용자 이름과 비밀번호입니다. 이 세션에 앞선 ``EHLO``\\나 "
"``HELO`` 명령이 없었으면, 이 메서드는 ESMTP ``EHLO``\\를 먼저 시도합니다. 인증에 성공하면 이 메서드는 "
"정상적으로 반환하고, 그렇지 않으면 다음 예외를 발생시킬 수 있습니다:"

#: ../../library/smtplib.rst:321
msgid ":exc:`SMTPAuthenticationError`"
msgstr ":exc:`SMTPAuthenticationError`"

#: ../../library/smtplib.rst:322
msgid "The server didn't accept the username/password combination."
msgstr "서버가 사용자 이름/비밀번호 조합을 수락하지 않았습니다."

#: ../../library/smtplib.rst:324 ../../library/smtplib.rst:409
#: ../../library/smtplib.rst:485
msgid ":exc:`SMTPNotSupportedError`"
msgstr ":exc:`SMTPNotSupportedError`"

#: ../../library/smtplib.rst:325
msgid "The ``AUTH`` command is not supported by the server."
msgstr "서버가 ``AUTH`` 명령을 지원하지 않습니다."

#: ../../library/smtplib.rst:327
msgid ":exc:`SMTPException`"
msgstr ":exc:`SMTPException`"

#: ../../library/smtplib.rst:328
msgid "No suitable authentication method was found."
msgstr "적합한 인증 메서드가 없습니다."

#: ../../library/smtplib.rst:330
msgid ""
"Each of the authentication methods supported by :mod:`smtplib` are tried "
"in turn if they are advertised as supported by the server.  See "
":meth:`auth` for a list of supported authentication methods.  "
"*initial_response_ok* is passed through to :meth:`auth`."
msgstr ""
":mod:`smtplib`\\가 지원하는 각 인증 메서드는 서버가 지원하는 것으로 광고되면 차례로 시도됩니다. 지원되는 인증 메서드"
" 목록은 :meth:`auth`\\를 참조하십시오. *initial_response_ok*\\는 :meth:`auth`\\로 "
"전달됩니다."

#: ../../library/smtplib.rst:335
msgid ""
"Optional keyword argument *initial_response_ok* specifies whether, for "
"authentication methods that support it, an \"initial response\" as "
"specified in :rfc:`4954` can be sent along with the ``AUTH`` command, "
"rather than requiring a challenge/response."
msgstr ""
"선택적 키워드 인자 *initial_response_ok*\\는, 이를 지원하는 인증 메서드의 경우, 챌린지/응답을 요구하지 않고 "
":rfc:`4954`\\에 지정된 \"초기 응답(initial response)\"을 ``AUTH`` 명령과 함께 보낼 수 있는지를"
" 지정합니다."

#: ../../library/smtplib.rst:340
msgid ""
":exc:`SMTPNotSupportedError` may be raised, and the *initial_response_ok*"
" parameter was added."
msgstr ""
":exc:`SMTPNotSupportedError` 가 발생할 수 있고, *initial_response_ok* 매개 변수가 "
"추가되었습니다."

#: ../../library/smtplib.rst:347
msgid ""
"Issue an ``SMTP`` ``AUTH`` command for the specified authentication "
"*mechanism*, and handle the challenge response via *authobject*."
msgstr ""
"지정된 인증 *메커니즘(mechanism)*\\으로 ``SMTP`` ``AUTH`` 명령을 발행하고, *authobject*\\를 "
"통해 챌린지 응답을 처리합니다."

#: ../../library/smtplib.rst:350
msgid ""
"*mechanism* specifies which authentication mechanism is to be used as "
"argument to the ``AUTH`` command; the valid values are those listed in "
"the ``auth`` element of :attr:`esmtp_features`."
msgstr ""
"*mechanism*\\은 ``AUTH`` 명령의 인자로 사용할 인증 메커니즘을 지정합니다; 유효한 값은 "
":attr:`esmtp_features`\\의 ``auth`` 요소에 나열된 값입니다."

#: ../../library/smtplib.rst:354
#, fuzzy
msgid ""
"*authobject* must be a callable object taking an optional single "
"argument::"
msgstr "*authobject*\\는 선택적 단일 인자를 취하는 콜러블 객체여야 합니다:"

#: ../../library/smtplib.rst:356
msgid "data = authobject(challenge=None)"
msgstr "data = authobject(challenge=None)"

#: ../../library/smtplib.rst:358
msgid ""
"If optional keyword argument *initial_response_ok* is true, "
"``authobject()`` will be called first with no argument.  It can return "
"the :rfc:`4954` \"initial response\" ASCII ``str`` which will be encoded "
"and sent with the ``AUTH`` command as below.  If the ``authobject()`` "
"does not support an initial response (e.g. because it requires a "
"challenge), it should return ``None`` when called with "
"``challenge=None``.  If *initial_response_ok* is false, then "
"``authobject()`` will not be called first with ``None``."
msgstr ""
"선택적 키워드 인자 *initial_response_ok*\\가 참이면, 인자 없이 ``authobject()``\\가 먼저 "
"호출됩니다. 이것은 :rfc:`4954` \"초기 응답(initial response)\" ASCII ``str``\\을 반환할 수"
" 있으며, 이는 아래와 같이 ``AUTH`` 명령으로 인코딩되고 전송됩니다. ``authobject()``\\가 초기 응답을 "
"지원하지 않으면 (예를 들어 챌린지가 필요하기 때문에), ``challenge=None``\\으로 호출될 때 ``None``\\을 "
"반환해야 합니다. *initial_response_ok*\\가 거짓이면, ``authobject()``\\는 ``None``\\으로"
" 먼저 호출되지 않습니다."

#: ../../library/smtplib.rst:366
msgid ""
"If the initial response check returns ``None``, or if "
"*initial_response_ok* is false, ``authobject()`` will be called to "
"process the server's challenge response; the *challenge* argument it is "
"passed will be a ``bytes``.  It should return ASCII ``str`` *data* that "
"will be base64 encoded and sent to the server."
msgstr ""
"초기 응답 확인이 ``None``\\을 반환하거나, *initial_response_ok*\\가 거짓이면, 서버의 챌린지 응답을 "
"처리하기 위해 ``authobject()``\\가 호출됩니다; 전달된 *challenge* 인자는 ``bytes``\\입니다. "
"base64로 인코딩되어 서버로 전송될 ASCII ``str`` *data*\\를 반환해야 합니다."

#: ../../library/smtplib.rst:372
msgid ""
"The ``SMTP`` class provides ``authobjects`` for the ``CRAM-MD5``, "
"``PLAIN``, and ``LOGIN`` mechanisms; they are named "
"``SMTP.auth_cram_md5``, ``SMTP.auth_plain``, and ``SMTP.auth_login`` "
"respectively.  They all require that the ``user`` and ``password`` "
"properties of the ``SMTP`` instance are set to appropriate values."
msgstr ""
"``SMTP`` 클래스는 ``CRAM-MD5``, ``PLAIN`` 및 ``LOGIN`` 메커니즘을 위한 "
"``authobjects``\\를 제공합니다. 그것들은 각각 ``SMTP.auth_cram_md5``, "
"``SMTP.auth_plain`` 및 ``SMTP.auth_login``\\으로 명명됩니다. 모두 ``SMTP`` 인스턴스의 "
"``user``\\와 ``password`` 프로퍼티가 적절한 값으로 설정되어 있도록 요구합니다."

#: ../../library/smtplib.rst:378
msgid ""
"User code does not normally need to call ``auth`` directly, but can "
"instead call the :meth:`login` method, which will try each of the above "
"mechanisms in turn, in the order listed.  ``auth`` is exposed to "
"facilitate the implementation of authentication methods not (or not yet) "
"supported directly by :mod:`smtplib`."
msgstr ""
"사용자 코드는 일반적으로 ``auth``\\를 직접 호출할 필요는 없지만, 대신 :meth:`login` 메서드를 호출할 수는 "
"있는데, 위의 각 메커니즘을 나열된 순서대로 시도합니다. ``auth``\\는 :mod:`smtplib`\\가 직접 지원하지 않는 "
"(또는 아직 지원하지 않는) 인증 메서드를 쉽게 구현할 수 있도록 노출되어 있습니다."

#: ../../library/smtplib.rst:389
msgid ""
"Put the SMTP connection in TLS (Transport Layer Security) mode.  All SMTP"
" commands that follow will be encrypted.  You should then call "
":meth:`ehlo` again."
msgstr ""
"SMTP 연결을 TLS (Transport Layer Security) 모드로 전환합니다. 뒤따르는 모든 SMTP 명령은 "
"암호화됩니다. 그런 다음 :meth:`ehlo`\\를 다시 호출해야 합니다."

#: ../../library/smtplib.rst:393
msgid ""
"If *keyfile* and *certfile* are provided, they are used to create an "
":class:`ssl.SSLContext`."
msgstr "*keyfile*\\과 *certfile*\\이 제공되면, :class:`ssl.SSLContext`\\를 만드는 데 사용됩니다."

#: ../../library/smtplib.rst:396
msgid ""
"Optional *context* parameter is an :class:`ssl.SSLContext` object; This "
"is an alternative to using a keyfile and a certfile and if specified both"
" *keyfile* and *certfile* should be ``None``."
msgstr ""
"선택적 *context* 매개 변수는 :class:`ssl.SSLContext` 객체입니다; 이것은 keyfile과 "
"certfile대신 사용할 수 있으며 *keyfile*\\과 *certfile*\\이 모두 지정되면 ``None``\\이어야 "
"합니다."

#: ../../library/smtplib.rst:400
msgid ""
"If there has been no previous ``EHLO`` or ``HELO`` command this session, "
"this method tries ESMTP ``EHLO`` first."
msgstr "이 세션에 앞선 ``EHLO``\\나 ``HELO`` 명령이 없었으면, 이 메서드는 ESMTP ``EHLO``\\를 먼저 시도합니다."

#: ../../library/smtplib.rst:410
msgid "The server does not support the STARTTLS extension."
msgstr "서버가 STARTTLS 확장을 지원하지 않습니다."

#: ../../library/smtplib.rst:412
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../library/smtplib.rst:413
msgid "SSL/TLS support is not available to your Python interpreter."
msgstr "파이썬 인터프리터가 SSL/TLS를 지원하지 않습니다."

#: ../../library/smtplib.rst:418
#, fuzzy
msgid ""
"The method now supports hostname check with "
":attr:`SSLContext.check_hostname` and *Server Name Indicator* (see "
":const:`~ssl.HAS_SNI`)."
msgstr ""
"이 메서드는 이제 :attr:`SSLContext.check_hostname`\\과 *서버 이름 표시(Server Name "
"Indicator)*\\로 호스트 이름 확인을 지원합니다 (:data:`~ssl.HAS_SNI`\\를 참조하십시오)."

#: ../../library/smtplib.rst:423
msgid ""
"The error raised for lack of STARTTLS support is now the "
":exc:`SMTPNotSupportedError` subclass instead of the base "
":exc:`SMTPException`."
msgstr ""
"STARTTLS 지원 부족으로 발생한 에러는 이제 베이스 :exc:`SMTPException` 대신 "
":exc:`SMTPNotSupportedError` 서브 클래스입니다."

#: ../../library/smtplib.rst:431
msgid ""
"Send mail.  The required arguments are an :rfc:`822` from-address string,"
" a list of :rfc:`822` to-address strings (a bare string will be treated "
"as a list with 1 address), and a message string.  The caller may pass a "
"list of ESMTP options (such as ``8bitmime``) to be used in ``MAIL FROM`` "
"commands as *mail_options*. ESMTP options (such as ``DSN`` commands) that"
" should be used with all ``RCPT`` commands can be passed as "
"*rcpt_options*.  (If you need to use different ESMTP options to different"
" recipients you have to use the low-level methods such as :meth:`mail`, "
":meth:`rcpt` and :meth:`data` to send the message.)"
msgstr ""
"메일을 보냅니다. 필수 인자는 :rfc:`822` from-address 문자열, :rfc:`822` to-address 문자열의 "
"리스트 (단순 문자열은 주소가 한 개인 리스트로 처리됩니다) 및 메시지 문자열입니다. 호출자는 ``MAIL FROM`` 명령에 "
"사용되는 ESMTP 옵션 (가령 ``8bitmime``) 리스트를 *mail_options*\\로 전달할 수 있습니다. 모든 "
"``RCPT`` 명령과 함께 사용해야 하는 ESMTP 옵션(가령 ``DSN`` 명령)을 *rcpt_options*\\로 전달할 수 "
"있습니다. (다른 수신자에게 다른 ESMTP 옵션을 사용해야 하면 메시지를 보내는 데 :meth:`mail`, "
":meth:`rcpt` 및 :meth:`data`\\와 같은 저수준 메서드를 사용해야 합니다.)"

#: ../../library/smtplib.rst:442
msgid ""
"The *from_addr* and *to_addrs* parameters are used to construct the "
"message envelope used by the transport agents.  ``sendmail`` does not "
"modify the message headers in any way."
msgstr ""
"*from_addr*\\과 *to_addrs* 매개 변수는 전송 에이전트가 사용하는 메시지 봉투(envelope)를 구성하는 데 "
"사용됩니다. ``sendmail``\\은 어떤 방식으로든 메시지 헤더를 수정하지 않습니다."

#: ../../library/smtplib.rst:446
msgid ""
"*msg* may be a string containing characters in the ASCII range, or a byte"
" string.  A string is encoded to bytes using the ascii codec, and lone "
"``\\r`` and ``\\n`` characters are converted to ``\\r\\n`` characters.  A"
" byte string is not modified."
msgstr ""
"*msg*\\는 ASCII 범위의 문자를 포함하는 문자열이거나, 바이트 문자열일 수 있습니다. 문자열은 ascii 코덱을 사용하여 "
"바이트열로 인코딩되며, 독립된 ``\\r``\\과 ``\\n`` 문자는 ``\\r\\n`` 문자로 변환됩니다. 바이트 문자열은 "
"수정되지 않습니다."

#: ../../library/smtplib.rst:451
msgid ""
"If there has been no previous ``EHLO`` or ``HELO`` command this session, "
"this method tries ESMTP ``EHLO`` first. If the server does ESMTP, message"
" size and each of the specified options will be passed to it (if the "
"option is in the feature set the server advertises).  If ``EHLO`` fails, "
"``HELO`` will be tried and ESMTP options suppressed."
msgstr ""
"이 세션에 앞선 ``EHLO``\\나 ``HELO`` 명령이 없었으면, 이 메서드는 ESMTP ``EHLO``\\를 먼저 "
"시도합니다. 서버가 ESMTP를 지원하면, 메시지 크기와 지정된 각 옵션이 전달됩니다 (옵션이 서버가 광고한 기능 집합에 있다면)."
" ``EHLO``\\가 실패하면, ``HELO``\\가 시도되고 ESMTP 옵션이 억제됩니다."

#: ../../library/smtplib.rst:457
msgid ""
"This method will return normally if the mail is accepted for at least one"
" recipient. Otherwise it will raise an exception.  That is, if this "
"method does not raise an exception, then someone should get your mail. If"
" this method does not raise an exception, it returns a dictionary, with "
"one entry for each recipient that was refused.  Each entry contains a "
"tuple of the SMTP error code and the accompanying error message sent by "
"the server."
msgstr ""
"이 메서드는 적어도 한 명의 수신자에게 메일이 수락되면 정상적으로 반환됩니다. 그렇지 않으면 예외가 발생합니다. 즉, 이 메서드로 "
"예외가 발생하지 않으면 누군가 메일을 받아야 합니다. 이 메서드에서 예외가 발생하지 않으면, 거부된 각 수신자에 대해 하나의 항목이"
" 있는 딕셔너리를 반환합니다. 각 항목에는 서버에서 보낸 SMTP 에러 코드와 해당 에러 메시지의 튜플이 포함됩니다."

#: ../../library/smtplib.rst:464
msgid ""
"If ``SMTPUTF8`` is included in *mail_options*, and the server supports "
"it, *from_addr* and *to_addrs* may contain non-ASCII characters."
msgstr ""
"``SMTPUTF8``\\이 *mail_options*\\에 포함되어 있고, 서버가 이를 지원하면, *from_addr*\\과 "
"*to_addrs*\\는 ASCII가 아닌 문자를 포함할 수 있습니다."

#: ../../library/smtplib.rst:467
msgid "This method may raise the following exceptions:"
msgstr "이 메서드는 다음과 같은 예외를 발생시킬 수 있습니다:"

#: ../../library/smtplib.rst:469
msgid ":exc:`SMTPRecipientsRefused`"
msgstr ":exc:`SMTPRecipientsRefused`"

#: ../../library/smtplib.rst:470
msgid ""
"All recipients were refused.  Nobody got the mail.  The "
":attr:`recipients` attribute of the exception object is a dictionary with"
" information about the refused recipients (like the one returned when at "
"least one recipient was accepted)."
msgstr ""
"모든 수신자가 거부되었습니다. 아무도 메일을 받지 못했습니다. 예외 객체의 :attr:`recipients` 어트리뷰트는 거부된 "
"수신자에 대한 정보가 있는 딕셔너리입니다 (적어도 한 명의 수신자가 수락되었을 때 반환되는 것과 같습니다)."

#: ../../library/smtplib.rst:478
msgid ":exc:`SMTPSenderRefused`"
msgstr ":exc:`SMTPSenderRefused`"

#: ../../library/smtplib.rst:479
msgid "The server didn't accept the *from_addr*."
msgstr "서버가 *from_addr*\\을 수락하지 않았습니다."

#: ../../library/smtplib.rst:481
msgid ":exc:`SMTPDataError`"
msgstr ":exc:`SMTPDataError`"

#: ../../library/smtplib.rst:482
msgid ""
"The server replied with an unexpected error code (other than a refusal of"
" a recipient)."
msgstr "서버가 예기치 않은 에러 코드(수신자 거부는 제외하고)로 응답했습니다."

#: ../../library/smtplib.rst:486
msgid ""
"``SMTPUTF8`` was given in the *mail_options* but is not supported by the "
"server."
msgstr "``SMTPUTF8``\\이 *mail_options*\\에 제공되었지만, 서버에서 지원되지 않습니다."

#: ../../library/smtplib.rst:489
msgid ""
"Unless otherwise noted, the connection will be open even after an "
"exception is raised."
msgstr "달리 명시되지 않는 한, 예외가 발생한 후에도 연결은 열려있습니다."

#: ../../library/smtplib.rst:492
msgid "*msg* may be a byte string."
msgstr "*msg*\\는 바이트 문자열일 수 있습니다."

#: ../../library/smtplib.rst:495
msgid ""
"``SMTPUTF8`` support added, and :exc:`SMTPNotSupportedError` may be "
"raised if ``SMTPUTF8`` is specified but the server does not support it."
msgstr ""
"``SMTPUTF8`` 지원이 추가되었으며, ``SMTPUTF8``\\이 지정되었지만, 서버가 지원하지 않으면 "
":exc:`SMTPNotSupportedError` 가 발생할 수 있습니다."

#: ../../library/smtplib.rst:503
msgid ""
"This is a convenience method for calling :meth:`sendmail` with the "
"message represented by an :class:`email.message.Message` object.  The "
"arguments have the same meaning as for :meth:`sendmail`, except that "
"*msg* is a ``Message`` object."
msgstr ""
"이는 :class:`email.message.Message` 객체로 표현되는 메시지로 :meth:`sendmail`\\을 호출하는 "
"편의 메서드입니다. 인자는 *msg*\\가 ``Message`` 객체라는 점을 제외하고 :meth:`sendmail`\\과 같은 "
"의미입니다."

#: ../../library/smtplib.rst:508
msgid ""
"If *from_addr* is ``None`` or *to_addrs* is ``None``, ``send_message`` "
"fills those arguments with addresses extracted from the headers of *msg* "
"as specified in :rfc:`5322`\\: *from_addr* is set to the "
":mailheader:`Sender` field if it is present, and otherwise to the "
":mailheader:`From` field. *to_addrs* combines the values (if any) of the "
":mailheader:`To`, :mailheader:`Cc`, and :mailheader:`Bcc` fields from "
"*msg*.  If exactly one set of :mailheader:`Resent-*` headers appear in "
"the message, the regular headers are ignored and the "
":mailheader:`Resent-*` headers are used instead. If the message contains "
"more than one set of :mailheader:`Resent-*` headers, a :exc:`ValueError` "
"is raised, since there is no way to unambiguously detect the most recent "
"set of :mailheader:`Resent-` headers."
msgstr ""
"*from_addr*\\이 ``None``\\이거나 *to_addrs*\\가 ``None``\\이면, "
"``send_message``\\는 :rfc:`5322` \\에 지정된 대로 *msg*\\의 헤더에서 추출된 주소로 해당 인자를 "
"채웁니다: *from_addr*\\은 :mailheader:`Sender` 필드가 있으면 이것으로 설정되고, 그렇지 않으면 "
":mailheader:`From` 필드로 설정됩니다. *to_addrs*\\는 (있다면) *msg*\\의 "
":mailheader:`To`, :mailheader:`Cc` 및 :mailheader:`Bcc` 필드 값을 결합합니다. 정확히 "
"하나의 :mailheader:`Resent-*` 헤더 집합이 메시지에 등장하면, 일반 헤더는 무시되고 "
":mailheader:`Resent-*` 헤더가 대신 사용됩니다. 메시지에 둘 이상의 :mailheader:`Resent-*` 헤더"
" 집합이 포함되면, 가장 최근의 :mailheader:`Resent-` 헤더 집합을 모호하지 않게 감지할 방법이 없어서 "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/smtplib.rst:520
#, fuzzy
msgid ""
"``send_message`` serializes *msg* using "
":class:`~email.generator.BytesGenerator` with ``\\r\\n`` as the "
"*linesep*, and calls :meth:`sendmail` to transmit the resulting message."
"  Regardless of the values of *from_addr* and *to_addrs*, "
"``send_message`` does not transmit any :mailheader:`Bcc` or :mailheader"
":`Resent-Bcc` headers that may appear in *msg*.  If any of the addresses "
"in *from_addr* and *to_addrs* contain non-ASCII characters and the server"
" does not advertise ``SMTPUTF8`` support, an :exc:`SMTPNotSupportedError`"
" is raised.  Otherwise the ``Message`` is serialized with a clone of its "
":mod:`~email.policy` with the :attr:`~email.policy.EmailPolicy.utf8` "
"attribute set to ``True``, and ``SMTPUTF8`` and ``BODY=8BITMIME`` are "
"added to *mail_options*."
msgstr ""
"``send_message``\\는 ``\\r\\n``\\을 *linesep*\\으로 사용하여 "
":class:`~email.generator.BytesGenerator`\\를 통해 *msg*\\를 직렬화하고, "
":meth:`sendmail`\\을 호출하여 결과 메시지를 전송합니다. *from_addr*\\과 *to_addrs*\\의 값과 "
"관계없이 ``send_message``\\는 *msg*\\에 나타날 수 있는 :mailheader:`Bcc`\\나 "
":mailheader:`Resent-Bcc` 헤더를 전송하지 않습니다. *from_addr*\\과 *to_addrs*\\의 주소 중"
" 하나에 ASCII가 아닌 문자가 포함되어 있고 서버가 ``SMTPUTF8`` 지원을 광고하지 않으면, "
":exc:`SMTPNotSupported` 에러가 발생합니다. 그렇지 않으면 ``Message``\\는 "
":attr:`~email.policy.EmailPolicy.utf8` 어트리뷰트가 ``True``\\로 설정된 자신의 "
":mod:`~email.policy`\\의 복제본으로 직렬화되고, ``SMTPUTF8`` \\과 "
"``BODY=8BITMIME``\\이 *mail_options*\\에 추가됩니다."

#: ../../library/smtplib.rst:534
msgid "Support for internationalized addresses (``SMTPUTF8``)."
msgstr "국제화된 주소 (``SMTPUTF8``) 지원."

#: ../../library/smtplib.rst:540
msgid ""
"Terminate the SMTP session and close the connection.  Return the result "
"of the SMTP ``QUIT`` command."
msgstr "SMTP 세션을 종료하고 연결을 닫습니다. SMTP ``QUIT`` 명령의 결과를 반환합니다."

#: ../../library/smtplib.rst:544
msgid ""
"Low-level methods corresponding to the standard SMTP/ESMTP commands "
"``HELP``, ``RSET``, ``NOOP``, ``MAIL``, ``RCPT``, and ``DATA`` are also "
"supported. Normally these do not need to be called directly, so they are "
"not documented here.  For details, consult the module code."
msgstr ""
"표준 SMTP/ESMTP 명령 ``HELP``, ``RSET``, ``NOOP``, ``MAIL``, ``RCPT`` 및 "
"``DATA``\\에 해당하는 저수준 메서드도 지원됩니다. 일반적으로 이들은 직접 호출할 필요가 없어서, 여기에 설명되어 있지 "
"않습니다. 자세한 내용은, 모듈 코드를 참조하십시오."

#: ../../library/smtplib.rst:553
msgid "SMTP Example"
msgstr "SMTP 예"

#: ../../library/smtplib.rst:555
#, fuzzy
msgid ""
"This example prompts the user for addresses needed in the message "
"envelope ('To' and 'From' addresses), and the message to be delivered.  "
"Note that the headers to be included with the message must be included in"
" the message as entered; this example doesn't do any processing of the "
":rfc:`822` headers.  In particular, the 'To' and 'From' addresses must be"
" included in the message headers explicitly::"
msgstr ""
"이 예에서는 메시지 봉투(envelope)에 필요한 주소('To'와 'From' 주소)와 전달할 메시지를 사용자에게 요구합니다. "
"메시지에 포함할 헤더는 입력한 대로 메시지에 포함됨에 유의하십시오; 이 예제는 :rfc:`822` 헤더를 처리하지 않습니다. 특히,"
" 'To'와 'From' 주소는 메시지 헤더에 명시적으로 포함되어야 합니다. ::"

#: ../../library/smtplib.rst:561
#, python-brace-format
msgid ""
"import smtplib\n"
"\n"
"def prompt(title):\n"
"    return input(title).strip()\n"
"\n"
"from_addr = prompt(\"From: \")\n"
"to_addrs  = prompt(\"To: \").split()\n"
"print(\"Enter message, end with ^D (Unix) or ^Z (Windows):\")\n"
"\n"
"# Add the From: and To: headers at the start!\n"
"lines = [f\"From: {from_addr}\", f\"To: {', '.join(to_addrs)}\", \"\"]\n"
"while True:\n"
"    try:\n"
"        line = input()\n"
"    except EOFError:\n"
"        break\n"
"    else:\n"
"        lines.append(line)\n"
"\n"
"msg = \"\\r\\n\".join(lines)\n"
"print(\"Message length is\", len(msg))\n"
"\n"
"server = smtplib.SMTP(\"localhost\")\n"
"server.set_debuglevel(1)\n"
"server.sendmail(from_addr, to_addrs, msg)\n"
"server.quit()"
msgstr ""

#: ../../library/smtplib.rst:590
msgid ""
"In general, you will want to use the :mod:`email` package's features to "
"construct an email message, which you can then send via "
":meth:`~smtplib.SMTP.send_message`; see :ref:`email-examples`."
msgstr ""
"일반적으로, :mod:`email` 패키지의 기능을 사용하여 전자 메일 메시지를 만들고자 할 것이고, 그런 다음 "
":meth:`~smtplib.SMTP.send_message`\\를 통해 보낼 수 있습니다; :ref:`email-"
"examples`\\를 참조하십시오."

#: ../../library/smtplib.rst:11
msgid "SMTP"
msgstr ""

#: ../../library/smtplib.rst:11
msgid "protocol"
msgstr ""

#: ../../library/smtplib.rst:11
#, fuzzy
msgid "Simple Mail Transfer Protocol"
msgstr ":rfc:`821` - Simple Mail Transfer Protocol"

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``smtplib.send`` with arguments ``self``, "
#~ "``data``."
#~ msgstr ""
#~ "인자 ``self``, ``data``\\로 :ref:`감사 이벤트 "
#~ "<auditing>` ``smtplib.send``\\를 발생시킵니다."

#~ msgid ""
#~ "*keyfile* and *certfile* are a legacy"
#~ " alternative to *context*, and can "
#~ "point to a PEM formatted private "
#~ "key and certificate chain file for "
#~ "the SSL connection."
#~ msgstr ""
#~ "*keyfile*\\과 *certfile*\\은 *context*\\의 레거시 "
#~ "대안이며, SSL 연결을 위한 PEM 형식 개인 "
#~ "키와 인증서 체인 파일을 가리킬 수 있습니다."

#~ msgid ""
#~ "*keyfile* and *certfile* are deprecated "
#~ "in favor of *context*. Please use "
#~ ":meth:`ssl.SSLContext.load_cert_chain` instead, or "
#~ "let :func:`ssl.create_default_context` select the"
#~ " system's trusted CA certificates for "
#~ "you."
#~ msgstr ""
#~ "*keyfile*\\과 *certfile*\\은 폐지되었고 *context*\\로 "
#~ "대체되었습니다. 대신 :meth:`ssl.SSLContext.load_cert_chain`\\을 "
#~ "사용하거나, :func:`ssl.create_default_context`\\가 시스템의 "
#~ "신뢰할 수 있는 CA 인증서를 선택하도록 하십시오."

