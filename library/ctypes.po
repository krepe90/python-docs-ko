# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/ctypes.rst:2
#, fuzzy
msgid ":mod:`!ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- 파이썬용 외부 함수 라이브러리"

#: ../../library/ctypes.rst:9
msgid "**Source code:** :source:`Lib/ctypes`"
msgstr ""

#: ../../library/ctypes.rst:13
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes`\\는 파이썬용 외부 함수(foreign function) 라이브러리입니다. C 호환 데이터형을 제공하며, "
"DLL 또는 공유 라이브러리에 있는 함수를 호출할 수 있습니다. 이 라이브러리들을 순수 파이썬으로 감싸는 데 사용할 수 있습니다."

#: ../../library/ctypes.rst:21
msgid "ctypes tutorial"
msgstr "ctypes 자습서"

#: ../../library/ctypes.rst:23
#, fuzzy
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure "
"that they actually work.  Since some code samples behave differently "
"under Linux, Windows, or macOS, they contain doctest directives in "
"comments."
msgstr ""
"참고: 이 자습서의 코드 예제는 :mod:`doctest`\\를 사용하여 실제로 작동하는지 확인합니다. 일부 코드 예제는 리눅스, "
"윈도우 또는 맥 OS X에서 다르게 동작하므로, 주석에 doctest 지시문이 포함되어 있습니다."

#: ../../library/ctypes.rst:27
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to "
":class:`c_long`. So, you should not be confused if :class:`c_long` is "
"printed if you would expect :class:`c_int` --- they are actually the same"
" type."
msgstr ""
"참고: 일부 코드 예제는 ctypes :class:`c_int` 형을 참조합니다. ``sizeof(long) == "
"sizeof(int)``\\인 플랫폼에서, 이는 :class:`c_long`\\의 별칭입니다. 따라서 "
":class:`c_int`\\를 기대할 때 :class:`c_long`\\가 인쇄되더라도 혼란스러워하지 않아도 됩니다 --- "
"이것들은 실제로 같은 형입니다."

#: ../../library/ctypes.rst:35
msgid "Loading dynamic link libraries"
msgstr "동적 링크 라이브러리 로드하기"

#: ../../library/ctypes.rst:37
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes`\\는 동적 링크 라이브러리 로드를 위해 *cdll*\\을, 그리고 윈도우에서는 *windll* 및 "
"*oledll* 객체를, 노출합니다."

#: ../../library/ctypes.rst:40
#, fuzzy
msgid ""
"You load libraries by accessing them as attributes of these objects. "
"*cdll* loads libraries which export functions using the standard "
"``cdecl`` calling convention, while *windll* libraries call functions "
"using the ``stdcall`` calling convention. *oledll* also uses the "
"``stdcall`` calling convention, and assumes the functions return a "
"Windows :c:type:`!HRESULT` error code. The error code is used to "
"automatically raise an :class:`OSError` exception when the function call "
"fails."
msgstr ""
"이 객체의 어트리뷰트를 액세스하여 라이브러리를 로드합니다. *cdll*\\은 표준 ``cdecl`` 호출 규칙을 사용하는 함수를 "
"내보내는 라이브러리를 로드하는 반면, *windll* 라이브러리는 ``stdcall`` 호출 규칙을 사용하여 함수를 호출합니다. "
"*oledll* 또한 ``stdcall`` 호출 규칙을 사용하고, 함수가 윈도우 :c:type:`HRESULT` 에러 코드를 "
"반환한다고 가정합니다. 에러 코드는 함수 호출이 실패할 때 :class:`OSError` 예외를 자동으로 발생시키는 데 사용됩니다."

#: ../../library/ctypes.rst:48
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias "
"of :exc:`OSError`."
msgstr "윈도우 에러는 :exc:`WindowsError`\\를 일으켜왔습니다. 이제는 :exc:`OSError`\\의 별칭입니다."

#: ../../library/ctypes.rst:53
#, fuzzy
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS "
"standard C library containing most standard C functions, and uses the "
"``cdecl`` calling convention::"
msgstr ""
"다음은 윈도우 용 예제입니다. ``msvcrt``\\는 대부분 표준 C 함수가 포함된 MS 표준 C 라이브러리며, cdecl 호출 "
"규칙을 사용합니다::"

#: ../../library/ctypes.rst:57
msgid ""
">>> from ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handle ... at ...>\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handle ... at ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:65
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "윈도우는 일반적인 ``.dll`` 파일 접미사를 자동으로 추가합니다."

#: ../../library/ctypes.rst:68
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one "
"being used by Python. Where possible, use native Python functionality, or"
" else import and use the ``msvcrt`` module."
msgstr ""
"``cdll.msvcrt``\\를 통해 표준 C 라이브러리에 액세스하면 파이썬에서 사용되는 라이브러리와 호환되지 않는 오래된 "
"라이브러리 버전이 사용됩니다. 가능하면 파이썬 자체의 기능을 사용하거나, ``msvcrt`` 모듈을 임포트 해서 사용하십시오."

#: ../../library/ctypes.rst:73
#, fuzzy
msgid ""
"On Linux, it is required to specify the filename *including* the "
"extension to load a library, so attribute access can not be used to load "
"libraries. Either the :meth:`~LibraryLoader.LoadLibrary` method of the "
"dll loaders should be used, or you should load the library by creating an"
" instance of CDLL by calling the constructor::"
msgstr ""
"리눅스에서, 라이브러리를 로드하기 위해서는 확장자를 *포함하는* 파일명을 지정해야 하므로, 어트리뷰트 액세스를 사용하여 라이브러리를"
" 로드 할 수 없습니다. dll 로더의 :meth:`LoadLibrary` 메서드를 사용하거나 CDLL의 생성자를 호출하여 "
"인스턴스를 만들어 라이브러리를 로드해야 합니다::"

#: ../../library/ctypes.rst:79
msgid ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:92
msgid "Accessing functions from loaded dlls"
msgstr "로드된 dll에서 함수에 액세스하기"

#: ../../library/ctypes.rst:94
msgid "Functions are accessed as attributes of dll objects::"
msgstr "함수는 dll 객체의 어트리뷰트로 액세스 됩니다::"

#: ../../library/ctypes.rst:96
msgid ""
">>> libc.printf\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.MyOwnFunction)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 239, in __getattr__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function 'MyOwnFunction' not found\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:108
#, fuzzy
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export"
" ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with a ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 "
"``GetModuleHandle`` function, which returns a *module handle* for a given"
" module name, has the following C prototype, and a macro is used to "
"expose one of them as ``GetModuleHandle`` depending on whether UNICODE is"
" defined or not::"
msgstr ""
"``kernel32`` 와 ``user32``\\와 같은 win32 시스템 dll은 종종 ANSI뿐만 아니라 UNICODE 버전의 "
"함수를 내보냅니다. UNICODE 버전은 이름에 ``W``\\가 추가된 상태로 내보내지고, ANSI 버전은 이름에 ``A``\\가 "
"추가되어 내보내 집니다. 지정된 모듈 이름의 *모듈 핸들*\\을 반환하는 win32 ``GetModuleHandle`` 함수는, "
"다음과 같은 C 프로토타입을 가지며, UNICODE가 정의되어 있는지에 따라 그중 하나를 ``GetModuleHandle``\\로 "
"노출하기 위해 매크로가 사용됩니다::"

#: ../../library/ctypes.rst:116
msgid ""
"/* ANSI version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"
msgstr ""

#: ../../library/ctypes.rst:121
msgid ""
"*windll* does not try to select one of them by magic, you must access the"
" version you need by specifying ``GetModuleHandleA`` or "
"``GetModuleHandleW`` explicitly, and then call it with bytes or string "
"objects respectively."
msgstr ""
"*windll*\\는 마술적으로 이 중 하나를 선택하려고 하지 않으므로, ``GetModuleHandleA`` 나 "
"``GetModuleHandleW``\\를 명시적으로 지정하여 필요한 버전에 액세스해야 하고, 그런 다음 각각 바이트열이나 문자열 "
"객체로 호출해야 합니다."

#: ../../library/ctypes.rst:125
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use "
":func:`getattr` to retrieve the function::"
msgstr ""
"때때로, dll은 ``\"??2@YAPAXI@Z\"``\\와 같은 유효한 파이썬 식별자가 아닌 이름으로 함수를 내보냅니다. 이때는 "
":func:`getattr`\\를 사용하여 함수를 조회해야 합니다::"

#: ../../library/ctypes.rst:129
msgid ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr object at 0x...>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:133
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"윈도우에서, 일부 dll은 이름이 아니라 서수(ordinal)로 함수를 내보냅니다. 이 함수는 서수로 dll 객체를 인덱싱하여 "
"액세스할 수 있습니다::"

#: ../../library/ctypes.rst:136
msgid ""
">>> cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
">>> cdll.kernel32[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 310, in __getitem__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function ordinal 0 not found\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:150
msgid "Calling functions"
msgstr "함수 호출하기"

#: ../../library/ctypes.rst:152
#, fuzzy
msgid ""
"You can call these functions like any other Python callable. This example"
" uses the ``rand()`` function, which takes no arguments and returns a "
"pseudo-random integer::"
msgstr ""
"다른 파이썬 콜러블처럼 이 함수를 호출할 수 있습니다. 이 예제에서는 시스템 시간을 유닉스 에포크부터의 초로 반환하는 "
"``time()`` 함수와 win32 모듈 핸들을 반환하는 ``GetModuleHandleA()`` 함수를 사용합니다."

#: ../../library/ctypes.rst:155
msgid ""
">>> print(libc.rand())\n"
"1804289383"
msgstr ""

#: ../../library/ctypes.rst:158
msgid ""
"On Windows, you can call the ``GetModuleHandleA()`` function, which "
"returns a win32 module handle (passing ``None`` as single argument to "
"call it with a ``NULL`` pointer)::"
msgstr ""

#: ../../library/ctypes.rst:161
msgid ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:165
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with "
"the ``cdecl`` calling convention, or vice versa::"
msgstr ""
"``cdecl`` 호출 규칙을 사용하여 ``stdcall`` 함수를 호출하면 :exc:`ValueError`\\가 발생하고, 그 "
"반대도 마찬가지입니다::"

#: ../../library/ctypes.rst:168
msgid ""
">>> cdll.kernel32.GetModuleHandleA(None)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>>\n"
"\n"
">>> windll.msvcrt.printf(b\"spam\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in"
" excess)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:180
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr "올바른 호출 규칙을 찾으려면 C 헤더 파일이나 호출할 함수에 대한 설명서를 살펴봐야 합니다."

#: ../../library/ctypes.rst:183
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"윈도우에서, :mod:`ctypes`\\는 함수가 유효하지 않은 인자 값을 사용하여 호출될 때, 일반적인 보호 오류로 인한 충돌을 "
"방지하기 위해 win32 구조적 예외 처리를 사용합니다::"

#: ../../library/ctypes.rst:187
msgid ""
">>> windll.kernel32.GetModuleHandleA(32)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"OSError: exception: access violation reading 0x00000020\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:193
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so "
"you should be careful anyway.  The :mod:`faulthandler` module can be "
"helpful in debugging crashes (e.g. from segmentation faults produced by "
"erroneous C library calls)."
msgstr ""
"그러나, :mod:`ctypes`\\로 파이썬을 충돌시킬 방법이 많으므로, 어쨌든 주의해야 합니다. "
":mod:`faulthandler` 모듈은 충돌을 디버깅하는 데 도움이 될 수 있습니다 (예를 들어, 오류가 있는 C 라이브러리 "
"호출로 인한 세그먼트 오류)."

#: ../../library/ctypes.rst:198
#, fuzzy
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only "
"native Python objects that can directly be used as parameters in these "
"function calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects"
" and strings are passed as pointer to the memory block that contains "
"their data (:c:expr:`char *` or :c:expr:`wchar_t *`).  Python integers "
"are passed as the platform's default C :c:expr:`int` type, their value is"
" masked to fit into the C type."
msgstr ""
"``None``, 정수, 바이트열 객체 및 (유니코드) 문자열은 이러한 함수 호출에서 매개 변수로 직접 사용할 수 있는 유일한 "
"파이썬 자체의 객체입니다. ``None``\\는 C ``NULL`` 포인터로 전달되고, 바이트열 객체와 문자열은 데이터가 저장된 "
"메모리 블록에 대한 포인터로 전달됩니다 (:c:type:`char *` 이나 :c:type:`wchar_t *`). 파이썬 정수는 "
"플랫폼의 기본 C :c:type:`int` 형으로 전달되며, 그 값은 C 형에 맞게 마스크 됩니다."

#: ../../library/ctypes.rst:205
msgid ""
"Before we move on calling functions with other parameter types, we have "
"to learn more about :mod:`ctypes` data types."
msgstr "다른 매개 변수 형으로 함수를 호출하기 전에, :mod:`ctypes` 데이터형에 대해 더 알아야 합니다."

#: ../../library/ctypes.rst:212 ../../library/ctypes.rst:2242
msgid "Fundamental data types"
msgstr "기본 데이터형"

#: ../../library/ctypes.rst:214
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes`\\는 많은 기본적인 C 호환 데이터형을 정의합니다.:"

#: ../../library/ctypes.rst:217
msgid "ctypes type"
msgstr "ctypes 형"

#: ../../library/ctypes.rst:217
msgid "C type"
msgstr "C 형"

#: ../../library/ctypes.rst:217
msgid "Python type"
msgstr "파이썬 형"

#: ../../library/ctypes.rst:219
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../../library/ctypes.rst:219
#, fuzzy
msgid ":c:expr:`_Bool`"
msgstr ":c:type:`_Bool`"

#: ../../library/ctypes.rst:219
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:221
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../../library/ctypes.rst:221 ../../library/ctypes.rst:225
#, fuzzy
msgid ":c:expr:`char`"
msgstr ":c:type:`char`"

#: ../../library/ctypes.rst:221
msgid "1-character bytes object"
msgstr "1-문자 바이트열 객체"

#: ../../library/ctypes.rst:223
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../../library/ctypes.rst:223
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../../library/ctypes.rst:223
msgid "1-character string"
msgstr "1-문자 문자열"

#: ../../library/ctypes.rst:225
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../../library/ctypes.rst:225 ../../library/ctypes.rst:227
#: ../../library/ctypes.rst:229 ../../library/ctypes.rst:231
#: ../../library/ctypes.rst:233 ../../library/ctypes.rst:235
#: ../../library/ctypes.rst:237 ../../library/ctypes.rst:239
#: ../../library/ctypes.rst:241 ../../library/ctypes.rst:243
#: ../../library/ctypes.rst:246 ../../library/ctypes.rst:248
#: ../../library/ctypes.rst:251
msgid "int"
msgstr "int"

#: ../../library/ctypes.rst:227
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../../library/ctypes.rst:227
#, fuzzy
msgid ":c:expr:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: ../../library/ctypes.rst:229
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../../library/ctypes.rst:229
#, fuzzy
msgid ":c:expr:`short`"
msgstr ":c:type:`short`"

#: ../../library/ctypes.rst:231
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../../library/ctypes.rst:231
#, fuzzy
msgid ":c:expr:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: ../../library/ctypes.rst:233
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../../library/ctypes.rst:233
#, fuzzy
msgid ":c:expr:`int`"
msgstr ":c:type:`int`"

#: ../../library/ctypes.rst:235
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../../library/ctypes.rst:235
#, fuzzy
msgid ":c:expr:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: ../../library/ctypes.rst:237
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../../library/ctypes.rst:237
#, fuzzy
msgid ":c:expr:`long`"
msgstr ":c:type:`long`"

#: ../../library/ctypes.rst:239
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../../library/ctypes.rst:239
#, fuzzy
msgid ":c:expr:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: ../../library/ctypes.rst:241
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../../library/ctypes.rst:241
#, fuzzy
msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:type:`__int64` 나 :c:type:`long long`"

#: ../../library/ctypes.rst:243
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../../library/ctypes.rst:243
#, fuzzy
msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:type:`unsigned __int64` 나 :c:type:`unsigned long long`"

#: ../../library/ctypes.rst:246
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../../library/ctypes.rst:246
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../../library/ctypes.rst:248
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../../library/ctypes.rst:248
#, fuzzy
msgid ":c:type:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` 나 :c:type:`Py_ssize_t`"

#: ../../library/ctypes.rst:251
#, fuzzy
msgid ":class:`c_time_t`"
msgstr ":class:`c_size_t`"

#: ../../library/ctypes.rst:251
#, fuzzy
msgid ":c:type:`time_t`"
msgstr ":c:type:`size_t`"

#: ../../library/ctypes.rst:253
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../../library/ctypes.rst:253
#, fuzzy
msgid ":c:expr:`float`"
msgstr ":c:type:`float`"

#: ../../library/ctypes.rst:253 ../../library/ctypes.rst:255
#: ../../library/ctypes.rst:257
msgid "float"
msgstr "float"

#: ../../library/ctypes.rst:255
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../../library/ctypes.rst:255
#, fuzzy
msgid ":c:expr:`double`"
msgstr ":c:type:`double`"

#: ../../library/ctypes.rst:257
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../../library/ctypes.rst:257
#, fuzzy
msgid ":c:expr:`long double`"
msgstr ":c:type:`long double`"

#: ../../library/ctypes.rst:259
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../../library/ctypes.rst:259
#, fuzzy
msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:type:`char *` (NUL 종료됨)"

#: ../../library/ctypes.rst:259
msgid "bytes object or ``None``"
msgstr "바이트열 객체나 ``None``"

#: ../../library/ctypes.rst:261
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../../library/ctypes.rst:261
#, fuzzy
msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:type:`wchar_t *` (NUL 종료됨)"

#: ../../library/ctypes.rst:261
msgid "string or ``None``"
msgstr "문자열이나 ``None``"

#: ../../library/ctypes.rst:263
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../../library/ctypes.rst:263
#, fuzzy
msgid ":c:expr:`void *`"
msgstr ":c:type:`void *`"

#: ../../library/ctypes.rst:263
msgid "int or ``None``"
msgstr "int 나 ``None``"

#: ../../library/ctypes.rst:267
msgid "The constructor accepts any object with a truth value."
msgstr "생성자는 논릿값을 가진 모든 객체를 받아들입니다."

#: ../../library/ctypes.rst:269
msgid ""
"All these types can be created by calling them with an optional "
"initializer of the correct type and value::"
msgstr "이 모든 형은 올바른 형과 값의 선택적 초기화자로 호출해서 만들어질 수 있습니다::"

#: ../../library/ctypes.rst:272
msgid ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hello, World\")\n"
"c_wchar_p(140018365411392)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:280
msgid ""
"Since these types are mutable, their value can also be changed "
"afterwards::"
msgstr "이러한 형은 가변이므로, 값을 나중에 변경할 수도 있습니다::"

#: ../../library/ctypes.rst:282
msgid ""
">>> i = c_int(42)\n"
">>> print(i)\n"
"c_long(42)\n"
">>> print(i.value)\n"
"42\n"
">>> i.value = -99\n"
">>> print(i.value)\n"
"-99\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:292
#, fuzzy
msgid ""
"Assigning a new value to instances of the pointer types "
":class:`c_char_p`, :class:`c_wchar_p`, and :class:`c_void_p` changes the "
"*memory location* they point to, *not the contents* of the memory block "
"(of course not, because Python string objects are immutable)::"
msgstr ""
":class:`c_char_p`, :class:`c_wchar_p` 및 :class:`c_void_p` 포인터형의 인스턴스에 새 "
"값을 대입하면 포인터가 가리키는 *메모리 위치*\\가 변경됩니다, 메모리 블록의 *내용이 아닙니다* (당연히 아닙니다, 파이썬 "
"바이트열 객체는 불변입니다)::"

#: ../../library/ctypes.rst:297
msgid ""
">>> s = \"Hello, World\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> print(c_s)\n"
"c_wchar_p(139966785747344)\n"
">>> print(c_s.value)\n"
"Hello World\n"
">>> c_s.value = \"Hi, there\"\n"
">>> print(c_s)              # the memory location has changed\n"
"c_wchar_p(139966783348904)\n"
">>> print(c_s.value)\n"
"Hi, there\n"
">>> print(s)                # first object is unchanged\n"
"Hello, World\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:312
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has"
" a :func:`create_string_buffer` function which creates these in various "
"ways.  The current memory block contents can be accessed (or changed) "
"with the ``raw`` property; if you want to access it as NUL terminated "
"string, use the ``value`` property::"
msgstr ""
"그러나, 이것들을 가변 메모리에 대한 포인터를 예상하는 함수에 전달하지 않도록 주의해야 합니다. 가변 메모리 블록이 필요하다면, "
"ctypes에는 다양한 방법으로 이를 만드는 :func:`create_string_buffer` 함수가 있습니다. 현재 메모리 블록"
" 내용은 ``raw`` 프로퍼티를 사용하여 액세스(또는 변경)할 수 있습니다; NUL 종료 문자열로 액세스하려면 ``value`` "
"프로퍼티를 사용하십시오::"

#: ../../library/ctypes.rst:319
msgid ""
">>> from ctypes import *\n"
">>> p = create_string_buffer(3)            # create a 3 byte buffer, "
"initialized to NUL bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\")     # create a buffer containing"
" a NUL terminated string\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hello\\x00'\n"
">>> print(repr(p.value))\n"
"b'Hello'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.value = b\"Hi\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:336
#, fuzzy
msgid ""
"The :func:`create_string_buffer` function replaces the old "
":func:`!c_buffer` function (which is still available as an alias).  To "
"create a mutable memory block containing unicode characters of the C type"
" :c:type:`wchar_t`, use the :func:`create_unicode_buffer` function."
msgstr ""
":func:`create_string_buffer` 함수는 이전 ctypes 배포에 있는 :func:`c_string` 함수뿐만 "
"아니라 :func:`c_buffer` 함수(아직 별칭으로 사용할 수 있습니다)를 대체합니다. C 형 "
":c:type:`wchar_t`\\의 유니코드 문자를 포함하는 가변 메모리 블록을 생성하려면 "
":func:`create_unicode_buffer` 함수를 사용하십시오."

#: ../../library/ctypes.rst:345
msgid "Calling functions, continued"
msgstr "함수 호출하기, 계속"

#: ../../library/ctypes.rst:347
msgid ""
"Note that printf prints to the real standard output channel, *not* to "
":data:`sys.stdout`, so these examples will only work at the console "
"prompt, not from within *IDLE* or *PythonWin*::"
msgstr ""
"printf는 :data:`sys.stdout`\\이 *아니라* 실제 표준 출력으로 인쇄하므로, 이 예제는 콘솔 프롬프트에서만 "
"작동하고 *IDLE* 이나 *PythonWin*\\에서는 작동하지 않음에 유의하십시오::"

#: ../../library/ctypes.rst:351
#, python-format
msgid ""
">>> printf = libc.printf\n"
">>> printf(b\"Hello, %s\\n\", b\"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"Hello, %S\\n\", \"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"%d bottles of beer\\n\", 42)\n"
"42 bottles of beer\n"
"19\n"
">>> printf(b\"%f bottles of beer\\n\", 42.5)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: Don't know how to convert "
"parameter 2\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:367
msgid ""
"As has been mentioned before, all Python types except integers, strings, "
"and bytes objects have to be wrapped in their corresponding :mod:`ctypes`"
" type, so that they can be converted to the required C data type::"
msgstr ""
"이전에 언급했듯이, 정수, 문자열 및 바이트열 객체를 제외한 모든 파이썬 형은 필요한 C 데이터형으로 변환될 수 있도록 해당하는 "
":mod:`ctypes` 형으로 래핑 되어야 합니다::"

#: ../../library/ctypes.rst:371
#, python-format
msgid ""
">>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n"
"An int 1234, a double 3.140000\n"
"31\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:379
#, fuzzy
msgid "Calling variadic functions"
msgstr "함수 호출하기"

#: ../../library/ctypes.rst:381
msgid ""
"On a lot of platforms calling variadic functions through ctypes is "
"exactly the same as calling functions with a fixed number of parameters. "
"On some platforms, and in particular ARM64 for Apple Platforms, the "
"calling convention for variadic functions is different than that for "
"regular functions."
msgstr ""

#: ../../library/ctypes.rst:386
msgid ""
"On those platforms it is required to specify the "
":attr:`~_CFuncPtr.argtypes` attribute for the regular, non-variadic, "
"function arguments:"
msgstr ""

#: ../../library/ctypes.rst:389
msgid "libc.printf.argtypes = [ctypes.c_char_p]"
msgstr ""

#: ../../library/ctypes.rst:393
msgid ""
"Because specifying the attribute does not inhibit portability it is "
"advised to always specify :attr:`~_CFuncPtr.argtypes` for all variadic "
"functions."
msgstr ""

#: ../../library/ctypes.rst:400
msgid "Calling functions with your own custom data types"
msgstr "사용자 정의 데이터형을 사용하여 함수 호출하기"

#: ../../library/ctypes.rst:402
#, fuzzy
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow "
"instances of your own classes be used as function arguments. "
":mod:`ctypes` looks for an :attr:`!_as_parameter_` attribute and uses "
"this as the function argument. The attribute must be an integer, string, "
"bytes, a :mod:`ctypes` instance, or an object with an "
":attr:`!_as_parameter_` attribute::"
msgstr ""
"또한 :mod:`ctypes` 인자 변환을 사용자 정의하여 사용자 고유 클래스의 인스턴스를 함수 인자로 사용할 수 있습니다. "
":mod:`ctypes`\\는 :attr:`_as_parameter_` 어트리뷰트를 찾고, 이를 함수 인자로 사용합니다. 물론 "
"정수, 문자열 또는 바이트열 중 하나여야 합니다::"

#: ../../library/ctypes.rst:408
#, python-format
msgid ""
">>> class Bottles:\n"
"...     def __init__(self, number):\n"
"...         self._as_parameter_ = number\n"
"...\n"
">>> bottles = Bottles(42)\n"
">>> printf(b\"%d bottles of beer\\n\", bottles)\n"
"42 bottles of beer\n"
"19\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:418
#, fuzzy
msgid ""
"If you don't want to store the instance's data in the "
":attr:`!_as_parameter_` instance variable, you could define a "
":class:`property` which makes the attribute available on request."
msgstr ""
":attr:`_as_parameter_` 인스턴스 변수에 인스턴스의 데이터를 저장하지 않으려면, "
":class:`property`\\를 정의하여 요청 시 어트리뷰트를 사용할 수 있게 할 수 있습니다."

#: ../../library/ctypes.rst:426
msgid "Specifying the required argument types (function prototypes)"
msgstr "필수 인자 형 (함수 프로토타입) 지정하기"

#: ../../library/ctypes.rst:428
#, fuzzy
msgid ""
"It is possible to specify the required argument types of functions "
"exported from DLLs by setting the :attr:`~_CFuncPtr.argtypes` attribute."
msgstr ":attr:`argtypes` 어트리뷰트를 설정하여 DLL에서 내보낸 함수의 필수 인자 형을 지정할 수 있습니다."

#: ../../library/ctypes.rst:431
#, fuzzy
msgid ""
":attr:`~_CFuncPtr.argtypes` must be a sequence of C data types (the "
":func:`!printf` function is probably not a good example here, because it "
"takes a variable number and different types of parameters depending on "
"the format string, on the other hand this is quite handy to experiment "
"with this feature)::"
msgstr ""
":attr:`argtypes`\\는 C 데이터형의 시퀀스 여야 합니다 (``printf`` 함수는 포맷 문자열에 따라 개수와 형이 "
"다른 매개 변수를 받아들이기 때문에, 여기서는 좋은 예가 아닐 수 있습니다. 반면에 이 기능을 실험하기에 매우 편리하기도 "
"합니다)::"

#: ../../library/ctypes.rst:436
#, python-format
msgid ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n"
"String 'Hi', Int 10, Double 2.200000\n"
"37\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:442
msgid ""
"Specifying a format protects against incompatible argument types (just as"
" a prototype for a C function), and tries to convert the arguments to "
"valid types::"
msgstr "포맷을 지정하면 호환되지 않는 인자 형으로부터 보호하고(C 함수의 프로토타입처럼), 유효한 형으로 인자를 변환하려고 시도합니다::"

#: ../../library/ctypes.rst:445
#, python-format
msgid ""
">>> printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: 'int' object cannot be "
"interpreted as ctypes.c_char_p\n"
">>> printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:454
#, fuzzy
msgid ""
"If you have defined your own classes which you pass to function calls, "
"you have to implement a :meth:`~_CData.from_param` class method for them "
"to be able to use them in the :attr:`~_CFuncPtr.argtypes` sequence. The "
":meth:`~_CData.from_param` class method receives the Python object passed"
" to the function call, it should do a typecheck or whatever is needed to "
"make sure this object is acceptable, and then return the object itself, "
"its :attr:`!_as_parameter_` attribute, or whatever you want to pass as "
"the C function argument in this case. Again, the result should be an "
"integer, string, bytes, a :mod:`ctypes` instance, or an object with an "
":attr:`!_as_parameter_` attribute."
msgstr ""
"함수 호출에 전달하는 여러분 자신의 클래스를 정의했으면, :attr:`argtypes` 시퀀스에서 해당 클래스를 사용할 수 있도록,"
" :meth:`from_param` 클래스 메서드를 구현해야 합니다. :meth:`from_param` 클래스 메서드는 함수 호출에"
" 전달된 파이썬 객체를 받습니다. 형 검사나 이 객체가 수용 가능한지 확인하는 데 필요한 모든 작업을 수행한 다음, 객체 자체나 "
":attr:`_as_parameter_` 어트리뷰트나 무엇이건 이 경우에 C 함수 인자로 전달되길 원하는 것을 반환해야 합니다. "
"다시 말하지만, 결과는 정수, 문자열, 바이트열, :mod:`ctypes` 인스턴스 또는 :attr:`_as_parameter_` "
"어트리뷰트가 있는 객체여야 합니다."

#: ../../library/ctypes.rst:468
msgid "Return types"
msgstr "반환형"

#: ../../library/ctypes.rst:478
#, fuzzy
msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  "
"Other return types can be specified by setting the "
":attr:`~_CFuncPtr.restype` attribute of the function object."
msgstr ""
"기본적으로 함수는 C :c:type:`int` 형을 반환한다고 가정합니다. 다른 반환형은 함수 객체의 :attr:`restype` "
"어트리뷰트를 설정하여 지정할 수 있습니다."

#: ../../library/ctypes.rst:482
msgid ""
"The C prototype of :c:func:`time` is ``time_t time(time_t *)``. Because "
":c:type:`time_t` might be of a different type than the default return "
"type :c:expr:`int`, you should specify the :attr:`!restype` attribute::"
msgstr ""

#: ../../library/ctypes.rst:486
msgid ">>> libc.time.restype = c_time_t"
msgstr ""

#: ../../library/ctypes.rst:488
msgid "The argument types can be specified using :attr:`~_CFuncPtr.argtypes`::"
msgstr ""

#: ../../library/ctypes.rst:490
msgid ">>> libc.time.argtypes = (POINTER(c_time_t),)"
msgstr ""

#: ../../library/ctypes.rst:492
msgid ""
"To call the function with a ``NULL`` pointer as first argument, use "
"``None``::"
msgstr ""

#: ../../library/ctypes.rst:494
msgid ""
">>> print(libc.time(None))\n"
"1150640792"
msgstr ""

#: ../../library/ctypes.rst:497
#, fuzzy
msgid ""
"Here is a more advanced example, it uses the :func:`!strchr` function, "
"which expects a string pointer and a char, and returns a pointer to a "
"string::"
msgstr ""
"다음은 더 고급 예제입니다. ``strchr`` 함수를 사용하는데, 문자열 포인터와 char을 기대하고, 문자열에 대한 포인터를 "
"반환합니다::"

#: ../../library/ctypes.rst:500
msgid ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p    # c_char_p is a pointer to a string\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"None\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:510
#, fuzzy
msgid ""
"If you want to avoid the :func:`ord(\"x\") <ord>` calls above, you can "
"set the :attr:`~_CFuncPtr.argtypes` attribute, and the second argument "
"will be converted from a single character Python bytes object into a C "
"char:"
msgstr ""
"위의 ``ord(\"x\")`` 호출을 피하려면, :attr:`argtypes` 어트리뷰트를 설정할 수 있으며, 두 번째 인자는 한"
" 글자 파이썬 바이트열 객체에서 C char로 변환됩니다::"

#: ../../library/ctypes.rst:514
msgid ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (most recent call last):\n"
"ctypes.ArgumentError: argument 2: TypeError: one character bytes, "
"bytearray or integer expected\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"None\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:529
#, fuzzy
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`~_CFuncPtr.restype` attribute, if the foreign "
"function returns an integer.  The callable will be called with the "
"*integer* the C function returns, and the result of this call will be "
"used as the result of your function call. This is useful to check for "
"error return values and automatically raise an exception::"
msgstr ""
"외부 함수가 정수를 반환하면, 콜러블 파이썬 객체(예를 들어, 함수나 클래스)를 :attr:`restype` 어트리뷰트로 사용할 "
"수도 있습니다. 콜러블은 C 함수가 돌려주는 *정수*\\로 호출되며, 이 호출의 결과는 함수 호출의 결과로 사용됩니다. 이것은 에러"
" 반환 값을 검사하고 자동으로 예외를 발생시키는 데 유용합니다::"

#: ../../library/ctypes.rst:535
msgid ""
">>> GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
">>> def ValidHandle(value):\n"
"...     if value == 0:\n"
"...         raise WinError()\n"
"...     return value\n"
"...\n"
">>>\n"
">>> GetModuleHandle.restype = ValidHandle\n"
">>> GetModuleHandle(None)\n"
"486539264\n"
">>> GetModuleHandle(\"something silly\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 3, in ValidHandle\n"
"OSError: [Errno 126] The specified module could not be found.\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:552
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` "
"api to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one"
" is used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError``\\는 윈도우 ``FormatMessage()`` api를 호출하여 에러 코드의 문자열 표현을 가져오고, "
"예외를 *반환하는* 함수입니다. ``WinError``\\는 선택적 에러 코드 매개 변수를 취합니다, 제공하지 않으면 "
":func:`GetLastError`\\를 호출하여 에러 코드를 가져옵니다."

#: ../../library/ctypes.rst:557
#, fuzzy
msgid ""
"Please note that a much more powerful error checking mechanism is "
"available through the :attr:`~_CFuncPtr.errcheck` attribute; see the "
"reference manual for details."
msgstr ""
"훨씬 더 강력한 에러 검사 메커니즘을 :attr:`errcheck` 어트리뷰트를 통해 사용할 수 있음에 유의하십시오; 자세한 내용은"
" 레퍼런스 설명서를 참조하십시오."

#: ../../library/ctypes.rst:565
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "포인터 전달하기 (또는: 참조로 매개 변수 전달하기)"

#: ../../library/ctypes.rst:567
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as "
"parameter, probably to write into the corresponding location, or if the "
"data is too large to be passed by value. This is also known as *passing "
"parameters by reference*."
msgstr ""
"때때로 C api 함수는 매개 변수로 데이터형을 가리키는 *포인터*\\를 기대합니다, 아마도 해당 위치에 쓰기 위해서, 또는 "
"데이터가 너무 커서 값으로 전달할 수 없어서. 이것은 *참조로 매개 변수 전달하기*\\로 알려져 있기도 합니다."

#: ../../library/ctypes.rst:571
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the "
":func:`pointer` function, although :func:`pointer` does a lot more work "
"since it constructs a real pointer object, so it is faster to use "
":func:`byref` if you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes`\\는 매개 변수를 참조로 전달하는 데 사용되는 :func:`byref` 함수를 내보냅니다. 같은 효과를 "
":func:`pointer` 함수로도 얻을 수 있습니다. 하지만 :func:`pointer`\\는 실제 포인터 객체를 생성하기 "
"때문에 더 많은 작업을 수행하므로, 파이썬 자체에서 포인터 객체가 필요하지 않으면 :func:`byref`\\를 사용하는 것이 더 "
"빠릅니다.::"

#: ../../library/ctypes.rst:577
#, python-format
msgid ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = create_string_buffer(b'\\000' * 32)\n"
">>> print(i.value, f.value, repr(s.value))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"...             byref(i), byref(f), s)\n"
"3\n"
">>> print(i.value, f.value, repr(s.value))\n"
"1 3.1400001049 b'Hello'\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:593
msgid "Structures and unions"
msgstr "구조체와 공용체"

#: ../../library/ctypes.rst:595
#, fuzzy
msgid ""
"Structures and unions must derive from the :class:`Structure` and "
":class:`Union` base classes which are defined in the :mod:`ctypes` "
"module. Each subclass must define a :attr:`~Structure._fields_` "
"attribute.  :attr:`!_fields_` must be a list of *2-tuples*, containing a "
"*field name* and a *field type*."
msgstr ""
"구조체와 공용체는 :mod:`ctypes` 모듈에 정의된 :class:`Structure`\\와 :class:`Union` 베이스 "
"클래스에서 파생되어야 합니다. 각 서브 클래스는 :attr:`_fields_` 어트리뷰트를 정의해야 합니다. "
":attr:`_fields_`\\는 *필드 이름* 과 *필드형*\\을 포함하는 *2-튜플*\\의 리스트여야 합니다."

#: ../../library/ctypes.rst:600
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"필드형은 :class:`c_int`\\와 같은 :mod:`ctypes` 형이거나 다른 파생된 :mod:`ctypes` 형(구조체, "
"공용체, 배열, 포인터)이어야 합니다."

#: ../../library/ctypes.rst:603
msgid ""
"Here is a simple example of a POINT structure, which contains two "
"integers named *x* and *y*, and also shows how to initialize a structure "
"in the constructor::"
msgstr ""
"다음은 *x* 및 *y*\\라는 두 개의 정수가 포함된 POINT 구조체의 간단한 예제이며, 생성자에서 구조체를 초기화하는 방법도 "
"보여줍니다::"

#: ../../library/ctypes.rst:606
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: too many initializers\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:623
msgid ""
"You can, however, build much more complicated structures.  A structure "
"can itself contain other structures by using a structure as a field type."
msgstr "그러나, 훨씬 복잡한 구조를 만들 수 있습니다. 구조체는 필드형으로 구조체를 사용하여 다른 구조체를 포함할 수 있습니다."

#: ../../library/ctypes.rst:626
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr "다음은 *upperleft* 및 *lowerright*\\라는 두 개의 POINT를 포함하는 RECT 구조체입니다::"

#: ../../library/ctypes.rst:629
msgid ""
">>> class RECT(Structure):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"...                 (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(point)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:640
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr "중첩된 구조체는 여러 가지 방법으로 생성자에서 초기화할 수 있습니다::"

#: ../../library/ctypes.rst:642
msgid ""
">>> r = RECT(POINT(1, 2), POINT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"
msgstr ""

#: ../../library/ctypes.rst:645
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"필드 :term:`디스크립터 <descriptor>`\\는 *클래스*\\에서 조회할 수 있습니다. 유용한 정보를 제공할 수 있으므로"
" 디버깅에 유용합니다::"

#: ../../library/ctypes.rst:648
msgid ""
">>> print(POINT.x)\n"
"<Field type=c_long, ofs=0, size=4>\n"
">>> print(POINT.y)\n"
"<Field type=c_long, ofs=4, size=4>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:659
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-"
"fields to functions by value.  While this may work on 32-bit x86, it's "
"not guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by "
"pointer."
msgstr ""
":mod:`ctypes`\\는 비트 필드가 있는 공용체나 구조체를 값으로 함수에 전달할 수 없습니다. 32비트 x86에서 작동할 수"
" 있지만, 일반적으로 작동은 라이브러리가 보증하지 않습니다. 비트 필드가 있는 공용체와 구조체는 항상 포인터로 함수에 전달되어야 "
"합니다."

#: ../../library/ctypes.rst:665
msgid "Structure/union alignment and byte order"
msgstr "구조체/공용체 정렬과 바이트 순서"

#: ../../library/ctypes.rst:667
#, fuzzy
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying "
"a :attr:`~Structure._pack_` class attribute in the subclass definition. "
"This must be set to a positive integer and specifies the maximum "
"alignment for the fields. This is what ``#pragma pack(n)`` also does in "
"MSVC. It is also possible to set a minimum alignment for how the subclass"
" itself is packed in the same way ``#pragma align(n)`` works in MSVC. "
"This can be achieved by specifying a :attr:`~Structure._align_` class "
"attribute in the subclass definition."
msgstr ""
"기본적으로, Structure와 Union 필드는 C 컴파일러와 같은 방식으로 정렬됩니다. 서브 클래스 정의에서 "
":attr:`_pack_` 클래스 어트리뷰트를 지정하면, 이 동작을 재정의할 수 있습니다. 이 값은 양의 정수로 설정해야 하고, "
"필드의 최대 정렬을 지정합니다. 이것은 MSVC에서 ``#pragma pack(n)``\\가 수행하는 것입니다."

#: ../../library/ctypes.rst:677
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the "
":class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  "
"These classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes`\\는 구조체와 공용체에 기본(native) 바이트 순서를 사용합니다. 기본이 아닌 바이트 순서로 구조체를 "
"만들려면 :class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion` 및 :class:`LittleEndianUnion` 베이스 클래스 중 하나를 사용할 수 "
"있습니다. 이러한 클래스들은 포인터 필드를 포함할 수 없습니다."

#: ../../library/ctypes.rst:687
msgid "Bit fields in structures and unions"
msgstr "구조체와 공용체의 비트 필드"

#: ../../library/ctypes.rst:689
#, fuzzy
msgid ""
"It is possible to create structures and unions containing bit fields. Bit"
" fields are only possible for integer fields, the bit width is specified "
"as the third item in the :attr:`~Structure._fields_` tuples::"
msgstr ""
"비트 필드를 포함하는 구조체와 공용체를 만드는 것이 가능합니다. 비트 필드는 정수 필드에만 가능하며, 비트 폭은 "
":attr:`_fields_` 튜플의 세 번째 항목으로 지정됩니다::"

#: ../../library/ctypes.rst:693
msgid ""
">>> class Int(Structure):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"...                 (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.first_16)\n"
"<Field type=c_long, ofs=0:0, bits=16>\n"
">>> print(Int.second_16)\n"
"<Field type=c_long, ofs=0:16, bits=16>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:707
msgid "Arrays"
msgstr "배열"

#: ../../library/ctypes.rst:709
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr "배열은 같은 형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다."

#: ../../library/ctypes.rst:711
msgid ""
"The recommended way to create array types is by multiplying a data type "
"with a positive integer::"
msgstr "배열형을 만드는 데 권장되는 방법은 데이터형에 양의 정수를 곱하는 것입니다::"

#: ../../library/ctypes.rst:714
msgid "TenPointsArrayType = POINT * 10"
msgstr ""

#: ../../library/ctypes.rst:716
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr "다음은 다소 인공적인 데이터형의 예입니다. 다른 항목들과 함께 4개의 POINT를 포함하는 구조체입니다::"

#: ../../library/ctypes.rst:719
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"...                 (\"b\", c_float),\n"
"...                 (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:732
msgid "Instances are created in the usual way, by calling the class::"
msgstr "인스턴스는 클래스를 호출하는 일반적인 방법으로 만들어집니다::"

#: ../../library/ctypes.rst:734
msgid ""
"arr = TenPointsArrayType()\n"
"for pt in arr:\n"
"    print(pt.x, pt.y)"
msgstr ""

#: ../../library/ctypes.rst:738
msgid ""
"The above code print a series of ``0 0`` lines, because the array "
"contents is initialized to zeros."
msgstr "위 코드는 배열 내용이 0으로 초기화되기 때문에, 일련의 ``0 0`` 줄을 인쇄합니다."

#: ../../library/ctypes.rst:741
msgid "Initializers of the correct type can also be specified::"
msgstr "올바른 형의 초기화자를 지정할 수도 있습니다::"

#: ../../library/ctypes.rst:743
msgid ""
">>> from ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10 object at 0x...>\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:757
msgid "Pointers"
msgstr "포인터"

#: ../../library/ctypes.rst:759
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on "
"a :mod:`ctypes` type::"
msgstr "포인터 인스턴스는 :mod:`ctypes` 형에 :func:`pointer` 함수를 호출해서 만듭니다::"

#: ../../library/ctypes.rst:762
msgid ""
">>> from ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pointer(i)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:767
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which "
"returns the object to which the pointer points, the ``i`` object above::"
msgstr ""
"포인터 인스턴스는 포인터가 가리키는 객체(위에서는 ``i`` 객체)를 반환하는 :attr:`~_Pointer.contents` "
"어트리뷰트를 가집니다::"

#: ../../library/ctypes.rst:770
msgid ""
">>> pi.contents\n"
"c_long(42)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:774
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
":mod:`ctypes`\\에는 OOR(원래 객체 반환, original object return)이 없다는 것에 유의하십시오. "
"어트리뷰트를 가져올 때마다 (동등하지만) 새로운 객체를 만듭니다::"

#: ../../library/ctypes.rst:777
msgid ""
">>> pi.contents is i\n"
"False\n"
">>> pi.contents is pi.contents\n"
"False\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:783
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where "
"this is stored::"
msgstr ""
"다른 :class:`c_int` 인스턴스를 포인터의 contents 어트리뷰트에 대입하면 포인터는 이 인스턴스가 저장되어있는 메모리"
" 위치를 가리키게 됩니다::"

#: ../../library/ctypes.rst:786
msgid ""
">>> i = c_int(99)\n"
">>> pi.contents = i\n"
">>> pi.contents\n"
"c_long(99)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:795
msgid "Pointer instances can also be indexed with integers::"
msgstr "포인터 인스턴스는 정수로도 인덱싱할 수 있습니다.::"

#: ../../library/ctypes.rst:797
msgid ""
">>> pi[0]\n"
"99\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:801
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "정수 인덱스에 대입하면 가리키고 있는 값이 바뀝니다::"

#: ../../library/ctypes.rst:803
msgid ""
">>> print(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> print(i)\n"
"c_long(22)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:810
msgid ""
"It is also possible to use indexes different from 0, but you must know "
"what you're doing, just as in C: You can access or change arbitrary "
"memory locations. Generally you only use this feature if you receive a "
"pointer from a C function, and you *know* that the pointer actually "
"points to an array instead of a single item."
msgstr ""
"0이 아닌 인덱스를 사용할 수도 있지만, C에서와 마찬가지로 자신이 하는 일을 알아야 합니다: 임의의 메모리 위치를 액세스하거나 "
"변경할 수 있습니다. 일반적으로 C 함수에서 포인터를 받고, 포인터가 실제로 단일 항목 대신 배열을 가리키는 것을 *알* 때만 이 "
"기능을 사용합니다."

#: ../../library/ctypes.rst:816
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply "
"create pointer instances, it has to create pointer *types* first. This is"
" done with the :func:`POINTER` function, which accepts any :mod:`ctypes` "
"type, and returns a new type::"
msgstr ""
"장막 뒤에서, :func:`pointer` 함수는 단순히 포인터 인스턴스를 만드는 것 이상을 수행합니다. 먼저 포인터 *형*\\을 "
"만들어야 합니다. 이것은 임의의 :mod:`ctypes` 형을 받아들이고, 새로운 형을 반환하는 :func:`POINTER` 함수로"
" 수행됩니다::"

#: ../../library/ctypes.rst:821
msgid ""
">>> PI = POINTER(c_int)\n"
">>> PI\n"
"<class 'ctypes.LP_c_long'>\n"
">>> PI(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: expected c_long instead of int\n"
">>> PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:832
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr "인자 없이 포인터형을 호출하면 ``NULL`` 포인터가 만들어집니다. ``NULL`` 포인터는 ``False`` 논릿값을 갖습니다::"

#: ../../library/ctypes.rst:835
msgid ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"False\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:840
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes`\\는 포인터를 역참조(dereference)할 때 ``NULL``\\인지 확인합니다 (하지만 "
"``NULL``\\이 아닌 잘못된 포인터를 역참조하면 파이썬을 충돌시킵니다)::"

#: ../../library/ctypes.rst:843
msgid ""
">>> null_ptr[0]\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:859
msgid "Type conversions"
msgstr "형 변환"

#: ../../library/ctypes.rst:861
#, fuzzy
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`~_CFuncPtr.argtypes` list of a function "
"or as the type of a member field in a structure definition, only "
"instances of exactly the same type are accepted.  There are some "
"exceptions to this rule, where ctypes accepts other objects.  For "
"example, you can pass compatible array instances instead of pointer "
"types.  So, for ``POINTER(c_int)``, ctypes accepts an array of c_int::"
msgstr ""
"일반적으로, ctypes는 엄격한 형 검사를 수행합니다. 이는 함수의 :attr:`argtypes` 목록에 "
"``POINTER(c_int)``\\가 있거나, 구조체 멤버 필드의 형이 그런 형이라면, 정확히 같은 형의 인스턴스만 허용됨을 "
"뜻합니다. 이 규칙에는 ctypes가 다른 객체를 허용하는 몇 가지 예외가 있습니다. 예를 들어, 포인터형 대신 호환 가능한 배열 "
"인스턴스를 전달할 수 있습니다. 따라서 ``POINTER(c_int)``\\의 경우, ctype은 c_int 배열을 허용합니다::"

#: ../../library/ctypes.rst:868
msgid ""
">>> class Bar(Structure):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.values = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"...     print(bar.values[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:882
#, fuzzy
msgid ""
"In addition, if a function argument is explicitly declared to be a "
"pointer type (such as ``POINTER(c_int)``) in :attr:`~_CFuncPtr.argtypes`,"
" an object of the pointed type (``c_int`` in this case) can be passed to "
"the function.  ctypes will apply the required :func:`byref` conversion in"
" this case automatically."
msgstr ""
"또한, 함수 인자가 :attr:`argtypes`\\에 포인터형(가령 ``POINTER(c_int)``)으로 명시적으로 선언되면, "
"대상형(이 경우 ``c_int``)의 객체를 함수에 전달할 수 있습니다. 이때 ctypes는 필요한 :func:`byref` 변환을"
" 자동으로 적용합니다."

#: ../../library/ctypes.rst:887
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr "POINTER 형 필드를 ``NULL``\\로 설정하려면, ``None``\\을 대입할 수 있습니다::"

#: ../../library/ctypes.rst:889
msgid ""
">>> bar.values = None\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:894
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast "
"one type into another type.  :mod:`ctypes` provides a :func:`cast` "
"function which can be used in the same way.  The ``Bar`` structure "
"defined above accepts ``POINTER(c_int)`` pointers or :class:`c_int` "
"arrays for its ``values`` field, but not instances of other types::"
msgstr ""
"때에 따라 호환되지 않는 형의 인스턴스가 있을 수 있습니다. C에서는, 한 형을 다른 형으로 강제 변환(cast)할 수 있습니다. "
":mod:`ctypes`\\는 같은 방식으로 사용할 수 있는 :func:`cast` 함수를 제공합니다. 위에 정의된 ``Bar`` "
"구조체는 ``values`` 필드에 대해 ``POINTER(c_int)`` 포인터나 :class:`c_int` 배열을 받아들이지만 "
"다른 형의 인스턴스는 허용하지 않습니다::"

#: ../../library/ctypes.rst:900
msgid ""
">>> bar.values = (c_byte * 4)()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: incompatible types, c_byte_Array_4 instance instead of "
"LP_c_long instance\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:906
msgid "For these cases, the :func:`cast` function is handy."
msgstr "이럴 때, :func:`cast` 함수가 편리합니다."

#: ../../library/ctypes.rst:908
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two "
"parameters, a ctypes object that is or can be converted to a pointer of "
"some kind, and a ctypes pointer type.  It returns an instance of the "
"second argument, which references the same memory block as the first "
"argument::"
msgstr ""
":func:`cast` 함수는 ctypes 인스턴스를 다른 ctypes 데이터형에 대한 포인터로 변환하는 데 사용할 수 있습니다. "
":func:`cast`\\는 두 개의 매개 변수, 어떤 종류의 포인터로 변환될 수 있는 ctypes 객체와 ctypes 포인터형을 "
"받아들입니다. 첫 번째 인자와 같은 메모리 블록을 참조하는 두 번째 인자의 인스턴스를 반환합니다::"

#: ../../library/ctypes.rst:914
msgid ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long object at ...>\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:919
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar``"
" the structure::"
msgstr "따라서, :func:`cast`\\는 ``Bar`` 구조체의 ``values`` 필드에 대입하는 데 사용할 수 있습니다::"

#: ../../library/ctypes.rst:922
msgid ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.values[0])\n"
"0\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:932
msgid "Incomplete Types"
msgstr "불완전한 형"

#: ../../library/ctypes.rst:934
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not"
" yet specified. In C, they are specified by forward declarations, which "
"are defined later::"
msgstr ""
"*불완전한 형*\\은 멤버가 아직 지정되지 않은 구조체, 공용체 또는 배열입니다. C에서, 이것들은 나중에 정의되는 전방 "
"선언(forward declaration)으로 지정됩니다::"

#: ../../library/ctypes.rst:938
#, python-brace-format
msgid ""
"struct cell; /* forward declaration */\n"
"\n"
"struct cell {\n"
"    char *name;\n"
"    struct cell *next;\n"
"};"
msgstr ""

#: ../../library/ctypes.rst:945
msgid ""
"The straightforward translation into ctypes code would be this, but it "
"does not work::"
msgstr "ctypes 코드로 그대로 옮기면 이렇게 되지만, 작동하지는 않습니다::"

#: ../../library/ctypes.rst:948
msgid ""
">>> class cell(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in cell\n"
"NameError: name 'cell' is not defined\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:958
#, fuzzy
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the "
":attr:`~Structure._fields_` attribute later, after the class statement::"
msgstr ""
"새 ``class cell``\\은 클래스 문 자체에서 사용할 수 없기 때문입니다. :mod:`ctypes`\\에서는, "
"``cell`` 클래스를 정의한 다음, class 문 뒤에서 :attr:`_fields_` 어트리뷰트를 설정할 수 있습니다::"

#: ../../library/ctypes.rst:962
msgid ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:970
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"해 봅시다. 우리는 두 개의 ``cell`` 인스턴스를 만들고, 서로를 가리키도록 한 다음, 마지막으로 포인터 체인을 몇 번 "
"따라갑니다::"

#: ../../library/ctypes.rst:973
msgid ""
">>> c1 = cell()\n"
">>> c1.name = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.name = b\"bar\"\n"
">>> c1.next = pointer(c2)\n"
">>> c2.next = pointer(c1)\n"
">>> p = c1\n"
">>> for i in range(8):\n"
"...     print(p.name, end=\" \")\n"
"...     p = p.next[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:991
msgid "Callback functions"
msgstr "콜백 함수"

#: ../../library/ctypes.rst:993
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes`\\는 파이썬 콜러블로부터 C에서 호출 가능한 함수 포인터를 만들 수 있습니다. 이들은 때로 *콜백 "
"함수(callback functions)*\\라고 불립니다."

#: ../../library/ctypes.rst:996
msgid ""
"First, you must create a class for the callback function. The class knows"
" the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr "먼저, 콜백 함수를 위한 클래스를 만들어야 합니다. 클래스는 호출 규칙, 반환형 및 이 함수가 받는 인자의 수와 형을 알고 있습니다."

#: ../../library/ctypes.rst:1000
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback "
"functions using the ``cdecl`` calling convention. On Windows, the "
":func:`WINFUNCTYPE` factory function creates types for callback functions"
" using the ``stdcall`` calling convention."
msgstr ""
":func:`CFUNCTYPE` 팩토리 함수는 ``cdecl`` 호출 규칙을 사용하여 콜백 함수의 형을 만듭니다. 윈도우에서, "
":func:`WINFUNCTYPE` 팩토리 함수는 ``stdcall`` 호출 규칙을 사용하여 콜백 함수 형을 만듭니다."

#: ../../library/ctypes.rst:1005
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr "이러한 팩토리 함수는 모두 첫 번째 인자로 결과 형을, 나머지 인자로 콜백 함수가 기대하는 인자 형들로 호출됩니다."

#: ../../library/ctypes.rst:1009
#, fuzzy
msgid ""
"I will present an example here which uses the standard C library's "
":c:func:`!qsort` function, that is used to sort items with the help of a "
"callback function.  :c:func:`!qsort` will be used to sort an array of "
"integers::"
msgstr ""
"콜백 함수의 도움을 받아 항목을 정렬하는 데 사용되는 표준 C 라이브러리의 :c:func:`qsort` 함수를 사용하는 예제를 "
"제시합니다. :c:func:`qsort`\\는 정수 배열을 정렬하는 데 사용될 것입니다::"

#: ../../library/ctypes.rst:1013
msgid ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = None\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1019
#, fuzzy
msgid ""
":func:`!qsort` must be called with a pointer to the data to sort, the "
"number of items in the data array, the size of one item, and a pointer to"
" the comparison function, the callback. The callback will then be called "
"with two pointers to items, and it must return a negative integer if the "
"first item is smaller than the second, a zero if they are equal, and a "
"positive integer otherwise."
msgstr ""
":func:`qsort`\\는 정렬 할 데이터에 대한 포인터, 데이터 배열의 항목 수, 항목 하나의 크기 및 비교 함수에 대한 "
"포인터인 콜백으로 호출해야 합니다. 콜백은 항목에 대한 두 개의 포인터로 호출되며, 첫 번째 항목이 두 번째 항목보다 작으면 음의 "
"정수를, 같으면 0을, 그렇지 않으면 양수 정수를 반환해야 합니다."

#: ../../library/ctypes.rst:1025
msgid ""
"So our callback function receives pointers to integers, and must return "
"an integer. First we create the ``type`` for the callback function::"
msgstr "따라서 콜백 함수는 정수에 대한 포인터들을 받고 정수를 반환해야 합니다. 먼저 콜백 함수를 위한 ``형``\\을 만듭니다::"

#: ../../library/ctypes.rst:1028
msgid ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1031
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr "시작하기 위해, 전달된 값을 보여주는 간단한 콜백이 있습니다::"

#: ../../library/ctypes.rst:1034
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1041
msgid "The result::"
msgstr "결과::"

#: ../../library/ctypes.rst:1043
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1051
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "이제 실제로 두 항목을 비교하여 유용한 결과를 반환할 수 있습니다::"

#: ../../library/ctypes.rst:1053
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1066
msgid "As we can easily check, our array is sorted now::"
msgstr "쉽게 확인할 수 있듯이, 배열은 이제 정렬되었습니다::"

#: ../../library/ctypes.rst:1068
msgid ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1073
msgid ""
"The function factories can be used as decorator factories, so we may as "
"well write::"
msgstr "함수 팩토리는 데코레이터 팩토리로 사용할 수 있으므로, 다음과 같이 작성할 수도 있습니다::"

#: ../../library/ctypes.rst:1076
msgid ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1091
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as "
"they are used from C code. :mod:`ctypes` doesn't, and if you don't, they "
"may be garbage collected, crashing your program when a callback is made."
msgstr ""
"C 코드에서 사용되는 동안 :func:`CFUNCTYPE` 객체에 대한 참조를 유지해야 합니다. :mod:`ctypes`\\가 "
"참조를 유지하지는 않으며, 여러분이 하지 않는다면 가비지 수집되어, 콜백이 발생할 때 프로그램이 충돌할 수 있습니다."

#: ../../library/ctypes.rst:1095
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values "
"stored with :class:`threading.local` will *not* survive across different "
"callbacks, even when those calls are made from the same C thread."
msgstr ""
"또한, 콜백 함수가 파이썬 제어 바깥에서 만들어진 스레드(예를 들어, 콜백을 호출하는 외부 코드)에서 호출되면, ctypes는 모든"
" 호출에 대해 새로운 더미 파이썬 스레드를 만듭니다. 이 동작은 대부분 적합하지만, "
":class:`threading.local`\\에 저장된 값은, 같은 C 스레드에서 호출되는 여러 콜백에서 살아남을 수 "
"*없음*\\을 뜻합니다."

#: ../../library/ctypes.rst:1105
msgid "Accessing values exported from dlls"
msgstr "dll에서 내 보낸 값을 액세스하기"

#: ../../library/ctypes.rst:1107
#, fuzzy
msgid ""
"Some shared libraries not only export functions, they also export "
"variables. An example in the Python library itself is the "
":c:data:`Py_Version`, Python runtime version number encoded in a single "
"constant integer."
msgstr ""
"일부 공유 라이브러리는 함수를 내보낼 뿐만 아니라 변수도 내보냅니다. 파이썬 라이브러리 자체에 있는 예는 "
":c:data:`Py_OptimizeFlag` 인데, 시작 시 주어진 :option:`-O`\\나 :option:`-OO` 플래그에"
" 따라, 0, 1 또는 2로 설정된 정수입니다."

#: ../../library/ctypes.rst:1111
#, fuzzy
msgid ""
":mod:`ctypes` can access values like this with the :meth:`~_CData.in_dll`"
" class methods of the type.  *pythonapi* is a predefined symbol giving "
"access to the Python C api::"
msgstr ""
":mod:`ctypes`\\는 형의 :meth:`in_dll` 클래스 메서드를 사용하여 이와 같은 값을 액세스할 수 있습니다. "
"*pythonapi*\\는 파이썬 C API에 대한 액세스를 제공하는 미리 정의된 심볼입니다::"

#: ../../library/ctypes.rst:1115
msgid ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.value))\n"
"0x30c00a0"
msgstr ""

#: ../../library/ctypes.rst:1119
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"포인터의 사용법도 보여주는 확장 예제는 파이썬이 내 보낸 :c:data:`PyImport_FrozenModules` 포인터에 "
"액세스합니다."

#: ../../library/ctypes.rst:1122
msgid "Quoting the docs for that value:"
msgstr "해당 값에 대한 문서를 인용하면:"

#: ../../library/ctypes.rst:1124
#, fuzzy
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When "
"a frozen module is imported, it is searched in this table.  Third-party "
"code could play tricks with this to provide a dynamically created "
"collection of frozen modules."
msgstr ""
"이 포인터는 멤버가 모두 ``NULL`` 이나 0인 것으로 끝나는 :c:type:`struct _frozen` 레코드 배열을 "
"가리키도록 초기화됩니다. 프로즌 모듈이 임포트될 때, 이 테이블에서 검색됩니다. 제삼자 코드는 동적으로 만들어진 프로즌 모듈의 "
"컬렉션을 제공하기 위해 이것을 조작할 수 있습니다."

#: ../../library/ctypes.rst:1129
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with "
":mod:`ctypes`::"
msgstr ""
"따라서, 이 포인터를 조작하는 것이 유용할 수도 있습니다. 예제 크기를 제한하기 위해, :mod:`ctypes`\\로 이 테이블을 "
"읽는 방법만 보여줍니다::"

#: ../../library/ctypes.rst:1132
msgid ""
">>> from ctypes import *\n"
">>>\n"
">>> class struct_frozen(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"code\", POINTER(c_ubyte)),\n"
"...                 (\"size\", c_int),\n"
"...                 (\"get_code\", POINTER(c_ubyte)),  # Function pointer"
"\n"
"...                ]\n"
"...\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1143
#, fuzzy
msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the "
"pointer to the table::"
msgstr ":c:type:`struct _frozen` 데이터형을 정의했으므로, 테이블에 대한 포인터를 얻을 수 있습니다::"

#: ../../library/ctypes.rst:1146
msgid ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> table = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1150
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` "
"records, we can iterate over it, but we just have to make sure that our "
"loop terminates, because pointers have no size. Sooner or later it would "
"probably crash with an access violation or whatever, so it's better to "
"break out of the loop when we hit the ``NULL`` entry::"
msgstr ""
"``table``\\이 ``struct_frozen`` 레코드의 배열에 대한 ``포인터``\\이므로, 이터레이션할 수 있습니다. "
"하지만 포인터는 크기가 없으므로 루프를 종료하는 방법이 필요합니다. 조만간 액세스 위반 등으로 인해 충돌이 발생할 수 있으므로, "
"``NULL`` 엔트리가 발견되자마자 루프에서 벗어나는 것이 좋습니다::"

#: ../../library/ctypes.rst:1156
msgid ""
">>> for item in table:\n"
"...     if item.name is None:\n"
"...         break\n"
"...     print(item.name.decode(\"ascii\"), item.size)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1166
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only"
" used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"표준 파이썬이 프로즌 모듈과 프로즌 패키지(음수 ``size`` 멤버로 표시됨)를 가지고 있다는 사실은 잘 알려지지 않았으며, "
"테스트용으로만 사용됩니다. 예를 들어 ``import __hello__``\\를 시도해보십시오."

#: ../../library/ctypes.rst:1174
msgid "Surprises"
msgstr "의외의 것들"

#: ../../library/ctypes.rst:1176
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something "
"other than what actually happens."
msgstr ":mod:`ctypes`\\에는 여러분이 기대하는 것과 실제로 일어나는 것이 다른 가장자리가 있습니다."

#: ../../library/ctypes.rst:1179
msgid "Consider the following example::"
msgstr "다음 예제를 고려해보십시오::"

#: ../../library/ctypes.rst:1181
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1199
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line "
"above::"
msgstr ""
"흠. 아마도 마지막 문장이 ``3 4 1 2``\\를 인쇄할 것으로 기대했을 겁니다. 어떻게 된 걸까요? 위의 ``rc.a, "
"rc.b = rc.b, rc.a`` 줄의 단계는 다음과 같습니다::"

#: ../../library/ctypes.rst:1202
msgid ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1207
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies "
"the buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, "
"changes the contents of ``temp1``. So, the last assignment ``rc.b = "
"temp1``, doesn't have the expected effect."
msgstr ""
"``temp0`` 과 ``temp1``\\은 여전히 위의 ``rc`` 객체의 내부 버퍼를 사용하는 객체입니다. 따라서 ``rc.a "
"= temp0``\\를 실행하면 ``temp0``\\의 버퍼 내용이 ``rc``\\의 버퍼로 복사됩니다. 이것은, 결과적으로 "
"``temp1``\\의 내용을 변경합니다. 따라서 마지막 대입인 ``rc.b = temp1``\\은 기대하는 효과를 주지 못합니다."

#: ../../library/ctypes.rst:1213
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and "
"Arrays doesn't *copy* the sub-object, instead it retrieves a wrapper "
"object accessing the root-object's underlying buffer."
msgstr ""
"Structure, Union 및 Array에서 서브 객체를 가져오는 것은 서브 객체를 *복사*\\하지 않고, 대신 루트 객체의 "
"하부 버퍼에 액세스하는 래퍼 객체를 가져온다는 점에 유의하십시오."

#: ../../library/ctypes.rst:1217
msgid ""
"Another example that may behave differently from what one would expect is"
" this::"
msgstr "예상과 다른 행동을 하는 또 다른 예는 다음과 같습니다::"

#: ../../library/ctypes.rst:1219
msgid ""
">>> s = c_char_p()\n"
">>> s.value = b\"abc def ghi\"\n"
">>> s.value\n"
"b'abc def ghi'\n"
">>> s.value is s.value\n"
"False\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1229
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set"
" to bytes or integers."
msgstr ":class:`c_char_p`\\로 인스턴스를 만든 객체는 바이트열이나 정수로 설정된 value만 가질 수 있습니다."

#: ../../library/ctypes.rst:1232
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of "
"the memory. Storing a Python object in the memory block does not store "
"the object itself, instead the ``contents`` of the object is stored.  "
"Accessing the contents again constructs a new Python object each time!"
msgstr ""
"``False``\\를 인쇄하는 이유는 무엇일까요? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 어떤 "
":term:`디스크립터 <descriptor>`\\를 포함하는 객체입니다. 메모리 블록에 파이썬 객체를 저장하면 객체 자체를 "
"저장하지 않고, 대신 객체의 ``내용``\\을 저장합니다. 내용에 다시 액세스하면 매번 새로운 파이썬 객체가 생성됩니다!"

#: ../../library/ctypes.rst:1242
msgid "Variable-sized data types"
msgstr "가변 크기 데이터형"

#: ../../library/ctypes.rst:1244
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and "
"structures."
msgstr ":mod:`ctypes`\\는 가변 크기 배열과 구조체에 대한 일부 지원을 제공합니다."

#: ../../library/ctypes.rst:1246
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an"
" existing ctypes object.  The function takes the object as first "
"argument, and the requested size in bytes as the second argument.  The "
"memory block cannot be made smaller than the natural memory block "
"specified by the objects type, a :exc:`ValueError` is raised if this is "
"tried::"
msgstr ""
":func:`resize` 함수는 기존 ctypes 객체의 메모리 버퍼 크기를 바꾸는 데 사용할 수 있습니다. 이 함수는 객체를 첫"
" 번째 인자로 가져오고, 바이트 단위의 요청 된 크기를 두 번째 인자로 가져옵니다. 메모리 블록을 객체 형이 지정하는 원래 메모리 "
"블록보다 작게 만들 수 없습니다. 시도하면 :exc:`ValueError`\\가 발생합니다::"

#: ../../library/ctypes.rst:1252
msgid ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> resize(short_array, 4)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: minimum size is 8\n"
">>> resize(short_array, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1266
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 "
"elements, we get errors accessing other elements::"
msgstr ""
"훌륭합니다, 하지만 이 배열에 포함된 추가 요소에 어떻게 액세스할 수 있습니까? 형은 여전히 4개의 요소만 알고 있으므로, 다른 "
"요소에 액세스하면 에러가 발생합니다::"

#: ../../library/ctypes.rst:1270
msgid ""
">>> short_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (most recent call last):\n"
"    ...\n"
"IndexError: invalid index\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1278
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use"
" the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
":mod:`ctypes`\\에서 가변 크기 데이터형을 사용하는 또 다른 방법은, 파이썬의 동적 특성을 사용하고 필요한 크기가 이미 "
"알려진 후 매번 데이터형을 (재) 정의하는 것입니다."

#: ../../library/ctypes.rst:1286
msgid "ctypes reference"
msgstr "ctypes 레퍼런스"

#: ../../library/ctypes.rst:1292
msgid "Finding shared libraries"
msgstr "공유 라이브러리 찾기"

#: ../../library/ctypes.rst:1294
msgid ""
"When programming in a compiled language, shared libraries are accessed "
"when compiling/linking a program, and when the program is run."
msgstr "컴파일 언어로 프로그래밍할 때, 공유 라이브러리는 프로그램을 컴파일/링크할 때와 프로그램을 실행할 때 액세스 됩니다."

#: ../../library/ctypes.rst:1297
#, fuzzy
msgid ""
"The purpose of the :func:`~ctypes.util.find_library` function is to "
"locate a library in a way similar to what the compiler or runtime loader "
"does (on platforms with several versions of a shared library the most "
"recent should be loaded), while the ctypes library loaders act like when "
"a program is run, and call the runtime loader directly."
msgstr ""
":func:`find_library` 함수의 목적은 컴파일러나 실행 시간 로더가 하는 것과 비슷한 방식으로 라이브러리를 찾는 "
"것입니다 (여러 버전의 공유 라이브러리가 있는 플랫폼에서는 가장 최근의 것을 로드해야 합니다). 반면에 ctypes 라이브러리 "
"로더는 프로그램이 실행될 때처럼 동작하고, 실행 시간 로더를 직접 호출합니다."

#: ../../library/ctypes.rst:1303
#, fuzzy
msgid ""
"The :mod:`!ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ":mod:`ctypes.util` 모듈은 로드할 라이브러리를 판별하는 데 도움이 되는 함수를 제공합니다."

#: ../../library/ctypes.rst:1311
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version"
" number (this is the form used for the posix linker option "
":option:`!-l`).  If no library can be found, returns ``None``."
msgstr ""
"라이브러리를 찾아서 경로명을 반환하려고 시도합니다. *name*\\은 *lib* 같은 접두사, ``.so``, ``.dylib`` "
"또는 버전 번호와 같은 접미사가 없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 :option:`!-l`\\에 사용되는 "
"양식입니다). 라이브러리를 찾을 수 없으면 ``None``\\을 반환합니다."

#: ../../library/ctypes.rst:1316 ../../library/ctypes.rst:2002
msgid "The exact functionality is system dependent."
msgstr "정확한 기능은 시스템에 따라 다릅니다."

#: ../../library/ctypes.rst:1318
#, fuzzy
msgid ""
"On Linux, :func:`~ctypes.util.find_library` tries to run external "
"programs (``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find "
"the library file. It returns the filename of the library file."
msgstr ""
"리눅스에서, :func:`find_library`\\는 외부 프로그램(``/sbin/ldconfig``, ``gcc``, "
"``objdump`` 및 ``ld``)을 실행하여 라이브러리 파일을 찾으려고 합니다. 라이브러리 파일의 파일명을 반환합니다."

#: ../../library/ctypes.rst:1322
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is "
"used when searching for libraries, if a library cannot be found by any "
"other means."
msgstr ""
"리눅스에서, 다른 수단으로 라이브러리를 찾을 수 없으면, 라이브러리 검색 시 환경 변수 ``LD_LIBRARY_PATH``\\의 "
"값이 사용됩니다."

#: ../../library/ctypes.rst:1326
msgid "Here are some examples::"
msgstr "여기 예제가 있습니다::"

#: ../../library/ctypes.rst:1328
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1337
#, fuzzy
msgid ""
"On macOS and Android, :func:`~ctypes.util.find_library` uses the system's"
" standard naming schemes and paths to locate the library, and returns a "
"full pathname if successful::"
msgstr ""
"OS X에서, :func:`find_library`\\는 라이브러리를 찾기 위해 미리 정의된 몇 가지 명명 체계와 경로를 시도하고 "
"성공하면 전체 경로명을 반환합니다::"

#: ../../library/ctypes.rst:1341
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1352
#, fuzzy
msgid ""
"On Windows, :func:`~ctypes.util.find_library` searches along the system "
"search path, and returns the full pathname, but since there is no "
"predefined naming scheme a call like ``find_library(\"c\")`` will fail "
"and return ``None``."
msgstr ""
"윈도우에서, :func:`find_library`\\는 시스템 검색 경로를 따라 검색하고 전체 경로명을 반환하지만, 미리 정의된 "
"명명 체계가 없으므로 ``find_library(\"c\")``\\와 같은 호출은 실패하고 ``None``\\을 반환합니다."

#: ../../library/ctypes.rst:1356
#, fuzzy
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using "
":func:`~ctypes.util.find_library` to locate the library at runtime."
msgstr ""
"공유 라이브러리를 :mod:`ctypes`\\로 래핑하려면, 실행 시간에 라이브러리를 찾기 위해 "
":func:`find_library`\\를 사용하기보다, 개발 시점에 공유 라이브러리 이름을 확인하고 래퍼 모듈에 하드 코딩 하는 "
"것이 더 좋을 수 있습니다."

#: ../../library/ctypes.rst:1364
msgid "Loading shared libraries"
msgstr "공유 라이브러리 로드하기"

#: ../../library/ctypes.rst:1366
msgid ""
"There are several ways to load shared libraries into the Python process."
"  One way is to instantiate one of the following classes:"
msgstr ""
"공유 라이브러리를 파이썬 프로세스에 로드하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 다음 클래스 중 하나의 인스턴스를 "
"만드는 것입니다:"

#: ../../library/ctypes.rst:1372
#, fuzzy
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to"
" return :c:expr:`int`."
msgstr ""
"이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타냅니다. 이 라이브러리의 함수는 표준 C 호출 규칙을 사용하며, "
":c:type:`int`\\를 반환한다고 가정합니다."

#: ../../library/ctypes.rst:1376
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL "
"name exists. When a dependent DLL of the loaded DLL is not found, a "
":exc:`OSError` error is raised with the message *\"[WinError 126] The "
"specified module could not be found\".* This error message does not "
"contain the name of the missing DLL because the Windows API does not "
"return this information making this error hard to diagnose. To resolve "
"this error and determine which DLL is not found, you need to find the "
"list of dependent DLLs and determine which one is not found using Windows"
" debugging and tracing tools."
msgstr ""
"윈도우에서는 DLL 이름이 존재하더라도 :class:`CDLL` 인스턴스 생성이 실패할 수 있습니다. 로드된 DLL의 종속 DLL을"
" 찾을 수 없을 때, *\"[WinError 126] The specified module could not be found\"* "
"메시지로 :exc:`OSError` 에러가 발생합니다. 윈도우 API가 정보를 반환하지 않아서 이 에러 메시지에는 누락된 DLL의 "
"이름이 포함되어 있지 않고, 이 에러를 진단하기 어렵게 만듭니다. 이 에러를 해결하고 찾을 수 없는 DLL을 확인하려면, 윈도우 "
"디버깅과 추적 도구를 사용하여 종속 DLL 목록을 찾고 찾을 수 없는 DLL을 확인해야 합니다."

#: ../../library/ctypes.rst:1388 ../../library/ctypes.rst:1413
#: ../../library/ctypes.rst:1426 ../../library/ctypes.rst:1444
msgid "The *name* parameter can now be a :term:`path-like object`."
msgstr ""

#: ../../library/ctypes.rst:1392
msgid ""
"`Microsoft DUMPBIN tool "
"<https://docs.microsoft.com/cpp/build/reference/dependents>`_ -- A tool "
"to find DLL dependents."
msgstr ""
"`Microsoft DUMPBIN tool "
"<https://docs.microsoft.com/cpp/build/reference/dependents>`_ -- DLL 종속 "
"항목을 찾는 도구."

#: ../../library/ctypes.rst:1398
#, fuzzy
msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed "
"to return the windows specific :class:`HRESULT` code.  :class:`HRESULT` "
"values contain information specifying whether the function call failed or"
" succeeded, together with additional error code.  If the return value "
"signals a failure, an :class:`OSError` is automatically raised."
msgstr ""
"윈도우 전용: 이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타내며, 이 라이브러리의 함수는 ``stdcall`` 호출 규칙을 "
"사용하고, 윈도우 특정 :class:`HRESULT` 코드를 반환한다고 가정합니다. :class:`HRESULT` 값에는 함수 "
"호출이 실패했는지 또는 성공했는지와 추가 에러 코드를 지정하는 정보가 들어 있습니다. 반환 값이 실패를 알리면, "
":class:`OSError`\\가 자동으로 발생합니다."

#: ../../library/ctypes.rst:1405 ../../library/ctypes.rst:1422
#: ../../library/ctypes.rst:1566 ../../library/ctypes.rst:1574
#: ../../library/ctypes.rst:1751 ../../library/ctypes.rst:1982
#: ../../library/ctypes.rst:1991 ../../library/ctypes.rst:2016
#: ../../library/ctypes.rst:2025 ../../library/ctypes.rst:2034
#: ../../library/ctypes.rst:2049 ../../library/ctypes.rst:2106
#: ../../library/ctypes.rst:2134 ../../library/ctypes.rst:2478
msgid "Availability"
msgstr ""

#: ../../library/ctypes.rst:1407
#, fuzzy
msgid ""
":exc:`WindowsError` used to be raised, which is now an alias of "
":exc:`OSError`."
msgstr "윈도우 에러는 :exc:`WindowsError`\\를 일으켜왔습니다. 이제는 :exc:`OSError`\\의 별칭입니다."

#: ../../library/ctypes.rst:1418
#, fuzzy
msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed "
"to return :c:expr:`int` by default."
msgstr ""
"윈도우 전용: 이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타내며, 이 라이브러리의 함수는 ``stdcall`` 호출 규칙을 "
"사용하고, 기본적으로 :c:type:`int`\\를 반환한다고 가정합니다."

#: ../../library/ctypes.rst:1429
msgid ""
"The Python :term:`global interpreter lock` is released before calling any"
" function exported by these libraries, and reacquired afterwards."
msgstr ""
"파이썬 :term:`전역 인터프리터 록 <global interpreter lock>`\\은, 이 라이브러리들이 내보낸 함수를 "
"호출하기 전에 해제되고 나중에 다시 획득됩니다."

#: ../../library/ctypes.rst:1435
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that "
"the Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is"
" set, a Python exception is raised."
msgstr ""
"이 클래스의 인스턴스는 :class:`CDLL` 인스턴스처럼 동작합니다. 단, 파이썬 GIL이 함수 호출 중에 릴리스 되지 "
"*않고*, 함수 실행 후 파이썬 에러 플래그가 확인된다는 점만 다릅니다. 에러 플래그가 설정되면 파이썬 예외가 발생합니다."

#: ../../library/ctypes.rst:1440
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "따라서, 이것은 파이썬 C API 함수를 직접 호출하는 경우에만 유용합니다."

#: ../../library/ctypes.rst:1446
#, fuzzy
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platform's "
":c:func:`!dlopen` or :c:func:`!LoadLibrary` function is used to load the "
"library into the process, and to get a handle to it."
msgstr ""
"이러한 모든 클래스는 공유 라이브러리의 경로명인 적어도 하나의 인자를 사용하여 인스턴스를 만들 수 있습니다. 이미 로드된 공유 "
"라이브러리에 대한 기존 핸들이 있으면, 이를 ``handle`` 이라고 이름 붙은 매개 변수로 전달할 수 있습니다. 그렇지 않으면 "
"하부 플랫폼의 ``dlopen`` 이나 ``LoadLibrary`` 함수를 사용하여 라이브러리를 프로세스에 로드하고 이에 대한 "
"핸들을 확보합니다."

#: ../../library/ctypes.rst:1453
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  "
"For details, consult the :manpage:`dlopen(3)` manpage.  On Windows, "
"*mode* is ignored.  On posix systems, RTLD_NOW is always added, and is "
"not configurable."
msgstr ""
"*mode* 매개 변수는 라이브러리가 로드되는 방법을 지정하는 데 사용될 수 있습니다. 자세한 내용은, "
":manpage:`dlopen(3)` 매뉴얼 페이지를 참조하십시오. 윈도우에서는, *mode*\\가 무시됩니다. posix "
"시스템에서는 RTLD_NOW가 항상 추가되며 구성할 수 없습니다."

#: ../../library/ctypes.rst:1458
#, fuzzy
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism "
"that allows accessing the system :data:`errno` error number in a safe "
"way. :mod:`ctypes` maintains a thread-local copy of the system's "
":data:`errno` variable; if you call foreign functions created with "
"``use_errno=True`` then the :data:`errno` value before the function call "
"is swapped with the ctypes private copy, the same happens immediately "
"after the function call."
msgstr ""
"*use_errno* 매개 변수를 참으로 설정하면 시스템 :data:`errno` 에러 번호에 안전하게 액세스할 수 있는 "
"ctypes 메커니즘을 활성화합니다. :mod:`ctypes`\\는 시스템 :data:`errno` 변수의 스레드 로컬 사본을 "
"유지합니다; ``use_errno=True``\\로 만든 외부 함수를 호출하면 함수 호출 전에 :data:`errno` 값이 "
"ctypes 내부 복사본과 스와프되며 함수 호출 직후에도 마찬가지 작업을 합니다."

#: ../../library/ctypes.rst:1465
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the "
"ctypes private copy to a new value and returns the former value."
msgstr ""
":func:`ctypes.get_errno` 함수는 ctypes 내부 사본의 값을 반환하고, "
":func:`ctypes.set_errno` 함수는 ctypes 내부 사본을 새 값으로 변경하고 이전 값을 반환합니다."

#: ../../library/ctypes.rst:1469
#, fuzzy
msgid ""
"The *use_last_error* parameter, when set to true, enables the same "
"mechanism for the Windows error code which is managed by the "
":func:`GetLastError` and :func:`!SetLastError` Windows API functions; "
":func:`ctypes.get_last_error` and :func:`ctypes.set_last_error` are used "
"to request and change the ctypes private copy of the windows error code."
msgstr ""
"*use_last_error* 매개 변수를 참으로 설정하면, :func:`GetLastError` 와 "
":func:`SetLastError` 윈도우 API 함수에서 관리하는 윈도우 에러 코드에 대해 같은 메커니즘을 활성화합니다. "
":func:`ctypes.get_last_error`\\와 :func:`ctypes.set_last_error`\\는 윈도우 에러 "
"코드의 ctypes 내부 사본을 요청하고 변경하는 데 사용됩니다."

#: ../../library/ctypes.rst:1475
#, fuzzy
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for "
"the Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the "
"default is to use the flags that result in the most secure DLL load, "
"which avoids issues such as DLL hijacking. Passing the full path to the "
"DLL is the safest way to ensure the correct library and dependencies are "
"loaded."
msgstr ""
"*winmode* 매개 변수는 윈도우에서 라이브러리를 로드하는 방법을 지정하는 데 사용됩니다 (*mode*\\가 무시되므로). "
"Win32 API ``LoadLibraryEx`` 플래그 매개 변수에 유효한 모든 값을 받아들입니다. 생략되면, 기본값은 DLL "
"하이재킹과 같은 문제를 피하고자 가장 안전한 DLL 로드가 이루어지는 플래그를 사용합니다. DLL의 전체 경로를 전달하는 것은 "
"올바른 라이브러리와 종속성이 로드되도록 하는 가장 안전한 방법입니다."

#: ../../library/ctypes.rst:1482
msgid "Added *winmode* parameter."
msgstr "*winmode* 매개 변수가 추가되었습니다."

#: ../../library/ctypes.rst:1489
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr "*mode* 매개 변수에 사용하는 플래그. 이 플래그를 사용할 수 없는 플랫폼에서는, 정수 0으로 정의됩니다."

#: ../../library/ctypes.rst:1496
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not "
"available, it is the same as *RTLD_GLOBAL*."
msgstr "*mode* 매개 변수에 사용하는 플래그. 이 플래그를 사용할 수 없는 플랫폼에서는, *RTLD_GLOBAL*\\과 같습니다."

#: ../../library/ctypes.rst:1503
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, "
"this is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"공유 라이브러리를 로드하는 데 사용되는 기본 모드. OSX 10.3에서는 *RTLD_GLOBAL*\\이고, 그렇지 않으면 "
"*RTLD_LOCAL*\\과 같습니다."

#: ../../library/ctypes.rst:1506
msgid ""
"Instances of these classes have no public methods.  Functions exported by"
" the shared library can be accessed as attributes or by index.  Please "
"note that accessing the function through an attribute caches the result "
"and therefore accessing it repeatedly returns the same object each time."
"  On the other hand, accessing it through an index returns a new object "
"each time::"
msgstr ""
"이 클래스들의 인스턴스는 공개 메서드가 없습니다. 공유 라이브러리가 내보낸 함수는 어트리뷰트나 인덱스로 액세스할 수 있습니다. "
"어트리뷰트를 통해 함수에 액세스하면 결과가 캐시 되므로 반복적으로 액세스할 때 매번 같은 객체가 반환됨에 유의하십시오. 반면에 "
"인덱스를 통해 액세스하면 매번 새로운 객체가 반환됩니다::"

#: ../../library/ctypes.rst:1512
msgid ""
">>> from ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\")  # On Linux\n"
">>> libc.time == libc.time\n"
"True\n"
">>> libc['time'] == libc['time']\n"
"False"
msgstr ""

#: ../../library/ctypes.rst:1519
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr "다음 공개 어트리뷰트를 사용할 수 있습니다. 내보낸 함수 이름과의 충돌을 피하고자 이름은 밑줄로 시작합니다:"

#: ../../library/ctypes.rst:1525
msgid "The system handle used to access the library."
msgstr "라이브러리에 액세스하는 데 사용되는 시스템 핸들."

#: ../../library/ctypes.rst:1530
msgid "The name of the library passed in the constructor."
msgstr "생성자에서 전달된 라이브러리의 이름."

#: ../../library/ctypes.rst:1532
#, fuzzy
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either "
"by calling the :meth:`~LibraryLoader.LoadLibrary` method, or by "
"retrieving the library as attribute of the loader instance."
msgstr ""
"공유 라이브러리는 :class:`LibraryLoader` 클래스의 인스턴스인 사전 작성된 객체 중 하나를 사용하여 로드 할 수도 "
"있습니다. 로더의 :meth:`LoadLibrary` 메서드를 호출하거나 로더 인스턴스의 어트리뷰트로 라이브러리를 조회합니다."

#: ../../library/ctypes.rst:1540
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the "
":class:`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"공유 라이브러리를 로드하는 클래스. *dlltype*\\은 :class:`CDLL`, :class:`PyDLL`, "
":class:`WinDLL` 또는 :class:`OleDLL` 형 중 하나여야 합니다."

#: ../../library/ctypes.rst:1543
#, fuzzy
msgid ""
":meth:`!__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ""
":meth:`__getattr__`\\에는 특수한 동작이 있습니다: 라이브러리 로더 인스턴스의 어트리뷰트를 액세스하여 공유 "
"라이브러리를 로드 할 수 있게 합니다. 결과는 캐시 되므로 반복되는 어트리뷰트 액세스는 매번 같은 라이브러리를 반환합니다."

#: ../../library/ctypes.rst:1549
msgid ""
"Load a shared library into the process and return it.  This method always"
" returns a new instance of the library."
msgstr "공유 라이브러리를 프로세스에 로드하고 반환합니다. 이 메서드는 항상 라이브러리의 새 인스턴스를 반환합니다."

#: ../../library/ctypes.rst:1553
msgid "These prefabricated library loaders are available:"
msgstr "다음과 같은 사전 작성된 로더를 사용할 수 있습니다:"

#: ../../library/ctypes.rst:1558
msgid "Creates :class:`CDLL` instances."
msgstr ":class:`CDLL` 인스턴스를 만듭니다."

#: ../../library/ctypes.rst:1564
#, fuzzy
msgid "Creates :class:`WinDLL` instances."
msgstr ":class:`CDLL` 인스턴스를 만듭니다."

#: ../../library/ctypes.rst:1572
#, fuzzy
msgid "Creates :class:`OleDLL` instances."
msgstr ":class:`CDLL` 인스턴스를 만듭니다."

#: ../../library/ctypes.rst:1580
msgid "Creates :class:`PyDLL` instances."
msgstr ":class:`PyDLL` 인스턴스를 만듭니다."

#: ../../library/ctypes.rst:1583
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr "C 파이썬 API에 직접 액세스하기 위해, 바로 사용할 수 있는 파이썬 공유 라이브러리 객체가 제공됩니다:"

#: ../../library/ctypes.rst:1589
#, fuzzy
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C "
":c:expr:`int`, which is of course not always the truth, so you have to "
"assign the correct :attr:`!restype` attribute to use these functions."
msgstr ""
"파이썬 C API 함수를 어트리뷰트로 노출하는 :class:`PyDLL`\\의 인스턴스. 이 모든 함수는 C "
":c:type:`int`\\를 반환한다고 가정하는데, 물론 항상 옳지는 않습니다. 그런 함수를 사용하려면 올바른 "
":attr:`restype` 어트리뷰트를 대입해야 합니다."

#: ../../library/ctypes.rst:1594 ../../library/ctypes.rst:1596
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the "
"name used to load the library."
msgstr ""
"이러한 객체를 통해 라이브러리를 로드하면 라이브러리를 로드하는 데 사용된 이름인 ``name`` 문자열 인자로 :ref:`감사 "
"이벤트(auditing event) <auditing>` ``ctypes.dlopen``\\을 발생시킵니다."

#: ../../library/ctypes.rst:1600 ../../library/ctypes.rst:1602
msgid ""
"Accessing a function on a loaded library raises an auditing event "
"``ctypes.dlsym`` with arguments ``library`` (the library object) and "
"``name`` (the symbol's name as a string or integer)."
msgstr ""
"로드된 라이브러리에서 함수에 액세스하면 인자 ``library``\\(라이브러리 객체)와 ``name``\\(문자열이나 정수로 "
"심볼의 이름)으로 감사 이벤트 ``ctypes.dlsym``\\을 발생시킵니다."

#: ../../library/ctypes.rst:1606 ../../library/ctypes.rst:1608
msgid ""
"In cases when only the library handle is available rather than the "
"object, accessing a function raises an auditing event "
"``ctypes.dlsym/handle`` with arguments ``handle`` (the raw library "
"handle) and ``name``."
msgstr ""
"객체 대신 라이브러리 핸들만 사용 가능한 경우, 함수에 액세스하면 인자 ``handle``\\(원시 라이브러리 핸들)과 "
"``name``\\으로 감사 이벤트 ``ctypes.dlsym/handle``\\을 발생시킵니다."

#: ../../library/ctypes.rst:1615
msgid "Foreign functions"
msgstr "외부 함수"

#: ../../library/ctypes.rst:1617
#, fuzzy
msgid ""
"As explained in the previous section, foreign functions can be accessed "
"as attributes of loaded shared libraries.  The function objects created "
"in this way by default accept any number of arguments, accept any ctypes "
"data instances as arguments, and return the default result type specified"
" by the library loader."
msgstr ""
"이전 섹션에서 설명한 것처럼, 외부 함수는 로드된 공유 라이브러리의 어트리뷰트로 액세스할 수 있습니다. 이런 방식으로 만들어진 함수"
" 객체는 기본적으로 임의의 개수 인자를 허용하고, 임의의 ctypes 데이터 인스턴스를 인자로 받아들이고, 라이브러리 로더에 의해 "
"지정된 기본 결과형을 반환합니다. 이것들은 내부 클래스의 인스턴스입니다:"

#: ../../library/ctypes.rst:1622
msgid ""
"They are instances of a private local class :class:`!_FuncPtr` (not "
"exposed in :mod:`!ctypes`) which inherits from the private "
":class:`_CFuncPtr` class:"
msgstr ""

#: ../../library/ctypes.rst:1625
msgid ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"True\n"
">>> lib._FuncPtr is ctypes._CFuncPtr\n"
"False"
msgstr ""

#: ../../library/ctypes.rst:1636
msgid "Base class for C callable foreign functions."
msgstr "C 호출 가능한 외부 함수의 베이스 클래스."

#: ../../library/ctypes.rst:1638
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr "외부 함수의 인스턴스는 C 호환 데이터형이기도 합니다; C 함수 포인터를 나타냅니다."

#: ../../library/ctypes.rst:1641
msgid ""
"This behavior can be customized by assigning to special attributes of the"
" foreign function object."
msgstr "이 동작은 외부 함수 객체의 특수 어트리뷰트에 대입하여 사용자 정의할 수 있습니다."

#: ../../library/ctypes.rst:1646
#, fuzzy
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. "
"Use ``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"ctypes 형을 대입하여 외부 함수의 결과형을 지정합니다. 아무것도 반환하지 않는 함수인 :c:type:`void`\\는 "
"``None``\\를 사용하십시오."

#: ../../library/ctypes.rst:1649
#, fuzzy
msgid ""
"It is possible to assign a callable Python object that is not a ctypes "
"type, in this case the function is assumed to return a C :c:expr:`int`, "
"and the callable will be called with this integer, allowing further "
"processing or error checking.  Using this is deprecated, for more "
"flexible post processing or error checking use a ctypes data type as "
":attr:`!restype` and assign a callable to the :attr:`errcheck` attribute."
msgstr ""
"ctypes 형이 아닌 콜러블 파이썬 객체를 대입할 수 있습니다. 이때 함수는 C :c:type:`int`\\를 반환한다고 "
"가정하고, 이 콜러블 객체는 이 정수로 호출되어, 사후 처리나 에러 검사를 허용합니다. 이 기능을 사용하는 것은 폐지되었습니다. 더"
" 유연한 사후 처리나 에러 검사를 위해, ctypes 데이터형을 :attr:`restype`\\로 사용하고, 콜러블을 "
":attr:`errcheck` 어트리뷰트에 대입하십시오."

#: ../../library/ctypes.rst:1658
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can"
" only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"ctypes 형의 튜플을 대입하여 함수가 받아들이는 인자 형을 지정합니다. ``stdcall`` 호출 규칙을 사용하는 함수는 이 "
"튜플의 길이와 같은 수의 인자로만 호출할 수 있습니다; C 호출 규칙을 사용하는 함수는 추가적인 지정되지 않은 인자도 허용합니다."

#: ../../library/ctypes.rst:1664
#, fuzzy
msgid ""
"When a foreign function is called, each actual argument is passed to the "
":meth:`~_CData.from_param` class method of the items in the "
":attr:`argtypes` tuple, this method allows adapting the actual argument "
"to an object that the foreign function accepts.  For example, a "
":class:`c_char_p` item in the :attr:`argtypes` tuple will convert a "
"string passed as argument into a bytes object using ctypes conversion "
"rules."
msgstr ""
"외부 함수가 호출될 때, 각 실제 인자는 :attr:`argtypes` 튜플의 항목의 :meth:`from_param` 클래스 "
"메서드에 전달됩니다. 이 메서드는 실제 인자를 외부 함수가 받아들이는 객체에 맞출 수 있습니다. 예를 들어, "
":attr:`argtypes` 튜플의 :class:`c_char_p` 항목은 ctypes 변환 규칙을 사용하여 인자로 전달된 "
"문자열을 바이트열 객체로 변환합니다."

#: ../../library/ctypes.rst:1671
#, fuzzy
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes "
"types, but each item must have a :meth:`~_CData.from_param` method which "
"returns a value usable as argument (integer, string, ctypes instance).  "
"This allows defining adapters that can adapt custom objects as function "
"parameters."
msgstr ""
"새로운 기능: 이제 ctypes 형이 아닌 항목을 argtypes에 넣을 수 있습니다. 하지만 각 항목에는 인자로 사용할 수 있는 "
"값(정수, 문자열, ctypes 인스턴스)을 반환하는 :meth:`from_param` 메서드가 있어야 합니다. 이를 통해 사용자 "
"정의 객체를 함수 매개 변수로 맞출 수 있는 어댑터를 정의 할 수 있습니다."

#: ../../library/ctypes.rst:1678
msgid ""
"Assign a Python function or another callable to this attribute. The "
"callable will be called with three or more arguments:"
msgstr "이 어트리뷰트에 파이썬 함수나 다른 콜러블을 대입합니다. 콜러블은 3개 이상의 인자로 호출됩니다:"

#: ../../library/ctypes.rst:1685
#, fuzzy
msgid ""
"*result* is what the foreign function returns, as specified by the "
":attr:`!restype` attribute."
msgstr "*result*\\는 :attr:`restype` 어트리뷰트에 지정된 대로 외부 함수가 반환하는 것입니다."

#: ../../library/ctypes.rst:1688
msgid ""
"*func* is the foreign function object itself, this allows reusing the "
"same callable object to check or post process the results of several "
"functions."
msgstr ""
"*func*\\는 외부 함수 객체 자체이며, 같은 콜러블 객체를 재사용하여 여러 함수의 결과를 확인하거나 사후 처리할 수 있도록 "
"합니다."

#: ../../library/ctypes.rst:1692
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the"
" function call, this allows specializing the behavior on the arguments "
"used."
msgstr ""
"*arguments*\\는 원래 함수 호출에 전달된 매개 변수를 포함하는 튜플입니다. 사용된 인자에 따라 동작을 특수화할 수 있도록"
" 합니다."

#: ../../library/ctypes.rst:1696
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an "
"exception if the foreign function call failed."
msgstr ""
"이 함수가 반환하는 객체는 외부 함수 호출에서 반환되지만, 결괏값을 확인하고 외부 함수 호출이 실패하면 예외를 발생시킬 수도 "
"있습니다."

#: ../../library/ctypes.rst:1703
msgid ""
"This exception is raised when a foreign function call cannot convert one "
"of the passed arguments."
msgstr "외부 함수 호출이 전달된 인자 중 하나를 변환할 수 없을 때 발생하는 예외."

#: ../../library/ctypes.rst:1707 ../../library/ctypes.rst:1709
#, fuzzy
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced "
"with a suitable Python exception. Further, an auditing event "
"``ctypes.set_exception`` with argument ``code`` will be raised, allowing "
"an audit hook to replace the exception with its own."
msgstr ""
"윈도우에서 외부 함수 호출이 시스템 예외(예를 들어, 액세스 위반으로 인해)를 발생시키면, 이를 포착하여 적합한 파이썬 예외로 "
"대체합니다. 또한, 인자 ``code``\\로 감사 이벤트 ``ctypes.seh_exception``\\를 발생 시켜, 감사 훅이"
" 예외를 자신의 것으로 대체할 수 있도록 합니다."

#: ../../library/ctypes.rst:1715 ../../library/ctypes.rst:1717
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""
"외부 함수 호출을 일으키는 일부 방법은 인자 ``function pointer``\\와 ``arguments``\\로 감사 이벤트 "
"``ctypes.call_function``\\를 발생시킬 수 있습니다."

#: ../../library/ctypes.rst:1723
msgid "Function prototypes"
msgstr "함수 프로토타입"

#: ../../library/ctypes.rst:1725
msgid ""
"Foreign functions can also be created by instantiating function "
"prototypes. Function prototypes are similar to function prototypes in C; "
"they describe a function (return type, argument types, calling "
"convention) without defining an implementation.  The factory functions "
"must be called with the desired result type and the argument types of the"
" function, and can be used as decorator factories, and as such, be "
"applied to functions through the ``@wrapper`` syntax. See :ref:`ctypes-"
"callback-functions` for examples."
msgstr ""
"함수 프로토타입의 인스턴스를 만들어서 외부 함수를 만들 수도 있습니다. 함수 프로토타입은 C의 함수 프로토타입과 비슷합니다; 구현을"
" 정의하지 않고 함수(반환형, 인자형, 호출 규칙)를 설명합니다. 팩토리 함수는 원하는 결과형과 함수의 인자형들로 호출되어야 하며,"
" 데코레이터 팩토리로 사용되어 ``@wrapper`` 문법을 통해 함수에 적용될 수 있습니다. 예제는 :ref:`ctypes-"
"callback-functions`\\를 참조하십시오."

#: ../../library/ctypes.rst:1736
msgid ""
"The returned function prototype creates functions that use the standard C"
" calling convention.  The function will release the GIL during the call."
"  If *use_errno* is set to true, the ctypes private copy of the system "
":data:`errno` variable is exchanged with the real :data:`errno` value "
"before and after the call; *use_last_error* does the same for the Windows"
" error code."
msgstr ""
"반환된 함수 프로토타입은 표준 C 호출 규칙을 사용하는 함수를 만듭니다. 이 함수는 호출 중에 GIL을 해제합니다. "
"*use_errno*\\를 참으로 설정하면, 시스템 :data:`errno` 변수의 ctypes 내부 복사본이 호출 전후에 실제 "
":data:`errno` 값과 교환됩니다; *use_last_error*\\는 윈도우 에러 코드에 대해 같은 일을 합니다."

#: ../../library/ctypes.rst:1746
#, fuzzy
msgid ""
"The returned function prototype creates functions that use the "
"``stdcall`` calling convention.  The function will release the GIL during"
" the call.  *use_errno* and *use_last_error* have the same meaning as "
"above."
msgstr ""
"윈도우 전용: 반환된 함수 프로토타입은 ``stdcall`` 호출 규칙을 사용하는 함수를 만듭니다. 단 "
":func:`WINFUNCTYPE`\\이 :func:`CFUNCTYPE`\\과 같은 윈도우 CE는 예외입니다. 이 함수는 호출 중에"
" GIL을 해제합니다. *use_errno* 와 *use_last_error*\\는 위에서와 같은 의미가 있습니다."

#: ../../library/ctypes.rst:1756
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the "
"call."
msgstr "반환된 함수 프로토타입은 파이썬 호출 규칙을 사용하는 함수를 만듭니다. 이 함수는 호출 도중 GIL을 해제하지 *않습니다*."

#: ../../library/ctypes.rst:1759
msgid ""
"Function prototypes created by these factory functions can be "
"instantiated in different ways, depending on the type and number of the "
"parameters in the call:"
msgstr "이러한 팩토리 함수로 만들어진 함수 프로토타입은 호출의 매개 변수 형과 수에 따라 다른 방법으로 인스턴스를 만들 수 있습니다:"

#: ../../library/ctypes.rst:1766
msgid ""
"Returns a foreign function at the specified address which must be an "
"integer."
msgstr "지정된 정수 주소에 있는 외부 함수를 반환합니다."

#: ../../library/ctypes.rst:1773
msgid ""
"Create a C callable function (a callback function) from a Python "
"*callable*."
msgstr "파이썬 *callable*\\로 C 호출 가능 함수(콜백 함수)를 만듭니다."

#: ../../library/ctypes.rst:1780
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must"
" be a 2-tuple ``(name_or_ordinal, library)``. The first item is the name "
"of the exported function as string, or the ordinal of the exported "
"function as small integer.  The second item is the shared library "
"instance."
msgstr ""
"공유 라이브러리가 내보낸 외부 함수를 반환합니다. *func_spec*\\은 2-튜플 ``(name_or_ordinal, "
"library)`` 여야 합니다. 첫 번째 항목은 내보낸 함수의 문자열 이름이거나, 작은 정수로 표현된 내보낸 함수의 "
"서수(ordinal)입니다. 두 번째 항목은 공유 라이브러리 인스턴스입니다."

#: ../../library/ctypes.rst:1790
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is "
"the index into the virtual function table, a small non-negative integer. "
"*name* is name of the COM method. *iid* is an optional pointer to the "
"interface identifier which is used in extended error reporting."
msgstr ""
"COM 메서드를 호출할 외부 함수를 반환합니다. *vtbl_index*\\는 가상 함수 테이블에 대한 인덱스이며, 작은 음이 아닌 "
"정수입니다. *name*\\은 COM 메서드의 이름입니다. *iid*\\는 확장 에러 보고에 사용되는 인터페이스 식별자를 가리키는 "
"선택적 포인터입니다."

#: ../../library/ctypes.rst:1795
#, fuzzy
msgid ""
"COM methods use a special calling convention: They require a pointer to "
"the COM interface as first argument, in addition to those parameters that"
" are specified in the :attr:`!argtypes` tuple."
msgstr ""
"COM 메서드는 특별한 호출 규칙을 사용합니다: :attr:`argtypes` 튜플에 지정된 매개 변수 외에, 첫 번째 인자로 "
"COM 인터페이스에 대한 포인터가 필요합니다."

#: ../../library/ctypes.rst:1799
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers "
"with much more functionality than the features described above."
msgstr "선택적 *paramflags* 매개 변수는 위에 설명된 기능보다 훨씬 많은 기능을 갖는 외부 함수 래퍼를 만듭니다."

#: ../../library/ctypes.rst:1802
#, fuzzy
msgid ""
"*paramflags* must be a tuple of the same length as "
":attr:`~_CFuncPtr.argtypes`."
msgstr "*paramflags*\\는 :attr:`argtypes`\\와 같은 길이의 튜플이어야 합니다."

#: ../../library/ctypes.rst:1804
msgid ""
"Each item in this tuple contains further information about a parameter, "
"it must be a tuple containing one, two, or three items."
msgstr "이 튜플의 각 항목에는 매개 변수에 대한 추가 정보가 들어 있으며, 한 개, 두 개 또는 세 개의 항목이 들어있는 튜플이어야 합니다."

#: ../../library/ctypes.rst:1807
msgid ""
"The first item is an integer containing a combination of direction flags "
"for the parameter:"
msgstr "첫 번째 항목은 매개 변수의 방향 플래그 조합을 포함하는 정수입니다:"

#: ../../library/ctypes.rst:1810
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1811
msgid "Specifies an input parameter to the function."
msgstr "함수에 대한 입력 매개 변수를 지정합니다."

#: ../../library/ctypes.rst:1813
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1814
msgid "Output parameter.  The foreign function fills in a value."
msgstr "출력 매개 변수. 외부 함수가 값을 채웁니다."

#: ../../library/ctypes.rst:1816
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1817
msgid "Input parameter which defaults to the integer zero."
msgstr "기본값이 정수 0인 입력 매개 변수."

#: ../../library/ctypes.rst:1819
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr "선택적인 두 번째 항목은 문자열 매개 변수 이름입니다. 이것이 지정되면, 이름있는 매개 변수로 외부 함수를 호출할 수 있습니다."

#: ../../library/ctypes.rst:1822
msgid "The optional third item is the default value for this parameter."
msgstr "선택적 세 번째 항목은 이 매개 변수의 기본값입니다."

#: ../../library/ctypes.rst:1825
#, fuzzy
msgid ""
"The following example demonstrates how to wrap the Windows "
"``MessageBoxW`` function so that it supports default parameters and named"
" arguments. The C declaration from the windows header file is this::"
msgstr ""
"이 예제는 기본값이 있는 매개 변수와 이름있는 인자를 지원하도록 윈도우 ``MessageBoxW`` 함수를 래핑하는 방법을 "
"보여줍니다. 윈도우 헤더 파일의 C 선언은 다음과 같습니다::"

#: ../../library/ctypes.rst:1829
msgid ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"
msgstr ""

#: ../../library/ctypes.rst:1836 ../../library/ctypes.rst:1859
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "다음은 :mod:`ctypes`\\로 래핑하는 방법입니다::"

#: ../../library/ctypes.rst:1838
msgid ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, "
"\"caption\", \"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)"
msgstr ""

#: ../../library/ctypes.rst:1844
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr "이제 ``MessageBox`` 외부 함수를 다음과 같이 호출할 수 있습니다.::"

#: ../../library/ctypes.rst:1846
msgid ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Spam, spam, spam\")\n"
">>> MessageBox(flags=2, text=\"foo bar\")"
msgstr ""

#: ../../library/ctypes.rst:1850
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window"
" by copying them into ``RECT`` structure that the caller has to supply.  "
"Here is the C declaration::"
msgstr ""
"두 번째 예제는 출력 매개 변수를 보여줍니다. win32 ``GetWindowRect`` 함수는 지정된 창의 크기를 조회하는데, "
"호출자가 제공해야 하는 ``RECT`` 구조체로 복사합니다. 다음은 C 선언입니다::"

#: ../../library/ctypes.rst:1854
msgid ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"
msgstr ""

#: ../../library/ctypes.rst:1861
msgid ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1868
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the "
"output parameter values when there are more than one, so the "
"GetWindowRect function now returns a RECT instance, when called."
msgstr ""
"출력 매개 변수가 있는 함수는, 하나뿐이면 자동으로 출력 매개 변숫값을 반환하고, 여러 개면 출력 매개 변숫값을 포함하는 튜플을 "
"반환하므로, GetWindowRect 함수는 이제 호출되면 RECT 인스턴스를 반환합니다."

#: ../../library/ctypes.rst:1873
#, fuzzy
msgid ""
"Output parameters can be combined with the :attr:`~_CFuncPtr.errcheck` "
"protocol to do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr ""
"출력 매개 변수는 :attr:`errcheck` 프로토콜과 결합하여 추가적인 출력 처리와 에러 검사를 수행할 수 있습니다. "
"win32 ``GetWindowRect`` api 함수는 성공이나 실패를 알리기 위해 ``BOOL``\\을 반환하므로, 이 함수는 "
"에러 검사를 수행하고 API 호출이 실패했을 때 예외를 발생시킬 수 있습니다::"

#: ../../library/ctypes.rst:1878
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     return args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1886
#, fuzzy
msgid ""
"If the :attr:`~_CFuncPtr.errcheck` function returns the argument tuple it"
" receives unchanged, :mod:`ctypes` continues the normal processing it "
"does on the output parameters.  If you want to return a tuple of window "
"coordinates instead of a ``RECT`` instance, you can retrieve the fields "
"in the function and return them instead, the normal processing will no "
"longer take place::"
msgstr ""
":attr:`errcheck` 함수가 수신한 인자 튜플을 변경 없이 반환하면, :mod:`ctypes`\\는 출력 매개 변수에 "
"수행하는 일반 처리를 계속합니다. ``RECT`` 인스턴스 대신 창 좌표의 튜플을 반환하려면, 함수에서 필드를 조회해서 대신 "
"반환하면 됩니다, 이때는 일반 처리가 더는 수행되지 않습니다::"

#: ../../library/ctypes.rst:1892
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     rc = args[1]\n"
"...     return rc.left, rc.top, rc.bottom, rc.right\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:1905
msgid "Utility functions"
msgstr "유틸리티 함수"

#: ../../library/ctypes.rst:1909
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr "메모리 버퍼의 주소를 정수로 반환합니다. *obj*\\는 ctypes 형의 인스턴스여야 합니다."

#: ../../library/ctypes.rst:1912
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr "인자 ``obj``\\로 :ref:`감사 이벤트 <auditing>` ``ctypes.addressof``\\를 발생시킵니다."

#: ../../library/ctypes.rst:1917
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must "
"be a ctypes type or instance."
msgstr "ctypes 형의 정렬 요구 사항을 반환합니다. *obj_or_type*\\는 ctypes 형이나 인스턴스여야 합니다."

#: ../../library/ctypes.rst:1923
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will"
" be added to the internal pointer value."
msgstr ""
"*obj*\\에 대한 경량 포인터를 반환합니다. *obj*\\는 ctypes 형의 인스턴스여야 합니다. *offset*\\의 "
"기본값은 0이며, 내부 포인터 값에 더해질 정수여야 합니다."

#: ../../library/ctypes.rst:1927
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)``\\는 이 C 코드에 해당합니다::"

#: ../../library/ctypes.rst:1929
msgid "(((char *)&obj) + offset)"
msgstr ""

#: ../../library/ctypes.rst:1931
msgid ""
"The returned object can only be used as a foreign function call "
"parameter. It behaves similar to ``pointer(obj)``, but the construction "
"is a lot faster."
msgstr ""
"반환된 객체는 외부 함수 호출 매개 변수로만 사용할 수 있습니다. ``pointer(obj)``\\와 비슷하게 동작하지만, 훨씬 "
"빨리 만들어집니다."

#: ../../library/ctypes.rst:1937
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  "
"*type* must be a pointer type, and *obj* must be an object that can be "
"interpreted as a pointer."
msgstr ""
"이 함수는 C의 형 변환 연산자와 유사합니다. *obj*\\와 같은 메모리 블록을 가리키는 *type* 형의 새 인스턴스를 "
"반환합니다. *type*\\은 포인터형이어야 하며, *obj*\\는 포인터로 해석될 수 있는 객체여야 합니다."

#: ../../library/ctypes.rst:1945
msgid ""
"This function creates a mutable character buffer. The returned object is "
"a ctypes array of :class:`c_char`."
msgstr "이 함수는 가변 문자 버퍼를 만듭니다. 반환된 객체는 :class:`c_char`\\의 ctypes 배열입니다."

#: ../../library/ctypes.rst:1948
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, "
"or a bytes object which will be used to initialize the array items."
msgstr "*init_or_size*\\는 배열의 크기를 지정하는 정수거나 배열 항목을 초기화하는 데 사용될 바이트열 객체여야 합니다."

#: ../../library/ctypes.rst:1951
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a "
"NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the bytes "
"should not be used."
msgstr ""
"바이트열 객체가 첫 번째 인자로 지정되면, 버퍼의 길이는 이 객체의 길이보다 한 항목만큼 길어져서, 배열의 마지막 요소가 NUL "
"종료 문자가 됩니다. 두 번째 인자로 정수를 전달하면 바이트열의 길이를 사용하지 않고 배열의 크기를 지정할 수 있습니다."

#: ../../library/ctypes.rst:1956
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``ctypes.create_string_buffer`` with arguments ``init``, ``size``."
msgstr ""
"``init``, ``size`` 인자로 :ref:`감사 이벤트 <auditing>` "
"``ctypes.create_string_buffer``\\를 발생시킵니다."

#: ../../library/ctypes.rst:1961
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr "이 함수는 가변 유니코드 문자 버퍼를 만듭니다. 반환된 객체는 :class:`c_wchar`\\의 ctypes 배열입니다."

#: ../../library/ctypes.rst:1964
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, "
"or a string which will be used to initialize the array items."
msgstr "*init_or_size*\\는 배열의 크기를 지정하는 정수거나 배열 항목을 초기화하는 데 사용될 문자열이어야 합니다."

#: ../../library/ctypes.rst:1967
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the "
"array is a NUL termination character. An integer can be passed as second "
"argument which allows specifying the size of the array if the length of "
"the string should not be used."
msgstr ""
"문자열이 첫 번째 인자로 지정되면, 버퍼의 길이는 문자열의 길이보다 한 항목만큼 길어져서, 배열의 마지막 요소가 NUL 종료 문자가"
" 됩니다. 두 번째 인자로 정수를 전달하면 문자열의 길이를 사용하지 않고 배열의 크기를 지정할 수 있습니다."

#: ../../library/ctypes.rst:1973
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``ctypes.create_unicode_buffer`` with arguments ``init``, ``size``."
msgstr ""
"``init``, ``size`` 인자로 :ref:`감사 이벤트 <auditing>` "
"``ctypes.create_unicode_buffer``\\를 발생시킵니다."

#: ../../library/ctypes.rst:1978
#, fuzzy
msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllCanUnloadNow function that the "
"_ctypes extension dll exports."
msgstr ""
"윈도우 전용: 이 함수는 ctypes로 프로세스 내부(in-process) COM 서버를 구현하게 하는 훅입니다. _ctypes "
"확장 dll이 내보내는 DllCanUnloadNow 함수에서 호출됩니다."

#: ../../library/ctypes.rst:1987
#, fuzzy
msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllGetClassObject function that the "
"``_ctypes`` extension dll exports."
msgstr ""
"윈도우 전용: 이 함수는 ctypes로 프로세스 내부(in-process) COM 서버를 구현하게 하는 훅입니다. "
"``_ctypes`` 확장 dll이 내보내는 DllGetClassObject 함수에서 호출됩니다."

#: ../../library/ctypes.rst:1997
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or "
"version number (this is the form used for the posix linker option "
":option:`!-l`).  If no library can be found, returns ``None``."
msgstr ""
"라이브러리를 찾아서 경로명을 반환하려고 시도합니다. *name*\\은 ``lib`` 같은 접두사, ``.so``, "
"``.dylib`` 또는 버전 번호와 같은 접미사가 없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 "
":option:`!-l`\\에 사용되는 양식입니다). 라이브러리를 찾을 수 없으면 ``None``\\을 반환합니다."

#: ../../library/ctypes.rst:2008
#, fuzzy
msgid ""
"Returns the filename of the VC runtime library used by Python, and by the"
" extension modules.  If the name of the library cannot be determined, "
"``None`` is returned."
msgstr ""
"윈도우 전용: 파이썬과 확장 모듈이 사용하는 VC 런타임 라이브러리의 파일명을 반환합니다. 라이브러리의 이름을 판별할 수 없으면 "
"``None``\\이 반환됩니다."

#: ../../library/ctypes.rst:2012
msgid ""
"If you need to free memory, for example, allocated by an extension module"
" with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"예를 들어, ``free(void *)``\\에 대한 호출로 확장 모듈에 의해 할당된 메모리를 해제해야 하면, 메모리를 할당한 것과"
" 같은 라이브러리에 있는 함수를 사용하는 것이 중요합니다."

#: ../../library/ctypes.rst:2021
#, fuzzy
msgid ""
"Returns a textual description of the error code *code*.  If no error code"
" is specified, the last error code is used by calling the Windows api "
"function GetLastError."
msgstr ""
"윈도우 전용: 에러 코드 *code*\\의 텍스트 설명을 반환합니다. 에러 코드를 지정하지 않으면 윈도우 API 함수 "
"GetLastError를 호출하여 마지막 에러 코드가 사용됩니다."

#: ../../library/ctypes.rst:2030
#, fuzzy
msgid ""
"Returns the last error code set by Windows in the calling thread. This "
"function calls the Windows ``GetLastError()`` function directly, it does "
"not return the ctypes-private copy of the error code."
msgstr ""
"윈도우 전용: 호출 스레드에서 윈도우가 설정한 마지막 에러 코드를 반환합니다. 이 함수는 윈도우 `GetLastError()` "
"함수를 직접 호출합니다. 에러 코드의 ctypes 내부 복사본을 반환하지 않습니다."

#: ../../library/ctypes.rst:2039
msgid ""
"Returns the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread."
msgstr "호출하는 스레드에서 시스템 :data:`errno` 변수의 ctypes 내부 복사본의 현재 값을 반환합니다."

#: ../../library/ctypes.rst:2042
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``ctypes.get_errno``\\를 발생시킵니다."

#: ../../library/ctypes.rst:2046
#, fuzzy
msgid ""
"Returns the current value of the ctypes-private copy of the system "
":data:`!LastError` variable in the calling thread."
msgstr "호출하는 스레드에서 시스템 :data:`errno` 변수의 ctypes 내부 복사본의 현재 값을 반환합니다."

#: ../../library/ctypes.rst:2051
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with"
" no arguments."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``ctypes.get_last_error``\\를 발생시킵니다."

#: ../../library/ctypes.rst:2056
msgid ""
"Same as the standard C memmove library function: copies *count* bytes "
"from *src* to *dst*. *dst* and *src* must be integers or ctypes instances"
" that can be converted to pointers."
msgstr ""
"표준 C memmove 라이브러리 함수와 같습니다: *count* 바이트를 *src*\\에서 *dst*\\로 복사합니다. *dst*"
" 와 *src*\\는 정수이거나 포인터로 변환할 수 있는 ctypes 인스턴스여야 합니다."

#: ../../library/ctypes.rst:2063
msgid ""
"Same as the standard C memset library function: fills the memory block at"
" address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"표준 C memset 라이브러리 함수와 같습니다: 주소 *dst*\\의 메모리 블록을 값 *c*\\의 *count* 바이트로 "
"채웁니다. *dst*\\는 주소를 지정하는 정수거나 ctypes 인스턴스여야 합니다."

#: ../../library/ctypes.rst:2070
#, fuzzy
msgid ""
"Create and return a new ctypes pointer type. Pointer types are cached and"
" reused internally, so calling this function repeatedly is cheap. *type* "
"must be a ctypes type."
msgstr ""
"이 팩토리 함수는 새로운 ctypes 포인터형을 만들고 반환합니다. 포인터형은 캐시 되고 내부적으로 재사용되므로, 이 함수를 "
"반복적으로 호출하는 것은 저렴합니다. *type*\\는 ctypes 형이어야 합니다."

#: ../../library/ctypes.rst:2077
#, fuzzy
msgid ""
"Create a new pointer instance, pointing to *obj*. The returned object is "
"of the type ``POINTER(type(obj))``."
msgstr ""
"이 함수는 *obj*\\를 가리키는 새 포인터 인스턴스를 만듭니다. 반환된 객체는 형 "
"``POINTER(type(obj))``\\입니다."

#: ../../library/ctypes.rst:2080
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign "
"function call, you should use ``byref(obj)`` which is much faster."
msgstr "참고 사항: 객체에 대한 포인터를 단지 외부 함수 호출로 전달하려면 훨씬 빠른 ``byref(obj)``\\를 사용해야 합니다."

#: ../../library/ctypes.rst:2086
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be "
"an instance of a ctypes type.  It is not possible to make the buffer "
"smaller than the native size of the objects type, as given by "
"``sizeof(type(obj))``, but it is possible to enlarge the buffer."
msgstr ""
"이 함수는 *obj*\\의 내부 메모리 버퍼의 크기를 조정합니다. *obj*\\는 ctypes 형의 인스턴스여야 합니다. "
"``sizeof(type(obj))``\\로 주어지는 객체 형의 원래 크기보다 버퍼를 작게 만들 수는 없지만, 버퍼를 확대할 수 "
"있습니다."

#: ../../library/ctypes.rst:2094
msgid ""
"Set the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread to *value* and return the "
"previous value."
msgstr ""
"호출 중인 스레드의 시스템 :data:`errno` 변수의 ctypes 내부 복사본의 현재 값을 *value*\\로 설정하고 이전 "
"값을 반환합니다."

#: ../../library/ctypes.rst:2097
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr "인자 ``errno``\\로 :ref:`감사 이벤트 <auditing>` ``ctypes.set_errno``\\를 발생시킵니다."

#: ../../library/ctypes.rst:2102
#, fuzzy
msgid ""
"Sets the current value of the ctypes-private copy of the system "
":data:`!LastError` variable in the calling thread to *value* and return "
"the previous value."
msgstr ""
"호출 중인 스레드의 시스템 :data:`errno` 변수의 ctypes 내부 복사본의 현재 값을 *value*\\로 설정하고 이전 "
"값을 반환합니다."

#: ../../library/ctypes.rst:2108
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with"
" argument ``error``."
msgstr ""
"인자 ``error``\\로 :ref:`감사 이벤트 <auditing>` ``ctypes.set_last_error``\\를 "
"발생시킵니다."

#: ../../library/ctypes.rst:2113
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. "
"Does the same as the C ``sizeof`` operator."
msgstr "ctypes 형이나 인스턴스 메모리 버퍼의 크기를 바이트 단위로 반환합니다. C ``sizeof`` 연산자와 같은 일을 합니다."

#: ../../library/ctypes.rst:2119
#, fuzzy
msgid ""
"Return the byte string at *void \\*ptr*. If *size* is specified, it is "
"used as size, otherwise the string is assumed to be zero-terminated."
msgstr ""
"이 함수는 메모리 주소 *address*\\에서 시작하는 C 문자열을 바이트열 객체로 반환합니다. size가 지정되면 크기로 "
"사용되며, 그렇지 않으면 문자열은 0으로 종료된다고 가정합니다."

#: ../../library/ctypes.rst:2123
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"인자 ``address``, ``size``\\로 :ref:`감사 이벤트 <auditing>` "
"``ctypes.string_at``\\을 발생시킵니다."

#: ../../library/ctypes.rst:2128
#, fuzzy
msgid ""
"This function is probably the worst-named thing in ctypes. It creates an "
"instance of :exc:`OSError`.  If *code* is not specified, ``GetLastError``"
" is called to determine the error code. If *descr* is not specified, "
":func:`FormatError` is called to get a textual description of the error."
msgstr ""
"윈도우 전용: 이 함수는 아마도 ctypes에서 가장 이름을 잘못 붙인 것입니다. OSError의 인스턴스를 만듭니다. "
"*code*\\를 지정하지 않으면, 에러 코드를 판별하기 위해 ``GetLastError``\\가 호출됩니다. *descr*\\가 "
"지정되지 않으면, 에러에 대한 텍스트 설명을 얻기 위해 :func:`FormatError`\\가 호출됩니다."

#: ../../library/ctypes.rst:2136
#, fuzzy
msgid ""
"An instance of :exc:`WindowsError` used to be created, which is now an "
"alias of :exc:`OSError`."
msgstr ":exc:`WindowsError`\\의 인스턴스를 만들어왔습니다."

#: ../../library/ctypes.rst:2143
#, fuzzy
msgid ""
"Return the wide-character string at *void \\*ptr*. If *size* is "
"specified, it is used as the number of characters of the string, "
"otherwise the string is assumed to be zero-terminated."
msgstr ""
"이 함수는 메모리 주소 *address*\\에서 시작하는 광폭(wide) 문자열을 문자열로 반환합니다. *size*\\가 지정되면,"
" 문자열의 문자 수로 사용되며, 그렇지 않으면 문자열은 0으로 종료된다고 가정합니다."

#: ../../library/ctypes.rst:2148
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"인자 ``address``, ``size``\\로 :ref:`감사 이벤트 <auditing>` "
"``ctypes.wstring_at``\\을 발생시킵니다."

#: ../../library/ctypes.rst:2154
msgid "Data types"
msgstr "데이터형"

#: ../../library/ctypes.rst:2159
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that"
" hold C compatible data; the address of the memory block is returned by "
"the :func:`addressof` helper function. Another instance variable is "
"exposed as :attr:`_objects`; this contains other Python objects that need"
" to be kept alive in case the memory block contains pointers."
msgstr ""
"이 비공개 클래스는 모든 ctypes 데이터형의 공통 베이스 클래스입니다. 무엇보다도, 모든 ctypes 형 인스턴스에는 C 호환 "
"데이터를 보관하는 메모리 블록이 포함됩니다; 메모리 블록의 주소는 :func:`addressof` 도우미 함수에 의해 반환됩니다. "
"다른 인스턴스 변수는 :attr:`_objects`\\로 노출됩니다; 여기에는 메모리 블록에 포인터가 포함되어있을 때, 살려둘 "
"필요가 있는 다른 파이썬 객체가 포함되어 있습니다."

#: ../../library/ctypes.rst:2166
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"ctypes 데이터형의 공통 메서드, 이것들은 모두 클래스 메서드입니다 (정확히 말하면, :term:`메타 클래스 "
"<metaclass>`\\의 메서드입니다):"

#: ../../library/ctypes.rst:2171
msgid ""
"This method returns a ctypes instance that shares the buffer of the "
"*source* object.  The *source* object must support the writeable buffer "
"interface.  The optional *offset* parameter specifies an offset into the "
"source buffer in bytes; the default is zero.  If the source buffer is not"
" large enough a :exc:`ValueError` is raised."
msgstr ""
"이 메서드는 *source* 객체의 버퍼를 공유하는 ctypes 인스턴스를 반환합니다. *source* 객체는 쓰기 가능한 버퍼 "
"인터페이스를 지원해야 합니다. 선택적 *offset* 매개 변수는 source 버퍼의 오프셋을 바이트 단위로 지정합니다; 기본값은 "
"0입니다. source 버퍼가 충분히 크지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/ctypes.rst:2177 ../../library/ctypes.rst:2187
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"인자 ``pointer``, ``size``, ``offset``\\으로 :ref:`감사 이벤트 <auditing>` "
"``ctypes.cdata/buffer``\\를 발생시킵니다."

#: ../../library/ctypes.rst:2181
msgid ""
"This method creates a ctypes instance, copying the buffer from the "
"*source* object buffer which must be readable.  The optional *offset* "
"parameter specifies an offset into the source buffer in bytes; the "
"default is zero.  If the source buffer is not large enough a "
":exc:`ValueError` is raised."
msgstr ""
"이 메서드는 읽을 수 있어야 하는 *source* 객체 버퍼에서 버퍼를 복사하여 ctypes 인스턴스를 만듭니다. 선택적 "
"*offset* 매개 변수는 원본 버퍼의 오프셋을 바이트 단위로 지정합니다. 기본값은 0입니다. 소스 버퍼가 충분히 크지 않으면 "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/ctypes.rst:2191
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr "이 메서드는 정수 *address*\\로 지정된 메모리를 사용하여 ctypes 형 인스턴스를 반환합니다."

#: ../../library/ctypes.rst:2194 ../../library/ctypes.rst:2196
msgid ""
"This method, and others that indirectly call this method, raises an "
":ref:`auditing event <auditing>` ``ctypes.cdata`` with argument "
"``address``."
msgstr ""
"이 메서드와 이 메서드를 간접적으로 호출하는 다른 것들은 인자 ``address``\\로 :ref:`감사 이벤트 "
"<auditing>` ``ctypes.cdata``\\를 발생시킵니다."

#: ../../library/ctypes.rst:2202
#, fuzzy
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`~_CFuncPtr.argtypes` tuple; it must return an "
"object that can be used as a function call parameter."
msgstr ""
"이 메서드는 *obj*\\를 ctypes 형에게 맞게 조정합니다. 형이 외부 함수의 :attr:`argtypes` 튜플에 존재할 "
"때, 외부 함수 호출에 사용된 실제 객체로 호출됩니다; 함수 호출 매개 변수로 사용할 수 있는 객체를 반환 해야 합니다."

#: ../../library/ctypes.rst:2207
msgid ""
"All ctypes data types have a default implementation of this classmethod "
"that normally returns *obj* if that is an instance of the type.  Some "
"types accept other objects as well."
msgstr ""
"모든 ctypes 데이터형은 이 클래스 메서드의 기본 구현을 갖는데, *obj* 가 이 형의 인스턴스면 *obj* 를 반환합니다. "
"일부 형은 다른 객체도 허용합니다."

#: ../../library/ctypes.rst:2213
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"이 메서드는 공유 라이브러리가 내보낸 ctypes 형 인스턴스를 반환합니다. *name*\\은 데이터를 내보내는 심볼의 이름이고, "
"*library*\\는 로드된 공유 라이브러리입니다."

#: ../../library/ctypes.rst:2217
msgid "Common instance variables of ctypes data types:"
msgstr "ctypes 데이터형의 공통 인스턴스 변수:"

#: ../../library/ctypes.rst:2221
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain,"
" instead they share part of the memory block of a base object.  The "
":attr:`_b_base_` read-only member is the root ctypes object that owns the"
" memory block."
msgstr ""
"때로 ctypes 데이터 인스턴스는 포함하는 메모리 블록을 소유하지 않고, 베이스 객체의 메모리 블록의 일부를 공유합니다. "
":attr:`_b_base_` 읽기 전용 멤버는 메모리 블록을 소유한 루트 ctypes 객체입니다."

#: ../../library/ctypes.rst:2228
msgid ""
"This read-only variable is true when the ctypes data instance has "
"allocated the memory block itself, false otherwise."
msgstr "이 읽기 전용 변수는 ctypes 데이터 인스턴스가 메모리 블록을 스스로 할당했을 때 참이고, 그렇지 않으면 거짓입니다."

#: ../../library/ctypes.rst:2233
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept "
"valid.  This object is only exposed for debugging; never modify the "
"contents of this dictionary."
msgstr ""
"이 멤버는 ``None`` 이거나 메모리 블록 내용이 계속 유효하도록 유지되어야 하는 파이썬 객체를 포함하는 딕셔너리입니다. 이 "
"객체는 디버깅을 위해서만 노출됩니다; 이 딕셔너리의 내용을 수정하지 마십시오."

#: ../../library/ctypes.rst:2246
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of "
"the fundamental ctypes data types.  :class:`_SimpleCData` is a subclass "
"of :class:`_CData`, so it inherits their methods and attributes. ctypes "
"data types that are not and do not contain pointers can now be pickled."
msgstr ""
"이 비공개 클래스는 모든 기본 ctypes 데이터형의 베이스 클래스입니다. 여기에는 기본 ctypes 데이터형의 공통 어트리뷰트가 "
"들어 있으므로 여기에서 언급합니다. :class:`_SimpleCData`\\는 :class:`_CData`\\의 서브 "
"클래스이므로, 메서드와 어트리뷰트를 상속받습니다. 포인터가 아니고 포인터를 포함하지 않는 ctypes 데이터형을 이제 피클 할 수 "
"있습니다."

#: ../../library/ctypes.rst:2252
msgid "Instances have a single attribute:"
msgstr "인스턴스에는 어트리뷰트가 하나 있습니다:"

#: ../../library/ctypes.rst:2256
msgid ""
"This attribute contains the actual value of the instance. For integer and"
" pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a "
"Python bytes object or string."
msgstr ""
"이 어트리뷰트는 인스턴스의 실제 값을 포함합니다. 정수형과 포인터형에서는 정수고, 문자형에서는 단일 문자 바이트열 객체나 "
"문자열이고, 문자 포인터형에서는 파이썬 바이트열 객체나 문자열입니다."

#: ../../library/ctypes.rst:2261
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually"
" a new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"ctypes 인스턴스에서 ``value`` 어트리뷰트를 조회하면, 대개 매번 새 객체가 반환됩니다. :mod:`ctypes`\\는 "
"원래의 객체 반환을 구현하지 *않습니다*. 항상 새로운 객체가 만들어집니다. 다른 모든 ctypes 객체 인스턴스에서도 "
"마찬가지입니다."

#: ../../library/ctypes.rst:2267
#, fuzzy
msgid ""
"Fundamental data types, when returned as foreign function call results, "
"or, for example, by retrieving structure field members or array items, "
"are transparently converted to native Python types.  In other words, if a"
" foreign function has a :attr:`~_CFuncPtr.restype` of :class:`c_char_p`, "
"you will always receive a Python bytes object, *not* a :class:`c_char_p` "
"instance."
msgstr ""
"기본 데이터형은, 외부 함수 호출 결과로 반환되거나 (예를 들어) 구조체 필드 멤버나 배열 항목을 꺼낼 때, 원시(native) "
"파이썬 형으로 투명하게 변환됩니다. 즉, 외부 함수가 :class:`c_char_p`\\인 :attr:`restype`\\을 "
"가지면, 항상 :class:`c_char_p` 인스턴스가 *아니라* 파이썬 바이트열 객체를 받습니다."

#: ../../library/ctypes.rst:2275
#, fuzzy
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, "
"if a foreign functions :attr:`!restype` is a subclass of "
":class:`c_void_p`, you will receive an instance of this subclass from the"
" function call. Of course, you can get the value of the pointer by "
"accessing the ``value`` attribute."
msgstr ""
"기본 데이터형의 서브 클래스는 이 동작을 상속하지 *않습니다*. 따라서 외부 함수의 :attr:`restype`\\가 "
":class:`c_void_p`\\의 서브 클래스면, 함수 호출에서 이 서브 클래스의 인스턴스를 받게 됩니다. 물론, "
"``value`` 어트리뷰트에 액세스해서 포인터 값을 가져올 수 있습니다."

#: ../../library/ctypes.rst:2280
msgid "These are the fundamental ctypes data types:"
msgstr "다음은 기본 ctypes 데이터형입니다:"

#: ../../library/ctypes.rst:2284
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value"
" as small integer.  The constructor accepts an optional integer "
"initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed char` 데이터형을 나타내고, 값을 작은 정수로 해석합니다. 생성자는 선택적 정수 초기화자를 "
"받아들입니다; 오버플로 검사는 수행되지 않습니다."

#: ../../library/ctypes.rst:2291
#, fuzzy
msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"C :c:type:`char` 데이터형을 나타내고, 값을 단일 문자로 해석합니다. 생성자는 선택적 문자열 초기화자를 받아들입니다, "
"문자열의 길이는 정확히 한 문자여야 합니다."

#: ../../library/ctypes.rst:2298
#, fuzzy
msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point "
"to binary data, ``POINTER(c_char)`` must be used.  The constructor "
"accepts an integer address, or a bytes object."
msgstr ""
"0으로 끝나는 문자열을 가리킬 때, C :c:type:`char *` 데이터형을 나타냅니다. 바이너리 데이터를 가리킬 수도 있는 "
"일반 문자 포인터를 위해서는, ``POINTER(c_char)``\\를 사용해야 합니다. 생성자는 정수 주소나 바이트열 객체를 "
"받아들입니다."

#: ../../library/ctypes.rst:2306
#, fuzzy
msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`double` 데이터형을 나타냅니다. 생성자는 선택적 float 초기화자를 받아들입니다."

#: ../../library/ctypes.rst:2312
#, fuzzy
msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts"
" an optional float initializer.  On platforms where ``sizeof(long double)"
" == sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"C :c:type:`long double` 데이터형을 나타냅니다. 생성자는 선택적 float 초기화자를 받아들입니다. "
"``sizeof(long double) == sizeof(double)``\\인 플랫폼에서 :class:`c_double`\\의 "
"별칭입니다."

#: ../../library/ctypes.rst:2318
#, fuzzy
msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`float` 데이터형을 나타냅니다. 생성자는 선택적 float 초기화자를 받아들입니다."

#: ../../library/ctypes.rst:2324
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On "
"platforms where ``sizeof(int) == sizeof(long)`` it is an alias to "
":class:`c_long`."
msgstr ""
"C :c:type:`signed int` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다. 오버플로 검사는 "
"수행되지 않습니다. ``sizeof(int) == sizeof(long)``\\인 플랫폼에서 :class:`c_long`\\의 "
"별칭입니다."

#: ../../library/ctypes.rst:2331
#, fuzzy
msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_byte`."
msgstr "C 8비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_byte`\\의 별칭입니다."

#: ../../library/ctypes.rst:2337
#, fuzzy
msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr "C 16비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_short`\\의 별칭입니다."

#: ../../library/ctypes.rst:2343
#, fuzzy
msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr "C 32비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_int`\\의 별칭입니다."

#: ../../library/ctypes.rst:2349
#, fuzzy
msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr "C 64비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_longlong`\\의 별칭입니다."

#: ../../library/ctypes.rst:2355
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts"
" an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다."

#: ../../library/ctypes.rst:2361
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 "
"검사는 수행되지 않습니다."

#: ../../library/ctypes.rst:2367
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed short` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다."

#: ../../library/ctypes.rst:2373
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "C :c:type:`size_t` 데이터형을 나타냅니다."

#: ../../library/ctypes.rst:2378
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "C :c:type:`ssize_t` 데이터형을 나타냅니다."

#: ../../library/ctypes.rst:2385
#, fuzzy
msgid "Represents the C :c:type:`time_t` datatype."
msgstr "C :c:type:`size_t` 데이터형을 나타냅니다."

#: ../../library/ctypes.rst:2392
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the "
"value as small integer.  The constructor accepts an optional integer "
"initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned char` 데이터형을 나타내고, 값을 작은 정수로 해석합니다. 생성자는 선택적 정수 초기화자를 "
"받아들입니다; 오버플로 검사는 수행되지 않습니다."

#: ../../library/ctypes.rst:2399
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done.  "
"On platforms where ``sizeof(int) == sizeof(long)`` it is an alias for "
":class:`c_ulong`."
msgstr ""
"C :c:type:`unsigned int` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다. ``sizeof(int) == sizeof(long)``\\인 플랫폼에서 :class:`c_ulong`\\의 "
"별칭입니다."

#: ../../library/ctypes.rst:2406
#, fuzzy
msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  Usually an alias"
" for :class:`c_ubyte`."
msgstr "C 8비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_ubyte`\\의 별칭입니다."

#: ../../library/ctypes.rst:2412
#, fuzzy
msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an "
"alias for :class:`c_ushort`."
msgstr "C 16비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_ushort`\\의 별칭입니다."

#: ../../library/ctypes.rst:2418
#, fuzzy
msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an "
"alias for :class:`c_uint`."
msgstr "C 32비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_uint`\\의 별칭입니다."

#: ../../library/ctypes.rst:2424
#, fuzzy
msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an "
"alias for :class:`c_ulonglong`."
msgstr ""
"C 64비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_ulonglong`\\의 "
"별칭입니다."

#: ../../library/ctypes.rst:2430
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는"
" 수행되지 않습니다."

#: ../../library/ctypes.rst:2436
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; "
"오버플로 검사는 수행되지 않습니다."

#: ../../library/ctypes.rst:2442
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned short` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 "
"검사는 수행되지 않습니다."

#: ../../library/ctypes.rst:2448
#, fuzzy
msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr "C :c:type:`void *` 형을 나타냅니다. 값은 정수로 표시됩니다. 생성자는 선택적 정수 초기화자를 받아들입니다."

#: ../../library/ctypes.rst:2454
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as "
"a single character unicode string.  The constructor accepts an optional "
"string initializer, the length of the string must be exactly one "
"character."
msgstr ""
"C :c:type:`wchar_t` 데이터형을 나타내고, 값을 단일 문자 유니코드 문자열로 해석합니다. 생성자는 선택적 문자열 "
"초기화자를 받아들입니다, 문자열의 길이는 정확히 한 문자여야 합니다."

#: ../../library/ctypes.rst:2461
#, fuzzy
msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to"
" a zero-terminated wide character string.  The constructor accepts an "
"integer address, or a string."
msgstr ""
"0으로 끝나는 광폭 문자 문자열을 가리키는 포인터여야 하는 C :c:type:`wchar_t *` 데이터형을 나타냅니다. 생성자는 "
"정수 주소나 문자열을 받아들입니다."

#: ../../library/ctypes.rst:2468
#, fuzzy
msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool`"
" from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"C :c:type:`bool` 데이터형을 나타냅니다 (더욱 정확하게, C99의 :c:type:`_Bool`). 이 값은 "
"``True``\\나 ``False`` 일 수 있고, 생성자는 논릿값이 있는 임의의 객체를 받아들입니다."

#: ../../library/ctypes.rst:2475
#, fuzzy
msgid ""
"Represents a :c:type:`!HRESULT` value, which contains success or error "
"information for a function or method call."
msgstr "윈도우 전용: 함수 또는 메서드 호출에 대한 성공 또는 에러 정보가 들어있는, :c:type:`HRESULT` 값을 나타냅니다."

#: ../../library/ctypes.rst:2483
#, fuzzy
msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"C :c:type:`PyObject *` 데이터형을 나타냅니다. 인자 없이 이것을 호출하면 ``NULL`` "
":c:type:`PyObject *` 포인터가 만들어집니다."

#: ../../library/ctypes.rst:2486
#, fuzzy
msgid ""
"The :mod:`!ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`!HWND`, :c:type:`!WPARAM`, or "
":c:type:`!DWORD`. Some useful structures like :c:type:`!MSG` or "
":c:type:`!RECT` are also defined."
msgstr ""
":mod:`ctypes.wintypes` 모듈은 다른 윈도우 특정 데이터형을 제공합니다, 예를 들어, :c:type:`HWND`, "
":c:type:`WPARAM` 또는 :c:type:`DWORD`. :c:type:`MSG`\\나 :c:type:`RECT`\\와 "
"같은 유용한 구조체도 정의됩니다."

#: ../../library/ctypes.rst:2494
msgid "Structured data types"
msgstr "구조화된 데이터형"

#: ../../library/ctypes.rst:2499
msgid "Abstract base class for unions in native byte order."
msgstr "네이티브 바이트 순서의 공용체를 위한 추상 베이스 클래스."

#: ../../library/ctypes.rst:2504
#, fuzzy
msgid "Abstract base class for unions in *big endian* byte order."
msgstr "*빅엔디안(big endian)* 바이트 순서의 구조체를 위한 추상 베이스 클래스."

#: ../../library/ctypes.rst:2510
#, fuzzy
msgid "Abstract base class for unions in *little endian* byte order."
msgstr "*리틀엔디안(little endian)* 바이트 순서로의 구조체를 위한 추상 베이스 클래스."

#: ../../library/ctypes.rst:2516
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "*빅엔디안(big endian)* 바이트 순서의 구조체를 위한 추상 베이스 클래스."

#: ../../library/ctypes.rst:2521
msgid "Abstract base class for structures in *little endian* byte order."
msgstr "*리틀엔디안(little endian)* 바이트 순서로의 구조체를 위한 추상 베이스 클래스."

#: ../../library/ctypes.rst:2523
#, fuzzy
msgid ""
"Structures and unions with non-native byte order cannot contain pointer "
"type fields, or any other data types containing pointer type fields."
msgstr "네이티브가 아닌 바이트 순서를 갖는 구조체는 포인터형 필드나 포인터형 필드를 포함하는 다른 데이터형을 포함할 수 없습니다."

#: ../../library/ctypes.rst:2529
msgid "Abstract base class for structures in *native* byte order."
msgstr "*네이티브* 바이트 순서의 구조체를 위한 추상 베이스 클래스."

#: ../../library/ctypes.rst:2531
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. "
":mod:`ctypes` will create :term:`descriptor`\\s which allow reading and "
"writing the fields by direct attribute accesses.  These are the"
msgstr ""
"구상 구조체와 공용체 형은 이 형 중 하나를 서브 클래싱하고 적어도 :attr:`_fields_` 클래스 변수를 정의해서 만들어야 "
"합니다. :mod:`ctypes`\\는 직접 어트리뷰트 액세스로 필드를 읽고 쓸 수 있는 :term:`디스크립터 "
"<descriptor>`\\를 만듭니다. 이것들은"

#: ../../library/ctypes.rst:2539
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or "
"3-tuples.  The first item is the name of the field, the second item "
"specifies the type of the field; it can be any ctypes data type."
msgstr ""
"구조체 필드를 정의하는 시퀀스. 항목은 2-튜플이나 3-튜플이어야 합니다. 첫 번째 항목은 필드의 이름이고, 두 번째 항목은 필드의"
" 형을 지정합니다; 모든 ctypes 데이터형이 될 수 있습니다."

#: ../../library/ctypes.rst:2543
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be"
" given.  It must be a small positive integer defining the bit width of "
"the field."
msgstr ""
":class:`c_int`\\와 같은 정수형 필드에서는, 세 번째 선택적 항목을 지정할 수 있습니다. 필드의 비트 폭을 정의하는 "
"작은 양의 정수여야 합니다."

#: ../../library/ctypes.rst:2547
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"필드 이름은 하나의 구조체나 공용체 내에서 고유해야 합니다. 이것은 검사되지 않습니다, 이름이 중복되면 하나의 필드만 액세스할 수 "
"있습니다."

#: ../../library/ctypes.rst:2550
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating"
" data types that directly or indirectly reference themselves::"
msgstr ""
":attr:`_fields_` 클래스 변수를, Structure 서브 클래스를 정의하는 클래스 문 *뒤에서* 정의할 수 있습니다. "
"직접 또는 간접적으로 자신을 참조하는 데이터형을 만들 수 있게 합니다::"

#: ../../library/ctypes.rst:2554
msgid ""
"class List(Structure):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"
msgstr ""

#: ../../library/ctypes.rst:2560
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on "
"it, and so on).  Later assignments to the :attr:`_fields_` class variable"
" will raise an AttributeError."
msgstr ""
"하지만, 형이 처음 사용되기 전에 :attr:`_fields_` 클래스 변수를 정의해야 합니다 (인스턴스가 만들어지고, "
":func:`sizeof`\\가 호출되는 등의 일이 일어납니다). 나중에 :attr:`_fields_` 클래스 변수에 대입하면 "
"AttributeError가 발생합니다."

#: ../../library/ctypes.rst:2565
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit "
"the fields of the base class plus the :attr:`_fields_` defined in the "
"sub-subclass, if any."
msgstr ""
"구조체 형의 서브-서브 클래스를 정의할 수 있습니다. 베이스 클래스의 필드를 상속하고, 여기에 서브-서브 클래스에 정의된 "
":attr:`_fields_`\\의 필드가 추가됩니다."

#: ../../library/ctypes.rst:2572
#, fuzzy
msgid ""
"An optional small integer that allows overriding the alignment of "
"structure fields in the instance.  :attr:`_pack_` must already be defined"
" when :attr:`_fields_` is assigned, otherwise it will have no effect. "
"Setting this attribute to 0 is the same as not setting it at all."
msgstr ""
"인스턴스의 구조체 필드 정렬을 재정의할 수 있는 선택적 작은 정수입니다. :attr:`_fields_`\\가 대입될 때 "
":attr:`_pack_`\\는 이미 정의되어 있어야 합니다. 그렇지 않으면 아무 효과가 없습니다."

#: ../../library/ctypes.rst:2580
msgid ""
"An optional small integer that allows overriding the alignment of the "
"structure when being packed or unpacked to/from memory. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""

#: ../../library/ctypes.rst:2588
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. "
":attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"이름 없는(익명) 필드의 이름을 나열하는 선택적 시퀀스. :attr:`_fields_`\\가 대입될 때 "
":attr:`_anonymous_`\\는 이미 정의되어 있어야 합니다. 그렇지 않으면 아무 효과가 없습니다."

#: ../../library/ctypes.rst:2592
msgid ""
"The fields listed in this variable must be structure or union type "
"fields. :mod:`ctypes` will create descriptors in the structure type that "
"allows accessing the nested fields directly, without the need to create "
"the structure or union field."
msgstr ""
"이 변수에 나열된 필드는 구조체나 공용체 형 필드여야 합니다. :mod:`ctypes`\\는 구조체나 공용체 필드를 만들 필요 "
"없이, 중첩된 필드에 직접 액세스할 수 있는 디스크립터를 구조체 형에 만듭니다."

#: ../../library/ctypes.rst:2597
msgid "Here is an example type (Windows)::"
msgstr "다음은 예제 형입니다 (윈도우)::"

#: ../../library/ctypes.rst:2599
msgid ""
"class _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"class TYPEDESC(Structure):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"
msgstr ""

#: ../../library/ctypes.rst:2610
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field "
"is defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` "
"are equivalent, but the former is faster since it does not need to create"
" a temporary union instance::"
msgstr ""
"``TYPEDESC`` 구조체는 COM 데이터형을 설명합니다. ``vt`` 필드는 공용체 필드 중 어느 것이 유효한지 지정합니다. "
"``u`` 필드가 익명 필드로 정의되었으므로, 이제 TYPEDESC 인스턴스에서 멤버에 직접 액세스할 수 있습니다. "
"``td.lptdesc``\\와 ``td.u.lptdesc``\\는 동등하지만, 앞에 있는 것이 임시 공용체 인스턴스를 만들 필요가"
" 없으므로 더 빠릅니다::"

#: ../../library/ctypes.rst:2617
msgid ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"
msgstr ""

#: ../../library/ctypes.rst:2622
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate "
":attr:`_fields_` variable, the fields specified in this are appended to "
"the fields of the base class."
msgstr ""
"구조체 형의 서브-서브 클래스를 정의할 수 있으며, 베이스 클래스의 필드를 상속합니다. 서브 클래스 정의에 별도의 "
":attr:`_fields_` 변수가 있으면, 여기에 지정된 필드가 베이스 클래스의 필드에 추가됩니다."

#: ../../library/ctypes.rst:2627
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in "
"the same order as they are appear in :attr:`_fields_`.  Keyword arguments"
" in the constructor are interpreted as attribute assignments, so they "
"will initialize :attr:`_fields_` with the same name, or create new "
"attributes for names not present in :attr:`_fields_`."
msgstr ""
"구조체와 공용체 생성자는 위치와 키워드 인자를 모두 받아들입니다. 위치 인자는 :attr:`_fields_`\\에 나타나는 순서대로"
" 멤버 필드를 초기화하는 데 사용됩니다. 생성자의 키워드 인자는 어트리뷰트 대입으로 해석되므로, :attr:`_fields_`\\를"
" 같은 이름으로 초기화하거나, :attr:`_fields_`\\에 없는 이름에 대한 새 어트리뷰트를 만듭니다."

#: ../../library/ctypes.rst:2638
msgid "Arrays and pointers"
msgstr "배열과 포인터"

#: ../../library/ctypes.rst:2642
msgid "Abstract base class for arrays."
msgstr "배열의 추상 베이스 클래스."

#: ../../library/ctypes.rst:2644
#, fuzzy
msgid ""
"The recommended way to create concrete array types is by multiplying any "
":mod:`ctypes` data type with a non-negative integer.  Alternatively, you "
"can subclass this type and define :attr:`_length_` and :attr:`_type_` "
"class variables. Array elements can be read and written using standard "
"subscript and slice accesses; for slice reads, the resulting object is "
"*not* itself an :class:`Array`."
msgstr ""
"구상 배열형을 만드는 데 권장되는 방법은, 임의의 :mod:`ctypes` 데이터형에 양의 정수를 곱하는 것입니다. 또는, 이 형의"
" 서브 클래스를 만들고, :attr:`_length_` 와 :attr:`_type_` 클래스 변수를 정의할 수 있습니다. 배열 "
"요소는 표준 서브 스크립트나 슬라이스 액세스를 사용해서 읽고 쓸 수 있습니다; 슬라이스 읽기의 경우, 결과 객체는 "
":class:`Array`\\가 *아닙니다*."

#: ../../library/ctypes.rst:2654
msgid ""
"A positive integer specifying the number of elements in the array. Out-"
"of-range subscripts result in an :exc:`IndexError`. Will be returned by "
":func:`len`."
msgstr ""
"배열의 요소 수를 지정하는 양의 정수. 범위를 벗어나는 서브 스크립트는 :exc:`IndexError`\\를 일으킵니다. "
":func:`len`\\에 의해 반환됩니다."

#: ../../library/ctypes.rst:2661
msgid "Specifies the type of each element in the array."
msgstr "배열의 각 요소 형을 지정합니다."

#: ../../library/ctypes.rst:2664
msgid ""
"Array subclass constructors accept positional arguments, used to "
"initialize the elements in order."
msgstr "Array 서브 클래스 생성자는 요소를 순서대로 초기화하는 데 사용되는 위치 인자를 받아들입니다."

#: ../../library/ctypes.rst:2669
msgid ""
"Create an array. Equivalent to ``type * length``, where *type* is a "
":mod:`ctypes` data type and *length* an integer."
msgstr ""

#: ../../library/ctypes.rst:2673
msgid ""
"This function is :term:`soft deprecated` in favor of multiplication. "
"There are no plans to remove it."
msgstr ""

#: ../../library/ctypes.rst:2679
msgid "Private, abstract base class for pointers."
msgstr "포인터를 위한 내부 추상 베이스 클래스."

#: ../../library/ctypes.rst:2681
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the "
"type that will be pointed to; this is done automatically by "
":func:`pointer`."
msgstr ""
"구상 포인터형은 가리킬 형으로 :func:`POINTER`\\를 호출해서 만들어집니다; 이것은 :func:`pointer`\\에 "
"의해 자동으로 수행됩니다."

#: ../../library/ctypes.rst:2685
msgid ""
"If a pointer points to an array, its elements can be read and written "
"using standard subscript and slice accesses.  Pointer objects have no "
"size, so :func:`len` will raise :exc:`TypeError`.  Negative subscripts "
"will read from the memory *before* the pointer (as in C), and out-of-"
"range subscripts will probably crash with an access violation (if you're "
"lucky)."
msgstr ""
"포인터가 배열을 가리키면, 그것의 요소는 표준 서브 스크립트 및 슬라이스 액세스를 사용하여 읽고 쓸 수 있습니다. 포인터 객체는 "
"크기가 없으므로, :func:`len`\\는 :exc:`TypeError`\\를 발생시킵니다. 음수 서브 스크립트는 (C처럼) "
"포인터 *앞의* 메모리를 읽을 것이고, 범위를 벗어나는 서브 스크립트는 (운이 좋다면) 액세스 위반으로 인해 충돌을 일으킬 "
"것입니다."

#: ../../library/ctypes.rst:2695
msgid "Specifies the type pointed to."
msgstr "가리키는 형을 지정합니다."

#: ../../library/ctypes.rst:2699
msgid ""
"Returns the object to which to pointer points.  Assigning to this "
"attribute changes the pointer to point to the assigned object."
msgstr "포인터가 가리키는 객체를 반환합니다. 이 어트리뷰트에 대입하면 대입된 객체를 가리키도록 포인터가 변경됩니다."

#~ msgid ""
#~ "This example calls both functions with"
#~ " a ``NULL`` pointer (``None`` should "
#~ "be used as the ``NULL`` pointer)::"
#~ msgstr "이 예는 ``NULL`` 포인터로 두 함수를 호출합니다 (``None``\\을 ``NULL`` 포인터로 사용해야 합니다)::"

#~ msgid ""
#~ "If the interpreter would have been "
#~ "started with :option:`-O`, the sample "
#~ "would have printed ``c_long(1)``, or "
#~ "``c_long(2)`` if :option:`-OO` would have "
#~ "been specified."
#~ msgstr ""
#~ "인터프리터가 :option:`-O`\\로 시작되면, 예는 "
#~ "``c_long(1)``\\를, :option:`-OO`\\가 지정되면 "
#~ "``c_long(2)``\\를 인쇄합니다."

#~ msgid ":exc:`WindowsError` used to be raised."
#~ msgstr ":exc:`WindowsError`\\를 발생시켰었습니다."

#~ msgid ""
#~ "On Windows CE only the standard "
#~ "calling convention is used, for "
#~ "convenience the :class:`WinDLL` and "
#~ ":class:`OleDLL` use the standard calling "
#~ "convention on this platform."
#~ msgstr ""
#~ "윈도우 CE에서는 오직 표준 호출 규칙만 사용됩니다. "
#~ "편의상 :class:`WinDLL` 와 :class:`OleDLL`\\은, 이"
#~ " 플랫폼에서 표준 호출 규칙을 사용합니다."

#~ msgid "Windows only: Creates :class:`WinDLL` instances."
#~ msgstr "윈도우 전용: :class:`WinDLL` 인스턴스를 만듭니다."

#~ msgid "Windows only: Creates :class:`OleDLL` instances."
#~ msgstr "윈도우 전용: :class:`OleDLL` 인스턴스를 만듭니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``ctypes.dlopen`` with argument ``name``."
#~ msgstr ""
#~ "인자 ``name``\\을 사용하여 :ref:`감사 이벤트 "
#~ "<auditing>` ``ctypes.dlopen``\\을 발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``ctypes.dlsym`` with arguments ``library``, "
#~ "``name``."
#~ msgstr "``library``, ``name`` 인자로 감사 이벤트 ``ctypes.dlsym``\\을 발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``ctypes.dlsym/handle`` with arguments ``handle``,"
#~ " ``name``."
#~ msgstr "``handle``, ``name`` 인자로 감사 이벤트 ``ctypes.dlsym/handle``\\을 발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``ctypes.seh_exception`` with argument ``code``."
#~ msgstr "인자 ``code``\\로 감사 이벤트 ``ctypes.seh_exception``\\을 발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``ctypes.call_function`` with arguments "
#~ "``func_pointer``, ``arguments``."
#~ msgstr ""
#~ "``func_pointer``, ``arguments`` 인자로 감사 이벤트 "
#~ "``ctypes.call_function``\\을 발생시킵니다."

#~ msgid ""
#~ "Windows only: returns the current value"
#~ " of the ctypes-private copy of "
#~ "the system :data:`LastError` variable in "
#~ "the calling thread."
#~ msgstr ""
#~ "윈도우 전용: 호출 중인 스레드에서 시스템 "
#~ ":data:`LastError` 변수의 ctypes 내부 복사본의 현재"
#~ " 값을 반환합니다."

#~ msgid ""
#~ "Windows only: set the current value "
#~ "of the ctypes-private copy of the"
#~ " system :data:`LastError` variable in the"
#~ " calling thread to *value* and return"
#~ " the previous value."
#~ msgstr ""
#~ "윈도우 전용: 호출 중인 스레드의 시스템 "
#~ ":data:`LastError` 변수의 ctypes 내부 복사본의 현재"
#~ " 값을 *value*\\로 설정하고 이전 값을 반환합니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``ctypes.cdata`` with argument ``address``."
#~ msgstr "인자 ``address``\\로 :ref:`감사 이벤트 <auditing>` ``ctypes.cdata``\\를 발생시킵니다."

