# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/optparse.rst:2
#, fuzzy
msgid ":mod:`!optparse` --- Parser for command line options"
msgstr ":mod:`optparse` --- 명령 줄 옵션용 구문 분석기"

#: ../../library/optparse.rst:10
msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**소스 코드:** :source:`Lib/optparse.py`"

#: ../../library/optparse.rst:17
msgid "Choosing an argument parsing library"
msgstr ""

#: ../../library/optparse.rst:19
msgid "The standard library includes three argument parsing libraries:"
msgstr ""

#: ../../library/optparse.rst:21
msgid ""
":mod:`getopt`: a module that closely mirrors the procedural C ``getopt`` "
"API. Included in the standard library since before the initial Python 1.0"
" release."
msgstr ""

#: ../../library/optparse.rst:23
msgid ""
":mod:`optparse`: a declarative replacement for ``getopt`` that provides "
"equivalent functionality without requiring each application to implement "
"its own procedural option parsing logic. Included in the standard library"
" since the Python 2.3 release."
msgstr ""

#: ../../library/optparse.rst:27
msgid ""
":mod:`argparse`: a more opinionated alternative to ``optparse`` that "
"provides more functionality by default, at the expense of reduced "
"application flexibility in controlling exactly how arguments are "
"processed. Included in the standard library since the Python 2.7 and "
"Python 3.2 releases."
msgstr ""

#: ../../library/optparse.rst:32
msgid ""
"In the absence of more specific argument parsing design constraints, "
":mod:`argparse` is the recommended choice for implementing command line "
"applications, as it offers the highest level of baseline functionality "
"with the least application level code."
msgstr ""

#: ../../library/optparse.rst:36
msgid ""
":mod:`getopt` is retained almost entirely for backwards compatibility "
"reasons. However, it also serves a niche use case as a tool for "
"prototyping and testing command line argument handling in "
"``getopt``-based C applications."
msgstr ""

#: ../../library/optparse.rst:40
msgid ""
":mod:`optparse` should be considered as an alternative to :mod:`argparse`"
" in the following cases:"
msgstr ""

#: ../../library/optparse.rst:43
msgid ""
"an application is already using :mod:`optparse` and doesn't want to risk "
"the subtle behavioural changes that may arise when migrating to "
":mod:`argparse`"
msgstr ""

#: ../../library/optparse.rst:45
msgid ""
"the application requires additional control over the way options and "
"positional parameters are interleaved on the command line (including the "
"ability to disable the interleaving feature completely)"
msgstr ""

#: ../../library/optparse.rst:48
msgid ""
"the application requires additional control over the incremental parsing "
"of command line elements (while ``argparse`` does support this, the exact"
" way it works in practice is undesirable for some use cases)"
msgstr ""

#: ../../library/optparse.rst:51
msgid ""
"the application requires additional control over the handling of options "
"which accept parameter values that may start with ``-`` (such as "
"delegated options to be passed to invoked subprocesses)"
msgstr ""

#: ../../library/optparse.rst:54
msgid ""
"the application requires some other command line parameter processing "
"behavior which ``argparse`` does not support, but which can be "
"implemented in terms of the lower level interface offered by ``optparse``"
msgstr ""

#: ../../library/optparse.rst:58
msgid ""
"These considerations also mean that :mod:`optparse` is likely to provide "
"a better foundation for library authors writing third party command line "
"argument processing libraries."
msgstr ""

#: ../../library/optparse.rst:62
msgid ""
"As a concrete example, consider the following two command line argument "
"parsing configurations, the first using ``optparse``, and the second "
"using ``argparse``:"
msgstr ""

#: ../../library/optparse.rst:66
msgid ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"
msgstr ""

#: ../../library/optparse.rst:77
msgid ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"
msgstr ""

#: ../../library/optparse.rst:89
msgid ""
"The most obvious difference is that in the ``optparse`` version, the non-"
"option arguments are processed separately by the application after the "
"option processing is complete. In the ``argparse`` version, positional "
"arguments are declared and processed in the same way as the named "
"options."
msgstr ""

#: ../../library/optparse.rst:94
msgid ""
"However, the ``argparse`` version will also handle some parameter "
"combination differently from the way the ``optparse`` version would "
"handle them. For example (amongst other differences):"
msgstr ""

#: ../../library/optparse.rst:98
msgid ""
"supplying ``-o -v`` gives ``output=\"-v\"`` and ``verbose=False`` when "
"using ``optparse``, but a usage error with ``argparse`` (complaining that"
" no value has been supplied for ``-o/--output``, since ``-v`` is "
"interpreted as meaning the verbosity flag)"
msgstr ""

#: ../../library/optparse.rst:102
msgid ""
"similarly, supplying ``-o --`` gives ``output=\"--\"`` and ``args=()`` "
"when using ``optparse``, but a usage error with ``argparse`` (also "
"complaining that no value has been supplied for ``-o/--output``, since "
"``--`` is interpreted as terminating the option processing and treating "
"all remaining values as positional arguments)"
msgstr ""

#: ../../library/optparse.rst:107
msgid ""
"supplying ``-o=foo`` gives ``output=\"=foo\"`` when using ``optparse``, "
"but gives ``output=\"foo\"`` with ``argparse`` (since ``=`` is special "
"cased as an alternative separator for option parameter values)"
msgstr ""

#: ../../library/optparse.rst:111
msgid ""
"Whether these differing behaviors in the ``argparse`` version are "
"considered desirable or a problem will depend on the specific command "
"line application use case."
msgstr ""

#: ../../library/optparse.rst:117
msgid ""
":pypi:`click` is a third party argument processing library (originally "
"based on ``optparse``), which allows command line applications to be "
"developed as a set of decorated command implementation functions."
msgstr ""

#: ../../library/optparse.rst:121
msgid ""
"Other third party libraries, such as :pypi:`typer` or :pypi:`msgspec-"
"click`, allow command line interfaces to be specified in ways that more "
"effectively integrate with static checking of Python type annotations."
msgstr ""

#: ../../library/optparse.rst:127
msgid "Introduction"
msgstr ""

#: ../../library/optparse.rst:129
#, fuzzy
msgid ""
":mod:`optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the minimalist :mod:`getopt` module. "
":mod:`optparse` uses a more declarative style of command-line parsing: "
"you create an instance of :class:`OptionParser`, populate it with "
"options, and parse the command line. :mod:`optparse` allows users to "
"specify options in the conventional GNU/POSIX syntax, and additionally "
"generates usage and help messages for you."
msgstr ""
":mod:`optparse`\\는 이전 :mod:`getopt` 모듈보다 명령 줄 옵션을 구문 분석하기 위한 더 편리하고 유연하며 "
"강력한 라이브러리입니다. :mod:`optparse`\\는 더 선언적인 스타일의 명령 줄 구문 분석을 사용합니다: "
":class:`OptionParser`\\의 인스턴스를 만들고, 옵션으로 채우고, 명령 줄을 구문 분석합니다. "
":mod:`optparse`\\를 사용하면 사용자가 전통적인 GNU/POSIX 문법으로 옵션을 지정할 수 있으며, 추가로 사용법과 "
"도움말 메시지를 생성할 수 있습니다."

#: ../../library/optparse.rst:137
msgid "Here's an example of using :mod:`optparse` in a simple script::"
msgstr "다음은 간단한 스크립트에서 :mod:`optparse`\\를 사용하는 예입니다::"

#: ../../library/optparse.rst:139
msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"write report to FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,"
"\n"
"                  help=\"don't print status messages to stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:150
msgid ""
"With these few lines of code, users of your script can now do the \"usual"
" thing\" on the command-line, for example::"
msgstr "이 몇 줄의 코드로, 스크립트 사용자는 이제 명령 줄에서 \"일반적인 작업\"을 수행 할 수 있습니다, 예를 들면::"

#: ../../library/optparse.rst:153
msgid "<yourscript> --file=outfile -q"
msgstr ""

#: ../../library/optparse.rst:155
#, fuzzy
msgid ""
"As it parses the command line, :mod:`optparse` sets attributes of the "
"``options`` object returned by :meth:`~OptionParser.parse_args` based on "
"user-supplied command-line values.  When :meth:`~OptionParser.parse_args`"
" returns from parsing this command line, ``options.filename`` will be "
"``\"outfile\"`` and ``options.verbose`` will be ``False``.  "
":mod:`optparse` supports both long and short options, allows short "
"options to be merged together, and allows options to be associated with "
"their arguments in a variety of ways.  Thus, the following command lines "
"are all equivalent to the above example::"
msgstr ""
"명령 줄을 구문 분석할 때, :mod:`optparse`\\는 사용자가 제공한 명령 줄 값을 기반으로 "
":meth:`parse_args`\\에서 반환한 ``options`` 객체의 어트리뷰트를 설정합니다. 이 명령 줄 구문 분석에서 "
":meth:`parse_args`\\가 반환되면, ``options.filename``\\은 ``\"outfile\"``\\이 되고"
" ``options.verbose``\\는 ``False``\\가 됩니다. :mod:`optparse`\\는 긴 옵션과 짧은 옵션을"
" 모두 지원하고, 짧은 옵션을 함께 병합하도록 하며, 다양한 방법으로 옵션을 인자와 연관시킬 수 있습니다. 따라서 다음 명령 줄은 "
"모두 위의 예와 동등합니다::"

#: ../../library/optparse.rst:164
msgid ""
"<yourscript> -f outfile --quiet\n"
"<yourscript> --quiet --file outfile\n"
"<yourscript> -q -foutfile\n"
"<yourscript> -qfoutfile"
msgstr ""

#: ../../library/optparse.rst:169
msgid "Additionally, users can run one of the following ::"
msgstr "또한, 사용자는 다음 중 하나를 실행할 수 있습니다 ::"

#: ../../library/optparse.rst:171
msgid ""
"<yourscript> -h\n"
"<yourscript> --help"
msgstr ""

#: ../../library/optparse.rst:174
msgid ""
"and :mod:`optparse` will print out a brief summary of your script's "
"options:"
msgstr "그러면 :mod:`optparse`\\는 스크립트 옵션에 대한 간략한 요약을 인쇄합니다:"

#: ../../library/optparse.rst:176
msgid ""
"Usage: <yourscript> [options]\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -f FILE, --file=FILE  write report to FILE\n"
"  -q, --quiet           don't print status messages to stdout"
msgstr ""

#: ../../library/optparse.rst:185
msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr "여기서 *yourscript*\\의 값은 (일반적으로 ``sys.argv[0]``\\에서) 실행 시간에 결정됩니다."

#: ../../library/optparse.rst:192
msgid "Background"
msgstr "배경"

#: ../../library/optparse.rst:194
#, fuzzy
msgid ""
":mod:`optparse` was explicitly designed to encourage the creation of "
"programs with straightforward command-line interfaces that follow the "
"conventions established by the :c:func:`!getopt` family of functions "
"available to C developers. To that end, it supports only the most common "
"command-line syntax and semantics conventionally used under Unix.  If you"
" are unfamiliar with these conventions, reading this section will allow "
"you to acquaint yourself with them."
msgstr ""
":mod:`optparse`\\는 간단하고 전통적인 명령 줄 인터페이스를 갖는 프로그램을 만들 수 있도록 명시적으로 설계되었습니다."
" 이를 위해, 유닉스에서 전통적으로 사용되는 가장 일반적인 명령 줄 문법과 의미 체계만 지원합니다. 이러한 규칙에 익숙하지 않으면,"
" 이 섹션을 읽고 숙지하십시오."

#: ../../library/optparse.rst:205
msgid "Terminology"
msgstr "용어"

#: ../../library/optparse.rst:207
msgid "argument"
msgstr "인자(argument)"

#: ../../library/optparse.rst:208
msgid ""
"a string entered on the command-line, and passed by the shell to "
"``execl()`` or ``execv()``.  In Python, arguments are elements of "
"``sys.argv[1:]`` (``sys.argv[0]`` is the name of the program being "
"executed).  Unix shells also use the term \"word\"."
msgstr ""
"명령 줄에 입력하고, 셸에서 ``execl()``\\이나 ``execv()``\\로 전달한 문자열. 파이썬에서, 인자는 "
"``sys.argv[1:]``\\의 요소입니다 (``sys.argv[0]``\\은 실행 중인 프로그램의 이름입니다). 유닉스 셸은 "
"\"워드(word)\"라는 용어도 사용합니다."

#: ../../library/optparse.rst:213
msgid ""
"It is occasionally desirable to substitute an argument list other than "
"``sys.argv[1:]``, so you should read \"argument\" as \"an element of "
"``sys.argv[1:]``, or of some other list provided as a substitute for "
"``sys.argv[1:]``\"."
msgstr ""
"때때로 ``sys.argv[1:]`` 이외의 인자 리스트로 대체하는 것이 바람직해서, \"인자\"를 "
"\"``sys.argv[1:]``\\이나 ``sys.argv[1:]``\\의 대체로 제공된 다른 리스트의 요소\"로 읽어야 합니다."

#: ../../library/optparse.rst:218
msgid "option"
msgstr "옵션(option)"

#: ../../library/optparse.rst:219
msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; "
"the traditional Unix syntax is a hyphen (\"-\") followed by a single "
"letter, e.g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows "
"multiple options to be merged into a single argument, e.g. ``-x -F`` is "
"equivalent to ``-xF``.  The GNU project introduced ``--`` followed by a "
"series of hyphen-separated words, e.g. ``--file`` or ``--dry-run``.  "
"These are the only two option syntaxes provided by :mod:`optparse`."
msgstr ""
"프로그램 실행을 안내하거나 사용자 정의하기 위해 추가 정보를 제공하는 데 사용되는 인자. 옵션에 대한 다양한 문법이 있습니다; "
"전통적인 유닉스 문법은 하이픈 (\"-\") 뒤에 단일 문자가 옵니다, 예를 들어 ``-x``\\나 ``-F``. 또한, 전통적인 "
"유닉스 문법은 여러 옵션을 단일 인자로 병합할 수 있도록 합니다, 예를 들어 ``-x -F``\\는 ``-xF``\\와 동등합니다."
" GNU 프로젝트는 하이픈으로 구분된 일련의 단어가 뒤따르는 ``--``\\를 도입했습니다, 예를 들어 ``--file``\\이나 "
"``--dry-run``. 이들이 :mod:`optparse`\\에서 제공하는 유일한 두 가지 옵션 문법입니다."

#: ../../library/optparse.rst:228
msgid "Some other option syntaxes that the world has seen include:"
msgstr "세상에 등장했던 다른 옵션 문법은 다음과 같습니다:"

#: ../../library/optparse.rst:230
msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same "
"as multiple options merged into a single argument)"
msgstr "몇 개의 문자가 뒤따르는 하이픈, 예를 들어 ``-pf`` (이것은 하나의 인자로 병합된 여러 옵션과 같은 것이 *아닙니다*)"

#: ../../library/optparse.rst:233
msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the "
"same program)"
msgstr ""
"전체 단어가 뒤따르는 하이픈, 예를 들어 ``-file`` (기술적으로 이전 문법과 동등하지만, 일반적으로 같은 프로그램에서 "
"등장하지 않습니다)"

#: ../../library/optparse.rst:237
msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, "
"e.g. ``+f``, ``+rgb``"
msgstr "단일 문자나 몇 개의 문자 또는 단어가 뒤따르는 더하기 기호, 예를 들어 ``+f``, ``+rgb``"

#: ../../library/optparse.rst:240
msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, "
"``/file``"
msgstr "단일 문자나 몇 개의 문자 또는 단어가 뒤따르는 슬래시, 예를 들어 ``/f``, ``/file``"

#: ../../library/optparse.rst:243
#, fuzzy
msgid ""
"These option syntaxes are not supported by :mod:`optparse`, and they "
"never will be.  This is deliberate: the first three are non-standard on "
"any environment, and the last only makes sense if you're exclusively "
"targeting Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""
"이러한 옵션 문법들은 :mod:`optparse`\\에서 지원되지 않으며, 앞으로도 지원되지 않을 것입니다. 이것은 의도적입니다: "
"처음 세 가지는 모든 환경에서 표준이 아니며, 마지막은 VMS, MS-DOS 및/또는 윈도우만 대상으로 하는 경우에만 의미가 "
"있습니다."

#: ../../library/optparse.rst:248
msgid "option argument"
msgstr "옵션 인자(option argument)"

#: ../../library/optparse.rst:249
msgid ""
"an argument that follows an option, is closely associated with that "
"option, and is consumed from the argument list when that option is. With "
":mod:`optparse`, option arguments may either be in a separate argument "
"from their option:"
msgstr ""
"옵션 뒤에 오는 인자는 해당 옵션과 밀접하게 연관되어 있으며, 해당 옵션이 있으면 인자 목록에서 사용됩니다. "
":mod:`optparse`\\를 사용하면, 옵션 인자가 해당 옵션과 별도의 인자로 있을 수 있습니다:"

#: ../../library/optparse.rst:254
msgid ""
"-f foo\n"
"--file foo"
msgstr ""

#: ../../library/optparse.rst:259
msgid "or included in the same argument:"
msgstr "또는 같은 인자에 포함될 수 있습니다:"

#: ../../library/optparse.rst:261
msgid ""
"-ffoo\n"
"--file=foo"
msgstr ""

#: ../../library/optparse.rst:266
msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of"
" people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  "
"This is somewhat controversial, because it makes parsing ambiguous: if "
"``-a`` takes an optional argument and ``-b`` is another option entirely, "
"how do we interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` "
"does not support this feature."
msgstr ""
"일반적으로, 주어진 옵션은 인자를 취하거나 취하지 않습니다. 많은 사람이 \"선택적 옵션 인자\" 기능을 원합니다. 즉, 일부 "
"옵션은 있다면 인자를 취하고 그렇지 않으면 취하지 않습니다. 이것은 구문 분석을 모호하게 만들기 때문에 다소 논란의 여지가 "
"있습니다: ``-a``\\가 선택적 인자를 취하고 ``-b``\\가 완전히 다른 옵션이면 ``-ab``\\를 어떻게 해석합니까? "
"이러한 모호성 때문에, :mod:`optparse`\\는 이 기능을 지원하지 않습니다."

#: ../../library/optparse.rst:274
msgid "positional argument"
msgstr "위치 인자(positional argument)"

#: ../../library/optparse.rst:275
msgid ""
"something leftover in the argument list after options have been parsed, "
"i.e. after options and their arguments have been parsed and removed from "
"the argument list."
msgstr "옵션이 구문 분석된 후, 즉 옵션과 해당 인자가 구문 분석되고 인자 목록에서 제거된 후 인자 목록에 남은 것."

#: ../../library/optparse.rst:279
msgid "required option"
msgstr "필수 옵션(required option)"

#: ../../library/optparse.rst:280
msgid ""
"an option that must be supplied on the command-line; note that the phrase"
" \"required option\" is self-contradictory in English.  :mod:`optparse` "
"doesn't prevent you from implementing required options, but doesn't give "
"you much help at it either."
msgstr ""
"명령 줄에서 제공해야 하는 옵션; \"필수 옵션\"이라는 문구는 영어에서 모순된다는 점에 유의하십시오. "
":mod:`optparse`\\는 필수 옵션을 구현하는 것을 방해하지 않지만, 그다지 도움을 주지도 않습니다."

#: ../../library/optparse.rst:285
msgid "For example, consider this hypothetical command-line::"
msgstr "예를 들어, 다음 가상 명령 줄을 고려하십시오::"

#: ../../library/optparse.rst:287
msgid "prog -v --report report.txt foo bar"
msgstr ""

#: ../../library/optparse.rst:289
msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` "
"takes one argument, ``report.txt`` is an option argument.  ``foo`` and "
"``bar`` are positional arguments."
msgstr ""
"``-v``\\와 ``--report``\\는 둘 다 옵션입니다. ``--report``\\가 하나의 인자를 취한다고 가정하면, "
"``report.txt``\\는 옵션 인자입니다. ``foo``\\와 ``bar``\\는 위치 인자입니다."

#: ../../library/optparse.rst:297
msgid "What are options for?"
msgstr "옵션은 무엇을 위한 것입니까?"

#: ../../library/optparse.rst:299
msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can "
"it run without any options at all and still make sense?  The main "
"exceptions are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant"
" oddballs that have been rightly criticized for their non-standard syntax"
" and confusing interfaces.)"
msgstr ""
"옵션은 프로그램 실행을 조정하거나 사용자 정의하기 위한 추가 정보를 제공하는 데 사용됩니다. 명확하지 않은 경우, 옵션은 일반적으로"
" *선택적*\\입니다. 프로그램은 어떤 옵션도 없이 잘 실행될 수 있어야 합니다. (유닉스나 GNU 도구 집합에서 임의의 프로그램을"
" 선택하십시오. 옵션 없이도 실행될 수 있으며 여전히 의미가 있습니까? 주요 예외는 ``find``, ``tar`` 및 "
"``dd``\\입니다 --- 모두 비표준 문법과 혼란스러운 인터페이스 때문에 올바로 비판을 받은 돌연변이 괴짜입니다.)"

#: ../../library/optparse.rst:307
msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a "
"piece of information that your program absolutely requires in order to "
"run successfully, that's what positional arguments are for."
msgstr ""
"많은 사람이 프로그램에 \"필수 옵션\"이 있기를 원합니다. 생각해보십시오. 필수라면, 그것은 *선택적(optional)이 "
"아닙니다*! 당신의 프로그램이 성공적으로 실행하기 위해 절대적으로 필요한 정보가 있다면, 그것이 바로 위치 인자의 목적입니다."

#: ../../library/optparse.rst:312
msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. "
"Hence, ``cp`` fails if you run it with no arguments.  However, it has a "
"flexible, useful syntax that does not require any options at all::"
msgstr ""
"좋은 명령 줄 인터페이스 설계의 예로, 파일 복사를 위한 겸손한 ``cp`` 유틸리티를 고려하십시오. 대상과 하나 이상의 소스를 "
"제공하지 않고 파일을 복사하는 것은 의미가 없습니다. 따라서, 인자 없이 실행하면 ``cp``\\가 실패합니다. 그러나 옵션이 전혀"
" 필수로 요구하지 않는 유연하고 유용한 문법을 갖습니다::"

#: ../../library/optparse.rst:318
msgid ""
"cp SOURCE DEST\n"
"cp SOURCE ... DEST-DIR"
msgstr ""

#: ../../library/optparse.rst:321
msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations "
"provide a bunch of options to tweak exactly how the files are copied: you"
" can preserve mode and modification time, avoid following symlinks, ask "
"before clobbering existing files, etc.  But none of this distracts from "
"the core mission of ``cp``, which is to copy either one file to another, "
"or several files to another directory."
msgstr ""
"그것만으로도 꽤 멀리 갈 수 있습니다. 대부분의 ``cp`` 구현은 파일이 복사되는 방식을 정확하게 조정할 수 있는 여러 옵션을 "
"제공합니다: 모드 및 수정 시간을 보존하고, 심볼릭 링크를 따르지 않고, 기존 파일을 건드리기 전에 물을 수 있습니다. 하지만 이 "
"중 어느 것도 한 파일을 다른 파일로 복사하거나 여러 파일을 다른 디렉터리로 복사하는 ``cp``\\의 핵심 임무를 방해하지 "
"않습니다."

#: ../../library/optparse.rst:332
msgid "What are positional arguments for?"
msgstr "위치 인자는 무엇을 위한 것입니까?"

#: ../../library/optparse.rst:334
msgid ""
"Positional arguments are for those pieces of information that your "
"program absolutely, positively requires to run."
msgstr "위치 인자는 프로그램이 실행하기 위해 절대적으로 필요로하는 정보를 위한 것입니다."

#: ../../library/optparse.rst:337
msgid ""
"A good user interface should have as few absolute requirements as "
"possible.  If your program requires 17 distinct pieces of information in "
"order to run successfully, it doesn't much matter *how* you get that "
"information from the user---most people will give up and walk away before"
" they successfully run the program.  This applies whether the user "
"interface is a command-line, a configuration file, or a GUI: if you make "
"that many demands on your users, most of them will simply give up."
msgstr ""
"좋은 사용자 인터페이스에는 가능한 한 적은 절대 요구 사항이 있어야 합니다. 프로그램을 성공적으로 실행하기 위해 17개의 개별 "
"정보를 요구한다면, 사용자로부터 해당 정보를 *어떻게* 얻는지는 중요하지 않습니다---대부분의 사람은 프로그램을 성공적으로 실행하기"
" 전에 포기하고 떠납니다. 이것은 사용자 인터페이스가 명령 줄이든, 구성 파일이든, GUI이든 상관없이 적용됩니다: 사용자에게 "
"그렇게 많은 요구를 하면, 대부분은 단순히 포기할 것입니다."

#: ../../library/optparse.rst:345
msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible."
"  Of course, you also want to make your programs reasonably flexible.  "
"That's what options are for.  Again, it doesn't matter if they are "
"entries in a config file, widgets in the \"Preferences\" dialog of a GUI,"
" or command-line options---the more options you implement, the more "
"flexible your program is, and the more complicated its implementation "
"becomes.  Too much flexibility has drawbacks as well, of course; too many"
" options can overwhelm users and make your code much harder to maintain."
msgstr ""
"요컨대, 사용자가 절대적으로 제공해야 하는 정보의 양을 최소화하십시오---가능할 때마다 합리적인 기본값을 사용하십시오. 물론, "
"프로그램을 합리적으로 유연하게 만들고 싶기도 합니다. 그것이 바로 옵션이 있는 이유입니다. 다시 말하지만, 구성 파일의 항목인지, "
"GUI의 \"기본 설정\" 대화 상자에 있는 위젯인지, 명령 줄 옵션인지는 중요하지 않습니다---구현하는 옵션이 많을수록, "
"프로그램이 더 유연해지고, 구현은 더 복잡해집니다. 물론 유연성이 너무 많으면 단점도 있습니다; 너무 많은 옵션은 사용자를 압도하고"
" 코드 유지 관리를 훨씬 더 어렵게 만들 수 있습니다."

#: ../../library/optparse.rst:358
msgid "Tutorial"
msgstr "자습서"

#: ../../library/optparse.rst:360
msgid ""
"While :mod:`optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code "
"patterns that are common to any :mod:`optparse`\\ -based program."
msgstr ""
":mod:`optparse`\\는 매우 유연하고 강력하지만, 대부분의 경우 사용하기도 간단합니다. 이 섹션에서는 모든 "
":mod:`optparse` 기반 프로그램에 공통적인 코드 패턴을 다룹니다."

#: ../../library/optparse.rst:364
msgid ""
"First, you need to import the OptionParser class; then, early in the main"
" program, create an OptionParser instance::"
msgstr ""
"먼저, OptionParser 클래스를 임포트 해야 합니다; 그런 다음 메인 프로그램의 초기에, OptionParser 인스턴스를 "
"만듭니다::"

#: ../../library/optparse.rst:367
msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"
msgstr ""

#: ../../library/optparse.rst:371
msgid "Then you can start defining options.  The basic syntax is::"
msgstr "그런 다음 옵션 정의를 시작할 수 있습니다. 기본 문법은 다음과 같습니다::"

#: ../../library/optparse.rst:373
msgid ""
"parser.add_option(opt_str, ...,\n"
"                  attr=value, ...)"
msgstr ""

#: ../../library/optparse.rst:376
msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``,"
" and several option attributes that tell :mod:`optparse` what to expect "
"and what to do when it encounters that option on the command line."
msgstr ""
"각 옵션에는 ``-f``\\나 ``--file``\\과 같은 하나 이상의 옵션 문자열이 있고, 명령 줄에서 해당 옵션을 발견했을 때"
" :mod:`optparse`\\가 기대하는 것과 수행 할 작업을 알려주는 여러 옵션 어트리뷰트가 있습니다."

#: ../../library/optparse.rst:380
msgid ""
"Typically, each option will have one short option string and one long "
"option string, e.g.::"
msgstr "일반적으로, 각 옵션에는 하나의 짧은 옵션 문자열과 하나의 긴 옵션 문자열이 있습니다, 예를 들어::"

#: ../../library/optparse.rst:383
msgid "parser.add_option(\"-f\", \"--file\", ...)"
msgstr ""

#: ../../library/optparse.rst:385
msgid ""
"You're free to define as many short option strings and as many long "
"option strings as you like (including zero), as long as there is at least"
" one option string overall."
msgstr ""
"전체적으로 적어도 하나의 옵션 문자열이 있는 한 원하는 만큼 짧은 옵션 문자열과 긴 옵션 문자열을 (없는 것도 포함합니다) 자유롭게"
" 정의 할 수 있습니다."

#: ../../library/optparse.rst:389
msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are "
"effectively labels for the option defined by that call.  For brevity, we "
"will frequently refer to *encountering an option* on the command line; in"
" reality, :mod:`optparse` encounters *option strings* and looks up "
"options from them."
msgstr ""
":meth:`OptionParser.add_option`\\에 전달된 옵션 문자열은 해당 호출에 의해 정의된 옵션에 대한 "
"레이블입니다. 간결함을 위해, 명령 줄에서 *옵션을 만난다*\\를 자주 언급할 것입니다; 실제로는, "
":mod:`optparse`\\가 *옵션 문자열*\\을 만나고 이것으로 옵션을 찾습니다."

#: ../../library/optparse.rst:395
msgid ""
"Once all of your options are defined, instruct :mod:`optparse` to parse "
"your program's command line::"
msgstr "일단 모든 옵션이 정의되면, :mod:`optparse`\\가 프로그램의 명령 줄을 구문 분석하도록 지시합니다::"

#: ../../library/optparse.rst:398
msgid "(options, args) = parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:400
#, fuzzy
msgid ""
"(If you like, you can pass a custom argument list to "
":meth:`~OptionParser.parse_args`, but that's rarely necessary: by default"
" it uses ``sys.argv[1:]``.)"
msgstr ""
"(원한다면, 사용자 정의 인자 리스트를 :meth:`parse_args`\\에 전달할 수 있지만, 거의 필요하지 않습니다: "
"기본적으로 ``sys.argv[1:]``\\을 사용합니다.)"

#: ../../library/optparse.rst:403
#, fuzzy
msgid ":meth:`~OptionParser.parse_args` returns two values:"
msgstr ":meth:`parse_args`\\는 두 가지 값을 반환합니다:"

#: ../../library/optparse.rst:405
msgid ""
"``options``, an object containing values for all of your options---e.g. "
"if ``--file`` takes a single string argument, then ``options.file`` will "
"be the filename supplied by the user, or ``None`` if the user did not "
"supply that option"
msgstr ""
"``options``, 모든 옵션에 대한 값을 포함하는 객체---예를 들어 ``--file``\\이 단일 문자열 인자를 취하면, "
"``options.file``\\은 사용자가 제공한 파일명이거나, 사용자가 해당 옵션을 제공하지 않으면 ``None``\\입니다."

#: ../../library/optparse.rst:410
msgid "``args``, the list of positional arguments leftover after parsing options"
msgstr "``args``, 옵션 구문 분석 후 남은 위치 인자 리스트"

#: ../../library/optparse.rst:412
msgid ""
"This tutorial section only covers the four most important option "
"attributes: :attr:`~Option.action`, :attr:`~Option.type`, "
":attr:`~Option.dest` (destination), and :attr:`~Option.help`. Of these, "
":attr:`~Option.action` is the most fundamental."
msgstr ""
"이 자습서 섹션에서는 가장 중요한 4가지 옵션 어트리뷰트만 다룹니다: :attr:`~Option.action`, "
":attr:`~Option.type`, :attr:`~Option.dest` (destination) 및 "
":attr:`~Option.help`\\만 다룹니다. 이 중, :attr:`~Option.action`\\이 가장 기본입니다."

#: ../../library/optparse.rst:421
msgid "Understanding option actions"
msgstr "옵션 액션의 이해"

#: ../../library/optparse.rst:423
msgid ""
"Actions tell :mod:`optparse` what to do when it encounters an option on "
"the command line.  There is a fixed set of actions hard-coded into "
":mod:`optparse`; adding new actions is an advanced topic covered in "
"section :ref:`optparse-extending-optparse`.  Most actions tell "
":mod:`optparse` to store a value in some variable---for example, take a "
"string from the command line and store it in an attribute of ``options``."
msgstr ""
"액션은 명령 줄에서 옵션을 발견할 때 수행 할 작업을 :mod:`optparse`\\에 알려줍니다. "
":mod:`optparse`\\에 하드 코딩된 고정된 액션 집합이 있습니다; 새로운 액션 추가는 섹션 :ref:`optparse-"
"extending-optparse`\\에서 다루는 고급 주제입니다. 대부분의 액션은 :mod:`optparse`\\에게 어떤 변수에"
" 값을 저장하도록 지시합니다---예를 들어, 명령 줄에서 문자열을 취해서 ``options``\\의 어트리뷰트에 저장합니다."

#: ../../library/optparse.rst:430
msgid ""
"If you don't specify an option action, :mod:`optparse` defaults to "
"``store``."
msgstr "옵션 액션을 지정하지 않으면, :mod:`optparse`\\의 기본값은 ``store``\\입니다."

#: ../../library/optparse.rst:436
msgid "The store action"
msgstr "store 액션"

#: ../../library/optparse.rst:438
msgid ""
"The most common option action is ``store``, which tells :mod:`optparse` "
"to take the next argument (or the remainder of the current argument), "
"ensure that it is of the correct type, and store it to your chosen "
"destination."
msgstr ""
"가장 일반적인 옵션 액션은 ``store``\\로, :mod:`optparse`\\에게 다음 인자(또는 현재 인자의 나머지)를 "
"취하고, 올바른 형인지 확인한 다음, 선택한 대상에 저장하도록 지시합니다."

#: ../../library/optparse.rst:442
msgid "For example::"
msgstr "예를 들면::"

#: ../../library/optparse.rst:444
msgid ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"
msgstr ""

#: ../../library/optparse.rst:447
msgid ""
"Now let's make up a fake command line and ask :mod:`optparse` to parse "
"it::"
msgstr "이제 가짜 명령 줄을 만들고 :mod:`optparse`\\에게 구문 분석을 요청합시다::"

#: ../../library/optparse.rst:449
msgid ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"
msgstr ""

#: ../../library/optparse.rst:452
#, fuzzy
msgid ""
"When :mod:`optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`~OptionParser.parse_args`, ``options.filename`` is "
"``\"foo.txt\"``."
msgstr ""
":mod:`optparse`\\가 옵션 문자열 ``-f``\\를 보면, 다음 인자인 ``foo.txt``\\를 소비하고, "
"``options.filename``\\에 저장합니다. 따라서, 이 :meth:`parse_args` 호출 후, "
"``options.filename``\\은 ``\"foo.txt\"``\\입니다."

#: ../../library/optparse.rst:456
msgid ""
"Some other option types supported by :mod:`optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ""
":mod:`optparse`\\에서 지원하는 다른 옵션 형은 ``int``\\와 ``float``\\입니다. 정수 인자를 기대하는 "
"옵션은 다음과 같습니다::"

#: ../../library/optparse.rst:459
msgid "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"
msgstr ""

#: ../../library/optparse.rst:461
msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is "
"``store``."
msgstr ""
"이 옵션에는 긴 옵션 문자열이 없는데, 완벽하게 허용됩니다. 또한, 기본값이 ``store``\\이기 때문에 명시적인 액션이 "
"없습니다."

#: ../../library/optparse.rst:464
msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr ""
"다른 가짜 명령 줄을 구문 분석해 봅시다. 이번에는, 옵션 인자를 옵션 바로 다음에 붙일 것입니다: ``-n42``\\(하나의 "
"인자)는 ``-n 42``\\(두 개의 인자)와 동등하므로, 다음 코드는 ::"

#: ../../library/optparse.rst:468
msgid ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"
msgstr ""

#: ../../library/optparse.rst:471
msgid "will print ``42``."
msgstr "``42``\\를 인쇄합니다."

#: ../../library/optparse.rst:473
msgid ""
"If you don't specify a type, :mod:`optparse` assumes ``string``.  "
"Combined with the fact that the default action is ``store``, that means "
"our first example can be a lot shorter::"
msgstr ""
"형을 지정하지 않으면, :mod:`optparse`\\는 ``string``\\을 가정합니다. 기본 액션이 ``store``\\라는"
" 사실과 결합하면, 첫 번째 예제를 훨씬 더 짧게 만들 수 있습니다::"

#: ../../library/optparse.rst:477
msgid "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"
msgstr ""

#: ../../library/optparse.rst:479
msgid ""
"If you don't supply a destination, :mod:`optparse` figures out a sensible"
" default from the option strings: if the first long option string is "
"``--foo-bar``, then the default destination is ``foo_bar``.  If there are"
" no long option strings, :mod:`optparse` looks at the first short option "
"string: the default destination for ``-f`` is ``f``."
msgstr ""
"대상을 제공하지 않으면, :mod:`optparse`\\는 옵션 문자열에서 합리적인 기본값을 추측합니다: 첫 번째 긴 옵션 문자열이"
" ``--foo-bar``\\이면 기본 대상은 ``foo_bar``\\입니다. 긴 옵션 문자열이 없으면, "
":mod:`optparse`\\는 첫 번째 짧은 옵션 문자열을 찾습니다: ``-f``\\의 기본 대상은 ``f``\\입니다."

#: ../../library/optparse.rst:485
msgid ""
":mod:`optparse` also includes the built-in ``complex`` type.  Adding "
"types is covered in section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse`\\는 내장 ``complex`` 형도 포함합니다. 형 추가는 섹션 :ref:`optparse-"
"extending-optparse`\\에서 다룹니다."

#: ../../library/optparse.rst:492
msgid "Handling boolean (flag) options"
msgstr "불리언 (플래그) 옵션 처리하기"

#: ../../library/optparse.rst:494
msgid ""
"Flag options---set a variable to true or false when a particular option "
"is seen---are quite common.  :mod:`optparse` supports them with two "
"separate actions, ``store_true`` and ``store_false``.  For example, you "
"might have a ``verbose`` flag that is turned on with ``-v`` and off with "
"``-q``::"
msgstr ""
"플래그 옵션(특정 옵션이 발견되면 변수를 참이나 거짓으로 설정합니다)은 매우 흔합니다. :mod:`optparse`\\는 "
"``store_true``\\와 ``store_false``\\의 두 가지 별도의 액션으로 지원합니다. 예를 들어, "
"``-v``\\로 켜고 ``-q``\\로 끄는 ``verbose`` 플래그가 있을 수 있습니다::"

#: ../../library/optparse.rst:499
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""

#: ../../library/optparse.rst:502
msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr ""
"여기에 대상이 같은 두 가지 옵션이 있는데, 완벽하게 괜찮습니다. (단지 기본값을 설정할 때 약간 주의해야 함을 뜻합니다---아래를"
" 참조하십시오.)"

#: ../../library/optparse.rst:506
msgid ""
"When :mod:`optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, "
"``options.verbose`` is set to ``False``."
msgstr ""
":mod:`optparse`\\가 명령 줄에서 ``-v``\\를 만나면, ``options.verbose``\\를 "
"``True``\\로 설정합니다; ``-q``\\를 만나면 ``options.verbose``\\는 ``False``\\로 "
"설정됩니다."

#: ../../library/optparse.rst:514
msgid "Other actions"
msgstr "다른 액션들"

#: ../../library/optparse.rst:516
msgid "Some other actions supported by :mod:`optparse` are:"
msgstr ":mod:`optparse`\\에서 지원하는 다른 액션은 다음과 같습니다:"

#: ../../library/optparse.rst:518 ../../library/optparse.rst:1040
msgid "``\"store_const\"``"
msgstr "``\"store_const\"``"

#: ../../library/optparse.rst:519 ../../library/optparse.rst:1041
msgid "store a constant value, pre-set via :attr:`Option.const`"
msgstr ""

#: ../../library/optparse.rst:521 ../../library/optparse.rst:1049
msgid "``\"append\"``"
msgstr "``\"append\"``"

#: ../../library/optparse.rst:522 ../../library/optparse.rst:1050
msgid "append this option's argument to a list"
msgstr "이 옵션의 인자를 리스트에 추가합니다"

#: ../../library/optparse.rst:524 ../../library/optparse.rst:1055
msgid "``\"count\"``"
msgstr "``\"count\"``"

#: ../../library/optparse.rst:525 ../../library/optparse.rst:1056
msgid "increment a counter by one"
msgstr "카운터를 1씩 증가시킵니다"

#: ../../library/optparse.rst:527 ../../library/optparse.rst:1058
msgid "``\"callback\"``"
msgstr "``\"callback\"``"

#: ../../library/optparse.rst:528 ../../library/optparse.rst:1059
msgid "call a specified function"
msgstr "지정된 함수를 호출합니다"

#: ../../library/optparse.rst:530
msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section"
" :ref:`optparse-option-callbacks`."
msgstr ""
"이들은 섹션 :ref:`optparse-reference-guide`\\와 섹션 :ref:`optparse-option-"
"callbacks`\\에서 다룹니다."

#: ../../library/optparse.rst:537
msgid "Default values"
msgstr "기본값"

#: ../../library/optparse.rst:539
msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What "
"happens if those options are never seen?  Since we didn't supply any "
"defaults, they are all set to ``None``.  This is usually fine, but "
"sometimes you want more control.  :mod:`optparse` lets you supply a "
"default value for each destination, which is assigned before the command "
"line is parsed."
msgstr ""
"위의 모든 예에는 특정 명령 줄 옵션을 볼 때 일부 변수 (\"대상(destination)\") 설정이 수반됩니다. 이러한 옵션이 "
"나타나지 않으면 어떻게 될까요? 기본값을 제공하지 않아서, 모두 ``None``\\으로 설정됩니다. 이것은 일반적으로 괜찮지만, "
"때로는 더 많은 제어가 필요합니다. :mod:`optparse`\\는 각 대상에 대한 기본값을 제공할 수 있도록 하는데, 명령 줄이"
" 구문 분석되기 전에 대입됩니다."

#: ../../library/optparse.rst:546
msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`optparse` to"
" set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""
"먼저, verbose/quiet 예를 고려하십시오. ``-q``\\가 나타나지 않는 한 :mod:`optparse`\\가 "
"``verbose``\\를 ``True``\\로 설정하도록 하려면, 다음과 같이 할 수 있습니다::"

#: ../../library/optparse.rst:549
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""

#: ../../library/optparse.rst:552
msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr ""
"기본값은 특정 옵션이 아닌 *대상(destination)*\\에 적용되고, 이 두 옵션은 같은 대상을 갖기 때문에, 다음과 정확히 "
"동등합니다::"

#: ../../library/optparse.rst:556
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""

#: ../../library/optparse.rst:559
msgid "Consider this::"
msgstr "이걸 생각해봅시다::"

#: ../../library/optparse.rst:561
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""

#: ../../library/optparse.rst:564
msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last "
"default value supplied for any particular destination is the one that "
"counts."
msgstr "다시, ``verbose``\\의 기본값은 ``True``\\입니다: 특정 대상에 대해 제공되는 마지막 기본값이 사용되는 값입니다."

#: ../../library/optparse.rst:567
#, fuzzy
msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` "
"method of OptionParser, which you can call at any time before calling "
":meth:`~OptionParser.parse_args`::"
msgstr ""
"기본값을 지정하는 더 명확한 방법은 OptionParser의 :meth:`set_defaults` 메서드인데, "
":meth:`parse_args`\\를 호출하기 전에 언제든지 호출할 수 있습니다::"

#: ../../library/optparse.rst:571
msgid ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"
msgstr ""

#: ../../library/optparse.rst:575
msgid ""
"As before, the last value specified for a given option destination is the"
" one that counts.  For clarity, try to use one method or the other of "
"setting default values, not both."
msgstr ""
"이전과 마찬가지로, 주어진 옵션 대상에 대해 지정된 마지막 값이 사용됩니다. 명확성을 위해, 둘 다가 아닌 한 가지 방법을 사용하여"
" 기본값을 설정하십시오."

#: ../../library/optparse.rst:583
msgid "Generating help"
msgstr "도움말 생성하기"

#: ../../library/optparse.rst:585
msgid ""
":mod:`optparse`'s ability to generate help and usage text automatically "
"is useful for creating user-friendly command-line interfaces.  All you "
"have to do is supply a :attr:`~Option.help` value for each option, and "
"optionally a short usage message for your whole program.  Here's an "
"OptionParser populated with user-friendly (documented) options::"
msgstr ""
"도움말과 사용법 텍스트를 자동으로 생성하는 :mod:`optparse`\\의 기능은 사용자 친화적인 명령 줄 인터페이스를 만드는 데"
" 유용합니다. 각 옵션에 대해 :attr:`~Option.help` 값을 제공하고, 선택적으로 전체 프로그램에 대한 짧은 사용법 "
"메시지를 제공하기만 하면 됩니다. 다음은 사용자에게 친숙한 (문서화된) 옵션으로 채워진 OptionParser입니다::"

#: ../../library/optparse.rst:591
#, python-format
msgid ""
"usage = \"usage: %prog [options] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"make lots of noise [default]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"be vewwy quiet (I'm hunting wabbits)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FILE\", help=\"write output to FILE\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermediate\",\n"
"                  help=\"interaction mode: novice, intermediate, \"\n"
"                       \"or expert [default: %default]\")"
msgstr ""

#: ../../library/optparse.rst:606
msgid ""
"If :mod:`optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the "
"following to standard output:"
msgstr ""
":mod:`optparse`\\가 명령 줄에서 ``-h``\\나 ``--help``\\를 만나거나, "
":meth:`parser.print_help`\\를 호출하면, 다음을 표준 출력에 인쇄합니다:"

#: ../../library/optparse.rst:610
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]"
msgstr ""

#: ../../library/optparse.rst:623
msgid ""
"(If the help output is triggered by a help option, :mod:`optparse` exits "
"after printing the help text.)"
msgstr "(도움말 출력이 help 옵션으로 트리거 되면, :mod:`optparse`\\가 도움말 텍스트를 인쇄한 후 종료합니다.)"

#: ../../library/optparse.rst:626
msgid ""
"There's a lot going on here to help :mod:`optparse` generate the best "
"possible help message:"
msgstr "여기에는 :mod:`optparse`\\가 최상의 도움말 메시지를 생성하는 데 도움이 되는 많은 것들이 있습니다:"

#: ../../library/optparse.rst:629
msgid "the script defines its own usage message::"
msgstr "스크립트는 자체 사용법 메시지를 정의합니다::"

#: ../../library/optparse.rst:631
msgid "usage = \"usage: %prog [options] arg1 arg2\""
msgstr ""

#: ../../library/optparse.rst:633
msgid ""
":mod:`optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""
":mod:`optparse`\\는 사용법 문자열의 ``%prog``\\를 현재 프로그램의 이름, 즉 "
"``os.path.basename(sys.argv[0])``\\으로 확장합니다. 확장된 문자열은 자세한 옵션 도움말 앞에 "
"인쇄됩니다."

#: ../../library/optparse.rst:637
msgid ""
"If you don't supply a usage string, :mod:`optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""
"사용법 문자열을 제공하지 않으면, :mod:`optparse`\\는 단순하지만, 합리적인 기본값을 사용합니다: ``\"Usage: "
"%prog [options]\"``, 이는 스크립트가 위치 인자를 취하지 않는다면 괜찮습니다."

#: ../../library/optparse.rst:641
msgid ""
"every option defines a help string, and doesn't worry about line-"
"wrapping---\\ :mod:`optparse` takes care of wrapping lines and making the"
" help output look good."
msgstr ""
"모든 옵션은 도움말 문자열을 정의하고, 줄 바꿈에 대해 걱정하지 않습니다---\\ :mod:`optparse`\\는 줄 바꿈을 "
"처리하고 도움말 출력을 보기 좋게 만듭니다."

#: ../../library/optparse.rst:645
#, fuzzy
msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr "값을 취하는 옵션은 자동으로 생성된 도움말 메시지에 이 사실을 나타냅니다, 예를 들어 \"mode\" 옵션의 경우::"

#: ../../library/optparse.rst:648
msgid "-m MODE, --mode=MODE"
msgstr ""

#: ../../library/optparse.rst:650
#, fuzzy
msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument "
"that the user is expected to supply to ``-m``/``--mode``.  By default, "
":mod:`optparse` converts the destination variable name to uppercase and "
"uses that for the meta-variable.  Sometimes, that's not what you want---"
"for example, the ``--filename`` option explicitly sets "
"``metavar=\"FILE\"``, resulting in this automatically generated option "
"description::"
msgstr ""
"여기서, \"MODE\"를 메타 변수(meta-variable)라고 합니다: 사용자가 ``-m``/``--mode``\\에 제공할 "
"것으로 기대되는 인자를 나타냅니다. 기본적으로, :mod:`optparse`\\는 대상 변수 이름을 대문자로 변환하고 이를 메타 "
"변수에 사용합니다. 때로는, 이것이 여러분이 원하는 것이 아닙니다---예를 들어, ``--filename`` 옵션은 명시적으로 "
"``metavar=\"FILE\"``\\을 설정하여 다음과 같은 자동 생성 옵션 설명을 생성합니다::"

#: ../../library/optparse.rst:657
msgid "-f FILE, --filename=FILE"
msgstr ""

#: ../../library/optparse.rst:659
msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in "
"that there's a connection between the semi-formal syntax ``-f FILE`` and "
"the informal semantic description \"write output to FILE\". This is a "
"simple but effective way to make your help text a lot clearer and more "
"useful for end users."
msgstr ""
"이것은 공간을 절약하는 것 이상으로 중요합니다: 수동으로 작성된 도움말 텍스트는 메타 변수 ``FILE``\\을 사용하여 반 형식 "
"구문 ``-f FILE``\\과 비형식적 의미 설명 \"write output to FILE\" 사이에 연결이 있다는 단서를 "
"사용자에게 알려줍니다. 이는 최종 사용자에게 도움말 텍스트를 훨씬 더 명확하고 유용하게 만드는 간단하지만, 효과적인 방법입니다."

#: ../../library/optparse.rst:665
#, python-format
msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`optparse` will replace it with :func:`str` of the "
"option's default value.  If an option has no default value (or the "
"default value is ``None``), ``%default`` expands to ``none``."
msgstr ""
"기본값이 있는 옵션은 도움말 문자열에 ``%default``\\를 포함할 수 있습니다---\\ :mod:`optparse`\\는 "
"이를 옵션 기본값의 :func:`str`\\로 대체합니다. 옵션에 기본값이 없으면 (또는 기본값이 ``None``\\이면), "
"``%default``\\는 ``none``\\으로 확장됩니다."

#: ../../library/optparse.rst:671
msgid "Grouping Options"
msgstr "옵션 그룹화하기"

#: ../../library/optparse.rst:673
msgid ""
"When dealing with many options, it is convenient to group these options "
"for better help output.  An :class:`OptionParser` can contain several "
"option groups, each of which can contain several options."
msgstr ""
"많은 옵션을 다룰 때, 더 나은 도움말 출력을 위해 이러한 옵션을 그룹화하는 것이 편리합니다. "
":class:`OptionParser`\\에는 여러 옵션 그룹이 포함될 수 있으며 각 그룹에는 여러 옵션이 포함될 수 있습니다."

#: ../../library/optparse.rst:677
msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "옵션 그룹은 클래스 :class:`OptionGroup`\\을 사용하여 얻습니다:"

#: ../../library/optparse.rst:681 ../../library/optparse.rst:1752
msgid "where"
msgstr "여기서"

#: ../../library/optparse.rst:683
msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted "
"in to"
msgstr "parser는 그룹이 삽입될 :class:`OptionParser` 인스턴스입니다"

#: ../../library/optparse.rst:685
msgid "title is the group title"
msgstr "title은 그룹 제목입니다"

#: ../../library/optparse.rst:686
msgid "description, optional, is a long description of the group"
msgstr "description(선택 사항)은 그룹에 대한 자세한 설명입니다"

#: ../../library/optparse.rst:688
msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like "
":class:`OptionParser`) and so the :meth:`add_option` method can be used "
"to add an option to the group."
msgstr ""
":class:`OptionGroup`\\은 (:class:`OptionParser` 처럼) "
":class:`OptionContainer`\\에서 상속되므로 :meth:`add_option` 메서드를 사용하여 그룹에 옵션을 "
"추가할 수 있습니다."

#: ../../library/optparse.rst:692
msgid ""
"Once all the options are declared, using the :class:`OptionParser` method"
" :meth:`add_option_group` the group is added to the previously defined "
"parser."
msgstr ""
"일단 모든 옵션이 선언되면, :class:`OptionParser` 메서드 :meth:`add_option_group`\\을 "
"사용하여 그룹이 이전에 정의된 구문 분석기에 추가됩니다."

#: ../../library/optparse.rst:695
msgid ""
"Continuing with the parser defined in the previous section, adding an "
":class:`OptionGroup` to a parser is easy::"
msgstr ""
"이전 섹션에서 정의한 구문 분석기로 계속 진행하면, 구문 분석기에 :class:`OptionGroup`\\을 쉽게 추가할 수 "
"있습니다::"

#: ../../library/optparse.rst:698
msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)"
msgstr ""

#: ../../library/optparse.rst:704
msgid "This would result in the following help output:"
msgstr "그러면 다음과 같은 도움말이 출력됩니다:"

#: ../../library/optparse.rst:706
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that "
"some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option."
msgstr ""

#: ../../library/optparse.rst:725
msgid ""
"A bit more complete example might involve using more than one group: "
"still extending the previous example::"
msgstr "좀 더 완전한 예는 둘 이상의 그룹을 수반할 수 있습니다: 여전히 이전 예를 확장합니다::"

#: ../../library/optparse.rst:728
msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Debug Options\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Print debug information\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Print all SQL statements executed\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Print every action"
" done\")\n"
"parser.add_option_group(group)"
msgstr ""

#: ../../library/optparse.rst:742
msgid "that results in the following output:"
msgstr "다음과 같은 출력을 줍니다:"

#: ../../library/optparse.rst:744
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert"
"\n"
"                        [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that "
"some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option.\n"
"\n"
"  Debug Options:\n"
"    -d, --debug         Print debug information\n"
"    -s, --sql           Print all SQL statements executed\n"
"    -e                  Print every action done"
msgstr ""

#: ../../library/optparse.rst:768
msgid ""
"Another interesting method, in particular when working programmatically "
"with option groups is:"
msgstr "특히 옵션 그룹을 프로그래밍 방식으로 작업할 때, 또 다른 흥미로운 메서드는 다음과 같습니다:"

#: ../../library/optparse.rst:773
msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such "
":class:`OptionGroup`, return ``None``."
msgstr ""
"짧거나 긴 옵션 문자열 *opt_str*\\(예를 들어 ``'-o'``\\나 ``'--option'``)이 속한 "
":class:`OptionGroup`\\을 반환합니다. 그러한 :class:`OptionGroup`\\이 없으면, "
"``None``\\을 반환합니다."

#: ../../library/optparse.rst:780
msgid "Printing a version string"
msgstr "버전 문자열 인쇄하기"

#: ../../library/optparse.rst:782
msgid ""
"Similar to the brief usage string, :mod:`optparse` can also print a "
"version string for your program.  You have to supply the string as the "
"``version`` argument to OptionParser::"
msgstr ""
"간단한 사용법 문자열과 유사하게, :mod:`optparse`\\는 프로그램의 버전 문자열을 인쇄 할 수도 있습니다. "
"OptionParser에 ``version`` 인자로 문자열을 제공해야 합니다::"

#: ../../library/optparse.rst:786
msgid "parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"
msgstr ""

#: ../../library/optparse.rst:788
msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, "
":mod:`optparse` automatically adds a ``--version`` option to your parser."
" If it encounters this option on the command line, it expands your "
"``version`` string (by replacing ``%prog``), prints it to stdout, and "
"exits."
msgstr ""
"``%prog``\\는 ``usage``\\에서처럼 확장됩니다. 그 외에도, ``version``\\은 원하는 무엇이든 포함할 수 "
"있습니다. 이를 제공하면, :mod:`optparse`\\는 자동으로 구문 분석기에 ``--version`` 옵션을 추가합니다. "
"명령 줄에서 이 옵션을 발견하면, (``%prog``\\를 대체하여) ``version`` 문자열을 확장하고, stdout에 인쇄한"
" 다음, 종료합니다."

#: ../../library/optparse.rst:794
msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "예를 들어, 스크립트가 ``/usr/bin/foo``\\로 호출되면:"

#: ../../library/optparse.rst:796
msgid ""
"$ /usr/bin/foo --version\n"
"foo 1.0"
msgstr ""

#: ../../library/optparse.rst:801
msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr "다음 두 가지 메서드를 사용하여 ``version`` 문자열을 인쇄하고 가져올 수 있습니다:"

#: ../../library/optparse.rst:805
msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"현재 프로그램의 버전 메시지(``self.version``)를 *file*\\(기본값은 표준 출력)로 인쇄합니다. "
":meth:`print_usage`\\와 마찬가지로, ``self.version``\\에 등장하는 ``%prog``\\는 현재 "
"프로그램의 이름으로 대체됩니다. ``self.version``\\이 비어 있거나 정의되지 않았으면 아무 작업도 수행하지 않습니다."

#: ../../library/optparse.rst:812
msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr ":meth:`print_version`\\과 같지만 인쇄하는 대신 버전 문자열을 반환합니다."

#: ../../library/optparse.rst:819
msgid "How :mod:`optparse` handles errors"
msgstr ":mod:`optparse`\\가 에러를 처리하는 방법"

#: ../../library/optparse.rst:821
msgid ""
"There are two broad classes of errors that :mod:`optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  "
"These are dealt with in the usual way: raise an exception (either "
":exc:`optparse.OptionError` or :exc:`TypeError`) and let the program "
"crash."
msgstr ""
":mod:`optparse`\\가 걱정해야 할 에러에는 두 가지가 있습니다: 프로그래머 에러와 사용자 에러. 프로그래머 에러는 "
"일반적으로 :func:`OptionParser.add_option`\\에 대한 잘못된 호출입니다, 예를 들어 잘못된 옵션 문자열, "
"알 수 없는 옵션 어트리뷰트, 누락된 옵션 어트리뷰트 등. 이러한 에러는 일반적인 방식으로 처리됩니다: "
"예외(:exc:`optparse.OptionError`\\나 :exc:`TypeError`)를 발생시키고 프로그램이 충돌하도록 "
"합니다."

#: ../../library/optparse.rst:828
msgid ""
"Handling user errors is much more important, since they are guaranteed to"
" happen no matter how stable your code is.  :mod:`optparse` can "
"automatically detect some user errors, such as bad option arguments "
"(passing ``-n 4x`` where ``-n`` takes an integer argument), missing "
"arguments (``-n`` at the end of the command line, where ``-n`` takes an "
"argument of any type).  Also, you can call :func:`OptionParser.error` to "
"signal an application-defined error condition::"
msgstr ""
"사용자 에러를 처리하는 것은 훨씬 더 중요합니다, 코드가 아무리 안정적이더라도 발생하는 것이 보장되기 때문입니다. "
":mod:`optparse`\\는 잘못된 옵션 인자 (``-n``\\이 정수 인자를 취할 때 ``-n 4x`` 전달), 누락된 "
"인자(``-n``\\이 모든 형의 인자를 취할 때, 명령 줄 끝의 ``-n``)와 같은 일부 사용자 에러를 자동으로 감지할 수 "
"있습니다. 또한, :func:`OptionParser.error`\\를 호출하여 응용 프로그램 정의 에러 조건을 알릴 수 "
"있습니다::"

#: ../../library/optparse.rst:836
msgid ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"options -a and -b are mutually exclusive\")"
msgstr ""

#: ../../library/optparse.rst:841
msgid ""
"In either case, :mod:`optparse` handles the error the same way: it prints"
" the program's usage message and an error message to standard error and "
"exits with error status 2."
msgstr ""
"두 경우 모두, :mod:`optparse`\\는 같은 방식으로 에러를 처리합니다: 프로그램의 사용법 메시지와 에러 메시지를 표준 "
"에러에 인쇄하고 에러 상태 2로 종료합니다."

#: ../../library/optparse.rst:845
msgid ""
"Consider the first example above, where the user passes ``4x`` to an "
"option that takes an integer:"
msgstr "사용자가 정수를 취하는 옵션에 ``4x``\\를 전달하는 위의 첫 번째 예를 고려하십시오:"

#: ../../library/optparse.rst:848
msgid ""
"$ /usr/bin/foo -n 4x\n"
"Usage: foo [options]\n"
"\n"
"foo: error: option -n: invalid integer value: '4x'"
msgstr ""

#: ../../library/optparse.rst:855
msgid "Or, where the user fails to pass a value at all:"
msgstr "또는 사용자가 값을 전혀 전달하지 못하는 경우:"

#: ../../library/optparse.rst:857
msgid ""
"$ /usr/bin/foo -n\n"
"Usage: foo [options]\n"
"\n"
"foo: error: -n option requires an argument"
msgstr ""

#: ../../library/optparse.rst:864
msgid ""
":mod:`optparse`\\ -generated error messages take care always to mention "
"the option involved in the error; be sure to do the same when calling "
":func:`OptionParser.error` from your application code."
msgstr ""
":mod:`optparse`\\ -생성 에러 메시지는 항상 에러와 관련된 옵션을 언급하도록 주의를 기울입니다; 응용 프로그램 "
"코드에서 :func:`OptionParser.error`\\를 호출할 때도 그래야 합니다."

#: ../../library/optparse.rst:868
msgid ""
"If :mod:`optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its "
":meth:`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""
":mod:`optparse`\\의 기본 에러 처리 동작이 여러분의 요구에 맞지 않으면, OptionParser를 서브 클래스 화하고"
" :meth:`~OptionParser.exit` 및/또는 :meth:`~OptionParser.error` 메서드를 재정의해야 "
"합니다."

#: ../../library/optparse.rst:876
msgid "Putting it all together"
msgstr "모두 합치기"

#: ../../library/optparse.rst:878
msgid "Here's what :mod:`optparse`\\ -based scripts usually look like::"
msgstr "일반적으로 :mod:`optparse` 기반 스크립트는 다음과 같습니다::"

#: ../../library/optparse.rst:880
#, python-format
msgid ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"usage: %prog [options] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"read data from FILENAME\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"incorrect number of arguments\")\n"
"    if options.verbose:\n"
"        print(\"reading %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""

#: ../../library/optparse.rst:906
msgid "Reference Guide"
msgstr "레퍼런스 지침서"

#: ../../library/optparse.rst:912
msgid "Creating the parser"
msgstr "구문 분석기 만들기"

#: ../../library/optparse.rst:914
msgid ""
"The first step in using :mod:`optparse` is to create an OptionParser "
"instance."
msgstr ":mod:`optparse`\\를 사용하는 첫 번째 단계는 OptionParser 인스턴스를 만드는 것입니다."

#: ../../library/optparse.rst:918
msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are "
"declared."
msgstr ""
"OptionParser 생성자에는 필수 인자가 없지만, 여러 선택적 키워드 인자가 있습니다. 이들을 항상 키워드 인자로 전달해야 "
"합니다, 즉, 인자가 선언된 순서에 의존하지 마십시오."

#: ../../library/optparse.rst:922
msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``usage`` (기본값: ``\"%prog [options]\"``)"

#: ../../library/optparse.rst:923
#, fuzzy
msgid ""
"The usage summary to print when your program is run incorrectly or with a"
" help option.  When :mod:`optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you "
"passed that keyword argument).  To suppress a usage message, pass the "
"special value :const:`optparse.SUPPRESS_USAGE`."
msgstr ""
"프로그램이 잘못 실행되거나 도움말(help) 옵션을 사용할 때 인쇄할 사용법 요약. :mod:`optparse`\\가 사용법 "
"문자열을 인쇄할 때, ``%prog``\\를 ``os.path.basename(sys.argv[0])``\\(또는 해당 키워드 "
"인자를 전달한 경우 ``prog``)으로 확장합니다. 사용법 메시지를 표시하지 않으려면, 특수 값 "
":data:`optparse.SUPPRESS_USAGE`\\를 전달하십시오."

#: ../../library/optparse.rst:929
msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list`` (기본값: ``[]``)"

#: ../../library/optparse.rst:930
msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` "
"(a class attribute that may be set by OptionParser subclasses), but "
"before any version or help options. Deprecated; use :meth:`add_option` "
"after creating the parser instead."
msgstr ""
"구문 분석기를 채울 Option 객체 리스트. ``option_list``\\의 옵션은 "
"``standard_option_list``\\(OptionParser 서브 클래스에서 설정할 수 있는 클래스 어트리뷰트)의 모든 "
"옵션 뒤에 추가되지만, 모든 버전(version) 또는 도움말(help) 옵션 앞에 추가됩니다. 폐지되었습니다; 대신 구문 분석기를"
" 만든 후 :meth:`add_option`\\을 사용하십시오."

#: ../../library/optparse.rst:936
msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class`` (기본값: optparse.Option)"

#: ../../library/optparse.rst:937
msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr ":meth:`add_option`\\에서 구문 분석기에 옵션을 추가할 때 사용할 클래스."

#: ../../library/optparse.rst:939
msgid "``version`` (default: ``None``)"
msgstr "``version`` (기본값: ``None``)"

#: ../../library/optparse.rst:940
msgid ""
"A version string to print when the user supplies a version option. If you"
" supply a true value for ``version``, :mod:`optparse` automatically adds "
"a version option with the single option string ``--version``.  The "
"substring ``%prog`` is expanded the same as for ``usage``."
msgstr ""
"사용자가 버전(version) 옵션을 제공할 때 인쇄 할 버전 문자열. ``version``\\에 참값을 제공하면, "
":mod:`optparse`\\는 단일 옵션 문자열 ``--version``\\으로 버전 옵션을 자동으로 추가합니다. 하위 문자열 "
"``%prog``\\는 ``usage``\\와 마찬가지로 확장됩니다."

#: ../../library/optparse.rst:945
msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``conflict_handler`` (기본값: ``\"error\"``)"

#: ../../library/optparse.rst:946
msgid ""
"Specifies what to do when options with conflicting option strings are "
"added to the parser; see section :ref:`optparse-conflicts-between-"
"options`."
msgstr ""
"충돌하는 옵션 문자열이 있는 옵션이 구문 분석기에 추가될 때 수행 할 작업을 지정합니다; 섹션 :ref:`optparse-"
"conflicts-between-options`\\을 참조하십시오."

#: ../../library/optparse.rst:950
msgid "``description`` (default: ``None``)"
msgstr "``description`` (기본값: ``None``)"

#: ../../library/optparse.rst:951
msgid ""
"A paragraph of text giving a brief overview of your program. "
":mod:`optparse` reformats this paragraph to fit the current terminal "
"width and prints it when the user requests help (after ``usage``, but "
"before the list of options)."
msgstr ""
"프로그램에 대한 간략한 개요를 제공하는 텍스트 단락. :mod:`optparse`\\는 현재 터미널 너비에 맞게 이 단락을 다시 "
"포맷하고 사용자가 도움말을 요청할 때 인쇄합니다 (``usage`` 이후, 옵션 목록 이전)."

#: ../../library/optparse.rst:956
msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr "``formatter`` (기본값: 새 :class:`IndentedHelpFormatter`)"

#: ../../library/optparse.rst:957
msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help"
" text.  :mod:`optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""
"도움말 텍스트를 인쇄하는 데 사용될 optparse.HelpFormatter의 인스턴스. :mod:`optparse`\\는 이 "
"목적으로 두 개의 구상 클래스를 제공합니다: IndentedHelpFormatter 와 TitledHelpFormatter."

#: ../../library/optparse.rst:961
msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option`` (기본값: ``True``)"

#: ../../library/optparse.rst:962
msgid ""
"If true, :mod:`optparse` will add a help option (with option strings "
"``-h`` and ``--help``) to the parser."
msgstr ""
"참이면, :mod:`optparse`\\는 구문 분석기에 도움말 옵션(옵션 문자열 ``-h``\\와 ``--help``)을 "
"추가합니다."

#: ../../library/optparse.rst:965
msgid "``prog``"
msgstr "``prog``"

#: ../../library/optparse.rst:966
msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"``usage``\\와 ``version``\\에서 ``%prog``\\를 확장할 때 "
"``os.path.basename(sys.argv[0])`` 대신 사용할 문자열."

#: ../../library/optparse.rst:969
msgid "``epilog`` (default: ``None``)"
msgstr "``epilog`` (기본값: ``None``)"

#: ../../library/optparse.rst:970
msgid "A paragraph of help text to print after the option help."
msgstr "옵션 도움말 다음에 인쇄할 도움말 텍스트 단락."

#: ../../library/optparse.rst:975
msgid "Populating the parser"
msgstr "구문 분석기 채우기"

#: ../../library/optparse.rst:977
msgid ""
"There are several ways to populate the parser with options.  The "
"preferred way is by using :meth:`OptionParser.add_option`, as shown in "
"section :ref:`optparse-tutorial`.  :meth:`add_option` can be called in "
"one of two ways:"
msgstr ""
"구문 분석기를 옵션으로 채우는 방법에는 여러 가지가 있습니다. 선호되는 방법은 섹션 :ref:`optparse-"
"tutorial`\\에 표시된 대로, :meth:`OptionParser.add_option`\\을 사용하는 것입니다. "
":meth:`add_option`\\은 다음 두 가지 방법의 하나로 호출 할 수 있습니다:"

#: ../../library/optparse.rst:981
msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr "(:func:`make_option`\\에서 반환되는 것과 같은) Option 인스턴스를 전달합니다"

#: ../../library/optparse.rst:983
msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and "
"it will create the Option instance for you"
msgstr ""
":func:`make_option`\\(즉, Option 생성자)에 허용되는 위치와 키워드 인자의 조합을 전달합니다, 그러면 "
"Option 인스턴스를 만듭니다"

#: ../../library/optparse.rst:987
msgid ""
"The other alternative is to pass a list of pre-constructed Option "
"instances to the OptionParser constructor, as in::"
msgstr "다른 대안은 다음과 같이 미리 생성된 Option 인스턴스 리스트를 OptionParser 생성자에 전달하는 것입니다::"

#: ../../library/optparse.rst:990
msgid ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""

#: ../../library/optparse.rst:998
msgid ""
"(:func:`make_option` is a factory function for creating Option instances;"
" currently it is an alias for the Option constructor.  A future version "
"of :mod:`optparse` may split Option into several classes, and "
":func:`make_option` will pick the right class to instantiate.  Do not "
"instantiate Option directly.)"
msgstr ""
"(:func:`make_option`\\은 Option 인스턴스를 만들기 위한 팩토리 함수입니다; 현재는 Option 생성자의 "
"별칭입니다. :mod:`optparse`\\의 향후 버전은 Option을 여러 클래스로 나눌 수 있으며, "
":func:`make_option`\\은 인스턴스 화할 올바른 클래스를 선택할 것입니다. Option을 직접 인스턴스 화하지 "
"마십시오.)"

#: ../../library/optparse.rst:1007
msgid "Defining options"
msgstr "옵션 정의하기"

#: ../../library/optparse.rst:1009
msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short"
" or long option strings, but you must specify at least one overall option"
" string."
msgstr ""
"각 Option 인스턴스는 동의어 명령 줄 옵션 문자열 집합을 나타냅니다, 예를 들어 ``-f``\\와 ``--file``. 짧거나"
" 긴 옵션 문자열을 얼마든지 지정할 수 있지만, 전체적으로 옵션 문자열을 적어도 하나 지정해야 합니다."

#: ../../library/optparse.rst:1013
msgid ""
"The canonical way to create an :class:`Option` instance is with the "
":meth:`add_option` method of :class:`OptionParser`."
msgstr ""
":class:`Option` 인스턴스를 만드는 규범적 방법은 :class:`OptionParser`\\의 "
":meth:`add_option` 메서드를 사용하는 것입니다."

#: ../../library/optparse.rst:1019
msgid "To define an option with only a short option string::"
msgstr "짧은 옵션 문자열로만 옵션을 정의하려면::"

#: ../../library/optparse.rst:1021
msgid "parser.add_option(\"-f\", attr=value, ...)"
msgstr ""

#: ../../library/optparse.rst:1023
msgid "And to define an option with only a long option string::"
msgstr "그리고 긴 옵션 문자열로만 옵션을 정의하려면::"

#: ../../library/optparse.rst:1025
msgid "parser.add_option(\"--foo\", attr=value, ...)"
msgstr ""

#: ../../library/optparse.rst:1027
msgid ""
"The keyword arguments define attributes of the new Option object.  The "
"most important option attribute is :attr:`~Option.action`, and it largely"
" determines which other attributes are relevant or required.  If you pass"
" irrelevant option attributes, or fail to pass required ones, "
":mod:`optparse` raises an :exc:`OptionError` exception explaining your "
"mistake."
msgstr ""
"키워드 인자는 새 Option 객체의 어트리뷰트를 정의합니다. 가장 중요한 옵션 어트리뷰트는 "
":attr:`~Option.action`\\이며, 전체적으로 어떤 어트리뷰트가 관련성이 있거나 필요한지를 결정합니다. 관련 없는 "
"옵션 어트리뷰트를 전달하거나, 필수 어트리뷰트를 전달하지 못하면, :mod:`optparse`\\는 실수를 설명하는 "
":exc:`OptionError` 예외를 발생시킵니다."

#: ../../library/optparse.rst:1033
msgid ""
"An option's *action* determines what :mod:`optparse` does when it "
"encounters this option on the command-line.  The standard option actions "
"hard-coded into :mod:`optparse` are:"
msgstr ""
"옵션의 *action*\\은 명령 줄에서 이 옵션을 만날 때 :mod:`optparse`\\가 수행하는 작업을 결정합니다. "
":mod:`optparse`\\에 하드 코딩된 표준 옵션 액션은 다음과 같습니다:"

#: ../../library/optparse.rst:1037
msgid "``\"store\"``"
msgstr "``\"store\"``"

#: ../../library/optparse.rst:1038
msgid "store this option's argument (default)"
msgstr "이 옵션의 인자를 저장합니다 (기본값)"

#: ../../library/optparse.rst:1043
msgid "``\"store_true\"``"
msgstr "``\"store_true\"``"

#: ../../library/optparse.rst:1044
msgid "store ``True``"
msgstr "``True``\\를 저장합니다"

#: ../../library/optparse.rst:1046
msgid "``\"store_false\"``"
msgstr "``\"store_false\"``"

#: ../../library/optparse.rst:1047
msgid "store ``False``"
msgstr "``False``\\를 저장합니다"

#: ../../library/optparse.rst:1052
msgid "``\"append_const\"``"
msgstr "``\"append_const\"``"

#: ../../library/optparse.rst:1053
#, fuzzy
msgid "append a constant value to a list, pre-set via :attr:`Option.const`"
msgstr "리스트에 상숫값을 추가합니다"

#: ../../library/optparse.rst:1061 ../../library/optparse.rst:1356
msgid "``\"help\"``"
msgstr "``\"help\"``"

#: ../../library/optparse.rst:1062
msgid "print a usage message including all options and the documentation for them"
msgstr "모든 옵션과 해당 설명을 포함하는 사용법 메시지를 인쇄합니다"

#: ../../library/optparse.rst:1064
msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest`"
" option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"(액션을 제공하지 않으면, 기본값은 ``\"store\"``\\입니다. 이 액션의 경우, :attr:`~Option.type`\\과"
" :attr:`~Option.dest` 옵션 어트리뷰트도 제공할 수 있습니다; :ref:`optparse-standard-"
"option-actions`\\을 참조하십시오.)"

#: ../../library/optparse.rst:1068
#, fuzzy
msgid ""
"As you can see, most actions involve storing or updating a value "
"somewhere. :mod:`optparse` always creates a special object for this, "
"conventionally called ``options``, which is an instance of "
":class:`optparse.Values`."
msgstr ""
"보시다시피, 대부분의 액션은 값을 어딘가에 저장하거나 갱신하는 것을 수반합니다. :mod:`optparse`\\는 항상 이를 위해 "
"일반적으로 ``options``\\(:class:`optparse.Values`\\의 인스턴스)라고 하는 특수 객체를 만듭니다. "
"옵션 인자(및 기타 다양한 값)는 :attr:`~Option.dest` (destination) 옵션 어트리뷰트에 따라, 이 객체의"
" 어트리뷰트로 저장됩니다."

#: ../../library/optparse.rst:1074
msgid ""
"An object holding parsed argument names and values as attributes. "
"Normally created by calling when calling :meth:`OptionParser.parse_args`,"
" and can be overridden by a custom subclass passed to the *values* "
"argument of :meth:`OptionParser.parse_args` (as described in :ref"
":`optparse-parsing-arguments`)."
msgstr ""

#: ../../library/optparse.rst:1079
msgid ""
"Option arguments (and various other values) are stored as attributes of "
"this object, according to the :attr:`~Option.dest` (destination) option "
"attribute."
msgstr ""

#: ../../library/optparse.rst:1083
msgid "For example, when you call ::"
msgstr "예를 들어, 다음과 같이 호출할 때 ::"

#: ../../library/optparse.rst:1085
#, fuzzy
msgid "parser.parse_args()"
msgstr "``parser.rargs``"

#: ../../library/optparse.rst:1087
msgid ""
"one of the first things :mod:`optparse` does is create the ``options`` "
"object::"
msgstr ":mod:`optparse`\\가 하는 첫 번째 작업 중 하나는 ``options`` 객체를 만드는 것입니다::"

#: ../../library/optparse.rst:1089
#, fuzzy
msgid "options = Values()"
msgstr "옵션 어트리뷰트"

#: ../../library/optparse.rst:1091
msgid "If one of the options in this parser is defined with ::"
msgstr "이 구문 분석기의 옵션 중 하나가 다음과 같이 정의되었으면::"

#: ../../library/optparse.rst:1093
msgid ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"
msgstr ""

#: ../../library/optparse.rst:1095
msgid "and the command-line being parsed includes any of the following::"
msgstr "그리고 구문 분석 중인 명령 줄에는 다음 중 하나가 포함되면::"

#: ../../library/optparse.rst:1097
msgid ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--file foo"
msgstr ""

#: ../../library/optparse.rst:1102
msgid "then :mod:`optparse`, on seeing this option, will do the equivalent of ::"
msgstr ":mod:`optparse`\\는 이 옵션을 볼 때 다음과 동등한 일을 합니다 ::"

#: ../../library/optparse.rst:1104
msgid "options.filename = \"foo\""
msgstr ""

#: ../../library/optparse.rst:1106
msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action`"
" is the only one that makes sense for *all* options."
msgstr ""
":attr:`~Option.type`\\과 :attr:`~Option.dest` 옵션 어트리뷰트는 "
":attr:`~Option.action`\\만큼 중요하지만, :attr:`~Option.action`\\은 *모든* 옵션에 적합한 "
"유일한 어트리뷰트입니다."

#: ../../library/optparse.rst:1114
msgid "Option attributes"
msgstr "옵션 어트리뷰트"

#: ../../library/optparse.rst:1118
msgid ""
"A single command line argument, with various attributes passed by keyword"
" to the constructor. Normally created with "
":meth:`OptionParser.add_option` rather than directly, and can be "
"overridden by a custom class via the *option_class* argument to "
":class:`OptionParser`."
msgstr ""

#: ../../library/optparse.rst:1124
msgid ""
"The following option attributes may be passed as keyword arguments to "
":meth:`OptionParser.add_option`.  If you pass an option attribute that is"
" not relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`optparse` raises :exc:`OptionError`."
msgstr ""
"다음 옵션 어트리뷰트는 :meth:`OptionParser.add_option`\\에 키워드 인자로 전달될 수 있습니다. 특정 "
"옵션과 관련이 없는 옵션 어트리뷰트를 전달하거나, 필수 옵션 어트리뷰트를 전달하지 못하면 :mod:`optparse`\\는 "
":exc:`OptionError`\\를 발생시킵니다."

#: ../../library/optparse.rst:1131
msgid "(default: ``\"store\"``)"
msgstr "(기본값: ``\"store\"``)"

#: ../../library/optparse.rst:1133
msgid ""
"Determines :mod:`optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""
"이 옵션이 명령 줄에서 보일 때 :mod:`optparse`\\의 동작을 결정합니다; 사용 가능한 옵션은 :ref:`여기 "
"<optparse-standard-option-actions>`\\에 설명되어 있습니다."

#: ../../library/optparse.rst:1139
msgid "(default: ``\"string\"``)"
msgstr "(기본값: ``\"string\"``)"

#: ../../library/optparse.rst:1141
msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here "
"<optparse-standard-option-types>`."
msgstr ""
"이 옵션이 기대하는 인자 형 (예를 들어, ``\"string\"``\\이나 ``\"int\"``); 사용 가능한 옵션 형은 "
":ref:`여기 <optparse-standard-option-types>`\\에 설명되어 있습니다."

#: ../../library/optparse.rst:1147 ../../library/optparse.rst:1197
msgid "(default: derived from option strings)"
msgstr "(기본값: 옵션 문자열에서 파생됩니다)"

#: ../../library/optparse.rst:1149
msgid ""
"If the option's action implies writing or modifying a value somewhere, "
"this tells :mod:`optparse` where to write it: :attr:`~Option.dest` names "
"an attribute of the ``options`` object that :mod:`optparse` builds as it "
"parses the command line."
msgstr ""
"옵션의 액션이 어딘가에 값을 쓰거나 수정하는 것을 의미하면, 이것은 :mod:`optparse`\\에게 어디에 쓸 것인지 "
"알려줍니다: :attr:`~Option.dest`\\는 명령 줄을 구문 분석할 때 :mod:`optparse`\\가 빌드하는 "
"``options`` 객체의 어트리뷰트의 이름을 정합니다."

#: ../../library/optparse.rst:1156
msgid ""
"The value to use for this option's destination if the option is not seen "
"on the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr ""
"옵션이 명령 줄에서 보이지 않으면 이 옵션의 대상에 사용할 값. :meth:`OptionParser.set_defaults`\\도 "
"참조하십시오."

#: ../../library/optparse.rst:1161
msgid "(default: 1)"
msgstr "(기본값: 1)"

#: ../../library/optparse.rst:1163
msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when "
"this option is seen.  If > 1, :mod:`optparse` will store a tuple of "
"values to :attr:`~Option.dest`."
msgstr ""
"이 옵션이 보일 때 소비되어야 하는 :attr:`~Option.type` 형의 인자 수입니다. > 1 이면, "
":mod:`optparse`\\는 값의 튜플을 :attr:`~Option.dest`\\에 저장합니다."

#: ../../library/optparse.rst:1169
msgid "For actions that store a constant value, the constant value to store."
msgstr "상숫값을 저장하는 액션의 경우, 저장할 상숫값."

#: ../../library/optparse.rst:1173
msgid ""
"For options of type ``\"choice\"``, the list of strings the user may "
"choose from."
msgstr "``\"choice\"`` 형 옵션의 경우, 사용자가 이 중에서 선택할 수 있는 문자열 리스트."

#: ../../library/optparse.rst:1178
msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail "
"on the arguments passed to the callable."
msgstr ""
"액션 ``\"callback\"``\\이 있는 옵션의 경우, 이 옵션이 보일 때 호출 할 콜러블. 콜러블에 전달된 인자에 대한 "
"자세한 내용은 섹션 :ref:`optparse-option-callbacks`\\을 참조하십시오."

#: ../../library/optparse.rst:1185
msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after"
" the four standard callback arguments."
msgstr "4개의 표준 콜백 인자 다음에 ``callback``\\에 전달할 추가 위치와 키워드 인자."

#: ../../library/optparse.rst:1190
#, fuzzy
msgid ""
"Help text to print for this option when listing all available options "
"after the user supplies a :attr:`~Option.help` option (such as "
"``--help``).  If no help text is supplied, the option will be listed "
"without help text.  To hide this option, use the special value "
":const:`optparse.SUPPRESS_HELP`."
msgstr ""
"사용자가 :attr:`~Option.help` 옵션을 제공한 (가령 ``--help``) 후 사용 가능한 모든 옵션을 나열할 때 이"
" 옵션에 대해 인쇄할 도움말 텍스트. 도움말 텍스트가 제공되지 않으면, 옵션이 도움말 텍스트 없이 나열됩니다. 이 옵션을 숨기려면,"
" 특수 값 :data:`optparse.SUPPRESS_HELP`\\를 사용하십시오."

#: ../../library/optparse.rst:1199
msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr ""
"도움말 텍스트를 인쇄할 때 사용할 옵션 인자를 나타냅니다. 예제는 섹션 :ref:`optparse-tutorial`\\를 "
"참조하십시오."

#: ../../library/optparse.rst:1206
msgid "Standard option actions"
msgstr "표준 옵션 액션"

#: ../../library/optparse.rst:1208
msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you "
"may specify to guide :mod:`optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""
"다양한 옵션 액션은 모두 요구 사항과 효과가 약간 다릅니다. 대부분의 액션에는 :mod:`optparse`\\의 동작을 안내하기 "
"위해 지정할 수 있는 몇 가지 연관된 옵션 어트리뷰트가 있습니다; 일부는 해당 액션을 사용하는 모든 옵션에 대해 지정해야 하는 필수"
" 어트리뷰트가 있습니다."

#: ../../library/optparse.rst:1213
msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"store\"`` [연관된 옵션: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1216
msgid ""
"The option must be followed by an argument, which is converted to a value"
" according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  "
"If :attr:`~Option.nargs` > 1, multiple arguments will be consumed from "
"the command line; all will be converted according to :attr:`~Option.type`"
" and stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-"
"standard-option-types` section."
msgstr ""
"옵션 뒤에 인자가 와야 하며, 인자는 :attr:`~Option.type`\\에 따라 값으로 변환되고, "
":attr:`~Option.dest`\\에 저장됩니다. :attr:`~Option.nargs` > 1 이면, 명령 줄에서 여러 "
"인자가 소비됩니다; 모두 :attr:`~Option.type`\\에 따라 변환되고 :attr:`~Option.dest`\\에 튜플로"
" 저장됩니다. :ref:`optparse-standard-option-types` 섹션을 참조하십시오."

#: ../../library/optparse.rst:1223
msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr ""
":attr:`~Option.choices`\\가 제공되면 (문자열 리스트나 튜플), 형의 기본값은 "
"``\"choice\"``\\입니다."

#: ../../library/optparse.rst:1226
msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr ":attr:`~Option.type`\\이 제공되지 않으면, 기본값은 ``\"string\"``\\입니다."

#: ../../library/optparse.rst:1228
msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` "
"implies ``foo_bar``). If there are no long option strings, "
":mod:`optparse` derives a destination from the first short option string "
"(e.g., ``-f`` implies ``f``)."
msgstr ""
":attr:`~Option.dest`\\가 제공되지 않으면, :mod:`optparse`\\는 첫 번째 긴 옵션 문자열에서 대상을 "
"파생합니다 (예를 들어, ``--foo-bar``\\는 ``foo_bar``\\를 암시합니다). 긴 옵션 문자열이 없으면, "
":mod:`optparse`\\는 첫 번째 짧은 옵션 문자열에서 대상을 파생합니다 (예를 들어, ``-f``\\는 ``f``\\를 "
"암시합니다)."

#: ../../library/optparse.rst:1233 ../../library/optparse.rst:1253
#: ../../library/optparse.rst:1275 ../../library/optparse.rst:1293
#: ../../library/optparse.rst:1332 ../../library/optparse.rst:1370
msgid "Example::"
msgstr "예::"

#: ../../library/optparse.rst:1235
msgid ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"
msgstr ""

#: ../../library/optparse.rst:1238
msgid "As it parses the command line ::"
msgstr "다음과 같은 명령 줄을 구문 분석할 때 ::"

#: ../../library/optparse.rst:1240
msgid "-f foo.txt -p 1 -3.5 4 -fbar.txt"
msgstr ""

#: ../../library/optparse.rst:1242
msgid ":mod:`optparse` will set ::"
msgstr ":mod:`optparse`\\는 다음과 같이 설정합니다 ::"

#: ../../library/optparse.rst:1244
msgid ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""
msgstr ""

#: ../../library/optparse.rst:1248
msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: "
":attr:`~Option.dest`]"
msgstr ""
"``\"store_const\"`` [필수 옵션: :attr:`~Option.const`; 연관된 옵션: "
":attr:`~Option.dest`]"

#: ../../library/optparse.rst:1251
msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "값 :attr:`~Option.const`\\는 :attr:`~Option.dest`\\에 저장됩니다."

#: ../../library/optparse.rst:1255
msgid ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"
msgstr ""

#: ../../library/optparse.rst:1262
msgid "If ``--noisy`` is seen, :mod:`optparse` will set  ::"
msgstr "``--noisy``\\가 보이면, :mod:`optparse`\\는 다음과 같이 설정합니다 ::"

#: ../../library/optparse.rst:1264
msgid "options.verbose = 2"
msgstr ""

#: ../../library/optparse.rst:1266
msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [연관된 옵션: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1268
msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to "
":attr:`~Option.dest`."
msgstr "``True``\\를 :attr:`~Option.dest`\\에 저장하는 ``\"store_const\"``\\의 특별한 경우."

#: ../../library/optparse.rst:1271
msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [연관된 옵션: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1273
msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "``\"store_true\"``\\와 비슷하지만, ``False``\\를 저장합니다."

#: ../../library/optparse.rst:1277
msgid ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")"
"\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", "
"dest=\"clobber\")"
msgstr ""

#: ../../library/optparse.rst:1280
msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"append\"`` [연관된 옵션: :attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1283
msgid ""
"The option must be followed by an argument, which is appended to the list"
" in :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` "
"is supplied, an empty list is automatically created when :mod:`optparse` "
"first encounters this option on the command-line.  If "
":attr:`~Option.nargs` > 1, multiple arguments are consumed, and a tuple "
"of length :attr:`~Option.nargs` is appended to :attr:`~Option.dest`."
msgstr ""
"옵션 다음에는 :attr:`~Option.dest`\\의 리스트에 추가되는 인자가 와야 합니다. "
":attr:`~Option.dest`\\의 기본값이 제공되지 않으면, :mod:`optparse`\\가 명령 줄에서 이 옵션을 처음"
" 발견할 때 빈 리스트가 자동으로 만들어집니다. :attr:`~Option.nargs` > 1 이면, 여러 인자가 소비되며, "
":attr:`~Option.nargs` 길이의 튜플이 :attr:`~Option.dest`\\에 추가됩니다."

#: ../../library/optparse.rst:1290
msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the "
"same as for the ``\"store\"`` action."
msgstr ""
":attr:`~Option.type`\\과 :attr:`~Option.dest`\\의 기본값은 ``\"store\"`` 액션의 "
"경우와 같습니다."

#: ../../library/optparse.rst:1295
msgid "parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"
msgstr ""

#: ../../library/optparse.rst:1297
msgid ""
"If ``-t3`` is seen on the command-line, :mod:`optparse` does the "
"equivalent of::"
msgstr "``-t3``\\가 명령 줄에 보이면, :mod:`optparse`\\는 다음과 동등한 것을 수행합니다::"

#: ../../library/optparse.rst:1300
msgid ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"
msgstr ""

#: ../../library/optparse.rst:1303
msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "잠시 후, ``--tracks=4``\\가 보이면, 다음을 수행합니다::"

#: ../../library/optparse.rst:1305
msgid "options.tracks.append(int(\"4\"))"
msgstr ""

#: ../../library/optparse.rst:1307
msgid ""
"The ``append`` action calls the ``append`` method on the current value of"
" the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty,"
" the default elements will be present in the parsed value for the option,"
" with any values from the command line appended after those default "
"values::"
msgstr ""
"``append`` 액션은 옵션의 현재 값에 대해 ``append`` 메서드를 호출합니다. 이는 지정된 모든 기본값에 "
"``append`` 메서드가 있어야 함을 의미합니다. 또한, 기본값이 비어 있지 않으면, 기본 요소가 옵션의 구문 분석된 값에 "
"존재하며, 명령 줄의 모든 값이 기본값 뒤에 추가됨을 의미합니다::"

#: ../../library/optparse.rst:1313
msgid ""
">>> parser.add_option(\"--files\", action=\"append\", "
"default=['~/.mypkg/defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"
msgstr ""

#: ../../library/optparse.rst:1318
msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: "
":attr:`~Option.dest`]"
msgstr ""
"``\"append_const\"`` [필수 옵션: :attr:`~Option.const`; 연관된 옵션: "
":attr:`~Option.dest`]"

#: ../../library/optparse.rst:1321
msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended"
" to :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` "
"defaults to ``None``, and an empty list is automatically created the "
"first time the option is encountered."
msgstr ""
"``\"store_const\"``\\와 비슷하지만, :attr:`~Option.const` 값이 "
":attr:`~Option.dest`\\에 추가됩니다; ``\"append\"``\\와 마찬가지로, "
":attr:`~Option.dest`\\의 기본값은 ``None``\\이며, 옵션이 처음 발견될 때 빈 리스트가 자동으로 "
"만들어집니다."

#: ../../library/optparse.rst:1326
msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [연관된 옵션: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1328
msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default "
"value is supplied, :attr:`~Option.dest` is set to zero before being "
"incremented the first time."
msgstr ""
":attr:`~Option.dest`\\에 저장된 정수를 증가시킵니다. 기본값이 제공되지 않으면, "
":attr:`~Option.dest`\\는 처음으로 증가하기 전에 0으로 설정됩니다."

#: ../../library/optparse.rst:1334
msgid "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"
msgstr ""

#: ../../library/optparse.rst:1336
msgid ""
"The first time ``-v`` is seen on the command line, :mod:`optparse` does "
"the equivalent of::"
msgstr "``-v``\\가 명령 줄에서 처음 보이면, :mod:`optparse`\\는 다음과 동등한 작업을 수행합니다::"

#: ../../library/optparse.rst:1339
msgid ""
"options.verbosity = 0\n"
"options.verbosity += 1"
msgstr ""

#: ../../library/optparse.rst:1342
msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "이후에 ``-v``\\가 나타날 때마다 다음과 같이 합니다 ::"

#: ../../library/optparse.rst:1344
msgid "options.verbosity += 1"
msgstr ""

#: ../../library/optparse.rst:1346
msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: "
":attr:`~Option.type`, :attr:`~Option.nargs`, "
":attr:`~Option.callback_args`, :attr:`~Option.callback_kwargs`]"
msgstr ""
"``\"callback\"`` [필수 옵션: :attr:`~Option.callback`; 연관된 옵션: "
":attr:`~Option.type`, :attr:`~Option.nargs`, "
":attr:`~Option.callback_args`, :attr:`~Option.callback_kwargs`]"

#: ../../library/optparse.rst:1350
msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called "
"as ::"
msgstr ":attr:`~Option.callback`\\으로 지정된 함수를 호출합니다, 이 함수는 다음과 같이 호출됩니다 ::"

#: ../../library/optparse.rst:1352 ../../library/optparse.rst:1750
msgid "func(option, opt_str, value, parser, *args, **kwargs)"
msgstr ""

#: ../../library/optparse.rst:1354
msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr "자세한 내용은 섹션 :ref:`optparse-option-callbacks`\\을 참조하십시오."

#: ../../library/optparse.rst:1358
msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed"
" to OptionParser's constructor and the :attr:`~Option.help` string passed"
" to every option."
msgstr ""
"현재 옵션 구문 분석기의 모든 옵션에 대한 전체 도움말 메시지를 인쇄합니다. 도움말 메시지는 OptionParser의 생성자에 "
"전달된 ``usage`` 문자열과 모든 옵션에 전달된 :attr:`~Option.help` 문자열로 구성됩니다."

#: ../../library/optparse.rst:1363
#, fuzzy
msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will "
"still be listed in the help message.  To omit an option entirely, use the"
" special value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"옵션에 :attr:`~Option.help` 문자열이 제공되지 않아도, 도움말 메시지에 나열됩니다. 옵션을 완전히 생략하려면, 특수"
" 값 :data:`optparse.SUPPRESS_HELP`\\를 사용하십시오."

#: ../../library/optparse.rst:1367
msgid ""
":mod:`optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""
":mod:`optparse`\\는 모든 OptionParser에 :attr:`~Option.help` 옵션을 자동으로 추가하므로, "
"일반적으로 만들 필요가 없습니다."

#: ../../library/optparse.rst:1372
msgid ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# usually, a help option is added automatically, but that can\n"
"# be suppressed using the add_help_option argument\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Be moderately verbose\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Input file to read data from\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"
msgstr ""

#: ../../library/optparse.rst:1385
msgid ""
"If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line, "
"it will print something like the following help message to stdout "
"(assuming ``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""
":mod:`optparse`\\가 명령 줄에서 ``-h``\\나 ``--help``\\를 보면, 다음 도움말 메시지와 같은 내용을 "
"stdout에 인쇄합니다 (``sys.argv[0]``\\이 ``\"foo.py\"``\\라고 가정합니다):"

#: ../../library/optparse.rst:1389
msgid ""
"Usage: foo.py [options]\n"
"\n"
"Options:\n"
"  -h, --help        Show this help message and exit\n"
"  -v                Be moderately verbose\n"
"  --file=FILENAME   Input file to read data from"
msgstr ""

#: ../../library/optparse.rst:1398
msgid ""
"After printing the help message, :mod:`optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr "도움말 메시지를 인쇄한 후, :mod:`optparse`\\는 ``sys.exit(0)``\\으로 프로세스를 종료합니다."

#: ../../library/optparse.rst:1401
msgid "``\"version\"``"
msgstr "``\"version\"``"

#: ../../library/optparse.rst:1403
msgid ""
"Prints the version number supplied to the OptionParser to stdout and "
"exits. The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if "
"the ``version`` argument is supplied to the OptionParser constructor.  As"
" with :attr:`~Option.help` options, you will rarely create ``version`` "
"options, since :mod:`optparse` automatically adds them when needed."
msgstr ""
"OptionParser에 제공된 버전 번호를 stdout에 인쇄하고 종료합니다. 버전 번호는 실제로 OptionParser의 "
"``print_version()`` 메서드에 의해 포맷되고 인쇄됩니다. 일반적으로 ``version`` 인자가 "
"OptionParser 생성자에 제공되는 경우에만 의미가 있습니다. :attr:`~Option.help` 옵션과 마찬가지로, "
":mod:`optparse`\\는 필요할 때 자동으로 추가하기 때문에, ``version`` 옵션을 거의 만들지 않습니다."

#: ../../library/optparse.rst:1414
msgid "Standard option types"
msgstr "표준 옵션 형"

#: ../../library/optparse.rst:1416
msgid ""
":mod:`optparse` has five built-in option types: ``\"string\"``, "
"``\"int\"``, ``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you "
"need to add new option types, see section :ref:`optparse-extending-"
"optparse`."
msgstr ""
":mod:`optparse`\\에는 다섯 가지 내장 옵션 형이 있습니다: ``\"string\"``, ``\"int\"``, "
"``\"choice\"``, ``\"float\"`` 및 ``\"complex\"``. 새로운 옵션 형을 추가해야 하면, 섹션 "
":ref:`optparse-extending-optparse`\\를 참조하십시오."

#: ../../library/optparse.rst:1420
msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr ""
"문자열 옵션에 대한 인자는 어떤 방식으로도 검사되거나 변환되지 않습니다: 명령 줄의 텍스트는 있는 그대로 대상에 저장(또는 콜백에 "
"전달)됩니다."

#: ../../library/optparse.rst:1423
msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr "정수 인자(``\"int\"`` 형)는 다음과 같이 구문 분석됩니다:"

#: ../../library/optparse.rst:1425
msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr "숫자가 ``0x``\\로 시작하면, 16진수로 구문 분석됩니다"

#: ../../library/optparse.rst:1427
msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "숫자가 ``0``\\으로 시작하면, 8진수로 구문 분석됩니다"

#: ../../library/optparse.rst:1429
msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr "숫자가 ``0b``\\로 시작하면, 이진수로 구문 분석됩니다"

#: ../../library/optparse.rst:1431
msgid "otherwise, the number is parsed as a decimal number"
msgstr "그렇지 않으면, 숫자는 10진수로 구문 분석됩니다"

#: ../../library/optparse.rst:1434
msgid ""
"The conversion is done by calling :func:`int` with the appropriate base "
"(2, 8, 10, or 16).  If this fails, so will :mod:`optparse`, although with"
" a more useful error message."
msgstr ""
"변환은 적절한 진수(2, 8, 10 또는 16)로 :func:`int`\\를 호출하여 수행됩니다. 이것이 실패하면, 더 유용한 에러"
" 메시지를 제공하기는 하지만, :mod:`optparse`\\도 마찬가지로 실패합니다."

#: ../../library/optparse.rst:1438
msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly"
" with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"``\"float\"``\\와 ``\"complex\"`` 옵션 인자는 유사한 에러 처리로 :func:`float`\\와 "
":func:`complex`\\로 직접 변환됩니다."

#: ../../library/optparse.rst:1441
msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The "
":attr:`~Option.choices` option attribute (a sequence of strings) defines "
"the set of allowed option arguments.  :func:`optparse.check_choice` "
"compares user-supplied option arguments against this master list and "
"raises :exc:`OptionValueError` if an invalid string is given."
msgstr ""
"``\"choice\"`` 옵션은 ``\"string\"`` 옵션의 서브 형입니다. :attr:`~Option.choices` 옵션"
" 어트리뷰트(문자열 시퀀스)는 허용되는 옵션 인자 집합을 정의합니다. :func:`optparse.check_choice`\\는 "
"사용자가 제공한 옵션 인자를 이 마스터 리스트와 비교하고 유효하지 않은 문자열이 주어지면 :exc:`OptionValueError`"
" 를 발생시킵니다."

#: ../../library/optparse.rst:1451
msgid "Parsing arguments"
msgstr "인자 구문 분석하기"

#: ../../library/optparse.rst:1453
#, fuzzy
msgid ""
"The whole point of creating and populating an OptionParser is to call its"
" :meth:`~OptionParser.parse_args` method."
msgstr "OptionParser를 만들고 채우는 것의 요점은 :meth:`parse_args` 메서드를 호출하는 것입니다::"

#: ../../library/optparse.rst:1458
msgid "Parse the command-line options found in *args*."
msgstr ""

#: ../../library/optparse.rst:1460
#, fuzzy
msgid "The input parameters are"
msgstr "여기서 입력 매개 변수는"

#: ../../library/optparse.rst:1462 ../../library/optparse.rst:1476
#: ../../library/optparse.rst:1794
msgid "``args``"
msgstr "``args``"

#: ../../library/optparse.rst:1463
msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "처리할 인자의 리스트 (기본값: ``sys.argv[1:]``)"

#: ../../library/optparse.rst:1465
msgid "``values``"
msgstr "``values``"

#: ../../library/optparse.rst:1466
#, fuzzy
msgid ""
"a :class:`Values` object to store option arguments in (default: a new "
"instance of :class:`Values`) -- if you give an existing object, the "
"option defaults will not be initialized on it"
msgstr ""
"옵션 인자를 저장할 :class:`optparse.Values` 객체 (기본값: :class:`Values`\\의 새 인스턴스) "
"-- 기존 객체를 제공하면, 옵션 기본값이 초기화되지 않습니다."

#: ../../library/optparse.rst:1470
#, fuzzy
msgid "and the return value is a pair ``(options, args)`` where"
msgstr "그리고 반환 값은"

#: ../../library/optparse.rst:1472
msgid "``options``"
msgstr "``options``"

#: ../../library/optparse.rst:1473
#, fuzzy
msgid ""
"the same object that was passed in as *values*, or the "
"``optparse.Values`` instance created by :mod:`optparse`"
msgstr "``values``\\로 전달된 것과 같은 객체, 또는 :mod:`optparse`\\가 만든 optparse.Values 인스턴스"

#: ../../library/optparse.rst:1477
msgid "the leftover positional arguments after all options have been processed"
msgstr "모든 옵션이 처리된 후 남은 위치 인자"

#: ../../library/optparse.rst:1479
#, fuzzy
msgid ""
"The most common usage is to supply neither keyword argument.  If you "
"supply ``values``, it will be modified with repeated :func:`setattr` "
"calls (roughly one for every option argument stored to an option "
"destination) and returned by :meth:`~OptionParser.parse_args`."
msgstr ""
"가장 일반적인 사용법은 두 키워드 인자 중 어느 것도 제공하지 않는 것입니다. ``values``\\를 제공하면, 반복된 "
":func:`setattr` 호출(옵션 대상에 저장된 모든 옵션 인자에 대해 대략 하나씩)로 수정되고, "
":meth:`parse_args`\\에서 반환됩니다."

#: ../../library/optparse.rst:1484
#, fuzzy
msgid ""
"If :meth:`~OptionParser.parse_args` encounters any errors in the argument"
" list, it calls the OptionParser's :meth:`error` method with an "
"appropriate end-user error message. This ultimately terminates your "
"process with an exit status of 2 (the traditional Unix exit status for "
"command-line errors)."
msgstr ""
":meth:`parse_args`\\가 인자 리스트에서 에러를 만나면, 적절한 최종 사용자 에러 메시지와 함께 "
"OptionParser의 :meth:`error` 메서드를 호출합니다. 이는 궁극적으로 종료 상태 2(명령 줄 에러에 대한 전통적인"
" 유닉스 종료 상태)로 프로세스를 종료합니다."

#: ../../library/optparse.rst:1493
msgid "Querying and manipulating your option parser"
msgstr "옵션 구문 분석기를 조회하고 조작하기"

#: ../../library/optparse.rst:1495
msgid ""
"The default behavior of the option parser can be customized slightly, and"
" you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr ""
"옵션 구문 분석기의 기본 동작은 약간 사용자 정의 할 수 있으며, 옵션 구문 분석기를 들여다보고 거기에 무엇이 있는지 볼 수도 "
"있습니다. OptionParser는 다음과 같은 몇 가지 메서드를 제공합니다:"

#: ../../library/optparse.rst:1501
msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and "
"``-b`` are both simple options that take no arguments, :mod:`optparse` "
"normally accepts this syntax::"
msgstr ""
"첫 번째 옵션이 아닌 것에서 중지하도록 구문 분석을 설정합니다. 예를 들어 ``-a``\\와 ``-b``\\가 모두 인자를 취하지 "
"않는 간단한 옵션이면, :mod:`optparse`\\는 일반적으로 다음 문법을 허용합니다::"

#: ../../library/optparse.rst:1505
msgid "prog -a arg1 -b arg2"
msgstr ""

#: ../../library/optparse.rst:1507
msgid "and treats it as equivalent to  ::"
msgstr "그리고 다음과 동등하게 취급합니다 ::"

#: ../../library/optparse.rst:1509
msgid "prog -a -b arg1 arg2"
msgstr ""

#: ../../library/optparse.rst:1511
msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the "
"first non-option argument."
msgstr ""
"이 기능을 비활성화하려면, :meth:`disable_interspersed_args`\\를 호출하십시오. 이렇게 하면 옵션 구문 "
"분석이 첫 번째 옵션이 아닌 인자에서 중지되는, 전통적인 유닉스 문법이 복원됩니다."

#: ../../library/optparse.rst:1515
msgid ""
"Use this if you have a command processor which runs another command which"
" has options of its own and you want to make sure these options don't get"
" confused.  For example, each command might have a different set of "
"options."
msgstr ""
"자체 옵션이 있는 다른 명령을 실행하는 명령 프로세서가 있고 이러한 옵션이 혼동되지 않도록 하려면 이것을 사용하십시오. 예를 들어,"
" 각 명령에는 다른 옵션 집합이 있을 수 있습니다."

#: ../../library/optparse.rst:1521
msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr ""
"첫 번째 옵션이 아닌 것에서 구문 분석이 중지되지 않도록 설정하여, 명령 인자와 스위치를 분산시킬 수 있도록 합니다. 이것이 기본 "
"동작입니다."

#: ../../library/optparse.rst:1526
msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None``"
" if no options have that option string."
msgstr ""
"옵션 문자열 *opt_str*\\을 갖는 Option 인스턴스를 반환합니다, 또는 해당 옵션 문자열을 갖는 옵션이 없으면 "
"``None``\\을 반환합니다."

#: ../../library/optparse.rst:1531
msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"OptionParser에 옵션 문자열 *opt_str*\\을 갖는 옵션이 있으면 ``True``\\를 반환합니다 (예를 들어, "
"``-q``\\나 ``--verbose``)."

#: ../../library/optparse.rst:1536
msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, "
"that option is removed.  If that option provided any other option "
"strings, all of those option strings become invalid. If *opt_str* does "
"not occur in any option belonging to this :class:`OptionParser`, raises "
":exc:`ValueError`."
msgstr ""
":class:`OptionParser`\\에 *opt_str*\\에 해당하는 옵션이 있으면, 해당 옵션이 제거됩니다. 해당 옵션이 "
"다른 옵션 문자열을 제공하면, 해당 옵션 문자열은 모두 유효하지 않게 됩니다. 이 :class:`OptionParser`\\에 "
"속하는 옵션에서 *opt_str*\\이 등장하지 않으면, :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/optparse.rst:1545
msgid "Conflicts between options"
msgstr "옵션 간의 충돌"

#: ../../library/optparse.rst:1547
msgid ""
"If you're not careful, it's easy to define options with conflicting "
"option strings::"
msgstr "주의하지 않으면, 충돌하는 옵션 문자열을 갖는 옵션을 정의하기 쉽습니다::"

#: ../../library/optparse.rst:1550
msgid ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"
msgstr ""

#: ../../library/optparse.rst:1554
msgid ""
"(This is particularly true if you've defined your own OptionParser "
"subclass with some standard options.)"
msgstr "(일부 표준 옵션을 사용하여 자체 OptionParser 서브 클래스를 정의한 경우 특히 그렇습니다.)"

#: ../../library/optparse.rst:1557
msgid ""
"Every time you add an option, :mod:`optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-"
"handling mechanism. You can set the conflict-handling mechanism either in"
" the constructor::"
msgstr ""
"옵션을 추가할 때마다, :mod:`optparse`\\는 기존 옵션과의 충돌을 확인합니다. 발견되면, 현재 충돌 처리 메커니즘을 "
"호출합니다. 충돌 처리 메커니즘을 설정할 수 있는데, 생성자에서::"

#: ../../library/optparse.rst:1561
msgid "parser = OptionParser(..., conflict_handler=handler)"
msgstr ""

#: ../../library/optparse.rst:1563
msgid "or with a separate call::"
msgstr "또는 별도의 호출로 가능합니다::"

#: ../../library/optparse.rst:1565
msgid "parser.set_conflict_handler(handler)"
msgstr ""

#: ../../library/optparse.rst:1567
msgid "The available conflict handlers are:"
msgstr "사용 가능한 충돌 처리기는 다음과 같습니다:"

#: ../../library/optparse.rst:1569
msgid "``\"error\"`` (default)"
msgstr "``\"error\"`` (기본값)"

#: ../../library/optparse.rst:1570
msgid ""
"assume option conflicts are a programming error and raise "
":exc:`OptionConflictError`"
msgstr "옵션 충돌이 프로그래밍 에러라고 가정하고 :exc:`OptionConflictError` 를 발생시킵니다"

#: ../../library/optparse.rst:1573
msgid "``\"resolve\"``"
msgstr "``\"resolve\"``"

#: ../../library/optparse.rst:1574
msgid "resolve option conflicts intelligently (see below)"
msgstr "옵션 충돌을 지능적으로 해결합니다 (아래를 참조하십시오)"

#: ../../library/optparse.rst:1577
msgid ""
"As an example, let's define an :class:`OptionParser` that resolves "
"conflicts intelligently and add conflicting options to it::"
msgstr "예를 들어, 충돌을 지능적으로 해결하고 :class:`OptionParser`\\를 정의하고 충돌하는 옵션을 추가해 보겠습니다::"

#: ../../library/optparse.rst:1580
msgid ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"do no harm\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"be noisy\")"
msgstr ""

#: ../../library/optparse.rst:1584
#, fuzzy
msgid ""
"At this point, :mod:`optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only "
"way for the user to activate that option.  If the user asks for help, the"
" help message will reflect that::"
msgstr ""
"이 시점에서, :mod:`optparse`\\는 이전에 추가된 옵션이 이미 ``-n`` 옵션 문자열을 사용하고 있음을 감지합니다. "
"``conflict_handler``\\가 ``\"resolve\"``\\이므로, 이전 옵션의 옵션 문자열 리스트에서 "
"``-n``\\을 제거하여 상황을 해결합니다. 이제 ``--dry-run``\\은 사용자가 해당 옵션을 활성화하는 유일한 "
"방법입니다. 사용자가 help를 요청하면, 도움말 메시지에 이것이 반영됩니다::"

#: ../../library/optparse.rst:1590
msgid ""
"Options:\n"
"  --dry-run     do no harm\n"
"  ...\n"
"  -n, --noisy   be noisy"
msgstr ""

#: ../../library/optparse.rst:1595
#, fuzzy
msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking "
"that option from the command-line.  In that case, :mod:`optparse` removes"
" that option completely, so it doesn't show up in help text or anywhere "
"else. Carrying on with our existing OptionParser::"
msgstr ""
"남아있는 옵션이 없을 때까지 이전에 추가된 옵션에 대한 옵션 문자열을 제거 할 수 있고, 사용자는 명령 줄에서 해당 옵션을 호출할 "
"방법이 없을 가능성이 있습니다. 이 경우, :mod:`optparse`\\는 해당 옵션을 완전히 제거해서, 도움말 텍스트나 다른 "
"곳에 표시되지 않습니다. 기존 OptionParser를 계속 사용해서::"

#: ../../library/optparse.rst:1601
msgid "parser.add_option(\"--dry-run\", ..., help=\"new dry-run option\")"
msgstr ""

#: ../../library/optparse.rst:1603
msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`optparse` removes it, leaving this help text::"
msgstr ""
"이 시점에서, 원래 ``-n``/``--dry-run`` 옵션에 더는 액세스할 수 없어서, :mod:`optparse`\\는 해당 "
"옵션을 제거하고, 다음 도움말 텍스트를 남깁니다::"

#: ../../library/optparse.rst:1606
msgid ""
"Options:\n"
"  ...\n"
"  -n, --noisy   be noisy\n"
"  --dry-run     new dry-run option"
msgstr ""

#: ../../library/optparse.rst:1615
msgid "Cleanup"
msgstr "정리"

#: ../../library/optparse.rst:1617
msgid ""
"OptionParser instances have several cyclic references.  This should not "
"be a problem for Python's garbage collector, but you may wish to break "
"the cyclic references explicitly by calling :meth:`~OptionParser.destroy`"
" on your OptionParser once you are done with it.  This is particularly "
"useful in long-running applications where large object graphs are "
"reachable from your OptionParser."
msgstr ""
"OptionParser 인스턴스에는 여러 순환 참조가 있습니다. 이것은 파이썬의 가비지 수거기에선 문제가 되지 않지만, 작업이 "
"끝나면 OptionParser에서 :meth:`~OptionParser.destroy`\\를 호출하여 순환 참조를 명시적으로 끊을 "
"수 있습니다. 이것은 OptionParser에서 큰 객체 그래프에 도달할 수 있는 장기 실행 응용 프로그램에서 특히 유용합니다."

#: ../../library/optparse.rst:1628
msgid "Other methods"
msgstr "기타 메서드"

#: ../../library/optparse.rst:1630
msgid "OptionParser supports several other public methods:"
msgstr "OptionParser는 몇 가지 다른 공용 메서드를 지원합니다:"

#: ../../library/optparse.rst:1634
#, fuzzy
msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the "
"default usage string; use :const:`optparse.SUPPRESS_USAGE` to suppress a "
"usage message."
msgstr ""
"``usage`` 생성자 키워드 인자에 대해 위에서 설명한 규칙에 따라 사용법 문자열을 설정합니다. ``None``\\을 전달하면 "
"기본 사용법 문자열이 설정됩니다; 사용법 메시지를 억제하려면 :data:`optparse.SUPPRESS_USAGE`\\를 "
"사용하십시오."

#: ../../library/optparse.rst:1640
msgid ""
"Print the usage message for the current program (``self.usage``) to "
"*file* (default stdout).  Any occurrence of the string ``%prog`` in "
"``self.usage`` is replaced with the name of the current program.  Does "
"nothing if ``self.usage`` is empty or not defined."
msgstr ""
"현재 프로그램의 사용법 메시지(``self.usage``)를 *file*\\(기본값 stdout)로 인쇄합니다. "
"``self.usage``\\에 등장하는 문자열 ``%prog``\\는 현재 프로그램의 이름으로 대체됩니다. "
"``self.usage``\\가 비어 있거나 정의되지 않았으면 아무 작업도 수행하지 않습니다."

#: ../../library/optparse.rst:1647
msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of "
"printing it."
msgstr ":meth:`print_usage`\\와 같지만 인쇄하는 대신 사용법 문자열을 반환합니다."

#: ../../library/optparse.rst:1652
msgid ""
"Set default values for several option destinations at once.  Using "
":meth:`set_defaults` is the preferred way to set default values for "
"options, since multiple options can share the same destination.  For "
"example, if several \"mode\" options all set the same destination, any "
"one of them can set the default, and the last one wins::"
msgstr ""
"한 번에 여러 옵션 대상에 대한 기본값을 설정합니다. 여러 옵션이 같은 대상을 공유 할 수 있기 때문에, "
":meth:`set_defaults`\\를 사용하여 옵션의 기본값을 설정하는 것이 좋습니다. 예를 들어, 여러 \"mode\" "
"옵션이 모두 같은 대상을 설정하면, 그중 하나가 기본값을 설정할 수 있으며 마지막 옵션이 이깁니다::"

#: ../../library/optparse.rst:1658
msgid ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # overridden below\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # overrides above setting"
msgstr ""

#: ../../library/optparse.rst:1665
msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "이러한 혼동을 피하려면, :meth:`set_defaults`\\를 사용하십시오::"

#: ../../library/optparse.rst:1667
msgid ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"
msgstr ""

#: ../../library/optparse.rst:1677
msgid "Option Callbacks"
msgstr "옵션 콜백"

#: ../../library/optparse.rst:1679
msgid ""
"When :mod:`optparse`'s built-in actions and types aren't quite enough for"
" your needs, you have two choices: extend :mod:`optparse` or define a "
"callback option. Extending :mod:`optparse` is more general, but overkill "
"for a lot of simple cases.  Quite often a simple callback is all you "
"need."
msgstr ""
":mod:`optparse`\\의 내장 액션과 형이 여러분의 필요에 충분하지 않으면, 두 가지 선택이 있습니다: "
":mod:`optparse`\\를 확장하거나 콜백 옵션을 정의합니다. :mod:`optparse`\\를 확장하는 것이 더 "
"일반적이지만, 많은 간단한 경우에는 과합니다. 종종 간단한 콜백만 있으면 됩니다."

#: ../../library/optparse.rst:1684
msgid "There are two steps to defining a callback option:"
msgstr "콜백 옵션을 정의하는 두 단계가 있습니다:"

#: ../../library/optparse.rst:1686
msgid "define the option itself using the ``\"callback\"`` action"
msgstr "``\"callback\"`` 액션을 사용하여 옵션 자체를 정의합니다"

#: ../../library/optparse.rst:1688
msgid ""
"write the callback; this is a function (or method) that takes at least "
"four arguments, as described below"
msgstr "콜백을 작성합니다; 이것은 아래에 설명된 대로, 최소한 4개의 인자를 취하는 함수(또는 메서드)입니다"

#: ../../library/optparse.rst:1695
msgid "Defining a callback option"
msgstr "콜백 옵션 정의하기"

#: ../../library/optparse.rst:1697
msgid ""
"As always, the easiest way to define a callback option is by using the "
":meth:`OptionParser.add_option` method.  Apart from "
":attr:`~Option.action`, the only option attribute you must specify is "
"``callback``, the function to call::"
msgstr ""
"항상 그렇듯이, 콜백 옵션을 정의하는 가장 쉬운 방법은 :meth:`OptionParser.add_option` 메서드를 사용하는 "
"것입니다. :attr:`~Option.action`\\과 별도로 지정해야 하는 유일한 옵션 어트리뷰트는 호출할 함수인 "
"``callback``\\입니다::"

#: ../../library/optparse.rst:1701
msgid "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"
msgstr ""

#: ../../library/optparse.rst:1703
msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. "
"In this simple case, :mod:`optparse` doesn't even know if ``-c`` takes "
"any arguments, which usually means that the option takes no arguments---"
"the mere presence of ``-c`` on the command-line is all it needs to know."
"  In some circumstances, though, you might want your callback to consume "
"an arbitrary number of command-line arguments.  This is where writing "
"callbacks gets tricky; it's covered later in this section."
msgstr ""
"``callback``\\은 함수(또는 다른 콜러블 객체)이므로, 이 콜백 옵션을 만들 때 ``my_callback()``\\을 "
"이미 정의했어야 합니다. 이 간단한 경우, :mod:`optparse`\\는 ``-c``\\가 인자를 취하는지조차 알지 못합니다. "
"이는 일반적으로 옵션이 인자를 받지 않음을 의미합니다---명령 줄에 ``-c``\\가 있다는 것만 알 필요가 있습니다. 그러나 일부"
" 상황에서는, 콜백이 임의의 수의 명령 줄 인자를 소비하도록 할 수 있습니다. 콜백 작성이 까다로워지는 곳입니다: 이 섹션의 "
"뒷부분에서 다룹니다."

#: ../../library/optparse.rst:1712
msgid ""
":mod:`optparse` always passes four particular arguments to your callback,"
" and it will only pass additional arguments if you specify them via "
":attr:`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus,"
" the minimal callback function signature is::"
msgstr ""
":mod:`optparse`\\는 항상 4개의 특정 인자를 콜백에 전달하며, "
":attr:`~Option.callback_args`\\와 :attr:`~Option.callback_kwargs`\\를 통해 "
"지정하는 경우에만 추가 인자를 전달합니다. 따라서 최소 콜백 함수 서명은 다음과 같습니다::"

#: ../../library/optparse.rst:1717
msgid "def my_callback(option, opt, value, parser):"
msgstr ""

#: ../../library/optparse.rst:1719
msgid "The four arguments to a callback are described below."
msgstr "콜백에 대한 네 가지 인자가 아래에 설명되어 있습니다."

#: ../../library/optparse.rst:1721
msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr "콜백 옵션을 정의할 때 제공할 수 있는 몇 가지 다른 옵션 어트리뷰트가 있습니다:"

#: ../../library/optparse.rst:1724
msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.type`"

#: ../../library/optparse.rst:1725
msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` "
"actions, it instructs :mod:`optparse` to consume one argument and convert"
" it to :attr:`~Option.type`.  Rather than storing the converted value(s) "
"anywhere, though, :mod:`optparse` passes it to your callback function."
msgstr ""
"일반적인 의미를 갖습니다: ``\"store\"``\\나 ``\"append\"`` 액션과 마찬가지로, "
":mod:`optparse`\\에게 하나의 인자를 소비하고 이를 :attr:`~Option.type`\\으로 변환하도록 지시합니다."
" 그러나 :mod:`optparse`\\는 변환된 값을 어딘가에 저장하는 대신 콜백 함수에 전달합니다."

#: ../../library/optparse.rst:1730
msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

#: ../../library/optparse.rst:1731
msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`optparse` "
"will consume :attr:`~Option.nargs` arguments, each of which must be "
"convertible to :attr:`~Option.type`.  It then passes a tuple of converted"
" values to your callback."
msgstr ""
"역시 일반적인 의미를 갖습니다: 제공되고 > 1 이면, :mod:`optparse`\\는 :attr:`~Option.nargs` "
"인자를 소비하며 각 인자는 :attr:`~Option.type`\\으로 변환 가능해야 합니다. 그런 다음 변환된 값의 튜플을 콜백에"
" 전달합니다."

#: ../../library/optparse.rst:1736
msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

#: ../../library/optparse.rst:1737
msgid "a tuple of extra positional arguments to pass to the callback"
msgstr "콜백에 전달할 추가 위치 인자의 튜플"

#: ../../library/optparse.rst:1739
msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

#: ../../library/optparse.rst:1740
msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr "콜백에 전달할 추가 키워드 인자의 딕셔너리"

#: ../../library/optparse.rst:1746
msgid "How callbacks are called"
msgstr "콜백이 호출되는 방법"

#: ../../library/optparse.rst:1748
msgid "All callbacks are called as follows::"
msgstr "모든 콜백은 다음과 같이 호출됩니다::"

#: ../../library/optparse.rst:1754
msgid "``option``"
msgstr "``option``"

#: ../../library/optparse.rst:1755
msgid "is the Option instance that's calling the callback"
msgstr "콜백을 호출하는 Option 인스턴스입니다"

#: ../../library/optparse.rst:1757
msgid "``opt_str``"
msgstr "``opt_str``"

#: ../../library/optparse.rst:1758
msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be "
"the full, canonical option string---e.g. if the user puts ``--foo`` on "
"the command-line as an abbreviation for ``--foobar``, then ``opt_str`` "
"will be ``\"--foobar\"``.)"
msgstr ""
"콜백을 트리거 하는 명령 줄에 나타나는 옵션 문자열입니다. (축약된 긴 옵션이 사용되면, ``opt_str``\\은 완전한, "
"규범적인 옵션 문자열이 됩니다---예를 들어 사용자가 ``--foobar``\\의 약어로 명령 줄에 ``--foo``\\를 "
"입력하면, ``opt_str``\\은 ``\"--foobar\"``\\가 됩니다.)"

#: ../../library/optparse.rst:1764
msgid "``value``"
msgstr "``value``"

#: ../../library/optparse.rst:1765
msgid ""
"is the argument to this option seen on the command-line.  :mod:`optparse`"
" will only expect an argument if :attr:`~Option.type` is set; the type of"
" ``value`` will be the type implied by the option's type.  If "
":attr:`~Option.type` for this option is ``None`` (no argument expected), "
"then ``value`` will be ``None``.  If :attr:`~Option.nargs` > 1, ``value``"
" will be a tuple of values of the appropriate type."
msgstr ""
"명령 줄에 나타난 이 옵션에 대한 인자입니다. :mod:`optparse`\\는 :attr:`~Option.type`\\이 "
"설정되었을 때만 인자를 기대합니다; ``value``\\의 형은 옵션의 형이 암시하는 형입니다. 이 옵션의 "
":attr:`~Option.type`\\이 ``None``\\(기대하는 인자 없음)이면, ``value``\\는 "
"``None``\\이 됩니다. :attr:`~Option.nargs` > 1 이면, ``value``\\는 적절한 형의 값의 튜플이"
" 됩니다."

#: ../../library/optparse.rst:1771
msgid "``parser``"
msgstr "``parser``"

#: ../../library/optparse.rst:1772
msgid ""
"is the OptionParser instance driving the whole thing, mainly useful "
"because you can access some other interesting data through its instance "
"attributes:"
msgstr ""
"모든 것을 구동하는 OptionParser 인스턴스입니다, 인스턴스 어트리뷰트를 통해 다른 흥미로운 데이터에 액세스 할 수 있어서 "
"주로 유용합니다:"

#: ../../library/optparse.rst:1775
msgid "``parser.largs``"
msgstr "``parser.largs``"

#: ../../library/optparse.rst:1776
#, fuzzy
msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to "
"modify ``parser.largs``, e.g. by adding more arguments to it.  (This list"
" will become ``args``, the second return value of "
":meth:`~OptionParser.parse_args`.)"
msgstr ""
"남은 인자의 현재 리스트, 즉, 소비되었지만 옵션이나 옵션 인자가 아닌 인자. 예를 들어 더 많은 인자를 추가하여, "
"``parser.largs``\\를 자유롭게 수정하십시오. (이 리스트는 :meth:`parse_args`\\의 두 번째 반환 값인"
" ``args``\\가 됩니다.)"

#: ../../library/optparse.rst:1781
msgid "``parser.rargs``"
msgstr "``parser.rargs``"

#: ../../library/optparse.rst:1782
msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and "
"``value`` (if applicable) removed, and only the arguments following them "
"still there.  Feel free to modify ``parser.rargs``, e.g. by consuming "
"more arguments."
msgstr ""
"나머지 인자의 현재 리스트, 즉, ``opt_str``\\과 ``value``\\(해당한다면)가 제거되고, 그 뒤에 오는 인자만 "
"그대로 남아 있습니다. 예를 들어 더 많은 인자를 소비하여, ``parser.rargs``\\를 자유롭게 수정하십시오."

#: ../../library/optparse.rst:1787
msgid "``parser.values``"
msgstr "``parser.values``"

#: ../../library/optparse.rst:1788
msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as "
"the rest of :mod:`optparse` for storing option values; you don't need to "
"mess around with globals or closures.  You can also access or modify the "
"value(s) of any options already encountered on the command-line."
msgstr ""
"옵션값이 기본적으로 저장되는 객체 (optparse.OptionValues의 인스턴스). 이를 통해 콜백은 옵션값을 저장하기 위해 "
"나머지 :mod:`optparse`\\와 같은 메커니즘을 사용할 수 있습니다; 전역이나 클로저를 엉망으로 만들 필요가 없습니다. "
"명령 줄에서 이미 발견된 모든 옵션의 값에 액세스하거나 수정할 수도 있습니다."

#: ../../library/optparse.rst:1795
msgid ""
"is a tuple of arbitrary positional arguments supplied via the "
":attr:`~Option.callback_args` option attribute."
msgstr ":attr:`~Option.callback_args` 옵션 어트리뷰트를 통해 제공되는 임의의 위치 인자의 튜플입니다."

#: ../../library/optparse.rst:1798
msgid "``kwargs``"
msgstr "``kwargs``"

#: ../../library/optparse.rst:1799
msgid ""
"is a dictionary of arbitrary keyword arguments supplied via "
":attr:`~Option.callback_kwargs`."
msgstr ":attr:`~Option.callback_kwargs`\\를 통해 제공된 임의의 키워드 인자의 딕셔너리입니다."

#: ../../library/optparse.rst:1806
msgid "Raising errors in a callback"
msgstr "콜백에서 에러 발생시키기"

#: ../../library/optparse.rst:1808
msgid ""
"The callback function should raise :exc:`OptionValueError` if there are "
"any problems with the option or its argument(s).  :mod:`optparse` catches"
" this and terminates the program, printing the error message you supply "
"to stderr.  Your message should be clear, concise, accurate, and mention "
"the option at fault. Otherwise, the user will have a hard time figuring "
"out what they did wrong."
msgstr ""
"옵션이나 인자에 문제가 있으면 콜백 함수는 :exc:`OptionValueError` 를 발생시켜야 합니다. "
":mod:`optparse`\\는 이것을 포착하고 프로그램을 종료하고, stderr에 여러분이 제공하는 에러 메시지를 인쇄합니다. "
"메시지는 명확하고 간결하며 정확해야 하며 잘못된 옵션을 언급해야 합니다. 그렇지 않으면, 사용자는 자신이 무엇을 잘못했는지 파악하는"
" 데 어려움을 겪을 것입니다."

#: ../../library/optparse.rst:1818
msgid "Callback example 1: trivial callback"
msgstr "콜백 예제 1: 간단한 콜백"

#: ../../library/optparse.rst:1820
msgid ""
"Here's an example of a callback option that takes no arguments, and "
"simply records that the option was seen::"
msgstr "다음은 인자를 취하지 않고, 단순히 옵션이 발견되었음을 기록하는 콜백 옵션의 예입니다::"

#: ../../library/optparse.rst:1823
msgid ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", "
"callback=record_foo_seen)"
msgstr ""

#: ../../library/optparse.rst:1828
msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "물론 ``\"store_true\"`` 액션으로 그렇게 할 수 있습니다."

#: ../../library/optparse.rst:1834
msgid "Callback example 2: check option order"
msgstr "콜백 예제 2: 옵션 순서 확인"

#: ../../library/optparse.rst:1836
msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` "
"is seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr ""
"여기에 약간 더 흥미로운 예가 있습니다: ``-a``\\가 발견되었다는 사실을 기록하지만, 명령 줄에서 ``-b`` 뒤에 오면 "
"폭발합니다. ::"

#: ../../library/optparse.rst:1839
msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use -a after -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"
msgstr ""

#: ../../library/optparse.rst:1851
msgid "Callback example 3: check option order (generalized)"
msgstr "콜백 예제 3: 옵션 순서 확인 (일반화)"

#: ../../library/optparse.rst:1853
#, fuzzy
msgid ""
"If you want to reuse this callback for several similar options (set a "
"flag, but blow up if ``-b`` has already been seen), it needs a bit of "
"work: the error message and the flag that it sets must be generalized.  "
"::"
msgstr ""
"이 콜백을 몇 가지 유사한 옵션에 다시 사용하려면 (플래그를 설정하지만, ``-b``\\가 이미 보였으면 폭발함), 약간의 작업이 "
"필요합니다: 에러 메시지와 설정하는 플래그를 일반화해야 합니다. ::"

#: ../../library/optparse.rst:1857
#, python-format
msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use %s after -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"
msgstr ""

#: ../../library/optparse.rst:1870
msgid "Callback example 4: check arbitrary condition"
msgstr "콜백 예제 4: 임의 조건 확인"

#: ../../library/optparse.rst:1872
msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have"
" options that should not be called when the moon is full, all you have to"
" do is this::"
msgstr ""
"물론, 여기에 어떤 조건도 넣을 수 있습니다---이미 정의된 옵션의 값을 확인하는 데 국한되지 않습니다. 예를 들어, 만월일 때 "
"호출해서는 안 되는 옵션이 있으면, 다음과 같이 하면 됩니다::"

#: ../../library/optparse.rst:1876
#, python-format
msgid ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s option invalid when moon is full\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"
msgstr ""

#: ../../library/optparse.rst:1885
msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the "
"reader.)"
msgstr "(``is_moon_full()``\\의 정의는 독자를 위한 연습 문제로 남겨 둡니다.)"

#: ../../library/optparse.rst:1891
msgid "Callback example 5: fixed arguments"
msgstr "콜백 예제 5: 고정 인자"

#: ../../library/optparse.rst:1893
msgid ""
"Things get slightly more interesting when you define callback options "
"that take a fixed number of arguments.  Specifying that a callback option"
" takes arguments is similar to defining a ``\"store\"`` or ``\"append\"``"
" option: if you define :attr:`~Option.type`, then the option takes one "
"argument that must be convertible to that type; if you further define "
":attr:`~Option.nargs`, then the option takes :attr:`~Option.nargs` "
"arguments."
msgstr ""
"고정된 수의 인자를 사용하는 콜백 옵션을 정의하면 상황이 약간 더 흥미로워집니다. 콜백 옵션이 인자를 받도록 지정하는 것은 "
"``\"store\"``\\나 ``\"append\"`` 옵션을 정의하는 것과 유사합니다: "
":attr:`~Option.type`\\을 정의하면, 옵션은 해당 형으로 변환 할 수 있어야 하는 하나의 인자를 취합니다; "
":attr:`~Option.nargs`\\를 추가로 정의하면, 옵션은 :attr:`~Option.nargs` 인자를 취합니다."

#: ../../library/optparse.rst:1900
msgid "Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "다음은 표준 ``\"store\"`` 액션을 흉내 내는 예입니다::"

#: ../../library/optparse.rst:1902
msgid ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"
msgstr ""

#: ../../library/optparse.rst:1909
msgid ""
"Note that :mod:`optparse` takes care of consuming 3 arguments and "
"converting them to integers for you; all you have to do is store them.  "
"(Or whatever; obviously you don't need a callback for this example.)"
msgstr ""
":mod:`optparse`\\가 3개의 인자를 소비하고 이를 정수로 변환하는 작업을 처리함에 유의하십시오; 여러분이 해야 할 일은"
" 그것들을 저장하는 것뿐입니다. (또는 무엇이든; 분명히 이 예제에서는 콜백이 필요하지 않습니다.)"

#: ../../library/optparse.rst:1917
msgid "Callback example 6: variable arguments"
msgstr "콜백 예제 6: 가변 인자"

#: ../../library/optparse.rst:1919
msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal "
"with certain intricacies of conventional Unix command-line parsing that "
":mod:`optparse` normally handles for you.  In particular, callbacks "
"should implement the conventional rules for bare ``--`` and ``-`` "
"arguments:"
msgstr ""
"가변적인 수의 인자를 취하는 옵션을 원할 때 상황이 복잡해집니다. 이 경우, :mod:`optparse`\\는 이것을 위한 내장 "
"기능을 제공하지 않아서 콜백을 작성해야 합니다. 그리고 :mod:`optparse`\\가 일반적으로 처리하는 전통적인 유닉스 명령 "
"줄 구문 분석의 복잡한 문제를 여러분이 처리해야 합니다. 특히, 콜백은 날(bare) ``--``\\와 ``-`` 인자에 대한 "
"전통적인 규칙을 구현해야 합니다:"

#: ../../library/optparse.rst:1926
msgid "either ``--`` or ``-`` can be option arguments"
msgstr "``--``\\나 ``-``\\는 옵션 인자가 될 수 있습니다"

#: ../../library/optparse.rst:1928
msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr "날 ``--`` (어떤 옵션에 대한 인자가 아닌 경우): 명령 줄 처리를 중단하고 ``--``\\를 버립니다"

#: ../../library/optparse.rst:1931
msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr ""
"날 ``-`` (어떤 옵션에 대한 인자가 아닌 경우): 명령 줄 처리를 중지하지만 ``-``\\는 유지합니다 "
"(``parser.largs``\\에 추가합니다)"

#: ../../library/optparse.rst:1934
msgid ""
"If you want an option that takes a variable number of arguments, there "
"are several subtle, tricky issues to worry about.  The exact "
"implementation you choose will be based on which trade-offs you're "
"willing to make for your application (which is why :mod:`optparse` "
"doesn't support this sort of thing directly)."
msgstr ""
"가변적인 수의 인자를 취하는 옵션을 원한다면, 몇 가지 미묘하고 까다로운 문제가 있습니다. 여러분이 선택하는 정확한 구현은 여러분이"
" 여러분의 응용 프로그램을 위해 취하고자 하는 절충을 기반으로 할 것입니다 (이것이 :mod:`optparse`\\가 이런 종류의 "
"것을 직접 지원하지 않는 이유입니다)."

#: ../../library/optparse.rst:1940
msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr "그런데도, 가변 인자가 있는 옵션에 대한 콜백에는 가시가 있습니다::"

#: ../../library/optparse.rst:1943
msgid ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # stop on --foo like options\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # stop on -a, but not on -3 or -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"
msgstr ""

#: ../../library/optparse.rst:1974
msgid "Extending :mod:`optparse`"
msgstr ":mod:`optparse` 확장하기"

#: ../../library/optparse.rst:1976
msgid ""
"Since the two major controlling factors in how :mod:`optparse` interprets"
" command-line options are the action and type of each option, the most "
"likely direction of extension is to add new actions and new types."
msgstr ""
":mod:`optparse`\\가 명령 줄 옵션을 해석하는 방법의 두 가지 주요 제어 요소는 각 옵션의 액션과 형이므로, 확장 "
"방향은 새 액션과 새 형을 추가하는 것입니다."

#: ../../library/optparse.rst:1984
msgid "Adding new types"
msgstr "새로운 형 추가하기"

#: ../../library/optparse.rst:1986
msgid ""
"To add new types, you need to define your own subclass of "
":mod:`optparse`'s :class:`Option` class.  This class has a couple of "
"attributes that define :mod:`optparse`'s types: :attr:`~Option.TYPES` and"
" :attr:`~Option.TYPE_CHECKER`."
msgstr ""
"새로운 형을 추가하려면, :mod:`optparse`\\의 :class:`Option` 클래스의 여러분 자신의 서브 클래스를 "
"정의해야 합니다. 이 클래스에는 :mod:`optparse`\\의 형을 정의하는 몇 가지 어트리뷰트가 있습니다: "
":attr:`~Option.TYPES`\\와 :attr:`~Option.TYPE_CHECKER`."

#: ../../library/optparse.rst:1992
msgid ""
"A tuple of type names; in your subclass, simply define a new tuple "
":attr:`TYPES` that builds on the standard one."
msgstr "형 이름의 튜플; 여러분의 서브 클래스에서, 표준 튜플을 기반으로 하는 새 튜플 :attr:`TYPES`\\를 정의하십시오."

#: ../../library/optparse.rst:1997
msgid ""
"A dictionary mapping type names to type-checking functions.  A type-"
"checking function has the following signature::"
msgstr "형 이름을 형 검사 함수에 매핑하는 딕셔너리. 형 검사 함수는 다음과 같은 서명을 갖습니다::"

#: ../../library/optparse.rst:2000
msgid "def check_mytype(option, opt, value)"
msgstr ""

#: ../../library/optparse.rst:2002
msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option "
"string (e.g., ``-f``), and ``value`` is the string from the command line "
"that must be checked and converted to your desired type.  "
"``check_mytype()`` should return an object of the hypothetical type "
"``mytype``.  The value returned by a type-checking function will wind up "
"in the OptionValues instance returned by :meth:`OptionParser.parse_args`,"
" or be passed to a callback as the ``value`` parameter."
msgstr ""
"여기서 ``option``\\은 :class:`Option` 인스턴스이고, ``opt``\\는 옵션 문자열(예를 들어, "
"``-f``)이며, ``value``\\는 검사되고 원하는 형으로 변환되어야 하는 명령 줄의 문자열입니다. "
"``check_mytype()``\\은 가상의 형 ``mytype``\\의 객체를 반환해야 합니다. 형 검사 함수가 반환한 값은 "
":meth:`OptionParser.parse_args`\\에서 반환한 OptionValues 인스턴스에 포함되거나 "
"``value`` 매개 변수로 콜백에 전달됩니다."

#: ../../library/optparse.rst:2010
msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string "
"``\"error:\"`` and prints everything to stderr before terminating the "
"process."
msgstr ""
"형 검사 함수는 문제가 발생하면 :exc:`OptionValueError` 를 발생시켜야 합니다. "
":exc:`OptionValueError` 는 :class:`OptionParser`\\의 :meth:`error` 메서드에 있는 "
"그대로 전달되는 단일 문자열 인자를 취하며, 이는 차례로 프로그램 이름과 문자열 ``\"error:\"``\\를 앞에 붙이고 "
"프로세스를 종료하기 전에 모든 것을 stderr에 인쇄합니다."

#: ../../library/optparse.rst:2016
msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is"
" even sillier than it used to be, because :mod:`optparse` 1.3 added "
"built-in support for complex numbers, but never mind.)"
msgstr ""
"다음은 명령 줄에서 파이썬 스타일 복소수를 구문 분석하기 위해 ``\"complex\"`` 옵션 형을 추가하는 것을 보여주는 "
"우스꽝스러운 예입니다. (:mod:`optparse` 1.3은 복소수에 대한 기본 지원을 추가했기 때문에 전보다 훨씬 "
"우스꽝스럽지만, 신경 쓰지 마십시오.)"

#: ../../library/optparse.rst:2021
msgid "First, the necessary imports::"
msgstr "첫째, 필요한 임포트::"

#: ../../library/optparse.rst:2023
msgid ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"
msgstr ""

#: ../../library/optparse.rst:2026
msgid ""
"You need to define your type-checker first, since it's referred to later "
"(in the :attr:`~Option.TYPE_CHECKER` class attribute of your Option "
"subclass)::"
msgstr ""
"나중에 (Option 서브 클래스의 :attr:`~Option.TYPE_CHECKER` 클래스 어트리뷰트에서) 참조되므로, 형 "
"검사기를 먼저 정의해야 합니다::"

#: ../../library/optparse.rst:2029
#, python-format
msgid ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: invalid complex value: %r\" % (opt, value))"
msgstr ""

#: ../../library/optparse.rst:2036
msgid "Finally, the Option subclass::"
msgstr "마지막으로, Option 서브 클래스::"

#: ../../library/optparse.rst:2038
msgid ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"
msgstr ""

#: ../../library/optparse.rst:2043
msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we "
"would end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of "
":mod:`optparse`'s Option class.  This being Python, nothing stops you "
"from doing that except good manners and common sense.)"
msgstr ""
"(:attr:`Option.TYPE_CHECKER`\\의 :func:`copy`\\를 만들지 않았다면, "
":mod:`optparse`\\의 Option 클래스의 :attr:`~Option.TYPE_CHECKER` 어트리뷰트를 수정하게 될"
" 것입니다. 이것은 파이썬이기 때문에, 좋은 태도와 상식을 제외하고는 아무것도 이렇게 하는 것을 막을 수 없습니다.)"

#: ../../library/optparse.rst:2048
msgid ""
"That's it!  Now you can write a script that uses the new option type just"
" like any other :mod:`optparse`\\ -based script, except you have to "
"instruct your OptionParser to use MyOption instead of Option::"
msgstr ""
"이것이 전부입니다! 이제 OptionParser가 Option 대신 MyOption을 사용하도록 지시해야 한다는 점을 제외하고는, "
"다른 :mod:`optparse` 기반 스크립트와 마찬가지로 새 옵션 형을 사용하는 스크립트를 작성할 수 있습니다::"

#: ../../library/optparse.rst:2052
msgid ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"
msgstr ""

#: ../../library/optparse.rst:2055
msgid ""
"Alternately, you can build your own option list and pass it to "
"OptionParser; if you don't use :meth:`add_option` in the above way, you "
"don't need to tell OptionParser which option class to use::"
msgstr ""
"또는, 여러분 자신만의 옵션 목록을 만들어 OptionParser에 전달할 수 있습니다; 위의 방법으로 "
":meth:`add_option`\\을 사용하지 않으면, OptionParser에 사용할 옵션 클래스를 알려줄 필요가 없습니다::"

#: ../../library/optparse.rst:2059
msgid ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""

#: ../../library/optparse.rst:2066
msgid "Adding new actions"
msgstr "새로운 액션 추가하기"

#: ../../library/optparse.rst:2068
msgid ""
"Adding new actions is a bit trickier, because you have to understand that"
" :mod:`optparse` has a couple of classifications for actions:"
msgstr ":mod:`optparse`\\에는 액션에 대한 몇 가지 분류가 있음을 이해해야 해서, 새 액션을 추가하는 것은 약간 까다롭습니다:"

#: ../../library/optparse.rst:2071
msgid "\"store\" actions"
msgstr "\"저장\" 액션"

#: ../../library/optparse.rst:2072
msgid ""
"actions that result in :mod:`optparse` storing a value to an attribute of"
" the current OptionValues instance; these options require a "
":attr:`~Option.dest` attribute to be supplied to the Option constructor."
msgstr ""
":mod:`optparse`\\가 현재 OptionValues 인스턴스의 어트리뷰트에 값을 저장하는 결과를 주는 액션; 이러한 "
"옵션을 사용하려면 Option 생성자에 :attr:`~Option.dest` 어트리뷰트를 제공해야 합니다."

#: ../../library/optparse.rst:2076
msgid "\"typed\" actions"
msgstr "\"형이 있는\" 액션"

#: ../../library/optparse.rst:2077
msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain "
"type. These options require a :attr:`~Option.type` attribute to the "
"Option constructor."
msgstr ""
"명령 줄에서 값을 취하고 이것이 특정 형일 것으로 기대하는 액션; 또는, 특정 형으로 변환할 수 있는 문자열. 이러한 옵션을 "
"사용하려면 Option 생성자에 :attr:`~Option.type` 어트리뷰트를 제공해야 합니다."

#: ../../library/optparse.rst:2082
msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, "
"while the default \"typed\" actions are ``\"store\"``, ``\"append\"``, "
"and ``\"callback\"``."
msgstr ""
"이들은 겹치는 집합입니다: 일부 기본 \"저장\" 액션은 ``\"store\"``, ``\"store_const\"``, "
"``\"append\"`` 및 ``\"count\"``\\이고, 기본 \"형이 있는\" 액션은 ``\"store\"``, "
"``\"append\"`` 및 ``\"callback\"``\\입니다."

#: ../../library/optparse.rst:2086
msgid ""
"When you add an action, you need to categorize it by listing it in at "
"least one of the following class attributes of Option (all are lists of "
"strings):"
msgstr "액션을 추가할 때, Option의 다음 클래스 어트리뷰트 중 하나 이상에 나열하여 분류해야 합니다 (모두 문자열 리스트입니다):"

#: ../../library/optparse.rst:2091
msgid "All actions must be listed in ACTIONS."
msgstr "모든 액션은 ACTIONS에 나열되어야 합니다."

#: ../../library/optparse.rst:2095
msgid "\"store\" actions are additionally listed here."
msgstr "\"저장\" 액션이 여기에 추가로 나열됩니다."

#: ../../library/optparse.rst:2099
msgid "\"typed\" actions are additionally listed here."
msgstr "\"형이 있는\" 액션이 여기에 추가로 나열됩니다."

#: ../../library/optparse.rst:2103
msgid ""
"Actions that always take a type (i.e. whose options always take a value) "
"are additionally listed here.  The only effect of this is that "
":mod:`optparse` assigns the default type, ``\"string\"``, to options with"
" no explicit type whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""
"항상 형을 취하는 액션(즉, 옵션이 항상 값을 취하는 액션)이 여기에 추가로 나열됩니다. 이것의 유일한 효과는 "
":mod:`optparse`\\가 :attr:`ALWAYS_TYPED_ACTIONS`\\에 액션이 나열되는 명시적인 형이 없는 "
"옵션에 기본형인 ``\"string\"``\\을 대입한다는 것입니다."

#: ../../library/optparse.rst:2108
msgid ""
"In order to actually implement your new action, you must override "
"Option's :meth:`take_action` method and add a case that recognizes your "
"action."
msgstr ""
"새 액션을 실제로 구현하려면, Option의 :meth:`take_action` 메서드를 재정의하고 액션을 인식하는 케이스를 "
"추가해야 합니다."

#: ../../library/optparse.rst:2111
msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from"
" the command-line and appending it to an existing list, ``\"extend\"`` "
"will take multiple values in a single comma-delimited string, and extend "
"an existing list with them.  That is, if ``--names`` is an ``\"extend\"``"
" option of type ``\"string\"``, the command line ::"
msgstr ""
"예를 들어, ``\"extend\"`` 액션을 추가해 보겠습니다. 이것은 표준 ``\"append\"`` 액션과 유사하지만, 명령 "
"줄에서 단일 값을 취해서 기존 리스트에 추가하는 대신, ``\"extend\"``\\는 단일 쉼표로 구분된 문자열에서 여러 값을 "
"취해서 기존 리스트를 확장합니다. 즉, ``--names``\\가 ``\"string\"`` 형의 ``\"extend\"`` "
"옵션이면, 다음과 같은 명령 줄은 ::"

#: ../../library/optparse.rst:2118
msgid "--names=foo,bar --names blah --names ding,dong"
msgstr ""

#: ../../library/optparse.rst:2120
msgid "would result in a list  ::"
msgstr "다음과 같은 리스트를 만듭니다 ::"

#: ../../library/optparse.rst:2122
msgid "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"
msgstr ""

#: ../../library/optparse.rst:2124
msgid "Again we define a subclass of Option::"
msgstr "다시 Option의 서브 클래스를 정의합니다::"

#: ../../library/optparse.rst:2126
msgid ""
"class MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = value.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        else:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, value, values, parser)"
msgstr ""

#: ../../library/optparse.rst:2141
msgid "Features of note:"
msgstr "참고할만한 특징:"

#: ../../library/optparse.rst:2143
msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and "
":attr:`~Option.TYPED_ACTIONS`."
msgstr ""
"``\"extend\"``\\는 명령 줄에서 값을 기대하기도 하고 그 값을 어딘가에 저장하기도 하므로, "
":attr:`~Option.STORE_ACTIONS`\\와 :attr:`~Option.TYPED_ACTIONS` 모두에 들어갑니다."

#: ../../library/optparse.rst:2147
msgid ""
"to ensure that :mod:`optparse` assigns the default type of ``\"string\"``"
" to ``\"extend\"`` actions, we put the ``\"extend\"`` action in "
":attr:`~Option.ALWAYS_TYPED_ACTIONS` as well."
msgstr ""
":mod:`optparse`\\가 기본형 ``\"string\"``\\을 ``\"extend\"`` 액션에 대입하도록 하기 위해, "
":attr:`~Option.ALWAYS_TYPED_ACTIONS`\\에도 ``\"extend\"`` 액션을 넣습니다."

#: ../../library/optparse.rst:2151
msgid ""
":meth:`MyOption.take_action` implements just this one new action, and "
"passes control back to :meth:`Option.take_action` for the standard "
":mod:`optparse` actions."
msgstr ""
":meth:`MyOption.take_action`\\은 이 하나의 새로운 액션만 구현하고, 표준 :mod:`optparse` "
"액션을 위해 제어를 :meth:`Option.take_action`\\으로 되돌립니다."

#: ../../library/optparse.rst:2155
msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. "
":meth:`ensure_value` is essentially :func:`getattr` with a safety valve; "
"it is called as ::"
msgstr ""
"``values``\\는 매우 유용한 :meth:`ensure_value` 메서드를 제공하는 "
"optparse_parser.Values 클래스의 인스턴스입니다. :meth:`ensure_value`\\는 본질적으로 안전밸브가 "
"있는 :func:`getattr`\\입니다; 다음과 같이 호출됩니다 ::"

#: ../../library/optparse.rst:2159
msgid "values.ensure_value(attr, value)"
msgstr ""

#: ../../library/optparse.rst:2161
#, fuzzy
msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, "
"then ensure_value() first sets it to ``value``, and then returns "
"``value``. This is very handy for actions like ``\"extend\"``, "
"``\"append\"``, and ``\"count\"``, all of which accumulate data in a "
"variable and expect that variable to be of a certain type (a list for the"
" first two, an integer for the latter).  Using :meth:`ensure_value` means"
" that scripts using your action don't have to worry about setting a "
"default value for the option destinations in question; they can just "
"leave the default as ``None`` and :meth:`ensure_value` will take care of "
"getting it right when it's needed."
msgstr ""
"``values``\\의 ``attr`` 어트리뷰트가 존재하지 않거나 ``None``\\이면, ensure_value()는 먼저 "
"이를 ``value``\\로 설정한 다음, ``value``\\를 반환합니다. 이것은 ``\"extend\"``, "
"``\"append\"`` 및 ``\"count\"``\\와 같은 액션에 매우 편리합니다. 이 액션들은 모두 변수에 데이터를 "
"누적하고 해당 변수가 특정 형(처음 두 개는 리스트, 마지막은 정수)이 될 것으로 기대합니다. "
":meth:`ensure_value`\\를 사용한다는 것은 액션을 사용하는 스크립트가 문제의 옵션 대상에 대한 기본값 설정에 대해 "
"걱정할 필요가 없음을 의미합니다; 기본값을 ``None``\\으로 그대로 둘 수 있으며 :meth:`ensure_value`\\는 "
"필요할 때 올바르게 처리합니다."

#: ../../library/optparse.rst:2172
#, fuzzy
msgid "Exceptions"
msgstr "옵션(option)"

#: ../../library/optparse.rst:2176
msgid ""
"Raised if an :class:`Option` instance is created with invalid or "
"inconsistent arguments."
msgstr ""

#: ../../library/optparse.rst:2181
msgid "Raised if conflicting options are added to an :class:`OptionParser`."
msgstr ""

#: ../../library/optparse.rst:2185
msgid "Raised if an invalid option value is encountered on the command line."
msgstr ""

#: ../../library/optparse.rst:2189
#, fuzzy
msgid "Raised if an invalid option is passed on the command line."
msgstr "다음과 같은 명령 줄을 구문 분석할 때 ::"

#: ../../library/optparse.rst:2193
msgid "Raised if an ambiguous option is passed on the command line."
msgstr ""

#~ msgid ""
#~ "The :mod:`optparse` module is deprecated "
#~ "and will not be developed further; "
#~ "development will continue with the "
#~ ":mod:`argparse` module."
#~ msgstr ""
#~ ":mod:`optparse` 모듈은 폐지되었으며 더는 개발되지 않습니다;"
#~ " 개발은 :mod:`argparse` 모듈로 계속될 것입니다."

#~ msgid "store a constant value"
#~ msgstr "상숫값을 저장합니다"

