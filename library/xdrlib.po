# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/xdrlib.rst:2
#, fuzzy
msgid ":mod:`!xdrlib` --- Encode and decode XDR data"
msgstr ":mod:`xdrlib` --- XDR 데이터 인코딩과 디코딩"

#: ../../library/xdrlib.rst:10
msgid ""
"This module is no longer part of the Python standard library. It was "
":ref:`removed in Python 3.13 <whatsnew313-pep594>` after being deprecated"
" in Python 3.11.  The removal was decided in :pep:`594`."
msgstr ""

#: ../../library/xdrlib.rst:14
msgid ""
"The last version of Python that provided the :mod:`!xdrlib` module was "
"`Python 3.12 <https://docs.python.org/3.12/library/xdrlib.html>`_."
msgstr ""

#~ msgid "**Source code:** :source:`Lib/xdrlib.py`"
#~ msgstr "**소스 코드:** :source:`Lib/xdrlib.py`"

#~ msgid ""
#~ "The :mod:`xdrlib` module supports the "
#~ "External Data Representation Standard as "
#~ "described in :rfc:`1014`, written by Sun"
#~ " Microsystems, Inc. June 1987.  It "
#~ "supports most of the data types "
#~ "described in the RFC."
#~ msgstr ""
#~ ":mod:`xdrlib` 모듈은 1987년 6월에 Sun "
#~ "Microsystems, Inc.가 작성한 :rfc:`1014`\\에 설명된 "
#~ "외부 데이터 표현 표준(External Data "
#~ "Representation Standard)을 지원합니다. 이 모듈은 "
#~ "RFC에 설명된 대부분의 데이터형을 지원합니다."

#~ msgid ""
#~ "The :mod:`xdrlib` module defines two "
#~ "classes, one for packing variables into"
#~ " XDR representation, and another for "
#~ "unpacking from XDR representation.  There "
#~ "are also two exception classes."
#~ msgstr ""
#~ ":mod:`xdrlib` 모듈은 두 개의 클래스를 정의합니다. "
#~ "하나는 변수를 XDR 표현으로 패킹하고, 다른 하나는 "
#~ "XDR 표현으로부터 언 패킹합니다. 또한, 두 가지 "
#~ "예외 클래스가 있습니다."

#~ msgid ""
#~ ":class:`Packer` is the class for packing"
#~ " data into XDR representation. The "
#~ ":class:`Packer` class is instantiated with "
#~ "no arguments."
#~ msgstr ""
#~ ":class:`Packer`\\는 데이터를 XDR 표현으로 패킹하는 "
#~ "클래스입니다. :class:`Packer` 클래스는 인자 없이 "
#~ "인스턴스화됩니다."

#~ msgid ""
#~ "``Unpacker`` is the complementary class "
#~ "which unpacks XDR data values from "
#~ "a string buffer.  The input buffer "
#~ "is given as *data*."
#~ msgstr ""
#~ "``Unpacker``\\는 문자열 버퍼에서 XDR 데이터값을 언 "
#~ "패킹하는 반대 클래스입니다. 입력 버퍼는 *data*\\로 "
#~ "주어집니다."

#~ msgid ":rfc:`1014` - XDR: External Data Representation Standard"
#~ msgstr ":rfc:`1014` - XDR: External Data Representation Standard"

#~ msgid ""
#~ "This RFC defined the encoding of "
#~ "data which was XDR at the time "
#~ "this module was originally written.  It"
#~ " has apparently been obsoleted by "
#~ ":rfc:`1832`."
#~ msgstr ""
#~ "이 RFC는 이 모듈이 처음 작성되었을 당시에 "
#~ "XDR이었던 데이터의 인코딩을 정의합니다. :rfc:`1832`\\로 "
#~ "개정되었습니다."

#~ msgid ":rfc:`1832` - XDR: External Data Representation Standard"
#~ msgstr ":rfc:`1832` - XDR: External Data Representation Standard"

#~ msgid "Newer RFC that provides a revised definition of XDR."
#~ msgstr "XDR의 개정된 정의를 제공하는 최신 RFC"

#~ msgid "Packer Objects"
#~ msgstr "Packer 객체"

#~ msgid ":class:`Packer` instances have the following methods:"
#~ msgstr ":class:`Packer` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#~ msgid "Returns the current pack buffer as a string."
#~ msgstr "현재의 팩 버퍼를 문자열로 반환합니다."

#~ msgid "Resets the pack buffer to the empty string."
#~ msgstr "팩 버퍼를 빈 문자열로 재설정합니다."

#~ msgid ""
#~ "In general, you can pack any of"
#~ " the most common XDR data types "
#~ "by calling the appropriate ``pack_type()`` "
#~ "method.  Each method takes a single "
#~ "argument, the value to pack.  The "
#~ "following simple data type packing "
#~ "methods are supported: :meth:`pack_uint`, "
#~ ":meth:`pack_int`, :meth:`pack_enum`, :meth:`pack_bool`,"
#~ " :meth:`pack_uhyper`, and :meth:`pack_hyper`."
#~ msgstr ""
#~ "일반적으로, 적절한 ``pack_type()`` 메서드를 호출하여 가장"
#~ " 자주 쓰이는 XDR 데이터형을 팩할 수 있습니다."
#~ " 각 메서드는 팩할 값인 단일 인자를 취합니다. "
#~ "다음과 같은 간단한 데이터형의 패킹 메서드가 지원됩니다:"
#~ " :meth:`pack_uint`, :meth:`pack_int`, "
#~ ":meth:`pack_enum`, :meth:`pack_bool`, :meth:`pack_uhyper`"
#~ " 및 :meth:`pack_hyper`."

#~ msgid "Packs the single-precision floating point number *value*."
#~ msgstr "단정밀도 부동 소수점 숫자 *value*\\를 팩합니다."

#~ msgid "Packs the double-precision floating point number *value*."
#~ msgstr "배정밀도 부동 소수점 숫자 *value*\\를 팩합니다."

#~ msgid "The following methods support packing strings, bytes, and opaque data:"
#~ msgstr "다음 메서드는 문자열, 바이트열 및 불투명 데이터의 패킹을 지원합니다:"

#~ msgid ""
#~ "Packs a fixed length string, *s*.  "
#~ "*n* is the length of the string"
#~ " but it is *not* packed into "
#~ "the data buffer.  The string is "
#~ "padded with null bytes if necessary "
#~ "to guaranteed 4 byte alignment."
#~ msgstr ""
#~ "고정 길이 문자열 *s*\\를 팩합니다. *n*\\는 문자열의"
#~ " 길이이지만 데이터 버퍼에 팩 되지는 *않습니다*. "
#~ "4바이트 정렬을 보장하는 데 필요하면 문자열에 null "
#~ "바이트가 채워집니다."

#~ msgid ""
#~ "Packs a fixed length opaque data "
#~ "stream, similarly to :meth:`pack_fstring`."
#~ msgstr ":meth:`pack_fstring`\\과 유사하게, 고정 길이의 불투명한 데이터 스트림을 팩합니다."

#~ msgid ""
#~ "Packs a variable length string, *s*."
#~ "  The length of the string is "
#~ "first packed as an unsigned integer, "
#~ "then the string data is packed "
#~ "with :meth:`pack_fstring`."
#~ msgstr ""
#~ "가변 길이 문자열 *s*\\를 팩합니다. 문자열의 길이를"
#~ " 먼저 부호 없는 정수로 팩하고, 문자열 데이터는 "
#~ ":meth:`pack_fstring`\\으로 팩합니다."

#~ msgid ""
#~ "Packs a variable length opaque data "
#~ "string, similarly to :meth:`pack_string`."
#~ msgstr ":meth:`pack_string`\\과 유사하게, 가변 길이 불투명 데이터 문자열을 팩합니다."

#~ msgid "Packs a variable length byte stream, similarly to :meth:`pack_string`."
#~ msgstr ":meth:`pack_string`\\과 유사하게, 가변 길이 바이트 스트림을 팩합니다."

#~ msgid "The following methods support packing arrays and lists:"
#~ msgstr "다음 메서드는 배열과 리스트의 패킹을 지원합니다:"

#~ msgid ""
#~ "Packs a *list* of homogeneous items."
#~ "  This method is useful for lists "
#~ "with an indeterminate size; i.e. the "
#~ "size is not available until the "
#~ "entire list has been walked.  For "
#~ "each item in the list, an unsigned"
#~ " integer ``1`` is packed first, "
#~ "followed by the data value from "
#~ "the list.  *pack_item* is the function"
#~ " that is called to pack the "
#~ "individual item.  At the end of "
#~ "the list, an unsigned integer ``0`` "
#~ "is packed."
#~ msgstr ""
#~ "균질한 항목의 *list*\\를 팩합니다. 이 메서드는 크기가"
#~ " 결정되지 않은 리스트에 유용합니다; 즉, 전체 리스트를"
#~ " 검사해볼 때까지 크기를 알 수 없습니다. 리스트의"
#~ " 각 항목에 대해 부호 없는 정수 ``1``\\이 "
#~ "먼저 팩 되고, 그다음에 리스트로부터의 데이터값이 옵니다."
#~ " *pack_item*\\은 개별 항목을 팩하려고 호출되는 "
#~ "함수입니다. 리스트의 끝에서 부호 없는 정수 ``0``\\이"
#~ " 팩 됩니다."

#~ msgid ""
#~ "For example, to pack a list of "
#~ "integers, the code might appear like "
#~ "this::"
#~ msgstr "예를 들어, 정수 리스트를 팩하려면, 이런 코드를 사용할 수 있습니다::"

#~ msgid ""
#~ "Packs a fixed length list (*array*) "
#~ "of homogeneous items.  *n* is the "
#~ "length of the list; it is *not*"
#~ " packed into the buffer, but a "
#~ ":exc:`ValueError` exception is raised if "
#~ "``len(array)`` is not equal to *n*.  "
#~ "As above, *pack_item* is the function"
#~ " used to pack each element."
#~ msgstr ""
#~ "균질한 항목의 고정 길이 리스트(*array*)를 팩합니다. "
#~ "*n*\\은 리스트의 길이입니다; 버퍼에 팩 되지 *않지만*,"
#~ " ``len(array)``\\가 *n*\\과 같지 않으면 "
#~ ":exc:`ValueError` 예외가 발생합니다. 위와 같이, "
#~ "*pack_item*\\은 각 요소를 팩하는 데 사용되는 "
#~ "함수입니다."

#~ msgid ""
#~ "Packs a variable length *list* of "
#~ "homogeneous items.  First, the length of"
#~ " the list is packed as an "
#~ "unsigned integer, then each element is"
#~ " packed as in :meth:`pack_farray` above."
#~ msgstr ""
#~ "균질한 항목의 가변 길이 *list*\\를 팩합니다. 먼저,"
#~ " 리스트의 길이가 부호 없는 정수로 팩 되고, "
#~ "각 요소는 위의 :meth:`pack_farray`\\와 같이 팩 "
#~ "됩니다."

#~ msgid "Unpacker Objects"
#~ msgstr "Unpacker 객체"

#~ msgid "The :class:`Unpacker` class offers the following methods:"
#~ msgstr ":class:`Unpacker` 클래스는 다음과 같은 메서드를 제공합니다:"

#~ msgid "Resets the string buffer with the given *data*."
#~ msgstr "지정된 *data*\\로 문자열 버퍼를 재설정합니다."

#~ msgid "Returns the current unpack position in the data buffer."
#~ msgstr "데이터 버퍼의 현재의 언팩 위치를 반환합니다."

#~ msgid ""
#~ "Sets the data buffer unpack position "
#~ "to *position*.  You should be careful"
#~ " about using :meth:`get_position` and "
#~ ":meth:`set_position`."
#~ msgstr ""
#~ "데이터 버퍼 언팩 위치를 *position*\\으로 설정합니다. "
#~ ":meth:`get_position`\\과 :meth:`set_position` 사용 시"
#~ " 주의해야 합니다."

#~ msgid "Returns the current unpack data buffer as a string."
#~ msgstr "현재의 언팩 데이터 버퍼를 문자열로 반환합니다."

#~ msgid ""
#~ "Indicates unpack completion.  Raises an "
#~ ":exc:`Error` exception if all of the "
#~ "data has not been unpacked."
#~ msgstr "언팩 완료를 나타냅니다. 모든 데이터가 언팩 되지 않았으면 :exc:`Error` 예외를 발생시킵니다."

#~ msgid ""
#~ "In addition, every data type that "
#~ "can be packed with a :class:`Packer`,"
#~ " can be unpacked with an "
#~ ":class:`Unpacker`.  Unpacking methods are of"
#~ " the form ``unpack_type()``, and take "
#~ "no arguments.  They return the unpacked"
#~ " object."
#~ msgstr ""
#~ "또한, :class:`Packer`\\로 팩할 수 있는 모든 "
#~ "데이터형은 :class:`Unpacker`\\로 언팩할 수 있습니다. 언"
#~ " 패킹 메서드는 ``unpack_type()`` 형식이며 인자를 "
#~ "받아들이지 않습니다. 이것들은 언팩 된 객체를 반환합니다."

#~ msgid "Unpacks a single-precision floating point number."
#~ msgstr "단정밀도 부동 소수점 숫자를 언팩합니다."

#~ msgid ""
#~ "Unpacks a double-precision floating "
#~ "point number, similarly to "
#~ ":meth:`unpack_float`."
#~ msgstr ":meth:`unpack_float`\\와 유사하게, 배정밀도 부동 소수점 숫자를 언팩합니다."

#~ msgid ""
#~ "In addition, the following methods "
#~ "unpack strings, bytes, and opaque data:"
#~ msgstr "또한, 다음 메서드는 문자열, 바이트열 및 불투명 데이터를 언팩합니다:"

#~ msgid ""
#~ "Unpacks and returns a fixed length "
#~ "string.  *n* is the number of "
#~ "characters expected.  Padding with null "
#~ "bytes to guaranteed 4 byte alignment "
#~ "is assumed."
#~ msgstr ""
#~ "고정 길이 문자열을 언팩하고 반환합니다. *n*\\는 예상"
#~ " 문자 수입니다. 4바이트의 정렬을 보장하기 위해서, "
#~ "null 바이트로 채워졌다고 가정합니다."

#~ msgid ""
#~ "Unpacks and returns a fixed length "
#~ "opaque data stream, similarly to "
#~ ":meth:`unpack_fstring`."
#~ msgstr ":meth:`unpack_fstring`\\과 유사하게, 고정 길이 불투명 데이터 스트림을 언팩하고 반환합니다."

#~ msgid ""
#~ "Unpacks and returns a variable length"
#~ " string.  The length of the string"
#~ " is first unpacked as an unsigned "
#~ "integer, then the string data is "
#~ "unpacked with :meth:`unpack_fstring`."
#~ msgstr ""
#~ "가변 길이 문자열을 언팩하고 반환합니다. 문자열의 길이를"
#~ " 먼저 부호 없는 정수로 언팩한 다음, 문자열 "
#~ "데이터를 :meth:`unpack_fstring`\\으로 언팩합니다."

#~ msgid ""
#~ "Unpacks and returns a variable length"
#~ " opaque data string, similarly to "
#~ ":meth:`unpack_string`."
#~ msgstr ":meth:`unpack_string`\\과 유사하게, 가변 길이 불투명 데이터 문자열을 언팩하고 반환합니다."

#~ msgid ""
#~ "Unpacks and returns a variable length"
#~ " byte stream, similarly to "
#~ ":meth:`unpack_string`."
#~ msgstr ":meth:`unpack_string`\\과 유사하게, 가변 길이 바이트 스트림을 언팩하고 반환합니다."

#~ msgid "The following methods support unpacking arrays and lists:"
#~ msgstr "다음 메서드는 배열과 리스트의 언 패킹을 지원합니다:"

#~ msgid ""
#~ "Unpacks and returns a list of "
#~ "homogeneous items.  The list is unpacked"
#~ " one element at a time by first"
#~ " unpacking an unsigned integer flag.  "
#~ "If the flag is ``1``, then the "
#~ "item is unpacked and appended to "
#~ "the list.  A flag of ``0`` "
#~ "indicates the end of the list.  "
#~ "*unpack_item* is the function that is"
#~ " called to unpack the items."
#~ msgstr ""
#~ "균질한 항목의 리스트를 언팩하고 반환합니다. 리스트는 한"
#~ " 번에 한 요소씩 먼저 부호 없는 정수 "
#~ "플래그를 언팩해서 언팩합니다. 플래그가 ``1``\\이면, 항목이 "
#~ "언팩되어 리스트에 추가됩니다. ``0`` 플래그는 리스트의 "
#~ "끝을 나타냅니다. *unpack_item*\\은 항목을 언팩하는 "
#~ "함수입니다."

#~ msgid ""
#~ "Unpacks and returns (as a list) a"
#~ " fixed length array of homogeneous "
#~ "items.  *n* is number of list "
#~ "elements to expect in the buffer. "
#~ "As above, *unpack_item* is the function"
#~ " used to unpack each element."
#~ msgstr ""
#~ "균질한 항목의 고정 길이 배열을 언팩하고 (리스트로) "
#~ "반환합니다. *n*\\은 버퍼에서 예상되는 리스트 요소의 "
#~ "수입니다. 위와 같이, *unpack_item*\\은 각 요소를 "
#~ "언팩하는 데 사용되는 함수입니다."

#~ msgid ""
#~ "Unpacks and returns a variable length"
#~ " *list* of homogeneous items. First, "
#~ "the length of the list is unpacked"
#~ " as an unsigned integer, then each"
#~ " element is unpacked as in "
#~ ":meth:`unpack_farray` above."
#~ msgstr ""
#~ "균질한 항목의 가변 길이 *list*\\를 언팩하고 "
#~ "반환합니다. 먼저, 리스트의 길이를 부호 없는 정수로 "
#~ "언팩하고, 각 요소는 위의 :meth:`unpack_farray`\\처럼 "
#~ "언팩됩니다."

#~ msgid "Exceptions"
#~ msgstr "예외"

#~ msgid "Exceptions in this module are coded as class instances:"
#~ msgstr "이 모듈의 예외는 클래스 인스턴스로 코딩됩니다:"

#~ msgid ""
#~ "The base exception class.  :exc:`Error` "
#~ "has a single public attribute "
#~ ":attr:`msg` containing the description of "
#~ "the error."
#~ msgstr ""
#~ "베이스 예외 클래스. :exc:`Error`\\에는 에러에 대한 "
#~ "설명을 포함하는 공용 어트리뷰트 :attr:`msg`\\가 하나 "
#~ "있습니다."

#~ msgid ""
#~ "Class derived from :exc:`Error`.  Contains "
#~ "no additional instance variables."
#~ msgstr ":exc:`Error`\\에서 파생된 클래스. 추가 인스턴스 변수가 없습니다."

#~ msgid "Here is an example of how you would catch one of these exceptions::"
#~ msgstr "다음은 이러한 예외 중 하나를 잡는 방법의 예입니다::"

