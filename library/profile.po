# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/profile.rst:5
msgid "The Python Profilers"
msgstr "파이썬 프로파일러"

#: ../../library/profile.rst:7
msgid "**Source code:** :source:`Lib/profile.py` and :source:`Lib/pstats.py`"
msgstr "**소스 코드:** :source:`Lib/profile.py` 및 :source:`Lib/pstats.py`"

#: ../../library/profile.rst:14
msgid "Introduction to the profilers"
msgstr "프로파일러 소개"

#: ../../library/profile.rst:20
msgid ""
":mod:`cProfile` and :mod:`profile` provide :dfn:`deterministic profiling`"
" of Python programs. A :dfn:`profile` is a set of statistics that "
"describes how often and for how long various parts of the program "
"executed. These statistics can be formatted into reports via the "
":mod:`pstats` module."
msgstr ""
":mod:`cProfile`\\과 :mod:`profile`\\은 파이썬 프로그램의 :dfn:`결정론적 프로파일링 "
"(deterministic profiling)`\\을 제공합니다. :dfn:`프로파일 (profile)`\\은 프로그램의 여러 "
"부분이 얼마나 자주 그리고 얼마나 오랫동안 실행되었는지를 기술하는 통계 집합입니다. 이러한 통계는 :mod:`pstats` 모듈을 "
"통해 보고서로 포매팅 할 수 있습니다."

#: ../../library/profile.rst:25
msgid ""
"The Python standard library provides two different implementations of the"
" same profiling interface:"
msgstr "파이썬 표준 라이브러리는 같은 프로파일링 인터페이스의 두 가지 구현을 제공합니다:"

#: ../../library/profile.rst:28
msgid ""
":mod:`cProfile` is recommended for most users; it's a C extension with "
"reasonable overhead that makes it suitable for profiling long-running "
"programs.  Based on :mod:`lsprof`, contributed by Brett Rosen and Ted "
"Czotter."
msgstr ""
":mod:`cProfile`\\이 대부분 사용자에게 권장됩니다; 오래 실행되는 프로그램을 프로파일링하는 데 적합한 합리적인 부하를 "
"주는 C 확장입니다. Brett Rosen과 Ted Czotter가 제공한 :mod:`lsprof`\\를 기반으로 합니다."

#: ../../library/profile.rst:33
msgid ""
":mod:`profile`, a pure Python module whose interface is imitated by "
":mod:`cProfile`, but which adds significant overhead to profiled "
"programs. If you're trying to extend the profiler in some way, the task "
"might be easier with this module.  Originally designed and written by Jim"
" Roskind."
msgstr ""
":mod:`profile`\\은 순수 파이썬 모듈이고 이 인터페이스를 :mod:`cProfile`\\이 모방했습니다. 하지만, "
"프로파일링 되는 프로그램에 상당한 부하를 추가합니다. 어떤 방식으로 프로파일러를 확장하려고 한다면, 이 모듈을 사용하면 작업이 더 "
"쉬울 수 있습니다. Jim Roskind가 원래 설계하고 작성했습니다."

#: ../../library/profile.rst:40
msgid ""
"The profiler modules are designed to provide an execution profile for a "
"given program, not for benchmarking purposes (for that, there is "
":mod:`timeit` for reasonably accurate results).  This particularly "
"applies to benchmarking Python code against C code: the profilers "
"introduce overhead for Python code, but not for C-level functions, and so"
" the C code would seem faster than any Python one."
msgstr ""
"프로파일러 모듈은 벤치마킹 목적(이를 위해서는 합리적으로 정확한 결과를 주는 :mod:`timeit`\\이 있습니다)이 아니라 "
"주어진 프로그램에 대한 실행 프로파일을 제공하도록 설계되었습니다. 이것은 특히 C 코드에 대한 파이썬 코드 벤치마킹에 적용됩니다: "
"프로파일러는 파이썬 코드에 부하를 가하지만, C 수준 함수에는 그렇지 않아서 C 코드는 모든 파이썬 코드보다 빨라 보입니다."

#: ../../library/profile.rst:51
msgid "Instant User's Manual"
msgstr "즉석 사용자 설명서"

#: ../../library/profile.rst:53
msgid ""
"This section is provided for users that \"don't want to read the "
"manual.\" It provides a very brief overview, and allows a user to rapidly"
" perform profiling on an existing application."
msgstr ""
"이 섹션은 \"설명서를 읽고 싶지 않은\" 사용자를 위해 제공됩니다. 매우 간단한 개요를 제공하며, 사용자가 기존 응용 프로그램에서"
" 프로파일링을 빠르게 수행할 수 있도록 합니다."

#: ../../library/profile.rst:57
msgid "To profile a function that takes a single argument, you can do::"
msgstr "단일 인자를 취하는 함수를 프로파일링하려면, 이렇게 할 수 있습니다::"

#: ../../library/profile.rst:59
msgid ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")')"
msgstr ""

#: ../../library/profile.rst:63
msgid ""
"(Use :mod:`profile` instead of :mod:`cProfile` if the latter is not "
"available on your system.)"
msgstr "(시스템에서 :mod:`cProfile`\\을 사용할 수 없으면 대신 :mod:`profile`\\을 사용하십시오.)"

#: ../../library/profile.rst:66
msgid ""
"The above action would run :func:`re.compile` and print profile results "
"like the following::"
msgstr "위의 작업은 :func:`re.compile`\\을 실행하고 다음과 같은 프로파일 결과를 인쇄합니다::"

#: ../../library/profile.rst:69
#, python-brace-format
msgid ""
"      214 function calls (207 primitive calls) in 0.002 seconds\n"
"\n"
"Ordered by: cumulative time\n"
"\n"
"ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n"
"     1    0.000    0.000    0.002    0.002 {built-in method "
"builtins.exec}\n"
"     1    0.000    0.000    0.001    0.001 <string>:1(<module>)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:250(compile)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:289(_compile)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:759(compile)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:937(parse)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:598(_code)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:435(_parse_sub)"
msgstr ""

#: ../../library/profile.rst:83
#, fuzzy
msgid ""
"The first line indicates that 214 calls were monitored.  Of those calls, "
"207 were :dfn:`primitive`, meaning that the call was not induced via "
"recursion. The next line: ``Ordered by: cumulative time`` indicates the "
"output is sorted by the ``cumtime`` values. The column headings include:"
msgstr ""
"첫 번째 줄은 197개의 호출이 관찰되었음을 나타냅니다. 이 호출 중 192개는 "
":dfn:`프리미티브(primitive)`\\였으며, 이는 호출이 재귀를 통해 유발되지 않았음을 의미합니다. 다음 줄: "
"``Ordered by: standard name``, 은 가장 오른쪽 열의 텍스트 문자열이 출력을 정렬하는 데 사용되었음을 "
"나타냅니다. 열 제목은 다음과 같습니다:"

#: ../../library/profile.rst:88
msgid "ncalls"
msgstr "ncalls"

#: ../../library/profile.rst:89
msgid "for the number of calls."
msgstr "호출 수."

#: ../../library/profile.rst:91
msgid "tottime"
msgstr "tottime"

#: ../../library/profile.rst:92
msgid ""
"for the total time spent in the given function (and excluding time made "
"in calls to sub-functions)"
msgstr "주어진 함수에서 소비된 총 시간 (서브 함수 호출에 든 시간은 제외합니다)"

#: ../../library/profile.rst:95 ../../library/profile.rst:102
msgid "percall"
msgstr "percall"

#: ../../library/profile.rst:96
msgid "is the quotient of ``tottime`` divided by ``ncalls``"
msgstr "``tottime``\\을 ``ncalls``\\로 나눈 몫"

#: ../../library/profile.rst:98
msgid "cumtime"
msgstr "cumtime"

#: ../../library/profile.rst:99
msgid ""
"is the cumulative time spent in this and all subfunctions (from "
"invocation till exit). This figure is accurate *even* for recursive "
"functions."
msgstr "이 함수와 모든 서브 함수에서 소요된 누적 시간 (호출에서 종료까지). 이 수치는 재귀 함수에서도 *정확*\\합니다."

#: ../../library/profile.rst:103
msgid "is the quotient of ``cumtime`` divided by primitive calls"
msgstr "``cumtime``\\을 프리미티브 호출로 나눈 몫"

#: ../../library/profile.rst:105
msgid "filename:lineno(function)"
msgstr "filename:lineno(function)"

#: ../../library/profile.rst:106
msgid "provides the respective data of each function"
msgstr "각 함수의 해당 데이터를 제공합니다 -- 파일명:줄 번호(함수)"

#: ../../library/profile.rst:108
msgid ""
"When there are two numbers in the first column (for example ``3/1``), it "
"means that the function recursed.  The second value is the number of "
"primitive calls and the former is the total number of calls.  Note that "
"when the function does not recurse, these two values are the same, and "
"only the single figure is printed."
msgstr ""
"첫 번째 열에 두 개의 숫자가 있으면 (예를 들어 ``3/1``), 함수가 재귀 되었음을 의미합니다. 두 번째 값은 프리미티브 호출"
" 수이고 앞엣것은 총 호출 수입니다. 함수가 재귀 되지 않으면, 이 두 값은 같으며, 한 숫자만 인쇄됩니다."

#: ../../library/profile.rst:114
msgid ""
"Instead of printing the output at the end of the profile run, you can "
"save the results to a file by specifying a filename to the :func:`run` "
"function::"
msgstr "프로파일 실행의 끝에 출력을 인쇄하는 대신, :func:`run` 함수에 파일명을 지정하여 결과를 파일에 저장할 수 있습니다::"

#: ../../library/profile.rst:117
msgid ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")', 'restats')"
msgstr ""

#: ../../library/profile.rst:121
msgid ""
"The :class:`pstats.Stats` class reads profile results from a file and "
"formats them in various ways."
msgstr ":class:`pstats.Stats` 클래스는 파일에서 프로파일 결과를 읽고 다양한 방식으로 포맷합니다."

#: ../../library/profile.rst:128
msgid ""
"The files :mod:`cProfile` and :mod:`profile` can also be invoked as a "
"script to profile another script.  For example::"
msgstr ""
":mod:`cProfile`\\과 :mod:`profile`\\을 스크립트로 호출하여 다른 스크립트를 프로파일링 할 수도 있습니다."
" 예를 들면::"

#: ../../library/profile.rst:131
msgid ""
"python -m cProfile [-o output_file] [-s sort_order] (-m module | "
"myscript.py)"
msgstr ""

#: ../../library/profile.rst:135
#, fuzzy
msgid "Writes the profile results to a file instead of to stdout."
msgstr "``-o``\\는 stdout 대신 파일에 프로파일 결과를 씁니다."

#: ../../library/profile.rst:139
#, fuzzy
msgid ""
"Specifies one of the :func:`~pstats.Stats.sort_stats` sort values to sort"
" the output by. This only applies when :option:`-o <cProfile -o>` is not "
"supplied."
msgstr ""
"``-s``\\는 출력을 정렬할 :func:`~pstats.Stats.sort_stats` 정렬 값 중 하나를 지정합니다. 이는 "
"``-o``\\가 제공되지 않은 경우에만 적용됩니다."

#: ../../library/profile.rst:145
#, fuzzy
msgid "Specifies that a module is being profiled instead of a script."
msgstr "``-m``\\은 스크립트 대신 모듈이 프로파일링 되도록 지정합니다."

#: ../../library/profile.rst:147
msgid "Added the ``-m`` option to :mod:`cProfile`."
msgstr "``-m`` 옵션을 :mod:`cProfile`\\에 추가했습니다."

#: ../../library/profile.rst:150
msgid "Added the ``-m`` option to :mod:`profile`."
msgstr "``-m`` 옵션을 :mod:`profile`\\에 추가했습니다."

#: ../../library/profile.rst:153
msgid ""
"The :mod:`pstats` module's :class:`~pstats.Stats` class has a variety of "
"methods for manipulating and printing the data saved into a profile "
"results file::"
msgstr ""
":mod:`pstats` 모듈의 :class:`~pstats.Stats` 클래스에는 프로파일 결과 파일에 저장된 데이터를 조작하고 "
"인쇄하기 위한 다양한 메서드가 있습니다::"

#: ../../library/profile.rst:156
msgid ""
"import pstats\n"
"from pstats import SortKey\n"
"p = pstats.Stats('restats')\n"
"p.strip_dirs().sort_stats(-1).print_stats()"
msgstr ""

#: ../../library/profile.rst:161
msgid ""
"The :meth:`~pstats.Stats.strip_dirs` method removed the extraneous path "
"from all the module names. The :meth:`~pstats.Stats.sort_stats` method "
"sorted all the entries according to the standard module/line/name string "
"that is printed. The :meth:`~pstats.Stats.print_stats` method printed out"
" all the statistics.  You might try the following sort calls::"
msgstr ""
":meth:`~pstats.Stats.strip_dirs` 메서드는 모든 모듈 이름에서 외부 경로를 제거했습니다. "
":meth:`~pstats.Stats.sort_stats` 메서드는 인쇄되는 표준 모듈/줄/이름 문자열에 따라 모든 항목을 "
"정렬했습니다. :meth:`~pstats.Stats.print_stats` 메서드는 모든 통계를 인쇄했습니다. 다음과 같은 정렬 "
"호출을 시도할 수 있습니다::"

#: ../../library/profile.rst:167
msgid ""
"p.sort_stats(SortKey.NAME)\n"
"p.print_stats()"
msgstr ""

#: ../../library/profile.rst:170
msgid ""
"The first call will actually sort the list by function name, and the "
"second call will print out the statistics.  The following are some "
"interesting calls to experiment with::"
msgstr ""
"첫 번째 호출은 실제로 함수 이름으로 목록을 정렬하고, 두 번째 호출은 통계를 인쇄합니다. 다음은 몇 가지 흥미로운 실험 "
"호출입니다::"

#: ../../library/profile.rst:174
msgid "p.sort_stats(SortKey.CUMULATIVE).print_stats(10)"
msgstr ""

#: ../../library/profile.rst:176
msgid ""
"This sorts the profile by cumulative time in a function, and then only "
"prints the ten most significant lines.  If you want to understand what "
"algorithms are taking time, the above line is what you would use."
msgstr ""
"이것은 함수에서의 누적 시간을 기준으로 프로파일을 정렬한 다음, 가장 중요한 10개의 줄만 인쇄합니다. 시간이 걸리는 알고리즘을 "
"이해하려면, 위의 줄을 사용하십시오."

#: ../../library/profile.rst:180
msgid ""
"If you were looking to see what functions were looping a lot, and taking "
"a lot of time, you would do::"
msgstr "어떤 함수가 많이 반복되고 많은 시간이 걸리는지 알고 싶다면, 다음을 수행하여::"

#: ../../library/profile.rst:183
msgid "p.sort_stats(SortKey.TIME).print_stats(10)"
msgstr ""

#: ../../library/profile.rst:185
msgid ""
"to sort according to time spent within each function, and then print the "
"statistics for the top ten functions."
msgstr "각 함수 내에서 소비한 시간에 따라 정렬한 다음, 상위 10개 함수에 대한 통계를 인쇄하십시오."

#: ../../library/profile.rst:188
msgid "You might also try::"
msgstr "다음과 같은 것도 시도해 볼 수 있습니다::"

#: ../../library/profile.rst:190
msgid "p.sort_stats(SortKey.FILENAME).print_stats('__init__')"
msgstr ""

#: ../../library/profile.rst:192
msgid ""
"This will sort all the statistics by file name, and then print out "
"statistics for only the class init methods (since they are spelled with "
"``__init__`` in them).  As one final example, you could try::"
msgstr ""
"이렇게 하면 모든 통계가 파일 이름으로 정렬된 다음, 클래스 초기화(init) 메서드에 대한 통계만 인쇄됩니다 (이들의 철자가 "
"``__init__``\\이기 때문입니다). 마지막 예로, 다음을 시도해 볼 수 있습니다::"

#: ../../library/profile.rst:196
msgid "p.sort_stats(SortKey.TIME, SortKey.CUMULATIVE).print_stats(.5, 'init')"
msgstr ""

#: ../../library/profile.rst:198
msgid ""
"This line sorts statistics with a primary key of time, and a secondary "
"key of cumulative time, and then prints out some of the statistics. To be"
" specific, the list is first culled down to 50% (re: ``.5``) of its "
"original size, then only lines containing ``init`` are maintained, and "
"that sub-sub-list is printed."
msgstr ""
"이 줄은 주 시간 키와 누적 시간 보조 키로 통계를 정렬한 다음, 일부 통계를 인쇄합니다. 구체적으로, 목록을 먼저 원래 크기의 "
"50%(``.5``)로 줄인 다음, ``init``\\를 포함하는 줄만 유지되고, 그 서브 서브 목록이 인쇄됩니다."

#: ../../library/profile.rst:203
msgid ""
"If you wondered what functions called the above functions, you could now "
"(``p`` is still sorted according to the last criteria) do::"
msgstr ""
"어떤 함수가 위의 함수를 호출했는지 궁금하다면, 이제 다음과 같이 할 수 있습니다 (``p``\\는 여전히 마지막 기준에 따라 "
"정렬됩니다)::"

#: ../../library/profile.rst:206
msgid "p.print_callers(.5, 'init')"
msgstr ""

#: ../../library/profile.rst:208
msgid "and you would get a list of callers for each of the listed functions."
msgstr "그러면 나열된 각 함수에 대한 호출자 목록을 얻습니다."

#: ../../library/profile.rst:210
msgid ""
"If you want more functionality, you're going to have to read the manual, "
"or guess what the following functions do::"
msgstr "더 많은 기능을 원하면, 매뉴얼을 읽거나, 다음 함수가 무엇인지 추측하십시오::"

#: ../../library/profile.rst:213
msgid ""
"p.print_callees()\n"
"p.add('restats')"
msgstr ""

#: ../../library/profile.rst:216
msgid ""
"Invoked as a script, the :mod:`pstats` module is a statistics browser for"
" reading and examining profile dumps.  It has a simple line-oriented "
"interface (implemented using :mod:`cmd`) and interactive help."
msgstr ""
"스크립트로 호출될 때, :mod:`pstats` 모듈은 프로파일 덤프를 읽고 검사하기 위한 통계 브라우저입니다. 간단한 줄 지향 "
"인터페이스(:mod:`cmd`\\를 사용하여 구현되었습니다)와 대화식 도움말이 있습니다."

#: ../../library/profile.rst:221
msgid ":mod:`profile` and :mod:`cProfile` Module Reference"
msgstr ":mod:`profile`\\과 :mod:`cProfile` 모듈 레퍼런스"

#: ../../library/profile.rst:227
msgid ""
"Both the :mod:`profile` and :mod:`cProfile` modules provide the following"
" functions:"
msgstr ":mod:`profile`\\과 :mod:`cProfile` 모듈은 모두 다음 함수를 제공합니다:"

#: ../../library/profile.rst:232
msgid ""
"This function takes a single argument that can be passed to the "
":func:`exec` function, and an optional file name.  In all cases this "
"routine executes::"
msgstr ""
"이 함수는 :func:`exec` 함수에 전달할 수 있는 단일 인자와 선택적 파일 이름을 취합니다. 모든 경우에 이 루틴은 다음을 "
"실행합니다::"

#: ../../library/profile.rst:235
msgid "exec(command, __main__.__dict__, __main__.__dict__)"
msgstr ""

#: ../../library/profile.rst:237
msgid ""
"and gathers profiling statistics from the execution. If no file name is "
"present, then this function automatically creates a "
":class:`~pstats.Stats` instance and prints a simple profiling report. If "
"the sort value is specified, it is passed to this :class:`~pstats.Stats` "
"instance to control how the results are sorted."
msgstr ""
"그리고 실행으로부터 프로파일링 통계를 수집합니다. 파일 이름이 없으면, 이 함수는 자동으로 :class:`~pstats.Stats`"
" 인스턴스를 만들고 간단한 프로파일링 보고서를 인쇄합니다. 정렬 값이 지정되면, 이 :class:`~pstats.Stats` "
"인스턴스로 전달되어 결과 정렬 방법을 제어합니다."

#: ../../library/profile.rst:245
#, fuzzy
msgid ""
"This function is similar to :func:`run`, with added arguments to supply "
"the globals and locals mappings for the *command* string. This routine "
"executes::"
msgstr ""
"이 함수는 :func:`run`\\과 유사하며, *command* 문자열에 대한 전역(globals)과 지역(locals) "
"딕셔너리를 제공하기 위한 인자가 추가되었습니다. 이 루틴은 다음을 실행합니다::"

#: ../../library/profile.rst:249
msgid "exec(command, globals, locals)"
msgstr ""

#: ../../library/profile.rst:251
msgid "and gathers profiling statistics as in the :func:`run` function above."
msgstr "그리고 위의 :func:`run` 함수에서와같이 프로파일링 통계를 수집합니다."

#: ../../library/profile.rst:255
msgid ""
"This class is normally only used if more precise control over profiling "
"is needed than what the :func:`cProfile.run` function provides."
msgstr ""
"이 클래스는 일반적으로 :func:`cProfile.run` 함수가 제공하는 것보다 프로파일링에 대한 더 세밀한 제어가 필요할 때만"
" 사용됩니다."

#: ../../library/profile.rst:258
msgid ""
"A custom timer can be supplied for measuring how long code takes to run "
"via the *timer* argument. This must be a function that returns a single "
"number representing the current time. If the number is an integer, the "
"*timeunit* specifies a multiplier that specifies the duration of each "
"unit of time. For example, if the timer returns times measured in "
"thousands of seconds, the time unit would be ``.001``."
msgstr ""
"*timer* 인자를 통해 코드를 실행하는 데 걸리는 시간을 측정하기 위한 사용자 정의 타이머를 제공할 수 있습니다. 현재 시각을 "
"나타내는 단일 숫자를 반환하는 함수여야 합니다. 숫자가 정수이면, *timeunit*\\는 각 시간 단위의 지속 시간을 지정하는 "
"승수를 지정합니다. 예를 들어, 타이머가 밀리초 단위로 측정된 시간을 반환하면 시간 단위는 ``.001``\\입니다."

#: ../../library/profile.rst:265
msgid ""
"Directly using the :class:`Profile` class allows formatting profile "
"results without writing the profile data to a file::"
msgstr ":class:`Profile` 클래스를 직접 사용하면 프로파일 데이터를 파일에 쓰지 않고도 프로파일 결과를 포맷할 수 있습니다::"

#: ../../library/profile.rst:268
msgid ""
"import cProfile, pstats, io\n"
"from pstats import SortKey\n"
"pr = cProfile.Profile()\n"
"pr.enable()\n"
"# ... do something ...\n"
"pr.disable()\n"
"s = io.StringIO()\n"
"sortby = SortKey.CUMULATIVE\n"
"ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\n"
"ps.print_stats()\n"
"print(s.getvalue())"
msgstr ""

#: ../../library/profile.rst:280
msgid ""
"The :class:`Profile` class can also be used as a context manager "
"(supported only in :mod:`cProfile` module. see "
":ref:`typecontextmanager`)::"
msgstr ""
":class:`Profile` 클래스는 컨텍스트 관리자로도 사용될 수 있습니다 (:mod:`cProfile` 모듈에서만 지원됩니다."
" :ref:`typecontextmanager`\\을 참조하십시오)::"

#: ../../library/profile.rst:283
msgid ""
"import cProfile\n"
"\n"
"with cProfile.Profile() as pr:\n"
"    # ... do something ...\n"
"\n"
"    pr.print_stats()"
msgstr ""

#: ../../library/profile.rst:290
msgid "Added context manager support."
msgstr "컨텍스트 관리자 지원이 추가되었습니다."

#: ../../library/profile.rst:295
msgid "Start collecting profiling data. Only in :mod:`cProfile`."
msgstr "프로파일링 데이터 수집을 시작합니다. :mod:`cProfile`\\에만 있습니다."

#: ../../library/profile.rst:299
msgid "Stop collecting profiling data. Only in :mod:`cProfile`."
msgstr "프로파일링 데이터 수집을 중지합니다. :mod:`cProfile`\\에만 있습니다."

#: ../../library/profile.rst:303
msgid ""
"Stop collecting profiling data and record the results internally as the "
"current profile."
msgstr "프로파일링 데이터 수집을 중지하고 결과를 내부적으로 현재 프로파일로 기록합니다."

#: ../../library/profile.rst:308
msgid ""
"Create a :class:`~pstats.Stats` object based on the current profile and "
"print the results to stdout."
msgstr "현재 프로파일을 기반으로 :class:`~pstats.Stats` 객체를 만들고 결과를 stdout에 인쇄합니다."

#: ../../library/profile.rst:311
msgid ""
"The *sort* parameter specifies the sorting order of the displayed "
"statistics. It accepts a single key or a tuple of keys to enable multi-"
"level sorting, as in :func:`Stats.sort_stats <pstats.Stats.sort_stats>`."
msgstr ""

#: ../../library/profile.rst:315
msgid ":meth:`~Profile.print_stats` now accepts a tuple of keys."
msgstr ""

#: ../../library/profile.rst:320
msgid "Write the results of the current profile to *filename*."
msgstr "현재 프로파일의 결과를 *filename*\\에 씁니다."

#: ../../library/profile.rst:324
msgid "Profile the cmd via :func:`exec`."
msgstr ":func:`exec`\\를 통해 cmd를 프로파일 합니다."

#: ../../library/profile.rst:328
msgid ""
"Profile the cmd via :func:`exec` with the specified global and local "
"environment."
msgstr "지정된 전역과 지역 환경으로 :func:`exec`\\를 통해 cmd를 프로파일 합니다."

#: ../../library/profile.rst:333
msgid "Profile ``func(*args, **kwargs)``"
msgstr "``func(*args, **kwargs)``\\를 프로파일 합니다"

#: ../../library/profile.rst:335
msgid ""
"Note that profiling will only work if the called command/function "
"actually returns.  If the interpreter is terminated (e.g. via a "
":func:`sys.exit` call during the called command/function execution) no "
"profiling results will be printed."
msgstr ""
"프로파일링은 호출된 명령/함수가 실제로 반환하는 경우에만 작동함에 유의하십시오. 인터프리터가 종료되면 (예를 들어 호출된 명령/함수"
" 실행 중 :func:`sys.exit` 호출을 통해) 아무런 프로파일링 결과도 인쇄되지 않습니다."

#: ../../library/profile.rst:343
msgid "The :class:`Stats` Class"
msgstr ":class:`Stats` 클래스"

#: ../../library/profile.rst:345
msgid ""
"Analysis of the profiler data is done using the :class:`~pstats.Stats` "
"class."
msgstr "프로파일러 데이터의 분석은 :class:`~pstats.Stats` 클래스를 사용하여 수행됩니다."

#: ../../library/profile.rst:352
msgid ""
"This class constructor creates an instance of a \"statistics object\" "
"from a *filename* (or list of filenames) or from a :class:`Profile` "
"instance. Output will be printed to the stream specified by *stream*."
msgstr ""
"이 클래스 생성자는 *filename*\\(또는 파일명의 리스트)이나 :class:`Profile` 인스턴스에서 \"통계 객체\"의"
" 인스턴스를 만듭니다. 출력은 *stream*\\에 의해 지정된 스트림으로 인쇄됩니다."

#: ../../library/profile.rst:356
msgid ""
"The file selected by the above constructor must have been created by the "
"corresponding version of :mod:`profile` or :mod:`cProfile`.  To be "
"specific, there is *no* file compatibility guaranteed with future "
"versions of this profiler, and there is no compatibility with files "
"produced by other profilers, or the same profiler run on a different "
"operating system.  If several files are provided, all the statistics for "
"identical functions will be coalesced, so that an overall view of several"
" processes can be considered in a single report.  If additional files "
"need to be combined with data in an existing :class:`~pstats.Stats` "
"object, the :meth:`~pstats.Stats.add` method can be used."
msgstr ""
"위의 생성자에 의해 선택된 파일은 해당 버전의 :mod:`profile`\\이나 :mod:`cProfile`\\에 의해 만들어졌어야"
" 합니다. 구체적으로, 이 프로파일러의 향후 버전에서 보장되는 파일 호환성은 *없으며*, 다른 프로파일러에서 생성된 파일이나 다른 "
"운영 체제에서 실행되는 같은 프로파일러의 실행과 호환되지 않습니다. 여러 파일이 제공되면, 동일한 함수에 대한 모든 통계가 "
"통합되므로, 여러 프로세스에 대한 전체 뷰를 단일 보고서에서 고려할 수 있습니다. 추가 파일을 기존 "
":class:`~pstats.Stats` 객체의 데이터와 결합해야 하면, :meth:`~pstats.Stats.add` 메서드를 "
"사용할 수 있습니다."

#: ../../library/profile.rst:367
msgid ""
"Instead of reading the profile data from a file, a "
":class:`cProfile.Profile` or :class:`profile.Profile` object can be used "
"as the profile data source."
msgstr ""
"파일에서 프로파일 데이터를 읽는 대신, :class:`cProfile.Profile`\\이나 "
":class:`profile.Profile` 객체를 프로파일 데이터 소스로 사용할 수 있습니다."

#: ../../library/profile.rst:370
msgid ":class:`Stats` objects have the following methods:"
msgstr ":class:`Stats` 객체에는 다음과 같은 메서드가 있습니다:"

#: ../../library/profile.rst:374
msgid ""
"This method for the :class:`Stats` class removes all leading path "
"information from file names.  It is very useful in reducing the size of "
"the printout to fit within (close to) 80 columns.  This method modifies "
"the object, and the stripped information is lost.  After performing a "
"strip operation, the object is considered to have its entries in a "
"\"random\" order, as it was just after object initialization and loading."
" If :meth:`~pstats.Stats.strip_dirs` causes two function names to be "
"indistinguishable (they are on the same line of the same filename, and "
"have the same function name), then the statistics for these two entries "
"are accumulated into a single entry."
msgstr ""
":class:`Stats` 클래스에 대한 이 메서드는 파일 이름에서 모든 선행 경로 정보를 제거합니다. 80열 이내에 (가깝게) "
"맞게 출력물의 크기를 줄이는 데 매우 유용합니다. 이 메서드는 객체를 수정하고, 제거된 정보는 손실됩니다. 제거 조작을 수행한 후,"
" 객체는 객체 초기화와 로드 직후와 마찬가지로 \"임의의\" 순서로 항목을 가진 것으로 간주합니다. "
":meth:`~pstats.Stats.strip_dirs`\\로 인해 두 함수 이름이 구별할 수 없게 되면 (같은 파일 이름의 같은"
" 줄에 있고, 함수 이름도 같습니다), 이 두 항목에 대한 통계는 단일 항목으로 누적됩니다."

#: ../../library/profile.rst:388
msgid ""
"This method of the :class:`Stats` class accumulates additional profiling "
"information into the current profiling object.  Its arguments should "
"refer to filenames created by the corresponding version of "
":func:`profile.run` or :func:`cProfile.run`. Statistics for identically "
"named (re: file, line, name) functions are automatically accumulated into"
" single function statistics."
msgstr ""
":class:`Stats` 클래스의 이 메서드는 추가 프로파일링 정보를 현재 프로파일링 객체에 누적합니다. 인자는 해당 버전의 "
":func:`profile.run`\\이나 :func:`cProfile.run`\\으로 만들어진 파일명을 참조해야 합니다. 동일한 "
"이름을 가진 (파일, 줄, 이름) 함수에 대한 통계는 자동으로 단일 함수 통계에 축적됩니다."

#: ../../library/profile.rst:398
msgid ""
"Save the data loaded into the :class:`Stats` object to a file named "
"*filename*.  The file is created if it does not exist, and is overwritten"
" if it already exists.  This is equivalent to the method of the same name"
" on the :class:`profile.Profile` and :class:`cProfile.Profile` classes."
msgstr ""
":class:`Stats` 객체에 로드된 데이터를 *filename*\\이라는 파일에 저장합니다. 파일이 없으면 만들어지고, 이미 "
"존재하면 덮어씁니다. 이것은 :class:`profile.Profile`\\과 :class:`cProfile.Profile` "
"클래스에 있는 같은 이름의 메서드와 동등합니다."

#: ../../library/profile.rst:406
msgid ""
"This method modifies the :class:`Stats` object by sorting it according to"
" the supplied criteria.  The argument can be either a string or a SortKey"
" enum identifying the basis of a sort (example: ``'time'``, ``'name'``, "
"``SortKey.TIME`` or ``SortKey.NAME``). The SortKey enums argument have "
"advantage over the string argument in that it is more robust and less "
"error prone."
msgstr ""
"이 메서드는 제공된 기준에 따라 :class:`Stats` 객체를 정렬하여 수정합니다. 인자는 정렬 기준을 식별하는 문자열이나 "
"SortKey 열거형일 수 있습니다 (예: ``'time'``, ``'name'``, ``SortKey.TIME`` 또는 "
"``SortKey.NAME``). SortKey 열거형 인자는 문자열 인자보다 안정적이고 에러가 적다는 점에서 문자열 인자보다 "
"유리합니다."

#: ../../library/profile.rst:413
msgid ""
"When more than one key is provided, then additional keys are used as "
"secondary criteria when there is equality in all keys selected before "
"them.  For example, ``sort_stats(SortKey.NAME, SortKey.FILE)`` will sort "
"all the entries according to their function name, and resolve all ties "
"(identical function names) by sorting by file name."
msgstr ""
"둘 이상의 키가 제공되면, 그 앞에 선택된 모든 키가 같을 때 추가 키가 보조 기준으로 사용됩니다. 예를 들어, "
"``sort_stats(SortKey.NAME, SortKey.FILE)``\\은 함수 이름에 따라 모든 항목을 정렬하고, 함수 "
"이름이 같으면 파일 이름으로 정렬합니다."

#: ../../library/profile.rst:419
msgid ""
"For the string argument, abbreviations can be used for any key names, as "
"long as the abbreviation is unambiguous."
msgstr "문자열 인자의 경우, 약어가 모호하지 않은 한, 모든 키 이름에 약어를 사용할 수 있습니다."

#: ../../library/profile.rst:422
msgid "The following are the valid string and SortKey:"
msgstr "유효한 문자열과 SortKey는 다음과 같습니다:"

#: ../../library/profile.rst:425
msgid "Valid String Arg"
msgstr "유효한 문자열 인자"

#: ../../library/profile.rst:425
msgid "Valid enum Arg"
msgstr "유효한 열거형 인자"

#: ../../library/profile.rst:425
msgid "Meaning"
msgstr "의미"

#: ../../library/profile.rst:427
msgid "``'calls'``"
msgstr "``'calls'``"

#: ../../library/profile.rst:427
msgid "SortKey.CALLS"
msgstr "SortKey.CALLS"

#: ../../library/profile.rst:427 ../../library/profile.rst:439
msgid "call count"
msgstr "호출 수"

#: ../../library/profile.rst:429
msgid "``'cumulative'``"
msgstr "``'cumulative'``"

#: ../../library/profile.rst:429
msgid "SortKey.CUMULATIVE"
msgstr "SortKey.CUMULATIVE"

#: ../../library/profile.rst:429 ../../library/profile.rst:431
msgid "cumulative time"
msgstr "누적 시간"

#: ../../library/profile.rst:431
msgid "``'cumtime'``"
msgstr "``'cumtime'``"

#: ../../library/profile.rst:431 ../../library/profile.rst:433
#: ../../library/profile.rst:437 ../../library/profile.rst:439
#: ../../library/profile.rst:453
msgid "N/A"
msgstr "해당 없음"

#: ../../library/profile.rst:433
msgid "``'file'``"
msgstr "``'file'``"

#: ../../library/profile.rst:433 ../../library/profile.rst:435
#: ../../library/profile.rst:437
msgid "file name"
msgstr "파일 이름"

#: ../../library/profile.rst:435
msgid "``'filename'``"
msgstr "``'filename'``"

#: ../../library/profile.rst:435
msgid "SortKey.FILENAME"
msgstr "SortKey.FILENAME"

#: ../../library/profile.rst:437
msgid "``'module'``"
msgstr "``'module'``"

#: ../../library/profile.rst:439
msgid "``'ncalls'``"
msgstr "``'ncalls'``"

#: ../../library/profile.rst:441
msgid "``'pcalls'``"
msgstr "``'pcalls'``"

#: ../../library/profile.rst:441
msgid "SortKey.PCALLS"
msgstr "SortKey.PCALLS"

#: ../../library/profile.rst:441
msgid "primitive call count"
msgstr "프리미티브 호출 수"

#: ../../library/profile.rst:443
msgid "``'line'``"
msgstr "``'line'``"

#: ../../library/profile.rst:443
msgid "SortKey.LINE"
msgstr "SortKey.LINE"

#: ../../library/profile.rst:443
msgid "line number"
msgstr "줄 번호"

#: ../../library/profile.rst:445
msgid "``'name'``"
msgstr "``'name'``"

#: ../../library/profile.rst:445
msgid "SortKey.NAME"
msgstr "SortKey.NAME"

#: ../../library/profile.rst:445
msgid "function name"
msgstr "함수 이름"

#: ../../library/profile.rst:447
msgid "``'nfl'``"
msgstr "``'nfl'``"

#: ../../library/profile.rst:447
msgid "SortKey.NFL"
msgstr "SortKey.NFL"

#: ../../library/profile.rst:447
msgid "name/file/line"
msgstr "이름/파일/줄"

#: ../../library/profile.rst:449
msgid "``'stdname'``"
msgstr "``'stdname'``"

#: ../../library/profile.rst:449
msgid "SortKey.STDNAME"
msgstr "SortKey.STDNAME"

#: ../../library/profile.rst:449
msgid "standard name"
msgstr "표준 이름"

#: ../../library/profile.rst:451
msgid "``'time'``"
msgstr "``'time'``"

#: ../../library/profile.rst:451
msgid "SortKey.TIME"
msgstr "SortKey.TIME"

#: ../../library/profile.rst:451 ../../library/profile.rst:453
msgid "internal time"
msgstr "내부 시간"

#: ../../library/profile.rst:453
msgid "``'tottime'``"
msgstr "``'tottime'``"

#: ../../library/profile.rst:456
msgid ""
"Note that all sorts on statistics are in descending order (placing most "
"time consuming items first), where as name, file, and line number "
"searches are in ascending order (alphabetical). The subtle distinction "
"between ``SortKey.NFL`` and ``SortKey.STDNAME`` is that the standard name"
" is a sort of the name as printed, which means that the embedded line "
"numbers get compared in an odd way.  For example, lines 3, 20, and 40 "
"would (if the file names were the same) appear in the string order 20, 3 "
"and 40. In contrast, ``SortKey.NFL`` does a numeric compare of the line "
"numbers. In fact, ``sort_stats(SortKey.NFL)`` is the same as "
"``sort_stats(SortKey.NAME, SortKey.FILENAME, SortKey.LINE)``."
msgstr ""
"통계의 모든 정렬은 내림차순이고 (가장 시간이 오래 걸리는 항목을 앞에 놓습니다), 이름, 파일 및 줄 번호 검색은 오름차순(알파벳"
" 순서)임에 유의하십시오. ``SortKey.NFL``\\과 ``SortKey.STDNAME`` 간의 미묘한 차이점은 표준 이름이 "
"인쇄된 이름의 일종이라는 것입니다. 즉, 포함된 줄 번호가 이상한 방식으로 비교됩니다. 예를 들어, 줄 3, 20 및 40은 (파일"
" 이름이 같으면) 문자열 순서 20, 3 및 40으로 나타납니다. 반면에 ``SortKey.NFL``\\은 줄 번호를 숫자로 "
"비교합니다. 실제로, ``sort_stats(SortKey.NFL)``\\은 ``sort_stats(SortKey.NAME, "
"SortKey.FILENAME, SortKey.LINE)``\\과 같습니다."

#: ../../library/profile.rst:467
msgid ""
"For backward-compatibility reasons, the numeric arguments ``-1``, ``0``, "
"``1``, and ``2`` are permitted.  They are interpreted as ``'stdname'``, "
"``'calls'``, ``'time'``, and ``'cumulative'`` respectively.  If this old "
"style format (numeric) is used, only one sort key (the numeric key) will "
"be used, and additional arguments will be silently ignored."
msgstr ""
"이전 버전과의 호환성을 위해, 숫자 인자 ``-1``, ``0``, ``1`` 및 ``2``\\가 허용됩니다. 이들은 각각 "
"``'stdname'``, ``'calls'``, ``'time'`` 및 ``'cumulative'``\\로 해석됩니다. 이 이전 "
"스타일 형식(숫자)을 사용하면, 오직 하나의 정렬 키(숫자키)만 사용되며, 추가 인자는 조용히 무시됩니다."

#: ../../library/profile.rst:475
msgid "Added the SortKey enum."
msgstr "SortKey 열거형을 추가했습니다."

#: ../../library/profile.rst:480
msgid ""
"This method for the :class:`Stats` class reverses the ordering of the "
"basic list within the object.  Note that by default ascending vs "
"descending order is properly selected based on the sort key of choice."
msgstr ""
":class:`Stats` 클래스에 대한 이 메서드는 객체 내 기본 리스트의 순서를 뒤집습니다. 기본적으로 오름차순 대 내림차순은 "
"선택한 정렬 키에 따라 올바르게 선택됨에 유의하십시오."

#: ../../library/profile.rst:490
msgid ""
"This method for the :class:`Stats` class prints out a report as described"
" in the :func:`profile.run` definition."
msgstr ":class:`Stats` 클래스에 대한 이 메서드는 :func:`profile.run` 정의에 설명된 대로 보고서를 인쇄합니다."

#: ../../library/profile.rst:493
msgid ""
"The order of the printing is based on the last "
":meth:`~pstats.Stats.sort_stats` operation done on the object (subject to"
" caveats in :meth:`~pstats.Stats.add` and "
":meth:`~pstats.Stats.strip_dirs`)."
msgstr ""
"인쇄 순서는 객체에서 수행된 마지막 :meth:`~pstats.Stats.sort_stats` 연산을 기반으로 합니다 "
"(:meth:`~pstats.Stats.add`\\와 :meth:`~pstats.Stats.strip_dirs`\\의 경고가 "
"적용됩니다)."

#: ../../library/profile.rst:498
msgid ""
"The arguments provided (if any) can be used to limit the list down to the"
" significant entries.  Initially, the list is taken to be the complete "
"set of profiled functions.  Each restriction is either an integer (to "
"select a count of lines), or a decimal fraction between 0.0 and 1.0 "
"inclusive (to select a percentage of lines), or a string that will "
"interpreted as a regular expression (to pattern match the standard name "
"that is printed). If several restrictions are provided, then they are "
"applied sequentially. For example::"
msgstr ""
"(있다면) 제공된 인자를 사용하여 목록을 중요한 항목으로 줄일 수 있습니다. 처음에는, 목록이 전체 프로파일링 된 함수 집합이 "
"됩니다. 각 제한(restriction)은 정수(줄 수 선택)나 0.0과 1.0을 포함하고 그사이의 십진 소수(줄의 백분율을 "
"선택), 또는 정규식으로 해석되는 문자열(인쇄되는 표준 이름과 일치하는 패턴)입니다. 여러 제한이 제공되면, 순차적으로 적용됩니다."
" 예를 들면::"

#: ../../library/profile.rst:507
msgid "print_stats(.1, 'foo:')"
msgstr ""

#: ../../library/profile.rst:509
#, python-format
msgid ""
"would first limit the printing to first 10% of list, and then only print "
"functions that were part of filename :file:`.\\*foo:`.  In contrast, the "
"command::"
msgstr ""
"는 먼저 인쇄를 목록의 처음 10%로 제한한 다음, 파일 이름 :file:`.\\*foo:`\\의 일부인 함수만 인쇄합니다. "
"대조적으로, 명령::"

#: ../../library/profile.rst:513
msgid "print_stats('foo:', .1)"
msgstr ""

#: ../../library/profile.rst:515
#, python-format
msgid ""
"would limit the list to all functions having file names :file:`.\\*foo:`,"
" and then proceed to only print the first 10% of them."
msgstr "은 파일 이름이 :file:`.\\*foo:` 인 모든 함수로 목록을 제한한 다음, 그중 처음 10%만 인쇄합니다."

#: ../../library/profile.rst:521
msgid ""
"This method for the :class:`Stats` class prints a list of all functions "
"that called each function in the profiled database.  The ordering is "
"identical to that provided by :meth:`~pstats.Stats.print_stats`, and the "
"definition of the restricting argument is also identical.  Each caller is"
" reported on its own line.  The format differs slightly depending on the "
"profiler that produced the stats:"
msgstr ""
":class:`Stats` 클래스에 대한 이 메서드는 프로파일 된 데이터베이스에 있는 각 함수를 호출한 모든 함수의 목록을 "
"인쇄합니다. 순서는 :meth:`~pstats.Stats.print_stats`\\에서 제공한 순서와 동일하며, 제한 인자의 정의도"
" 동일합니다. 각 호출자는 개별 줄로 보고됩니다. 통계를 생성한 프로파일러에 따라 형식이 약간 다릅니다:"

#: ../../library/profile.rst:528
msgid ""
"With :mod:`profile`, a number is shown in parentheses after each caller "
"to show how many times this specific call was made.  For convenience, a "
"second non-parenthesized number repeats the cumulative time spent in the "
"function at the right."
msgstr ""
":mod:`profile`\\을 사용하면, 각 호출자 뒤에 숫자가 괄호 안에 표시되어 이 특정 호출이 몇 번이나 되었는지 "
"표시됩니다. 편의를 위해, 두 번째 괄호로 묶지 않은 숫자는 오른쪽에 나오는 함수에서 소비한 누적 시간을 반복합니다."

#: ../../library/profile.rst:533
msgid ""
"With :mod:`cProfile`, each caller is preceded by three numbers: the "
"number of times this specific call was made, and the total and cumulative"
" times spent in the current function while it was invoked by this "
"specific caller."
msgstr ""
":mod:`cProfile`\\을 사용하면, 각 호출자 앞에 세 숫자가 나옵니다: 이 특정 호출이 발생한 횟수, 이 특정 호출자가 "
"호출한 동안 현재 함수에서 소비 한 총 및 누적 시간."

#: ../../library/profile.rst:541
msgid ""
"This method for the :class:`Stats` class prints a list of all function "
"that were called by the indicated function.  Aside from this reversal of "
"direction of calls (re: called vs was called by), the arguments and "
"ordering are identical to the :meth:`~pstats.Stats.print_callers` method."
msgstr ""
":class:`Stats` 클래스에 대한 이 메서드는 표시된 함수에 의해 호출된 모든 함수의 목록을 인쇄합니다. 이러한 호출 방향 "
"반전(호출한 대 호출된)을 제외하고, 인자와 순서는 :meth:`~pstats.Stats.print_callers` 메서드와 "
"같습니다."

#: ../../library/profile.rst:549
msgid ""
"This method returns an instance of StatsProfile, which contains a mapping"
" of function names to instances of FunctionProfile. Each FunctionProfile "
"instance holds information related to the function's profile such as how "
"long the function took to run, how many times it was called, etc..."
msgstr ""
"이 메서드는 함수 이름을 FunctionProfile 인스턴스로 매핑하는 StatsProfile 인스턴스를 반환합니다. 각 "
"FunctionProfile 인스턴스에는 함수 실행 시간, 호출 횟수 등의 함수의 프로파일 관련 정보가 있습니다."

#: ../../library/profile.rst:554
msgid ""
"Added the following dataclasses: StatsProfile, FunctionProfile. Added the"
" following function: get_stats_profile."
msgstr ""
"다음과 같은 데이터 클래스(dataclasses)를 추가했습니다: StatsProfile, FunctionProfile. 다음과 "
"같은 함수를 추가했습니다: get_stats_profile."

#: ../../library/profile.rst:561
msgid "What Is Deterministic Profiling?"
msgstr "결정론적 프로파일링이란 무엇입니까?"

#: ../../library/profile.rst:563
msgid ""
":dfn:`Deterministic profiling` is meant to reflect the fact that all "
"*function call*, *function return*, and *exception* events are monitored,"
" and precise timings are made for the intervals between these events "
"(during which time the user's code is executing).  In contrast, "
":dfn:`statistical profiling` (which is not done by this module) randomly "
"samples the effective instruction pointer, and deduces where time is "
"being spent.  The latter technique traditionally involves less overhead "
"(as the code does not need to be instrumented), but provides only "
"relative indications of where time is being spent."
msgstr ""
":dfn:`결정론적 프로파일링(Deterministic profiling)`\\이라는 용어는 모든 *함수 호출*, *함수 반환* 및"
" *예외* 이벤트가 모니터링되고, (사용자 코드가 실행되는 시간 동안) 이러한 이벤트 사이의 간격에 대한 정확한 시간 측정이 "
"이루어진다는 사실을 반영하기 위한 것입니다. 반면에, :dfn:`통계적 프로파일링(statistical profiling)`\\(이"
" 모듈에서는 수행하지 않습니다)은 유효 명령어 포인터를 무작위로 샘플링하여 시간이 소비되는 위치를 추론합니다. 후자의 기술은 "
"전통적으로 (코드를 계측할 필요가 없기 때문에) 오버헤드가 적지만, 시간이 어디에서 소비되는지에 대한 상대적 표시만 제공합니다."

#: ../../library/profile.rst:572
msgid ""
"In Python, since there is an interpreter active during execution, the "
"presence of instrumented code is not required in order to do "
"deterministic profiling. Python automatically provides a :dfn:`hook` "
"(optional callback) for each event. In addition, the interpreted nature "
"of Python tends to add so much overhead to execution, that deterministic "
"profiling tends to only add small processing overhead in typical "
"applications.  The result is that deterministic profiling is not that "
"expensive, yet provides extensive run time statistics about the execution"
" of a Python program."
msgstr ""
"파이썬에서는, 실행 중에 인터프리터가 활성화되어있어서, 결정론적 프로파일링을 수행하기 위해 인스트루먼트 된 "
"코드(instrumented code)가 필요하지 않습니다. 파이썬은 각 이벤트에 대해 자동으로 "
":dfn:`훅(hook)`\\(선택적 콜백)을 제공합니다. 또한, 파이썬의 인터프리터 적인 성격은 실행에 이미 많은 오버헤드를 "
"추가하는 경향이 있어서, 결정론적 프로파일링은 일반적인 응용 프로그램에서 작은 처리 오버헤드만 추가하는 경향이 있습니다. 결과적으로"
" 결정론적 프로파일링은 그다지 비싸지 않으면서도, 파이썬 프로그램의 실행에 대한 광범위한 실행 시간 통계를 제공합니다."

#: ../../library/profile.rst:581
msgid ""
"Call count statistics can be used to identify bugs in code (surprising "
"counts), and to identify possible inline-expansion points (high call "
"counts).  Internal time statistics can be used to identify \"hot loops\" "
"that should be carefully optimized.  Cumulative time statistics should be"
" used to identify high level errors in the selection of algorithms.  Note"
" that the unusual handling of cumulative times in this profiler allows "
"statistics for recursive implementations of algorithms to be directly "
"compared to iterative implementations."
msgstr ""
"호출 수 통계를 사용하여 코드의 버그(놀랄만한 횟수)를 식별하고, 가능한 인라인 확장 지점(높은 호출 횟수)을 식별할 수 있습니다."
" 내부 시간 통계를 사용하여 신중하게 최적화해야 하는 \"핫 루프(hot loops)\"를 식별할 수 있습니다. 누적 시간 통계를 "
"사용하여 알고리즘 선택에서의 고수준 에러를 식별할 수 있습니다. 이 프로파일러에서의 누적 시간의 특이한 처리는 알고리즘의 재귀 "
"구현에 대한 통계를 반복 구현과 직접 비교할 수 있도록 함에 유의하십시오."

#: ../../library/profile.rst:594
msgid "Limitations"
msgstr "한계"

#: ../../library/profile.rst:596
msgid ""
"One limitation has to do with accuracy of timing information. There is a "
"fundamental problem with deterministic profilers involving accuracy.  The"
" most obvious restriction is that the underlying \"clock\" is only "
"ticking at a rate (typically) of about .001 seconds.  Hence no "
"measurements will be more accurate than the underlying clock.  If enough "
"measurements are taken, then the \"error\" will tend to average out. "
"Unfortunately, removing this first error induces a second source of "
"error."
msgstr ""
"타이밍 정보의 정확성과 관련하여 한 가지 제약이 있습니다. 정확성과 관련해서는 결정론적 프로파일러에 근본적인 문제가 있습니다. 가장"
" 명백한 제약은 하부 \"시계\"가 (일반적으로) 약 .001 초의 속도로만 눈금이 변하는 것입니다. 따라서 하부 시계보다 더 "
"정확한 측정은 없습니다. 충분한 측정을 수행하면, \"에러\"가 평균이 되어 사라지는 경향이 있습니다. 불행히도, 이 첫 번째 "
"에러를 제거하면 두 번째 에러 원인이 발생합니다."

#: ../../library/profile.rst:604
msgid ""
"The second problem is that it \"takes a while\" from when an event is "
"dispatched until the profiler's call to get the time actually *gets* the "
"state of the clock.  Similarly, there is a certain lag when exiting the "
"profiler event handler from the time that the clock's value was obtained "
"(and then squirreled away), until the user's code is once again "
"executing.  As a result, functions that are called many times, or call "
"many functions, will typically accumulate this error. The error that "
"accumulates in this fashion is typically less than the accuracy of the "
"clock (less than one clock tick), but it *can* accumulate and become very"
" significant."
msgstr ""
"두 번째 문제는 이벤트가 디스패치 된 시점부터 프로파일러가 시간을 얻기 위해 호출하는 것이 실제로 시계의 상태를 *얻기*\\까지 "
"\"시간이 걸린다\"는 것입니다. 마찬가지로, 프로파일러 이벤트 핸들러를 빠져나갈 때 시계값이 획득된 (그런 다음 저장됩니다) "
"시간부터, 사용자의 코드가 다시 실행될 때까지 어떤 지연이 발생합니다. 결과적으로, 여러 번 호출되거나, 많은 함수를 호출하는 "
"함수는 일반적으로 이 에러를 누적합니다. 이러한 방식으로 누적되는 에러는 일반적으로 시계 정확도(1 눈금 미만)보다 작지만, 누적될"
" *수* 있어서 매우 중요해집니다."

#: ../../library/profile.rst:614
msgid ""
"The problem is more important with :mod:`profile` than with the lower-"
"overhead :mod:`cProfile`.  For this reason, :mod:`profile` provides a "
"means of calibrating itself for a given platform so that this error can "
"be probabilistically (on the average) removed. After the profiler is "
"calibrated, it will be more accurate (in a least square sense), but it "
"will sometimes produce negative numbers (when call counts are "
"exceptionally low, and the gods of probability work against you :-). )  "
"Do *not* be alarmed by negative numbers in the profile.  They should "
"*only* appear if you have calibrated your profiler, and the results are "
"actually better than without calibration."
msgstr ""
"오버헤드가 낮은 :mod:`cProfile`\\보다 :mod:`profile`\\에서 이 문제가 더 중요합니다. 이러한 이유로, "
":mod:`profile`\\은 특정 플랫폼에 대해 자신을 보정하는 방법을 제공하여 이 에러를 확률적으로 (평균적으로) 제거할 수 "
"있습니다. 프로파일러가 보정된 후에는, 더 정확하지만 (최소한 최소 자승의 의미에서), 때로는 음수를 생성합니다 (호출 횟수가 "
"예외적으로 낮고, 확률의 신들이 당신에게 등을 돌리면 :-). ) 프로파일에서 음수를 보아도 너무 놀라지 *마십시오*. 프로파일러를"
" 보정한 경우에\\*만* 나타나야 하며, 결과는 실제로 보정하지 않은 것보다 낫습니다."

#: ../../library/profile.rst:628
msgid "Calibration"
msgstr "보정"

#: ../../library/profile.rst:630
msgid ""
"The profiler of the :mod:`profile` module subtracts a constant from each "
"event handling time to compensate for the overhead of calling the time "
"function, and socking away the results.  By default, the constant is 0. "
"The following procedure can be used to obtain a better constant for a "
"given platform (see :ref:`profile-limitations`). ::"
msgstr ""
":mod:`profile` 모듈의 프로파일러는 각 이벤트 처리 시간에서 상수를 빼서 시간 함수 호출의 오버헤드를 보상하고, 결과를 "
"잘 보관합니다. 기본적으로, 상수는 0입니다. 다음 절차는 주어진 플랫폼에 대해 더 나은 상수를 얻는 데 사용될 수 있습니다 "
"(:ref:`profile-limitations`\\를 참조하십시오). ::"

#: ../../library/profile.rst:636
msgid ""
"import profile\n"
"pr = profile.Profile()\n"
"for i in range(5):\n"
"    print(pr.calibrate(10000))"
msgstr ""

#: ../../library/profile.rst:641
#, fuzzy
msgid ""
"The method executes the number of Python calls given by the argument, "
"directly and again under the profiler, measuring the time for both. It "
"then computes the hidden overhead per profiler event, and returns that as"
" a float.  For example, on a 1.8Ghz Intel Core i5 running macOS, and "
"using Python's time.process_time() as the timer, the magical number is "
"about 4.04e-6."
msgstr ""
"이 메서드는 인자가 제공한 횟수의 파이썬 호출을, 직접하고 프로파일러하에서 다시 하면서, 두 두 시간을 측정합니다. 그런 다음 "
"프로파일러 이벤트 당 숨겨진 오버헤드를 계산하여 부동 소수점으로 반환합니다. 예를 들어, Mac OS X를 실행하는 1.8Ghz "
"인텔 코어 i5에서, 그리고 파이썬의 time.process_time()을 타이머로 사용할 때, 매직 넘버는 약 "
"4.04e-6입니다."

#: ../../library/profile.rst:647
msgid ""
"The object of this exercise is to get a fairly consistent result. If your"
" computer is *very* fast, or your timer function has poor resolution, you"
" might have to pass 100000, or even 1000000, to get consistent results."
msgstr ""
"이 반복의 목적은 상당히 일관된 결과를 얻는 것입니다. 컴퓨터가 *매우* 빠르거나, 타이머 함수의 해상도가 좋지 않으면, 일관된 "
"결과를 얻기 위해 100000이나 심지어 1000000을 전달해야 할 수 있습니다."

#: ../../library/profile.rst:651
msgid "When you have a consistent answer, there are three ways you can use it::"
msgstr "일관된 대답을 얻었을 때, 세 가지 방법으로 사용할 수 있습니다::"

#: ../../library/profile.rst:653
msgid ""
"import profile\n"
"\n"
"# 1. Apply computed bias to all Profile instances created hereafter.\n"
"profile.Profile.bias = your_computed_bias\n"
"\n"
"# 2. Apply computed bias to a specific Profile instance.\n"
"pr = profile.Profile()\n"
"pr.bias = your_computed_bias\n"
"\n"
"# 3. Specify computed bias in instance constructor.\n"
"pr = profile.Profile(bias=your_computed_bias)"
msgstr ""

#: ../../library/profile.rst:665
msgid ""
"If you have a choice, you are better off choosing a smaller constant, and"
" then your results will \"less often\" show up as negative in profile "
"statistics."
msgstr "선택해야 한다면, 더 작은 상수를 선택하는 것이 좋습니다, 그러면 결과가 프로파일 통계에서 결과가 \"덜 자주\" 음수로 표시됩니다."

#: ../../library/profile.rst:671
msgid "Using a custom timer"
msgstr "사용자 정의 타이머 사용하기"

#: ../../library/profile.rst:673
msgid ""
"If you want to change how current time is determined (for example, to "
"force use of wall-clock time or elapsed process time), pass the timing "
"function you want to the :class:`Profile` class constructor::"
msgstr ""
"현재 시각을 결정하는 방법을 변경하려면 (예를 들어, 벽시계 시간이나 소요된 프로세스 시간을 사용하도록 만들려면), "
":class:`Profile` 클래스 생성자에게 원하는 타이밍 함수를 전달합니다::"

#: ../../library/profile.rst:677
msgid "pr = profile.Profile(your_time_func)"
msgstr ""

#: ../../library/profile.rst:679
msgid ""
"The resulting profiler will then call ``your_time_func``. Depending on "
"whether you are using :class:`profile.Profile` or "
":class:`cProfile.Profile`, ``your_time_func``'s return value will be "
"interpreted differently:"
msgstr ""
"결과 프로파일러는 ``your_time_func``\\를 호출합니다. :class:`profile.Profile`\\이나 "
":class:`cProfile.Profile` 중 어느 것을 사용하느냐에 따라, ``your_time_func``\\의 반환 값은 "
"다르게 해석됩니다:"

#: ../../library/profile.rst:683
msgid ":class:`profile.Profile`"
msgstr ":class:`profile.Profile`"

#: ../../library/profile.rst:684
msgid ""
"``your_time_func`` should return a single number, or a list of numbers "
"whose sum is the current time (like what :func:`os.times` returns).  If "
"the function returns a single time number, or the list of returned "
"numbers has length 2, then you will get an especially fast version of the"
" dispatch routine."
msgstr ""
"``your_time_func``\\는 단일 숫자를 반환하거나, 또는 (:func:`os.times`\\가 반환하는 것과 같이) "
"합계가 현재 시각인 숫자 리스트를 반환해야 합니다. 함수가 단일 시간 숫자를 반환하거나, 반환된 숫자의 리스트 길이가 2이면, 특히"
" 빠른 버전의 디스패치 루틴을 얻게 됩니다."

#: ../../library/profile.rst:690
#, fuzzy
msgid ""
"Be warned that you should calibrate the profiler class for the timer "
"function that you choose (see :ref:`profile-calibration`).  For most "
"machines, a timer that returns a lone integer value will provide the best"
" results in terms of low overhead during profiling.  (:func:`os.times` is"
" *pretty* bad, as it returns a tuple of floating-point values).  If you "
"want to substitute a better timer in the cleanest fashion, derive a class"
" and hardwire a replacement dispatch method that best handles your timer "
"call, along with the appropriate calibration constant."
msgstr ""
"여러분이 선택한 타이머 함수에 대해 프로파일러 클래스를 보정해야 합니다 (:ref:`profile-calibration`\\을 "
"참조하십시오). 대부분의 기계에서, 단일 정숫값을 반환하는 타이머는 프로파일링 중 낮은 오버헤드 측면에서 최상의 결과를 제공합니다."
" (:func:`os.times`\\는 부동 소수점 값의 튜플을 반환하므로 *꽤* 나쁩니다). 더 좋은 타이머를 가장 깨끗한 "
"방식으로 대체하려면, 클래스를 파생하고 적절한 보정 상수와 함께 타이머 호출을 가장 잘 처리하는 대체 디스패치 메서드를 "
"배선하십시오."

#: ../../library/profile.rst:699
msgid ":class:`cProfile.Profile`"
msgstr ":class:`cProfile.Profile`"

#: ../../library/profile.rst:700
msgid ""
"``your_time_func`` should return a single number.  If it returns "
"integers, you can also invoke the class constructor with a second "
"argument specifying the real duration of one unit of time.  For example, "
"if ``your_integer_time_func`` returns times measured in thousands of "
"seconds, you would construct the :class:`Profile` instance as follows::"
msgstr ""
"``your_time_func``\\는 단일 숫자를 반환해야 합니다. 정수를 반환하면, 시간 단위의 실제 지속 시간을 지정하는 두 "
"번째 인자로 클래스 생성자를 호출할 수도 있습니다. 예를 들어, ``your_integer_time_func``\\가 밀리초 단위로"
" 측정된 시간을 반환하면, 다음과 같이 :class:`Profile` 인스턴스를 구성합니다::"

#: ../../library/profile.rst:706
msgid "pr = cProfile.Profile(your_integer_time_func, 0.001)"
msgstr ""

#: ../../library/profile.rst:708
#, fuzzy
msgid ""
"As the :class:`cProfile.Profile` class cannot be calibrated, custom timer"
" functions should be used with care and should be as fast as possible.  "
"For the best results with a custom timer, it might be necessary to hard-"
"code it in the C source of the internal :mod:`!_lsprof` module."
msgstr ""
":class:`cProfile.Profile` 클래스를 보정할 수 없어서, 사용자 정의 타이머 함수는 주의해서 사용해야 하고 가능한"
" 한 빨라야 합니다. 사용자 정의 타이머로 최상의 결과를 얻으려면, 내부 :mod:`_lsprof` 모듈의 C 소스에 하드 코딩해야"
" 할 수도 있습니다."

#: ../../library/profile.rst:713
msgid ""
"Python 3.3 adds several new functions in :mod:`time` that can be used to "
"make precise measurements of process or wall-clock time. For example, see"
" :func:`time.perf_counter`."
msgstr ""
"파이썬 3.3은 :mod:`time`\\에 프로세스나 벽시계 시간을 정확하게 측정하는 데 사용할 수 있는 몇 가지 새로운 함수를 "
"추가합니다. 예를 들어, :func:`time.perf_counter`\\를 참조하십시오."

#: ../../library/profile.rst:16
#, fuzzy
msgid "deterministic profiling"
msgstr "결정론적 프로파일링이란 무엇입니까?"

#: ../../library/profile.rst:16
msgid "profiling, deterministic"
msgstr ""

