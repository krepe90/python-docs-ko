# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/unittest.mock.rst:2
#, fuzzy
msgid ":mod:`!unittest.mock` --- mock object library"
msgstr ":mod:`unittest.mock` --- 모의 객체 라이브러리"

#: ../../library/unittest.mock.rst:12
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**소스 코드:** :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:16
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to"
" replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock`\\은 파이썬에서 테스트하기 위한 라이브러리입니다. 테스트 대상 시스템의 일부를 모의 객체로 "
"교체하고 그들이 사용된 방식에 대해 어서션(assertion)을 할 수 있습니다."

#: ../../library/unittest.mock.rst:20
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the "
"need to create a host of stubs throughout your test suite. After "
"performing an action, you can make assertions about which methods / "
"attributes were used and arguments they were called with. You can also "
"specify return values and set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock`\\은 핵심 :class:`Mock` 클래스를 제공하여 테스트 스위트 전체에 걸쳐 많은 스텁을 "
"만들 필요가 없도록 합니다. 작업을 수행한 후, 사용된 메서드 / 어트리뷰트와 호출에 제공된 인자에 대한 어서션을 할 수 있습니다."
" 일반적인 방법으로 반환 값을 지정하고 필요한 어트리뷰트를 설정할 수도 있습니다."

#: ../../library/unittest.mock.rst:26
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles "
"patching module and class level attributes within the scope of a test, "
"along with :const:`sentinel` for creating unique objects. See the `quick "
"guide`_ for some examples of how to use :class:`Mock`, :class:`MagicMock`"
" and :func:`patch`."
msgstr ""
"또한, mock은 테스트 스코프 내에서 모듈과 클래스 수준 어트리뷰트의 패치를 처리하는 :func:`patch` 데코레이터를 고유한"
" 객체 생성을 위한 :const:`sentinel`\\과 함께 제공합니다. :class:`Mock`, "
":class:`MagicMock` 및 :func:`patch` 사용 방법에 대한 몇 가지 예는 `간략 지침 <quick "
"guide_>`_\\을 참조하십시오."

#: ../../library/unittest.mock.rst:32
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action"
" -> assertion' pattern instead of 'record -> replay' used by many mocking"
" frameworks."
msgstr ""
"Mock은 :mod:`unittest`\\와 함께 사용하도록 설계되었고 많은 모킹(mocking) 프레임워크에서 사용하는 "
"'기록(record) -> 재생(replay)' 대신 '액션(action) -> 어서션(assertion)' 패턴을 기반으로 "
"합니다."

#: ../../library/unittest.mock.rst:36
#, fuzzy
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of "
"Python, available as :pypi:`mock` on PyPI."
msgstr ""
"이전 버전의 파이썬을 위한 :mod:`unittest.mock`\\의 역 이식이 있습니다, `PyPI의 mock "
"<https://pypi.org/project/mock>`_\\에서 제공됩니다."

#: ../../library/unittest.mock.rst:41
msgid "Quick Guide"
msgstr "간략 지침"

#: ../../library/unittest.mock.rst:59
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. "
"You can configure them, to specify return values or limit what attributes"
" are available, and then make assertions about how they have been used:"
msgstr ""
":class:`Mock`\\과 :class:`MagicMock` 객체는 그것들을 액세스함에 따라 모든 어트리뷰트와 메서드를 작성하고"
" 사용 방식에 대한 세부 사항을 저장합니다. 반환 값을 지정하거나 사용 가능한 어트리뷰트를 제한하도록 구성한 다음, 사용된 방식에 "
"대한 어서션을 만들 수 있습니다:"

#: ../../library/unittest.mock.rst:71
#, fuzzy
msgid ""
":attr:`~Mock.side_effect` allows you to perform side effects, including "
"raising an exception when a mock is called:"
msgstr ""
":attr:`side_effect`\\를 사용하면 모의 객체(mock)가 호출될 때 예외를 발생시키는 것을 포함하여 부작용(side"
" effect)을 수행 할 수 있습니다:"

#: ../../library/unittest.mock.rst:92
msgid ""
"Mock has many other ways you can configure it and control its behaviour. "
"For example the *spec* argument configures the mock to take its "
"specification from another object. Attempting to access attributes or "
"methods on the mock that don't exist on the spec will fail with an "
":exc:`AttributeError`."
msgstr ""
"Mock은 여러 가지 방법으로 구성하고 동작을 제어 할 수 있습니다. 예를 들어 *spec* 인자는 다른 객체에서 사양을 가져오도록"
" 모의 객체를 구성합니다. spec에 존재하지 않는 모의 객체의 어트리뷰트나 메서드에 액세스하려고 시도하면 "
":exc:`AttributeError`\\로 실패합니다."

#: ../../library/unittest.mock.rst:97
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock "
"classes or objects in a module under test. The object you specify will be"
" replaced with a mock (or other object) during the test and restored when"
" the test ends::"
msgstr ""
":func:`patch` 데코레이터 / 컨텍스트 관리자는 테스트 대상 모듈에서 클래스나 객체를 쉽게 모킹할 수 있도록 합니다. "
"지정한 객체는 테스트 중에 모의 객체(또는 다른 객체)로 치환되고 테스트가 끝나면 복원됩니다::"

#: ../../library/unittest.mock.rst:101
msgid ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock.rst:116
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example"
" above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"patch 데코레이터를 중첩할 때 모의 객체는 적용한 순서와 같은 순서로 데코레이트 되는 함수로 전달됩니다 (데코레이터가 적용되는 "
"일반적인 *파이썬* 순서). 이것은 아래에서 위로 감을 뜻하므로, 위의 예에서 ``module.ClassName1``\\에 대한 "
"모의 객체가 먼저 전달됩니다."

#: ../../library/unittest.mock.rst:121
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace "
"where they are looked up. This is normally straightforward, but for a "
"quick guide read :ref:`where to patch <where-to-patch>`."
msgstr ""
":func:`patch`\\를 사용할 때 조회되는 이름 공간에서 객체를 패치하는 것이 중요합니다. 이것은 일반적으로 간단하지만, "
"간략 지침은 :ref:`패치할 곳 <where-to-patch>`\\을 읽으십시오."

#: ../../library/unittest.mock.rst:125
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in "
"a with statement:"
msgstr "데코레이터 :func:`patch`\\는 with 문에서 컨텍스트 관리자로 사용할 수도 있습니다:"

#: ../../library/unittest.mock.rst:135
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when "
"the test ends:"
msgstr ""
"스코프 도중 딕셔너리에 값을 설정하고 테스트가 종료될 때 딕셔너리를 원래 상태로 복원하기 위한 "
":func:`patch.dict`\\도 있습니다:"

#: ../../library/unittest.mock.rst:146
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`."
" The easiest way of using magic methods is with the :class:`MagicMock` "
"class. It allows you to do things like:"
msgstr ""
"Mock은 파이썬 :ref:`매직 메서드 <magic-methods>`\\의 모킹을 지원합니다. 매직 메서드를 사용하는 가장 쉬운 "
"방법은 :class:`MagicMock` 클래스를 사용하는 것입니다. 다음과 같은 것을 할 수 있도록 합니다:"

#: ../../library/unittest.mock.rst:156
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` "
"class is just a Mock variant that has all of the magic methods pre-"
"created for you (well, all the useful ones anyway)."
msgstr ""
"Mock을 사용하면 함수(또는 다른 Mock 인스턴스)를 매직 메서드에 대입할 수 있고 적절하게 호출될 것입니다. "
":class:`MagicMock` 클래스는 모든 매직 메서드(아마도, 모든 유용한 메서드)가 미리 만들어져 있는 Mock 변형일 "
"뿐입니다."

#: ../../library/unittest.mock.rst:161
msgid ""
"The following is an example of using magic methods with the ordinary Mock"
" class:"
msgstr "다음은 평범한 Mock 클래스로 매직 메서드를 사용하는 예입니다:"

#: ../../library/unittest.mock.rst:169
msgid ""
"For ensuring that the mock objects in your tests have the same api as the"
" objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates "
"mock objects that have the same attributes and methods as the objects "
"they are replacing, and any functions and methods (including "
"constructors) have the same call signature as the real object."
msgstr ""
"테스트의 모의 객체가 대체하는 객체와 같은 api를 갖도록, :ref:`자동 사양 <auto-speccing>`\\를 사용할 수 "
"있습니다. 자동 사양은 패치 할 *autospec* 인자를 patch에 전달하거나 :func:`create_autospec` 함수를"
" 통해 수행할 수 있습니다. 자동 사양은 대체하는 객체와 같은 어트리뷰트와 메서드를 갖는 모의 객체를 만들고, 모든 함수와 "
"(생성자를 포함한) 메서드는 실제 객체와 같은 호출 서명을 갖습니다."

#: ../../library/unittest.mock.rst:177
msgid ""
"This ensures that your mocks will fail in the same way as your production"
" code if they are used incorrectly:"
msgstr "이것은 모의 객체가 잘못 사용될 경우 프로덕션 코드와 같은 방식으로 실패하도록 합니다:"

#: ../../library/unittest.mock.rst:193
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec`\\이 클래스에 사용되면 ``__init__`` 메서드의 서명을 복사하고, 콜러블 객체에 "
"사용되면 ``__call__`` 메서드의 서명을 복사합니다."

#: ../../library/unittest.mock.rst:200
msgid "The Mock Class"
msgstr "Mock 클래스"

#: ../../library/unittest.mock.rst:213
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of "
"stubs and test doubles throughout your code. Mocks are callable and "
"create attributes as new mocks when you access them [#]_. Accessing the "
"same attribute will always return the same mock. Mocks record how you use"
" them, allowing you to make assertions about what your code has done to "
"them."
msgstr ""
":class:`Mock`\\은 코드 전체에서 스텁과 테스트 이중화의 사용을 대체하기 위한 유연한 모의 객체입니다. 모의 객체는 "
"콜러블이고 어트리뷰트에 액세스할 때 새 모의 객체로 어트리뷰트를 만듭니다 [#]_. 같은 어트리뷰트에 액세스하면 항상 같은 모의 "
"객체를 반환합니다. 모의 객체는 사용 방법을 기록하여, 코드가 모의 객체에 대해 수행한 작업에 대한 어서션을 만들 수 있도록 "
"합니다."

#: ../../library/unittest.mock.rst:219
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic "
"methods pre-created and ready to use. There are also non-callable "
"variants, useful when you are mocking out objects that aren't callable: "
":class:`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock`\\은 :class:`Mock`\\의 서브 클래스이며, 모든 매직 메서드가 미리 만들어져 사용할 "
"준비가 되어있습니다. 콜러블이 아닌 변형도 있어서, 콜러블이 아닌 객체를 모킹할 때 유용합니다: "
":class:`NonCallableMock`\\과 :class:`NonCallableMagicMock`"

#: ../../library/unittest.mock.rst:224
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes"
" in a particular module with a :class:`Mock` object. By default "
":func:`patch` will create a :class:`MagicMock` for you. You can specify "
"an alternative class of :class:`Mock` using the *new_callable* argument "
"to :func:`patch`."
msgstr ""
":func:`patch` 데코레이터를 사용하면 특정 모듈의 클래스를 :class:`Mock` 객체로 쉽게 대체 할 수 있습니다. "
"기본적으로 :func:`patch`\\는 :class:`MagicMock`\\을 생성합니다. :func:`patch`\\에 "
"*new_callable* 인자를 사용하여 대체 :class:`Mock` 클래스를 지정할 수 있습니다."

#: ../../library/unittest.mock.rst:232
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"새로운 :class:`Mock` 객체를 만듭니다. :class:`Mock`\\은 Mock 객체의 동작을 지정하는 몇 가지 선택적 "
"인자를 취합니다:"

#: ../../library/unittest.mock.rst:235
msgid ""
"*spec*: This can be either a list of strings or an existing object (a "
"class or instance) that acts as the specification for the mock object. If"
" you pass in an object then a list of strings is formed by calling dir on"
" the object (excluding unsupported magic attributes and methods). "
"Accessing any attribute not in this list will raise an "
":exc:`AttributeError`."
msgstr ""
"*spec*: 문자열 리스트이거나 모의 객체의 사양으로 작동하는 기존 객체 (클래스나 인스턴스)일 수 있습니다. 객체를 전달하면 "
"객체에 dir을 호출하여 문자열 리스트가 형성됩니다 (지원되지 않는 매직 어트리뷰트와 메서드는 제외합니다). 이 리스트에 없는 "
"어트리뷰트에 액세스하면 :exc:`AttributeError`\\가 발생합니다."

#: ../../library/unittest.mock.rst:241
#, fuzzy
msgid ""
"If *spec* is an object (rather than a list of strings) then "
":attr:`~object.__class__` returns the class of the spec object. This "
"allows mocks to pass :func:`isinstance` tests."
msgstr ""
"*spec*\\이 (문자열 리스트 대신에) 객체이면, :attr:`~instance.__class__`\\는 spec 객체의 "
"클래스를 반환합니다. 이것은 모의 객체가 :func:`isinstance` 검사를 통과할 수 있도록 합니다."

#: ../../library/unittest.mock.rst:245
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or"
" get an attribute on the mock that isn't on the object passed as "
"*spec_set* will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*: *spec*\\의 더 엄격한 변형. 사용되면, *spec_set*\\으로 전달된 객체에 없는 모의 객체의 "
"어트리뷰트를 *설정*\\하거나 얻으려고 시도하면 :exc:`AttributeError`\\가 발생합니다."

#: ../../library/unittest.mock.rst:249
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See "
"the :attr:`~Mock.side_effect` attribute. Useful for raising exceptions or"
" dynamically changing return values. The function is called with the same"
" arguments as the mock, and unless it returns :data:`DEFAULT`, the return"
" value of this function is used as the return value."
msgstr ""
"*side_effect*: Mock이 호출될 때마다 호출되는 함수. :attr:`~Mock.side_effect` 어트리뷰트를 "
"참조하십시오. 예외를 발생시키거나 반환 값을 동적으로 변경하는 데 유용합니다. 함수는 모의 객체와 같은 인자로 호출되며, "
":data:`DEFAULT`\\를 반환하지 않는 한, 이 함수의 반환 값이 반환 값으로 사용됩니다."

#: ../../library/unittest.mock.rst:255
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In "
"this case the exception will be raised when the mock is called."
msgstr "또는 *side_effect*\\는 예외 클래스나 인스턴스일 수 있습니다. 이 경우 모의 객체가 호출될 때 그 예외가 발생합니다."

#: ../../library/unittest.mock.rst:258
msgid ""
"If *side_effect* is an iterable then each call to the mock will return "
"the next value from the iterable."
msgstr "*side_effect*\\가 이터러블이면 모의 객체에 대한 각 호출은 이터러블의 다음 값을 반환합니다."

#: ../../library/unittest.mock.rst:261
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "*side_effect*\\는 ``None``\\으로 설정하여 지울 수 있습니다."

#: ../../library/unittest.mock.rst:263
msgid ""
"*return_value*: The value returned when the mock is called. By default "
"this is a new Mock (created on first access). See the "
":attr:`return_value` attribute."
msgstr ""
"*return_value*: 모의 객체가 호출될 때 반환되는 값. 기본적으로 이것은 새로운 Mock입니다 (처음 액세스할 때 "
"만들어집니다). :attr:`return_value` 어트리뷰트를 참조하십시오."

#: ../../library/unittest.mock.rst:267
#, fuzzy
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an "
":exc:`AttributeError`. Passing ``unsafe=True`` will allow access to these"
" attributes."
msgstr ""
"*unsafe*: 기본적으로 어트리뷰트가 *assert*\\나 *assret*\\로 시작하면 "
":exc:`AttributeError`\\가 발생합니다. ``unsafe=True``\\를 전달하면 이러한 어트리뷰트에 액세스 할 "
"수 있습니다."

#: ../../library/unittest.mock.rst:274
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` "
"then calling the Mock will pass the call through to the wrapped object "
"(returning the real result). Attribute access on the mock will return a "
"Mock object that wraps the corresponding attribute of the wrapped object "
"(so attempting to access an attribute that doesn't exist will raise an "
":exc:`AttributeError`)."
msgstr ""
"*wraps*: 모의 객체가 감쌀 항목. *wraps*\\가 ``None``\\이 아니면 Mock을 호출할 때 래핑 된 객체로 "
"호출이 전달됩니다 (실제 결과를 반환합니다). 모의 객체에 대한 어트리뷰트 액세스는 래핑 된 객체의 해당 어트리뷰트를 래핑하는 "
"Mock 객체를 반환합니다 (따라서 존재하지 않는 어트리뷰트에 액세스하려고 시도하면 :exc:`AttributeError`\\가 "
"발생합니다)."

#: ../../library/unittest.mock.rst:281
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed "
"to the wrapped object and the *return_value* is returned instead."
msgstr ""
"모의 객체에 명시적으로 *return_value*\\가 설정되면 호출은 래핑 된 객체로 전달되지 않고 대신 "
"*return_value*\\가 반환됩니다."

#: ../../library/unittest.mock.rst:284
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the "
"mock. This can be useful for debugging. The name is propagated to child "
"mocks."
msgstr ""
"*name*: 모의 객체에 이름이 있으면 모의 객체의 repr에 사용됩니다. 디버깅에 유용할 수 있습니다. 이름은 자식 모의 객체로"
" 전파됩니다."

#: ../../library/unittest.mock.rst:288
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the "
":meth:`configure_mock` method for details."
msgstr ""
"임의의 키워드 인자로 모의 객체를 호출할 수도 있습니다. 이것들은 모의 객체가 만들어진 후에 어트리뷰트를 설정하는 데 사용됩니다. "
"자세한 내용은 :meth:`configure_mock` 메서드를 참조하십시오."

#: ../../library/unittest.mock.rst:294
msgid "Assert that the mock was called at least once."
msgstr "모의 객체가 적어도 한 번 호출되었다고 어서트 합니다."

#: ../../library/unittest.mock.rst:305
msgid "Assert that the mock was called exactly once."
msgstr "모의 객체가 정확히 한 번 호출되었다고 어서트 합니다."

#: ../../library/unittest.mock.rst:324
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr "이 메서드는 마지막 호출이 특정 방식으로 이루어졌음을 어서트하는 편리한 방법입니다:"

#: ../../library/unittest.mock.rst:334
#, fuzzy
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr "모의 객체가 정확히 한 번 호출되었고 해당 호출이 지정된 인자로 이루어졌다고 어서트 합니다."

#: ../../library/unittest.mock.rst:349
msgid "assert the mock has been called with the specified arguments."
msgstr "지정된 인자로 모의 객체가 호출되었다고 어서트 합니다."

#: ../../library/unittest.mock.rst:351
msgid ""
"The assert passes if the mock has *ever* been called, unlike "
":meth:`assert_called_with` and :meth:`assert_called_once_with` that only "
"pass if the call is the most recent one, and in the case of "
":meth:`assert_called_once_with` it must also be the only call."
msgstr ""
"호출이 가장 최근 호출일 때만 통과하는 :meth:`assert_called_with`\\와 "
":meth:`assert_called_once_with`, 그리고 :meth:`assert_called_once_with`\\의 "
"경우 유일한 호출이어야 하는 것과 달리 모의 객체가 호출된 적이 *있으면* 어서트가 통과합니다."

#: ../../library/unittest.mock.rst:364
msgid ""
"assert the mock has been called with the specified calls. The "
":attr:`mock_calls` list is checked for the calls."
msgstr "지정된 호출로 모의 객체가 호출되었다고 어서트 합니다. calls에 대해 :attr:`mock_calls` 리스트를 검사합니다."

#: ../../library/unittest.mock.rst:367
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr "*any_order*\\가 거짓이면 호출은 순차적이어야 합니다. 지정된 호출 전후에 추가 호출이 있을 수 있습니다."

#: ../../library/unittest.mock.rst:371
msgid ""
"If *any_order* is true then the calls can be in any order, but they must "
"all appear in :attr:`mock_calls`."
msgstr "*any_order*\\가 참이면 호출 순서는 상관없지만, 모두 :attr:`mock_calls`\\에 나타나야 합니다."

#: ../../library/unittest.mock.rst:386
msgid "Assert the mock was never called."
msgstr "모의 객체가 호출되지 않았다고 어서트 합니다."

#: ../../library/unittest.mock.rst:402
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "reset_mock 메서드는 모의 객체의 모든 호출 어트리뷰트를 재설정합니다:"

#: ../../library/unittest.mock.rst:404
msgid ""
">>> mock = Mock(return_value=None)\n"
">>> mock('hello')\n"
">>> mock.called\n"
"True\n"
">>> mock.reset_mock()\n"
">>> mock.called\n"
"False"
msgstr ""

#: ../../library/unittest.mock.rst:414
msgid ""
"This can be useful where you want to make a series of assertions that "
"reuse the same object."
msgstr ""

#: ../../library/unittest.mock.rst:417
msgid "*return_value* parameter when set to ``True`` resets :attr:`return_value`:"
msgstr ""

#: ../../library/unittest.mock.rst:419
msgid ""
">>> mock = Mock(return_value=5)\n"
">>> mock('hello')\n"
"5\n"
">>> mock.reset_mock(return_value=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:428
msgid "*side_effect* parameter when set to ``True`` resets :attr:`side_effect`:"
msgstr ""

#: ../../library/unittest.mock.rst:430
msgid ""
">>> mock = Mock(side_effect=ValueError)\n"
">>> mock('hello')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError\n"
">>> mock.reset_mock(side_effect=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:441
msgid ""
"Note that :meth:`reset_mock` *doesn't* clear the :attr:`return_value`, "
":attr:`side_effect` or any child attributes you have set using normal "
"assignment by default."
msgstr ""

#: ../../library/unittest.mock.rst:445
msgid "Child mocks are reset as well."
msgstr ""

#: ../../library/unittest.mock.rst:447
#, fuzzy
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr "reset_mock 함수에 두 개의 키워드 전용 인자를 추가했습니다."

#: ../../library/unittest.mock.rst:452
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of "
"strings. Only attributes on the *spec* can be fetched as attributes from "
"the mock."
msgstr ""
"모의 객체에 사양을 추가합니다. *spec*\\은 객체이거나 문자열 리스트일 수 있습니다. *spec*\\의 어트리뷰트 만 모의 "
"객체에서 어트리뷰트로 꺼낼 수 있습니다."

#: ../../library/unittest.mock.rst:456
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr "*spec_set*\\이 참이면 스펙에 있는 어트리뷰트 만 설정할 수 있습니다."

#: ../../library/unittest.mock.rst:461
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent."
" Calls to the attached mock will be recorded in the :attr:`method_calls` "
"and :attr:`mock_calls` attributes of this one."
msgstr ""
"이름과 부모를 치환해서, 이것의 어트리뷰트(attribute)로 모의 객체(mock)를 연결합니다. 연결된 모의 객체에 대한 호출은"
" 이것의 :attr:`method_calls`\\와 :attr:`mock_calls` 어트리뷰트에 기록됩니다."

#: ../../library/unittest.mock.rst:468
msgid "Set attributes on the mock through keyword arguments."
msgstr "키워드 인자를 통해 모의 객체의 어트리뷰트를 설정합니다."

#: ../../library/unittest.mock.rst:470
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method "
"call:"
msgstr ""
"표준 점 표기법과 메서드 호출에서 딕셔너리 언 패킹을 사용해서 자식 모의 객체에 어트리뷰트와 반환 값 및 부작용을 설정할 수 "
"있습니다:"

#: ../../library/unittest.mock.rst:484
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "모의 객체에 대한 생성자 호출에서 같은 것을 할 수 있습니다:"

#: ../../library/unittest.mock.rst:497
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after"
" the mock has been created."
msgstr ":meth:`configure_mock`\\은 모의 객체를 만든 후에 구성을 더 쉽게 할 수 있도록 하기 위해 존재합니다."

#: ../../library/unittest.mock.rst:503
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted "
"attributes for the mock."
msgstr ""
":class:`Mock` 객체는 ``dir(some_mock)``\\의 결과를 유용한 결과로 제한합니다. *spec*\\이 있는 "
"모의 객체에서 이것은 모의 객체에 허용되는 모든 어트리뷰트를 포함합니다."

#: ../../library/unittest.mock.rst:507
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it"
" off."
msgstr "이 필터링이 하는 일과 해제 방법에 대해서는 :data:`FILTER_DIR`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:513
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to"
" override this to customize the way child mocks are made."
msgstr ""
"어트리뷰트와 반환 값에 대한 자식 모의 객체를 만듭니다. 기본적으로 자식 모의 객체는 부모와 같은 형입니다. Mock의 서브 "
"클래스는 자식 모의 객체가 만들어지는 방법을 사용자 정의하기 위해 이를 재정의할 수 있습니다."

#: ../../library/unittest.mock.rst:518
msgid ""
"For non-callable mocks the callable variant will be used (rather than any"
" custom subclass)."
msgstr "콜러블이 아닌 모의 객체의 경우 (사용자 정의 서브 클래스 대신) 콜러블 변형이 사용됩니다."

#: ../../library/unittest.mock.rst:524
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "모의 객체가 호출되었는지를 나타내는 불리언:"

#: ../../library/unittest.mock.rst:535
msgid "An integer telling you how many times the mock object has been called:"
msgstr "모의 객체가 몇 번이나 호출되었는지를 알려주는 정수:"

#: ../../library/unittest.mock.rst:547
msgid "Set this to configure the value returned by calling the mock:"
msgstr "모의 객체를 호출할 때 반환되는 값을 구성하려면 이것을 설정하십시오:"

#: ../../library/unittest.mock.rst:554
msgid ""
"The default return value is a mock object and you can configure it in the"
" normal way:"
msgstr "기본 반환 값은 모의 객체이며 일반적인 방식으로 구성할 수 있습니다:"

#: ../../library/unittest.mock.rst:563
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr "생성자에서 :attr:`return_value`\\를 설정할 수도 있습니다:"

#: ../../library/unittest.mock.rst:574
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr "이것은 모의 객체가 호출될 때 호출되는 함수, 이터러블 또는 발생시킬 예외(클래스나 인스턴스)일 수 있습니다."

#: ../../library/unittest.mock.rst:577
msgid ""
"If you pass in a function it will be called with same arguments as the "
"mock and unless the function returns the :data:`DEFAULT` singleton the "
"call to the mock will then return whatever the function returns. If the "
"function returns :data:`DEFAULT` then the mock will return its normal "
"value (from the :attr:`return_value`)."
msgstr ""
"함수를 전달하면 모의 객체와 같은 인자로 호출되며 함수가 :data:`DEFAULT` 싱글톤을 반환하지 않는 한 모의 객체에 대한 "
"호출은 함수가 반환하는 것을 반환합니다. 함수가 :data:`DEFAULT`\\를 반환하면 모의 객체는 "
"(:attr:`return_value`\\에서) 정상값을 반환합니다."

#: ../../library/unittest.mock.rst:583
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must"
" yield a value on every call.  This value can either be an exception "
"instance to be raised, or a value to be returned from the call to the "
"mock (:data:`DEFAULT` handling is identical to the function case)."
msgstr ""
"이터러블을 전달하면, 모든 호출에서 값을 산출해야 하는 이터레이터를 얻는 데 사용됩니다. 이 값은 발생시킬 예외 인스턴스나 모의 "
"객체 호출에서 반환될 값일 수 있습니다 (:data:`DEFAULT` 처리는 함수 경우와 같습니다)."

#: ../../library/unittest.mock.rst:588
msgid ""
"An example of a mock that raises an exception (to test exception handling"
" of an API):"
msgstr "(API의 예외 처리를 테스트하기 위해) 예외를 발생시키는 모의 객체 예:"

#: ../../library/unittest.mock.rst:598
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr ":attr:`side_effect`\\를 사용하여 일련의 값을 반환하기:"

#: ../../library/unittest.mock.rst:605
msgid "Using a callable:"
msgstr "콜러블 사용하기:"

#: ../../library/unittest.mock.rst:615
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that"
" adds one to the value the mock is called with and returns it:"
msgstr ""
"생성자에서 :attr:`side_effect`\\를 설정할 수 있습니다. 다음은 모의 객체가 호출된 값에 1을 더해서 반환하는 "
"예입니다:"

#: ../../library/unittest.mock.rst:625
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr ":attr:`side_effect`\\를 ``None``\\으로 설정하면 지워집니다:"

#: ../../library/unittest.mock.rst:639
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the "
"arguments that the mock was last called with. This will be in the form of"
" a tuple: the first member, which can also be accessed through the "
"``args`` property, is any ordered arguments the mock was called with (or "
"an empty tuple) and the second member, which can also be accessed through"
" the ``kwargs`` property, is any keyword arguments (or an empty "
"dictionary)."
msgstr ""
"이것은 ``None``\\(모의 객체가 호출되지 않았을 때)이거나 모의 객체가 마지막으로 호출된 인자입니다. 이것은 튜플 "
"형태입니다: ``args`` 프로퍼티를 통해 액세스 할 수도 있는 첫 번째 멤버는 모의 객체를 호출한 순서 있는 인자(또는 빈 "
"튜플)이며 ``kwargs`` 프로퍼티를 통해 액세스 할 수도 있는 두 번째 멤버는 모든 키워드 인자(또는 빈 딕셔너리)입니다."

#: ../../library/unittest.mock.rst:672
msgid ""
":attr:`call_args`, along with members of the lists "
":attr:`call_args_list`, :attr:`method_calls` and :attr:`mock_calls` are "
":data:`call` objects. These are tuples, so they can be unpacked to get at"
" the individual arguments and make more complex assertions. See "
":ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args_list`, :attr:`method_calls` 및 :attr:`mock_calls` 리스트의 "
"멤버와 함께 :attr:`call_args`\\는 :data:`call` 객체입니다. 이들은 튜플이므로, 개별 인자를 얻고 더 "
"복잡한 어서션을 하기 위해 언팩할 수 있습니다. :ref:`call 튜플 <calls-as-tuples>`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:678
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "``args``\\와 ``kwargs`` 프로퍼티를 추가했습니다."

#: ../../library/unittest.mock.rst:684
msgid ""
"This is a list of all the calls made to the mock object in sequence (so "
"the length of the list is the number of times it has been called). Before"
" any calls have been made it is an empty list. The :data:`call` object "
"can be used for conveniently constructing lists of calls to compare with "
":attr:`call_args_list`."
msgstr ""
"이것은 모의 객체에 대한 모든 호출을 순서대로 나열한 리스트입니다 (따라서 리스트의 길이는 호출된 횟수입니다). 호출이 있기 전에는"
" 빈 리스트입니다. :data:`call` 객체는 :attr:`call_args_list`\\와 비교할 호출 리스트를 편리하게 "
"구성하는 데 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:700
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as"
" tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args_list`\\의 멤버는 :data:`call` 객체입니다. 이들은 개별 인자를 얻기 위해 튜플로서 "
"언팩될 수 있습니다. :ref:`call 튜플 <calls-as-tuples>`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:707
msgid ""
"As well as tracking calls to themselves, mocks also track calls to "
"methods and attributes, and *their* methods and attributes:"
msgstr "자신에 대한 호출 추적뿐만 아니라, 모의 객체는 메서드와 어트리뷰트, 그리고 *그들의* 메서드와 어트리뷰트에 대한 호출도 추적합니다:"

#: ../../library/unittest.mock.rst:718
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as"
" tuples <calls-as-tuples>`."
msgstr ""
":attr:`method_calls`\\의 멤버는 :data:`call` 객체입니다. 이들은 개별 인자를 얻기 위해 튜플로서 언팩될"
" 수 있습니다. :ref:`call 튜플 <calls-as-tuples>`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:725
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls`\\는 모의 객체, 그것의 메서드, 매직 메서드 *및* 반환 값 모의 객체에 대한 *모든* 호출을 "
"기록합니다."

#: ../../library/unittest.mock.rst:743
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as"
" tuples <calls-as-tuples>`."
msgstr ""
":attr:`mock_calls`\\의 멤버는 :data:`call` 객체입니다. 이들은 개별 인자를 얻기 위해 튜플로서 언팩될 수"
" 있습니다. :ref:`call 튜플 <calls-as-tuples>`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:749
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are"
" made, the parameters of ancestor calls are not recorded and so will "
"always compare equal:"
msgstr ""
":attr:`mock_calls`\\가 기록되는 방식은 중첩된 호출이 수행될 때 상위 호출의 매개 변수가 기록되지 않아서 항상 "
"같다고 비교됨을 뜻합니다.:"

#: ../../library/unittest.mock.rst:763
#, fuzzy
msgid ""
"Normally the :attr:`!__class__` attribute of an object will return its "
"type. For a mock object with a :attr:`!spec`, :attr:`!__class__` returns "
"the spec class instead. This allows mock objects to pass "
":func:`isinstance` tests for the object they are replacing / masquerading"
" as:"
msgstr ""
"일반적으로 객체의 :attr:`__class__` 어트리뷰트는 해당 형을 반환합니다. :attr:`spec`\\이 있는 모의 객체의"
" 경우, ``__class__``\\는 대신 spec 클래스를 반환합니다. 이를 통해 모의 객체는 다음과 같이 대체 / 가장하는 "
"객체에 대한 :func:`isinstance` 테스트를 통과할 수 있습니다:"

#: ../../library/unittest.mock.rst:772
#, fuzzy
msgid ""
":attr:`!__class__` is assignable to, this allows a mock to pass an "
":func:`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`__class__`\\는 대입할 수 있습니다. 이를 통해 spec을 사용하지 않고도 모의 객체가 "
":func:`isinstance` 검사를 통과할 수 있습니다.:"

#: ../../library/unittest.mock.rst:782
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have "
"the same meaning of :class:`Mock`, with the exception of *return_value* "
"and *side_effect* which have no meaning on a non-callable mock."
msgstr ""
"콜러블이 아닌 :class:`Mock` 버전. 생성자 매개 변수는 :class:`Mock`\\과 같은 의미를 가지며, 콜러블이 아닌"
" 모의 객체에서 의미가 없는 *return_value*\\와 *side_effect*\\는 예외입니다."

#: ../../library/unittest.mock.rst:786
#, fuzzy
msgid ""
"Mock objects that use a class or an instance as a :attr:`!spec` or "
":attr:`!spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"클래스 나 인스턴스를 :attr:`spec`\\이나 :attr:`spec_set`\\으로 사용하는 모의 객체는 "
":func:`isinstance` 테스트를 통과할 수 있습니다:"

#: ../../library/unittest.mock.rst:796
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See "
":ref:`magic methods <magic-methods>` for the full details."
msgstr ""
":class:`Mock` 클래스는 매직 메서드 모킹을 지원합니다. 자세한 내용은 :ref:`매직 메서드 <magic-"
"methods>`\\를 참조하십시오."

#: ../../library/unittest.mock.rst:799
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary "
"keyword arguments for configuration. For the :func:`patch` decorators the"
" keywords are passed to the constructor of the mock being created. The "
"keyword arguments are for configuring attributes of the mock:"
msgstr ""
"모의 객체 클래스와 :func:`patch` 데코레이터는 모두 구성을 위해 임의의 키워드 인자를 취합니다. :func:`patch`"
" 데코레이터의 경우 키워드는 만들어지는 모의 객체의 생성자로 전달됩니다. 키워드 인자는 모의 객체의 어트리뷰트를 구성하기 위한 "
"것입니다.:"

#: ../../library/unittest.mock.rst:810
msgid ""
"The return value and side effect of child mocks can be set in the same "
"way, using dotted notation. As you can't use dotted names directly in a "
"call you have to create a dictionary and unpack it using ``**``:"
msgstr ""
"자식 모의 객체의 반환 값과 부작용은 점 표기법을 사용하여 같은 방식으로 설정할 수 있습니다. 호출에서 점으로 구분된 이름을 직접 "
"사용할 수 없어서 딕셔너리를 만들고 ``**``\\를 사용하여 언팩해야 합니다:"

#: ../../library/unittest.mock.rst:825
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to "
"the mock.  Therefore, it can match the actual call's arguments regardless"
" of whether they were passed positionally or by name::"
msgstr ""
"*spec*\\(또는 *spec_set*)으로 만들어진 콜러블 모의 객체는 호출을 모의 객체와 일치시킬 때 사양 객체의 서명을 "
"검사합니다. 따라서, 위치나 이름으로 전달되었는지와 관계없이 실제 호출의 인자와 일치할 수 있습니다::"

#: ../../library/unittest.mock.rst:830
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""

#: ../../library/unittest.mock.rst:838
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, "
":meth:`~Mock.assert_called_once_with`, :meth:`~Mock.assert_has_calls` and"
" :meth:`~Mock.assert_any_call`.  When :ref:`auto-speccing`, it will also "
"apply to method calls on the mock object."
msgstr ""
"이것은 :meth:`~Mock.assert_called_with`, "
":meth:`~Mock.assert_called_once_with`, :meth:`~Mock.assert_has_calls` 및 "
":meth:`~Mock.assert_any_call`\\에 적용됩니다. :ref:`auto-speccing`\\할 때, 모의 객체의"
" 메서드 호출에도 적용됩니다."

#: ../../library/unittest.mock.rst:843
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr "spec 되거나 자동 사양된 모의 객체에 대한 서명 검사를 추가했습니다."

#: ../../library/unittest.mock.rst:849
#, fuzzy
msgid ""
"A mock intended to be used as a :class:`property`, or other "
":term:`descriptor`, on a class. :class:`PropertyMock` provides "
":meth:`~object.__get__` and :meth:`~object.__set__` methods so you can "
"specify a return value when it is fetched."
msgstr ""
"클래스에서 프로퍼티나 다른 디스크립터로 사용하기 위한 모의 객체. :class:`PropertyMock`\\은 "
":meth:`__get__`\\과 :meth:`__set__` 메서드를 제공하므로 꺼낼 때 반환 값을 지정할 수 있습니다."

#: ../../library/unittest.mock.rst:854
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"객체에서 :class:`PropertyMock` 인스턴스를 가져오면 인자 없이 모의 객체를 호출합니다. 설정하면 설정되는 값으로 "
"모의 객체를 호출합니다. ::"

#: ../../library/unittest.mock.rst:857
msgid ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as "
"mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"
msgstr ""

#: ../../library/unittest.mock.rst:875
msgid ""
"Because of the way mock attributes are stored you can't directly attach a"
" :class:`PropertyMock` to a mock object. Instead you can attach it to the"
" mock type object::"
msgstr ""
"모의 객체 어트리뷰트가 저장되는 방식으로 인해 :class:`PropertyMock`\\을 모의 객체에 직접 연결할 수 없습니다. "
"대신 모의 객체의 형 객체에 연결할 수 있습니다::"

#: ../../library/unittest.mock.rst:879
msgid ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"
msgstr ""

#: ../../library/unittest.mock.rst:888
msgid ""
"If an :exc:`AttributeError` is raised by :class:`PropertyMock`, it will "
"be interpreted as a missing descriptor and :meth:`~object.__getattr__` "
"will be called on the parent mock::"
msgstr ""

#: ../../library/unittest.mock.rst:892
msgid ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"
msgstr ""

#: ../../library/unittest.mock.rst:898
msgid "See :meth:`~object.__getattr__` for details."
msgstr ""

#: ../../library/unittest.mock.rst:903
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` "
"object will behave so the object is recognized as an async function, and "
"the result of a call is an awaitable."
msgstr ""
":class:`MagicMock`\\의 비동기 버전. :class:`AsyncMock` 객체는 객체가 비동기 함수로 인식되도록 "
"동작하고, 호출 결과는 어웨이터블 입니다."

#: ../../library/unittest.mock.rst:913
msgid ""
"The result of ``mock()`` is an async function which will have the outcome"
" of ``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"``mock()``\\의 결과는 어웨이트 한 후 ``side_effect``\\나 ``return_value``\\를 제공하는 "
"비동기 함수입니다:"

#: ../../library/unittest.mock.rst:916
msgid ""
"if ``side_effect`` is a function, the async function will return the "
"result of that function,"
msgstr "``side_effect``\\가 함수이면, 비동기 함수는 해당 함수의 결과를 반환합니다,"

#: ../../library/unittest.mock.rst:918
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr "``side_effect``\\가 예외이면, 비동기 함수는 예외를 발생시킵니다,"

#: ../../library/unittest.mock.rst:920
msgid ""
"if ``side_effect`` is an iterable, the async function will return the "
"next value of the iterable, however, if the sequence of result is "
"exhausted, ``StopAsyncIteration`` is raised immediately,"
msgstr ""
"``side_effect``\\가 이터러블이면, 비동기 함수는 이터러블의 다음 값을 반환하지만, 결과 시퀀스가 소진되면 "
"``StopAsyncIteration``\\이 즉시 발생합니다,"

#: ../../library/unittest.mock.rst:923
msgid ""
"if ``side_effect`` is not defined, the async function will return the "
"value defined by ``return_value``, hence, by default, the async function "
"returns a new :class:`AsyncMock` object."
msgstr ""
"``side_effect``\\가 정의되지 않으면, 비동기 함수는 ``return_value``\\에 의해 정의된 값을 반환하므로,"
" 기본적으로 비동기 함수는 새 :class:`AsyncMock` 객체를 반환합니다."

#: ../../library/unittest.mock.rst:928
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""
":class:`Mock`\\이나 :class:`MagicMock`\\의 *spec*\\을 비동기 함수로 설정하면 호출 후에 코루틴 "
"객체가 반환됩니다."

#: ../../library/unittest.mock.rst:940
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or "
":class:`AsyncMock` to a class with asynchronous and synchronous functions"
" will automatically detect the synchronous functions and set them as "
":class:`MagicMock` (if the parent mock is :class:`AsyncMock` or "
":class:`MagicMock`) or :class:`Mock` (if the parent mock is "
":class:`Mock`). All asynchronous functions will be :class:`AsyncMock`."
msgstr ""
":class:`Mock`, :class:`MagicMock` 또는 :class:`AsyncMock`\\의 *spec*\\을 비동기와"
" 동기 함수가 있는 클래스로 설정하면 동기 함수를 자동으로 감지하고 그들을 :class:`MagicMock`\\(부모 모의 객체가 "
":class:`AsyncMock`\\이나 :class:`MagicMock`\\일 때)이나 :class:`Mock`\\(부모 모의 "
"객체가 :class:`Mock`\\일 때)으로 설정합니다. 모든 비동기 함수는 :class:`AsyncMock`\\이 됩니다."

#: ../../library/unittest.mock.rst:968
msgid ""
"Assert that the mock was awaited at least once. Note that this is "
"separate from the object having been called, the ``await`` keyword must "
"be used:"
msgstr ""
"모의 객체가 적어도 한 번 어웨이트 되었다고 어서트 합니다. 이것은 호출된 객체와 별개임에 유의하십시오, ``await`` 키워드를"
" 반드시 사용해야 합니다:"

#: ../../library/unittest.mock.rst:987
msgid "Assert that the mock was awaited exactly once."
msgstr "모의 객체가 정확히 한 번 어웨이트 되었다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1003
msgid "Assert that the last await was with the specified arguments."
msgstr "마지막 어웨이트가 지정된 인자로 이루어졌다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1020
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr "모의 객체가 정확히 한 번, 지정된 인자로 어웨이트 되었다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1037
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "지정된 인자로 모의 객체가 어웨이트된 적이 있다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1053
msgid ""
"Assert the mock has been awaited with the specified calls. The "
":attr:`await_args_list` list is checked for the awaits."
msgstr ""
"지정된 호출로 모의 객체가 어웨이트 되었다고 어서트 합니다. 어웨이트에 대해 :attr:`await_args_list` 리스트가 "
"검사됩니다."

#: ../../library/unittest.mock.rst:1056
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr "*any_order*\\가 거짓이면 어웨이트는 순차적이어야 합니다. 지정된 어웨이트 전이나 후에 추가 호출이 있을 수 있습니다."

#: ../../library/unittest.mock.rst:1060
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must"
" all appear in :attr:`await_args_list`."
msgstr "*any_order*\\가 참이면 어웨이트 순서와 관계없이 모두 :attr:`await_args_list`\\에 나타나야 합니다."

#: ../../library/unittest.mock.rst:1080
msgid "Assert that the mock was never awaited."
msgstr "모의 객체가 어웨이트 된 적이 없다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1087
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, "
":attr:`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
":func:`Mock.reset_mock`\\을 참조하십시오. 또한 :attr:`await_count`\\를 0으로, "
":attr:`await_args`\\를 None으로 설정하고, :attr:`await_args_list`\\를 지웁니다."

#: ../../library/unittest.mock.rst:1092
msgid ""
"An integer keeping track of how many times the mock object has been "
"awaited."
msgstr "모의 객체가 몇 번 어웨이트 되었는지 추적하는 정수."

#: ../../library/unittest.mock.rst:1107
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the "
"arguments that the mock was last awaited with. Functions the same as "
":attr:`Mock.call_args`."
msgstr ""
"이것은 ``None``\\(모의 객체가 어웨이트 되지 않았을 때)이거나 모의 객체가 마지막으로 어웨이트 된 인자입니다. "
":attr:`Mock.call_args`\\와 같게 기능합니다."

#: ../../library/unittest.mock.rst:1125
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so "
"the length of the list is the number of times it has been awaited). "
"Before any awaits have been made it is an empty list."
msgstr ""
"이것은 모의 객체에 대한 모든 어웨이트를 순서대로 나열한 리스트입니다 (따라서 리스트의 길이는 어웨이트 한 횟수입니다). 어웨이트 "
"전에는 빈 리스트입니다."

#: ../../library/unittest.mock.rst:1145
msgid ""
"A version of :class:`MagicMock` for multithreading tests. The "
":class:`ThreadingMock` object provides extra methods to wait for a call "
"to be invoked, rather than assert on it immediately."
msgstr ""

#: ../../library/unittest.mock.rst:1149
msgid ""
"The default timeout is specified by the ``timeout`` argument, or if unset"
" by the :attr:`ThreadingMock.DEFAULT_TIMEOUT` attribute, which defaults "
"to blocking (``None``)."
msgstr ""

#: ../../library/unittest.mock.rst:1152
msgid ""
"You can configure the global default timeout by setting "
":attr:`ThreadingMock.DEFAULT_TIMEOUT`."
msgstr ""

#: ../../library/unittest.mock.rst:1156
#, fuzzy
msgid "Waits until the mock is called."
msgstr "모의 객체가 호출되지 않았다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1158
msgid ""
"If a timeout was passed at the creation of the mock or if a timeout "
"argument is passed to this function, the function raises an "
":exc:`AssertionError` if the call is not performed in time."
msgstr ""

#: ../../library/unittest.mock.rst:1170
#, fuzzy
msgid "Waits until the mock is called with the specified arguments."
msgstr "지정된 인자로 모의 객체가 호출되었다고 어서트 합니다."

#: ../../library/unittest.mock.rst:1172
msgid ""
"If a timeout was passed at the creation of the mock the function raises "
"an :exc:`AssertionError` if the call is not performed in time."
msgstr ""

#: ../../library/unittest.mock.rst:1183
msgid ""
"Global default timeout in seconds to create instances of "
":class:`ThreadingMock`."
msgstr ""

#: ../../library/unittest.mock.rst:1189
msgid "Calling"
msgstr "호출"

#: ../../library/unittest.mock.rst:1191
msgid ""
"Mock objects are callable. The call will return the value set as the "
":attr:`~Mock.return_value` attribute. The default return value is a new "
"Mock object; it is created the first time the return value is accessed "
"(either explicitly or by calling the Mock) - but it is stored and the "
"same one returned each time."
msgstr ""
"모의 객체는 콜러블입니다. 호출은 :attr:`~Mock.return_value` 어트리뷰트로 설정된 값을 반환합니다. 기본 반환 "
"값은 새로운 Mock 객체입니다; (명시적으로나 Mock을 호출하여) 반환 값에 처음으로 액세스할 때 만들어지지만 - 저장되고 매번"
" 같은 값이 반환됩니다."

#: ../../library/unittest.mock.rst:1197
msgid ""
"Calls made to the object will be recorded in the attributes like "
":attr:`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"객체에 대한 호출은 :attr:`~Mock.call_args`\\와 :attr:`~Mock.call_args_list` 같은 "
"어트리뷰트로 기록됩니다."

#: ../../library/unittest.mock.rst:1200
#, fuzzy
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call"
" has been recorded, so if :attr:`!side_effect` raises an exception the "
"call is still recorded."
msgstr ""
":attr:`~Mock.side_effect`\\가 설정되면 호출이 기록된 후에 호출되므로, "
":attr:`side_effect`\\에서 예외가 발생해도 호출은 여전히 기록됩니다."

#: ../../library/unittest.mock.rst:1204
msgid ""
"The simplest way to make a mock raise an exception when called is to make"
" :attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"호출될 때 모의 객체가 예외를 발생시키는 가장 간단한 방법은 :attr:`~Mock.side_effect`\\를 예외 클래스나 "
"인스턴스로 만드는 것입니다:"

#: ../../library/unittest.mock.rst:1222
#, fuzzy
msgid ""
"If :attr:`~Mock.side_effect` is a function then whatever that function "
"returns is what calls to the mock return. The :attr:`!side_effect` "
"function is called with the same arguments as the mock. This allows you "
"to vary the return value of the call dynamically, based on the input:"
msgstr ""
":attr:`side_effect`\\가 함수면 해당 함수가 반환하는 것이 모의 객체에 대한 호출이 반환하는 것입니다. "
":attr:`side_effect` 함수는 모의 객체와 같은 인자로 호출됩니다. 이를 통해 입력에 따라 호출의 반환 값을 동적으로 "
"변경할 수 있습니다:"

#: ../../library/unittest.mock.rst:1238
#, fuzzy
msgid ""
"If you want the mock to still return the default return value (a new "
"mock), or any set return value, then there are two ways of doing this. "
"Either return :attr:`~Mock.return_value` from inside "
":attr:`~Mock.side_effect`, or return :data:`DEFAULT`:"
msgstr ""
"모의 객체가 여전히 기본 반환 값(새로운 모의 객체)을, 또는 설정된 반환 값을, 반환하도록 하려면 두 가지 방법이 있습니다. "
":attr:`side_effect` 내부에서 :attr:`mock.return_value`\\를 반환하거나 "
":data:`DEFAULT`\\를 반환하십시오:"

#: ../../library/unittest.mock.rst:1257
#, fuzzy
msgid ""
"To remove a :attr:`~Mock.side_effect`, and return to the default "
"behaviour, set the :attr:`!side_effect` to ``None``:"
msgstr ""
":attr:`side_effect`\\를 제거하고 기본 동작으로 돌아가려면, :attr:`side_effect`\\를 "
"``None``\\으로 설정하십시오:"

#: ../../library/unittest.mock.rst:1271
#, fuzzy
msgid ""
"The :attr:`~Mock.side_effect` can also be any iterable object. Repeated "
"calls to the mock will return values from the iterable (until the "
"iterable is exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`side_effect`\\는 이터러블 객체일 수도 있습니다. 모의 객체에 대한 반복 호출은 이터러블에서 값을 반환합니다"
" (이터러블이 소진되고 :exc:`StopIteration`\\이 발생할 때까지):"

#: ../../library/unittest.mock.rst:1287
msgid ""
"If any members of the iterable are exceptions they will be raised instead"
" of returned::"
msgstr "이터러블의 멤버가 예외이면 반환되는 대신 예외를 발생시킵니다::"

#: ../../library/unittest.mock.rst:1290
msgid ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"
msgstr ""

#: ../../library/unittest.mock.rst:1305
msgid "Deleting Attributes"
msgstr "어트리뷰트 삭제"

#: ../../library/unittest.mock.rst:1307
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to "
"be objects of any type."
msgstr "모의 객체는 요청 시 어트리뷰트를 만듭니다. 이를 통해 모든 형의 객체인 것처럼 가장할 수 있습니다."

#: ../../library/unittest.mock.rst:1310
#, fuzzy
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call,"
" or raise an :exc:`AttributeError` when an attribute is fetched. You can "
"do this by providing an object as a :attr:`!spec` for a mock, but that "
"isn't always convenient."
msgstr ""
"모의 객체가 :func:`hasattr` 호출에 대해 ``False``\\를 반환하거나, 어트리뷰트를 가져올 때 "
":exc:`AttributeError`\\를 발생시키길 원할 수 있습니다. 모의 객체에 :attr:`spec`\\으로 객체를 "
"제공하여 그렇게 할 수 있지만, 항상 편리하지는 않습니다."

#: ../../library/unittest.mock.rst:1314
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"어트리뷰트를 삭제하여 어트리뷰트를 \"차단\"합니다. 일단 삭제되면, 어트리뷰트에 액세스할 때 "
":exc:`AttributeError`\\가 발생합니다."

#: ../../library/unittest.mock.rst:1331
msgid "Mock names and the name attribute"
msgstr "모의 객체 이름과 이름 어트리뷰트"

#: ../../library/unittest.mock.rst:1333
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you "
"want your mock object to have a \"name\" attribute you can't just pass it"
" in at creation time. There are two alternatives. One option is to use "
":meth:`~Mock.configure_mock`::"
msgstr ""
"\"name\"은 :class:`Mock` 생성자에 대한 인자이므로, 모의 객체가 \"name\" 어트리뷰트를 가지려면 생성 시 "
"전달할 수 없습니다. 두 가지 대안이 있습니다. 한가지 옵션은 :meth:`~Mock.configure_mock`\\을 사용하는 "
"것입니다::"

#: ../../library/unittest.mock.rst:1338
msgid ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"
msgstr ""

#: ../../library/unittest.mock.rst:1343
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr "더 간단한 옵션은 모의 객체를 만든 후 단순히 \"name\" 어트리뷰트를 설정하는 것입니다::"

#: ../../library/unittest.mock.rst:1345
msgid ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""
msgstr ""

#: ../../library/unittest.mock.rst:1350
msgid "Attaching Mocks as Attributes"
msgstr "모의 객체를 어트리뷰트로 연결하기"

#: ../../library/unittest.mock.rst:1352
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are "
"recorded in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` "
"attributes of the parent. This is useful for configuring child mocks and "
"then attaching them to the parent, or for attaching mocks to a parent "
"that records all calls to the children and allows you to make assertions "
"about the order of calls between mocks:"
msgstr ""
"모의 객체를 다른 모의 객체의 어트리뷰트로 (또는 반환 값으로) 연결하면 그 모의 객체의 \"자식\"이 됩니다. 자식에 대한 호출은"
" 부모의 :attr:`~Mock.method_calls`\\와 :attr:`~Mock.mock_calls` 어트리뷰트에 기록됩니다."
" 이는 자식 모의 객체를 구성한 다음 부모에 연결하는 데 유용합니다. 또는 자식들에 대한 모든 호출을 기록하는 부모에 여러 모의 "
"객체를 연결하고 모의 객체 간의 호출 순서에 대한 어서션을 하는 데 유용합니다:"

#: ../../library/unittest.mock.rst:1370
msgid ""
"The exception to this is if the mock has a name. This allows you to "
"prevent the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"이에 대한 예외는 모의 객체에 이름이 있는 경우입니다. 어떤 이유로든 원하지 않을 때 \"부모가 되는 것(parenting)\"을 "
"방지 할 수 있습니다."

#: ../../library/unittest.mock.rst:1381
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the "
":meth:`~Mock.attach_mock` method::"
msgstr ""
":func:`patch`\\가 만든 모의 객체에는 자동으로 이름이 지정됩니다. 부모에게 이름을 가진 모의 객체를 연결하려면 "
":meth:`~Mock.attach_mock` 메서드를 사용하십시오::"

#: ../../library/unittest.mock.rst:1385
msgid ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"
msgstr ""

#: ../../library/unittest.mock.rst:1399
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to "
"get a new Mock object when it expects a magic method. If you need magic "
"method support see :ref:`magic methods <magic-methods>`."
msgstr ""
"유일한 예외는 매직 메서드와 어트리뷰트(앞뒤에 이중 밑줄을 가진 것)입니다. Mock은 이것을 만들지 않고 대신 "
":exc:`AttributeError`\\를 발생시킵니다. 이는 인터프리터가 종종 묵시적으로 이러한 메서드를 요청하고, 매직 "
"메서드를 기대할 때 새 Mock 객체를 얻으면 *매우* 혼동되기 때문입니다. 매직 메서드 지원이 필요하면 :ref:`매직 메서드 "
"<magic-methods>`\\를 참조하십시오."

#: ../../library/unittest.mock.rst:1408
msgid "The patchers"
msgstr "패처"

#: ../../library/unittest.mock.rst:1410
msgid ""
"The patch decorators are used for patching objects only within the scope "
"of the function they decorate. They automatically handle the unpatching "
"for you, even if exceptions are raised. All of these functions can also "
"be used in with statements or as class decorators."
msgstr ""
"patch 데코레이터는 데코레이트 하는 함수의 스코프 내에서만 객체를 패치하는 데 사용됩니다. 예외가 발생하더라도 자동으로 패치 "
"해제를 처리합니다. 이러한 함수는 모두 with 문에서 사용될 수 있고, 클래스 데코레이터로도 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:1417
msgid "patch"
msgstr "patch"

#: ../../library/unittest.mock.rst:1421
msgid ""
"The key is to do the patching in the right namespace. See the section "
"`where to patch`_."
msgstr "중요한 것은 올바른 이름 공간에서 패치를 수행하는 것입니다. `패치할 곳 <where to patch_>`_ 절을 참조하십시오."

#: ../../library/unittest.mock.rst:1425
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* "
"is patched with a *new* object. When the function/with statement exits "
"the patch is undone."
msgstr ""
":func:`patch`\\는 함수 데코레이터, 클래스 데코레이터 또는 컨텍스트 관리자 역할을 합니다. 함수 본문이나 with 문 "
"내부에서, *target*\\은 *new* 객체로 패치됩니다. 함수/with 문이 종료될 때 패치가 복구됩니다."

#: ../../library/unittest.mock.rst:1430
msgid ""
"If *new* is omitted, then the target is replaced with an "
":class:`AsyncMock` if the patched object is an async function or a "
":class:`MagicMock` otherwise. If :func:`patch` is used as a decorator and"
" *new* is omitted, the created mock is passed in as an extra argument to "
"the decorated function. If :func:`patch` is used as a context manager the"
" created mock is returned by the context manager."
msgstr ""
"*new*\\가 생략되면, 대상(target)은 패치된 객체가 비동기 함수이면 :class:`AsyncMock`\\으로, 그렇지 "
"않으면 :class:`MagicMock`\\으로 치환됩니다. :func:`patch`\\가 데코레이터로 사용되고 *new*\\가 "
"생략되면, 만들어진 모의 객체는 데코레이트 되는 함수에 대한 추가 인자로 전달됩니다. :func:`patch`\\가 컨텍스트 "
"관리자로 사용되면 만들어진 모의 객체는 컨텍스트 관리자에 의해 반환됩니다."

#: ../../library/unittest.mock.rst:1438
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. "
"The *target* is imported and the specified object replaced with the *new*"
" object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target*\\은 ``'package.module.ClassName'`` 형식의 문자열이어야 합니다. *target*\\이 "
"임포트되고 지정된 객체를 *new* 객체로 치환하므로, :func:`patch`\\를 호출하는 환경에서 *target*\\을 임포트"
" 할 수 있어야 합니다. 데코레이트 하는 시간이 아니라 데코레이트 된 함수가 실행될 때 대상(target)을 임포트 합니다."

#: ../../library/unittest.mock.rst:1444
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the "
":class:`MagicMock` if patch is creating one for you."
msgstr ""
"patch가 여러분을 위해 만든다면 *spec*\\과 *spec_set* 키워드 인자는 :class:`MagicMock`\\으로 "
"전달됩니다."

#: ../../library/unittest.mock.rst:1447
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes"
" patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"또한 ``spec=True``\\나 ``spec_set=True``\\를 전달하면, patch는 모킹되는 객체를 "
"spec/spec_set 객체로 전달합니다."

#: ../../library/unittest.mock.rst:1450
msgid ""
"*new_callable* allows you to specify a different class, or callable "
"object, that will be called to create the *new* object. By default "
":class:`AsyncMock` is used for async functions and :class:`MagicMock` for"
" the rest."
msgstr ""
"*new_callable*\\을 사용하면 *new* 객체를 만들기 위해 호출될 다른 클래스나 콜러블 객체를 지정할 수 있습니다. "
"기본적으로 :class:`AsyncMock`\\이 비동기 함수에 사용되고 :class:`MagicMock`\\이 나머지에 "
"사용됩니다."

#: ../../library/unittest.mock.rst:1454
msgid ""
"A more powerful form of *spec* is *autospec*. If you set "
"``autospec=True`` then the mock will be created with a spec from the "
"object being replaced. All attributes of the mock will also have the spec"
" of the corresponding attribute of the object being replaced. Methods and"
" functions being mocked will have their arguments checked and will raise "
"a :exc:`TypeError` if they are called with the wrong signature. For mocks"
" replacing a class, their return value (the 'instance') will have the "
"same spec as the class. See the :func:`create_autospec` function and :ref"
":`auto-speccing`."
msgstr ""
"*spec*\\의 더 강력한 형태는 *autospec*\\입니다. ``autospec=True``\\를 설정하면 치환될 객체의 "
"사양으로 모의 객체가 만들어집니다. 모의 객체의 모든 어트리뷰트는 또한 치환되는 객체의 해당 어트리뷰트의 사양을 갖습니다. 모킹되는"
" 메서드와 함수는 인자를 검사하고 잘못된 서명으로 호출되면 :exc:`TypeError`\\를 발생시킵니다. 클래스를 치환하는 모의"
" 객체의 경우, 반환 값('인스턴스')은 클래스와 같은 사양을 갖습니다. :func:`create_autospec` 함수와 :ref"
":`auto-speccing`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:1464
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use"
" an arbitrary object as the spec instead of the one being replaced."
msgstr ""
"``autospec=True`` 대신 ``autospec=some_object``\\를 전달하여 치환되는 것 대신 임의의 객체를 "
"사양으로 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:1467
msgid ""
"By default :func:`patch` will fail to replace attributes that don't "
"exist. If you pass in ``create=True``, and the attribute doesn't exist, "
"patch will create the attribute for you when the patched function is "
"called, and delete it again after the patched function has exited. This "
"is useful for writing tests against attributes that your production code "
"creates at runtime. It is off by default because it can be dangerous. "
"With it switched on you can write passing tests against APIs that don't "
"actually exist!"
msgstr ""
"기본적으로 :func:`patch`\\는 존재하지 않는 어트리뷰트를 치환하지 못합니다. ``create=True``\\를 전달하고,"
" 어트리뷰트가 존재하지 않으면, 패치된 함수가 호출될 때 patch가 어트리뷰트를 만들고 패치된 함수가 종료된 후 다시 삭제합니다."
" 이는 프로덕션 코드가 실행 시간에 만드는 어트리뷰트에 대해 테스트를 작성하는 데 유용합니다. 위험할 수 있어서 기본적으로 "
"꺼져있습니다. 이 기능을 켜면 실제로 존재하지 않는 API에 대해 통과하는 테스트를 작성할 수 있습니다!"

#: ../../library/unittest.mock.rst:1477
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr "모듈에 있는 내장(builtins)을 패치하는 경우 ``create=True``\\를 전달할 필요가 없습니다, 기본적으로 추가됩니다."

#: ../../library/unittest.mock.rst:1481
#, fuzzy
msgid ""
"Patch can be used as a :class:`~unittest.TestCase` class decorator. It "
"works by decorating each test method in the class. This reduces the "
"boilerplate code when your test methods share a common patchings set. "
":func:`patch` finds tests by looking for method names that start with "
"``patch.TEST_PREFIX``. By default this is ``'test'``, which matches the "
"way :mod:`unittest` finds tests. You can specify an alternative prefix by"
" setting ``patch.TEST_PREFIX``."
msgstr ""
"패치는 :class:`TestCase` 클래스 데코레이터로 사용할 수 있습니다. 클래스의 각 테스트 메서드를 데코레이트 하여 "
"작동합니다. 테스트 메서드가 공통 패치 집합을 공유할 때 관리용 코드가 줄어듭니다. :func:`patch`\\는 "
"``patch.TEST_PREFIX``\\로 시작하는 메서드 이름을 조회하는 것으로 테스트를 찾습니다. 기본적으로 이것은 "
"``'test'``\\인데, :mod:`unittest`\\가 테스트를 찾는 방식과 일치합니다. "
"``patch.TEST_PREFIX``\\를 설정하여 대체 접두사를 지정할 수 있습니다."

#: ../../library/unittest.mock.rst:1488
msgid ""
"Patch can be used as a context manager, with the with statement. Here the"
" patching applies to the indented block after the with statement. If you "
"use \"as\" then the patched object will be bound to the name after the "
"\"as\"; very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"with 문에서 patch를 컨텍스트 관리자로 사용할 수 있습니다. 여기서 패치는 with 문 다음에 들여쓰기 된 블록에 "
"적용됩니다. \"as\"를 사용하면 패치된 객체는 \"as\" 뒤에 오는 이름으로 연결됩니다; :func:`patch`\\가 모의 "
"객체를 만들 때 매우 유용합니다."

#: ../../library/unittest.mock.rst:1493
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to "
":class:`AsyncMock` if the patched object is asynchronous, to "
":class:`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch`\\는 임의의 키워드 인자를 취합니다. 이들은 만들어질 때 패치되는 객체가 비동기이면 "
":class:`AsyncMock`\\으로, 그렇지 않으면 :class:`Mock`\\으로, 또는 지정되면 "
"*new_callable*\\로 전달됩니다."

#: ../../library/unittest.mock.rst:1497
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` "
"are available for alternate use-cases."
msgstr ""
"``patch.dict(...)``, ``patch.multiple(...)`` 및 ``patch.object(...)``\\는 "
"대체 사용 사례에 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:1500
msgid ""
":func:`patch` as function decorator, creating the mock for you and "
"passing it into the decorated function::"
msgstr ":func:`patch`\\를 함수 데코레이터로 사용하여, 모의 객체를 만들고 데코레이트 된 함수에 전달합니다::"

#: ../../library/unittest.mock.rst:1503
msgid ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"
msgstr ""

#: ../../library/unittest.mock.rst:1510
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*."
" If the class is instantiated in the code under test then it will be the "
":attr:`~Mock.return_value` of the mock that will be used."
msgstr ""
"클래스를 패치하면 클래스를 :class:`MagicMock` *인스턴스*\\로 치환합니다. 테스트 대상 코드에서 클래스가 인스턴스 "
"화 되면 사용될 모의 객체의 :attr:`~Mock.return_value`\\가 됩니다."

#: ../../library/unittest.mock.rst:1514
msgid ""
"If the class is instantiated multiple times you could use "
":attr:`~Mock.side_effect` to return a new mock each time. Alternatively "
"you can set the *return_value* to be anything you want."
msgstr ""
"클래스가 여러 번 인스턴스 화 되면 :attr:`~Mock.side_effect`\\를 사용하여 매번 새 모의 객체를 반환할 수 "
"있습니다. 또는 *return_value*\\를 원하는 것으로 설정할 수 있습니다."

#: ../../library/unittest.mock.rst:1518
#, fuzzy
msgid ""
"To configure return values on methods of *instances* on the patched class"
" you must do this on the :attr:`~Mock.return_value`. For example::"
msgstr ""
"패치된 클래스에서 *인스턴스*\\의 메서드에 대한 반환 값을 구성하려면 :attr:`return_value`\\에서 이를 수행해야 "
"합니다. 예를 들면::"

#: ../../library/unittest.mock.rst:1521
msgid ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:1532
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*,"
" then the return value of the created mock will have the same spec. ::"
msgstr ""
"*spec*\\이나 *spec_set*\\을 사용하고 :func:`patch`\\가 *클래스*\\를 대체하고 있다면, 만들어진 모의"
" 객체의 반환 값은 같은 사양을 갖습니다. ::"

#: ../../library/unittest.mock.rst:1535
msgid ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"
msgstr ""

#: ../../library/unittest.mock.rst:1542
msgid ""
"The *new_callable* argument is useful where you want to use an "
"alternative class to the default :class:`MagicMock` for the created mock."
" For example, if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"*new_callable* 인자는 생성된 모의 객체의 기본 :class:`MagicMock`\\에 대한 대체 클래스를 사용하려고 할"
" 때 유용합니다. 예를 들어, :class:`NonCallableMock`\\을 사용하려면::"

#: ../../library/unittest.mock.rst:1546
msgid ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as "
"mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"
msgstr ""

#: ../../library/unittest.mock.rst:1555
msgid ""
"Another use case might be to replace an object with an "
":class:`io.StringIO` instance::"
msgstr "또 다른 사용 사례는 객체를 :class:`io.StringIO` 인스턴스로 교체하는 것입니다::"

#: ../../library/unittest.mock.rst:1557
msgid ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock.rst:1568
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the "
"first thing you need to do is to configure the mock. Some of that "
"configuration can be done in the call to patch. Any arbitrary keywords "
"you pass into the call will be used to set attributes on the created "
"mock::"
msgstr ""
":func:`patch`\\가 여러분 대신 모의 객체를 만들 때, 보통 가장 먼저 해야 할 일은 모의 객체를 구성하는 것입니다. 이"
" 구성 중 일부는 patch 호출에서 수행 할 수 있습니다. 호출에 전달하는 임의의 키워드는 만들어진 모의 객체의 어트리뷰트를 "
"설정하는 데 사용됩니다::"

#: ../../library/unittest.mock.rst:1573
msgid ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"
msgstr ""

#: ../../library/unittest.mock.rst:1580
msgid ""
"As well as attributes on the created mock attributes, like the "
":attr:`~Mock.return_value` and :attr:`~Mock.side_effect`, of child mocks "
"can also be configured. These aren't syntactically valid to pass in "
"directly as keyword arguments, but a dictionary with these as keys can "
"still be expanded into a :func:`patch` call using ``**``::"
msgstr ""
"만들어진 모의 객체 어트리뷰트뿐만 아니라 자식 모의 객체의 :attr:`~Mock.return_value`\\와 "
":attr:`~Mock.side_effect`\\와 같은 어트리뷰트도 구성 할 수 있습니다. 키워드 인자로 직접 전달하는 것은 "
"문법적으로 유효하지 않지만, 이것들을 키로 갖는 딕셔너리는 여전히 ``**``\\를 사용하여 :func:`patch` 호출로 확장될"
" 수 있습니다::"

#: ../../library/unittest.mock.rst:1586
#, python-brace-format
msgid ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"
msgstr ""

#: ../../library/unittest.mock.rst:1596
msgid ""
"By default, attempting to patch a function in a module (or a method or an"
" attribute in a class) that does not exist will fail with "
":exc:`AttributeError`::"
msgstr ""
"기본적으로, 존재하지 않는 모듈의 함수(또는 클래스의 메서드나 어트리뷰트)를 패치하려고 시도하면 "
":exc:`AttributeError`\\로 실패합니다::"

#: ../../library/unittest.mock.rst:1599
msgid ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute "
"'non_existing_attribute'"
msgstr ""

#: ../../library/unittest.mock.rst:1608
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr "그러나 :func:`patch` 호출에 ``create=True``\\를 추가하면 이전 예제가 기대한 대로 작동합니다::"

#: ../../library/unittest.mock.rst:1611
msgid ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"
msgstr ""

#: ../../library/unittest.mock.rst:1619
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async"
" function."
msgstr ":func:`patch`\\는 이제 target이 비동기 함수면 :class:`AsyncMock`\\을 반환합니다."

#: ../../library/unittest.mock.rst:1623
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1627
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr "모의 객체로 객체(*target*)의 이름 있는 멤버(*attribute*)를 패치합니다."

#: ../../library/unittest.mock.rst:1630
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, "
"*autospec* and *new_callable* have the same meaning as for :func:`patch`."
" Like :func:`patch`, :func:`patch.object` takes arbitrary keyword "
"arguments for configuring the mock object it creates."
msgstr ""
":func:`patch.object`\\는 데코레이터, 클래스 데코레이터 또는 컨텍스트 관리자로 사용할 수 있습니다. 인자 "
"*new*, *spec*, *create*, *spec_set*, *autospec* 및 *new_callable*\\은 "
":func:`patch`\\와 같은 의미입니다. :func:`patch`\\와 마찬가지로, "
":func:`patch.object`\\는 만드는 모의 객체를 구성하기 위해 임의의 키워드 인자를 취합니다."

#: ../../library/unittest.mock.rst:1636
msgid ""
"When used as a class decorator :func:`patch.object` honours "
"``patch.TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"클래스 데코레이터로 사용될 때, :func:`patch.object`\\는 감쌀 메서드를 선택하는 데 "
"``patch.TEST_PREFIX``\\를 사용합니다."

#: ../../library/unittest.mock.rst:1639
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"세 개의 인자나 두 개의 인자로 :func:`patch.object`\\를 호출 할 수 있습니다. 세 개의 인자 형식은 패치 할 "
"객체, 어트리뷰트 이름 및 어트리뷰트를 대체 할 객체를 취합니다."

#: ../../library/unittest.mock.rst:1643
msgid ""
"When calling with the two argument form you omit the replacement object, "
"and a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr "두 개의 인자 형식으로 호출하면 대체 객체를 생략하고, 모의 객체가 만들어져 데코레이트 된 함수에 대한 추가 인자로 전달됩니다:"

#: ../../library/unittest.mock.rst:1654
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the"
" same meaning as they do for :func:`patch`."
msgstr ""
"*spec*, *create* 및 :func:`patch.object`\\에 대한 다른 인자는 :func:`patch`\\와 같은 "
"의미입니다."

#: ../../library/unittest.mock.rst:1659
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1663
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary"
" to its original state after the test."
msgstr "딕셔너리나 딕셔너리류 객체를 패치하고, 테스트 후에 딕셔너리를 원래 상태로 복원합니다."

#: ../../library/unittest.mock.rst:1666
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items"
" plus iterating over keys."
msgstr ""
"*in_dict*\\는 딕셔너리나 컨테이너와 같은 매핑일 수 있습니다. 매핑이면 적어도 가져오기(get), 설정(set) 및 "
"삭제(delete)와 키 이터레이션을 지원해야 합니다."

#: ../../library/unittest.mock.rst:1670
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, "
"which will then be fetched by importing it."
msgstr "*in_dict*\\는 딕셔너리 이름을 지정하는 문자열일 수도 있으며, 이때는 임포트 해서 가져옵니다."

#: ../../library/unittest.mock.rst:1673
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values*"
" can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values*\\는 딕셔너리에 설정할 값의 딕셔너리일 수 있습니다. *values*\\는 ``(key, value)`` 쌍의 "
"이터러블일 수도 있습니다."

#: ../../library/unittest.mock.rst:1676
msgid ""
"If *clear* is true then the dictionary will be cleared before the new "
"values are set."
msgstr "*clear*\\가 참이면 새 값이 설정되기 전에 딕셔너리가 지워집니다."

#: ../../library/unittest.mock.rst:1679
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to"
" set values in the dictionary."
msgstr "딕셔너리에 값을 설정하기 위해 임의의 키워드 인자로 :func:`patch.dict`\\를 호출할 수도 있습니다."

#: ../../library/unittest.mock.rst:1684
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a "
"context manager."
msgstr ":func:`patch.dict`\\는 이제 컨텍스트 관리자로 사용될 때 패치된 딕셔너리를 반환합니다."

#: ../../library/unittest.mock.rst:1687
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ":func:`patch.dict`\\는 컨텍스트 관리자, 데코레이터 또는 클래스 데코레이터로 사용할 수 있습니다:"

#: ../../library/unittest.mock.rst:1698
msgid ""
"When used as a class decorator :func:`patch.dict` honours "
"``patch.TEST_PREFIX`` (default to ``'test'``) for choosing which methods "
"to wrap:"
msgstr ""
"클래스 데코레이터로 사용될 때 :func:`patch.dict`\\는 감쌀 메서드를 선택하는 데 "
"``patch.TEST_PREFIX``\\(기본값은 ``'test'``)를 따릅니다:"

#: ../../library/unittest.mock.rst:1709
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For "
"more details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"테스트에 다른 접두사를 사용하려면, ``patch.TEST_PREFIX``\\를 설정하여 패처에 다른 접두사를 알릴 수 있습니다. "
"값을 변경하는 방법에 대한 자세한 내용은 :ref:`test-prefix`\\를 참조하십시오."

#: ../../library/unittest.mock.rst:1713
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply "
"let a test change a dictionary, and ensure the dictionary is restored "
"when the test ends."
msgstr ""
":func:`patch.dict`\\를 사용하여 멤버를 딕셔너리에 추가하고 (또는 단순히 테스트에서 딕셔너리를 변경하고) 테스트가 "
"끝나면 딕셔너리가 복원되도록 할 수 있습니다."

#: ../../library/unittest.mock.rst:1734
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr ":func:`patch.dict` 호출에서 키워드를 사용하여 딕셔너리에 값을 설정할 수 있습니다:"

#: ../../library/unittest.mock.rst:1744
#, fuzzy
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item "
"getting, setting, deleting and either iteration or membership test. This "
"corresponds to the magic methods :meth:`~object.__getitem__`, "
":meth:`~object.__setitem__`, :meth:`~object.__delitem__` and either "
":meth:`~container.__iter__` or :meth:`~object.__contains__`."
msgstr ""
":func:`patch.dict`\\는 실제로 딕셔너리가 아닌 딕셔너리류 객체와 함께 사용할 수 있습니다. 최소한 아이템 가져오기,"
" 설정하기, 삭제하기 및 이터레이션이나 멤버십 검사를 지원해야 합니다. 이것은 매직 메서드 :meth:`__getitem__`, "
":meth:`__setitem__`, :meth:`__delitem__` 및 :meth:`__iter__`\\나 "
":meth:`__contains__`\\에 해당합니다."

#: ../../library/unittest.mock.rst:1774
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1778
msgid ""
"Perform multiple patches in a single call. It takes the object to be "
"patched (either as an object or a string to fetch the object by "
"importing) and keyword arguments for the patches::"
msgstr ""
"한 번의 호출로 여러 패치를 수행합니다. 패치할 객체(객체나 임포트로 객체를 가져올 문자열로)와 패치에 대한 키워드 인자를 "
"취합니다::"

#: ../../library/unittest.mock.rst:1782
msgid ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."
msgstr ""

#: ../../library/unittest.mock.rst:1785
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when "
":func:`patch.multiple` is used as a context manager."
msgstr ""
":func:`patch.multiple`\\가 모의 객체를 만들기를 원하면 :data:`DEFAULT`\\를 값으로 사용하십시오. "
"이 경우 만들어진 모의 객체는 키워드로 데코레이트 된 함수로 전달되며, :func:`patch.multiple`\\이 컨텍스트 "
"관리자로 사용될 때는 딕셔너리가 반환됩니다."

#: ../../library/unittest.mock.rst:1790
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. These "
"arguments will be applied to *all* patches done by "
":func:`patch.multiple`."
msgstr ""
":func:`patch.multiple`\\은 데코레이터, 클래스 데코레이터 또는 컨텍스트 관리자로 사용할 수 있습니다. "
"*spec*, *spec_set*, *create*, *autospec* 및 *new_callable* 인자는 "
":func:`patch`\\와 같은 의미입니다. 이 인자는 :func:`patch.multiple`\\이 수행한 *모든* 패치에 "
"적용됩니다."

#: ../../library/unittest.mock.rst:1795
msgid ""
"When used as a class decorator :func:`patch.multiple` honours "
"``patch.TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"클래스 데코레이터로 사용될 때 :func:`patch.multiple`\\은 감쌀 메서드를 선택하는 데 "
"``patch.TEST_PREFIX``\\를 사용합니다."

#: ../../library/unittest.mock.rst:1798
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function "
"by keyword. ::"
msgstr ""
":func:`patch.multiple`\\가 모의 객체를 만들기를 원하면 :data:`DEFAULT`\\를 값으로 사용할 수 "
"있습니다. :func:`patch.multiple`\\을 데코레이터로 사용하면 만들어진 모의 객체가 키워드로 데코레이트 된 함수에 "
"전달됩니다. ::"

#: ../../library/unittest.mock.rst:1802
msgid ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"
msgstr ""

#: ../../library/unittest.mock.rst:1812
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but"
" put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple`\\은 다른 ``patch`` 데코레이터와 중첩될 수 있지만, 키워드로 전달된 인자를 "
":func:`patch`\\가 만든 모든 표준 인자들 *뒤*\\에 넣습니다::"

#: ../../library/unittest.mock.rst:1815
msgid ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"
msgstr ""

#: ../../library/unittest.mock.rst:1824
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value "
"returned by the context manager is a dictionary where created mocks are "
"keyed by name::"
msgstr ""
":func:`patch.multiple`\\가 컨텍스트 관리자로 사용되면, 컨텍스트 관리자가 반환한 값은 만들어진 모의 객체 이름을"
" 키로 갖는 딕셔너리입니다::"

#: ../../library/unittest.mock.rst:1827
msgid ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as "
"values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:1838
msgid "patch methods: start and stop"
msgstr "패처 메서드: start와 stop"

#: ../../library/unittest.mock.rst:1840
#, fuzzy
msgid ""
"All the patchers have :meth:`!start` and :meth:`!stop` methods. These "
"make it simpler to do patching in ``setUp`` methods or where you want to "
"do multiple patches without nesting decorators or with statements."
msgstr ""
"모든 패처에는 :meth:`start`\\와 :meth:`stop` 메서드가 있습니다. 이를 통해 ``setUp`` 메서드나 "
"데코레이터를 중첩하거나 with 문을 사용하지 않고 여러 패치를 수행하려는 곳에서 패치를 수행하는 것이 더 간단해집니다."

#: ../../library/unittest.mock.rst:1844
#, fuzzy
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or "
":func:`patch.dict` as normal and keep a reference to the returned "
"``patcher`` object. You can then call :meth:`!start` to put the patch in "
"place and :meth:`!stop` to undo it."
msgstr ""
"이것들을 사용하려면 :func:`patch`, :func:`patch.object` 또는 :func:`patch.dict`\\를 "
"정상적으로 호출하고 반환된 ``patcher`` 객체에 대한 참조를 유지하십시오. 그런 다음 :meth:`start`\\를 호출하여"
" 패치를 제자리에 놓고 :meth:`stop`\\을 사용하여 패치를 취소할 수 있습니다."

#: ../../library/unittest.mock.rst:1848
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ":func:`patch`\\를 사용하여 모의 객체를 만들면 ``patcher.start`` 호출로 반환됩니다. ::"

#: ../../library/unittest.mock.rst:1851
msgid ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"
msgstr ""

#: ../../library/unittest.mock.rst:1862
#, fuzzy
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`~unittest.TestCase`::"
msgstr "일반적인 사용 사례는 :class:`TestCase`\\의 ``setUp`` 메서드에서 여러 패치를 수행하는 것입니다::"

#: ../../library/unittest.mock.rst:1865
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"
msgstr ""

#: ../../library/unittest.mock.rst:1884
msgid ""
"If you use this technique you must ensure that the patching is \"undone\""
" by calling ``stop``. This can be fiddlier than you might think, because "
"if an exception is raised in the ``setUp`` then ``tearDown`` is not "
"called. :meth:`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"이 기법을 사용하는 경우 ``stop``\\을 호출하여 패치가 \"실행 취소\" 되도록 해야 합니다. ``setUp``\\에서 "
"예외가 발생하면 ``tearDown``\\이 호출되지 않기 때문에, 이것은 생각보다 까다로울 수 있습니다. "
":meth:`unittest.TestCase.addCleanup`\\은 이것을 더 쉽게 만듭니다::"

#: ../../library/unittest.mock.rst:1889
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:1899
msgid ""
"As an added bonus you no longer need to keep a reference to the "
"``patcher`` object."
msgstr "추가 보너스로 더는 ``patcher`` 객체에 대한 참조를 유지할 필요가 없습니다."

#: ../../library/unittest.mock.rst:1902
msgid ""
"It is also possible to stop all patches which have been started by using "
":func:`patch.stopall`."
msgstr ":func:`patch.stopall`\\을 사용하여 시작된 모든 패치를 중지할 수도 있습니다."

#: ../../library/unittest.mock.rst:1907
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr "모든 활성 패치를 중지합니다. ``start``\\로 시작한 패치만 중지합니다."

#: ../../library/unittest.mock.rst:1913
msgid "patch builtins"
msgstr "내장 패치"

#: ../../library/unittest.mock.rst:1914
msgid ""
"You can patch any builtins within a module. The following example patches"
" builtin :func:`ord`::"
msgstr "모듈 내의 어떤 내장(builtins)도 패치 할 수 있습니다. 다음 예제는 내장 :func:`ord`\\를 패치합니다::"

#: ../../library/unittest.mock.rst:1917
msgid ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"
msgstr ""

#: ../../library/unittest.mock.rst:1929
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1931
msgid ""
"All of the patchers can be used as class decorators. When used in this "
"way they wrap every test method on the class. The patchers recognise "
"methods that start with ``'test'`` as being test methods. This is the "
"same way that the :class:`unittest.TestLoader` finds test methods by "
"default."
msgstr ""
"모든 패처를 클래스 데코레이터로 사용할 수 있습니다. 이런 식으로 사용하면 클래스의 모든 테스트 메서드를 감쌉니다. 패처는 "
"``'test'``\\로 시작하는 메서드를 테스트 메서드로 인식합니다. 이것은 "
":class:`unittest.TestLoader`\\가 기본적으로 테스트 메서드를 찾는 것과 같은 방법입니다."

#: ../../library/unittest.mock.rst:1936
msgid ""
"It is possible that you want to use a different prefix for your tests. "
"You can inform the patchers of the different prefix by setting "
"``patch.TEST_PREFIX``::"
msgstr ""
"테스트에 다른 접두사를 사용하고 싶을 수도 있습니다. ``patch.TEST_PREFIX``\\를 설정하여 다른 접두사를 패처에 "
"알릴 수 있습니다::"

#: ../../library/unittest.mock.rst:1939
msgid ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"
msgstr ""

#: ../../library/unittest.mock.rst:1959
msgid "Nesting Patch Decorators"
msgstr "패치 데코레이터 중첩하기"

#: ../../library/unittest.mock.rst:1961
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr "여러 패치를 수행하려면 단순히 데코레이터를 쌓으면 됩니다."

#: ../../library/unittest.mock.rst:1964
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "이 패턴을 사용하여 여러 패치 데코레이터를 쌓을 수 있습니다:"

#: ../../library/unittest.mock.rst:1980
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the"
" standard way that Python applies decorators. The order of the created "
"mocks passed into your test function matches this order."
msgstr ""
"데코레이터는 아래에서 위쪽으로 적용됨에 유의하십시오. 이것은 파이썬이 데코레이터를 적용하는 표준 방식입니다. 생성된 모의 객체가 "
"테스트 함수에 전달되는 순서는 이 순서와 일치합니다."

#: ../../library/unittest.mock.rst:1988
msgid "Where to patch"
msgstr "패치할 곳"

#: ../../library/unittest.mock.rst:1990
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch"
" the name used by the system under test."
msgstr ""
":func:`patch`\\는 *name*\\이 가리키는 객체를 다른 객체로 (임시로) 변경하여 작동합니다. 개별 객체를 가리키는 "
"많은 이름이 있을 수 있어서, 패치가 작동하려면 테스트 대상 시스템에서 사용하는 이름을 패치해야 합니다."

#: ../../library/unittest.mock.rst:1995
msgid ""
"The basic principle is that you patch where an object is *looked up*, "
"which is not necessarily the same place as where it is defined. A couple "
"of examples will help to clarify this."
msgstr ""
"기본 원칙은 객체가 *조회되는* 곳을 패치하는 것입니다. 이것은 정의된 곳과 반드시 같은 곳일 필요는 없습니다. 몇 가지 예가 이를"
" 명확히 하는 데 도움이 됩니다."

#: ../../library/unittest.mock.rst:1999
msgid ""
"Imagine we have a project that we want to test with the following "
"structure::"
msgstr "테스트하려는 프로젝트가 다음 구조로 되어 있다고 가정하십시오::"

#: ../../library/unittest.mock.rst:2001
msgid ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"
msgstr ""

#: ../../library/unittest.mock.rst:2008
#, fuzzy
msgid ""
"Now we want to test ``some_function`` but we want to mock out "
"``SomeClass`` using :func:`patch`. The problem is that when we import "
"module b, which we will have to do when it imports ``SomeClass`` from "
"module a. If we use :func:`patch` to mock out ``a.SomeClass`` then it "
"will have no effect on our test; module b already has a reference to the "
"*real* ``SomeClass`` and it looks like our patching had no effect."
msgstr ""
"이제 ``some_function``\\을 테스트하고 싶지만, :func:`patch`\\를 사용하여 ``SomeClass``\\를"
" 모킹하고 싶습니다. 문제는 모듈 b를 임포트 할 때 모듈 a에서 ``SomeClass``\\를 임포트해야 한다는 것입니다. "
":func:`patch`\\를 사용하여 ``a.SomeClass``\\를 모킹하면 테스트에 영향을 미치지 않습니다; 모듈 b는 이미"
" *실제* ``SomeClass``\\에 대한 참조를 가지고 있으며 패치가 효과가 없는 것처럼 보입니다."

#: ../../library/unittest.mock.rst:2015
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should"
" look like::"
msgstr ""
"핵심은 ``SomeClass``\\가 사용되는 곳(또는 그것을 조회하는 곳)을 패치하는 것입니다. 이 경우 "
"``some_function``\\은 우리가 임포트 한 모듈 b에서 ``SomeClass``\\를 조회합니다. 패치는 다음과 같아야"
" 합니다::"

#: ../../library/unittest.mock.rst:2019
msgid "@patch('b.SomeClass')"
msgstr ""

#: ../../library/unittest.mock.rst:2021
msgid ""
"However, consider the alternative scenario where instead of ``from a "
"import SomeClass`` module b does ``import a`` and ``some_function`` uses "
"``a.SomeClass``. Both of these import forms are common. In this case the "
"class we want to patch is being looked up in the module and so we have to"
" patch ``a.SomeClass`` instead::"
msgstr ""
"하지만, ``from a import SomeClass`` 대신 모듈 b가 ``import a``\\를 수행하고 "
"``some_function``\\이 ``a.SomeClass``\\를 사용하는 대체 시나리오를 생각해보십시오. 이 두 가지 임포트"
" 형식은 모두 일반적입니다. 이 경우 패치하려는 클래스가 모듈에서 조회되므로 대신 ``a.SomeClass``\\를 패치해야 "
"합니다::"

#: ../../library/unittest.mock.rst:2026
msgid "@patch('a.SomeClass')"
msgstr ""

#: ../../library/unittest.mock.rst:2030
msgid "Patching Descriptors and Proxy Objects"
msgstr "디스크립터와 프락시 객체 패치하기"

#: ../../library/unittest.mock.rst:2032
#, fuzzy
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: "
"class methods, static methods and properties. You should patch these on "
"the *class* rather than an instance. They also work with *some* objects "
"that proxy attribute access, like the `django settings object "
"<https://web.archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"patch_ 와 patch.object_ 모두 디스크립터를 올바르게 패치하고 복원합니다: 클래스 메서드, 정적 메서드 및 프로퍼티."
" 이것들을 인스턴스가 아닌 *클래스*\\에서 패치해야 합니다. 이들은 또한 `장고 settings 객체 "
"<http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>`_\\와"
" 같이 어트리뷰트 액세스를 프락시 하는 *일부* 객체에서도 작동합니다."

#: ../../library/unittest.mock.rst:2040
msgid "MagicMock and magic method support"
msgstr "MagicMock과 매직 메서드 지원"

#: ../../library/unittest.mock.rst:2045
msgid "Mocking Magic Methods"
msgstr "매직 메서드 모킹하기"

#: ../../library/unittest.mock.rst:2047
#, fuzzy
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as"
" :term:`\"magic methods\" <magic method>`. This allows mock objects to "
"replace containers or other objects that implement Python protocols."
msgstr ""
":class:`Mock`\\은 \"매직 메서드\"라고도 하는 파이썬 프로토콜 메서드 모킹을 지원합니다. 이를 통해 모의 객체가 "
"컨테이너나 파이썬 프로토콜을 구현하는 다른 객체를 대체할 수 있습니다."

#: ../../library/unittest.mock.rst:2051
msgid ""
"Because magic methods are looked up differently from normal methods [#]_,"
" this support has been specially implemented. This means that only "
"specific magic methods are supported. The supported list includes "
"*almost* all of them. If there are any missing that you need please let "
"us know."
msgstr ""
"매직 메서드는 일반 메서드와는 다르게 조회되므로 [#]_, 이 지원은 특별히 구현되었습니다. 즉, 특정 매직 메서드만 지원됩니다. "
"지원되는 목록에 이들이 *거의* 모두 포함됩니다. 누락된 것이 있으면 알려주십시오."

#: ../../library/unittest.mock.rst:2056
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* "
"take ``self`` as the first argument [#]_."
msgstr ""
"관심 있는 메서드를 함수나 모의 객체 인스턴스로 설정하여 매직 메서드를 모킹합니다. 함수를 사용하면 *반드시* ``self``\\를"
" 첫 번째 인자로 취해야 합니다 [#]_."

#: ../../library/unittest.mock.rst:2079
msgid ""
"One use case for this is for mocking objects used as context managers in "
"a :keyword:`with` statement:"
msgstr "이것의 한 가지 사용 사례는 :keyword:`with` 문에서 컨텍스트 관리자로 사용되는 객체를 모킹하는 것입니다:"

#: ../../library/unittest.mock.rst:2091
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but "
"they are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"매직 메서드 호출은 :attr:`~Mock.method_calls`\\에는 나타나지 않지만, "
":attr:`~Mock.mock_calls`\\에 기록됩니다."

#: ../../library/unittest.mock.rst:2096
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting "
"to set a magic method that isn't in the spec will raise an "
":exc:`AttributeError`."
msgstr ""
"*spec* 키워드 인자를 사용하여 모의 객체를 만들면 spec에 없는 매직 메서드를 설정하려고 시도할 때 "
":exc:`AttributeError`\\가 발생합니다."

#: ../../library/unittest.mock.rst:2099
msgid "The full list of supported magic methods is:"
msgstr "지원되는 매직 메서드의 전체 목록은 다음과 같습니다:"

#: ../../library/unittest.mock.rst:2101
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__`` 및 ``__str__``"

#: ../../library/unittest.mock.rst:2102
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__`` 및 ``__subclasses__``"

#: ../../library/unittest.mock.rst:2103
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``, ``__floor__``, ``__trunc__`` 및 ``__ceil__``"

#: ../../library/unittest.mock.rst:2104
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` "
"and ``__ne__``"
msgstr ""
"비교: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` 및 "
"``__ne__``"

#: ../../library/unittest.mock.rst:2106
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"컨테이너 메서드: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` 및 "
"``__missing__``"

#: ../../library/unittest.mock.rst:2109
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr "컨텍스트 관리자: ``__enter__``, ``__exit__``, ``__aenter__`` 및 ``__aexit__``"

#: ../../library/unittest.mock.rst:2110
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "단항 숫자 메서드: ``__neg__``, ``__pos__`` 및 ``__invert__``"

#: ../../library/unittest.mock.rst:2111
#, fuzzy
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"숫자 메서드 (뒤집히거나 제자리 변형 포함) : ``__add__``, ``__sub__``, ``__mul__``, "
"``__matmul__``, ``__div__``, ``__truediv__``, ``__floordiv__``, "
"``__mod__``, ``__divmod__``, ``__lshift__``, ``__rshift__``, ``__and__``,"
" ``__xor__``, ``__or__`` 및 ``__pow__``"

#: ../../library/unittest.mock.rst:2115
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` "
"and ``__index__``"
msgstr "숫자 변환 메서드: ``__complex__``, ``__int__``, ``__float__`` 및 ``__index__``"

#: ../../library/unittest.mock.rst:2117
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "디스크립터 메서드: ``__get__``, ``__set__`` 및 ``__delete__``"

#: ../../library/unittest.mock.rst:2118
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"피클링: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` 및 ``__setstate__``"

#: ../../library/unittest.mock.rst:2120
msgid "File system path representation: ``__fspath__``"
msgstr "파일 시스템 경로 표현: ``__fspath__``"

#: ../../library/unittest.mock.rst:2121
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "비동기 이터레이션 메서드: ``__aiter__``\\와 ``__anext__``"

#: ../../library/unittest.mock.rst:2123
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr ":func:`os.PathLike.__fspath__`\\에 대한 지원이 추가되었습니다."

#: ../../library/unittest.mock.rst:2126
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"``__aenter__``, ``__aexit__``, ``__aiter__`` 및 ``__anext__``\\에 대한 지원이 "
"추가되었습니다."

#: ../../library/unittest.mock.rst:2130
msgid ""
"The following methods exist but are *not* supported as they are either in"
" use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"다음과 같은 메서드가 존재하지만, 모의 객체가 사용 중이거나, 동적으로 설정할 수 없거나, 문제를 일으킬 수 있어서 지원되지 "
"*않습니다*:"

#: ../../library/unittest.mock.rst:2133
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__`` 및 ``__new__``"

#: ../../library/unittest.mock.rst:2134
msgid "``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr "``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"

#: ../../library/unittest.mock.rst:2139
msgid "Magic Mock"
msgstr "매직 모의 객체"

#: ../../library/unittest.mock.rst:2141
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and "
":class:`NonCallableMagicMock`."
msgstr ""
"두 가지 ``MagicMock`` 변형이 있습니다: :class:`MagicMock`\\과 "
":class:`NonCallableMagicMock`."

#: ../../library/unittest.mock.rst:2146
#, fuzzy
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations"
" of most of the :term:`magic methods <magic method>`. You can use "
"``MagicMock`` without having to configure the magic methods yourself."
msgstr ""
"``MagicMock``\\은 대부분의 매직 메서드의 기본 구현이 있는 :class:`Mock`\\의 서브 클래스입니다. 매직 "
"메서드를 직접 구성하지 않고도 ``MagicMock``\\을 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:2150
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "생성자 매개 변수는 :class:`Mock`\\과 같은 의미입니다."

#: ../../library/unittest.mock.rst:2152
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods "
"that exist in the spec will be created."
msgstr "*spec*\\이나 *spec_set* 인자를 사용하면 *오직* 사양에 존재하는 매직 메서드만 만들어집니다."

#: ../../library/unittest.mock.rst:2158
msgid "A non-callable version of :class:`MagicMock`."
msgstr "콜러블이 아닌 :class:`MagicMock` 버전."

#: ../../library/unittest.mock.rst:2160
msgid ""
"The constructor parameters have the same meaning as for "
":class:`MagicMock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"생성자 매개 변수는 콜러블이 아닌 모의 객체에 의미가 없는 *return_value*\\와 *side_effect*\\를 제외하고 "
":class:`MagicMock`\\과 같은 의미입니다."

#: ../../library/unittest.mock.rst:2164
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr "매직 메서드는 :class:`MagicMock` 객체로 설정되므로, 일반적인 방법으로 구성하고 사용할 수 있습니다:"

#: ../../library/unittest.mock.rst:2174
msgid ""
"By default many of the protocol methods are required to return objects of"
" a specific type. These methods are preconfigured with a default return "
"value, so that they can be used without you having to do anything if you "
"aren't interested in the return value. You can still *set* the return "
"value manually if you want to change the default."
msgstr ""
"기본적으로 많은 프로토콜 메서드는 특정 형의 객체를 반환하도록 요구합니다. 이러한 메서드는 기본 반환 값으로 사전 구성되어 있어서,"
" 반환 값에 관심이 없을 때 아무 조처를 하지 않아도 사용할 수 있습니다. 기본값을 변경하고 싶으면, 여전히 반환 값을 수동으로 "
"*설정*\\할 수 있습니다."

#: ../../library/unittest.mock.rst:2180
msgid "Methods and their defaults:"
msgstr "메서드와 기본값:"

#: ../../library/unittest.mock.rst:2182
#, fuzzy
msgid "``__lt__``: :data:`NotImplemented`"
msgstr "``__lt__``: ``NotImplemented``"

#: ../../library/unittest.mock.rst:2183
#, fuzzy
msgid "``__gt__``: :data:`!NotImplemented`"
msgstr "``__gt__``: ``NotImplemented``"

#: ../../library/unittest.mock.rst:2184
#, fuzzy
msgid "``__le__``: :data:`!NotImplemented`"
msgstr "``__le__``: ``NotImplemented``"

#: ../../library/unittest.mock.rst:2185
#, fuzzy
msgid "``__ge__``: :data:`!NotImplemented`"
msgstr "``__ge__``: ``NotImplemented``"

#: ../../library/unittest.mock.rst:2186
msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

#: ../../library/unittest.mock.rst:2187
msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

#: ../../library/unittest.mock.rst:2188
msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

#: ../../library/unittest.mock.rst:2189
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

#: ../../library/unittest.mock.rst:2190
msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

#: ../../library/unittest.mock.rst:2191
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

#: ../../library/unittest.mock.rst:2192
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``: ``1j``"

#: ../../library/unittest.mock.rst:2193
msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1.0``"

#: ../../library/unittest.mock.rst:2194
msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``True``"

#: ../../library/unittest.mock.rst:2195
msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

#: ../../library/unittest.mock.rst:2196
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: 모의 객체의 기본 hash"

#: ../../library/unittest.mock.rst:2197
msgid "``__str__``: default str for the mock"
msgstr "``__str__``: 모의 객체의 기본 str"

#: ../../library/unittest.mock.rst:2198
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: 모의 객체의 기본 sizeof"

#: ../../library/unittest.mock.rst:2200
msgid "For example:"
msgstr "예를 들면:"

#: ../../library/unittest.mock.rst:2212
#, fuzzy
msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are "
"special. They do the default equality comparison on identity, using the "
":attr:`~Mock.side_effect` attribute, unless you change their return value"
" to return something else::"
msgstr ""
"두 동등 비교 메서드 :meth:`__eq__`\\와 :meth:`__ne__`\\는 특별합니다. 이들의 반환 값을 변경하여 다른 "
"것을 반환하지 않는 한, :attr:`~Mock.side_effect` 어트리뷰트를 사용하여 아이덴티티에 대한 기본 동등 비교를 "
"수행합니다::"

#: ../../library/unittest.mock.rst:2217
msgid ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"
msgstr ""

#: ../../library/unittest.mock.rst:2226
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object"
" and isn't required to be an iterator:"
msgstr ":meth:`MagicMock.__iter__`\\의 반환 값은 임의의 이터러블 객체일 수 있으며 이터레이터일 필요는 없습니다:"

#: ../../library/unittest.mock.rst:2236
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr "반환 값이 이터레이터면, 일단 이터레이트 하면 이를 소진하고 후속 이터레이션은 빈 목록을 줍니다:"

#: ../../library/unittest.mock.rst:2245
msgid ""
"``MagicMock`` has all of the supported magic methods configured except "
"for some of the obscure and obsolete ones. You can still set these up if "
"you want."
msgstr ""
"``MagicMock``\\에는 불분명하고 쓸모없는 일부를 제외하고 지원되는 모든 매직 메서드가 구성되어 있습니다. 원한다면 여전히"
" 설정할 수 있습니다."

#: ../../library/unittest.mock.rst:2248
msgid ""
"Magic methods that are supported but not setup by default in "
"``MagicMock`` are:"
msgstr "``MagicMock``\\에서 지원되지만, 기본적으로 설정되지 않는 매직 메서드는 다음과 같습니다:"

#: ../../library/unittest.mock.rst:2250
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2251
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2252
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2253
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__`` 및 ``__delete__``"

#: ../../library/unittest.mock.rst:2254
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__``\\와 ``__missing__``"

#: ../../library/unittest.mock.rst:2255
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` 및 ``__setstate__``"

#: ../../library/unittest.mock.rst:2257
#, fuzzy
msgid "``__getformat__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2261
msgid ""
"Magic methods *should* be looked up on the class rather than the "
"instance. Different versions of Python are inconsistent about applying "
"this rule. The supported protocol methods should work with all supported "
"versions of Python."
msgstr ""
"매직 메서드는 인스턴스가 아닌 클래스에서 조회되어야 합니다. 다른 버전의 파이썬은 이 규칙을 적용하는 데 일관적이지 않습니다. "
"지원되는 프로토콜 메서드는 지원되는 모든 버전의 파이썬에서 작동해야 합니다."

#: ../../library/unittest.mock.rst:2265
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` "
"instance is kept isolated from the others."
msgstr "이 함수는 기본적으로 클래스에 연결되어 있지만, 각 ``Mock`` 인스턴스는 다른 것들과 격리되어 있습니다."

#: ../../library/unittest.mock.rst:2270
msgid "Helpers"
msgstr "도우미"

#: ../../library/unittest.mock.rst:2273
msgid "sentinel"
msgstr "sentinel"

#: ../../library/unittest.mock.rst:2277
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr "``sentinel`` 객체는 테스트에 고유한(unique) 객체를 제공하는 편리한 방법을 제공합니다."

#: ../../library/unittest.mock.rst:2280
msgid ""
"Attributes are created on demand when you access them by name. Accessing "
"the same attribute will always return the same object. The objects "
"returned have a sensible repr so that test failure messages are readable."
msgstr ""
"어트리뷰트는 이름으로 어트리뷰트에 액세스할 때 요청에 따라 만들어집니다. 같은 어트리뷰트에 액세스하면 항상 같은 객체가 반환됩니다."
" 반환된 객체는 테스트 실패 메시지를 읽을 수 있도록 적절한 repr을 갖습니다."

#: ../../library/unittest.mock.rst:2284
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are "
":mod:`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"``sentinel`` 어트리뷰트는 이제 :mod:`복사 <copy>`\\되거나 :mod:`피클 <pickle>`\\될 때 "
"아이덴티티를 유지합니다."

#: ../../library/unittest.mock.rst:2288
msgid ""
"Sometimes when testing you need to test that a specific object is passed "
"as an argument to another method, or returned. It can be common to create"
" named sentinel objects to test this. :data:`sentinel` provides a "
"convenient way of creating and testing the identity of objects like this."
msgstr ""
"때로 테스트할 때 특정 객체가 다른 메서드에 대한 인자로 전달되거나 반환되는지 테스트해야 할 때가 있습니다. 이것을 테스트하기 위해"
" 이름 붙은 sentinel 객체를 만드는 것이 일반적일 수 있습니다. :data:`sentinel`\\은 이와 같은 객체의 "
"아이덴티티를 만들고 테스트하는 편리한 방법을 제공합니다."

#: ../../library/unittest.mock.rst:2293
msgid ""
"In this example we monkey patch ``method`` to return "
"``sentinel.some_object``:"
msgstr "이 예에서는 ``method``\\를 ``sentinel.some_object``\\를 반환하도록 몽키 패치합니다:"

#: ../../library/unittest.mock.rst:2305
msgid "DEFAULT"
msgstr "DEFAULT"

#: ../../library/unittest.mock.rst:2310
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually "
"``sentinel.DEFAULT``). It can be used by :attr:`~Mock.side_effect` "
"functions to indicate that the normal return value should be used."
msgstr ""
":data:`DEFAULT` 객체는 미리 만들어진 sentinel(실제로 ``sentinel.DEFAULT``)입니다. "
":attr:`~Mock.side_effect` 함수에서 일반 반환 값을 사용해야 함을 나타내는 데 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:2316
msgid "call"
msgstr "call"

#: ../../library/unittest.mock.rst:2320
msgid ""
":func:`call` is a helper object for making simpler assertions, for "
"comparing with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, "
":attr:`~Mock.mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can"
" also be used with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call`\\은 :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, "
":attr:`~Mock.mock_calls` 및 :attr:`~Mock.method_calls`\\와 비교할 때, 더 간단한 "
"어서션을 만들기 위한 도우미 객체입니다. :func:`call`\\은 :meth:`~Mock.assert_has_calls`\\와 "
"함께 사용할 수도 있습니다."

#: ../../library/unittest.mock.rst:2333
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` "
"returns a list of all the intermediate calls as well as the final call."
msgstr ""
"여러 호출을 나타내는 호출 객체의 경우, :meth:`call_list`\\는 마지막 호출뿐만 아니라 모든 중간 호출의 목록을 "
"반환합니다."

#: ../../library/unittest.mock.rst:2337
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. "
"Manually constructing the sequence of calls can be tedious."
msgstr ""
"``call_list``\\는 \"연쇄 호출(chained calls)\"에 대한 어서션을 만드는 데 특히 유용합니다. 연쇄 호출은"
" 한 줄의 코드에 있는 여러 번의 호출입니다. 이로 인해 모의 객체의 :attr:`~Mock.mock_calls`\\에 여러 항목이"
" 생성됩니다. 호출 시퀀스를 수동으로 구성하는 것은 지루할 수 있습니다."

#: ../../library/unittest.mock.rst:2342
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same"
" chained call:"
msgstr ":meth:`~call.call_list`\\는 같은 연쇄 호출에서 호출 시퀀스를 구성 할 수 있습니다.:"

#: ../../library/unittest.mock.rst:2359
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or"
" (name, positional args, keyword args) depending on how it was "
"constructed. When you construct them yourself this isn't particularly "
"interesting, but the ``call`` objects that are in the "
":attr:`Mock.call_args`, :attr:`Mock.call_args_list` and "
":attr:`Mock.mock_calls` attributes can be introspected to get at the "
"individual arguments they contain."
msgstr ""
"``call`` 객체는 구성 방식에 따라 (위치 인자, 키워드 인자)나 (이름, 위치 인자, 키워드 인자)의 튜플입니다. 이것들을 "
"직접 만들 때 특별히 흥미롭지는 않지만, :attr:`Mock.call_args`, "
":attr:`Mock.call_args_list` 및 :attr:`Mock.mock_calls` 어트리뷰트에 있는 ``call`` "
"객체는 포함된 개별 인자를 얻기 위해 검사될 수 있습니다."

#: ../../library/unittest.mock.rst:2366
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and "
":attr:`Mock.call_args_list` are two-tuples of (positional args, keyword "
"args) whereas the ``call`` objects in :attr:`Mock.mock_calls`, along with"
" ones you construct yourself, are three-tuples of (name, positional args,"
" keyword args)."
msgstr ""
":attr:`Mock.call_args`\\와 :attr:`Mock.call_args_list`\\에 있는 ``call`` 객체는 "
"(위치 인자, 키워드 인자)의 2-튜플이지만, :attr:`Mock.mock_calls`\\에 있는 ``call`` 객체는, "
"여러분이 직접 생성하는 객체와 함께, (이름, 위치 인자, 키워드 인자)의 3-튜플입니다."

#: ../../library/unittest.mock.rst:2371
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a"
" tuple (an empty tuple if there are no positional arguments) and the "
"keyword arguments are a dictionary:"
msgstr ""
"이들의 \"튜플성(tupleness)\"을 사용하여 더 복잡한 검사와 어서션을 위해 개별 인자를 가져올 수 있습니다. 위치 인자는 "
"튜플(위치 인자가 없으면 비어있는 튜플)이고 키워드 인자는 딕셔너리입니다:"

#: ../../library/unittest.mock.rst:2404
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2408
msgid ""
"Create a mock object using another object as a spec. Attributes on the "
"mock will use the corresponding attribute on the *spec* object as their "
"spec."
msgstr ""
"다른 객체를 사양으로 사용하여 모의 객체를 만듭니다. 모의 객체 어트리뷰트는 *spec* 객체의 해당 어트리뷰트를 사양으로 "
"사용합니다."

#: ../../library/unittest.mock.rst:2412
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr "모킹되는 함수나 메서드는 올바른 서명으로 호출되도록 인자를 점검합니다."

#: ../../library/unittest.mock.rst:2415
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't "
"exist on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*\\이 ``True``\\이면 사양 객체에 존재하지 않는 어트리뷰트를 설정하려는 시도는 "
":exc:`AttributeError`\\를 발생시킵니다."

#: ../../library/unittest.mock.rst:2418
msgid ""
"If a class is used as a spec then the return value of the mock (the "
"instance of the class) will have the same spec. You can use a class as "
"the spec for an instance object by passing ``instance=True``. The "
"returned mock will only be callable if instances of the mock are "
"callable."
msgstr ""
"클래스가 사양으로 사용되면 모의 객체의 반환 값(클래스의 인스턴스)은 같은 사양을 갖습니다. ``instance=True``\\를 "
"전달하여 클래스를 인스턴스 객체의 사양으로 사용할 수 있습니다. 반환된 모의 객체는 모의 객체의 인스턴스가 콜러블일 때만 "
"콜러블입니다."

#: ../../library/unittest.mock.rst:2423
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ":func:`create_autospec`\\은 또한 만들어진 모의 객체의 생성자에 전달되는 임의의 키워드 인자를 취합니다."

#: ../../library/unittest.mock.rst:2426
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with "
":func:`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
":func:`create_autospec`\\과 :func:`patch`\\에 대한 *autospec* 인자로 자동 사양을 사용하는"
" 방법에 대한 예는 :ref:`auto-speccing`\\을 참조하십시오."

#: ../../library/unittest.mock.rst:2432
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target "
"is an async function."
msgstr "대상이 비동기 함수이면 :func:`create_autospec`\\은 이제 :class:`AsyncMock`\\을 반환합니다."

#: ../../library/unittest.mock.rst:2437
msgid "ANY"
msgstr "ANY"

#: ../../library/unittest.mock.rst:2441
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments "
"in a call to mock, but either not care about some of the arguments or "
"want to pull them individually out of :attr:`~Mock.call_args` and make "
"more complex assertions on them."
msgstr ""
"때로는 모의 객체 호출에서 인자의 *일부*\\에 대한 어서션을 만들 필요가 있지만, 일부 인자에는 신경 쓰지 않거나 "
":attr:`~Mock.call_args`\\에서 개별적으로 꺼내어 더 복잡한 어서션을 만들고 싶을 수도 있습니다."

#: ../../library/unittest.mock.rst:2446
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to"
" *everything*. Calls to :meth:`~Mock.assert_called_with` and "
":meth:`~Mock.assert_called_once_with` will then succeed no matter what "
"was passed in."
msgstr ""
"특정 인자를 무시하려면 *모든 것*\\과 같다고 비교되는 객체를 전달할 수 있습니다. "
":meth:`~Mock.assert_called_with`\\와 "
":meth:`~Mock.assert_called_once_with`\\에 대한 호출은 전달된 내용과 관계없이 성공합니다."

#: ../../library/unittest.mock.rst:2455
msgid ""
":data:`ANY` can also be used in comparisons with call lists like "
":attr:`~Mock.mock_calls`:"
msgstr ":data:`ANY`\\는 :attr:`~Mock.mock_calls`\\와 같은 호출 리스트와 비교할 때도 사용할 수 있습니다.:"

#: ../../library/unittest.mock.rst:2465
msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can "
"also be used in test assertions::"
msgstr ""

#: ../../library/unittest.mock.rst:2468
msgid ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"
msgstr ""

#: ../../library/unittest.mock.rst:2476
msgid "FILTER_DIR"
msgstr "FILTER_DIR"

#: ../../library/unittest.mock.rst:2480
#, fuzzy
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike "
"this filtering, or need to switch it off for diagnostic purposes, then "
"set ``mock.FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR`\\은 모의 객체가 :func:`dir`\\에 응답하는 방식을 제어하는 모듈 수준 변수입니다 "
"(파이썬 2.6 이상에서만). 기본값은 ``True``\\이며, 아래 설명된 필터링을 사용하여 유용한 멤버만 표시합니다. 이 "
"필터링이 마음에 들지 않거나 진단 목적으로 필터를 꺼야 하면, ``mock.FILTER_DIR = False``\\를 설정하십시오."

#: ../../library/unittest.mock.rst:2486
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and "
"will include any dynamically created attributes that wouldn't normally be"
" shown. If the mock was created with a *spec* (or *autospec* of course) "
"then all the attributes from the original are shown, even if they haven't"
" been accessed yet:"
msgstr ""
"필터링을 켜면, ``dir(some_mock)``\\는 유용한 어트리뷰트만 표시하고 일반적으로 표시되지 않는 동적으로 만들어진 "
"어트리뷰트를 포함합니다. *spec*\\(또는 물론 *autospec*)으로 모의 객체를 만들었으면, 아직 액세스하지 않았다 "
"할지라도 원본의 모든 어트리뷰트가 표시됩니다:"

#: ../../library/unittest.mock.rst:2492
msgid ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."
msgstr ""

#: ../../library/unittest.mock.rst:2513
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the "
"thing being mocked) underscore and double underscore prefixed attributes "
"have been filtered from the result of calling :func:`dir` on a "
":class:`Mock`. If you dislike this behaviour you can switch it off by "
"setting the module level switch :data:`FILTER_DIR`:"
msgstr ""
":class:`Mock`\\에 대해 :func:`dir`\\을 호출한 결과에서 그다지 유용하지 않은 (모킹되는 대상이 아닌 "
":class:`Mock` 전용) 밑줄과 이중 밑줄 접두어 어트리뷰트가 필터링 되었습니다. 이 동작이 마음에 들지 않으면 모듈 수준 "
"스위치 :data:`FILTER_DIR`\\를 설정하여 끌 수 있습니다.:"

#: ../../library/unittest.mock.rst:2519
msgid ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."
msgstr ""

#: ../../library/unittest.mock.rst:2534
#, fuzzy
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering "
"irrespective of :const:`FILTER_DIR`."
msgstr ""
"또는 ``vars(my_mock)``\\(인스턴스 멤버)과 ``dir(type(my_mock))``\\(형 멤버)을 사용하여 "
":data:`mock.FILTER_DIR`\\에 관계없이 필터링을 무시할 수 있습니다."

#: ../../library/unittest.mock.rst:2540
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2544
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It"
" works for :func:`open` called directly or used as a context manager."
msgstr ""
":func:`open`\\의 사용을 대체하기 위한 모의 객체를 만드는 도우미 함수. 직접 호출되거나 컨텍스트 관리자로 사용되는 "
":func:`open`\\에 대해 작동합니다."

#: ../../library/unittest.mock.rst:2547
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"*mock* 인자는 구성할 모의 객체입니다. ``None``\\(기본값)이면 표준 파일 핸들에서 사용 가능한 메서드나 어트리뷰트로 "
"API가 제한된 :class:`MagicMock`\\이 만들어집니다."

#: ../../library/unittest.mock.rst:2551
#, fuzzy
msgid ""
"*read_data* is a string for the :meth:`~io.RawIOBase.read`, "
":meth:`~io.IOBase.readline`, and :meth:`~io.IOBase.readlines` methods of "
"the file handle to return.  Calls to those methods will take data from "
"*read_data* until it is depleted.  The mock of these methods is pretty "
"simplistic: every time the *mock* is called, the *read_data* is rewound "
"to the start.  If you need more control over the data that you are "
"feeding to the tested code you will need to customize this mock for "
"yourself.  When that is insufficient, one of the in-memory filesystem "
"packages on `PyPI <https://pypi.org>`_ can offer a realistic filesystem "
"for testing."
msgstr ""
"*read_data*\\는 파일 핸들의 :meth:`~io.IOBase.read`, "
":meth:`~io.IOBase.readline` 및 :meth:`~io.IOBase.readlines` 메서드가 반환할 "
"문자열입니다. 이러한 메서드를 호출하면 *read_data*\\에서 데이터가 고갈될 때까지 데이터를 가져옵니다. 이러한 메서드의 "
"모의 객체는 매우 단순합니다: *mock*\\이 호출될 때마다 *read_data*\\는 처음으로 되감깁니다. 테스트 되는 코드에 "
"공급하는 데이터를 더 세밀하게 제어하려면 이 모의 객체를 스스로 사용자 정의해야 합니다. 이것으로 불충분하면, `PyPI "
"<https://pypi.org>`_\\의 메모리 내 파일 시스템 패키지 중 하나가 테스트를 위한 진짜 같은 파일 시스템을 제공할 "
"수 있습니다."

#: ../../library/unittest.mock.rst:2561
#, fuzzy
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` "
"support. The mock of :meth:`~io.RawIOBase.read` changed to consume "
"*read_data* rather than returning it on each call."
msgstr ""
":meth:`~io.IOBase.readline`\\과 :meth:`~io.IOBase.readlines` 지원이 추가되었습니다. "
":meth:`~io.IOBase.read`\\의 모의 객체는 호출마다 *read_data*\\를 반환하는 대신 소비하도록 "
"변경되었습니다."

#: ../../library/unittest.mock.rst:2566
msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data*\\는 이제 *mock*\\을 호출할 때마다 재설정됩니다."

#: ../../library/unittest.mock.rst:2569
#, fuzzy
msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration "
"(such as in for loops) correctly consumes *read_data*."
msgstr ""
"이터레이션(가령 for 루프)에서 *read_data*\\를 올바르게 소비하도록 구현에 :meth:`__iter__`\\를 "
"추가했습니다."

#: ../../library/unittest.mock.rst:2573
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your "
"file handles are closed properly and is becoming common::"
msgstr ""
":func:`open`\\을 컨텍스트 관리자로 사용하는 것은 파일 핸들이 올바르게 닫히도록 보장하는 좋은 방법이고 점차 일반화되고 "
"있습니다::"

#: ../../library/unittest.mock.rst:2576
msgid ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"
msgstr ""

#: ../../library/unittest.mock.rst:2579
#, fuzzy
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the"
" *returned object* that is used as a context manager (and has "
":meth:`~object.__enter__` and :meth:`~object.__exit__` called)."
msgstr ""
"문제는 :func:`open`\\에 대한 호출을 모킹하더라도 컨텍스트 관리자로 사용되는 것은 *반환된 객체*\\라는 것입니다 "
"(그리고 :meth:`__enter__`\\와 :meth:`__exit__`\\가 호출됩니다)."

#: ../../library/unittest.mock.rst:2583
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ":class:`MagicMock`\\으로 컨텍스트 관리자를 모킹하는 것은 도우미 함수가 유용할 만큼 충분히 일반적입니다. ::"

#: ../../library/unittest.mock.rst:2586
msgid ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"
msgstr ""

#: ../../library/unittest.mock.rst:2600
msgid "And for reading files::"
msgstr "그리고 파일을 읽기 위해서는::"

#: ../../library/unittest.mock.rst:2602
msgid ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"
msgstr ""

#: ../../library/unittest.mock.rst:2613
msgid "Autospeccing"
msgstr "자동 사양"

#: ../../library/unittest.mock.rst:2615
#, fuzzy
msgid ""
"Autospeccing is based on the existing :attr:`!spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but "
"it is recursive (implemented lazily) so that attributes of mocks only "
"have the same api as the attributes of the spec. In addition mocked "
"functions / methods have the same call signature as the original so they "
"raise a :exc:`TypeError` if they are called incorrectly."
msgstr ""
"자동 사양은 기존의 :attr:`spec` 기능을 기반으로 합니다. 모의 객체 api를 원본 객체(사양)의 api로 제한하지만, "
"재귀적(게으르게(lazily) 구현되었습니다)이라서 모의 객체의 어트리뷰트는 사양의 어트리뷰트와 같은 api만 갖습니다. 또한 "
"모킹된 함수 / 메서드는 원본과 같은 호출 서명을 가지므로 잘못 호출되면 :exc:`TypeError`\\를 발생시킵니다."

#: ../../library/unittest.mock.rst:2622
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr "자동 사양이 작동하는 방식을 설명하기 전에, 이것이 필요한 이유는 이렇습니다."

#: ../../library/unittest.mock.rst:2624
#, fuzzy
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from"
" a flaw which is general to mocking. If you refactor some of your code, "
"rename members and so on, any tests for code that is still using the *old"
" api* but uses mocks instead of the real objects will still pass. This "
"means your tests can all pass even though your code is broken."
msgstr ""
"두 번째 문제는 모킹에 더 일반적입니다. 멤버 이름 등을 변경하는 등 일부 코드를 리팩토링하면, 여전히 *예전 api*\\를 "
"사용하는 코드에 대한 테스트는 실제 객체 대신 모의 객체를 사용하면 모두 통과합니다. 이것은 코드가 손상되어도 테스트를 모두 통과 "
"할 수 있다는 뜻입니다."

#: ../../library/unittest.mock.rst:2632
msgid ""
"Before 3.5, tests with a typo in the word assert would silently pass when"
" they should raise an error. You can still achieve this behavior by "
"passing ``unsafe=True`` to Mock."
msgstr ""

#: ../../library/unittest.mock.rst:2635
msgid ""
"Note that this is another reason why you need integration tests as well "
"as unit tests. Testing everything in isolation is all fine and dandy, but"
" if you don't test how your units are \"wired together\" there is still "
"lots of room for bugs that tests might have caught."
msgstr ""
"이것이 단위 테스트뿐만 아니라 통합 테스트가 필요한 또 다른 이유입니다. 모든 것을 분리해서 테스트하는 것은 괜찮고 멋지지만, "
"단위들이 어떻게 \"서로 연결되어\" 있는지 테스트하지 않으면 테스트가 발견할 수도 있을 버그에 대한 여지가 여전히 많습니다."

#: ../../library/unittest.mock.rst:2640
#, fuzzy
msgid ""
":mod:`unittest.mock` already provides a feature to help with this, called"
" speccing. If you use a class or instance as the :attr:`!spec` for a mock"
" then you can only access attributes on the mock that exist on the real "
"class:"
msgstr ""
":mod:`mock`\\은 이미 이에 도움이 되는 기능인 사양(speccing)을 제공합니다. 모의 객체에 클래스나 인스턴스를 "
":attr:`spec`\\으로 사용하면, 실제 클래스에 존재하는 모의 객체 어트리뷰트에만 액세스 할 수 있습니다:"

#: ../../library/unittest.mock.rst:2651
msgid ""
"The spec only applies to the mock itself, so we still have the same issue"
" with any methods on the mock:"
msgstr "사양은 모의 객체 자체에만 적용되므로, 모의 객체의 메서드와 관계된 문제는 여전히 있습니다:"

#: ../../library/unittest.mock.rst:2654
msgid ""
">>> mock.has_data()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.has_data.assret_called_with()  # Intentional typo!"
msgstr ""

#: ../../library/unittest.mock.rst:2660
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` "
"to :func:`patch` / :func:`patch.object` or use the "
":func:`create_autospec` function to create a mock with a spec. If you use"
" the ``autospec=True`` argument to :func:`patch` then the object that is "
"being replaced will be used as the spec object. Because the speccing is "
"done \"lazily\" (the spec is created as attributes on the mock are "
"accessed) you can use it with very complex or deeply nested objects (like"
" modules that import modules that import modules) without a big "
"performance hit."
msgstr ""
"자동 사양은 이 문제를 해결합니다. ``autospec=True``\\를 :func:`patch` / "
":func:`patch.object`\\로 전달하거나 :func:`create_autospec` 함수를 사용하여 사양이 있는 모의 "
"객체를 만들 수 있습니다. ``autospec=True`` 인자를 :func:`patch`\\에 사용하면 대체 중인 객체가 사양 "
"객체로 사용됩니다. 사양화(speccing)는 \"게으르게(lazily)\" 수행되므로 (모의 객체의 어트리뷰트에 액세스할 때 "
"사양이 만들어집니다) 성능이 크게 저하되지 않고도 매우 복잡하거나 깊이 중첩된 객체(가령 모듈을 임포트 하는 모듈을 임포트 하는 "
"모듈)와 함께 사용할 수 있습니다."

#: ../../library/unittest.mock.rst:2669
msgid "Here's an example of it in use::"
msgstr "사용 예는 다음과 같습니다::"

#: ../../library/unittest.mock.rst:2671
msgid ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:2679
#, fuzzy
msgid ""
"You can see that :class:`!request.Request` has a spec. "
":class:`!request.Request` takes two arguments in the constructor (one of "
"which is *self*). Here's what happens if we try to call it incorrectly::"
msgstr ""
":class:`request.Request`\\에 spec이 있음을 알 수 있습니다. "
":class:`request.Request`\\는 생성자에서 두 개의 인자를 취합니다 (하나는 *self*\\입니다). 잘못 "
"호출하면 이렇게 됩니다::"

#: ../../library/unittest.mock.rst:2683
msgid ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"
msgstr ""

#: ../../library/unittest.mock.rst:2688
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr "사양은 인스턴스 화 된 클래스(즉, 사양화된 모의 객체의 반환 값)에도 적용됩니다::"

#: ../../library/unittest.mock.rst:2691
msgid ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:2695
#, fuzzy
msgid ""
":class:`!Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`!request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the "
"correct error::"
msgstr ""
":class:`Request` 객체는 콜러블이 아니므로, 모킹된 :class:`request.Request`\\의 인스턴스 화의 "
"반환 값은 콜러블이 아닌 모의 객체입니다. 사양이 적용되면 어서션에 오타가 있을 때 올바른 에러를 발생시킵니다::"

#: ../../library/unittest.mock.rst:2699
msgid ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"
msgstr ""

#: ../../library/unittest.mock.rst:2707
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to "
"typos and api changes."
msgstr ""
"많은 경우 단지 기존 :func:`patch` 호출에 ``autospec=True``\\를 추가하면 오타와 api 변경으로 인한 "
"버그로부터 보호할 수 있습니다."

#: ../../library/unittest.mock.rst:2711
msgid ""
"As well as using *autospec* through :func:`patch` there is a "
":func:`create_autospec` for creating autospecced mocks directly:"
msgstr ""
":func:`patch`\\를 통해 *autospec*\\을 사용하는 것뿐만 아니라 자동 사양 모의 객체를 직접 만들기 위한 "
":func:`create_autospec`\\도 있습니다:"

#: ../../library/unittest.mock.rst:2719
msgid ""
"This isn't without caveats and limitations however, which is why it is "
"not the default behaviour. In order to know what attributes are available"
" on the spec object, autospec has to introspect (access attributes) the "
"spec. As you traverse attributes on the mock a corresponding traversal of"
" the original object is happening under the hood. If any of your specced "
"objects have properties or descriptors that can trigger code execution "
"then you may not be able to use autospec. On the other hand it is much "
"better to design your objects so that introspection is safe [#]_."
msgstr ""
"그러나 경고와 제한이 없는 것은 아니기 때문에 기본 동작이 아닙니다. 사양 객체에서 사용 가능한 어트리뷰트를 알기 위해 "
"autospec은 사양을 검사(어트리뷰트를 액세스합니다)해야 합니다. 모의 객체 어트리뷰트를 탐색할 때 원본 객체의 대응하는 탐색이"
" 수면 아래에서 발생합니다. 사양 객체 중 어느 하나가 코드 실행을 트리거 할 수 있는 프로퍼티나 디스크립터를 갖는 경우 자동 "
"사양을 사용하지 못할 수 있습니다. 반면에, 내부 검사가 안전하도록 객체를 설계하는 것이 훨씬 좋습니다 [#]_."

#: ../../library/unittest.mock.rst:2728
#, fuzzy
msgid ""
"A more serious problem is that it is common for instance attributes to be"
" created in the :meth:`~object.__init__` method and not to exist on the "
"class at all. *autospec* can't know about any dynamically created "
"attributes and restricts the api to visible attributes. ::"
msgstr ""
"더 심각한 문제는 인스턴스 어트리뷰트가 :meth:`__init__` 메서드에서 만들어지고 클래스에 전혀 존재하지 않는 것이 "
"일반적이라는 것입니다. *autospec*\\은 동적으로 만들어진 어트리뷰트를 알 수 없으며 api를 가시적 어트리뷰트로 "
"제한합니다. ::"

#: ../../library/unittest.mock.rst:2733
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"
msgstr ""

#: ../../library/unittest.mock.rst:2745
msgid ""
"There are a few different ways of resolving this problem. The easiest, "
"but not necessarily the least annoying, way is to simply set the required"
" attributes on the mock after creation. Just because *autospec* doesn't "
"allow you to fetch attributes that don't exist on the spec it doesn't "
"prevent you setting them::"
msgstr ""
"이 문제를 해결하는 방법에는 몇 가지가 있습니다. 가장 쉬운, 하지만 가장 덜 성가시다고 할 수는 없는, 방법은 단순히 생성 후에 "
"모의 객체에 필요한 어트리뷰트를 설정하는 것입니다. *autospec*\\은 사양에 존재하지 않는 어트리뷰트를 꺼내는 것을 허락하지"
" 않기 때문에 그것을 설정하는 것을 막지는 않습니다::"

#: ../../library/unittest.mock.rst:2751
msgid ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:2756
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that "
"*does* prevent you setting non-existent attributes. This is useful if you"
" want to ensure your code only *sets* valid attributes too, but obviously"
" it prevents this particular scenario:"
msgstr ""
"존재하지 않는 어트리뷰트를 설정하지 *못하게 하는* *spec*\\과 *autospec*\\의 더 적극적인 버전이 있습니다. 이것은"
" 코드가 *오직* 유효한 어트리뷰트만 설정하도록 보장하려는 경우 유용하지만, 명백히 이 특정 시나리오를 막습니다:"

#: ../../library/unittest.mock.rst:2769
#, fuzzy
msgid ""
"Probably the best way of solving the problem is to add class attributes "
"as default values for instance members initialised in "
":meth:`~object.__init__`. Note that if you are only setting default "
"attributes in :meth:`!__init__` then providing them via class attributes "
"(shared between instances of course) is faster too. e.g."
msgstr ""
"아마도 문제를 해결하는 가장 좋은 방법은 :meth:`__init__`\\에서 초기화되는 인스턴스 멤버의 기본값으로 클래스 "
"어트리뷰트를 추가하는 것입니다. :meth:`__init__`\\에서 기본 어트리뷰트만 설정하고 있다면 클래스 어트리뷰트(물론 "
"인스턴스 간에 공유됩니다)를 통해 제공하는 것이 더 빠르기도 합니다. 예를 들어"

#: ../../library/unittest.mock.rst:2775
msgid ""
"class Something:\n"
"    a = 33"
msgstr ""

#: ../../library/unittest.mock.rst:2780
msgid ""
"This brings up another issue. It is relatively common to provide a "
"default value of ``None`` for members that will later be an object of a "
"different type. ``None`` would be useless as a spec because it wouldn't "
"let you access *any* attributes or methods on it. As ``None`` is *never* "
"going to be useful as a spec, and probably indicates a member that will "
"normally of some other type, autospec doesn't use a spec for members that"
" are set to ``None``. These will just be ordinary mocks (well - "
"MagicMocks):"
msgstr ""
"이것은 또 다른 문제를 일으킵니다. 나중에 다른 형의 객체가 될 멤버에 대해 기본값 ``None``\\을 제공하는 것이 "
"일반적입니다. *아무런* 어트리뷰트나 메서드에도 액세스할 수 없도록 하므로 ``None``\\은 사양으로 쓸모가 없습니다. "
"``None``\\은 *결코* 스펙으로 유용하지 않고, 일반적으로 다른 형의 멤버를 나타낼 것이기 때문에, autospec은 "
"``None``\\으로 설정된 멤버의 사양을 사용하지 않습니다. 이것들은 평범한 모의 객체일 것입니다 (아마도 - "
"MagicMock):"

#: ../../library/unittest.mock.rst:2795
msgid ""
"If modifying your production classes to add defaults isn't to your liking"
" then there are more options. One of these is simply to use an instance "
"as the spec rather than the class. The other is to create a subclass of "
"the production class and add the defaults to the subclass without "
"affecting the production class. Both of these require you to use an "
"alternative object as the spec. Thankfully :func:`patch` supports this - "
"you can simply pass the alternative object as the *autospec* argument::"
msgstr ""
"프로덕션 클래스를 수정하여 기본값을 추가하는 것이 마음에 들지 않으면 더 많은 선택지가 있습니다. 이 중 하나는 단순히 클래스가 "
"아닌 인스턴스를 사양으로 사용하는 것입니다. 다른 하나는 프로덕션 클래스의 서브 클래스를 만들고 프로덕션 클래스에 영향을 주지 "
"않으면서 기본값을 서브 클래스에 추가하는 것입니다. 이 두 가지 모두 사양으로 대체 객체를 사용해야 합니다. 고맙게도 "
":func:`patch`\\는 이것을 지원합니다 - 단순히 대체 객체를 *autospec* 인자로 전달할 수 있습니다::"

#: ../../library/unittest.mock.rst:2803
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"
msgstr ""

#: ../../library/unittest.mock.rst:2816
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance."
" It is only attribute lookups - along with calls to :func:`dir` - that "
"are done."
msgstr ""
"이것은 클래스나 이미 인스턴스 화 된 객체에만 적용됩니다. 모킹된 클래스를 호출하여 모의 객체 인스턴스를 만드는 것은 실제 "
"인스턴스를 만들지 *않습니다*. (:func:`dir` 호출과 함께) 어트리뷰트 조회만 수행됩니다."

#: ../../library/unittest.mock.rst:2821
msgid "Sealing mocks"
msgstr "실링 모의 객체 봉인하기"

#: ../../library/unittest.mock.rst:2830
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are "
"already mocks recursively."
msgstr ""
"Seal은 봉인되는 모의 객체나 이것의 재귀적으로 이미 모의 객체인 어트리뷰트의 어트리뷰트를 액세스할 때 자동 모의 객체 생성을 "
"비활성화합니다."

#: ../../library/unittest.mock.rst:2833
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal"
" from fixing part of the mock object. ::"
msgstr ""
"이름이나 사양을 가진 모의 객체 인스턴스가 어트리뷰트에 대입되면 봉인 체인에서 고려되지 않습니다. 이것은 seal이 모의 객체의 "
"일부를 고정하는 것을 방지할 수 있게 합니다. ::"

#: ../../library/unittest.mock.rst:2837
msgid ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."
msgstr ""

#: ../../library/unittest.mock.rst:2849
msgid ""
"Order of precedence of :attr:`!side_effect`, :attr:`!return_value` and "
"*wraps*"
msgstr ""

#: ../../library/unittest.mock.rst:2851
msgid "The order of their precedence is:"
msgstr ""

#: ../../library/unittest.mock.rst:2853
msgid ":attr:`~Mock.side_effect`"
msgstr ""

#: ../../library/unittest.mock.rst:2854
msgid ":attr:`~Mock.return_value`"
msgstr ""

#: ../../library/unittest.mock.rst:2855
msgid "*wraps*"
msgstr ""

#: ../../library/unittest.mock.rst:2857
msgid ""
"If all three are set, mock will return the value from "
":attr:`~Mock.side_effect`, ignoring :attr:`~Mock.return_value` and the "
"wrapped object altogether. If any two are set, the one with the higher "
"precedence will return the value. Regardless of the order of which was "
"set first, the order of precedence remains unchanged."
msgstr ""

#: ../../library/unittest.mock.rst:2875
msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be "
"checked between :attr:`~Mock.return_value` and the wrapped object, "
"ignoring :attr:`~Mock.side_effect`."
msgstr ""

#: ../../library/unittest.mock.rst:2884
msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is "
":data:`DEFAULT`, it is ignored and the order of precedence moves to the "
"successor to obtain the value to return."
msgstr ""

#: ../../library/unittest.mock.rst:2893
msgid ""
"When :class:`Mock` wraps an object, the default value of "
":attr:`~Mock.return_value` will be :data:`DEFAULT`."
msgstr ""

#: ../../library/unittest.mock.rst:2902
msgid ""
"The order of precedence will ignore this value and it will move to the "
"last successor which is the wrapped object."
msgstr ""

#: ../../library/unittest.mock.rst:2905
msgid ""
"As the real call is being made to the wrapped object, creating an "
"instance of this mock will return the real instance of the class. The "
"positional arguments, if any, required by the wrapped object must be "
"passed."
msgstr ""

#: ../../library/unittest.mock.rst:2923
msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr ""

#: ../../library/unittest.mock.rst:2931
msgid ""
"Even if you set all three at once when initializing the mock, the order "
"of precedence remains the same:"
msgstr ""

#: ../../library/unittest.mock.rst:2948
msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will "
"not cause a value to be obtained from the successors. Instead, "
"``StopIteration`` exception is raised."
msgstr ""

#~ msgid ""
#~ "This can be useful where you want"
#~ " to make a series of assertions "
#~ "that reuse the same object. Note "
#~ "that :meth:`reset_mock` *doesn't* clear the"
#~ " return value, :attr:`side_effect` or any"
#~ " child attributes you have set using"
#~ " normal assignment by default. In "
#~ "case you want to reset *return_value*"
#~ " or :attr:`side_effect`, then pass the "
#~ "corresponding parameter as ``True``. Child "
#~ "mocks and the return value mock "
#~ "(if any) are reset as well."
#~ msgstr ""
#~ "같은 객체를 재사용하는 일련의 어서션을 만들려는 경우에 "
#~ "유용할 수 있습니다. :meth:`reset_mock`\\은 기본적으로 "
#~ "정규 대입을 사용하여 설정한 반환 값, "
#~ ":attr:`side_effect` 또는 모든 자식 어트리뷰트를 지우지"
#~ " *않음*\\에 유의하십시오. *return_value*\\나 "
#~ ":attr:`side_effect`\\를 재설정하려면, 해당 매개 변수를 "
#~ "``True``\\로 전달하십시오. 자식 모의 객체와 반환 값"
#~ " 모의 객체(있다면)도 재설정됩니다."

#~ msgid "*return_value*, and :attr:`side_effect` are keyword only argument."
#~ msgstr "*return_value*\\와 :attr:`side_effect`\\는 키워드 전용 인자입니다."

#~ msgid "``__getformat__`` and ``__setformat__``"
#~ msgstr "``__getformat__``\\과 ``__setformat__``"

#~ msgid ""
#~ ":class:`Mock` is a very powerful and "
#~ "flexible object, but it suffers from "
#~ "two flaws when used to mock out"
#~ " objects from a system under test."
#~ " One of these flaws is specific "
#~ "to the :class:`Mock` api and the "
#~ "other is a more general problem "
#~ "with using mock objects."
#~ msgstr ""
#~ ":class:`Mock`\\은 매우 강력하고 유연한 객체이지만, 테스트"
#~ " 대상 시스템에서 객체를 모킹할 때 두 가지 "
#~ "결함이 있습니다. 이러한 결함 중 하나는 "
#~ ":class:`Mock` api에만 해당하며 다른 하나는 모의 "
#~ "객체 사용에 대한 보다 일반적인 문제입니다."

#~ msgid ""
#~ "First the problem specific to "
#~ ":class:`Mock`. :class:`Mock` has two assert"
#~ " methods that are extremely handy: "
#~ ":meth:`~Mock.assert_called_with` and "
#~ ":meth:`~Mock.assert_called_once_with`."
#~ msgstr ""
#~ "먼저 :class:`Mock`\\과 관련된 문제입니다. "
#~ ":class:`Mock`\\에는 :meth:`~Mock.assert_called_with`\\와 "
#~ ":meth:`~Mock.assert_called_once_with`\\라는 매우 편리한 두"
#~ " 가지 어서션 메서드가 있습니다."

#~ msgid ""
#~ "Because mocks auto-create attributes on"
#~ " demand, and allow you to call "
#~ "them with arbitrary arguments, if you"
#~ " misspell one of these assert methods"
#~ " then your assertion is gone:"
#~ msgstr ""
#~ "모의 객체는 요청 시 어트리뷰트를 자동 생성하고, "
#~ "임의의 인자로 어트리뷰트를 호출하도록 허락합니다, 이러한 "
#~ "어서트 메서드 중 하나의 철자를 틀리면 어서션이 "
#~ "사라집니다:"

#~ msgid "Your tests can pass silently and incorrectly because of the typo."
#~ msgstr "오타로 인해 테스트가 조용히 잘못 통과할 수 있습니다."

