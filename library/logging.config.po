# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/logging.config.rst:2
#, fuzzy
msgid ":mod:`!logging.config` --- Logging configuration"
msgstr ":mod:`logging.config` --- 로깅 구성"

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**소스 코드:** :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
msgid "This page contains only reference information. For tutorials, please see"
msgstr "이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`기초 자습서 <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`고급 자습서 <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`로깅 요리책 <logging-cookbook>`"

#: ../../library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "이 절에서는 logging 모듈을 구성하기 위한 API에 관해 설명합니다."

#: ../../library/logging.config.rst:28
msgid "Configuration functions"
msgstr "구성 함수"

#: ../../library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in"
" the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to "
"the main API (defined in :mod:`logging` itself) and defining handlers "
"which are declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"다음 함수는 logging 모듈을 구성합니다. :mod:`logging.config` 모듈에 있습니다. 사용은 선택 사항입니다 "
"--- 이 함수들을 사용하거나 (:mod:`logging` 자체에서 정의된) 주 API를 호출하고 :mod:`logging`\\이나"
" :mod:`logging.handlers`\\에서 선언된 처리기를 정의해서 logging 모듈을 구성할 수 있습니다."

#: ../../library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"딕셔너리로 로깅 구성을 받습니다. 이 딕셔너리의 내용은 아래의 :ref:`logging-config-dictschema`\\에 "
"설명되어 있습니다."

#: ../../library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise"
" a :exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or "
":exc:`ImportError` with a suitably descriptive message.  The following is"
" a (possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"구성 중에 에러를 만나면, 이 함수는 적절하게 설명하는 메시지와 함께 :exc:`ValueError`, "
":exc:`TypeError`, :exc:`AttributeError` 또는 :exc:`ImportError`\\를 발생시킵니다. "
"다음은 에러를 발생시킬 수 있는 (불완전한) 조건 목록입니다:"

#: ../../library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding "
"to an actual logging level."
msgstr "문자열이 아니거나 실제 로깅 수준과 일치하지 않는 문자열인 ``level``."

#: ../../library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "불리언이 아닌 ``propagate`` 값."

#: ../../library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "해당 대상이 없는 id."

#: ../../library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr "증분(incremental) 호출 중에 발견된 존재하지 않는 처리기 id."

#: ../../library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "잘못된 로거 이름."

#: ../../library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "결정할 수 없는 내부나 외부 객체."

#: ../../library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a "
":meth:`configure` method.  The :mod:`logging.config` module has a "
"callable attribute :attr:`dictConfigClass` which is initially set to "
":class:`DictConfigurator`. You can replace the value of "
":attr:`dictConfigClass` with a suitable implementation of your own."
msgstr ""
"구문 분석은 :class:`DictConfigurator` 클래스에 의해 수행되며, 생성자로는 구성에 사용되는 딕셔너리가 전달되고,"
" 객체는 :meth:`configure` 메서드를 가집니다. :mod:`logging.config` 모듈에는 초기에 "
":class:`DictConfigurator`\\로 설정된 콜러블 어트리뷰트 :attr:`dictConfigClass`\\가 "
"있습니다. 여러분 자신의 적절한 구현으로 :attr:`dictConfigClass`\\의 값을 바꿀 수 있습니다."

#: ../../library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig`\\는 :attr:`dictConfigClass`\\를 호출해서 지정된 딕셔너리를 전달한 다음, "
"반환된 객체의 :meth:`configure` 메서드를 호출하여 구성을 적용합니다::"

#: ../../library/logging.config.rst:68
msgid ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"
msgstr ""

#: ../../library/logging.config.rst:71
#, fuzzy
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure`"
" call. :attr:`dictConfigClass` would be bound to this new subclass, and "
"then :func:`dictConfig` could be called exactly as in the default, "
"uncustomized state."
msgstr ""
"예를 들어, :class:`DictConfigurator`\\의 서브 클래스는 자체 :meth:`__init__()`\\에서 "
"``DictConfigurator.__init__()``\\를 호출한 다음, 후속 :meth:`configure` 호출에서 사용할 "
"수 있는 사용자 정의 접두사를 설정할 수 있습니다. :attr:`dictConfigClass`\\는 이 새 서브 클래스에 연결되고,"
" :func:`dictConfig`\\는 기본, 사용자 정의되지 않은 상태에서와 똑같이 호출될 수 있습니다."

#: ../../library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file."
" The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an "
"application, allowing an end user to select from various pre-canned "
"configurations (if the developer provides a mechanism to present the "
"choices and load the chosen configuration)."
msgstr ""
":mod:`configparser`\\-형식 파일에서 로깅 구성을 읽습니다. 파일 형식은 :ref:`logging-config-"
"fileformat`\\에 설명된 것과 같아야 합니다. 이 함수는 응용 프로그램에서 여러 번 호출 할 수 있어서, 최종 사용자가 "
"여러 가지 미리 준비된 구성 중에서 선택할 수 있도록 합니다 (개발자가 선택 사항을 표시하고 선택한 구성을 로드하는 메커니즘을 "
"제공한다면)."

#: ../../library/logging.config.rst:90
msgid ""
"It will raise :exc:`FileNotFoundError` if the file doesn't exist and "
":exc:`RuntimeError` if the file is invalid or empty."
msgstr ""

#: ../../library/logging.config.rst
msgid "Parameters"
msgstr "매개 변수"

#: ../../library/logging.config.rst:94
#, fuzzy
msgid ""
"A filename, or a file-like object, or an instance derived from "
":class:`~configparser.RawConfigParser`. If a "
":class:`!RawConfigParser`-derived instance is passed, it is used as is. "
"Otherwise, a :class:`~configparser.ConfigParser` is instantiated, and the"
" configuration read by it from the object passed in ``fname``. If that "
"has a :meth:`readline` method, it is assumed to be a file-like object and"
" read using :meth:`~configparser.ConfigParser.read_file`; otherwise, it "
"is assumed to be a filename and passed to "
":meth:`~configparser.ConfigParser.read`."
msgstr ""
"파일명, 또는 파일류 객체, 또는 :class:`~configparser.RawConfigParser`\\에서 파생된 인스턴스. "
"``RawConfigParser``-파생 인스턴스가 전달되면, 그대로 사용됩니다. 그렇지 않으면, "
":class:`~configparser.Configparser`\\의 인스턴스가 만들어지고, 이것으로 ``fname``\\으로 "
"전달된 객체로부터 구성을 읽습니다. :meth:`readline` 메서드가 있으면, 파일류 객체라고 가정하고, "
":meth:`~configparser.ConfigParser.read_file`\\을 사용하여 읽습니다; 그렇지 않으면, 파일명으로"
" 간주하고 :meth:`~configparser.ConfigParser.read`\\로 전달됩니다."

#: ../../library/logging.config.rst:106
#, fuzzy
msgid ""
"Defaults to be passed to the :class:`!ConfigParser` can be specified in "
"this argument."
msgstr "ConfigParser로 전달되는 기본값을 이 인자로 지정할 수 있습니다."

#: ../../library/logging.config.rst:109
msgid ""
"If specified as ``False``, loggers which exist when this call is made are"
" left enabled. The default is ``True`` because this enables old behaviour"
" in a backward-compatible way. This behaviour is to disable any existing "
"non-root loggers unless they or their ancestors are explicitly named in "
"the logging configuration."
msgstr ""
"``False``\\로 지정되면, 이 호출이 이루어졌을 때 존재하는 로거는 활성화된 상태로 남습니다. 기본값은 "
"``True``\\이므로, 과거 호환성을 유지하도록 이전 동작을 활성화합니다. 이 동작은 이미 존재하는 비 루트 로거를 그들이나 "
"그들의 조상이 로깅 구성에서 명시적으로 명명되지 않으면 비활성화하는 것입니다."

#: ../../library/logging.config.rst:118
msgid "The encoding used to open file when *fname* is filename."
msgstr ""

#: ../../library/logging.config.rst:120
#, fuzzy
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   "
"now accepted as a value for ``fname``. This facilitates:"
msgstr ""
":class:`~configparser.RawConfigParser`\\의 서브 클래스의 인스턴스가 이제 ``fname``\\에 "
"대한 값으로 허용됩니다. 이것은 다음을 쉽게 합니다:"

#: ../../library/logging.config.rst:124
msgid ""
"Use of a configuration file where logging configuration is just part of "
"the overall application configuration."
msgstr "로깅 구성이 전체 응용 프로그램 구성의 일부인 구성 파일의 사용."

#: ../../library/logging.config.rst:126
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of "
"the runtime environment) before being passed to ``fileConfig``."
msgstr ""
"파일에서 읽어 들인 다음 ``fileConfig``\\로 전달되기 전에 사용하는 응용 프로그램이 (예를 들어, 명령 줄 매개 변수나"
" 실행 시간 환경의 다른 측면에 기반하여) 수정하는 구성의 사용."

#: ../../library/logging.config.rst:130
msgid "Added the *encoding* parameter."
msgstr ""

#: ../../library/logging.config.rst:133
msgid ""
"An exception will be thrown if the provided file doesn't exist or is "
"invalid or empty."
msgstr ""

#: ../../library/logging.config.rst:139
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default "
":const:`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will"
" be sent as a file suitable for processing by :func:`dictConfig` or "
":func:`fileConfig`. Returns a :class:`~threading.Thread` instance on "
"which you can call :meth:`~threading.Thread.start` to start the server, "
"and which you can :meth:`~threading.Thread.join` when appropriate. To "
"stop the server, call :func:`stopListening`."
msgstr ""
"지정된 포트에서 소켓 서버를 시작하고, 새 구성을 수신 대기합니다. 포트를 지정하지 않으면, 모듈의 기본 "
":const:`DEFAULT_LOGGING_CONFIG_PORT`\\가 사용됩니다. 로깅 구성은 "
":func:`dictConfig`\\나 :func:`fileConfig`\\로 처리하기에 적합한 파일로 전송됩니다. 서버를 시작하기"
" 위해 :meth:`~threading.Thread.start`\\를 호출할 수 있는 "
":class:`~threading.Thread` 인스턴스를 반환하고, 적절할 때 "
":meth:`~threading.Thread.join`\\할 수 있습니다. 서버를 중지하려면, "
":func:`stopListening`\\을 호출하십시오."

#: ../../library/logging.config.rst:148
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform "
"signature verification and/or decryption. The ``verify`` callable is "
"called with a single argument - the bytes received across the socket - "
"and should return the bytes to be processed, or ``None`` to indicate that"
" the bytes should be discarded. The returned bytes could be the same as "
"the passed in bytes (e.g. when only verification is done), or they could "
"be completely different (perhaps if decryption were performed)."
msgstr ""
"``verify`` 인자가 지정되면, 소켓을 통해 수신된 바이트열이 유효하고 처리되어야 하는지를 확인하는 콜러블이어야 합니다. "
"소켓을 통해 전송되는 것을 암호화 및/또는 서명하고, ``verify`` 콜러블이 서명 확인 및/또는 암호 해독을 수행할 수 "
"있습니다. ``verify`` 콜러블은 단일 인자(소켓을 통해 수신된 바이트열)로 호출되며, 처리할 바이트열이나 바이트열을 버려야 "
"함을 나타내기 위해 ``None``\\을 반환합니다. 반환된 바이트열은 전달된 바이트열과 같을 수 있고 (예를 들어, 확인만 수행될"
" 때), 또는 완전히 다를 수 있습니다 (아마도 암호 해독이 수행될 때)."

#: ../../library/logging.config.rst:159
msgid ""
"To send a configuration to the socket, read in the configuration file and"
" send it to the socket as a sequence of bytes preceded by a four-byte "
"length string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"소켓으로 구성을 보내려면, 구성 파일을 읽어서 소켓에 ``struct.pack('>L', n)``\\를 사용하여 바이너리로 만든 "
"4바이트의 길이를 앞에 붙인 바이트 시퀀스를 보냅니다."

#: ../../library/logging.config.rst:167
#, fuzzy
msgid ""
"Because portions of the configuration are passed through :func:`eval`, "
"use of this function may open its users to a security risk. While the "
"function only binds to a socket on ``localhost``, and so does not accept "
"connections from remote machines, there are scenarios where untrusted "
"code could be run under the account of the process which calls "
":func:`listen`. Specifically, if the process calling :func:`listen` runs "
"on a multi-user machine where users cannot trust each other, then a "
"malicious user could arrange to run essentially arbitrary code in a "
"victim user's process, simply by connecting to the victim's "
":func:`listen` socket and sending a configuration which runs whatever "
"code the attacker wants to have executed in the victim's process. This is"
" especially easy to do if the default port is used, but not hard even if "
"a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised "
"configurations from being applied."
msgstr ""
"구성 일부가 :func:`eval`\\로 전달되므로, 이 함수를 사용하면 사용자를 보안 위험에 노출할 수 있습니다. 이 함수는 "
"소켓을 ``localhost``\\에만 바인드하고, 원격 기계의 연결은 허용하지 않지만, 신뢰할 수 없는 코드가 "
":func:`listen`\\을 호출하는 프로세스의 계정으로 실행될 수 있는 시나리오가 있습니다. 특히, "
":func:`listen`\\을 호출하는 프로세스가 사용자가 서로를 신뢰할 수 없는 다중 사용자 시스템에서 실행되는 경우, 악의적인"
" 사용자는 피해자의 :func:`listen` 소켓에 연결하여 공격자가 피해자의 프로세스에서 실행하고자 하는 코드를 실행하는 구성을"
" 보내는 것만으로도, 피해 사용자의 프로세스에서 사실상 임의의 코드를 실행할 수 있습니다. 이것은 기본 포트를 사용하는 경우 특히 "
"쉽게 수행할 수 있지만, 다른 포트가 사용되는 경우에도 어렵지는 않습니다. 이러한 일이 발생할 위험을 피하려면, "
":func:`listen`\\에 ``verify`` 인자를 사용하여 인식되지 않은 구성이 적용되지 않도록 하십시오."

#: ../../library/logging.config.rst:183
msgid "The ``verify`` argument was added."
msgstr "``verify`` 인자가 추가되었습니다."

#: ../../library/logging.config.rst:188
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the "
"configuration, which will use :func:`dictConfig` for configuration. This "
"method allows you to specify ``disable_existing_loggers`` as ``False`` in"
" the configuration you send."
msgstr ""
"리스너에 기존 로거를 비활성화하지 않는 구성을 보내려면, :func:`dictConfig`\\를 사용하도록 구성에 JSON 형식을 "
"사용해야 합니다. 이 방법은 보내는 구성에서 ``disable_existing_loggers``\\를 ``False``\\로 지정할"
" 수 있도록 합니다."

#: ../../library/logging.config.rst:197
msgid ""
"Stops the listening server which was created with a call to "
":func:`listen`. This is typically called before calling :meth:`join` on "
"the return value from :func:`listen`."
msgstr ""
":func:`listen`\\에 대한 호출로 만들어진 리스닝 서버를 중지합니다. 이것은 일반적으로 :func:`listen`\\의 "
"반환 값에 대해 :meth:`join`\\을 호출하기 전에 호출됩니다."

#: ../../library/logging.config.rst:203
#, fuzzy
msgid "Security considerations"
msgstr "객체 연결"

#: ../../library/logging.config.rst:205
msgid ""
"The logging configuration functionality tries to offer convenience, and "
"in part this is done by offering the ability to convert text in "
"configuration files into Python objects used in logging configuration - "
"for example, as described in :ref:`logging-config-dict-userdef`. However,"
" these same mechanisms (importing callables from user-defined modules and"
" calling them with parameters from the configuration) could be used to "
"invoke any code you like, and for this reason you should treat "
"configuration files from untrusted sources with *extreme caution* and "
"satisfy yourself that nothing bad can happen if you load them, before "
"actually loading them."
msgstr ""

#: ../../library/logging.config.rst:219
msgid "Configuration dictionary schema"
msgstr "구성 딕셔너리 스키마"

#: ../../library/logging.config.rst:221
msgid ""
"Describing a logging configuration requires listing the various objects "
"to create and the connections between them; for example, you may create a"
" handler named 'console' and then say that the logger named 'startup' "
"will send its messages to the 'console' handler. These objects aren't "
"limited to those provided by the :mod:`logging` module because you might "
"write your own formatter or handler class. The parameters to these "
"classes may also need to include external objects such as ``sys.stderr``."
"  The syntax for describing these objects and connections is defined in "
":ref:`logging-config-dict-connections` below."
msgstr ""
"로깅 구성을 기술하려면 만들려는 다양한 객체와 그들 간의 연결을 나열해야 합니다; 예를 들어, 'console'이라는 처리기를 만든"
" 다음 'startup'이라는 로거가 'console' 처리기에 메시지를 보낼 것이라고 말할 수 있습니다. 사용자 자신의 포매터나 "
"처리기 클래스를 작성할 수 있으므로, 이러한 객체가 :mod:`logging` 모듈에서 제공하는 객체로만 제한되지는 않습니다. "
"이러한 클래스의 매개 변수는 ``sys.stderr``\\과 같은 외부 객체를 포함할 수도 있습니다. 이러한 객체와 연결을 기술하는"
" 문법은 아래의 :ref:`logging-config-dict-connections`\\에 정의되어 있습니다."

#: ../../library/logging.config.rst:233
msgid "Dictionary Schema Details"
msgstr "딕셔너리 스키마 세부사항"

#: ../../library/logging.config.rst:235
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following "
"keys:"
msgstr ":func:`dictConfig`\\에 전달되는 딕셔너리에는 반드시 다음 키가 있어야 합니다:"

#: ../../library/logging.config.rst:238
msgid ""
"*version* - to be set to an integer value representing the schema "
"version.  The only valid value at present is 1, but having this key "
"allows the schema to evolve while still preserving backwards "
"compatibility."
msgstr ""
"*version* - 스키마 버전을 나타내는 정숫값으로 설정됩니다. 현재 유효한 유일한 값은 1이지만, 이 키를 사용하면 과거 "
"호환성을 유지하면서 스키마를 발전시킬 수 있습니다."

#: ../../library/logging.config.rst:243
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref"
":`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"다른 모든 키는 선택 사항이지만, 있으면 아래에 설명된 대로 해석됩니다. 아래에서 '구성 딕셔너리(configuring "
"dict)'가 언급되는 모든 경우에, 특수한 ``'()'`` 키를 검사해서 사용자 정의 인스턴스화가 필요한지를 확인합니다. 있다면,"
" 아래의 :ref:`logging-config-dict-userdef`\\에 설명된 메커니즘을 사용하여 인스턴스를 만듭니다; 그렇지"
" 않다면, 어떤 인스턴스를 만들지를 결정하는데 문맥이 사용됩니다."

#: ../../library/logging.config.rst:252
msgid ""
"*formatters* - the corresponding value will be a dict in which each key "
"is a formatter id and each value is a dict describing how to configure "
"the corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - 해당 값은 딕셔너리인데, 각 키는 포매터 id이고, 각 값은 해당 "
":class:`~logging.Formatter` 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다."

#: ../../library/logging.config.rst:256
#, fuzzy
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a "
":class:`~logging.Formatter` object:"
msgstr ""
"구성 딕셔너리는 키 ``name``\\(기본값은 빈 문자열)으로 검색되며, 이는 :class:`logging.Filter` "
"인스턴스를 만드는 데 사용됩니다."

#: ../../library/logging.config.rst:260
msgid "``format``"
msgstr ""

#: ../../library/logging.config.rst:261
msgid "``datefmt``"
msgstr ""

#: ../../library/logging.config.rst:262
msgid "``style``"
msgstr ""

#: ../../library/logging.config.rst:263
msgid "``validate`` (since version >=3.8)"
msgstr ""

#: ../../library/logging.config.rst:264
msgid "``defaults`` (since version >=3.12)"
msgstr ""

#: ../../library/logging.config.rst:266
#, fuzzy
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as"
" a dotted module and class name).  The instantiation arguments are as for"
" :class:`~logging.Formatter`, thus this key is most useful for "
"instantiating a customised subclass of :class:`~logging.Formatter`.  For "
"example, the alternative class might present exception tracebacks in an "
"expanded or condensed format.  If your formatter requires different or "
"extra configuration keys, you should use :ref:`logging-config-dict-"
"userdef`."
msgstr ""
"``class`` 항목은 선택적입니다. 포매터 클래스의 이름을 나타냅니다 (점으로 구분된 모듈과 클래스 이름). 이 옵션은 "
":class:`~logging.Formatter` 서브 클래스를 인스턴스화하는 데 유용합니다. "
":class:`~logging.Formatter`\\의 서브 클래스는 확장 또는 압축 형식으로 예외 트레이스백을 표시할 수 "
"있습니다."

#: ../../library/logging.config.rst:275
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a"
" filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* - 해당 값은 딕셔너리인데, 각 키가 필터 id이고 각 값은 해당 Filter 인스턴스를 구성하는 방법을 설명하는"
" 딕셔너리입니다."

#: ../../library/logging.config.rst:279
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"구성 딕셔너리는 키 ``name``\\(기본값은 빈 문자열)으로 검색되며, 이는 :class:`logging.Filter` "
"인스턴스를 만드는 데 사용됩니다."

#: ../../library/logging.config.rst:283
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is "
"a handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* - 해당 값은 딕셔너리인데, 각 키가 처리기 id이고 각 값은 해당 Handler 인스턴스를 구성하는 방법을 "
"설명하는 딕셔너리입니다."

#: ../../library/logging.config.rst:287 ../../library/logging.config.rst:332
msgid "The configuring dict is searched for the following keys:"
msgstr "구성 딕셔너리는 다음 키에서 검색합니다:"

#: ../../library/logging.config.rst:289
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr "``class`` (필수). 이것은 처리기 클래스의 완전히 정규화된 이름입니다."

#: ../../library/logging.config.rst:292
msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (선택). 처리기의 수준."

#: ../../library/logging.config.rst:294
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``formatter`` (선택). 이 처리기의 포매터의 id."

#: ../../library/logging.config.rst:297
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr "``filters`` (선택). 이 처리기의 필터의 id의 리스트."

#: ../../library/logging.config.rst:300 ../../library/logging.config.rst:341
msgid "``filters`` can take filter instances in addition to ids."
msgstr ""

#: ../../library/logging.config.rst:303
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's"
" constructor.  For example, given the snippet:"
msgstr "모든 *다른* 키는, 처리기의 생성자에 키워드 인자로 전달됩니다. 예를 들어, 다음과 같이 주어진 조각에서:"

#: ../../library/logging.config.rst:306
msgid ""
"handlers:\n"
"  console:\n"
"    class : logging.StreamHandler\n"
"    formatter: brief\n"
"    level   : INFO\n"
"    filters: [allow_foo]\n"
"    stream  : ext://sys.stdout\n"
"  file:\n"
"    class : logging.handlers.RotatingFileHandler\n"
"    formatter: precise\n"
"    filename: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"
msgstr ""

#: ../../library/logging.config.rst:322
msgid ""
"the handler with id ``console`` is instantiated as a "
":class:`logging.StreamHandler`, using ``sys.stdout`` as the underlying "
"stream.  The handler with id ``file`` is instantiated as a "
":class:`logging.handlers.RotatingFileHandler` with the keyword arguments "
"``filename='logconfig.log', maxBytes=1024, backupCount=3``."
msgstr ""
"id가 ``console`` 인 처리기는 ``sys.stdout``\\를 하부 스트림으로 사용하는 "
":class:`logging.StreamHandler`\\로 인스턴스가 만들어집니다. id가 ``file`` 인 처리기는 키워드 "
"인자 ``filename='logconfig.log', maxBytes=1024, backupCount=3``\\를 사용하여 "
":class:`logging.handlers.RotatingFileHandler`\\로 인스턴스가 만들어집니다."

#: ../../library/logging.config.rst:328
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a"
" logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* - 해당 값은 딕셔너리인데, 각 키가 로거 이름이고 각 값은 해당 Logger 인스턴스를 구성하는 방법을 설명하는"
" 딕셔너리입니다."

#: ../../library/logging.config.rst:334
msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (선택). 로거의 수준."

#: ../../library/logging.config.rst:336
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``propagate`` (선택). 로거의 전파(propagation) 설정."

#: ../../library/logging.config.rst:338
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr "``filters`` (선택). 이 로거의 필터의 id의 리스트"

#: ../../library/logging.config.rst:344
msgid "``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr "``handlers`` (선택). 이 로거의 처리기의 id의 리스트."

#: ../../library/logging.config.rst:347
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr "지정된 로거는 지정된 수준, 전파, 필터와 처리기에 따라 구성됩니다."

#: ../../library/logging.config.rst:350
msgid ""
"*root* - this will be the configuration for the root logger. Processing "
"of the configuration will be as for any logger, except that the "
"``propagate`` setting will not be applicable."
msgstr ""
"*root* - 루트 로거에 대한 구성입니다. ``propagate`` 설정을 적용할 수 없다는 점을 제외하고 구성 처리는 모든 "
"로거와 같습니다."

#: ../../library/logging.config.rst:354
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing "
":func:`fileConfig` API."
msgstr ""
"*incremental* - 구성을 기존 구성의 증분으로 해석할지 여부. 이 값의 기본값은 ``False``\\이며, 이는 지정된 "
"구성이 기존 구성을 기존 :func:`fileConfig` API에서 사용된 것과 같은 의미로 대체 함을 뜻합니다."

#: ../../library/logging.config.rst:360
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"지정된 값이 ``True``\\이면, :ref:`logging-config-dict-incremental` 절에서 설명하는 대로 "
"구성이 처리됩니다."

#: ../../library/logging.config.rst:363
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to"
" be disabled. This setting mirrors the parameter of the same name in "
":func:`fileConfig`. If absent, this parameter defaults to ``True``. This "
"value is ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - 기존의 루트가 아닌 로거를 비활성화할지 여부. 이 설정은 "
":func:`fileConfig`\\의 같은 이름의 매개 변수를 반영합니다. 없으면, 이 매개 변수의 기본값은 "
"``True``\\입니다. *incremental*\\이 ``True``\\이면 이 값은 무시됩니다."

#: ../../library/logging.config.rst:371
msgid "Incremental Configuration"
msgstr "증분 구성"

#: ../../library/logging.config.rst:373
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and "
"formatters are anonymous, once a configuration is set up, it is not "
"possible to refer to such anonymous objects when augmenting a "
"configuration."
msgstr ""
"증분 구성에 완벽한 유연성을 제공하기는 어렵습니다. 예를 들어, 필터와 포매터와 같은 객체는 익명이므로, 일단 구성이 설정되면, "
"이러한 익명 객체를 참조하여 구성을 보강할 수 없습니다."

#: ../../library/logging.config.rst:379
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once "
"a configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, "
"propagation flags).  Changing the object graph arbitrarily in a safe way "
"is problematic in a multi-threaded environment; while not impossible, the"
" benefits are not worth the complexity it adds to the implementation."
msgstr ""
"또한, 일단 구성이 설정되면, 실행 시간에 로거, 처리기, 필터, 포매터의 객체 그래프를 임의로 변경해야 할 강력한 사례는 "
"없습니다; 로거와 처리기의 상세도는 단지 수준(과, loggers에서는 전파 플래그)을 설정하여 제어할 수 있습니다. 객체 그래프를"
" 임의로 안전하게 변경하는 것은 다중 스레드 환경에서 문제가 됩니다; 불가능하지는 않지만, 구현에 추가되는 복잡성을 상쇄할만한 "
"가치가 없습니다."

#: ../../library/logging.config.rst:388
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and"
" is ``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the"
" ``loggers`` and ``root`` entries."
msgstr ""
"따라서, 구성 딕셔너리의 ``incremental`` 키가 있고 ``True``\\이면, 시스템은 ``formatters``\\와 "
"``filters`` 항목을 완전히 무시하고 ``handlers`` 항목의 ``level`` 설정과 ``loggers``\\와 "
"``root`` 항목의 ``level``\\과 ``propagate`` 설정만 처리합니다."

#: ../../library/logging.config.rst:394
msgid ""
"Using a value in the configuration dict lets configurations to be sent "
"over the wire as pickled dicts to a socket listener. Thus, the logging "
"verbosity of a long-running application can be altered over time with no "
"need to stop and restart the application."
msgstr ""
"구성 딕셔너리의 값을 사용하면 구성을 피클 된 딕셔너리의 형태로 네트워크를 통해 소켓 리스너로 전송할 수 있습니다. 따라서, 장기 "
"실행 응용 프로그램의 로깅 상세도는 응용 프로그램을 중지하고 다시 시작할 필요 없이 도중에 변경될 수 있습니다."

#: ../../library/logging.config.rst:402
msgid "Object connections"
msgstr "객체 연결"

#: ../../library/logging.config.rst:404
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object "
"graph.  Thus, the schema needs to represent connections between the "
"objects.  For example, say that, once configured, a particular logger has"
" attached to it a particular handler.  For the purposes of this "
"discussion, we can say that the logger represents the source, and the "
"handler the destination, of a connection between the two.  Of course in "
"the configured objects this is represented by the logger holding a "
"reference to the handler.  In the configuration dict, this is done by "
"giving each destination object an id which identifies it unambiguously, "
"and then using the id in the source object's configuration to indicate "
"that a connection exists between the source and the destination object "
"with that id."
msgstr ""
"스키마는 객체 그래프에서 서로 연결된 로깅 객체 집합(로거, 처리기, 포매터, 필터)을 기술합니다. 따라서, 스키마는 객체 간의 "
"연결을 표현할 필요가 있습니다. 예를 들어, 일단 구성되면, 특정 로거가 특정 처리기에 연결된다고 합시다. 이 토론의 목적을 위해,"
" 둘 간의 연결에서 로거는 소스를, 처리기는 대상(destination)을 나타낸다고 할 수 있습니다. 물론 구성된 객체에서 이것은"
" 처리기에 대한 참조를 갖는 로거로 표현됩니다. 구성 딕셔너리에서, 각 대상 객체에 명확하게 식별하는 id를 부여한 다음, 소스 "
"객체의 구성에서 그 id를 사용하여, 소스와 그 id를 갖는 대상 객체 사이에 연결이 있음을 나타냅니다."

#: ../../library/logging.config.rst:418
msgid "So, for example, consider the following YAML snippet:"
msgstr "그래서, 예를 들어, 다음 YAML 조각을 고려해보십시오:"

#: ../../library/logging.config.rst:420
msgid ""
"formatters:\n"
"  brief:\n"
"    # configuration for formatter with id 'brief' goes here\n"
"  precise:\n"
"    # configuration for formatter with id 'precise' goes here\n"
"handlers:\n"
"  h1: #This is an id\n"
"   # configuration of handler with id 'h1' goes here\n"
"   formatter: brief\n"
"  h2: #This is another id\n"
"   # configuration of handler with id 'h2' goes here\n"
"   formatter: precise\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # other configuration for logger 'foo.bar.baz'\n"
"    handlers: [h1, h2]"
msgstr ""

#: ../../library/logging.config.rst:439
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr "(참고: 딕셔너리에 해당하는 파이썬 소스 형식보다 약간 더 읽기 쉬우므로 여기에서 YAML을 사용했습니다.)"

#: ../../library/logging.config.rst:442
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. "
"``foo.bar.baz``.  The ids for Formatters and Filters can be any string "
"value (such as ``brief``, ``precise`` above) and they are transient, in "
"that they are only meaningful for processing the configuration dictionary"
" and used to determine connections between objects, and are not persisted"
" anywhere when the configuration call is complete."
msgstr ""
"로거의 id는 로거로의 참조를 얻기 위해서 프로그램적으로 사용되는 로거 이름입니다, 예를 들어 ``foo.bar.baz``. "
"포매터와 필터의 id는 임의의 문자열 값(가령 위의 ``brief``, ``precise``)이 될 수 있으며, 일시적이므로 구성 "
"딕셔너리 처리에만 의미가 있고 객체 간의 연결을 결정하는 데 사용되며, 구성 호출이 완료된 후에는 어디에도 남아있지 않습니다."

#: ../../library/logging.config.rst:450
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have"
" two handlers attached to it, which are described by the handler ids "
"``h1`` and ``h2``. The formatter for ``h1`` is that described by id "
"``brief``, and the formatter for ``h2`` is that described by id "
"``precise``."
msgstr ""
"위의 조각은 ``foo.bar.baz``\\라는 로거에 두 개의 처리기가 연결되어 있어야 하며, 이 처리기들은 처리기 id "
"``h1``\\과 ``h2``\\에 의해 기술됩니다. ``h1``\\의 포매터는 id ``brief``\\로 기술되는 것이고, "
"``h2``\\의 포매터는 id ``precise``\\로 기술되는 것입니다."

#: ../../library/logging.config.rst:460
msgid "User-defined objects"
msgstr "사용자 정의 객체"

#: ../../library/logging.config.rst:462
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"스키마는 처리기, 필터 및 포매터에 대한 사용자 정의 객체를 지원합니다. (로거에는 인스턴스마다 다른 형이 필요하지 않으므로, 이 "
"구성 스키마에는 사용자 정의 로거 클래스에 대한 지원이 없습니다.)"

#: ../../library/logging.config.rst:467
msgid ""
"Objects to be configured are described by dictionaries which detail their"
" configuration.  In some places, the logging system will be able to infer"
" from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which "
"is called with a configuration dictionary and which returns the "
"instantiated object. This is signalled by an absolute import path to the "
"factory being made available under the special key ``'()'``.  Here's a "
"concrete example:"
msgstr ""
"구성할 객체는 구성을 자세히 설명하는 딕셔너리로 시술됩니다. 어떤 곳에서는, 로깅 시스템이 객체를 어떻게 인스턴스화할지 문맥으로부터"
" 추측할 수 있지만, 사용자 정의 객체를 인스턴스화 해야 할 때, 시스템은 이를 수행하는 방법을 알 수 없습니다. 사용자 정의 객체"
" 인스턴스화를 위한 완벽한 유연성을 제공하기 위해, 사용자는 '팩토리'를 제공해야 하는데, 구성 딕셔너리로 호출되고 인스턴스화 된 "
"객체를 반환하는 콜러블입니다. 이것은 특수키 ``'()'``\\로 제공되는 팩토리로의 절대적 임포트 경로로 표시됩니다. 다음은 "
"구체적인 예입니다:"

#: ../../library/logging.config.rst:479
#, python-format
msgid ""
"formatters:\n"
"  brief:\n"
"    format: '%(message)s'\n"
"  default:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      answer: 42"
msgstr ""

#: ../../library/logging.config.rst:493
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a "
":class:`logging.Formatter` initialized with those two format strings.  "
"Shown in Python source form, the ``brief`` and ``default`` formatters "
"have configuration sub-dictionaries::"
msgstr ""
"위의 YAML 조각은 세 가지 포매터를 정의합니다. 첫 번째(id ``brief``)\\는 지정된 포맷 문자열을 갖는 표준 "
":class:`logging.Formatter` 인스턴스입니다. 두 번째(id ``default``)\\는 더 긴 포맷을 가지며 "
"명시적으로 시간 포맷을 정의하기도 하고, 이 두 포맷 문자열로 초기화된 :class:`logging.Formatter`\\가 "
"됩니다. 파이썬 소스 형식으로 표시하면, ``brief``\\와 ``default`` 포매터는 각각 다음과 같은 구성 서브 "
"딕셔너리를 갖습니다::"

#: ../../library/logging.config.rst:501
#, python-brace-format, python-format
msgid ""
"{\n"
"  'format' : '%(message)s'\n"
"}"
msgstr ""

#: ../../library/logging.config.rst:505
msgid "and::"
msgstr "그리고::"

#: ../../library/logging.config.rst:507
#, python-brace-format, python-format
msgid ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"
msgstr ""

#: ../../library/logging.config.rst:512
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``,"
" is::"
msgstr ""
"그리고, 이 딕셔너리에는 특수키 ``'()'``\\가 포함되어 있지 않으므로, 문맥에서 인스턴스가 추론됩니다: 결과적으로, 표준 "
":class:`logging.Formatter` 인스턴스가 만들어집니다. 세 번째 포매터(id ``custom``)에 대한 구성 "
"서브 딕셔너리는 다음과 같습니다::"

#: ../../library/logging.config.rst:518
#, python-brace-format
msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42\n"
"}"
msgstr ""

#: ../../library/logging.config.rst:525
msgid ""
"and this contains the special key ``'()'``, which means that user-defined"
" instantiation is wanted.  In this case, the specified factory callable "
"will be used. If it is an actual callable it will be used directly - "
"otherwise, if you specify a string (as in the example) the actual "
"callable will be located using normal import mechanisms. The callable "
"will be called with the **remaining** items in the configuration sub-"
"dictionary as keyword arguments.  In the above example, the formatter "
"with id ``custom`` will be assumed to be returned by the call::"
msgstr ""
"여기에는 특수키 ``'()'``\\가 포함되어 있는데, 사용자 정의 인스턴스가 필요하다는 뜻입니다. 이때, 지정된 팩토리 콜러블이 "
"사용됩니다. 그것이 실제 콜러블이면 직접 사용됩니다 - 그렇지 않고, (예에서와같이) 문자열을 지정하면 일반적인 임포트 메커니즘을 "
"사용하여 실제 콜러블을 얻습니다. 콜러블은 구성 서브 딕셔너리의 **나머지** 항목을 키워드 인자로 호출됩니다. 위의 예제에서, "
"id가 ``custom``\\인 포매터는 다음과 같은 호출이 반환한다고 가정합니다::"

#: ../../library/logging.config.rst:535
msgid "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"
msgstr ""

#: ../../library/logging.config.rst:537
msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above"
" example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the"
" configuration machinery, but passed to the callable as-is."
msgstr ""

#: ../../library/logging.config.rst:542
msgid ""
"The key ``'()'`` has been used as the special key because it is not a "
"valid keyword parameter name, and so will not clash with the names of the"
" keyword arguments used in the call.  The ``'()'`` also serves as a "
"mnemonic that the corresponding value is a callable."
msgstr ""
"``'()'`` 키가 유효한 키워드 매개 변수 이름이 아니라서 특수키로 사용되었습니다. 그러므로 호출에 사용되는 키워드 인자의 "
"이름과 충돌하지 않습니다. ``'()'``\\는 해당 값이 콜러블이라는 표시로도 기능합니다."

#: ../../library/logging.config.rst:547
msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr ""

#: ../../library/logging.config.rst:551
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is"
" a mapping of attribute names to values. If found, the specified "
"attributes will be set on the user-defined object before it is returned. "
"Thus, with the following configuration::"
msgstr ""

#: ../../library/logging.config.rst:556
#, python-brace-format
msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"
msgstr ""

#: ../../library/logging.config.rst:567
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr ""

#: ../../library/logging.config.rst:570
msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the"
" configuration machinery, but set as attribute values as-is."
msgstr ""

#: ../../library/logging.config.rst:579
#, fuzzy
msgid "Handler configuration order"
msgstr "증분 구성"

#: ../../library/logging.config.rst:581
msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working "
"copy of) the ``handlers`` dictionary in the schema. If you use a "
"construct such as ``cfg://handlers.foo``, then initially "
"``handlers['foo']`` points to the configuration dictionary for the "
"handler named ``foo``, and later (once that handler has been configured) "
"it points to the configured handler instance. Thus, "
"``cfg://handlers.foo`` could resolve to either a dictionary or a handler "
"instance. In general, it is wise to name handlers in a way such that "
"dependent handlers are configured _after_ any handlers they depend on; "
"that allows something like ``cfg://handlers.foo`` to be used in "
"configuring a handler that depends on handler ``foo``. If that dependent "
"handler were named ``bar``, problems would result, because the "
"configuration of ``bar`` would be attempted before that of ``foo``, and "
"``foo`` would not yet have been configured. However, if the dependent "
"handler were named ``foobar``, it would be configured after ``foo``, with"
" the result that ``cfg://handlers.foo`` would resolve to configured "
"handler ``foo``, and not its configuration dictionary."
msgstr ""

#: ../../library/logging.config.rst:602
msgid "Access to external objects"
msgstr "외부 객체에 대한 액세스"

#: ../../library/logging.config.rst:604
msgid ""
"There are times where a configuration needs to refer to objects external "
"to the configuration, for example ``sys.stderr``.  If the configuration "
"dict is constructed using Python code, this is straightforward, but a "
"problem arises when the configuration is provided via a text file (e.g. "
"JSON, YAML).  In a text file, there is no standard way to distinguish "
"``sys.stderr`` from the literal string ``'sys.stderr'``.  To facilitate "
"this distinction, the configuration system looks for certain special "
"prefixes in string values and treat them specially.  For example, if the "
"literal string ``'ext://sys.stderr'`` is provided as a value in the "
"configuration, then the ``ext://`` will be stripped off and the remainder"
" of the value processed using normal import mechanisms."
msgstr ""
"구성에서 구성 외부의 객체를 참조해야 하는 경우가 있습니다, 예를 들어 ``sys.stderr``. 구성 딕셔너리가 파이썬 코드를 "
"사용하여 만들어질 때는 간단하지만, 구성이 텍스트 파일(예를 들어, JSON, YAML)을 통해 제공될 때 문제가 발생합니다. "
"텍스트 파일에서는, ``sys.stderr``\\를 리터럴 문자열 ``'sys.stderr'``\\과 구별하는 표준 방법이 "
"없습니다. 이 구별을 쉽게 하기 위해, 구성 시스템은 문자열 값에서 특정 접두사를 찾아 특수하게 처리합니다. 예를 들어, 리터럴 "
"문자열 ``'ext://sys.stderr'``\\이 구성에서 값으로 제공되면, ``ext://``\\는 제거되고 값의 나머지 "
"부분을 일반 임포트 메커니즘을 사용하여 처리합니다."

#: ../../library/logging.config.rst:617
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match "
"the regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby,"
" if the ``prefix`` is recognised, the ``suffix`` is processed in a "
"prefix-dependent manner and the result of the processing replaces the "
"string value.  If the prefix is not recognised, then the string value "
"will be left as-is."
msgstr ""
"이러한 접두사의 처리는 프로토콜 처리와 유사한 방식으로 수행됩니다: 정규식 "
"``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$``\\와 일치하는 접두사를 찾는 일반 메커니즘이 있습니다. "
"``prefix``\\가 인식되면 ``suffix``\\는 접두사 종속적 방식으로 처리되고 처리 결과가 문자열 값을 대체합니다. "
"접두사가 인식되지 않으면, 문자열 값은 그대로 남습니다."

#: ../../library/logging.config.rst:629
msgid "Access to internal objects"
msgstr "내부 객체에 대한 액세스"

#: ../../library/logging.config.rst:631
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object "
"id and resolve to the appropriate destination object."
msgstr ""
"외부 객체뿐만 아니라, 때로 구성에 있는 객체를 참조할 필요도 있습니다. 이것은 구성 시스템이 알고 있는 것들에 대해 묵시적으로 "
"수행됩니다. 예를 들어, 로거나 처리기의 ``level``\\에 대한 문자열 값 ``'DEBUG'``\\은 자동으로 값 "
"``logging.DEBUG``\\으로 변환되고, ``handlers``, ``filters`` 및 ``formatter`` 항목은"
" 객체 id를 받아서 적절한 대상 객체로 결정합니다."

#: ../../library/logging.config.rst:639
msgid ""
"However, a more generic mechanism is needed for user-defined objects "
"which are not known to the :mod:`logging` module.  For example, consider "
":class:`logging.handlers.MemoryHandler`, which takes a ``target`` "
"argument which is another handler to delegate to. Since the system "
"already knows about this class, then in the configuration, the given "
"``target`` just needs to be the object id of the relevant target handler,"
" and the system will resolve to the handler from the id.  If, however, a "
"user defines a ``my.package.MyHandler`` which has an ``alternate`` "
"handler, the configuration system would not know that the ``alternate`` "
"referred to a handler.  To cater for this, a generic resolution system "
"allows the user to specify:"
msgstr ""
"하지만, :mod:`logging` 모듈에 알려지지 않은 사용자 정의 객체에는 더욱 일반적인 메커니즘이 필요합니다. 예를 들어, "
"위임할 다른 처리기인 ``target`` 인자를 취하는 :class:`logging.handlers.MemoryHandler`\\를"
" 고려해봅시다. 시스템이 이미 이 클래스에 대해 알고 있으므로, 구성에서, 주어진 ``target``\\은 단지 관련 target "
"처리기의 객체 id이기만 하면 되며, 시스템은 id로부터 처리기를 결정합니다. 그러나 사용자가 ``alternate`` 처리기를 "
"갖는 ``my.package.MyHandler``\\를 정의하면, 구성 시스템은 ``alternate``\\가 처리기를 참조한다는 "
"것을 알 수 없습니다. 이 문제를 해결하기 위해, 일반 결정 시스템은 사용자가 다음과 같이 지정할 수 있게 합니다:"

#: ../../library/logging.config.rst:651
msgid ""
"handlers:\n"
"  file:\n"
"    # configuration of file handler goes here\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"
msgstr ""

#: ../../library/logging.config.rst:661
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism "
"allows access by dot or by index, in a similar way to that provided by "
"``str.format``.  Thus, given the following snippet:"
msgstr ""
"리터럴 문자열 ``'cfg://handlers.file'``\\은 ``ext://`` 접두사가 있는 문자열과 비슷하게 결정되지만, "
"임포트 이름 공간이 아닌 구성 자체를 조회합니다. 이 메커니즘은 ``str.format``\\에서 제공하는 것과 유사한 방식으로 "
"점이나 인덱스로 액세스하는 것을 허락합니다. 따라서, 구성에서 다음과 같은 조각이 주어질 때:"

#: ../../library/logging.config.rst:667
msgid ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."
msgstr ""

#: ../../library/logging.config.rst:679
#, fuzzy
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to "
"the dict with key ``handlers``, the string ``'cfg://handlers.email`` "
"would resolve to the dict with key ``email`` in the ``handlers`` dict, "
"and so on.  The string ``'cfg://handlers.email.toaddrs[1]`` would resolve"
" to ``'dev_team@domain.tld'`` and the string "
"``'cfg://handlers.email.toaddrs[0]'`` would resolve to the value "
"``'support_team@domain.tld'``. The ``subject`` value could be accessed "
"using either ``'cfg://handlers.email.subject'`` or, equivalently, "
"``'cfg://handlers.email[subject]'``.  The latter form only needs to be "
"used if the key contains spaces or non-alphanumeric characters. Please "
"note that the characters ``[`` and ``]`` are not allowed in the keys. If "
"an index value consists only of decimal digits, access will be attempted "
"using the corresponding integer value, falling back to the string value "
"if needed."
msgstr ""
"문자열 ``'cfg://handlers'``\\는 키 ``handlers``\\의 딕셔너리로 결정되고, 문자열 "
"``'cfg://handlers.email``\\은 ``handlers`` 딕셔너리에 있는 키 ``email``\\의 딕셔너리로 "
"결정됩니다, 등등. 문자열 ``'cfg://handlers.email.toaddrs[1]``\\은 "
"``'dev_team.domain.tld'``\\로 결정되고 문자열 "
"``'cfg://handlers.email.toaddrs[0]'``\\은 값 "
"``'support_team@domain.tld'``\\로 결정됩니다. ``subject`` 값은 "
"``'cfg://handlers.email.subject'``\\나 동등하게 "
"``'cfg://handlers.email[subject]'``\\를 사용하여 액세스할 수 있습니다. 후자의 형식은 키에 공백이나 "
"영숫자가 아닌 문자가 포함되어있을 때만 필요합니다. 인덱스값이 십진수로만 구성되면, 해당 정숫값을 사용하여 액세스가 시도되고, "
"필요하면 문자열 값으로 다시 시도합니다."

#: ../../library/logging.config.rst:694
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve "
"to ``config_dict['handlers']['myhandler']['mykey']['123']``. If the "
"string is specified as ``cfg://handlers.myhandler.mykey[123]``, the "
"system will attempt to retrieve the value from "
"``config_dict['handlers']['myhandler']['mykey'][123]``, and fall back to "
"``config_dict['handlers']['myhandler']['mykey']['123']`` if that fails."
msgstr ""
"문자열 ``cfg://handlers.myhandler.mykey.123``\\이 주어지면, "
"``config_dict['handlers']['myhandler']['mykey']['123']``\\으로 변환됩니다. 문자열이 "
"``cfg://handlers.myhandler.mykey[123]``\\로 지정되면, 시스템은 "
"``config_dict['handlers']['myhandler']['mykey'][123]``\\에서 값을 가져오려고 시도하고,"
" 실패하면 ``config_dict['handlers']['myhandler']['mykey']['123']``\\으로 폴백합니다."

#: ../../library/logging.config.rst:706
msgid "Import resolution and custom importers"
msgstr "임포트 결정과 사용자 정의 임포터"

#: ../../library/logging.config.rst:708
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` "
"function to do its importing. You may want to replace this with your own "
"importing mechanism: if so, you can replace the :attr:`importer` "
"attribute of the :class:`DictConfigurator` or its superclass, the "
":class:`BaseConfigurator` class. However, you need to be careful because "
"of the way functions are accessed from classes via descriptors. If you "
"are using a Python callable to do your imports, and you want to define it"
" at class level rather than instance level, you need to wrap it with "
":func:`staticmethod`. For example::"
msgstr ""
"임포트 결정은, 기본적으로, 임포트 하는데 내장 :func:`__import__` 함수를 사용합니다. 이것을 자신의 임포트 "
"메커니즘으로 바꾸고 싶을 수 있습니다: 그렇다면, :class:`DictConfigurator`\\나 그것의 슈퍼 "
"클래스(:class:`BaseConfigurator` 클래스)의 :attr:`importer` 어트리뷰트를 바꿀 수 있습니다. "
"그러나, 함수가 클래스에서 디스크립터를 통해 액세스 되는 방식 때문에 주의해야 합니다. 파이썬 콜러블을 사용하여 임포트를 수행하려고"
" 하고, 인스턴스 수준이 아닌 클래스 수준에서 정의하려고 한다면, :func:`staticmethod`\\로 감쌀 필요가 있습니다."
" 예를 들면::"

#: ../../library/logging.config.rst:718
msgid ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"
msgstr ""

#: ../../library/logging.config.rst:723
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr "구성자 *instance*\\에서 임포트 콜러블을 설정한다면, :func:`staticmethod`\\로 감쌀 필요가 없습니다."

#: ../../library/logging.config.rst:729
msgid "Configuring QueueHandler and QueueListener"
msgstr ""

#: ../../library/logging.config.rst:731
msgid ""
"If you want to configure a :class:`~logging.handlers.QueueHandler`, "
"noting that this is normally used in conjunction with a "
":class:`~logging.handlers.QueueListener`, you can configure both "
"together. After the configuration, the ``QueueListener`` instance will be"
" available as the :attr:`~logging.handlers.QueueHandler.listener` "
"attribute of the created handler, and that in turn will be available to "
"you using :func:`~logging.getHandlerByName` and passing the name you have"
" used for the ``QueueHandler`` in your configuration. The dictionary "
"schema for configuring the pair is shown in the example YAML snippet "
"below."
msgstr ""

#: ../../library/logging.config.rst:740
msgid ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."
msgstr ""

#: ../../library/logging.config.rst:752
msgid "The ``queue`` and ``listener`` keys are optional."
msgstr ""

#: ../../library/logging.config.rst:754
msgid ""
"If the ``queue`` key is present, the corresponding value can be one of "
"the following:"
msgstr ""

#: ../../library/logging.config.rst:756
msgid ""
"An object implementing the :meth:`Queue.put_nowait "
"<queue.Queue.put_nowait>` and :meth:`Queue.get <queue.Queue.get>` public "
"API. For instance, this may be an actual instance of :class:`queue.Queue`"
" or a subclass thereof, or a proxy obtained by "
":meth:`multiprocessing.managers.SyncManager.Queue`."
msgstr ""

#: ../../library/logging.config.rst:761
msgid ""
"This is of course only possible if you are constructing or modifying the "
"configuration dictionary in code."
msgstr ""

#: ../../library/logging.config.rst:764
msgid ""
"A string that resolves to a callable which, when called with no "
"arguments, returns the queue instance to use. That callable could be a "
":class:`queue.Queue` subclass or a function which returns a suitable "
"queue instance, such as ``my.module.queue_factory()``."
msgstr ""

#: ../../library/logging.config.rst:769
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a :class:`queue.Queue` instance."
msgstr ""

#: ../../library/logging.config.rst:773
msgid ""
"If the  ``queue`` key is absent, a standard unbounded "
":class:`queue.Queue` instance is created and used."
msgstr ""

#: ../../library/logging.config.rst:776
msgid ""
"If the ``listener`` key is present, the corresponding value can be one of"
" the following:"
msgstr ""

#: ../../library/logging.config.rst:778
msgid ""
"A subclass of :class:`logging.handlers.QueueListener`. This is of course "
"only possible if you are constructing or modifying the configuration "
"dictionary in code."
msgstr ""

#: ../../library/logging.config.rst:782
msgid ""
"A string which resolves to a class which is a subclass of "
"``QueueListener``, such as ``'my.package.CustomListener'``."
msgstr ""

#: ../../library/logging.config.rst:785
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a callable with the same signature as the "
"``QueueListener`` initializer."
msgstr ""

#: ../../library/logging.config.rst:789
msgid ""
"If the ``listener`` key is absent, "
":class:`logging.handlers.QueueListener` is used."
msgstr ""

#: ../../library/logging.config.rst:791
msgid ""
"The values under the ``handlers`` key are the names of other handlers in "
"the configuration (not shown in the above snippet) which will be passed "
"to the queue listener."
msgstr ""

#: ../../library/logging.config.rst:795
msgid ""
"Any custom queue handler and listener classes will need to be defined "
"with the same initialization signatures as "
":class:`~logging.handlers.QueueHandler` and "
":class:`~logging.handlers.QueueListener`."
msgstr ""

#: ../../library/logging.config.rst:804
msgid "Configuration file format"
msgstr "구성 파일 형식"

#: ../../library/logging.config.rst:806
msgid ""
"The configuration file format understood by :func:`fileConfig` is based "
"on :mod:`configparser` functionality. The file must contain sections "
"called ``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify "
"by name the entities of each type which are defined in the file. For each"
" such entity, there is a separate section which identifies how that "
"entity is configured.  Thus, for a logger named ``log01`` in the "
"``[loggers]`` section, the relevant configuration details are held in a "
"section ``[logger_log01]``. Similarly, a handler called ``hand01`` in the"
" ``[handlers]`` section will have its configuration held in a section "
"called ``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a "
"section called ``[formatter_form01]``. The root logger configuration must"
" be specified in a section called ``[logger_root]``."
msgstr ""
":func:`fileConfig`\\이 이해하는 구성 파일 형식은 :mod:`configparser` 기능을 기반으로 합니다. "
"파일에는 ``[loggers]``, ``[handlers]`` 및 ``[formatters]``\\라는 섹션이 있어야 하며, 이 "
"섹션에서는 파일에 정의된 각 유형의 엔티티를 이름으로 식별합니다. 이러한 엔티티마다 해당 엔티티 구성 방법을 식별하는 별도의 섹션이"
" 있습니다. 따라서, ``[loggers]`` 섹션에서 ``log01``\\이라고 이름 붙은 로거에 대해, 관련 구성 세부 사항은 "
"``[logger_log01]`` 섹션에 담깁니다. 마찬가지로, ``[handlers]`` 섹션에서 ``hand01``\\이라고 "
"부르는 처리기는 ``[handler_hand01]``\\이라는 섹션에 구성이 담기고, ``[formatters]`` 섹션에서 "
"``form01``\\이라고 부르는 포매터는 ``[formatter_form01]``\\이라는 섹션에서 구성이 지정됩니다. 루트 "
"로거 구성은 ``[logger_root]``\\라는 섹션에서 지정해야 합니다."

#: ../../library/logging.config.rst:821
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and "
"does not provide functionality to cover certain aspects of logging. For "
"example, you cannot configure :class:`~logging.Filter` objects, which "
"provide for filtering of messages beyond simple integer levels, using "
":func:`fileConfig`. If you need to have instances of "
":class:`~logging.Filter` in your logging configuration, you will need to "
"use :func:`dictConfig`. Note that future enhancements to configuration "
"functionality will be added to :func:`dictConfig`, so it's worth "
"considering transitioning to this newer API when it's convenient to do "
"so."
msgstr ""
":func:`fileConfig` API는 :func:`dictConfig` API보다 오래되었으며 로깅의 특정 측면을 다루는 "
"기능을 제공하지 않습니다. 예를 들어, :func:`fileConfig`\\를 사용해서는 간단한 정수 수준을 넘어서는 메시지 "
"필터링을 제공하는 :class:`~logging.Filter` 객체를 구성할 수 없습니다. 로깅 구성에 "
":class:`~logging.Filter` 인스턴스가 필요하면, :func:`dictConfig`\\를 사용해야 합니다. 향후 "
"구성 기능의 개선은 :func:`dictConfig`\\에 추가될 것임에 유의하십시오. 따라서, 편리할 때 이 새로운 API로 "
"전환하는 것을 고려해 볼 가치가 있습니다."

#: ../../library/logging.config.rst:831
msgid "Examples of these sections in the file are given below."
msgstr "파일에 있는 이 절의 예는 아래에 나와 있습니다."

#: ../../library/logging.config.rst:833
msgid ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"
msgstr ""

#: ../../library/logging.config.rst:844
msgid ""
"The root logger must specify a level and a list of handlers. An example "
"of a root logger section is given below."
msgstr "루트 로거는 수준과 처리기 목록을 지정해야 합니다. 루트 로거 섹션의 예가 아래에 나와 있습니다."

#: ../../library/logging.config.rst:847
msgid ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"
msgstr ""

#: ../../library/logging.config.rst:853
#, fuzzy
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, "
"CRITICAL`` or ``NOTSET``. For the root logger only, ``NOTSET`` means that"
" all messages will be logged. Level values are :ref:`evaluated <func-"
"eval>` in the context of the ``logging`` package's namespace."
msgstr ""
"``level`` 항목은 ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` 또는 ``NOTSET`` 중 "
"하나일 수 있습니다. 루트 로거에서만, ``NOTSET``\\는 모든 메시지가 로그 됨을 의미합니다. 수준 값은 "
"``logging`` 패키지의 이름 공간 컨텍스트에서 :func:`eval`\\됩니다."

#: ../../library/logging.config.rst:858
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the"
" ``[handlers]`` section and have corresponding sections in the "
"configuration file."
msgstr ""
"``handlers`` 항목은 ``[handlers]`` 섹션에 나타나야 하는 처리기 이름의 쉼표로 구분된 목록입니다. 이 이름들은"
" ``[handlers]`` 섹션에 나타나야 하며, 구성 파일에 해당 섹션이 있어야 합니다."

#: ../../library/logging.config.rst:863
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr "루트 로거가 아닌 로거의 경우, 몇 가지 추가 정보가 필요합니다. 이것은 다음 예제가 보여줍니다."

#: ../../library/logging.config.rst:866
msgid ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"
msgstr ""

#: ../../library/logging.config.rst:874
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as "
"``NOTSET``, the system consults loggers higher up the hierarchy to "
"determine the effective level of the logger. The ``propagate`` entry is "
"set to 1 to indicate that messages must propagate to handlers higher up "
"the logger hierarchy from this logger, or 0 to indicate that messages are"
" **not** propagated to handlers up the hierarchy. The ``qualname`` entry "
"is the hierarchical channel name of the logger, that is to say the name "
"used by the application to get the logger."
msgstr ""
"``level``\\과 ``handlers`` 항목은 루트 로거에서처럼 해석됩니다. 단, 루트가 아닌 로거의 수준이 "
"``NOTSET``\\로 지정되면, 시스템은 로거의 유효 수준을 판별하기 위해 상위 계층 로거를 참조합니다. "
"``propagate`` 항목은 메시지가 이 로거로부터 더 높은 로거 계층의 처리기로 전파되어야 함을 나타내려면 1로 설정되고, "
"메시지가 계층 위의 처리기로 전달되지 **않음**\\을 나타내려면 0으로 설정됩니다. ``qualname`` 항목은 로거의 계층적 "
"채널 이름, 즉 응용 프로그램에서 로거를 가져오는 데 사용되는 이름입니다."

#: ../../library/logging.config.rst:883
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr "처리기 구성을 지정하는 섹션은 다음과 같이 예시됩니다."

#: ../../library/logging.config.rst:885
msgid ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"
msgstr ""

#: ../../library/logging.config.rst:893
msgid ""
"The ``class`` entry indicates the handler's class (as determined by "
":func:`eval` in the ``logging`` package's namespace). The ``level`` is "
"interpreted as for loggers, and ``NOTSET`` is taken to mean 'log "
"everything'."
msgstr ""
"``class`` 항목은 (``logging`` 패키지의 이름 공간에서 :func:`eval`\\로 결정되는) 처리기의 클래스를 "
"나타냅니다. ``level``\\은 로거에서처럼 해석되며, ``NOTSET``\\은 '모든 것을 로깅'을 의미합니다."

#: ../../library/logging.config.rst:897
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is"
" used. If a name is specified, it must appear in the ``[formatters]`` "
"section and have a corresponding section in the configuration file."
msgstr ""
"``formatter`` 항목은 이 처리기의 포매터의 키 이름을 나타냅니다. 비어 있으면, 기본 "
"포매터(``logging._defaultFormatter``)가 사용됩니다. 이름이 지정되면, ``[formatters]`` 섹션에"
" 나타나야 하며 구성 파일에 해당 섹션이 있어야 합니다."

#: ../../library/logging.config.rst:902
#, fuzzy
msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of "
"the ``logging`` package's namespace, is the list of arguments to the "
"constructor for the handler class. Refer to the constructors for the "
"relevant handlers, or to the examples below, to see how typical entries "
"are constructed. If not provided, it defaults to ``()``."
msgstr ""
"``args`` 항목은, ``logging`` 패키지의 이름 공간 컨텍스트에서 :func:`eval`\\될 때, 처리기 클래스의 "
"생성자에 대한 인자 목록입니다. 일반적인 항목 작성 방법을 보려면, 관련 처리기의 생성자나 아래 예제를 참조하십시오. 제공되지 "
"않으면, 기본값은 ``()``\\입니다."

#: ../../library/logging.config.rst:908
#, fuzzy, python-brace-format
msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument "
"dict to the constructor for the handler class. If not provided, it "
"defaults to ``{}``."
msgstr ""
"선택적 ``kwargs`` 항목은, ``logging`` 패키지의 이름 공간 컨텍스트에서 :func:`eval`\\될 때, 처리기 "
"클래스의 생성자에 대한 키워드 인자 딕셔너리입니다. 제공되지 않으면, 기본값은 ``{}``\\입니다."

#: ../../library/logging.config.rst:912
#, python-brace-format
msgid ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), "
"handlers.SysLogHandler.LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger "
"Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"
msgstr ""

#: ../../library/logging.config.rst:965
msgid ""
"Sections which specify formatter configuration are typified by the "
"following."
msgstr "포매터 구성을 지정하는 섹션은 다음과 같이 예시됩니다."

#: ../../library/logging.config.rst:967
#, python-brace-format, python-format
msgid ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"
msgstr ""

#: ../../library/logging.config.rst:977
msgid ""
"The arguments for the formatter configuration are the same as the keys in"
" the dictionary schema :ref:`formatters section <logging-config-"
"dictschema-formatters>`."
msgstr ""

#: ../../library/logging.config.rst:981
#, fuzzy, python-brace-format
msgid ""
"The ``defaults`` entry, when :ref:`evaluated <func-eval>` in the context "
"of the ``logging`` package's namespace, is a dictionary of default values"
" for custom formatting fields. If not provided, it defaults to ``None``."
msgstr ""
"선택적 ``kwargs`` 항목은, ``logging`` 패키지의 이름 공간 컨텍스트에서 :func:`eval`\\될 때, 처리기 "
"클래스의 생성자에 대한 키워드 인자 딕셔너리입니다. 제공되지 않으면, 기본값은 ``{}``\\입니다."

#: ../../library/logging.config.rst:988
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where "
"multiple users with no mutual trust run code on the same machine; see the"
" :func:`listen` documentation for more information."
msgstr ""
"위에서 설명한 대로 :func:`eval`\\를 사용하기 때문에, :func:`listen`\\을 사용하여 소켓을 통해 구성을 "
"보내고 받을 때 발생할 수 있는 잠재적인 보안 위험이 있습니다. 위험은 상호 신뢰가 없는 여러 사용자가 같은 기계에서 코드를 실행할"
" 때로 제한됩니다; 자세한 내용은 :func:`listen` 설명서를 참조하십시오."

#: ../../library/logging.config.rst:996
msgid "Module :mod:`logging`"
msgstr "모듈 :mod:`logging`"

#: ../../library/logging.config.rst:997
msgid "API reference for the logging module."
msgstr "logging 모듈에 관한 API 레퍼런스."

#: ../../library/logging.config.rst:999
msgid "Module :mod:`logging.handlers`"
msgstr "모듈 :mod:`logging.handlers`"

#: ../../library/logging.config.rst:1000
msgid "Useful handlers included with the logging module."
msgstr "logging 모듈에 포함된 유용한 처리기."

#~ msgid ""
#~ "The configuring dict is searched for "
#~ "keys ``format`` and ``datefmt`` (with "
#~ "defaults of ``None``) and these are "
#~ "used to construct a "
#~ ":class:`~logging.Formatter` instance."
#~ msgstr ""
#~ "구성 딕셔너리는 키 ``format``\\과 ``datefmt``\\(기본값은"
#~ " ``None``)으로 검색되며 이들은 :class:`~logging.Formatter`"
#~ " 인스턴스를 만드는 데 사용됩니다."

#~ msgid ""
#~ "a ``validate`` key (with default of "
#~ "``True``) can be added into the "
#~ "``formatters`` section of the configuring "
#~ "dict, this is to validate the "
#~ "format."
#~ msgstr ""
#~ "구성 딕셔너리의 ``formatters`` 섹션에 ``validate`` "
#~ "키(기본값은 ``True``)를 추가할 수 있습니다. 이것은 "
#~ "포맷을 확인하기 위함입니다."

#~ msgid ""
#~ "The ``format`` entry is the overall "
#~ "format string, and the ``datefmt`` entry"
#~ " is the :func:`strftime`\\ -compatible "
#~ "date/time format string.  If empty, the"
#~ " package substitutes something which is "
#~ "almost equivalent to specifying the date"
#~ " format string ``'%Y-%m-%d %H:%M:%S'``.  "
#~ "This format also specifies milliseconds, "
#~ "which are appended to the result "
#~ "of using the above format string, "
#~ "with a comma separator.  An example "
#~ "time in this format is ``2003-01-23 "
#~ "00:29:50,411``."
#~ msgstr ""
#~ "``format`` 항목은 전체 포맷 문자열이고, ``datefmt``"
#~ " 항목은 :func:`strftime` 호환 날짜/시간 포맷 "
#~ "문자열입니다. 비어있으면, 패키지는 날짜 포맷 문자열 "
#~ "``'%Y-%m-%d %H:%M:%S'``\\를 지정하는 것과 거의 "
#~ "동등한 것으로 대체합니다. 이 포맷은 밀리 초도 "
#~ "지정하는데, 위의 포맷 문자열을 사용한 결과에 쉼표 "
#~ "구분 기호와 함께 추가됩니다. 이 포맷의 예제 "
#~ "시간은 ``2003-01-23 00:29:50,411``\\입니다."

