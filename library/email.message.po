# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/email.message.rst:2
#, fuzzy
msgid ":mod:`!email.message`: Representing an email message"
msgstr ":mod:`email.message`: 전자 메일 메시지 표현"

#: ../../library/email.message.rst:10
msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**소스 코드:** :source:`Lib/email/message.py`"

#: ../../library/email.message.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.message.rst:16
msgid ""
"The central class in the :mod:`email` package is the "
":class:`EmailMessage` class, imported from the :mod:`email.message` "
"module.  It is the base class for the :mod:`email` object model.  "
":class:`EmailMessage` provides the core functionality for setting and "
"querying header fields, for accessing message bodies, and for creating or"
" modifying structured messages."
msgstr ""
":mod:`email` 패키지의 중심 클래스는 :mod:`email.message` 모듈에서 임포트 되는 "
":class:`EmailMessage` 클래스입니다. :mod:`email` 객체 모델의 베이스 클래스입니다. "
":class:`EmailMessage`\\는 헤더 필드 설정과 조회, 메시지 본문 액세스 및 구조화된 메시지 작성이나 수정을 위한 "
"핵심 기능을 제공합니다."

#: ../../library/email.message.rst:22
msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` "
"style field names and values, where the field name and value are "
"separated by a colon.  The colon is not part of either the field name or "
"the field value.  The payload may be a simple text message, or a binary "
"object, or a structured sequence of sub-messages each with their own set "
"of headers and their own payload.  The latter type of payload is "
"indicated by the message having a MIME type such as "
":mimetype:`multipart/\\*` or :mimetype:`message/rfc822`."
msgstr ""
"전자 메일 메시지는 *헤더(headers)*\\와 *페이 로드(payload)*\\(*내용(content)*\\이라고도 합니다)로 "
"구성됩니다. 헤더는 :rfc:`5322`\\나 :rfc:`6532` 스타일 필드 이름과 값이며, 필드 이름과 값은 콜론으로 "
"구분됩니다. 콜론은 필드 이름이나 필드 값의 일부가 아닙니다. 페이 로드는 간단한 텍스트 메시지, 바이너리 객체 또는 각각 자신만의"
" 헤더 집합과 자신만의 페이 로드를 갖는 서브 메시지들의 구조화된 시퀀스일 수 있습니다. 마지막 유형의 페이 로드는 "
":mimetype:`multipart/\\*`\\나 :mimetype:`message/rfc822`\\와 같은 MIME 유형을 가진"
" 메시지로 표시됩니다."

#: ../../library/email.message.rst:31
msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that "
"of an ordered dictionary of headers coupled with a *payload* that "
"represents the :rfc:`5322` body of the message, which might be a list of "
"sub-``EmailMessage`` objects.  In addition to the normal dictionary "
"methods for accessing the header names and values, there are methods for "
"accessing specialized information from the headers (for example the MIME "
"content type), for operating on the payload, for generating a serialized "
"version of the message, and for recursively walking over the object tree."
msgstr ""
":class:`EmailMessage` 객체가 제공하는 개념적 모델은 메시지의 :rfc:`5322` 본문을 나타내는 "
"*payload*\\와 결합 된 헤더들의 순서 있는 딕셔너리이며, 본문은 서브-``EmailMessage`` 객체의 리스트일 수 "
"있습니다. 헤더 이름과 값에 액세스하기 위한 일반적인 딕셔너리 메서드 외에도, 헤더에서 특수 정보(예를 들어 MIME 콘텐츠 "
"유형)에 액세스하고, 페이 로드를 다루고, 메시지의 직렬화된 버전을 생성하고, 객체 트리를 재귀적으로 탐색하는 메서드가 있습니다."

#: ../../library/email.message.rst:40
#, fuzzy
msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the "
"header names, which must be ASCII values.  The values of the dictionary "
"are strings with some extra methods.  Headers are stored and returned in "
"case-preserving form, but field names are matched case-insensitively.  "
"The keys are ordered, but unlike a real dict, there can be duplicates.  "
"Additional methods are provided for working with headers that have "
"duplicate keys."
msgstr ""
":class:`EmailMessage` 딕셔너리류 인터페이스는 ASCII 값이어야 하는 헤더 이름으로 인덱싱됩니다. 딕셔너리의 값은"
" 몇 가지 추가 메서드가 있는 문자열입니다. 헤더는 대소 문자를 유지하면서 저장되고 반환되지만, 필드 이름은 대소 문자를 구분하지 "
"않고 일치합니다. 실제 딕셔너리와 달리, 키 순서가 있으며 중복된 키를 가질 수 있습니다. 중복 키가 있는 헤더로 작업하기 위한 "
"추가 메서드가 제공됩니다."

#: ../../library/email.message.rst:47
msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and "
":mimetype:`message/rfc822` message objects."
msgstr ""
"*페이 로드*\\는 간단한 메시지 객체의 경우 문자열이나 바이트열 객체이고, :mimetype:`multipart/\\*`\\와 "
":mimetype:`message/rfc822` 메시지 객체와 같은 MIME 컨테이너 문서에서는 "
":class:`EmailMessage` 객체의 리스트입니다."

#: ../../library/email.message.rst:55
msgid ""
"If *policy* is specified use the rules it specifies to update and "
"serialize the representation of the message.  If *policy* is not set, use"
" the :class:`~email.policy.default` policy, which follows the rules of "
"the email RFCs except for line endings (instead of the RFC mandated "
"``\\r\\n``, it uses the Python standard ``\\n`` line endings).  For more "
"information see the :mod:`~email.policy` documentation."
msgstr ""
"*policy*\\가 지정되면, 그것이 지정하는 규칙을 사용하여 메시지 표현을 갱신하고 직렬화합니다. *policy*\\가 설정되지"
" 않으면, 줄 종료를 제외하고는 전자 메일 RFC 규칙을 따르는 :class:`~email.policy.default` 정책을 "
"사용합니다 (RFC가 요구하는 ``\\r\\n`` 대신에, 파이썬 표준 ``\\n`` 줄 종료를 사용합니다). 자세한 내용은 "
":mod:`~email.policy` 설명서를 참조하십시오."

#: ../../library/email.message.rst:64
#, fuzzy
msgid ""
"Return the entire message flattened as a string.  When optional "
"*unixfrom* is true, the envelope header is included in the returned "
"string.  *unixfrom* defaults to ``False``.  For backward compatibility "
"with the base :class:`~email.message.Message` class *maxheaderlen* is "
"accepted, but defaults to ``None``, which means that by default the line "
"length is controlled by the :attr:`~email.policy.Policy.max_line_length` "
"of the policy.  The *policy* argument may be used to override the default"
" policy obtained from the message instance.  This can be used to control "
"some of the formatting produced by the method, since the specified "
"*policy* will be passed to the :class:`~email.generator.Generator`."
msgstr ""
"전체 메시지를 평평하게 만든 문자열을 반환합니다. 선택적 *unixfrom*\\이 참이면, 봉투 헤더(envelope "
"header)가 반환된 문자열에 포함됩니다. *unixfrom*\\의 기본값은 ``False``\\입니다. 베이스 "
":class:`~email.message.Message` 클래스와의 과거 호환성을 위해 *maxheaderlen*\\이 허용되지만,"
" 기본값은 ``None``\\이고, 이는 기본적으로 줄 길이가 정책의 "
":attr:`~email.policy.EmailPolicy.max_line_length`\\에 의해 제어됨을 의미합니다. "
"*policy* 인자는 메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 *policy*\\가 "
":class:`~email.generator.Generator`\\로 전달되기 때문에, 메서드가 생성하는 포매팅의 일부를 제어하는 "
"데 사용할 수 있습니다."

#: ../../library/email.message.rst:76 ../../library/email.message.rst:114
msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` "
"if defaults need to be filled in to complete the transformation to a "
"string (for example, MIME boundaries may be generated or modified)."
msgstr ""
"문자열로의 변환을 완료하기 위해 기본값을 채워야 하면 메시지를 평평하게 만들 때 :class:`EmailMessage`\\에 대한 "
"변경이 발생할 수 있습니다 (예를 들어, MIME 경계(boundaries)가 생성되거나 수정될 수 있습니다)."

#: ../../library/email.message.rst:80
msgid ""
"Note that this method is provided as a convenience and may not be the "
"most useful way to serialize messages in your application, especially if "
"you are dealing with multiple messages.  See "
":class:`email.generator.Generator` for a more flexible API for "
"serializing messages.  Note also that this method is restricted to "
"producing messages serialized as \"7 bit clean\" when "
":attr:`~email.policy.EmailPolicy.utf8` is ``False``, which is the "
"default."
msgstr ""
"이 메서드는 편의상 제공되며, 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법은 아닐 수 있습니다, 특히 여러 메시지를 "
"다룬다면 그렇습니다. 메시지 직렬화를 위한 더 유연한 API는 :class:`email.generator.Generator`\\를 "
"참조하십시오. 또한 이 메서드는 :attr:`~email.policy.EmailPolicy.utf8`\\가 "
"``False``\\(기본값)일 때 \"7비트 클린\"으로 직렬화된 메시지를 생성하는 것으로 제한됩니다."

#: ../../library/email.message.rst:88
msgid ""
"the default behavior when *maxheaderlen* is not specified was changed "
"from defaulting to 0 to defaulting to the value of *max_line_length* from"
" the policy."
msgstr ""
"*maxheaderlen*\\이 지정되지 않았을 때의 기본 동작은 기본값을 0으로 하는 것에서 정책(policy)의 "
"*max_line_length* 값을 기본값으로 사용하는 것으로 변경되었습니다."

#: ../../library/email.message.rst:95
msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows"
" ``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"``as_string(policy=self.policy.clone(utf8=True))``\\와 동등합니다. "
"``str(msg)``\\가 직렬화된 메시지를 포함하는 문자열을 읽을 수 있는 형식으로 생성할 수 있도록 합니다."

#: ../../library/email.message.rst:99
msgid ""
"the method was changed to use ``utf8=True``, thus producing an "
":rfc:`6531`-like message representation, instead of being a direct alias "
"for :meth:`as_string`."
msgstr ""
"이 메서드는 ``utf8=True``\\를 사용하도록 변경되어, :meth:`as_string`\\의 직접적인 별칭인 대신, "
":rfc:`6531`\\과 유사한 메시지 표현을 생성합니다."

#: ../../library/email.message.rst:106
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned "
"string.  *unixfrom* defaults to ``False``.  The *policy* argument may be "
"used to override the default policy obtained from the message instance. "
"This can be used to control some of the formatting produced by the "
"method, since the specified *policy* will be passed to the "
":class:`~email.generator.BytesGenerator`."
msgstr ""
"전체 메시지를 평평하게 만든 바이트열 객체를 반환합니다. 선택적 *unixfrom*\\이 참이면, 봉투 헤더(envelope "
"header)가 반환된 문자열에 포함됩니다. *unixfrom*\\의 기본값은 ``False``\\입니다. *policy* 인자는 "
"메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 *policy*\\가 "
":class:`~email.generator.BytesGenerator`\\로 전달되기 때문에, 메서드가 생성하는 포매팅의 일부를 "
"제어하는 데 사용할 수 있습니다."

#: ../../library/email.message.rst:118
msgid ""
"Note that this method is provided as a convenience and may not be the "
"most useful way to serialize messages in your application, especially if "
"you are dealing with multiple messages.  See "
":class:`email.generator.BytesGenerator` for a more flexible API for "
"serializing messages."
msgstr ""
"이 메서드는 편의상 제공되며, 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법은 아닐 수 있습니다, 특히 여러 메시지를 "
"다룬다면 그렇습니다. 메시지 직렬화를 위한 더 유연한 API는 "
":class:`email.generator.BytesGenerator`\\를 참조하십시오."

#: ../../library/email.message.rst:127
#, fuzzy
msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a "
"bytes object containing the serialized message."
msgstr ""
":meth:`.as_bytes()`\\와 동등합니다. ``bytes(msg)``\\가 직렬화된 메시지를 포함하는 바이트열 객체를 "
"생성할 수 있도록 합니다."

#: ../../library/email.message.rst:133
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ "
":class:`EmailMessage` objects, otherwise return ``False``.  When "
":meth:`is_multipart` returns ``False``, the payload should be a string "
"object (which might be a CTE encoded binary payload).  Note that "
":meth:`is_multipart` returning ``True`` does not necessarily mean that "
"\"msg.get_content_maintype() == 'multipart'\" will return the ``True``. "
"For example, ``is_multipart`` will return ``True`` when the "
":class:`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"메시지의 페이 로드가 서브-\\ :class:`EmailMessage` 객체의 리스트면 ``True``\\를, 그렇지 않으면 "
"``False``\\를 반환합니다. :meth:`is_multipart`\\가 ``False``\\를 반환할 때, 페이 로드는 "
"문자열 객체(CTE 인코딩된 바이너리 페이 로드일 수 있습니다)여야 합니다. ``True``\\를 반환하는 "
":meth:`is_multipart`\\가 반드시 \"msg.get_content_maintype() == "
"'multipart'\"가 ``True``\\를 반환한다는 것을 의미하지는 않습니다. 예를 들어, "
":class:`EmailMessage`\\가 ``message/rfc822`` 유형일 때 ``is_multipart``\\는 "
"``True``\\를 반환합니다."

#: ../../library/email.message.rst:145
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a "
"string.  (See :class:`~mailbox.mboxMessage` for a brief description of "
"this header.)"
msgstr ""
"메시지의 봉투 헤더(envelope header)를 문자열이어야 하는 *unixfrom*\\으로 설정합니다. (이 헤더에 대한 "
"간단한 설명은 :class:`~mailbox.mboxMessage`\\를 참조하십시오.)"

#: ../../library/email.message.rst:152
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the "
"envelope header was never set."
msgstr "메시지의 봉투 헤더(envelope header)를 반환합니다. 봉투 헤더가 설정되지 않았으면 기본값은 ``None``\\입니다."

#: ../../library/email.message.rst:156
msgid ""
"The following methods implement the mapping-like interface for accessing "
"the message's headers.  Note that there are some semantic differences "
"between these methods and a normal mapping (i.e. dictionary) interface.  "
"For example, in a dictionary there are no duplicate keys, but here there "
"may be duplicate message headers.  Also, in dictionaries there is no "
"guaranteed order to the keys returned by :meth:`keys`, but in an "
":class:`EmailMessage` object, headers are always returned in the order "
"they appeared in the original message, or in which they were added to the"
" message later.  Any header deleted and then re-added is always appended "
"to the end of the header list."
msgstr ""
"다음 메서드는 메시지 헤더에 액세스하기 위한 매핑류 인터페이스를 구현합니다. 이 메서드들과 일반 매핑(즉, 딕셔너리) 인터페이스 "
"사이에는 의미상 차이가 있습니다. 예를 들어, 딕셔너리에는 중복 키가 없지만, 여기서는 중복 메시지 헤더가 있을 수 있습니다. 또한"
" 딕셔너리에서는 :meth:`keys`\\가 반환한 키의 순서가 보장되지 않지만, :class:`EmailMessage` 객체에서는"
" 헤더가 항상 원래 메시지에 나타난 순서대로, 또는 나중에 메시지에 추가된 순서대로 반환됩니다. 삭제한 후 다시 추가된 헤더는 항상"
" 헤더 리스트의 끝에 추가됩니다."

#: ../../library/email.message.rst:167
msgid ""
"These semantic differences are intentional and are biased toward "
"convenience in the most common use cases."
msgstr "이러한 의미적 차이는 의도적이며 가장 흔한 사용 사례에서의 편의를 추구하는 쪽으로 기울어져 있습니다."

#: ../../library/email.message.rst:170
msgid ""
"Note that in all cases, any envelope header present in the message is not"
" included in the mapping interface."
msgstr "모든 경우에, 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되지 않습니다."

#: ../../library/email.message.rst:176
msgid "Return the total number of headers, including duplicates."
msgstr "중복을 포함하여, 총 헤더 수를 반환합니다."

#: ../../library/email.message.rst:181
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching "
"is done without regard to case and *name* does not include the trailing "
"colon.  Used for the ``in`` operator.  For example::"
msgstr ""
"메시지 객체에 *name*\\이라는 필드가 있으면 ``True``\\를 반환합니다. 대소 문자를 구분하지 않고 일치하며, "
"*name*\\은 후행 콜론을 포함하지 않습니다. ``in`` 연산자에 사용됩니다. 예를 들면::"

#: ../../library/email.message.rst:185
msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""

#: ../../library/email.message.rst:191
msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a"
" :exc:`KeyError` is never raised."
msgstr ""
"이름으로 지정된 헤더 필드의 값을 반환합니다. *name*\\은 콜론 필드 구분자를 포함하지 않습니다. 헤더가 없으면 "
"``None``\\이 반환됩니다; :exc:`KeyError`\\가 발생하지 않습니다."

#: ../../library/email.message.rst:195
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is "
"undefined.  Use the :meth:`get_all` method to get the values of all the "
"extant headers named *name*."
msgstr ""
"이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면, 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. "
":meth:`get_all` 메서드를 사용하여 *name*\\으로 이름이 지정된 모든 기존 헤더의 값을 가져오십시오."

#: ../../library/email.message.rst:200
msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr ""
"표준 (``compat32``\\가 아닌) 정책을 사용하여, 반환된 값은 "
":class:`email.headerregistry.BaseHeader`\\의 서브 클래스 인스턴스입니다."

#: ../../library/email.message.rst:206
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr "필드 이름이 *name*\\이고 값이 *val*\\인 헤더를 메시지에 추가합니다. 필드는 메시지의 기존 헤더들 끝에 추가됩니다."

#: ../../library/email.message.rst:209
msgid ""
"Note that this does *not* overwrite or delete any existing header with "
"the same name.  If you want to ensure that the new header is the only one"
" present in the message with field name *name*, delete the field first, "
"e.g.::"
msgstr ""
"같은 이름을 가진 기존 헤더를 덮어쓰거나 삭제하지 *않습니다*. 새 헤더가 메시지에서 필드 이름이 *name*\\인 유일한 것이 "
"되도록 하려면, 먼저 필드를 삭제하십시오. 예를 들어::"

#: ../../library/email.message.rst:213
msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""

#: ../../library/email.message.rst:216
#, fuzzy
msgid ""
"If the :mod:`policy <email.policy>` defines certain headers to be unique "
"(as the standard policies do), this method may raise a :exc:`ValueError` "
"when an attempt is made to assign a value to such a header when one "
"already exists.  This behavior is intentional for consistency's sake, but"
" do not depend on it as we may choose to make such assignments do an "
"automatic deletion of the existing header in the future."
msgstr ""
":mod:`policy`\\가 (표준 정책에서처럼) 특정 헤더를 고유한(unique) 것으로 정의하면, 이 메서드는 헤더가 이미 "
"존재할 때 해당 헤더에 값을 할당하려고 시도하면 :exc:`ValueError`\\를 발생시킬 수 있습니다. 이 동작은 일관성을 "
"위해 의도적이지만, 향후 이러한 대입이 기존 헤더를 자동으로 삭제하도록 선택할 수 있기 때문에, 이것에 의존하지 마십시오."

#: ../../library/email.message.rst:226
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr "메시지 헤더에서 이름이 *name*\\인 모든 필드를 삭제합니다. 해당 이름의 필드가 헤더에 없어도 예외가 발생하지 않습니다."

#: ../../library/email.message.rst:233
msgid "Return a list of all the message's header field names."
msgstr "메시지의 모든 헤더 필드 이름의 리스트를 반환합니다."

#: ../../library/email.message.rst:238
msgid "Return a list of all the message's field values."
msgstr "메시지의 모든 필드 값의 리스트를 반환합니다."

#: ../../library/email.message.rst:243
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr "메시지의 모든 필드 헤더와 값을 담은 2-튜플의 리스트를 반환합니다."

#: ../../library/email.message.rst:249
#, fuzzy
msgid ""
"Return the value of the named header field.  This is identical to "
":meth:`~object.__getitem__` except that optional *failobj* is returned if"
" the named header is missing (*failobj* defaults to ``None``)."
msgstr ""
"명명된 헤더 필드의 값을 반환합니다. 명명된 헤더가 없을 때 선택적 *failobj*\\가 반환된다는 점을 제외하면 "
":meth:`__getitem__`\\와 같습니다 (*failobj*\\의 기본값은 ``None``)."

#: ../../library/email.message.rst:254
msgid "Here are some additional useful header related methods:"
msgstr "추가적인 유용한 헤더 관련 메서드는 다음과 같습니다:"

#: ../../library/email.message.rst:259
msgid ""
"Return a list of all the values for the field named *name*. If there are "
"no such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"*name*\\으로 명명된 필드의 모든 값의 리스트를 반환합니다. 메시지에 그런 이름의 헤더가 없으면 *failobj*\\가 "
"반환됩니다 (기본값은 ``None``)."

#: ../../library/email.message.rst:266
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the "
"*primary* value for the header."
msgstr ""
"확장된 헤더 설정. 이 메서드는 추가 헤더 파라미터가 키워드 인자로 제공될 수 있다는 점을 제외하고는 "
":meth:`__setitem__`\\과 유사합니다. *_name*\\은 추가할 헤더 필드이고 *_value*\\는 헤더의 "
"*기본(primary)*\\값입니다."

#: ../../library/email.message.rst:271
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is "
"taken as the parameter name, with underscores converted to dashes (since "
"dashes are illegal in Python identifiers).  Normally, the parameter will "
"be added as ``key=\"value\"`` unless the value is ``None``, in which case"
" only the key will be added."
msgstr ""
"키워드 인자 딕셔너리 *_params*\\의 각 항목에 대해, 키는 파라미터 이름으로 사용되며 밑줄은 대시로 변환됩니다 (대시는 "
"파이썬 식별자에서 유효하지 않기 때문입니다). 일반적으로, 값이 ``None``\\이 아니면 파라미터가 "
"``key=\"value\"``\\로 추가되며, None이면 키만 추가됩니다."

#: ../../library/email.message.rst:277
msgid ""
"If the value contains non-ASCII characters, the charset and language may "
"be explicitly controlled by specifying the value as a three tuple in the "
"format ``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string "
"naming the charset to be used to encode the value, ``LANGUAGE`` can "
"usually be set to ``None`` or the empty string (see :rfc:`2231` for other"
" possibilities), and ``VALUE`` is the string value containing non-ASCII "
"code points.  If a three tuple is not passed and the value contains non-"
"ASCII characters, it is automatically encoded in :rfc:`2231` format using"
" a ``CHARSET`` of ``utf-8`` and a ``LANGUAGE`` of ``None``."
msgstr ""
"값에 ASCII가 아닌 문자가 포함되면, 값을 ``(CHARSET, LANGUAGE, VALUE)`` 형식의 3-튜플로 지정하여 "
"문자 집합과 언어를 명시적으로 제어 할 수 있습니다. 여기서 ``CHARSET``\\은 값을 인코딩하는 데 사용할 문자 집합의 "
"이름을 지정하는 문자열이고, ``LANGUAGE``\\는 보통 ``None``\\이나 빈 문자열(다른 가능성은 "
":rfc:`2231`\\을 참조하십시오)로 설정되고, ``VALUE``\\는 비 ASCII 코드 포인트를 포함하는 문자열 값입니다."
" 3-튜플이 전달되지 않고 값에 ASCII가 아닌 문자가 포함되면, ``CHARSET``\\으로 ``utf-8``, "
"``LANGUAGE``\\로 ``None``\\을 사용하여 :rfc:`2231` 형식으로 자동 인코딩됩니다."

#: ../../library/email.message.rst:287
msgid "Here is an example::"
msgstr "예를 들면 다음과 같습니다::"

#: ../../library/email.message.rst:289
msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""

#: ../../library/email.message.rst:291
msgid "This will add a header that looks like ::"
msgstr "이것은 다음과 같은 헤더를 추가합니다 ::"

#: ../../library/email.message.rst:293
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr ""

#: ../../library/email.message.rst:295
msgid "An example of the extended interface with non-ASCII characters::"
msgstr "비 ASCII 문자가 있는 확장 인터페이스의 예::"

#: ../../library/email.message.rst:297
msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""

#: ../../library/email.message.rst:303
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the "
"original header.  If no matching header is found, raise a "
":exc:`KeyError`."
msgstr ""
"헤더를 교체합니다. 메시지에서 발견된 *_name*\\과 일치하는 첫 번째 헤더를 교체하고, 원래 헤더의 헤더 순서와 필드 이름 "
"케이스(case)를 유지합니다. 일치하는 헤더가 없으면 :exc:`KeyError`\\를 발생시킵니다."

#: ../../library/email.message.rst:311
msgid ""
"Return the message's content type, coerced to lower case of the form "
":mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by "
":meth:`get_default_type`.  If the :mailheader:`Content-Type` header is "
"invalid, return ``text/plain``."
msgstr ""
":mimetype:`maintype/subtype` 형식의 소문자로 강제 변환된 메시지의 콘텐츠 유형을 반환합니다. 메시지에 "
":mailheader:`Content-Type` 헤더가 없으면 :meth:`get_default_type`\\이 반환하는 값을 "
"반환합니다. :mailheader:`Content-Type` 헤더가 유효하지 않으면 ``text/plain``\\을 반환합니다."

#: ../../library/email.message.rst:317
msgid ""
"(According to :rfc:`2045`, messages always have a default type, "
":meth:`get_content_type` will always return a value.  :rfc:`2045` defines"
" a message's default type to be :mimetype:`text/plain` unless it appears "
"inside a :mimetype:`multipart/digest` container, in which case it would "
"be :mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header "
"has an invalid type specification, :rfc:`2045` mandates that the default "
"type be :mimetype:`text/plain`.)"
msgstr ""
"(:rfc:`2045`\\에 따라, 메시지는 항상 기본 유형을 가지며, :meth:`get_content_type`\\은 항상 값을"
" 반환합니다. :rfc:`2045`\\는 :mimetype:`multipart/digest` 컨테이너 내에 등장하면 기본 유형이 "
":mimetype:`message/rfc822`\\이고, 그렇지 않으면 기본 유형을 :mimetype:`text/plain`\\으로"
" 정의합니다. :mailheader:`Content-Type` 헤더가 유효하지 않은 유형 지정이면, :rfc:`2045`\\는 기본"
" 유형을 :mimetype:`text/plain`\\으로 강제합니다.)"

#: ../../library/email.message.rst:328
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype`"
" part of the string returned by :meth:`get_content_type`."
msgstr ""
"메시지의 메인 콘텐츠 유형을 반환합니다. 이것은 :meth:`get_content_type`\\이 반환한 문자열의 "
":mimetype:`maintype` 부분입니다."

#: ../../library/email.message.rst:334
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"메시지의 서브 콘텐츠 유형을 반환합니다. 이것은 :meth:`get_content_type`\\이 반환한 문자열의 "
":mimetype:`subtype` 부분입니다."

#: ../../library/email.message.rst:340
msgid ""
"Return the default content type.  Most messages have a default content "
"type of :mimetype:`text/plain`, except for messages that are subparts of "
":mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"기본 콘텐츠 유형을 반환합니다. :mimetype:`multipart/digest` 컨테이너의 서브 파트인 메시지를 제외하고 "
"대부분의 메시지는 기본 콘텐츠 유형이 :mimetype:`text/plain`\\입니다. 이러한 서브 파트는 기본 콘텐츠 유형이 "
":mimetype:`message/rfc822`\\입니다."

#: ../../library/email.message.rst:348
msgid ""
"Set the default content type.  *ctype* should either be "
":mimetype:`text/plain` or :mimetype:`message/rfc822`, although this is "
"not enforced.  The default content type is not stored in the :mailheader"
":`Content-Type` header, so it only affects the return value of the "
"``get_content_type`` methods when no :mailheader:`Content-Type` header is"
" present in the message."
msgstr ""
"기본 콘텐츠 유형을 설정합니다. *ctype*\\은 :mimetype:`text/plain`\\이나 "
":mimetype:`message/rfc822`\\여야 하지만, 이것을 강제하지는 않습니다. 기본 콘텐츠 유형은 "
":mailheader:`Content-Type` 헤더에 저장되지 않기 때문에, 메시지에 :mailheader:`Content-"
"Type` 헤더가 없을 때 ``get_content_type`` 메서드의 반환 값에만 영향을 줍니다."

#: ../../library/email.message.rst:359
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the "
"parameter already exists in the header, replace its value with *value*. "
"When *header* is ``Content-Type`` (the default) and the header does not "
"yet exist in the message, add it, set its value to "
":mimetype:`text/plain`, and append the new parameter value.  Optional "
"*header* specifies an alternative header to :mailheader:`Content-Type`."
msgstr ""
":mailheader:`Content-Type` 헤더에 파라미터를 설정합니다. 파라미터가 이미 헤더에 존재하면, 해당 값을 "
"*value*\\로 바꿉니다. *header*\\가 ``Content-Type``\\(기본값)이고 헤더가 메시지에 아직 없으면, "
"헤더를 추가하고 값을 :mimetype:`text/plain`\\으로 설정한 다음 새 파라미터 값을 추가합니다. 선택적 "
"*header*\\는 :mailheader:`Content-Type`\\의 대체 헤더를 지정합니다."

#: ../../library/email.message.rst:366
msgid ""
"If the value contains non-ASCII characters, the charset and language may "
"be explicitly specified using the optional *charset* and *language* "
"parameters.  Optional *language* specifies the :rfc:`2231` language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings.  The default is to use the ``utf8`` *charset* and ``None`` for "
"the *language*."
msgstr ""
"값에 ASCII가 아닌 문자가 포함되면, 선택적 *charset*\\과 *language* 매개 변수를 사용하여 문자 집합과 언어를"
" 명시적으로 지정할 수 있습니다. 선택적 *language*\\는 :rfc:`2231` 언어를 지정하며, 기본값은 빈 문자열입니다."
" *charset*\\과 *language*\\는 모두 문자열이어야 합니다. 기본값은 ``utf8`` *charset*\\과 "
"``None`` *language*\\를 사용하는 것입니다."

#: ../../library/email.message.rst:373
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of"
" the list of headers.  If *replace* is ``True``, the header will be "
"updated in place."
msgstr ""
"*replace*\\가 ``False``\\(기본값)이면 헤더는 헤더 리스트의 끝으로 이동합니다. *replace*\\가 "
"``True``\\이면, 헤더는 제자리에서 갱신됩니다."

#: ../../library/email.message.rst:377 ../../library/email.message.rst:394
msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr ":class:`EmailMessage` 객체에 *requote* 매개 변수를 사용하는 것은 폐지되었습니다."

#: ../../library/email.message.rst:380
#, fuzzy
msgid ""
"Note that existing parameter values of headers may be accessed through "
"the :attr:`~email.headerregistry.ParameterizedMIMEHeader.params` "
"attribute of the header value (for example, ``msg['Content-"
"Type'].params['charset']``)."
msgstr ""
"헤더의 기존 파라미터값은 헤더 값의 :attr:`~email.headerregistry.BaseHeader.params` "
"어트리뷰트를 통해 액세스 할 수 있음에 유의하십시오 (예를 들어, ``msg['Content-"
"Type'].params['charset']``)."

#: ../../library/email.message.rst:384
msgid "``replace`` keyword was added."
msgstr "``replace`` 키워드가 추가되었습니다."

#: ../../library/email.message.rst:389
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type`"
" header.  The header will be re-written in place without the parameter or"
" its value.  Optional *header* specifies an alternative to :mailheader"
":`Content-Type`."
msgstr ""
":mailheader:`Content-Type` 헤더에서 지정된 파라미터를 완전히 제거합니다. 헤더는 해당 파라미터나 그 값 없이 "
"제자리에서 다시 작성됩니다. 선택적 *header*\\는 :mailheader:`Content-Type`\\의 대체 헤더를 "
"지정합니다."

#: ../../library/email.message.rst:400
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader"
":`Content-Disposition` header of the message.  If the header does not "
"have a ``filename`` parameter, this method falls back to looking for the "
"``name`` parameter on the :mailheader:`Content-Type` header.  If neither "
"is found, or the header is missing, then *failobj* is returned. The "
"returned string will always be unquoted as per "
":func:`email.utils.unquote`."
msgstr ""
"메시지의 :mailheader:`Content-Disposition` 헤더의 ``filename`` 파라미터값을 반환합니다. 헤더에"
" ``filename`` 파라미터가 없으면, 이 메서드는 :mailheader:`Content-Type` 헤더에서 ``name`` "
"파라미터를 찾는 것으로 폴백(fallback)합니다. 둘 다 없거나 헤더가 없으면, *failobj*\\가 반환됩니다. 반환된 "
"문자열은 항상 :func:`email.utils.unquote`\\에 따라 unquote 됩니다."

#: ../../library/email.message.rst:411
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader"
":`Content-Type` header of the message, or *failobj* if either the header "
"is missing, or has no ``boundary`` parameter.  The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"메시지의 :mailheader:`Content-Type` 헤더의 ``boundary`` 파라미터값, 또는 헤더가 없거나 "
"``boundary`` 파라미터가 없으면 *failobj*\\를 반환합니다. 반환된 문자열은 항상 "
":func:`email.utils.unquote`\\에 따라 unquote 됩니다."

#: ../../library/email.message.rst:419
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header "
"to *boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the "
"message object has no :mailheader:`Content-Type` header."
msgstr ""
":mailheader:`Content-Type` 헤더의 ``boundary`` 파라미터를 *boundary*\\로 설정합니다. "
"필요하면 :meth:`set_boundary`\\는 항상 *boundary*\\를 quote 합니다. 메시지 객체에 "
":mailheader:`Content-Type` 헤더가 없으면 "
":exc:`~email.errors.HeaderParseError`\\가 발생합니다."

#: ../../library/email.message.rst:424
msgid ""
"Note that using this method is subtly different from deleting the old "
":mailheader:`Content-Type` header and adding a new one with the new "
"boundary via :meth:`add_header`, because :meth:`set_boundary` preserves "
"the order of the :mailheader:`Content-Type` header in the list of "
"headers."
msgstr ""
":meth:`set_boundary`\\가 헤더 리스트에서 :mailheader:`Content-Type` 헤더의 순서를 유지하기 "
"때문에, 이 메서드를 사용하는 것은 이전 :mailheader:`Content-Type` 헤더를 삭제하고 "
":meth:`add_header`\\를 통해 새 boundary로 새 헤더를 추가하는 것과는 미묘한 차이가 있음에 유의하십시오."

#: ../../library/email.message.rst:433
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` "
"header, coerced to lower case.  If there is no :mailheader:`Content-Type`"
" header, or if that header has no ``charset`` parameter, *failobj* is "
"returned."
msgstr ""
":mailheader:`Content-Type` 헤더의 ``charset`` 파라미터를 소문자로 강제 변환하여 반환합니다. "
":mailheader:`Content-Type` 헤더가 없거나 헤더에 ``charset`` 파라미터가 없으면 *failobj*\\가"
" 반환됩니다."

#: ../../library/email.message.rst:440
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one "
"element for each subpart in the payload, otherwise, it will be a list of "
"length 1."
msgstr ""
"메시지 내의 문자 집합 이름들을 포함하는 리스트를 반환합니다. 메시지가 :mimetype:`multipart`\\이면, 리스트는 "
"페이 로드의 각 서브 파트마다 하나의 요소를 포함하며, 그렇지 않으면 길이 1인 리스트가 됩니다."

#: ../../library/email.message.rst:444
msgid ""
"Each item in the list will be a string which is the value of the "
"``charset`` parameter in the :mailheader:`Content-Type` header for the "
"represented subpart.  If the subpart has no :mailheader:`Content-Type` "
"header, no ``charset`` parameter, or is not of the :mimetype:`text` main "
"MIME type, then that item in the returned list will be *failobj*."
msgstr ""
"리스트의 각 항목은 표현된 서브 파트에 대한 :mailheader:`Content-Type` 헤더의 ``charset`` 파라미터의"
" 값인 문자열입니다. 서브 파트에 :mailheader:`Content-Type` 헤더가 없거나, ``charset`` 파라미터가 "
"없거나, :mimetype:`text` 메인 MIME 유형이 아니면, 반환된 리스트의 해당 항목은 *failobj*\\입니다."

#: ../../library/email.message.rst:453
msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header "
"and its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr ""
":mailheader:`Content-Disposition` 헤더가 있고 (대소 문자를 구분하지 않는) 값이 "
"``attachment``\\이면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/email.message.rst:456
msgid ""
"is_attachment is now a method instead of a property, for consistency with"
" :meth:`~email.message.Message.is_multipart`."
msgstr ""
":meth:`~email.message.Message.is_multipart`\\와 일관성을 유지하기 위해, "
"is_attachment는 이제 프로퍼티 대신 메서드입니다."

#: ../../library/email.message.rst:463
msgid ""
"Return the lowercased value (without parameters) of the message's "
":mailheader:`Content-Disposition` header if it has one, or ``None``.  The"
" possible values for this method are *inline*, *attachment* or ``None`` "
"if the message follows :rfc:`2183`."
msgstr ""
"메시지의 :mailheader:`Content-Disposition` 헤더가 있으면 소문자로 변환된 (파라미터 없는) 값을, 그렇지"
" 않으면 ``None``\\을 반환합니다. 메시지가 :rfc:`2183`\\을 따르면, 이 메서드의 가능한 값은 *inline*, "
"*attachment* 또는 ``None``\\입니다."

#: ../../library/email.message.rst:471
msgid ""
"The following methods relate to interrogating and manipulating the "
"content (payload) of the message."
msgstr "다음 메서드는 메시지의 내용(페이 로드)을 조사하고 조작하는 것과 관련이 있습니다."

#: ../../library/email.message.rst:477
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in "
"depth-first traversal order.  You will typically use :meth:`walk` as the "
"iterator in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
":meth:`walk` 메서드는 메시지 객체 트리의 모든 파트와 서브 파트를 깊이 우선 탐색 순서로 이터레이트 하는 데 사용할 수 "
"있는 범용 제너레이터입니다. 일반적으로 :meth:`walk`\\를 ``for`` 루프에서 이터레이터로 사용합니다; 각 이터레이션은"
" 다음 서브 파트를 반환합니다."

#: ../../library/email.message.rst:482
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr "다음은 멀티 파트 메시지 구조의 모든 파트의 MIME 유형을 인쇄하는 예입니다:"

#: ../../library/email.message.rst:491
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""

#: ../../library/email.message.rst:503
msgid ""
"``walk`` iterates over the subparts of any part where "
":meth:`is_multipart` returns ``True``, even though "
"``msg.get_content_maintype() == 'multipart'`` may return ``False``.  We "
"can see this in our example by making use of the ``_structure`` debug "
"helper function:"
msgstr ""
"``msg.get_content_maintype() == 'multipart'``\\가 ``False``\\를 반환하더라도, "
"``walk``\\는 :meth:`is_multipart`\\가 ``True``\\를 반환하는 모든 파트의 서브 파트를 이터레이트 "
"합니다. ``_structure`` 디버그 도우미 함수를 사용하여 예제에서 이를 확인할 수 있습니다:"

#: ../../library/email.message.rst:509
msgid ""
">>> from email.iterators import _structure\n"
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""

#: ../../library/email.message.rst:531
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into "
"the subparts."
msgstr ""
"여기서 ``message`` 파트는 ``multiparts``\\는 아니지만, 서브 파트를 포함합니다. "
"``is_multipart()``\\는 ``True``\\를 반환하고 ``walk``\\는 서브 파트로 내려갑니다."

#: ../../library/email.message.rst:538
msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the"
" message."
msgstr "메시지의 \"본문\"이 될 수 있는 가장 적합한 후보인 MIME 파트를 반환합니다."

#: ../../library/email.message.rst:541
msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist*\\는 ``related``, ``html`` 및 ``plain`` 집합의 문자열 시퀀스이어야 하며, "
"반환된 파트의 콘텐츠 유형에 대한 선호 순서를 나타냅니다."

#: ../../library/email.message.rst:545
msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr "``get_body`` 메서드가 호출된 객체와 일치하는 후보를 찾기 시작합니다."

#: ../../library/email.message.rst:548
msgid ""
"If ``related`` is not included in *preferencelist*, consider the root "
"part (or subpart of the root part) of any related encountered as a "
"candidate if the (sub-)part matches a preference."
msgstr ""
"``related``\\가 *preferencelist*\\에 포함되지 않으면, (서브) 파트가 선호와 일치하면 후보로 만난 모든 "
"관련(related)의 루트 파트(또는 루트 파트의 서브 파트)를 고려합니다."

#: ../../library/email.message.rst:552
msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter "
"and if a part with a matching :mailheader:`Content-ID` is found, consider"
" only it when looking for candidate matches.  Otherwise consider only the"
" first (default root) part of the ``multipart/related``."
msgstr ""
"``multipart/related``\\와 만날 때, ``start`` 파라미터를 확인하고 일치하는 :mailheader"
":`Content-ID`\\가 있는 파트를 발견하면, 일치하는 후보를 찾을 때만 고려합니다. 그렇지 않으면 "
"``multipart/related``\\의 첫 번째 (기본 루트) 파트만 고려합니다."

#: ../../library/email.message.rst:557
msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider "
"the part a candidate match if the value of the header is ``inline``."
msgstr ""
"파트에 :mailheader:`Content-Disposition` 헤더가 있으면, 헤더 값이 ``inline``\\일 때만 해당 "
"파트를 후보로 간주합니다."

#: ../../library/email.message.rst:560
msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr "*preferencelist*\\의 선호 어느 것과도 일치하는 후보가 없으면, ``None``\\을 반환합니다."

#: ../../library/email.message.rst:563
msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations "
"that really make sense are ``('plain',)``, ``('html', 'plain')``, and the"
" default ``('related', 'html', 'plain')``.  (2) Because matching starts "
"with the object on which ``get_body`` is called, calling ``get_body`` on "
"a ``multipart/related`` will return the object itself unless "
"*preferencelist* has a non-default value. (3) Messages (or message parts)"
" that do not specify a :mailheader:`Content-Type` or whose :mailheader"
":`Content-Type` header is invalid will be treated as if they are of type "
"``text/plain``, which may occasionally cause ``get_body`` to return "
"unexpected results."
msgstr ""
"참고: (1) 대부분의 응용 프로그램에서 실제로 의미가 있는 *preferencelist* 조합은 ``('plain',)``, "
"``('html', 'plain')`` 및 기본 ``('related', 'html', 'plain')``\\뿐입니다. (2) "
"``get_body``\\가 호출되는 객체에서 일치가 시작되므로, *preferencelist*\\가 기본값이면 "
"``multipart/related``\\에서 ``get_body``\\를 호출하면 객체 자신을 반환합니다. (3) "
":mailheader:`Content-Type`\\을 지정하지 않거나 :mailheader:`Content-Type` 헤더가 "
"유효하지 않은 메시지(또는 메시지 파트)는 마치 ``text/plain`` 유형인 것처럼 처리되어, 간혹 "
"``get_body``\\가 예기치 않은 결과를 반환하도록 합니다."

#: ../../library/email.message.rst:577
msgid ""
"Return an iterator over all of the immediate sub-parts of the message "
"that are not candidate \"body\" parts.  That is, skip the first "
"occurrence of each of ``text/plain``, ``text/html``, "
"``multipart/related``, or ``multipart/alternative`` (unless they are "
"explicitly marked as attachments via :mailheader:`Content-Disposition: "
"attachment`), and return all remaining parts.  When applied directly to a"
" ``multipart/related``, return an iterator over the all the related parts"
" except the root part (ie: the part pointed to by the ``start`` "
"parameter, or the first part if there is no ``start`` parameter or the "
"``start`` parameter doesn't match the :mailheader:`Content-ID` of any of "
"the parts).  When applied directly to a ``multipart/alternative`` or a "
"non-``multipart``, return an empty iterator."
msgstr ""
"\"본문\" 파트 후보가 아닌 메시지의 모든 직접적인 서브 파트에 대한 이터레이터를 반환합니다. 즉, ``text/plain``, "
"``text/html``, ``multipart/related`` 또는 ``multipart/alternative`` 각각의 첫 "
"번째 등장을 건너뛰고 (:mailheader:`Content-Disposition: attachment`\\를 통해 첨부 파일로 "
"명시적으로 표시되지 않은 한), 나머지 모든 파트를 반환합니다. ``multipart/related``\\에 직접 적용될 때, 루트"
" 파트(즉: ``start`` 파라미터가 가리키는 파트나 ``start`` 파라미터가 없거나 ``start`` 파라미터가 파트들의 "
":mailheader:`Content-ID`\\와 일치하지 않으면 첫 번째 파트)를 제외한 모든 관련 파트에 대한 이터레이터를 "
"반환합니다. ``multipart/alternative`` 또는 비-``multipart``\\에 직접 적용되면 빈 이터레이터를 "
"반환합니다."

#: ../../library/email.message.rst:593
msgid ""
"Return an iterator over all of the immediate sub-parts of the message, "
"which will be empty for a non-``multipart``.  (See also "
":meth:`~email.message.EmailMessage.walk`.)"
msgstr ""
"메시지의 모든 직계 서브 파트에 대한 이터레이터를 반환합니다. ``multipart``\\가 아니면 비어있게 됩니다. "
"(:meth:`~email.message.EmailMessage.walk`\\도 참조하십시오.)"

#: ../../library/email.message.rst:600
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method "
"of the *content_manager*, passing self as the message object, and passing"
" along any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified"
" by the current :mod:`~email.policy`."
msgstr ""
"*content_manager*\\의 "
":meth:`~email.contentmanager.ContentManager.get_content` 메서드를 호출합니다. 추가 "
"인자로 제공되는 인자나 키워드와 함께 self를 메시지 객체로 전달합니다. *content_manager*\\가 지정되지 않으면, "
"현재 :mod:`~email.policy`\\가 지정하는 ``content_manager``\\를 사용합니다."

#: ../../library/email.message.rst:609
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method "
"of the *content_manager*, passing self as the message object, and passing"
" along any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified"
" by the current :mod:`~email.policy`."
msgstr ""
"*content_manager*\\의 "
":meth:`~email.contentmanager.ContentManager.set_content` 메서드를 호출합니다. 추가 "
"인자로 제공되는 인자나 키워드와 함께 self를 메시지 객체로 전달합니다. *content_manager*\\가 지정되지 않으면, "
"현재 :mod:`~email.policy`\\가 지정하는 ``content_manager``\\를 사용합니다."

#: ../../library/email.message.rst:618
msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message,"
" moving any existing :mailheader:`Content-` headers and payload into a "
"(new) first part of the ``multipart``.  If *boundary* is specified, use "
"it as the boundary string in the multipart, otherwise leave the boundary "
"to be automatically created when it is needed (for example, when the "
"message is serialized)."
msgstr ""
"비 ``multipart`` 메시지를 ``multipart/related`` 메시지로 변환합니다. 기존 "
":mailheader:`Content-` 헤더와 페이 로드를 ``multipart``\\의 (새로운) 첫 파트로 옮깁니다. "
"*boundary*\\가 지정되면, multipart에서 경계 문자열로 사용하고, 그렇지 않으면 필요할 때 (예를 들어, 메시지가 "
"직렬화될 때) 경계가 자동으로 만들어지도록 둡니다."

#: ../../library/email.message.rst:628
msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a "
"``multipart/alternative``, moving any existing :mailheader:`Content-` "
"headers and payload into a (new) first part of the ``multipart``.  If "
"*boundary* is specified, use it as the boundary string in the multipart, "
"otherwise leave the boundary to be automatically created when it is "
"needed (for example, when the message is serialized)."
msgstr ""
"비 ``multipart``\\나 ``multipart/related``\\를 ``multipart/alternative``\\로 "
"변환합니다. 기존 :mailheader:`Content-` 헤더와 페이 로드를 ``multipart``\\의 (새로운) 첫 파트로 "
"옮깁니다. *boundary*\\가 지정되면, multipart에서 경계 문자열로 사용하고, 그렇지 않으면 필요할 때 (예를 들어,"
" 메시지가 직렬화될 때) 경계가 자동으로 만들어지도록 둡니다."

#: ../../library/email.message.rst:638
msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing "
":mailheader:`Content-` headers and payload into a (new) first part of the"
" ``multipart``.  If *boundary* is specified, use it as the boundary "
"string in the multipart, otherwise leave the boundary to be automatically"
" created when it is needed (for example, when the message is serialized)."
msgstr ""
"비 ``multipart``, ``multipart/related`` 또는 ``multipart-alternative``\\를 "
"``multipart/mixed``\\로 변환합니다. 기존 :mailheader:`Content-` 헤더와 페이 로드를 "
"``multipart``\\의 (새로운) 첫 파트로 옮깁니다. *boundary*\\가 지정되면, multipart에서 경계 "
"문자열로 사용하고, 그렇지 않으면 필요할 때 (예를 들어, 메시지가 직렬화될 때) 경계가 자동으로 만들어지도록 둡니다."

#: ../../library/email.message.rst:648
msgid ""
"If the message is a ``multipart/related``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and "
":meth:`~email.message.Message.attach` it to the ``multipart``.  If the "
"message is a non-``multipart``, call :meth:`make_related` and then "
"proceed as above.  If the message is any other type of ``multipart``, "
"raise a :exc:`TypeError`. If *content_manager* is not specified, use the "
"``content_manager`` specified by the current :mod:`~email.policy`. If the"
" added part has no :mailheader:`Content-Disposition` header, add one with"
" the value ``inline``."
msgstr ""
"메시지가 ``multipart/related``\\이면, 새 메시지 객체를 만들고, 모든 인자를 그것의 "
":meth:`set_content` 메서드에 전달하고, 그것을 ``multipart``\\에 "
":meth:`~email.message.Message.attach`\\합니다. 메시지가 ``multipart``\\가 아니면, "
":meth:`make_related`\\를 호출한 다음 위에서처럼 진행합니다. 메시지가 다른 유형의 "
"``multipart``\\이면, :exc:`TypeError`\\를 발생시킵니다. *content_manager*\\가 지정되지 "
"않으면, 현재 :mod:`~email.policy`\\가 지정하는 ``content_manager``\\를 사용합니다. 추가된 "
"파트에 :mailheader:`Content-Disposition` 헤더가 없으면, 값 ``inline``\\으로 추가합니다."

#: ../../library/email.message.rst:661
msgid ""
"If the message is a ``multipart/alternative``, create a new message "
"object, pass all of the arguments to its :meth:`set_content` method, and "
":meth:`~email.message.Message.attach` it to the ``multipart``.  If the "
"message is a non-``multipart`` or ``multipart/related``, call "
":meth:`make_alternative` and then proceed as above.  If the message is "
"any other type of ``multipart``, raise a :exc:`TypeError`. If "
"*content_manager* is not specified, use the ``content_manager`` specified"
" by the current :mod:`~email.policy`."
msgstr ""
"메시지가 ``multipart/alternative``\\이면, 새 메시지 객체를 만들고, 모든 인자를 그것의 "
":meth:`set_content` 메서드에 전달하고, 그것을 ``multipart``\\에 "
":meth:`~email.message.Message.attach`\\합니다. 메시지가 ``multipart``\\가 아니거나 "
"``multipart/related``\\이면, :meth:`make_alternative`\\를 호출한 다음 위에서처럼 "
"진행합니다. 메시지가 다른 유형의 ``multipart``\\이면, :exc:`TypeError`\\를 발생시킵니다. "
"*content_manager*\\가 지정되지 않으면, 현재 :mod:`~email.policy`\\가 지정하는 "
"``content_manager``\\를 사용합니다."

#: ../../library/email.message.rst:673
msgid ""
"If the message is a ``multipart/mixed``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and "
":meth:`~email.message.Message.attach` it to the ``multipart``.  If the "
"message is a non-``multipart``, ``multipart/related``, or "
"``multipart/alternative``, call :meth:`make_mixed` and then proceed as "
"above. If *content_manager* is not specified, use the ``content_manager``"
" specified by the current :mod:`~email.policy`.  If the added part has no"
" :mailheader:`Content-Disposition` header, add one with the value "
"``attachment``.  This method can be used both for explicit attachments "
"(:mailheader:`Content-Disposition: attachment`) and ``inline`` "
"attachments (:mailheader:`Content-Disposition: inline`), by passing "
"appropriate options to the ``content_manager``."
msgstr ""
"메시지가 ``multipart/mixed``\\이면, 새 메시지 객체를 만들고, 모든 인자를 그것의 "
":meth:`set_content` 메서드에 전달하고, 그것을 ``multipart``\\에 "
":meth:`~email.message.Message.attach`\\합니다. 메시지가 ``multipart``\\가 아니거나, "
"``multipart/related``\\나 ``multipart/alternative``\\이면, "
":meth:`make_mixed`\\를 호출한 다음 위에서처럼 진행합니다. *content_manager*\\가 지정되지 않으면, "
"현재 :mod:`~email.policy`\\가 지정하는 ``content_manager``\\를 사용합니다. 추가된 파트에 "
":mailheader:`Content-Disposition` 헤더가 없으면, 값 ``attachment``\\로 추가합니다. 이 "
"메서드는 ``content_manager``\\에 적절한 옵션을 전달하여 명시적 첨부(:mailheader:`Content-"
"Disposition: attachment`)와 ``inline`` 첨부(:mailheader:`Content-"
"Disposition: inline`)에 모두 사용할 수 있습니다."

#: ../../library/email.message.rst:689
msgid "Remove the payload and all of the headers."
msgstr "페이 로드와 모든 헤더를 제거합니다."

#: ../../library/email.message.rst:694
#, fuzzy
msgid ""
"Remove the payload and all of the :mailheader:`!Content-` headers, "
"leaving all other headers intact and in their original order."
msgstr "페이 로드와 모든 :exc:`Content-` 헤더를 제거하고, 다른 모든 헤더는 원래 순서대로 그대로 둡니다."

#: ../../library/email.message.rst:698
msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr ":class:`EmailMessage` 객체에는 다음과 같은 인스턴스 어트리뷰트가 있습니다:"

#: ../../library/email.message.rst:703
msgid ""
"The format of a MIME document allows for some text between the blank line"
" following the headers, and the first multipart boundary string. "
"Normally, this text is never visible in a MIME-aware mail reader because "
"it falls outside the standard MIME armor.  However, when viewing the raw "
"text of the message, or when viewing the message in a non-MIME aware "
"reader, this text can become visible."
msgstr ""
"MIME 문서의 형식은 헤더 다음의 빈 줄과 첫 번째 멀티 파트 경계 문자열 사이에 어떤 텍스트를 허용합니다. 일반적으로 이 "
"텍스트는 표준 MIME 방어구를 벗어나기 때문에 MIME을 인식하는 메일 리더에서 보이지 않습니다. 그러나, 메시지의 원시 텍스트를"
" 보거나, MIME을 인식하지 않는 리더에서 메시지를 볼 때 이 텍스트가 나타날 수 있습니다."

#: ../../library/email.message.rst:710
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text "
"after the headers but before the first boundary string, it assigns this "
"text to the message's *preamble* attribute.  When the "
":class:`~email.generator.Generator` is writing out the plain text "
"representation of a MIME message, and it finds the message has a "
"*preamble* attribute, it will write this text in the area between the "
"headers and the first boundary.  See :mod:`email.parser` and "
":mod:`email.generator` for details."
msgstr ""
"*preamble* 어트리뷰트는 MIME 문서에 있는 이 선행 방어구 밖 텍스트를 포함합니다. "
":class:`~email.parser.Parser`\\가 헤더 다음이지만 첫 번째 경계 문자열 이전에 있는 어떤 텍스트를 "
"발견하면, 이 텍스트를 메시지의 *preamble* 어트리뷰트에 대입합니다. "
":class:`~email.generator.Generator`\\가 MIME 메시지의 일반 텍스트(plain text) 표현을 "
"기록할 때, 메시지가 *preamble* 어트리뷰트를 가진 것을 발견하면, 헤더와 첫 번째 경계 사이의 영역에 이 텍스트를 씁니다."
" 자세한 내용은 :mod:`email.parser`\\와 :mod:`email.generator`\\를 참조하십시오."

#: ../../library/email.message.rst:720
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute"
" will be ``None``."
msgstr "메시지 객체에 preamble이 없으면, *preamble* 어트리뷰트는 ``None``\\입니다."

#: ../../library/email.message.rst:726
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and "
"the end of the message.  As with the :attr:`~EmailMessage.preamble`, if "
"there is no epilog text this attribute will be ``None``."
msgstr ""
"*epilogue* 어트리뷰트는 메시지의 마지막 경계와 끝 사이에 나타나는 텍스트를 포함한다는 점을 제외하고 *preamble* "
"어트리뷰트와 같은 방식으로 작동합니다. :attr:`~EmailMessage.preamble`\\과 마찬가지로 epilog 텍스트가"
" 없으면, 이 어트리뷰트는 ``None``\\입니다."

#: ../../library/email.message.rst:734
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description"
" of the possible parsing defects."
msgstr ""
"*defects* 어트리뷰트는 이 메시지를 구문 분석할 때 발견된 모든 문제점의 리스트를 포함합니다. 가능한 구문 분석 결함에 대한"
" 자세한 설명은 :mod:`email.errors`\\를 참조하십시오."

#: ../../library/email.message.rst:741
msgid ""
"This class represents a subpart of a MIME message.  It is identical to "
":class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers "
"are added when :meth:`~EmailMessage.set_content` is called, since sub-"
"parts do not need their own :mailheader:`MIME-Version` headers."
msgstr ""
"이 클래스는 MIME 메시지의 서브 파트를 나타냅니다. 서브 파트에는 자체 :mailheader:`MIME-Version` 헤더가 "
"필요하지 않아서, :meth:`~EmailMessage.set_content`\\를 호출할 때 :mailheader:`MIME-"
"Version` 헤더가 추가되지 않는다는 점을 제외하면 :class:`EmailMessage`\\와 같습니다."

#: ../../library/email.message.rst:748
msgid "Footnotes"
msgstr "각주"

#: ../../library/email.message.rst:749
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to "
":ref:`compat32_message`."
msgstr ""
"원래 3.4에서 :term:`잠정 모듈 <provisional package>`\\로 추가되었습니다. 레거시 메시지 클래스를 위한 "
"설명서는 :ref:`compat32_message`\\로 옮겼습니다."

