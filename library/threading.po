# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/threading.rst:2
#, fuzzy
msgid ":mod:`!threading` --- Thread-based parallelism"
msgstr ":mod:`threading` --- 스레드 기반 병렬 처리"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**소스 코드:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
#, fuzzy
msgid ""
"This module constructs higher-level threading interfaces on top of the "
"lower level :mod:`_thread` module."
msgstr ""
"이 모듈은 저수준 :mod:`_thread` 모듈 위에 고수준 스레딩 인터페이스를 구축합니다. :mod:`queue` 모듈도 "
"참조하십시오."

#: ../../library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr "이 모듈은 선택 사양이었지만, 이제는 항상 사용 가능합니다."

#: ../../library/threading.rst:19
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution"
" of the calling thread, while still being able to retrieve their results "
"when needed."
msgstr ""

#: ../../library/threading.rst:23
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between"
" running threads."
msgstr ""

#: ../../library/threading.rst:26
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system "
"threads."
msgstr ""

#: ../../library/threading.rst:31
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for "
"some methods and functions. These are deprecated as of Python 3.10, but "
"they are still supported for compatibility with Python 2.5 and lower."
msgstr ""

#: ../../library/threading.rst:38
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter"
" lock>`, only one thread can execute Python code at once (even though "
"certain performance-oriented libraries might overcome this limitation). "
"If you want your application to make better use of the computational "
"resources of multi-core machines, you are advised to use "
":mod:`multiprocessing` or "
":class:`concurrent.futures.ProcessPoolExecutor`. However, threading is "
"still an appropriate model if you want to run multiple I/O-bound tasks "
"simultaneously."
msgstr ""
"CPython에서는, :term:`전역 인터프리터 록 <global interpreter lock>`\\으로 인해 한 번에 하나의 "
"스레드만 파이썬 코드를 실행할 수 있습니다 (설사 일부 성능 지향 라이브러리가 이 제한을 극복할 수 있을지라도). 응용 프로그램에서"
" 멀티 코어 기계의 계산 자원을 더 잘 활용하려면 :mod:`multiprocessing`\\이나 "
":class:`concurrent.futures.ProcessPoolExecutor`\\를 사용하는 것이 좋습니다. 그러나, 여러 "
"I/O 병목 작업을 동시에 실행하고 싶을 때 threading은 여전히 적절한 모델입니다."

#: ../../includes/wasm-notavail.rst:3 ../../library/threading.rst:130
#: ../../library/threading.rst:229 ../../library/threading.rst:468
msgid "Availability"
msgstr "가용성"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref"
":`wasm-availability` for more information."
msgstr ""
"이 모듈은 웹어셈블리에서 작동하지 않거나 제공되지 않습니다. 자세한 내용은 :ref:`wasm-availability`\\을 "
"참조하세요."

#: ../../library/threading.rst:50
msgid "This module defines the following functions:"
msgstr "이 모듈은 다음 함수를 정의합니다:"

#: ../../library/threading.rst:55
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The "
"returned count is equal to the length of the list returned by "
":func:`.enumerate`."
msgstr ""
"현재 살아있는 :class:`Thread` 객체 수를 반환합니다. 반환된 수는 :func:`.enumerate`\\가 반환한 "
"리스트의 길이와 같습니다."

#: ../../library/threading.rst:58
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr ""

#: ../../library/threading.rst:63
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"호출자의 제어 스레드에 해당하는 현재 :class:`Thread` 객체를 반환합니다. 호출자의 제어 스레드가 "
":mod:`threading` 모듈을 통해 만들어지지 않았으면, 기능이 제한된 더미 스레드 객체가 반환됩니다."

#: ../../library/threading.rst:68
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr ""

#: ../../library/threading.rst:73
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr ":func:`Thread.run`\\에 의해 발생한 포착되지 않은 예외를 처리합니다."

#: ../../library/threading.rst:75
msgid "The *args* argument has the following attributes:"
msgstr "*args* 인자에는 다음과 같은 어트리뷰트가 있습니다:"

#: ../../library/threading.rst:77
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: 예외 형."

#: ../../library/threading.rst:78
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*: 예외 값, ``None``\\일 수 있습니다."

#: ../../library/threading.rst:79
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: 예외 트레이스백, ``None``\\일 수 있습니다."

#: ../../library/threading.rst:80
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*thread*: 예외를 발생시킨 스레드, ``None``\\일 수 있습니다."

#: ../../library/threading.rst:82
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"*exc_type*\\이 :exc:`SystemExit`\\이면, 예외는 조용히 무시됩니다. 그렇지 않으면, "
":data:`sys.stderr`\\에 예외가 인쇄됩니다."

#: ../../library/threading.rst:85
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called "
"to handle it."
msgstr "이 함수에서 예외가 발생하면, 이를 처리하기 위해 :func:`sys.excepthook`\\이 호출됩니다."

#: ../../library/threading.rst:88
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`Thread.run`\\에 의해 발생한 포착되지 않은 예외를 처리하는 방법을 제어하기 위해 "
":func:`threading.excepthook`\\을 재정의할 수 있습니다."

#: ../../library/threading.rst:91
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the "
"exception is no longer needed."
msgstr ""
"사용자 정의 훅을 사용하여 *exc_value*\\를 저장하면 참조 순환을 만들 수 있습니다. 예외가 더는 필요하지 않을 때 참조 "
"순환을 끊기 위해 명시적으로 지워야 합니다."

#: ../../library/threading.rst:95
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"사용자 정의 훅을 사용하여 *thread*\\를 저장하면 파이널라이즈 중인 객체로 설정되면 이를 되살릴 수 있습니다. 객체를 "
"되살리는 것을 방지하려면 사용자 정의 훅이 완료된 후 *thread*\\를 보관하지 마십시오."

#: ../../library/threading.rst:100
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook`\\은 포착되지 않은 예외를 처리합니다."

#: ../../library/threading.rst:106
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get "
"replaced with broken or alternative objects."
msgstr ""

#: ../../library/threading.rst:114
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic "
"cookie to be used e.g. to index a dictionary of thread-specific data.  "
"Thread identifiers may be recycled when a thread exits and another thread"
" is created."
msgstr ""
"현재 스레드의 '스레드 식별자'를 반환합니다. 이것은 0이 아닌 정수입니다. 이 값은 직접적인 의미가 없습니다; 이것은 매직 쿠키로"
" 사용하려는 것입니다, 예를 들어 스레드 특정 데이터의 딕셔너리를 인덱싱하는 데 사용됩니다. 스레드 식별자는 스레드가 종료되고 다른"
" 스레드가 만들어질 때 재활용될 수 있습니다."

#: ../../library/threading.rst:125
msgid ""
"Return the native integral Thread ID of the current thread assigned by "
"the kernel. This is a non-negative integer. Its value may be used to "
"uniquely identify this particular thread system-wide (until the thread "
"terminates, after which the value may be recycled by the OS)."
msgstr ""
"커널이 할당한 현재 스레드의 네이티브 정수 스레드 ID를 반환합니다. 음수가 아닌 정수입니다. 이 값은 시스템 전체에서 이 특정 "
"스레드를 고유하게 식별하는 데 사용될 수 있습니다 (스레드가 종료될 때까지, 그 후에는 OS에서 값을 재활용할 수 있습니다)."

#: ../../library/threading.rst:134
msgid "Added support for GNU/kFreeBSD."
msgstr ""

#: ../../library/threading.rst:140
#, fuzzy
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by "
":func:`current_thread`.  It excludes terminated threads and threads that "
"have not yet been started.  However, the main thread is always part of "
"the result, even when terminated."
msgstr ""
"현재 살아있는 모든 :class:`Thread` 객체의 리스트를 반환합니다. 이 리스트에는 데몬 스레드, "
":func:`current_thread`\\에서 만든 더미 스레드 객체 및 메인 스레드가 포함됩니다. 종료된 스레드와 아직 시작되지"
" 않은 스레드는 제외합니다."

#: ../../library/threading.rst:149
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr "메인 :class:`Thread` 객체를 반환합니다. 정상적인 조건에서, 메인 스레드는 파이썬 인터프리터가 시작된 스레드입니다."

#: ../../library/threading.rst:160
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` 모듈에서 시작된 모든 스레드에 대한 추적 함수를 설정합니다. *func*\\는 "
":meth:`~Thread.run` 메서드가 호출되기 전에 각 스레드에 대해 :func:`sys.settrace`\\로 전달됩니다."

#: ../../library/threading.rst:166
#, fuzzy
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module and all Python threads that are currently executing."
msgstr ""
":mod:`threading` 모듈에서 시작된 모든 스레드에 대한 추적 함수를 설정합니다. *func*\\는 "
":meth:`~Thread.run` 메서드가 호출되기 전에 각 스레드에 대해 :func:`sys.settrace`\\로 전달됩니다."

#: ../../library/threading.rst:169
#, fuzzy
msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` 모듈에서 시작된 모든 스레드에 대한 추적 함수를 설정합니다. *func*\\는 "
":meth:`~Thread.run` 메서드가 호출되기 전에 각 스레드에 대해 :func:`sys.settrace`\\로 전달됩니다."

#: ../../library/threading.rst:180
msgid "Get the trace function as set by :func:`settrace`."
msgstr ""

#: ../../library/threading.rst:189
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` 모듈에서 시작된 모든 스레드에 대한 프로파일 함수를 설정합니다. *func*\\는 "
":meth:`~Thread.run` 메서드가 호출되기 전에 각 스레드에 대해 :func:`sys.setprofile`\\로 "
"전달됩니다."

#: ../../library/threading.rst:195
#, fuzzy
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module and all Python threads that are currently executing."
msgstr ""
":mod:`threading` 모듈에서 시작된 모든 스레드에 대한 프로파일 함수를 설정합니다. *func*\\는 "
":meth:`~Thread.run` 메서드가 호출되기 전에 각 스레드에 대해 :func:`sys.setprofile`\\로 "
"전달됩니다."

#: ../../library/threading.rst:198
#, fuzzy
msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
":mod:`threading` 모듈에서 시작된 모든 스레드에 대한 프로파일 함수를 설정합니다. *func*\\는 "
":meth:`~Thread.run` 메서드가 호출되기 전에 각 스레드에 대해 :func:`sys.setprofile`\\로 "
"전달됩니다."

#: ../../library/threading.rst:207
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr ""

#: ../../library/threading.rst:214
msgid ""
"Return the thread stack size used when creating new threads.  The "
"optional *size* argument specifies the stack size to be used for "
"subsequently created threads, and must be 0 (use platform or configured "
"default) or a positive integer value of at least 32,768 (32 KiB). If "
"*size* is not specified, 0 is used.  If changing the thread stack size is"
" unsupported, a :exc:`RuntimeError` is raised.  If the specified stack "
"size is invalid, a :exc:`ValueError` is raised and the stack size is "
"unmodified.  32 KiB is currently the minimum supported stack size value "
"to guarantee sufficient stack space for the interpreter itself.  Note "
"that some platforms may have particular restrictions on values for the "
"stack size, such as requiring a minimum stack size > 32 KiB or requiring "
"allocation in multiples of the system memory page size - platform "
"documentation should be referred to for more information (4 KiB pages are"
" common; using multiples of 4096 for the stack size is the suggested "
"approach in the absence of more specific information)."
msgstr ""
"새 스레드를 만들 때 사용된 스레드 스택 크기를 반환합니다. 선택적 *size* 인자는 이후에 만들어지는 스레드에 사용할 스택 "
"크기를 지정하며, 0(플랫폼이나 구성된 기본값을 사용합니다)이거나 32,768 (32 KiB) 이상의 양의 정숫값이어야 합니다. "
"*size*\\를 지정하지 않으면, 0이 사용됩니다. 스레드 스택 크기 변경이 지원되지 않으면, "
":exc:`RuntimeError`\\가 발생합니다. 지정된 스택 크기가 유효하지 않으면, :exc:`ValueError`\\가 "
"발생하고 스택 크기는 수정되지 않습니다. 32 KiB는 현재 인터프리터 자체에 충분한 스택 공간을 보장하기 위해 지원되는 최소 스택"
" 크기 값입니다. 최소 스택 크기가 32 KiB 보다 커야 한다거나 시스템 메모리 페이지 크기의 배수로 할당해야 하는 등 일부 "
"플랫폼에는 스택 크기 값에 대한 특정 제한이 있을 수 있습니다 - 자세한 내용은 플랫폼 설명서를 참조하십시오 (4 KiB 페이지는 "
"흔합니다; 스택 크기에 4096의 배수를 사용하는 것이 더 구체적인 정보가 없을 때 제안하는 방법입니다)."

#: ../../library/threading.rst:231
msgid "Unix platforms with POSIX threads support."
msgstr ""

#: ../../library/threading.rst:234
msgid "This module also defines the following constant:"
msgstr "이 모듈은 또한 다음 상수를 정의합니다:"

#: ../../library/threading.rst:238
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking "
"functions (:meth:`Lock.acquire`, :meth:`RLock.acquire`, "
":meth:`Condition.wait`, etc.). Specifying a timeout greater than this "
"value will raise an :exc:`OverflowError`."
msgstr ""
"블로킹 함수(:meth:`Lock.acquire`, :meth:`RLock.acquire`, "
":meth:`Condition.wait` 등)의 *timeout* 매개 변수에 허용되는 최댓값. 이 값보다 큰 timeout을 "
"지정하면 :exc:`OverflowError`\\가 발생합니다."

#: ../../library/threading.rst:246
msgid ""
"This module defines a number of classes, which are detailed in the "
"sections below."
msgstr "이 모듈은 아래 섹션에 자세히 설명되는 많은 클래스를 정의합니다."

#: ../../library/threading.rst:249
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of"
" every object, they are separate objects in Python.  Python's "
":class:`Thread` class supports a subset of the behavior of Java's Thread "
"class; currently, there are no priorities, no thread groups, and threads "
"cannot be destroyed, stopped, suspended, resumed, or interrupted.  The "
"static methods of Java's Thread class, when implemented, are mapped to "
"module-level functions."
msgstr ""
"이 모듈의 설계는 Java의 스레딩 모델에 약하게 기반합니다. 그러나, Java가 록(locks)과 조건 변수(condition "
"variables)를 모든 객체의 기본 동작으로 만들지만, 파이썬에서는 별도의 객체입니다. 파이썬의 :class:`Thread` "
"클래스는 Java Thread 클래스 동작의 부분 집합을 지원합니다; 현재, 우선순위가 없고, 스레드 그룹이 없으며 스레드를 파괴,"
" 중지, 일시 중지, 재개 또는 인터럽트 할 수 없습니다. 구현될 때, Java 스레드 클래스의 정적 메서드는 모듈 수준 함수에 "
"매핑됩니다."

#: ../../library/threading.rst:257
msgid "All of the methods described below are executed atomically."
msgstr "아래에 설명된 모든 메서드는 원자 적으로 실행됩니다."

#: ../../library/threading.rst:261
msgid "Thread-Local Data"
msgstr "스레드 로컬 데이터"

#: ../../library/threading.rst:263
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a "
"subclass) and store attributes on it::"
msgstr ""
"스레드 로컬 데이터는 값이 스레드에만 한정되는 데이터입니다. 스레드 로컬 데이터를 관리하려면, :class:`local`\\(또는 "
"서브 클래스) 인스턴스를 만들고 그것에 어트리뷰트를 저장하십시오::"

#: ../../library/threading.rst:267
msgid ""
"mydata = threading.local()\n"
"mydata.x = 1"
msgstr ""

#: ../../library/threading.rst:270
msgid "The instance's values will be different for separate threads."
msgstr "인스턴스 값은 개별 스레드마다 다릅니다."

#: ../../library/threading.rst:275
msgid "A class that represents thread-local data."
msgstr "스레드 로컬 데이터를 나타내는 클래스."

#: ../../library/threading.rst:277
#, fuzzy
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`!_threading_local` module: :source:`Lib/_threading_local.py`."
msgstr "자세한 내용과 광범위한 예는, :mod:`_threading_local` 모듈의 독스트링을 참조하십시오."

#: ../../library/threading.rst:284
msgid "Thread Objects"
msgstr "Thread 객체"

#: ../../library/threading.rst:286
#, fuzzy
msgid ""
"The :class:`Thread` class represents an activity that is run in a "
"separate thread of control.  There are two ways to specify the activity: "
"by passing a callable object to the constructor, or by overriding the "
":meth:`~Thread.run` method in a subclass.  No other methods (except for "
"the constructor) should be overridden in a subclass.  In other words, "
"*only*  override the ``__init__()`` and :meth:`~Thread.run` methods of "
"this class."
msgstr ""
":class:`Thread` 클래스는 별도의 제어 스레드에서 실행되는 활동을 나타냅니다. 활동을 지정하는 두 가지 방법이 있습니다:"
" 콜러블 객체를 생성자에 전달하거나, 서브 클래스에서 :meth:`~Thread.run` 메서드를 재정의합니다. 서브 클래스에서는 "
"다른 메서드(생성자를 제외하고)를 재정의해서는 안 됩니다. 즉, *오직* 이 클래스의 "
":meth:`~Thread.__init__`\\와 :meth:`~Thread.run` 메서드만 재정의합니다."

#: ../../library/threading.rst:293
msgid ""
"Once a thread object is created, its activity must be started by calling "
"the thread's :meth:`~Thread.start` method.  This invokes the "
":meth:`~Thread.run` method in a separate thread of control."
msgstr ""
"일단 스레드 객체가 만들어지면, 스레드의 :meth:`~Thread.start` 메서드를 호출하여 활동을 시작해야 합니다. 이것은 "
"별도의 제어 스레드에서 :meth:`~Thread.run` 메서드를 호출합니다."

#: ../../library/threading.rst:297
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. "
"It stops being alive when its :meth:`~Thread.run` method terminates -- "
"either normally, or by raising an unhandled exception.  The "
":meth:`~Thread.is_alive` method tests whether the thread is alive."
msgstr ""
"일단 스레드의 활동이 시작되면, 스레드는 '살아있는(alive)' 것으로 간주합니다. :meth:`~Thread.run` 메서드가 "
"정상적으로 혹은 처리되지 않은 예외를 발생시켜서 종료할 때 살아있음을 멈춥니다. :meth:`~Thread.is_alive` "
"메서드는 스레드가 살아있는지 검사합니다."

#: ../../library/threading.rst:302
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This "
"blocks the calling thread until the thread whose :meth:`~Thread.join` "
"method is called is terminated."
msgstr ""
"다른 스레드는 스레드의 :meth:`~Thread.join` 메서드를 호출할 수 있습니다. 이것은 "
":meth:`~Thread.join` 메서드가 호출된 스레드가 종료될 때까지 호출하는 스레드를 블록 합니다."

#: ../../library/threading.rst:306
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read"
" or changed through the :attr:`~Thread.name` attribute."
msgstr ""
"스레드에는 이름이 있습니다. 이름은 생성자에 전달되고, :attr:`~Thread.name` 어트리뷰트를 통해 읽거나 변경할 수 "
"있습니다."

#: ../../library/threading.rst:309
msgid ""
"If the :meth:`~Thread.run` method raises an exception, "
":func:`threading.excepthook` is called to handle it. By default, "
":func:`threading.excepthook` ignores silently :exc:`SystemExit`."
msgstr ""
":meth:`~Thread.run` 메서드에서 예외가 발생하면, 이를 처리하기 위해 "
":func:`threading.excepthook`\\이 호출됩니다. 기본적으로, "
":func:`threading.excepthook`\\은 :exc:`SystemExit`\\를 조용히 무시합니다."

#: ../../library/threading.rst:313
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this"
" flag is that the entire Python program exits when only daemon threads "
"are left.  The initial value is inherited from the creating thread.  The "
"flag can be set through the :attr:`~Thread.daemon` property or the "
"*daemon* constructor argument."
msgstr ""
"스레드는 \"데몬 스레드\"로 플래그 할 수 있습니다. 이 플래그의 의미는 오직 데몬 스레드만 남았을 때 전체 파이썬 프로그램이 "
"종료된다는 것입니다. 초깃값은 만드는 스레드에서 상속됩니다. 플래그는 :attr:`~Thread.daemon` 프로퍼티나 "
"*daemon* 생성자 인자를 통해 설정할 수 있습니다."

#: ../../library/threading.rst:320
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such "
"as open files, database transactions, etc.) may not be released properly."
" If you want your threads to stop gracefully, make them non-daemonic and "
"use a suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"종료 시 데몬 스레드는 갑자기 중지됩니다. 그들의 자원(가령 열린 파일, 데이터베이스 트랜잭션 등)은 제대로 해제되지 않을 수 "
"있습니다. 스레드가 우아하게 중지되도록 하려면, 스레드를 데몬이 아니도록 만들고 :class:`Event`\\와 같은 적절한 신호 "
"메커니즘을 사용하십시오."

#: ../../library/threading.rst:325
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread"
" of control in the Python program.  It is not a daemon thread."
msgstr "\"메인 스레드\" 객체가 있습니다; 이것은 파이썬 프로그램의 초기 제어 스레드에 해당합니다. 이것은 데몬 스레드가 아닙니다."

#: ../../library/threading.rst:328
#, fuzzy
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These"
" are thread objects corresponding to \"alien threads\", which are threads"
" of control started outside the threading module, such as directly from C"
" code.  Dummy thread objects have limited functionality; they are always "
"considered alive and daemonic, and cannot be :ref:`joined <meth-thread-"
"join>`.  They are never deleted, since it is impossible to detect the "
"termination of alien threads."
msgstr ""
"\"더미 스레드 객체\"가 만들어질 수 있습니다. 이들은 \"외부 스레드\"에 해당하는 스레드 객체로, C 코드에서 직접 만든 "
"것처럼 threading 모듈 외부에서 시작된 제어 스레드입니다. 더미 스레드 객체는 기능이 제한적입니다; 항상 살아 있고 데몬으로"
" 간주하며, :meth:`~Thread.join`\\할 수 없습니다. 외부 스레드의 종료를 감지하는 것이 불가능하므로 삭제되지 "
"않습니다."

#: ../../library/threading.rst:339
msgid ""
"This constructor should always be called with keyword arguments.  "
"Arguments are:"
msgstr "이 생성자는 항상 키워드 인자로 호출해야 합니다. 인자는 다음과 같습니다:"

#: ../../library/threading.rst:342
#, fuzzy
msgid ""
"*group* should be ``None``; reserved for future extension when a "
":class:`!ThreadGroup` class is implemented."
msgstr ""
"*group*\\은 ``None``\\이어야 합니다; :class:`ThreadGroup` 클래스가 구현될 때 향후 확장을 위해 "
"예약되어 있습니다."

#: ../../library/threading.rst:345
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target*\\은 :meth:`run` 메서드에 의해 호출될 콜러블 객체입니다. 기본값은 ``None``\\이며, 아무것도 "
"호출되지 않습니다."

#: ../../library/threading.rst:348
#, fuzzy
msgid ""
"*name* is the thread name. By default, a unique name is constructed of "
"the form \"Thread-*N*\" where *N* is a small decimal number, or "
"\"Thread-*N* (target)\" where \"target\" is ``target.__name__`` if the "
"*target* argument is specified."
msgstr ""
"*name*\\은 스레드 이름입니다. 기본적으로, 고유한 이름이 \"Thread-*N*\" 형식으로 구성되는데, 여기서 *N*\\은"
" 작은 십진수입니다."

#: ../../library/threading.rst:353
#, fuzzy
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  "
"Defaults to ``()``."
msgstr "*args*\\는 target 호출을 위한 인자 튜플입니다. 기본값은 ``()``\\입니다."

#: ../../library/threading.rst:355
#, python-brace-format
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr "*kwargs*\\는 target 호출을 위한 키워드 인자의 딕셔너리입니다. 기본값은 ``{}``\\입니다."

#: ../../library/threading.rst:358
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic."
" If ``None`` (the default), the daemonic property is inherited from the "
"current thread."
msgstr ""
"``None``\\이 아니면, *daemon*\\은 스레드가 데몬인지를 명시적으로 설정합니다. ``None``\\(기본값)이면, "
"데몬 속성은 현재 스레드에서 상속됩니다."

#: ../../library/threading.rst:362
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke "
"the base class constructor (``Thread.__init__()``) before doing anything "
"else to the thread."
msgstr ""
"서브 클래스가 생성자를 재정의하면, 스레드에 다른 작업을 수행하기 전에 베이스 클래스 "
"생성자(``Thread.__init__()``)를 호출해야 합니다."

#: ../../library/threading.rst:366
#, fuzzy
msgid "Added the *daemon* parameter."
msgstr "*daemon* 인자를 추가했습니다."

#: ../../library/threading.rst:369
msgid "Use the *target* name if *name* argument is omitted."
msgstr ""

#: ../../library/threading.rst:374
msgid "Start the thread's activity."
msgstr "스레드 활동을 시작합니다."

#: ../../library/threading.rst:376
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of"
" control."
msgstr ""
"스레드 객체 당 최대 한 번 호출되어야 합니다. 객체의 :meth:`~Thread.run` 메서드가 별도의 제어 스레드에서 "
"호출되도록 배치합니다."

#: ../../library/threading.rst:380
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on "
"the same thread object."
msgstr "이 메서드는 같은 스레드 객체에서 두 번 이상 호출되면, :exc:`RuntimeError`\\를 발생시킵니다."

#: ../../library/threading.rst:385
msgid "Method representing the thread's activity."
msgstr "스레드의 활동을 표현하는 메서드."

#: ../../library/threading.rst:387
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` "
"method invokes the callable object passed to the object's constructor as "
"the *target* argument, if any, with positional and keyword arguments "
"taken from the *args* and *kwargs* arguments, respectively."
msgstr ""
"서브 클래스에서 이 메서드를 재정의할 수 있습니다. 표준 :meth:`run` 메서드는 *target* 인자로 객체의 생성자에 "
"전달된 콜러블 객체를 호출합니다, 있다면 *args*\\와 *kwargs* 인자에서 각각 취한 위치와 키워드 인자로 호출합니다."

#: ../../library/threading.rst:392
msgid ""
"Using list or tuple as the *args* argument which passed to the "
":class:`Thread` could achieve the same effect."
msgstr ""

#: ../../library/threading.rst:395
#, fuzzy
msgid "Example::"
msgstr "예를 들면::"

#: ../../library/threading.rst:397
msgid ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"
msgstr ""

#: ../../library/threading.rst:409
msgid ""
"Wait until the thread terminates. This blocks the calling thread until "
"the thread whose :meth:`~Thread.join` method is called terminates -- "
"either normally or through an unhandled exception -- or until the "
"optional timeout occurs."
msgstr ""
"스레드가 종료할 때까지 기다립니다. :meth:`~Thread.join` 메서드가 호출된 스레드가 정상적으로 혹은 처리되지 않은 "
"예외를 통해 종료하거나 선택적 시간제한 초과가 발생할 때까지 호출하는 스레드를 블록 합니다."

#: ../../library/threading.rst:414
#, fuzzy
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds "
"(or fractions thereof). As :meth:`~Thread.join` always returns ``None``, "
"you must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to "
"decide whether a timeout happened -- if the thread is still alive, the "
":meth:`~Thread.join` call timed out."
msgstr ""
"*timeout* 인자가 있고 ``None``\\이 아니면, 작업의 시간제한을 초(또는 부분 초)로 지정하는 부동 소수점 숫자여야 "
"합니다. :meth:`~Thread.join`\\은 항상 ``None``\\을 반환하므로, :meth:`~Thread.join` "
"이후에 :meth:`~Thread.is_alive`\\를 호출하여 시간제한 초과가 발생했는지 판단해야 합니다 -- 스레드가 아직 "
"살아있다면, :meth:`~Thread.join` 호출이 시간제한을 초과한 것입니다."

#: ../../library/threading.rst:421
msgid ""
"When the *timeout* argument is not present or ``None``, the operation "
"will block until the thread terminates."
msgstr "*timeout* 인자가 없거나 ``None``\\이면, 스레드가 종료될 때까지 작업이 블록 됩니다."

#: ../../library/threading.rst:424
#, fuzzy
msgid "A thread can be joined many times."
msgstr "스레드는 여러 번 :meth:`~Thread.join`\\될 수 있습니다."

#: ../../library/threading.rst:426
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made "
"to join the current thread as that would cause a deadlock. It is also an "
"error to :meth:`~Thread.join` a thread before it has been started and "
"attempts to do so raise the same exception."
msgstr ""
"교착 상태를 유발할 수 있어서 현재 스레드를 조인하려고 시도하면 :meth:`~Thread.join`\\은 "
":exc:`RuntimeError`\\를 발생시킵니다. 스레드가 시작되기 전에 :meth:`~Thread.join` 하는 것도 "
"에러이고 같은 예외가 발생합니다."

#: ../../library/threading.rst:433
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by "
"the constructor."
msgstr "식별 목적으로만 사용되는 문자열. 의미는 없습니다. 여러 스레드에 같은 이름을 지정할 수 있습니다. 초기 이름은 생성자가 설정합니다."

#: ../../library/threading.rst:440
#, fuzzy
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as"
" a property instead."
msgstr ":attr:`~Thread.name`\\을 위한 오래된 getter/setter API; 대신 프로퍼티로 직접 사용하십시오."

#: ../../library/threading.rst:447
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"이 스레드의 '스레드 식별자' 또는 스레드가 시작되지 않았으면 ``None``. 이것은 0이 아닌 정수입니다. "
":func:`get_ident` 함수를 참조하십시오. 스레드 식별자는 스레드가 종료되고 다른 스레드가 만들어질 때 재활용될 수 "
"있습니다. 스레드가 종료된 후에도 식별자를 사용할 수 있습니다."

#: ../../library/threading.rst:455
#, fuzzy
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). "
"This is a non-negative integer, or ``None`` if the thread has not been "
"started. See the :func:`get_native_id` function. This value may be used "
"to uniquely identify this particular thread system-wide (until the thread"
" terminates, after which the value may be recycled by the OS)."
msgstr ""
"이 스레드의 네이티브 정수 스레드 ID. 음수가 아닌 정수, 또는 스레드가 시작되지 않았으면 ``None``\\입니다. "
":func:`get_native_id` 함수를 참조하십시오. OS(커널)에 의해 스레드에 할당된 스레드 ID(``TID``)를 "
"나타냅니다. 이 값은 시스템 전체에서 이 특정 스레드를 고유하게 식별하는 데 사용될 수 있습니다 (스레드가 종료될 때까지, OS가 "
"값을 재활용 할 수 있습니다)."

#: ../../library/threading.rst:464
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique "
"system-wide) from the time the thread is created until the thread has "
"been terminated."
msgstr ""
"프로세스 ID 와 유사하게, 스레드 ID는 스레드가 만들어진 시점부터 스레드가 종료될 때까지만 유효(시스템 전체에서 고유함이 "
"보장)합니다."

#: ../../library/threading.rst:474
msgid "Return whether the thread is alive."
msgstr "스레드가 살아있는지를 반환합니다."

#: ../../library/threading.rst:476
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"이 메서드는 :meth:`~Thread.run` 메서드가 시작되기 직전부터 :meth:`~Thread.run` 메서드가 종료된 "
"직후까지 ``True``\\를 반환합니다. 모듈 함수 :func:`.enumerate`\\는 모든 살아있는 스레드 리스트를 "
"반환합니다."

#: ../../library/threading.rst:482
#, fuzzy
msgid ""
"A boolean value indicating whether this thread is a daemon thread "
"(``True``) or not (``False``).  This must be set before "
":meth:`~Thread.start` is called, otherwise :exc:`RuntimeError` is raised."
"  Its initial value is inherited from the creating thread; the main "
"thread is not a daemon thread and therefore all threads created in the "
"main thread default to :attr:`~Thread.daemon` = ``False``."
msgstr ""
"이 스레드가 데몬 스레드인지(True) 아닌지(False)를 나타내는 불리언 값. :meth:`~Thread.start`\\가 "
"호출되기 전에 설정되어야 합니다, 그렇지 않으면 :exc:`RuntimeError`\\가 발생합니다. 초깃값은 만드는 스레드에서 "
"상속됩니다; 메인 스레드는 데몬 스레드가 아니므로 메인 스레드에서 만드는 모든 스레드의 기본값은 "
":attr:`~Thread.daemon` = ``False``\\입니다."

#: ../../library/threading.rst:489
msgid "The entire Python program exits when no alive non-daemon threads are left."
msgstr "살아있는 데몬이 아닌 스레드가 남아 있지 않으면 전체 파이썬 프로그램이 종료됩니다."

#: ../../library/threading.rst:494
#, fuzzy
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly "
"as a property instead."
msgstr ":attr:`~Thread.daemon`\\을 위한 오래된 getter/setter API; 대신 프로퍼티로 직접 사용하십시오."

#: ../../library/threading.rst:503
msgid "Lock Objects"
msgstr "Lock 객체"

#: ../../library/threading.rst:505
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest "
"level synchronization primitive available, implemented directly by the "
":mod:`_thread` extension module."
msgstr ""
"프리미티브 록(primitive lock)은 잠겨있을 때 특정 스레드가 소유하지 않는 동기화 프리미티브입니다. 파이썬에서는 현재 "
":mod:`_thread` 확장 모듈에 의해 직접 구현되는 가장 낮은 수준의 동기화 프리미티브입니다."

#: ../../library/threading.rst:510
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It "
"is created in the unlocked state.  It has two basic methods, "
":meth:`~Lock.acquire` and :meth:`~Lock.release`.  When the state is "
"unlocked, :meth:`~Lock.acquire` changes the state to locked and returns "
"immediately.  When the state is locked, :meth:`~Lock.acquire` blocks "
"until a call to :meth:`~Lock.release` in another thread changes it to "
"unlocked, then the :meth:`~Lock.acquire` call resets it to locked and "
"returns.  The :meth:`~Lock.release` method should only be called in the "
"locked state; it changes the state to unlocked and returns immediately. "
"If an attempt is made to release an unlocked lock, a :exc:`RuntimeError` "
"will be raised."
msgstr ""
"프리미티브 록은 두 상태 중 하나입니다, \"잠금(locked)\"이나 \"잠금 해제(unlocked)\". 잠금 해제 상태로 "
"만들어집니다. 두 가지 기본 메서드가 있습니다, :meth:`~Lock.acquire`\\와 "
":meth:`~Lock.release`. 상태가 잠금 해제일 때, :meth:`~Lock.acquire`\\는 상태를 잠금으로 "
"변경하고 즉시 반환합니다. 상태가 잠금일 때, :meth:`~Lock.acquire`\\는 다른 스레드에서의 "
":meth:`~Lock.release`\\에 호출이 잠금 해제로 변경할 때까지 블록 된 후, :meth:`~Lock.acquire`"
" 호출이 이를 잠금으로 재설정하고 반환합니다. :meth:`~Lock.release` 메서드는 잠금 상태에서만 호출해야 합니다; "
"상태를 잠금 해제로 변경하고 즉시 반환합니다. 잠금 해제된 록을 해제하려고 하면, :exc:`RuntimeError`\\가 "
"발생합니다."

#: ../../library/threading.rst:521
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "록은 :ref:`컨텍스트 관리자 프로토콜 <with-locks>`\\도 지원합니다."

#: ../../library/threading.rst:523
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for"
" the state to turn to unlocked, only one thread proceeds when a "
":meth:`~Lock.release` call resets the state to unlocked; which one of the"
" waiting threads proceeds is not defined, and may vary across "
"implementations."
msgstr ""
"둘 이상의 스레드가 :meth:`~Lock.acquire`\\에서 블록 되어 상태가 잠금 해제가 되기를 기다릴 때, "
":meth:`~Lock.release` 호출이 상태를 잠금 해제로 재설정하면 하나의 스레드만 진행됩니다; 대기 중인 스레드 중 어느"
" 것이 진행하는지는 정의되지 않았으며, 구현에 따라 다를 수 있습니다."

#: ../../library/threading.rst:528
msgid "All methods are executed atomically."
msgstr "모든 메서드는 원자 적으로 실행됩니다."

#: ../../library/threading.rst:533
msgid ""
"The class implementing primitive lock objects.  Once a thread has "
"acquired a lock, subsequent attempts to acquire it block, until it is "
"released; any thread may release it."
msgstr ""
"프리미티브 록 객체를 구현하는 클래스. 일단 스레드가 록을 획득하면, 이후에 해당 록을 확보하려고 시도하면 해제될 때까지 블록 "
"합니다; 모든 스레드가 해제할 수 있습니다."

#: ../../library/threading.rst:537
msgid ""
"``Lock`` is now a class. In earlier Pythons, ``Lock`` was a factory "
"function which returned an instance of the underlying private lock type."
msgstr ""

#: ../../library/threading.rst:545 ../../library/threading.rst:636
msgid "Acquire a lock, blocking or non-blocking."
msgstr "블로킹이거나 비 블로킹으로, 록을 획득합니다."

#: ../../library/threading.rst:547
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return "
"``True``."
msgstr ""
"*blocking* 인자를 ``True``\\(기본값)로 설정하여 호출하면, 록이 잠금 해제될 때까지 블록 한 다음, 잠금으로 "
"설정하고 ``True``\\를 반환합니다."

#: ../../library/threading.rst:550
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block."
" If a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"*blocking* 인자를 ``False``\\로 설정하여 호출하면, 블록 하지 않습니다. *blocking*\\이 "
"``True``\\로 설정된 호출이 블록 될 것이라면, 즉시 ``False``\\를 반환합니다; 그렇지 않으면, 록을 잠금으로 "
"설정하고 ``True``\\를 반환합니다."

#: ../../library/threading.rst:554
#, fuzzy
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive"
" value, block for at most the number of seconds specified by *timeout* "
"and as long as the lock cannot be acquired.  A *timeout* argument of "
"``-1`` specifies an unbounded wait.  It is forbidden to specify a "
"*timeout* when *blocking* is ``False``."
msgstr ""
"양수 값으로 설정된 부동 소수점 *timeout* 인자로 호출하면, 록을 획득할 수 없는 한 최대 *timeout*\\에 지정된 초"
" 동안 블록 합니다. ``-1``\\의 *timeout* 인자는 제한 없는 대기를 지정합니다. *blocking*\\이 거짓일 때 "
"*timeout*\\을 지정하는 것은 금지되어 있습니다."

#: ../../library/threading.rst:560
msgid ""
"The return value is ``True`` if the lock is acquired successfully, "
"``False`` if not (for example if the *timeout* expired)."
msgstr ""
"록이 성공적으로 획득되면 반환 값은 ``True``\\이고, 그렇지 않으면  (예를 들어 *timeout*\\이 만료되면) "
"``False``\\입니다."

#: ../../library/threading.rst:563 ../../library/threading.rst:674
#: ../../library/threading.rst:921
msgid "The *timeout* parameter is new."
msgstr "*timeout* 매개 변수가 추가되었습니다."

#: ../../library/threading.rst:566
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr "하부 스레딩 구현이 지원한다면 POSIX에서 시그널로 록 획득을 중단할 수 있습니다."

#: ../../library/threading.rst:573
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr "록을 해제합니다. 록을 획득한 스레드뿐만 아니라 모든 스레드에서 호출할 수 있습니다."

#: ../../library/threading.rst:576
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed."
msgstr ""
"록이 잠금일 때, 잠금 해제로 재설정하고 반환합니다. 록이 잠금 해제될 때까지 다른 스레드가 블록 되어 기다리고 있으면, 그들 중 "
"정확히 하나의 스레드가 진행되도록 합니다."

#: ../../library/threading.rst:580
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "잠금 해제된 록에서 호출되면, :exc:`RuntimeError`\\가 발생합니다."

#: ../../library/threading.rst:582 ../../library/threading.rst:690
msgid "There is no return value."
msgstr "반환 값이 없습니다."

#: ../../library/threading.rst:586
#, fuzzy
msgid "Return ``True`` if the lock is acquired."
msgstr "록이 획득되면 참을 반환합니다."

#: ../../library/threading.rst:593
msgid "RLock Objects"
msgstr "RLock 객체"

#: ../../library/threading.rst:595
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the "
"locked/unlocked state used by primitive locks.  In the locked state, some"
" thread owns the lock; in the unlocked state, no thread owns it."
msgstr ""
"재진입 록(reentrant lock)은 같은 스레드에 의해 여러 번 획득될 수 있는 동기화 프리미티브입니다. 내부적으로, "
"프리미티브 록에서 사용하는 잠금/잠금 해제 상태에 더해 \"소유하는 스레드(owning thread)\"와 \"재귀 "
"수준(recursion level)\" 개념을 사용합니다. 잠금 상태에서는, 어떤 스레드가 록을 소유합니다; 잠금 해제 상태에서는 "
"아무런 스레드도 록을 소유하지 않습니다."

#: ../../library/threading.rst:601
msgid ""
"Threads call a lock's :meth:`~RLock.acquire` method to lock it, and its "
":meth:`~Lock.release` method to unlock it."
msgstr ""

#: ../../library/threading.rst:606
msgid ""
"Reentrant locks support the :ref:`context management protocol <with-"
"locks>`, so it is recommended to use :keyword:`with` instead of manually "
"calling :meth:`~RLock.acquire` and :meth:`~RLock.release` to handle "
"acquiring and releasing the lock for a block of code."
msgstr ""

#: ../../library/threading.rst:611
#, fuzzy
msgid ""
"RLock's :meth:`~RLock.acquire`/:meth:`~RLock.release` call pairs may be "
"nested, unlike Lock's :meth:`~Lock.acquire`/:meth:`~Lock.release`. Only "
"the final :meth:`~RLock.release` (the :meth:`~Lock.release` of the "
"outermost pair) resets the lock to an unlocked state and allows another "
"thread blocked in :meth:`~RLock.acquire` to proceed."
msgstr ""
"록을 잠그기 위해, 스레드는 :meth:`~RLock.acquire` 메서드를 호출합니다; 일단 스레드가 잠금을 소유하면 "
"반환합니다. 록을 잠금 해제하기 위해, 스레드는 :meth:`~Lock.release` 메서드를 호출합니다. "
":meth:`~Lock.acquire`/ :meth:`~Lock.release` 호출 쌍은 중첩될 수 있습니다; 오직 마지막 "
":meth:`~Lock.release`\\(가장 바깥쪽 쌍의 :meth:`~Lock.release`)만 록을 잠금 해제로 재설정하고"
" :meth:`~Lock.acquire`\\에서 블록 된 다른 스레드가 진행하도록 할 수 있습니다."

#: ../../library/threading.rst:617
msgid ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` must be used in pairs: each"
" acquire must have a release in the thread that has acquired the lock. "
"Failing to call release as many times the lock has been acquired can lead"
" to deadlock."
msgstr ""

#: ../../library/threading.rst:624
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; "
"the thread must release it once for each time it has acquired it."
msgstr ""
"이 클래스는 재진입 록 객체를 구현합니다. 재진입 록은 획득한 스레드에서 해제해야 합니다. 일단 스레드가 재진입 록을 획득하면, "
"같은 스레드는 블록 하지 않고 다시 스레드를 획득할 수 있습니다; 스레드는 획득할 때마다 한 번씩 해제해야 합니다."

#: ../../library/threading.rst:629
msgid ""
"Note that ``RLock`` is actually a factory function which returns an "
"instance of the most efficient version of the concrete RLock class that "
"is supported by the platform."
msgstr ""
"``RLock``\\은 실제로는 플랫폼에서 지원하는 가장 효율적인 버전의 구상 RLock 클래스 인스턴스를 반환하는 팩토리 함수임에"
" 유의하십시오."

#: ../../library/threading.rst:640
msgid ":ref:`Using RLock as a context manager <with-locks>`"
msgstr ""

#: ../../library/threading.rst:641
msgid ""
"Recommended over manual :meth:`!acquire` and :meth:`release` calls "
"whenever practical."
msgstr ""

#: ../../library/threading.rst:645
#, fuzzy
msgid "When invoked with the *blocking* argument set to ``True`` (the default):"
msgstr ""
"*blocking* 인자를 ``True``\\(기본값)로 설정하여 호출하면, 록이 잠금 해제될 때까지 블록 한 다음, 잠금으로 "
"설정하고 ``True``\\를 반환합니다."

#: ../../library/threading.rst:647 ../../library/threading.rst:659
msgid "If no thread owns the lock, acquire the lock and return immediately."
msgstr ""

#: ../../library/threading.rst:649
msgid ""
"If another thread owns the lock, block until we are able to acquire lock,"
" or *timeout*, if set to a positive float value."
msgstr ""

#: ../../library/threading.rst:652
msgid ""
"If the same thread owns the lock, acquire the lock again, and return "
"immediately. This is the difference between :class:`Lock` and "
":class:`!RLock`; :class:`Lock` handles this case the same as the "
"previous, blocking until the lock can be acquired."
msgstr ""

#: ../../library/threading.rst:657
#, fuzzy
msgid "When invoked with the *blocking* argument set to ``False``:"
msgstr "인자 없이 호출될 때:"

#: ../../library/threading.rst:661
msgid "If another thread owns the lock, return immediately."
msgstr ""

#: ../../library/threading.rst:663
msgid ""
"If the same thread owns the lock, acquire the lock again and return "
"immediately."
msgstr ""

#: ../../library/threading.rst:666
msgid ""
"In all cases, if the thread was able to acquire the lock, return "
"``True``. If the thread was unable to acquire the lock (i.e. if not "
"blocking or the timeout was reached) return ``False``."
msgstr ""

#: ../../library/threading.rst:670
msgid ""
"If called multiple times, failing to call :meth:`~RLock.release` as many "
"times may lead to deadlock. Consider using :class:`!RLock` as a context "
"manager rather than calling acquire/release directly."
msgstr ""

#: ../../library/threading.rst:680
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement"
" it is zero, reset the lock to unlocked (not owned by any thread), and if"
" any other threads are blocked waiting for the lock to become unlocked, "
"allow exactly one of them to proceed.  If after the decrement the "
"recursion level is still nonzero, the lock remains locked and owned by "
"the calling thread."
msgstr ""
"재귀 수준을 낮추면서, 잠금을 해제합니다. 감소 후에 0이 되면, 록을 잠금 해제로 (아무런 스레드도 소유하지 않은) 재설정하고, "
"록이 잠금 해제되도록 기다리면서 블록 된 다른 스레드가 있으면, 그중 정확히 하나가 진행되도록 합니다. 감소 후에 재귀 수준이 "
"여전히 0이 아니면, 록은 잠금이고, 호출하는 스레드에 의해 소유된 채로 유지됩니다."

#: ../../library/threading.rst:686
#, fuzzy
msgid ""
"Only call this method when the calling thread owns the lock. A "
":exc:`RuntimeError` is raised if this method is called when the lock is "
"not acquired."
msgstr ""
"호출하는 스레드가 록을 소유했을 때만 이 메서드를 호출하십시오. 록이 잠금 해제일 때 이 메서드가 호출되면 "
":exc:`RuntimeError`\\가 발생합니다."

#: ../../library/threading.rst:696
msgid "Condition Objects"
msgstr "Condition 객체"

#: ../../library/threading.rst:698
msgid ""
"A condition variable is always associated with some kind of lock; this "
"can be passed in or one will be created by default.  Passing one in is "
"useful when several condition variables must share the same lock.  The "
"lock is part of the condition object: you don't have to track it "
"separately."
msgstr ""
"조건 변수(condition variable)는 항상 어떤 종류의 록과 연관됩니다; 이것은 전달되거나 기본적으로 만들어집니다. "
"전달하는 것은 여러 조건 변수가 같은 록을 공유해야 할 때 유용합니다. 록은 조건 객체의 일부입니다: 별도로 추적할 필요가 "
"없습니다."

#: ../../library/threading.rst:703
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for "
"the duration of the enclosed block.  The :meth:`~Condition.acquire` and "
":meth:`~Condition.release` methods also call the corresponding methods of"
" the associated lock."
msgstr ""
"조건 변수는 :ref:`컨텍스트 관리자 프로토콜 <with-locks>`\\을 준수합니다: ``with`` 문을 사용해서 감싼 "
"블록의 지속 시간 동안 연관된 록을 획득합니다. :meth:`~Condition.acquire`\\와 "
":meth:`~Condition.release` 메서드도 연관된 록의 해당 메서드를 호출합니다."

#: ../../library/threading.rst:709
msgid ""
"Other methods must be called with the associated lock held.  The "
":meth:`~Condition.wait` method releases the lock, and then blocks until "
"another thread awakens it by calling :meth:`~Condition.notify` or "
":meth:`~Condition.notify_all`.  Once awakened, :meth:`~Condition.wait` "
"re-acquires the lock and returns.  It is also possible to specify a "
"timeout."
msgstr ""
"다른 메서드들은 연관된 록을 잡은 상태에서 호출해야 합니다. :meth:`~Condition.wait` 메서드는 록을 해제한 다음,"
" 다른 스레드가 :meth:`~Condition.notify`\\나 :meth:`~Condition.notify_all`\\을 "
"호출하여 록을 해제할 때까지 블록 합니다. 일단 깨어나면, :meth:`~Condition.wait`\\는 록을 다시 획득하고 "
"반환합니다. 시간제한을 지정할 수도 있습니다."

#: ../../library/threading.rst:715
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting "
"for the condition variable, if any are waiting.  The "
":meth:`~Condition.notify_all` method wakes up all threads waiting for the"
" condition variable."
msgstr ""
":meth:`~Condition.notify` 메서드는 있다면 조건 변수를 기다리는 스레드 중 하나를 깨웁니다. "
":meth:`~Condition.notify_all` 메서드는 조건 변수를 기다리는 모든 스레드를 깨웁니다."

#: ../../library/threading.rst:719
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called "
":meth:`~Condition.notify` or :meth:`~Condition.notify_all` finally "
"relinquishes ownership of the lock."
msgstr ""
"참고: :meth:`~Condition.notify`\\와 :meth:`~Condition.notify_all` 메서드는 록을 "
"해제하지 않습니다; 이것은 깨어난 스레드나 스레드들이 :meth:`~Condition.wait` 호출에서 즉시 반환되지 않지만, "
":meth:`~Condition.notify`\\나 :meth:`~Condition.notify_all`\\을 호출한 스레드가 "
"최종적으로 록 소유권을 포기할 때만 반환됨을 의미합니다."

#: ../../library/threading.rst:725
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a"
" particular change of state call :meth:`~Condition.wait` repeatedly until"
" they see the desired state, while threads that modify the state call "
":meth:`~Condition.notify` or :meth:`~Condition.notify_all` when they "
"change the state in such a way that it could possibly be a desired state "
"for one of the waiters.  For example, the following code is a generic "
"producer-consumer situation with unlimited buffer capacity::"
msgstr ""
"조건 변수를 사용하는 일반적인 프로그래밍 스타일은 록을 사용하여 어떤 공유 상태에 대한 액세스를 동기화합니다; 특정 상태 변경에 "
"관심 있는 스레드는 원하는 상태를 볼 때까지 :meth:`~Condition.wait`\\를 반복적으로 호출하는 반면, 상태를 "
"변경하는 스레드는 대기자 중 하나가 원하는 상태일 수 있도록 상태를 변경할 때 :meth:`~Condition.notify`\\나 "
":meth:`~Condition.notify_all`\\을 호출합니다. 예를 들어, 다음 코드는 무제한 버퍼 용량의 일반적인 "
"생산자-소비자 상황입니다::"

#: ../../library/threading.rst:734
msgid ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"
msgstr ""

#: ../../library/threading.rst:745
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, "
"and the condition which prompted the :meth:`~Condition.notify` call may "
"no longer hold true.  This is inherent to multi-threaded programming.  "
"The :meth:`~Condition.wait_for` method can be used to automate the "
"condition checking, and eases the computation of timeouts::"
msgstr ""
":meth:`~Condition.wait`\\가 임의의 긴 시간 후에 반환될 수 있고, "
":meth:`~Condition.notify` 호출을 유발한 조건이 더는 참이 아닐 수 있기 때문에, 응용 프로그램의 조건에 대한 "
"``while`` 루프 검사가 필요합니다. 이것은 다중 스레드 프로그래밍에 본질적으로 수반됩니다. "
":meth:`~Condition.wait_for` 메서드를 사용하면 조건 검사를 자동화하고 시간제한 계산을 쉽게 수행할 수 "
"있습니다::"

#: ../../library/threading.rst:752
msgid ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"
msgstr ""

#: ../../library/threading.rst:757
msgid ""
"To choose between :meth:`~Condition.notify` and "
":meth:`~Condition.notify_all`, consider whether one state change can be "
"interesting for only one or several waiting threads.  E.g. in a typical "
"producer-consumer situation, adding one item to the buffer only needs to "
"wake up one consumer thread."
msgstr ""
":meth:`~Condition.notify`\\와 :meth:`~Condition.notify_all` 중에서 선택하려면, 하나의"
" 상태 변경에 흥미 있는 대기 중인 스레드가 하나일지 여러 개일지를 고려하십시오. 예를 들어 일반적인 생산자-소비자 상황에서, "
"하나의 항목을 버퍼에 추가하면 오직 하나의 소비자 스레드만 깨울 필요가 있습니다."

#: ../../library/threading.rst:765
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another "
"thread."
msgstr ""
"이 클래스는 조건 변수 객체를 구현합니다. 조건 변수를 사용하면 하나 이상의 스레드가 다른 스레드에 의해 통지될 때까지 기다릴 수 "
"있습니다."

#: ../../library/threading.rst:768
msgid ""
"If the *lock* argument is given and not ``None``, it must be a "
":class:`Lock` or :class:`RLock` object, and it is used as the underlying "
"lock.  Otherwise, a new :class:`RLock` object is created and used as the "
"underlying lock."
msgstr ""
"*lock* 인자가 제공되고 ``None``\\이 아니면, :class:`Lock`\\이나 :class:`RLock` 객체여야 "
"하며, 하부 록으로 사용됩니다. 그렇지 않으면, 새 :class:`RLock` 객체가 만들어지고 하부 록으로 사용됩니다."

#: ../../library/threading.rst:772 ../../library/threading.rst:896
#: ../../library/threading.rst:942 ../../library/threading.rst:994
#: ../../library/threading.rst:1062
msgid "changed from a factory function to a class."
msgstr "팩토리 함수에서 클래스로 변경되었습니다."

#: ../../library/threading.rst:777
msgid ""
"Acquire the underlying lock. This method calls the corresponding method "
"on the underlying lock; the return value is whatever that method returns."
msgstr "하부 록을 획득합니다. 이 메서드는 하부 록에서 해당 메서드를 호출합니다; 반환 값은 그 메서드가 반환하는 것입니다."

#: ../../library/threading.rst:782
msgid ""
"Release the underlying lock. This method calls the corresponding method "
"on the underlying lock; there is no return value."
msgstr "하부 록을 해제합니다. 이 메서드는 하부 록에서 해당 메서드를 호출합니다; 반환 값이 없습니다."

#: ../../library/threading.rst:787
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has "
"not acquired the lock when this method is called, a :exc:`RuntimeError` "
"is raised."
msgstr ""
"통지되거나 시간제한이 만료될 때까지 기다립니다. 이 메서드가 호출될 때 호출하는 스레드가 록을 획득하지 않았으면, "
":exc:`RuntimeError`\\가 발생합니다."

#: ../../library/threading.rst:791
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout "
"occurs.  Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"이 메서드는 하부 록을 해제한 다음, 같은 조건 변수에 대한 다른 스레드에서의 :meth:`notify`\\나 "
":meth:`notify_all` 호출에 의해 깨어날 때까지 또는 선택적 시간제한 만료가 발생할 때까지 블록 합니다. 일단 "
"깨어나거나 시간제한이 만료되면, 록을 다시 획득하고 반환합니다."

#: ../../library/threading.rst:796
#, fuzzy
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds "
"(or fractions thereof)."
msgstr ""
"*timeout* 인자가 있고 ``None``\\이 아니면, 작업의 시간제한을 초(또는 부분 초)로 지정하는 부동 소수점 숫자여야 "
"합니다."

#: ../../library/threading.rst:800
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using "
"its :meth:`release` method, since this may not actually unlock the lock "
"when it was acquired multiple times recursively.  Instead, an internal "
"interface of the :class:`RLock` class is used, which really unlocks it "
"even when it has been recursively acquired several times. Another "
"internal interface is then used to restore the recursion level when the "
"lock is reacquired."
msgstr ""
"하부 록이 :class:`RLock`\\일 때, 록이 여러 번 재귀적으로 획득되었을 때 록을 실제로 잠금 해제하지 못할 수 있기 "
"때문에, :meth:`release` 메서드를 사용하여 록을 해제하지 않습니다. 대신, :class:`RLock` 클래스의 내부 "
"인터페이스가 사용되어, 재귀적으로 여러 번 획득한 경우에도 실제로 록을 잠금 해제합니다. 그런 다음 다른 내부 인터페이스를 사용하여"
" 록을 다시 획득할 때 재귀 수준을 복원합니다."

#: ../../library/threading.rst:808
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which "
"case it is ``False``."
msgstr "주어진 *timeout*\\이 만료되지 않는 한 반환 값은 ``True``\\이며, 만료되면 ``False``\\입니다."

#: ../../library/threading.rst:811 ../../library/threading.rst:1027
msgid "Previously, the method always returned ``None``."
msgstr "이전에는, 메서드가 항상 ``None``\\을 반환했습니다."

#: ../../library/threading.rst:816
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a "
"callable which result will be interpreted as a boolean value. A *timeout*"
" may be provided giving the maximum time to wait."
msgstr ""
"조건이 참으로 평가될 때까지 기다립니다. *predicate*\\는 불리언 값으로 해석될 결과를 반환하는 콜러블 이어야 합니다. "
"최대 대기 시간을 주는 *timeout*\\이 제공될 수 있습니다."

#: ../../library/threading.rst:820
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate "
"is satisfied, or until a timeout occurs. The return value is the last "
"return value of the predicate and will evaluate to ``False`` if the "
"method timed out."
msgstr ""
"이 유틸리티 메서드는 술어(predicate)가 충족될 때까지, 또는 시간제한 만료가 발생할 때까지 :meth:`wait`\\를 "
"반복적으로 호출할 수 있습니다. 반환 값은 predicate의 마지막 반환 값이며 메서드가 시간제한 만료되면 ``False``\\로"
" 평가됩니다."

#: ../../library/threading.rst:825
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent "
"to writing::"
msgstr "시간제한 기능을 무시할 때, 이 메서드를 호출하는 것은 대략 다음과 같이 작성하는 것과 동등합니다::"

#: ../../library/threading.rst:828
msgid ""
"while not predicate():\n"
"    cv.wait()"
msgstr ""

#: ../../library/threading.rst:831
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be "
"held when called and is re-acquired on return.  The predicate is "
"evaluated with the lock held."
msgstr ""
"따라서, :meth:`wait`\\와 같은 규칙이 적용됩니다: 호출될 때 록을 잡고 있어야 하며 반환할 때 다시 확보됩니다. "
"predicate는 록을 잡고 있는 상태로 평가됩니다."

#: ../../library/threading.rst:839
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the"
" calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"기본적으로, (있다면) 이 조건에서 대기 중인 하나의 스레드를 깨웁니다. 이 메서드가 호출될 때 호출하는 스레드가 잠금을 획득하지 "
"않았으면 :exc:`RuntimeError`\\가 발생합니다."

#: ../../library/threading.rst:843
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition"
" variable; it is a no-op if no threads are waiting."
msgstr "이 메서드는 조건 변수를 기다리는 스레드를 최대 *n* 개 깨웁니다; 기다리는 스레드가 없으면 아무런 일도 하지 않습니다."

#: ../../library/threading.rst:846
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"적어도 *n* 스레드가 대기 중이면, 현재 구현은 정확히 *n* 스레드를 깨웁니다. 그러나, 이 동작에 의존하는 것은 안전하지 "
"않습니다. 미래에는, 최적화된 구현이 때때로 *n* 스레드보다 많이 깨울 수 있습니다."

#: ../../library/threading.rst:851
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` "
"call until it can reacquire the lock.  Since :meth:`notify` does not "
"release the lock, its caller should."
msgstr ""
"참고: 깨어난 스레드는 록을 다시 획득할 때까지 :meth:`wait` 호출에서 실제로 반환하지 않습니다. "
":meth:`notify`\\가 록을 해제하지 않기 때문에, 호출자가 해제해야 합니다."

#: ../../library/threading.rst:857
msgid ""
"Wake up all threads waiting on this condition.  This method acts like "
":meth:`notify`, but wakes up all waiting threads instead of one. If the "
"calling thread has not acquired the lock when this method is called, a "
":exc:`RuntimeError` is raised."
msgstr ""
"이 조건에서 대기 중인 모든 스레드를 깨웁니다. 이 메서드는 :meth:`notify`\\처럼 작동하지만, 하나 대신에 대기 중인 "
"모든 스레드를 깨웁니다. 이 메서드가 호출될 때 호출하는 스레드가 잠금을 획득하지 않았으면 :exc:`RuntimeError`\\가"
" 발생합니다."

#: ../../library/threading.rst:862
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr ""

#: ../../library/threading.rst:868
msgid "Semaphore Objects"
msgstr "Semaphore 객체"

#: ../../library/threading.rst:870
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger "
"W. Dijkstra (he used the names ``P()`` and ``V()`` instead of "
":meth:`~Semaphore.acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"이것은 일찌감치 네덜란드 컴퓨터 과학자 Edsger W. Dijkstra가 발명한, 컴퓨터 과학 역사상 가장 오래된 동기화 "
"프리미티브 중 하나입니다 (그는 :meth:`~Semaphore.acquire`\\와 "
":meth:`~Semaphore.release` 대신 ``P()``\\와 ``V()``\\라는 이름을 사용했습니다)."

#: ../../library/threading.rst:875
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`~Semaphore.acquire` call and incremented by each "
":meth:`~Semaphore.release` call.  The counter can never go below zero; "
"when :meth:`~Semaphore.acquire` finds that it is zero, it blocks, waiting"
" until some other thread calls :meth:`~Semaphore.release`."
msgstr ""
"세마포어는 각 :meth:`~Semaphore.acquire` 호출에 의해 감소하고 각 "
":meth:`~Semaphore.release` 호출에 의해 증가하는 내부 카운터를 관리합니다. 카운터는 절대 0 밑으로 떨어질 수"
" 없습니다; :meth:`~Semaphore.acquire`\\가 0임을 발견하면, 다른 스레드가 "
":meth:`~Semaphore.release`\\를 호출할 때까지 대기하면서 블록 합니다."

#: ../../library/threading.rst:881
msgid ""
"Semaphores also support the :ref:`context management protocol <with-"
"locks>`."
msgstr "세마포어도 :ref:`컨텍스트 관리자 프로토콜 <with-locks>`\\을 지원합니다."

#: ../../library/threading.rst:886
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number"
" of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` "
"method blocks if necessary until it can return without making the counter"
" negative. If not given, *value* defaults to 1."
msgstr ""
"이 클래스는 세마포어 객체를 구현합니다. 세마포어는 :meth:`release` 호출 수에서 :meth:`acquire` 호출 수를"
" 빼고, 초깃값을 더한 원자 적 카운터를 관리합니다. :meth:`acquire` 메서드는 카운터를 음수로 만들지 않고 반환할 수 "
"있을 때까지 필요하면 블록 합니다. 지정하지 않으면, *value*\\의 기본값은 1입니다."

#: ../../library/threading.rst:892
msgid ""
"The optional argument gives the initial *value* for the internal counter;"
" it defaults to ``1``. If the *value* given is less than 0, "
":exc:`ValueError` is raised."
msgstr ""
"선택적 인자는 내부 카운터의 초깃 *값(value)*\\을 제공합니다; 기본값은 ``1``\\입니다. 주어진 *value*\\가 "
"0보다 작으면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/threading.rst:901
msgid "Acquire a semaphore."
msgstr "세마포어를 획득합니다."

#: ../../library/threading.rst:903
msgid "When invoked without arguments:"
msgstr "인자 없이 호출될 때:"

#: ../../library/threading.rst:905
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one"
" and return ``True`` immediately."
msgstr "진입 시 내부 카운터가 0보다 크면, 1 감소시키고 즉시 ``True``\\를 반환합니다."

#: ../../library/threading.rst:907
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to"
" :meth:`~Semaphore.release`.  Once awoken (and the counter is greater "
"than 0), decrement the counter by 1 and return ``True``.  Exactly one "
"thread will be awoken by each call to :meth:`~Semaphore.release`.  The "
"order in which threads are awoken should not be relied on."
msgstr ""
"진입 시 내부 카운터가 0이면, :meth:`~Semaphore.release`\\를 호출하여 깨울 때까지 블록 합니다. 일단 "
"깨어나면 (그리고 카운터가 0보다 크면), 카운터를 1줄이고 ``True``\\를 반환합니다. "
":meth:`~Semaphore.release`\\를 호출할 때마다 정확히 하나의 스레드가 깨어납니다. 스레드가 깨어나는 순서에 "
"의존해서는 안 됩니다."

#: ../../library/threading.rst:913
#, fuzzy
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise,"
" do the same thing as when called without arguments, and return ``True``."
msgstr ""
"거짓으로 설정한 *blocking*\\으로 호출하면 블록 하지 않습니다. 인자가 없는 호출이 블록 할 것이라면, 즉시 "
"``False``\\를 반환합니다; 그렇지 않으면, 인자 없이 호출할 때와 같은 작업을 수행하고, ``True``\\를 반환합니다."

#: ../../library/threading.rst:917
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at "
"most *timeout* seconds.  If acquire does not complete successfully in "
"that interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"``None`` 이외의 *timeout*\\으로 호출하면, 최대 *timeout* 초 동안 블록 합니다. 그 기간 획득이 완료되지 "
"않으면, ``False``\\를 반환합니다. 그렇지 않으면 ``True``\\를 반환합니다."

#: ../../library/threading.rst:926
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it "
"was zero on entry and other threads are waiting for it to become larger "
"than zero again, wake up *n* of those threads."
msgstr ""
"내부 카운터를 *n* 증가시키면서 세마포어를 해제합니다. 진입 시 0이고 다른 스레드가 다시 0보다 커지기를 기다리고 있으면, 해당"
" 스레드를 *n*\\개 깨웁니다."

#: ../../library/threading.rst:930
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr "여러 대기 스레드를 한 번에 해제하기 위해 *n* 매개 변수를 추가했습니다."

#: ../../library/threading.rst:936
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks"
" to make sure its current value doesn't exceed its initial value.  If it "
"does, :exc:`ValueError` is raised. In most situations semaphores are used"
" to guard resources with limited capacity.  If the semaphore is released "
"too many times it's a sign of a bug.  If not given, *value* defaults to "
"1."
msgstr ""
"경계 세마포어 객체를 구현하는 클래스. 경계 세마포어는 현재 값이 초깃값을 초과하지 않는지 확인합니다. 그렇다면, "
":exc:`ValueError`\\가 발생합니다. 대부분은 세마포어는 제한된 용량의 자원을 보호하는 데 사용됩니다. 세마포어가 너무"
" 여러 번 해제되면 버그의 징조입니다. 지정하지 않으면, *value*\\의 기본값은 1입니다."

#: ../../library/threading.rst:949
msgid ":class:`Semaphore` Example"
msgstr ":class:`Semaphore` 예"

#: ../../library/threading.rst:951
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the "
"resource is fixed, you should use a bounded semaphore.  Before spawning "
"any worker threads, your main thread would initialize the semaphore::"
msgstr ""
"세마포어는 예를 들어 데이터베이스 서버와 같이 제한된 용량의 자원을 보호하는 데 종종 사용됩니다. 자원의 크기가 고정된 상황에서는,"
" 경계 세마포어를 사용해야 합니다. 작업자 스레드를 만들기 전에, 메인 스레드가 세마포어를 초기화합니다::"

#: ../../library/threading.rst:956
msgid ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"
msgstr ""

#: ../../library/threading.rst:960
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr "일단 만들어지면, 작업자 스레드는 서버에 연결해야 할 때 세마포어의 acquire 및 release 메서드를 호출합니다::"

#: ../../library/threading.rst:963
msgid ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"
msgstr ""

#: ../../library/threading.rst:970
msgid ""
"The use of a bounded semaphore reduces the chance that a programming "
"error which causes the semaphore to be released more than it's acquired "
"will go undetected."
msgstr "경계 세마포어를 사용하면 세마포어가 획득한 것보다 더 많이 해제되는 프로그래밍 에러가 감지되지 않을 가능성이 줄어듭니다."

#: ../../library/threading.rst:977
msgid "Event Objects"
msgstr "Event 객체"

#: ../../library/threading.rst:979
msgid ""
"This is one of the simplest mechanisms for communication between threads:"
" one thread signals an event and other threads wait for it."
msgstr "이것은 스레드 간 통신을 위한 가장 간단한 메커니즘 중 하나입니다: 하나의 스레드는 이벤트를 알리고 다른 스레드는 이를 기다립니다."

#: ../../library/threading.rst:982
msgid ""
"An event object manages an internal flag that can be set to true with the"
" :meth:`~Event.set` method and reset to false with the "
":meth:`~Event.clear` method.  The :meth:`~Event.wait` method blocks until"
" the flag is true."
msgstr ""
"이벤트 객체는 :meth:`~Event.set` 메서드를 사용하여 참으로 설정하고 :meth:`~Event.clear` 메서드를 "
"사용하여 거짓으로 재설정 할 수 있는 내부 플래그를 관리합니다. :meth:`~Event.wait` 메서드는 플래그가 참이 될 "
"때까지 블록 합니다."

#: ../../library/threading.rst:989
msgid ""
"Class implementing event objects.  An event manages a flag that can be "
"set to true with the :meth:`~Event.set` method and reset to false with "
"the :meth:`clear` method.  The :meth:`wait` method blocks until the flag "
"is true. The flag is initially false."
msgstr ""
"이벤트 객체를 구현하는 클래스. 이벤트는 :meth:`~Event.set` 메서드로 참으로 설정하고 :meth:`clear` "
"메서드로 거짓으로 재설정 할 수 있는 플래그를 관리합니다. :meth:`wait` 메서드는 플래그가 참이 될 때까지 블록 합니다. "
"플래그는 처음에는 거짓입니다."

#: ../../library/threading.rst:999
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "내부 플래그가 참이면 그리고 오직 그때만 ``True``\\를 반환합니다."

#: ../../library/threading.rst:1001
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr ""

#: ../../library/threading.rst:1005
msgid ""
"Set the internal flag to true. All threads waiting for it to become true "
"are awakened. Threads that call :meth:`wait` once the flag is true will "
"not block at all."
msgstr ""
"내부 플래그를 참으로 설정합니다. 이것이 참이 되기를 기다리는 모든 스레드가 깨어납니다. 일단 플래그가 참이면 "
":meth:`wait`\\를 호출하는 스레드는 전혀 블록 하지 않습니다."

#: ../../library/threading.rst:1011
msgid ""
"Reset the internal flag to false. Subsequently, threads calling "
":meth:`wait` will block until :meth:`.set` is called to set the internal "
"flag to true again."
msgstr ""
"내부 플래그를 거짓으로 재설정합니다. 이후 :meth:`wait`\\를 호출하는 스레드는 내부 플래그를 다시 참으로 설정하기 위해 "
":meth:`.set`\\을 호출할 때까지 블록 합니다."

#: ../../library/threading.rst:1017
msgid ""
"Block as long as the internal flag is false and the timeout, if given, "
"has not expired. The return value represents the reason that this "
"blocking method returned; ``True`` if returning because the internal flag"
" is set to true, or ``False`` if a timeout is given and the internal flag"
" did not become true within the given wait time."
msgstr ""

#: ../../library/threading.rst:1023
#, fuzzy
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds, "
"or fractions thereof."
msgstr ""
"timeout 인자가 있고 ``None``\\이 아니면, 작업의 시간제한을 초(또는 부분 초)로 지정하는 부동 소수점 숫자여야 "
"합니다."

#: ../../library/threading.rst:1034
msgid "Timer Objects"
msgstr "Timer 객체"

#: ../../library/threading.rst:1036
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of "
":class:`Thread` and as such also functions as an example of creating "
"custom threads."
msgstr ""
"이 클래스는 특정 시간이 지난 후에만 실행되어야 하는 조치를 나타냅니다 -- 타이머. :class:`Timer`\\는 "
":class:`Thread`\\의 서브 클래스이며 사용자 정의 스레드를 만드는 예제로도 기능합니다."

#: ../../library/threading.rst:1040
#, fuzzy
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the "
"timer will wait before executing its action may not be exactly the same "
"as the interval specified by the user."
msgstr ""
"타이머는 스레드와 마찬가지로, :meth:`~Timer.start` 메서드를 호출하여 시작됩니다. "
":meth:`~Timer.cancel` 메서드를 호출하여 (조치를 시작하기 전에) 타이머를 중지할 수 있습니다. 조치를 실행하기 "
"전에 타이머가 대기하는 간격은 사용자가 지정한 간격과 정확히 같지 않을 수 있습니다."

#: ../../library/threading.rst:1046
msgid "For example::"
msgstr "예를 들면::"

#: ../../library/threading.rst:1048
msgid ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"
msgstr ""

#: ../../library/threading.rst:1057
msgid ""
"Create a timer that will run *function* with arguments *args* and  "
"keyword arguments *kwargs*, after *interval* seconds have passed. If "
"*args* is ``None`` (the default) then an empty list will be used. If "
"*kwargs* is ``None`` (the default) then an empty dict will be used."
msgstr ""
"*interval* 초가 지난 후 *args* 인자와 *kwargs* 키워드 인자로 *function*\\을 실행하는 타이머를 "
"만듭니다. *args*\\가 ``None``\\(기본값)이면 빈 리스트가 사용됩니다. *kwargs*\\가 "
"``None``\\(기본값)이면 빈 딕셔너리가 사용됩니다."

#: ../../library/threading.rst:1067
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This "
"will only work if the timer is still in its waiting stage."
msgstr "타이머를 중지하고, 타이머 조치의 실행을 취소합니다. 타이머가 아직 대기 상태에 있을 때만 작동합니다."

#: ../../library/threading.rst:1072
msgid "Barrier Objects"
msgstr "Barrier 객체"

#: ../../library/threading.rst:1076
msgid ""
"This class provides a simple synchronization primitive for use by a fixed"
" number of threads that need to wait for each other.  Each of the threads"
" tries to pass the barrier by calling the :meth:`~Barrier.wait` method "
"and will block until all of the threads have made their "
":meth:`~Barrier.wait` calls. At this point, the threads are released "
"simultaneously."
msgstr ""
"이 클래스는 서로를 기다려야 하는 고정된 수의 스레드에서 사용할 수 있는 간단한 동기화 프리미티브를 제공합니다. 각 스레드는 "
":meth:`~Barrier.wait` 메서드를 호출하여 장벽(barrier)을 통과하려고 시도하고 모든 스레드가 "
":meth:`~Barrier.wait` 호출을 수행할 때까지 블록 합니다. 이 시점에서, 스레드가 동시에 해제됩니다."

#: ../../library/threading.rst:1082
msgid ""
"The barrier can be reused any number of times for the same number of "
"threads."
msgstr "장벽은 같은 수의 스레드에 대해 여러 번 재사용 할 수 있습니다."

#: ../../library/threading.rst:1084
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr "예를 들어, 다음은 클라이언트와 서버 스레드를 동기화하는 간단한 방법입니다::"

#: ../../library/threading.rst:1086
msgid ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"
msgstr ""

#: ../../library/threading.rst:1104
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, "
"when provided, is a callable to be called by one of the threads when they"
" are released.  *timeout* is the default timeout value if none is "
"specified for the :meth:`wait` method."
msgstr ""
"*parties* 수의 스레드에 대한 장벽 객체를 만듭니다. 제공되면, *action*\\은 해제될 때 스레드 중 하나가 호출할 "
"콜러블입니다. *timeout*\\은 :meth:`wait` 메서드에 대해 지정되지 않을 때 사용될 기본 시간제한 값입니다."

#: ../../library/threading.rst:1111
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"장벽을 통과합니다. 장벽에 속한 모든 스레드가 이 함수를 호출할 때, 모두 동시에 해제됩니다. *timeout*\\이 제공되면, "
"클래스 생성자에 제공된 것보다 우선하여 사용됩니다."

#: ../../library/threading.rst:1116
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, "
"different for each thread.  This can be used to select a thread to do "
"some special housekeeping, e.g.::"
msgstr ""
"반환 값은 0에서 *parties* - 1 범위의 정수이며, 스레드마다 다릅니다. 이것은 특별한 하우스키핑을 수행할 스레드를 "
"선택하는데 사용될 수 있습니다, 예를 들어::"

#: ../../library/threading.rst:1120
msgid ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"
msgstr ""

#: ../../library/threading.rst:1125
msgid ""
"If an *action* was provided to the constructor, one of the threads will "
"have called it prior to being released.  Should this call raise an error,"
" the barrier is put into the broken state."
msgstr ""
"생성자에 *action*\\이 제공되면, 스레드 중 하나가 해제되기 전에 호출합니다. 이 호출로 에러가 발생하면, 장벽은 망가진 "
"상태가 됩니다."

#: ../../library/threading.rst:1129
msgid "If the call times out, the barrier is put into the broken state."
msgstr "호출 시간제한이 만료되면, 장벽은 망가진 상태가 됩니다."

#: ../../library/threading.rst:1131
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the "
"barrier is broken or reset while a thread is waiting."
msgstr ""
"스레드가 기다리는 동안 장벽이 망가지거나 재설정되면 이 메서드는 :class:`BrokenBarrierError` 예외를 발생시킬 "
"수 있습니다."

#: ../../library/threading.rst:1136
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on "
"it will receive the :class:`BrokenBarrierError` exception."
msgstr "장벽을 기본의 빈 상태로 되돌립니다. 대기 중인 모든 스레드는 :class:`BrokenBarrierError` 예외를 수신합니다."

#: ../../library/threading.rst:1139
msgid ""
"Note that using this function may require some external synchronization "
"if there are other threads whose state is unknown.  If a barrier is "
"broken it may be better to just leave it and create a new one."
msgstr ""
"상태를 알 수 없는 다른 스레드가 있을 때 이 함수를 사용하려면 외부 동기화가 필요할 수 있습니다. 장벽이 망가지면 그냥 두고 새 "
"장벽을 만드는 것이 좋습니다."

#: ../../library/threading.rst:1145
msgid ""
"Put the barrier into a broken state.  This causes any active or future "
"calls to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use "
"this for example if one of the threads needs to abort, to avoid "
"deadlocking the application."
msgstr ""
"장벽을 망가진 상태로 보냅니다. 이로 인해 :meth:`wait`\\에 대한 활성 또는 미래의 호출이 "
":class:`BrokenBarrierError`\\로 실패합니다. 예를 들어 응용 프로그램의 교착 상태를 피하고자 스레드 중 "
"하나를 중단해야 할 때 이를 사용하십시오."

#: ../../library/threading.rst:1150
msgid ""
"It may be preferable to simply create the barrier with a sensible "
"*timeout* value to automatically guard against one of the threads going "
"awry."
msgstr "스레드 중 하나가 잘못되는 것을 막기 위해 단순히 적절한 *timeout* 값으로 장벽을 만드는 것이 바람직 할 수 있습니다."

#: ../../library/threading.rst:1156
msgid "The number of threads required to pass the barrier."
msgstr "장벽을 통과하는 데 필요한 스레드 수."

#: ../../library/threading.rst:1160
msgid "The number of threads currently waiting in the barrier."
msgstr "현재 장벽에서 대기 중인 스레드 수."

#: ../../library/threading.rst:1164
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "장벽이 망가진 상태이면 ``True``\\인 불리언."

#: ../../library/threading.rst:1169
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the "
":class:`Barrier` object is reset or broken."
msgstr ""
":exc:`RuntimeError`\\의 서브 클래스인, 이 예외는 :class:`Barrier` 객체가 재설정되거나 망가질 때 "
"발생합니다."

#: ../../library/threading.rst:1176
msgid "Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr ":keyword:`!with` 문으로 록, 조건 및 세마포어 사용하기"

#: ../../library/threading.rst:1178
#, fuzzy
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with`"
" statement.  The ``acquire`` method will be called when the block is "
"entered, and ``release`` will be called when the block is exited.  Hence,"
" the following snippet::"
msgstr ""
"이 모듈에서 제공하는 :meth:`acquire`\\와 :meth:`release` 메서드가 있는 모든 객체는 "
":keyword:`with` 문의 컨텍스트 관리자로 사용될 수 있습니다. 블록에 진입할 때 :meth:`acquire` 메서드가 "
"호출되고, 블록을 벗어날 때 :meth:`release`\\가 호출됩니다. 따라서, 다음 코드 조각은::"

#: ../../library/threading.rst:1184
msgid ""
"with some_lock:\n"
"    # do something..."
msgstr ""

#: ../../library/threading.rst:1187
msgid "is equivalent to::"
msgstr "다음과 동등합니다::"

#: ../../library/threading.rst:1189
msgid ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"
msgstr ""

#: ../../library/threading.rst:1195
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, "
":class:`Semaphore`, and :class:`BoundedSemaphore` objects may be used as "
":keyword:`with` statement context managers."
msgstr ""
"현재 :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:`Semaphore` "
"및 :class:`BoundedSemaphore` 객체는 :keyword:`with` 문 컨텍스트 관리자로 사용될 수 있습니다."

#: ../../library/threading.rst:158 ../../library/threading.rst:176
msgid "trace function"
msgstr ""

#: ../../library/threading.rst:176
msgid "debugger"
msgstr ""

#: ../../library/threading.rst:187 ../../library/threading.rst:205
msgid "profile function"
msgstr ""

#~ msgid ""
#~ "While they are not listed below, "
#~ "the ``camelCase`` names used for some"
#~ " methods and functions in this module"
#~ " in the Python 2.x series are "
#~ "still supported by this module."
#~ msgstr ""
#~ "아래에 나열되지는 않지만, 파이썬 2.x 시리즈에서 이 "
#~ "모듈의 일부 메서드와 함수에 사용된 ``camelCase`` "
#~ "이름도 이 모듈에서 여전히 지원됩니다."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Windows, "
#~ "FreeBSD, Linux, macOS, OpenBSD, NetBSD, "
#~ "AIX."
#~ msgstr ""
#~ ":ref:`가용성 <availability>`: 윈도우, FreeBSD, 리눅스,"
#~ " macOS, OpenBSD, NetBSD, AIX."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Windows, systems"
#~ " with POSIX threads."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우, POSIX 스레드가 있는 시스템."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Requires "
#~ ":func:`get_native_id` function."
#~ msgstr ":ref:`가용성 <availability>`: :func:`get_native_id` 함수가 필요합니다."

#~ msgid ""
#~ "Note that ``Lock`` is actually a "
#~ "factory function which returns an "
#~ "instance of the most efficient version"
#~ " of the concrete Lock class that "
#~ "is supported by the platform."
#~ msgstr ""
#~ "``Lock``\\은 실제로는 플랫폼에서 지원하는 가장 효율적인 "
#~ "버전의 구상 Lock 클래스 인스턴스를 반환하는 팩토리 "
#~ "함수임에 유의하십시오."

#~ msgid ""
#~ "Reentrant locks also support the "
#~ ":ref:`context management protocol <with-"
#~ "locks>`."
#~ msgstr "재진입 록도 :ref:`컨텍스트 관리자 프로토콜 <with-locks>`\\을 지원합니다."

#~ msgid ""
#~ "When invoked without arguments: if this"
#~ " thread already owns the lock, "
#~ "increment the recursion level by one,"
#~ " and return immediately.  Otherwise, if "
#~ "another thread owns the lock, block "
#~ "until the lock is unlocked.  Once "
#~ "the lock is unlocked (not owned by"
#~ " any thread), then grab ownership, "
#~ "set the recursion level to one, "
#~ "and return.  If more than one "
#~ "thread is blocked waiting until the "
#~ "lock is unlocked, only one at a"
#~ " time will be able to grab "
#~ "ownership of the lock. There is no"
#~ " return value in this case."
#~ msgstr ""
#~ "인자 없이 호출될 때: 이 스레드가 이미 록을"
#~ " 소유했으면, 재귀 수준을 1 늘리고, 즉시 반환합니다."
#~ " 그렇지 않고, 다른 스레드가 록을 소유했으면, 록이"
#~ " 잠금 해제될 때까지 블록 합니다. 일단 록이 "
#~ "잠금 해제되면 (아무런 스레드도 소유하지 않으면), 소유권을"
#~ " 잡고, 재귀 수준을 1로 설정한 후 반환합니다. "
#~ "록이 잠금 해제될 때까지 대기 중인 스레드가 둘"
#~ " 이상이면, 한 번에 오직 하나만 록의 소유권을 "
#~ "확보할 수 있습니다. 이 경우 반환 값이 없습니다."

#~ msgid ""
#~ "When invoked with the *blocking* "
#~ "argument set to true, do the same"
#~ " thing as when called without "
#~ "arguments, and return ``True``."
#~ msgstr ""
#~ "*blocking* 인자를 참으로 설정하여 호출하면, 인자 "
#~ "없이 호출할 때와 같은 작업을 수행하고, ``True``\\를"
#~ " 반환합니다."

#~ msgid ""
#~ "When invoked with the *blocking* "
#~ "argument set to false, do not "
#~ "block.  If a call without an "
#~ "argument would block, return ``False`` "
#~ "immediately; otherwise, do the same "
#~ "thing as when called without arguments,"
#~ " and return ``True``."
#~ msgstr ""
#~ "거짓으로 설정된 *blocking* 인자로 호출하면, 블록 "
#~ "하지 않습니다. 인자가 없는 호출이 블록 할 "
#~ "것이라면, 즉시 ``False``\\를 반환합니다; 그렇지 않으면,"
#~ " 인자 없이 호출할 때와 같은 작업을 수행하고, "
#~ "``True``\\를 반환합니다."

#~ msgid ""
#~ "When invoked with the floating-point "
#~ "*timeout* argument set to a positive "
#~ "value, block for at most the "
#~ "number of seconds specified by *timeout*"
#~ " and as long as the lock cannot"
#~ " be acquired.  Return ``True`` if the"
#~ " lock has been acquired, false if "
#~ "the timeout has elapsed."
#~ msgstr ""
#~ "양수 값으로 설정된 부동 소수점 *timeout* 인자로"
#~ " 호출하면, 록을 획득할 수 없는 한 최대 "
#~ "*timeout*\\에 지정된 초 동안 블록 합니다. 록이"
#~ " 획득되면 ``True``\\를 반환하고, timeout을 초과하면 "
#~ "거짓을 반환합니다."

#~ msgid ""
#~ "Block until the internal flag is "
#~ "true.  If the internal flag is "
#~ "true on entry, return immediately.  "
#~ "Otherwise, block until another thread "
#~ "calls :meth:`.set` to set the flag "
#~ "to true, or until the optional "
#~ "timeout occurs."
#~ msgstr ""
#~ "내부 플래그가 참이 될 때까지 블록 합니다. 진입"
#~ " 시에 내부 플래그가 참이면 즉시 반환합니다. 그렇지"
#~ " 않으면, 다른 스레드가 :meth:`.set`\\을 호출하여 "
#~ "플래그를 참으로 설정하거나, 선택적 시간제한 만료가 발생할"
#~ " 때까지 블록 합니다."

#~ msgid ""
#~ "This method returns ``True`` if and "
#~ "only if the internal flag has been"
#~ " set to true, either before the "
#~ "wait call or after the wait "
#~ "starts, so it will always return "
#~ "``True`` except if a timeout is "
#~ "given and the operation times out."
#~ msgstr ""
#~ "이 메서드는 wait 호출 전이나 wait 시작 "
#~ "후에 내부 플래그가 참으로 설정된 경우에만 "
#~ "``True``\\를 반환하므로, timeout이 지정되고 연산이 "
#~ "시간제한 만료되었을 때를 제외하고 항상 ``True``\\를 "
#~ "반환합니다."

