# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/aifc.rst:2
#, fuzzy
msgid ":mod:`!aifc` --- Read and write AIFF and AIFC files"
msgstr ":mod:`aifc` --- AIFF와 AIFC 파일 읽고 쓰기"

#: ../../library/aifc.rst:10
msgid ""
"This module is no longer part of the Python standard library. It was "
":ref:`removed in Python 3.13 <whatsnew313-pep594>` after being deprecated"
" in Python 3.11.  The removal was decided in :pep:`594`."
msgstr ""

#: ../../library/aifc.rst:14
msgid ""
"The last version of Python that provided the :mod:`!aifc` module was "
"`Python 3.12 <https://docs.python.org/3.12/library/aifc.html>`_."
msgstr ""

#~ msgid "**Source code:** :source:`Lib/aifc.py`"
#~ msgstr "**소스 코드:** :source:`Lib/aifc.py`"

#~ msgid ""
#~ "This module provides support for reading"
#~ " and writing AIFF and AIFF-C files."
#~ " AIFF is Audio Interchange File "
#~ "Format, a format for storing digital "
#~ "audio samples in a file.  AIFF-C "
#~ "is a newer version of the format"
#~ " that includes the ability to "
#~ "compress the audio data."
#~ msgstr ""
#~ "이 모듈은 AIFF와 AIFF-C 파일을 읽고 쓸 "
#~ "수 있도록 지원합니다. AIFF는 디지털 오디오 샘플을 "
#~ "파일에 저장하는 형식인 Audio Interchange File "
#~ "Format입니다. AIFF-C는 오디오 데이터를 압축하는 기능을 "
#~ "포함하는 이 형식의 새 버전입니다."

#~ msgid ""
#~ "Audio files have a number of "
#~ "parameters that describe the audio data."
#~ " The sampling rate or frame rate "
#~ "is the number of times per second"
#~ " the sound is sampled.  The number"
#~ " of channels indicate if the audio"
#~ " is mono, stereo, or quadro.  Each"
#~ " frame consists of one sample per "
#~ "channel.  The sample size is the "
#~ "size in bytes of each sample.  "
#~ "Thus a frame consists of ``nchannels "
#~ "* samplesize`` bytes, and a second's "
#~ "worth of audio consists of ``nchannels"
#~ " * samplesize * framerate`` bytes."
#~ msgstr ""
#~ "오디오 파일에는 오디오 데이터를 설명하는 많은 파라미터가"
#~ " 있습니다. 샘플링 속도나 프레임 속도는 음향을 "
#~ "샘플링하는 초당 횟수입니다. 채널 수는 오디오가 "
#~ "모노(mono), 스테레오(stereo) 또는 쿼드로(quadro)인지를 "
#~ "나타냅니다. 각 프레임은 채널 당 하나의 샘플로 "
#~ "구성됩니다. 샘플 크기는 각 샘플의 크기를 바이트로 "
#~ "표현한 것입니다. 따라서 프레임은 ``nchannels * "
#~ "samplesize`` 바이트로 구성되고, 1초 분량의 오디오는 "
#~ "``nchannels * samplesize * framerate`` "
#~ "바이트로 구성됩니다."

#~ msgid ""
#~ "For example, CD quality audio has "
#~ "a sample size of two bytes (16 "
#~ "bits), uses two channels (stereo) and"
#~ " has a frame rate of 44,100 "
#~ "frames/second.  This gives a frame size"
#~ " of 4 bytes (2\\*2), and a "
#~ "second's worth occupies 2\\*2\\*44100 bytes"
#~ " (176,400 bytes)."
#~ msgstr ""
#~ "예를 들어, CD 품질 오디오는 샘플 크기가 "
#~ "2바이트 (16비트)이고, 2채널(스테레오)을 사용하며 프레임 속도가"
#~ " 44,100프레임/초입니다. 이는 4바이트(2\\*2)의 프레임 크기를"
#~ " 제공하고, 1초 분량의 오디오는 "
#~ "2\\*2\\*44100바이트(176,400바이트)를 차지합니다."

#~ msgid "Module :mod:`aifc` defines the following function:"
#~ msgstr "모듈 :mod:`aifc`\\는 다음 함수를 정의합니다:"

#~ msgid ""
#~ "Open an AIFF or AIFF-C file and"
#~ " return an object instance with "
#~ "methods that are described below.  The"
#~ " argument *file* is either a string"
#~ " naming a file or a :term:`file "
#~ "object`.  *mode* must be ``'r'`` or "
#~ "``'rb'`` when the file must be "
#~ "opened for reading, or ``'w'``  or "
#~ "``'wb'`` when the file must be "
#~ "opened for writing. If omitted, "
#~ "``file.mode`` is used if it exists, "
#~ "otherwise ``'rb'`` is used.  When used"
#~ " for writing, the file object should"
#~ " be seekable, unless you know ahead"
#~ " of time how many samples you "
#~ "are going to write in total and"
#~ " use :meth:`writeframesraw` and "
#~ ":meth:`setnframes`. The :func:`.open` function "
#~ "may be used in a :keyword:`with` "
#~ "statement.  When the :keyword:`!with` block"
#~ " completes, the :meth:`~aifc.close` method "
#~ "is called."
#~ msgstr ""
#~ "AIFF나 AIFF-C 파일을 열고 아래에 설명된 메서드를"
#~ " 갖는 객체 인스턴스를 반환합니다. 인자 *file*\\는 "
#~ "파일을 명명하는 문자열이거나 :term:`파일 객체 <file "
#~ "object>`\\입니다. *mode*\\는 파일을 읽기 위해 열어야"
#~ " 할 때 ``'r'``\\이나 ``'rb'`` 여야 하며, "
#~ "파일을 쓰기 위해 열어야 하는 경우 ``'w'``\\나 "
#~ "``'wb'`` 여야 합니다. 생략하면, ``file.mode``\\가 "
#~ "있으면 그것을 쓰고, 그렇지 않으면 ``'rb'``\\가 "
#~ "사용됩니다. 쓰기 위해 열 때는, 앞으로 기록할 "
#~ "샘플의 총수를 미리 알고 :meth:`writeframesraw` 및"
#~ " :meth:`setnframes`\\를 사용하지 않는 한 파일 "
#~ "객체는 위치 변경할 수 있어야(seekable) 합니다. "
#~ ":func:`.open` 함수는 :keyword:`with` 문에서 사용될 "
#~ "수 있습니다. :keyword:`!with` 블록이 완료될 때 "
#~ ":meth:`~aifc.close` 메서드가 호출됩니다."

#~ msgid "Support for the :keyword:`with` statement was added."
#~ msgstr ":keyword:`with` 문에 대한 지원이 추가되었습니다."

#~ msgid ""
#~ "Objects returned by :func:`.open` when a"
#~ " file is opened for reading have "
#~ "the following methods:"
#~ msgstr "파일을 읽기 위해 열 때 :func:`.open`\\가 반환하는 객체는 다음과 같은 메서드를 가집니다:"

#~ msgid "Return the number of audio channels (1 for mono, 2 for stereo)."
#~ msgstr "오디오 채널 수를 반환합니다 (모노는 1, 스테레오는 2)."

#~ msgid "Return the size in bytes of individual samples."
#~ msgstr "개별 샘플의 크기를 바이트 단위로 반환합니다."

#~ msgid "Return the sampling rate (number of audio frames per second)."
#~ msgstr "샘플링 속도(초당 오디오 프레임의 수)를 반환합니다."

#~ msgid "Return the number of audio frames in the file."
#~ msgstr "파일 내의 오디오 프레임의 수를 반환합니다."

#~ msgid ""
#~ "Return a bytes array of length 4"
#~ " describing the type of compression "
#~ "used in the audio file.  For AIFF"
#~ " files, the returned value is "
#~ "``b'NONE'``."
#~ msgstr ""
#~ "오디오 파일에서 사용된 압축 유형을 설명하는 길이 "
#~ "4의 바이트열을 반환합니다. AIFF 파일의 경우, 반환"
#~ " 값은 ``b'NONE'``\\입니다."

#~ msgid ""
#~ "Return a bytes array convertible to "
#~ "a human-readable description of the "
#~ "type of compression used in the "
#~ "audio file.  For AIFF files, the "
#~ "returned value is ``b'not compressed'``."
#~ msgstr ""
#~ "오디오 파일에서 사용된 압축 유형을 사람이 읽을 수"
#~ " 있는 형식으로 변환할 수 있는 바이트열을 반환합니다."
#~ " AIFF 파일의 경우, 반환 값은 ``b'not "
#~ "compressed'``\\입니다."

#~ msgid ""
#~ "Returns a :func:`~collections.namedtuple` "
#~ "``(nchannels, sampwidth, framerate, nframes, "
#~ "comptype, compname)``, equivalent to output"
#~ " of the :meth:`get\\*` methods."
#~ msgstr ""
#~ ":meth:`get\\*` 메서드의 결과와 동등한, "
#~ ":func:`~collections.namedtuple` ``(nchannels, sampwidth,"
#~ " framerate, nframes, comptype, compname)``\\을 "
#~ "반환합니다."

#~ msgid ""
#~ "Return a list of markers in the"
#~ " audio file.  A marker consists of"
#~ " a tuple of three elements.  The "
#~ "first is the mark ID (an integer),"
#~ " the second is the mark position "
#~ "in frames from the beginning of "
#~ "the data (an integer), the third "
#~ "is the name of the mark (a "
#~ "string)."
#~ msgstr ""
#~ "오디오 파일의 마커(marker) 리스트를 반환합니다. 마커는 "
#~ "세 요소의 튜플로 구성됩니다. 첫 번째는 마크 "
#~ "ID(정수)이고, 두 번째는 데이터 시작부터 따진 프레임에서의"
#~ " 마크 위치이며 (정수), 세 번째는 마크의 이름입니다"
#~ " (문자열)."

#~ msgid ""
#~ "Return the tuple as described in "
#~ ":meth:`getmarkers` for the mark with the"
#~ " given *id*."
#~ msgstr "지정된 *id*\\를 가진 마크에 대해 :meth:`getmarkers`\\에 설명된 튜플을 반환합니다."

#~ msgid ""
#~ "Read and return the next *nframes* "
#~ "frames from the audio file.  The "
#~ "returned data is a string containing "
#~ "for each frame the uncompressed samples"
#~ " of all channels."
#~ msgstr ""
#~ "오디오 파일에서 다음 *nframes* 프레임을 읽고 "
#~ "반환합니다. 반환된 데이터는 각 프레임의 모든 채널의 "
#~ "압축되지 않은 샘플을 포함하는 문자열입니다."

#~ msgid ""
#~ "Rewind the read pointer.  The next "
#~ ":meth:`readframes` will start from the "
#~ "beginning."
#~ msgstr "읽기 포인터를 되감습니다. 다음 :meth:`readframes`\\는 처음부터 시작됩니다."

#~ msgid "Seek to the specified frame number."
#~ msgstr "지정된 프레임 번호로 위치 변경합니다."

#~ msgid "Return the current frame number."
#~ msgstr "현재의 프레임 번호를 반환합니다."

#~ msgid ""
#~ "Close the AIFF file.  After calling "
#~ "this method, the object can no "
#~ "longer be used."
#~ msgstr "AIFF 파일을 닫습니다. 이 메서드를 호출한 후에는 객체를 더는 사용할 수 없습니다."

#~ msgid ""
#~ "Objects returned by :func:`.open` when a"
#~ " file is opened for writing have "
#~ "all the above methods, except for "
#~ ":meth:`readframes` and :meth:`setpos`.  In "
#~ "addition the following methods exist.  "
#~ "The :meth:`get\\*` methods can only be"
#~ " called after the corresponding "
#~ ":meth:`set\\*` methods have been called.  "
#~ "Before the first :meth:`writeframes` or "
#~ ":meth:`writeframesraw`, all parameters except "
#~ "for the number of frames must be"
#~ " filled in."
#~ msgstr ""
#~ "파일을 쓰기 위해 열 때, :func:`.open`\\이 "
#~ "반환하는 객체는 :meth:`readframes`\\와 :meth:`setpos`\\를 "
#~ "제외하고 위의 모든 메서드를 가집니다. 이에 더해 "
#~ "다음과 같은 메서드가 있습니다. :meth:`get\\*` 메서드는"
#~ " 해당 :meth:`set\\*` 메서드가 호출된 후에만 호출할"
#~ " 수 있습니다. 첫 번째 :meth:`writeframes`\\나 "
#~ ":meth:`writeframesraw` 이전에, 프레임 수를 제외한 "
#~ "모든 파라미터를 채워야 합니다."

#~ msgid ""
#~ "Create an AIFF file.  The default "
#~ "is that an AIFF-C file is created,"
#~ " unless the name of the file "
#~ "ends in ``'.aiff'`` in which case "
#~ "the default is an AIFF file."
#~ msgstr ""
#~ "AIFF 파일을 만듭니다. 기본값은 AIFF-C 파일을 만드는"
#~ " 것입니다. 파일 이름이 ``'.aiff'``\\로 끝날 때는"
#~ " 예외인데, 이때 기본값은 AIFF 파일입니다."

#~ msgid ""
#~ "Create an AIFF-C file.  The default "
#~ "is that an AIFF-C file is created,"
#~ " unless the name of the file "
#~ "ends in ``'.aiff'`` in which case "
#~ "the default is an AIFF file."
#~ msgstr ""
#~ "AIFF-C 파일을 만듭니다. 기본값은 AIFF-C 파일을 "
#~ "만드는 것입니다. 파일 이름이 ``'.aiff'``\\로 끝날 "
#~ "때는 예외인데, 이때 기본값은 AIFF 파일입니다."

#~ msgid "Specify the number of channels in the audio file."
#~ msgstr "오디오 파일의 채널 수를 지정합니다."

#~ msgid "Specify the size in bytes of audio samples."
#~ msgstr "오디오 샘플의 크기를 바이트 단위로 지정합니다."

#~ msgid "Specify the sampling frequency in frames per second."
#~ msgstr "샘플링 빈도를 초당 프레임 수로 지정합니다."

#~ msgid ""
#~ "Specify the number of frames that "
#~ "are to be written to the audio "
#~ "file. If this parameter is not "
#~ "set, or not set correctly, the "
#~ "file needs to support seeking."
#~ msgstr ""
#~ "오디오 파일에 기록할 프레임 수를 지정합니다. 이 "
#~ "파라미터가 설정되지 않거나, 올바르게 설정되지 않으면, 파일은"
#~ " 위치 변경을 지원해야 합니다."

#~ msgid ""
#~ "Specify the compression type.  If not"
#~ " specified, the audio data will not"
#~ " be compressed.  In AIFF files, "
#~ "compression is not possible. The name"
#~ " parameter should be a human-readable"
#~ " description of the compression type "
#~ "as a bytes array, the type "
#~ "parameter should be a bytes array "
#~ "of length 4.  Currently the following"
#~ " compression types are supported: "
#~ "``b'NONE'``, ``b'ULAW'``, ``b'ALAW'``, ``b'G722'``."
#~ msgstr ""
#~ "압축 유형을 지정합니다. 지정하지 않으면, 오디오 데이터는"
#~ " 압축되지 않습니다. AIFF 파일에서, 압축은 불가능합니다."
#~ " name 매개 변수는 사람이 읽을 수 있는 "
#~ "압축 유형 설명을 바이트열로 제공해야 하며, type "
#~ "매개 변수는 길이가 4인 바이트열이어야 합니다. 현재 "
#~ "다음 압축 유형이 지원됩니다: ``b'NONE'``, "
#~ "``b'ULAW'``, ``b'ALAW'``, ``b'G722'``."

#~ msgid ""
#~ "Set all the above parameters at "
#~ "once.  The argument is a tuple "
#~ "consisting of the various parameters.  "
#~ "This means that it is possible to"
#~ " use the result of a "
#~ ":meth:`getparams` call as argument to "
#~ ":meth:`setparams`."
#~ msgstr ""
#~ "위의 모든 파라미터를 한 번에 설정합니다. 인자는 "
#~ "여러 파라미터로 구성된 튜플입니다. 이것은 "
#~ ":meth:`getparams` 호출의 결과를 :meth:`setparams`\\의 "
#~ "인자로 사용할 수 있음을 뜻합니다."

#~ msgid ""
#~ "Add a mark with the given id "
#~ "(larger than 0), and the given "
#~ "name at the given position.  This "
#~ "method can be called at any time"
#~ " before :meth:`close`."
#~ msgstr ""
#~ "지정된 id(0보다 큰 값)의 마크를 주어진 name으로"
#~ " 주어진 위치에 추가합니다. 이 메서드는 :meth:`close`"
#~ " 이전에 언제든지 호출할 수 있습니다."

#~ msgid ""
#~ "Return the current write position in "
#~ "the output file.  Useful in combination"
#~ " with :meth:`setmark`."
#~ msgstr "출력 파일의 현재 쓰기 위치를 반환합니다. :meth:`setmark`\\와 함께 사용하면 유용합니다."

#~ msgid ""
#~ "Write data to the output file.  "
#~ "This method can only be called "
#~ "after the audio file parameters have "
#~ "been set."
#~ msgstr "데이터를 출력 파일에 씁니다. 이 메서드는 오디오 파일 파라미터가 설정된 후에만 호출할 수 있습니다."

#~ msgid "Any :term:`bytes-like object` is now accepted."
#~ msgstr "이제 모든 :term:`바이트열류 객체 <bytes-like object>`\\가 허용됩니다."

#~ msgid ""
#~ "Like :meth:`writeframes`, except that the "
#~ "header of the audio file is not"
#~ " updated."
#~ msgstr "오디오 파일의 헤더가 갱신되지 않는다는 점을 제외하고는, :meth:`writeframes`\\와 같습니다."

#~ msgid ""
#~ "Close the AIFF file.  The header "
#~ "of the file is updated to reflect"
#~ " the actual size of the audio "
#~ "data. After calling this method, the "
#~ "object can no longer be used."
#~ msgstr ""
#~ "AIFF 파일을 닫습니다. 파일의 헤더는 오디오 데이터의"
#~ " 실제 크기를 반영하도록 갱신됩니다. 이 메서드를 호출한"
#~ " 후에는, 객체를 더는 사용할 수 없습니다."

