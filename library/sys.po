# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/sys.rst:2
#, fuzzy
msgid ":mod:`!sys` --- System-specific parameters and functions"
msgstr ":mod:`sys` --- 시스템 특정 파라미터와 함수"

#: ../../library/sys.rst:9
#, fuzzy
msgid ""
"This module provides access to some variables used or maintained by the "
"interpreter and to functions that interact strongly with the interpreter."
" It is always available. Unless explicitly noted otherwise, all variables"
" are read-only."
msgstr ""
"이 모듈은 인터프리터에 의해 사용되거나 유지되는 일부 변수와 인터프리터와 강하게 상호 작용하는 함수에 대한 액세스를 제공합니다. "
"항상 사용 가능합니다."

#: ../../library/sys.rst:16
msgid ""
"On POSIX systems where Python was built with the standard ``configure`` "
"script, this contains the ABI flags as specified by :pep:`3149`."
msgstr ""
"표준 ``configure`` 스크립트를 사용하여 파이썬을 빌드한 POSIX 시스템에서, 이것은 :pep:`3149`\\에 지정된 "
"ABI 플래그를 포함합니다."

#: ../../library/sys.rst:21
msgid ""
"Default flags became an empty string (``m`` flag for pymalloc has been "
"removed)."
msgstr "기본 플래그는 빈 문자열이 되었습니다 (pymalloc을 위한 ``m`` 플래그가 제거되었습니다)."

#: ../../library/sys.rst:25 ../../library/sys.rst:299 ../../library/sys.rst:369
#: ../../library/sys.rst:760 ../../library/sys.rst:778
#: ../../library/sys.rst:1020 ../../library/sys.rst:1522
#: ../../library/sys.rst:1763 ../../library/sys.rst:1778
#: ../../library/sys.rst:1786 ../../library/sys.rst:1802
#: ../../library/sys.rst:2046
msgid "Availability"
msgstr "가용성"

#: ../../library/sys.rst:30
#, fuzzy
msgid ""
"Append the callable *hook* to the list of active auditing hooks for the "
"current (sub)interpreter."
msgstr "현재 인터프리터의 활성 감사 훅 리스트에 콜러블 *hook*\\을 추가합니다."

#: ../../library/sys.rst:33
#, fuzzy
msgid ""
"When an auditing event is raised through the :func:`sys.audit` function, "
"each hook will be called in the order it was added with the event name "
"and the tuple of arguments. Native hooks added by "
":c:func:`PySys_AddAuditHook` are called first, followed by hooks added in"
" the current (sub)interpreter.  Hooks can then log the event, raise an "
"exception to abort the operation, or terminate the process entirely."
msgstr ""
":func:`sys.audit` 함수를 통해 감사 이벤트가 발생하면, 각 훅은 추가된 순서대로 이벤트 이름과 인자 튜플로 "
"호출됩니다. :c:func:`PySys_AddAuditHook`\\으로 추가된 네이티브 훅이 먼저 호출되고, 현재 인터프리터에서 "
"추가된 훅이 뒤따릅니다. 그런 다음 훅은 이벤트를 로그 하거나, 예외를 발생 시켜 연산을 중단하거나, 프로세스를 완전히 종료 할 수"
" 있습니다."

#: ../../library/sys.rst:40
msgid ""
"Note that audit hooks are primarily for collecting information about "
"internal or otherwise unobservable actions, whether by Python or "
"libraries written in Python. They are not suitable for implementing a "
"\"sandbox\". In particular, malicious code can trivially disable or "
"bypass hooks added using this function. At a minimum, any security-"
"sensitive hooks must be added using the C API "
":c:func:`PySys_AddAuditHook` before initialising the runtime, and any "
"modules allowing arbitrary memory modification (such as :mod:`ctypes`) "
"should be completely removed or closely monitored."
msgstr ""

#: ../../library/sys.rst:49 ../../library/sys.rst:51
msgid ""
"Calling :func:`sys.addaudithook` will itself raise an auditing event "
"named ``sys.addaudithook`` with no arguments. If any existing hooks raise"
" an exception derived from :class:`RuntimeError`, the new hook will not "
"be added and the exception suppressed. As a result, callers cannot assume"
" that their hook has been added unless they control all existing hooks."
msgstr ""
":func:`sys.addaudithook`\\을 호출하면 스스로 인자 없이 ``sys.addaudithook``\\이라는 이름의 "
"감사 이벤트를 발생시킵니다. 기존 훅에서 :class:`RuntimeError`\\에서 파생된 예외가 발생하면, 새 훅이 추가되지 "
"않고 예외가 억제됩니다. 결과적으로, 호출자는 기존의 모든 훅을 제어하지 않는 한 훅이 추가되었다고 가정할 수 없습니다."

#: ../../library/sys.rst:58
msgid ""
"See the :ref:`audit events table <audit-events>` for all events raised by"
" CPython, and :pep:`578` for the original design discussion."
msgstr ""
"CPython이 발생시키는 모든 이벤트에 대해서는 :ref:`감사 이벤트 표 <audit-events>`\\를, 원래 디자인 논의는"
" :pep:`578`\\을 참조하십시오."

#: ../../library/sys.rst:65
msgid ""
"Exceptions derived from :class:`Exception` but not :class:`RuntimeError` "
"are no longer suppressed."
msgstr ""
":class:`Exception`\\에서 파생되었지만 :class:`RuntimeError`\\가 아닌 예외는 더는 억제되지 "
"않습니다."

#: ../../library/sys.rst:70
msgid ""
"When tracing is enabled (see :func:`settrace`), Python hooks are only "
"traced if the callable has a ``__cantrace__`` member that is set to a "
"true value. Otherwise, trace functions will skip the hook."
msgstr ""
"추적(tracing)이 활성화되었을 때 (:func:`settrace`\\를 참조하십시오), 파이썬 훅은 콜러블에 참값으로 설정된 "
"``__cantrace__`` 멤버가 있을 때만 추적합니다. 그렇지 않으면, 추적 함수는 훅을 건너뜁니다."

#: ../../library/sys.rst:77
msgid ""
"The list of command line arguments passed to a Python script. ``argv[0]``"
" is the script name (it is operating system dependent whether this is a "
"full pathname or not).  If the command was executed using the "
":option:`-c` command line option to the interpreter, ``argv[0]`` is set "
"to the string ``'-c'``.  If no script name was passed to the Python "
"interpreter, ``argv[0]`` is the empty string."
msgstr ""
"파이썬 스크립트에 전달된 명령 줄 인자 리스트. ``argv[0]``\\은 스크립트 이름입니다 (전체 경로명인지는 운영 체제에 따라"
" 다릅니다). 인터프리터에 :option:`-c` 명령 줄 옵션을 사용하여 명령이 실행되었으면, ``argv[0]``\\은 문자열 "
"``'-c'``\\로 설정됩니다. 파이썬 인터프리터에 스크립트 이름이 전달되지 않으면, ``argv[0]``\\은 빈 문자열입니다."

#: ../../library/sys.rst:83
msgid ""
"To loop over the standard input, or the list of files given on the "
"command line, see the :mod:`fileinput` module."
msgstr "표준 입력이나 명령 줄에 제공된 파일 목록을 루핑 하려면, :mod:`fileinput` 모듈을 참조하십시오."

#: ../../library/sys.rst:86
msgid "See also :data:`sys.orig_argv`."
msgstr ""

#: ../../library/sys.rst:89
msgid ""
"On Unix, command line arguments are passed by bytes from OS.  Python "
"decodes them with filesystem encoding and \"surrogateescape\" error "
"handler. When you need original bytes, you can get it by "
"``[os.fsencode(arg) for arg in sys.argv]``."
msgstr ""
"유닉스에서, 명령 줄 인자는 OS에서 바이트열로 전달됩니다. 파이썬은 이것들을 파일 시스템 인코딩과 "
"\"surrogateescape\" 에러 처리기로 디코딩합니다. 원본 바이트열이 필요할 때, ``[os.fsencode(arg) "
"for arg in sys.argv]``\\로 얻을 수 있습니다."

#: ../../library/sys.rst:101
msgid ""
"Raise an auditing event and trigger any active auditing hooks. *event* is"
" a string identifying the event, and *args* may contain optional "
"arguments with more information about the event.  The number and types of"
" arguments for a given event are considered a public and stable API and "
"should not be modified between releases."
msgstr ""
"활성 감사 훅으로 감사 이벤트를 발생시킵니다. *event*\\는 이벤트를 식별하는 문자열이고, *args*\\는 이벤트에 대한 "
"추가 정보를 갖는 선택적 인자를 포함할 수 있습니다. 주어진 이벤트에 대한 인자의 수와 형은 공개된 안정 API로 간주하며 배포 "
"간에 수정되지 않아야 합니다."

#: ../../library/sys.rst:107
msgid ""
"For example, one auditing event is named ``os.chdir``. This event has one"
" argument called *path* that will contain the requested new working "
"directory."
msgstr ""
"예를 들어, 한 감사 이벤트의 이름은 ``os.chdir``\\입니다. 이 이벤트에는 요청된 새 작업 디렉터리를 포함하는 "
"*path*\\라는 인자가 하나 있습니다."

#: ../../library/sys.rst:111
msgid ""
":func:`sys.audit` will call the existing auditing hooks, passing the "
"event name and arguments, and will re-raise the first exception from any "
"hook. In general, if an exception is raised, it should not be handled and"
" the process should be terminated as quickly as possible. This allows "
"hook implementations to decide how to respond to particular events: they "
"can merely log the event or abort the operation by raising an exception."
msgstr ""
":func:`sys.audit`\\는 이벤트 이름과 인자들을 전달하여 기존 감사 훅들을 호출하고, 어떤 훅에서건 발생한 첫 번째 "
"예외를 발생시킵니다. 일반적으로, 예외가 발생하면, 처리되지 않아야 하며 가능한 한 빨리 프로세스를 종료해야 합니다. 이렇게 하면 "
"훅 구현이 특정 이벤트에 반응하는 방법을 결정할 수 있습니다: 단순히 이벤트를 로그 하거나 예외를 발생 시켜 연산을 중단 할 수 "
"있습니다."

#: ../../library/sys.rst:119
msgid ""
"Hooks are added using the :func:`sys.addaudithook` or "
":c:func:`PySys_AddAuditHook` functions."
msgstr ""
"훅은 :func:`sys.addaudithook`\\이나 :c:func:`PySys_AddAuditHook` 함수를 사용하여 "
"추가됩니다."

#: ../../library/sys.rst:122
msgid ""
"The native equivalent of this function is :c:func:`PySys_Audit`. Using "
"the native function is preferred when possible."
msgstr "이 함수의 네이티브 동등 물은 :c:func:`PySys_Audit`\\입니다. 가능하면 네이티브 함수를 사용하는 것이 좋습니다."

#: ../../library/sys.rst:125
msgid ""
"See the :ref:`audit events table <audit-events>` for all events raised by"
" CPython."
msgstr "CPython이 발생시키는 모든 이벤트에 대해서는 :ref:`감사 이벤트 표 <audit-events>`\\를 참조하십시오."

#: ../../library/sys.rst:133
msgid ""
"Set during Python startup, before ``site.py`` is run, to the same value "
"as :data:`exec_prefix`. If not running in a :ref:`virtual environment "
"<venv-def>`, the values will stay the same; if ``site.py`` finds that a "
"virtual environment is in use, the values of :data:`prefix` and "
":data:`exec_prefix` will be changed to point to the virtual environment, "
"whereas :data:`base_prefix` and :data:`base_exec_prefix` will remain "
"pointing to the base Python installation (the one which the virtual "
"environment was created from)."
msgstr ""
"파이썬 시작 중에, ``site.py``\\가 실행되기 전에, :data:`exec_prefix`\\와 같은 값으로 설정됩니다. "
":ref:`가상 환경 <venv-def>`\\에서 실행되지 않으면, 값은 같게 유지됩니다; ``site.py``\\가 가상 환경이 "
"사용 중임을 발견하면, :data:`prefix`\\와 :data:`exec_prefix`\\의 값은 가상 환경을 가리키도록 "
"변경되지만, :data:`base_prefix`\\와 :data:`base_exec_prefix`\\는 기본 파이썬 설치(가상 "
"환경을 만든 것)를 계속 가리킵니다."

#: ../../library/sys.rst:147
msgid ""
"Set during Python startup, before ``site.py`` is run, to the same value "
"as :data:`prefix`. If not running in a :ref:`virtual environment <venv-"
"def>`, the values will stay the same; if ``site.py`` finds that a virtual"
" environment is in use, the values of :data:`prefix` and "
":data:`exec_prefix` will be changed to point to the virtual environment, "
"whereas :data:`base_prefix` and :data:`base_exec_prefix` will remain "
"pointing to the base Python installation (the one which the virtual "
"environment was created from)."
msgstr ""
"파이썬 시작 중에, ``site.py``\\가 실행되기 전에, :data:`prefix`\\와 같은 값으로 설정됩니다. "
":ref:`가상 환경 <venv-def>`\\에서 실행되지 않으면, 값은 같게 유지됩니다; ``site.py``\\가 가상 환경이 "
"사용 중임을 발견하면, :data:`prefix`\\와 :data:`exec_prefix`\\의 값은 가상 환경을 가리키도록 "
"변경되지만, :data:`base_prefix`\\와 :data:`base_exec_prefix`\\는 기본 파이썬 설치(가상 "
"환경을 만든 것)를 계속 가리킵니다."

#: ../../library/sys.rst:160
msgid ""
"An indicator of the native byte order.  This will have the value "
"``'big'`` on big-endian (most-significant byte first) platforms, and "
"``'little'`` on little-endian (least-significant byte first) platforms."
msgstr ""
"네이티브 바이트 순서의 표시기. 이는 빅 엔디안(최상위 바이트 먼저) 플랫폼에서 ``'big'`` 값을, 리틀 엔디안(최하위 바이트"
" 먼저) 플랫폼에서 ``'little'``\\을 갖습니다."

#: ../../library/sys.rst:167
#, fuzzy
msgid ""
"A tuple of strings containing the names of all modules that are compiled "
"into this Python interpreter.  (This information is not available in any "
"other way --- ``modules.keys()`` only lists the imported modules.)"
msgstr ""
"이 파이썬 인터프리터로 컴파일된 모든 모듈의 이름을 제공하는 문자열의 튜플. (이 정보는 다른 방법으로는 얻을 수 없습니다 --- "
"``modules.keys()``\\는 임포트 된 모듈만 나열합니다.)"

#: ../../library/sys.rst:171
msgid "See also the :data:`sys.stdlib_module_names` list."
msgstr ""

#: ../../library/sys.rst:176
#, fuzzy
msgid ""
"Call ``func(*args)``, while tracing is enabled.  The tracing state is "
"saved, and restored afterwards.  This is intended to be called from a "
"debugger from a checkpoint, to recursively debug or profile some other "
"code."
msgstr ""
"추적이 활성화된 동안, ``func(*args)``\\를 호출합니다. 추적 상태가 저장되고, 나중에 복원됩니다. 이것은 체크 "
"포인트에서 디버거에서 호출되어 다른 코드를 재귀적으로 디버깅하기 위한 것입니다."

#: ../../library/sys.rst:180
msgid ""
"Tracing is suspended while calling a tracing function set by "
":func:`settrace` or :func:`setprofile` to avoid infinite recursion. "
":func:`!call_tracing` enables explicit recursion of the tracing function."
msgstr ""

#: ../../library/sys.rst:187
msgid "A string containing the copyright pertaining to the Python interpreter."
msgstr "파이썬 인터프리터와 관련된 저작권이 포함된 문자열."

#: ../../library/sys.rst:192
msgid ""
"Clear the internal type cache. The type cache is used to speed up "
"attribute and method lookups. Use the function *only* to drop unnecessary"
" references during reference leak debugging."
msgstr ""
"내부 형 캐시를 지웁니다. 형 캐시는 어트리뷰트와 메서드 조회 속도를 높이는 데 사용됩니다. 참조 누수 디버깅 중에 불필요한 참조를"
" 제거하기 위해서 *만* 이 함수를 사용하십시오."

#: ../../library/sys.rst:196 ../../library/sys.rst:223
#: ../../library/sys.rst:236
msgid "This function should be used for internal and specialized purposes only."
msgstr "이 함수는 내부와 특수 목적으로만 사용해야 합니다."

#: ../../library/sys.rst:198
msgid "Use the more general :func:`_clear_internal_caches` function instead."
msgstr ""

#: ../../library/sys.rst:204
msgid ""
"Clear all internal performance-related caches. Use this function *only* "
"to release unnecessary references and memory blocks when hunting for "
"leaks."
msgstr ""

#: ../../library/sys.rst:212
msgid ""
"Return a dictionary mapping each thread's identifier to the topmost stack"
" frame currently active in that thread at the time the function is "
"called. Note that functions in the :mod:`traceback` module can build the "
"call stack given such a frame."
msgstr ""
"함수가 호출될 때 각 스레드의 식별자를 해당 스레드에서 현재 활성화된 최상위 스택 프레임에 매핑하는 딕셔너리를 반환합니다. "
":mod:`traceback` 모듈의 함수는 이러한 프레임을 주면 호출 스택을 빌드할 수 있음에 유의하십시오."

#: ../../library/sys.rst:217
msgid ""
"This is most useful for debugging deadlock:  this function does not "
"require the deadlocked threads' cooperation, and such threads' call "
"stacks are frozen for as long as they remain deadlocked.  The frame "
"returned for a non-deadlocked thread may bear no relationship to that "
"thread's current activity by the time calling code examines the frame."
msgstr ""
"이것은 교착 상태 디버깅에 가장 유용합니다: 이 함수는 교착 상태에 빠진 스레드의 협력을 필요로하지 않으며, 이러한 스레드의 호출 "
"스택은 교착 상태를 유지하는 한 고정됩니다. 교착 상태가 아닌 스레드에 대해 반환된 프레임은 호출하는 코드가 프레임을 검사할 때까지"
" 해당 스레드의 현재 활동과 관련이 없을 수 있습니다."

#: ../../library/sys.rst:225
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._current_frames`` with "
"no arguments."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys._current_frames``\\를 발생시킵니다."

#: ../../library/sys.rst:229
#, fuzzy
msgid ""
"Return a dictionary mapping each thread's identifier to the topmost "
"exception currently active in that thread at the time the function is "
"called. If a thread is not currently handling an exception, it is not "
"included in the result dictionary."
msgstr ""
"함수가 호출될 때 각 스레드의 식별자를 해당 스레드에서 현재 활성화된 최상위 스택 프레임에 매핑하는 딕셔너리를 반환합니다. "
":mod:`traceback` 모듈의 함수는 이러한 프레임을 주면 호출 스택을 빌드할 수 있음에 유의하십시오."

#: ../../library/sys.rst:234
msgid "This is most useful for statistical profiling."
msgstr ""

#: ../../library/sys.rst:238
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._current_exceptions`` "
"with no arguments."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys._current_frames``\\를 발생시킵니다."

#: ../../library/sys.rst:240
msgid ""
"Each value in the dictionary is now a single exception instance, rather "
"than a 3-tuple as returned from ``sys.exc_info()``."
msgstr ""

#: ../../library/sys.rst:246
msgid ""
"This hook function is called by built-in :func:`breakpoint`.  By default,"
" it drops you into the :mod:`pdb` debugger, but it can be set to any "
"other function so that you can choose which debugger gets used."
msgstr ""
"이 훅 함수는 내장 :func:`breakpoint`\\에 의해 호출됩니다. 기본적으로, :mod:`pdb` 디버거로 떨어뜨리지만,"
" 다른 함수로 설정하여 사용할 디버거를 선택할 수 있습니다."

#: ../../library/sys.rst:250
msgid ""
"The signature of this function is dependent on what it calls.  For "
"example, the default binding (e.g. ``pdb.set_trace()``) expects no "
"arguments, but you might bind it to a function that expects additional "
"arguments (positional and/or keyword).  The built-in ``breakpoint()`` "
"function passes its ``*args`` and ``**kws`` straight through.  Whatever "
"``breakpointhooks()`` returns is returned from ``breakpoint()``."
msgstr ""
"이 함수의 서명은 그것이 호출하는 것에 의존합니다. 예를 들어, 기본 바인딩(예를 들어 ``pdb.set_trace()``)에는 "
"인자가 필요하지 않지만, 추가 인자(위치 및/또는 키워드)를 기대하는 함수에 바인딩할 수 있습니다. 내장 "
"``breakpoint()`` 함수는 ``*args``\\와 ``**kws``\\를 그대로 전달합니다. "
"``breakpointhooks()``\\가 반환하는 것이 ``breakpoint()``\\에서 반환됩니다."

#: ../../library/sys.rst:257
msgid ""
"The default implementation first consults the environment variable "
":envvar:`PYTHONBREAKPOINT`.  If that is set to ``\"0\"`` then this "
"function returns immediately; i.e. it is a no-op.  If the environment "
"variable is not set, or is set to the empty string, ``pdb.set_trace()`` "
"is called. Otherwise this variable should name a function to run, using "
"Python's dotted-import nomenclature, e.g. "
"``package.subpackage.module.function``. In this case, "
"``package.subpackage.module`` would be imported and the resulting module "
"must have a callable named ``function()``.  This is run, passing in "
"``*args`` and ``**kws``, and whatever ``function()`` returns, "
"``sys.breakpointhook()`` returns to the built-in :func:`breakpoint` "
"function."
msgstr ""
"기본 구현은 먼저 환경 변수 :envvar:`PYTHONBREAKPOINT`\\를 참조합니다. 이것이 ``\"0\"``\\으로 "
"설정되면, 이 함수는 즉시 반환합니다; 즉, 아무런 일도 하지 않습니다. 환경 변수가 설정되지 않거나 빈 문자열로 설정되면, "
"``pdb.set_trace()``\\가 호출됩니다. 그렇지 않으면 이 변수는 파이썬의 점으로 표현한 임포트 표기법(예를 들어 "
"``package.subpackage.module.function``)을 사용하여 실행할 함수의 이름을 지정해야 합니다. 이 경우,"
" ``package.subpackage.module``\\이 임포트 되고 결과 모듈에는 ``function()``\\이라는 이름의 "
"콜러블이 있어야 합니다. 이것이 ``*args`` 및 ``**kws``\\를 전달하여 실행되며, ``function()``\\이 "
"반환하는 것을 ``sys.breakpointhook()``\\이 내장 :func:`breakpoint` 함수로 반환합니다."

#: ../../library/sys.rst:269
msgid ""
"Note that if anything goes wrong while importing the callable named by "
":envvar:`PYTHONBREAKPOINT`, a :exc:`RuntimeWarning` is reported and the "
"breakpoint is ignored."
msgstr ""
":envvar:`PYTHONBREAKPOINT`\\로 이름이 지정된 콜러블을 임포트 하는 도중에 문제가 발생하면, "
":exc:`RuntimeWarning`\\이 보고되고 중단점은 무시됨에 유의하십시오."

#: ../../library/sys.rst:273
msgid ""
"Also note that if ``sys.breakpointhook()`` is overridden "
"programmatically, :envvar:`PYTHONBREAKPOINT` is *not* consulted."
msgstr ""
"또한 ``sys.breakpointhook()``\\이 프로그래밍 방식으로 재정의되면, "
":envvar:`PYTHONBREAKPOINT`\\는 참조되지 *않음*\\에 유의하십시오."

#: ../../library/sys.rst:280
msgid ""
"Print low-level information to stderr about the state of CPython's memory"
" allocator."
msgstr "CPython의 메모리 할당자 상태에 대한 저수준 정보를 stderr에 인쇄합니다."

#: ../../library/sys.rst:283
#, fuzzy
msgid ""
"If Python is :ref:`built in debug mode <debug-build>` (:option:`configure"
" --with-pydebug option <--with-pydebug>`), it also performs some "
"expensive internal consistency checks."
msgstr "파이썬이 --with-pydebug 으로 구성되었으면, 값비싼 내부 일관성 검사도 수행합니다."

#: ../../library/sys.rst:291
msgid ""
"This function is specific to CPython.  The exact output format is not "
"defined here, and may change."
msgstr "이 함수는 CPython 전용입니다. 정확한 출력 형식은 여기에 정의되어 있지 않으며, 변경될 수 있습니다."

#: ../../library/sys.rst:297
msgid "Integer specifying the handle of the Python DLL."
msgstr "파이썬 DLL의 핸들을 지정하는 정수."

#: ../../library/sys.rst:304
msgid ""
"If *value* is not ``None``, this function prints ``repr(value)`` to "
"``sys.stdout``, and saves *value* in ``builtins._``. If ``repr(value)`` "
"is not encodable to ``sys.stdout.encoding`` with ``sys.stdout.errors`` "
"error handler (which is probably ``'strict'``), encode it to "
"``sys.stdout.encoding`` with ``'backslashreplace'`` error handler."
msgstr ""
"*value*\\가 ``None``\\이 아니면, 이 함수는 ``repr(value)``\\를 ``sys.stdout``\\으로 "
"인쇄하고, *value*\\를 ``builtins._``\\에 저장합니다. ``repr(value)``\\를 "
"``sys.stdout.errors`` 에러 처리기(아마도 ``'strict'``)로 "
"``sys.stdout.encoding``\\으로 인코딩할 수 없으면, ``'backslashreplace'`` 에러 처리기를 "
"사용하여 ``sys.stdout.encoding``\\으로 인코딩합니다."

#: ../../library/sys.rst:310
msgid ""
"``sys.displayhook`` is called on the result of evaluating an "
":term:`expression` entered in an interactive Python session.  The display"
" of these values can be customized by assigning another one-argument "
"function to ``sys.displayhook``."
msgstr ""
"``sys.displayhook``\\은 대화형 파이썬 세션에서 입력한 :term:`표현식 <expression>`\\을 평가한 "
"결과에 대해 호출됩니다. ``sys.displayhook``\\에 다른 1-인자 함수를 대입하여 이러한 값의 표시를 사용자 정의할 "
"수 있습니다."

#: ../../library/sys.rst:314
msgid "Pseudo-code::"
msgstr "의사 코드::"

#: ../../library/sys.rst:316
msgid ""
"def displayhook(value):\n"
"    if value is None:\n"
"        return\n"
"    # Set '_' to None to avoid recursion\n"
"    builtins._ = None\n"
"    text = repr(value)\n"
"    try:\n"
"        sys.stdout.write(text)\n"
"    except UnicodeEncodeError:\n"
"        bytes = text.encode(sys.stdout.encoding, 'backslashreplace')\n"
"        if hasattr(sys.stdout, 'buffer'):\n"
"            sys.stdout.buffer.write(bytes)\n"
"        else:\n"
"            text = bytes.decode(sys.stdout.encoding, 'strict')\n"
"            sys.stdout.write(text)\n"
"    sys.stdout.write(\"\\n\")\n"
"    builtins._ = value"
msgstr ""

#: ../../library/sys.rst:334
msgid "Use ``'backslashreplace'`` error handler on :exc:`UnicodeEncodeError`."
msgstr ":exc:`UnicodeEncodeError` 에 ``'backslashreplace'`` 에러 처리기를 사용합니다."

#: ../../library/sys.rst:340
msgid ""
"If this is true, Python won't try to write ``.pyc`` files on the import "
"of source modules.  This value is initially set to ``True`` or ``False`` "
"depending on the :option:`-B` command line option and the "
":envvar:`PYTHONDONTWRITEBYTECODE` environment variable, but you can set "
"it yourself to control bytecode file generation."
msgstr ""
"이것이 참이면, 파이썬은 소스 모듈을 임포트 할 때 ``.pyc`` 파일을 쓰려고 하지 않습니다. 이 값은 :option:`-B` "
"명령 줄 옵션과 :envvar:`PYTHONDONTWRITEBYTECODE` 환경 변수에 따라 초기에 ``True``\\나 "
"``False``\\로 설정되지만, 바이트 코드 파일 생성을 제어하기 위해 직접 설정할 수 있습니다."

#: ../../library/sys.rst:349
msgid ""
"A :term:`named tuple` holding information about the environment on the "
"*wasm32-emscripten* platform. The named tuple is provisional and may "
"change in the future."
msgstr ""

#: ../../library/sys.rst:355
msgid ""
"Emscripten version as tuple of ints (major, minor, micro), e.g. ``(3, 1, "
"8)``."
msgstr ""

#: ../../library/sys.rst:359
msgid ""
"Runtime string, e.g. browser user agent, ``'Node.js v14.18.2'``, or "
"``'UNKNOWN'``."
msgstr ""

#: ../../library/sys.rst:363
msgid "``True`` if Python is compiled with Emscripten pthreads support."
msgstr ""

#: ../../library/sys.rst:367
msgid "``True`` if Python is compiled with shared memory support."
msgstr ""

#: ../../library/sys.rst:376
#, fuzzy
msgid ""
"If this is set (not ``None``), Python will write bytecode-cache ``.pyc`` "
"files to (and read them from) a parallel directory tree rooted at this "
"directory, rather than from ``__pycache__`` directories in the source "
"code tree. Any ``__pycache__`` directories in the source code tree will "
"be ignored and new ``.pyc`` files written within the pycache prefix. Thus"
" if you use :mod:`compileall` as a pre-build step, you must ensure you "
"run it with the same pycache prefix (if any) that you will use at "
"runtime."
msgstr ""
"이것이 설정되면 (``None``\\이 아니면), 파이썬은 바이트 코드 캐시 ``.pyc`` 파일을 소스 코드 트리의 "
"``__pycache__`` 디렉터리가 아니라, 이 디렉터리를 루트로 하는 병렬 디렉터리 트리에 씁니다 (그리고 그곳에서 "
"읽습니다). 소스 코드 트리의 모든 ``__pycache__`` 디렉터리는 무시되고 새 `.pyc` 파일이 이 디렉터리 내에 "
"기록됩니다. 따라서 :mod:`compileall`\\을 사전 빌드 단계로 사용한다면, 실행 시간에 사용할 같은 pycache "
"접두어(있다면)로 실행해야 합니다."

#: ../../library/sys.rst:384
msgid "A relative path is interpreted relative to the current working directory."
msgstr "상대 경로는 현재 작업 디렉터리를 기준으로 해석됩니다."

#: ../../library/sys.rst:386
msgid ""
"This value is initially set based on the value of the :option:`-X` "
"``pycache_prefix=PATH`` command-line option or the "
":envvar:`PYTHONPYCACHEPREFIX` environment variable (command-line takes "
"precedence). If neither are set, it is ``None``."
msgstr ""
"이 값은 초기에 :option:`-X` ``pycache_prefix=PATH`` 명령 줄 옵션이나 "
":envvar:`PYTHONPYCACHEPREFIX` 환경 변수(명령 줄이 우선합니다)의 값을 기반으로 설정됩니다. 둘 다 설정되지"
" 않으면, ``None``\\입니다."

#: ../../library/sys.rst:396
msgid ""
"This function prints out a given traceback and exception to "
"``sys.stderr``."
msgstr "이 함수는 주어진 트레이스백(traceback)과 예외를 ``sys.stderr``\\에 인쇄합니다."

#: ../../library/sys.rst:398
#, fuzzy
msgid ""
"When an exception other than :exc:`SystemExit` is raised and uncaught, "
"the interpreter calls ``sys.excepthook`` with three arguments, the "
"exception class, exception instance, and a traceback object.  In an "
"interactive session this happens just before control is returned to the "
"prompt; in a Python program this happens just before the program exits.  "
"The handling of such top-level exceptions can be customized by assigning "
"another three-argument function to ``sys.excepthook``."
msgstr ""
"예외가 발생하고 잡히지 않을 때, 인터프리터는 세 인자, 예외 클래스, 예외 인스턴스 및 트레이스백 객체로 "
"``sys.excepthook``\\을 호출합니다. 대화식 세션에서는 제어가 프롬프트로 반환되기 직전에 일어납니다; 파이썬 "
"프로그램에서는 프로그램이 종료되기 직전에 일어납니다. 이러한 최상위 예외 처리는 ``sys.excepthook``\\에 다른 "
"3-인자 함수를 대입하여 사용자 정의할 수 있습니다."

#: ../../library/sys.rst:405 ../../library/sys.rst:407
msgid ""
"Raise an auditing event ``sys.excepthook`` with arguments ``hook``, "
"``type``, ``value``, ``traceback`` when an uncaught exception occurs. If "
"no hook has been set, ``hook`` may be ``None``. If any hook raises an "
"exception derived from :class:`RuntimeError` the call to the hook will be"
" suppressed. Otherwise, the audit hook exception will be reported as "
"unraisable and ``sys.excepthook`` will be called."
msgstr ""
"잡히지 않은 예외가 발생할 때 인자 ``hook``, ``type``, ``value``, ``traceback``\\로 감사 "
"이벤트 ``sys.excepthook``\\을 발생시킵니다. 아무런 훅도 설정되지 않았으면, ``hook``\\은 ``None`` "
"일 수 있습니다. 훅이 :class:`RuntimeError`\\에서 파생된 예외를 발생시키면 훅 호출이 억제됩니다. 그렇지 "
"않으면, 감사 훅 예외는 발생시킬 수 없는 것(unraisable)으로 보고되고 ``sys.excepthook``\\이 호출됩니다."

#: ../../library/sys.rst:416
msgid ""
"The :func:`sys.unraisablehook` function handles unraisable exceptions and"
" the :func:`threading.excepthook` function handles exception raised by "
":func:`threading.Thread.run`."
msgstr ""
":func:`sys.unraisablehook` 함수는 발생시킬 수 없는 예외(unraisable exception)를 다루고 "
":func:`threading.excepthook` 함수는 :func:`threading.Thread.run`\\이 발생시킨 예외를"
" 다룹니다."

#: ../../library/sys.rst:426
msgid ""
"These objects contain the original values of ``breakpointhook``, "
"``displayhook``, ``excepthook``, and ``unraisablehook`` at the start of "
"the program.  They are saved so that ``breakpointhook``, ``displayhook`` "
"and ``excepthook``, ``unraisablehook`` can be restored in case they "
"happen to get replaced with broken or alternative objects."
msgstr ""
"이러한 객체는 프로그램 시작 시 ``breakpointhook``, ``displayhook``, ``excepthook`` 및 "
"``unraisablehook`` 의 원래 값을 포함합니다. ``breakpointhook``, ``displayhook`` 및 "
"``excepthook``, ``unraisablehook`` 이 파손되거나 대체 객체로 교체될 때 복원 할 수 있도록 저장됩니다."

#: ../../library/sys.rst:432
msgid "__breakpointhook__"
msgstr "__breakpointhook__"

#: ../../library/sys.rst:435
msgid "__unraisablehook__"
msgstr "__unraisablehook__"

#: ../../library/sys.rst:441
msgid ""
"This function, when called while an exception handler is executing (such "
"as an ``except`` or ``except*`` clause), returns the exception instance "
"that was caught by this handler. When exception handlers are nested "
"within one another, only the exception handled by the innermost handler "
"is accessible."
msgstr ""

#: ../../library/sys.rst:446
msgid "If no exception handler is executing, this function returns ``None``."
msgstr ""

#: ../../library/sys.rst:453
msgid ""
"This function returns the old-style representation of the handled "
"exception. If an exception ``e`` is currently handled (so "
":func:`exception` would return ``e``), :func:`exc_info` returns the tuple"
" ``(type(e), e, e.__traceback__)``. That is, a tuple containing the type "
"of the exception (a subclass of :exc:`BaseException`), the exception "
"itself, and a :ref:`traceback object <traceback-objects>` which typically"
" encapsulates the call stack at the point where the exception last "
"occurred."
msgstr ""

#: ../../library/sys.rst:464
msgid ""
"If no exception is being handled anywhere on the stack, this function "
"return a tuple containing three ``None`` values."
msgstr ""

#: ../../library/sys.rst:467
msgid ""
"The ``type`` and ``traceback`` fields are now derived from the ``value`` "
"(the exception instance), so when an exception is modified while it is "
"being handled, the changes are reflected in the results of subsequent "
"calls to :func:`exc_info`."
msgstr ""

#: ../../library/sys.rst:475
#, python-brace-format
msgid ""
"A string giving the site-specific directory prefix where the platform-"
"dependent Python files are installed; by default, this is also "
"``'/usr/local'``.  This can be set at build time with the ``--exec-"
"prefix`` argument to the :program:`configure` script.  Specifically, all "
"configuration files (e.g. the :file:`pyconfig.h` header file) are "
"installed in the directory :file:`{exec_prefix}/lib/python{X.Y}/config`, "
"and shared library modules are installed in "
":file:`{exec_prefix}/lib/python{X.Y}/lib-dynload`, where *X.Y* is the "
"version number of Python, for example ``3.2``."
msgstr ""
"플랫폼 특정 파이썬 파일이 설치되는 사이트 특정 디렉터리 접두사를 제공하는 문자열; 기본적으로, 이것은 "
"``'/usr/local'``\\이기도 합니다. :program:`configure` 스크립트에 ``--exec-prefix`` "
"인자를 사용하여 빌드 시 설정할 수 있습니다. 구체적으로, 모든 구성 파일(예를 들어 :file:`pyconfig.h` 헤더 "
"파일)은 디렉터리 :file:`{exec_prefix}/lib/python{X.Y}/config`\\에 설치되고, 공유 라이브러리 "
"모듈은 :file:`{exec_prefix}/lib/python{X.Y}/lib-dynload`\\에 설치됩니다. 여기서 "
"*X.Y*\\는 파이썬의 버전 번호입니다, 예를 들어 ``3.2``."

#: ../../library/sys.rst:486
msgid ""
"If a :ref:`virtual environment <venv-def>` is in effect, this value will "
"be changed in ``site.py`` to point to the virtual environment. The value "
"for the Python installation will still be available, via "
":data:`base_exec_prefix`."
msgstr ""
":ref:`가상 환경 <venv-def>`\\이 유효하면, 이 값은 ``site.py``\\에서 가상 환경을 가리키도록 변경됩니다."
" 파이썬 설치 값은 :data:`base_exec_prefix`\\를 통해 계속 제공됩니다."

#: ../../library/sys.rst:494
msgid ""
"A string giving the absolute path of the executable binary for the Python"
" interpreter, on systems where this makes sense. If Python is unable to "
"retrieve the real path to its executable, :data:`sys.executable` will be "
"an empty string or ``None``."
msgstr ""
"의미가 있는 시스템에서, 파이썬 인터프리터를 위한 실행 바이너리의 절대 경로를 제공하는 문자열. 파이썬이 실행 파일의 실제 경로를 "
"검색할 수 없으면, :data:`sys.executable`\\은 빈 문자열이거나 ``None``\\입니다."

#: ../../library/sys.rst:502
msgid ""
"Raise a :exc:`SystemExit` exception, signaling an intention to exit the "
"interpreter."
msgstr ""

#: ../../library/sys.rst:504
msgid ""
"The optional argument *arg* can be an integer giving the exit status "
"(defaulting to zero), or another type of object.  If it is an integer, "
"zero is considered \"successful termination\" and any nonzero value is "
"considered \"abnormal termination\" by shells and the like.  Most systems"
" require it to be in the range 0--127, and produce undefined results "
"otherwise.  Some systems have a convention for assigning specific "
"meanings to specific exit codes, but these are generally underdeveloped; "
"Unix programs generally use 2 for command line syntax errors and 1 for "
"all other kind of errors.  If another type of object is passed, ``None`` "
"is equivalent to passing zero, and any other object is printed to "
":data:`stderr` and results in an exit code of 1.  In particular, "
"``sys.exit(\"some error message\")`` is a quick way to exit a program "
"when an error occurs."
msgstr ""
"선택적 인자 *arg*\\는 종료 상태(기본값은 0)를 나타내는 정수나 다른 형의 객체일 수 있습니다. 정수면, 0은 \"성공적인 "
"종료\"로 간주하고, 0이 아닌 값은 셸 등이 \"비정상 종료\"로 간주합니다. 대부분 시스템은 0--127 범위를 요구하고, "
"그렇지 않으면 정의되지 않은 결과를 생성합니다. 일부 시스템에는 특정 종료 코드에 특정 의미를 지정하는 규칙이 있지만, 일반적으로 "
"잘 개발되지 않은 상태입니다; 유닉스 프로그램은 일반적으로 명령 줄 구문 에러에 2를, 다른 모든 종류의 에러에 1을 사용합니다. "
"다른 형의 객체가 전달되면, ``None``\\은 0을 전달하는 것과 동등하며, 다른 모든 객체는 :data:`stderr`\\로 "
"인쇄되고 종료 코드 1을 만듭니다. 특히, ``sys.exit(\"some error message\")``\\는 에러가 발생할 때"
" 프로그램을 종료하는 빠른 방법입니다."

#: ../../library/sys.rst:517
#, fuzzy
msgid ""
"Since :func:`exit` ultimately \"only\" raises an exception, it will only "
"exit the process when called from the main thread, and the exception is "
"not intercepted. Cleanup actions specified by finally clauses of "
":keyword:`try` statements are honored, and it is possible to intercept "
"the exit attempt at an outer level."
msgstr ""
":func:`exit`\\는 궁극적으로 \"단지\" 예외를 발생시키기만 하므로, 메인 스레드에서 호출되고 예외를 가로채지 않을 때만"
" 프로세스를 종료합니다."

#: ../../library/sys.rst:522
msgid ""
"If an error occurs in the cleanup after the Python interpreter has caught"
" :exc:`SystemExit` (such as an error flushing buffered data in the "
"standard streams), the exit status is changed to 120."
msgstr ""
"파이썬 인터프리터가 :exc:`SystemExit`\\를 잡은 후 정리할 때 에러가 발생하면 (가령 표준 스트림에 버퍼링 된 "
"데이터를 플러시할 때의 에러), 종료 상태가 120으로 변경됩니다."

#: ../../library/sys.rst:530
msgid ""
"The :term:`named tuple` *flags* exposes the status of command line flags."
" The attributes are read only."
msgstr ""
":term:`네임드 튜플 <named tuple>` *flags*\\는 명령 줄 플래그의 상태를 노출합니다. 어트리뷰트는 읽기 "
"전용입니다."

#: ../../library/sys.rst:536
msgid ":option:`-d`"
msgstr ":option:`-d`"

#: ../../library/sys.rst:539 ../../library/sys.rst:542
msgid ":option:`-i`"
msgstr ":option:`-i`"

#: ../../library/sys.rst:545
msgid ":option:`-I`"
msgstr ":option:`-I`"

#: ../../library/sys.rst:548
msgid ":option:`-O` or :option:`-OO`"
msgstr ":option:`-O` 또는 :option:`-OO`"

#: ../../library/sys.rst:551
msgid ":option:`-B`"
msgstr ":option:`-B`"

#: ../../library/sys.rst:554
msgid ":option:`-s`"
msgstr ":option:`-s`"

#: ../../library/sys.rst:557
msgid ":option:`-S`"
msgstr ":option:`-S`"

#: ../../library/sys.rst:560
msgid ":option:`-E`"
msgstr ":option:`-E`"

#: ../../library/sys.rst:563
msgid ":option:`-v`"
msgstr ":option:`-v`"

#: ../../library/sys.rst:566
msgid ":option:`-b`"
msgstr ":option:`-b`"

#: ../../library/sys.rst:569
msgid ":option:`-q`"
msgstr ":option:`-q`"

#: ../../library/sys.rst:572
msgid ":option:`-R`"
msgstr ":option:`-R`"

#: ../../library/sys.rst:575
msgid ":option:`-X dev <-X>` (:ref:`Python Development Mode <devmode>`)"
msgstr ":option:`-X dev <-X>` (:ref:`파이썬 개발 모드 <devmode>`)"

#: ../../library/sys.rst:578
msgid ":option:`-X utf8 <-X>`"
msgstr ":option:`-X utf8 <-X>`"

#: ../../library/sys.rst:581
#, fuzzy
msgid ":option:`-P`"
msgstr ":option:`-v`"

#: ../../library/sys.rst:584
msgid ""
":option:`-X int_max_str_digits <-X>` (:ref:`integer string conversion "
"length limitation <int_max_str_digits>`)"
msgstr ""

#: ../../library/sys.rst:588
#, fuzzy
msgid ":option:`-X warn_default_encoding <-X>`"
msgstr ":option:`-X utf8 <-X>`"

#: ../../library/sys.rst:590
msgid "Added ``quiet`` attribute for the new :option:`-q` flag."
msgstr "새로운 :option:`-q` 플래그에 대한 ``quiet`` 어트리뷰트가 추가되었습니다."

#: ../../library/sys.rst:593
msgid "The ``hash_randomization`` attribute."
msgstr "``hash_randomization`` 어트리뷰트."

#: ../../library/sys.rst:596
msgid "Removed obsolete ``division_warning`` attribute."
msgstr "사용되지 않는 ``division_warning`` 어트리뷰트를 제거했습니다."

#: ../../library/sys.rst:599
msgid "Added ``isolated`` attribute for :option:`-I` ``isolated`` flag."
msgstr ":option:`-I` ``isolated`` 플래그에 대한 ``isolated`` 어트리뷰트가 추가되었습니다."

#: ../../library/sys.rst:602
msgid ""
"Added the ``dev_mode`` attribute for the new :ref:`Python Development "
"Mode <devmode>` and the ``utf8_mode`` attribute for the new  :option:`-X`"
" ``utf8`` flag."
msgstr ""
"새로운 :ref:`파이썬 개발자 모드 <devmode>`\\에 대한 ``dev_mode`` 어트리뷰트와 새로운 "
":option:`-X` ``utf8`` 플래그에 대한 ``utf8_mode`` 어트리뷰트가 추가되었습니다."

#: ../../library/sys.rst:607
#, fuzzy
msgid ""
"Added ``warn_default_encoding`` attribute for :option:`-X` "
"``warn_default_encoding`` flag."
msgstr ":option:`-I` ``isolated`` 플래그에 대한 ``isolated`` 어트리뷰트가 추가되었습니다."

#: ../../library/sys.rst:610
#, fuzzy
msgid "Added the ``safe_path`` attribute for :option:`-P` option."
msgstr ":option:`-I` ``isolated`` 플래그에 대한 ``isolated`` 어트리뷰트가 추가되었습니다."

#: ../../library/sys.rst:613
#, fuzzy
msgid "Added the ``int_max_str_digits`` attribute."
msgstr "``hash_randomization`` 어트리뷰트."

#: ../../library/sys.rst:619
msgid ""
"A :term:`named tuple` holding information about the float type. It "
"contains low level information about the precision and internal "
"representation.  The values correspond to the various floating-point "
"constants defined in the standard header file :file:`float.h` for the 'C'"
" programming language; see section 5.2.4.2.2 of the 1999 ISO/IEC C "
"standard [C99]_, 'Characteristics of floating types', for details."
msgstr ""
"float 형에 대한 정보를 담은 :term:`네임드 튜플 <named tuple>`. 정밀도와 내부 표현에 대한 저수준 정보를 "
"포함합니다. 값은 'C' 프로그래밍 언어의 표준 헤더 파일 :file:`float.h`\\에 정의된 다양한 부동 소수점 상수에 "
"해당합니다; 자세한 내용은 1999 ISO/IEC C 표준 [C99]_ 의 섹션 5.2.4.2.2 'Characteristics "
"of floating types'를 참조하십시오."

#: ../../library/sys.rst:626
msgid "Attributes of the :data:`!float_info` :term:`named tuple`"
msgstr ""

#: ../../library/sys.rst:629
msgid "attribute"
msgstr "어트리뷰트"

#: ../../library/sys.rst:630
msgid "float.h macro"
msgstr "float.h 매크로"

#: ../../library/sys.rst:631
msgid "explanation"
msgstr "설명"

#: ../../library/sys.rst:634
#, fuzzy
msgid ":c:macro:`!DBL_EPSILON`"
msgstr ":const:`epsilon`"

#: ../../library/sys.rst:635
#, fuzzy
msgid ""
"difference between 1.0 and the least value greater than 1.0 that is "
"representable as a float."
msgstr "1.0과 부동 소수점으로 표현할 수 있는 1.0보다 큰 최솟값의 차이"

#: ../../library/sys.rst:638
msgid "See also :func:`math.ulp`."
msgstr ":func:`math.ulp`\\도 참조하십시오."

#: ../../library/sys.rst:641
msgid ":c:macro:`!DBL_DIG`"
msgstr ""

#: ../../library/sys.rst:642
#, fuzzy
msgid ""
"The maximum number of decimal digits that can be faithfully represented "
"in a float; see below."
msgstr "부동 소수점으로 충실하게 표현할 수 있는 최대 십진 숫자의 개수; 아래를 참조하십시오"

#: ../../library/sys.rst:646
#, fuzzy
msgid ":c:macro:`!DBL_MANT_DIG`"
msgstr ":const:`mant_dig`"

#: ../../library/sys.rst:647
#, fuzzy
msgid ""
"Float precision: the number of base-``radix`` digits in the significand "
"of a float."
msgstr "float 정밀도: float의 유효 숫자에서 기본-``radix`` 자릿수"

#: ../../library/sys.rst:651
msgid ":c:macro:`!DBL_MAX`"
msgstr ""

#: ../../library/sys.rst:652
#, fuzzy
msgid "The maximum representable positive finite float."
msgstr "최대 표현 가능한 양의 유한 float"

#: ../../library/sys.rst:655
#, fuzzy
msgid ":c:macro:`!DBL_MAX_EXP`"
msgstr ":const:`max_exp`"

#: ../../library/sys.rst:656
#, fuzzy
msgid ""
"The maximum integer *e* such that ``radix**(e-1)`` is a representable "
"finite float."
msgstr "``radix**(e-1)`` 이 표현 가능한 유한 float가 되도록 하는 최대 정수 *e*"

#: ../../library/sys.rst:660
#, fuzzy
msgid ":c:macro:`!DBL_MAX_10_EXP`"
msgstr ":const:`max_10_exp`"

#: ../../library/sys.rst:661
#, fuzzy
msgid ""
"The maximum integer *e* such that ``10**e`` is in the range of "
"representable finite floats."
msgstr "``10**e``\\가 표현 가능한 유한 float의 범위에 있도록 하는 최대 정수 *e*"

#: ../../library/sys.rst:665
msgid ":c:macro:`!DBL_MIN`"
msgstr ""

#: ../../library/sys.rst:666
#, fuzzy
msgid "The minimum representable positive *normalized* float."
msgstr "최소 표현 가능한 양의(positive) *정규화된* float"

#: ../../library/sys.rst:668
msgid ""
"Use :func:`math.ulp(0.0) <math.ulp>` to get the smallest positive "
"*denormalized* representable float."
msgstr ""
":func:`math.ulp(0.0) <math.ulp>`\\를 사용하여 가장 작은 양의 *정규화되지 "
"않은(denormalized)* 표현 가능한 float를 얻습니다."

#: ../../library/sys.rst:672
#, fuzzy
msgid ":c:macro:`!DBL_MIN_EXP`"
msgstr ":const:`min_exp`"

#: ../../library/sys.rst:673
#, fuzzy
msgid "The minimum integer *e* such that ``radix**(e-1)`` is a normalized float."
msgstr "``radix**(e-1)`` 이 정규화된 float가 되도록 하는 최소 정수 *e*"

#: ../../library/sys.rst:677
#, fuzzy
msgid ":c:macro:`!DBL_MIN_10_EXP`"
msgstr ":const:`min_10_exp`"

#: ../../library/sys.rst:678
#, fuzzy
msgid "The minimum integer *e* such that ``10**e`` is a normalized float."
msgstr "``10**e``\\가 정규화된 float가 되도록 하는 최소 정수 *e*"

#: ../../library/sys.rst:681
#, fuzzy
msgid ":c:macro:`!FLT_RADIX`"
msgstr ":const:`radix`"

#: ../../library/sys.rst:682
#, fuzzy
msgid "The radix of exponent representation."
msgstr "지수 표현의 기수"

#: ../../library/sys.rst:685
#, fuzzy
msgid ":c:macro:`!FLT_ROUNDS`"
msgstr ":const:`rounds`"

#: ../../library/sys.rst:686
#, fuzzy
msgid ""
"An integer representing the rounding mode for floating-point arithmetic. "
"This reflects the value of the system :c:macro:`!FLT_ROUNDS` macro at "
"interpreter startup time:"
msgstr ""
"산술 연산에 사용되는 자리 올림 모드를 나타내는 정수 상수. 이는 인터프리터 시작 시 시스템 FLT_ROUNDS 매크로의 값을 "
"반영합니다. 가능한 값과 그 의미에 대한 설명은 C99 표준의 섹션 5.2.4.2.2를 참조하십시오."

#: ../../library/sys.rst:690
msgid "``-1``: indeterminable"
msgstr ""

#: ../../library/sys.rst:691
msgid "``0``: toward zero"
msgstr ""

#: ../../library/sys.rst:692
msgid "``1``: to nearest"
msgstr ""

#: ../../library/sys.rst:693
msgid "``2``: toward positive infinity"
msgstr ""

#: ../../library/sys.rst:694
msgid "``3``: toward negative infinity"
msgstr ""

#: ../../library/sys.rst:696
msgid ""
"All other values for :c:macro:`!FLT_ROUNDS` characterize implementation-"
"defined rounding behavior."
msgstr ""

#: ../../library/sys.rst:699
#, fuzzy
msgid ""
"The attribute :attr:`sys.float_info.dig` needs further explanation.  If "
"``s`` is any string representing a decimal number with at most "
":attr:`!sys.float_info.dig` significant digits, then converting ``s`` to "
"a float and back again will recover a string representing the same "
"decimal value::"
msgstr ""
":attr:`sys.float_info.dig` 어트리뷰트는 추가 설명이 필요합니다. ``s``\\가 최대 "
":attr:`sys.float_info.dig` 유효 숫자를 가진 십진수를 나타내는 문자열이면, ``s``\\를 float로 변환한"
" 후 다시 역변환하면 같은 십진수 값을 나타내는 문자열이 복구됩니다::"

#: ../../library/sys.rst:705
msgid ""
">>> import sys\n"
">>> sys.float_info.dig\n"
"15\n"
">>> s = '3.14159265358979'    # decimal string with 15 significant digits"
"\n"
">>> format(float(s), '.15g')  # convert to float and back -> same value\n"
"'3.14159265358979'"
msgstr ""

#: ../../library/sys.rst:712
msgid ""
"But for strings with more than :attr:`sys.float_info.dig` significant "
"digits, this isn't always true::"
msgstr "그러나 유효 숫자가 :attr:`sys.float_info.dig`\\보다 많은 문자열의 경우, 항상 그렇지는 않습니다::"

#: ../../library/sys.rst:715
msgid ""
">>> s = '9876543211234567'    # 16 significant digits is too many!\n"
">>> format(float(s), '.16g')  # conversion changes value\n"
"'9876543211234568'"
msgstr ""

#: ../../library/sys.rst:721
msgid ""
"A string indicating how the :func:`repr` function behaves for floats.  If"
" the string has value ``'short'`` then for a finite float ``x``, "
"``repr(x)`` aims to produce a short string with the property that "
"``float(repr(x)) == x``.  This is the usual behaviour in Python 3.1 and "
"later.  Otherwise, ``float_repr_style`` has value ``'legacy'`` and "
"``repr(x)`` behaves in the same way as it did in versions of Python prior"
" to 3.1."
msgstr ""
":func:`repr` 함수가 float에 대해 작동하는 방식을 나타내는 문자열. 문자열이 ``'short'`` 값을 가지면, 유한"
" float ``x``\\의 경우, ``repr(x)``\\는 ``float(repr(x)) == x`` 속성을 유지하는 짧은 "
"문자열을 생성하는 것을 목표로 합니다. 이것은 파이썬 3.1 이상에서 일반적인 동작입니다. 그렇지 않으면, "
"``float_repr_style``\\은 ``'legacy'`` 값을 가지며 ``repr(x)``\\는 3.1 이전의 파이썬 "
"버전에서와 같은 방식으로 작동합니다."

#: ../../library/sys.rst:734
#, fuzzy
msgid ""
"Return the number of memory blocks currently allocated by the "
"interpreter, regardless of their size.  This function is mainly useful "
"for tracking and debugging memory leaks.  Because of the interpreter's "
"internal caches, the result can vary from call to call; you may have to "
"call :func:`_clear_internal_caches` and :func:`gc.collect` to get more "
"predictable results."
msgstr ""
"크기에 상관없이, 인터프리터가 현재 할당한 메모리 블록 수를 반환합니다. 이 함수는 주로 메모리 누수를 추적하고 디버깅하는 데 "
"유용합니다. 인터프리터의 내부 캐시로 인해, 결과는 호출마다 다를 수 있습니다; 보다 예측 가능한 결과를 얻으려면 "
":func:`_clear_type_cache()`\\와 :func:`gc.collect()`\\를 호출해야 할 수도 있습니다."

#: ../../library/sys.rst:741
#, fuzzy
msgid ""
"If a Python build or implementation cannot reasonably compute this "
"information, :func:`getallocatedblocks` is allowed to return 0 instead."
msgstr ""
"파이썬 빌드나 구현이 이 정보를 합리적으로 계산할 수 없으면, :func:`getallocatedblocks()`\\는 대신 0을 "
"반환할 수 있습니다."

#: ../../library/sys.rst:749
msgid "Return the number of unicode objects that have been interned."
msgstr ""

#: ../../library/sys.rst:756
msgid ""
"Return the build-time API level of Android as an integer. This represents"
" the minimum version of Android this build of Python can run on. For "
"runtime version information, see :func:`platform.android_ver`."
msgstr ""

#: ../../library/sys.rst:767
#, fuzzy
msgid ""
"Return ``'utf-8'``. This is the name of the default string encoding, used"
" in methods like :meth:`str.encode`."
msgstr "유니코드 구현에서 사용되는 현재 기본 문자열 인코딩의 이름을 반환합니다."

#: ../../library/sys.rst:773
#, fuzzy, python-brace-format
msgid ""
"Return the current value of the flags that are used for :c:func:`dlopen` "
"calls.  Symbolic names for the flag values can be found in the :mod:`os` "
"module (:samp:`RTLD_{xxx}` constants, e.g. :const:`os.RTLD_LAZY`)."
msgstr ""
":c:func:`dlopen` 호출에 사용되는 플래그의 현재 값을 반환합니다. 플래그 값의 기호 이름은 :mod:`os` 모듈에서 "
"찾을 수 있습니다 (``RTLD_xxx`` 상수, 예를 들어 :data:`os.RTLD_LAZY`)."

#: ../../library/sys.rst:783
msgid ""
"Get the :term:`filesystem encoding <filesystem encoding and error "
"handler>`: the encoding used with the :term:`filesystem error handler "
"<filesystem encoding and error handler>` to convert between Unicode "
"filenames and bytes filenames. The filesystem error handler is returned "
"from :func:`getfilesystemencodeerrors`."
msgstr ""

#: ../../library/sys.rst:789
#, fuzzy
msgid ""
"For best compatibility, str should be used for filenames in all cases, "
"although representing filenames as bytes is also supported. Functions "
"accepting or returning filenames should support either str or bytes and "
"internally convert to the system's preferred representation."
msgstr ""
"유니코드 파일명과 바이트열 파일명 사이를 변환하는 데 사용되는 인코딩 이름을 반환합니다. 최상의 호환성을 위해, 파일명을 바이트열로"
" 나타내는 것도 지원되지만, 모든 경우에 파일명에 str을 사용해야 합니다. 파일명을 받아들이거나 반환하는 함수는 str이나 "
"bytes를 지원하고 내부적으로 시스템의 선호되는 표현으로 변환해야 합니다."

#: ../../library/sys.rst:794 ../../library/sys.rst:822
msgid ""
":func:`os.fsencode` and :func:`os.fsdecode` should be used to ensure that"
" the correct encoding and errors mode are used."
msgstr ""
"올바른 인코딩과 에러 모드를 사용하려면 :func:`os.fsencode`\\와 :func:`os.fsdecode`\\를 사용해야 "
"합니다."

#: ../../library/sys.rst:797 ../../library/sys.rst:825
msgid ""
"The :term:`filesystem encoding and error handler` are configured at "
"Python startup by the :c:func:`PyConfig_Read` function: see "
":c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""

#: ../../library/sys.rst:802
msgid ":func:`getfilesystemencoding` result cannot be ``None`` anymore."
msgstr ":func:`getfilesystemencoding` 결과는 더는 ``None``\\일 수 없습니다."

#: ../../library/sys.rst:805
msgid ""
"Windows is no longer guaranteed to return ``'mbcs'``. See :pep:`529` and "
":func:`_enablelegacywindowsfsencoding` for more information."
msgstr ""
"윈도우는 더는 ``'mbcs'``\\를 반환한다고 보장하지 않습니다. 자세한 정보는 :pep:`529`\\와 "
":func:`_enablelegacywindowsfsencoding`\\를 참조하십시오."

#: ../../library/sys.rst:809
msgid "Return ``'utf-8'`` if the :ref:`Python UTF-8 Mode <utf8-mode>` is enabled."
msgstr ""

#: ../../library/sys.rst:816
#, fuzzy
msgid ""
"Get the :term:`filesystem error handler <filesystem encoding and error "
"handler>`: the error handler used with the :term:`filesystem encoding "
"<filesystem encoding and error handler>` to convert between Unicode "
"filenames and bytes filenames. The filesystem encoding is returned from "
":func:`getfilesystemencoding`."
msgstr ""
"유니코드 파일명과 바이트 파일명 사이를 변환하는 데 사용되는 에러 모드의 이름을 반환합니다. 인코딩 이름은 "
":func:`getfilesystemencoding` 에서 반환됩니다."

#: ../../library/sys.rst:834
msgid ""
"Returns the current value for the :ref:`integer string conversion length "
"limitation <int_max_str_digits>`. See also "
":func:`set_int_max_str_digits`."
msgstr ""

#: ../../library/sys.rst:841
msgid ""
"Return the reference count of the *object*.  The count returned is "
"generally one higher than you might expect, because it includes the "
"(temporary) reference as an argument to :func:`getrefcount`."
msgstr ""
"*object*\\의 참조 횟수를 반환합니다. 반환된 수는 일반적으로 예상보다 1이 높습니다. "
":func:`getrefcount`\\에 대한 인자로서의 (임시) 참조를 포함하기 때문입니다."

#: ../../library/sys.rst:845
msgid ""
"Note that the returned value may not actually reflect how many references"
" to the object are actually held.  For example, some objects are "
":term:`immortal` and have a very high refcount that does not reflect the "
"actual number of references.  Consequently, do not rely on the returned "
"value to be accurate, other than a value of 0 or 1."
msgstr ""

#: ../../library/sys.rst:851
msgid ""
"Immortal objects have very large refcounts that do not match the actual "
"number of references to the object."
msgstr ""

#: ../../library/sys.rst:857
msgid ""
"Return the current value of the recursion limit, the maximum depth of the"
" Python interpreter stack.  This limit prevents infinite recursion from "
"causing an overflow of the C stack and crashing Python.  It can be set by"
" :func:`setrecursionlimit`."
msgstr ""
"파이썬 인터프리터 스택의 최대 깊이인, 재귀 한계의 현재 값을 반환합니다. 이 제한은 무한 재귀로 인해 C 스택의 오버플로가 "
"발생하고 파이썬이 충돌하는 것을 방지합니다. :func:`setrecursionlimit`\\로 설정할 수 있습니다."

#: ../../library/sys.rst:865
msgid ""
"Return the size of an object in bytes. The object can be any type of "
"object. All built-in objects will return correct results, but this does "
"not have to hold true for third-party extensions as it is implementation "
"specific."
msgstr ""
"객체의 크기를 바이트 단위로 반환합니다. 객체는 모든 형의 객체일 수 있습니다. 모든 내장 객체는 올바른 결과를 반환하지만, 구현 "
"특정이기 때문에 제삼자 확장에서도 그렇다고 보장할 수는 없습니다."

#: ../../library/sys.rst:870
msgid ""
"Only the memory consumption directly attributed to the object is "
"accounted for, not the memory consumption of objects it refers to."
msgstr "객체에 직접 기여한 메모리 소비만 포함하며, 이 객체가 참조하는 객체의 메모리 소비는 따지지 않습니다."

#: ../../library/sys.rst:873
msgid ""
"If given, *default* will be returned if the object does not provide means"
" to retrieve the size.  Otherwise a :exc:`TypeError` will be raised."
msgstr ""
"주어진 경우, 객체가 크기를 조회하는 수단을 제공하지 않으면 *default*\\가 반환됩니다. 그렇지 않으면 "
":exc:`TypeError`\\가 발생합니다."

#: ../../library/sys.rst:876
msgid ""
":func:`getsizeof` calls the object's ``__sizeof__`` method and adds an "
"additional garbage collector overhead if the object is managed by the "
"garbage collector."
msgstr ""
":func:`getsizeof`\\는 객체의 ``__sizeof__`` 메서드를 호출하고 객체가 가비지 수거기에 의해 관리되면 추가"
" 가비지 수거기 오버헤드를 추가합니다."

#: ../../library/sys.rst:880
#, fuzzy
msgid ""
"See `recursive sizeof recipe <https://code.activestate.com/recipes/577504"
"-compute-memory-footprint-of-an-object-and-its-cont/>`_ for an example of"
" using :func:`getsizeof` recursively to find the size of containers and "
"all their contents."
msgstr ""
"컨테이너와 모든 내용물의 크기를 찾기 위해 :func:`getsizeof`\\를 재귀적으로 사용하는 예는 `recursive "
"sizeof recipe <https://code.activestate.com/recipes/577504>`_\\를 참조하십시오."

#: ../../library/sys.rst:886
#, fuzzy
msgid ""
"Return the interpreter's \"thread switch interval\" in seconds; see "
":func:`setswitchinterval`."
msgstr "인터프리터의 \"스레드 스위치 간격\"을 반환합니다; :func:`setswitchinterval`\\을 참조하십시오."

#: ../../library/sys.rst:894
msgid ""
"Return a frame object from the call stack.  If optional integer *depth* "
"is given, return the frame object that many calls below the top of the "
"stack.  If that is deeper than the call stack, :exc:`ValueError` is "
"raised.  The default for *depth* is zero, returning the frame at the top "
"of the call stack."
msgstr ""
"호출 스택에서 프레임 객체를 반환합니다. 선택적 정수 *depth*\\가 제공되면, 스택 맨 위에서 지정한 수 만큼 아래에 있는 "
"호출의 프레임 객체를 반환합니다. 호출 스택보다 깊으면, :exc:`ValueError`\\가 발생합니다. *depth*\\의 "
"기본값은 0이며, 호출 스택의 맨 위에 있는 프레임을 반환합니다."

#: ../../library/sys.rst:899
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._getframe`` with "
"argument ``frame``."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys._getframe``\\을 발생시킵니다."

#: ../../library/sys.rst:903 ../../library/sys.rst:919
msgid ""
"This function should be used for internal and specialized purposes only. "
"It is not guaranteed to exist in all implementations of Python."
msgstr "이 함수는 내부와 특수 목적으로만 사용해야 합니다. 모든 파이썬 구현에 존재한다고 보장되는 것은 아닙니다."

#: ../../library/sys.rst:909
#, fuzzy
msgid ""
"Return the name of a module from the call stack.  If optional integer "
"*depth* is given, return the module that many calls below the top of the "
"stack.  If that is deeper than the call stack, or if the module is "
"unidentifiable, ``None`` is returned.  The default for *depth* is zero, "
"returning the module at the top of the call stack."
msgstr ""
"호출 스택에서 프레임 객체를 반환합니다. 선택적 정수 *depth*\\가 제공되면, 스택 맨 위에서 지정한 수 만큼 아래에 있는 "
"호출의 프레임 객체를 반환합니다. 호출 스택보다 깊으면, :exc:`ValueError`\\가 발생합니다. *depth*\\의 "
"기본값은 0이며, 호출 스택의 맨 위에 있는 프레임을 반환합니다."

#: ../../library/sys.rst:915
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys._getframemodulename`` "
"with argument ``depth``."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys._getframe``\\을 발생시킵니다."

#: ../../library/sys.rst:925
msgid ""
"This function only exists if CPython was built using the specialized "
"configure option :option:`--with-trace-refs`. It is intended only for "
"debugging garbage-collection issues."
msgstr ""

#: ../../library/sys.rst:929
msgid ""
"Return a list of up to *limit* dynamically allocated Python objects. If "
"*type* is given, only objects of that exact type (not subtypes) are "
"included."
msgstr ""

#: ../../library/sys.rst:933
msgid ""
"Objects from the list are not safe to use. Specifically, the result will "
"include objects from all interpreters that share their object allocator "
"state (that is, ones created with "
":c:member:`PyInterpreterConfig.use_main_obmalloc` set to 1 or using "
":c:func:`Py_NewInterpreter`, and the :ref:`main interpreter <sub-"
"interpreter-support>`). Mixing objects from different interpreters may "
"lead to crashes or other unexpected behavior."
msgstr ""

#: ../../library/sys.rst:944
#, fuzzy
msgid ""
"This function should be used for specialized purposes only. It is not "
"guaranteed to exist in all implementations of Python."
msgstr "이 함수는 내부와 특수 목적으로만 사용해야 합니다. 모든 파이썬 구현에 존재한다고 보장되는 것은 아닙니다."

#: ../../library/sys.rst:949
msgid "The result may include objects from other interpreters."
msgstr ""

#: ../../library/sys.rst:958
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr ":func:`setprofile`\\에 의해 설정된 프로파일러 함수를 얻습니다."

#: ../../library/sys.rst:967
msgid "Get the trace function as set by :func:`settrace`."
msgstr ":func:`settrace`\\에 의해 설정된 추적 함수를 얻습니다."

#: ../../library/sys.rst:971
msgid ""
"The :func:`gettrace` function is intended only for implementing "
"debuggers, profilers, coverage tools and the like.  Its behavior is part "
"of the implementation platform, rather than part of the language "
"definition, and thus may not be available in all Python implementations."
msgstr ""
":func:`gettrace` 함수는 디버거, 프로파일러, 커버리지 도구 등을 구현하기 위한 것입니다. 그 동작은 언어 정의의 "
"일부라기보다는 구현 플랫폼의 일부이기 때문에, 모든 파이썬 구현에서 사용 가능한 것은 아닙니다."

#: ../../library/sys.rst:979
msgid ""
"Return a named tuple describing the Windows version currently running.  "
"The named elements are *major*, *minor*, *build*, *platform*, "
"*service_pack*, *service_pack_minor*, *service_pack_major*, *suite_mask*,"
" *product_type* and *platform_version*. *service_pack* contains a string,"
" *platform_version* a 3-tuple and all other values are integers. The "
"components can also be accessed by name, so "
"``sys.getwindowsversion()[0]`` is equivalent to "
"``sys.getwindowsversion().major``. For compatibility with prior versions,"
" only the first 5 elements are retrievable by indexing."
msgstr ""
"현재 실행 중인 윈도우 버전을 설명하는 네임드 튜플을 반환합니다. 명명된 요소는 *major*, *minor*, *build*, "
"*platform*, *service_pack*, *service_pack_minor*, *service_pack_major*, "
"*suite_mask*, *product_type* 및 *platform_version*\\입니다. *service_pack*\\은"
" 문자열을 포함하고 *platform_version*\\은 3-튜플이며 다른 모든 값은 정수입니다. 구성 요소는 이름으로도 액세스할"
" 수 있어서, ``sys.getwindowsversion()[0]`` 은 "
"``sys.getwindowsversion().major``\\와 동등합니다. 이전 버전과의 호환성을 위해, 처음 5개 요소 만 "
"인덱싱을 통해 꺼낼 수 있습니다."

#: ../../library/sys.rst:990
#, fuzzy
msgid "*platform* will be ``2`` (VER_PLATFORM_WIN32_NT)."
msgstr "*platform*\\은 :const:`2 (VER_PLATFORM_WIN32_NT)`\\입니다."

#: ../../library/sys.rst:992
msgid "*product_type* may be one of the following values:"
msgstr "*product_type*\\은 다음 값 중 하나일 수 있습니다:"

#: ../../library/sys.rst:995
msgid "Constant"
msgstr "상수"

#: ../../library/sys.rst:995
msgid "Meaning"
msgstr "의미"

#: ../../library/sys.rst:997
#, fuzzy
msgid "``1`` (VER_NT_WORKSTATION)"
msgstr ":const:`1 (VER_NT_WORKSTATION)`"

#: ../../library/sys.rst:997
msgid "The system is a workstation."
msgstr "시스템은 워크 스테이션입니다."

#: ../../library/sys.rst:999
#, fuzzy
msgid "``2`` (VER_NT_DOMAIN_CONTROLLER)"
msgstr ":const:`2 (VER_NT_DOMAIN_CONTROLLER)`"

#: ../../library/sys.rst:999
msgid "The system is a domain controller."
msgstr "시스템은 도메인 컨트롤러입니다."

#: ../../library/sys.rst:1002
#, fuzzy
msgid "``3`` (VER_NT_SERVER)"
msgstr ":const:`3 (VER_NT_SERVER)`"

#: ../../library/sys.rst:1002
msgid "The system is a server, but not a domain controller."
msgstr "시스템은 서버이지만, 도메인 컨트롤러는 아닙니다."

#: ../../library/sys.rst:1006
#, fuzzy
msgid ""
"This function wraps the Win32 :c:func:`!GetVersionEx` function; see the "
"Microsoft documentation on :c:func:`!OSVERSIONINFOEX` for more "
"information about these fields."
msgstr ""
"이 함수는 Win32 :c:func:`GetVersionEx` 함수를 감쌉니다; 이러한 필드에 대한 자세한 내용은 "
":c:func:`OSVERSIONINFOEX` 에 대한 마이크로소프트 설명서를 참조하십시오."

#: ../../library/sys.rst:1010
#, fuzzy
msgid ""
"*platform_version* returns the major version, minor version and build "
"number of the current operating system, rather than the version that is "
"being emulated for the process. It is intended for use in logging rather "
"than for feature detection."
msgstr ""
"*platform_version*\\은 프로세스에 대해 에뮬레이션 되는 버전이 아니라, 정확한 주 버전, 부 버전 및 현재 운영 "
"체제의 빌드 번호를 반환합니다. 기능 감지가 아닌 로깅에 사용하기 위한 것입니다."

#: ../../library/sys.rst:1016
msgid ""
"*platform_version* derives the version from kernel32.dll which can be of "
"a different version than the OS version. Please use :mod:`platform` "
"module for achieving accurate OS version."
msgstr ""

#: ../../library/sys.rst:1022
msgid ""
"Changed to a named tuple and added *service_pack_minor*, "
"*service_pack_major*, *suite_mask*, and *product_type*."
msgstr ""
"네임드 튜플로 변경되어 *service_pack_minor*, *service_pack_major*, *suite_mask* 및 "
"*product_type*\\이 추가되었습니다."

#: ../../library/sys.rst:1026
msgid "Added *platform_version*"
msgstr "*platform_version*\\을 추가했습니다"

#: ../../library/sys.rst:1032
#, fuzzy
msgid ""
"Returns an *asyncgen_hooks* object, which is similar to a "
":class:`~collections.namedtuple` of the form ``(firstiter, finalizer)``, "
"where *firstiter* and *finalizer* are expected to be either ``None`` or "
"functions which take an :term:`asynchronous generator iterator` as an "
"argument, and are used to schedule finalization of an asynchronous "
"generator by an event loop."
msgstr ""
"`(firstiter, finalizer)` 형식의 :class:`~collections.namedtuple`\\과 유사한 "
"*asyncgen_hooks* 객체를 반환합니다. 여기서 *firstiter*\\와 *finalizer*\\는 "
"``None``\\이나 :term:`비동기 제너레이터 이터레이터 <asynchronous generator iterator>`\\를"
" 인자로 취하는 함수로 기대되며, 이벤트 루프에 의해 비동기 제너레이터의 파이널리제이션을 스케줄 하는 데 사용됩니다."

#: ../../library/sys.rst:1039
msgid "See :pep:`525` for more details."
msgstr "자세한 내용은 :pep:`525`\\를 참조하십시오."

#: ../../library/sys.rst:1043 ../../library/sys.rst:1734
msgid ""
"This function has been added on a provisional basis (see :pep:`411` for "
"details.)"
msgstr "이 함수는 잠정적(provisional)으로 추가되었습니다 (자세한 내용은 :pep:`411`\\을 참조하십시오)."

#: ../../library/sys.rst:1049
msgid ""
"Get the current coroutine origin tracking depth, as set by "
":func:`set_coroutine_origin_tracking_depth`."
msgstr ":func:`set_coroutine_origin_tracking_depth`\\로 설정된 현재 코루틴 원점 추적 깊이를 가져옵니다."

#: ../../library/sys.rst:1055 ../../library/sys.rst:1755
msgid ""
"This function has been added on a provisional basis (see :pep:`411` for "
"details.)  Use it only for debugging purposes."
msgstr ""
"이 함수는 잠정적(provisional)으로 추가되었습니다 (자세한 내용은 :pep:`411`\\을 참조하십시오). 디버깅 "
"목적으로만 사용하십시오."

#: ../../library/sys.rst:1061
msgid ""
"A :term:`named tuple` giving parameters of the numeric hash "
"implementation.  For more details about hashing of numeric types, see "
":ref:`numeric-hash`."
msgstr ""
"숫자 해시 구현의 매개 변수를 제공하는 :term:`네임드 튜플 <named tuple>`. 숫자 형의 해싱에 대한 자세한 내용은 "
":ref:`numeric-hash`\\을 참조하십시오."

#: ../../library/sys.rst:1067
#, fuzzy
msgid "The width in bits used for hash values"
msgstr "해시값에 사용되는 비트 폭"

#: ../../library/sys.rst:1071
#, fuzzy
msgid "The prime modulus P used for numeric hash scheme"
msgstr "수치 해시 체계에 사용되는 소수 모듈러스 P"

#: ../../library/sys.rst:1075
#, fuzzy
msgid "The hash value returned for a positive infinity"
msgstr "양의 무한대에 대해 반환된 해시값"

#: ../../library/sys.rst:1079
msgid "(This attribute is no longer used)"
msgstr ""

#: ../../library/sys.rst:1083
#, fuzzy
msgid "The multiplier used for the imaginary part of a complex number"
msgstr "복소수의 허수부에 사용되는 승수(multiplier)"

#: ../../library/sys.rst:1087
#, fuzzy
msgid "The name of the algorithm for hashing of str, bytes, and memoryview"
msgstr "str, bytes 및 memoryview의 해싱 알고리즘 이름"

#: ../../library/sys.rst:1091
#, fuzzy
msgid "The internal output size of the hash algorithm"
msgstr "해시 알고리즘의 내부 출력 크기"

#: ../../library/sys.rst:1095
#, fuzzy
msgid "The size of the seed key of the hash algorithm"
msgstr "해시 알고리즘의 시드 키 크기"

#: ../../library/sys.rst:1099
msgid "Added *algorithm*, *hash_bits* and *seed_bits*"
msgstr "*algorithm*, *hash_bits* 및 *seed_bits*\\를 추가했습니다"

#: ../../library/sys.rst:1105
msgid ""
"The version number encoded as a single integer.  This is guaranteed to "
"increase with each version, including proper support for non-production "
"releases.  For example, to test that the Python interpreter is at least "
"version 1.5.2, use::"
msgstr ""
"단일 정수로 인코딩된 버전 번호. 이것은 비 프로덕션 릴리스에 대한 적절한 지원을 포함하여, 버전마다 증가함이 보장됩니다. 예를 "
"들어, 파이썬 인터프리터가 버전 1.5.2 이상인지 검사하려면, 다음을 사용하십시오::"

#: ../../library/sys.rst:1109
msgid ""
"if sys.hexversion >= 0x010502F0:\n"
"    # use some advanced feature\n"
"    ...\n"
"else:\n"
"    # use an alternative implementation or warn the user\n"
"    ..."
msgstr ""

#: ../../library/sys.rst:1116
msgid ""
"This is called ``hexversion`` since it only really looks meaningful when "
"viewed as the result of passing it to the built-in :func:`hex` function."
"  The :term:`named tuple`  :data:`sys.version_info` may be used for a "
"more human-friendly encoding of the same information."
msgstr ""
"내장 :func:`hex` 함수에 전달한 결과로 볼 때만 실제로 의미가 있기 때문에 이것을 ``hexversion``\\이라고 "
"합니다. :term:`네임드 튜플 <named tuple>` :data:`sys.version_info`\\는 같은 정보의 더 인간"
" 친화적인 인코딩으로 사용될 수 있습니다."

#: ../../library/sys.rst:1121
msgid "More details of ``hexversion`` can be found at :ref:`apiabiversion`."
msgstr "``hexversion``\\에 대한 자세한 내용은 :ref:`apiabiversion` 에서 찾을 수 있습니다."

#: ../../library/sys.rst:1126
msgid ""
"An object containing information about the implementation of the "
"currently running Python interpreter.  The following attributes are "
"required to exist in all Python implementations."
msgstr "현재 실행 중인 파이썬 인터프리터의 구현에 대한 정보가 포함된 객체. 모든 파이썬 구현에서 다음과 같은 어트리뷰트가 있어야 합니다."

#: ../../library/sys.rst:1130
msgid ""
"*name* is the implementation's identifier, e.g. ``'cpython'``.  The "
"actual string is defined by the Python implementation, but it is "
"guaranteed to be lower case."
msgstr ""
"*name*\\은 구현 식별자입니다, 예를 들어 ``'cpython'``. 실제 문자열은 파이썬 구현에 의해 정의되지만, 소문자임이"
" 보장됩니다."

#: ../../library/sys.rst:1134
msgid ""
"*version* is a named tuple, in the same format as "
":data:`sys.version_info`.  It represents the version of the Python "
"*implementation*.  This has a distinct meaning from the specific version "
"of the Python *language* to which the currently running interpreter "
"conforms, which ``sys.version_info`` represents.  For example, for PyPy "
"1.8 ``sys.implementation.version`` might be ``sys.version_info(1, 8, 0, "
"'final', 0)``, whereas ``sys.version_info`` would be "
"``sys.version_info(2, 7, 2, 'final', 0)``.  For CPython they are the same"
" value, since it is the reference implementation."
msgstr ""
"*version*\\은 :data:`sys.version_info`\\와 같은 형식의 네임드 튜플입니다. 파이썬 *구현*\\의 "
"버전을 나타냅니다. 이것은 현재 실행 중인 인터프리터가 준수하는, ``sys.version_info``\\가 나타내는, 특정 버전의"
" 파이썬 *언어*\\와는 다른 의미입니다. 예를 들어, PyPy 1.8의 경우 "
"``sys.implementation.version``\\은 ``sys.version_info(1, 8, 0, 'final', "
"0)``\\일 수 있지만, ``sys.version_info``\\는 ``sys.version_info(2, 7, 2, "
"'final', 0)``\\입니다. CPython의 경우 참조 구현이기 때문에 같은 값입니다."

#: ../../library/sys.rst:1144
msgid ""
"*hexversion* is the implementation version in hexadecimal format, like "
":data:`sys.hexversion`."
msgstr "*hexversion*\\은 :data:`sys.hexversion`\\과 같은 16진수 형식의 구현 버전입니다."

#: ../../library/sys.rst:1147
msgid ""
"*cache_tag* is the tag used by the import machinery in the filenames of "
"cached modules.  By convention, it would be a composite of the "
"implementation's name and version, like ``'cpython-33'``.  However, a "
"Python implementation may use some other value if appropriate.  If "
"``cache_tag`` is set to ``None``, it indicates that module caching should"
" be disabled."
msgstr ""
"*cache_tag*\\는 임포트 절차에서 캐시 된 모듈의 파일명에 사용되는 태그입니다. 관습상, "
"``'cpython-33'``\\과 같이 구현 이름과 버전을 합성한 것입니다. 그러나, 파이썬 구현은 적절하다면 다른 값을 사용할 "
"수 있습니다. ``cache_tag``\\가 ``None``\\으로 설정되면, 모듈 캐싱을 사용하지 않아야 함을 나타냅니다."

#: ../../library/sys.rst:1154
msgid ""
":data:`sys.implementation` may contain additional attributes specific to "
"the Python implementation.  These non-standard attributes must start with"
" an underscore, and are not described here.  Regardless of its contents, "
":data:`sys.implementation` will not change during a run of the "
"interpreter, nor between implementation versions.  (It may change between"
" Python language versions, however.)  See :pep:`421` for more "
"information."
msgstr ""
":data:`sys.implementation`\\은 파이썬 구현에 고유한 추가 어트리뷰트를 포함할 수 있습니다. 이러한 비표준 "
"어트리뷰트는 밑줄로 시작해야 하며, 여기에서는 설명하지 않습니다. 내용과 관계없이, "
":data:`sys.implementation`\\은 인터프리터 실행 중이나 구현 버전 간에 변경되지 않습니다. (그러나, 파이썬 "
"언어 버전 간에는 변경될 수 있습니다.) 자세한 정보는 :pep:`421`\\을 참조하십시오."

#: ../../library/sys.rst:1165
msgid ""
"The addition of new required attributes must go through the normal PEP "
"process. See :pep:`421` for more information."
msgstr "새로운 필수 어트리뷰트를 추가하려면 일반 PEP 프로세스를 거쳐야 합니다. 자세한 정보는 :pep:`421`\\을 참조하십시오."

#: ../../library/sys.rst:1170
msgid ""
"A :term:`named tuple` that holds information about Python's internal "
"representation of integers.  The attributes are read only."
msgstr "파이썬의 정수 내부 표현에 대한 정보를 담고 있는 :term:`네임드 튜플 <named tuple>`. 어트리뷰트는 읽기 전용입니다."

#: ../../library/sys.rst:1175
#, fuzzy
msgid ""
"The number of bits held in each digit. Python integers are stored "
"internally in base ``2**int_info.bits_per_digit``."
msgstr ""
"각 자릿수에 담긴 비트 수. 파이썬 정수는 내부적으로 기수(base) ``2**int_info.bits_per_digit``\\로 "
"저장됩니다"

#: ../../library/sys.rst:1180
#, fuzzy
msgid "The size in bytes of the C type used to represent a digit."
msgstr "자릿수를 나타내는 데 사용되는 C형의 바이트 단위 크기"

#: ../../library/sys.rst:1184
msgid ""
"The default value for :func:`sys.get_int_max_str_digits` when it is not "
"otherwise explicitly configured."
msgstr ""

#: ../../library/sys.rst:1189
msgid ""
"The minimum non-zero value for :func:`sys.set_int_max_str_digits`, "
":envvar:`PYTHONINTMAXSTRDIGITS`, or :option:`-X int_max_str_digits <-X>`."
msgstr ""

#: ../../library/sys.rst:1196
msgid ""
"Added :attr:`~int_info.default_max_str_digits` and "
":attr:`~int_info.str_digits_check_threshold`."
msgstr ""

#: ../../library/sys.rst:1202
msgid ""
"When this attribute exists, its value is automatically called (with no "
"arguments) when the interpreter is launched in :ref:`interactive mode "
"<tut-interactive>`.  This is done after the :envvar:`PYTHONSTARTUP` file "
"is read, so that you can set this hook there.  The :mod:`site` module "
":ref:`sets this <rlcompleter-config>`."
msgstr ""
"이 어트리뷰트가 존재하면, :ref:`대화형 모드 <tut-interactive>`\\로 인터프리터가 시작될 때 해당 값이 (인자 "
"없이) 자동으로 호출됩니다. 이것은 :envvar:`PYTHONSTARTUP` 파일을 읽은 후에 수행되므로, 그곳에서 이 훅을 "
"설정할 수 있습니다. :mod:`site` 모듈은 :ref:`이것을 설정합니다 <rlcompleter-config>`."

#: ../../library/sys.rst:1208 ../../library/sys.rst:1210
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.run_interactivehook`` with the hook object as the argument when"
" the hook is called on startup."
msgstr ""
"시작 시 훅이 호출될 때 훅 객체를 인자로 :ref:`감사 이벤트 <auditing>` "
"``cpython.run_interactivehook``\\을 발생시킵니다."

#: ../../library/sys.rst:1219
msgid ""
"Enter *string* in the table of \"interned\" strings and return the "
"interned string -- which is *string* itself or a copy. Interning strings "
"is useful to gain a little performance on dictionary lookup -- if the "
"keys in a dictionary are interned, and the lookup key is interned, the "
"key comparisons (after hashing) can be done by a pointer compare instead "
"of a string compare.  Normally, the names used in Python programs are "
"automatically interned, and the dictionaries used to hold module, class "
"or instance attributes have interned keys."
msgstr ""
"\"인턴 된(interned)\" 문자열 테이블에 *string*\\을 넣고, *string* 자신이거나 사본인 인턴 된 문자열을 "
"반환합니다. 문자열을 인턴 하는 것은 딕셔너리 조회에서 약간의 성능 개선을 얻는 데 유용합니다 -- 딕셔너리의 키가 인턴 되고. "
"조회 키가 인턴 되면, (해싱 후의) 키 비교는 문자열 비교 대신 포인터 비교를 수행 할 수 있습니다. 일반적으로, 파이썬 "
"프로그램에서 사용되는 이름은 자동으로 인턴 되며, 모듈, 클래스 또는 인스턴스 어트리뷰트를 담는 데 사용되는 딕셔너리는 인턴 된 "
"키를 갖습니다."

#: ../../library/sys.rst:1227
#, fuzzy
msgid ""
"Interned strings are not :term:`immortal`; you must keep a reference to "
"the return value of :func:`intern` around to benefit from it."
msgstr "인턴 된 문자열은 불멸이 아닙니다; 이점을 얻으려면 :func:`intern`\\의 반환 값에 대한 참조를 유지해야 합니다."

#: ../../library/sys.rst:1233
msgid ""
"Return :const:`True` if the :term:`GIL` is enabled and :const:`False` if "
"it is disabled."
msgstr ""

#: ../../library/sys.rst:1240 ../../library/sys.rst:1272
#, fuzzy
msgid "It is not guaranteed to exist in all implementations of Python."
msgstr "이 함수는 내부와 특수 목적으로만 사용해야 합니다. 모든 파이썬 구현에 존재한다고 보장되는 것은 아닙니다."

#: ../../library/sys.rst:1244
#, fuzzy
msgid ""
"Return :const:`True` if the main Python interpreter is :term:`shutting "
"down <interpreter shutdown>`. Return :const:`False` otherwise."
msgstr ""
"파이썬 인터프리터가 :term:`종료 <interpreter shutdown>` 중이면 :const:`True`\\를, 그렇지 "
"않으면 :const:`False`\\를 반환합니다."

#: ../../library/sys.rst:1247
msgid "See also the :exc:`PythonFinalizationError` exception."
msgstr ""

#: ../../library/sys.rst:1253
#, fuzzy
msgid ""
"This variable is not always defined; it is set to the exception instance "
"when an exception is not handled and the interpreter prints an error "
"message and a stack traceback.  Its intended use is to allow an "
"interactive user to import a debugger module and engage in post-mortem "
"debugging without having to re-execute the command that caused the error."
"  (Typical use is ``import pdb; pdb.pm()`` to enter the post-mortem "
"debugger; see :mod:`pdb` module for more information.)"
msgstr ""
"이 세 변수가 항상 정의되는 것은 아닙니다; 예외가 처리되지 않고 인터프리터가 에러 메시지와 스택 트레이스백을 인쇄할 때 "
"설정됩니다. 의도된 용도는 대화형 사용자가 디버거 모듈을 임포트하고 에러를 일으킨 명령을 다시 실행하지 않고도 사후 디버깅에 참여할"
" 수 있도록 하는 것입니다. (사후 디버거에 들어가기 위해 일반적으로 ``import pdb; pdb.pm()``\\을 사용합니다;"
" 자세한 내용은 :mod:`pdb` 모듈을 참조하십시오.)"

#: ../../library/sys.rst:1265
#, fuzzy
msgid ""
"Return :const:`True` if the given string is \"interned\", :const:`False` "
"otherwise."
msgstr ""
"파이썬 인터프리터가 :term:`종료 <interpreter shutdown>` 중이면 :const:`True`\\를, 그렇지 "
"않으면 :const:`False`\\를 반환합니다."

#: ../../library/sys.rst:1279
msgid ""
"These three variables are deprecated; use :data:`sys.last_exc` instead. "
"They hold the legacy representation of ``sys.last_exc``, as returned from"
" :func:`exc_info` above."
msgstr ""

#: ../../library/sys.rst:1285
msgid ""
"An integer giving the maximum value a variable of type "
":c:type:`Py_ssize_t` can take.  It's usually ``2**31 - 1`` on a 32-bit "
"platform and ``2**63 - 1`` on a 64-bit platform."
msgstr ""
":c:type:`Py_ssize_t` 형의 변수가 취할 수 있는 최댓값을 제공하는 정수. 일반적으로 32비트 플랫폼에서는 "
"``2**31 - 1``\\이고 64비트 플랫폼에서는 ``2**63 - 1``\\입니다."

#: ../../library/sys.rst:1292
msgid ""
"An integer giving the value of the largest Unicode code point, i.e. "
"``1114111`` (``0x10FFFF`` in hexadecimal)."
msgstr "가장 큰 유니코드 코드 포인트의 값을 제공하는 정수, 즉 ``1114111`` (16진수로 ``0x10FFFF``)."

#: ../../library/sys.rst:1295
msgid ""
"Before :pep:`393`, ``sys.maxunicode`` used to be either ``0xFFFF`` or "
"``0x10FFFF``, depending on the configuration option that specified "
"whether Unicode characters were stored as UCS-2 or UCS-4."
msgstr ""
":pep:`393` 이전에는, 유니코드 문자가 UCS-2와 UCS-4 중 어는 것으로 저장되었는지를 지정하는 구성 옵션에 따라, "
"``sys.maxunicode``\\는 ``0xFFFF``\\나 ``0x10FFFF``\\이었습니다."

#: ../../library/sys.rst:1303
#, fuzzy
msgid ""
"A list of :term:`meta path finder` objects that have their "
":meth:`~importlib.abc.MetaPathFinder.find_spec` methods called to see if "
"one of the objects can find the module to be imported. By default, it "
"holds entries that implement Python's default import semantics. The "
":meth:`~importlib.abc.MetaPathFinder.find_spec` method is called with at "
"least the absolute name of the module being imported. If the module to be"
" imported is contained in a package, then the parent package's "
":attr:`~module.__path__` attribute is passed in as a second argument. The"
" method returns a :term:`module spec`, or ``None`` if the module cannot "
"be found."
msgstr ""
":term:`메타 경로 파인더 <meta path finder>` 객체의 리스트. 이 객체의 "
":meth:`~importlib.abc.MetaPathFinder.find_spec` 메서드를 호출해서 임포트 할 모듈을 찾을 수 "
"있는지 확인할 수 있습니다. 최소한 임포트 할 모듈의 절대 이름으로 "
":meth:`~importlib.abc.MetaPathFinder.find_spec` 메서드가 호출됩니다. 임포트 할 모듈이 "
"패키지에 포함되어 있으면, 부모 패키지의 :attr:`__path__` 어트리뷰트가 두 번째 인자로 전달됩니다. 이 메서드는 "
":term:`모듈 스펙 <module spec>`\\이나 모듈을 찾을 수 없으면 ``None``\\을 반환합니다."

#: ../../library/sys.rst:1316
msgid ":class:`importlib.abc.MetaPathFinder`"
msgstr ":class:`importlib.abc.MetaPathFinder`"

#: ../../library/sys.rst:1317
msgid ""
"The abstract base class defining the interface of finder objects on "
":data:`meta_path`."
msgstr ":data:`meta_path`\\에 있는 파인더 객체의 인터페이스를 정의하는 추상 베이스 클래스."

#: ../../library/sys.rst:1319
msgid ":class:`importlib.machinery.ModuleSpec`"
msgstr ":class:`importlib.machinery.ModuleSpec`"

#: ../../library/sys.rst:1320
msgid ""
"The concrete class which :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"should return instances of."
msgstr ""
":meth:`~importlib.abc.MetaPathFinder.find_spec`\\이 이 구상 클래스의 인스턴스를 반환해야 "
"합니다."

#: ../../library/sys.rst:1326
msgid ""
":term:`Module specs <module spec>` were introduced in Python 3.4, by "
":pep:`451`."
msgstr ""

#: ../../library/sys.rst:1331
#, fuzzy
msgid ""
"Removed the fallback that looked for a :meth:`!find_module` method if a "
":data:`meta_path` entry didn't have a "
":meth:`~importlib.abc.MetaPathFinder.find_spec` method."
msgstr ""
":term:`모듈 스펙 <module spec>`\\은 파이썬 3.4에서 :pep:`451`\\에 의해 도입되었습니다. 이전 버전의"
" 파이썬은 :meth:`~importlib.abc.MetaPathFinder.find_module`\\이라는 메서드를 찾았습니다. "
":data:`meta_path` 항목에 :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"메서드가 없으면 이를 대신 호출합니다."

#: ../../library/sys.rst:1337
#, fuzzy
msgid ""
"This is a dictionary that maps module names to modules which have already"
" been loaded.  This can be manipulated to force reloading of modules and "
"other tricks. However, replacing the dictionary will not necessarily work"
" as expected and deleting essential items from the dictionary may cause "
"Python to fail.  If you want to iterate over this global dictionary "
"always use ``sys.modules.copy()`` or ``tuple(sys.modules)`` to avoid "
"exceptions as its size may change during iteration as a side effect of "
"code or activity in other threads."
msgstr ""
"이것은 모듈 이름을 이미 로드된 모듈로 매핑하는 딕셔너리입니다. 모듈의 재로딩과 기타 트릭을 강제하기 위해 조작할 수 있습니다. "
"그러나 딕셔너리를 교체하는 것은 예상대로 작동하지는 않으며 딕셔너리에서 필수 항목을 삭제하면 파이썬이 실패할 수 있습니다."

#: ../../library/sys.rst:1349
msgid ""
"The list of the original command line arguments passed to the Python "
"executable."
msgstr ""

#: ../../library/sys.rst:1352
msgid ""
"The elements of :data:`sys.orig_argv` are the arguments to the Python "
"interpreter, while the elements of :data:`sys.argv` are the arguments to "
"the user's program. Arguments consumed by the interpreter itself will be "
"present in :data:`sys.orig_argv` and missing from :data:`sys.argv`."
msgstr ""

#: ../../library/sys.rst:1364
msgid ""
"A list of strings that specifies the search path for modules. Initialized"
" from the environment variable :envvar:`PYTHONPATH`, plus an "
"installation-dependent default."
msgstr ""
"모듈의 검색 경로를 지정하는 문자열 리스트. 환경 변수 :envvar:`PYTHONPATH`\\와 설치 종속 기본값으로 "
"초기화되었습니다."

#: ../../library/sys.rst:1368
msgid ""
"By default, as initialized upon program startup, a potentially unsafe "
"path is prepended to :data:`sys.path` (*before* the entries inserted as a"
" result of :envvar:`PYTHONPATH`):"
msgstr ""

#: ../../library/sys.rst:1372
#, fuzzy
msgid "``python -m module`` command line: prepend the current working directory."
msgstr "상대 경로는 현재 작업 디렉터리를 기준으로 해석됩니다."

#: ../../library/sys.rst:1374
msgid ""
"``python script.py`` command line: prepend the script's directory. If "
"it's a symbolic link, resolve symbolic links."
msgstr ""

#: ../../library/sys.rst:1376
msgid ""
"``python -c code`` and ``python`` (REPL) command lines: prepend an empty "
"string, which means the current working directory."
msgstr ""

#: ../../library/sys.rst:1379
msgid ""
"To not prepend this potentially unsafe path, use the :option:`-P` command"
" line option or the :envvar:`PYTHONSAFEPATH` environment variable."
msgstr ""

#: ../../library/sys.rst:1382
#, fuzzy
msgid ""
"A program is free to modify this list for its own purposes.  Only strings"
" should be added to :data:`sys.path`; all other data types are ignored "
"during import."
msgstr ""
"프로그램은 자체 목적으로 이 리스트를 자유롭게 수정할 수 있습니다. 문자열과 바이트열만 :data:`sys.path`\\에 추가해야"
" 합니다; 임포트 하는 동안 다른 모든 데이터형은 무시됩니다."

#: ../../library/sys.rst:1388
msgid ""
"Module :mod:`site` This describes how to use .pth files to extend "
":data:`sys.path`."
msgstr "모듈 :mod:`site`. 이것은 .pth 파일을 사용하여 :data:`sys.path`\\를 확장하는 방법에 관해 설명합니다."

#: ../../library/sys.rst:1393
msgid ""
"A list of callables that take a path argument to try to create a "
":term:`finder` for the path. If a finder can be created, it is to be "
"returned by the callable, else raise :exc:`ImportError`."
msgstr ""
"경로 인자를 취해서 경로를 위한 :term:`파인더 <finder>`\\를 만들려고 시도하는 콜러블의 리스트. 파인더를 만들 수 "
"있으면, 콜러블이 반환하고, 그렇지 않으면 :exc:`ImportError`\\를 발생시킵니다."

#: ../../library/sys.rst:1397 ../../library/sys.rst:1408
msgid "Originally specified in :pep:`302`."
msgstr "원래 :pep:`302`\\에서 지정되었습니다."

#: ../../library/sys.rst:1402
msgid ""
"A dictionary acting as a cache for :term:`finder` objects. The keys are "
"paths that have been passed to :data:`sys.path_hooks` and the values are "
"the finders that are found. If a path is a valid file system path but no "
"finder is found on :data:`sys.path_hooks` then ``None`` is stored."
msgstr ""
":term:`파인더 <finder>` 객체의 캐시 역할을 하는 딕셔너리. 키는 :data:`sys.path_hooks`\\에 전달된"
" 경로이며 값은 찾은 파인더입니다. 경로가 유효한 파일 시스템 경로이지만 :data:`sys.path_hooks`\\에 파인더가 "
"없으면 ``None``\\이 저장됩니다."

#: ../../library/sys.rst:1413
msgid "A string containing a platform identifier. Known values are:"
msgstr ""

#: ../../library/sys.rst:1416
msgid "System"
msgstr "시스템"

#: ../../library/sys.rst:1416
msgid "``platform`` value"
msgstr "``platform`` 값"

#: ../../library/sys.rst:1418
msgid "AIX"
msgstr "AIX"

#: ../../library/sys.rst:1418
msgid "``'aix'``"
msgstr "``'aix'``"

#: ../../library/sys.rst:1419
msgid "Android"
msgstr ""

#: ../../library/sys.rst:1419
#, fuzzy
msgid "``'android'``"
msgstr "``'aix'``"

#: ../../library/sys.rst:1420
msgid "Emscripten"
msgstr ""

#: ../../library/sys.rst:1420
#, fuzzy
msgid "``'emscripten'``"
msgstr "``'exception'``"

#: ../../library/sys.rst:1421
#, fuzzy
msgid "iOS"
msgstr "윈도우"

#: ../../library/sys.rst:1421
#, fuzzy
msgid "``'ios'``"
msgstr "``'aix'``"

#: ../../library/sys.rst:1422
msgid "Linux"
msgstr "리눅스"

#: ../../library/sys.rst:1422
msgid "``'linux'``"
msgstr "``'linux'``"

#: ../../library/sys.rst:1423
msgid "macOS"
msgstr "맥 OS"

#: ../../library/sys.rst:1423
msgid "``'darwin'``"
msgstr "``'darwin'``"

#: ../../library/sys.rst:1424
msgid "Windows"
msgstr "윈도우"

#: ../../library/sys.rst:1424
msgid "``'win32'``"
msgstr "``'win32'``"

#: ../../library/sys.rst:1425
msgid "Windows/Cygwin"
msgstr "윈도우/Cygwin"

#: ../../library/sys.rst:1425
msgid "``'cygwin'``"
msgstr "``'cygwin'``"

#: ../../library/sys.rst:1426
msgid "WASI"
msgstr ""

#: ../../library/sys.rst:1426
#, fuzzy
msgid "``'wasi'``"
msgstr "``'aix'``"

#: ../../library/sys.rst:1429
#, fuzzy
msgid ""
"On Unix systems not listed in the table, the value is the lowercased OS "
"name as returned by ``uname -s``, with the first part of the version as "
"returned by ``uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, "
"*at the time when Python was built*.  Unless you want to test for a "
"specific system version, it is therefore recommended to use the following"
" idiom::"
msgstr ""
"리눅스 및 AIX를 제외한 유닉스 시스템에서, *파이썬이 빌드될 때* ``uname -s``\\에 의해 반환되는 소문자 OS 이름에"
" ``uname -r``\\에 의해 반환되는 버전의 첫 번째 부분을 덧붙인 것입니다, 예를 들어 ``'sunos5'``\\나 "
"``'freebsd8'``. 특정 시스템 버전을 테스트하려는 것이 아닌 한, 다음 관용구를 사용하는 것이 좋습니다::"

#: ../../library/sys.rst:1435
msgid ""
"if sys.platform.startswith('freebsd'):\n"
"    # FreeBSD-specific code here..."
msgstr ""

#: ../../library/sys.rst:1438
#, fuzzy
msgid ""
"On Linux, :data:`sys.platform` doesn't contain the major version anymore."
" It is always ``'linux'``, instead of ``'linux2'`` or ``'linux3'``."
msgstr ""
"리눅스에서, :attr:`sys.platform`\\은 더는 주 버전을 포함하지 않습니다. ``'linux2'``\\나 "
"``'linux3'`` 대신, 항상 ``'linux'``\\입니다. 이전 파이썬 버전은 버전 번호를 포함하기 때문에, 항상 위에 "
"제시된 ``startswith`` 관용구를 사용하는 것이 좋습니다."

#: ../../library/sys.rst:1442
#, fuzzy
msgid ""
"On AIX, :data:`sys.platform` doesn't contain the major version anymore. "
"It is always ``'aix'``, instead of ``'aix5'`` or ``'aix7'``."
msgstr ""
"AIX에서, :attr:`sys.platform`\\은 더는 주 버전을 포함하지 않습니다. ``'aix5'``\\나 "
"``'aix7'`` 대신, 항상 ``'aix'``\\입니다. 이전 파이썬 버전은 버전 번호를 포함하기 때문에, 항상 위에 제시된 "
"``startswith`` 관용구를 사용하는 것이 좋습니다."

#: ../../library/sys.rst:1446
msgid ""
"On Android, :data:`sys.platform` now returns ``'android'`` rather than "
"``'linux'``."
msgstr ""

#: ../../library/sys.rst:1452
#, fuzzy
msgid ""
":data:`os.name` has a coarser granularity.  :func:`os.uname` gives "
"system-dependent version information."
msgstr ":attr:`os.name`\\은 덜 세분되어 있습니다. :func:`os.uname`\\은 시스템 종속 버전 정보를 제공합니다."

#: ../../library/sys.rst:1455
msgid ""
"The :mod:`platform` module provides detailed checks for the system's "
"identity."
msgstr ":mod:`platform` 모듈은 시스템 식별자에 대한 상세한 검사를 제공합니다."

#: ../../library/sys.rst:1461
msgid ""
"Name of the platform-specific library directory. It is used to build the "
"path of standard library and the paths of installed extension modules."
msgstr "플랫폼별 라이브러리 디렉터리의 이름. 표준 라이브러리의 경로와 설치된 확장 모듈들의 경로를 빌드하는 데 사용됩니다."

#: ../../library/sys.rst:1464
msgid ""
"It is equal to ``\"lib\"`` on most platforms. On Fedora and SuSE, it is "
"equal to ``\"lib64\"`` on 64-bit platforms which gives the following "
"``sys.path`` paths (where ``X.Y`` is the Python ``major.minor`` version):"
msgstr ""
"대부분의 플랫폼에서 ``\"lib\"``\\와 같습니다. Fedora와 SuSE에서는, 64비트 플랫폼에서 "
"``\"lib64\"``\\와 같으며 다음과 같은 ``sys.path`` 경로를 제공합니다 (``X.Y``\\는 파이썬 "
"``major.minor`` 버전):"

#: ../../library/sys.rst:1468
msgid ""
"``/usr/lib64/pythonX.Y/``: Standard library (like ``os.py`` of the "
":mod:`os` module)"
msgstr "``/usr/lib64/pythonX.Y/``: 표준 라이브러리 (:mod:`os` 모듈의 ``os.py``\\와 같은)"

#: ../../library/sys.rst:1470
msgid ""
"``/usr/lib64/pythonX.Y/lib-dynload/``: C extension modules of the "
"standard library (like the :mod:`errno` module, the exact filename is "
"platform specific)"
msgstr ""
"``/usr/lib64/pythonX.Y/lib-dynload/``: 표준 라이브러리의 C 확장 모듈 (:mod:`errno` "
"모듈과 같은, 정확한 파일 이름은 플랫폼에 따라 다릅니다)"

#: ../../library/sys.rst:1473
msgid ""
"``/usr/lib/pythonX.Y/site-packages/`` (always use ``lib``, not "
":data:`sys.platlibdir`): Third-party modules"
msgstr ""
"``/usr/lib/pythonX.Y/site-packages/`` (항상 ``lib``\\를 사용합니다, "
":data:`sys.platlibdir`\\이 아닙니다): 제삼자 모듈"

#: ../../library/sys.rst:1475
msgid ""
"``/usr/lib64/pythonX.Y/site-packages/``: C extension modules of third-"
"party packages"
msgstr "``/usr/lib64/pythonX.Y/site-packages/``: 제삼자 패키지의 C 확장 모듈"

#: ../../library/sys.rst:1483
#, fuzzy, python-brace-format
msgid ""
"A string giving the site-specific directory prefix where the platform "
"independent Python files are installed; on Unix, the default is "
":file:`/usr/local`. This can be set at build time with the "
":option:`--prefix` argument to the :program:`configure` script.  See "
":ref:`installation_paths` for derived paths."
msgstr ""
"플랫폼 독립적인 파이썬 파일이 설치되는 사이트별 디렉터리 접두사를 제공하는 문자열; 기본적으로 이것은 문자열 "
"``'/usr/local'``\\입니다. :program:`configure` 스크립트에 대한 ``--prefix`` 인자를 "
"사용하여 빌드 시 설정할 수 있습니다. 파이썬 라이브러리 모듈의 메인 컬렉션은 "
":file:`{prefix}/lib/python{X.Y}` 디렉터리에 설치되는 반면 플랫폼 독립 헤더 "
"파일(:file:`pyconfig.h`\\를 제외한 모든 것)은 "
":file:`{prefix}/include/python{X.Y}`\\에 저장됩니다, 여기서 *X.Y*\\는 파이썬의 버전 "
"번호입니다, 예를 들어 ``3.2``."

#: ../../library/sys.rst:1489
msgid ""
"If a :ref:`virtual environment <venv-def>` is in effect, this value will "
"be changed in ``site.py`` to point to the virtual environment. The value "
"for the Python installation will still be available, via "
":data:`base_prefix`."
msgstr ""
":ref:`가상 환경 <venv-def>`\\이 유효하면, 이 값은 ``site.py``\\에서 가상 환경을 가리키도록 변경됩니다."
" 파이썬 설치 값은 :data:`base_prefix`\\를 통해 계속 사용할 수 있습니다."

#: ../../library/sys.rst:1504
msgid ""
"Strings specifying the primary and secondary prompt of the interpreter.  "
"These are only defined if the interpreter is in interactive mode.  Their "
"initial values in this case are ``'>>> '`` and ``'... '``.  If a non-"
"string object is assigned to either variable, its :func:`str` is re-"
"evaluated each time the interpreter prepares to read a new interactive "
"command; this can be used to implement a dynamic prompt."
msgstr ""
"인터프리터의 기본과 보조 프롬프트를 지정하는 문자열. 인터프리터가 대화형 모드일 때만 정의됩니다. 이 경우 초깃값은 ``'>>> "
"'``\\과 ``'... '``\\입니다. 문자열이 아닌 객체가 어느 변수에라도 지정되면, 인터프리터가 새 대화식 명령을 읽을 "
"준비를 할 때마다 그 객체의 :func:`str`\\이 재평가됩니다; 동적 프롬프트를 구현하는 데 사용할 수 있습니다."

#: ../../library/sys.rst:1514
#, fuzzy, python-brace-format
msgid ""
"Set the flags used by the interpreter for :c:func:`dlopen` calls, such as"
" when the interpreter loads extension modules.  Among other things, this "
"will enable a lazy resolving of symbols when importing a module, if "
"called as ``sys.setdlopenflags(0)``.  To share symbols across extension "
"modules, call as ``sys.setdlopenflags(os.RTLD_GLOBAL)``.  Symbolic names "
"for the flag values can be found in the :mod:`os` module "
"(:samp:`RTLD_{xxx}` constants, e.g. :const:`os.RTLD_LAZY`)."
msgstr ""
"인터프리터가 확장 모듈을 로드할 때와 같이 :c:func:`dlopen` 호출에 인터프리터가 사용하는 플래그를 설정합니다. "
"무엇보다도, 이것은 ``sys.setdlopenflags(0)``\\라고 호출하는 경우, 모듈을 임포트 할 때 심볼의 지연된 "
"결정(lazy resolving)을 활성화합니다. 확장 모듈 간에 심볼을 공유하려면, "
"``sys.setdlopenflags(os.RTLD_GLOBAL)``\\로 호출하십시오. 플래그 값의 기호 이름은 :mod:`os`"
" 모듈에서 찾을 수 있습니다 (``RTLD_xxx`` 상수, 예를 들어 :data:`os.RTLD_LAZY`)."

#: ../../library/sys.rst:1526
msgid ""
"Set the :ref:`integer string conversion length limitation "
"<int_max_str_digits>` used by this interpreter. See also "
":func:`get_int_max_str_digits`."
msgstr ""

#: ../../library/sys.rst:1538
msgid ""
"Set the system's profile function, which allows you to implement a Python"
" source code profiler in Python.  See chapter :ref:`profile` for more "
"information on the Python profiler.  The system's profile function is "
"called similarly to the system's trace function (see :func:`settrace`), "
"but it is called with different events, for example it isn't called for "
"each executed line of code (only on call and return, but the return event"
" is reported even when an exception has been set). The function is "
"thread-specific, but there is no way for the profiler to know about "
"context switches between threads, so it does not make sense to use this "
"in the presence of multiple threads. Also, its return value is not used, "
"so it can simply return ``None``.  Error in the profile function will "
"cause itself unset."
msgstr ""
"시스템의 프로파일 함수를 설정합니다. 파이썬에서 파이썬 소스 코드 프로파일러를 구현할 수 있도록 합니다. 파이썬 프로파일러에 대한 "
"자세한 내용은 :ref:`profile` 장을 참조하십시오. 시스템의 프로파일 함수는 시스템의 추적 "
"함수(:func:`settrace`\\를 참조하십시오)와 유사하게 호출되지만, 다른 이벤트로 호출됩니다, 예를 들어 이 함수는 "
"실행되는 줄마다 호출되지 않습니다 (오직 호출과 반환에서만 호출됩니다만, 예외가 설정되었을 때도 반환 이벤트가 보고됩니다). 이 "
"함수는 스레드로 한정되지만, 프로파일러가 스레드 간의 컨텍스트 전환에 대해 알 방법이 없어서, 여러 스레드가 있을 때 이를 사용하는"
" 것은 의미가 없습니다. 또한, 반환 값이 사용되지 않아서, 단순히 ``None``\\을 반환할 수 있습니다. 프로파일 함수에서 "
"에러가 발생하면 설정이 해제됩니다."

#: ../../library/sys.rst:1550
msgid ""
"The same tracing mechanism is used for :func:`!setprofile` as "
":func:`settrace`. To trace calls with :func:`!setprofile` inside a "
"tracing function (e.g. in a debugger breakpoint), see "
":func:`call_tracing`."
msgstr ""

#: ../../library/sys.rst:1554
msgid ""
"Profile functions should have three arguments: *frame*, *event*, and "
"*arg*. *frame* is the current stack frame.  *event* is a string: "
"``'call'``, ``'return'``, ``'c_call'``, ``'c_return'``, or "
"``'c_exception'``. *arg* depends on the event type."
msgstr ""
"프로파일 함수에는 세 가지 인자가 있습니다: *frame*, *event* 및 *arg*. *frame*\\은 현재 스택 "
"프레임입니다. *event*\\는 문자열입니다: ``'call'``, ``'return'``, ``'c_call'``, "
"``'c_return'`` 또는 ``'c_exception'``. *arg*\\는 이벤트 유형에 따라 다릅니다."

#: ../../library/sys.rst:1559 ../../library/sys.rst:1646
msgid "The events have the following meaning:"
msgstr "이벤트의 의미는 다음과 같습니다:"

#: ../../library/sys.rst:1561 ../../library/sys.rst:1648
msgid "``'call'``"
msgstr "``'call'``"

#: ../../library/sys.rst:1562
msgid ""
"A function is called (or some other code block entered).  The profile "
"function is called; *arg* is ``None``."
msgstr "함수가 호출되었습니다 (또는 다른 코드 블록에 진입했습니다). 프로파일 함수가 호출됩니다; *arg*\\는 ``None``\\입니다."

#: ../../library/sys.rst:1565 ../../library/sys.rst:1663
msgid "``'return'``"
msgstr "``'return'``"

#: ../../library/sys.rst:1566
msgid ""
"A function (or other code block) is about to return.  The profile "
"function is called; *arg* is the value that will be returned, or ``None``"
" if the event is caused by an exception being raised."
msgstr ""
"함수(또는 다른 코드 블록)가 반환하려고 합니다. 프로파일 함수가 호출됩니다; *arg*\\는 반환될 값이거나, 예외가 발생하여 "
"이벤트가 발생한 경우는 ``None``\\입니다."

#: ../../library/sys.rst:1570
msgid "``'c_call'``"
msgstr "``'c_call'``"

#: ../../library/sys.rst:1571
msgid ""
"A C function is about to be called.  This may be an extension function or"
" a built-in.  *arg* is the C function object."
msgstr "C 함수를 호출하려고 합니다. 확장 함수나 내장일 수 있습니다. *arg*\\는 C 함수 객체입니다."

#: ../../library/sys.rst:1574
msgid "``'c_return'``"
msgstr "``'c_return'``"

#: ../../library/sys.rst:1575
msgid "A C function has returned. *arg* is the C function object."
msgstr "C 함수가 반환했습니다. *arg*\\는 C 함수 객체입니다."

#: ../../library/sys.rst:1577
msgid "``'c_exception'``"
msgstr "``'c_exception'``"

#: ../../library/sys.rst:1578
msgid "A C function has raised an exception.  *arg* is the C function object."
msgstr "C 함수에서 예외가 발생했습니다. *arg*\\는 C 함수 객체입니다."

#: ../../library/sys.rst:1580
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.setprofile`` with no "
"arguments."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys.setprofile``\\을 발생시킵니다."

#: ../../library/sys.rst:1585
msgid ""
"Set the maximum depth of the Python interpreter stack to *limit*.  This "
"limit prevents infinite recursion from causing an overflow of the C stack"
" and crashing Python."
msgstr ""
"파이썬 인터프리터 스택의 최대 깊이를 *limit*\\로 설정합니다. 이 제한은 무한 재귀로 인해 C 스택의 오버플로가 발생하고 "
"파이썬이 충돌하는 것을 방지합니다."

#: ../../library/sys.rst:1589
msgid ""
"The highest possible limit is platform-dependent.  A user may need to set"
" the limit higher when they have a program that requires deep recursion "
"and a platform that supports a higher limit.  This should be done with "
"care, because a too-high limit can lead to a crash."
msgstr ""
"가능한 최대 제한은 플랫폼에 따라 다릅니다. 사용자는 깊은 재귀가 필요한 프로그램과 더 높은 제한을 지원하는 플랫폼이 있을 때 "
"제한을 더 높게 설정해야 할 수 있습니다. 제한이 너무 높으면 충돌이 발생할 수 있기 때문에, 주의해서 사용해야 합니다."

#: ../../library/sys.rst:1594
msgid ""
"If the new limit is too low at the current recursion depth, a "
":exc:`RecursionError` exception is raised."
msgstr "현재 재귀 깊이에서 새 제한이 너무 낮으면 :exc:`RecursionError` 예외가 발생합니다."

#: ../../library/sys.rst:1597
msgid ""
"A :exc:`RecursionError` exception is now raised if the new limit is too "
"low at the current recursion depth."
msgstr "현재 재귀 깊이에서 새 한계가 너무 낮으면 이제 :exc:`RecursionError` 예외가 발생합니다."

#: ../../library/sys.rst:1604
msgid ""
"Set the interpreter's thread switch interval (in seconds).  This "
"floating-point value determines the ideal duration of the \"timeslices\" "
"allocated to concurrently running Python threads.  Please note that the "
"actual value can be higher, especially if long-running internal functions"
" or methods are used.  Also, which thread becomes scheduled at the end of"
" the interval is the operating system's decision.  The interpreter "
"doesn't have its own scheduler."
msgstr ""
"인터프리터의 스레드 전환 간격을 (초 단위로) 설정합니다. 이 부동 소수점 값은 동시에 실행 중인 파이썬 스레드에 할당된 \"시 "
"분할(timeslices)\"의 이상적인 지속 시간을 결정합니다. 특히 오래 실행되는 내부 함수나 메서드가 사용된다면, 실제 값은 "
"더 클 수 있음에 유의하십시오. 또한, 간격이 끝날 때 어떤 스레드가 예약되는지는 운영 체제의 결정입니다. 인터프리터에는 자체 "
"스케줄러가 없습니다."

#: ../../library/sys.rst:1621
msgid ""
"Set the system's trace function, which allows you to implement a Python "
"source code debugger in Python.  The function is thread-specific; for a "
"debugger to support multiple threads, it must register a trace function "
"using :func:`settrace` for each thread being debugged or use "
":func:`threading.settrace`."
msgstr ""
"시스템의 추적 함수를 설정합니다. 파이썬에서 파이썬 소스 코드 디버거를 구현할 수 있도록 합니다. 이 함수는 스레드로 한정됩니다; "
"디버거가 여러 스레드를 지원하려면, 디버깅 중인 각 스레드에 대해 :func:`settrace`\\를 사용하여 추적 함수를 "
"등록하거나, :func:`threading.settrace`\\를 사용해야 합니다."

#: ../../library/sys.rst:1626
msgid ""
"Trace functions should have three arguments: *frame*, *event*, and *arg*."
" *frame* is the current stack frame.  *event* is a string: ``'call'``, "
"``'line'``, ``'return'``, ``'exception'`` or ``'opcode'``.  *arg* depends"
" on the event type."
msgstr ""
"추적 함수에는 세 개의 인자가 있습니다: *frame*, *event* 및 *arg*. *frame*\\은 현재 스택 프레임입니다."
" *event*\\는 문자열입니다: ``'call'``, ``'line'``, ``'return'``, ``'exception'``"
" 또는 ``'opcode'``. *arg*\\는 이벤트 유형에 따라 다릅니다."

#: ../../library/sys.rst:1631
msgid ""
"The trace function is invoked (with *event* set to ``'call'``) whenever a"
" new local scope is entered; it should return a reference to a local "
"trace function to be used for the new scope, or ``None`` if the scope "
"shouldn't be traced."
msgstr ""
"추적 함수는 새로운 로컬 스코프에 진입할 때마다 호출됩니다 (*event*\\가 ``'call'``\\로 설정됩니다); 새 "
"스코프에서 사용될 지역 추적 함수(local trace function)에 대한 참조를 반환하거나, 스코프를 추적하지 않아야 하면 "
"``None``\\을 반환해야 합니다."

#: ../../library/sys.rst:1636
#, fuzzy
msgid ""
"The local trace function should return a reference to itself, or to "
"another function which would then be used as the local trace function for"
" the scope."
msgstr ""
"지역 추적 함수는 자기 자신(또는 해당 스코프의 추가 추적을 위한 다른 함수)에 대한 참조를 반환하거나, 해당 범위에서 추적을 "
"끄려면 ``None``\\을 반환해야 합니다."

#: ../../library/sys.rst:1639
msgid ""
"If there is any error occurred in the trace function, it will be unset, "
"just like ``settrace(None)`` is called."
msgstr "추적 함수에서 에러가 발생하면, ``settrace(None)``\\이 호출되는 것처럼 설정이 해제됩니다."

#: ../../library/sys.rst:1643
msgid ""
"Tracing is disabled while calling the trace function (e.g. a function set"
" by :func:`!settrace`). For recursive tracing see :func:`call_tracing`."
msgstr ""

#: ../../library/sys.rst:1649
msgid ""
"A function is called (or some other code block entered).  The global "
"trace function is called; *arg* is ``None``; the return value specifies "
"the local trace function."
msgstr ""
"함수가 호출되었습니다 (또는 다른 코드 블록에 진입했습니다). 전역 추적 함수가 호출됩니다; *arg*\\는 "
"``None``\\입니다; 반환 값은 지역 추적 함수를 지정합니다."

#: ../../library/sys.rst:1653
msgid "``'line'``"
msgstr "``'line'``"

#: ../../library/sys.rst:1654
#, fuzzy
msgid ""
"The interpreter is about to execute a new line of code or re-execute the "
"condition of a loop.  The local trace function is called; *arg* is "
"``None``; the return value specifies the new local trace function.  See "
":file:`Objects/lnotab_notes.txt` for a detailed explanation of how this "
"works. Per-line events may be disabled for a frame by setting "
":attr:`~frame.f_trace_lines` to :const:`False` on that :ref:`frame "
"<frame-objects>`."
msgstr ""
"인터프리터가 새로운 코드 줄을 실행하거나 루프의 조건을 다시 실행하려고 합니다. 지역 추적 함수가 호출됩니다; *arg*\\는 "
"``None``\\입니다; 반환 값은 새로운 지역 추적 함수를 지정합니다. 작동 방식에 대한 자세한 설명은 "
":file:`Objects/lnotab_notes.txt`\\를 참조하십시오. 해당 프레임에서 "
":attr:`f_trace_lines`\\를 :const:`False`\\로 설정하여 줄별 이벤트를 비활성화 할 수 있습니다."

#: ../../library/sys.rst:1664
msgid ""
"A function (or other code block) is about to return.  The local trace "
"function is called; *arg* is the value that will be returned, or ``None``"
" if the event is caused by an exception being raised.  The trace "
"function's return value is ignored."
msgstr ""
"함수(또는 다른 코드 블록)가 반환하려고 합니다. 지역 추적 함수가 호출됩니다; *arg*\\는 반환될 값이거나, 예외가 발생하여 "
"이벤트가 발생한 경우는 ``None``\\입니다. 추적 함수의 반환 값은 무시됩니다."

#: ../../library/sys.rst:1669
msgid "``'exception'``"
msgstr "``'exception'``"

#: ../../library/sys.rst:1670
msgid ""
"An exception has occurred.  The local trace function is called; *arg* is "
"a tuple ``(exception, value, traceback)``; the return value specifies the"
" new local trace function."
msgstr ""
"예외가 발생했습니다. 지역 추적 함수가 호출됩니다; *arg*\\는 튜플 ``(exception, value, "
"traceback)``\\입니다; 반환 값은 새로운 지역 추적 함수를 지정합니다."

#: ../../library/sys.rst:1674
msgid "``'opcode'``"
msgstr "``'opcode'``"

#: ../../library/sys.rst:1675
#, fuzzy
msgid ""
"The interpreter is about to execute a new opcode (see :mod:`dis` for "
"opcode details).  The local trace function is called; *arg* is ``None``; "
"the return value specifies the new local trace function. Per-opcode "
"events are not emitted by default: they must be explicitly requested by "
"setting :attr:`~frame.f_trace_opcodes` to :const:`True` on the "
":ref:`frame <frame-objects>`."
msgstr ""
"인터프리터가 새 옵코드(opcode)를 실행하려고 합니다 (opcode 세부 사항은 :mod:`dis`\\를 참조하십시오). 지역 "
"추적 함수가 호출됩니다; *arg*\\는 ``None``\\입니다; 반환 값은 새로운 지역 추적 함수를 지정합니다. 옵코드 별 "
"이벤트는 기본적으로 발생하지 않습니다; 해당 프레임에서 :attr:`f_trace_opcodes`\\를 "
":const:`True`\\로 설정하여 명시적으로 요청해야 합니다."

#: ../../library/sys.rst:1682
msgid ""
"Note that as an exception is propagated down the chain of callers, an "
"``'exception'`` event is generated at each level."
msgstr "호출자 체인을 따라 예외가 전파됨에 따라, 각 수준에서 ``'exception'`` 이벤트가 생성됨에 유의하십시오."

#: ../../library/sys.rst:1685
msgid ""
"For more fine-grained usage, it's possible to set a trace function by "
"assigning ``frame.f_trace = tracefunc`` explicitly, rather than relying "
"on it being set indirectly via the return value from an already installed"
" trace function. This is also required for activating the trace function "
"on the current frame, which :func:`settrace` doesn't do. Note that in "
"order for this to work, a global tracing function must have been "
"installed with :func:`settrace` in order to enable the runtime tracing "
"machinery, but it doesn't need to be the same tracing function (e.g. it "
"could be a low overhead tracing function that simply returns ``None`` to "
"disable itself immediately on each frame)."
msgstr ""
"더 세분된 사용을 위해, 이미 설치된 추적 함수의 반환 값을 통해 간접적으로 설정되는 것에 의존하는 대신, "
"``frame.f_trace = tracefunc``\\를 명시적으로 대입하여 추적 함수를 설정할 수 있습니다. 이것은 현재 "
"프레임에서 추적 함수를 활성화하는 데에도 필요한데, :func:`settrace`\\가 하지 않는 일입니다. 이것이 작동하려면 실행"
" 시간 추적 장치를 활성화하기 위해 전역 추적 함수가 :func:`settrace`\\로 설치되어 있어야 하지만, 같은 추적 함수 "
"일 필요는 없음에 유의하십시오 (예를 들어, 각 프레임에서 즉시 비활성화되도록 단순히 ``None``\\을 반환하는 오버헤드가 낮은"
" 추적 함수일 수 있습니다)."

#: ../../library/sys.rst:1696
msgid "For more information on code and frame objects, refer to :ref:`types`."
msgstr "코드와 프레임 객체에 대한 자세한 내용은 :ref:`types`\\를 참조하십시오."

#: ../../library/sys.rst:1698
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.settrace`` with no "
"arguments."
msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys.settrace``\\를 발생시킵니다."

#: ../../library/sys.rst:1702
msgid ""
"The :func:`settrace` function is intended only for implementing "
"debuggers, profilers, coverage tools and the like.  Its behavior is part "
"of the implementation platform, rather than part of the language "
"definition, and thus may not be available in all Python implementations."
msgstr ""
":func:`settrace` 함수는 오직 디버거, 프로파일러, 커버리지(coverage) 도구 등을 구현하기 위한 것입니다. 그 "
"동작은 언어 정의의 일부라기보다는 구현 플랫폼의 일부라서, 모든 파이썬 구현에서 사용 가능한 것은 아닙니다."

#: ../../library/sys.rst:1709
#, fuzzy
msgid ""
"``'opcode'`` event type added; :attr:`~frame.f_trace_lines` and "
":attr:`~frame.f_trace_opcodes` attributes added to frames"
msgstr ""
"``'opcode'`` 이벤트 유형이 추가되었습니다; :attr:`f_trace_lines`\\와 "
":attr:`f_trace_opcodes` 어트리뷰트가 프레임에 추가되었습니다"

#: ../../library/sys.rst:1714
msgid ""
"Accepts two optional keyword arguments which are callables that accept an"
" :term:`asynchronous generator iterator` as an argument. The *firstiter* "
"callable will be called when an asynchronous generator is iterated for "
"the first time. The *finalizer* will be called when an asynchronous "
"generator is about to be garbage collected."
msgstr ""
"두 개의 선택적 키워드 인자를 받아들이는데, 모두 :term:`비동기 제너레이터 이터레이터 <asynchronous "
"generator iterator>`\\를 인자로 받아들이는 콜러블입니다. 비동기 제너레이터가 처음으로 이터레이트 될 때 "
"*firstiter* 콜러블이 호출됩니다. 비동기 제너레이터가 가비지 수거될 때 *finalizer*\\가 호출됩니다."

#: ../../library/sys.rst:1720
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``sys.set_asyncgen_hooks_firstiter`` with no arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트 <auditing>` ``sys.set_asyncgen_hooks_firstiter``\\를 "
"발생시킵니다."

#: ../../library/sys.rst:1722
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``sys.set_asyncgen_hooks_finalizer`` with no arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트 <auditing>` ``sys.set_asyncgen_hooks_finalizer``\\를 "
"발생시킵니다."

#: ../../library/sys.rst:1724
msgid ""
"Two auditing events are raised because the underlying API consists of two"
" calls, each of which must raise its own event."
msgstr "하부 API는 두 개의 호출로 구성되기 때문에, 두 개의 감사 이벤트가 발생합니다, 각각은 자체 이벤트를 발생시켜야 합니다."

#: ../../library/sys.rst:1727
msgid ""
"See :pep:`525` for more details, and for a reference example of a "
"*finalizer* method see the implementation of "
"``asyncio.Loop.shutdown_asyncgens`` in "
":source:`Lib/asyncio/base_events.py`"
msgstr ""
"자세한 내용은 :pep:`525`\\를 참조하고, *finalizer* 메서드의 참조 예제는 "
":source:`Lib/asyncio/base_events.py`\\의 "
"``asyncio.Loop.shutdown_asyncgens`` 구현을 참조하십시오."

#: ../../library/sys.rst:1739
#, fuzzy
msgid ""
"Allows enabling or disabling coroutine origin tracking. When enabled, the"
" ``cr_origin`` attribute on coroutine objects will contain a tuple of "
"(filename, line number, function name) tuples describing the traceback "
"where the coroutine object was created, with the most recent call first. "
"When disabled, ``cr_origin`` will be ``None``."
msgstr ""
"코루틴 원점 추적을 활성화하거나 비활성화하도록 합니다. 활성화하면, 코루틴 객체의 ``cr_origin`` 어트리뷰트에 코루틴 "
"객체가 만들어진 트레이스백을 설명하는 (파일명, 줄 번호, 함수 이름) 튜플이 포함됩니다. 가장 최근의 호출이 먼저 옵니다. "
"비활성화하면 ``cr_origin``\\은 None입니다."

#: ../../library/sys.rst:1746
msgid ""
"To enable, pass a *depth* value greater than zero; this sets the number "
"of frames whose information will be captured. To disable, pass set "
"*depth* to zero."
msgstr ""
"활성화하려면, 0보다 큰 *depth* 값을 전달하십시오; 정보를 캡처할 프레임 수를 설정합니다. 비활성화하려면, "
"*depth*\\를 0으로 전달하십시오."

#: ../../library/sys.rst:1750
msgid "This setting is thread-specific."
msgstr "이 설정은 스레드에 한정됩니다."

#: ../../library/sys.rst:1760
msgid ""
"Activate the stack profiler trampoline *backend*. The only supported "
"backend is ``\"perf\"``."
msgstr ""

#: ../../library/sys.rst:1769
msgid ":ref:`perf_profiling`"
msgstr ""

#: ../../library/sys.rst:1770
msgid "https://perf.wiki.kernel.org"
msgstr ""

#: ../../library/sys.rst:1774
msgid "Deactivate the current stack profiler trampoline backend."
msgstr ""

#: ../../library/sys.rst:1776
msgid "If no stack profiler is activated, this function has no effect."
msgstr ""

#: ../../library/sys.rst:1784
msgid "Return ``True`` if a stack profiler trampoline is active."
msgstr ""

#: ../../library/sys.rst:1792
#, fuzzy
msgid ""
"Changes the :term:`filesystem encoding and error handler` to 'mbcs' and "
"'replace' respectively, for consistency with versions of Python prior to "
"3.6."
msgstr ""
"3.6 이전의 파이썬 버전과 일관성을 유지하기 위해, 기본 파일 시스템 인코딩과 에러 모드를 각각 'mbcs'와 'replace'로"
" 변경합니다."

#: ../../library/sys.rst:1796
msgid ""
"This is equivalent to defining the "
":envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment variable before "
"launching Python."
msgstr ""
"이것은 파이썬을 시작하기 전에 :envvar:`PYTHONLEGACYWINDOWSFSENCODING` 환경 변수를 정의하는 것과 "
"동등합니다."

#: ../../library/sys.rst:1799
msgid ""
"See also :func:`sys.getfilesystemencoding` and "
":func:`sys.getfilesystemencodeerrors`."
msgstr ""

#: ../../library/sys.rst:1805
msgid ""
"Changing the filesystem encoding after Python startup is risky because "
"the old fsencoding or paths encoded by the old fsencoding may be cached "
"somewhere. Use :envvar:`PYTHONLEGACYWINDOWSFSENCODING` instead."
msgstr ""

#: ../../library/sys.rst:1809
msgid "See :pep:`529` for more details."
msgstr "자세한 내용은 :pep:`529`\\를 참조하십시오."

#: ../../library/sys.rst:1812
msgid "Use :envvar:`PYTHONLEGACYWINDOWSFSENCODING` instead."
msgstr ""

#: ../../library/sys.rst:1819
msgid ""
":term:`File objects <file object>` used by the interpreter for standard "
"input, output and errors:"
msgstr "인터프리터가 표준 입력, 출력 및 에러에 사용하는 :term:`파일 객체 <file object>`:"

#: ../../library/sys.rst:1822
msgid ""
"``stdin`` is used for all interactive input (including calls to "
":func:`input`);"
msgstr "``stdin``\\는 모든 대화식 입력에 사용됩니다 (:func:`input` 호출을 포함합니다);"

#: ../../library/sys.rst:1824
msgid ""
"``stdout`` is used for the output of :func:`print` and :term:`expression`"
" statements and for the prompts of :func:`input`;"
msgstr ""
"``stdout``\\은 :func:`print`\\와 :term:`표현식 <expression>` 문장의 출력과 "
":func:`input`\\의 프롬프트에 사용됩니다;"

#: ../../library/sys.rst:1826
msgid "The interpreter's own prompts and its error messages go to ``stderr``."
msgstr "인터프리터 자신의 프롬프트와 에러 메시지는 ``stderr``\\로 갑니다."

#: ../../library/sys.rst:1828
msgid ""
"These streams are regular :term:`text files <text file>` like those "
"returned by the :func:`open` function.  Their parameters are chosen as "
"follows:"
msgstr ""
"이 스트림은 :func:`open` 함수에 의해 반환되는 것과 같은 일반적인 :term:`텍스트 파일 <text "
"file>`\\입니다. 매개 변수는 다음과 같이 선택됩니다:"

#: ../../library/sys.rst:1832
msgid ""
"The encoding and error handling are is initialized from "
":c:member:`PyConfig.stdio_encoding` and "
":c:member:`PyConfig.stdio_errors`."
msgstr ""

#: ../../library/sys.rst:1835
#, fuzzy
msgid ""
"On Windows, UTF-8 is used for the console device.  Non-character devices "
"such as disk files and pipes use the system locale encoding (i.e. the "
"ANSI codepage).  Non-console character devices such as NUL (i.e. where "
"``isatty()`` returns ``True``) use the value of the console input and "
"output codepages at startup, respectively for stdin and stdout/stderr. "
"This defaults to the system :term:`locale encoding` if the process is not"
" initially attached to a console."
msgstr ""
"윈도우에서는, 콘솔 장치에 UTF-8이 사용됩니다. 디스크 파일과 파이프와 같은 비문자 장치는 시스템 로케일 인코딩(즉, ANSI "
"코드 페이지)을 사용합니다. NUL(즉, ``isatty()``\\가 ``True``\\를 반환하는)과 같은 비 콘솔 문자 장치는 "
"시작 시에 콘솔 입력과 출력 코드 페이지의 값을 각각 stdin과 stdout/stderr에 사용합니다. 프로세스가 초기에 콘솔에 "
"연결되지 않았으면 시스템 로케일 인코딩이 기본값입니다."

#: ../../library/sys.rst:1844
msgid ""
"The special behaviour of the console can be overridden by setting the "
"environment variable PYTHONLEGACYWINDOWSSTDIO before starting Python. In "
"that case, the console codepages are used as for any other character "
"device."
msgstr ""
"파이썬을 시작하기 전에 환경 변수 PYTHONLEGACYWINDOWSSTDIO를 설정하여 콘솔의 특수 동작을 재정의할 수 있습니다."
" 이 경우, 콘솔 코드 페이지는 다른 모든 문자 장치에서처럼 사용됩니다."

#: ../../library/sys.rst:1849
msgid ""
"Under all platforms, you can override the character encoding by setting "
"the :envvar:`PYTHONIOENCODING` environment variable before starting "
"Python or by using the new :option:`-X` ``utf8`` command line option and "
":envvar:`PYTHONUTF8` environment variable.  However, for the Windows "
"console, this only applies when :envvar:`PYTHONLEGACYWINDOWSSTDIO` is "
"also set."
msgstr ""
"모든 플랫폼에서, 파이썬을 시작하기 전에 :envvar:`PYTHONIOENCODING` 환경 변수를 설정하거나 새로운 "
":option:`-X` ``utf8`` 명령 줄 옵션과 :envvar:`PYTHONUTF8` 환경 변수를 사용하여 문자 인코딩을 "
"재정의할 수 있습니다. 그러나, 윈도우 콘솔의 경우, :envvar:`PYTHONLEGACYWINDOWSSTDIO` 도 설정했을 "
"때만 적용됩니다."

#: ../../library/sys.rst:1856
msgid ""
"When interactive, the ``stdout`` stream is line-buffered. Otherwise, it "
"is block-buffered like regular text files.  The ``stderr`` stream is "
"line-buffered in both cases.  You can make both streams unbuffered by "
"passing the :option:`-u` command-line option or setting the "
":envvar:`PYTHONUNBUFFERED` environment variable."
msgstr ""
"대화형일 때, ``stdout`` 스트림은 줄 버퍼링 됩니다. 그렇지 않으면, 일반 텍스트 파일처럼 블록 버퍼링 됩니다. "
"``stderr`` 스트림은 두 경우 모두 줄 버퍼링 됩니다. :option:`-u` 명령 줄 옵션을 전달하거나 "
":envvar:`PYTHONUNBUFFERED` 환경 변수를 설정하여 두 스트림을 모두 버퍼링하지 않을 수 있습니다."

#: ../../library/sys.rst:1862
msgid "Non-interactive ``stderr`` is now line-buffered instead of fully buffered."
msgstr "비 대화형 ``stderr``\\은 이제 완전히 버퍼링 되는 대신 줄 버퍼링 됩니다."

#: ../../library/sys.rst:1868
msgid ""
"To write or read binary data from/to the standard streams, use the "
"underlying binary :data:`~io.TextIOBase.buffer` object.  For example, to "
"write bytes to :data:`stdout`, use ``sys.stdout.buffer.write(b'abc')``."
msgstr ""
"표준 스트림에서 바이너리 데이터를 읽거나 표준 스트림으로 바이너리 데이터를 쓰려면, 하부 바이너리 "
":data:`~io.TextIOBase.buffer` 객체를 사용하십시오. 예를 들어, 바이트열을 :data:`stdout`\\에 "
"쓰려면, ``sys.stdout.buffer.write(b'abc')``\\를 사용하십시오."

#: ../../library/sys.rst:1872
#, fuzzy
msgid ""
"However, if you are writing a library (and do not control in which "
"context its code will be executed), be aware that the standard streams "
"may be replaced with file-like objects like :class:`io.StringIO` which do"
" not support the :attr:`!buffer` attribute."
msgstr ""
"그러나, 라이브러리를 작성하고 있다면 (그리고 코드가 실행될 문맥을 제어하지 않으면), 표준 스트림은 "
":attr:`~io.BufferedIOBase.buffer` 어트리뷰트를 지원하지 않는 :class:`io.StringIO`\\와 "
"같은 파일류 객체로 대체 될 수 있음을 유의하십시오."

#: ../../library/sys.rst:1882
msgid ""
"These objects contain the original values of ``stdin``, ``stderr`` and "
"``stdout`` at the start of the program.  They are used during "
"finalization, and could be useful to print to the actual standard stream "
"no matter if the ``sys.std*`` object has been redirected."
msgstr ""
"이 객체는 프로그램 시작 시 ``stdin``, ``stderr`` 및 ``stdout``\\의 원래 값을 포함합니다. 이들은 "
"파이널리제이션 중에 사용되며, ``sys.std*`` 객체가 리디렉션 되었는지에 관계없이 실제 표준 스트림으로 인쇄하는 데 유용할 "
"수 있습니다."

#: ../../library/sys.rst:1887
msgid ""
"It can also be used to restore the actual files to known working file "
"objects in case they have been overwritten with a broken object.  "
"However, the preferred way to do this is to explicitly save the previous "
"stream before replacing it, and restore the saved object."
msgstr ""
"또한 잘못된 객체로 덮어쓴 경우 실제 파일을 알려진 작동하는 파일 객체로 복원하는 데 사용할 수 있습니다. 그러나, 이를 수행하기 "
"위해 선호되는 방법은 이전 스트림을 교체하기 전에 명시적으로 저장하고, 저장된 객체를 복원하는 것입니다."

#: ../../library/sys.rst:1893
msgid ""
"Under some conditions ``stdin``, ``stdout`` and ``stderr`` as well as the"
" original values ``__stdin__``, ``__stdout__`` and ``__stderr__`` can be "
"``None``. It is usually the case for Windows GUI apps that aren't "
"connected to a console and Python apps started with :program:`pythonw`."
msgstr ""
"일부 조건에서, ``stdin``, ``stdout`` 및 ``stderr`` 뿐만 아니라 원래 값 ``__stdin__``, "
"``__stdout__`` 및 ``__stderr__``\\은 ``None``\\일 수 있습니다. 보통 콘솔에 연결되지 않은 윈도우"
" GUI 앱과 :program:`pythonw`\\로 시작된 파이썬 앱이 이런 경우입니다."

#: ../../library/sys.rst:1901
msgid "A frozenset of strings containing the names of standard library modules."
msgstr ""

#: ../../library/sys.rst:1903
msgid ""
"It is the same on all platforms. Modules which are not available on some "
"platforms and modules disabled at Python build are also listed. All "
"module kinds are listed: pure Python, built-in, frozen and extension "
"modules. Test modules are excluded."
msgstr ""

#: ../../library/sys.rst:1908
msgid ""
"For packages, only the main package is listed: sub-packages and sub-"
"modules are not listed. For example, the ``email`` package is listed, but"
" the ``email.mime`` sub-package and the ``email.message`` sub-module are "
"not listed."
msgstr ""

#: ../../library/sys.rst:1913
msgid "See also the :data:`sys.builtin_module_names` list."
msgstr ""

#: ../../library/sys.rst:1920
msgid "A :term:`named tuple` holding information about the thread implementation."
msgstr "스레드 구현에 대한 정보를 담은 :term:`네임드 튜플 <named tuple>`."

#: ../../library/sys.rst:1925
#, fuzzy
msgid "The name of the thread implementation:"
msgstr "스레드 구현 이름:"

#: ../../library/sys.rst:1927
#, fuzzy
msgid "``\"nt\"``: Windows threads"
msgstr "``'nt'``: 윈도우 스레드"

#: ../../library/sys.rst:1928
#, fuzzy
msgid "``\"pthread\"``: POSIX threads"
msgstr "``'pthread'``: POSIX 스레드"

#: ../../library/sys.rst:1929
msgid ""
"``\"pthread-stubs\"``: stub POSIX threads (on WebAssembly platforms "
"without threading support)"
msgstr ""

#: ../../library/sys.rst:1931
#, fuzzy
msgid "``\"solaris\"``: Solaris threads"
msgstr "``'solaris'``: 솔라리스 스레드"

#: ../../library/sys.rst:1935
#, fuzzy
msgid "The name of the lock implementation:"
msgstr "록 구현 이름:"

#: ../../library/sys.rst:1937
#, fuzzy
msgid "``\"semaphore\"``: a lock uses a semaphore"
msgstr "``'semaphore'``: 록은 세마포어를 사용합니다"

#: ../../library/sys.rst:1938
#, fuzzy
msgid "``\"mutex+cond\"``: a lock uses a mutex and a condition variable"
msgstr "``'mutex+cond'``: 록은 뮤텍스(mutex)와 조건 변수(condition variable)를 사용합니다"

#: ../../library/sys.rst:1939
msgid "``None`` if this information is unknown"
msgstr "이 정보를 알 수 없으면 ``None``"

#: ../../library/sys.rst:1943
#, fuzzy
msgid ""
"The name and version of the thread library. It is a string, or ``None`` "
"if this information is unknown."
msgstr "스레드 라이브러리의 이름과 버전. 문자열이거나, 이 정보를 알 수 없으면 ``None``\\입니다."

#: ../../library/sys.rst:1951
msgid ""
"When this variable is set to an integer value, it determines the maximum "
"number of levels of traceback information printed when an unhandled "
"exception occurs. The default is ``1000``.  When set to ``0`` or less, "
"all traceback information is suppressed and only the exception type and "
"value are printed."
msgstr ""
"이 변수가 정숫값으로 설정되면, 처리되지 않은 예외가 발생할 때 인쇄되는 트레이스백 정보의 최대 수준 수를 결정합니다. 기본값은 "
"``1000``\\입니다. ``0`` 이하로 설정하면, 모든 트레이스백 정보가 억제되고 예외 형과 값만 인쇄됩니다."

#: ../../library/sys.rst:1959
msgid "Handle an unraisable exception."
msgstr "발생시킬 수 없는 예외(unraisable exception)를 처리합니다."

#: ../../library/sys.rst:1961
msgid ""
"Called when an exception has occurred but there is no way for Python to "
"handle it. For example, when a destructor raises an exception or during "
"garbage collection (:func:`gc.collect`)."
msgstr ""
"예외가 발생했지만, 파이썬이 예외를 처리할 방법이 없을 때 호출됩니다. 예를 들어, 파괴자가 예외를 발생시키거나 가비지 수거 "
"(:func:`gc.collect`) 중에."

#: ../../library/sys.rst:1965
msgid "The *unraisable* argument has the following attributes:"
msgstr "*unraisable* 인자에는 다음과 같은 어트리뷰트가 있습니다:"

#: ../../library/sys.rst:1967
#, fuzzy
msgid ":attr:`!exc_type`: Exception type."
msgstr "*exc_type*: 예외 형."

#: ../../library/sys.rst:1968
#, fuzzy
msgid ":attr:`!exc_value`: Exception value, can be ``None``."
msgstr "*exc_value*: 예외 값. ``None``\\일 수 있습니다."

#: ../../library/sys.rst:1969
#, fuzzy
msgid ":attr:`!exc_traceback`: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: 예외 트레이스백, ``None``\\일 수 있습니다."

#: ../../library/sys.rst:1970
#, fuzzy
msgid ":attr:`!err_msg`: Error message, can be ``None``."
msgstr "*err_msg*: 에러 메시지, ``None``\\일 수 있습니다."

#: ../../library/sys.rst:1971
#, fuzzy
msgid ":attr:`!object`: Object causing the exception, can be ``None``."
msgstr "*object*: 예외를 발생시킨 객체, ``None``\\일 수 있습니다."

#: ../../library/sys.rst:1973
#, fuzzy, python-brace-format
msgid ""
"The default hook formats :attr:`!err_msg` and :attr:`!object` as: "
"``f'{err_msg}: {object!r}'``; use \"Exception ignored in\" error message "
"if :attr:`!err_msg` is ``None``."
msgstr ""
"기본 훅은 *err_msg*\\와 *object*\\를 다음과 같이 포맷합니다: ``f'{err_msg}: "
"{object!r}'``; *err_msg*\\가 ``None``\\이면 \"Exception ignored in\" 에러 메시지를"
" 사용합니다."

#: ../../library/sys.rst:1977
msgid ""
":func:`sys.unraisablehook` can be overridden to control how unraisable "
"exceptions are handled."
msgstr ":func:`sys.unraisablehook` 은 발생시킬 수 없는 예외 처리 방법을 제어하기 위해 재정의될 수 있습니다."

#: ../../library/sys.rst:1982
#, fuzzy
msgid ":func:`excepthook` which handles uncaught exceptions."
msgstr "잡히지 않은 예외를 처리하는 :func:`excepthook`\\도 참조하십시오."

#: ../../library/sys.rst:1986
#, fuzzy
msgid ""
"Storing :attr:`!exc_value` using a custom hook can create a reference "
"cycle. It should be cleared explicitly to break the reference cycle when "
"the exception is no longer needed."
msgstr ""
"사용자 정의 훅을 사용하여 *exc_value*\\를 저장하면 참조 순환이 만들어질 수 있습니다. 예외가 더는 필요하지 않을 때 "
"참조 순환을 끊기 위해 명시적으로 지워야 합니다."

#: ../../library/sys.rst:1990
#, fuzzy
msgid ""
"Storing :attr:`!object` using a custom hook can resurrect it if it is set"
" to an object which is being finalized. Avoid storing :attr:`!object` "
"after the custom hook completes to avoid resurrecting objects."
msgstr ""
"사용자 정의 훅을 사용하여 *object*\\를 저장하면 파이널라이즈 중인 객체로 설정될 때 그것을 되살릴 수 있습니다. 객체 "
"되살림을 방지하려면 사용자 정의 훅이 완료된 후 *object*\\를 저장하지 마십시오."

#: ../../library/sys.rst:1994 ../../library/sys.rst:1996
#, fuzzy
msgid ""
"Raise an auditing event ``sys.unraisablehook`` with arguments *hook*, "
"*unraisable* when an exception that cannot be handled occurs. The "
"*unraisable* object is the same as what will be passed to the hook. If no"
" hook has been set, *hook* may be ``None``."
msgstr ""
"처리할 수 없는 예외가 발생할 때 인자 ``hook``, ``unraisable``\\로 감사 이벤트 "
"``sys.unraisablehook``\\을 발생시킵니다. ``unraisable`` 객체는 훅에 전달되는 것과 같습니다. 아무런"
" 훅도 설정되지 않았으면, ``hook``\\은 ``None`` 일 수 있습니다."

#: ../../library/sys.rst:2005
msgid ""
"A string containing the version number of the Python interpreter plus "
"additional information on the build number and compiler used.  This "
"string is displayed when the interactive interpreter is started.  Do not "
"extract version information out of it, rather, use :data:`version_info` "
"and the functions provided by the :mod:`platform` module."
msgstr ""
"파이썬 인터프리터의 버전 번호와 빌드 번호 및 사용된 컴파일러에 대한 추가 정보가 포함된 문자열. 이 문자열은 대화식 인터프리터가 "
"시작될 때 표시됩니다. 여기서 버전 정보를 추출하지 말고, :data:`version_info`\\와 :mod:`platform` "
"모듈이 제공하는 함수를 사용하십시오."

#: ../../library/sys.rst:2014
msgid ""
"The C API version for this interpreter.  Programmers may find this useful"
" when debugging version conflicts between Python and extension modules."
msgstr "이 인터프리터의 C API 버전. 프로그래머는 파이썬과 확장 모듈 간의 버전 충돌을 디버깅할 때 이것이 유용할 수 있습니다."

#: ../../library/sys.rst:2020
msgid ""
"A tuple containing the five components of the version number: *major*, "
"*minor*, *micro*, *releaselevel*, and *serial*.  All values except "
"*releaselevel* are integers; the release level is ``'alpha'``, "
"``'beta'``, ``'candidate'``, or ``'final'``.  The ``version_info`` value "
"corresponding to the Python version 2.0 is ``(2, 0, 0, 'final', 0)``.  "
"The components can also be accessed by name, so ``sys.version_info[0]`` "
"is equivalent to ``sys.version_info.major`` and so on."
msgstr ""
"버전 번호의 5가지 구성 요소를 포함하는 튜플: *major*, *minor*, *micro*, *releaselevel* 및 "
"*serial*. *releaselevel*\\을 제외한 모든 값은 정수입니다; 릴리스 수준은 ``'alpha'``, "
"``'beta'``, ``'candidate'`` 또는 ``'final'``\\입니다. 파이썬 버전 2.0에 해당하는 "
"``version_info`` 값은 ``(2, 0, 0, 'final', 0)``\\입니다. 구성 요소는 이름으로도 액세스 할 수 "
"있어서, ``sys.version_info[0]``\\는 ``sys.version_info.major``\\와 동등합니다."

#: ../../library/sys.rst:2028
msgid "Added named component attributes."
msgstr "이름있는 구성 요소 어트리뷰트를 추가했습니다."

#: ../../library/sys.rst:2033
msgid ""
"This is an implementation detail of the warnings framework; do not modify"
" this value.  Refer to the :mod:`warnings` module for more information on"
" the warnings framework."
msgstr ""
"이것은 경고 프레임워크의 구현 세부 사항입니다; 이 값을 수정하지 마십시오. 경고 프레임워크에 대한 자세한 정보는 "
":mod:`warnings` 모듈을 참조하십시오."

#: ../../library/sys.rst:2040
#, fuzzy
msgid ""
"The version number used to form registry keys on Windows platforms. This "
"is stored as string resource 1000 in the Python DLL.  The value is "
"normally the major and minor versions of the running Python interpreter."
"  It is provided in the :mod:`sys` module for informational purposes; "
"modifying this value has no effect on the registry keys used by Python."
msgstr ""
"윈도우 플랫폼에서 레지스트리 키를 형성하는 데 사용되는 버전 번호. 이것은 파이썬 DLL에서 문자열 리소스 1000으로 저장됩니다."
" 값은 일반적으로 :const:`version`\\의 처음 세 문자입니다. 정보용으로 :mod:`sys` 모듈에서 제공됩니다; 이 "
"값을 수정해도 파이썬에서 사용하는 레지스트리 키에는 영향을 미치지 않습니다."

#: ../../library/sys.rst:2052
msgid ""
"Namespace containing functions and constants for register callbacks and "
"controlling monitoring events. See  :mod:`sys.monitoring` for details."
msgstr ""

#: ../../library/sys.rst:2058
msgid ""
"A dictionary of the various implementation-specific flags passed through "
"the :option:`-X` command-line option.  Option names are either mapped to "
"their values, if given explicitly, or to :const:`True`.  Example:"
msgstr ""
":option:`-X` 명령 줄 옵션을 통해 전달된 다양한 구현 특정 플래그의 딕셔너리. 옵션 이름은 명시적으로 지정되면 그들의 "
"값으로, 그렇지 않으면 :const:`True`\\로 매핑됩니다. 예:"

#: ../../library/sys.rst:2062
#, python-brace-format
msgid ""
"$ ./python -Xa=b -Xc\n"
"Python 3.2a3+ (py3k, Oct 16 2010, 20:14:50)\n"
"[GCC 4.4.3] on linux2\n"
"Type \"help\", \"copyright\", \"credits\" or \"license\" for more "
"information.\n"
">>> import sys\n"
">>> sys._xoptions\n"
"{'a': 'b', 'c': True}"
msgstr ""

#: ../../library/sys.rst:2074
msgid ""
"This is a CPython-specific way of accessing options passed through "
":option:`-X`.  Other implementations may export them through other means,"
" or not at all."
msgstr ""
"이는 :option:`-X`\\를 통해 전달된 옵션에 액세스하는 CPython 특정 방법입니다. 다른 구현은 다른 수단을 통해, "
"또는 전혀 노출하지 않을 수 있습니다."

#: ../../library/sys.rst:2082
msgid "Citations"
msgstr "인용"

#: ../../library/sys.rst:2083
#, fuzzy
msgid ""
"ISO/IEC 9899:1999.  \"Programming languages -- C.\"  A public draft of "
"this standard is available at https://www.open-"
"std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\\ ."
msgstr ""
"ISO/IEC 9899:1999. \"Programming languages -- C.\" 이 표준의 공개 초안은 "
"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf 에 있습니다."

#: ../../library/sys.rst:99
msgid "auditing"
msgstr ""

#: ../../library/sys.rst:462
msgid "object"
msgstr ""

#: ../../library/sys.rst:462
msgid "traceback"
msgstr ""

#: ../../library/sys.rst:954 ../../library/sys.rst:1534
msgid "profile function"
msgstr ""

#: ../../library/sys.rst:954 ../../library/sys.rst:1534
msgid "profiler"
msgstr ""

#: ../../library/sys.rst:963 ../../library/sys.rst:1617
msgid "trace function"
msgstr ""

#: ../../library/sys.rst:963 ../../library/sys.rst:1617
msgid "debugger"
msgstr ""

#: ../../library/sys.rst:1362
msgid "module"
msgstr ""

#: ../../library/sys.rst:1362
msgid "search"
msgstr ""

#: ../../library/sys.rst:1362
msgid "path"
msgstr ""

#: ../../library/sys.rst:1498
msgid "interpreter prompts"
msgstr ""

#: ../../library/sys.rst:1498
msgid "prompts, interpreter"
msgstr ""

#: ../../library/sys.rst:1498
msgid ">>>"
msgstr ""

#: ../../library/sys.rst:1498
msgid "interpreter prompt"
msgstr ""

#: ../../library/sys.rst:1498
msgid "..."
msgstr ""

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``sys.addaudithook`` with no arguments."
#~ msgstr "인자 없이 :ref:`감사 이벤트 <auditing>` ``sys.addaudithook``\\을 발생시킵니다."

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``sys.excepthook`` with arguments ``hook``, "
#~ "``type``, ``value``, ``traceback``."
#~ msgstr ""
#~ "인자 ``hook``, ``type``, ``value``, "
#~ "``traceback``\\으로 :ref:`감사 이벤트 <auditing>` "
#~ "``sys.excepthook``\\을 발생시킵니다."

#~ msgid ""
#~ "This function returns a tuple of "
#~ "three values that give information about"
#~ " the exception that is currently "
#~ "being handled.  The information returned "
#~ "is specific both to the current "
#~ "thread and to the current stack "
#~ "frame.  If the current stack frame "
#~ "is not handling an exception, the "
#~ "information is taken from the calling"
#~ " stack frame, or its caller, and "
#~ "so on until a stack frame is "
#~ "found that is handling an exception."
#~ "  Here, \"handling an exception\" is "
#~ "defined as \"executing an except "
#~ "clause.\"  For any stack frame, only "
#~ "information about the exception being "
#~ "currently handled is accessible."
#~ msgstr ""
#~ "이 함수는 현재 처리 중인 예외에 대한 정보를"
#~ " 제공하는 세 가지 값의 튜플을 반환합니다. 반환된"
#~ " 정보는 현재 스레드와 현재 스택 프레임에만 해당합니다."
#~ " 현재 스택 프레임이 예외를 처리하지 않고 있으면,"
#~ " 호출하는 스택 프레임, 또는 그것의 호출자, 그리고"
#~ " 예외를 처리하는 스택 프레임이 발견될 때까지 거슬러"
#~ " 올라가서 발견된 스택 프레임에서 정보를 가져옵니다. "
#~ "여기에서, \"예외를 처리하는\"은 \"except 절을 실행하는\"으로"
#~ " 정의됩니다. 모든 스택 프레임에서, 현재 처리 중인"
#~ " 예외에 대한 정보만 액세스 할 수 있습니다."

#~ msgid ""
#~ "If no exception is being handled "
#~ "anywhere on the stack, a tuple "
#~ "containing three ``None`` values is "
#~ "returned.  Otherwise, the values returned "
#~ "are ``(type, value, traceback)``.  Their "
#~ "meaning is: *type* gets the type "
#~ "of the exception being handled (a "
#~ "subclass of :exc:`BaseException`); *value* "
#~ "gets the exception instance (an instance"
#~ " of the exception type); *traceback* "
#~ "gets a :ref:`traceback object <traceback-"
#~ "objects>` which encapsulates the call "
#~ "stack at the point where the "
#~ "exception originally occurred."
#~ msgstr ""
#~ "스택의 어느 곳에서도 예외가 처리되고 있지 않으면, "
#~ "세 개의 ``None`` 값을 포함하는 튜플이 반환됩니다."
#~ " 그렇지 않으면, 반환된 값은 ``(type, value, "
#~ "traceback)``\\입니다. 의미는 이렇습니다: *type*\\은 처리 "
#~ "중인 예외의 형(:exc:`BaseException`\\의 서브 클래스)을 "
#~ "얻습니다; *value*\\는 예외 인스턴스(예외 형의 인스턴스)를"
#~ " 얻습니다; *traceback* 은 예외가 원래 발생한 "
#~ "지점에서 호출 스택을 캡슐화하는 :ref:`트레이스백 객체 "
#~ "<traceback-objects>`\\를 얻습니다."

#~ msgid ""
#~ "Exit from Python.  This is implemented"
#~ " by raising the :exc:`SystemExit` "
#~ "exception, so cleanup actions specified "
#~ "by finally clauses of :keyword:`try` "
#~ "statements are honored, and it is "
#~ "possible to intercept the exit attempt"
#~ " at an outer level."
#~ msgstr ""
#~ "파이썬에서 빠져나옵니다. 이는 :exc:`SystemExit` 예외를 "
#~ "발생시키는 것으로 구현되므로, :keyword:`try` 문의 "
#~ "finally 절에 지정된 정리 조치가 적용되며, 바깥 "
#~ "수준에서 종료 시도를 가로챌 수 있습니다."

#~ msgid "flag"
#~ msgstr "플래그"

#~ msgid ":const:`debug`"
#~ msgstr ":const:`debug`"

#~ msgid ":const:`inspect`"
#~ msgstr ":const:`inspect`"

#~ msgid ":const:`interactive`"
#~ msgstr ":const:`interactive`"

#~ msgid ":const:`isolated`"
#~ msgstr ":const:`isolated`"

#~ msgid ":const:`optimize`"
#~ msgstr ":const:`optimize`"

#~ msgid ":const:`dont_write_bytecode`"
#~ msgstr ":const:`dont_write_bytecode`"

#~ msgid ":const:`no_user_site`"
#~ msgstr ":const:`no_user_site`"

#~ msgid ":const:`no_site`"
#~ msgstr ":const:`no_site`"

#~ msgid ":const:`ignore_environment`"
#~ msgstr ":const:`ignore_environment`"

#~ msgid ":const:`verbose`"
#~ msgstr ":const:`verbose`"

#~ msgid ":const:`bytes_warning`"
#~ msgstr ":const:`bytes_warning`"

#~ msgid ":const:`quiet`"
#~ msgstr ":const:`quiet`"

#~ msgid ":const:`hash_randomization`"
#~ msgstr ":const:`hash_randomization`"

#~ msgid ":const:`dev_mode`"
#~ msgstr ":const:`dev_mode`"

#~ msgid ":const:`utf8_mode`"
#~ msgstr ":const:`utf8_mode`"

#~ msgid "DBL_EPSILON"
#~ msgstr "DBL_EPSILON"

#~ msgid ":const:`dig`"
#~ msgstr ":const:`dig`"

#~ msgid "DBL_DIG"
#~ msgstr "DBL_DIG"

#~ msgid "DBL_MANT_DIG"
#~ msgstr "DBL_MANT_DIG"

#~ msgid ":const:`max`"
#~ msgstr ":const:`max`"

#~ msgid "DBL_MAX"
#~ msgstr "DBL_MAX"

#~ msgid "DBL_MAX_EXP"
#~ msgstr "DBL_MAX_EXP"

#~ msgid "DBL_MAX_10_EXP"
#~ msgstr "DBL_MAX_10_EXP"

#~ msgid ":const:`min`"
#~ msgstr ":const:`min`"

#~ msgid "DBL_MIN"
#~ msgstr "DBL_MIN"

#~ msgid "DBL_MIN_EXP"
#~ msgstr "DBL_MIN_EXP"

#~ msgid "DBL_MIN_10_EXP"
#~ msgstr "DBL_MIN_10_EXP"

#~ msgid "FLT_RADIX"
#~ msgstr "FLT_RADIX"

#~ msgid "FLT_ROUNDS"
#~ msgstr "FLT_ROUNDS"

#~ msgid "Return the build time API version of Android as an integer."
#~ msgstr "안드로이드의 빌드 시간 API 버전을 정수로 반환합니다."

#~ msgid ":ref:`Availability <availability>`: Android."
#~ msgstr ":ref:`가용성 <availability>`: 안드로이드."

#~ msgid ":ref:`Availability <availability>`: Unix."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스."

#~ msgid "This encoding is always ASCII-compatible."
#~ msgstr "이 인코딩은 항상 ASCII 호환입니다."

#~ msgid "In the UTF-8 mode, the encoding is ``utf-8`` on any platform."
#~ msgstr "UTF-8 모드에서, 인코딩은 모든 플랫폼에서 ``utf-8``\\입니다."

#~ msgid "On macOS, the encoding is ``'utf-8'``."
#~ msgstr "macOS에서, 인코딩은 ``'utf-8'``\\입니다."

#~ msgid "On Unix, the encoding is the locale encoding."
#~ msgstr "유닉스에서, 인코딩은 로케일 인코딩입니다."

#~ msgid ""
#~ "On Windows, the encoding may be "
#~ "``'utf-8'`` or ``'mbcs'``, depending on "
#~ "user configuration."
#~ msgstr "윈도우에서, 사용자 구성에 따라 인코딩은 ``'utf-8'``\\이나 ``'mbcs'``\\일 수 있습니다."

#~ msgid "On Android, the encoding is ``'utf-8'``."
#~ msgstr "안드로이드에서, 인코딩은 ``'utf-8'``\\입니다."

#~ msgid "On VxWorks, the encoding is ``'utf-8'``."
#~ msgstr "VxWorks에서, 인코딩은 ``'utf-8'``\\입니다."

#~ msgid "Return 'utf-8' in the UTF-8 mode."
#~ msgstr "UTF-8 모드에서 'utf-8'을 반환합니다."

#~ msgid ":const:`width`"
#~ msgstr ":const:`width`"

#~ msgid ":const:`modulus`"
#~ msgstr ":const:`modulus`"

#~ msgid ":const:`inf`"
#~ msgstr ":const:`inf`"

#~ msgid ":const:`nan`"
#~ msgstr ":const:`nan`"

#~ msgid "hash value returned for a nan"
#~ msgstr "nan에 대해 반환된 해시값"

#~ msgid ":const:`imag`"
#~ msgstr ":const:`imag`"

#~ msgid ":const:`algorithm`"
#~ msgstr ":const:`algorithm`"

#~ msgid ":const:`hash_bits`"
#~ msgstr ":const:`hash_bits`"

#~ msgid ":const:`seed_bits`"
#~ msgstr ":const:`seed_bits`"

#~ msgid "Attribute"
#~ msgstr "어트리뷰트"

#~ msgid "Explanation"
#~ msgstr "설명"

#~ msgid ":const:`bits_per_digit`"
#~ msgstr ":const:`bits_per_digit`"

#~ msgid ":const:`sizeof_digit`"
#~ msgstr ":const:`sizeof_digit`"

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``cpython.run_interactivehook`` with argument "
#~ "``hook``."
#~ msgstr ""
#~ "인자 ``hook``\\으로 :ref:`감사 이벤트 <auditing>` "
#~ "``cpython.run_interactivehook``\\을 발생시킵니다."

#~ msgid ""
#~ "The meaning of the variables is "
#~ "the same as that of the return "
#~ "values from :func:`exc_info` above."
#~ msgstr "변수의 의미는 위의 :func:`exc_info`\\의 반환 값의 의미와 같습니다."

#~ msgid ""
#~ "As initialized upon program startup, the"
#~ " first item of this list, "
#~ "``path[0]``, is the directory containing "
#~ "the script that was used to invoke"
#~ " the Python interpreter.  If the "
#~ "script directory is not available (e.g."
#~ "  if the interpreter is invoked "
#~ "interactively or if the script is "
#~ "read from standard input), ``path[0]`` "
#~ "is the empty string, which directs "
#~ "Python to search modules in the "
#~ "current directory first.  Notice that "
#~ "the script directory is inserted "
#~ "*before* the entries inserted as a "
#~ "result of :envvar:`PYTHONPATH`."
#~ msgstr ""
#~ "프로그램 시작 시 초기화된 대로, 이 리스트의 첫"
#~ " 번째 항목인 ``path[0]``\\은 파이썬 인터프리터를 "
#~ "호출하는 데 사용된 스크립트가 포함된 디렉터리입니다. 스크립트"
#~ " 디렉터리를 사용할 수 없으면 (예를 들어, 인터프리터가"
#~ " 대화형으로 호출되거나 표준 입력에서 스크립트를 읽을 "
#~ "때) ``path[0]``\\은 빈 문자열이 되는데, 파이썬이 "
#~ "현재 디렉터리에서 모듈을 먼저 검색하도록 합니다. 스크립트"
#~ " 디렉터리가 :envvar:`PYTHONPATH`\\의 결과로 삽입된 항목"
#~ " *앞*\\에 삽입됨에 유의하십시오."

#~ msgid ""
#~ "``None`` is stored instead of "
#~ ":class:`imp.NullImporter` when no finder is"
#~ " found."
#~ msgstr "파인더가 없으면 :class:`imp.NullImporter` 대신 ``None``\\이 저장됩니다."

#~ msgid ""
#~ "This string contains a platform "
#~ "identifier that can be used to "
#~ "append platform-specific components to "
#~ ":data:`sys.path`, for instance."
#~ msgstr ""
#~ "이 문자열에는 예를 들어 :data:`sys.path`\\에 플랫폼별"
#~ " 구성 요소를 추가하는 데 사용할 수 있는 "
#~ "플랫폼 식별자가 포함되어 있습니다."

#~ msgid "For other systems, the values are:"
#~ msgstr "다른 시스템의 경우, 값은 다음과 같습니다:"

#~ msgid ""
#~ "The character encoding is platform-"
#~ "dependent.  Non-Windows platforms use "
#~ "the locale encoding (see "
#~ ":meth:`locale.getpreferredencoding()`)."
#~ msgstr ""
#~ "문자 인코딩은 플랫폼에 따라 다릅니다. 윈도우 이외의 "
#~ "플랫폼은 로케일 인코딩을 사용합니다 "
#~ "(:meth:`locale.getpreferredencoding()`\\을 참조하십시오)."

#~ msgid ":const:`name`"
#~ msgstr ":const:`name`"

#~ msgid ":const:`lock`"
#~ msgstr ":const:`lock`"

#~ msgid ":const:`version`"
#~ msgstr ":const:`version`"

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``sys.unraisablehook`` with arguments ``hook``, "
#~ "``unraisable``."
#~ msgstr "인자 ``hook``, ``unraisable``\\로 감사 이벤트 ``sys.unraisablehook``\\을 발생시킵니다."

