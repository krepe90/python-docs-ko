# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/code.rst:2
msgid ":mod:`!code` --- Interpreter base classes"
msgstr ":mod:`!code` --- 인터프리터 베이스 클래스"

#: ../../library/code.rst:7
msgid "**Source code:** :source:`Lib/code.py`"
msgstr "**소스 코드:** :source:`Lib/code.py`"

#: ../../library/code.rst:11
msgid ""
"The ``code`` module provides facilities to implement read-eval-print "
"loops in Python.  Two classes and convenience functions are included "
"which can be used to build applications which provide an interactive "
"interpreter prompt."
msgstr ""
"``code`` 모듈은 파이썬에서 REPL(read-eval-print loop)을 구현하는 기능을 제공합니다. 대화형 인터프리터 "
"프롬프트를 제공하는 응용 프로그램을 만드는 데 사용할 수 있는 두 개의 클래스와 편리 함수들이 포함되어 있습니다."

#: ../../library/code.rst:18
msgid ""
"This class deals with parsing and interpreter state (the user's "
"namespace); it does not deal with input buffering or prompting or input "
"file naming (the filename is always passed in explicitly). The optional "
"*locals* argument specifies a mapping to use as the namespace in which "
"code will be executed; it defaults to a newly created dictionary with key"
" ``'__name__'`` set to ``'__console__'`` and key ``'__doc__'`` set to "
"``None``."
msgstr ""
"이 클래스는 구문 분석과 인터프리터 상태(사용자의 이름 공간)를 처리합니다; 입력 버퍼링이나 프롬프트 또는 입력 파일 이름 지정을 "
"처리하지 않습니다 (파일명은 항상 명시적으로 전달됩니다). 선택적 *locals* 인자는 코드가 실행될 이름 공간으로 사용될 매핑을"
" 지정합니다; 기본값은 키 ``'__name__'``\\이 ``'__console__'``\\로 설정되고 키 "
"``'__doc__'``\\이 ``None``\\으로 설정된 새로 만들어진 딕셔너리입니다."

#: ../../library/code.rst:28
msgid ""
"Closely emulate the behavior of the interactive Python interpreter. This "
"class builds on :class:`InteractiveInterpreter` and adds prompting using "
"the familiar ``sys.ps1`` and ``sys.ps2``, and input buffering. If "
"*local_exit* is true, ``exit()`` and ``quit()`` in the console will not "
"raise :exc:`SystemExit`, but instead return to the calling code."
msgstr ""
"대화형 파이썬 인터프리터의 동작을 가깝게 흉내 냅니다. 이 클래스는 :class:`InteractiveInterpreter`\\를 "
"기반으로 하며 친숙한 ``sys.ps1``\\과 ``sys.ps2``\\를 사용하는 프롬프트와 입력 버퍼링을 추가합니다. "
"*local_exit*\\가 참이면, 콘솔에서의 ``exit()``\\와 ``quit()``\\는 "
":exc:`SystemExit`\\를 발생시키지 않고, 대신 호출 코드로 돌아갑니다."

#: ../../library/code.rst:34 ../../library/code.rst:52
msgid "Added *local_exit* parameter."
msgstr "*local_exit* 매개 변수가 추가되었습니다."

#: ../../library/code.rst:39
msgid ""
"Convenience function to run a read-eval-print loop.  This creates a new "
"instance of :class:`InteractiveConsole` and sets *readfunc* to be used as"
" the :meth:`InteractiveConsole.raw_input` method, if provided.  If "
"*local* is provided, it is passed to the :class:`InteractiveConsole` "
"constructor for use as the default namespace for the interpreter loop.  "
"If *local_exit* is provided, it is passed to the "
":class:`InteractiveConsole` constructor.  The "
":meth:`~InteractiveConsole.interact` method of the instance is then run "
"with *banner* and *exitmsg* passed as the banner and exit message to use,"
" if provided.  The console object is discarded after use."
msgstr ""
"REPL(read-eval-print loop)를 실행하는 편리 함수. 이것은 "
":class:`InteractiveConsole`\\의 새 인스턴스를 만들고, 제공된다면 *readfunc*\\가 "
":meth:`InteractiveConsole.raw_input` 메서드로 사용되도록 설정합니다. *local*\\이 제공되면 "
"인터프리터 루프의 기본 이름 공간으로 사용하기 위해 :class:`InteractiveConsole` 생성자로 전달됩니다. "
"*local_exit*\\가 제공되면 :class:`InteractiveConsole` 생성자로 전달됩니다. 그런 다음 인스턴스의 "
":meth:`~InteractiveConsole.interact` 메서드를 실행하는데, 제공된다면 *banner*\\와 "
"*exitmsg*\\를 각각 배너와 종료 메시지로 사용하도록 전달합니다. 콘솔 객체는 사용 후에 폐기됩니다."

#: ../../library/code.rst:49
msgid "Added *exitmsg* parameter."
msgstr "*exitmsg* 매개 변수가 추가되었습니다."

#: ../../library/code.rst:57
msgid ""
"This function is useful for programs that want to emulate Python's "
"interpreter main loop (a.k.a. the read-eval-print loop).  The tricky part"
" is to determine when the user has entered an incomplete command that can"
" be completed by entering more text (as opposed to a complete command or "
"a syntax error).  This function *almost* always makes the same decision "
"as the real interpreter main loop."
msgstr ""
"이 함수는 파이썬의 인터프리터 메인 루프(소위 REPL)를 흉내 내고 싶은 프로그램에 유용합니다. 까다로운 부분은 사용자가 후에 "
"추가의 텍스트를 입력해서 완성할 수 있는 불완전한 명령을 입력했는지를 결정하는 것입니다 (완전한 명령이나 문법 에러가 아니라). 이"
" 함수는 *거의* 항상 실제 인터프리터 메인 루프와 같은 결정을 내립니다."

#: ../../library/code.rst:64
msgid ""
"*source* is the source string; *filename* is the optional filename from "
"which source was read, defaulting to ``'<input>'``; and *symbol* is the "
"optional grammar start symbol, which should be ``'single'`` (the "
"default), ``'eval'`` or ``'exec'``."
msgstr ""
"*source*\\는 소스 문자열입니다; *filename*\\은 소스를 읽어 들인 선택적 파일명이며, 기본값은 "
"``'<input>'``\\입니다; 그리고 *symbol*\\은 선택적 문법 시작 기호이며 ``'single'`` (기본값), "
"``'eval'`` 또는 ``'exec'`` 중 하나여야 합니다."

#: ../../library/code.rst:69
msgid ""
"Returns a code object (the same as ``compile(source, filename, symbol)``)"
" if the command is complete and valid; ``None`` if the command is "
"incomplete; raises :exc:`SyntaxError` if the command is complete and "
"contains a syntax error, or raises :exc:`OverflowError` or "
":exc:`ValueError` if the command contains an invalid literal."
msgstr ""
"명령이 완전하고 유효하면 코드 객체(``compile(source, filename, symbol)``\\와 같습니다)를 "
"반환합니다; 명령이 불완전하면 ``None``\\을 반환합니다; 명령이 완전하고 문법 에러가 있으면 "
":exc:`SyntaxError`\\를 발생시키고, 명령에 유효하지 않은 리터럴이 포함되었으면 "
":exc:`OverflowError`\\나 :exc:`ValueError`\\를 발생시킵니다."

#: ../../library/code.rst:79
msgid "Interactive Interpreter Objects"
msgstr "대화형 인터프리터 객체"

#: ../../library/code.rst:84
msgid ""
"Compile and run some source in the interpreter. Arguments are the same as"
" for :func:`compile_command`; the default for *filename* is "
"``'<input>'``, and for *symbol* is ``'single'``.  One of several things "
"can happen:"
msgstr ""
"인터프리터에서 소스를 컴파일하고 실행합니다. 인자는 :func:`compile_command`\\와 같습니다; "
"*filename*\\의 기본값은 ``'<input>'``\\이고, *symbol*\\의 기본값은 ``'single'``\\입니다."
" 여러 가지 중 하나가 발생할 수 있습니다:"

#: ../../library/code.rst:88
msgid ""
"The input is incorrect; :func:`compile_command` raised an exception "
"(:exc:`SyntaxError` or :exc:`OverflowError`).  A syntax traceback will be"
" printed by calling the :meth:`showsyntaxerror` method.  "
":meth:`runsource` returns ``False``."
msgstr ""
"입력이 잘못되었습니다; :func:`compile_command`\\가 예외(:exc:`SyntaxError`\\나 "
":exc:`OverflowError`)를 발생시켰습니다. 문법 트레이스백이 :meth:`showsyntaxerror` 메서드를 "
"호출하여 인쇄됩니다. :meth:`runsource`\\는 ``False``\\를 반환합니다."

#: ../../library/code.rst:93
msgid ""
"The input is incomplete, and more input is required; "
":func:`compile_command` returned ``None``. :meth:`runsource` returns "
"``True``."
msgstr ""
"입력이 불완전하고, 더 많은 입력이 필요합니다; :func:`compile_command`\\가 ``None``\\을 반환했습니다."
" :meth:`runsource`\\는 ``True``\\를 반환합니다."

#: ../../library/code.rst:96
msgid ""
"The input is complete; :func:`compile_command` returned a code object.  "
"The code is executed by calling the :meth:`runcode` (which also handles "
"run-time exceptions, except for :exc:`SystemExit`). :meth:`runsource` "
"returns ``False``."
msgstr ""
"입력이 완전합니다; :func:`compile_command`\\가 코드 객체를 반환했습니다. 코드는 "
":meth:`runcode`\\(:exc:`SystemExit`\\를 제외한 실행 시간 예외도 처리합니다)를 호출하여 실행됩니다. "
":meth:`runsource`\\는 ``False``\\를 반환합니다."

#: ../../library/code.rst:100
msgid ""
"The return value can be used to decide whether to use ``sys.ps1`` or "
"``sys.ps2`` to prompt the next line."
msgstr ""
"반환 값은 다음 줄의 프롬프트에 ``sys.ps1``\\과 ``sys.ps2`` 중 어느 것을 사용할지 결정하는 데 사용될 수 "
"있습니다."

#: ../../library/code.rst:106
msgid ""
"Execute a code object. When an exception occurs, :meth:`showtraceback` is"
" called to display a traceback.  All exceptions are caught except "
":exc:`SystemExit`, which is allowed to propagate."
msgstr ""
"코드 객체를 실행합니다. 예외가 발생하면, :meth:`showtraceback`\\가 호출되어 트레이스백을 표시합니다. 전파가 "
"허락된 :exc:`SystemExit`\\를 제외한 모든 예외를 잡습니다."

#: ../../library/code.rst:110
msgid ""
"A note about :exc:`KeyboardInterrupt`: this exception may occur elsewhere"
" in this code, and may not always be caught.  The caller should be "
"prepared to deal with it."
msgstr ""
":exc:`KeyboardInterrupt`\\에 대한 노트: 이 예외는 이 코드의 어딘가에서 발생할 수 있으며, 항상 잡히지는 "
"않습니다. 호출자는 이것을 처리할 준비가 되어 있어야 합니다."

#: ../../library/code.rst:117
msgid ""
"Display the syntax error that just occurred.  This does not display a "
"stack trace because there isn't one for syntax errors. If *filename* is "
"given, it is stuffed into the exception instead of the default filename "
"provided by Python's parser, because it always uses ``'<string>'`` when "
"reading from a string. The output is written by the :meth:`write` method."
msgstr ""
"방금 발생한 문법 에러를 표시합니다. 스택 트레이스는 표시하지 않습니다, 문법 에러에는 그런 것이 없기 때문입니다. "
"*filename*\\이 주어지면, 파이썬 구문 분석기가 제공하는 기본 파일명 대신에 예외에 채워집니다, 문자열에서 읽을 때는 항상"
" ``'<string>'``\\을 사용하기 때문입니다. 출력은 :meth:`write` 메서드로 기록됩니다."

#: ../../library/code.rst:126
msgid ""
"Display the exception that just occurred.  We remove the first stack item"
" because it is within the interpreter object implementation. The output "
"is written by the :meth:`write` method."
msgstr ""
"방금 발생한 예외를 표시합니다. 첫 번째 스택 항목을 제거합니다, 그것은 인터프리터 객체 구현에 속하기 때문입니다. 출력은 "
":meth:`write` 메서드로 기록됩니다."

#: ../../library/code.rst:130
msgid ""
"The full chained traceback is displayed instead of just the primary "
"traceback."
msgstr "단지 기본(primary) 트레이스백이 아니라 전체 연결된(chained) 트레이스백이 표시됩니다."

#: ../../library/code.rst:136
msgid ""
"Write a string to the standard error stream (``sys.stderr``). Derived "
"classes should override this to provide the appropriate output handling "
"as needed."
msgstr ""
"문자열을 표준 에러 스트림(``sys.stderr``)에 기록합니다. 파생 클래스는 필요에 따라 적절한 출력 처리를 제공하기 위해 "
"이것을 재정의해야 합니다."

#: ../../library/code.rst:143
msgid "Interactive Console Objects"
msgstr "대화형 콘솔 객체"

#: ../../library/code.rst:145
msgid ""
"The :class:`InteractiveConsole` class is a subclass of "
":class:`InteractiveInterpreter`, and so offers all the methods of the "
"interpreter objects as well as the following additions."
msgstr ""
":class:`InteractiveConsole` 클래스는 :class:`InteractiveInterpreter`\\의 서브 "
"클래스이므로, 인터프리터 객체의 모든 메서드와 다음과 같은 추가 메서드를 제공합니다."

#: ../../library/code.rst:152
msgid ""
"Closely emulate the interactive Python console. The optional *banner* "
"argument specify the banner to print before the first interaction; by "
"default it prints a banner similar to the one printed by the standard "
"Python interpreter, followed by the class name of the console object in "
"parentheses (so as not to confuse this with the real interpreter -- since"
" it's so close!)."
msgstr ""
"대화형 파이썬 콘솔을 가깝게 흉내 냅니다. 선택적 *banner* 인자는 첫 번째 상호 작용 전에 인쇄할 배너를 지정합니다; "
"기본적으로 표준 파이썬 인터프리터가 출력하는 것과 비슷한 배너를 출력한 다음 괄호 안에 콘솔 객체의 클래스 이름을 출력합니다 (실제"
" 인터프리터와 혼동하지 않도록 하기 위함입니다 -- 너무 비슷합니다!)."

#: ../../library/code.rst:158
msgid ""
"The optional *exitmsg* argument specifies an exit message printed when "
"exiting. Pass the empty string to suppress the exit message. If *exitmsg*"
" is not given or ``None``, a default message is printed."
msgstr ""
"선택적 *exitmsg* 인자는 종료할 때 인쇄되는 종료 메시지를 지정합니다. 종료 메시지를 표시하지 않으려면 빈 문자열을 "
"전달하십시오. *exitmsg*\\가 주어지지 않았거나 ``None``\\이면, 기본 메시지가 인쇄됩니다."

#: ../../library/code.rst:162
msgid "To suppress printing any banner, pass an empty string."
msgstr "배너 인쇄를 억제하려면, 빈 문자열을 전달하십시오."

#: ../../library/code.rst:165
msgid "Print an exit message when exiting."
msgstr "종료할 때 종료 메시지를 인쇄합니다."

#: ../../library/code.rst:171
msgid ""
"Push a line of source text to the interpreter. The line should not have a"
" trailing newline; it may have internal newlines.  The line is appended "
"to a buffer and the interpreter's "
":meth:`~InteractiveInterpreter.runsource` method is called with the "
"concatenated contents of the buffer as source.  If this indicates that "
"the command was executed or invalid, the buffer is reset; otherwise, the "
"command is incomplete, and the buffer is left as it was after the line "
"was appended.  The return value is ``True`` if more input is required, "
"``False`` if the line was dealt with in some way (this is the same as "
":meth:`!runsource`)."
msgstr ""
"소스 텍스트 줄을 인터프리터로 밀어 넣습니다. line에는 후행 줄 바꿈이 없어야 합니다; 내부 줄 바꿈은 있을 수 있습니다. 줄은"
" 버퍼에 추가되고 인터프리터의 :meth:`~InteractiveInterpreter.runsource` 메서드가 이어붙인 버퍼의 "
"내용을 소스로 하여 호출됩니다. 이것이 명령이 실행되었거나 유효하지 않았다고 알리면 버퍼는 재설정됩니다; 그렇지 않고 명령이 "
"불완전하다면, 버퍼는 줄을 추가한 상태로 유지됩니다. 반환 값은 추가 입력이 필요하면 ``True``\\이고, 어떤 식으로든 줄이 "
"처리되었으면 ``False``\\입니다 (:meth:`!runsource`\\와 같습니다)."

#: ../../library/code.rst:183
msgid "Remove any unhandled source text from the input buffer."
msgstr "처리되지 않은 소스 텍스트를 입력 버퍼에서 제거합니다."

#: ../../library/code.rst:188
msgid ""
"Write a prompt and read a line.  The returned line does not include the "
"trailing newline.  When the user enters the EOF key sequence, "
":exc:`EOFError` is raised. The base implementation reads from "
"``sys.stdin``; a subclass may replace this with a different "
"implementation."
msgstr ""
"프롬프트를 기록하고 줄을 읽습니다. 반환된 줄에는 후행 줄 바꿈이 포함되지 않습니다. 사용자가 EOF 키 시퀀스를 입력하면, "
":exc:`EOFError`\\가 발생합니다. 기본 구현은 ``sys.stdin``\\에서 읽습니다; 서브 클래스는 이것을 다른 "
"구현으로 바꿀 수 있습니다."

