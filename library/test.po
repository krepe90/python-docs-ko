# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/test.rst:2
#, fuzzy
msgid ":mod:`!test` --- Regression tests package for Python"
msgstr ":mod:`test` --- 파이썬 용 회귀 테스트 패키지"

#: ../../library/test.rst:10
msgid ""
"The :mod:`test` package is meant for internal use by Python only. It is "
"documented for the benefit of the core developers of Python. Any use of "
"this package outside of Python's standard library is discouraged as code "
"mentioned here can change or be removed without notice between releases "
"of Python."
msgstr ""
":mod:`test` 패키지는 파이썬 내부 용으로만 사용됩니다. 파이썬의 핵심 개발자를 위해 설명됩니다. 여기에 언급된 코드는 "
"파이썬 릴리스 사이에 예고 없이 변경되거나 제거될 수 있어서, 파이썬의 표준 라이브러리 외부에서 이 패키지를 사용하는 것은 권장되지"
" 않습니다."

#: ../../library/test.rst:18
msgid ""
"The :mod:`test` package contains all regression tests for Python as well "
"as the modules :mod:`test.support` and :mod:`test.regrtest`. "
":mod:`test.support` is used to enhance your tests while "
":mod:`test.regrtest` drives the testing suite."
msgstr ""
":mod:`test` 패키지에는 :mod:`test.support`\\와 :mod:`test.regrtest`\\뿐만 아니라 "
"파이썬에 대한 모든 회귀 테스트가 포함되어 있습니다. :mod:`test.support`\\는 테스트를 향상하는 데 사용되며 "
":mod:`test.regrtest`\\는 테스트 스위트를 구동합니다."

#: ../../library/test.rst:23
msgid ""
"Each module in the :mod:`test` package whose name starts with ``test_`` "
"is a testing suite for a specific module or feature. All new tests should"
" be written using the :mod:`unittest` or :mod:`doctest` module.  Some "
"older tests are written using a \"traditional\" testing style that "
"compares output printed to ``sys.stdout``; this style of test is "
"considered deprecated."
msgstr ""
"이름이 ``test_``\\로 시작하는 :mod:`test` 패키지의 각 모듈은 특정 모듈이나 기능에 대한 테스트 스위트입니다. "
"모든 새로운 테스트는 :mod:`unittest`\\나 :mod:`doctest` 모듈을 사용하여 작성해야 합니다. 일부 오래된 "
"테스트는 ``sys.stdout``\\으로 인쇄된 출력을 비교하는 \"전통적인\" 테스트 스타일을 사용하여 작성되었습니다; 이 "
"테스트 스타일은 폐지된 것으로 간주합니다."

#: ../../library/test.rst:32
msgid "Module :mod:`unittest`"
msgstr "모듈 :mod:`unittest`"

#: ../../library/test.rst:33
msgid "Writing PyUnit regression tests."
msgstr "PyUnit 회귀 테스트 작성."

#: ../../library/test.rst:35
msgid "Module :mod:`doctest`"
msgstr "모듈 :mod:`doctest`"

#: ../../library/test.rst:36
msgid "Tests embedded in documentation strings."
msgstr "독스트링에 포함된 테스트."

#: ../../library/test.rst:42
msgid "Writing Unit Tests for the :mod:`test` package"
msgstr ":mod:`test` 패키지를 위한 단위 테스트 작성하기"

#: ../../library/test.rst:44
msgid ""
"It is preferred that tests that use the :mod:`unittest` module follow a "
"few guidelines. One is to name the test module by starting it with "
"``test_`` and end it with the name of the module being tested. The test "
"methods in the test module should start with ``test_`` and end with a "
"description of what the method is testing. This is needed so that the "
"methods are recognized by the test driver as test methods. Also, no "
"documentation string for the method should be included. A comment (such "
"as ``# Tests function returns only True or False``) should be used to "
"provide documentation for test methods. This is done because "
"documentation strings get printed out if they exist and thus what test is"
" being run is not stated."
msgstr ""
":mod:`unittest` 모듈을 사용하는 테스트는 몇 가지 지침을 따르는 것이 좋습니다. 하나는 테스트 모듈의 이름을 "
"``test_``\\로 시작하고 테스트 중인 모듈의 이름으로 끝나도록 짓는 것입니다. 테스트 모듈의 테스트 메서드는 "
"``test_``\\로 시작하고 메서드가 테스트하는 내용에 대한 설명으로 끝나야 합니다. 이는 테스트 드라이버가 메서드를 테스트 "
"메서드로 인식하기 위해 필요합니다. 또한, 메서드에 대한 독스트링이 포함되어서는 안 됩니다. 주석(가령 ``# Tests "
"function returns only True or False``)을 사용하여 테스트 메서드에 대한 설명을 제공해야 합니다. 이는"
" 독스트링이 존재하면 이것이 인쇄되어 실행되는 테스트가 인쇄되지 않기 때문입니다."

#: ../../library/test.rst:55
msgid "A basic boilerplate is often used::"
msgstr "기본 상용구가 자주 사용됩니다::"

#: ../../library/test.rst:57
msgid ""
"import unittest\n"
"from test import support\n"
"\n"
"class MyTestCase1(unittest.TestCase):\n"
"\n"
"    # Only use setUp() and tearDown() if necessary\n"
"\n"
"    def setUp(self):\n"
"        ... code to execute in preparation for tests ...\n"
"\n"
"    def tearDown(self):\n"
"        ... code to execute to clean up after tests ...\n"
"\n"
"    def test_feature_one(self):\n"
"        # Test feature one.\n"
"        ... testing code ...\n"
"\n"
"    def test_feature_two(self):\n"
"        # Test feature two.\n"
"        ... testing code ...\n"
"\n"
"    ... more test methods ...\n"
"\n"
"class MyTestCase2(unittest.TestCase):\n"
"    ... same structure as MyTestCase1 ...\n"
"\n"
"... more test classes ...\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""

#: ../../library/test.rst:88
msgid ""
"This code pattern allows the testing suite to be run by "
":mod:`test.regrtest`, on its own as a script that supports the "
":mod:`unittest` CLI, or via the ``python -m unittest`` CLI."
msgstr ""
"이 코드 패턴을 사용하면 :mod:`test.regrtest`\\에서 자체적으로 :mod:`unittest` CLI를 지원하는 "
"스크립트로나 ``python -m unittest`` CLI를 통해 테스트 스위트를 실행할 수 있습니다."

#: ../../library/test.rst:92
msgid ""
"The goal for regression testing is to try to break code. This leads to a "
"few guidelines to be followed:"
msgstr "회귀 테스트의 목표는 코드를 깨려고 시도하는 것입니다. 이는 따라야 할 몇 가지 지침으로 이어집니다:"

#: ../../library/test.rst:95
msgid ""
"The testing suite should exercise all classes, functions, and constants. "
"This includes not just the external API that is to be presented to the "
"outside world but also \"private\" code."
msgstr ""
"테스트 스위트는 모든 클래스, 함수 및 상수를 괴롭혀야 합니다. 여기에는 외부 세계에 제공되는 외부 API뿐만 아니라 "
"\"내부(private)\" 코드도 포함됩니다."

#: ../../library/test.rst:99
msgid ""
"Whitebox testing (examining the code being tested when the tests are "
"being written) is preferred. Blackbox testing (testing only the published"
" user interface) is not complete enough to make sure all boundary and "
"edge cases are tested."
msgstr ""
"화이트 박스 테스트 (테스트 작성 시 테스트 중인 코드 검사)가 선호됩니다. 블랙박스 테스트(게시된 사용자 인터페이스 만 테스트)는"
" 모든 경계와 에지 케이스가 테스트 되었는지 확인하기에 충분하지 않습니다."

#: ../../library/test.rst:104
msgid ""
"Make sure all possible values are tested including invalid ones. This "
"makes sure that not only all valid values are acceptable but also that "
"improper values are handled correctly."
msgstr ""
"유효하지 않은 값을 포함하여 가능한 모든 값이 테스트 되었는지 확인하십시오. 이렇게 하면 모든 유효한 값이 받아들여질 뿐만 아니라 "
"부적절한 값이 올바르게 처리되었는지 확인하게 됩니다."

#: ../../library/test.rst:108
msgid ""
"Exhaust as many code paths as possible. Test where branching occurs and "
"thus tailor input to make sure as many different paths through the code "
"are taken."
msgstr ""
"가능한 한 많은 코드 경로를 소진하십시오. 분기가 발생하는 위치를 테스트하고 입력을 조정하여 코드에서 여러 경로가 사용되는지 "
"확인합니다."

#: ../../library/test.rst:111
msgid ""
"Add an explicit test for any bugs discovered for the tested code. This "
"will make sure that the error does not crop up again if the code is "
"changed in the future."
msgstr ""
"테스트 된 코드에 대해 발견된 버그에 대한 명시적 테스트를 추가합니다. 이렇게 하면 나중에 코드가 변경되어도 에러가 다시 발생하는지"
" 확인합니다."

#: ../../library/test.rst:115
msgid ""
"Make sure to clean up after your tests (such as close and remove all "
"temporary files)."
msgstr "테스트 후에 정리해야 합니다 (가령 모든 임시 파일 닫고 제거하기)."

#: ../../library/test.rst:118
msgid ""
"If a test is dependent on a specific condition of the operating system "
"then verify the condition already exists before attempting the test."
msgstr "테스트가 운영 체제의 특정 조건에 의존하면 테스트를 시도하기 전에 조건이 이미 존재하는지 확인하십시오."

#: ../../library/test.rst:121
msgid ""
"Import as few modules as possible and do it as soon as possible. This "
"minimizes external dependencies of tests and also minimizes possible "
"anomalous behavior from side-effects of importing a module."
msgstr ""
"가능한 한 적은 수의 모듈을 임포트 하고 가능한 한 빨리 수행하십시오. 이렇게 하면 테스트의 외부 종속성이 최소화되고 모듈 임포트의"
" 부작용에 따른 비정상적인 동작이 최소화됩니다."

#: ../../library/test.rst:125
msgid ""
"Try to maximize code reuse. On occasion, tests will vary by something as "
"small as what type of input is used. Minimize code duplication by "
"subclassing a basic test class with a class that specifies the input::"
msgstr ""
"코드 재사용을 극대화하십시오. 때에 따라, 테스트는 사용되는 입력 유형에 따라 조금씩 달라집니다. 입력을 지정하는 클래스로 기본 "
"테스트 클래스를 서브 클래싱하여 코드 중복을 최소화합니다::"

#: ../../library/test.rst:129
msgid ""
"class TestFuncAcceptsSequencesMixin:\n"
"\n"
"    func = mySuperWhammyFunction\n"
"\n"
"    def test_func(self):\n"
"        self.func(self.arg)\n"
"\n"
"class AcceptLists(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = [1, 2, 3]\n"
"\n"
"class AcceptStrings(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = 'abc'\n"
"\n"
"class AcceptTuples(TestFuncAcceptsSequencesMixin, unittest.TestCase):\n"
"    arg = (1, 2, 3)"
msgstr ""

#: ../../library/test.rst:145
#, fuzzy
msgid ""
"When using this pattern, remember that all classes that inherit from "
":class:`unittest.TestCase` are run as tests.  The "
":class:`!TestFuncAcceptsSequencesMixin` class in the example above does "
"not have any data and so can't be run by itself, thus it does not inherit"
" from :class:`unittest.TestCase`."
msgstr ""
"이 패턴을 사용할 때, :class:`unittest.TestCase`\\를 상속한 모든 클래스가 테스트로 실행된다는 점을 "
"기억하십시오. 위 예제의 :class:`Mixin` 클래스는 데이터가 없어서 자체적으로 실행할 수 없기 때문에, "
":class:`unittest.TestCase`\\를 상속하지 않습니다."

#: ../../library/test.rst:153
msgid "Test Driven Development"
msgstr "테스트 주도 개발(Test Driven Development)"

#: ../../library/test.rst:154
msgid "A book by Kent Beck on writing tests before code."
msgstr "코드 전에 테스트를 작성하는 것에 관한 Kent Beck의 책."

#: ../../library/test.rst:160
msgid "Running tests using the command-line interface"
msgstr "명령 줄 인터페이스를 사용하여 테스트 실행하기"

#: ../../library/test.rst:165
msgid ""
"The :mod:`test` package can be run as a script to drive Python's "
"regression test suite, thanks to the :option:`-m` option: "
":program:`python -m test`. Under the hood, it uses :mod:`test.regrtest`; "
"the call :program:`python -m test.regrtest` used in previous Python "
"versions still works.  Running the script by itself automatically starts "
"running all regression tests in the :mod:`test` package. It does this by "
"finding all modules in the package whose name starts with ``test_``, "
"importing them, and executing the function :func:`test_main` if present "
"or loading the tests via unittest.TestLoader.loadTestsFromModule if "
"``test_main`` does not exist.  The names of tests to execute may also be "
"passed to the script. Specifying a single regression test "
"(:program:`python -m test test_spam`) will minimize output and only print"
" whether the test passed or failed."
msgstr ""
":option:`-m` 옵션 덕분에 :mod:`test` 패키지를 스크립트로 실행하여 파이썬의 회귀 테스트 스위트를 구동 할 수 "
"있습니다: :program:`python -m test`. 내부적으로는 :mod:`test.regrtest`\\를 사용합니다; 이전"
" 파이썬 버전에서 사용된 호출 :program:`python -m test.regrtest`\\는 여전히 작동합니다. 스크립트를 "
"단독으로 실행하면 :mod:`test` 패키지의 모든 회귀 테스트 실행이 자동으로 시작됩니다. 패키지에서 이름이 "
"``test_``\\로 시작하는 모든 모듈을 찾아서, 임포트 하고, :func:`test_main` 함수가 있으면 실행하고, "
"``test_main``\\이 없으면 unittest.TestLoader.loadTestsFromModule 을 통해 테스트를 "
"로드하여 이를 수행합니다. 실행할 테스트 이름도 스크립트에 전달할 수 있습니다. 단일 회귀 테스트를 지정하면 "
"(:program:`python -m test test_spam`) 출력이 최소화되고 테스트의 통과나 실패 여부만 인쇄됩니다."

#: ../../library/test.rst:178
msgid ""
"Running :mod:`test` directly allows what resources are available for "
"tests to use to be set. You do this by using the ``-u`` command-line "
"option. Specifying ``all`` as the value for the ``-u`` option enables all"
" possible resources: :program:`python -m test -uall`. If all but one "
"resource is desired (a more common case), a comma-separated list of "
"resources that are not desired may be listed after ``all``. The command "
":program:`python -m test -uall,-audio,-largefile` will run :mod:`test` "
"with all resources except the ``audio`` and ``largefile`` resources. For "
"a list of all resources and more command-line options, run "
":program:`python -m test -h`."
msgstr ""
":mod:`test`\\를 직접 실행하면 테스트에 사용할 수 있는 리소스를 설정할 수 있습니다. ``-u`` 명령 줄 옵션을 "
"사용하여 이 작업을 수행합니다. ``-u`` 옵션의 값으로 ``all``\\을 지정하면 가능한 모든 자원을 사용할 수 있습니다: "
":program:`python -m test -uall`. 하나를 제외한 모든 리소스가 필요한 경우 (더 흔한 경우입니다), 원하지"
" 않는 리소스의 쉼표로 구분된 목록이 ``all`` 뒤에 나열될 수 있습니다. :program:`python -m test "
"-uall,-audio,-largefile` 명령은 ``audio``\\와 ``largefile`` 리소스를 제외한 모든 리소스로 "
":mod:`test`\\를 실행합니다. 모든 리소스와 추가 명령 줄 옵션 목록을 보려면, :program:`python -m "
"test -h`\\를 실행하십시오."

#: ../../library/test.rst:189
msgid ""
"Some other ways to execute the regression tests depend on what platform "
"the tests are being executed on. On Unix, you can run :program:`make "
"test` at the top-level directory where Python was built. On Windows, "
"executing :program:`rt.bat` from your :file:`PCbuild` directory will run "
"all regression tests."
msgstr ""
"회귀 테스트를 실행하는 다른 방법은 테스트가 실행되는 플랫폼에 따라 다릅니다. 유닉스에서는, 파이썬이 빌드된 최상위 디렉터리에서 "
":program:`make test`\\를 실행할 수 있습니다. 윈도우에서는, :file:`PCbuild` 디렉터리에서 "
":program:`rt.bat`\\을 실행하면 모든 회귀 테스트가 실행됩니다."

#: ../../library/test.rst:197
msgid ":mod:`test.support` --- Utilities for the Python test suite"
msgstr ":mod:`test.support` --- 파이썬 테스트 스위트용 유틸리티"

#: ../../library/test.rst:203
msgid ""
"The :mod:`test.support` module provides support for Python's regression "
"test suite."
msgstr ":mod:`test.support` 모듈은 파이썬의 회귀 테스트 스위트를 지원합니다."

#: ../../library/test.rst:208
msgid ""
":mod:`test.support` is not a public module.  It is documented here to "
"help Python developers write tests.  The API of this module is subject to"
" change without backwards compatibility concerns between releases."
msgstr ""
":mod:`test.support`\\는 공용 모듈이 아닙니다. 파이썬 개발자가 테스트를 작성하는 데 도움이 되도록 여기에 설명하고"
" 있습니다. 이 모듈의 API는 릴리스 간에 하위 호환성에 대한 고려 없이 변경될 수 있습니다."

#: ../../library/test.rst:213
msgid "This module defines the following exceptions:"
msgstr "이 모듈은 다음 예외를 정의합니다:"

#: ../../library/test.rst:217
msgid ""
"Exception to be raised when a test fails. This is deprecated in favor of "
":mod:`unittest`\\ -based tests and :class:`unittest.TestCase`'s assertion"
" methods."
msgstr ""
"테스트가 실패할 때 발생하는 예외. 이것은 폐지되었고 :mod:`unittest` 기반 테스트와 "
":class:`unittest.TestCase`\\의 어서션 메서드로 대체합니다."

#: ../../library/test.rst:224
msgid ""
"Subclass of :exc:`unittest.SkipTest`. Raised when a resource (such as a "
"network connection) is not available. Raised by the :func:`requires` "
"function."
msgstr ""
":exc:`unittest.SkipTest`\\의 서브 클래스. 리소스(가령 네트워크 연결)를 사용할 수 없을 때 발생합니다. "
":func:`requires` 함수에 의해 발생합니다."

#: ../../library/test.rst:229
msgid "The :mod:`test.support` module defines the following constants:"
msgstr ":mod:`test.support` 모듈은 다음 상수를 정의합니다:"

#: ../../library/test.rst:233
msgid ""
"``True`` when verbose output is enabled. Should be checked when more "
"detailed information is desired about a running test. *verbose* is set by"
" :mod:`test.regrtest`."
msgstr ""
"상세 출력이 활성화될 때 ``True``. 실행 중인 테스트에 대한 자세한 정보가 필요할 때 확인해야 합니다. "
"*verbose*\\는 :mod:`test.regrtest`\\에 의해 설정됩니다."

#: ../../library/test.rst:240
msgid "``True`` if the running interpreter is Jython."
msgstr "실행 중인 인터프리터가 Jython이면 ``True``."

#: ../../library/test.rst:245
msgid "``True`` if the system is Android."
msgstr "시스템이 안드로이드이면 ``True``."

#: ../../library/test.rst:250
msgid "Path for shell if not on Windows; otherwise ``None``."
msgstr "윈도우가 아니면 셸 경로; 그렇지 않으면 ``None``."

#: ../../library/test.rst:255
msgid ""
"Timeout in seconds for tests using a network server listening on the "
"network local loopback interface like ``127.0.0.1``."
msgstr ""
"``127.0.0.1``\\과 같은 네트워크 로컬 루프 백 인터페이스에서 리스닝하는 네트워크 서버를 사용하는 테스트의 초 단위 제한"
" 시간."

#: ../../library/test.rst:258
msgid ""
"The timeout is long enough to prevent test failure: it takes into account"
" that the client and the server can run in different threads or even "
"different processes."
msgstr ""
"제한 시간은 테스트 실패를 방지 할 수 있을 만큼 깁니다: 클라이언트와 서버가 다른 스레드나 다른 프로세스에서 실행될 수 있다는 "
"점을 고려합니다."

#: ../../library/test.rst:262
msgid ""
"The timeout should be long enough for :meth:`~socket.socket.connect`, "
":meth:`~socket.socket.recv` and :meth:`~socket.socket.send` methods of "
":class:`socket.socket`."
msgstr ""
"제한 시간은 :class:`socket.socket`\\의 :meth:`~socket.socket.connect`, "
":meth:`~socket.socket.recv` 및 :meth:`~socket.socket.send` 메서드를 위해 충분히 길어야"
" 합니다."

#: ../../library/test.rst:266
msgid "Its default value is 5 seconds."
msgstr "기본값은 5초입니다."

#: ../../library/test.rst:268
msgid "See also :data:`INTERNET_TIMEOUT`."
msgstr ":data:`INTERNET_TIMEOUT`\\도 참조하십시오."

#: ../../library/test.rst:273
#, fuzzy
msgid "Timeout in seconds for network requests going to the internet."
msgstr "인터넷으로 가는 네트워크 요청에 대한 초 단위 제한 시간."

#: ../../library/test.rst:275
#, fuzzy
msgid ""
"The timeout is short enough to prevent a test to wait for too long if the"
" internet request is blocked for whatever reason."
msgstr "어떤 이유로 든 인터넷 요청이 블록 되면 테스트가 너무 오래 기다리지 않을 만큼 제한 시간이 적당히 짧습니다."

#: ../../library/test.rst:278
msgid ""
"Usually, a timeout using :data:`INTERNET_TIMEOUT` should not mark a test "
"as failed, but skip the test instead: see "
":func:`~test.support.socket_helper.transient_internet`."
msgstr ""
"일반적으로, :data:`INTERNET_TIMEOUT`\\을 사용하는 시간 초과는 테스트를 실패로 표시해서는 안 되며, 대신 "
"테스트를 건너뜁니다: :func:`~test.support.socket_helper.transient_internet`\\을 "
"참조하십시오."

#: ../../library/test.rst:282
msgid "Its default value is 1 minute."
msgstr "기본값은 1분입니다."

#: ../../library/test.rst:284
msgid "See also :data:`LOOPBACK_TIMEOUT`."
msgstr ":data:`LOOPBACK_TIMEOUT`\\도 참조하십시오."

#: ../../library/test.rst:289
msgid ""
"Timeout in seconds to mark a test as failed if the test takes \"too "
"long\"."
msgstr "테스트가 \"너무 오래\" 걸리면 테스트를 실패로 표시하는 초 단위 제한 시간."

#: ../../library/test.rst:291
msgid ""
"The timeout value depends on the regrtest ``--timeout`` command line "
"option."
msgstr "제한 시간 값은 regrtest ``--timeout`` 명령 줄 옵션에 따라 다릅니다."

#: ../../library/test.rst:293
msgid ""
"If a test using :data:`SHORT_TIMEOUT` starts to fail randomly on slow "
"buildbots, use :data:`LONG_TIMEOUT` instead."
msgstr ""
":data:`SHORT_TIMEOUT`\\을 사용하는 테스트가 느린 빌드 봇에서 무작위로 실패하기 시작하면, 대신 "
":data:`LONG_TIMEOUT`\\을 사용합니다."

#: ../../library/test.rst:296
msgid "Its default value is 30 seconds."
msgstr "기본값은 30초입니다."

#: ../../library/test.rst:301
msgid "Timeout in seconds to detect when a test hangs."
msgstr "테스트 멈춤을 감지하기 위한 초 단위 제한 시간."

#: ../../library/test.rst:303
msgid ""
"It is long enough to reduce the risk of test failure on the slowest "
"Python buildbots. It should not be used to mark a test as failed if the "
"test takes \"too long\".  The timeout value depends on the regrtest "
"``--timeout`` command line option."
msgstr ""
"가장 느린 파이썬 빌드 봇에서 테스트 실패의 위험을 줄이기에 충분히 깁니다. 테스트가 \"너무 오래\" 걸리면 테스트를 실패로 "
"표시하는 데 사용해서는 안 됩니다. 제한 시간 값은 regrtest ``--timeout`` 명령 줄 옵션에 따라 다릅니다."

#: ../../library/test.rst:308
msgid "Its default value is 5 minutes."
msgstr "기본값은 5분입니다."

#: ../../library/test.rst:310
msgid ""
"See also :data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` and "
":data:`SHORT_TIMEOUT`."
msgstr ""
":data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` 및 "
":data:`SHORT_TIMEOUT`\\도 참조하십시오."

#: ../../library/test.rst:316
msgid "Set when tests can be skipped when they are not useful for PGO."
msgstr "PGO에 유용하지 않은 테스트를 건너뛸 수 있을 때 설정합니다."

#: ../../library/test.rst:321
msgid ""
"A constant that is likely larger than the underlying OS pipe buffer size,"
" to make writes blocking."
msgstr "쓰기 블로킹을 일으키기 위해, 하부 OS 파이프 버퍼 크기보다 클 가능성이 높은 상수."

#: ../../library/test.rst:327
msgid ""
"``True`` if Python was built with the :c:macro:`Py_DEBUG` macro defined, "
"that is, if Python was :ref:`built in debug mode <debug-build>`."
msgstr ""

#: ../../library/test.rst:336
msgid ""
"A constant that is likely larger than the underlying OS socket buffer "
"size, to make writes blocking."
msgstr "쓰기 블로킹을 일으키기 위해, 하부 OS 소켓 버퍼 크기보다 클 가능성이 높은 상수."

#: ../../library/test.rst:342
msgid "Set to the top level directory that contains :mod:`test.support`."
msgstr ":mod:`test.support`\\를 포함하는 최상위 디렉터리로 설정합니다."

#: ../../library/test.rst:347
msgid "Set to the top level directory for the test package."
msgstr "테스트 패키지의 최상위 디렉터리로 설정합니다."

#: ../../library/test.rst:352
msgid "Set to the ``data`` directory within the test package."
msgstr "테스트 패키지 내의 ``data`` 디렉터리로 설정합니다."

#: ../../library/test.rst:357
msgid "Set to :data:`sys.maxsize` for big memory tests."
msgstr "대용량 메모리 테스트를 위해 :data:`sys.maxsize`\\로 설정합니다."

#: ../../library/test.rst:362
msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests. "
"Limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"대용량 메모리 테스트를 위한 메모리 제한으로 :func:`set_memlimit`\\에 의해 설정됩니다. "
":data:`MAX_Py_ssize_t`\\에 의해 제한됩니다."

#: ../../library/test.rst:368
msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests.  "
"Not limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"대용량 메모리 테스트를 위한 메모리 제한으로 :func:`set_memlimit`\\에 의해 설정됩니다. "
":data:`MAX_Py_ssize_t`\\에 의해 제한되지 않습니다."

#: ../../library/test.rst:374
msgid ""
"Set to ``True`` if Python is built without docstrings (the "
":c:macro:`WITH_DOC_STRINGS` macro is not defined). See the "
":option:`configure --without-doc-strings <--without-doc-strings>` option."
msgstr ""

#: ../../library/test.rst:378
msgid "See also the :data:`HAVE_DOCSTRINGS` variable."
msgstr ""

#: ../../library/test.rst:383
msgid ""
"Set to ``True`` if function docstrings are available. See the "
":option:`python -OO <-O>` option, which strips docstrings of functions "
"implemented in Python."
msgstr ""

#: ../../library/test.rst:386
msgid "See also the :data:`MISSING_C_DOCSTRINGS` variable."
msgstr ""

#: ../../library/test.rst:391
msgid "Define the URL of a dedicated HTTP server for the network tests."
msgstr "네트워크 테스트를 위한 전용 HTTP 서버의 URL을 정의합니다."

#: ../../library/test.rst:396
msgid "Object that is equal to anything.  Used to test mixed type comparison."
msgstr "모든 것과 같은 객체. 혼합형 비교를 테스트하는 데 사용됩니다."

#: ../../library/test.rst:401
msgid ""
"Object that is not equal to anything (even to :data:`ALWAYS_EQ`). Used to"
" test mixed type comparison."
msgstr "어떤 것과도 같지 않은 객체 (:data:`ALWAYS_EQ`\\에도 해당합니다). 혼합형 비교를 테스트하는 데 사용됩니다."

#: ../../library/test.rst:407
msgid ""
"Object that is greater than anything (except itself). Used to test mixed "
"type comparison."
msgstr "모든 것보다 큰 객체 (자신은 제외하고). 혼합형 비교를 테스트하는 데 사용됩니다."

#: ../../library/test.rst:413
msgid ""
"Object that is less than anything (except itself). Used to test mixed "
"type comparison."
msgstr "모든 것보다 작은 객체 (자신은 제외하고). 혼합형 비교를 테스트하는 데 사용됩니다."

#: ../../library/test.rst:417
msgid "The :mod:`test.support` module defines the following functions:"
msgstr ":mod:`test.support` 모듈은 다음 함수를 정의합니다:"

#: ../../library/test.rst:421
msgid "Run the loop body until ``break`` stops the loop."
msgstr ""

#: ../../library/test.rst:423
msgid ""
"After *timeout* seconds, raise an :exc:`AssertionError` if *error* is "
"true, or just stop the loop if *error* is false."
msgstr ""

#: ../../library/test.rst:426
#, fuzzy
msgid "Example::"
msgstr "사용 예::"

#: ../../library/test.rst:428
msgid ""
"for _ in support.busy_retry(support.SHORT_TIMEOUT):\n"
"    if check():\n"
"        break"
msgstr ""

#: ../../library/test.rst:432 ../../library/test.rst:456
#, fuzzy
msgid "Example of error=False usage::"
msgstr "사용 예::"

#: ../../library/test.rst:434
msgid ""
"for _ in support.busy_retry(support.SHORT_TIMEOUT, error=False):\n"
"    if check():\n"
"        break\n"
"else:\n"
"    raise RuntimeError('my custom error')"
msgstr ""

#: ../../library/test.rst:442
msgid "Wait strategy that applies exponential backoff."
msgstr ""

#: ../../library/test.rst:444
msgid ""
"Run the loop body until ``break`` stops the loop. Sleep at each loop "
"iteration, but not at the first iteration. The sleep delay is doubled at "
"each iteration (up to *max_delay* seconds)."
msgstr ""

#: ../../library/test.rst:448
msgid "See :func:`busy_retry` documentation for the parameters usage."
msgstr ""

#: ../../library/test.rst:450
msgid "Example raising an exception after SHORT_TIMEOUT seconds::"
msgstr ""

#: ../../library/test.rst:452
msgid ""
"for _ in support.sleeping_retry(support.SHORT_TIMEOUT):\n"
"    if check():\n"
"        break"
msgstr ""

#: ../../library/test.rst:458
msgid ""
"for _ in support.sleeping_retry(support.SHORT_TIMEOUT, error=False):\n"
"    if check():\n"
"        break\n"
"else:\n"
"    raise RuntimeError('my custom error')"
msgstr ""

#: ../../library/test.rst:466
msgid ""
"Return ``True`` if *resource* is enabled and available. The list of "
"available resources is only set when :mod:`test.regrtest` is executing "
"the tests."
msgstr ""
"*resource*\\가 활성화되고 사용할 수 있으면 ``True``\\를 반환합니다. 사용 가능한 리소스 목록은 "
":mod:`test.regrtest`\\가 테스트를 실행할 때만 설정됩니다."

#: ../../library/test.rst:473
msgid "Return ``True`` if Python was not built with ``-O0`` or ``-Og``."
msgstr "파이썬이 ``-O0``\\이나 ``-Og``\\로 빌드되지 않았으면 ``True``\\를 반환합니다."

#: ../../library/test.rst:478
#, fuzzy
msgid "Return :const:`_testcapi.WITH_PYMALLOC`."
msgstr ":data:`_testcapi.WITH_PYMALLOC`\\을 반환합니다."

#: ../../library/test.rst:483
msgid ""
"Raise :exc:`ResourceDenied` if *resource* is not available. *msg* is the "
"argument to :exc:`ResourceDenied` if it is raised. Always returns "
"``True`` if called by a function whose ``__name__`` is ``'__main__'``. "
"Used when tests are executed by :mod:`test.regrtest`."
msgstr ""
"*resource*\\를 사용할 수 없으면 :exc:`ResourceDenied`\\를 발생시킵니다. *msg*\\는 "
":exc:`ResourceDenied`\\가 발생한다면 이에 대한 인자입니다. ``__name__``\\이 "
"``'__main__'``\\인 함수에 의해 호출되면 항상 ``True``\\를 반환합니다. "
":mod:`test.regrtest`\\에서 테스트를 실행할 때 사용됩니다."

#: ../../library/test.rst:491
msgid "Return a repr of *dict* with keys sorted."
msgstr "정렬된 키로 *dict*\\의 repr을 반환합니다."

#: ../../library/test.rst:496
msgid ""
"Return the path to the file named *filename*. If no match is found "
"*filename* is returned. This does not equal a failure since it could be "
"the path to the file."
msgstr ""
"*filename*\\이라는 파일의 경로를 반환합니다. 일치하는 것이 없으면 *filename*\\이 반환됩니다. 이것은 파일의 "
"경로일 수 있어서 실패와 같지 않습니다."

#: ../../library/test.rst:500
msgid ""
"Setting *subdir* indicates a relative path to use to find the file rather"
" than looking directly in the path directories."
msgstr "*subdir* 설정은 경로 디렉터리를 직접 찾는 대신 파일을 찾는 데 사용할 상대 경로를 나타냅니다."

#: ../../library/test.rst:506
msgid "Get size of a page in bytes."
msgstr ""

#: ../../library/test.rst:513
msgid ""
"Set the :func:`sys.setswitchinterval` to the given *interval*.  Defines a"
" minimum interval for Android systems to prevent the system from hanging."
msgstr ""
":func:`sys.setswitchinterval`\\을 주어진 *interval*\\로 설정합니다. 시스템이 멈추는 것을 "
"방지하기 위해 안드로이드 시스템을 위한 최소 간격을 정의합니다."

#: ../../library/test.rst:519
#, fuzzy
msgid ""
"Use this check to guard CPython's implementation-specific tests or to run"
" them only on the implementations guarded by the arguments.  This "
"function returns ``True`` or ``False`` depending on the host platform. "
"Example usage::"
msgstr "이 검사를 사용하여 CPython의 구현 별 테스트를 보호하거나 인자로 보호되는 구현에서만 실행합니다::"

#: ../../library/test.rst:524
msgid ""
"check_impl_detail()               # Only on CPython (default).\n"
"check_impl_detail(jython=True)    # Only on Jython.\n"
"check_impl_detail(cpython=False)  # Everywhere except CPython."
msgstr ""

#: ../../library/test.rst:531
msgid ""
"Set the values for :data:`max_memuse` and :data:`real_max_memuse` for big"
" memory tests."
msgstr "대용량 메모리 테스트를 위해 :data:`max_memuse`\\와 :data:`real_max_memuse` 값을 설정합니다."

#: ../../library/test.rst:537
msgid ""
"Store the value from *stdout*.  It is meant to hold the stdout at the "
"time the regrtest began."
msgstr "*stdout*\\의 값을 저장합니다. regrtest가 시작될 때 stdout을 잡기 위한 것입니다."

#: ../../library/test.rst:543
msgid ""
"Return the original stdout set by :func:`record_original_stdout` or "
"``sys.stdout`` if it's not set."
msgstr ""
":func:`record_original_stdout`\\에 의해 설정된 원래 stdout이나 설정되지 않았으면 "
"``sys.stdout``\\을 반환합니다."

#: ../../library/test.rst:549
msgid ""
"Return a list of command line arguments reproducing the current settings "
"in ``sys.flags`` and ``sys.warnoptions``."
msgstr "``sys.flags``\\와 ``sys.warnoptions``\\의 현재 설정을 재현하는 명령 줄 인자 리스트를 반환합니다."

#: ../../library/test.rst:555
msgid ""
"Return a list of command line arguments reproducing the current "
"optimization settings in ``sys.flags``."
msgstr "``sys.flags``\\의 현재 최적화 설정을 재현하는 명령 줄 인자 리스트를 반환합니다."

#: ../../library/test.rst:563
msgid ""
"A context managers that temporarily replaces the named stream with "
":class:`io.StringIO` object."
msgstr "명명된 스트림을 :class:`io.StringIO` 객체로 일시적으로 대체하는 컨텍스트 관리자."

#: ../../library/test.rst:566
msgid "Example use with output streams::"
msgstr "출력 스트림 사용 예::"

#: ../../library/test.rst:568
msgid ""
"with captured_stdout() as stdout, captured_stderr() as stderr:\n"
"    print(\"hello\")\n"
"    print(\"error\", file=sys.stderr)\n"
"assert stdout.getvalue() == \"hello\\n\"\n"
"assert stderr.getvalue() == \"error\\n\""
msgstr ""

#: ../../library/test.rst:574
msgid "Example use with input stream::"
msgstr "입력 스트림 사용 예::"

#: ../../library/test.rst:576
msgid ""
"with captured_stdin() as stdin:\n"
"    stdin.write('hello\\n')\n"
"    stdin.seek(0)\n"
"    # call test code that consumes from sys.stdin\n"
"    captured = input()\n"
"self.assertEqual(captured, \"hello\")"
msgstr ""

#: ../../library/test.rst:586
#, fuzzy
msgid "A context manager that temporary disables :mod:`faulthandler`."
msgstr "프로세스 umask를 임시로 설정하는 컨텍스트 관리자."

#: ../../library/test.rst:591
msgid ""
"Force as many objects as possible to be collected.  This is needed "
"because timely deallocation is not guaranteed by the garbage collector.  "
"This means that ``__del__`` methods may be called later than expected and"
" weakrefs may remain alive for longer than expected."
msgstr ""
"가능한 한 많은 객체를 수거하도록 강제합니다. 이는 가비지 수거기가 적시에 할당 해제를 보장하지 않기 때문에 필요합니다. 이는 "
"``__del__`` 메서드가 예상보다 늦게 호출될 수 있고 약한 참조(weakrefs)가 예상보다 오래 살아있을 수 있음을 "
"의미합니다."

#: ../../library/test.rst:599
#, fuzzy
msgid ""
"A context manager that disables the garbage collector on entry. On exit, "
"the garbage collector is restored to its prior state."
msgstr "진입할 때 가비지 수거기를 비활성화하고 탈출할 때 다시 활성화하는 컨텍스트 관리자."

#: ../../library/test.rst:605
msgid "Context manager to swap out an attribute with a new object."
msgstr "어트리뷰트를 새 객체로 스와프하는 컨텍스트 관리자."

#: ../../library/test.rst:607 ../../library/test.rst:625
#: ../../library/test.rst:866 ../../library/test.rst:1332
msgid "Usage::"
msgstr "용법::"

#: ../../library/test.rst:609
msgid ""
"with swap_attr(obj, \"attr\", 5):\n"
"    ..."
msgstr ""

#: ../../library/test.rst:612
msgid ""
"This will set ``obj.attr`` to 5 for the duration of the ``with`` block, "
"restoring the old value at the end of the block.  If ``attr`` doesn't "
"exist on ``obj``, it will be created and then deleted at the end of the "
"block."
msgstr ""
"이렇게 하면 ``with`` 블록의 기간 중 ``obj.attr``\\이 5로 설정되고, 블록 끝에서 이전 값이 복원됩니다. "
"``obj``\\에 ``attr``\\이 없으면, 만들어지고 블록의 끝에서 삭제됩니다."

#: ../../library/test.rst:617 ../../library/test.rst:635
msgid ""
"The old value (or ``None`` if it doesn't exist) will be assigned to the "
"target of the \"as\" clause, if there is one."
msgstr "이전 값(또는 존재하지 않으면 ``None``)이 \"as\" 절의 대상(있다면)에 대입됩니다."

#: ../../library/test.rst:623
msgid "Context manager to swap out an item with a new object."
msgstr "항목을 새 객체로 스와프하는 컨텍스트 관리자."

#: ../../library/test.rst:627
msgid ""
"with swap_item(obj, \"item\", 5):\n"
"    ..."
msgstr ""

#: ../../library/test.rst:630
msgid ""
"This will set ``obj[\"item\"]`` to 5 for the duration of the ``with`` "
"block, restoring the old value at the end of the block. If ``item`` "
"doesn't exist on ``obj``, it will be created and then deleted at the end "
"of the block."
msgstr ""
"이렇게 하면 ``with`` 블록의 기간 중 ``obj[\"item\"]``\\이 5로 설정되고, 블록 끝에서 이전 값이 "
"복원됩니다. ``obj``\\에 ``item``\\이 없으면, 만들어지고 블록의 끝에서 삭제됩니다."

#: ../../library/test.rst:641
msgid ""
"Call the ``flush()`` method on :data:`sys.stdout` and then on "
":data:`sys.stderr`. It can be used to make sure that the logs order is "
"consistent before writing into stderr."
msgstr ""

#: ../../library/test.rst:650
#, python-brace-format
msgid ""
"Print a warning into :data:`sys.__stderr__`. Format the message as: "
"``f\"Warning -- {msg}\"``. If *msg* is made of multiple lines, add "
"``\"Warning -- \"`` prefix to each line."
msgstr ""
":data:`sys.__stderr__`\\에 경고를 인쇄합니다. 메시지를 다음처럼 포맷합니다: ``f\"Warning -- "
"{msg}\"``. *msg*\\가 여러 줄로 구성되면, 각 줄에 ``\"Warning -- \"`` 접두사를 추가합니다."

#: ../../library/test.rst:659
msgid ""
"Wait until process *pid* completes and check that the process exit code "
"is *exitcode*."
msgstr "프로세스 *pid*\\가 완료될 때까지 기다렸다가 프로세스 종료 코드가 *exitcode*\\인지 확인합니다."

#: ../../library/test.rst:662
msgid ""
"Raise an :exc:`AssertionError` if the process exit code is not equal to "
"*exitcode*."
msgstr "프로세스 종료 코드가 *exitcode*\\와 같지 않으면 :exc:`AssertionError`\\를 발생시킵니다."

#: ../../library/test.rst:665
msgid ""
"If the process runs longer than *timeout* seconds (:data:`SHORT_TIMEOUT` "
"by default), kill the process and raise an :exc:`AssertionError`. The "
"timeout feature is not available on Windows."
msgstr ""
"프로세스가 *timeout*\\(기본적으로 :data:`SHORT_TIMEOUT`) 초보다 오래 실행되면, 프로세스를 죽이고 "
":exc:`AssertionError`\\를 발생시킵니다. 제한 시간 기능은 윈도우에서 사용할 수 없습니다."

#: ../../library/test.rst:674
msgid ""
"Return the size of the :c:type:`PyObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python "
"object header and alignment."
msgstr ""

#: ../../library/test.rst:680
msgid ""
"Return the size of the :c:type:`PyVarObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python "
"object header and alignment."
msgstr ""

#: ../../library/test.rst:686
msgid ""
"For testcase *test*, assert that the ``sys.getsizeof`` for *o* plus the "
"GC header size equals *size*."
msgstr ""
"테스트 케이스 *test*\\에 대해, *o*\\의 ``sys.getsizeof``\\에 GC 헤더 크기를 더한 값이 "
"*size*\\와 같다고 어서션 합니다."

#: ../../library/test.rst:692
msgid ""
"A decorator to conditionally mark tests with "
":func:`unittest.expectedFailure`. Any use of this decorator should have "
"an associated comment identifying the relevant tracker issue."
msgstr ""
":func:`unittest.expectedFailure`\\로 테스트를 조건부로 표시하는 데코레이터. 이 데코레이터를 사용하려면 "
"관련 추적기(tracker) 이슈를 식별하는 관련 주석이 있어야 합니다."

#: ../../library/test.rst:699
#, fuzzy
msgid ""
"A decorator that skips the decorated test on TLS certification validation"
" failures."
msgstr "TLS 인증서 유효성 검사 실패 시 :exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:704
msgid ""
"A decorator for running a function in a different locale, correctly "
"resetting it after it has finished.  *catstr* is the locale category as a"
" string (for example ``\"LC_ALL\"``).  The *locales* passed will be tried"
" sequentially, and the first valid locale will be used."
msgstr ""
"다른 로케일에서 함수를 실행하기 위한 데코레이터로, 완료된 후 올바르게 재설정합니다. *catstr*\\은 문자열로 된 로케일 "
"범주입니다 (예를 들어 ``\"LC_ALL\"``). 전달된 *locales*\\는 순차적으로 시도되며, 첫 번째 유효한 로케일이 "
"사용됩니다."

#: ../../library/test.rst:712
msgid ""
"A decorator for running a function in a specific timezone, correctly "
"resetting it after it has finished."
msgstr "특정 시간대에서 함수를 실행하기 위한 데코레이터로, 완료된 후 올바르게 재설정합니다."

#: ../../library/test.rst:718
#, fuzzy
msgid ""
"Decorator for the minimum version when running test on FreeBSD.  If the "
"FreeBSD version is less than the minimum, the test is skipped."
msgstr ""
"FreeBSD에서 테스트를 실행할 때 최소 버전을 위한 데코레이터. FreeBSD 버전이 최소 버전보다 낮으면, "
":exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:724
#, fuzzy
msgid ""
"Decorator for the minimum version when running test on Linux.  If the "
"Linux version is less than the minimum, the test is skipped."
msgstr ""
"리눅스에서 테스트를 실행할 때 최소 버전을 위한 데코레이터. 리눅스 버전이 최소 버전보다 낮으면, "
":exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:730
#, fuzzy
msgid ""
"Decorator for the minimum version when running test on macOS.  If the "
"macOS version is less than the minimum, the test is skipped."
msgstr ""
"Mac OS X에서 테스트를 실행할 때 최소 버전을 위한 데코레이터. MAC OS X 버전이 최소 버전보다 낮으면, "
":exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:736
msgid ""
"Decorator for skipping tests on the free-threaded build.  If the "
":term:`GIL` is disabled, the test is skipped."
msgstr ""

#: ../../library/test.rst:742
msgid "Decorator for skipping tests on non-IEEE 754 platforms."
msgstr "비 IEEE 754 플랫폼에서 테스트를 건너뛰는 데코레이터."

#: ../../library/test.rst:747
msgid "Decorator for skipping tests if :mod:`zlib` doesn't exist."
msgstr ":mod:`zlib`\\가 없으면 테스트를 건너뛰는 데코레이터."

#: ../../library/test.rst:752
msgid "Decorator for skipping tests if :mod:`gzip` doesn't exist."
msgstr ":mod:`gzip`\\이 없으면 테스트를 건너뛰는 데코레이터."

#: ../../library/test.rst:757
msgid "Decorator for skipping tests if :mod:`bz2` doesn't exist."
msgstr ":mod:`bz2`\\가 없으면 테스트를 건너뛰는 데코레이터."

#: ../../library/test.rst:762
msgid "Decorator for skipping tests if :mod:`lzma` doesn't exist."
msgstr ":mod:`lzma`\\가 없으면 테스트를 건너뛰는 데코레이터."

#: ../../library/test.rst:767
msgid "Decorator for skipping tests if *resource* is not available."
msgstr "*resource*\\를 사용할 수 없으면 테스트를 건너뛰는 데코레이터."

#: ../../library/test.rst:772
msgid "Decorator for only running the test if :data:`HAVE_DOCSTRINGS`."
msgstr ":data:`HAVE_DOCSTRINGS`\\일 때만 테스트를 실행하는 데코레이터."

#: ../../library/test.rst:777
#, fuzzy
msgid ""
"Decorator for only running the test if :ref:`Limited C API "
"<limited-c-api>` is available."
msgstr ":data:`HAVE_DOCSTRINGS`\\일 때만 테스트를 실행하는 데코레이터."

#: ../../library/test.rst:783
msgid "Decorator for tests only applicable to CPython."
msgstr "CPython에만 적용되는 테스트용 데코레이터."

#: ../../library/test.rst:788
msgid ""
"Decorator for invoking :func:`check_impl_detail` on *guards*.  If that "
"returns ``False``, then uses *msg* as the reason for skipping the test."
msgstr ""
"*guards*\\에 :func:`check_impl_detail`\\을 호출하는 데코레이터. ``False``\\가 반환되면, "
"테스트를 건너뛰는 이유로 *msg*\\를 사용합니다."

#: ../../library/test.rst:794
msgid "Decorator to temporarily turn off tracing for the duration of the test."
msgstr "테스트 기간 중 일시적으로 추적을 해제하는 데코레이터."

#: ../../library/test.rst:799
msgid ""
"Decorator for tests which involve reference counting.  The decorator does"
" not run the test if it is not run by CPython.  Any trace function is "
"unset for the duration of the test to prevent unexpected refcounts caused"
" by the trace function."
msgstr ""
"참조 횟수를 수반하는 테스트를 위한 데코레이터. 데코레이터는 CPython에 의해 실행되지 않으면 테스트를 실행하지 않습니다. 추적"
" 함수로 인한 예기치 않은 참조 횟수를 방지하기 위해 테스트 기간 중 모든 추적 함수가 설정 해제됩니다."

#: ../../library/test.rst:807
msgid "Decorator for bigmem tests."
msgstr "bigmem 테스트를 위한 데코레이터."

#: ../../library/test.rst:809
msgid ""
"*size* is a requested size for the test (in arbitrary, test-interpreted "
"units.)  *memuse* is the number of bytes per unit for the test, or a good"
" estimate of it.  For example, a test that needs two byte buffers, of 4 "
"GiB each, could be decorated with ``@bigmemtest(size=_4G, memuse=2)``."
msgstr ""
"*size*\\는 테스트를 위해 요청된 크기입니다 (임의의 테스트가 해석하는 단위.) *memuse*\\는 테스트 단위당 바이트 "
"수, 또는 이의 적절한 추정치입니다. 예를 들어, 각각 4GiB인 두 개의 바이트 버퍼가 필요한 테스트는 "
"``@bigmemtest(size=_4G, memuse=2)``\\로 데코레이트 될 수 있습니다."

#: ../../library/test.rst:814
msgid ""
"The *size* argument is normally passed to the decorated test method as an"
" extra argument.  If *dry_run* is ``True``, the value passed to the test "
"method may be less than the requested value.  If *dry_run* is ``False``, "
"it means the test doesn't support dummy runs when ``-M`` is not "
"specified."
msgstr ""
"*size* 인자는 일반적으로 데코레이트 된 테스트 메서드에 추가 인자로 전달됩니다. *dry_run*\\이 "
"``True``\\이면, 테스트 메서드에 전달된 값이 요청된 값보다 작을 수 있습니다. *dry_run*\\이 "
"``False``\\이면, ``-M``\\가 지정되지 않은 경우 테스트가 더미 실행을 지원하지 않음을 의미합니다."

#: ../../library/test.rst:822
#, fuzzy
msgid "Decorator for tests that fill the address space."
msgstr "주소 공간을 채우는 테스트용 데코레이터. *f*\\는 래핑 할 함수입니다."

#: ../../library/test.rst:827
msgid ""
"Test for syntax errors in *statement* by attempting to compile "
"*statement*. *testcase* is the :mod:`unittest` instance for the test.  "
"*errtext* is the regular expression which should match the string "
"representation of the raised :exc:`SyntaxError`.  If *lineno* is not "
"``None``, compares to the line of the exception.  If *offset* is not "
"``None``, compares to the offset of the exception."
msgstr ""
"*statement* 컴파일을 시도하여 *statement*\\의 구문 에러를 테스트합니다. *testcase*\\는 테스트를 위한"
" :mod:`unittest` 인스턴스입니다. *errtext*\\는 발생한 :exc:`SyntaxError`\\의 문자열 표현과 "
"일치해야 하는 정규식입니다. *lineno*\\가 ``None``\\이 아니면, 예외 줄과 비교합니다. *offset*\\이 "
"``None``\\이 아니면, 예외의 오프셋과 비교합니다."

#: ../../library/test.rst:837
msgid "Open *url*.  If open fails, raises :exc:`TestFailed`."
msgstr "*url*\\을 엽니다. 열기에 실패하면, :exc:`TestFailed`\\를 발생시킵니다."

#: ../../library/test.rst:842
msgid ""
"Use this at the end of ``test_main`` whenever sub-processes are started. "
"This will help ensure that no extra children (zombies) stick around to "
"hog resources and create problems when looking for refleaks."
msgstr ""
"서브 프로세스가 시작될 때마다 ``test_main`` 끝에 이것을 사용하십시오. 이렇게 하면 여분의 자식(좀비)이 남아서 리소스를"
" 탐하지 않도록 하고 참조 누수를 찾을 때 문제가 발생하지 않도록 할 수 있습니다."

#: ../../library/test.rst:849
msgid ""
"Get an attribute, raising :exc:`unittest.SkipTest` if "
":exc:`AttributeError` is raised."
msgstr ""
"어트리뷰트를 가져옵니다, :exc:`AttributeError`\\가 발생하면 :exc:`unittest.SkipTest`\\를 "
"발생시킵니다."

#: ../../library/test.rst:855
msgid ""
"Context manager catching unraisable exception using "
":func:`sys.unraisablehook`."
msgstr ""
":func:`sys.unraisablehook`\\를 사용하여 발생시킬 수 없는(unraisable) 예외를 포착하는 컨텍스트 "
"관리자."

#: ../../library/test.rst:858
msgid ""
"Storing the exception value (``cm.unraisable.exc_value``) creates a "
"reference cycle. The reference cycle is broken explicitly when the "
"context manager exits."
msgstr ""
"예외 값(``cm.unraisable.exc_value``)을 저장하면 참조 순환을 만듭니다. 컨텍스트 관리자가 탈출할 때 참조 "
"순환이 명시적으로 끊어집니다."

#: ../../library/test.rst:862
msgid ""
"Storing the object (``cm.unraisable.object``) can resurrect it if it is "
"set to an object which is being finalized. Exiting the context manager "
"clears the stored object."
msgstr ""
"객체(``cm.unraisable.object``)를 저장하면 파이널라이즈 중인 객체로 설정되어 있으면 되살릴 수 있습니다. "
"컨텍스트 관리자를 탈출하면 저장된 객체가 지워집니다."

#: ../../library/test.rst:868
msgid ""
"with support.catch_unraisable_exception() as cm:\n"
"    # code creating an \"unraisable exception\"\n"
"    ...\n"
"\n"
"    # check the unraisable exception: use cm.unraisable\n"
"    ...\n"
"\n"
"# cm.unraisable attribute no longer exists at this point\n"
"# (to break a reference cycle)"
msgstr ""

#: ../../library/test.rst:883
msgid ""
"Generic implementation of the :mod:`unittest` ``load_tests`` protocol for"
" use in test packages.  *pkg_dir* is the root directory of the package; "
"*loader*, *standard_tests*, and *pattern* are the arguments expected by "
"``load_tests``.  In simple cases, the test package's ``__init__.py`` can "
"be the following::"
msgstr ""
"테스트 패키지에서 사용하기 위한 :mod:`unittest` ``load_tests`` 프로토콜의 일반 구현. "
"*pkg_dir*\\는 패키지의 루트 디렉터리입니다; *loader*, *standard_tests* 및 *pattern*\\은 "
"``load_tests``\\가 기대하는 인자입니다. 간단한 경우, 테스트 패키지의 ``__init__.py``\\는 다음과 같을 "
"수 있습니다::"

#: ../../library/test.rst:889
msgid ""
"import os\n"
"from test.support import load_package_tests\n"
"\n"
"def load_tests(*args):\n"
"    return load_package_tests(os.path.dirname(__file__), *args)"
msgstr ""

#: ../../library/test.rst:898
msgid ""
"Returns the set of attributes, functions or methods of *ref_api* not "
"found on *other_api*, except for a defined list of items to be ignored in"
" this check specified in *ignore*."
msgstr ""
"*ignore*\\에 지정된 이 검사에서 무시할 정의된 항목 리스트를 제외하고, *other_api*\\에서 찾을 수 없는 "
"*ref_api*\\의 어트리뷰트, 함수 또는 메서드 집합을 반환합니다."

#: ../../library/test.rst:902
msgid ""
"By default this skips private attributes beginning with '_' but includes "
"all magic methods, i.e. those starting and ending in '__'."
msgstr ""
"기본적으로 이것은 '_'로 시작하는 내부(private) 어트리뷰트를 건너뛰지만, 모든 매직 메서드, 즉 '__'로 시작하고 끝나는"
" 것들을 포함합니다."

#: ../../library/test.rst:910
msgid ""
"Override *object_to_patch.attr_name* with *new_value*.  Also add cleanup "
"procedure to *test_instance* to restore *object_to_patch* for "
"*attr_name*.  The *attr_name* should be a valid attribute for "
"*object_to_patch*."
msgstr ""
"*object_to_patch.attr_name*\\을 *new_value*\\로 대체합니다. 또한 "
"*test_instance*\\에 대한 정리 절차를 추가하여 *object_to_patch*\\의 *attr_name*\\을 "
"복원합니다. *attr_name*\\은 *object_to_patch*\\의 유효한 어트리뷰트여야 합니다."

#: ../../library/test.rst:918
msgid ""
"Run *code* in subinterpreter.  Raise :exc:`unittest.SkipTest` if "
":mod:`tracemalloc` is enabled."
msgstr ""
"서브 인터프리터에서 *code*\\를 실행합니다. :mod:`tracemalloc`\\이 활성화되면 "
":exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:924
#, fuzzy
msgid "Assert instances of *cls* are deallocated after iterating."
msgstr "이터레이션 후 *iter*\\가 할당 해제되었음을 어서션 합니다."

#: ../../library/test.rst:929
msgid ""
"Check for the existence of the compiler executables whose names are "
"listed in *cmd_names* or all the compiler executables when *cmd_names* is"
" empty and return the first missing executable or ``None`` when none is "
"found missing."
msgstr ""
"*cmd_names*\\에 이름이 나열된 컴파일러 실행 파일이나 *cmd_names*\\가 비어있을 때 모든 컴파일러 실행 파일이 "
"있는지 확인하고 누락된 첫 번째 실행 파일을 반환하거나 누락된 것이 없으면 ``None``\\을 반환합니다."

#: ../../library/test.rst:937
msgid ""
"Assert that the ``__all__`` variable of *module* contains all public "
"names."
msgstr "*module*\\의 ``__all__`` 변수에 모든 공용 이름이 포함되어 있는지 어서션 합니다."

#: ../../library/test.rst:939
msgid ""
"The module's public names (its API) are detected automatically based on "
"whether they match the public name convention and were defined in "
"*module*."
msgstr "모듈의 공용 이름(그것의 API)은 공용 이름 규칙과 일치하고 *module*\\에 정의되었는지에 따라 자동으로 감지됩니다."

#: ../../library/test.rst:943
msgid ""
"The *name_of_module* argument can specify (as a string or tuple thereof) "
"what module(s) an API could be defined in order to be detected as a "
"public API. One case for this is when *module* imports part of its public"
" API from other modules, possibly a C backend (like ``csv`` and its "
"``_csv``)."
msgstr ""
"*name_of_module* 인자는 공용 API로 감지하기 위해 API를 정의 할 수 있는 모듈을 (문자열이나 튜플로) 지정할 수"
" 있습니다. 이에 대한 한 가지 사례는 *module*\\이 다른 모듈에서 공용 API의 일부를 임포트 할 때입니다, C 백 엔드도"
" 가능합니다 (``csv``\\와 그것의 ``_csv`` 처럼)."

#: ../../library/test.rst:948
#, fuzzy
msgid ""
"The *extra* argument can be a set of names that wouldn't otherwise be "
"automatically detected as \"public\", like objects without a proper "
":attr:`~definition.__module__` attribute. If provided, it will be added "
"to the automatically detected ones."
msgstr ""
"*extra* 인자는 적절한 ``__module__`` 어트리뷰트가 없는 객체처럼, \"공용\"으로 자동 감지되지 않는 이름 집합일"
" 수 있습니다. 제공되면, 자동 감지된 항목에 추가됩니다."

#: ../../library/test.rst:952
#, fuzzy
msgid ""
"The *not_exported* argument can be a set of names that must not be "
"treated as part of the public API even though their names indicate "
"otherwise."
msgstr "*blacklist* 인자는 이름이 공용처럼 보이더라도 공용 API의 일부로 취급해서는 안 되는 이름 집합일 수 있습니다."

#: ../../library/test.rst:955 ../../library/test.rst:1582
msgid "Example use::"
msgstr "사용 예::"

#: ../../library/test.rst:957
#, python-brace-format
msgid ""
"import bar\n"
"import foo\n"
"import unittest\n"
"from test import support\n"
"\n"
"class MiscTestCase(unittest.TestCase):\n"
"    def test__all__(self):\n"
"        support.check__all__(self, foo)\n"
"\n"
"class OtherTestCase(unittest.TestCase):\n"
"    def test__all__(self):\n"
"        extra = {'BAR_CONST', 'FOO_CONST'}\n"
"        not_exported = {'baz'}  # Undocumented name.\n"
"        # bar imports part of its API from _bar.\n"
"        support.check__all__(self, bar, ('bar', '_bar'),\n"
"                             extra=extra, not_exported=not_exported)"
msgstr ""

#: ../../library/test.rst:978
msgid ""
"Skip tests if the :mod:`multiprocessing.synchronize` module is missing, "
"if there is no available semaphore implementation, or if creating a lock "
"raises an :exc:`OSError`."
msgstr ""

#: ../../library/test.rst:987
msgid "Assert that type *tp* cannot be instantiated using *args* and *kwds*."
msgstr ""

#: ../../library/test.rst:994
msgid ""
"This function returns a context manager that will change the global "
":func:`sys.set_int_max_str_digits` setting for the duration of the "
"context to allow execution of test code that needs a different limit on "
"the number of digits when converting between an integer and string."
msgstr ""

#: ../../library/test.rst:1002
msgid "The :mod:`test.support` module defines the following classes:"
msgstr ":mod:`test.support` 모듈은 다음 클래스를 정의합니다:"

#: ../../library/test.rst:1007
msgid ""
"A context manager used to try to prevent crash dialog popups on tests "
"that are expected to crash a subprocess."
msgstr "서브 프로세스를 충돌시킬 것으로 예상되는 테스트에서 충돌 대화 상자 팝업을 방지하는 데 사용되는 컨텍스트 관리자."

#: ../../library/test.rst:1010
msgid ""
"On Windows, it disables Windows Error Reporting dialogs using "
"`SetErrorMode <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms680621.aspx>`_."
msgstr ""
"윈도우에서는, `SetErrorMode <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms680621.aspx>`_\\를 사용하여 윈도우 에러 보고 대화 상자를 "
"비활성화합니다."

#: ../../library/test.rst:1013
#, fuzzy
msgid ""
"On UNIX, :func:`resource.setrlimit` is used to set "
":const:`resource.RLIMIT_CORE`'s soft limit to 0 to prevent coredump file "
"creation."
msgstr ""
"유닉스에서는, :func:`resource.setrlimit`\\를 사용하여 "
":attr:`resource.RLIMIT_CORE`\\의 소프트 제한을 0으로 설정하여 코어 덤프 파일 생성을 방지하는 데 "
"사용됩니다."

#: ../../library/test.rst:1017
#, fuzzy
msgid "On both platforms, the old value is restored by :meth:`~object.__exit__`."
msgstr "두 플랫폼 모두에서, 이전 값은 :meth:`__exit__`\\에 의해 복원됩니다."

#: ../../library/test.rst:1022
msgid ""
"Class to save and restore signal handlers registered by the Python signal"
" handler."
msgstr "파이썬 시그널 처리기가 등록한 시그널 처리기를 저장하고 복원하는 클래스."

#: ../../library/test.rst:1027
msgid ""
"Save the signal handlers to a dictionary mapping signal numbers to the "
"current signal handler."
msgstr ""

#: ../../library/test.rst:1032
msgid ""
"Set the signal numbers from the :meth:`save` dictionary to the saved "
"handler."
msgstr ""

#: ../../library/test.rst:1040
msgid "Try to match a single dict with the supplied arguments."
msgstr "단일 딕셔너리를 제공된 인자와 일치시키려고 합니다."

#: ../../library/test.rst:1045
msgid "Try to match a single stored value (*dv*) with a supplied value (*v*)."
msgstr "단일 저장된 값(*dv*)을 제공된 값(*v*)과 일치시키려고 합니다."

#: ../../library/test.rst:1049
msgid ":mod:`test.support.socket_helper` --- Utilities for socket tests"
msgstr ":mod:`test.support.socket_helper` --- 소켓 테스트용 유틸리티"

#: ../../library/test.rst:1055
msgid ""
"The :mod:`test.support.socket_helper` module provides support for socket "
"tests."
msgstr ":mod:`test.support.socket_helper` 모듈은 소켓 테스트를 지원합니다."

#: ../../library/test.rst:1062
msgid "Set to ``True`` if IPv6 is enabled on this host, ``False`` otherwise."
msgstr "이 호스트에서 IPv6가 활성화되어 있으면 ``True``\\로 설정하고, 그렇지 않으면 ``False``\\로 설정합니다."

#: ../../library/test.rst:1067
msgid ""
"Returns an unused port that should be suitable for binding.  This is "
"achieved by creating a temporary socket with the same family and type as "
"the ``sock`` parameter (default is :const:`~socket.AF_INET`, "
":const:`~socket.SOCK_STREAM`), and binding it to the specified host "
"address (defaults to ``0.0.0.0``) with the port set to 0, eliciting an "
"unused ephemeral port from the OS. The temporary socket is then closed "
"and deleted, and the ephemeral port is returned."
msgstr ""
"바인딩에 적합해야 하는 미사용 포트를 반환합니다. 이는 ``sock`` 매개 변수와 같은 패밀리와 유형으로 (기본값은 "
":const:`~socket.AF_INET`, :const:`~socket.SOCK_STREAM`) 임시 소켓을 만들고, 포트를 "
"0으로 설정하여 지정된 호스트 주소(기본값은 ``0.0.0.0``)에 바인딩하여, OS에서 사용되지 않은 임시 포트를 도출하여 "
"수행됩니다. 그런 다음 임시 소켓이 닫히고 삭제되고, 임시 포트가 반환됩니다."

#: ../../library/test.rst:1076
msgid ""
"Either this method or :func:`bind_port` should be used for any tests "
"where a server socket needs to be bound to a particular port for the "
"duration of the test. Which one to use depends on whether the calling "
"code is creating a Python socket, or if an unused port needs to be "
"provided in a constructor or passed to an external program (i.e. the "
"``-accept`` argument to openssl's s_server mode).  Always prefer "
":func:`bind_port` over :func:`find_unused_port` where possible.  Using a "
"hard coded port is discouraged since it can make multiple instances of "
"the test impossible to run simultaneously, which is a problem for "
"buildbots."
msgstr ""
"이 메서드나 :func:`bind_port`\\는 테스트 기간 중 서버 소켓을 특정 포트에 바인딩해야 하는 모든 테스트에 사용해야 "
"합니다. 어떤 것을 사용할 것인지는 호출하는 코드가 파이썬 소켓을 만드는지, 또는 사용되지 않은 포트가 생성자에서 제공되어야 하는지"
" 또는 외부 프로그램에 전달되어야 하는지 (즉 openssl의 s_server 모드에 대한 ``-accept`` 인자)에 따라 "
"다릅니다. 가능하면 항상 :func:`find_unused_port`\\보다 :func:`bind_port`\\를 선호하십시오. "
"하드 코딩된 포트를 사용하면 여러 테스트 인스턴스를 동시에 실행할 수 없게 되어 빌드 봇에 문제가 될 수 있어서 피하는 것이 "
"좋습니다."

#: ../../library/test.rst:1090
msgid ""
"Bind the socket to a free port and return the port number.  Relies on "
"ephemeral ports in order to ensure we are using an unbound port.  This is"
" important as many tests may be running simultaneously, especially in a "
"buildbot environment.  This method raises an exception if the "
"``sock.family`` is :const:`~socket.AF_INET` and ``sock.type`` is "
":const:`~socket.SOCK_STREAM`, and the socket has "
":const:`~socket.SO_REUSEADDR` or :const:`~socket.SO_REUSEPORT` set on it."
" Tests should never set these socket options for TCP/IP sockets. The only"
" case for setting these options is testing multicasting via multiple UDP "
"sockets."
msgstr ""
"소켓을 사용 가능한 포트에 바인딩하고 포트 번호를 반환합니다. 바인딩 되지 않은 포트를 사용하기 위해 임시 포트에 의존합니다. 이는"
" 특히 빌드 봇 환경에서, 많은 테스트가 동시에 실행될 수 있어서 중요합니다. 이 메서드는 ``sock.family``\\가 "
":const:`~socket.AF_INET`\\이고 ``sock.type``\\이 "
":const:`~socket.SOCK_STREAM`\\이고, 소켓에 :const:`~socket.SO_REUSEADDR`\\이나 "
":const:`~socket.SO_REUSEPORT`\\가 설정되면 예외가 발생합니다. 테스트는 TCP/IP 소켓에 대해 이러한 "
"소켓 옵션을 설정해서는 안 됩니다. 이러한 옵션을 설정하는 유일한 경우는 여러 UDP 소켓을 통해 멀티캐스팅을 테스트하는 것입니다."

#: ../../library/test.rst:1101
msgid ""
"Additionally, if the :const:`~socket.SO_EXCLUSIVEADDRUSE` socket option "
"is available (i.e. on Windows), it will be set on the socket.  This will "
"prevent anyone else from binding to our host/port for the duration of the"
" test."
msgstr ""
"또한, :const:`~socket.SO_EXCLUSIVEADDRUSE` 소켓 옵션을 사용할 수 있으면 (즉 윈도우에서), 소켓에 "
"설정됩니다. 이렇게 하면 다른 사람이 테스트 기간 중 우리의 호스트/포트에 바인딩하는 것을 방지할 수 있습니다."

#: ../../library/test.rst:1109
#, fuzzy
msgid ""
"Bind a Unix socket, raising :exc:`unittest.SkipTest` if "
":exc:`PermissionError` is raised."
msgstr ""
"유닉스 소켓을 바인드 합니다, :exc:`PermissionError`\\가 발생하면 "
":exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:1115
msgid ""
"A decorator for running tests that require a functional ``bind()`` for "
"Unix sockets."
msgstr "유닉스 소켓용 ``bind()`` 기능이 필요한 테스트를 실행하기 위한 데코레이터."

#: ../../library/test.rst:1121
msgid ""
"A context manager that raises :exc:`~test.support.ResourceDenied` when "
"various issues with the internet connection manifest themselves as "
"exceptions."
msgstr ""
"인터넷 연결과 관련된 다양한 문제가 예외로 나타날 때 :exc:`~test.support.ResourceDenied`\\를 "
"발생시키는 컨텍스트 관리자."

#: ../../library/test.rst:1127
msgid ""
":mod:`test.support.script_helper` --- Utilities for the Python execution "
"tests"
msgstr ":mod:`test.support.script_helper` --- 파이썬 실행 테스트용 유틸리티"

#: ../../library/test.rst:1133
msgid ""
"The :mod:`test.support.script_helper` module provides support for "
"Python's script execution tests."
msgstr ":mod:`test.support.script_helper` 모듈은 파이썬의 스크립트 실행 테스트를 지원합니다."

#: ../../library/test.rst:1138
msgid ""
"Return ``True`` if ``sys.executable interpreter`` requires environment "
"variables in order to be able to run at all."
msgstr "``sys.executable 인터프리터``\\를 실행하기 위해 환경 변수가 필요하면 ``True``\\를 반환합니다."

#: ../../library/test.rst:1141
msgid ""
"This is designed to be used with ``@unittest.skipIf()`` to annotate tests"
" that need to use an ``assert_python*()`` function to launch an isolated "
"mode (``-I``) or no environment mode (``-E``) sub-interpreter process."
msgstr ""
"``assert_python*()`` 함수를 사용하여 격리 모드(``-I``)를 시작하거나 환경 없음 모드(``-E``) 서브 "
"인터프리터 프로세스를 시작해야 하는 테스트를 어노테이트 하는 ``@unittest.skipIf()``\\와 함께 사용하도록 "
"설계되었습니다."

#: ../../library/test.rst:1145
msgid ""
"A normal build & test does not run into this situation but it can happen "
"when trying to run the standard library test suite from an interpreter "
"that doesn't have an obvious home with Python's current home finding "
"logic."
msgstr ""
"정상적인 빌드와 테스트는 이러한 상황을 만나지 않지만, 파이썬의 현재 홈 찾기 논리로 명확한 홈이 없는 인터프리터에서 표준 "
"라이브러리 테스트 스위트를 실행하려고 할 때 발생할 수 있습니다."

#: ../../library/test.rst:1149
msgid ""
"Setting :envvar:`PYTHONHOME` is one way to get most of the testsuite to "
"run in that situation.  :envvar:`PYTHONPATH` or :envvar:`PYTHONUSERSITE` "
"are other common environment variables that might impact whether or not "
"the interpreter can start."
msgstr ""
":envvar:`PYTHONHOME` 설정은 이러한 상황에서 대부분의 테스트 스위트를 실행하는 한 가지 방법입니다. "
":envvar:`PYTHONPATH`\\나 :envvar:`PYTHONUSERSITE`\\는 인터프리터가 시작될 수 있는지에 영향을"
" 줄 수 있는 다른 공통 환경 변수입니다."

#: ../../library/test.rst:1157
msgid ""
"Set up the environment based on *env_vars* for running the interpreter in"
" a subprocess.  The values can include ``__isolated``, ``__cleanenv``, "
"``__cwd``, and ``TERM``."
msgstr ""
"서브 프로세스에서 인터프리터를 실행하기 위해 *env_vars* 기반 환경을 설정합니다. 값에는 ``__isolated``, "
"``__cleanenv``, ``__cwd`` 및 ``TERM``\\이 포함될 수 있습니다."

#: ../../library/test.rst:1161 ../../library/test.rst:1177
#: ../../library/test.rst:1189
msgid "The function no longer strips whitespaces from *stderr*."
msgstr "이 함수는 더는 *stderr*\\에서 공백을 제거하지 않습니다."

#: ../../library/test.rst:1167
msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* succeeds (``rc == 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"*args*\\와 선택적 환경 변수 *env_vars*\\를 사용하여 인터프리터를 실행하면 성공(``rc == 0``)하고 "
"``(return code, stdout, stderr)`` 튜플을 반환함을 어서션 합니다."

#: ../../library/test.rst:1171
#, fuzzy
msgid ""
"If the *__cleanenv* keyword-only parameter is set, *env_vars* is used as "
"a fresh environment."
msgstr "``__cleanenv`` 키워드가 설정되면, *env_vars*\\가 새로운 환경으로 사용됩니다."

#: ../../library/test.rst:1174
#, fuzzy
msgid ""
"Python is started in isolated mode (command line option ``-I``), except "
"if the *__isolated* keyword-only parameter is set to ``False``."
msgstr ""
"파이썬은 ``__isolated`` 키워드가 ``False``\\로 설정된 경우를 제외하고, 격리 모드(명령 줄 옵션 "
"``-I``)에서 시작됩니다."

#: ../../library/test.rst:1183
msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* fails (``rc != 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"*args*\\와 선택적 환경 변수 *env_vars*\\를 사용하여 인터프리터 실행하면 실패(``rc != 0``)하고 "
"``(return code, stdout, stderr)`` 튜플을 반환함을 어서션 합니다."

#: ../../library/test.rst:1187
msgid "See :func:`assert_python_ok` for more options."
msgstr "추가 옵션은 :func:`assert_python_ok`\\를 참조하십시오."

#: ../../library/test.rst:1195
msgid "Run a Python subprocess with the given arguments."
msgstr "주어진 인자로 파이썬 서브 프로세스를 실행합니다."

#: ../../library/test.rst:1197
msgid ""
"*kw* is extra keyword args to pass to :func:`subprocess.Popen`. Returns a"
" :class:`subprocess.Popen` object."
msgstr ""
"*kw*\\는 :func:`subprocess.Popen`\\에 전달할 추가 키워드 인자입니다. "
":class:`subprocess.Popen` 객체를 반환합니다."

#: ../../library/test.rst:1203
msgid ""
"Run the given :class:`subprocess.Popen` process until completion and "
"return stdout."
msgstr "완료될 때까지 주어진 :class:`subprocess.Popen` 프로세스를 실행하고 stdout을 반환합니다."

#: ../../library/test.rst:1209
msgid ""
"Create script containing *source* in path *script_dir* and "
"*script_basename*. If *omit_suffix* is ``False``, append ``.py`` to the "
"name.  Return the full script path."
msgstr ""
"*script_dir*\\과 *script_basename* 경로에 *source*\\를 포함하는 스크립트를 만듭니다. "
"*omit_suffix*\\가 ``False``\\이면, 이름에 ``.py``\\를 추가합니다. 전체 스크립트 경로를 반환합니다."

#: ../../library/test.rst:1216
msgid ""
"Create zip file at *zip_dir* and *zip_basename* with extension ``zip`` "
"which contains the files in *script_name*. *name_in_zip* is the archive "
"name. Return a tuple containing ``(full path, full path of archive "
"name)``."
msgstr ""
"*script_name*\\의 파일을 포함하는 확장자가 ``zip``\\인 zip 파일을 *zip_dir*\\과 "
"*zip_basename*\\에 만듭니다. *name_in_zip*\\은 아카이브 이름입니다. ``(full path, full "
"path of archive name)``\\을 포함하는 튜플을 반환합니다."

#: ../../library/test.rst:1223
msgid ""
"Create a directory named *pkg_dir* containing an ``__init__`` file with "
"*init_source* as its contents."
msgstr "*init_source*\\를 내용으로 하는 ``__init__`` 파일을 포함하는 *pkg_dir*\\이라는 디렉터리를 만듭니다."

#: ../../library/test.rst:1230
msgid ""
"Create a zip package directory with a path of *zip_dir* and "
"*zip_basename* containing an empty ``__init__`` file and a file "
"*script_basename* containing the *source*.  If *compiled* is ``True``, "
"both source files will be compiled and added to the zip package.  Return "
"a tuple of the full zip path and the archive name for the zip file."
msgstr ""
"빈 ``__init__`` 파일과 *source*\\를 포함하는 파일 *script_basename*\\을 포함하는 zip 패키지 "
"디렉터리를 *zip_dir*\\과 *zip_basename* 경로로 만듭니다. *compiled*\\가 ``True``\\이면, 두"
" 소스 파일이 모두 컴파일되어 zip 패키지에 추가됩니다. 전체 zip 경로와 zip 파일의 아카이브 이름의 튜플을 반환합니다."

#: ../../library/test.rst:1238
msgid ""
":mod:`test.support.bytecode_helper` --- Support tools for testing correct"
" bytecode generation"
msgstr ":mod:`test.support.bytecode_helper` --- 올바른 바이트 코드 생성 테스트를 위한 지원 도구"

#: ../../library/test.rst:1243
msgid ""
"The :mod:`test.support.bytecode_helper` module provides support for "
"testing and inspecting bytecode generation."
msgstr ":mod:`test.support.bytecode_helper` 모듈은 바이트 코드 생성 테스트와 검사를 지원합니다."

#: ../../library/test.rst:1248
msgid "The module defines the following class:"
msgstr "모듈은 다음 클래스를 정의합니다:"

#: ../../library/test.rst:1252
msgid "This class has custom assertion methods for inspecting bytecode."
msgstr "이 클래스에는 바이트 코드를 검사하기 위한 사용자 정의 어서션 메서드가 있습니다."

#: ../../library/test.rst:1256
msgid "Return the disassembly of *co* as string."
msgstr "*co*\\의 역 어셈블리를 문자열로 반환합니다."

#: ../../library/test.rst:1261
msgid "Return instr if *opname* is found, otherwise throws :exc:`AssertionError`."
msgstr "*opname*\\이 발견되면 명령어를 반환하고, 그렇지 않으면 :exc:`AssertionError`\\를 던집니다."

#: ../../library/test.rst:1266
msgid "Throws :exc:`AssertionError` if *opname* is found."
msgstr "*opname*\\이 발견되면 :exc:`AssertionError`\\를 던집니다."

#: ../../library/test.rst:1270
#, fuzzy
msgid ":mod:`test.support.threading_helper` --- Utilities for threading tests"
msgstr ":mod:`test.support.socket_helper` --- 소켓 테스트용 유틸리티"

#: ../../library/test.rst:1275
#, fuzzy
msgid ""
"The :mod:`test.support.threading_helper` module provides support for "
"threading tests."
msgstr ":mod:`test.support.socket_helper` 모듈은 소켓 테스트를 지원합니다."

#: ../../library/test.rst:1282
msgid ""
"Join a *thread* within *timeout*.  Raise an :exc:`AssertionError` if "
"thread is still alive after *timeout* seconds."
msgstr ""
"*timeout* 내에 *thread*\\에 조인(join)합니다. 스레드가 *timeout* 초 후에도 여전히 살아 있으면 "
":exc:`AssertionError`\\를 발생시킵니다."

#: ../../library/test.rst:1288
msgid "Decorator to ensure the threads are cleaned up even if the test fails."
msgstr "테스트가 실패하더라도 스레드를 정리하는 데코레이터."

#: ../../library/test.rst:1293
msgid ""
"Context manager to start *threads*, which is a sequence of threads. "
"*unlock* is a function called after the threads are started, even if an "
"exception was raised; an example would be :meth:`threading.Event.set`. "
"``start_threads`` will attempt to join the started threads upon exit."
msgstr ""

#: ../../library/test.rst:1301
msgid ""
"Cleanup up threads not specified in *original_values*.  Designed to emit "
"a warning if a test leaves running threads in the background."
msgstr ""
"*original_values*\\에 지정되지 않은 스레드를 정리합니다. 테스트가 백그라운드에서 실행 중인 스레드를 남겨두면 경고를"
" 내도록 설계되었습니다."

#: ../../library/test.rst:1307
msgid "Return current thread count and copy of dangling threads."
msgstr "현재 스레드 수와 매달린(dangling) 스레드의 복사본을 반환합니다."

#: ../../library/test.rst:1312
msgid ""
"Context manager to wait until all threads created in the ``with`` "
"statement exit."
msgstr "``with`` 문에서 만들어진 모든 스레드가 종료할 때까지 대기하는 컨텍스트 관리자."

#: ../../library/test.rst:1318
msgid ""
"Context manager catching :class:`threading.Thread` exception using "
":func:`threading.excepthook`."
msgstr ""
":func:`threading.excepthook`\\을 사용하여 :class:`threading.Thread` 예외를 포착하는 "
"컨텍스트 관리자."

#: ../../library/test.rst:1321
#, fuzzy
msgid "Attributes set when an exception is caught:"
msgstr "예외가 포착될 때 설정되는 어트리뷰트:"

#: ../../library/test.rst:1323
msgid "``exc_type``"
msgstr "``exc_type``"

#: ../../library/test.rst:1324
msgid "``exc_value``"
msgstr "``exc_value``"

#: ../../library/test.rst:1325
msgid "``exc_traceback``"
msgstr "``exc_traceback``"

#: ../../library/test.rst:1326
msgid "``thread``"
msgstr "``thread``"

#: ../../library/test.rst:1328
msgid "See :func:`threading.excepthook` documentation."
msgstr ":func:`threading.excepthook` 설명서를 참조하십시오."

#: ../../library/test.rst:1330
msgid "These attributes are deleted at the context manager exit."
msgstr "이러한 어트리뷰트들은 컨텍스트 관리자 탈출 시에 삭제됩니다."

#: ../../library/test.rst:1334
msgid ""
"with threading_helper.catch_threading_exception() as cm:\n"
"    # code spawning a thread which raises an exception\n"
"    ...\n"
"\n"
"    # check the thread exception, use cm attributes:\n"
"    # exc_type, exc_value, exc_traceback, thread\n"
"    ...\n"
"\n"
"# exc_type, exc_value, exc_traceback, thread attributes of cm no longer\n"
"# exists at this point\n"
"# (to avoid reference cycles)"
msgstr ""

#: ../../library/test.rst:1350
#, fuzzy
msgid ":mod:`test.support.os_helper` --- Utilities for os tests"
msgstr ":mod:`test.support.socket_helper` --- 소켓 테스트용 유틸리티"

#: ../../library/test.rst:1355
#, fuzzy
msgid "The :mod:`test.support.os_helper` module provides support for os tests."
msgstr ":mod:`test.support.socket_helper` 모듈은 소켓 테스트를 지원합니다."

#: ../../library/test.rst:1362
msgid "A non-ASCII character encodable by :func:`os.fsencode`."
msgstr ":func:`os.fsencode`\\로 인코딩 할 수 있는 비 ASCII 문자."

#: ../../library/test.rst:1367
msgid "Set to :func:`os.getcwd`."
msgstr ":func:`os.getcwd`\\로 설정합니다."

#: ../../library/test.rst:1372
msgid ""
"Set to a name that is safe to use as the name of a temporary file.  Any "
"temporary file that is created should be closed and unlinked (removed)."
msgstr "임시 파일의 이름으로 사용하기에 안전한 이름으로 설정합니다. 만들어진 모든 임시 파일은 닫히고 언 링크(제거) 되어야 합니다."

#: ../../library/test.rst:1378
msgid ""
"Set to a filename containing the :data:`FS_NONASCII` character, if it "
"exists. This guarantees that if the filename exists, it can be encoded "
"and decoded with the default filesystem encoding. This allows tests that "
"require a non-ASCII filename to be easily skipped on platforms where they"
" can't work."
msgstr ""

#: ../../library/test.rst:1386
msgid ""
"Set to a filename (str type) that should not be able to be encoded by "
"file system encoding in strict mode.  It may be ``None`` if it's not "
"possible to generate such a filename."
msgstr ""
"엄격(strict) 모드에서 파일 시스템 인코딩으로 인코딩할 수 없는 파일명(str 형)으로 설정합니다. 이러한 파일명을 생성할 수"
" 없으면 ``None``\\일 수 있습니다."

#: ../../library/test.rst:1393
msgid ""
"Set to a filename (bytes type) that should not be able to be decoded by "
"file system encoding in strict mode.  It may be ``None`` if it's not "
"possible to generate such a filename."
msgstr ""
"엄격(strict) 모드에서 파일 시스템 인코딩으로 디코딩할 수 없는 파일명(bytes 형)으로 설정합니다. 이러한 파일명을 생성할"
" 수 없으면 ``None``\\일 수 있습니다."

#: ../../library/test.rst:1400
msgid "Set to a non-ASCII name for a temporary file."
msgstr "임시 파일을 위한 비 ASCII 이름으로 설정합니다."

#: ../../library/test.rst:1405
msgid ""
"Class used to temporarily set or unset environment variables.  Instances "
"can be used as a context manager and have a complete dictionary interface"
" for querying/modifying the underlying ``os.environ``. After exit from "
"the context manager all changes to environment variables done through "
"this instance will be rolled back."
msgstr ""
"환경 변수를 임시로 설정하거나 설정 해제하는 데 사용되는 클래스. 인스턴스는 컨텍스트 관리자로 사용할 수 있으며 하부 "
"``os.environ``\\을 조회/수정하기 위한 완전한 딕셔너리 인터페이스를 가질 수 있습니다. 컨텍스트 관리자를 탈출하면 이 "
"인스턴스를 통해 수행된 환경 변수에 대한 모든 변경 사항이 되돌려집니다."

#: ../../library/test.rst:1411
msgid "Added dictionary interface."
msgstr "딕셔너리 인터페이스가 추가되었습니다."

#: ../../library/test.rst:1417
#, fuzzy
msgid ""
"Simple :term:`path-like object`.  It implements the "
":meth:`~os.PathLike.__fspath__` method which just returns the *path* "
"argument.  If *path* is an exception, it will be raised in "
":meth:`!__fspath__`."
msgstr ""
"단순 :term:`경로류 객체 <path-like object>`. 단지 *path* 인자를 반환하는 "
":meth:`__fspath__` 메서드를 구현합니다. *path*\\가 예외이면, :meth:`!__fspath__`\\에서 "
"발생시킵니다."

#: ../../library/test.rst:1425
msgid ""
"Temporarily set the environment variable ``envvar`` to the value of "
"``value``."
msgstr "일시적으로 환경 변수 ``envvar``\\를 ``value`` 값으로 설정합니다."

#: ../../library/test.rst:1431
msgid "Temporarily unset the environment variable ``envvar``."
msgstr "일시적으로 환경 변수 ``envvar``\\를 설정 해제합니다."

#: ../../library/test.rst:1436
msgid "Return ``True`` if the OS supports symbolic links, ``False`` otherwise."
msgstr "OS가 심볼릭 링크를 지원하면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/test.rst:1442
msgid "Return ``True`` if the OS supports xattr, ``False`` otherwise."
msgstr "OS가 xattr을 지원하면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../../library/test.rst:1448
msgid ""
"A context manager that temporarily changes the current working directory "
"to *path* and yields the directory."
msgstr "현재 작업 디렉터리를 *path*\\로 일시적으로 변경하고 그 디렉터리를 산출하는 컨텍스트 관리자."

#: ../../library/test.rst:1451
msgid ""
"If *quiet* is ``False``, the context manager raises an exception on "
"error.  Otherwise, it issues only a warning and keeps the current working"
" directory the same."
msgstr ""
"*quiet*\\가 ``False``\\이면, 컨텍스트 관리자는 에러 시 예외를 발생시킵니다. 그렇지 않으면, 경고만 발행하고 현재"
" 작업 디렉터리를 같게 유지합니다."

#: ../../library/test.rst:1458
msgid "Create an empty file with *filename*.  If it already exists, truncate it."
msgstr "*filename*\\으로 빈 파일을 만듭니다. 이미 있으면, 자릅니다."

#: ../../library/test.rst:1463
msgid "Count the number of open file descriptors."
msgstr "열린 파일 기술자의 수를 셉니다."

#: ../../library/test.rst:1468
msgid "Return ``True`` if the file system for *directory* is case-insensitive."
msgstr "*directory*\\의 파일 시스템이 대소 문자를 구분하지 않으면 ``True``\\를 반환합니다."

#: ../../library/test.rst:1473
msgid ""
"Create an invalid file descriptor by opening and closing a temporary "
"file, and returning its descriptor."
msgstr "임시 파일을 여닫아서 잘못된 파일 기술자를 만든 다음, 그 기술자를 반환합니다."

#: ../../library/test.rst:1479
#, fuzzy
msgid ""
"Call :func:`os.rmdir` on *filename*.  On Windows platforms, this is "
"wrapped with a wait loop that checks for the existence of the file, which"
" is needed due to antivirus programs that can hold files open and prevent"
" deletion."
msgstr ""
"*filename*\\에 대해 :func:`os.rmdir`\\을 호출합니다. 윈도우 플랫폼에서는, 파일의 존재를 확인하는 대기 "
"루프로 래핑 됩니다."

#: ../../library/test.rst:1487
#, fuzzy
msgid ""
"Call :func:`shutil.rmtree` on *path* or call :func:`os.lstat` and "
":func:`os.rmdir` to remove a path and its contents.  As with "
":func:`rmdir`, on Windows platforms this is wrapped with a wait loop that"
" checks for the existence of the files."
msgstr ""
"*path*\\에 대해 :func:`shutil.rmtree`\\를 호출하거나 :func:`os.lstat`\\과 "
":func:`os.rmdir`\\을 호출하여 경로와 해당 내용을 제거합니다. 윈도우 플랫폼에서, 이것은 파일의 존재를 확인하는 대기"
" 루프로 래핑 됩니다."

#: ../../library/test.rst:1495
msgid "A decorator for running tests that require support for symbolic links."
msgstr "심볼릭 링크 지원이 필요한 테스트를 실행하기 위한 데코레이터."

#: ../../library/test.rst:1500
msgid "A decorator for running tests that require support for xattr."
msgstr "xattr 지원이 필요한 테스트를 실행하기 위한 데코레이터."

#: ../../library/test.rst:1505
msgid ""
"A context manager that temporarily creates a new directory and changes "
"the current working directory (CWD)."
msgstr "임시로 새 디렉터리를 만들고 현재 작업 디렉터리(CWD)를 변경하는 컨텍스트 관리자."

#: ../../library/test.rst:1508
msgid ""
"The context manager creates a temporary directory in the current "
"directory with name *name* before temporarily changing the current "
"working directory.  If *name* is ``None``, the temporary directory is "
"created using :func:`tempfile.mkdtemp`."
msgstr ""
"컨텍스트 관리자는 현재 작업 디렉터리를 임시로 변경하기 전에 이름이 *name*\\인 임시 디렉터리를 현재 디렉터리에 만듭니다. "
"*name*\\이 ``None``\\이면, 임시 디렉터리는 :func:`tempfile.mkdtemp`\\를 사용하여 만들어집니다."

#: ../../library/test.rst:1513
msgid ""
"If *quiet* is ``False`` and it is not possible to create or change the "
"CWD, an error is raised.  Otherwise, only a warning is raised and the "
"original CWD is used."
msgstr ""
"*quiet*\\가 ``False``\\이고 만들 수 없거나 CWD를 변경할 수 없으면, 에러가 발생합니다. 그렇지 않으면, 경고만"
" 발생하고 원래 CWD가 사용됩니다."

#: ../../library/test.rst:1520
msgid ""
"A context manager that creates a temporary directory at *path* and yields"
" the directory."
msgstr "*path*\\에 임시 디렉터리를 만들고 그 디렉터리를 산출하는 컨텍스트 관리자."

#: ../../library/test.rst:1523
msgid ""
"If *path* is ``None``, the temporary directory is created using "
":func:`tempfile.mkdtemp`.  If *quiet* is ``False``, the context manager "
"raises an exception on error.  Otherwise, if *path* is specified and "
"cannot be created, only a warning is issued."
msgstr ""
"*path*\\가 ``None``\\이면, 임시 디렉터리는 :func:`tempfile.mkdtemp`\\를 사용하여 만들어집니다."
" *quiet*\\가 ``False``\\이면, 컨텍스트 관리자는 에러 시 예외를 발생시킵니다. 그렇지 않으면, *path*\\가 "
"지정되고 만들 수 없으면, 경고만 발행됩니다."

#: ../../library/test.rst:1531
msgid "A context manager that temporarily sets the process umask."
msgstr "프로세스 umask를 임시로 설정하는 컨텍스트 관리자."

#: ../../library/test.rst:1536
#, fuzzy
msgid ""
"Call :func:`os.unlink` on *filename*.  As with :func:`rmdir`, on Windows "
"platforms, this is wrapped with a wait loop that checks for the existence"
" of the file."
msgstr ""
"*filename*\\에 대해 :func:`os.unlink`\\를 호출합니다. 윈도우 플랫폼에서는, 파일의 존재를 확인하는 대기 "
"루프로 래핑 됩니다."

#: ../../library/test.rst:1542
#, fuzzy
msgid ":mod:`test.support.import_helper` --- Utilities for import tests"
msgstr ":mod:`test.support.socket_helper` --- 소켓 테스트용 유틸리티"

#: ../../library/test.rst:1547
#, fuzzy
msgid ""
"The :mod:`test.support.import_helper` module provides support for import "
"tests."
msgstr ":mod:`test.support.socket_helper` 모듈은 소켓 테스트를 지원합니다."

#: ../../library/test.rst:1554
msgid ""
"Remove the module named *module_name* from ``sys.modules`` and delete any"
" byte-compiled files of the module."
msgstr "``sys.modules``\\에서 *module_name*\\이라는 모듈을 제거하고 모듈의 바이트 컴파일된 파일을 삭제합니다."

#: ../../library/test.rst:1560
msgid ""
"This function imports and returns a fresh copy of the named Python module"
" by removing the named module from ``sys.modules`` before doing the "
"import. Note that unlike :func:`reload`, the original module is not "
"affected by this operation."
msgstr ""
"이 함수는 임포트 전에 ``sys.modules``\\에서 명명된 모듈을 제거하여 명명된 파이썬 모듈의 새 복사본을 임포트하고 "
"반환합니다. :func:`reload`\\와 달리, 원래 모듈은 이 연산의 영향을 받지 않습니다."

#: ../../library/test.rst:1565
msgid ""
"*fresh* is an iterable of additional module names that are also removed "
"from the ``sys.modules`` cache before doing the import."
msgstr "*fresh*\\는 임포트를 수행하기 전에 ``sys.modules`` 캐시에서 함께 제거되는 추가 모듈 이름의 이터러블입니다."

#: ../../library/test.rst:1568
msgid ""
"*blocked* is an iterable of module names that are replaced with ``None`` "
"in the module cache during the import to ensure that attempts to import "
"them raise :exc:`ImportError`."
msgstr ""
"*blocked*\\는 임포트 하는 동안 모듈 캐시에서 ``None``\\으로 대체되는 모듈 이름의 이터러블로, 임포트 하려고 "
"시도하면 :exc:`ImportError`\\가 발생하도록 합니다."

#: ../../library/test.rst:1572
msgid ""
"The named module and any modules named in the *fresh* and *blocked* "
"parameters are saved before starting the import and then reinserted into "
"``sys.modules`` when the fresh import is complete."
msgstr ""
"명명된 모듈과 *fresh*\\와 *blocked* 매개 변수에 명명된 모든 모듈은 임포트를 시작하기 전에 보관되고 새 임포트가 "
"완료되면 ``sys.modules``\\에 다시 삽입됩니다."

#: ../../library/test.rst:1576
msgid ""
"Module and package deprecation messages are suppressed during this import"
" if *deprecated* is ``True``."
msgstr "*deprecated*\\가 ``True``\\이면 이 임포트 중에 모듈과 패키지 폐지 메시지가 억제됩니다."

#: ../../library/test.rst:1579
msgid ""
"This function will raise :exc:`ImportError` if the named module cannot be"
" imported."
msgstr "이 함수는 명명된 모듈을 임포트 할 수 없으면 :exc:`ImportError`\\를 발생시킵니다."

#: ../../library/test.rst:1584
msgid ""
"# Get copies of the warnings module for testing without affecting the\n"
"# version being used by the rest of the test suite. One copy uses the\n"
"# C implementation, the other is forced to use the pure Python fallback\n"
"# implementation\n"
"py_warnings = import_fresh_module('warnings', blocked=['_warnings'])\n"
"c_warnings = import_fresh_module('warnings', fresh=['_warnings'])"
msgstr ""

#: ../../library/test.rst:1596
msgid ""
"This function imports and returns the named module. Unlike a normal "
"import, this function raises :exc:`unittest.SkipTest` if the module "
"cannot be imported."
msgstr ""
"이 함수는 명명된 모듈을 임포트하고 반환합니다. 일반 임포트와 달리, 이 함수는 모듈을 임포트할 수 없으면 "
":exc:`unittest.SkipTest`\\를 발생시킵니다."

#: ../../library/test.rst:1600
msgid ""
"Module and package deprecation messages are suppressed during this import"
" if *deprecated* is ``True``.  If a module is required on a platform but "
"optional for others, set *required_on* to an iterable of platform "
"prefixes which will be compared against :data:`sys.platform`."
msgstr ""
"*deprecated*\\가 ``True``\\이면 이 임포트 중에 모듈과 패키지 폐지 메시지가 억제됩니다. 모듈이 한 플랫폼에서는"
" 필수지만, 다른 곳에서는 선택적이면, *required_on*\\을 :data:`sys.platform`\\과 비교할 플랫폼 "
"접두사의 이터러블로 설정합니다."

#: ../../library/test.rst:1610
msgid "Return a copy of :data:`sys.modules`."
msgstr ":data:`sys.modules`\\의 복사본을 반환합니다."

#: ../../library/test.rst:1615
msgid ""
"Remove modules except for *oldmodules* and ``encodings`` in order to "
"preserve internal cache."
msgstr "내부 캐시를 보존하기 위해 *oldmodules*\\와 ``encodings``\\를 제외한 모듈들을 제거합니다."

#: ../../library/test.rst:1621
msgid "Delete *name* from ``sys.modules``."
msgstr "``sys.modules``\\에서 *name*\\을 삭제합니다."

#: ../../library/test.rst:1626
msgid ""
"Move a :pep:`3147`/:pep:`488` pyc file to its legacy pyc location and "
"return the file system path to the legacy pyc file.  The *source* value "
"is the file system path to the source file.  It does not need to exist, "
"however the PEP 3147/488 pyc file must exist."
msgstr ""
":pep:`3147`/:pep:`488` pyc 파일을 레거시 pyc 위치로 옮기고 레거시 pyc 파일에 대한 파일 시스템 경로를 "
"반환합니다. *source* 값은 소스 파일에 대한 파일 시스템 경로입니다. 반드시 존재할 필요는 없지만, PEP 3147/488 "
"pyc 파일이 있어야 합니다."

#: ../../library/test.rst:1634
#, fuzzy
msgid ""
"A context manager to force import to return a new module reference.  This"
" is useful for testing module-level behaviors, such as the emission of a "
":exc:`DeprecationWarning` on import.  Example usage::"
msgstr ""
"새 모듈 참조를 반환하도록 임포트를 강제하는 컨텍스트 관리자. 이는 임포트 시 DeprecationWarning의 방출과 같은 모듈"
" 수준 동작을 테스트하는 데 유용합니다. 사용 예::"

#: ../../library/test.rst:1638
msgid ""
"with CleanImport('foo'):\n"
"    importlib.import_module('foo')  # New reference."
msgstr ""

#: ../../library/test.rst:1644
#, fuzzy
msgid "A context manager to temporarily add directories to :data:`sys.path`."
msgstr "sys.path에 디렉터리를 임시로 추가하는 컨텍스트 관리자."

#: ../../library/test.rst:1646
msgid ""
"This makes a copy of :data:`sys.path`, appends any directories given as "
"positional arguments, then reverts :data:`sys.path` to the copied "
"settings when the context ends."
msgstr ""
"이렇게 하면 :data:`sys.path`\\의 복사본이 만들어지고, 위치 인자로 지정된 모든 디렉터리를 추가한 다음, 컨텍스트가 "
"끝나면 :data:`sys.path`\\를 복사된 설정으로 되돌립니다."

#: ../../library/test.rst:1650
msgid ""
"Note that *all* :data:`sys.path` modifications in the body of the context"
" manager, including replacement of the object, will be reverted at the "
"end of the block."
msgstr ""
"객체 교체를 포함하여, 컨텍스트 관리자 본문의 *모든* :data:`sys.path` 수정 사항은 블록 끝에서 되돌려짐에 "
"유의하십시오."

#: ../../library/test.rst:1656
#, fuzzy
msgid ":mod:`test.support.warnings_helper` --- Utilities for warnings tests"
msgstr ":mod:`test.support.socket_helper` --- 소켓 테스트용 유틸리티"

#: ../../library/test.rst:1661
#, fuzzy
msgid ""
"The :mod:`test.support.warnings_helper` module provides support for "
"warnings tests."
msgstr ":mod:`test.support.socket_helper` 모듈은 소켓 테스트를 지원합니다."

#: ../../library/test.rst:1668
msgid ""
"Suppress warnings that are instances of *category*, which must be "
":exc:`Warning` or a subclass. Roughly equivalent to "
":func:`warnings.catch_warnings` with "
":meth:`warnings.simplefilter('ignore', category=category) "
"<warnings.simplefilter>`. For example::"
msgstr ""

#: ../../library/test.rst:1674
msgid ""
"@warning_helper.ignore_warnings(category=DeprecationWarning)\n"
"def test_suppress_warning():\n"
"    # do something"
msgstr ""

#: ../../library/test.rst:1683
msgid ""
"Context manager to check that no :exc:`ResourceWarning` was raised.  You "
"must remove the object which may emit :exc:`ResourceWarning` before the "
"end of the context manager."
msgstr ""
":exc:`ResourceWarning`\\이 발생하지 않았는지 확인하는 컨텍스트 관리자. 컨텍스트 관리자가 끝나기 전에 "
":exc:`ResourceWarning`\\을 방출할 수 있는 객체를 제거해야 합니다."

#: ../../library/test.rst:1690
msgid ""
"Test for syntax warning in *statement* by attempting to compile "
"*statement*. Test also that the :exc:`SyntaxWarning` is emitted only "
"once, and that it will be converted to a :exc:`SyntaxError` when turned "
"into error. *testcase* is the :mod:`unittest` instance for the test.  "
"*errtext* is the regular expression which should match the string "
"representation of the emitted :exc:`SyntaxWarning` and raised "
":exc:`SyntaxError`.  If *lineno* is not ``None``, compares to the line of"
" the warning and exception. If *offset* is not ``None``, compares to the "
"offset of the exception."
msgstr ""
"*statement* 컴파일을 시도하여 *statement*\\에서 구문 경고를 테스트합니다. "
":exc:`SyntaxWarning`\\이 한 번만 방출되고, 에러로 바꿀 때 :exc:`SyntaxError`\\로 변환되는지도 "
"테스트합니다. *testcase*\\는 테스트를 위한 :mod:`unittest` 인스턴스입니다. *errtext*\\는 방출된 "
":exc:`SyntaxWarning`\\과 발생한 :exc:`SyntaxError`\\의 문자열 표현과 일치해야 하는 정규식입니다."
" *lineno*\\가 ``None``\\이 아니면 경고와 예외 줄과 비교합니다. *offset*\\이 ``None``\\이 "
"아니면, 예외 오프셋과 비교합니다."

#: ../../library/test.rst:1704
#, fuzzy
msgid ""
"A convenience wrapper for :func:`warnings.catch_warnings` that makes it "
"easier to test that a warning was correctly raised.  It is approximately "
"equivalent to calling ``warnings.catch_warnings(record=True)`` with "
":meth:`warnings.simplefilter` set to ``always`` and with the option to "
"automatically validate the results that are recorded."
msgstr ""
"경고가 올바르게 발생했는지 테스트하기 쉽게 하는 :func:`warnings.catch_warnings()` 용 편의 래퍼. "
":meth:`warnings.simplefilter`\\를 ``always``\\로 설정하고 기록된 결과를 자동으로 검증하는 옵션을"
" 사용하여 ``warnings.catch_warnings(record=True)``\\를 호출하는 것과 거의 동등합니다."

#: ../../library/test.rst:1710
msgid ""
"``check_warnings`` accepts 2-tuples of the form ``(\"message regexp\", "
"WarningCategory)`` as positional arguments. If one or more *filters* are "
"provided, or if the optional keyword argument *quiet* is ``False``, it "
"checks to make sure the warnings are as expected:  each specified filter "
"must match at least one of the warnings raised by the enclosed code or "
"the test fails, and if any warnings are raised that do not match any of "
"the specified filters the test fails.  To disable the first of these "
"checks, set *quiet* to ``True``."
msgstr ""
"``check_warnings``\\는 위치 인자로 ``(\"message regexp\", WarningCategory)`` "
"형식의 2-튜플을 받습니다. 하나 이상의 *filters*\\가 제공되거나, 선택적 키워드 인자 *quiet*\\가 "
"``False``\\이면, 경고가 예상대로인지 확인합니다: 지정된 각 필터는 둘러싸인 코드에서 발생한 경고 중 적어도 하나와 "
"일치해야 합니다. 그렇지 않으면 테스트가 실패합니다. 지정된 필터와 일치하지 않는 경고가 발생하면 테스트가 실패합니다. 첫 번째 "
"검사를 비활성화하려면, *quiet*\\를 ``True``\\로 설정합니다."

#: ../../library/test.rst:1719
msgid "If no arguments are specified, it defaults to::"
msgstr "인자가 지정되지 않으면, 기본값은 다음과 같습니다::"

#: ../../library/test.rst:1721
msgid "check_warnings((\"\", Warning), quiet=True)"
msgstr ""

#: ../../library/test.rst:1723
msgid "In this case all warnings are caught and no errors are raised."
msgstr "이 경우 모든 경고가 포착되고 에러가 발생하지 않습니다."

#: ../../library/test.rst:1725
msgid ""
"On entry to the context manager, a :class:`WarningRecorder` instance is "
"returned. The underlying warnings list from "
":func:`~warnings.catch_warnings` is available via the recorder object's "
":attr:`warnings` attribute.  As a convenience, the attributes of the "
"object representing the most recent warning can also be accessed directly"
" through the recorder object (see example below).  If no warning has been"
" raised, then any of the attributes that would otherwise be expected on "
"an object representing a warning will return ``None``."
msgstr ""
"컨텍스트 관리자에 진입하면, :class:`WarningRecorder` 인스턴스가 반환됩니다. "
":func:`~warnings.catch_warnings`\\의 하부 경고 리스트는 레코더 객체의 :attr:`warnings` "
"어트리뷰트를 통해 사용할 수 있습니다. 편의상, 가장 최근의 경고를 나타내는 객체의 어트리뷰트는 레코더 객체를 통해 직접 액세스 할"
" 수도 있습니다 (아래 예를 참조하십시오). 경고가 발생하지 않으면, 객체에서 예상되는 경고를 나타내는 어트리뷰트는 "
"``None``\\을 반환합니다."

#: ../../library/test.rst:1734
msgid ""
"The recorder object also has a :meth:`reset` method, which clears the "
"warnings list."
msgstr "레코더 객체에는 경고 리스트를 지우는 :meth:`reset` 메서드도 있습니다."

#: ../../library/test.rst:1737
msgid "The context manager is designed to be used like this::"
msgstr "컨텍스트 관리자는 다음과 같이 사용되도록 설계되었습니다::"

#: ../../library/test.rst:1739
msgid ""
"with check_warnings((\"assertion is always true\", SyntaxWarning),\n"
"                    (\"\", UserWarning)):\n"
"    exec('assert(False, \"Hey!\")')\n"
"    warnings.warn(UserWarning(\"Hide me!\"))"
msgstr ""

#: ../../library/test.rst:1744
msgid ""
"In this case if either warning was not raised, or some other warning was "
"raised, :func:`check_warnings` would raise an error."
msgstr "이 경우 경고가 발생하지 않았거나, 다른 경고가 발생하면, :func:`check_warnings`\\는 에러를 발생시킵니다."

#: ../../library/test.rst:1747
msgid ""
"When a test needs to look more deeply into the warnings, rather than just"
" checking whether or not they occurred, code like this can be used::"
msgstr "테스트에서 경고가 발생했는지를 확인하는 것만이 아니라, 경고를 더 깊이 조사해야 할 때, 다음과 같은 코드를 사용할 수 있습니다::"

#: ../../library/test.rst:1750
msgid ""
"with check_warnings(quiet=True) as w:\n"
"    warnings.warn(\"foo\")\n"
"    assert str(w.args[0]) == \"foo\"\n"
"    warnings.warn(\"bar\")\n"
"    assert str(w.args[0]) == \"bar\"\n"
"    assert str(w.warnings[0].args[0]) == \"foo\"\n"
"    assert str(w.warnings[1].args[0]) == \"bar\"\n"
"    w.reset()\n"
"    assert len(w.warnings) == 0"
msgstr ""

#: ../../library/test.rst:1761
msgid ""
"Here all warnings will be caught, and the test code tests the captured "
"warnings directly."
msgstr "여기에서 모든 경고가 포착되고, 테스트 코드는 포착된 경고를 직접 테스트합니다."

#: ../../library/test.rst:1764
msgid "New optional arguments *filters* and *quiet*."
msgstr "새로운 선택적 인자 *filters*\\와 *quiet*."

#: ../../library/test.rst:1770
msgid ""
"Class used to record warnings for unit tests. See documentation of "
":func:`check_warnings` above for more details."
msgstr ""
"단위 테스트에 대한 경고를 기록하는 데 사용되는 클래스. 자세한 내용은 위의 :func:`check_warnings` 설명서를 "
"참조하십시오."

#~ msgid "Set to :func:`sys.getfilesystemencoding`."
#~ msgstr ":func:`sys.getfilesystemencoding`\\로 설정합니다."

#~ msgid "Set to a filename containing the :data:`FS_NONASCII` character."
#~ msgstr ":data:`FS_NONASCII` 문자를 포함하는 파일명으로 설정합니다."

#~ msgid ""
#~ "Return ``True`` if running on CPython,"
#~ " not on Windows, and configuration "
#~ "not set with ``WITH_DOC_STRINGS``."
#~ msgstr ""
#~ "윈도우가 아닌 CPython에서 실행 중이고, 구성이 "
#~ "``WITH_DOC_STRINGS``\\로 설정되지 않았으면 ``True``\\를 "
#~ "반환합니다."

#~ msgid "Check for presence of docstrings."
#~ msgstr "독스트링이 있는지 확인합니다."

#~ msgid "Match *test* to patterns set in :func:`set_match_tests`."
#~ msgstr "*test*\\를 :func:`set_match_tests`\\에 설정된 패턴과 일치시킵니다."

#~ msgid "Define match test with regular expression *patterns*."
#~ msgstr "정규식 *patterns*\\로 일치 테스트를 정의합니다."

#~ msgid ""
#~ "Execute :class:`unittest.TestCase` subclasses passed"
#~ " to the function. The function scans"
#~ " the classes for methods starting "
#~ "with the prefix ``test_`` and executes"
#~ " the tests individually."
#~ msgstr ""
#~ "함수에 전달된 :class:`unittest.TestCase` 서브 클래스를 "
#~ "실행합니다. 이 함수는 접두사 ``test_``\\로 시작하는 "
#~ "메서드에 대해 클래스를 검색하고 테스트를 개별적으로 "
#~ "실행합니다."

#~ msgid ""
#~ "It is also legal to pass strings"
#~ " as parameters; these should be keys"
#~ " in ``sys.modules``. Each associated module"
#~ " will be scanned by "
#~ "``unittest.TestLoader.loadTestsFromModule()``. This is "
#~ "usually seen in the following "
#~ ":func:`test_main` function::"
#~ msgstr ""
#~ "문자열을 매개 변수로 전달하는 것도 유효합니다; "
#~ "``sys.modules``\\의 키여야 합니다. 각 관련 모듈은 "
#~ "``unittest.TestLoader.loadTestsFromModule()`` 에 의해 "
#~ "스캔 됩니다. 일반적으로 다음 :func:`test_main` 함수에서"
#~ " 볼 수 있습니다::"

#~ msgid "This will run all tests defined in the named module."
#~ msgstr "이것은 명명된 모듈에 정의된 모든 테스트가 실행됩니다."

#~ msgid ""
#~ "Run :func:`doctest.testmod` on the given "
#~ "*module*.  Return ``(failure_count, test_count)``."
#~ msgstr ""
#~ "주어진 *module*\\에서 :func:`doctest.testmod`\\를 실행합니다."
#~ " ``(failure_count, test_count)``\\를 반환합니다."

#~ msgid ""
#~ "If *verbosity* is ``None``, "
#~ ":func:`doctest.testmod` is run with verbosity"
#~ " set to :data:`verbose`.  Otherwise, it "
#~ "is run with verbosity set to "
#~ "``None``.  *optionflags* is passed as "
#~ "``optionflags`` to :func:`doctest.testmod`."
#~ msgstr ""
#~ "*verbosity*\\가 ``None``\\이면, :func:`doctest.testmod`\\는"
#~ " 상세도를 :data:`verbose`\\로 설정하여 실행됩니다. 그렇지"
#~ " 않으면 상세도를 ``None``\\으로 설정하여 실행됩니다. "
#~ "*optionflags*\\는 ``optionflags``\\로 "
#~ ":func:`doctest.testmod`\\에 전달됩니다."

#~ msgid "A context manager that replaces ``sys.stderr`` with ``sys.__stderr__``."
#~ msgstr "``sys.stderr``\\를 ``sys.__stderr__``\\로 대체하는 컨텍스트 관리자."

#~ msgid ""
#~ "Context manager to start *threads*.  It"
#~ " attempts to join the threads upon"
#~ " exit."
#~ msgstr "*threads*\\를 시작하는 컨텍스트 관리자. 탈출 시 스레드 join을 시도합니다."

#~ msgid ""
#~ "Return :func:`struct.calcsize` for ``nP{fmt}0n`` "
#~ "or, if ``gettotalrefcount`` exists, "
#~ "``2PnP{fmt}0P``."
#~ msgstr ""
#~ "``nP{fmt}0n``\\이나 ``gettotalrefcount`` 가 있으면, "
#~ "``2PnP{fmt}0P``\\에 대해 :func:`struct.calcsize`\\를 "
#~ "반환합니다."

#~ msgid ""
#~ "Return :func:`struct.calcsize` for ``nPn{fmt}0n``"
#~ " or, if ``gettotalrefcount`` exists, "
#~ "``2PnPn{fmt}0P``."
#~ msgstr ""
#~ "``nPn{fmt}0n``\\이나 ``gettotalrefcount`` 가 있으면, "
#~ "``2PnPn{fmt}0P``\\에 대해 :func:`struct.calcsize`\\를 "
#~ "반환합니다."

#~ msgid ""
#~ "Instances are a context manager that "
#~ "raises :exc:`ResourceDenied` if the specified"
#~ " exception type is raised.  Any "
#~ "keyword arguments are treated as "
#~ "attribute/value pairs to be compared "
#~ "against any exception raised within the"
#~ " :keyword:`with` statement.  Only if all"
#~ " pairs match properly against attributes"
#~ " on the exception is :exc:`ResourceDenied`"
#~ " raised."
#~ msgstr ""
#~ "인스턴스는 지정된 예외 형이 발생하면 "
#~ ":exc:`ResourceDenied`\\를 발생시키는 컨텍스트 관리자입니다. 모든"
#~ " 키워드 인자는 :keyword:`with` 문 내에서 발생한"
#~ " 예외와 비교할 어트리뷰트/값 쌍으로 처리됩니다. 모든 "
#~ "쌍이 예외의 어트리뷰트와 올바르게 일치할 때만 "
#~ ":exc:`ResourceDenied`\\가 발생합니다."

#~ msgid "Run *test* and return the result."
#~ msgstr "*test*\\를 실행하고 결과를 반환합니다."

