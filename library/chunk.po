# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/chunk.rst:2
#, fuzzy
msgid ":mod:`!chunk` --- Read IFF chunked data"
msgstr ":mod:`chunk` --- IFF 청크된 데이터 읽기"

#: ../../library/chunk.rst:10
msgid ""
"This module is no longer part of the Python standard library. It was "
":ref:`removed in Python 3.13 <whatsnew313-pep594>` after being deprecated"
" in Python 3.11.  The removal was decided in :pep:`594`."
msgstr ""

#: ../../library/chunk.rst:14
msgid ""
"The last version of Python that provided the :mod:`!chunk` module was "
"`Python 3.12 <https://docs.python.org/3.12/library/chunk.html>`_."
msgstr ""

#~ msgid "**Source code:** :source:`Lib/chunk.py`"
#~ msgstr "**소스 코드:** :source:`Lib/chunk.py`"

#~ msgid ""
#~ "This module provides an interface for"
#~ " reading files that use EA IFF "
#~ "85 chunks. [#]_  This format is "
#~ "used in at least the Audio "
#~ "Interchange File Format (AIFF/AIFF-C) and "
#~ "the Real Media File Format (RMFF).  "
#~ "The WAVE audio file format is "
#~ "closely related and can also be "
#~ "read using this module."
#~ msgstr ""
#~ "이 모듈은 EA IFF 85 청크를 사용하는 파일을"
#~ " 읽기 위한 인터페이스를 제공합니다. [#]_ 이 형식은"
#~ " 적어도 AIFF/AIFF-C (Audio Interchange File"
#~ " Format) 와 RMFF (Real Media File "
#~ "Format)에서 사용됩니다. WAVE 오디오 파일 형식은 "
#~ "밀접하게 관련되어 있으며 이 모듈을 사용하여 읽을 "
#~ "수도 있습니다."

#~ msgid "A chunk has the following structure:"
#~ msgstr "청크의 구조는 다음과 같습니다:"

#~ msgid "Offset"
#~ msgstr "오프셋"

#~ msgid "Length"
#~ msgstr "길이"

#~ msgid "Contents"
#~ msgstr "내용"

#~ msgid "0"
#~ msgstr "0"

#~ msgid "4"
#~ msgstr "4"

#~ msgid "Chunk ID"
#~ msgstr "청크 ID"

#~ msgid "Size of chunk in big-endian byte order, not including the header"
#~ msgstr "빅 엔디안 바이트 순서로 청크의 크기. 헤더는 포함하지 않습니다."

#~ msgid "8"
#~ msgstr "8"

#~ msgid "*n*"
#~ msgstr "*n*"

#~ msgid "Data bytes, where *n* is the size given in the preceding field"
#~ msgstr "데이터 바이트. 여기서 *n*\\은 앞 필드에서 주어진 크기입니다."

#~ msgid "8 + *n*"
#~ msgstr "8 + *n*"

#~ msgid "0 or 1"
#~ msgstr "0 또는 1"

#~ msgid "Pad byte needed if *n* is odd and chunk alignment is used"
#~ msgstr "*n*\\가 홀수이고 청크 정렬이 사용된 경우 필요한 패드 바이트"

#~ msgid "The ID is a 4-byte string which identifies the type of chunk."
#~ msgstr "ID는 청크의 유형을 식별하는 4바이트 문자열입니다."

#~ msgid ""
#~ "The size field (a 32-bit value, "
#~ "encoded using big-endian byte order) "
#~ "gives the size of the chunk data,"
#~ " not including the 8-byte header."
#~ msgstr ""
#~ "크기 필드(빅 엔디안 바이트 순서를 사용하여 인코딩된 "
#~ "32비트 값)는 청크 데이터의 크기를 제공하며, 8바이트"
#~ " 헤더는 포함하지 않습니다."

#~ msgid ""
#~ "Usually an IFF-type file consists "
#~ "of one or more chunks.  The "
#~ "proposed usage of the :class:`Chunk` "
#~ "class defined here is to instantiate "
#~ "an instance at the start of each"
#~ " chunk and read from the instance "
#~ "until it reaches the end, after "
#~ "which a new instance can be "
#~ "instantiated. At the end of the "
#~ "file, creating a new instance will "
#~ "fail with an :exc:`EOFError` exception."
#~ msgstr ""
#~ "일반적으로 IFF 형식의 파일은 하나 이상의 청크로 "
#~ "구성됩니다. 여기에 정의된 :class:`Chunk` 클래스의 제안"
#~ " 된 사용법은 각 청크의 시작 부분에서 인스턴스를 "
#~ "만들고 끝까지 도달할 때까지 인스턴스에서 읽는 것입니다."
#~ " 그다음에 새 인스턴스를 만들 수 있습니다. 파일의"
#~ " 끝에서, 새 인스턴스를 만드는 것은 :exc:`EOFError`"
#~ " 예외로 실패합니다."

#~ msgid ""
#~ "Class which represents a chunk.  The "
#~ "*file* argument is expected to be "
#~ "a file-like object.  An instance "
#~ "of this class is specifically allowed."
#~ "  The only method that is needed "
#~ "is :meth:`~io.IOBase.read`.  If the methods"
#~ " :meth:`~io.IOBase.seek` and :meth:`~io.IOBase.tell`"
#~ " are present and don't raise an "
#~ "exception, they are also used. If "
#~ "these methods are present and raise "
#~ "an exception, they are expected to "
#~ "not have altered the object.  If "
#~ "the optional argument *align* is true,"
#~ " chunks are assumed to be aligned "
#~ "on 2-byte boundaries.  If *align* is "
#~ "false, no alignment is assumed.  The "
#~ "default value is true.  If the "
#~ "optional argument *bigendian* is false, "
#~ "the chunk size is assumed to be"
#~ " in little-endian order. This is "
#~ "needed for WAVE audio files. The "
#~ "default value is true.  If the "
#~ "optional argument *inclheader* is true, "
#~ "the size given in the chunk header"
#~ " includes the size of the header."
#~ "  The default value is false."
#~ msgstr ""
#~ "청크를 나타내는 클래스. *file* 인자는 파일류 객체를"
#~ " 기대합니다. 이 클래스의 인스턴스가 특별히 허용됩니다. "
#~ "필요한 유일한 메서드는 :meth:`~io.IOBase.read`\\입니다. "
#~ ":meth:`~io.IOBase.seek` 와 :meth:`~io.IOBase.tell` "
#~ "메서드가 있고 예외를 발생시키지 않으면 이것들도 사용됩니다."
#~ " 이러한 메서드가 존재하고, 예외가 발생하면, 객체가 "
#~ "변경되지 않았을 것으로 기대합니다. 선택적 인자 "
#~ "*align*\\이 참이면, 청크는 2바이트 경계에서 정렬되는 "
#~ "것으로 가정합니다. *align*\\이 거짓이면 정렬을 가정하지 "
#~ "않습니다. 기본값은 참입니다. 선택적 인자 *bigendian*\\이"
#~ " 거짓이면 청크 크기는 리틀 엔디안 순서로 간주합니다."
#~ " 이것은 WAVE 오디오 파일에 필요합니다. 기본값은 "
#~ "참입니다. 선택적 인자 *inclheader*\\가 참이면, 청크 "
#~ "헤더에 주어진 크기는 헤더의 크기를 포함합니다. 기본값은"
#~ " 거짓입니다."

#~ msgid "A :class:`Chunk` object supports the following methods:"
#~ msgstr ":class:`Chunk` 객체는 다음 메서드를 지원합니다:"

#~ msgid ""
#~ "Returns the name (ID) of the "
#~ "chunk.  This is the first 4 bytes"
#~ " of the chunk."
#~ msgstr "청크의 이름(ID)을 돌려줍니다. 이것은 청크의 처음 4바이트입니다."

#~ msgid "Returns the size of the chunk."
#~ msgstr "청크의 크기를 돌려줍니다."

#~ msgid ""
#~ "Close and skip to the end of "
#~ "the chunk.  This does not close "
#~ "the underlying file."
#~ msgstr "닫고 청크의 끝으로 건너뜁니다. 하부 파일을 닫지 않습니다."

#~ msgid ""
#~ "The remaining methods will raise "
#~ ":exc:`OSError` if called after the "
#~ ":meth:`close` method has been called.  "
#~ "Before Python 3.3, they used to "
#~ "raise :exc:`IOError`, now an alias of"
#~ " :exc:`OSError`."
#~ msgstr ""
#~ "나머지 메서드는 :meth:`close` 메서드가 호출된 후에 "
#~ "호출되면 :exc:`OSError`\\를 발생시킵니다. 파이썬 3.3 "
#~ "이전에는 :exc:`IOError`\\를 발생시켰습니다. 이제는 "
#~ ":exc:`OSError`\\의 별칭입니다."

#~ msgid "Returns ``False``."
#~ msgstr "``False``\\를 반환합니다."

#~ msgid ""
#~ "Set the chunk's current position.  The"
#~ " *whence* argument is optional and "
#~ "defaults to ``0`` (absolute file "
#~ "positioning); other values are ``1`` "
#~ "(seek relative to the current position)"
#~ " and ``2`` (seek relative to the "
#~ "file's end).  There is no return "
#~ "value. If the underlying file does "
#~ "not allow seek, only forward seeks "
#~ "are allowed."
#~ msgstr ""
#~ "청크의 현재 위치를 설정합니다. *whence* 인자는 선택"
#~ " 사항이며 기본값은 ``0``\\(절대 파일 위치 지정)입니다;"
#~ " 다른 값은 ``1``\\(현재 위치에 상대적인 탐색)과 "
#~ "``2``\\(파일의 끝에 상대적인 탐색)입니다. 반환 값이 "
#~ "없습니다. 하부 파일이 탐색을 허용하지 않으면, 정방향 "
#~ "탐색만 허용됩니다."

#~ msgid "Return the current position into the chunk."
#~ msgstr "청크의 현재 위치를 반환합니다."

#~ msgid ""
#~ "Read at most *size* bytes from the"
#~ " chunk (less if the read hits "
#~ "the end of the chunk before "
#~ "obtaining *size* bytes).  If the *size*"
#~ " argument is negative or omitted, "
#~ "read all data until the end of "
#~ "the chunk.  An empty bytes object "
#~ "is returned when the end of the"
#~ " chunk is encountered immediately."
#~ msgstr ""
#~ "청크에서 최대 *size* 바이트를 읽습니다 (*size* "
#~ "바이트를 얻기 전에 read가 청크 끝에 도달하면 "
#~ "덜 읽을 수 있습니다). *size* 인자가 음수이거나 "
#~ "생략되면, 청크의 끝까지 모든 데이터를 읽습니다. 청크의"
#~ " 끝이 즉시 발견되면 빈 바이트열 객체가 반환됩니다."

#~ msgid ""
#~ "Skip to the end of the chunk.  "
#~ "All further calls to :meth:`read` for"
#~ " the chunk will return ``b''``.  If"
#~ " you are not interested in the "
#~ "contents of the chunk, this method "
#~ "should be called so that the file"
#~ " points to the start of the "
#~ "next chunk."
#~ msgstr ""
#~ "청크의 끝으로 건너뜁니다. 청크에 대한 모든 추가 "
#~ ":meth:`read` 호출은 ``b''``\\를 반환합니다. 청크의 "
#~ "내용에 관심이 없으면, 파일이 다음 청크의 시작을 "
#~ "가리키도록 이 메서드를 호출해야 합니다."

#~ msgid "Footnotes"
#~ msgstr "각주"

#~ msgid ""
#~ "\"EA IFF 85\" Standard for Interchange"
#~ " Format Files, Jerry Morrison, Electronic"
#~ " Arts, January 1985."
#~ msgstr ""
#~ "\"EA IFF 85\" Standard for Interchange"
#~ " Format Files, Jerry Morrison, Electronic"
#~ " Arts, 1985년 1월."

