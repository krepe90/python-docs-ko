# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/array.rst:2
msgid ":mod:`!array` --- Efficient arrays of numeric values"
msgstr ":mod:`!array` --- 효율적인 숫자 배열"

#: ../../library/array.rst:11
msgid ""
"This module defines an object type which can compactly represent an array"
" of basic values: characters, integers, floating-point numbers.  Arrays "
"are sequence types and behave very much like lists, except that the type "
"of objects stored in them is constrained.  The type is specified at "
"object creation time by using a :dfn:`type code`, which is a single "
"character.  The following type codes are defined:"
msgstr ""
"이 모듈은 문자, 정수, 부동 소수점 숫자와 같은 기본적인 값의 배열을 간결하게 표현할 수 있는 객체 형을 정의합니다. 배열은 "
"시퀀스 형이며 리스트와 매우 비슷하게 행동합니다만, 그곳에 저장되는 객체의 형이 제약된다는 점이 다릅니다. 형은 객체 생성 시에 "
"단일 문자인 :dfn:`형 코드(type code)`\\를 사용하여 지정됩니다. 다음 형 코드가 정의됩니다:"

#: ../../library/array.rst:19
msgid "Type code"
msgstr "형 코드"

#: ../../library/array.rst:19
msgid "C Type"
msgstr "C 형"

#: ../../library/array.rst:19
msgid "Python Type"
msgstr "파이썬 형"

#: ../../library/array.rst:19
msgid "Minimum size in bytes"
msgstr "최소 크기(바이트)"

#: ../../library/array.rst:19
msgid "Notes"
msgstr "노트"

#: ../../library/array.rst:21
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/array.rst:21
msgid "signed char"
msgstr "signed char"

#: ../../library/array.rst:21 ../../library/array.rst:23
#: ../../library/array.rst:29 ../../library/array.rst:31
#: ../../library/array.rst:33 ../../library/array.rst:35
#: ../../library/array.rst:37 ../../library/array.rst:39
#: ../../library/array.rst:41 ../../library/array.rst:43
msgid "int"
msgstr "int"

#: ../../library/array.rst:21 ../../library/array.rst:23
msgid "1"
msgstr "1"

#: ../../library/array.rst:23
msgid "``'B'``"
msgstr "``'B'``"

#: ../../library/array.rst:23
msgid "unsigned char"
msgstr "unsigned char"

#: ../../library/array.rst:25
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/array.rst:25
msgid "wchar_t"
msgstr "wchar_t"

#: ../../library/array.rst:25 ../../library/array.rst:27
msgid "Unicode character"
msgstr "유니코드 문자"

#: ../../library/array.rst:25 ../../library/array.rst:29
#: ../../library/array.rst:31 ../../library/array.rst:33
#: ../../library/array.rst:35
msgid "2"
msgstr "2"

#: ../../library/array.rst:25
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/array.rst:27
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/array.rst:27
msgid "Py_UCS4"
msgstr "Py_UCS4"

#: ../../library/array.rst:27 ../../library/array.rst:37
#: ../../library/array.rst:39 ../../library/array.rst:45
msgid "4"
msgstr "4"

#: ../../library/array.rst:29
msgid "``'h'``"
msgstr "``'h'``"

#: ../../library/array.rst:29
msgid "signed short"
msgstr "signed short"

#: ../../library/array.rst:31
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/array.rst:31
msgid "unsigned short"
msgstr "unsigned short"

#: ../../library/array.rst:33
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/array.rst:33
msgid "signed int"
msgstr "signed int"

#: ../../library/array.rst:35
msgid "``'I'``"
msgstr "``'I'``"

#: ../../library/array.rst:35
msgid "unsigned int"
msgstr "unsigned int"

#: ../../library/array.rst:37
msgid "``'l'``"
msgstr "``'l'``"

#: ../../library/array.rst:37
msgid "signed long"
msgstr "signed long"

#: ../../library/array.rst:39
msgid "``'L'``"
msgstr "``'L'``"

#: ../../library/array.rst:39
msgid "unsigned long"
msgstr "unsigned long"

#: ../../library/array.rst:41
msgid "``'q'``"
msgstr "``'q'``"

#: ../../library/array.rst:41
msgid "signed long long"
msgstr "signed long long"

#: ../../library/array.rst:41 ../../library/array.rst:43
#: ../../library/array.rst:47
msgid "8"
msgstr "8"

#: ../../library/array.rst:43
msgid "``'Q'``"
msgstr "``'Q'``"

#: ../../library/array.rst:43
msgid "unsigned long long"
msgstr "unsigned long long"

#: ../../library/array.rst:45
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/array.rst:45 ../../library/array.rst:47
msgid "float"
msgstr "float"

#: ../../library/array.rst:47
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/array.rst:47
msgid "double"
msgstr "double"

#: ../../library/array.rst:50
msgid "Notes:"
msgstr "노트:"

#: ../../library/array.rst:53
msgid "It can be 16 bits or 32 bits depending on the platform."
msgstr "플랫폼에 따라 16비트 또는 32비트 일 수 있습니다."

#: ../../library/array.rst:55
msgid ""
"``array('u')`` now uses :c:type:`wchar_t` as C type instead of deprecated"
" ``Py_UNICODE``. This change doesn't affect its behavior because "
"``Py_UNICODE`` is alias of :c:type:`wchar_t` since Python 3.3."
msgstr ""
"``array('u')``\\는 이제 폐지된 ``Py_UNICODE`` 대신 :c:type:`wchar_t`\\를 C형으로 "
"사용합니다. ``Py_UNICODE``\\는 파이썬 3.3부터 :c:type:`wchar_t`\\의 별칭이라서 이 변경은 동작에 "
"영향을 미치지 않습니다."

#: ../../library/array.rst:60
msgid "Please migrate to ``'w'`` typecode."
msgstr ""

#: ../../library/array.rst:64
msgid ""
"The actual representation of values is determined by the machine "
"architecture (strictly speaking, by the C implementation).  The actual "
"size can be accessed through the :attr:`array.itemsize` attribute."
msgstr ""
"값의 실제 표현은 기계 아키텍처에 의해(엄격히 말하자면 C 구현에 의해) 결정됩니다. 실제 크기는 "
":attr:`array.itemsize` 어트리뷰트를 통해 액세스할 수 있습니다."

#: ../../library/array.rst:68
msgid "The module defines the following item:"
msgstr "모듈은 다음 항목을 정의합니다:"

#: ../../library/array.rst:73
msgid "A string with all available type codes."
msgstr "사용 가능한 모든 형 코드가 있는 문자열."

#: ../../library/array.rst:76
msgid "The module defines the following type:"
msgstr "모듈은 다음 형을 정의합니다:"

#: ../../library/array.rst:81
msgid ""
"A new array whose items are restricted by *typecode*, and initialized "
"from the optional *initializer* value, which must be a :class:`bytes` or "
":class:`bytearray` object, a Unicode string, or iterable over elements of"
" the appropriate type."
msgstr ""
"항목이 *typecode*\\에 의해 제한되는 새 배열, 선택적인 *initializer* 값으로 초기화되는데, "
":class:`bytes` 나 :class:`bytearray` 객체, 유니코드 문자열 또는 적절한 형의 요소에 대한 이터러블이어야"
" 합니다."

#: ../../library/array.rst:86
msgid ""
"If given a :class:`bytes` or :class:`bytearray` object, the initializer "
"is passed to the new array's :meth:`frombytes` method; if given a Unicode"
" string, the initializer is passed to the :meth:`fromunicode` method; "
"otherwise, the initializer's iterator is passed to the :meth:`extend` "
"method to add initial items to the array."
msgstr ""
":class:`bytes` 나 :class:`bytearray` 객체가 주어지면, initializer는 새 배열의 "
":meth:`frombytes` 메서드로 전달됩니다; 유니코드 문자열이 주어지면, initializer는 "
":meth:`fromunicode` 메서드로 전달됩니다; 그렇지 않으면, initializer의 이터레이터가 "
":meth:`extend` 메서드에 전달되어 배열에 초기 항목들을 추가합니다."

#: ../../library/array.rst:93
msgid ""
"Array objects support the ordinary sequence operations of indexing, "
"slicing, concatenation, and multiplication.  When using slice assignment,"
" the assigned value must be an array object with the same type code; in "
"all other cases, :exc:`TypeError` is raised. Array objects also implement"
" the buffer interface, and may be used wherever :term:`bytes-like objects"
" <bytes-like object>` are supported."
msgstr ""
"배열 객체는 인덱싱, 슬라이싱, 이어붙이기 및 곱셈과 같은 일반적인 시퀀스 연산을 지원합니다. 슬라이스 대입을 사용할 때, 대입되는"
" 값은 같은 형 코드의 배열 객체여야 합니다; 다른 모든 경우에는, :exc:`TypeError`\\가 발생합니다. 배열 객체는 "
"버퍼 인터페이스도 구현하며, :term:`바이트열류 객체 <bytes-like object>`\\가 지원되는 곳이면 어디에서나 "
"사용될 수 있습니다."

#: ../../library/array.rst:99
msgid ""
"Raises an :ref:`auditing event <auditing>` ``array.__new__`` with "
"arguments ``typecode``, ``initializer``."
msgstr ""
"``typecode``, ``initializer`` 인자로 :ref:`감사 이벤트(auditing event) "
"<auditing>` ``array.__new__``\\를 발생시킵니다."

#: ../../library/array.rst:104
msgid "The typecode character used to create the array."
msgstr "배열을 만드는 데 사용된 typecode 문자."

#: ../../library/array.rst:109
msgid "The length in bytes of one array item in the internal representation."
msgstr "내부 표현에서 하나의 배열 항목의 길이 (바이트)."

#: ../../library/array.rst:114
msgid "Append a new item with value *x* to the end of the array."
msgstr "배열의 끝에 값 *x*\\로 새 항목을 추가합니다."

#: ../../library/array.rst:119
msgid ""
"Return a tuple ``(address, length)`` giving the current memory address "
"and the length in elements of the buffer used to hold array's contents.  "
"The size of the memory buffer in bytes can be computed as "
"``array.buffer_info()[1] * array.itemsize``.  This is occasionally useful"
" when working with low-level (and inherently unsafe) I/O interfaces that "
"require memory addresses, such as certain :c:func:`!ioctl` operations.  "
"The returned numbers are valid as long as the array exists and no length-"
"changing operations are applied to it."
msgstr ""
"배열의 내용을 담는 데 사용된 버퍼의 현재 메모리 주소와 요소의 수로 표현한 길이를 제공하는 튜플 ``(address, "
"length)``\\를 반환합니다. 바이트 단위의 메모리 버퍼 크기는 ``array.buffer_info()[1] * "
"array.itemsize``\\로 계산할 수 있습니다. 이것은 특정 :c:func:`!ioctl` 연산과 같은 메모리 주소가 "
"필요한 저수준(그리고 근본적으로 안전하지 않은) I/O 인터페이스로 작업할 때 간혹 유용합니다. 반환된 숫자는 배열이 존재하고 길이"
" 변경 연산이 적용되지 않는 한 유효합니다."

#: ../../library/array.rst:129
msgid ""
"When using array objects from code written in C or C++ (the only way to "
"effectively make use of this information), it makes more sense to use the"
" buffer interface supported by array objects.  This method is maintained "
"for backward compatibility and should be avoided in new code.  The buffer"
" interface is documented in :ref:`bufferobjects`."
msgstr ""
"C나 C++로 작성된 코드(이 정보를 효율적으로 사용하는 유일한 방법)에서 배열 객체를 사용할 때, 배열 객체가 지원하는 버퍼 "
"인터페이스를 사용하는 것이 좋습니다. 이 메서드는 이전 버전과의 호환성을 위해 유지되며 새 코드에서는 사용하지 않아야 합니다. 버퍼"
" 인터페이스는 :ref:`bufferobjects`\\에 설명되어 있습니다."

#: ../../library/array.rst:138
msgid ""
"\"Byteswap\" all items of the array.  This is only supported for values "
"which are 1, 2, 4, or 8 bytes in size; for other types of values, "
":exc:`RuntimeError` is raised.  It is useful when reading data from a "
"file written on a machine with a different byte order."
msgstr ""
"배열의 모든 항목을 \"바이트 스와프(byteswap)\" 합니다. 1, 2, 4 또는 8바이트 크기의 값에 대해서만 지원됩니다; "
"다른 형의 값이면 :exc:`RuntimeError`\\가 발생합니다. 바이트 순서가 다른 컴퓨터에서 작성된 파일에서 데이터를 읽을"
" 때 유용합니다."

#: ../../library/array.rst:146
msgid "Return the number of occurrences of *x* in the array."
msgstr "배열 내에서 *x*\\가 등장하는 횟수를 반환합니다."

#: ../../library/array.rst:151
msgid ""
"Append items from *iterable* to the end of the array.  If *iterable* is "
"another array, it must have *exactly* the same type code; if not, "
":exc:`TypeError` will be raised.  If *iterable* is not an array, it must "
"be iterable and its elements must be the right type to be appended to the"
" array."
msgstr ""
"*iterable*\\의 항목을 배열의 끝에 추가합니다. *iterable*\\이 다른 배열이면, *정확히* 같은 형 코드를 가져야"
" 합니다; 그렇지 않으면, :exc:`TypeError`\\가 발생합니다. *iterable*\\이 배열이 아니면, 이터러블이어야 "
"하며 요소는 배열에 추가할 올바른 형이어야 합니다."

#: ../../library/array.rst:159
msgid ""
"Appends items from the :term:`bytes-like object`, interpreting its "
"content as an array of machine values (as if it had been read from a file"
" using the :meth:`fromfile` method)."
msgstr ""
":term:`바이트열류 객체 <bytes-like object>`\\에서 항목을 추가합니다. 내용을 기곗값(machine "
"value)의 배열로 해석합니다 (마치 :meth:`fromfile` 메서드를 사용하여 파일에서 읽은 것처럼)."

#: ../../library/array.rst:163
msgid ":meth:`!fromstring` is renamed to :meth:`frombytes` for clarity."
msgstr ":meth:`!fromstring`\\은 명확하게 하려고 :meth:`frombytes`\\로 이름을 바꿨습니다."

#: ../../library/array.rst:169
msgid ""
"Read *n* items (as machine values) from the :term:`file object` *f* and "
"append them to the end of the array.  If less than *n* items are "
"available, :exc:`EOFError` is raised, but the items that were available "
"are still inserted into the array."
msgstr ""
":term:`파일 객체 <file object>` *f*\\에서 (기곗값으로) *n* 항목을 읽고 배열의 끝에 추가합니다. *n* "
"미만의 항목만 사용할 수 있으면 :exc:`EOFError`\\가 발생하지만, 사용 가능한 항목은 여전히 배열에 삽입됩니다."

#: ../../library/array.rst:177
msgid ""
"Append items from the list.  This is equivalent to ``for x in list: "
"a.append(x)`` except that if there is a type error, the array is "
"unchanged."
msgstr ""
"리스트에서 항목을 추가합니다. 이것은 형 에러가 있으면 배열이 변경되지 않는다는 점만 제외하면 ``for x in list: "
"a.append(x)``\\와 동등합니다."

#: ../../library/array.rst:183
msgid ""
"Extends this array with data from the given Unicode string. The array "
"must have type code ``'u'`` or ``'w'``; otherwise a :exc:`ValueError` is "
"raised. Use ``array.frombytes(unicodestring.encode(enc))`` to append "
"Unicode data to an array of some other type."
msgstr ""
"주어진 유니코드 문자열의 데이터로 이 배열을 확장합니다. 배열은 형 코드가 ``'u'`` 나 ``'w'`` 이어야 합니다; 그렇지 "
"않으면 :exc:`ValueError`\\가 발생합니다. 다른 형의 배열에 유니코드 데이터를 추가하려면 "
"``array.frombytes(unicodestring.encode(enc))``\\를 사용하십시오."

#: ../../library/array.rst:191
msgid ""
"Return the smallest *i* such that *i* is the index of the first "
"occurrence of *x* in the array.  The optional arguments *start* and "
"*stop* can be specified to search for *x* within a subsection of the "
"array.  Raise :exc:`ValueError` if *x* is not found."
msgstr ""

#: ../../library/array.rst:196
msgid "Added optional *start* and *stop* parameters."
msgstr ""

#: ../../library/array.rst:202
msgid ""
"Insert a new item with value *x* in the array before position *i*. "
"Negative values are treated as being relative to the end of the array."
msgstr "*i* 위치 앞에 값이 *x*\\인 새 항목을 배열에 삽입합니다. 음수 값은 배열 끝에 상대적인 값으로 처리됩니다."

#: ../../library/array.rst:208
msgid ""
"Removes the item with the index *i* from the array and returns it. The "
"optional argument defaults to ``-1``, so that by default the last item is"
" removed and returned."
msgstr ""
"배열에서 인덱스 *i*\\에 있는 항목을 제거하고 이를 반환합니다. 선택적 인자의 기본값은 ``-1``\\이므로, 기본적으로 마지막"
" 항목이 제거되고 반환됩니다."

#: ../../library/array.rst:215
msgid "Remove the first occurrence of *x* from the array."
msgstr "배열에서 첫 번째 *x*\\를 제거합니다."

#: ../../library/array.rst:220
msgid "Remove all elements from the array."
msgstr "배열에서 모든 항목을 제거합니다."

#: ../../library/array.rst:227
msgid "Reverse the order of the items in the array."
msgstr "배열의 항목 순서를 뒤집습니다."

#: ../../library/array.rst:232
msgid ""
"Convert the array to an array of machine values and return the bytes "
"representation (the same sequence of bytes that would be written to a "
"file by the :meth:`tofile` method.)"
msgstr ""
"배열을 기곗값 배열로 변환하고 바이트열 표현(:meth:`tofile` 메서드로 파일에 기록될 바이트 시퀀스와 같습니다)을 "
"반환합니다."

#: ../../library/array.rst:236
msgid ":meth:`!tostring` is renamed to :meth:`tobytes` for clarity."
msgstr ":meth:`!tostring`\\은 명확하게 하려고 :meth:`tobytes`\\로 이름을 바꿨습니다."

#: ../../library/array.rst:242
msgid "Write all items (as machine values) to the :term:`file object` *f*."
msgstr "모든 항목을 (기곗값으로) :term:`파일 객체 <file object>` *f*\\에 씁니다."

#: ../../library/array.rst:247
msgid "Convert the array to an ordinary list with the same items."
msgstr "배열을 같은 항목이 있는 일반 리스트로 변환합니다."

#: ../../library/array.rst:252
msgid ""
"Convert the array to a Unicode string.  The array must have a type "
"``'u'`` or ``'w'``; otherwise a :exc:`ValueError` is raised. Use "
"``array.tobytes().decode(enc)`` to obtain a Unicode string from an array "
"of some other type."
msgstr ""
"배열을 유니코드 문자열로 변환합니다. 배열은 형 코드가 ``'u'`` 나 ``'w'`` 이어야 합니다; 그렇지 않으면 "
":exc:`ValueError`\\가 발생합니다. 다른 형의 배열로부터 유니코드 문자열을 얻으려면 "
"``array.tobytes().decode(enc)``\\를 사용하십시오."

#: ../../library/array.rst:257
msgid ""
"The string representation of array objects has the form ``array(typecode,"
" initializer)``. The *initializer* is omitted if the array is empty, "
"otherwise it is a Unicode string if the *typecode* is ``'u'`` or ``'w'``,"
" otherwise it is a list of numbers. The string representation is "
"guaranteed to be able to be converted back to an array with the same type"
" and value using :func:`eval`, so long as the :class:`~array.array` class"
" has been imported using ``from array import array``. Variables ``inf`` "
"and ``nan`` must also be defined if it contains corresponding floating-"
"point values. Examples::"
msgstr ""
"배열 객체의 문자열 표현은 ``array(typecode, initializer)`` 형태를 취합니다. 배열이 비어 있으면 "
"*initializer*\\가 생략되고, 그렇지 않으면 *typecode*\\가 ``'u'`` 나 ``'w'`` 인 경우 유니코드 "
"문자열이 되고, 그렇지 않으면 숫자 리스트가 됩니다. 문자열 표현은 :func:`eval`\\을 사용하여 같은 형과 값을 갖는 "
"배열로 다시 변환될 수 있음이 보장됩니다. 단 ``from array import array``\\를 사용하여 "
":class:`~array.array` 클래스를 임포트 한다고 가정합니다. 변수 ``inf`` 와 ``nan`` 도 해당 부동소수점"
" 값을 포함하는 경우 정의해야합니다. 예::"

#: ../../library/array.rst:269
msgid ""
"array('l')\n"
"array('w', 'hello \\u2641')\n"
"array('l', [1, 2, 3, 4, 5])\n"
"array('d', [1.0, 2.0, 3.14, -inf, nan])"
msgstr ""
"array('l')\n"
"array('w', 'hello \\u2641')\n"
"array('l', [1, 2, 3, 4, 5])\n"
"array('d', [1.0, 2.0, 3.14, -inf, nan])"

#: ../../library/array.rst:277
msgid "Module :mod:`struct`"
msgstr "모듈 :mod:`struct`"

#: ../../library/array.rst:278
msgid "Packing and unpacking of heterogeneous binary data."
msgstr "이질적인(heterogeneous) 바이너리 데이터의 패킹과 언 패킹."

#: ../../library/array.rst:280
msgid "`NumPy <https://numpy.org/>`_"
msgstr "`NumPy <https://numpy.org/>`_"

#: ../../library/array.rst:281
msgid "The NumPy package defines another array type."
msgstr "NumPy 패키지는 다른 배열형을 정의합니다."

#: ../../library/array.rst:7
msgid "arrays"
msgstr "배열"

#~ msgid "The following data items and methods are also supported:"
#~ msgstr "다음 데이터 항목과 메서드도 지원됩니다:"

#~ msgid ""
#~ "Return the smallest *i* such that "
#~ "*i* is the index of the first "
#~ "occurrence of *x* in the array."
#~ msgstr "*i*\\가 배열에서 *x*\\가 처음 나타나는 인덱스가 되도록 가장 작은 *i*\\를 반환합니다."

#~ msgid "Module :mod:`xdrlib`"
#~ msgstr "모듈 :mod:`xdrlib`"

#~ msgid ""
#~ "Packing and unpacking of External Data"
#~ " Representation (XDR) data as used in"
#~ " some remote procedure call systems."
#~ msgstr ""
#~ "일부 원격 프로시저 호출 시스템에서 사용되는 "
#~ "XDR(External Data Representation) 데이터의 패킹과 "
#~ "언 패킹."

