# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/tokenize.rst:2
msgid ":mod:`!tokenize` --- Tokenizer for Python source"
msgstr ":mod:`!tokenize` --- 파이썬 소스를 위한 토크나이저"

#: ../../library/tokenize.rst:10
msgid "**Source code:** :source:`Lib/tokenize.py`"
msgstr "**소스 코드:** :source:`Lib/tokenize.py`"

#: ../../library/tokenize.rst:14
msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments"
" as tokens as well, making it useful for implementing \"pretty-"
"printers\", including colorizers for on-screen displays."
msgstr ""
":mod:`tokenize` 모듈은 파이썬으로 구현된 파이썬 소스 코드를 위한 어휘 스캐너를 제공합니다. 이 모듈의 스캐너는 주석도"
" 토큰으로 반환하므로, 화면 디스플레이용 색상 표시기를 포함하여 \"예쁜 인쇄기\"를 구현하는 데 유용합니다."

#: ../../library/tokenize.rst:19
msgid ""
"To simplify token stream handling, all :ref:`operator <operators>` and "
":ref:`delimiter <delimiters>` tokens and :data:`Ellipsis` are returned "
"using the generic :data:`~token.OP` token type.  The exact type can be "
"determined by checking the ``exact_type`` property on the :term:`named "
"tuple` returned from :func:`tokenize.tokenize`."
msgstr ""
"토큰 스트림 처리를 단순화하기 위해, 모든 :ref:`연산자 <operators>`\\와 :ref:`구분자 <delimiters>`"
" 토큰과 :data:`Ellipsis`\\는 범용 :data:`~token.OP` 토큰 유형을 사용하여 반환됩니다. 정확한 유형은 "
":func:`tokenize.tokenize`\\에서 반환된 :term:`네임드 튜플 <named tuple>`\\의 "
"``exact_type`` 프로퍼티를 확인하여 파악할 수 있습니다."

#: ../../library/tokenize.rst:28
msgid ""
"Note that the functions in this module are only designed to parse "
"syntactically valid Python code (code that does not raise when parsed "
"using :func:`ast.parse`).  The behavior of the functions in this module "
"is **undefined** when providing invalid Python code and it can change at "
"any point."
msgstr ""

#: ../../library/tokenize.rst:35
msgid "Tokenizing Input"
msgstr "입력 토큰화하기"

#: ../../library/tokenize.rst:37
msgid "The primary entry point is a :term:`generator`:"
msgstr "기본 진입점은 :term:`제너레이터 <generator>`\\입니다:"

#: ../../library/tokenize.rst:41
msgid ""
"The :func:`.tokenize` generator requires one argument, *readline*, which "
"must be a callable object which provides the same interface as the "
":meth:`io.IOBase.readline` method of file objects.  Each call to the "
"function should return one line of input as bytes."
msgstr ""
":func:`.tokenize` 제너레이터는 하나의 인자 *readline*\\을 요구합니다. 이 인자는 파일 객체의 "
":meth:`io.IOBase.readline` 메서드와 같은 인터페이스를 제공하는 콜러블 객체여야 합니다. 함수를 호출할 때마다 "
"한 줄의 입력을 바이트열로 반환해야 합니다."

#: ../../library/tokenize.rst:46
msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` "
"of ints specifying the row and column where the token ends in the source;"
" and the line on which the token was found. The line passed (the last "
"tuple item) is the *physical* line.  The 5 tuple is returned as a "
":term:`named tuple` with the field names: ``type string start end line``."
msgstr ""
"제너레이터는 다음 멤버를 갖는 5-튜플을 생성합니다: 토큰 유형; 토큰 문자열; 토큰이 소스에서 시작하는 줄과 열을 지정하는 정수의"
" 2-튜플 ``(srow, scol)``; 토큰이 소스에서 끝나는 줄과 열을 지정하는 정수의 2-튜플 ``(erow, "
"ecol)``\\과 토큰이 발견된 줄. 전달된 줄(마지막 튜플 항목)은 *물리적* 줄입니다. 5-튜플은 필드 이름이 ``type "
"string start end line`` 인 :term:`네임드 튜플 <named tuple>`\\로 반환됩니다."

#: ../../library/tokenize.rst:55
msgid ""
"The returned :term:`named tuple` has an additional property named "
"``exact_type`` that contains the exact operator type for "
":data:`~token.OP` tokens.  For all other token types ``exact_type`` "
"equals the named tuple ``type`` field."
msgstr ""
"반환된 :term:`네임드 튜플 <named tuple>`\\에는 :data:`~token.OP` 토큰에 대한 정확한 연산자 유형이"
" 포함된 ``exact_type``\\이라는 추가 프로퍼티가 있습니다. 다른 모든 토큰 유형에서 ``exact_type``\\은 "
"네임드 튜플 ``type`` 필드와 같습니다."

#: ../../library/tokenize.rst:60
msgid "Added support for named tuples."
msgstr "네임드 튜플에 대한 지원이 추가되었습니다."

#: ../../library/tokenize.rst:63
msgid "Added support for ``exact_type``."
msgstr "``exact_type``\\에 대한 지원이 추가되었습니다."

#: ../../library/tokenize.rst:66
msgid ""
":func:`.tokenize` determines the source encoding of the file by looking "
"for a UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr ""
":func:`.tokenize`\\는 :pep:`263`\\에 따라 UTF-8 BOM이나 인코딩 쿠키를 찾아 파일의 소스 인코딩을 "
"결정합니다."

#: ../../library/tokenize.rst:71
msgid "Tokenize a source reading unicode strings instead of bytes."
msgstr "바이트열 대신에 유니코드 문자열을 읽는 소스를 토큰화합니다."

#: ../../library/tokenize.rst:73
msgid ""
"Like :func:`.tokenize`, the *readline* argument is a callable returning a"
" single line of input. However, :func:`generate_tokens` expects "
"*readline* to return a str object rather than bytes."
msgstr ""
":func:`.tokenize`\\와 마찬가지로, *readline* 인자는 한 줄의 입력을 반환하는 콜러블입니다. 그러나, "
":func:`generate_tokens`\\는 *readline*\\이 바이트열이 아닌 문자열 객체를 반환할 것으로 기대합니다."

#: ../../library/tokenize.rst:77
msgid ""
"The result is an iterator yielding named tuples, exactly like "
":func:`.tokenize`. It does not yield an :data:`~token.ENCODING` token."
msgstr ""
"결과는 정확히 :func:`.tokenize`\\처럼 네임드 튜플을 산출하는 이터레이터입니다. "
":data:`~token.ENCODING` 토큰을 산출하지 않습니다."

#: ../../library/tokenize.rst:80
msgid ""
"All constants from the :mod:`token` module are also exported from "
":mod:`tokenize`."
msgstr ":mod:`token` 모듈의 모든 상수도 :mod:`tokenize`\\에서 내보냅니다."

#: ../../library/tokenize.rst:83
msgid ""
"Another function is provided to reverse the tokenization process. This is"
" useful for creating tools that tokenize a script, modify the token "
"stream, and write back the modified script."
msgstr ""
"토큰화 프로세스를 역전시키는 또 다른 함수가 제공됩니다. 이것은 스크립트를 토큰화하고, 토큰 스트림을 수정한 후, 수정된 스크립트를"
" 다시 쓰는 도구를 만드는 데 유용합니다."

#: ../../library/tokenize.rst:90
msgid ""
"Converts tokens back into Python source code.  The *iterable* must return"
" sequences with at least two elements, the token type and the token "
"string. Any additional sequence elements are ignored."
msgstr ""
"토큰을 파이썬 소스 코드로 역 변환합니다. *iterable*\\은 최소한 토큰 유형과 토큰 문자열의 두 요소가 있는 시퀀스를 "
"반환해야 합니다. 추가 시퀀스 요소는 무시됩니다."

#: ../../library/tokenize.rst:94
msgid ""
"The result is guaranteed to tokenize back to match the input so that the "
"conversion is lossless and round-trips are assured.  The guarantee "
"applies only to the token type and token string as the spacing between "
"tokens (column positions) may change."
msgstr ""
"결과는 다시 토큰화하면 입력과 일치함이 보장되어, 변환은 무손실이고 왕복이 보장됩니다. 보증은 토큰 유형과 토큰 문자열에만 "
"적용되어, 토큰 간의 간격(열 위치)은 변경될 수 있습니다."

#: ../../library/tokenize.rst:99
msgid ""
"It returns bytes, encoded using the :data:`~token.ENCODING` token, which "
"is the first token sequence output by :func:`.tokenize`. If there is no "
"encoding token in the input, it returns a str instead."
msgstr ""
":func:`.tokenize` 에 의해 출력되는 첫 번째 토큰 시퀀스인 :data:`~token.ENCODING` 토큰을 사용하여"
" 인코딩된 바이트열을 반환합니다. 입력에 인코딩 토큰이 없으면, 대신 str을 반환합니다."

#: ../../library/tokenize.rst:104
msgid ""
":func:`.tokenize` needs to detect the encoding of source files it "
"tokenizes. The function it uses to do this is available:"
msgstr ""
":func:`.tokenize`\\는 토큰화하는 소스 파일의 인코딩을 감지해야 합니다. 이 작업을 수행하는 데 사용되는 함수를 "
"사용할 수 있습니다:"

#: ../../library/tokenize.rst:109
msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argument, "
"readline, in the same way as the :func:`.tokenize` generator."
msgstr ""
":func:`detect_encoding` 함수는 파이썬 소스 파일을 디코딩할 때 사용해야 하는 인코딩을 감지하는 데 사용됩니다. "
":func:`.tokenize` 제너레이터와 같은 방식으로, 하나의 인자 readline을 요구합니다."

#: ../../library/tokenize.rst:113
msgid ""
"It will call readline a maximum of twice, and return the encoding used "
"(as a string) and a list of any lines (not decoded from bytes) it has "
"read in."
msgstr ""
"readline을 최대 두 번 호출하고, 사용된 인코딩(문자열로)과 읽은 줄들(바이트열에서 디코드 되지 않습니다)의 리스트를 "
"반환합니다."

#: ../../library/tokenize.rst:117
msgid ""
"It detects the encoding from the presence of a UTF-8 BOM or an encoding "
"cookie as specified in :pep:`263`. If both a BOM and a cookie are "
"present, but disagree, a :exc:`SyntaxError` will be raised. Note that if "
"the BOM is found, ``'utf-8-sig'`` will be returned as an encoding."
msgstr ""
":pep:`263`\\에 지정된 대로 UTF-8 BOM이나 인코딩 쿠키의 존재로부터 인코딩을 검색합니다. BOM과 쿠키가 모두 "
"있지만 서로 일치하지 않으면 :exc:`SyntaxError`\\가 발생합니다. BOM이 발견되면, "
"``'utf-8-sig'``\\가 인코딩으로 반환됩니다."

#: ../../library/tokenize.rst:122
msgid ""
"If no encoding is specified, then the default of ``'utf-8'`` will be "
"returned."
msgstr "인코딩이 지정되지 않으면, 기본값인 ``'utf-8'``\\이 반환됩니다."

#: ../../library/tokenize.rst:125
msgid ""
"Use :func:`.open` to open Python source files: it uses "
":func:`detect_encoding` to detect the file encoding."
msgstr ""
":func:`.open`\\을 사용하여 파이썬 소스 파일을 여십시오: :func:`detect_encoding`\\을 사용하여 파일"
" 인코딩을 감지합니다."

#: ../../library/tokenize.rst:131
msgid ""
"Open a file in read only mode using the encoding detected by "
":func:`detect_encoding`."
msgstr ":func:`detect_encoding`\\에 의해 감지된 인코딩을 사용하여 읽기 전용 모드로 파일을 엽니다."

#: ../../library/tokenize.rst:138
msgid ""
"Raised when either a docstring or expression that may be split over "
"several lines is not completed anywhere in the file, for example::"
msgstr "여러 줄로 나눌 수 있는 독스트링이나 표현식이 파일의 어디에서도 완료되지 않을 때 발생합니다, 예를 들어::"

#: ../../library/tokenize.rst:141
msgid ""
"\"\"\"Beginning of\n"
"docstring"
msgstr ""
"\"\"\"Beginning of\n"
"docstring"

#: ../../library/tokenize.rst:144
msgid "or::"
msgstr "또는::"

#: ../../library/tokenize.rst:146
msgid ""
"[1,\n"
" 2,\n"
" 3"
msgstr ""
"[1,\n"
" 2,\n"
" 3"

#: ../../library/tokenize.rst:153
msgid "Command-Line Usage"
msgstr "명령 줄 사용법"

#: ../../library/tokenize.rst:157
msgid ""
"The :mod:`tokenize` module can be executed as a script from the command "
"line. It is as simple as:"
msgstr ":mod:`tokenize` 모듈은 명령 줄에서 스크립트로 실행될 수 있습니다. 이렇게 간단합니다:"

#: ../../library/tokenize.rst:160
msgid "python -m tokenize [-e] [filename.py]"
msgstr "python -m tokenize [-e] [filename.py]"

#: ../../library/tokenize.rst:164
msgid "The following options are accepted:"
msgstr "허용되는 옵션은 다음과 같습니다:"

#: ../../library/tokenize.rst:170
msgid "show this help message and exit"
msgstr "이 도움말 메시지를 표시하고 종료합니다"

#: ../../library/tokenize.rst:174
msgid "display token names using the exact type"
msgstr "정확한 유형(exact_type)을 사용하여 토큰 이름을 표시합니다"

#: ../../library/tokenize.rst:176
msgid ""
"If :file:`filename.py` is specified its contents are tokenized to stdout."
" Otherwise, tokenization is performed on stdin."
msgstr ""
":file:`filename.py`\\가 지정되면 그 내용은 표준출력(stdout)으로 토큰화됩니다. 그렇지 않으면, "
"표준입력(stdin)에 대해 토큰화가 수행됩니다."

#: ../../library/tokenize.rst:180
msgid "Examples"
msgstr "예제"

#: ../../library/tokenize.rst:182
msgid ""
"Example of a script rewriter that transforms float literals into Decimal "
"objects::"
msgstr "float 리터럴을 Decimal 객체로 변환하는 스크립트 재 작성기의 예제::"

#: ../../library/tokenize.rst:185
msgid ""
"from tokenize import tokenize, untokenize, NUMBER, STRING, NAME, OP\n"
"from io import BytesIO\n"
"\n"
"def decistmt(s):\n"
"    \"\"\"Substitute Decimals for floats in a string of statements.\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    The format of the exponent is inherited from the platform C library.\n"
"    Known cases are \"e-007\" (Windows) and \"e-07\" (not Windows).  "
"Since\n"
"    we're only showing 12 digits, and the 13th isn't close to 5, the\n"
"    rest of the output should be platform-independent.\n"
"\n"
"    >>> exec(s)  #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    Output from calculations with Decimal should be identical across all\n"
"    platforms.\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline)  # tokenize the "
"string\n"
"    for toknum, tokval, _, _, _ in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # replace NUMBER tokens\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"
msgstr ""
"from tokenize import tokenize, untokenize, NUMBER, STRING, NAME, OP\n"
"from io import BytesIO\n"
"\n"
"def decistmt(s):\n"
"    \"\"\"문장 문자열에 있는 float를 Decimal로 치환합니다.\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    지수 형식은 플랫폼 C 라이브러리에서 상속됩니다. 알려진 경우는 \"e-007\" (윈도우) 와 \"e-07\"\n"
"    (윈도우 외) 입니다. 우리는 단지 12자리 숫자를 보여주고 있고, 13번째 숫자는 5에 가깝지\n"
"    않으므로, 출력의 나머지 부분은 플랫폼 독립적이어야 합니다.\n"
"\n"
"    >>> exec(s)  #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    Decimal을 사용한 계산의 결과는 모든 플랫폼에서 같아야 합니다.\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline)  # 문자열을 토큰화합니다\n"
"    for toknum, tokval, _, _, _ in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # NUMBER 토큰을 바꿔치기합니다\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"

#: ../../library/tokenize.rst:224
msgid "Example of tokenizing from the command line.  The script::"
msgstr "명령 줄에서 토큰화하는 예제. 스크립트::"

#: ../../library/tokenize.rst:226
msgid ""
"def say_hello():\n"
"    print(\"Hello, World!\")\n"
"\n"
"say_hello()"
msgstr ""
"def say_hello():\n"
"    print(\"Hello, World!\")\n"
"\n"
"say_hello()"

#: ../../library/tokenize.rst:231
msgid ""
"will be tokenized to the following output where the first column is the "
"range of the line/column coordinates where the token is found, the second"
" column is the name of the token, and the final column is the value of "
"the token (if any)"
msgstr ""
"는 다음 출력으로 토큰화됩니다. 여기서 첫 번째 열은 토큰이 발견된 줄/열 좌표의 범위이고, 두 번째 열은 토큰의 이름이며, 마지막"
" 열은 토큰의 값입니다 (있다면)"

#: ../../library/tokenize.rst:235
msgid ""
"$ python -m tokenize hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          OP             '('\n"
"1,14-1,15:          OP             ')'\n"
"1,15-1,16:          OP             ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           OP             '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          OP             ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           OP             '('\n"
"4,10-4,11:          OP             ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"
msgstr ""
"$ python -m tokenize hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          OP             '('\n"
"1,14-1,15:          OP             ')'\n"
"1,15-1,16:          OP             ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           OP             '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          OP             ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           OP             '('\n"
"4,10-4,11:          OP             ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"

#: ../../library/tokenize.rst:259
msgid "The exact token type names can be displayed using the :option:`-e` option:"
msgstr "정확한 토큰 유형 이름은 :option:`-e` 옵션을 사용하여 표시할 수 있습니다:"

#: ../../library/tokenize.rst:261
msgid ""
"$ python -m tokenize -e hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          LPAR           '('\n"
"1,14-1,15:          RPAR           ')'\n"
"1,15-1,16:          COLON          ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           LPAR           '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          RPAR           ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           LPAR           '('\n"
"4,10-4,11:          RPAR           ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"
msgstr ""
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          LPAR           '('\n"
"1,14-1,15:          RPAR           ')'\n"
"1,15-1,16:          COLON          ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           LPAR           '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          RPAR           ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           LPAR           '('\n"
"4,10-4,11:          RPAR           ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"

#: ../../library/tokenize.rst:285
msgid ""
"Example of tokenizing a file programmatically, reading unicode strings "
"instead of bytes with :func:`generate_tokens`::"
msgstr ":func:`generate_tokens`\\로 바이트열 대신 유니코드 문자열을 읽는, 프로그래밍 방식으로 파일을 토큰화하는 예::"

#: ../../library/tokenize.rst:288
msgid ""
"import tokenize\n"
"\n"
"with tokenize.open('hello.py') as f:\n"
"    tokens = tokenize.generate_tokens(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
msgstr ""
"import tokenize\n"
"\n"
"with tokenize.open('hello.py') as f:\n"
"    tokens = tokenize.generate_tokens(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"

#: ../../library/tokenize.rst:295
msgid "Or reading bytes directly with :func:`.tokenize`::"
msgstr "또는 :func:`.tokenize`\\로 직접 바이트열을 읽는 예::"

#: ../../library/tokenize.rst:297
msgid ""
"import tokenize\n"
"\n"
"with open('hello.py', 'rb') as f:\n"
"    tokens = tokenize.tokenize(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
msgstr ""
"import tokenize\n"
"\n"
"with open('hello.py', 'rb') as f:\n"
"    tokens = tokenize.tokenize(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"

