# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/multiprocessing.shared_memory.rst:2
#, fuzzy
msgid ""
":mod:`!multiprocessing.shared_memory` --- Shared memory for direct access"
" across processes"
msgstr ":mod:`multiprocessing.shared_memory` --- 프로세스 간 직접 액세스를 위한 공유 메모리를 제공합니다"

#: ../../library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**소스 코드:** :source:`Lib/multiprocessing/shared_memory.py`"

#: ../../library/multiprocessing.shared_memory.rst:18
#, fuzzy
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation "
"and management of shared memory to be accessed by one or more processes "
"on a multicore or symmetric multiprocessor (SMP) machine.  To assist with"
" the life-cycle management of shared memory especially across distinct "
"processes, a :class:`~multiprocessing.managers.BaseManager` subclass, "
":class:`~multiprocessing.managers.SharedMemoryManager`, is also provided "
"in the :mod:`multiprocessing.managers` module."
msgstr ""
"이 모듈은 멀티 코어나 대칭 멀티 프로세서 (SMP) 기계에서 하나 이상의 프로세스가 액세스할 공유 메모리의 할당과 관리를 위한 "
"클래스 :class:`SharedMemory`\\를 제공합니다. 특히 별개의 프로세스에 걸친 공유 메모리의 수명 주기 관리를 "
"지원하기 위해, :class:`~multiprocessing.managers.BaseManager` 서브 클래스인 "
":class:`SharedMemoryManager`\\도 ``multiprocessing.managers`` 모듈에서 제공됩니다."

#: ../../library/multiprocessing.shared_memory.rst:26
#, fuzzy
msgid ""
"In this module, shared memory refers to \"POSIX style\" shared memory "
"blocks (though is not necessarily implemented explicitly as such) and "
"does not refer to \"distributed shared memory\".  This style of shared "
"memory permits distinct processes to potentially read and write to a "
"common (or shared) region of volatile memory.  Processes are "
"conventionally limited to only have access to their own process memory "
"space but shared memory permits the sharing of data between processes, "
"avoiding the need to instead send messages between processes containing "
"that data.  Sharing data directly via memory can provide significant "
"performance benefits compared to sharing data via disk or socket or other"
" communications requiring the serialization/deserialization and copying "
"of data."
msgstr ""
"이 모듈에서, 공유 메모리는 \"시스템 V 스타일\" 공유 메모리 블록을 가리키며 (꼭 그런 식으로 구현돼야 할 필요는 없습니다),"
" \"분산 공유 메모리\"를 가리키지는 않습니다. 이 스타일의 공유 메모리는 개별 프로세스가 잠재적으로 휘발성 메모리의 공통 (또는"
" 공유) 영역을 읽고 쓸 수 있게 합니다. 프로세스는 일반적으로 자체 프로세스 메모리 공간에만 액세스 할 수 있도록 제한되지만, "
"공유 메모리는 프로세스 간에 데이터를 공유 할 수 있도록 해서, 프로세스 간에 대신 해당 데이터가 포함된 메시지를 보낼 필요가 "
"없도록 합니다. 메모리를 통해 직접 데이터를 공유하면 디스크나 소켓 또는 직렬화/역 직렬화와 데이터의 복사를 요구하는 다른 통신과 "
"비교하여 상당한 성능상의 이점을 얻을 수 있습니다."

#: ../../library/multiprocessing.shared_memory.rst:41
#, fuzzy
msgid ""
"Create an instance of the :class:`!SharedMemory` class for either "
"creating a new shared memory block or attaching to an existing shared "
"memory block.  Each shared memory block is assigned a unique name. In "
"this way, one process can create a shared memory block with a particular "
"name and a different process can attach to that same shared memory block "
"using that same name."
msgstr ""
"새 공유 메모리 블록을 만들거나 기존 공유 메모리 블록에 연결합니다. 각 공유 메모리 블록에는 고유한 이름이 지정됩니다. 이런 "
"식으로, 하나의 프로세스가 특정 이름을 가진 공유 메모리 블록을 생성 할 수 있으며, 다른 프로세스가 같은 이름을 사용하여 같은 "
"공유 메모리 블록에 연결할 수 있습니다."

#: ../../library/multiprocessing.shared_memory.rst:48
#, fuzzy
msgid ""
"As a resource for sharing data across processes, shared memory blocks may"
" outlive the original process that created them.  When one process no "
"longer needs access to a shared memory block that might still be needed "
"by other processes, the :meth:`close` method should be called. When a "
"shared memory block is no longer needed by any process, the "
":meth:`unlink` method should be called to ensure proper cleanup."
msgstr ""
"프로세스 간에 데이터를 공유하기 위한 자원으로서, 공유 메모리 블록은 생성한 원래 프로세스보다 오래갈 수 있습니다. 한 프로세스가 "
"더는 다른 프로세스가 필요로 할 수도 있는 공유 메모리 블록에 대한 액세스를 필요로하지 않으면 :meth:`close()` 메서드를"
" 호출해야 합니다. 어떤 프로세스에서도 공유 메모리 블록이 더는 필요하지 않으면, 적절한 정리를 위해 :meth:`unlink()`"
" 메서드를 호출해야 합니다."

#: ../../library/multiprocessing.shared_memory.rst
msgid "Parameters"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:55
#, fuzzy
msgid ""
"The unique name for the requested shared memory, specified as a string. "
"When creating a new shared memory block, if ``None`` (the default) is "
"supplied for the name, a novel name will be generated."
msgstr ""
"*name*\\은 문자열로 지정된 요청된 공유 메모리의 고유한 이름입니다. 새 공유 메모리 블록을 만들 때, 이름에 "
"``None``\\(기본값)이 제공되면, 새로운 이름이 생성됩니다."

#: ../../library/multiprocessing.shared_memory.rst:61
#, fuzzy
msgid ""
"Control whether a new shared memory block is created (``True``) or an "
"existing shared memory block is attached (``False``)."
msgstr ""
"*create*\\는 새 공유 메모리 블록을 만들지(``True``), 또는 기존 공유 메모리 블록을 연결할지(``False``)를"
" 제어합니다."

#: ../../library/multiprocessing.shared_memory.rst:65
#, fuzzy
msgid ""
"The requested number of bytes when creating a new shared memory block. "
"Because some platforms choose to allocate chunks of memory based upon "
"that platform's memory page size, the exact size of the shared memory "
"block may be larger or equal to the size requested. When attaching to an "
"existing shared memory block, the *size* parameter is ignored."
msgstr ""
"*size*\\는 새 공유 메모리 블록을 만들 때 요청된 바이트 수를 지정합니다. 일부 플랫폼은 해당 플랫폼의 메모리 페이지 크기를"
" 기반으로 메모리 덩어리를 할당하기 때문에, 공유 메모리 블록의 정확한 크기는 요청한 크기보다 크거나 같을 수 있습니다. 기존 공유"
" 메모리 블록에 연결할 때는, ``size`` 매개 변수가 무시됩니다."

#: ../../library/multiprocessing.shared_memory.rst:73
msgid ""
"When ``True``, register the shared memory block with a resource tracker "
"process on platforms where the OS does not do this automatically. The "
"resource tracker ensures proper cleanup of the shared memory even if all "
"other processes with access to the memory exit without doing so. Python "
"processes created from a common ancestor using :mod:`multiprocessing` "
"facilities share a single resource tracker process, and the lifetime of "
"shared memory segments is handled automatically among these processes. "
"Python processes created in any other way will receive their own resource"
" tracker when accessing shared memory with *track* enabled. This will "
"cause the shared memory to be deleted by the resource tracker of the "
"first process that terminates. To avoid this issue, users of "
":mod:`subprocess` or standalone Python processes should set *track* to "
"``False`` when there is already another process in place that does the "
"bookkeeping. *track* is ignored on Windows, which has its own tracking "
"and automatically deletes shared memory when all handles to it have been "
"closed."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:91
msgid "Added the *track* parameter."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:96
msgid ""
"Close the file descriptor/handle to the shared memory from this instance."
"  :meth:`close` should be called once access to the shared memory block "
"from this instance is no longer needed.  Depending on operating system, "
"the underlying memory may or may not be freed even if all handles to it "
"have been closed.  To ensure proper cleanup, use the :meth:`unlink` "
"method."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:105
msgid ""
"Delete the underlying shared memory block.  This should be called only "
"once per shared memory block regardless of the number of handles to it, "
"even in other processes. :meth:`unlink` and :meth:`close` can be called "
"in any order, but trying to access data inside a shared memory block "
"after :meth:`unlink` may result in memory access errors, depending on "
"platform."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:112
msgid ""
"This method has no effect on Windows, where the only way to delete a "
"shared memory block is to close all handles."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:117
msgid "A memoryview of contents of the shared memory block."
msgstr "공유 메모리 블록의 내용에 대한 메모리 뷰."

#: ../../library/multiprocessing.shared_memory.rst:121
msgid "Read-only access to the unique name of the shared memory block."
msgstr "공유 메모리 블록의 고유한 이름에 대한 읽기 전용 액세스."

#: ../../library/multiprocessing.shared_memory.rst:125
msgid "Read-only access to size in bytes of the shared memory block."
msgstr "공유 메모리 블록의 크기(바이트)에 대한 읽기 전용 액세스."

#: ../../library/multiprocessing.shared_memory.rst:128
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory`"
" instances::"
msgstr "다음 예제는 :class:`SharedMemory` 인스턴스의 저수준 사용을 보여줍니다::"

#: ../../library/multiprocessing.shared_memory.rst:131
msgid ""
">>> from multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> type(shm_a.buf)\n"
"<class 'memoryview'>\n"
">>> buffer = shm_a.buf\n"
">>> len(buffer)\n"
"10\n"
">>> buffer[:4] = bytearray([22, 33, 44, 55])  # Modify multiple at once\n"
">>> buffer[4] = 100                           # Modify single byte at a "
"time\n"
">>> # Attach to an existing shared memory block\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5])  # Copy the data into a new "
"array.array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy'  # Modify via shm_b using bytes\n"
">>> bytes(shm_a.buf[:5])      # Access via shm_a\n"
"b'howdy'\n"
">>> shm_b.close()   # Close each SharedMemory instance\n"
">>> shm_a.close()\n"
">>> shm_a.unlink()  # Call unlink only once to release the shared memory"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:154
#, fuzzy
msgid ""
"The following example demonstrates a practical use of the "
":class:`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, "
"accessing the same :class:`!numpy.ndarray` from two distinct Python "
"shells:"
msgstr ""
"다음 예제는 두 개의 다른 파이썬 셸에서 같은 ``numpy.ndarray``\\에 액세스하는, `NumPy 배열 "
"<https://www.numpy.org/>`_\\과 함께 :class:`SharedMemory` 클래스를 사용하는 실용적인 방법을"
" 보여줍니다:"

#: ../../library/multiprocessing.shared_memory.rst:158
msgid ""
">>> # In the first Python interactive shell\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # Start with an existing NumPy "
"array\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Now create a NumPy array backed by shared memory\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copy the original data into shared memory\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # We did not specify a name so one was chosen for us\n"
"'psm_21467_46075'\n"
"\n"
">>> # In either the same shell or a new Python shell on the same machine\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # Attach to the existing shared memory block\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # Note that a.shape is (6,) and a.dtype is np.int64 in this example\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Back in the first Python interactive shell, b reflects this change\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Clean up from within the second Python shell\n"
">>> del c  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> existing_shm.close()\n"
"\n"
">>> # Clean up from within the first Python shell\n"
">>> del b  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> shm.close()\n"
">>> shm.unlink()  # Free and release the shared memory block at the very "
"end"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:208
#, fuzzy
msgid ""
"A subclass of :class:`multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ""
"프로세스 간 공유 메모리 블록을 관리하는 데 사용할 수 있는 "
":class:`~multiprocessing.managers.BaseManager`\\의 서브 클래스."

#: ../../library/multiprocessing.shared_memory.rst:211
#, fuzzy
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a "
":class:`!SharedMemoryManager` instance causes a new process to be "
"started. This new process's sole purpose is to manage the life cycle of "
"all shared memory blocks created through it.  To trigger the release of "
"all shared memory blocks managed by that process, call "
":meth:`~multiprocessing.managers.BaseManager.shutdown` on the instance. "
"This triggers a "
":meth:`~multiprocessing.shared_memory.SharedMemory.unlink` call on all of"
" the :class:`SharedMemory` objects managed by that process and then stops"
" the process itself.  By creating :class:`!SharedMemory` instances "
"through a :class:`!SharedMemoryManager`, we avoid the need to manually "
"track and trigger the freeing of shared memory resources."
msgstr ""
":class:`SharedMemoryManager` 인스턴스에서 "
":meth:`~multiprocessing.managers.BaseManager.start`\\를 호출하면 새 프로세스가 "
"시작됩니다. 이 새로운 프로세스의 유일한 목적은 이를 통해 생성된 모든 공유 메모리 블록의 수명 주기를 관리하는 것입니다. 해당 "
"프로세스가 관리하는 모든 공유 메모리 블록의 해제를 시작시키려면, 해당 인스턴스에서 "
":meth:`~multiprocessing.managers.BaseManager.shutdown()`\\을 호출하십시오. 그러면 이"
" 프로세스에 의해 관리되는 모든 :class:`SharedMemory` 객체에 대해 "
":meth:`SharedMemory.unlink()` 호출을 일으키고, 그런 다음 프로세스 자체를 중지합니다. "
"``SharedMemoryManager``\\를 통해 ``SharedMemory`` 인스턴스를 생성함으로써, 공유 메모리 자원을 "
"수동으로 추적하여 해제할 필요가 없습니다."

#: ../../library/multiprocessing.shared_memory.rst:223
msgid ""
"This class provides methods for creating and returning "
":class:`SharedMemory` instances and for creating a list-like object "
"(:class:`ShareableList`) backed by shared memory."
msgstr ""
"이 클래스는 :class:`SharedMemory` 인스턴스를 만들고 반환하는 메서드와, 공유 메모리로 지원되는 리스트류 "
"객체(:class:`ShareableList`)를 만드는 메서드를 제공합니다."

#: ../../library/multiprocessing.shared_memory.rst:227
#, fuzzy
msgid ""
"Refer to :class:`~multiprocessing.managers.BaseManager` for a description"
" of the inherited *address* and *authkey* optional input arguments and "
"how they may be used to connect to an existing "
":class:`!SharedMemoryManager` service from other processes."
msgstr ""
"상속된 *address*\\와 *authkey* 선택적 입력 인자에 대한 설명과 이 인자를 사용하여 다른 프로세스의 기존 "
"``SharedMemoryManager`` 서비스에 연결하는 방법에 대해서는 "
":class:`multiprocessing.managers.BaseManager`\\를 참조하십시오."

#: ../../library/multiprocessing.shared_memory.rst:234
#, fuzzy
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"*size* in bytes."
msgstr "바이트로 지정된 ``size`` 크기의 새로운 :class:`SharedMemory` 객체를 만들고 반환합니다."

#: ../../library/multiprocessing.shared_memory.rst:239
#, fuzzy
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the"
" values from the input *sequence*."
msgstr "입력 ``sequence``\\의 값으로 초기화된, 새 :class:`ShareableList` 객체를 만들고 반환합니다."

#: ../../library/multiprocessing.shared_memory.rst:243
#, fuzzy
msgid ""
"The following example demonstrates the basic mechanisms of a "
":class:`~multiprocessing.managers.SharedMemoryManager`:"
msgstr "다음 예제는 :class:`SharedMemoryManager`\\의 기본 메커니즘을 보여줍니다:"

#: ../../library/multiprocessing.shared_memory.rst:246
msgid ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start()  # Start the process that manages the shared memory "
"blocks\n"
">>> sl = smm.ShareableList(range(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> another_sl = smm.ShareableList('alpha')\n"
">>> another_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown()  # Calls unlink() on sl, raw_shm, and another_sl"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:261
#, fuzzy
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`~multiprocessing.managers.SharedMemoryManager` objects via "
"the :keyword:`with` statement to ensure that all shared memory blocks are"
" released after they are no longer needed:"
msgstr ""
"다음 예제는 :keyword:`with` 문을 통해 :class:`SharedMemoryManager` 객체를 사용하여 더는 "
"필요하지 않은 모든 공유 메모리 블록이 해제되도록 하는, 잠재적으로 더 편리한 패턴을 보여줍니다:"

#: ../../library/multiprocessing.shared_memory.rst:266
msgid ""
">>> with SharedMemoryManager() as smm:\n"
"...     sl = smm.ShareableList(range(2000))\n"
"...     # Divide the work among two processes, storing partial results in"
" sl\n"
"...     p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"...     p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"...     p1.start()\n"
"...     p2.start()  # A multiprocessing.Pool might be more efficient\n"
"...     p1.join()\n"
"...     p2.join()   # Wait for all work to complete in both processes\n"
"...     total_result = sum(sl)  # Consolidate the partial results now in "
"sl"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:280
#, fuzzy
msgid ""
"When using a :class:`~multiprocessing.managers.SharedMemoryManager` in a "
":keyword:`with` statement, the shared memory blocks created using that "
"manager are all released when the :keyword:`!with` statement's code block"
" finishes execution."
msgstr ""
":keyword:`with` 문에서 :class:`SharedMemoryManager`\\를 사용할 때, "
":keyword:`with` 문의 코드 블록 실행이 완료되면 해당 관리자를 사용하여 만들어진 공유 메모리 블록이 모두 해제됩니다."

#: ../../library/multiprocessing.shared_memory.rst:288
msgid ""
"Provide a mutable list-like object where all values stored within are "
"stored in a shared memory block. This constrains storable values to the "
"following built-in data types:"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:292
msgid ":class:`int` (signed 64-bit)"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:293
msgid ":class:`float`"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:294
msgid ":class:`bool`"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:295
msgid ":class:`str` (less than 10M bytes each when encoded as UTF-8)"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:296
msgid ":class:`bytes` (less than 10M bytes each)"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:297
msgid "``None``"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:299
msgid ""
"It also notably differs from the built-in :class:`list` type in that "
"these lists can not change their overall length (i.e. no :meth:`!append`,"
" :meth:`!insert`, etc.) and do not support the dynamic creation of new "
":class:`!ShareableList` instances via slicing."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:305
#, fuzzy
msgid ""
"*sequence* is used in populating a new :class:`!ShareableList` full of "
"values. Set to ``None`` to instead attach to an already existing "
":class:`!ShareableList` by its unique shared memory name."
msgstr ""
"*sequence*\\는 새로운 ``ShareableList``\\를 값으로 가득 채우는 데 사용됩니다. 고유한 공유 메모리 "
"이름으로 이미 존재하는 ``ShareableList``\\에 대신 연결하려면 ``None``\\으로 설정하십시오."

#: ../../library/multiprocessing.shared_memory.rst:309
#, fuzzy
msgid ""
"*name* is the unique name for the requested shared memory, as described "
"in the definition for :class:`SharedMemory`.  When attaching to an "
"existing :class:`!ShareableList`, specify its shared memory block's "
"unique name while leaving *sequence* set to ``None``."
msgstr ""
"*name*\\은 :class:`SharedMemory`\\에 대한 정의에서 설명한 대로, 요청된 공유 메모리의 고유한 이름입니다."
" 기존 ``ShareableList``\\에 연결할 때, ``sequence``\\를 ``None``\\으로 설정하고 공유 메모리 "
"블록의 고유한 이름을 지정하십시오."

#: ../../library/multiprocessing.shared_memory.rst:316
msgid ""
"A known issue exists for :class:`bytes` and :class:`str` values. If they "
"end with ``\\x00`` nul bytes or characters, those may be *silently "
"stripped* when fetching them by index from the :class:`!ShareableList`. "
"This ``.rstrip(b'\\x00')`` behavior is considered a bug and may go away "
"in the future. See :gh:`106939`."
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:322
msgid ""
"For applications where rstripping of trailing nulls is a problem, work "
"around it by always unconditionally appending an extra non-0 byte to the "
"end of such values when storing and unconditionally removing it when "
"fetching:"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:327
msgid ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> padded[0][:-1]\n"
"'?\\x00'\n"
">>> padded[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:345
#, fuzzy
msgid "Return the number of occurrences of *value*."
msgstr "``value``\\의 발생 횟수를 반환합니다."

#: ../../library/multiprocessing.shared_memory.rst:349
#, fuzzy
msgid ""
"Return first index position of *value*. Raise :exc:`ValueError` if "
"*value* is not present."
msgstr ""
"``value``\\의 첫 번째 인덱스 위치를 반환합니다. ``value``\\가 없으면 :exc:`ValueError`\\를 "
"발생시킵니다."

#: ../../library/multiprocessing.shared_memory.rst:354
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by "
"all currently stored values."
msgstr "현재 저장된 모든 값이 사용하는 :mod:`struct` 패킹 형식을 포함하는 읽기 전용 어트리뷰트."

#: ../../library/multiprocessing.shared_memory.rst:359
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "값이 저장되는 :class:`SharedMemory` 인스턴스."

#: ../../library/multiprocessing.shared_memory.rst:362
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr "다음 예제는 :class:`ShareableList` 인스턴스의 기본 사용을 보여줍니다.:"

#: ../../library/multiprocessing.shared_memory.rst:395
msgid ""
"The following example depicts how one, two, or many processes may access "
"the same :class:`ShareableList` by supplying the name of the shared "
"memory block behind it:"
msgstr ""
"다음 예는 하나, 둘 또는 여러 프로세스가 그 뒤에 있는 공유 메모리 블록의 이름을 제공하여 같은 "
":class:`ShareableList`\\에 액세스하는 방법을 보여줍니다:"

#: ../../library/multiprocessing.shared_memory.rst:410
msgid ""
"The following examples demonstrates that :class:`ShareableList` (and "
"underlying :class:`SharedMemory`) objects can be pickled and unpickled if"
" needed. Note, that it will still be the same shared object. This "
"happens, because the deserialized object has the same unique name and is "
"just attached to an existing object with the same name (if the object is "
"still alive):"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Shared Memory"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "POSIX Shared Memory"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Named Shared Memory"
msgstr ""

#~ msgid ""
#~ "Closes access to the shared memory "
#~ "from this instance.  In order to "
#~ "ensure proper cleanup of resources, all"
#~ " instances should call ``close()`` once "
#~ "the instance is no longer needed.  "
#~ "Note that calling ``close()`` does not"
#~ " cause the shared memory block itself"
#~ " to be destroyed."
#~ msgstr ""
#~ "이 인스턴스에서 공유 메모리에 대한 액세스를 닫습니다. "
#~ "자원을 적절히 정리하기 위해, 인스턴스가 더는 필요하지 "
#~ "않으면 모든 인스턴스가 ``close()``\\를 호출해야 합니다."
#~ " ``close()``\\를 호출해도 공유 메모리 블록 자체가"
#~ " 파괴되지는 않습니다."

#~ msgid ""
#~ "Requests that the underlying shared "
#~ "memory block be destroyed.  In order "
#~ "to ensure proper cleanup of resources,"
#~ " ``unlink()`` should be called once "
#~ "(and only once) across all processes "
#~ "which have need for the shared "
#~ "memory block.  After requesting its "
#~ "destruction, a shared memory block may"
#~ " or may not be immediately destroyed"
#~ " and this behavior may differ across"
#~ " platforms.  Attempts to access data "
#~ "inside the shared memory block after "
#~ "``unlink()`` has been called may result"
#~ " in memory access errors.  Note: the"
#~ " last process relinquishing its hold "
#~ "on a shared memory block may call"
#~ " ``unlink()`` and :meth:`close()` in either"
#~ " order."
#~ msgstr ""
#~ "하부 공유 메모리 블록이 삭제되도록 요청합니다. 리소스를"
#~ " 적절히 정리하려면, ``unlink()``\\를 공유 메모리 "
#~ "블록이 필요한 모든 프로세스 전체에서 (오직) 한 "
#~ "번만 호출해야 합니다. 파괴를 요청한 후에는, 공유 "
#~ "메모리 블록이 즉시 파괴될 수도 있고 그렇지 않을"
#~ " 수도 있습니다. 이 동작은 플랫폼에 따라 다를 "
#~ "수 있습니다. ``unlink()``\\가 호출된 후에, 공유 "
#~ "메모리 블록 내부의 데이터에 액세스하려고 하면 메모리 "
#~ "액세스 에러가 발생할 수 있습니다. 주의: 공유 "
#~ "메모리 블록에 대한 참조를 해제하는 마지막 프로세스는 "
#~ "``unlink()``\\와 :meth:`close()`\\를 어느 순서로든 호출"
#~ " 할 수 있습니다."

#~ msgid ""
#~ "Provides a mutable list-like object "
#~ "where all values stored within are "
#~ "stored in a shared memory block.  "
#~ "This constrains storable values to only"
#~ " the ``int``, ``float``, ``bool``, ``str``"
#~ " (less than 10M bytes each), "
#~ "``bytes`` (less than 10M bytes each),"
#~ " and ``None`` built-in data types."
#~ " It also notably differs from the "
#~ "built-in ``list`` type in that "
#~ "these lists can not change their "
#~ "overall length (i.e. no append, insert,"
#~ " etc.) and do not support the "
#~ "dynamic creation of new :class:`ShareableList`"
#~ " instances via slicing."
#~ msgstr ""
#~ "안에 저장되는 모든 값이 공유 메모리 블록에 "
#~ "저장되는 가변 리스트류 객체를 제공합니다. 이것은 "
#~ "``int``, ``float``, ``bool``, ``str`` (각각 "
#~ "10M 바이트 미만), ``bytes`` (각각 10M 바이트"
#~ " 미만) 및 ``None`` 내장 데이터형으로만 저장 "
#~ "가능한 값을 제한합니다. 또한, 이 리스트는 전체 "
#~ "길이를 변경할 수 없으며 (즉, 추가, 삽입 등이"
#~ " 없습니다), 슬라이싱을 통해 새로운 :class:`ShareableList`"
#~ " 인스턴스를 동적으로 생성할 수 없다는 점에서 내장"
#~ " ``list`` 형과 상당히 다릅니다."

