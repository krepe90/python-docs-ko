# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/telnetlib.rst:2
#, fuzzy
msgid ":mod:`!telnetlib` --- Telnet client"
msgstr ":mod:`telnetlib` --- 텔넷 클라이언트"

#: ../../library/telnetlib.rst:10
msgid ""
"This module is no longer part of the Python standard library. It was "
":ref:`removed in Python 3.13 <whatsnew313-pep594>` after being deprecated"
" in Python 3.11.  The removal was decided in :pep:`594`."
msgstr ""

#: ../../library/telnetlib.rst:14
msgid ""
"Possible replacements are third-party libraries from PyPI: "
":pypi:`telnetlib3` or :pypi:`Exscript`.  These are not supported or "
"maintained by the Python core team."
msgstr ""

#: ../../library/telnetlib.rst:18
msgid ""
"The last version of Python that provided the :mod:`!telnetlib` module was"
" `Python 3.12 <https://docs.python.org/3.12/library/telnetlib.html>`_."
msgstr ""

#~ msgid "**Source code:** :source:`Lib/telnetlib.py`"
#~ msgstr "**소스 코드:** :source:`Lib/telnetlib.py`"

#~ msgid ""
#~ "The :mod:`telnetlib` module provides a "
#~ ":class:`Telnet` class that implements the "
#~ "Telnet protocol.  See :rfc:`854` for "
#~ "details about the protocol. In addition,"
#~ " it provides symbolic constants for "
#~ "the protocol characters (see below), and"
#~ " for the telnet options. The symbolic"
#~ " names of the telnet options follow"
#~ " the definitions in ``arpa/telnet.h``, with"
#~ " the leading ``TELOPT_`` removed. For "
#~ "symbolic names of options which are "
#~ "traditionally not included in "
#~ "``arpa/telnet.h``, see the module source "
#~ "itself."
#~ msgstr ""
#~ ":mod:`telnetlib` 모듈은 텔넷 프로토콜을 구현하는 "
#~ ":class:`Telnet` 클래스를 제공합니다. 프로토콜에 대한 자세한"
#~ " 내용은 :rfc:`854`\\를 참조하십시오. 또한, 프로토콜 "
#~ "문자(아래를 보십시오)와 텔넷 옵션을 위한 기호 상수를 "
#~ "제공합니다. 텔넷 옵션의 기호 이름은 "
#~ "``arpa/telnet.h``\\의 정의를 따르며, 선행 "
#~ "``TELOPT_``\\는 제거됩니다. 전통적으로 ``arpa/telnet.h``\\에 "
#~ "포함되지 않는 옵션의 기호 이름에 대해서는 모듈 "
#~ "소스 자체를 참조하십시오."

#~ msgid ""
#~ "The symbolic constants for the telnet"
#~ " commands are: IAC, DONT, DO, WONT,"
#~ " WILL, SE (Subnegotiation End), NOP "
#~ "(No Operation), DM (Data Mark), BRK "
#~ "(Break), IP (Interrupt process), AO "
#~ "(Abort output), AYT (Are You There), "
#~ "EC (Erase Character), EL (Erase Line),"
#~ " GA (Go Ahead), SB (Subnegotiation "
#~ "Begin)."
#~ msgstr ""
#~ "텔넷 명령을 위한 기호 상수는 다음과 같습니다: "
#~ "IAC, DONT, DO, WONT, WILL, SE "
#~ "(Subnegotiation End), NOP (No Operation), "
#~ "DM (Data Mark), BRK (Break), IP "
#~ "(Interrupt process), AO (Abort output), "
#~ "AYT (Are You There), EC (Erase "
#~ "Character), EL (Erase Line), GA (Go "
#~ "Ahead), SB (Subnegotiation Begin)."

#~ msgid ""
#~ ":class:`Telnet` represents a connection to "
#~ "a Telnet server. The instance is "
#~ "initially not connected by default; the"
#~ " :meth:`~Telnet.open` method must be used"
#~ " to establish a connection.  Alternatively,"
#~ " the host name and optional port "
#~ "number can be passed to the "
#~ "constructor too, in which case the "
#~ "connection to the server will be "
#~ "established before the constructor returns."
#~ "  The optional *timeout* parameter "
#~ "specifies a timeout in seconds for "
#~ "blocking operations like the connection "
#~ "attempt (if not specified, the global"
#~ " default timeout setting will be "
#~ "used)."
#~ msgstr ""
#~ ":class:`Telnet`\\는 텔넷 서버와의 연결을 나타냅니다. "
#~ "인스턴스는 기본적으로 처음에는 연결되지 않습니다; 연결하려면 "
#~ ":meth:`~Telnet.open` 메서드를 사용해야 합니다. 또는, "
#~ "호스트 이름과 선택적 포트 번호를 생성자에게 전달할 "
#~ "수 있는데, 이때는 생성자가 반환되기 전에 서버와 "
#~ "연결합니다. 선택적 *timeout* 매개 변수는 연결 시도와"
#~ " 같은 블로킹 연산에 대한 시간제한을 초로 지정합니다"
#~ " (지정하지 않으면, 전역 기본 시간제한 설정이 "
#~ "사용됩니다)."

#~ msgid "Do not reopen an already connected instance."
#~ msgstr "이미 연결된 인스턴스를 다시 열지 마십시오."

#~ msgid ""
#~ "This class has many :meth:`read_\\*` "
#~ "methods.  Note that some of them  "
#~ "raise :exc:`EOFError` when the end of"
#~ " the connection is read, because they"
#~ " can return an empty string for "
#~ "other reasons.  See the individual "
#~ "descriptions below."
#~ msgstr ""
#~ "이 클래스에는 많은 :meth:`read_\\*` 메서드가 있습니다."
#~ " 이들 중 일부는 연결의 끝을 읽을 때 "
#~ ":exc:`EOFError`\\를 발생시킴에 유의하십시오. 다른 이유로 "
#~ "빈 문자열을 반환할 수 있기 때문입니다. 아래의 "
#~ "개별 설명을 참조하십시오."

#~ msgid ""
#~ "A :class:`Telnet` object is a context"
#~ " manager and can be used in a"
#~ " :keyword:`with` statement.  When the "
#~ ":keyword:`!with` block ends, the :meth:`close`"
#~ " method is called::"
#~ msgstr ""
#~ ":class:`Telnet` 객체는 컨텍스트 관리자이며 :keyword:`with`"
#~ " 문에서 사용할 수 있습니다. :keyword:`!with` 블록이"
#~ " 끝날 때, :meth:`close` 메서드가 호출됩니다::"

#~ msgid "Context manager support added"
#~ msgstr "컨텍스트 관리자 지원을 추가했습니다"

#~ msgid ":rfc:`854` - Telnet Protocol Specification"
#~ msgstr ":rfc:`854` - Telnet Protocol Specification"

#~ msgid "Definition of the Telnet protocol."
#~ msgstr "텔넷 프로토콜의 정의."

#~ msgid "Telnet Objects"
#~ msgstr "텔넷 객체"

#~ msgid ":class:`Telnet` instances have the following methods:"
#~ msgstr ":class:`Telnet` 인스턴스에는 다음과 같은 메서드가 있습니다.:"

#~ msgid ""
#~ "Read until a given byte string, "
#~ "*expected*, is encountered or until "
#~ "*timeout* seconds have passed."
#~ msgstr "주어진 바이트열 *expected*\\를 만나거나 *timeout* 초가 경과 할 때까지 읽습니다."

#~ msgid ""
#~ "When no match is found, return "
#~ "whatever is available instead, possibly "
#~ "empty bytes.  Raise :exc:`EOFError` if "
#~ "the connection is closed and no "
#~ "cooked data is available."
#~ msgstr ""
#~ "일치하는 것을 찾을 수 없으면, 사용 가능한 것을"
#~ " 대신 반환합니다. 빈 바이트열도 가능합니다. 연결이 "
#~ "닫혀 있고 사용할 수 있는 요리된 데이터가 없으면"
#~ " :exc:`EOFError`\\를 발생시킵니다."

#~ msgid "Read all data until EOF as bytes; block until connection closed."
#~ msgstr "EOF까지 모든 데이터를 바이트열로 읽습니다; 연결이 닫힐 때까지 블록합니다."

#~ msgid ""
#~ "Read at least one byte of cooked"
#~ " data unless EOF is hit. Return "
#~ "``b''`` if EOF is hit.  Block if"
#~ " no data is immediately available."
#~ msgstr ""
#~ "EOF를 만나지 않으면 적어도 1바이트의 요리된 데이터를"
#~ " 읽습니다. EOF를 만나면 ``b''``\\를 반환합니다. 즉시"
#~ " 사용할 수 있는 데이터가 없으면 블록합니다."

#~ msgid "Read everything that can be without blocking in I/O (eager)."
#~ msgstr "I/O에서 블록하지 않고 읽을 수 있는 모든 것을 읽습니다 (eager)."

#~ msgid ""
#~ "Raise :exc:`EOFError` if connection closed "
#~ "and no cooked data available. Return "
#~ "``b''`` if no cooked data available "
#~ "otherwise. Do not block unless in "
#~ "the midst of an IAC sequence."
#~ msgstr ""
#~ "연결이 닫혀 있고 사용할 수 있는 요리된 데이터가"
#~ " 없으면 :exc:`EOFError`\\를 발생시킵니다. 그렇지 않고 "
#~ "사용할 수 있는 요리된 데이터가 없으면 ``b''``\\를"
#~ " 반환합니다. IAC 시퀀스의 중간에 있지 않으면 "
#~ "블록하지 않습니다."

#~ msgid "Read readily available data."
#~ msgstr "쉽게 사용할 수 있는 데이터를 읽습니다."

#~ msgid "Process and return data already in the queues (lazy)."
#~ msgstr "이미 큐에 있는 데이터를 처리하고 반환합니다 (lazy)."

#~ msgid ""
#~ "Raise :exc:`EOFError` if connection closed "
#~ "and no data available. Return ``b''``"
#~ " if no cooked data available "
#~ "otherwise.  Do not block unless in "
#~ "the midst of an IAC sequence."
#~ msgstr ""
#~ "연결이 닫혀 있고 사용할 수 있는 데이터가 없으면"
#~ " :exc:`EOFError`\\를 발생시킵니다. 그렇지 않고 사용할 "
#~ "수 있는 요리된 데이터가 없으면 ``b''``\\를 "
#~ "반환합니다. IAC 시퀀스의 중간에 있지 않으면 블록하지"
#~ " 않습니다."

#~ msgid "Return any data available in the cooked queue (very lazy)."
#~ msgstr "요리된 큐에 있는 모든 데이터를 반환합니다 (very lazy)."

#~ msgid ""
#~ "Raise :exc:`EOFError` if connection closed "
#~ "and no data available. Return ``b''``"
#~ " if no cooked data available "
#~ "otherwise.  This method never blocks."
#~ msgstr ""
#~ "연결이 닫혀 있고 사용할 수 있는 데이터가 없으면"
#~ " :exc:`EOFError`\\를 발생시킵니다. 그렇지 않고 사용할 "
#~ "수 있는 요리된 데이터가 없으면 ``b''``\\를 "
#~ "반환합니다. 이 메서드는 절대 블록하지 않습니다."

#~ msgid ""
#~ "Return the data collected between a "
#~ "SB/SE pair (suboption begin/end). The "
#~ "callback should access these data when"
#~ " it was invoked with a ``SE`` "
#~ "command. This method never blocks."
#~ msgstr ""
#~ "SB/SE 쌍(suboption begin/end)간에 수집된 데이터를 "
#~ "반환합니다. ``SE`` 명령으로 호출되었을 때 콜백은 이"
#~ " 데이터에 액세스해야 합니다. 이 방법은 절대 블록하지"
#~ " 않습니다."

#~ msgid ""
#~ "Connect to a host. The optional "
#~ "second argument is the port number, "
#~ "which defaults to the standard Telnet"
#~ " port (23). The optional *timeout* "
#~ "parameter specifies a timeout in seconds"
#~ " for blocking operations like the "
#~ "connection attempt (if not specified, "
#~ "the global default timeout setting will"
#~ " be used)."
#~ msgstr ""
#~ "호스트에 연결합니다. 선택적 두 번째 인자는 포트 "
#~ "번호이며, 기본값은 표준 텔넷 포트(23)입니다. 선택적 "
#~ "*timeout* 매개 변수는 연결 시도와 같은 블로킹 "
#~ "연산에 대한 시간제한을 초로 지정합니다 (지정하지 않으면,"
#~ " 전역 기본 시간제한 설정이 사용됩니다)."

#~ msgid "Do not try to reopen an already connected instance."
#~ msgstr "이미 연결된 인스턴스를 다시 열려고 하지 마십시오."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``telnetlib.Telnet.open`` with arguments ``self``,"
#~ " ``host``, ``port``."
#~ msgstr ""
#~ "``self``, ``host``, ``port``\\를 인자로 :ref:`감사"
#~ " 이벤트(auditing event) <auditing>` "
#~ "``telnetlib.Telnet.open``\\을 발생시킵니다."

#~ msgid ""
#~ "Print a debug message when the "
#~ "debug level is ``>`` 0. If extra"
#~ " arguments are present, they are "
#~ "substituted in the message using the "
#~ "standard string formatting operator."
#~ msgstr ""
#~ "디버그 수준이 ``>`` 0 일 때 디버그 메시지를"
#~ " 인쇄합니다. 추가 인자가 있으면, 표준 문자열 포매팅"
#~ " 연산자를 사용하여 메시지에 치환됩니다."

#~ msgid ""
#~ "Set the debug level.  The higher "
#~ "the value of *debuglevel*, the more "
#~ "debug output you get (on "
#~ "``sys.stdout``)."
#~ msgstr ""
#~ "디버그 수준을 설정합니다. *debuglevel*\\의 값이 클수록,"
#~ " 더 많은 디버그 출력을 얻을 수 있습니다 "
#~ "(``sys.stdout``\\으로)."

#~ msgid "Close the connection."
#~ msgstr "연결을 닫습니다."

#~ msgid "Return the socket object used internally."
#~ msgstr "내부적으로 사용되는 소켓 객체를 반환합니다."

#~ msgid "Return the file descriptor of the socket object used internally."
#~ msgstr "내부적으로 사용되는 소켓 객체의 파일 기술자를 반환합니다."

#~ msgid ""
#~ "Write a byte string to the socket,"
#~ " doubling any IAC characters. This "
#~ "can block if the connection is "
#~ "blocked.  May raise :exc:`OSError` if "
#~ "the connection is closed."
#~ msgstr ""
#~ "IAC 문자를 중복(doubling)해서 소켓에 바이트열을 기록합니다."
#~ " 연결이 블록 되면 블록 할 수 있습니다. "
#~ "연결이 닫히면 :exc:`OSError`\\가 발생할 수 있습니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``telnetlib.Telnet.write`` with arguments ``self``,"
#~ " ``buffer``."
#~ msgstr ""
#~ "``self``, ``buffer``\\를 인자로 :ref:`감사 "
#~ "이벤트(auditing event) <auditing>` "
#~ "``telnetlib.Telnet.write``\\를 발생시킵니다."

#~ msgid ""
#~ "This method used to raise "
#~ ":exc:`socket.error`, which is now an "
#~ "alias of :exc:`OSError`."
#~ msgstr "이 메서드는 방법은 :exc:`socket.error`\\를 발생시켰습니다. 이제는 :exc:`OSError`\\의 별칭입니다."

#~ msgid "Interaction function, emulates a very dumb Telnet client."
#~ msgstr "상호 작용 함수, 매우 단순한 텔넷 클라이언트를 에뮬레이션합니다."

#~ msgid "Multithreaded version of :meth:`interact`."
#~ msgstr ":meth:`interact`\\의 다중 스레드 버전."

#~ msgid "Read until one from a list of a regular expressions matches."
#~ msgstr "정규식 리스트 중 하나가 일치할 때까지 읽습니다."

#~ msgid ""
#~ "The first argument is a list of"
#~ " regular expressions, either compiled "
#~ "(:ref:`regex objects <re-objects>`) or "
#~ "uncompiled (byte strings). The optional "
#~ "second argument is a timeout, in "
#~ "seconds; the default is to block "
#~ "indefinitely."
#~ msgstr ""
#~ "첫 번째 인자는 컴파일되었거나 (:ref:`정규식 객체 "
#~ "<re-objects>`) 컴파일되지 않은 (바이트열) 정규식의 "
#~ "리스트입니다. 선택적 두 번째 인자는 초 단위의 "
#~ "시간제한입니다; 기본값은 무기한 블록 하는 것입니다."

#~ msgid ""
#~ "Return a tuple of three items: the"
#~ " index in the list of the first"
#~ " regular expression that matches; the "
#~ "match object returned; and the bytes "
#~ "read up till and including the "
#~ "match."
#~ msgstr ""
#~ "세 항목의 튜플을 반환합니다: 일치하는 첫 번째 "
#~ "정규식의 리스트 인덱스; 반환된 일치 객체; 그리고 "
#~ "일치를 포함해서 그때까지 읽은 바이트열."

#~ msgid ""
#~ "If end of file is found and "
#~ "no bytes were read, raise "
#~ ":exc:`EOFError`. Otherwise, when nothing "
#~ "matches, return ``(-1, None, data)`` "
#~ "where *data* is the bytes received "
#~ "so far (may be empty bytes if "
#~ "a timeout happened)."
#~ msgstr ""
#~ "파일의 끝이 발견되고 아무런 바이트도 읽히지 않았으면, "
#~ ":exc:`EOFError`\\를 발생시킵니다. 그렇지 않으면, 아무것도 "
#~ "일치하지 않을 때, ``(-1, None, data)``\\를 "
#~ "반환합니다. 여기서 *data*\\는 지금까지 받은 바이트열입니다 "
#~ "(시간 초과가 발생하면 빈 바이트열일 수 있습니다)."

#~ msgid ""
#~ "If a regular expression ends with "
#~ "a greedy match (such as ``.*``) or"
#~ " if more than one expression can "
#~ "match the same input, the results "
#~ "are non-deterministic, and may depend"
#~ " on the I/O timing."
#~ msgstr ""
#~ "정규식이 탐욕적인 일치(가령 ``.*``)로 끝나거나 둘 "
#~ "이상의 정규식이 같은 입력과 일치 할 수 있으면,"
#~ " 결과는 비결정적이며, I/O 타이밍에 따라 달라질 수"
#~ " 있습니다."

#~ msgid ""
#~ "Each time a telnet option is read"
#~ " on the input flow, this *callback*"
#~ " (if set) is called with the "
#~ "following parameters: callback(telnet socket, "
#~ "command (DO/DONT/WILL/WONT), option).  No "
#~ "other action is done afterwards by "
#~ "telnetlib."
#~ msgstr ""
#~ "입력 흐름에서 텔넷 옵션을 읽을 때마다, 이 "
#~ "*callback*\\(설정되었다면)은 다음과 같은 매개 변수로 "
#~ "호출됩니다: callback(telnet socket, command "
#~ "(DO/DONT/WILL/WONT), option). telnetlib은 나중에 "
#~ "다른 작업을 수행하지 않습니다."

#~ msgid "Telnet Example"
#~ msgstr "텔넷 예제"

#~ msgid "A simple example illustrating typical use::"
#~ msgstr "일반적인 사용을 보여주는 간단한 예제::"

