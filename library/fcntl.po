# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/fcntl.rst:2
msgid ":mod:`!fcntl` --- The ``fcntl`` and ``ioctl`` system calls"
msgstr ":mod:`!fcntl` --- ``fcntl``\\과 ``ioctl`` 시스템 호출"

#: ../../library/fcntl.rst:16
msgid ""
"This module performs file and I/O control on file descriptors. It is an "
"interface to the :c:func:`fcntl` and :c:func:`ioctl` Unix routines. See "
"the :manpage:`fcntl(2)` and :manpage:`ioctl(2)` Unix manual pages for "
"full details."
msgstr ""
"이 모듈은 파일 기술자에 대한 파일과 I/O 제어를 수행합니다. :c:func:`fcntl`\\과 :c:func:`ioctl` "
"유닉스 루틴에 대한 인터페이스입니다. 자세한 설명은 :manpage:`fcntl(2)`\\과 :manpage:`ioctl(2)` "
"유닉스 매뉴얼 페이지를 참조하십시오."

#: ../../library/fcntl.rst:21
msgid "Availability"
msgstr "가용성"

#: ../../library/fcntl.rst:23
msgid ""
"All functions in this module take a file descriptor *fd* as their first "
"argument.  This can be an integer file descriptor, such as returned by "
"``sys.stdin.fileno()``, or an :class:`io.IOBase` object, such as "
"``sys.stdin`` itself, which provides a :meth:`~io.IOBase.fileno` that "
"returns a genuine file descriptor."
msgstr ""
"이 모듈의 모든 함수는 첫 번째 인자로 파일 기술자 *fd*\\를 받아들입니다. 이것은 "
"``sys.stdin.fileno()``\\에 의해 반환된 것과 같은 정수 파일 기술자이거나 ``sys.stdin`` 자체와 같은 "
":class:`io.IOBase` 객체일 수 있습니다. 이 객체는 실제 파일 기술자를 반환하는 "
":meth:`~io.IOBase.fileno`\\를 제공합니다."

#: ../../library/fcntl.rst:29
msgid ""
"Operations in this module used to raise an :exc:`IOError` where they now "
"raise an :exc:`OSError`."
msgstr "이 모듈의 연산은 :exc:`IOError`\\를 발생시켰는데, 이제는 :exc:`OSError`\\를 발생시킵니다."

#: ../../library/fcntl.rst:33
msgid ""
"The :mod:`!fcntl` module now contains ``F_ADD_SEALS``, ``F_GET_SEALS``, "
"and ``F_SEAL_*`` constants for sealing of :func:`os.memfd_create` file "
"descriptors."
msgstr ""
":mod:`!fcntl` 모듈에는 이제 :func:`os.memfd_create` 파일 기술자를 봉인(seal)하기 위한 "
"``F_ADD_SEALS``, ``F_GET_SEALS`` 및 ``F_SEAL_*`` 상수가 포함됩니다."

#: ../../library/fcntl.rst:38
msgid ""
"On macOS, the :mod:`!fcntl` module exposes the ``F_GETPATH`` constant, "
"which obtains the path of a file from a file descriptor. On "
"Linux(>=3.15), the :mod:`!fcntl` module exposes the ``F_OFD_GETLK``, "
"``F_OFD_SETLK`` and ``F_OFD_SETLKW`` constants, which are used when "
"working with open file description locks."
msgstr ""
"macOS에서, :mod:`!fcntl` 모듈은 파일 기술자에서 파일의 경로를 얻는 ``F_GETPATH`` 상수를 노출합니다. "
"리눅스(>=3.15)에서, :mod:`!fcntl` 모듈은 열린 파일 기술 록(open file description "
"locks)으로 작업할 때 사용되는 ``F_OFD_GETLK``, ``F_OFD_SETLK`` 및 ``F_OFD_SETLKW`` "
"상수를 노출합니다."

#: ../../library/fcntl.rst:45
msgid ""
"On Linux >= 2.6.11, the :mod:`!fcntl` module exposes the ``F_GETPIPE_SZ``"
" and ``F_SETPIPE_SZ`` constants, which allow to check and modify a pipe's"
" size respectively."
msgstr ""

#: ../../library/fcntl.rst:50
msgid ""
"On FreeBSD, the :mod:`!fcntl` module exposes the ``F_DUP2FD`` and "
"``F_DUP2FD_CLOEXEC`` constants, which allow to duplicate a file "
"descriptor, the latter setting ``FD_CLOEXEC`` flag in addition."
msgstr ""

#: ../../library/fcntl.rst:55
msgid ""
"On Linux >= 4.5, the :mod:`fcntl` module exposes the ``FICLONE`` and "
"``FICLONERANGE`` constants, which allow to share some data of one file "
"with another file by reflinking on some filesystems (e.g., btrfs, OCFS2, "
"and XFS). This behavior is commonly referred to as \"copy-on-write\"."
msgstr ""

#: ../../library/fcntl.rst:61
msgid ""
"On Linux >= 2.6.32, the :mod:`!fcntl` module exposes the ``F_GETOWN_EX``,"
" ``F_SETOWN_EX``, ``F_OWNER_TID``, ``F_OWNER_PID``, ``F_OWNER_PGRP`` "
"constants, which allow to direct I/O availability signals to a specific "
"thread, process, or process group. On Linux >= 4.13, the :mod:`!fcntl` "
"module exposes the ``F_GET_RW_HINT``, ``F_SET_RW_HINT``, "
"``F_GET_FILE_RW_HINT``, ``F_SET_FILE_RW_HINT``, and ``RWH_WRITE_LIFE_*`` "
"constants, which allow to inform the kernel about the relative expected "
"lifetime of writes on a given inode or via a particular open file "
"description. On Linux >= 5.1 and NetBSD, the :mod:`!fcntl` module exposes"
" the ``F_SEAL_FUTURE_WRITE`` constant for use with ``F_ADD_SEALS`` and "
"``F_GET_SEALS`` operations. On FreeBSD, the :mod:`!fcntl` module exposes "
"the ``F_READAHEAD``, ``F_ISUNIONSTACK``, and ``F_KINFO`` constants. On "
"macOS and FreeBSD, the :mod:`!fcntl` module exposes the ``F_RDAHEAD`` "
"constant. On NetBSD and AIX, the :mod:`!fcntl` module exposes the "
"``F_CLOSEM`` constant. On NetBSD, the :mod:`!fcntl` module exposes the "
"``F_MAXFD`` constant. On macOS and NetBSD, the :mod:`!fcntl` module "
"exposes the ``F_GETNOSIGPIPE`` and ``F_SETNOSIGPIPE`` constant."
msgstr ""

#: ../../library/fcntl.rst:82
msgid "The module defines the following functions:"
msgstr "이 모듈은 다음 함수를 정의합니다:"

#: ../../library/fcntl.rst:87
msgid ""
"Perform the operation *cmd* on file descriptor *fd* (file objects "
"providing a :meth:`~io.IOBase.fileno` method are accepted as well).  The "
"values used for *cmd* are operating system dependent, and are available "
"as constants in the :mod:`fcntl` module, using the same names as used in "
"the relevant C header files. The argument *arg* can either be an integer "
"value, or a :class:`bytes` object. With an integer value, the return "
"value of this function is the integer return value of the C "
":c:func:`fcntl` call.  When the argument is bytes it represents a binary "
"structure, e.g. created by :func:`struct.pack`. The binary data is copied"
" to a buffer whose address is passed to the C :c:func:`fcntl` call.  The "
"return value after a successful call is the contents of the buffer, "
"converted to a :class:`bytes` object. The length of the returned object "
"will be the same as the length of the *arg* argument. This is limited to "
"1024 bytes. If the information returned in the buffer by the operating "
"system is larger than 1024 bytes, this is most likely to result in a "
"segmentation violation or a more subtle data corruption."
msgstr ""
"파일 기술자 *fd*\\(:meth:`~io.IOBase.fileno` 메서드를 제공하는 파일 객체도 허용됩니다)에 대해 *cmd*"
" 연산을 수행합니다. *cmd*\\에 사용되는 값은 운영 체제에 따라 다르며, 관련 C 헤더 파일에 사용된 것과 같은 이름을 "
"사용하여 :mod:`fcntl` 모듈에서 상수로 제공됩니다. 인자 *arg*\\는 정숫값이나 :class:`bytes` 객체가 될 "
"수 있습니다. 정숫값일 때, 이 함수의 반환 값은 C :c:func:`fcntl` 호출의 정수 반환 값입니다. 인자가 바이트열일 때"
" 바이너리 구조체를 나타냅니다, 예를 들어 :func:`struct.pack`\\으로 만든 것입니다. 바이너리 데이터는 주소가 C "
":c:func:`fcntl` 호출에 전달될 버퍼로 복사됩니다. 호출 성공 후 반환 값은 버퍼 내용이며, :class:`bytes` "
"객체로 변환됩니다. 반환된 객체의 길이는 *arg* 인자의 길이와 같습니다. 이것은 1024바이트로 제한됩니다. 운영 체제에 의해 "
"버퍼로 반환된 정보가 1024바이트보다 크면, 세그멘테이션 위반이나 더 미묘한 데이터 손상이 발생할 가능성이 큽니다."

#: ../../library/fcntl.rst:104
msgid "If the :c:func:`fcntl` call fails, an :exc:`OSError` is raised."
msgstr ":c:func:`fcntl` 호출이 실패하면, :exc:`OSError`\\가 발생합니다."

#: ../../library/fcntl.rst:106
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.fcntl`` with arguments"
" ``fd``, ``cmd``, ``arg``."
msgstr ""
"인자 ``fd``, ``cmd``, ``arg``\\로 :ref:`감사 이벤트 <auditing>` "
"``fcntl.fcntl``\\을 발생시킵니다."

#: ../../library/fcntl.rst:111
msgid ""
"This function is identical to the :func:`~fcntl.fcntl` function, except "
"that the argument handling is even more complicated."
msgstr "이 함수는 인자 처리가 훨씬 더 복잡하다는 점을 제외하면, :func:`~fcntl.fcntl` 함수와 같습니다."

#: ../../library/fcntl.rst:114
msgid ""
"The *request* parameter is limited to values that can fit in 32-bits. "
"Additional constants of interest for use as the *request* argument can be"
" found in the :mod:`termios` module, under the same names as used in the "
"relevant C header files."
msgstr ""
"*request* 매개 변수는 32비트에 맞출 수 있는 값으로 제한됩니다. *request* 인자로 사용하기 위한 추가 상수는 관련"
" C 헤더 파일에서 사용된 것과 같은 이름으로 :mod:`termios` 모듈에서 제공됩니다."

#: ../../library/fcntl.rst:119
msgid ""
"The parameter *arg* can be one of an integer, an object supporting the "
"read-only buffer interface (like :class:`bytes`) or an object supporting "
"the read-write buffer interface (like :class:`bytearray`)."
msgstr ""
"매개 변수 *arg*\\는 정수, 읽기 전용 버퍼 인터페이스를 지원하는 (:class:`bytes` 같은) 객체 또는 읽기-쓰기 "
"버퍼 인터페이스를 지원하는 (:class:`bytearray` 같은) 객체 중 하나일 수 있습니다."

#: ../../library/fcntl.rst:123
msgid ""
"In all but the last case, behaviour is as for the :func:`~fcntl.fcntl` "
"function."
msgstr "마지막 경우를 제외하고는, 동작이 :func:`~fcntl.fcntl` 함수와 같습니다."

#: ../../library/fcntl.rst:126
msgid ""
"If a mutable buffer is passed, then the behaviour is determined by the "
"value of the *mutate_flag* parameter."
msgstr "가변 버퍼가 전달되면, 동작은 *mutate_flag* 매개 변수의 값에 의해 결정됩니다."

#: ../../library/fcntl.rst:129
msgid ""
"If it is false, the buffer's mutability is ignored and behaviour is as "
"for a read-only buffer, except that the 1024 byte limit mentioned above "
"is avoided -- so long as the buffer you pass is at least as long as what "
"the operating system wants to put there, things should work."
msgstr ""
"거짓이면, 버퍼의 가변성은 무시되고 동작은 읽기 전용 버퍼일 때와 같습니다. 단, 위에서 언급한 1024바이트 제한은 피할 수 "
"있습니다 -- 최소한 전달한 버퍼가 운영 체제가 원하는 만큼 길면 작동해야 합니다."

#: ../../library/fcntl.rst:134
msgid ""
"If *mutate_flag* is true (the default), then the buffer is (in effect) "
"passed to the underlying :func:`ioctl` system call, the latter's return "
"code is passed back to the calling Python, and the buffer's new contents "
"reflect the action of the :func:`ioctl`.  This is a slight "
"simplification, because if the supplied buffer is less than 1024 bytes "
"long it is first copied into a static buffer 1024 bytes long which is "
"then passed to :func:`ioctl` and copied back into the supplied buffer."
msgstr ""
"*mutate_flag*\\가 참(기본값)이면, 버퍼가 (결과적으로) 하부 :func:`ioctl` 시스템 호출로 전달되고, 이 "
"호출의 반환 코드는 호출하는 파이썬으로 다시 전달되고 버퍼의 새로운 내용은 :func:`ioctl`\\의 동작을 반영합니다. 이것은"
" 약간 단순화한 설명인데, 제공된 버퍼가 1024바이트보다 작으면, 1024바이트 길이의 정적 버퍼에 먼저 복사된 다음, 이 정적 "
"버퍼가 :func:`ioctl`\\로 전달되고, 정적 버퍼를 제공된 버퍼로 다시 복사하기 때문입니다."

#: ../../library/fcntl.rst:142
msgid "If the :c:func:`ioctl` call fails, an :exc:`OSError` exception is raised."
msgstr ":c:func:`ioctl` 호출이 실패하면, :exc:`OSError` 예외가 발생합니다."

#: ../../library/fcntl.rst:144
msgid "An example::"
msgstr "예제::"

#: ../../library/fcntl.rst:146
msgid ""
">>> import array, fcntl, struct, termios, os\n"
">>> os.getpgrp()\n"
"13341\n"
">>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, \"  \"))[0]\n"
"13341\n"
">>> buf = array.array('h', [0])\n"
">>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)\n"
"0\n"
">>> buf\n"
"array('h', [13341])"
msgstr ""
">>> import array, fcntl, struct, termios, os\n"
">>> os.getpgrp()\n"
"13341\n"
">>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, \"  \"))[0]\n"
"13341\n"
">>> buf = array.array('h', [0])\n"
">>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)\n"
"0\n"
">>> buf\n"
"array('h', [13341])"

#: ../../library/fcntl.rst:157
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.ioctl`` with arguments"
" ``fd``, ``request``, ``arg``."
msgstr ""
"인자 ``fd``, ``request``, ``arg``\\로 :ref:`감사 이벤트 <auditing>` "
"``fcntl.ioctl``\\을 발생시킵니다."

#: ../../library/fcntl.rst:162
msgid ""
"Perform the lock operation *operation* on file descriptor *fd* (file "
"objects providing a :meth:`~io.IOBase.fileno` method are accepted as "
"well). See the Unix manual :manpage:`flock(2)` for details.  (On some "
"systems, this function is emulated using :c:func:`fcntl`.)"
msgstr ""
"파일 기술자 *fd*\\(:meth:`~io.IOBase.fileno` 메서드를 제공하는 파일 객체도 허용됩니다)\\에 대한 잠금 "
"연산 *operation*\\을 수행합니다. 자세한 내용은 유닉스 매뉴얼 :manpage:`flock(2)`\\를 참조하십시오. "
"(일부 시스템에서는, 이 함수가 :c:func:`fcntl`\\를 사용하여 에뮬레이트됩니다.)"

#: ../../library/fcntl.rst:167
msgid "If the :c:func:`flock` call fails, an :exc:`OSError` exception is raised."
msgstr ":c:func:`flock` 호출이 실패하면, :exc:`OSError` 예외가 발생합니다."

#: ../../library/fcntl.rst:169
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.flock`` with arguments"
" ``fd``, ``operation``."
msgstr ""
"인자 ``fd``, ``operation``\\으로 :ref:`감사 이벤트 <auditing>` ``fcntl.flock``\\을 "
"발생시킵니다."

#: ../../library/fcntl.rst:174
msgid ""
"This is essentially a wrapper around the :func:`~fcntl.fcntl` locking "
"calls. *fd* is the file descriptor (file objects providing a "
":meth:`~io.IOBase.fileno` method are accepted as well) of the file to "
"lock or unlock, and *cmd* is one of the following values:"
msgstr ""
"이것은 본질에서 :func:`~fcntl.fcntl` 잠금 호출에 대한 래퍼입니다. *fd*\\는 잠그거나 잠금 해제할 파일의 파일"
" 기술자이고 (:meth:`~io.IOBase.fileno` 메서드를 제공하는 파일 객체도 허용됩니다), *cmd*\\는 다음 값 "
"중 하나입니다:"

#: ../../library/fcntl.rst:181
msgid "Release an existing lock."
msgstr "기존 잠금 해제."

#: ../../library/fcntl.rst:185
msgid "Acquire a shared lock."
msgstr "공유 잠금 획득."

#: ../../library/fcntl.rst:189
msgid "Acquire an exclusive lock."
msgstr "배타적 잠금 획득."

#: ../../library/fcntl.rst:193
msgid ""
"Bitwise OR with any of the other three ``LOCK_*`` constants to make the "
"request non-blocking."
msgstr "다른 세 개의 ``LOCK_*`` 상수와 비트별 OR 하여 요청을 비 블로킹으로 만듭니다."

#: ../../library/fcntl.rst:196
msgid ""
"If :const:`!LOCK_NB` is used and the lock cannot be acquired, an "
":exc:`OSError` will be raised and the exception will have an *errno* "
"attribute set to :const:`~errno.EACCES` or :const:`~errno.EAGAIN` "
"(depending on the operating system; for portability, check for both "
"values).  On at least some systems, :const:`!LOCK_EX` can only be used if"
" the file descriptor refers to a file opened for writing."
msgstr ""
":const:`!LOCK_NB`\\가 사용되고 잠금을 얻을 수 없을 때, :exc:`OSError`\\가 발생하고 *errno* "
"어트리뷰트가 :const:`~errno.EACCES`\\나 :const:`~errno.EAGAIN`\\으로 설정됩니다 (운영 체제에"
" 따라 다릅니다; 이식성을 위해서 두 값을 모두 확인하십시오). 적어도 일부 시스템에서, :const:`!LOCK_EX`\\는 파일"
" 기술자가 쓰기 위해 열린 파일을 참조할 때만 사용할 수 있습니다."

#: ../../library/fcntl.rst:203
msgid ""
"*len* is the number of bytes to lock, *start* is the byte offset at which"
" the lock starts, relative to *whence*, and *whence* is as with "
":func:`io.IOBase.seek`, specifically:"
msgstr ""
"*len*\\은 잠글 바이트 수, *start*\\는 *whence*\\가 정의하는 기준으로 잠금이 시작되는 바이트 오프셋이며 "
"*whence*\\는 :func:`io.IOBase.seek`\\에서와 같은데, 구체적으로 다음과 같습니다:"

#: ../../library/fcntl.rst:207
msgid "``0`` -- relative to the start of the file (:const:`os.SEEK_SET`)"
msgstr "``0`` -- 파일의 시작에 상대적 (:const:`os.SEEK_SET`)"

#: ../../library/fcntl.rst:208
msgid "``1`` -- relative to the current buffer position (:const:`os.SEEK_CUR`)"
msgstr "``1`` -- 현재 버퍼 위치에 상대적 (:const:`os.SEEK_CUR`)"

#: ../../library/fcntl.rst:209
msgid "``2`` -- relative to the end of the file (:const:`os.SEEK_END`)"
msgstr "``2`` -- 파일의 끝에 상대적 (:const:`os.SEEK_END`)"

#: ../../library/fcntl.rst:211
msgid ""
"The default for *start* is 0, which means to start at the beginning of "
"the file. The default for *len* is 0 which means to lock to the end of "
"the file.  The default for *whence* is also 0."
msgstr ""
"*start*\\의 기본값은 파일 시작 부분에서 시작한다는 의미인 0입니다. *len*\\의 기본값은 파일 끝까지 잠그는 것을 "
"의미하는 0입니다. *whence*\\의 기본값도 0입니다."

#: ../../library/fcntl.rst:215
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.lockf`` with arguments"
" ``fd``, ``cmd``, ``len``, ``start``, ``whence``."
msgstr ""
"인자 ``fd``, ``cmd``, ``len``, ``start``, ``whence``\\로 :ref:`감사 이벤트 "
"<auditing>` ``fcntl.lockf``\\를 발생시킵니다."

#: ../../library/fcntl.rst:217
msgid "Examples (all on a SVR4 compliant system)::"
msgstr "예제 (모두 SVR4 호환 시스템에서)::"

#: ../../library/fcntl.rst:219
msgid ""
"import struct, fcntl, os\n"
"\n"
"f = open(...)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)\n"
"\n"
"lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)"
msgstr ""
"import struct, fcntl, os\n"
"\n"
"f = open(...)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)\n"
"\n"
"lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)"

#: ../../library/fcntl.rst:227
msgid ""
"Note that in the first example the return value variable *rv* will hold "
"an integer value; in the second example it will hold a :class:`bytes` "
"object.  The structure lay-out for the *lockdata* variable is system "
"dependent --- therefore using the :func:`flock` call may be better."
msgstr ""
"첫 번째 예제에서 반환 값 변수 *rv*\\는 정숫값을 저장합니다; 두 번째 예제에서는 :class:`bytes` 객체를 "
"저장합니다. *lockdata* 변수에 대한 구조체 배치는 시스템 종속적입니다 --- 그래서 :func:`flock` 호출을 "
"사용하는 것이 더 좋을 수 있습니다."

#: ../../library/fcntl.rst:235
msgid "Module :mod:`os`"
msgstr "모듈 :mod:`os`"

#: ../../library/fcntl.rst:236
msgid ""
"If the locking flags :const:`~os.O_SHLOCK` and :const:`~os.O_EXLOCK` are "
"present in the :mod:`os` module (on BSD only), the :func:`os.open` "
"function provides an alternative to the :func:`lockf` and :func:`flock` "
"functions."
msgstr ""
"잠금 플래그 :const:`~os.O_SHLOCK`\\과 :const:`~os.O_EXLOCK`\\이 :mod:`os` 모듈에 "
"있으면 (BSD에만 해당합니다), :func:`os.open` 함수는 :func:`lockf`\\와 :func:`flock` 함수의"
" 대안을 제공합니다."

#: ../../library/fcntl.rst:10
msgid "UNIX"
msgstr "UNIX"

#: ../../library/fcntl.rst:10
msgid "file control"
msgstr "파일 제어"

#: ../../library/fcntl.rst:10
msgid "I/O control"
msgstr "I/O 제어"

