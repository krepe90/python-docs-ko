# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/xml.etree.elementtree.rst:2
#, fuzzy
msgid ":mod:`!xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ":mod:`xml.etree.ElementTree` --- ElementTree XML API"

#: ../../library/xml.etree.elementtree.rst:9
msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**소스 코드:** :source:`Lib/xml/etree/ElementTree.py`"

#: ../../library/xml.etree.elementtree.rst:13
msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient"
" API for parsing and creating XML data."
msgstr ""
":mod:`xml.etree.ElementTree` 모듈은 XML 데이터를 구문 분석하고 만들기 위한 단순하고 효율적인 API를 "
"구현합니다."

#: ../../library/xml.etree.elementtree.rst:16
msgid "This module will use a fast implementation whenever available."
msgstr "이 모듈은 가능할 때마다 빠른 구현을 사용합니다."

#: ../../library/xml.etree.elementtree.rst:19
#, fuzzy
msgid "The :mod:`!xml.etree.cElementTree` module is deprecated."
msgstr ":mod:`xml.etree.cElementTree` 모듈은 폐지되었습니다."

#: ../../library/xml.etree.elementtree.rst:25
msgid ""
"The :mod:`xml.etree.ElementTree` module is not secure against maliciously"
" constructed data.  If you need to parse untrusted or unauthenticated "
"data see :ref:`xml-vulnerabilities`."
msgstr ""
":mod:`xml.etree.ElementTree` 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 "
"인증되지 않은 데이터를 구문 분석해야 하면 :ref:`xml-vulnerabilities`\\을 참조하십시오."

#: ../../library/xml.etree.elementtree.rst:30
msgid "Tutorial"
msgstr "자습서"

#: ../../library/xml.etree.elementtree.rst:32
msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` "
"in short).  The goal is to demonstrate some of the building blocks and "
"basic concepts of the module."
msgstr ""
"이것은 :mod:`xml.etree.ElementTree`\\(줄여서 ``ET``)를 사용하기 위한 간단한 자습서입니다. 목표는 "
"모듈의 일부 빌딩 블록과 기본 개념을 예시하는 것입니다."

#: ../../library/xml.etree.elementtree.rst:37
msgid "XML tree and elements"
msgstr "XML 트리와 엘리먼트"

#: ../../library/xml.etree.elementtree.rst:39
msgid ""
"XML is an inherently hierarchical data format, and the most natural way "
"to represent it is with a tree.  ``ET`` has two classes for this purpose "
"- :class:`ElementTree` represents the whole XML document as a tree, and "
":class:`Element` represents a single node in this tree.  Interactions "
"with the whole document (reading and writing to/from files) are usually "
"done on the :class:`ElementTree` level.  Interactions with a single XML "
"element and its sub-elements are done on the :class:`Element` level."
msgstr ""
"XML은 본질적으로 위계적(hierarchical) 데이터 형식이며, 이를 나타내는 가장 자연스러운 방법은 트리를 사용하는 "
"것입니다. ``ET``\\에는 이 목적을 위한 두 가지 클래스가 있습니다 - :class:`ElementTree`\\는 전체 XML"
" 문서를 트리로 나타내고, :class:`Element`\\는 이 트리에 있는 단일 노드를 나타냅니다. 전체 문서와의 상호 "
"작용(파일 읽기와 쓰기)은 일반적으로 :class:`ElementTree` 수준에서 수행됩니다. 단일 XML 엘리먼트와 해당 서브 "
"엘리먼트와의 상호 작용은 :class:`Element` 수준에서 수행됩니다."

#: ../../library/xml.etree.elementtree.rst:50
msgid "Parsing XML"
msgstr "XML 구문 분석하기"

#: ../../library/xml.etree.elementtree.rst:52
#, fuzzy
msgid ""
"We'll be using the fictive :file:`country_data.xml` XML document as the "
"sample data for this section:"
msgstr "이 섹션의 샘플 데이터로 다음 XML 문서를 사용합니다:"

#: ../../library/xml.etree.elementtree.rst:54
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:80
msgid "We can import this data by reading from a file::"
msgstr "파일을 읽어서 이 데이터를 가져올 수 있습니다::"

#: ../../library/xml.etree.elementtree.rst:82
msgid ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:86
msgid "Or directly from a string::"
msgstr "또는 문자열에서 직접::"

#: ../../library/xml.etree.elementtree.rst:88
msgid "root = ET.fromstring(country_data_as_string)"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:90
msgid ""
":func:`fromstring` parses XML from a string directly into an "
":class:`Element`, which is the root element of the parsed tree.  Other "
"parsing functions may create an :class:`ElementTree`.  Check the "
"documentation to be sure."
msgstr ""
":func:`fromstring`\\은 문자열에서 :class:`Element`\\로 XML을 직접 구문 분석하는데, 구문 분석된 "
"트리의 루트 엘리먼트입니다. 다른 구문 분석 함수는 :class:`ElementTree`\\를 만들 수 있습니다. 설명서를 "
"확인하십시오."

#: ../../library/xml.etree.elementtree.rst:94
msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of "
"attributes::"
msgstr ":class:`Element`\\로서, ``root``\\에는 태그(tag)와 어트리뷰트 딕셔너리가 있습니다::"

#: ../../library/xml.etree.elementtree.rst:96
#, python-brace-format
msgid ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:101
msgid "It also has children nodes over which we can iterate::"
msgstr "또한 우리가 이터레이트 할 수 있는 자식 노드가 있습니다::"

#: ../../library/xml.etree.elementtree.rst:103
#, python-brace-format
msgid ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:110
msgid "Children are nested, and we can access specific child nodes by index::"
msgstr "자식은 중첩되며, 인덱스로 특정 자식 노드에 액세스 할 수 있습니다::"

#: ../../library/xml.etree.elementtree.rst:112
msgid ""
">>> root[0][1].text\n"
"'2008'"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:118
msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can"
" have comments and processing instructions in them; they will be included"
" when generating XML output. A document type declaration may be accessed "
"by passing a custom :class:`TreeBuilder` instance to the "
":class:`XMLParser` constructor."
msgstr ""
"XML 입력의 모든 엘리먼트가 구문 분석된 트리의 엘리먼트가 되는 것은 아닙니다. 현재, 이 모듈은 입력에서 XML 주석, 처리 "
"명령(processing instructions) 및 문서 형 선언(document type declarations)을 건너뜁니다."
" 그런데도, XML 텍스트를 구문 분석하는 대신 이 모듈의 API를 사용하여 만들어진 트리에는 주석과 처리 명령이 있을 수 "
"있습니다; 이들은 XML 출력을 생성할 때 포함됩니다. 사용자 정의 :class:`TreeBuilder` 인스턴스를 "
":class:`XMLParser` 생성자에 전달하여 문서 형 선언에 액세스 할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:132
msgid "Pull API for non-blocking parsing"
msgstr "비 블로킹 구문 분석을 위한 풀(pull) API"

#: ../../library/xml.etree.elementtree.rst:134
msgid ""
"Most parsing functions provided by this module require the whole document"
" to be read at once before returning any result.  It is possible to use "
"an :class:`XMLParser` and feed data into it incrementally, but it is a "
"push API that calls methods on a callback target, which is too low-level "
"and inconvenient for most needs.  Sometimes what the user really wants is"
" to be able to parse XML incrementally, without blocking operations, "
"while enjoying the convenience of fully constructed :class:`Element` "
"objects."
msgstr ""
"이 모듈이 제공하는 대부분의 구문 분석 함수는 결과를 반환하기 전에 전체 문서를 한 번에 읽도록 요구합니다. "
":class:`XMLParser`\\를 사용하고 점진적으로 데이터를 공급하는 것이 가능하지만, 콜백 대상에 메서드를 호출하는 "
"푸시(push) API로, 대부분의 경우 너무 저 수준이고 불편합니다. 때로 사용자가 실제로 원하는 것은 완전히 구성된 "
":class:`Element` 객체의 편리함을 즐기면서 연산을 블로킹하지 않고 XML을 점진적으로 구문 분석할 수 있는 것입니다."

#: ../../library/xml.etree.elementtree.rst:142
msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does"
" not require a blocking read to obtain the XML data, and is instead fed "
"with data incrementally with :meth:`XMLPullParser.feed` calls.  To get "
"the parsed XML elements, call :meth:`XMLPullParser.read_events`.  Here is"
" an example::"
msgstr ""
"이를 위한 가장 강력한 도구는 :class:`XMLPullParser` 입니다. XML 데이터를 얻기 위해 블로킹 읽기가 필요하지 "
"않으며, 대신 :meth:`XMLPullParser.feed` 호출을 통해 점진적으로 데이터가 제공됩니다. 구문 분석된 XML "
"엘리먼트를 얻으려면, :meth:`XMLPullParser.read_events`\\를 호출하십시오. 예를 들면 다음과 같습니다::"

#: ../../library/xml.etree.elementtree.rst:147
msgid ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:159
msgid ""
"The obvious use case is applications that operate in a non-blocking "
"fashion where the XML data is being received from a socket or read "
"incrementally from some storage device.  In such cases, blocking reads "
"are unacceptable."
msgstr ""
"명백한 사용 사례는 XML 데이터가 소켓에서 수신되거나 일부 저장 장치에서 점진적으로 읽히는 비 블로킹 방식으로 작동하는 응용 "
"프로그램입니다. 이럴 때, 블로킹 읽기는 허용되지 않습니다."

#: ../../library/xml.etree.elementtree.rst:163
msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to "
"use for simpler use-cases.  If you don't mind your application blocking "
"on reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
":class:`XMLPullParser`\\는 매우 유연하기 때문에 더 단순한 사용 사례에 사용하기 불편할 수 있습니다. 응용 "
"프로그램이 XML 데이터 읽기를 블로킹해도 상관없지만, 여전히 점진적인 구문 분석 기능이 필요하면, "
":func:`iterparse`\\를 살펴보십시오. 큰 XML 문서를 읽을 때 메모리에 전체를 저장하지 않으려는 경우 유용할 수 "
"있습니다."

#: ../../library/xml.etree.elementtree.rst:169
msgid ""
"Where *immediate* feedback through events is wanted, calling method "
":meth:`XMLPullParser.flush` can help reduce delay; please make sure to "
"study the related security notes."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:175
msgid "Finding interesting elements"
msgstr "흥미로운 엘리먼트 찾기"

#: ../../library/xml.etree.elementtree.rst:177
msgid ""
":class:`Element` has some useful methods that help iterate recursively "
"over all the sub-tree below it (its children, their children, and so on)."
"  For example, :meth:`Element.iter`::"
msgstr ""
":class:`Element`\\에는 그 아래의 모든 서브 트리(자식, 자식의 자식 등)를 재귀적으로 이터레이트 하는 데 도움을 "
"주는 유용한 메서드가 있습니다. 예를 들어, :meth:`Element.iter`::"

#: ../../library/xml.etree.elementtree.rst:181
#, python-brace-format
msgid ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:190
msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the "
"element's text content.  :meth:`Element.get` accesses the element's "
"attributes::"
msgstr ""
":meth:`Element.findall`\\은 현재 엘리먼트의 직접적인 자식인 태그가 있는 엘리먼트만 찾습니다. "
":meth:`Element.find`\\는 특정 태그가 있는 *첫 번째* 자식을 찾고, :attr:`Element.text`\\는 "
"엘리먼트의 텍스트 내용에 액세스합니다. :meth:`Element.get`\\은 엘리먼트의 어트리뷰트에 액세스합니다::"

#: ../../library/xml.etree.elementtree.rst:195
msgid ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:204
msgid ""
"More sophisticated specification of which elements to look for is "
"possible by using :ref:`XPath <elementtree-xpath>`."
msgstr ":ref:`XPath <elementtree-xpath>`\\를 사용하면 찾을 엘리먼트를 더 정교하게 지정할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:208
msgid "Modifying an XML File"
msgstr "XML 파일 수정하기"

#: ../../library/xml.etree.elementtree.rst:210
msgid ""
":class:`ElementTree` provides a simple way to build XML documents and "
"write them to files. The :meth:`ElementTree.write` method serves this "
"purpose."
msgstr ""
":class:`ElementTree`\\는 XML 문서를 구축하고 파일에 쓰는 간단한 방법을 제공합니다. "
":meth:`ElementTree.write` 메서드가 이 용도입니다."

#: ../../library/xml.etree.elementtree.rst:213
msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children "
"(for example with :meth:`Element.append`)."
msgstr ""
"일단 만들어지면, :class:`Element` 객체는 필드(가령 :attr:`Element.text`)를 직접 변경하고, "
"어트리뷰트를 추가하고 수정(:meth:`Element.set` 메서드)하는 것뿐만 아니라 새로운 자식을 추가하여 (예를 들어 "
":meth:`Element.append`) 조작 할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:218
msgid ""
"Let's say we want to add one to each country's rank, and add an "
"``updated`` attribute to the rank element::"
msgstr ""
"각각의 국가(country)의 순위(rank)에 1을 더하고, rank 엘리먼트에 ``updated`` 어트리뷰트를 추가하고 싶다고"
" 합시다::"

#: ../../library/xml.etree.elementtree.rst:221
msgid ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:228
#: ../../library/xml.etree.elementtree.rst:272
msgid "Our XML now looks like this:"
msgstr "우리의 XML은 이제 다음과 같습니다:"

#: ../../library/xml.etree.elementtree.rst:230
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:256
msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want "
"to remove all countries with a rank higher than 50::"
msgstr ""
":meth:`Element.remove`\\를 사용하여 엘리먼트를 제거할 수 있습니다. rank가 50보다 큰 모든 국가를 "
"제거하려고 한다고 합시다::"

#: ../../library/xml.etree.elementtree.rst:259
msgid ""
">>> for country in root.findall('country'):\n"
"...     # using root.findall() to avoid removal during traversal\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:267
msgid ""
"Note that concurrent modification while iterating can lead to problems, "
"just like when iterating and modifying Python lists or dicts. Therefore, "
"the example first collects all matching elements with ``root.findall()``,"
" and only then iterates over the list of matches."
msgstr ""
"이터레이션 하는 동안 동시 수정은 파이썬 리스트나 딕셔너리를 이터레이션 할 때와 마찬가지로 문제를 유발할 수 있음에 유의하십시오. "
"따라서, 이 예제에서는 먼저 ``root.findall()``\\로 일치하는 모든 엘리먼트를 수집한 다음, 일치 항목 리스트를 "
"이터레이트 합니다."

#: ../../library/xml.etree.elementtree.rst:274
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:294
msgid "Building XML documents"
msgstr "XML 문서 구축하기"

#: ../../library/xml.etree.elementtree.rst:296
msgid ""
"The :func:`SubElement` function also provides a convenient way to create "
"new sub-elements for a given element::"
msgstr ":func:`SubElement` 함수는 주어진 엘리먼트에 대해 새로운 서브 엘리먼트를 만드는 편리한 방법을 제공합니다::"

#: ../../library/xml.etree.elementtree.rst:299
msgid ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:307
msgid "Parsing XML with Namespaces"
msgstr "이름 공간이 있는 XML 구문 분석하기"

#: ../../library/xml.etree.elementtree.rst:309
#, python-brace-format
msgid ""
"If the XML input has `namespaces "
"<https://en.wikipedia.org/wiki/XML_namespace>`__, tags and attributes "
"with prefixes in the form ``prefix:sometag`` get expanded to "
"``{uri}sometag`` where the *prefix* is replaced by the full *URI*. Also, "
"if there is a `default namespace <https://www.w3.org/TR/xml-"
"names/#defaulting>`__, that full URI gets prepended to all of the non-"
"prefixed tags."
msgstr ""
"XML 입력에 `이름 공간(namespaces) "
"<https://en.wikipedia.org/wiki/XML_namespace>`__\\이 있으면, "
"``prefix:sometag`` 형식의 접두사가 있는 태그와 어트리뷰트는 ``{uri}sometag``\\로 확장되는데, 여기서 "
"*prefix*\\는 전체 *URI*\\로 대체됩니다. 또한 `기본 이름 공간(default namespace) "
"<https://www.w3.org/TR/xml-names/#defaulting>`__\\이 있으면, 그 전체 URI가 접두사가 "
"없는 모든 태그 앞에 추가됩니다."

#: ../../library/xml.etree.elementtree.rst:317
msgid ""
"Here is an XML example that incorporates two namespaces, one with the "
"prefix \"fictional\" and the other serving as the default namespace:"
msgstr ""
"다음은 두 개의 이름 공간을 통합한 XML 예제입니다, 하나는 접두사가 \"fictional\"이고 다른 하나는 기본 이름 공간으로"
" 사용됩니다:"

#: ../../library/xml.etree.elementtree.rst:320
msgid ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:338
msgid ""
"One way to search and explore this XML example is to manually add the URI"
" to every tag or attribute in the xpath of a :meth:`~Element.find` or "
":meth:`~Element.findall`::"
msgstr ""
"이 XML 예제를 검색하고 탐색하는 한 가지 방법은 :meth:`~Element.find`\\나 "
":meth:`~Element.findall`\\의 xpath에 있는 모든 태그나 어트리뷰트에 URI를 수동으로 추가하는 것입니다::"

#: ../../library/xml.etree.elementtree.rst:342
#, python-brace-format
msgid ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in "
"actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:349
msgid ""
"A better way to search the namespaced XML example is to create a "
"dictionary with your own prefixes and use those in the search functions::"
msgstr ""
"이름 공간이 있는 XML 예제를 검색하는 더 좋은 방법은 여러분 자신의 접두사가 담긴 딕셔너리를 만들고 검색 함수에서 사용하는 "
"것입니다::"

#: ../../library/xml.etree.elementtree.rst:352
#, python-brace-format
msgid ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:361
msgid "These two approaches both output::"
msgstr "이 두 가지 방법 모두 다음과 같이 출력합니다::"

#: ../../library/xml.etree.elementtree.rst:363
msgid ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:375
msgid "XPath support"
msgstr "XPath 지원"

#: ../../library/xml.etree.elementtree.rst:377
msgid ""
"This module provides limited support for `XPath expressions "
"<https://www.w3.org/TR/xpath>`_ for locating elements in a tree.  The "
"goal is to support a small subset of the abbreviated syntax; a full XPath"
" engine is outside the scope of the module."
msgstr ""
"이 모듈은 트리에서 엘리먼트를 찾기 위해 `XPath 표현식 <https://www.w3.org/TR/xpath>`_\\을 "
"제한적으로 지원합니다. 목표는 축약된 문법의 작은 부분 집합을 지원하는 것입니다; 완전한 XPath 엔진은 이 모듈의 범위를 "
"벗어납니다."

#: ../../library/xml.etree.elementtree.rst:383
#: ../../library/xml.etree.elementtree.rst:782
msgid "Example"
msgstr "예"

#: ../../library/xml.etree.elementtree.rst:385
msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the"
" module.  We'll be using the ``countrydata`` XML document from the "
":ref:`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"다음은 모듈의 일부 XPath 기능을 보여주는 예입니다. :ref:`XML 구문 분석하기 <elementtree-parsing-"
"xml>` 섹션의 ``countrydata`` XML 문서를 사용할 것입니다::"

#: ../../library/xml.etree.elementtree.rst:389
msgid ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:409
#, python-brace-format
msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr "이름 공간이 있는 XML의 경우, 일반적인 정규화된 ``{namespace}tag`` 표기법을 사용하십시오::"

#: ../../library/xml.etree.elementtree.rst:411
#, python-brace-format
msgid ""
"# All dublin-core \"title\" tags in the document\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:416
msgid "Supported XPath syntax"
msgstr "지원되는 XPath 문법"

#: ../../library/xml.etree.elementtree.rst:421
msgid "Syntax"
msgstr "문법"

#: ../../library/xml.etree.elementtree.rst:421
msgid "Meaning"
msgstr "의미"

#: ../../library/xml.etree.elementtree.rst:423
msgid "``tag``"
msgstr "``tag``"

#: ../../library/xml.etree.elementtree.rst:423
#, python-brace-format
msgid ""
"Selects all child elements with the given tag. For example, ``spam`` "
"selects all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  "
"``{namespace}*`` selects all tags in the given namespace, ``{*}spam`` "
"selects tags named ``spam`` in any (or no) namespace, and ``{}*`` only "
"selects tags that are not in a namespace."
msgstr ""
"주어진 태그를 가진 모든 자식 엘리먼트를 선택합니다. 예를 들어, ``spam``\\은 ``spam``\\이라는 모든 자식 "
"엘리먼트를 선택하고, ``spam/egg``\\는 ``spam``\\이라는 모든 자식의 ``egg``\\라는 모든 손자를 "
"선택합니다. ``{namespace}*``\\는 지정된 이름 공간의 모든 태그를 선택하고, ``{*}spam``\\은 모든 이름 "
"공간의 (또는 이름 공간이 없는) ``spam``\\이라는 태그를 선택하고, ``{}*``\\은 이름 공간이 없는 태그만 "
"선택합니다."

#: ../../library/xml.etree.elementtree.rst:432
msgid "Support for star-wildcards was added."
msgstr "애스터리스크 와일드카드 지원이 추가되었습니다."

#: ../../library/xml.etree.elementtree.rst:435
msgid "``*``"
msgstr "``*``"

#: ../../library/xml.etree.elementtree.rst:435
msgid ""
"Selects all child elements, including comments and processing "
"instructions.  For example, ``*/egg`` selects all grandchildren named "
"``egg``."
msgstr ""
"주석과 처리 명령을 포함한 모든 자식 엘리먼트를 선택합니다. 예를 들어, ``*/egg``\\는 ``egg``\\라는 모든 손자를 "
"선택합니다."

#: ../../library/xml.etree.elementtree.rst:439
msgid "``.``"
msgstr "``.``"

#: ../../library/xml.etree.elementtree.rst:439
msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr "현재 노드를 선택합니다. 상대 경로임을 나타내기 위해 경로의 시작 부분에서 주로 유용합니다."

#: ../../library/xml.etree.elementtree.rst:443
msgid "``//``"
msgstr "``//``"

#: ../../library/xml.etree.elementtree.rst:443
msgid ""
"Selects all subelements, on all levels beneath the current  element.  For"
" example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""
"현재 엘리먼트 아래의 모든 수준에서 모든 서브 엘리먼트를 선택합니다. 예를 들어, ``.//egg``\\는 전체 트리에서 모든 "
"``egg`` 엘리먼트를 선택합니다."

#: ../../library/xml.etree.elementtree.rst:447
msgid "``..``"
msgstr "``..``"

#: ../../library/xml.etree.elementtree.rst:447
msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to "
"reach the ancestors of the start element (the element ``find`` was called"
" on)."
msgstr ""
"부모 엘리먼트를 선택합니다. 경로가 (엘리먼트 ``find``\\가 호출된) 시작 엘리먼트의 조상에 도달하려고 하면 "
"``None``\\을 반환합니다."

#: ../../library/xml.etree.elementtree.rst:451
msgid "``[@attrib]``"
msgstr "``[@attrib]``"

#: ../../library/xml.etree.elementtree.rst:451
msgid "Selects all elements that have the given attribute."
msgstr "주어진 어트리뷰트를 가진 모든 엘리먼트를 선택합니다."

#: ../../library/xml.etree.elementtree.rst:453
msgid "``[@attrib='value']``"
msgstr "``[@attrib='value']``"

#: ../../library/xml.etree.elementtree.rst:453
msgid ""
"Selects all elements for which the given attribute has the given value.  "
"The value cannot contain quotes."
msgstr "주어진 어트리뷰트가 주어진 값을 갖는 모든 엘리먼트를 선택합니다. 값은 따옴표를 포함할 수 없습니다."

#: ../../library/xml.etree.elementtree.rst:457
#, fuzzy
msgid "``[@attrib!='value']``"
msgstr "``[@attrib='value']``"

#: ../../library/xml.etree.elementtree.rst:457
#, fuzzy
msgid ""
"Selects all elements for which the given attribute does not have the "
"given value. The value cannot contain quotes."
msgstr "주어진 어트리뷰트가 주어진 값을 갖는 모든 엘리먼트를 선택합니다. 값은 따옴표를 포함할 수 없습니다."

#: ../../library/xml.etree.elementtree.rst:463
msgid "``[tag]``"
msgstr "``[tag]``"

#: ../../library/xml.etree.elementtree.rst:463
msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr "``tag``\\라는 자식이 있는 모든 엘리먼트를 선택합니다. 직계 자식만 지원됩니다."

#: ../../library/xml.etree.elementtree.rst:466
msgid "``[.='text']``"
msgstr "``[.='text']``"

#: ../../library/xml.etree.elementtree.rst:466
msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr "자손을 포함한 전체 텍스트 내용이 주어진 ``text``\\와 같은 모든 엘리먼트를 선택합니다."

#: ../../library/xml.etree.elementtree.rst:471
#, fuzzy
msgid "``[.!='text']``"
msgstr "``[.='text']``"

#: ../../library/xml.etree.elementtree.rst:471
#, fuzzy
msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr "자손을 포함한 전체 텍스트 내용이 주어진 ``text``\\와 같은 모든 엘리먼트를 선택합니다."

#: ../../library/xml.etree.elementtree.rst:477
msgid "``[tag='text']``"
msgstr "``[tag='text']``"

#: ../../library/xml.etree.elementtree.rst:477
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr ""
"자손을 포함한 전체 텍스트 내용이 지정된 ``text``\\와 같은 이름이 ``tag``\\인 자식이 있는 모든 엘리먼트를 "
"선택합니다."

#: ../../library/xml.etree.elementtree.rst:481
#, fuzzy
msgid "``[tag!='text']``"
msgstr "``[tag='text']``"

#: ../../library/xml.etree.elementtree.rst:481
#, fuzzy
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr ""
"자손을 포함한 전체 텍스트 내용이 지정된 ``text``\\와 같은 이름이 ``tag``\\인 자식이 있는 모든 엘리먼트를 "
"선택합니다."

#: ../../library/xml.etree.elementtree.rst:487
msgid "``[position]``"
msgstr "``[position]``"

#: ../../library/xml.etree.elementtree.rst:487
msgid ""
"Selects all elements that are located at the given position.  The "
"position can be either an integer (1 is the first position), the "
"expression ``last()`` (for the last position), or a position relative to "
"the last position (e.g. ``last()-1``)."
msgstr ""
"주어진 위치(position)에 있는 모든 엘리먼트를 선택합니다. 위치(position)는 정수(1이 첫 번째 위치입니다), 표현식"
" ``last()`` (마지막 위치) 또는 마지막 위치에 상대적인 위치(예를 들어 ``last()-1``)일 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:494
msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag"
" name, an asterisk, or another predicate.  ``position`` predicates must "
"be preceded by a tag name."
msgstr ""
"술어 (대괄호 안에 있는 표현식) 앞에는 태그 이름, 애스터리스크 또는 다른 술어가 와야 합니다. ``position`` 술어 "
"앞에는 태그 이름이 와야 합니다."

#: ../../library/xml.etree.elementtree.rst:499
#: ../../library/xml.etree.elementtree.rst:834
msgid "Reference"
msgstr "레퍼런스"

#: ../../library/xml.etree.elementtree.rst:504
#: ../../library/xml.etree.elementtree.rst:839
msgid "Functions"
msgstr "함수"

#: ../../library/xml.etree.elementtree.rst:508
msgid "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ 변환 함수."

#: ../../library/xml.etree.elementtree.rst:510
#, fuzzy
msgid ""
"Canonicalization is a way to normalise XML output in a way that allows "
"byte-by-byte comparisons and digital signatures.  It reduces the freedom "
"that XML serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""
"규범화(canonicalization)는 바이트 단위 비교와 디지털 서명을 허용하는 방식으로 XML 출력을 정규화하는 방법입니다. "
"XML 직렬화기가 갖는 자유도를 줄이고 대신 더 제한된 XML 표현을 생성합니다. 주요 제한 사항은 이름 공간 선언의 배치, "
"어트리뷰트의 순서 및 무시할 수 있는 공백입니다."

#: ../../library/xml.etree.elementtree.rst:516
msgid ""
"This function takes an XML data string (*xml_data*) or a file path or "
"file-like object (*from_file*) as input, converts it to the canonical "
"form, and writes it out using the *out* file(-like) object, if provided, "
"or returns it as a text string if not.  The output file receives text, "
"not bytes.  It should therefore be opened in text mode with ``utf-8`` "
"encoding."
msgstr ""
"이 함수는 XML 데이터 문자열(*xml_data*)이나 파일 경로 또는 파일류 객체(*from_file*)를 입력으로 받아서, "
"규범적 형식으로 변환한 후, 제공된다면 *out* 파일(류) 객체를 사용하여 기록하고, 그렇지 않으면 텍스트 문자열로 반환합니다. "
"출력 파일은 바이트열이 아닌 텍스트를 받습니다. 따라서 ``utf-8`` 인코딩을 사용하여 텍스트 모드로 열어야 합니다."

#: ../../library/xml.etree.elementtree.rst:523
msgid "Typical uses::"
msgstr "일반적인 사용::"

#: ../../library/xml.etree.elementtree.rst:525
msgid ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:534
msgid "The configuration *options* are as follows:"
msgstr "구성 *options*\\는 다음과 같습니다:"

#: ../../library/xml.etree.elementtree.rst:536
msgid "*with_comments*: set to true to include comments (default: false)"
msgstr "*with_comments*: 주석을 포함하려면 참으로 설정합니다 (기본값: 거짓)."

#: ../../library/xml.etree.elementtree.rst:537
msgid ""
"*strip_text*: set to true to strip whitespace before and after text "
"content"
msgstr "*strip_text*: 텍스트 내용 전후의 공백을 제거하려면 참으로 설정합니다"

#: ../../library/xml.etree.elementtree.rst:538
#: ../../library/xml.etree.elementtree.rst:540
msgid "(default: false)"
msgstr "(기본값: 거짓)"

#: ../../library/xml.etree.elementtree.rst:539
#, python-brace-format
msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr "*rewrite_prefixes*: 이름 공간 접두사를 \"n{number}\" 로 바꾸려면 참으로 설정합니다"

#: ../../library/xml.etree.elementtree.rst:541
msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr "*qname_aware_tags*: 텍스트 내용에서 접두사를 대체해야 하는 qname 인식 태그 이름 집합"

#: ../../library/xml.etree.elementtree.rst:542
#: ../../library/xml.etree.elementtree.rst:544
msgid "should be replaced in text content (default: empty)"
msgstr "(기본값: 비어 있음)"

#: ../../library/xml.etree.elementtree.rst:543
msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which "
"prefixes"
msgstr "*qname_aware_attrs*: 텍스트 내용에서 접두사를 대체해야 하는 qname 인식 어트리뷰트 이름 집합"

#: ../../library/xml.etree.elementtree.rst:545
msgid "*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr "*exclude_attrs*: 직렬화하면 안 되는 어트리뷰트 이름 집합"

#: ../../library/xml.etree.elementtree.rst:546
msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr "*exclude_tags*: 직렬화하면 안 되는 태그 이름 집합"

#: ../../library/xml.etree.elementtree.rst:548
msgid ""
"In the option list above, \"a set\" refers to any collection or iterable "
"of strings, no ordering is expected."
msgstr "위의 옵션 목록에서, \"집합\"은 문자열의 모든 컬렉션이나 이터러블을 가리키며, 순서는 고려하지 않습니다."

#: ../../library/xml.etree.elementtree.rst:556
msgid ""
"Comment element factory.  This factory function creates a special element"
" that will be serialized as an XML comment by the standard serializer.  "
"The comment string can be either a bytestring or a Unicode string.  "
"*text* is a string containing the comment string.  Returns an element "
"instance representing a comment."
msgstr ""
"주석 엘리먼트 팩토리. 이 팩토리 함수는 표준 직렬화기가 XML 주석으로 직렬화할 특수 엘리먼트를 만듭니다. 주석 문자열은 바이트 "
"문자열이나 유니코드 문자열일 수 있습니다. *text*\\는 주석 문자열이 포함된 문자열입니다. 주석을 나타내는 엘리먼트 인스턴스를"
" 반환합니다."

#: ../../library/xml.etree.elementtree.rst:562
msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only "
"contain comment nodes if they have been inserted into to the tree using "
"one of the :class:`Element` methods."
msgstr ""
":class:`XMLParser`\\는 주석 객체를 만드는 대신 입력에서 주석을 건너뜀에 유의하십시오. "
":class:`ElementTree`\\는 :class:`Element` 메서드 중 하나를 사용하여 트리에 삽입된 주석 노드만 "
"포함합니다."

#: ../../library/xml.etree.elementtree.rst:569
msgid ""
"Writes an element tree or element structure to sys.stdout.  This function"
" should be used for debugging only."
msgstr "엘리먼트 트리나 엘리먼트 구조를 sys.stdout에 씁니다. 이 함수는 디버깅에만 사용해야 합니다."

#: ../../library/xml.etree.elementtree.rst:572
msgid ""
"The exact output format is implementation dependent.  In this version, "
"it's written as an ordinary XML file."
msgstr "정확한 출력 형식은 구현에 따라 다릅니다. 이 버전에서는, 일반 XML 파일로 기록됩니다."

#: ../../library/xml.etree.elementtree.rst:575
msgid "*elem* is an element tree or an individual element."
msgstr "*elem*\\은 엘리먼트 트리나 개별 엘리먼트입니다."

#: ../../library/xml.etree.elementtree.rst:577
msgid ""
"The :func:`dump` function now preserves the attribute order specified by "
"the user."
msgstr ":func:`dump` 함수는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다."

#: ../../library/xml.etree.elementtree.rst:584
msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  "
"*text* is a string containing XML data.  *parser* is an optional parser "
"instance. If not given, the standard :class:`XMLParser` parser is used. "
"Returns an :class:`Element` instance."
msgstr ""
"문자열 상수에서 XML 섹션을 구문 분석합니다. :func:`XML`\\과 같습니다. *text*\\는 XML 데이터를 포함하는 "
"문자열입니다. *parser*\\는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면, 표준 :class:`XMLParser` "
"구문 분석기가 사용됩니다. :class:`Element` 인스턴스를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:592
msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* "
"is a list or other sequence containing XML data fragments.  *parser* is "
"an optional parser instance.  If not given, the standard "
":class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"문자열 조각의 시퀀스에서 XML 문서를 구문 분석합니다. *sequence*\\는 XML 데이터 조각을 포함하는 리스트나 다른 "
"시퀀스입니다. *parser*\\는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 :class:`XMLParser` 구문"
" 분석기가 사용됩니다. :class:`Element` 인스턴스를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:602
msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can "
"be used to generate pretty-printed XML output. *tree* can be an Element "
"or ElementTree.  *space* is the whitespace string that will be inserted "
"for each indentation level, two space characters by default.  For "
"indenting partial subtrees inside of an already indented tree, pass the "
"initial indentation level as *level*."
msgstr ""
"트리를 시각적으로 들여쓰기하기 위해 서브 트리에 공백을 추가합니다. 이것은 예쁘게 인쇄된 XML 출력을 생성하는 데 사용될 수 "
"있습니다. *tree*\\는 Element나 ElementTree 일 수 있습니다. *space*\\는 각 들여쓰기 수준에 삽입되는"
" 공백 문자열이며 기본적으로 두 개의 스페이스 문자입니다. 이미 들여쓰기 된 트리 내부에서 부분 서브 트리를 들여 쓰려면, 초기 "
"들여쓰기 수준을 *level*\\로 전달하십시오."

#: ../../library/xml.etree.elementtree.rst:614
msgid ""
"Check if an object appears to be a valid element object.  *element* is an"
" element instance.  Return ``True`` if this is an element object."
msgstr ""
"객체가 유효한 엘리먼트 객체로 보이는지 확인합니다. *element*\\는 엘리먼트 인스턴스입니다. 이것이 엘리먼트 객체이면 "
"``True``\\를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:620
#, fuzzy
msgid ""
"Parses an XML section into an element tree incrementally, and reports "
"what's going on to the user.  *source* is a filename or :term:`file "
"object` containing XML data.  *events* is a sequence of events to report "
"back.  The supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the "
"\"ns\" events are used to get detailed namespace information).  If "
"*events* is omitted, only ``\"end\"`` events are reported. *parser* is an"
" optional parser instance.  If not given, the standard :class:`XMLParser`"
" parser is used.  *parser* must be a subclass of :class:`XMLParser` and "
"can only use the default :class:`TreeBuilder` as a target. Returns an "
":term:`iterator` providing ``(event, elem)`` pairs; it has a ``root`` "
"attribute that references the root element of the resulting XML tree once"
" *source* is fully read. The iterator has the :meth:`!close` method that "
"closes the internal file object if *source* is a filename."
msgstr ""
"XML 섹션을 엘리먼트 트리로 점진적으로 구문 분석하고, 사용자에게 진행 중인 작업을 보고합니다. *source*\\는 파일명이나 "
"XML 데이터를 포함하는 :term:`파일 객체 <file object>`\\입니다. *events*\\는 보고할 이벤트의 "
"시퀀스입니다. 지원되는 이벤트는 문자열 ``\"start\"``, ``\"end\"``, ``\"comment\"``, "
"``\"pi\"``, ``\"start-ns\"`` 및 ``\"end-ns\"``\\입니다 (\"ns\" 이벤트는 자세한 이름 공간"
" 정보를 얻는 데 사용됩니다). *events*\\를 생략하면, ``\"end\"`` 이벤트만 보고됩니다. *parser*\\는 "
"선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 :class:`XMLParser` 구문 분석기가 사용됩니다. "
"*parser*\\는 :class:`XMLParser`\\의 서브 클래스여야 하며 기본 :class:`TreeBuilder` 만 "
"대상으로 사용할 수 있습니다. ``(event, elem)`` 쌍을 제공하는 :term:`이터레이터 <iterator>`\\를 "
"반환합니다."

#: ../../library/xml.etree.elementtree.rst:636
msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it "
"issues blocking reads on *source* (or the file it names).  As such, it's "
"unsuitable for applications where blocking reads can't be made.  For "
"fully non-blocking parsing, see :class:`XMLPullParser`."
msgstr ""
":func:`iterparse`\\는 점진적으로 트리를 구축하지만, *source*\\(또는 그 이름의 파일)에 대한 블로킹 읽기를"
" 유발함에 유의하십시오. 따라서, 블로킹 읽기를 할 수 없는 응용 프로그램에는 적합하지 않습니다. 완전한 비 블로킹 구문 분석에 "
"대해서는 :class:`XMLPullParser`\\를 참조하십시오."

#: ../../library/xml.etree.elementtree.rst:643
msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of"
" a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined "
"at that point.  The same applies to the element children; they may or may"
" not be present."
msgstr ""
":func:`iterparse`\\는 \"start\" 이벤트를 방출할 때 시작 태그의 \">\" 문자를 보았다는 것만 보장해서, "
"어트리뷰트는 정의되지만, 텍스트의 내용과 테일(tail) 어트리뷰트는 그 시점에 정의되지 않습니다. 자식 엘리먼트에도 마찬가지로 "
"적용됩니다; 그들은 존재할 수도 그렇지 않을 수도 있습니다."

#: ../../library/xml.etree.elementtree.rst:649
#: ../../library/xml.etree.elementtree.rst:1522
msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr "완전히 채워진 엘리먼트가 필요하면, 대신 \"end\" 이벤트를 찾으십시오."

#: ../../library/xml.etree.elementtree.rst:651
msgid "The *parser* argument."
msgstr "*parser* 인자."

#: ../../library/xml.etree.elementtree.rst:654
#: ../../library/xml.etree.elementtree.rst:1526
msgid "The ``comment`` and ``pi`` events were added."
msgstr "``comment``\\와 ``pi`` 이벤트가 추가되었습니다."

#: ../../library/xml.etree.elementtree.rst:657
msgid "Added the :meth:`!close` method."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:663
msgid ""
"Parses an XML section into an element tree.  *source* is a filename or "
"file object containing XML data.  *parser* is an optional parser "
"instance.  If not given, the standard :class:`XMLParser` parser is used."
"  Returns an :class:`ElementTree` instance."
msgstr ""
"XML 섹션을 엘리먼트 트리로 구문 분석합니다. *source*\\는 XML 데이터를 포함하는 파일명이나 파일 객체입니다. "
"*parser*\\는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 :class:`XMLParser` 구문 분석기가 "
"사용됩니다. :class:`ElementTree` 인스턴스를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:671
msgid ""
"PI element factory.  This factory function creates a special element that"
" will be serialized as an XML processing instruction.  *target* is a "
"string containing the PI target.  *text* is a string containing the PI "
"contents, if given.  Returns an element instance, representing a "
"processing instruction."
msgstr ""
"PI 엘리먼트 팩토리. 이 팩토리 함수는 XML 처리 명령으로 직렬화될 특수 엘리먼트를 만듭니다. *target*\\은 PI 대상을"
" 포함하는 문자열입니다. 주어지면, *text*\\는 PI 내용을 포함하는 문자열입니다. 처리 명령을 나타내는 엘리먼트 인스턴스를 "
"반환합니다."

#: ../../library/xml.etree.elementtree.rst:676
#, fuzzy
msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the "
"input instead of creating PI objects for them. An :class:`ElementTree` "
"will only contain processing instruction nodes if they have been inserted"
" into to the tree using one of the :class:`Element` methods."
msgstr ""
":class:`XMLParser`\\는 처리 명령 객체를 작성하는 대신 입력에서 처리 명령을 건너뜀에 유의하십시오. "
":class:`ElementTree`\\는 :class:`Element` 메서드 중 하나를 사용하여 트리에 삽입된 처리 명령 노드만"
" 포함합니다."

#: ../../library/xml.etree.elementtree.rst:684
msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed."
" *prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if"
" at all possible."
msgstr ""
"이름 공간 접두사를 등록합니다. 레지스트리는 전역적이며, 지정된 접두사나 이름 공간 URI에 대한 기존 매핑이 제거됩니다. "
"*prefix*\\는 이름 공간 접두사입니다. *uri*\\는 이름 공간 URI입니다. 이 이름 공간의 태그와 어트리뷰트는 "
"가능하다면 주어진 접두사로 직렬화됩니다."

#: ../../library/xml.etree.elementtree.rst:695
msgid ""
"Subelement factory.  This function creates an element instance, and "
"appends it to an existing element."
msgstr "서브 엘리먼트 팩토리. 이 함수는 엘리먼트 인스턴스를 만들어 기존 엘리먼트에 추가합니다."

#: ../../library/xml.etree.elementtree.rst:698
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* "
"is the subelement name.  *attrib* is an optional dictionary, containing "
"element attributes.  *extra* contains additional attributes, given as "
"keyword arguments.  Returns an element instance."
msgstr ""
"엘리먼트 이름, 어트리뷰트 이름 및 어트리뷰트 값은 바이트 문자열이나 유니코드 문자열일 수 있습니다. *parent*\\는 부모 "
"엘리먼트입니다. *tag*\\는 서브 엘리먼트 이름입니다. *attrib*\\는 엘리먼트 어트리뷰트를 포함하는 선택적 "
"딕셔너리입니다. *extra*\\에는 키워드 인자로 지정된 추가 어트리뷰트가 포함됩니다. 엘리먼트 인스턴스를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:709
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_"
" is the output encoding (default is US-ASCII).  Use "
"``encoding=\"unicode\"`` to generate a Unicode string (otherwise, a "
"bytestring is generated).  *method* is either ``\"xml\"``, ``\"html\"`` "
"or ``\"text\"`` (default is ``\"xml\"``). *xml_declaration*, "
"*default_namespace* and *short_empty_elements* has the same meaning as in"
" :meth:`ElementTree.write`. Returns an (optionally) encoded string "
"containing the XML data."
msgstr ""
"모든 서브 엘리먼트를 포함하는, XML 엘리먼트의 문자열 표현을 생성합니다. *element*\\는 :class:`Element` "
"인스턴스입니다. *encoding* [1]_ 은 출력 인코딩입니다 (기본값은 US-ASCII입니다). "
"``encoding=\"unicode\"``\\를 사용하여 유니코드 문자열을 생성하십시오 (그렇지 않으면 바이트 문자열이 "
"생성됩니다). *method*\\는 ``\"xml\"``, ``\"html\"`` 또는 ``\"text\"``\\입니다 (기본값은 "
"``\"xml\"``\\입니다). *xml_declaration*, *default_namespace* 및 "
"*short_empty_elements*\\는 :meth:`ElementTree.write`\\에서와 같은 의미입니다. XML "
"데이터를 포함하는 (선택적으로) 인코딩된 문자열을 반환합니다."

#: ../../library/xml.etree.elementtree.rst:718
#: ../../library/xml.etree.elementtree.rst:745
#: ../../library/xml.etree.elementtree.rst:1199
#, fuzzy
msgid "Added the *short_empty_elements* parameter."
msgstr "*short_empty_elements* 매개 변수."

#: ../../library/xml.etree.elementtree.rst:721
#: ../../library/xml.etree.elementtree.rst:748
#, fuzzy
msgid "Added the *xml_declaration* and *default_namespace* parameters."
msgstr "*xml_declaration*\\과 *default_namespace* 매개 변수."

#: ../../library/xml.etree.elementtree.rst:724
msgid ""
"The :func:`tostring` function now preserves the attribute order specified"
" by the user."
msgstr ":func:`tostring` 함수는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다."

#: ../../library/xml.etree.elementtree.rst:733
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_"
" is the output encoding (default is US-ASCII).  Use "
"``encoding=\"unicode\"`` to generate a Unicode string (otherwise, a "
"bytestring is generated).  *method* is either ``\"xml\"``, ``\"html\"`` "
"or ``\"text\"`` (default is ``\"xml\"``). *xml_declaration*, "
"*default_namespace* and *short_empty_elements* has the same meaning as in"
" :meth:`ElementTree.write`. Returns a list of (optionally) encoded "
"strings containing the XML data. It does not guarantee any specific "
"sequence, except that ``b\"\".join(tostringlist(element)) == "
"tostring(element)``."
msgstr ""
"모든 서브 엘리먼트를 포함하는, XML 엘리먼트의 문자열 표현을 생성합니다. *element*\\는 :class:`Element` "
"인스턴스입니다. *encoding* [1]_ 은 출력 인코딩입니다 (기본값은 US-ASCII입니다). "
"``encoding=\"unicode\"``\\를 사용하여 유니코드 문자열을 생성하십시오 (그렇지 않으면 바이트 문자열이 "
"생성됩니다). *method*\\는 ``\"xml\"``, ``\"html\"`` 또는 ``\"text\"``\\입니다 (기본값은 "
"``\"xml\"``\\입니다). *xml_declaration*, *default_namespace* 및 "
"*short_empty_elements*\\는 :meth:`ElementTree.write`\\에서와 같은 의미입니다. XML "
"데이터가 포함된 (선택적으로) 인코딩된 문자열의 리스트를 반환합니다. "
"``b\"\".join(tostringlist(element)) == tostring(element)``\\라는 사실을 제외하고는,"
" 특정 시퀀스를 보장하지는 않습니다."

#: ../../library/xml.etree.elementtree.rst:751
msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ":func:`tostringlist` 함수는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다."

#: ../../library/xml.etree.elementtree.rst:758
msgid ""
"Parses an XML section from a string constant.  This function can be used "
"to embed \"XML literals\" in Python code.  *text* is a string containing "
"XML data.  *parser* is an optional parser instance.  If not given, the "
"standard :class:`XMLParser` parser is used.  Returns an :class:`Element` "
"instance."
msgstr ""
"문자열 상수에서 XML 섹션을 구문 분석합니다. 이 함수는 \"XML 리터럴\"을 파이썬 코드에 내장시키는 데 사용할 수 있습니다."
" *text*\\는 XML 데이터를 포함하는 문자열입니다. *parser*\\는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면"
" 표준 :class:`XMLParser` 구문 분석기가 사용됩니다. :class:`Element` 인스턴스를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:766
msgid ""
"Parses an XML section from a string constant, and also returns a "
"dictionary which maps from element id:s to elements.  *text* is a string "
"containing XML data.  *parser* is an optional parser instance.  If not "
"given, the standard :class:`XMLParser` parser is used.  Returns a tuple "
"containing an :class:`Element` instance and a dictionary."
msgstr ""
"문자열 상수에서 XML 섹션을 구문 분석하고, 엘리먼트 id:s 를 엘리먼트로 매핑하는 딕셔너리도 반환합니다. *text*\\는 "
"XML 데이터를 포함하는 문자열입니다. *parser*\\는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 "
":class:`XMLParser` 구문 분석기가 사용됩니다. :class:`Element` 인스턴스와 딕셔너리를 포함하는 튜플을 "
"반환합니다."

#: ../../library/xml.etree.elementtree.rst:776
msgid "XInclude support"
msgstr "XInclude 지원"

#: ../../library/xml.etree.elementtree.rst:778
msgid ""
"This module provides limited support for `XInclude directives "
"<https://www.w3.org/TR/xinclude/>`_, via the "
":mod:`xml.etree.ElementInclude` helper module.  This module can be used "
"to insert subtrees and text strings into element trees, based on "
"information in the tree."
msgstr ""
"이 모듈은 :mod:`xml.etree.ElementInclude` 도우미 모듈을 통해 `XInclude 지시어 "
"<https://www.w3.org/TR/xinclude/>`_\\를 제한적으로 지원합니다. 이 모듈은 트리의 정보를 기반으로, "
"서브 트리와 텍스트 문자열을 엘리먼트 트리에 삽입하는 데 사용할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:784
#, python-brace-format
msgid ""
"Here's an example that demonstrates use of the XInclude module. To "
"include an XML document in the current document, use the "
"``{http://www.w3.org/2001/XInclude}include`` element and set the "
"**parse** attribute to ``\"xml\"``, and use the **href** attribute to "
"specify the document to include."
msgstr ""
"다음은 XInclude 모듈의 사용법을 보여주는 예입니다. 현재 문서에 XML 문서를 포함 시키려면, "
"``{http://www.w3.org/2001/XInclude}include`` 엘리먼트를 사용하고 **parse** 어트리뷰트를 "
"``\"xml\"``\\로 설정하고, **href** 어트리뷰트를 사용하여 포함할 문서를 지정하십시오."

#: ../../library/xml.etree.elementtree.rst:786
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:793
msgid ""
"By default, the **href** attribute is treated as a file name. You can use"
" custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"기본적으로, **href** 어트리뷰트는 파일 이름으로 취급됩니다. 사용자 정의 로더를 사용하여 이 동작을 대체 할 수 있습니다. "
"또한 표준 도우미는 XPointer 문법을 지원하지 않음에 유의하십시오."

#: ../../library/xml.etree.elementtree.rst:795
msgid ""
"To process this file, load it as usual, and pass the root element to the "
":mod:`xml.etree.ElementTree` module:"
msgstr ""
"이 파일을 처리하려면, 평소와 같이 로드하고, 루트 엘리먼트를 :mod:`xml.etree.ElementTree` 모듈에 "
"전달하십시오:"

#: ../../library/xml.etree.elementtree.rst:797
msgid ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:806
#, python-brace-format
msgid ""
"The ElementInclude module replaces the "
"``{http://www.w3.org/2001/XInclude}include`` element with the root "
"element from the **source.xml** document. The result might look something"
" like this:"
msgstr ""
"ElementInclude 모듈은 ``{http://www.w3.org/2001/XInclude}include`` 엘리먼트를 "
"**source.xml** 문서의 루트 엘리먼트로 바꿉니다. 결과는 다음과 같습니다:"

#: ../../library/xml.etree.elementtree.rst:808
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>This is a paragraph.</para>\n"
"</document>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:814
msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr "**parse** 어트리뷰트가 생략되면, 기본값은 \"xml\"입니다. href 어트리뷰트는 필수입니다."

#: ../../library/xml.etree.elementtree.rst:816
#, python-brace-format
msgid ""
"To include a text document, use the "
"``{http://www.w3.org/2001/XInclude}include`` element, and set the "
"**parse** attribute to \"text\":"
msgstr ""
"텍스트 문서를 포함 시키려면, ``{http://www.w3.org/2001/XInclude}include`` 엘리먼트를 사용하고,"
" **parse** 어트리뷰트를 \"text\"로 설정하십시오:"

#: ../../library/xml.etree.elementtree.rst:818
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:825
msgid "The result might look something like:"
msgstr "결과는 다음과 같습니다:"

#: ../../library/xml.etree.elementtree.rst:827
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:845
#, fuzzy
msgid ""
"Default loader. This default loader reads an included resource from disk."
" *href* is a URL.  *parse* is for parse mode either \"xml\" or \"text\". "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``. Returns the expanded resource. If the parse mode is "
"``\"xml\"``, this is an :class:`~xml.etree.ElementTree.Element` instance."
" If the parse mode is ``\"text\"``, this is a string. If the loader "
"fails, it can return ``None`` or raise an exception."
msgstr ""
"기본 로더. 이 기본 로더는 디스크에서 포함되는 리소스를 읽습니다. *href*\\는 URL입니다. *parse*\\는 구문 분석 "
"모드로 \"xml\" 이나 \"text\"입니다. *encoding*\\은 선택적 텍스트 인코딩입니다. 지정하지 않으면, 인코딩은 "
"``utf-8``\\입니다. 확장된 리소스를 반환합니다. 구문 분석 모드가 ``\"xml\"``\\이면, ElementTree "
"인스턴스입니다. 구문 분석 모드가 \"text\"이면, 유니코드 문자열입니다. 로더가 실패하면, None을 반환하거나 예외를 "
"발생시킬 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:856
#, fuzzy
msgid ""
"This function expands XInclude directives in-place in tree pointed by "
"*elem*. *elem* is either the root :class:`~xml.etree.ElementTree.Element`"
" or an :class:`~xml.etree.ElementTree.ElementTree` instance to find such "
"element. *loader* is an optional resource loader.  If omitted, it "
"defaults to :func:`default_loader`. If given, it should be a callable "
"that implements the same interface as :func:`default_loader`.  *base_url*"
" is base URL of the original file, to resolve relative include file "
"references.  *max_depth* is the maximum number of recursive inclusions.  "
"Limited to reduce the risk of malicious content explosion. Pass ``None`` "
"to disable the limitation."
msgstr ""
"이 함수는 XInclude 지시어를 확장합니다. *elem*\\은 루트 엘리먼트입니다. *loader*\\는 선택적 리소스 "
"로더입니다. 생략하면, 기본값은 :func:`default_loader`\\입니다. 주어지면, "
":func:`default_loader`\\와 같은 인터페이스를 구현하는 콜러블 이어야 합니다. *base_url*\\은 상대적인 "
"포함 파일 참조를 결정하기 위한 원본 파일의 베이스 URL입니다. *max_depth*\\는 최대 재귀 포함 수입니다. 악의적인 "
"내용 폭발의 위험을 줄이도록 제한되었습니다. 제한을 비활성화하려면 음수 값을 전달하십시오."

#: ../../library/xml.etree.elementtree.rst:866
#, fuzzy
msgid "Added the *base_url* and *max_depth* parameters."
msgstr "*base_url*\\과 *max_depth* 매개 변수."

#: ../../library/xml.etree.elementtree.rst:873
msgid "Element Objects"
msgstr "Element 객체"

#: ../../library/xml.etree.elementtree.rst:881
msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr "Element 클래스. 이 클래스는 Element 인터페이스를 정의하고, 이 인터페이스의 참조 구현을 제공합니다."

#: ../../library/xml.etree.elementtree.rst:884
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is "
"an optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"엘리먼트 이름, 어트리뷰트 이름 및 어트리뷰트 값은 바이트 문자열이나 유니코드 문자열일 수 있습니다. *tag*\\는 엘리먼트 "
"이름입니다. *attrib*\\는 엘리먼트 어트리뷰트를 포함하는 선택적 딕셔너리입니다. *extra*\\에는 키워드 인자로 지정된 "
"추가 어트리뷰트가 포함되어 있습니다."

#: ../../library/xml.etree.elementtree.rst:892
msgid ""
"A string identifying what kind of data this element represents (the "
"element type, in other words)."
msgstr "이 엘리먼트가 나타내는 데이터 종류(즉, 엘리먼트 유형)를 식별하는 문자열."

#: ../../library/xml.etree.elementtree.rst:899
msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds "
"either the text between the element's end tag and the next tag, or "
"``None``.  For the XML data"
msgstr ""
"이 어트리뷰트는 엘리먼트와 연관된 추가 데이터를 담는 데 사용될 수 있습니다. 해당 값은 일반적으로 문자열이지만 임의의 응용 "
"프로그램별 객체일 수 있습니다. 엘리먼트가 XML 파일에서 만들어지면, *text* 어트리뷰트는 엘리먼트의 시작 태그와 첫 번째 "
"자식이나 종료 태그 사이의 텍스트를 담거나 ``None``\\이고, *tail* 어트리뷰트는 엘리먼트의 종료 태그와 다음 태그 "
"사이의 텍스트를 담거나 ``None``\\입니다. 다음과 같은 XML 데이터의 경우"

#: ../../library/xml.etree.elementtree.rst:907
msgid "<a><b>1<c>2<d/>3</c></b>4</a>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:911
msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the "
"*b* element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element "
"has *text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"*a* 엘리먼트는 *text*\\와 *tail* 어트리뷰트 모두에 대해 ``None``\\을 갖고, *b* 엘리먼트는 *text* "
"``\"1\"``\\과 *tail* ``\"4\"``\\를 갖고, *c* 엘리먼트는 *text* ``\"2\"``\\와 *tail*"
" ``None``\\을 갖고, *d* 엘리먼트는 *text* ``None``\\과 *tail* ``\"3\"``\\을 갖습니다."

#: ../../library/xml.etree.elementtree.rst:916
msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for "
"example ``\"\".join(element.itertext())``."
msgstr ""
"엘리먼트의 내부 텍스트를 수집하려면, :meth:`itertext`\\를 참조하십시오, 예를 들어 "
"``\"\".join(element.itertext())``."

#: ../../library/xml.etree.elementtree.rst:919
msgid "Applications may store arbitrary objects in these attributes."
msgstr "응용 프로그램은 이 어트리뷰트들에 임의의 객체를 저장할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:924
msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree"
" implementation may choose to use another internal representation, and "
"create the dictionary only if someone asks for it.  To take advantage of "
"such implementations, use the dictionary methods below whenever possible."
msgstr ""
"엘리먼트의 어트리뷰트를 포함하는 딕셔너리. *attrib* 값은 항상 진짜 가변 파이썬 딕셔너리이지만, ElementTree 구현은"
" 다른 내부 표현을 사용하도록 선택하고, 누군가가 요청할 때만 딕셔너리를 만들 수 있습니다. 이러한 구현의 이점을 활용하려면, "
"가능한 한 아래의 딕셔너리 메서드를 사용하십시오."

#: ../../library/xml.etree.elementtree.rst:930
msgid "The following dictionary-like methods work on the element attributes."
msgstr "다음과 같은 딕셔너리와 유사한 메서드가 엘리먼트 어트리뷰트에서 작동합니다."

#: ../../library/xml.etree.elementtree.rst:935
msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""
"엘리먼트를 재설정합니다. 이 함수는 모든 서브 엘리먼트를 제거하고, 모든 어트리뷰트를 지우고, text 및 tail 어트리뷰트를 "
"``None``\\으로 설정합니다."

#: ../../library/xml.etree.elementtree.rst:941
msgid "Gets the element attribute named *key*."
msgstr "*key*\\라는 이름의 엘리먼트 어트리뷰트를 가져옵니다."

#: ../../library/xml.etree.elementtree.rst:943
msgid "Returns the attribute value, or *default* if the attribute was not found."
msgstr "어트리뷰트 값을 반환하거나, 어트리뷰트를 찾을 수 없으면 *default*\\를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:948
msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The"
" attributes are returned in an arbitrary order."
msgstr "엘리먼트 어트리뷰트를 (이름, 값) 쌍의 시퀀스로 반환합니다. 어트리뷰트는 임의의 순서로 반환됩니다."

#: ../../library/xml.etree.elementtree.rst:954
msgid ""
"Returns the elements attribute names as a list.  The names are returned "
"in an arbitrary order."
msgstr "엘리먼트 어트리뷰트 이름을 리스트로 반환합니다. 이름은 임의의 순서로 반환됩니다."

#: ../../library/xml.etree.elementtree.rst:960
msgid "Set the attribute *key* on the element to *value*."
msgstr "엘리먼트의 *key* 어트리뷰트를 *value*\\로 설정합니다."

#: ../../library/xml.etree.elementtree.rst:962
msgid "The following methods work on the element's children (subelements)."
msgstr "다음 메서드는 엘리먼트의 자식(서브 엘리먼트)에서 작동합니다."

#: ../../library/xml.etree.elementtree.rst:967
msgid ""
"Adds the element *subelement* to the end of this element's internal list "
"of subelements.  Raises :exc:`TypeError` if *subelement* is not an "
":class:`Element`."
msgstr ""
"이 엘리먼트의 내부 서브 엘리먼트 리스트 끝에 엘리먼트 *subelement*\\를 추가합니다. *subelement*\\가 "
":class:`Element`\\가 아니면 :exc:`TypeError`\\를 발생시킵니다."

#: ../../library/xml.etree.elementtree.rst:974
#, fuzzy
msgid ""
"Appends *subelements* from an iterable of elements. Raises "
":exc:`TypeError` if a subelement is not an :class:`Element`."
msgstr ""
"0개 이상의 엘리먼트가 있는 시퀀스 객체로 제공되는 *subelements*\\를 추가합니다. 서브 엘리먼트가 "
":class:`Element`\\가 아니면 :exc:`TypeError`\\를 발생시킵니다."

#: ../../library/xml.etree.elementtree.rst:982
msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name "
"or a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to "
"full name.  Pass ``''`` as prefix to move all unprefixed tag names in the"
" expression into the given namespace."
msgstr ""
"*match*\\와 일치하는 첫 번째 서브 엘리먼트를 찾습니다. *match*\\는 태그 이름이나 :ref:`경로 "
"<elementtree-xpath>`\\일 수 있습니다. 엘리먼트 인스턴스나 ``None``\\을 반환합니다. "
"*namespaces*\\는 이름 공간 접두사에서 전체 이름으로의 선택적 매핑입니다. 표현식에서 접두사가 없는 모든 태그 이름을 "
"지정된 이름 공간으로 이동하려면 ``''``\\를 접두사로 전달하십시오."

#: ../../library/xml.etree.elementtree.rst:991
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full"
" name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"태그 이름이나 :ref:`경로 <elementtree-xpath>`\\로 일치하는 모든 서브 엘리먼트를 찾습니다. 일치하는 모든 "
"엘리먼트가 문서 순서로 포함된 리스트를 반환합니다. *namespaces*\\는 이름 공간 접두사에서 전체 이름으로의 선택적 "
"매핑입니다. 표현식에서 접두사가 없는 모든 태그 이름을 지정된 이름 공간으로 이동하려면 ``''``\\를 접두사로 전달하십시오."

#: ../../library/xml.etree.elementtree.rst:1000
msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a "
"tag name or a :ref:`path <elementtree-xpath>`.  Returns the text content "
"of the first matching element, or *default* if no element was found. Note"
" that if the matching element has no text content an empty string is "
"returned. *namespaces* is an optional mapping from namespace prefix to "
"full name.  Pass ``''`` as prefix to move all unprefixed tag names in the"
" expression into the given namespace."
msgstr ""
"*match*\\와 일치하는 첫 번째 서브 엘리먼트의 텍스트를 찾습니다. *match*\\는 태그 이름이나 :ref:`경로 "
"<elementtree-xpath>`\\일 수 있습니다. 일치하는 첫 번째 엘리먼트의 텍스트 내용을 반환하거나, 엘리먼트가 없으면 "
"*default*\\를 반환합니다. 일치하는 엘리먼트에 텍스트 내용이 없으면 빈 문자열이 반환됨에 유의하십시오. "
"*namespaces*\\는 이름 공간 접두사에서 전체 이름으로의 선택적 매핑입니다. 표현식에서 접두사가 없는 모든 태그 이름을 "
"지정된 이름 공간으로 이동하려면 ``''``\\를 접두사로 전달하십시오."

#: ../../library/xml.etree.elementtree.rst:1011
msgid ""
"Inserts *subelement* at the given position in this element.  Raises "
":exc:`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"이 엘리먼트의 지정된 위치에 *subelement*\\를 삽입합니다. *subelement*\\가 "
":class:`Element`\\가 아니면 :exc:`TypeError`\\를 발생시킵니다."

#: ../../library/xml.etree.elementtree.rst:1017
msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The"
" iterator iterates over this element and all elements below it, in "
"document (depth first) order.  If *tag* is not ``None`` or ``'*'``, only "
"elements whose tag equals *tag* are returned from the iterator.  If the "
"tree structure is modified during iteration, the result is undefined."
msgstr ""
"현재 엘리먼트를 루트로 하여 트리 :term:`이터레이터 <iterator>`\\를 만듭니다. 이터레이터는 이 엘리먼트와 그 아래의"
" 모든 엘리먼트를 문서 순서로 (깊이 우선) 이터레이트 합니다. *tag*\\가 ``None``\\이나 ``'*'``\\가 아니면,"
" 태그가 *tag*\\와 같은 엘리먼트만 이터레이터에서 반환됩니다. 이터레이션 중에 트리 구조가 수정되면, 결과는 정의되지 "
"않습니다."

#: ../../library/xml.etree.elementtree.rst:1028
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"태그 이름이나 :ref:`경로 <elementtree-xpath>`\\로 일치하는 모든 서브 엘리먼트를 찾습니다. 일치하는 모든 "
"엘리먼트를 문서 순서로 산출하는 이터러블을 반환합니다. *namespaces*\\는 이름 공간 접두사에서 전체 이름으로의 선택적 "
"매핑입니다."

#: ../../library/xml.etree.elementtree.rst:1039
msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""
"텍스트 이터레이터를 만듭니다. 이터레이터는 이 엘리먼트와 모든 서브 엘리먼트를 문서 순서대로 루핑하고, 모든 내부 텍스트를 "
"반환합니다."

#: ../../library/xml.etree.elementtree.rst:1047
msgid ""
"Creates a new element object of the same type as this element.  Do not "
"call this method, use the :func:`SubElement` factory function instead."
msgstr ""
"이 엘리먼트와 같은 유형의 새 엘리먼트 객체를 만듭니다. 이 메서드를 호출하지 말고, 대신 :func:`SubElement` 팩토리"
" 함수를 사용하십시오."

#: ../../library/xml.etree.elementtree.rst:1053
msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value"
" or contents."
msgstr ""
"엘리먼트에서 *subelement*\\를 제거합니다. find\\* 메서드와 달리 이 메서드는 태그값이나 내용이 아닌 인스턴스 "
"아이덴티티를 기준으로 엘리먼트를 비교합니다."

#: ../../library/xml.etree.elementtree.rst:1057
msgid ""
":class:`Element` objects also support the following sequence type methods"
" for working with subelements: :meth:`~object.__delitem__`, "
":meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__len__`."
msgstr ""
":class:`Element` 객체는 서브 엘리먼트 작업을 위한 :meth:`~object.__delitem__`, "
":meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__len__` 시퀀스 형 메서드도 지원합니다."

#: ../../library/xml.etree.elementtree.rst:1062
#, fuzzy
msgid ""
"Caution: Elements with no subelements will test as ``False``.  In a "
"future release of Python, all elements will test as ``True`` regardless "
"of whether subelements exist.  Instead, prefer explicit ``len(elem)`` or "
"``elem is not None`` tests.::"
msgstr ""
"주의: 서브 엘리먼트가 없는 엘리먼트는 ``False``\\로 테스트 됩니다. 이 동작은 이후 버전에서 변경될 것입니다. 대신 "
"구체적으로 ``len(elem)``\\이나 ``elem is None`` 테스트를 사용하십시오. ::"

#: ../../library/xml.etree.elementtree.rst:1067
msgid ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1075
msgid "Testing the truth value of an Element emits :exc:`DeprecationWarning`."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1078
msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary"
" reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"파이썬 3.8 이전에는, 어트리뷰트를 이름으로 정렬하여 엘리먼트의 XML 어트리뷰트의 직렬화 순서를 인위적으로 예측할 수 있도록 "
"했습니다. 이제 보장되는 딕셔너리 순서를 기반으로, 이 임의 재정렬은 파이썬 3.8에서 제거되어 어트리뷰트가 원래 구문 분석되거나 "
"사용자 코드에 의해 만들어진 순서를 유지합니다."

#: ../../library/xml.etree.elementtree.rst:1084
msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR"
"/xml-infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. "
"In cases where deterministic XML output is required, e.g. for "
"cryptographic signing or test data sets, canonical serialisation is "
"available with the :func:`canonicalize` function."
msgstr ""
"일반적으로, 사용자 코드는 `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_\\이 정보 전달에서 어트리뷰트 순서를 명시적으로 제외한다는 점에서 구체적인 어트리뷰트 순서에 의존하지 않아야 "
"합니다. 입력의 모든 순서를 다룰 수 있도록 코드를 준비해야 합니다. 예를 들어 암호화 서명이나 테스트 데이터 집합과 같이 결정론적"
" XML 출력이 필요한 경우, :func:`canonicalize` 함수로 규범적 직렬화를 사용할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:1092
msgid ""
"In cases where canonical output is not applicable but a specific "
"attribute order is still desirable on output, code should aim for "
"creating the attributes directly in the desired order, to avoid "
"perceptual mismatches for readers of the code. In cases where this is "
"difficult to achieve, a recipe like the following can be applied prior to"
" serialisation to enforce an order independently from the Element "
"creation::"
msgstr ""
"규범적 출력이 적용되지는 않지만, 출력에서 특정 어트리뷰트 순서가 여전히 필요하면, 코드는 코드를 읽는 사람의 지각 불일치를 "
"피하고자, 원하는 순서로 어트리뷰트를 직접 만드는 것을 목표로 해야 합니다. 이를 달성하기 어려운 경우, Element 생성과 "
"독립적으로 순서를 강제하기 위해 직렬화 전에 다음과 같은 조리법을 적용 할 수 있습니다::"

#: ../../library/xml.etree.elementtree.rst:1099
msgid ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # adjust attribute order, e.g. by sorting\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1112
msgid "ElementTree Objects"
msgstr "ElementTree 객체"

#: ../../library/xml.etree.elementtree.rst:1117
msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""
"ElementTree 래퍼 클래스. 이 클래스는 전체 엘리먼트 위계를 나타내며, 표준 XML과의 직렬화에 대한 추가 지원을 "
"추가합니다."

#: ../../library/xml.etree.elementtree.rst:1121
msgid ""
"*element* is the root element.  The tree is initialized with the contents"
" of the XML *file* if given."
msgstr "*element*\\는 루트 엘리먼트입니다. 주어지면 XML *file*\\의 내용으로 트리가 초기화됩니다."

#: ../../library/xml.etree.elementtree.rst:1127
msgid ""
"Replaces the root element for this tree.  This discards the current "
"contents of the tree, and replaces it with the given element.  Use with "
"care.  *element* is an element instance."
msgstr ""
"이 트리의 루트 엘리먼트를 교체합니다. 이것은 트리의 현재 내용을 버리고, 주어진 엘리먼트로 대체합니다. 주의해서 사용하십시오. "
"*element*\\는 엘리먼트 인스턴스입니다."

#: ../../library/xml.etree.elementtree.rst:1134
msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr ":meth:`Element.find`\\와 같습니다, 트리의 루트에서 시작합니다."

#: ../../library/xml.etree.elementtree.rst:1139
msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr ":meth:`Element.findall`\\과 같습니다, 트리의 루트에서 시작합니다."

#: ../../library/xml.etree.elementtree.rst:1144
msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr ":meth:`Element.findtext`\\와 같습니다, 트리의 루트에서 시작합니다."

#: ../../library/xml.etree.elementtree.rst:1149
msgid "Returns the root element for this tree."
msgstr "이 트리의 루트 엘리먼트를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:1154
msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag"
" to look for (default is to return all elements)."
msgstr ""
"루트 엘리먼트에 대한 트리 이터레이터를 만들고 반환합니다. 이터레이터는 이 트리의 모든 엘리먼트를 섹션 순서대로 루핑합니다. "
"*tag*\\는 찾을 태그입니다 (기본값은 모든 엘리먼트를 반환하는 것입니다)."

#: ../../library/xml.etree.elementtree.rst:1161
msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr ":meth:`Element.iterfind`\\와 같습니다, 트리의 루트에서 시작합니다."

#: ../../library/xml.etree.elementtree.rst:1168
msgid ""
"Loads an external XML section into this element tree.  *source* is a file"
" name or :term:`file object`.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used.  Returns "
"the section root element."
msgstr ""
"이 엘리먼트 트리에 외부 XML 섹션을 로드합니다. *source*\\는 파일 이름이나 :term:`파일 객체 <file "
"object>`\\입니다. *parser*\\는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 "
":class:`XMLParser` 구문 분석기가 사용됩니다. 섹션 루트 엘리먼트를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:1178
msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a "
":term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, "
"``True`` for always, ``None`` for only if not US-ASCII or UTF-8 or "
"Unicode (default is ``None``). *default_namespace* sets the default XML "
"namespace (for \"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` "
"or ``\"text\"`` (default is ``\"xml\"``). The keyword-only "
"*short_empty_elements* parameter controls the formatting of elements that"
" contain no content.  If ``True`` (the default), they are emitted as a "
"single self-closed tag, otherwise they are emitted as a pair of start/end"
" tags."
msgstr ""
"엘리먼트 트리를 XML로 파일에 씁니다. *file*\\은 파일 이름이거나 쓰기 위해 열린 :term:`파일 객체 <file "
"object>`\\입니다. *encoding* [1]_ 은 출력 인코딩입니다 (기본값은 US-ASCII입니다). "
"*xml_declaration*\\은 파일에 XML 선언을 추가해야 하는지를 제어합니다. 추가하지 말아야 하면 ``False``, "
"항상 추가하면 ``True``, US-ASCII나 UTF-8이나 유니코드가 아닐 때만 추가하면 ``None``\\을 사용하십시오 "
"(기본값은 ``None``\\입니다). *default_namespace*\\는 기본 XML 이름 공간을 설정합니다 "
"(\"xmlns\"). *method*\\는 ``\"xml\"``, ``\"html\"`` 또는 ``\"text\"``\\입니다 "
"(기본값은 ``\"xml\"``\\입니다). 키워드 전용 *short_empty_elements* 매개 변수는 내용이 없는 "
"엘리먼트의 포매팅을 제어합니다. ``True``\\(기본값)이면, 단일 스스로 닫힌 태그로 방출되고, 그렇지 않으면 한 쌍의 "
"시작/종료 태그로 방출됩니다."

#: ../../library/xml.etree.elementtree.rst:1192
msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note "
"that this may conflict with the type of *file* if it's an open "
":term:`file object`; make sure you do not try to write a string to a "
"binary stream and vice versa."
msgstr ""
"출력은 문자열(:class:`str`)이나 바이너리(:class:`bytes`)입니다. 이것은 *encoding* 인자에 의해 "
"제어됩니다. *encoding*\\이 ``\"unicode\"``\\이면, 출력은 문자열입니다; 그렇지 않으면 바이너리입니다. "
"*file*\\이 열린 :term:`파일 객체 <file object>`\\이면 *file*\\의 유형과 충돌할 수 있음에 "
"유의하십시오; 문자열을 바이너리 스트림에 쓰거나 그 반대로 하지 않도록 하십시오."

#: ../../library/xml.etree.elementtree.rst:1202
msgid ""
"The :meth:`write` method now preserves the attribute order specified by "
"the user."
msgstr ":meth:`write` 메서드는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다."

#: ../../library/xml.etree.elementtree.rst:1207
msgid "This is the XML file that is going to be manipulated::"
msgstr "이것은 조작될 XML 파일입니다::"

#: ../../library/xml.etree.elementtree.rst:1209
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1219
msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr "첫 번째 문단에 있는 모든 링크의 어트리뷰트 \"target\"을 변경하는 예::"

#: ../../library/xml.etree.elementtree.rst:1221
msgid ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Finds first occurrence of tag p in "
"body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Returns list of all links\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Iterates through all found links\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1239
msgid "QName Objects"
msgstr "QName 객체"

#: ../../library/xml.etree.elementtree.rst:1244
#, python-brace-format
msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in "
"order to get proper namespace handling on output.  *text_or_uri* is a "
"string containing the QName value, in the form {uri}local, or, if the tag"
" argument is given, the URI part of a QName.  If *tag* is given, the "
"first argument is interpreted as a URI, and this argument is interpreted "
"as a local name. :class:`QName` instances are opaque."
msgstr ""
"QName 래퍼. 출력에서 이름 공간을 올바르게 처리하기 위해, QName 어트리뷰트 값을 래핑하는 데 사용할 수 있습니다. "
"*text_or_uri*\\는 {uri}local 형식으로 QName 값을 포함하는 문자열이거나, tag 인자가 제공되면 "
"QName의 URI 부분입니다. *tag*\\가 제공되면, 첫 번째 인자는 URI로 해석되고, 이 인자는 로컬 이름으로 해석됩니다."
" :class:`QName` 인스턴스는 불투명합니다."

#: ../../library/xml.etree.elementtree.rst:1256
msgid "TreeBuilder Objects"
msgstr "TreeBuilder 객체"

#: ../../library/xml.etree.elementtree.rst:1262
msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"일반 엘리먼트 구조 빌더. 이 빌더는 일련의 start, data, end, comment 및 pi 메서드 호출을 올바른 형식의 "
"엘리먼트 구조로 변환합니다. 이 클래스를 사용하여 사용자 정의 XML 구문 분석기를 사용하거나 다른 XML 형식의 구문 분석기를 "
"사용하는 엘리먼트 구조를 구축할 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:1267
msgid ""
"*element_factory*, when given, must be a callable accepting two "
"positional arguments: a tag and a dict of attributes.  It is expected to "
"return a new element instance."
msgstr ""
"주어지면 *element_factory*\\는 두 개의 위치 인자를 받아들이는 콜러블 이어야 합니다: 태그와 어트리뷰트 딕셔너리. "
"새로운 엘리먼트 인스턴스를 반환할 것으로 기대합니다."

#: ../../library/xml.etree.elementtree.rst:1271
msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should "
"behave like the :func:`Comment` and :func:`ProcessingInstruction` "
"functions to create comments and processing instructions.  When not "
"given, the default factories will be used.  When *insert_comments* and/or"
" *insert_pis* is true, comments/pis will be inserted into the tree if "
"they appear within the root element (but not outside of it)."
msgstr ""
"주어지면, *comment_factory*\\와 *pi_factory* 함수는 주석과 처리 명령을 만들기 위해 "
":func:`Comment`\\와 :func:`ProcessingInstruction` 함수처럼 동작해야 합니다. 지정하지 않으면,"
" 기본 팩토리가 사용됩니다. *insert_comments* 및/또는 *insert_pis*\\가 참이면, 주석/처리 명령이 루트 "
"엘리먼트 내에 있으면 (하지만 외부에 있지 않으면) 트리에 삽입됩니다."

#: ../../library/xml.etree.elementtree.rst:1280
msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr "빌더 버퍼를 플러시하고, 최상위 문서 엘리먼트를 반환합니다. :class:`Element` 인스턴스를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:1286
msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr "현재 엘리먼트에 텍스트를 추가합니다. *data*\\는 문자열입니다. 바이트 문자열이거나 유니코드 문자열이어야 합니다."

#: ../../library/xml.etree.elementtree.rst:1292
msgid ""
"Closes the current element.  *tag* is the element name.  Returns the "
"closed element."
msgstr "현재 엘리먼트를 닫습니다. *tag*\\는 엘리먼트 이름입니다. 닫힌 엘리먼트를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:1298
msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary"
" containing element attributes.  Returns the opened element."
msgstr ""
"새로운 엘리먼트를 엽니다. *tag*\\는 엘리먼트 이름입니다. *attrs*\\는 엘리먼트 어트리뷰트를 포함하는 딕셔너리입니다. "
"열린 엘리먼트를 반환합니다."

#: ../../library/xml.etree.elementtree.rst:1304
msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true,"
" this will also add it to the tree."
msgstr "주어진 *text*\\로 주석을 만듭니다. ``insert_comments``\\가 참이면, 트리에 추가합니다."

#: ../../library/xml.etree.elementtree.rst:1312
#, fuzzy
msgid ""
"Creates a process instruction with the given *target* name and *text*. If"
" ``insert_pis`` is true, this will also add it to the tree."
msgstr "주어진 *target* 이름과 *text*\\로 처리 명령을 만듭니다. ``insert_pis``\\가 참이면, 트리에 추가합니다."

#: ../../library/xml.etree.elementtree.rst:1318
msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the "
"following methods:"
msgstr "또한, 사용자 정의 :class:`TreeBuilder` 객체는 다음 메서드를 제공할 수 있습니다:"

#: ../../library/xml.etree.elementtree.rst:1323
msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is "
"the public identifier.  *system* is the system identifier.  This method "
"does not exist on the default :class:`TreeBuilder` class."
msgstr ""
"doctype 선언을 처리합니다. *name*\\은 doctype 이름입니다. *pubid*\\는 공개 식별자입니다. "
"*system*\\은 시스템 식별자입니다. 이 메서드는 기본 :class:`TreeBuilder` 클래스에 없습니다."

#: ../../library/xml.etree.elementtree.rst:1331
msgid ""
"Is called whenever the parser encounters a new namespace declaration, "
"before the ``start()`` callback for the opening element that defines it. "
"*prefix* is ``''`` for the default namespace and the declared namespace "
"prefix name otherwise.  *uri* is the namespace URI."
msgstr ""
"구문 분석기가 새 이름 공간 선언을 발견할 때마다 이를 정의하는 여는 엘리먼트에 대한 ``start()`` 콜백 전에 호출됩니다. "
"*prefix*\\는 기본 이름 공간의 경우 ``''``\\이고, 그렇지 않으면 선언된 이름 공간 접두사 이름입니다. "
"*uri*\\는 이름 공간 URI입니다."

#: ../../library/xml.etree.elementtree.rst:1340
msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr "이름 공간 접두사 매핑을 선언한 엘리먼트의 ``end()`` 콜백 후에, 스코프를 벗어난 *prefix*\\의 이름으로 호출됩니다."

#: ../../library/xml.etree.elementtree.rst:1352
msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are "
"the same as for the :func:`canonicalize` function.  This class does not "
"build a tree but translates the callback events directly into a "
"serialised form using the *write* function."
msgstr ""
"`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ 기록기. 인자는 "
":func:`canonicalize` 함수와 같습니다. 이 클래스는 트리를 구축하지 않지만, *write* 함수를 사용하여 콜백 "
"이벤트를 직렬화된 형식으로 직접 변환합니다."

#: ../../library/xml.etree.elementtree.rst:1363
msgid "XMLParser Objects"
msgstr "XMLParser 객체"

#: ../../library/xml.etree.elementtree.rst:1368
msgid ""
"This class is the low-level building block of the module.  It uses "
":mod:`xml.parsers.expat` for efficient, event-based parsing of XML.  It "
"can be fed XML data incrementally with the :meth:`feed` method, and "
"parsing events are translated to a push API - by invoking callbacks on "
"the *target* object.  If *target* is omitted, the standard "
":class:`TreeBuilder` is used. If *encoding* [1]_ is given, the value "
"overrides the encoding specified in the XML file."
msgstr ""
"이 클래스는 모듈의 저수준 빌딩 블록입니다. 효율적인 이벤트 기반 XML 구문 분석을 위해 "
":mod:`xml.parsers.expat`\\을 사용합니다. :meth:`feed` 메서드를 사용하여 XML 데이터를 점진적으로 "
"공급할 수 있으며, 구문 분석 이벤트는 *target* 객체에서 콜백을 호출하여 푸시 API로 변환됩니다. *target*\\을 "
"생략하면, 표준 :class:`TreeBuilder`\\가 사용됩니다. *encoding* [1]_ 이 제공되면, 값이 XML "
"파일에 지정된 인코딩을 대체합니다."

#: ../../library/xml.etree.elementtree.rst:1376
#, fuzzy
msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The "
"*html* argument is no longer supported."
msgstr ""
"매개 변수는 이제 :ref:`키워드-전용 <keyword-only_parameter>`\\입니다. *html* 인자는 더는 지원되지"
" 않습니다."

#: ../../library/xml.etree.elementtree.rst:1383
msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by "
"default, this is the toplevel document element."
msgstr ""
"구문 분석기로의 데이터 공급을 완료합니다. 생성 중에 전달된 *target*\\의 ``close()`` 메서드를 호출한 결과를 "
"반환합니다; 기본적으로, 최상위 문서 엘리먼트입니다."

#: ../../library/xml.etree.elementtree.rst:1390
msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "구문 분석기에 데이터를 공급합니다. *data*\\는 인코딩된 데이터입니다."

#: ../../library/xml.etree.elementtree.rst:1395
#: ../../library/xml.etree.elementtree.rst:1473
msgid ""
"Triggers parsing of any previously fed unparsed data, which can be used "
"to ensure more immediate feedback, in particular with Expat >=2.6.0. The "
"implementation of :meth:`flush` temporarily disables reparse deferral "
"with Expat (if currently enabled) and triggers a reparse. Disabling "
"reparse deferral has security consequences; please see "
":meth:`xml.parsers.expat.xmlparser.SetReparseDeferralEnabled` for "
"details."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1402
#: ../../library/xml.etree.elementtree.rst:1480
msgid ""
"Note that :meth:`flush` has been backported to some prior releases of "
"CPython as a security fix.  Check for availability of :meth:`flush` using"
" :func:`hasattr` if used in code running across a variety of Python "
"versions."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1410
msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` "
"method for each opening tag, its ``end(tag)`` method for each closing "
"tag, and data is processed by method ``data(data)``.  For further "
"supported callback methods, see the :class:`TreeBuilder` class.  "
":meth:`XMLParser.close` calls *target*\\'s method ``close()``. "
":class:`XMLParser` can be used not only for building a tree structure. "
"This is an example of counting the maximum depth of an XML file::"
msgstr ""
":meth:`XMLParser.feed`\\는 각 여는 태그마다 *target*\\의 ``start(tag, "
"attrs_dict)`` 메서드를 호출하고, 닫는 태그마다 ``end(tag)`` 메서드를 호출하며, 데이터는 메서드 "
"``data(data)``\\로 처리됩니다. 추가로 지원되는 콜백 메서드는, :class:`TreeBuilder` 클래스를 "
"참조하십시오. :meth:`XMLParser.close`\\는 *target*\\의 메서드 ``close()``\\를 호출합니다. "
":class:`XMLParser`\\는 트리 구조 구축에만 사용할 수 있는 것은 아닙니다. 다음은 XML 파일의 최대 깊이를 "
"계산하는 예입니다::"

#: ../../library/xml.etree.elementtree.rst:1418
msgid ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser"
"\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:1454
msgid "XMLPullParser Objects"
msgstr "XMLPullParser 객체"

#: ../../library/xml.etree.elementtree.rst:1458
msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API"
" is similar to that of :class:`XMLParser`, but instead of pushing calls "
"to a callback target, :class:`XMLPullParser` collects an internal list of"
" parsing events and lets the user read from it. *events* is a sequence of"
" events to report back.  The supported events are the strings "
"``\"start\"``, ``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"``"
" and ``\"end-ns\"`` (the \"ns\" events are used to get detailed namespace"
" information).  If *events* is omitted, only ``\"end\"`` events are "
"reported."
msgstr ""
"비 블로킹 응용 프로그램에 적합한 풀 구문 분석기. 입력 측 API는 :class:`XMLParser`\\의 것과 유사하지만, 콜백"
" 대상으로 호출을 푸시하는 대신, :class:`XMLPullParser`\\는 내부 구문 분석 이벤트 리스트를 수집하여 사용자가 "
"여기서 읽을 수 있도록 합니다. *events*\\는 보고할 이벤트의 시퀀스입니다. 지원되는 이벤트는 문자열 "
"``\"start\"``, ``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"``"
" 및 ``\"end-ns\"``\\입니다 (\"ns\" 이벤트는 자세한 이름 공간 정보를 얻는 데 사용됩니다). "
"*events*\\를 생략하면, ``\"end\"`` 이벤트만 보고됩니다."

#: ../../library/xml.etree.elementtree.rst:1469
msgid "Feed the given bytes data to the parser."
msgstr "주어진 바이트열 데이터를 구문 분석기에 공급합니다."

#: ../../library/xml.etree.elementtree.rst:1489
msgid ""
"Signal the parser that the data stream is terminated. Unlike "
":meth:`XMLParser.close`, this method always returns :const:`None`. Any "
"events not yet retrieved when the parser is closed can still be read with"
" :meth:`read_events`."
msgstr ""
"구문 분석기에 데이터 스트림이 종료되었음을 알립니다. :meth:`XMLParser.close`\\와 달리, 이 메서드는 항상 "
":const:`None`\\을 반환합니다. 구문 분석기가 닫힐 때 아직 꺼내지 않은 이벤트는 "
":meth:`read_events`\\로 계속 읽을 수 있습니다."

#: ../../library/xml.etree.elementtree.rst:1496
msgid ""
"Return an iterator over the events which have been encountered in the "
"data fed to the parser.  The iterator yields ``(event, elem)`` pairs, "
"where *event* is a string representing the type of event (e.g. "
"``\"end\"``) and *elem* is the encountered :class:`Element` object, or "
"other context value as follows."
msgstr ""
"구문 분석기에 공급된 데이터에서 발생한 이벤트에 대한 이터레이터를 반환합니다. 이터레이터는 ``(event, elem)`` 쌍을 "
"산출합니다, 여기서 *event*\\는 이벤트 유형을 나타내는 문자열(예를 들어 ``\"end\"``)이고 *elem*\\은 발견된"
" :class:`Element` 객체나, 다음과 같은 기타 문맥 값입니다."

#: ../../library/xml.etree.elementtree.rst:1502
msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``end``: 현재 엘리먼트."

#: ../../library/xml.etree.elementtree.rst:1503
msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr "``comment``, ``pi``: 현재 주석 / 처리 명령"

#: ../../library/xml.etree.elementtree.rst:1504
msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr "``start-ns``: 선언된 이름 공간 매핑을 명명하는 튜플 ``(prefix, uri)``"

#: ../../library/xml.etree.elementtree.rst:1506
msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns``: :const:`None` (향후 버전에서 변경될 수 있습니다)"

#: ../../library/xml.etree.elementtree.rst:1508
msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when "
"they are retrieved from the iterator, so multiple readers iterating in "
"parallel over iterators obtained from :meth:`read_events` will have "
"unpredictable results."
msgstr ""
":meth:`read_events`\\에 대한 이전 호출에서 제공된 이벤트는 다시 산출되지 않습니다. 이벤트는 이터레이터에서 꺼낼 "
"때만 내부 큐에서 소비되므로, :meth:`read_events`\\에서 얻은 이터레이터에 대해 병렬로 이터레이션 하는 여러 "
"판독기는 예측할 수 없는 결과를 얻게 됩니다."

#: ../../library/xml.etree.elementtree.rst:1516
msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" "
"character of a starting tag when it emits a \"start\" event, so the "
"attributes are defined, but the contents of the text and tail attributes "
"are undefined at that point.  The same applies to the element children; "
"they may or may not be present."
msgstr ""
":class:`XMLPullParser` 는 \"start\" 이벤트를 방출할 때 시작 태그의 \">\" 문자를 보았다는 것만 "
"보장해서, 어트리뷰트는 정의되지만, 텍스트의 내용과 테일(tail) 어트리뷰트는 그 시점에 정의되지 않습니다. 자식 엘리먼트에도 "
"마찬가지로 적용됩니다; 그들은 존재할 수도 그렇지 않을 수도 있습니다."

#: ../../library/xml.etree.elementtree.rst:1531
msgid "Exceptions"
msgstr "예외"

#: ../../library/xml.etree.elementtree.rst:1535
msgid ""
"XML parse error, raised by the various parsing methods in this module "
"when parsing fails.  The string representation of an instance of this "
"exception will contain a user-friendly error message.  In addition, it "
"will have the following attributes available:"
msgstr ""
"XML 구문 분석 에러, 이 모듈의 다양한 구문 분석 메서드가 구문 분석이 실패할 때 발생시킵니다. 이 예외 인스턴스의 문자열 "
"표현에는 사용자 친화적인 에러 메시지가 포함됩니다. 또한, 다음과 같은 어트리뷰트를 사용할 수 있습니다:"

#: ../../library/xml.etree.elementtree.rst:1542
msgid ""
"A numeric error code from the expat parser. See the documentation of "
":mod:`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""
"expat 구문 분석기의 숫자 에러 코드. 에러 코드와 의미의 목록은 :mod:`xml.parsers.expat` 설명서를 "
"참조하십시오."

#: ../../library/xml.etree.elementtree.rst:1547
msgid "A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr "에러가 발생한 위치를 지정하는, *line*, *column* 숫자의 튜플."

#: ../../library/xml.etree.elementtree.rst:1550
msgid "Footnotes"
msgstr "각주"

#: ../../library/xml.etree.elementtree.rst:1551
msgid ""
"The encoding string included in XML output should conform to the "
"appropriate standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is "
"not.  See https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl "
"and https://www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"XML 출력에 포함된 인코딩 문자열은 적절한 표준을 준수해야 합니다. 예를 들어, \"UTF-8\"은 유효하지만, \"UTF8\"은"
" 유효하지 않습니다. https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-"
"EncodingDecl and https://www.iana.org/assignments/character-sets"
"/character-sets.xhtml 을 참조하십시오."

#~ msgid "Additional resources"
#~ msgstr "추가 자료"

#~ msgid ""
#~ "See http://effbot.org/zone/element-index.htm for "
#~ "tutorials and links to other docs."
#~ msgstr "자습서와 다른 문서에 대한 링크는 http://effbot.org/zone/element-index.htm 을 참조하십시오."

#~ msgid ""
#~ "Returns the expanded resource.  If the"
#~ " parse mode is ``\"xml\"``, this is"
#~ " an ElementTree instance.  If the "
#~ "parse mode is \"text\", this is a"
#~ " Unicode string.  If the loader "
#~ "fails, it can return None or raise"
#~ " an exception."
#~ msgstr ""
#~ "확장된 리소스를 반환합니다. 구문 분석 모드가 "
#~ "``\"xml\"``\\이면 ElementTree 인스턴스입니다. 구문 분석 "
#~ "모드가 \"text\"이면 유니코드 문자열입니다. 로더가 실패하면 "
#~ "None을 반환하거나 예외를 발생시킬 수 있습니다."

