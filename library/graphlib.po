# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/graphlib.rst:2
#, fuzzy
msgid ":mod:`!graphlib` --- Functionality to operate with graph-like structures"
msgstr ":mod:`graphlib` --- 그래프와 유사한 구조에 작동하는 기능"

#: ../../library/graphlib.rst:8
msgid "**Source code:** :source:`Lib/graphlib.py`"
msgstr "**소스 코드:** :source:`Lib/graphlib.py`"

#: ../../library/graphlib.rst:20
#, fuzzy
msgid ""
"Provides functionality to topologically sort a graph of :term:`hashable` "
"nodes."
msgstr "해시 가능 노드의 그래프(graph)를 위상 정렬(topological sort)하는 기능을 제공합니다."

#: ../../library/graphlib.rst:22
msgid ""
"A topological order is a linear ordering of the vertices in a graph such "
"that for every directed edge u -> v from vertex u to vertex v, vertex u "
"comes before vertex v in the ordering. For instance, the vertices of the "
"graph may represent tasks to be performed, and the edges may represent "
"constraints that one task must be performed before another; in this "
"example, a topological ordering is just a valid sequence for the tasks. A"
" complete topological ordering is possible if and only if the graph has "
"no directed cycles, that is, if it is a directed acyclic graph."
msgstr ""
"위상 순서(topological order)는 그래프(graph)에서 꼭짓점(vertex)의 선형 순서로, 꼭짓점 u에서 꼭짓점 "
"v로 가는 모든 유향 변(directed edge) u -> v 에 대해, 꼭짓점 u가 꼭짓점 v보다 앞에 옵니다. 예를 들어, "
"그래프의 꼭짓점은 수행될 작업을 나타낼 수 있고, 변은 하나의 작업이 다른 작업보다 먼저 수행되어야 한다는 제약을 나타낼 수 "
"있습니다; 이 예에서, 위상 순서는 유효한 작업 순서입니다. 그래프에 유향 순환이 없는 경우, 즉 유향 비순환 그래프인 경우에만 "
"완전한 위상 정렬이 가능합니다."

#: ../../library/graphlib.rst:31
msgid ""
"If the optional *graph* argument is provided it must be a dictionary "
"representing a directed acyclic graph where the keys are nodes and the "
"values are iterables of all predecessors of that node in the graph (the "
"nodes that have edges that point to the value in the key). Additional "
"nodes can be added to the graph using the :meth:`~TopologicalSorter.add` "
"method."
msgstr ""
"선택적 *graph* 인자가 제공되면 키가 노드이고 값이 그래프에서 해당 노드의 모든 선행 노드(키의 값을 가리키는 변이 있는 "
"노드)의 이터러블인 비순환 그래프를 나타내는 딕셔너리이어야 합니다). :meth:`~TopologicalSorter.add` "
"메서드를 사용하여 그래프에 추가 노드를 추가할 수 있습니다."

#: ../../library/graphlib.rst:37
msgid ""
"In the general case, the steps required to perform the sorting of a given"
" graph are as follows:"
msgstr "일반적으로, 주어진 그래프의 정렬을 수행하는 데 필요한 단계는 다음과 같습니다:"

#: ../../library/graphlib.rst:40
msgid ""
"Create an instance of the :class:`TopologicalSorter` with an optional "
"initial graph."
msgstr "선택적 초기 그래프를 사용하여 :class:`TopologicalSorter`\\의 인스턴스를 만듭니다."

#: ../../library/graphlib.rst:42
msgid "Add additional nodes to the graph."
msgstr "그래프에 노드를 추가합니다."

#: ../../library/graphlib.rst:43
msgid "Call :meth:`~TopologicalSorter.prepare` on the graph."
msgstr "그래프에서 :meth:`~TopologicalSorter.prepare`\\를 호출합니다."

#: ../../library/graphlib.rst:44
msgid ""
"While :meth:`~TopologicalSorter.is_active` is ``True``, iterate over the "
"nodes returned by :meth:`~TopologicalSorter.get_ready` and process them. "
"Call :meth:`~TopologicalSorter.done` on each node as it finishes "
"processing."
msgstr ""
":meth:`~TopologicalSorter.is_active`\\가 ``True``\\인 동안, "
":meth:`~TopologicalSorter.get_ready`\\가 반환하는 노드를 이터레이트하고 이들을 처리합니다. 처리가 "
"완료됨에 따라, 각 노드에 :meth:`~TopologicalSorter.done`\\을 호출합니다."

#: ../../library/graphlib.rst:49
msgid ""
"In case just an immediate sorting of the nodes in the graph is required "
"and no parallelism is involved, the convenience method "
":meth:`TopologicalSorter.static_order` can be used directly:"
msgstr ""
"그래프에서 노드의 즉각적인 정렬이 필요하고 병렬화가 개입하지 않으면, 편의 메서드 "
":meth:`TopologicalSorter.static_order`\\를 직접 사용할 수 있습니다:"

#: ../../library/graphlib.rst:53
#, python-brace-format
msgid ""
">>> graph = {\"D\": {\"B\", \"C\"}, \"C\": {\"A\"}, \"B\": {\"A\"}}\n"
">>> ts = TopologicalSorter(graph)\n"
">>> tuple(ts.static_order())\n"
"('A', 'C', 'B', 'D')"
msgstr ""

#: ../../library/graphlib.rst:60
msgid ""
"The class is designed to easily support parallel processing of the nodes "
"as they become ready. For instance::"
msgstr "이 클래스는 노드가 준비됨에 따라 병렬 처리를 쉽게 지원하도록 설계되었습니다. 예를 들어::"

#: ../../library/graphlib.rst:63
msgid ""
"topological_sorter = TopologicalSorter()\n"
"\n"
"# Add nodes to 'topological_sorter'...\n"
"\n"
"topological_sorter.prepare()\n"
"while topological_sorter.is_active():\n"
"    for node in topological_sorter.get_ready():\n"
"        # Worker threads or processes take nodes to work on off the\n"
"        # 'task_queue' queue.\n"
"        task_queue.put(node)\n"
"\n"
"    # When the work for a node is done, workers put the node in\n"
"    # 'finalized_tasks_queue' so we can get more nodes to work on.\n"
"    # The definition of 'is_active()' guarantees that, at this point, at\n"
"    # least one node has been placed on 'task_queue' that hasn't yet\n"
"    # been passed to 'done()', so this blocking 'get()' must (eventually)"
"\n"
"    # succeed.  After calling 'done()', we loop back to call "
"'get_ready()'\n"
"    # again, so put newly freed nodes on 'task_queue' as soon as\n"
"    # logically possible.\n"
"    node = finalized_tasks_queue.get()\n"
"    topological_sorter.done(node)"
msgstr ""

#: ../../library/graphlib.rst:87
#, fuzzy
msgid ""
"Add a new node and its predecessors to the graph. Both the *node* and all"
" elements in *predecessors* must be :term:`hashable`."
msgstr ""
"새 노드와 그 선행 노드를 그래프에 추가합니다. *node*\\와 *predecessors*\\의 모든 요소는 모두 해시 가능해야 "
"합니다."

#: ../../library/graphlib.rst:90
msgid ""
"If called multiple times with the same node argument, the set of "
"dependencies will be the union of all dependencies passed in."
msgstr "같은 노드 인자로 여러 번 호출되면, 종속성 집합은 전달된 모든 종속성의 합집합입니다."

#: ../../library/graphlib.rst:93
msgid ""
"It is possible to add a node with no dependencies (*predecessors* is not "
"provided) or to provide a dependency twice. If a node that has not been "
"provided before is included among *predecessors* it will be automatically"
" added to the graph with no predecessors of its own."
msgstr ""
"종속성이 없는 노드를 추가하거나(*predecessors*\\가 제공되지 않는 경우) 종속성을 두 번 제공할 수 있습니다. 이전에 "
"제공되지 않은 노드가 *predecessors*\\에 포함되면, 노드는 그 자신의 선행 노드 없이 자동으로 그래프에 추가됩니다."

#: ../../library/graphlib.rst:98
msgid ""
"Raises :exc:`ValueError` if called after "
":meth:`~TopologicalSorter.prepare`."
msgstr ":meth:`~TopologicalSorter.prepare` 이후에 호출되면 :exc:`ValueError`\\가 발생합니다."

#: ../../library/graphlib.rst:102
msgid ""
"Mark the graph as finished and check for cycles in the graph. If any "
"cycle is detected, :exc:`CycleError` will be raised, but "
":meth:`~TopologicalSorter.get_ready` can still be used to obtain as many "
"nodes as possible until cycles block more progress. After a call to this "
"function, the graph cannot be modified, and therefore no more nodes can "
"be added using :meth:`~TopologicalSorter.add`."
msgstr ""
"그래프를 완료로 표시하고 그래프에서 순환을 검사합니다. 순환이 감지되면, :exc:`CycleError`\\가 발생하지만, 순환이 "
"더 진행하는 것을 차단할 때까지 :meth:`~TopologicalSorter.get_ready`\\를 사용하여 여전히 가능한 많은"
" 노드를 얻을 수 있습니다. 이 함수를 호출한 후에는, 그래프를 수정할 수 없어서, "
":meth:`~TopologicalSorter.add`\\를 사용하여 더는 노드를 추가할 수 없습니다."

#: ../../library/graphlib.rst:111
msgid ""
"Returns ``True`` if more progress can be made and ``False`` otherwise. "
"Progress can be made if cycles do not block the resolution and either "
"there are still nodes ready that haven't yet been returned by "
":meth:`TopologicalSorter.get_ready` or the number of nodes marked "
":meth:`TopologicalSorter.done` is less than the number that have been "
"returned by :meth:`TopologicalSorter.get_ready`."
msgstr ""
"더 진행할 수 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. 순환이 결정을 차단하지 않고 "
":meth:`TopologicalSorter.get_ready`\\에 의해 아직 반환되지 않은 준비된 노드가 아직 있거나 "
":meth:`TopologicalSorter.done`\\으로 표시된 노드 수가 "
":meth:`TopologicalSorter.get_ready`\\에 의해 반환된 수보다 작으면 진행할 수 있습니다."

#: ../../library/graphlib.rst:118
#, fuzzy
msgid ""
"The :meth:`~object.__bool__` method of this class defers to this "
"function, so instead of::"
msgstr "이 클래스의 :meth:`~TopologicalSorter.__bool__` 메서드는 이 함수로 위임됩니다, 그래서 다음 대신::"

#: ../../library/graphlib.rst:121
msgid ""
"if ts.is_active():\n"
"    ..."
msgstr ""

#: ../../library/graphlib.rst:124
msgid "it is possible to simply do::"
msgstr "다음처럼 간단하게 할 수 있습니다::"

#: ../../library/graphlib.rst:126
msgid ""
"if ts:\n"
"    ..."
msgstr ""

#: ../../library/graphlib.rst:129 ../../library/graphlib.rst:152
msgid ""
"Raises :exc:`ValueError` if called without calling "
":meth:`~TopologicalSorter.prepare` previously."
msgstr ""
"이전에 :meth:`~TopologicalSorter.prepare`\\를 호출하지 않고 호출되면 "
":exc:`ValueError`\\가 발생합니다."

#: ../../library/graphlib.rst:134
msgid ""
"Marks a set of nodes returned by :meth:`TopologicalSorter.get_ready` as "
"processed, unblocking any successor of each node in *nodes* for being "
"returned in the future by a call to :meth:`TopologicalSorter.get_ready`."
msgstr ""
":meth:`TopologicalSorter.get_ready`\\에 의해 반환된 노드 집합이 처리된 것으로 표시하여, "
"*nodes*\\에 있는 각 노드의 모든 후속 노드들이 :meth:`TopologicalSorter.get_ready`\\에 대한 "
"호출로 나중에 반환되도록 차단 해제합니다."

#: ../../library/graphlib.rst:138
msgid ""
"Raises :exc:`ValueError` if any node in *nodes* has already been marked "
"as processed by a previous call to this method or if a node was not added"
" to the graph by using :meth:`TopologicalSorter.add`, if called without "
"calling :meth:`~TopologicalSorter.prepare` or if node has not yet been "
"returned by :meth:`~TopologicalSorter.get_ready`."
msgstr ""
"*nodes*\\에 있는 노드가 이 메서드에 대한 이전 호출에 의해 이미 처리된 것으로 표시되었거나 "
":meth:`TopologicalSorter.add`\\를 사용하여 그래프에 추가되지 않았거나, "
":meth:`~TopologicalSorter.prepare`\\를 호출하지 않고 호출되었거나, 또는 "
":meth:`~TopologicalSorter.get_ready`\\가 아직 노드를 반환하지 않았으면 "
":exc:`ValueError`\\를 발생시킵니다."

#: ../../library/graphlib.rst:146
msgid ""
"Returns a ``tuple`` with all the nodes that are ready. Initially it "
"returns all nodes with no predecessors, and once those are marked as "
"processed by calling :meth:`TopologicalSorter.done`, further calls will "
"return all new nodes that have all their predecessors already processed. "
"Once no more progress can be made, empty tuples are returned."
msgstr ""
"준비된 모든 노드가 담긴 ``tuple``\\을 반환합니다. 처음에는 선행 노드가 없는 모든 노드를 반환하며, 일단 "
":meth:`TopologicalSorter.done`\\을 호출하여 처리된 것으로 표시되면, 추가 호출은 모든 선행 노드가 이미 "
"처리된 모든 새 노드를 반환합니다. 더는 진행할 수 없으면, 빈 튜플이 반환됩니다."

#: ../../library/graphlib.rst:157
#, fuzzy
msgid ""
"Returns an iterator object which will iterate over nodes in a topological"
" order. When using this method, :meth:`~TopologicalSorter.prepare` and "
":meth:`~TopologicalSorter.done` should not be called. This method is "
"equivalent to::"
msgstr ""
"위상 순서로 노드의 이터러블을 반환합니다. 이 메서드를 사용하면 :meth:`TopologicalSorter.prepare`\\나 "
":meth:`TopologicalSorter.done`\\을 호출할 필요가 없습니다. 이 방법은 다음과 동등합니다::"

#: ../../library/graphlib.rst:162
msgid ""
"def static_order(self):\n"
"    self.prepare()\n"
"    while self.is_active():\n"
"        node_group = self.get_ready()\n"
"        yield from node_group\n"
"        self.done(*node_group)"
msgstr ""

#: ../../library/graphlib.rst:169
msgid ""
"The particular order that is returned may depend on the specific order in"
" which the items were inserted in the graph. For example:"
msgstr "반환되는 특정 순서는 항목이 그래프에 삽입된 특정 순서에 따라 달라질 수 있습니다. 예를 들면:"

#: ../../library/graphlib.rst:172
msgid ""
">>> ts = TopologicalSorter()\n"
">>> ts.add(3, 2, 1)\n"
">>> ts.add(1, 0)\n"
">>> print([*ts.static_order()])\n"
"[2, 0, 1, 3]\n"
"\n"
">>> ts2 = TopologicalSorter()\n"
">>> ts2.add(1, 0)\n"
">>> ts2.add(3, 2, 1)\n"
">>> print([*ts2.static_order()])\n"
"[0, 2, 1, 3]"
msgstr ""

#: ../../library/graphlib.rst:186
msgid ""
"This is due to the fact that \"0\" and \"2\" are in the same level in the"
" graph (they would have been returned in the same call to "
":meth:`~TopologicalSorter.get_ready`) and the order between them is "
"determined by the order of insertion."
msgstr ""
"이것은 그래프에서 \"0\"과 \"2\"가 같은 수준에 있고 "
"(:meth:`~TopologicalSorter.get_ready`\\에 대한 같은 호출에서 반환됩니다) 이들 간의 순서는 삽입 "
"순서에 따라 결정되기 때문입니다."

#: ../../library/graphlib.rst:192
msgid "If any cycle is detected, :exc:`CycleError` will be raised."
msgstr "순환이 감지되면 :exc:`CycleError`\\가 발생합니다."

#: ../../library/graphlib.rst:198
msgid "Exceptions"
msgstr "예외"

#: ../../library/graphlib.rst:199
msgid "The :mod:`graphlib` module defines the following exception classes:"
msgstr ":mod:`graphlib` 모듈은 다음 예외를 정의합니다:"

#: ../../library/graphlib.rst:203
msgid ""
"Subclass of :exc:`ValueError` raised by :meth:`TopologicalSorter.prepare`"
" if cycles exist in the working graph. If multiple cycles exist, only one"
" undefined choice among them will be reported and included in the "
"exception."
msgstr ""
"작업 그래프에 순환이 있으면 :meth:`TopologicalSorter.prepare`\\가 발생시키는 "
":exc:`ValueError`\\의 서브 클래스. 여러 순환이 존재하면, 그들 중 오직 하나의 정의되지 않은 선택만 보고되고 "
"예외에 포함됩니다."

#: ../../library/graphlib.rst:207
#, fuzzy
msgid ""
"The detected cycle can be accessed via the second element in the "
":attr:`~BaseException.args` attribute of the exception instance and "
"consists in a list of nodes, such that each node is, in the graph, an "
"immediate predecessor of the next node in the list. In the reported list,"
" the first and the last node will be the same, to make it clear that it "
"is cyclic."
msgstr ""
"감지된 순환은 예외 인스턴스의 :attr:`~CycleError.args` 속성에서 두 번째 요소를 통해 액세스 할 수 있으며 각 "
"노드가 그래프에서 리스트에 있는 다음 노드의 직전 선행 노드가 되도록 노드 리스트로 구성됩니다. 보고된 리스트에서, 순환임을 분명히"
" 하기 위해, 처음과 마지막 노드는 같습니다."

