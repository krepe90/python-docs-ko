# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/cmd.rst:2
#, fuzzy
msgid ":mod:`!cmd` --- Support for line-oriented command interpreters"
msgstr ":mod:`cmd` --- 줄 지향 명령 인터프리터 지원"

#: ../../library/cmd.rst:9
msgid "**Source code:** :source:`Lib/cmd.py`"
msgstr "**소스 코드:** :source:`Lib/cmd.py`"

#: ../../library/cmd.rst:13
msgid ""
"The :class:`Cmd` class provides a simple framework for writing line-"
"oriented command interpreters.  These are often useful for test "
"harnesses, administrative tools, and prototypes that will later be "
"wrapped in a more sophisticated interface."
msgstr ""
":class:`Cmd` 클래스는 줄 지향 명령 인터프리터를 작성하기 위한 간단한 프레임워크를 제공합니다. 이것들은 종종 테스트 "
"하네스(test harnesses), 관리 도구 및 나중에 더 복잡한 인터페이스로 포장될 프로토타입에 유용합니다."

#: ../../library/cmd.rst:20
msgid ""
"A :class:`Cmd` instance or subclass instance is a line-oriented "
"interpreter framework.  There is no good reason to instantiate "
":class:`Cmd` itself; rather, it's useful as a superclass of an "
"interpreter class you define yourself in order to inherit :class:`Cmd`'s "
"methods and encapsulate action methods."
msgstr ""
":class:`Cmd` 인스턴스나 서브 클래스 인스턴스는 줄 지향 인터프리터 프레임워크입니다. :class:`Cmd` 자체를 "
"인스턴스로 만들 이유는 없습니다; 그보다는, :class:`Cmd`\\의 메서드를 상속하고 액션 메서드를 캡슐화하기 위해 여러분 "
"스스로 정의한 인터프리터 클래스의 슈퍼 클래스로 유용합니다."

#: ../../library/cmd.rst:25
msgid ""
"The optional argument *completekey* is the :mod:`readline` name of a "
"completion key; it defaults to :kbd:`Tab`. If *completekey* is not "
":const:`None` and :mod:`readline` is available, command completion is "
"done automatically."
msgstr ""
"선택적 인자 *completekey*\\는 완성 키(completion key)의 :mod:`readline` 이름입니다; 기본값은"
" :kbd:`Tab`\\입니다. *completekey*\\가 :const:`None`\\이 아니고 "
":mod:`readline`\\을 사용할 수 있으면, 명령 완성이 자동으로 수행됩니다."

#: ../../library/cmd.rst:29
msgid ""
"The default, ``'tab'``, is treated specially, so that it refers to the "
":kbd:`Tab` key on every :data:`readline.backend`. Specifically, if "
":data:`readline.backend` is ``editline``, ``Cmd`` will use ``'^I'`` "
"instead of ``'tab'``. Note that other values are not treated this way, "
"and might only work with a specific backend."
msgstr ""

#: ../../library/cmd.rst:36
msgid ""
"The optional arguments *stdin* and *stdout* specify the  input and output"
" file objects that the Cmd instance or subclass  instance will use for "
"input and output. If not specified, they will default to "
":data:`sys.stdin` and :data:`sys.stdout`."
msgstr ""
"선택적 인자 *stdin*\\과 *stdout*\\은 Cmd 인스턴스나 서브 클래스 인스턴스가 입출력에 사용할 입력과 출력 파일 "
"객체를 지정합니다. 지정하지 않으면, 기본적으로 :data:`sys.stdin`\\과 :data:`sys.stdout`\\이 "
"됩니다."

#: ../../library/cmd.rst:41
msgid ""
"If you want a given *stdin* to be used, make sure to set the instance's "
":attr:`use_rawinput` attribute to ``False``, otherwise *stdin* will be "
"ignored."
msgstr ""
"지정된 *stdin*\\을 사용하려면, 인스턴스의 :attr:`use_rawinput` 어트리뷰트를 ``False``\\로 설정해야"
" 합니다, 그렇지 않으면 *stdin*\\이 무시됩니다."

#: ../../library/cmd.rst:45
msgid "``completekey='tab'`` is replaced by ``'^I'`` for ``editline``."
msgstr ""

#: ../../library/cmd.rst:52
msgid "Cmd Objects"
msgstr "Cmd 객체"

#: ../../library/cmd.rst:54
msgid "A :class:`Cmd` instance has the following methods:"
msgstr ":class:`Cmd` 인스턴스에는 다음과 같은 메서드가 있습니다:"

#: ../../library/cmd.rst:59
msgid ""
"Repeatedly issue a prompt, accept input, parse an initial prefix off the "
"received input, and dispatch to action methods, passing them the "
"remainder of the line as argument."
msgstr ""
"반복해서 프롬프트를 제시하고, 입력을 받아들이고, 수신된 입력에서 초기 접두사를 구문 분석하고, 줄의 나머지 부분을 인자로 전달해서"
" 액션 메서드를 호출합니다."

#: ../../library/cmd.rst:63
msgid ""
"The optional argument is a banner or intro string to be issued before the"
" first prompt (this overrides the :attr:`intro` class attribute)."
msgstr ""
"선택적 인자는 첫 번째 프롬프트 전에 제시할 배너나 소개 문자열입니다 (이것은 :attr:`intro` 클래스 어트리뷰트를 "
"재정의합니다)."

#: ../../library/cmd.rst:66
msgid ""
"If the :mod:`readline` module is loaded, input will automatically inherit"
" :program:`bash`\\ -like history-list editing (e.g. :kbd:`Control-P` "
"scrolls back to the last command, :kbd:`Control-N` forward to the next "
"one, :kbd:`Control-F` moves the cursor to the right non-destructively, "
":kbd:`Control-B` moves the cursor to the left non-destructively, etc.)."
msgstr ""
":mod:`readline` 모듈이 로드되면, 입력은 자동으로 :program:`bash`\\와 유사한 히스토리 목록 편집을 "
"상속합니다 (예를 들어, :kbd:`Control-P`\\는 직전 명령으로 돌아가고(scroll back), "
":kbd:`Control-N`\\은 다음 명령으로 이동하고(forward), :kbd:`Control-F`\\는 커서를 비파괴적으로"
" 오른쪽으로 이동하고, :kbd:`Control-B`\\는 커서를 비파괴적으로 왼쪽으로 이동하고, 등등)."

#: ../../library/cmd.rst:72
msgid "An end-of-file on input is passed back as the string ``'EOF'``."
msgstr "입력의 파일 끝(end-of-file)은 문자열 ``'EOF'``\\로 전달됩니다."

#: ../../library/cmd.rst:78
#, fuzzy
msgid ""
"An interpreter instance will recognize a command name ``foo`` if and only"
" if it has a method :meth:`!do_foo`.  As a special case, a line beginning"
" with the character ``'?'`` is dispatched to the method :meth:`do_help`."
"  As another special case, a line beginning with the character ``'!'`` is"
" dispatched to the method :meth:`!do_shell` (if such a method is "
"defined)."
msgstr ""
"인터프리터 인스턴스는 메서드 :meth:`do_foo`\\가 있을 때만 명령 이름 ``foo``\\를 인식합니다. 특수한 경우로, "
"문자 ``'?'``\\로 시작하는 줄은 메서드 :meth:`do_help`\\를 호출합니다. 또 다른 특수한 경우로, 문자 "
"``'!'``\\로 시작하는 줄은 메서드 :meth:`do_shell`\\을 (해당 메서드가 정의되었다면) 호출합니다."

#: ../../library/cmd.rst:84
#, fuzzy
msgid ""
"This method will return when the :meth:`postcmd` method returns a true "
"value. The *stop* argument to :meth:`postcmd` is the return value from "
"the command's corresponding :meth:`!do_\\*` method."
msgstr ""
"이 메서드는 :meth:`postcmd` 메서드가 참값을 반환할 때 반환합니다. :meth:`postcmd`\\에 대한 *stop*"
" 인자는 명령의 해당 :meth:`do_\\*` 메서드에서 반환되는 값입니다."

#: ../../library/cmd.rst:88
#, fuzzy
msgid ""
"If completion is enabled, completing commands will be done automatically,"
" and completing of commands args is done by calling :meth:`!complete_foo`"
" with arguments *text*, *line*, *begidx*, and *endidx*.  *text* is the "
"string prefix we are attempting to match: all returned matches must begin"
" with it. *line* is the current input line with leading whitespace "
"removed, *begidx* and *endidx* are the beginning and ending indexes of "
"the prefix text, which could be used to provide different completion "
"depending upon which position the argument is in."
msgstr ""
"완성(completion)이 활성화되면, 명령 완성이 자동으로 수행되고, 명령 인자의 완성은 인자 *text*, *line*, "
"*begidx* 및 *endidx*\\로 :meth:`complete_foo`\\를 호출하여 수행됩니다. *text*\\는 "
"일치시키려는 문자열 접두사입니다: 반환된 모든 일치는 이 문자열로 시작해야 합니다. *line*\\은 선행 공백이 제거된 현재 입력"
" 줄이며, *begidx*\\와 *endidx*\\는 접두사 텍스트의 시작과 끝 인덱스로, 인자의 위치에 따라 다른 완성을 제공하는"
" 데 사용될 수 있습니다."

#: ../../library/cmd.rst:99
#, fuzzy
msgid ""
"All subclasses of :class:`Cmd` inherit a predefined :meth:`!do_help`.  "
"This method, called with an argument ``'bar'``, invokes the corresponding"
" method :meth:`!help_bar`, and if that is not present, prints the "
"docstring of :meth:`!do_bar`, if available.  With no argument, "
":meth:`!do_help` lists all available help topics (that is, all commands "
"with corresponding :meth:`!help_\\*` methods or commands that have "
"docstrings), and also lists any undocumented commands."
msgstr ""
":class:`Cmd`\\의 모든 서브 클래스는 미리 정의된 :meth:`do_help`\\를 상속합니다. 인자 "
"``'bar'``\\로 호출되면, 이 메서드는 해당 메서드 :meth:`help_bar`\\를 호출하고, 존재하지 않으면 "
":meth:`do_bar`\\의 독스트링이 있다면 인쇄합니다. 인자가 없으면, :meth:`do_help`\\는 사용 가능한 모든 "
"도움말 주제(즉, 해당 :meth:`help_\\*` 메서드가 있거나 독스트링이 있는 모든 명령)을 나열하고, 설명이 없는 명령도 "
"나열합니다."

#: ../../library/cmd.rst:110
#, fuzzy
msgid ""
"Interpret the argument as though it had been typed in response to the "
"prompt. This may be overridden, but should not normally need to be; see "
"the :meth:`precmd` and :meth:`postcmd` methods for useful execution "
"hooks.  The return value is a flag indicating whether interpretation of "
"commands by the interpreter should stop.  If there is a :meth:`!do_\\*` "
"method for the command *str*, the return value of that method is "
"returned, otherwise the return value from the :meth:`default` method is "
"returned."
msgstr ""
"프롬프트에 대한 응답으로 입력된 것처럼 인자를 해석합니다. 재정의될 수도 있지만, 일반적으로 그럴 필요가 없어야 합니다; 유용한 "
"실행 훅에 대해서는 :meth:`precmd`\\와 :meth:`postcmd` 메서드를 참조하십시오. 반환 값은 인터프리터의 명령"
" 해석이 중지되어야 하는지를 나타내는 플래그입니다. 명령 *str*\\을 위한 :meth:`do_\\*` 메서드가 있으면, 해당 "
"메서드의 반환 값이 반환되고, 그렇지 않으면 :meth:`default` 메서드의 반환 값이 반환됩니다."

#: ../../library/cmd.rst:121
msgid ""
"Method called when an empty line is entered in response to the prompt. If"
" this method is not overridden, it repeats the last nonempty command "
"entered."
msgstr ""
"프롬프트에 응답하여 빈 줄을 입력할 때 호출되는 메서드. 이 메서드를 재정의하지 않으면, 입력된 마지막 비어 있지 않은 명령을 "
"반복합니다."

#: ../../library/cmd.rst:127
msgid ""
"Method called on an input line when the command prefix is not recognized."
" If this method is not overridden, it prints an error message and "
"returns."
msgstr "명령 접두사가 인식되지 않을 때 입력 줄로 호출되는 메서드. 이 메서드를 재정의하지 않으면, 에러 메시지를 인쇄하고 반환합니다."

#: ../../library/cmd.rst:133
#, fuzzy
msgid ""
"Method called to complete an input line when no command-specific "
":meth:`!complete_\\*` method is available.  By default, it returns an "
"empty list."
msgstr ""
"명령 별 :meth:`complete_\\*` 메서드가 없을 때 입력 줄을 완성하기 위해 호출되는 메서드. 기본적으로, 빈 리스트를"
" 반환합니다."

#: ../../library/cmd.rst:139
msgid ""
"Method called to display a list of strings as a compact set of columns. "
"Each column is only as wide as necessary. Columns are separated by two "
"spaces for readability."
msgstr ""

#: ../../library/cmd.rst:146
msgid ""
"Hook method executed just before the command line *line* is interpreted, "
"but after the input prompt is generated and issued.  This method is a "
"stub in :class:`Cmd`; it exists to be overridden by subclasses.  The "
"return value is used as the command which will be executed by the "
":meth:`onecmd` method; the :meth:`precmd` implementation may re-write the"
" command or simply return *line* unchanged."
msgstr ""
"명령 줄 *line*\\을 해석하기 직전에, 하지만 입력 프롬프트가 생성되고 제시된 후에 실행되는 훅 메서드. 이 메서드는 "
":class:`Cmd`\\에서는 스텁(stub)입니다; 서브 클래스에 의해 재정의되기 위해 존재합니다. 반환 값은 "
":meth:`onecmd` 메서드에 의해 실행될 명령으로 사용됩니다; :meth:`precmd` 구현은 명령을 다시 쓰거나 단순히 "
"*line*\\을 변경하지 않고 반환 할 수 있습니다."

#: ../../library/cmd.rst:156
msgid ""
"Hook method executed just after a command dispatch is finished.  This "
"method is a stub in :class:`Cmd`; it exists to be overridden by "
"subclasses.  *line* is the command line which was executed, and *stop* is"
" a flag which indicates whether execution will be terminated after the "
"call to :meth:`postcmd`; this will be the return value of the "
":meth:`onecmd` method.  The return value of this method will be used as "
"the new value for the internal flag which corresponds to *stop*; "
"returning false will cause interpretation to continue."
msgstr ""
"명령 호출이 완료된 직후에 실행되는 훅 메서드. 이 메서는 :class:`Cmd`\\에서는 스텁(stub)입니다; 서브 클래스에 "
"의해 재정의되기 위해 존재합니다. *line*\\은 실행된 명령 줄이고, *stop*\\은 :meth:`postcmd`\\를 호출한"
" 후 실행이 종료될지를 나타내는 플래그입니다; 이것은 :meth:`onecmd` 메서드의 반환 값입니다. 이 메서드의 반환 값은 "
"*stop*\\에 해당하는 내부 플래그의 새 값으로 사용됩니다; 거짓을 반환하면 해석이 계속됩니다."

#: ../../library/cmd.rst:167
msgid ""
"Hook method executed once when :meth:`cmdloop` is called.  This method is"
" a stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr ""
":meth:`cmdloop`\\가 호출될 때 한 번 실행되는 훅 메서드. 이 메서드는 :class:`Cmd`\\에서는 "
"스텁(stub)입니다; 서브 클래스에 의해 재정의되기 위해 존재합니다."

#: ../../library/cmd.rst:173
msgid ""
"Hook method executed once when :meth:`cmdloop` is about to return. This "
"method is a stub in :class:`Cmd`; it exists to be overridden by "
"subclasses."
msgstr ""
":meth:`cmdloop`\\가 반환하려고 할 때 한 번 실행되는 훅 메서드. 이 메서드는 :class:`Cmd`\\에서는 "
"스텁(stub)입니다; 서브 클래스에 의해 재정의되기 위해 존재합니다."

#: ../../library/cmd.rst:177
msgid "Instances of :class:`Cmd` subclasses have some public instance variables:"
msgstr ":class:`Cmd` 서브 클래스의 인스턴스에는 몇 가지 공용 인스턴스 변수가 있습니다:"

#: ../../library/cmd.rst:181
msgid "The prompt issued to solicit input."
msgstr "입력을 요청하는 프롬프트."

#: ../../library/cmd.rst:186
msgid "The string of characters accepted for the command prefix."
msgstr "명령 접두사에 허용되는 문자들의 문자열."

#: ../../library/cmd.rst:191
msgid "The last nonempty command prefix seen."
msgstr "비어 있지 않은 마지막 명령 접두사."

#: ../../library/cmd.rst:196
msgid ""
"A list of queued input lines.  The cmdqueue list is checked in "
":meth:`cmdloop` when new input is needed; if it is nonempty, its elements"
" will be processed in order, as if entered at the prompt."
msgstr ""
"계류 중인 입력 줄의 리스트. cmdqueue 리스트는 새로운 입력이 필요할 때 :meth:`cmdloop`\\에서 점검됩니다; "
"비어 있지 않으면, 프롬프트에서 입력한 것처럼 해당 요소가 순서대로 처리됩니다."

#: ../../library/cmd.rst:203
msgid ""
"A string to issue as an intro or banner.  May be overridden by giving the"
" :meth:`cmdloop` method an argument."
msgstr "소개나 배너로 제시할 문자열. :meth:`cmdloop` 메서드에 인자를 제공하여 재정의할 수 있습니다."

#: ../../library/cmd.rst:209
msgid ""
"The header to issue if the help output has a section for documented "
"commands."
msgstr "도움말 출력에 설명된 명령 섹션이 있을 때 제시할 헤더입니다."

#: ../../library/cmd.rst:214
#, fuzzy
msgid ""
"The header to issue if the help output has a section for miscellaneous  "
"help topics (that is, there are :meth:`!help_\\*` methods without "
"corresponding :meth:`!do_\\*` methods)."
msgstr ""
"도움말 출력에 기타 도움말 주제에 대한 섹션이 있을 때 제시할 헤더 (즉, 해당 :meth:`do_\\*` 메서드가 없는 "
":meth:`help_\\*` 메서드가 있을 때)."

#: ../../library/cmd.rst:221
#, fuzzy
msgid ""
"The header to issue if the help output has a section for undocumented  "
"commands (that is, there are :meth:`!do_\\*` methods without "
"corresponding :meth:`!help_\\*` methods)."
msgstr ""
"도움말 출력에 설명되지 않은 명령에 대한 섹션이 있을 때 제시할 헤더 (즉, 해당 :meth:`help_\\*` 메서드가 없는 "
":meth:`do_\\*` 메서드가 있을 때)."

#: ../../library/cmd.rst:228
msgid ""
"The character used to draw separator lines under the help-message "
"headers.  If empty, no ruler line is drawn.  It defaults to ``'='``."
msgstr ""
"도움말 메시지 헤더 아래에 구분선을 그리는 데 사용되는 문자입니다. 비어 있으면, 눈금자 선이 그려지지 않습니다. 기본값은 "
"``'='``\\입니다."

#: ../../library/cmd.rst:234
#, fuzzy
msgid ""
"A flag, defaulting to true.  If true, :meth:`cmdloop` uses :func:`input` "
"to display a prompt and read the next command; if false, "
":data:`sys.stdout.write() <sys.stdout>` and :data:`sys.stdin.readline() "
"<sys.stdin>` are used. (This means that by importing :mod:`readline`, on "
"systems that support it, the interpreter will automatically support "
":program:`Emacs`\\ -like line editing  and command-history keystrokes.)"
msgstr ""
"기본값이 참인 플래그. 참이면, :meth:`cmdloop`\\는 :func:`input`\\을 사용하여 프롬프트를 표시하고 다음 "
"명령을 읽습니다; 거짓이면, :meth:`sys.stdout.write`\\와 :meth:`sys.stdin.readline`\\이"
" 사용됩니다. (이는 지원하는 시스템에서 :mod:`readline`\\를 임포트 함으로써, 인터프리터가 "
":program:`Emacs`\\와 유사한 줄 편집과 명령 히스토리 키 입력을 자동으로 지원한다는 의미입니다.)"

#: ../../library/cmd.rst:244
msgid "Cmd Example"
msgstr "Cmd 예"

#: ../../library/cmd.rst:248
msgid ""
"The :mod:`cmd` module is mainly useful for building custom shells that "
"let a user work with a program interactively."
msgstr ":mod:`cmd` 모듈은 주로 사용자가 대화식으로 프로그램을 사용할 수 있도록 하는 사용자 정의 셸을 만드는 데 유용합니다."

#: ../../library/cmd.rst:251
msgid ""
"This section presents a simple example of how to build a shell around a "
"few of the commands in the :mod:`turtle` module."
msgstr "이 섹션에서는 :mod:`turtle` 모듈의 몇 가지 명령을 중심으로 셸을 작성하는 방법에 대한 간단한 예를 제공합니다."

#: ../../library/cmd.rst:254
#, fuzzy
msgid ""
"Basic turtle commands such as :meth:`~turtle.forward` are added to a "
":class:`Cmd` subclass with method named :meth:`!do_forward`.  The "
"argument is converted to a number and dispatched to the turtle module.  "
"The docstring is used in the help utility provided by the shell."
msgstr ""
":meth:`~turtle.forward`\\와 같은 기본 turtle 명령은 :meth:`do_forward`\\라는 메서드로 "
":class:`Cmd` 서브 클래스에 추가됩니다. 인자는 숫자로 변환되어 turtle 모듈로 전달됩니다. 독스트링은 셸에서 제공하는"
" 도움말 유틸리티에서 사용됩니다."

#: ../../library/cmd.rst:259
#, fuzzy
msgid ""
"The example also includes a basic record and playback facility "
"implemented with the :meth:`~Cmd.precmd` method which is responsible for "
"converting the input to lowercase and writing the commands to a file.  "
"The :meth:`!do_playback` method reads the file and adds the recorded "
"commands to the :attr:`~Cmd.cmdqueue` for immediate playback::"
msgstr ""
"이 예제에는 :meth:`~Cmd.precmd` 메서드로 구현된 기초적인 녹화와 재생 기능도 포함되는데, 이 메서드는 입력을 "
"소문자로 변환하고 명령을 파일에 쓰는 역할을 합니다. :meth:`do_playback` 메서드는 파일을 읽고 즉시 재생하기 위해 "
"녹화된 명령을 :attr:`cmdqueue`\\에 추가합니다::"

#: ../../library/cmd.rst:265
#, python-format
msgid ""
"import cmd, sys\n"
"from turtle import *\n"
"\n"
"class TurtleShell(cmd.Cmd):\n"
"    intro = 'Welcome to the turtle shell.   Type help or ? to list "
"commands.\\n'\n"
"    prompt = '(turtle) '\n"
"    file = None\n"
"\n"
"    # ----- basic turtle commands -----\n"
"    def do_forward(self, arg):\n"
"        'Move the turtle forward by the specified distance:  FORWARD 10'\n"
"        forward(*parse(arg))\n"
"    def do_right(self, arg):\n"
"        'Turn turtle right by given number of degrees:  RIGHT 20'\n"
"        right(*parse(arg))\n"
"    def do_left(self, arg):\n"
"        'Turn turtle left by given number of degrees:  LEFT 90'\n"
"        left(*parse(arg))\n"
"    def do_goto(self, arg):\n"
"        'Move turtle to an absolute position with changing orientation.  "
"GOTO 100 200'\n"
"        goto(*parse(arg))\n"
"    def do_home(self, arg):\n"
"        'Return turtle to the home position:  HOME'\n"
"        home()\n"
"    def do_circle(self, arg):\n"
"        'Draw circle with given radius an options extent and steps:  "
"CIRCLE 50'\n"
"        circle(*parse(arg))\n"
"    def do_position(self, arg):\n"
"        'Print the current turtle position:  POSITION'\n"
"        print('Current position is %d %d\\n' % position())\n"
"    def do_heading(self, arg):\n"
"        'Print the current turtle heading in degrees:  HEADING'\n"
"        print('Current heading is %d\\n' % (heading(),))\n"
"    def do_color(self, arg):\n"
"        'Set the color:  COLOR BLUE'\n"
"        color(arg.lower())\n"
"    def do_undo(self, arg):\n"
"        'Undo (repeatedly) the last turtle action(s):  UNDO'\n"
"    def do_reset(self, arg):\n"
"        'Clear the screen and return turtle to center:  RESET'\n"
"        reset()\n"
"    def do_bye(self, arg):\n"
"        'Stop recording, close the turtle window, and exit:  BYE'\n"
"        print('Thank you for using Turtle')\n"
"        self.close()\n"
"        bye()\n"
"        return True\n"
"\n"
"    # ----- record and playback -----\n"
"    def do_record(self, arg):\n"
"        'Save future commands to filename:  RECORD rose.cmd'\n"
"        self.file = open(arg, 'w')\n"
"    def do_playback(self, arg):\n"
"        'Playback commands from a file:  PLAYBACK rose.cmd'\n"
"        self.close()\n"
"        with open(arg) as f:\n"
"            self.cmdqueue.extend(f.read().splitlines())\n"
"    def precmd(self, line):\n"
"        line = line.lower()\n"
"        if self.file and 'playback' not in line:\n"
"            print(line, file=self.file)\n"
"        return line\n"
"    def close(self):\n"
"        if self.file:\n"
"            self.file.close()\n"
"            self.file = None\n"
"\n"
"def parse(arg):\n"
"    'Convert a series of zero or more numbers to an argument tuple'\n"
"    return tuple(map(int, arg.split()))\n"
"\n"
"if __name__ == '__main__':\n"
"    TurtleShell().cmdloop()"
msgstr ""

#: ../../library/cmd.rst:340
msgid ""
"Here is a sample session with the turtle shell showing the help "
"functions, using blank lines to repeat commands, and the simple record "
"and playback facility:"
msgstr ""
"다음은 도움말 기능과, 명령을 반복하기 위해 빈 줄을 사용하는 방법과, 간단한 녹화와 재생기능을 보여주기 위해 turtle 셀을 "
"사용한 예제 세션입니다:"

#: ../../library/cmd.rst:343
msgid ""
"Welcome to the turtle shell.   Type help or ? to list commands.\n"
"\n"
"(turtle) ?\n"
"\n"
"Documented commands (type help <topic>):\n"
"========================================\n"
"bye     color    goto     home  playback  record  right\n"
"circle  forward  heading  left  position  reset   undo\n"
"\n"
"(turtle) help forward\n"
"Move the turtle forward by the specified distance:  FORWARD 10\n"
"(turtle) record spiral.cmd\n"
"(turtle) position\n"
"Current position is 0 0\n"
"\n"
"(turtle) heading\n"
"Current heading is 0\n"
"\n"
"(turtle) reset\n"
"(turtle) circle 20\n"
"(turtle) right 30\n"
"(turtle) circle 40\n"
"(turtle) right 30\n"
"(turtle) circle 60\n"
"(turtle) right 30\n"
"(turtle) circle 80\n"
"(turtle) right 30\n"
"(turtle) circle 100\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) heading\n"
"Current heading is 180\n"
"\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 500\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 300\n"
"(turtle) playback spiral.cmd\n"
"Current position is 0 0\n"
"\n"
"Current heading is 0\n"
"\n"
"Current heading is 180\n"
"\n"
"(turtle) bye\n"
"Thank you for using Turtle"
msgstr ""

#: ../../library/cmd.rst:74
msgid "? (question mark)"
msgstr ""

#: ../../library/cmd.rst:74
msgid "in a command interpreter"
msgstr ""

#: ../../library/cmd.rst:74
msgid "! (exclamation)"
msgstr ""

