# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/wsgiref.rst:2
msgid ":mod:`!wsgiref` --- WSGI Utilities and Reference Implementation"
msgstr ":mod:`!wsgiref` --- WSGI 유틸리티와 참조 구현"

#: ../../library/wsgiref.rst:10
msgid "**Source code:** :source:`Lib/wsgiref`"
msgstr "**소스 코드:** :source:`Lib/wsgiref`"

#: ../../library/wsgiref.rst:14
msgid ""
"The Web Server Gateway Interface (WSGI) is a standard interface between "
"web server software and web applications written in Python. Having a "
"standard interface makes it easy to use an application that supports WSGI"
" with a number of different web servers."
msgstr ""
"WSGI(Web Server Gateway Interface)는 웹 서버 소프트웨어와 파이썬으로 작성된 웹 응용 프로그램 간의 표준"
" 인터페이스입니다. 표준 인터페이스는 여러 웹 서버에서 WSGI를 지원하는 응용 프로그램을 쉽게 사용할 수 있도록 합니다."

#: ../../library/wsgiref.rst:19
msgid ""
"Only authors of web servers and programming frameworks need to know every"
" detail and corner case of the WSGI design.  You don't need to understand"
" every detail of WSGI just to install a WSGI application or to write a "
"web application using an existing framework."
msgstr ""
"웹 서버와 프로그래밍 프레임워크의 작성자만 WSGI 설계의 모든 세부 사항과 코너 케이스를 알 필요가 있습니다. 단지 WSGI 응용"
" 프로그램을 설치하거나 기존 프레임워크를 사용하여 웹 응용 프로그램을 작성하기 위해, WSGI의 모든 세부 사항을 이해할 필요는 "
"없습니다."

#: ../../library/wsgiref.rst:24
msgid ""
":mod:`wsgiref` is a reference implementation of the WSGI specification "
"that can be used to add WSGI support to a web server or framework.  It "
"provides utilities for manipulating WSGI environment variables and "
"response headers, base classes for implementing WSGI servers, a demo HTTP"
" server that serves WSGI applications, types for static type checking, "
"and a validation tool that checks WSGI servers and applications for "
"conformance to the WSGI specification (:pep:`3333`)."
msgstr ""
":mod:`wsgiref`\\는 웹 서버나 프레임워크에 WSGI 지원을 추가하는 데 사용할 수 있는, WSGI 명세의 참조 "
"구현입니다. WSGI 환경 변수와 응답 헤더를 조작하는 유틸리티, WSGI 서버 구현을 위한 베이스 클래스, WSGI 응용 "
"프로그램을 서비스하는 데모 HTTP 서버, 정적 형 검사를 위한 형 및 WSGI 서버와 응용 프로그램이 WSGI "
"명세(:pep:`3333`)에 부합하는지 확인하는 유효성 검사 도구를 제공합니다."

#: ../../library/wsgiref.rst:32
msgid ""
"See `wsgi.readthedocs.io <https://wsgi.readthedocs.io/>`_ for more "
"information about WSGI, and links to tutorials and other resources."
msgstr ""
"WSGI에 대한 더 자세한 정보 및 자습서와 기타 자원에 대한 링크는 `wsgi.readthedocs.io "
"<https://wsgi.readthedocs.io/>`_\\를 참조하십시오."

#: ../../library/wsgiref.rst:39
msgid ":mod:`wsgiref.util` -- WSGI environment utilities"
msgstr ":mod:`wsgiref.util` -- WSGI 환경 유틸리티"

#: ../../library/wsgiref.rst:45
msgid ""
"This module provides a variety of utility functions for working with WSGI"
" environments.  A WSGI environment is a dictionary containing HTTP "
"request variables as described in :pep:`3333`.  All of the functions "
"taking an *environ* parameter expect a WSGI-compliant dictionary to be "
"supplied; please see :pep:`3333` for a detailed specification and "
":data:`~wsgiref.types.WSGIEnvironment` for a type alias that can be used "
"in type annotations."
msgstr ""
"이 모듈은 WSGI 환경으로 작업하기 위한 다양한 유틸리티 함수를 제공합니다. WSGI 환경은 :pep:`3333`\\에서 설명한 "
"대로 HTTP 요청 변수를 포함하는 딕셔너리입니다. *environ* 매개 변수를 취하는 모든 함수는 WSGI 호환 딕셔너리가 "
"제공될 것으로 기대합니다; 자세한 명세는 :pep:`3333`\\를 형 어노테이션에 사용할 수 있는 형 에일리어스는 "
":data:`~wsgiref.types.WSGIEnvironment`\\를 참조하십시오."

#: ../../library/wsgiref.rst:56
msgid ""
"Return a guess for whether ``wsgi.url_scheme`` should be \"http\" or "
"\"https\", by checking for a ``HTTPS`` environment variable in the "
"*environ* dictionary.  The return value is a string."
msgstr ""
"*environ* 딕셔너리에서 ``HTTPS`` 환경 변수를 검사하여 ``wsgi.url_scheme``\\이 \"http\"와 "
"\"https\" 중 어느 것인지 추측합니다. 반환 값은 문자열입니다."

#: ../../library/wsgiref.rst:60
msgid ""
"This function is useful when creating a gateway that wraps CGI or a CGI-"
"like protocol such as FastCGI.  Typically, servers providing such "
"protocols will include a ``HTTPS`` variable with a value of \"1\", "
"\"yes\", or \"on\" when a request is received via SSL.  So, this function"
" returns \"https\" if such a value is found, and \"http\" otherwise."
msgstr ""
"이 함수는 CGI 나 FastCGI와 같은 CGI와 유사한 프로토콜을 감싸는 게이트웨이를 만들 때 유용합니다. 일반적으로, 이러한 "
"프로토콜을 제공하는 서버는 SSL을 통해 요청이 수신될 때 \"1\", \"yes\" 또는 \"on\" 값을 갖는 ``HTTPS``"
" 변수를 포함합니다. 따라서, 이 함수는 그런 값을 발견하면 \"https\"를 반환하고, 그렇지 않으면 \"http\"를 "
"반환합니다."

#: ../../library/wsgiref.rst:69
msgid ""
"Return the full request URI, optionally including the query string, using"
" the algorithm found in the \"URL Reconstruction\" section of "
":pep:`3333`.  If *include_query* is false, the query string is not "
"included in the resulting URI."
msgstr ""
":pep:`3333`\\의 \"URL 재구성\" 절에 있는 알고리즘을 사용하여 전체 요청 URI를 반환합니다. 선택적으로 질의 "
"문자열(query string)을 포함합니다. *include_query*\\가 거짓이면 질의 문자열은 결과 URI에 포함되지 "
"않습니다."

#: ../../library/wsgiref.rst:76
msgid ""
"Similar to :func:`request_uri`, except that the ``PATH_INFO`` and "
"``QUERY_STRING`` variables are ignored.  The result is the base URI of "
"the application object addressed by the request."
msgstr ""
"``PATH_INFO`` 와 ``QUERY_STRING`` 변수가 무시된다는 점을 제외하면 :func:`request_uri`\\와"
" 유사합니다. 결과는 요청이 가리키는 응용 프로그램 객체의 기본 URI입니다."

#: ../../library/wsgiref.rst:83
msgid ""
"Shift a single name from ``PATH_INFO`` to ``SCRIPT_NAME`` and return the "
"name. The *environ* dictionary is *modified* in-place; use a copy if you "
"need to keep the original ``PATH_INFO`` or ``SCRIPT_NAME`` intact."
msgstr ""
"단일 이름을 ``PATH_INFO``\\에서 ``SCRIPT_NAME``\\로 이동하고 이름을 반환합니다. *environ* "
"딕셔너리는 그 자리에서 *수정*\\됩니다; 원본 ``PATH_INFO`` 나 ``SCRIPT_NAME``\\를 그대로 유지해야 하면"
" 사본을 사용하십시오."

#: ../../library/wsgiref.rst:87
msgid ""
"If there are no remaining path segments in ``PATH_INFO``, ``None`` is "
"returned."
msgstr "``PATH_INFO``\\에 남아있는 경로 세그먼트가 없으면, ``None``\\이 반환됩니다."

#: ../../library/wsgiref.rst:89
msgid ""
"Typically, this routine is used to process each portion of a request URI "
"path, for example to treat the path as a series of dictionary keys. This "
"routine modifies the passed-in environment to make it suitable for "
"invoking another WSGI application that is located at the target URI. For "
"example, if there is a WSGI application at ``/foo``, and the request URI "
"path is ``/foo/bar/baz``, and the WSGI application at ``/foo`` calls "
":func:`shift_path_info`, it will receive the string \"bar\", and the "
"environment will be updated to be suitable for passing to a WSGI "
"application at ``/foo/bar``.  That is, ``SCRIPT_NAME`` will change from "
"``/foo`` to ``/foo/bar``, and ``PATH_INFO`` will change from ``/bar/baz``"
" to ``/baz``."
msgstr ""
"일반적으로, 이 루틴은 요청 URI 경로의 각 부분을 처리하는 데 사용됩니다, 예를 들어 경로를 일련의 딕셔너리 키로 취급합니다. "
"이 루틴은 전달된 환경을 수정하여 대상 URI에 있는 다른 WSGI 응용 프로그램을 호출하는 데 적합하게 만듭니다. 예를 들어, "
"``/foo``\\에 WSGI 응용 프로그램이 있고, 요청 URI 경로가 ``/foo/bar/baz``\\이고, "
"``/foo``\\의 WSGI 응용 프로그램이 :func:`shift_path_info`\\를 호출하면 \"bar\" 문자열을 "
"수신하고 전달할 환경이 ``/foo/bar``\\에 있는 WSGI 응용 프로그램에 전달하기 적합하도록 갱신됩니다. 즉, "
"``SCRIPT_NAME``\\는 ``/foo``\\에서 ``/foo/bar``\\로 변경되고, ``PATH_INFO``\\는 "
"``/bar/baz``\\에서 ``/baz``\\로 변경됩니다."

#: ../../library/wsgiref.rst:100
msgid ""
"When ``PATH_INFO`` is just a \"/\", this routine returns an empty string "
"and appends a trailing slash to ``SCRIPT_NAME``, even though empty path "
"segments are normally ignored, and ``SCRIPT_NAME`` doesn't normally end "
"in a slash.  This is intentional behavior, to ensure that an application "
"can tell the difference between URIs ending in ``/x`` from ones ending in"
" ``/x/`` when using this routine to do object traversal."
msgstr ""
"``PATH_INFO``\\가 단지 \"/\"일 때, 이 루틴은 빈 문자열을 반환하고 ``SCRIPT_NAME``\\에 후행 "
"슬래시를 추가합니다; 빈 경로 세그먼트는 일반적으로 무시되고, ``SCRIPT_NAME``\\는 일반적으로 슬래시로 끝나지 않음에도"
" 그렇게 합니다. 의도적인 동작입니다. 이 루틴을 사용하여 객체를 탐색할 때, 응용 프로그램이 ``/x``\\로 끝나는 URI와 "
"``/x/``\\로 끝나는 URI의 차이를 구별할 수 있도록 하기 위함입니다."

#: ../../library/wsgiref.rst:110
msgid "Update *environ* with trivial defaults for testing purposes."
msgstr "테스트 목적으로 *environ*\\를 뻔한 기본값으로 갱신합니다."

#: ../../library/wsgiref.rst:112
msgid ""
"This routine adds various parameters required for WSGI, including "
"``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, ``REQUEST_METHOD``, "
"``SCRIPT_NAME``, ``PATH_INFO``, and all of the :pep:`3333`\\ -defined "
"``wsgi.*`` variables.  It only supplies default values, and does not "
"replace any existing settings for these variables."
msgstr ""
"이 루틴은 ``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, "
"``REQUEST_METHOD``, ``SCRIPT_NAME``, ``PATH_INFO`` 및 모든 :pep:`3333`\\에서 "
"정의된 ``wsgi.*`` 변수를 포함하여 WSGI에 필요한 다양한 매개 변수를 추가합니다. 기본값만 제공하며, 이 변수들에 대한 "
"기존 설정을 대체하지 않습니다."

#: ../../library/wsgiref.rst:118
msgid ""
"This routine is intended to make it easier for unit tests of WSGI servers"
" and applications to set up dummy environments.  It should NOT be used by"
" actual WSGI servers or applications, since the data is fake!"
msgstr ""
"이 루틴은 WSGI 서버와 응용 프로그램의 단위 테스트가 더미 환경을 쉽게 설정하도록 하기 위한 것입니다. 데이터가 가짜이므로, "
"실제 WSGI 서버나 응용 프로그램에서 사용해서는 안 됩니다!"

#: ../../library/wsgiref.rst:122
msgid ""
"Example usage (see also :func:`~wsgiref.simple_server.demo_app` for "
"another example)::"
msgstr ""

#: ../../library/wsgiref.rst:125
#, python-format
msgid ""
"from wsgiref.util import setup_testing_defaults\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# A relatively simple WSGI application. It's going to print out the\n"
"# environment dictionary after being updated by setup_testing_defaults\n"
"def simple_app(environ, start_response):\n"
"    setup_testing_defaults(environ)\n"
"\n"
"    status = '200 OK'\n"
"    headers = [('Content-type', 'text/plain; charset=utf-8')]\n"
"\n"
"    start_response(status, headers)\n"
"\n"
"    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n"
"           for key, value in environ.items()]\n"
"    return ret\n"
"\n"
"with make_server('', 8000, simple_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"    httpd.serve_forever()"
msgstr ""
"from wsgiref.util import setup_testing_defaults\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# 상대적으로 간단한 WSGI 응용 프로그램. setup_testing_defaults로 갱신된 후에 환경\n"
"# 딕셔너리를 인쇄할 것입니다.\n"
"def simple_app(environ, start_response):\n"
"    setup_testing_defaults(environ)\n"
"\n"
"    status = '200 OK'\n"
"    headers = [('Content-type', 'text/plain; charset=utf-8')]\n"
"\n"
"    start_response(status, headers)\n"
"\n"
"    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n"
"           for key, value in environ.items()]\n"
"    return ret\n"
"\n"
"with make_server('', 8000, simple_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"    httpd.serve_forever()"

#: ../../library/wsgiref.rst:147
msgid ""
"In addition to the environment functions above, the :mod:`wsgiref.util` "
"module also provides these miscellaneous utilities:"
msgstr "위의 환경 함수 외에도, :mod:`wsgiref.util` 모듈은 다음과 같은 기타 유틸리티를 제공합니다:"

#: ../../library/wsgiref.rst:153
msgid ""
"Return ``True`` if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header, as"
" defined by :rfc:`2616`."
msgstr ""
"'header_name'이 :rfc:`2616`\\가 정의하고 있는 HTTP/1.1 \"Hop-by-Hop\" 헤더면 "
"``True``\\를 반환합니다."

#: ../../library/wsgiref.rst:159
msgid ""
"A concrete implementation of the :class:`wsgiref.types.FileWrapper` "
"protocol used to convert a file-like object to an :term:`iterator`. The "
"resulting objects are :term:`iterable`\\ s. As the object is iterated "
"over, the optional *blksize* parameter will be repeatedly passed to the "
"*filelike* object's :meth:`read` method to obtain bytestrings to yield.  "
"When :meth:`read` returns an empty bytestring, iteration is ended and is "
"not resumable."
msgstr ""
"파일류 객체를 :term:`이터레이터 <iterator>`\\로 변환하는 데 사용되는 "
":class:`wsgiref.types.FileWrapper` 프로토콜의 구체적 구현. 결과 객체는 :term:`이터러블 "
"<iterable>`\\입니다. 객체가 이터레이트될 때, 선택적인 *blksize* 매개 변수는 산출할 바이트열을 얻기 위해 "
"*filelike* 객체의 :meth:`read` 메서드에 반복적으로 전달됩니다. :meth:`read`\\가 빈 바이트열을 "
"반환하면 이터레이션이 종료되고 다시 시작할 수 없습니다."

#: ../../library/wsgiref.rst:167
msgid ""
"If *filelike* has a :meth:`close` method, the returned object will also "
"have a :meth:`close` method, and it will invoke the *filelike* object's "
":meth:`close` method when called."
msgstr ""
"*filelike*\\에 :meth:`close` 메서드가 있으면, 반환된 객체에도 :meth:`close` 메서드가 있고, 호출될"
" 때 *filelike* 객체의 :meth:`close` 메서드를 호출합니다."

#: ../../library/wsgiref.rst:171 ../../library/wsgiref.rst:294
#: ../../library/wsgiref.rst:429
msgid "Example usage::"
msgstr "사용 예::"

#: ../../library/wsgiref.rst:173
msgid ""
"from io import StringIO\n"
"from wsgiref.util import FileWrapper\n"
"\n"
"# We're using a StringIO-buffer for as the file-like object\n"
"filelike = StringIO(\"This is an example file-like object\"*10)\n"
"wrapper = FileWrapper(filelike, blksize=5)\n"
"\n"
"for chunk in wrapper:\n"
"    print(chunk)"
msgstr ""
"from io import StringIO\n"
"from wsgiref.util import FileWrapper\n"
"\n"
"# 파일류 객체로 StringIO 버퍼를 사용하고 있습니다\n"
"filelike = StringIO(\"This is an example file-like object\"*10)\n"
"wrapper = FileWrapper(filelike, blksize=5)\n"
"\n"
"for chunk in wrapper:\n"
"    print(chunk)"

#: ../../library/wsgiref.rst:183
msgid "Support for :meth:`~object.__getitem__` method has been removed."
msgstr ":meth:`~object.__getitem__` 메서드 지원은 제거되었습니다."

#: ../../library/wsgiref.rst:188
msgid ":mod:`wsgiref.headers` -- WSGI response header tools"
msgstr ":mod:`wsgiref.headers` -- WSGI 응답 헤더 도구"

#: ../../library/wsgiref.rst:194
msgid ""
"This module provides a single class, :class:`Headers`, for convenient "
"manipulation of WSGI response headers using a mapping-like interface."
msgstr ""
"이 모듈은 매핑류 인터페이스를 사용하여 WSGI 응답 헤더를 편리하게 조작할 수 있는 클래스 :class:`Headers` 하나를 "
"제공합니다."

#: ../../library/wsgiref.rst:200
msgid ""
"Create a mapping-like object wrapping *headers*, which must be a list of "
"header name/value tuples as described in :pep:`3333`. The default value "
"of *headers* is an empty list."
msgstr ""
":pep:`3333`\\에 설명된 것처럼 헤더 이름/값 튜플의 리스트이어야 하는 *headers*\\를 감싸는 매핑류 객체를 "
"만듭니다. *headers*\\의 기본값은 빈 리스트입니다."

#: ../../library/wsgiref.rst:204
msgid ""
":class:`Headers` objects support typical mapping operations including "
":meth:`~object.__getitem__`, :meth:`~dict.get`, "
":meth:`~object.__setitem__`, :meth:`~dict.setdefault`, "
":meth:`~object.__delitem__` and :meth:`~object.__contains__`.  For each "
"of these methods, the key is the header name (treated case-"
"insensitively), and the value is the first value associated with that "
"header name.  Setting a header deletes any existing values for that "
"header, then adds a new value at the end of the wrapped header list.  "
"Headers' existing order is generally maintained, with new headers added "
"to the end of the wrapped list."
msgstr ""
":class:`Headers` 객체는 :meth:`~object.__getitem__`, :meth:`~dict.get`, "
":meth:`~object.__setitem__`, :meth:`~dict.setdefault`, "
":meth:`~object.__delitem__` 및 :meth:`~object.__contains__`\\를 포함한 일반적인 매핑"
" 연산을 지원합니다. 이러한 각 메서드에 대해, 키는 헤더 이름(대소 문자를 구분하지 않습니다)이며, 값은 해당 헤더 이름과 연관된"
" 첫 번째 값입니다. 헤더를 설정하면 해당 헤더의 기존 값이 삭제된 다음, 감싸진 헤러 리스트의 끝에 새 값이 추가됩니다. 헤더의 "
"기존 순서는 일반적으로 유지되며, 감싸진 리스트의 끝에 새 헤더가 추가됩니다."

#: ../../library/wsgiref.rst:214
msgid ""
"Unlike a dictionary, :class:`Headers` objects do not raise an error when "
"you try to get or delete a key that isn't in the wrapped header list. "
"Getting a nonexistent header just returns ``None``, and deleting a "
"nonexistent header does nothing."
msgstr ""
"딕셔너리와 달리, :class:`Headers` 객체는 감싸진 헤더 리스트에 없는 키를 가져오거나 삭제하려고 하면 에러를 발생시키지"
" 않습니다. 존재하지 않는 헤더를 가져오려고 하면 ``None``\\을 반환하고, 존재하지 않는 헤더를 삭제하면 아무것도 하지 "
"않습니다."

#: ../../library/wsgiref.rst:219
msgid ""
":class:`Headers` objects also support :meth:`keys`, :meth:`values`, and "
":meth:`items` methods.  The lists returned by :meth:`keys` and "
":meth:`items` can include the same key more than once if there is a "
"multi-valued header.  The ``len()`` of a :class:`Headers` object is the "
"same as the length of its :meth:`items`, which is the same as the length "
"of the wrapped header list.  In fact, the :meth:`items` method just "
"returns a copy of the wrapped header list."
msgstr ""
":class:`Headers` 객체는 :meth:`keys`, :meth:`values` 및 :meth:`items` 메서드도 "
"지원합니다. :meth:`keys` 와 :meth:`items`\\에 의해 반환된 리스트에는 다중-값 헤더가 있으면 같은 키가 두 "
"번 이상 포함될 수 있습니다. :class:`Headers` 객체의 ``len()``\\는 :meth:`items`\\의 길이와 "
"같고, 이는 감싸진 헤더 리스트의 길이와 같습니다. 실제로, :meth:`items` 메서드는 단지 감싸진 헤더 리스트의 복사본을 "
"반환합니다."

#: ../../library/wsgiref.rst:226
msgid ""
"Calling ``bytes()`` on a :class:`Headers` object returns a formatted "
"bytestring suitable for transmission as HTTP response headers.  Each "
"header is placed on a line with its value, separated by a colon and a "
"space. Each line is terminated by a carriage return and line feed, and "
"the bytestring is terminated with a blank line."
msgstr ""
":class:`Headers` 객체에서 ``bytes()``\\를 호출하면 HTTP 응답 헤더로 전송하기에 적합한 포맷된 바이트열이"
" 반환됩니다. 각 헤더는 콜론과 공백으로 구분된 값과 함께 줄에 들어갑니다. 각 줄은 캐리지 리턴과 줄넘김으로 끝나며, 바이트열은 "
"빈 줄로 끝납니다."

#: ../../library/wsgiref.rst:232
msgid ""
"In addition to their mapping interface and formatting features, "
":class:`Headers` objects also have the following methods for querying and"
" adding multi-valued headers, and for adding headers with MIME "
"parameters:"
msgstr ""
":class:`Headers` 객체는 매핑 인터페이스와 포매팅 기능 외에도, 다중-값 헤더를 조회하거나 추가하고, MIME "
"파라미터가 있는 헤더를 추가하기 위해 다음과 같은 메서드를 제공합니다:"

#: ../../library/wsgiref.rst:239
msgid "Return a list of all the values for the named header."
msgstr "주어진 이름의 헤더에 대한 모든 값의 리스트를 반환합니다."

#: ../../library/wsgiref.rst:241
msgid ""
"The returned list will be sorted in the order they appeared in the "
"original header list or were added to this instance, and may contain "
"duplicates.  Any fields deleted and re-inserted are always appended to "
"the header list.  If no fields exist with the given name, returns an "
"empty list."
msgstr ""
"반환된 리스트는 원래 헤더 리스트에 나타나거나 이 인스턴스에 추가된 순서대로 정렬되고, 중복을 포함할 수 있습니다. 삭제되고 다시 "
"삽입된 필드는 항상 헤더 리스트의 끝에 추가됩니다. 주어진 이름의 필드가 존재하지 않으면, 빈 리스트를 반환합니다."

#: ../../library/wsgiref.rst:249
msgid ""
"Add a (possibly multi-valued) header, with optional MIME parameters "
"specified via keyword arguments."
msgstr "키워드 인자로 지정되는 선택적 MIME 파라미터와 함께 헤더를 추가합니다 (다중-값 가능)."

#: ../../library/wsgiref.rst:252
msgid ""
"*name* is the header field to add.  Keyword arguments can be used to set "
"MIME parameters for the header field.  Each parameter must be a string or"
" ``None``. Underscores in parameter names are converted to dashes, since "
"dashes are illegal in Python identifiers, but many MIME parameter names "
"include dashes.  If the parameter value is a string, it is added to the "
"header value parameters in the form ``name=\"value\"``. If it is "
"``None``, only the parameter name is added. (This is used for MIME "
"parameters without a value.)  Example usage::"
msgstr ""
"*name*\\은 추가할 헤더 필드입니다. 키워드 인자는 헤더 필드에 대한 MIME 파라미터를 설정하는 데 사용될 수 있습니다. 각"
" 파라미터는 문자열이나 ``None`` 이어야 합니다. 파라미터 이름의 밑줄은 대시로 변환됩니다; 파이썬 식별자에서는 대시가 "
"유효하지 않지만 많은 MIME 파라미터 이름에는 대시가 포함되기 때문입니다. 파라미터값이 문자열이면 "
"``name=\"value\"`` 형식으로 헤더 값 파라미터에 추가됩니다. ``None``\\이면 파라미터 이름 만 추가됩니다. "
"(이것은 값이 없는 MIME 파라미터에 사용됩니다.) 사용 예::"

#: ../../library/wsgiref.rst:260
msgid "h.add_header('content-disposition', 'attachment', filename='bud.gif')"
msgstr "h.add_header('content-disposition', 'attachment', filename='bud.gif')"

#: ../../library/wsgiref.rst:262
msgid "The above will add a header that looks like this::"
msgstr "위의 코드는 다음과 같은 헤더를 추가합니다::"

#: ../../library/wsgiref.rst:264
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/wsgiref.rst:267
msgid "*headers* parameter is optional."
msgstr "*headers* 매개 변수는 선택적입니다."

#: ../../library/wsgiref.rst:272
msgid ":mod:`wsgiref.simple_server` -- a simple WSGI HTTP server"
msgstr ":mod:`wsgiref.simple_server` -- 간단한 WSGI HTTP 서버"

#: ../../library/wsgiref.rst:278
msgid ""
"This module implements a simple HTTP server (based on :mod:`http.server`)"
" that serves WSGI applications.  Each server instance serves a single "
"WSGI application on a given host and port.  If you want to serve multiple"
" applications on a single host and port, you should create a WSGI "
"application that parses ``PATH_INFO`` to select which application to "
"invoke for each request.  (E.g., using the :func:`shift_path_info` "
"function from :mod:`wsgiref.util`.)"
msgstr ""
"이 모듈은 WSGI 응용 프로그램을 서빙하는 간단한 HTTP 서버(:mod:`http.server` 기반)를 구현합니다. 각 서버 "
"인스턴스는 주어진 호스트와 포트에서 단일 WSGI 응용 프로그램을 서빙합니다. 단일 호스트와 포트에서 여러 응용 프로그램을 "
"서빙하려면, ``PATH_INFO``\\를 구문 분석하여 각 요청에 대해 호출할 응용 프로그램을 선택하는 WSGI 응용 프로그램을 "
"만들어야 합니다. (예를 들어, :mod:`wsgiref.util`\\의 :func:`shift_path_info` 함수를 "
"사용해서.)"

#: ../../library/wsgiref.rst:289
msgid ""
"Create a new WSGI server listening on *host* and *port*, accepting "
"connections for *app*.  The return value is an instance of the supplied "
"*server_class*, and will process requests using the specified "
"*handler_class*.  *app* must be a WSGI application object, as defined by "
":pep:`3333`."
msgstr ""
"*host* 와 *port*\\에서 수신을 기다리고, *app*\\에 대한 연결을 수락하는 새 WSGI 서버를 만듭니다. 반환 값은"
" 제공된 *server_class*\\의 인스턴스이며, 지정된 *handler_class*\\를 사용하여 요청을 처리합니다. "
"*app*\\는 :pep:`3333`\\에 정의된 WSGI 응용 프로그램 객체여야 합니다."

#: ../../library/wsgiref.rst:296
msgid ""
"from wsgiref.simple_server import make_server, demo_app\n"
"\n"
"with make_server('', 8000, demo_app) as httpd:\n"
"    print(\"Serving HTTP on port 8000...\")\n"
"\n"
"    # Respond to requests until process is killed\n"
"    httpd.serve_forever()\n"
"\n"
"    # Alternative: serve one request, then exit\n"
"    httpd.handle_request()"
msgstr ""
"from wsgiref.simple_server import make_server, demo_app\n"
"\n"
"with make_server('', 8000, demo_app) as httpd:\n"
"    print(\"Serving HTTP on port 8000...\")\n"
"\n"
"    # 프로세스를 죽일 때까지 요청에 응답합니다\n"
"    httpd.serve_forever()\n"
"\n"
"    # 대안: 하나의 요청을 처리한 다음 종료합니다\n"
"    httpd.handle_request()"

#: ../../library/wsgiref.rst:310
msgid ""
"This function is a small but complete WSGI application that returns a "
"text page containing the message \"Hello world!\" and a list of the "
"key/value pairs provided in the *environ* parameter.  It's useful for "
"verifying that a WSGI server (such as :mod:`wsgiref.simple_server`) is "
"able to run a simple WSGI application correctly."
msgstr ""
"이 함수는 작지만 완벽한 WSGI 응용 프로그램인데, \"Hello world!\" 메시지와 *environ* 매개 변수에 제공된 "
"키/값 쌍 목록이 포함된 텍스트 페이지를 반환합니다. WSGI 서버(가령 :mod:`wsgiref.simple_server`)가 "
"간단한 WSGI 응용 프로그램을 올바르게 실행할 수 있는지 확인하는 데 유용합니다."

#: ../../library/wsgiref.rst:316
msgid ""
"The *start_response* callable should follow the :class:`.StartResponse` "
"protocol."
msgstr "*start_response* 콜러블은 :class:`.StartResponse` 프로토콜을 따라야 합니다."

#: ../../library/wsgiref.rst:321
msgid ""
"Create a :class:`WSGIServer` instance.  *server_address* should be a "
"``(host,port)`` tuple, and *RequestHandlerClass* should be the subclass "
"of :class:`http.server.BaseHTTPRequestHandler` that will be used to "
"process requests."
msgstr ""
":class:`WSGIServer` 인스턴스를 만듭니다. *server_address*\\는 ``(host,port)`` 튜플이어야"
" 하며, *RequestHandlerClass*\\는 "
":class:`http.server.BaseHTTPRequestHandler`\\의 서브 클래스여야 하는데, 요청을 처리하는 데 "
"사용됩니다."

#: ../../library/wsgiref.rst:326
msgid ""
"You do not normally need to call this constructor, as the "
":func:`make_server` function can handle all the details for you."
msgstr ":func:`make_server` 함수가 모든 세부 사항을 처리할 수 있으므로, 일반적으로 이 생성자를 호출할 필요가 없습니다."

#: ../../library/wsgiref.rst:329
msgid ""
":class:`WSGIServer` is a subclass of :class:`http.server.HTTPServer`, so "
"all of its methods (such as :meth:`serve_forever` and "
":meth:`handle_request`) are available. :class:`WSGIServer` also provides "
"these WSGI-specific methods:"
msgstr ""
":class:`WSGIServer`\\는 :class:`http.server.HTTPServer`\\의 서브 클래스이므로, 모든 "
"메서드(가령 :meth:`serve_forever`\\와 :meth:`handle_request`)를 사용할 수 있습니다. "
":class:`WSGIServer`\\는 또한 다음과 같은 WSGI 전용 메서드를 제공합니다:"

#: ../../library/wsgiref.rst:336
msgid ""
"Sets the callable *application* as the WSGI application that will receive"
" requests."
msgstr "콜러블 *application*\\을 요청을 수신하는 WSGI 응용 프로그램으로 설정합니다."

#: ../../library/wsgiref.rst:342
msgid "Returns the currently set application callable."
msgstr "현재 설정되어있는 응용 프로그램 콜러블을 반환합니다."

#: ../../library/wsgiref.rst:344
msgid ""
"Normally, however, you do not need to use these additional methods, as "
":meth:`set_app` is normally called by :func:`make_server`, and the "
":meth:`get_app` exists mainly for the benefit of request handler "
"instances."
msgstr ""
"그러나 일반적으로, 이러한 추가 메서드를 사용할 필요가 없는데, :meth:`set_app`\\는 일반적으로 "
":func:`make_server`\\에서 호출되고, :meth:`get_app`\\은 주로 요청 처리기 인스턴스의 필요를 위해 "
"존재하기 때문입니다"

#: ../../library/wsgiref.rst:351
msgid ""
"Create an HTTP handler for the given *request* (i.e. a socket), "
"*client_address* (a ``(host,port)`` tuple), and *server* "
"(:class:`WSGIServer` instance)."
msgstr ""
"지정된 *request* (즉, 소켓), *client_address* (``(host,port)`` 튜플) 및 *server* "
"(:class:`WSGIServer` 인스턴스)를 위한 HTTP 처리기를 만듭니다."

#: ../../library/wsgiref.rst:354
msgid ""
"You do not need to create instances of this class directly; they are "
"automatically created as needed by :class:`WSGIServer` objects.  You can,"
" however, subclass this class and supply it as a *handler_class* to the "
":func:`make_server` function.  Some possibly relevant methods for "
"overriding in subclasses:"
msgstr ""
"이 클래스의 인스턴스를 직접 만들 필요는 없습니다; :class:`WSGIServer` 객체가 필요에 따라 자동으로 만듭니다. "
"그러나, 이 클래스를 서브 클래싱하여 *handler_class*\\로 :func:`make_server` 함수에 제공할 수 "
"있습니다. 서브 클래스에서 재정의하는데 적합한 메서드들은 다음과 같습니다:"

#: ../../library/wsgiref.rst:363
msgid ""
"Return a :data:`~wsgiref.types.WSGIEnvironment` dictionary for a request."
"  The default implementation copies the contents of the "
":class:`WSGIServer` object's :attr:`base_environ` dictionary attribute "
"and then adds various headers derived from the HTTP request.  Each call "
"to this method should return a new dictionary containing all of the "
"relevant CGI environment variables as specified in :pep:`3333`."
msgstr ""
"요청에 대한 :data:`~wsgiref.types.WSGIEnvironment` 딕셔너리를 반환합니다. 기본 구현은 "
":class:`WSGIServer` 객체의 :attr:`base_environ` 딕셔너리 어트리뷰트의 내용을 복사한 다음, HTTP"
" 요청으로부터 온 다양한 헤더를 추가합니다. 이 메서드를 호출할 때마다 :pep:`3333`\\에 지정된 CGI 환경 변수를 모두 "
"포함하는 새 딕셔너리를 반환해야 합니다."

#: ../../library/wsgiref.rst:374
msgid ""
"Return the object that should be used as the ``wsgi.errors`` stream. The "
"default implementation just returns ``sys.stderr``."
msgstr ""
"``wsgi.errors`` 스트림으로 사용해야 하는 객체를 반환합니다. 기본 구현은 단지 ``sys.stderr``\\를 "
"반환합니다."

#: ../../library/wsgiref.rst:380
msgid ""
"Process the HTTP request.  The default implementation creates a handler "
"instance using a :mod:`wsgiref.handlers` class to implement the actual "
"WSGI application interface."
msgstr ""
"HTTP 요청을 처리합니다. 기본 구현은 :mod:`wsgiref.handlers` 클래스를 사용하여 실제 WSGI 응용 프로그램 "
"인터페이스를 구현하는 처리기 인스턴스를 만듭니다."

#: ../../library/wsgiref.rst:386
msgid ":mod:`wsgiref.validate` --- WSGI conformance checker"
msgstr ":mod:`wsgiref.validate` --- WSGI 적합성 검사기"

#: ../../library/wsgiref.rst:392
msgid ""
"When creating new WSGI application objects, frameworks, servers, or "
"middleware, it can be useful to validate the new code's conformance using"
" :mod:`wsgiref.validate`.  This module provides a function that creates "
"WSGI application objects that validate communications between a WSGI "
"server or gateway and a WSGI application object, to check both sides for "
"protocol conformance."
msgstr ""
"새로운 WSGI 응용 프로그램 객체, 프레임워크, 서버 또는 미들웨어를 만들 때, :mod:`wsgiref.validate`\\를 "
"사용하여 새 코드의 적합성을 확인하는 것이 유용할 수 있습니다. 이 모듈은 WSGI 서버나 게이트웨이와 WSGI 응용 프로그램 객체"
" 사이의 통신을 검증하는 WSGI 응용 프로그램 객체를 만드는 함수를 제공하여, 양측의 프로토콜 준수 여부를 검사할 수 있도록 "
"합니다."

#: ../../library/wsgiref.rst:399
#, python-format
msgid ""
"Note that this utility does not guarantee complete :pep:`3333` "
"compliance; an absence of errors from this module does not necessarily "
"mean that errors do not exist.  However, if this module does produce an "
"error, then it is virtually certain that either the server or application"
" is not 100% compliant."
msgstr ""
"이 유틸리티는 완전한 :pep:`3333` 적합성을 보장하지는 않습니다; 이 모듈에서 에러가 없다고 해서 에러가 존재하지 않는다는 "
"것을 의미하지는 않습니다. 그러나, 이 모듈에서 오류가 발생하면, 서버나 응용 프로그램이 100% 적합하지 않다는 것은 사실상 "
"확실합니다."

#: ../../library/wsgiref.rst:404
msgid ""
"This module is based on the :mod:`paste.lint` module from Ian Bicking's "
"\"Python Paste\" library."
msgstr "이 모듈은 Ian Bicking의 \"Python Paste\" 라이브러리의 :mod:`paste.lint` 모듈을 기반으로 합니다."

#: ../../library/wsgiref.rst:410
msgid ""
"Wrap *application* and return a new WSGI application object.  The "
"returned application will forward all requests to the original "
"*application*, and will check that both the *application* and the server "
"invoking it are conforming to the WSGI specification and to :rfc:`2616`."
msgstr ""
"*application* 감싸고 새 WSGI 응용 프로그램 객체를 반환합니다. 반환된 응용 프로그램은 모든 요청을 원래 "
"*application*\\으로 전달하고, *application*\\과 이를 호출하는 서버가 모두 WSGI 명세와 "
":rfc:`2616`\\를 준수하는지 확인합니다."

#: ../../library/wsgiref.rst:415
msgid ""
"Any detected nonconformance results in an :exc:`AssertionError` being "
"raised; note, however, that how these errors are handled is server-"
"dependent.  For example, :mod:`wsgiref.simple_server` and other servers "
"based on :mod:`wsgiref.handlers` (that don't override the error handling "
"methods to do something else) will simply output a message that an error "
"has occurred, and dump the traceback to ``sys.stderr`` or some other "
"error stream."
msgstr ""
"탐지된 모든 부적합 결과는 :exc:`AssertionError`\\를 일으킵니다; 그러나 이러한 에러를 처리하는 방법은 서버에 "
"따라 다릅니다. 예를 들어, :mod:`wsgiref.simple_server`\\와 "
":mod:`wsgiref.handlers`\\를 기반으로 하는 다른 (에러 처리 메서드를 재정의해서 다른 작업을 수행하지 않는) "
"서버는 단순히 에러가 발생했다는 메시지를 출력하고 ``sys.stderr`` 나 기타 에러 스트림으로 트레이스백을 덤프합니다."

#: ../../library/wsgiref.rst:422
msgid ""
"This wrapper may also generate output using the :mod:`warnings` module to"
" indicate behaviors that are questionable but which may not actually be "
"prohibited by :pep:`3333`.  Unless they are suppressed using Python "
"command-line options or the :mod:`warnings` API, any such warnings will "
"be written to ``sys.stderr`` (*not* ``wsgi.errors``, unless they happen "
"to be the same object)."
msgstr ""
"이 래퍼는 의심스럽기는 하지만 :pep:`3333`\\에서 실제로 금지되지 않을 수도 있는 동작을 나타내도록 "
":mod:`warnings` 모듈을 사용하여 출력을 생성할 수도 있습니다. 파이썬 명령 줄 옵션이나 :mod:`warnings` "
"API를 사용해서 억제되지 않는 한, 그러한 경고는 ``sys.stderr``\\(같은 객체가 아니라면 "
"``wsgi.errors``\\가 *아닙니다*)에 기록됩니다."

#: ../../library/wsgiref.rst:431
msgid ""
"from wsgiref.validate import validator\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# Our callable object which is intentionally not compliant to the\n"
"# standard, so the validator is going to break\n"
"def simple_app(environ, start_response):\n"
"    status = '200 OK'  # HTTP Status\n"
"    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # This is going to break because we need to return a list, and\n"
"    # the validator is going to inform us\n"
"    return b\"Hello World\"\n"
"\n"
"# This is the application wrapped in a validator\n"
"validator_app = validator(simple_app)\n"
"\n"
"with make_server('', 8000, validator_app) as httpd:\n"
"    print(\"Listening on port 8000....\")\n"
"    httpd.serve_forever()"
msgstr ""
"from wsgiref.validate import validator\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# 의도적으로 표준을 준수하지 않는 콜러블 객체이므로,\n"
"# 적합성 검사기가 중단됩니다\n"
"def simple_app(environ, start_response):\n"
"    status = '200 OK'  # HTTP Status\n"
"    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # 이것은 중단하게 되는데, 목록을 반환해야 하기 때문입니다,\n"
"    # 적합성 검사기가 알려줄 것입니다\n"
"    return b\"Hello World\"\n"
"\n"
"# 이것은 적합성 검사기로 감싼 응용 프로그램입니다\n"
"validator_app = validator(simple_app)\n"
"\n"
"with make_server('', 8000, validator_app) as httpd:\n"
"    print(\"Listening on port 8000....\")\n"
"    httpd.serve_forever()"

#: ../../library/wsgiref.rst:454
msgid ":mod:`wsgiref.handlers` -- server/gateway base classes"
msgstr ":mod:`wsgiref.handlers` -- 서버/게이트웨이 베이스 클래스"

#: ../../library/wsgiref.rst:460
msgid ""
"This module provides base handler classes for implementing WSGI servers "
"and gateways.  These base classes handle most of the work of "
"communicating with a WSGI application, as long as they are given a CGI-"
"like environment, along with input, output, and error streams."
msgstr ""
"이 모듈은 WSGI 서버와 게이트웨이를 구현하기 위한 베이스 처리기 클래스를 제공합니다. 이러한 베이스 클래스는 입력, 출력 및 "
"에러 스트림과 함께 CGI와 유사한 환경이 제공되는 한, WSGI 응용 프로그램과 통신하는 대부분 작업을 처리합니다."

#: ../../library/wsgiref.rst:468
msgid ""
"CGI-based invocation via ``sys.stdin``, ``sys.stdout``, ``sys.stderr`` "
"and ``os.environ``.  This is useful when you have a WSGI application and "
"want to run it as a CGI script.  Simply invoke ``CGIHandler().run(app)``,"
" where ``app`` is the WSGI application object you wish to invoke."
msgstr ""
"``sys.stdin``, ``sys.stdout``, ``sys.stderr`` 및 ``os.environ``\\를 통한 CGI "
"기반 호출. 이것은 WSGI 응용 프로그램이 있고 CGI 스크립트로 실행하려고 할 때 유용합니다. "
"``CGIHandler().run(app)``\\을 호출하기만 하면 됩니다. 여기서 ``app``\\은 호출할 WSGI 응용 "
"프로그램 객체입니다."

#: ../../library/wsgiref.rst:473
msgid ""
"This class is a subclass of :class:`BaseCGIHandler` that sets "
"``wsgi.run_once`` to true, ``wsgi.multithread`` to false, and "
"``wsgi.multiprocess`` to true, and always uses :mod:`sys` and :mod:`os` "
"to obtain the necessary CGI streams and environment."
msgstr ""
"이 클래스는 ``wsgi.run_once``\\를 참으로, ``wsgi.multithread``\\를 거짓으로, "
"``wsgi.multiprocess``\\를 참으로 설정하고, 필요한 CGI 스트림과 환경을 얻기 위해 항상 "
":mod:`sys`\\와 :mod:`os`\\를 사용하는 :class:`BaseCGIHandler`\\의 서브 클래스입니다."

#: ../../library/wsgiref.rst:481
msgid ""
"A specialized alternative to :class:`CGIHandler`, for use when deploying "
"on Microsoft's IIS web server, without having set the config "
"allowPathInfo option (IIS>=7) or metabase allowPathInfoForScriptMappings "
"(IIS<7)."
msgstr ""
"config allowPathInfo 옵션 (IIS>=7) 나 metabase "
"allowPathInfoForScriptMappings (IIS<7)를 설정하지 않고도, Microsoft IIS 웹 서버에 배포할"
" 때 사용할 수 있는 :class:`CGIHandler`\\의 특수한 대안."

#: ../../library/wsgiref.rst:485
msgid ""
"By default, IIS gives a ``PATH_INFO`` that duplicates the ``SCRIPT_NAME``"
" at the front, causing problems for WSGI applications that wish to "
"implement routing. This handler strips any such duplicated path."
msgstr ""
"기본적으로, IIS는 앞에 ``SCRIPT_NAME``\\이 중복된 ``PATH_INFO``\\를 제공하므로, 라우팅을 구현하려는 "
"WSGI 응용 프로그램에 문제가 발생합니다. 이 처리기는 중복된 경로를 제거합니다."

#: ../../library/wsgiref.rst:489
msgid ""
"IIS can be configured to pass the correct ``PATH_INFO``, but this causes "
"another bug where ``PATH_TRANSLATED`` is wrong. Luckily this variable is "
"rarely used and is not guaranteed by WSGI. On IIS<7, though, the setting "
"can only be made on a vhost level, affecting all other script mappings, "
"many of which break when exposed to the ``PATH_TRANSLATED`` bug. For this"
" reason IIS<7 is almost never deployed with the fix (Even IIS7 rarely "
"uses it because there is still no UI for it.)."
msgstr ""
"IIS가 올바른 ``PATH_INFO``\\를 전달하도록 구성할 수 있지만, ``PATH_TRANSLATED``\\가 잘못되는 다른"
" 버그가 발생합니다. 다행히도 이 변수는 거의 사용되지 않으며 WSGI에서 보장하지 않습니다. 그러나 IIS<7에서는 설정이 가상 "
"호스트 수준에서만 이루어지므로, 다른 모든 스크립트 매핑에 영향을 미치며, 그중 많은 것들이 ``PATH_TRANSLATED`` "
"버그에 노출되면 망가집니다. 이러한 이유로 IIS<7은 거의 수정해서 배포되지 않습니다 (아직도 UI가 없어서 IIS7 조차도 거의"
" 사용하지 않습니다.)."

#: ../../library/wsgiref.rst:497
msgid ""
"There is no way for CGI code to tell whether the option was set, so a "
"separate handler class is provided.  It is used in the same way as "
":class:`CGIHandler`, i.e., by calling ``IISCGIHandler().run(app)``, where"
" ``app`` is the WSGI application object you wish to invoke."
msgstr ""
"CGI 코드가 옵션이 설정되었는지를 알 수 있는 방법이 없으므로, 별도의 처리기 클래스가 제공됩니다. "
":class:`CGIHandler`\\와 같은 방식으로 사용됩니다. 즉, ``IISCGIHandler().run(app)``\\을 "
"호출합니다. 여기서 ``app``\\은 호출할 WSGI 응용 프로그램 객체입니다."

#: ../../library/wsgiref.rst:507
msgid ""
"Similar to :class:`CGIHandler`, but instead of using the :mod:`sys` and "
":mod:`os` modules, the CGI environment and I/O streams are specified "
"explicitly. The *multithread* and *multiprocess* values are used to set "
"the ``wsgi.multithread`` and ``wsgi.multiprocess`` flags for any "
"applications run by the handler instance."
msgstr ""
":class:`CGIHandler`\\와 유사하지만, :mod:`sys` 와 :mod:`os` 모듈을 사용하는 대신, CGI 환경과"
" I/O 스트림이 명시적으로 지정됩니다. *multithread* 와 *multiprocess* 값은 처리기 인스턴스가 실행하는 "
"모든 응용 프로그램에 대한 ``wsgi.multithread`` 와 ``wsgi.multiprocess`` 플래그를 설정하는 데 "
"사용됩니다."

#: ../../library/wsgiref.rst:513
msgid ""
"This class is a subclass of :class:`SimpleHandler` intended for use with "
"software other than HTTP \"origin servers\".  If you are writing a "
"gateway protocol implementation (such as CGI, FastCGI, SCGI, etc.) that "
"uses a ``Status:`` header to send an HTTP status, you probably want to "
"subclass this instead of :class:`SimpleHandler`."
msgstr ""
"이 클래스는 HTTP \"오리진 서버\" 이외의 소프트웨어에서 사용하기 위한 :class:`SimpleHandler`\\의 서브 "
"클래스입니다. HTTP 상태를 보내기 위해 ``Status:`` 헤더를 사용하는 게이트웨이 프로토콜 구현(가령 CGI, "
"FastCGI, SCGI 등)을 작성하는 경우 :class:`SimpleHandler` 대신 이것을 서브 클래싱하고 싶을 겁니다."

#: ../../library/wsgiref.rst:522
msgid ""
"Similar to :class:`BaseCGIHandler`, but designed for use with HTTP origin"
" servers.  If you are writing an HTTP server implementation, you will "
"probably want to subclass this instead of :class:`BaseCGIHandler`."
msgstr ""
":class:`BaseCGIHandler`\\와 유사하지만, HTTP 오리진 서버에 사용하도록 설계되었습니다. HTTP 서버 구현을"
" 작성하는 경우 :class:`BaseCGIHandler` 대신 이것을 서브 클래싱하고 싶을 겁니다."

#: ../../library/wsgiref.rst:526
msgid ""
"This class is a subclass of :class:`BaseHandler`.  It overrides the "
":meth:`!__init__`, :meth:`~BaseHandler.get_stdin`, "
":meth:`~BaseHandler.get_stderr`, :meth:`~BaseHandler.add_cgi_vars`, "
":meth:`~BaseHandler._write`, and :meth:`~BaseHandler._flush` methods to "
"support explicitly setting the environment and streams via the "
"constructor.  The supplied environment and streams are stored in the "
":attr:`stdin`, :attr:`stdout`, :attr:`stderr`, and :attr:`environ` "
"attributes."
msgstr ""
"이 클래스는 :class:`BaseHandler`\\의 서브 클래스입니다. :meth:`!__init__`, "
":meth:`~BaseHandler.get_stdin`, :meth:`~BaseHandler.get_stderr`, "
":meth:`~BaseHandler.add_cgi_vars`, :meth:`~BaseHandler._write` 및 "
":meth:`~BaseHandler._flush` 메서드를 재정의하여 명시적으로 환경과 스트림을 생성자를 통해 설정하는 것을 "
"지원합니다. 제공된 환경과 스트림은 :attr:`stdin`, :attr:`stdout`, :attr:`stderr` 및 "
":attr:`environ` 어트리뷰트에 저장됩니다."

#: ../../library/wsgiref.rst:535
msgid ""
"The :meth:`~io.BufferedIOBase.write` method of *stdout* should write each"
" chunk in full, like :class:`io.BufferedIOBase`."
msgstr ""
"*stdout*\\의 :meth:`~io.BufferedIOBase.write` 메서드는 "
":class:`io.BufferedIOBase`\\처럼 각 덩어리 전체를 기록해야 합니다."

#: ../../library/wsgiref.rst:541
msgid ""
"This is an abstract base class for running WSGI applications.  Each "
"instance will handle a single HTTP request, although in principle you "
"could create a subclass that was reusable for multiple requests."
msgstr ""
"이것은 WSGI 응용 프로그램을 실행하기 위한 추상 베이스 클래스입니다. 원칙적으로 여러 요청에 대해 재사용할 수 있는 서브 "
"클래스를 만들 수 있지만, 각 인스턴스는 단일 HTTP 요청을 처리합니다."

#: ../../library/wsgiref.rst:545
msgid ""
":class:`BaseHandler` instances have only one method intended for external"
" use:"
msgstr ":class:`BaseHandler` 인스턴스에는 외부 사용을 위한 하나의 메서드 만 있습니다:"

#: ../../library/wsgiref.rst:550
msgid "Run the specified WSGI application, *app*."
msgstr "지정된 WSGI 응용 프로그램인 *app*\\을 실행합니다."

#: ../../library/wsgiref.rst:552
msgid ""
"All of the other :class:`BaseHandler` methods are invoked by this method "
"in the process of running the application, and thus exist primarily to "
"allow customizing the process."
msgstr ""
"다른 모든 :class:`BaseHandler` 메서드는 응용 프로그램을 실행하는 과정에서 이 메서드에 의해 호출되므로, 주로 "
"과정을 사용자 정의하기 위해 존재합니다."

#: ../../library/wsgiref.rst:556
msgid "The following methods MUST be overridden in a subclass:"
msgstr "다음 메서드는 서브 클래스에서 반드시 재정의되어야 합니다:"

#: ../../library/wsgiref.rst:561
msgid ""
"Buffer the bytes *data* for transmission to the client.  It's okay if "
"this method actually transmits the data; :class:`BaseHandler` just "
"separates write and flush operations for greater efficiency when the "
"underlying system actually has such a distinction."
msgstr ""
"클라이언트로의 전송을 위해 바이트열 *data*\\를 버퍼링합니다. 이 메서드가 실제로 데이터를 전송해도 상관없습니다; "
":class:`BaseHandler`\\는 쓰기와 플러시 연산을 분리하여 하부 시스템에 실제로 이러한 구분이 있을 때 효율성을 "
"높입니다."

#: ../../library/wsgiref.rst:569
msgid ""
"Force buffered data to be transmitted to the client.  It's okay if this "
"method is a no-op (i.e., if :meth:`_write` actually sends the data)."
msgstr ""
"버퍼링 된 데이터를 클라이언트로 전송하도록 강제합니다. 이 메서드가 아무 일도 하지 않아도 상관없습니다 (즉, "
":meth:`_write`\\가 실제로 데이터를 보낸다면)."

#: ../../library/wsgiref.rst:575
msgid ""
"Return an object compatible with :class:`~wsgiref.types.InputStream` "
"suitable for use as the ``wsgi.input`` of the request currently being "
"processed."
msgstr ""
"현재 처리 중인 요청의 ``wsgi.input``\\으로 사용하기에 적합한 "
":class:`~wsgiref.types.InputStream` 과 호환되는 객체를 반환합니다."

#: ../../library/wsgiref.rst:582
msgid ""
"Return an object compatible with :class:`~wsgiref.types.ErrorStream` "
"suitable for use as the ``wsgi.errors`` of the request currently being "
"processed."
msgstr ""
"현재 처리 중인 요청의 ``wsgi.errors``\\로 사용하기에 적합한 "
":class:`~wsgiref.types.ErrorStream` 과 호환되는 객체를 반환합니다."

#: ../../library/wsgiref.rst:589
msgid ""
"Insert CGI variables for the current request into the :attr:`environ` "
"attribute."
msgstr "현재 요청에 대한 CGI 변수를 :attr:`environ` 어트리뷰트에 삽입합니다."

#: ../../library/wsgiref.rst:591
msgid ""
"Here are some other methods and attributes you may wish to override. This"
" list is only a summary, however, and does not include every method that "
"can be overridden.  You should consult the docstrings and source code for"
" additional information before attempting to create a customized "
":class:`BaseHandler` subclass."
msgstr ""
"재정의하고 싶을 수 있는 다른 메서드와 어트리뷰트는 다음과 같습니다. 그러나, 이 목록은 요약에 지나지 않고, 재정의할 수 있는 "
"모든 메서드가 포함되어 있지 않습니다. 사용자 정의된 :class:`BaseHandler` 서브 클래스를 작성하기 전에 독스트링과 "
"소스 코드를 참조하여 추가 정보를 얻어야 합니다."

#: ../../library/wsgiref.rst:597
msgid "Attributes and methods for customizing the WSGI environment:"
msgstr "WSGI 환경을 사용자 정의하기 위한 어트리뷰트와 메서드:"

#: ../../library/wsgiref.rst:602
msgid ""
"The value to be used for the ``wsgi.multithread`` environment variable.  "
"It defaults to true in :class:`BaseHandler`, but may have a different "
"default (or be set by the constructor) in the other subclasses."
msgstr ""
"``wsgi.multithread`` 환경 변수에 사용될 값. :class:`BaseHandler`\\에서는 기본값이 참이지만, "
"다른 서브 클래스는 다른 기본값을 가질 수 있습니다 (또는 생성자에 의해 설정될 수 있습니다)."

#: ../../library/wsgiref.rst:609
msgid ""
"The value to be used for the ``wsgi.multiprocess`` environment variable."
"  It defaults to true in :class:`BaseHandler`, but may have a different "
"default (or be set by the constructor) in the other subclasses."
msgstr ""
"``wsgi.multiprocess`` 환경 변수에 사용될 값. :class:`BaseHandler`\\에서는 기본값이 참이지만, "
"다른 서브 클래스는 다른 기본값을 가질 수 있습니다 (또는 생성자에 의해 설정될 수 있습니다)."

#: ../../library/wsgiref.rst:616
msgid ""
"The value to be used for the ``wsgi.run_once`` environment variable.  It "
"defaults to false in :class:`BaseHandler`, but :class:`CGIHandler` sets "
"it to true by default."
msgstr ""
"``wsgi.run_once`` 환경 변수에 사용될 값. :class:`BaseHandler`\\에서는 기본값이 거짓이지만, "
":class:`CGIHandler`\\는 기본적으로 참으로 설정합니다."

#: ../../library/wsgiref.rst:623
msgid ""
"The default environment variables to be included in every request's WSGI "
"environment.  By default, this is a copy of ``os.environ`` at the time "
"that :mod:`wsgiref.handlers` was imported, but subclasses can either "
"create their own at the class or instance level.  Note that the "
"dictionary should be considered read-only, since the default value is "
"shared between multiple classes and instances."
msgstr ""
"모든 요청의 WSGI 환경에 포함될 기본 환경 변수. 기본적으로, :mod:`wsgiref.handlers`\\를 임포트 한 시점의"
" ``os.environ`` 사본이지만, 서브 클래스는 클래스나 인스턴스 수준에서 자체적으로 만들 수 있습니다. 기본값이 여러 "
"클래스와 인스턴스 간에 공유되므로, 딕셔너리는 읽기 전용으로 간주해야 합니다."

#: ../../library/wsgiref.rst:633
msgid ""
"If the :attr:`origin_server` attribute is set, this attribute's value is "
"used to set the default ``SERVER_SOFTWARE`` WSGI environment variable, "
"and also to set a default ``Server:`` header in HTTP responses.  It is "
"ignored for handlers (such as :class:`BaseCGIHandler` and "
":class:`CGIHandler`) that are not HTTP origin servers."
msgstr ""
":attr:`origin_server` 어트리뷰트가 설정된 경우, 이 어트리뷰트의 값은 기본 ``SERVER_SOFTWARE`` "
"WSGI 환경 변수를 설정하는 데 사용되고, HTTP 응답의 기본 ``Server:`` 헤더를 설정하는 데도 사용됩니다. HTTP "
"오리진 서버가 아닌 처리기(가령 :class:`BaseCGIHandler` 와 :class:`CGIHandler`)에서는 "
"무시됩니다."

#: ../../library/wsgiref.rst:639
msgid ""
"The term \"Python\" is replaced with implementation specific term like "
"\"CPython\", \"Jython\" etc."
msgstr "\"Python\"이라는 용어는 \"CPython\", \"Jython\" 등과 같은 구현 특정 용어로 대체됩니다."

#: ../../library/wsgiref.rst:645
msgid ""
"Return the URL scheme being used for the current request.  The default "
"implementation uses the :func:`guess_scheme` function from "
":mod:`wsgiref.util` to guess whether the scheme should be \"http\" or "
"\"https\", based on the current request's :attr:`environ` variables."
msgstr ""
"현재의 요청에 사용되고 있는 URL 스킴을 반환합니다. 기본 구현은 :mod:`wsgiref.util`\\의 "
":func:`guess_scheme` 함수를 사용하여, 현재 요청의 :attr:`environ` 변수를 기반으로, 스킴이 "
"\"http\"와 \"https\" 중 어느 것인지 추측합니다."

#: ../../library/wsgiref.rst:653
msgid ""
"Set the :attr:`environ` attribute to a fully populated WSGI environment."
"  The default implementation uses all of the above methods and "
"attributes, plus the :meth:`get_stdin`, :meth:`get_stderr`, and "
":meth:`add_cgi_vars` methods and the :attr:`wsgi_file_wrapper` attribute."
"  It also inserts a ``SERVER_SOFTWARE`` key if not present, as long as "
"the :attr:`origin_server` attribute is a true value and the "
":attr:`server_software` attribute is set."
msgstr ""
":attr:`environ` 어트리뷰트를 완전히 채워진 WSGI 환경으로 설정합니다. 기본 구현에서는 위의 모든 메서드와 "
"어트리뷰트에 더해 :meth:`get_stdin`, :meth:`get_stderr` 및 :meth:`add_cgi_vars` "
"메서드와 :attr:`wsgi_file_wrapper` 어트리뷰트를 모두 사용합니다. :attr:`origin_server` "
"어트리뷰트가 참이고 :attr:`server_software` 어트리뷰트가 설정된 경우 ``SERVER_SOFTWARE`` 키가 "
"없으면 삽입합니다."

#: ../../library/wsgiref.rst:660
msgid "Methods and attributes for customizing exception handling:"
msgstr "예외 처리를 사용자 정의하기 위한 메서드와 어트리뷰트:"

#: ../../library/wsgiref.rst:665
msgid ""
"Log the *exc_info* tuple in the server log.  *exc_info* is a ``(type, "
"value, traceback)`` tuple.  The default implementation simply writes the "
"traceback to the request's ``wsgi.errors`` stream and flushes it.  "
"Subclasses can override this method to change the format or retarget the "
"output, mail the traceback to an administrator, or whatever other action "
"may be deemed suitable."
msgstr ""
"*exc_info* 튜플을 서버 로그에 기록합니다. *exc_info*\\는 ``(type, value, traceback)`` "
"튜플입니다. 기본 구현은 요청의 ``wsgi.errors`` 스트림에 트레이스백을 쓰고 플러시 합니다. 서브 클래스는 이 메서드를 "
"재정의해서, 형식을 변경하거나 출력의 대상을 바꾸거나, 관리자에게 트레이스백을 메일로 보내거나, 적절한 것으로 생각되는 다른 액션을"
" 수행할 수 있습니다."

#: ../../library/wsgiref.rst:674
msgid ""
"The maximum number of frames to include in tracebacks output by the "
"default :meth:`log_exception` method.  If ``None``, all frames are "
"included."
msgstr ""
"기본 :meth:`log_exception` 메서드에 의해 출력되는 트레이스백에 포함하는 프레임의 최대 수. "
"``None``\\이면, 모든 프레임이 포함됩니다."

#: ../../library/wsgiref.rst:680
msgid ""
"This method is a WSGI application to generate an error page for the user."
"  It is only invoked if an error occurs before headers are sent to the "
"client."
msgstr ""
"이 메서드는 사용자를 위한 에러 페이지를 생성하는 WSGI 응용 프로그램입니다. 헤더가 클라이언트에 전송되기 전에 오류가 발생할 "
"때만 호출됩니다."

#: ../../library/wsgiref.rst:683
msgid ""
"This method can access the current error using ``sys.exception()``, and "
"should pass that information to *start_response* when calling it (as "
"described in the \"Error Handling\" section of :pep:`3333`). In "
"particular, the *start_response* callable should follow the "
":class:`.StartResponse` protocol."
msgstr ""
"이 메서드는 ``sys.exception()``\\을 사용하여 현재 에러에 액세스할 수 있으며, 호출할 때 해당 정보를 "
"*start_response*\\로 전달해야 합니다 (:pep:`3333`\\의 \"에러 처리\" 절에서 설명하듯이). 특히, "
"*start_response* 콜러블은 :class:`.StartResponse` 프로토콜을 따라야 합니다."

#: ../../library/wsgiref.rst:689
msgid ""
"The default implementation just uses the :attr:`error_status`, "
":attr:`error_headers`, and :attr:`error_body` attributes to generate an "
"output page.  Subclasses can override this to produce more dynamic error "
"output."
msgstr ""
"기본 구현은 :attr:`error_status`, :attr:`error_headers` 및 :attr:`error_body` "
"어트리뷰트를 사용하여 출력 페이지를 생성합니다. 서브 클래스는 이것을 재정의하여, 더욱 동적인 에러 출력을 생성할 수 있습니다."

#: ../../library/wsgiref.rst:693
msgid ""
"Note, however, that it's not recommended from a security perspective to "
"spit out diagnostics to any old user; ideally, you should have to do "
"something special to enable diagnostic output, which is why the default "
"implementation doesn't include any."
msgstr ""
"그러나, 보안 관점에서 오래된 사용자에게는 진단을 내보내지 않는 것이 좋습니다; 이상적으로, 진단 출력을 활성화하기 위해서는 특별한"
" 것을 해야 합니다. 이것이 기본 구현이 아무것도 포함하지 않는 이유입니다."

#: ../../library/wsgiref.rst:701
msgid ""
"The HTTP status used for error responses.  This should be a status string"
" as defined in :pep:`3333`; it defaults to a 500 code and message."
msgstr ""
"에러 응답에 사용되는 HTTP 상태. :pep:`3333`\\에 정의된 상태 문자열이어야 합니다; 기본값은 500 코드와 "
"메시지입니다."

#: ../../library/wsgiref.rst:707
msgid ""
"The HTTP headers used for error responses.  This should be a list of WSGI"
" response headers (``(name, value)`` tuples), as described in "
":pep:`3333`.  The default list just sets the content type to "
"``text/plain``."
msgstr ""
"에러 응답에 사용되는 HTTP 헤더. 이것은 :pep:`3333`\\에서 설명하는 WSGI 응답 헤더 (``(name, "
"value)`` 튜플)의 리스트여야 합니다. 기본 리스트는 단지 콘텐츠 형식을 ``text/plain``\\으로 설정합니다."

#: ../../library/wsgiref.rst:714
msgid ""
"The error response body.  This should be an HTTP response body "
"bytestring. It defaults to the plain text, \"A server error occurred.  "
"Please contact the administrator.\""
msgstr ""
"에러 응답 바디. 이것은 HTTP 응답 바디 바이트열이어야 합니다. 기본적으로 \"A server error occurred.  "
"Please contact the administrator.\" 라는 단순 텍스트입니다."

#: ../../library/wsgiref.rst:718
msgid ""
"Methods and attributes for :pep:`3333`'s \"Optional Platform-Specific "
"File Handling\" feature:"
msgstr ":pep:`3333`\\의 \"선택적 플랫폼 특정 파일 처리\" 기능을 위한 메서드와 어트리뷰트:"

#: ../../library/wsgiref.rst:724
msgid ""
"A ``wsgi.file_wrapper`` factory, compatible with "
":class:`wsgiref.types.FileWrapper`, or ``None``.  The default value of "
"this attribute is the :class:`wsgiref.util.FileWrapper` class."
msgstr ""
":class:`wsgiref.types.FileWrapper` 와 호환되는 ``wsgi.file_wrapper`` 팩토리나 "
"``None``. 이 어트리뷰트의 기본값은 :class:`wsgiref.util.FileWrapper` 클래스입니다."

#: ../../library/wsgiref.rst:731
msgid ""
"Override to implement platform-specific file transmission.  This method "
"is called only if the application's return value is an instance of the "
"class specified by the :attr:`wsgi_file_wrapper` attribute.  It should "
"return a true value if it was able to successfully transmit the file, so "
"that the default transmission code will not be executed. The default "
"implementation of this method just returns a false value."
msgstr ""
"플랫폼 특정 파일 전송을 구현하기 위해 재정의합니다. 이 메서드는 응용 프로그램의 반환 값이 "
":attr:`wsgi_file_wrapper` 어트리뷰트로 지정된 클래스의 인스턴스일 때만 호출됩니다. 파일을 성공적으로 전송할 수"
" 있었으면 참값을 반환해야 합니다. 그러면 기본 전송 코드가 실행되지 않습니다. 이 메서드의 기본 구현은 단지 거짓 값을 "
"반환합니다."

#: ../../library/wsgiref.rst:738
msgid "Miscellaneous methods and attributes:"
msgstr "기타 메서드와 어트리뷰트:"

#: ../../library/wsgiref.rst:743
msgid ""
"This attribute should be set to a true value if the handler's "
":meth:`_write` and :meth:`_flush` are being used to communicate directly "
"to the client, rather than via a CGI-like gateway protocol that wants the"
" HTTP status in a special ``Status:`` header."
msgstr ""
"특별한 ``Status:`` 헤더를 통해 HTTP 상태를 원하는 CGI와 같은 게이트웨이 프로토콜을 통하는 것이 아니라, 처리기의 "
":meth:`_write`\\와 :meth:`_flush`\\가 클라이언트와 직접 통신하는 데 사용되는 경우 이 어트리뷰트를 참으로"
" 설정해야 합니다."

#: ../../library/wsgiref.rst:748
msgid ""
"This attribute's default value is true in :class:`BaseHandler`, but false"
" in :class:`BaseCGIHandler` and :class:`CGIHandler`."
msgstr ""
":class:`BaseHandler`\\에서는 이 어트리뷰트의 기본값이 참이지만, :class:`BaseCGIHandler`\\와 "
":class:`CGIHandler`\\에서는 거짓입니다."

#: ../../library/wsgiref.rst:754
msgid ""
"If :attr:`origin_server` is true, this string attribute is used to set "
"the HTTP version of the response set to the client.  It defaults to "
"``\"1.0\"``."
msgstr ""
":attr:`origin_server`\\가 참이면, 이 문자열 어트리뷰트를 사용하여 클라이언트로 보내는 응답 집합의 HTTP "
"버전을 설정합니다. 기본값은 ``\"1.0\"``\\입니다."

#: ../../library/wsgiref.rst:760
msgid ""
"Transcode CGI variables from ``os.environ`` to :pep:`3333` \"bytes in "
"unicode\" strings, returning a new dictionary.  This function is used by "
":class:`CGIHandler` and :class:`IISCGIHandler` in place of directly using"
" ``os.environ``, which is not necessarily WSGI-compliant on all platforms"
" and web servers using Python 3 -- specifically, ones where the OS's "
"actual environment is Unicode (i.e. Windows), or ones where the "
"environment is bytes, but the system encoding used by Python to decode it"
" is anything other than ISO-8859-1 (e.g. Unix systems using UTF-8)."
msgstr ""
"CGI 변수를 ``os.environ``\\에서 :pep:`3333` \"유니코드에 들어있는 바이트열\" 문자열로 변환하여, 새 "
"딕셔너리를 반환합니다. 이 함수는 ``os.environ``\\을 직접 사용하는 대신 :class:`CGIHandler`\\와 "
":class:`IISCGIHandler`\\에서 사용됩니다. ``os.environ``\\은 파이썬 3을 사용하는 모든 플랫폼과 웹"
" 서버에서 WSGI를 준수한다는 보장이 없습니다 -- 구체적으로, OS의 실제 환경이 유니코드인 곳(가령 윈도우)이나 환경은 "
"바이트열이지만 파이썬이 디코딩하기 위해 사용하는 시스템 인코딩이 ISO-8859-1 이외의 것인 곳(예를 들어 UTF-8을 사용하는"
" 유닉스 시스템)."

#: ../../library/wsgiref.rst:769
msgid ""
"If you are implementing a CGI-based handler of your own, you probably "
"want to use this routine instead of just copying values out of "
"``os.environ`` directly."
msgstr ""
"여러분 자신의 CGI 기반 처리기를 구현한다면, ``os.environ``\\에서 직접 값을 복사하는 대신 이 루틴을 사용하는 것이"
" 좋습니다."

#: ../../library/wsgiref.rst:777
msgid ":mod:`wsgiref.types` -- WSGI types for static type checking"
msgstr ":mod:`wsgiref.types` --- 정적 형 검사기를 위한 WSGI 형"

#: ../../library/wsgiref.rst:783
msgid ""
"This module provides various types for static type checking as described "
"in :pep:`3333`."
msgstr ""

#: ../../library/wsgiref.rst:791
msgid ""
"A :class:`typing.Protocol` describing :pep:`start_response() <3333#the-"
"start-response-callable>` callables (:pep:`3333`)."
msgstr ""

#: ../../library/wsgiref.rst:797
msgid "A type alias describing a WSGI environment dictionary."
msgstr ""

#: ../../library/wsgiref.rst:801
msgid "A type alias describing a WSGI application callable."
msgstr "WSGI 응용 프로그램 콜러블을 기술하는 형 에일리어스."

#: ../../library/wsgiref.rst:805
msgid ""
"A :class:`typing.Protocol` describing a :pep:`WSGI Input Stream <3333"
"#input-and-error-streams>`."
msgstr ""

#: ../../library/wsgiref.rst:810
msgid ""
"A :class:`typing.Protocol` describing a :pep:`WSGI Error Stream <3333"
"#input-and-error-streams>`."
msgstr ""

#: ../../library/wsgiref.rst:815
msgid ""
"A :class:`typing.Protocol` describing a :pep:`file wrapper <3333"
"#optional-platform-specific-file-handling>`. See "
":class:`wsgiref.util.FileWrapper` for a concrete implementation of this "
"protocol."
msgstr ""

#: ../../library/wsgiref.rst:822
msgid "Examples"
msgstr "예제"

#: ../../library/wsgiref.rst:824
msgid ""
"This is a working \"Hello World\" WSGI application, where the "
"*start_response* callable should follow the :class:`.StartResponse` "
"protocol::"
msgstr ""
"이것은 작동하는 \"Hello World\" WSGI 응용 프로그램으로, *start_response* 콜러블은 "
":class:`.StartResponse` 프로토콜을 따라야 합니다::"

#: ../../library/wsgiref.rst:827
msgid ""
"\"\"\"\n"
"Every WSGI application must have an application object - a callable\n"
"object that accepts two arguments. For that purpose, we're going to\n"
"use a function (note that you're not limited to a function, you can\n"
"use a class for example). The first argument passed to the function\n"
"is a dictionary containing CGI-style environment variables and the\n"
"second variable is the callable object.\n"
"\"\"\"\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"\n"
"def hello_world_app(environ, start_response):\n"
"    status = \"200 OK\"  # HTTP Status\n"
"    headers = [(\"Content-type\", \"text/plain; charset=utf-8\")]  # HTTP"
" Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # The returned object is going to be printed\n"
"    return [b\"Hello World\"]\n"
"\n"
"with make_server(\"\", 8000, hello_world_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"\n"
"    # Serve until process is killed\n"
"    httpd.serve_forever()"
msgstr ""
"\"\"\"\n"
"모든 WSGI 응용 프로그램은 응용 프로그램 객체를 가져야\n"
"합니다 - 두 개의 인자를 받아들이는 콜러블. 이를 위해,\n"
"함수를 사용하려고 합니다 (함수로 제한되지는 않습니다,\n"
"예를 들어 클래스를 사용할 수 있습니다). 함수에 전달되는\n"
"첫 번째 인자는 CGI 스타일 환경 변수를 포함하는 딕셔너리이고,\n"
"두 번째 변수는 콜러블 객체입니다.\n"
"\"\"\"\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"\n"
"def hello_world_app(environ, start_response):\n"
"    status = \"200 OK\"  # HTTP Status\n"
"    headers = [(\"Content-type\", \"text/plain; charset=utf-8\")]  # HTTP"
" 헤더\n"
"    start_response(status, headers)\n"
"\n"
"    # 반환된 객체가 인쇄될 것입니다.\n"
"    return [b\"Hello World\"]\n"
"\n"
"with make_server(\"\", 8000, hello_world_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"\n"
"    # 프로세스를 죽일 때까지 서빙합니다\n"
"    httpd.serve_forever()"

#: ../../library/wsgiref.rst:854
msgid ""
"Example of a WSGI application serving the current directory, accept "
"optional directory and port number (default: 8000) on the command line::"
msgstr "현재 디렉터리를 제공하는 WSGI 응용 프로그램의 예, 명령 줄에서 선택적 디렉터리와 포트 번호(기본값: 8000)를 받아들입니다::"

#: ../../library/wsgiref.rst:857
#, python-brace-format
msgid ""
"\"\"\"\n"
"Small wsgiref based web server. Takes a path to serve from and an\n"
"optional port number (defaults to 8000), then tries to serve files.\n"
"MIME types are guessed from the file names, 404 errors are raised\n"
"if the file is not found.\n"
"\"\"\"\n"
"import mimetypes\n"
"import os\n"
"import sys\n"
"from wsgiref import simple_server, util\n"
"\n"
"\n"
"def app(environ, respond):\n"
"    # Get the file name and MIME type\n"
"    fn = os.path.join(path, environ[\"PATH_INFO\"][1:])\n"
"    if \".\" not in fn.split(os.path.sep)[-1]:\n"
"        fn = os.path.join(fn, \"index.html\")\n"
"    mime_type = mimetypes.guess_file_type(fn)[0]\n"
"\n"
"    # Return 200 OK if file exists, otherwise 404 Not Found\n"
"    if os.path.exists(fn):\n"
"        respond(\"200 OK\", [(\"Content-Type\", mime_type)])\n"
"        return util.FileWrapper(open(fn, \"rb\"))\n"
"    else:\n"
"        respond(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n"
"        return [b\"not found\"]\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Get the path and port from command-line arguments\n"
"    path = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()\n"
"    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000\n"
"\n"
"    # Make and start the server until control-c\n"
"    httpd = simple_server.make_server(\"\", port, app)\n"
"    print(f\"Serving {path} on port {port}, control-C to stop\")\n"
"    try:\n"
"        httpd.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"Shutting down.\")\n"
"        httpd.server_close()"
msgstr ""
"\"\"\"\n"
"작은 wsgiref 기반 웹 서버. 서비스할 경로와 선택적\n"
"포트 번호(기본값 8000)를 취한 다음, 파일을 서비스하려고\n"
"시도합니다. 파일 이름에서 MIME 유형을 추측하고, 파일을\n"
"찾을 수 없으면 404 에러를 발생시킵니다.\n"
"\"\"\"\n"
"import mimetypes\n"
"import os\n"
"import sys\n"
"from wsgiref import simple_server, util\n"
"\n"
"\n"
"def app(environ, respond):\n"
"    # 파일 이름과 MIME 유형을 가져옵니다\n"
"    fn = os.path.join(path, environ[\"PATH_INFO\"][1:])\n"
"    if \".\" not in fn.split(os.path.sep)[-1]:\n"
"        fn = os.path.join(fn, \"index.html\")\n"
"    mime_type = mimetypes.guess_file_type(fn)[0]\n"
"\n"
"    # 파일이 존재하면 200 OK 를, 그렇지 않으면 404 Not Found 를 돌려줍니다\n"
"    if os.path.exists(fn):\n"
"        respond(\"200 OK\", [(\"Content-Type\", mime_type)])\n"
"        return util.FileWrapper(open(fn, \"rb\"))\n"
"    else:\n"
"        respond(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n"
"        return [b\"not found\"]\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # 명령줄 인자에서 경로와 포트를 가져옵니다\n"
"    path = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()\n"
"    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000\n"
"\n"
"    # control-c 를 누를 때까지 서버를 만들고 시작합니다\n"
"    httpd = simple_server.make_server(\"\", port, app)\n"
"    print(f\"Serving {path} on port {port}, control-C to stop\")\n"
"    try:\n"
"        httpd.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"Shutting down.\")\n"
"        httpd.server_close()"

