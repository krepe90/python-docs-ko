# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/email.header.rst:2
#, fuzzy
msgid ":mod:`!email.header`: Internationalized headers"
msgstr ":mod:`email.header`: 국제화된 헤더"

#: ../../library/email.header.rst:7
msgid "**Source code:** :source:`Lib/email/header.py`"
msgstr "**소스 코드:** :source:`Lib/email/header.py`"

#: ../../library/email.header.rst:11
msgid ""
"This module is part of the legacy (``Compat32``) email API.  In the "
"current API encoding and decoding of headers is handled transparently by "
"the dictionary-like API of the :class:`~email.message.EmailMessage` "
"class.  In addition to uses in legacy code, this module can be useful in "
"applications that need to completely control the character sets used when"
" encoding headers."
msgstr ""
"이 모듈은 레거시 (``Compat32``) 이메일 API의 일부입니다. 현재 API에서 헤더의 인코딩과 디코딩은 "
":class:`~email.message.EmailMessage` 클래스의 딕셔너리와 유사한 API에 의해 투명하게 처리됩니다. "
"레거시 코드에서 사용하는 것 외에도, 이 모듈은 헤더를 인코딩할 때 사용되는 문자 집합을 완전히 제어해야 하는 응용 프로그램에서 "
"유용할 수 있습니다."

#: ../../library/email.header.rst:17
msgid ""
"The remaining text in this section is the original documentation of the "
"module."
msgstr "이 섹션의 나머지 텍스트는 모듈의 원본 설명서입니다."

#: ../../library/email.header.rst:19
msgid ""
":rfc:`2822` is the base standard that describes the format of email "
"messages. It derives from the older :rfc:`822` standard which came into "
"widespread use at a time when most email was composed of ASCII characters"
" only.  :rfc:`2822` is a specification written assuming email contains "
"only 7-bit ASCII characters."
msgstr ""
":rfc:`2822`\\는 이메일 메시지 형식을 기술하는 기본 표준입니다. 대부분의 이메일이 ASCII 문자로만 구성된 당시에 널리"
" 사용된 이전 :rfc:`822` 표준에서 파생됩니다. :rfc:`2822`\\는 이메일에 7비트 ASCII 문자만 포함되어 있다고"
" 가정한 명세입니다."

#: ../../library/email.header.rst:24
msgid ""
"Of course, as email has been deployed worldwide, it has become "
"internationalized, such that language specific character sets can now be "
"used in email messages.  The base standard still requires email messages "
"to be transferred using only 7-bit ASCII characters, so a slew of RFCs "
"have been written describing how to encode email containing non-ASCII "
"characters into :rfc:`2822`\\ -compliant format. These RFCs include "
":rfc:`2045`, :rfc:`2046`, :rfc:`2047`, and :rfc:`2231`. The :mod:`email` "
"package supports these standards in its :mod:`email.header` and "
":mod:`email.charset` modules."
msgstr ""
"물론, 이메일이 전 세계에 배포되면서, 국제화되어 언어별 문자 집합을 이메일 메시지에 사용할 수 있게 되었습니다. 기본 표준에서는 "
"여전히 7비트 ASCII 문자만 사용하여 이메일 메시지를 전송해야 하므로, ASCII가 아닌 문자가 포함된 이메일을 "
":rfc:`2822` 호환 형식으로 인코딩하는 방법을 설명하는 많은 RFC가 작성되었습니다. 이러한 RFC에는 "
":rfc:`2045`, :rfc:`2046`, :rfc:`2047` 및 :rfc:`2231`\\이 포함됩니다. "
":mod:`email` 패키지는 :mod:`email.header`\\와 :mod:`email.charset` 모듈에서 이러한 "
"표준을 지원합니다."

#: ../../library/email.header.rst:33
msgid ""
"If you want to include non-ASCII characters in your email headers, say in"
" the :mailheader:`Subject` or :mailheader:`To` fields, you should use the"
" :class:`Header` class and assign the field in the "
":class:`~email.message.Message` object to an instance of :class:`Header` "
"instead of using a string for the header value.  Import the "
":class:`Header` class from the :mod:`email.header` module. For example::"
msgstr ""
"이메일 헤더에 ASCII가 아닌 문자를 포함 시키려면 (가령 :mailheader:`Subject`\\나 "
":mailheader:`To` 필드에), :class:`Header` 클래스를 사용하고 헤더 값에 문자열을 사용하는 대신 "
":class:`~email.message.Message` 객체의 필드를 :class:`Header` 인스턴스로 대입해야 합니다. "
":mod:`email.header` 모듈에서 :class:`Header` 클래스를 임포트 합니다. 예를 들면::"

#: ../../library/email.header.rst:40
msgid ""
">>> from email.message import Message\n"
">>> from email.header import Header\n"
">>> msg = Message()\n"
">>> h = Header('p\\xf6stal', 'iso-8859-1')\n"
">>> msg['Subject'] = h\n"
">>> msg.as_string()\n"
"'Subject: =?iso-8859-1?q?p=F6stal?=\\n\\n'"
msgstr ""

#: ../../library/email.header.rst:50
msgid ""
"Notice here how we wanted the :mailheader:`Subject` field to contain a "
"non-ASCII character?  We did this by creating a :class:`Header` instance "
"and passing in the character set that the byte string was encoded in.  "
"When the subsequent :class:`~email.message.Message` instance was "
"flattened, the :mailheader:`Subject` field was properly :rfc:`2047` "
"encoded.  MIME-aware mail readers would show this header using the "
"embedded ISO-8859-1 character."
msgstr ""
":mailheader:`Subject` 필드에 비 ASCII 문자를 포함하기 위해 어떻게 했는지 아시겠습니까? 우리는 "
":class:`Header` 인스턴스를 만들고 바이트 문자열이 인코딩된 문자 집합을 전달하여 이를 수행했습니다. 뒤에 "
":class:`~email.message.Message` 인스턴스가 평탄화될 때, :mailheader:`Subject` 필드는 "
"올바르게 :rfc:`2047` 인코딩되었습니다. MIME 인식 메일 리더는 내장된 ISO-8859-1 문자를 사용하여 이 헤더를 "
"표시하게 됩니다."

#: ../../library/email.header.rst:57
msgid "Here is the :class:`Header` class description:"
msgstr ":class:`Header` 클래스 설명은 다음과 같습니다:"

#: ../../library/email.header.rst:62
msgid ""
"Create a MIME-compliant header that can contain strings in different "
"character sets."
msgstr "다른 문자 집합의 문자열을 포함할 수 있는 MIME 호환 헤더를 만듭니다."

#: ../../library/email.header.rst:65
msgid ""
"Optional *s* is the initial header value.  If ``None`` (the default), the"
" initial header value is not set.  You can later append to the header "
"with :meth:`append` method calls.  *s* may be an instance of "
":class:`bytes` or :class:`str`, but see the :meth:`append` documentation "
"for semantics."
msgstr ""
"선택적 *s*\\는 초기 헤더 값입니다. ``None``\\(기본값)이면, 초기 헤더 값이 설정되지 않습니다. 나중에 "
":meth:`append` 메서드 호출로 헤더에 추가할 수 있습니다. *s*\\는 :class:`bytes`\\나 "
":class:`str`\\의 인스턴스일 수 있지만, 의미에 대해서는 :meth:`append` 설명서를 참조하십시오."

#: ../../library/email.header.rst:70
msgid ""
"Optional *charset* serves two purposes: it has the same meaning as the "
"*charset* argument to the :meth:`append` method.  It also sets the "
"default character set for all subsequent :meth:`append` calls that omit "
"the *charset* argument.  If *charset* is not provided in the constructor "
"(the default), the ``us-ascii`` character set is used both as *s*'s "
"initial charset and as the default for subsequent :meth:`append` calls."
msgstr ""
"선택적 *charset*\\은 두 가지 용도로 사용됩니다: :meth:`append` 메서드에 대한 *charset* 인자와 같은 "
"의미입니다. 또한, *charset* 인자를 생략하는 모든 후속 :meth:`append` 호출에 대한 기본 문자 집합을 "
"설정합니다. *charset*\\이 생성자에 제공되지 않으면 (기본값), ``us-ascii`` 문자 집합이 *s*\\의 초기 문자"
" 집합과 후속 :meth:`append` 호출의 기본값으로 사용됩니다."

#: ../../library/email.header.rst:77
#, fuzzy
msgid ""
"The maximum line length can be specified explicitly via *maxlinelen*.  "
"For splitting the first line to a shorter value (to account for the field"
" header which isn't included in *s*, e.g. :mailheader:`Subject`) pass in "
"the name of the field in *header_name*.  The default *maxlinelen* is 78, "
"and the default value for *header_name* is ``None``, meaning it is not "
"taken into account for the first line of a long, split header."
msgstr ""
"최대 줄 길이는 *maxlinelen*\\을 통해 명시적으로 지정할 수 있습니다. (*s*\\에 포함되지 않은 필드 헤더를 고려하기"
" 위해, 예를 들어 :mailheader:`Subject`) 첫 번째 줄을 더 짧은 값으로 분할하려면 *header_name*\\에"
" 필드 이름을 전달하십시오. 기본 *maxlinelen*\\은 76이고, *header_name*\\의 기본값은 "
"``None``\\입니다, 이는 긴 분할 헤더의 첫 번째 줄을 고려하지 않음을 의미합니다."

#: ../../library/email.header.rst:84
msgid ""
"Optional *continuation_ws* must be :rfc:`2822`\\ -compliant folding "
"whitespace, and is usually either a space or a hard tab character.  This "
"character will be prepended to continuation lines.  *continuation_ws* "
"defaults to a single space character."
msgstr ""
"선택적인 *continuation_ws*\\는 :rfc:`2822` 호환 접는 공백(folding whitespace)이어야하며, "
"일반적으로 스페이스나 하드 탭 문자입니다. 이 문자는 연속 줄 앞에 추가됩니다. *continuation_ws*\\는 기본적으로 "
"단일 스페이스 문자입니다."

#: ../../library/email.header.rst:89
msgid "Optional *errors* is passed straight through to the :meth:`append` method."
msgstr "선택적 *errors*\\는 :meth:`append` 메서드로 바로 전달됩니다."

#: ../../library/email.header.rst:94
msgid "Append the string *s* to the MIME header."
msgstr "문자열 *s*\\를 MIME 헤더에 추가합니다."

#: ../../library/email.header.rst:96
msgid ""
"Optional *charset*, if given, should be a :class:`~email.charset.Charset`"
" instance (see :mod:`email.charset`) or the name of a character set, "
"which will be converted to a :class:`~email.charset.Charset` instance.  A"
" value of ``None`` (the default) means that the *charset* given in the "
"constructor is used."
msgstr ""
"선택적인 *charset*\\(제공되면)은 :class:`~email.charset.Charset` "
"인스턴스(:mod:`email.charset`\\을 참조하십시오)나 문자 집합의 이름이어야 하며, 이는 "
":class:`~email.charset.Charset` 인스턴스로 변환됩니다. ``None``\\(기본값) 값은 생성자에 지정된 "
"*charset*\\이 사용됨을 의미합니다."

#: ../../library/email.header.rst:102
msgid ""
"*s* may be an instance of :class:`bytes` or :class:`str`.  If it is an "
"instance of :class:`bytes`, then *charset* is the encoding of that byte "
"string, and a :exc:`UnicodeError` will be raised if the string cannot be "
"decoded with that character set."
msgstr ""
"*s*\\는 :class:`bytes`\\나 :class:`str`\\의 인스턴스일 수 있습니다. :class:`bytes`\\의 "
"인스턴스이면, *charset*\\은 해당 바이트 문자열의 인코딩이며, 문자열을 해당 문자 집합으로 디코딩할 수 없으면 "
":exc:`UnicodeError`\\가 발생합니다."

#: ../../library/email.header.rst:107
msgid ""
"If *s* is an instance of :class:`str`, then *charset* is a hint "
"specifying the character set of the characters in the string."
msgstr "*s*\\가 :class:`str`\\의 인스턴스이면, *charset*\\은 문자열에 있는 문자의 문자 집합을 지정하는 힌트입니다."

#: ../../library/email.header.rst:110
msgid ""
"In either case, when producing an :rfc:`2822`\\ -compliant header using "
":rfc:`2047` rules, the string will be encoded using the output codec of "
"the charset.  If the string cannot be encoded using the output codec, a "
"UnicodeError will be raised."
msgstr ""
"두 경우 모두, :rfc:`2047` 규칙을 사용하여 :rfc:`2822` 호환 헤더를 생성할 때, 문자열은 charset의 출력 "
"코덱을 사용하여 인코딩됩니다. 출력 코덱을 사용하여 문자열을 인코딩할 수 없으면 UnicodeError가 발생합니다."

#: ../../library/email.header.rst:115
msgid ""
"Optional *errors* is passed as the errors argument to the decode call if "
"*s* is a byte string."
msgstr "선택적 *errors*\\는 *s*\\가 바이트 문자열일 때 decode 호출에 errors 인자로 전달됩니다."

#: ../../library/email.header.rst:121
msgid ""
"Encode a message header into an RFC-compliant format, possibly wrapping "
"long lines and encapsulating non-ASCII parts in base64 or quoted-"
"printable encodings."
msgstr ""
"메시지 헤더를 RFC 호환 형식으로 인코딩합니다. 긴 줄을 래핑하고 비 ASCII 부분을 base64나 quoted-"
"printable 인코딩으로 캡슐화할 수 있습니다."

#: ../../library/email.header.rst:125
msgid ""
"Optional *splitchars* is a string containing characters which should be "
"given extra weight by the splitting algorithm during normal header "
"wrapping.  This is in very rough support of :RFC:`2822`\\'s 'higher level"
" syntactic breaks':  split points preceded by a splitchar are preferred "
"during line splitting, with the characters preferred in the order in "
"which they appear in the string.  Space and tab may be included in the "
"string to indicate whether preference should be given to one over the "
"other as a split point when other split chars do not appear in the line "
"being split.  Splitchars does not affect :RFC:`2047` encoded lines."
msgstr ""
"선택적 *splitchars*\\는 일반 헤더 래핑 중 분할 알고리즘에 의해 추가 가중치를 받아야 하는 문자를 포함하는 "
"문자열입니다. 이것은 :RFC:`2822`\\의 '높은 수준의 구문 분할'을 아주 거칠게 지원합니다: 분할 문자 뒤에 오는 분리 "
"점이 줄 분할 중에 선호되며, 문자열에 나타나는 순서대로 문자가 선호됩니다. 스페이스와 탭이 문자열에 포함되어 다른 분할 문자가 "
"분할되는 줄에 나타나지 않을 때 분할 지점으로 어느 것을 선호해야 하는지를 나타낼 수 있습니다. Splitchars는 "
":RFC:`2047` 인코딩 된 줄에 영향을 미치지 않습니다."

#: ../../library/email.header.rst:135
msgid ""
"*maxlinelen*, if given, overrides the instance's value for the maximum "
"line length."
msgstr "주어지면, *maxlinelen*\\은 최대 줄 길이에 대한 인스턴스의 값을 대체합니다."

#: ../../library/email.header.rst:138
msgid ""
"*linesep* specifies the characters used to separate the lines of the "
"folded header.  It defaults to the most useful value for Python "
"application code (``\\n``), but ``\\r\\n`` can be specified in order to "
"produce headers with RFC-compliant line separators."
msgstr ""
"*linesep*\\은 접힌 헤더의 줄을 구분하는 데 사용되는 문자를 지정합니다. 기본적으로 파이썬 응용 프로그램 코드에 가장 "
"유용한 값이지만 (``\\n``), RFC 호환 줄 구분자로 헤더를 생성하기 위해 ``\\r\\n``\\을 지정할 수 있습니다."

#: ../../library/email.header.rst:143
msgid "Added the *linesep* argument."
msgstr "*linesep* 인자를 추가했습니다."

#: ../../library/email.header.rst:147
msgid ""
"The :class:`Header` class also provides a number of methods to support "
"standard operators and built-in functions."
msgstr ":class:`Header` 클래스는 표준 연산자와 내장 함수를 지원하기 위한 많은 메서드도 제공합니다."

#: ../../library/email.header.rst:152
msgid ""
"Returns an approximation of the :class:`Header` as a string, using an "
"unlimited line length.  All pieces are converted to unicode using the "
"specified encoding and joined together appropriately.  Any pieces with a "
"charset of ``'unknown-8bit'`` are decoded as ASCII using the "
"``'replace'`` error handler."
msgstr ""
"무제한 줄 길이를 사용하여, :class:`Header`\\의 근삿값을 문자열로 반환합니다. 모든 조각은 지정된 인코딩을 사용하여 "
"유니코드로 변환되고 적절하게 결합합니다. 문자 집합이 ``'unknown-8bit'`` 인 조각은 ``'replace'`` 에러 "
"처리기를 사용하여 ASCII로 디코딩됩니다."

#: ../../library/email.header.rst:158
msgid "Added handling for the ``'unknown-8bit'`` charset."
msgstr "``'unknown-8bit'`` 문자 집합에 대한 처리가 추가되었습니다."

#: ../../library/email.header.rst:164
msgid ""
"This method allows you to compare two :class:`Header` instances for "
"equality."
msgstr "이 메서드를 사용하면 두 개의 :class:`Header` 인스턴스가 같은지 비교할 수 있습니다."

#: ../../library/email.header.rst:170
msgid ""
"This method allows you to compare two :class:`Header` instances for "
"inequality."
msgstr "이 메서드를 사용하면 두 :class:`Header` 인스턴스가 다른지 비교할 수 있습니다."

#: ../../library/email.header.rst:173
msgid ""
"The :mod:`email.header` module also provides the following convenient "
"functions."
msgstr ":mod:`email.header` 모듈은 다음과 같은 편의 함수도 제공합니다."

#: ../../library/email.header.rst:178
msgid ""
"Decode a message header value without converting the character set. The "
"header value is in *header*."
msgstr "문자 집합을 변환하지 않고 메시지 헤더 값을 디코딩합니다. 헤더 값은 *header*\\에 있습니다."

#: ../../library/email.header.rst:181
msgid ""
"This function returns a list of ``(decoded_string, charset)`` pairs "
"containing each of the decoded parts of the header.  *charset* is "
"``None`` for non-encoded parts of the header, otherwise a lower case "
"string containing the name of the character set specified in the encoded "
"string."
msgstr ""
"이 함수는 헤더의 디코딩된 각 부분을 포함하는 ``(decoded_string, charset)`` 쌍의 리스트를 반환합니다. "
"*charset*\\은 헤더의 인코딩되지 않은 부분에 대해 ``None``\\이며, 그렇지 않으면 인코딩된 문자열에 지정된 문자 "
"집합의 이름을 포함하는 소문자 문자열입니다."

#: ../../library/email.header.rst:186
msgid "Here's an example::"
msgstr "예를 들면 다음과 같습니다::"

#: ../../library/email.header.rst:188
msgid ""
">>> from email.header import decode_header\n"
">>> decode_header('=?iso-8859-1?q?p=F6stal?=')\n"
"[(b'p\\xf6stal', 'iso-8859-1')]"
msgstr ""

#: ../../library/email.header.rst:195
msgid ""
"Create a :class:`Header` instance from a sequence of pairs as returned by"
" :func:`decode_header`."
msgstr ""
":func:`decode_header`\\에 의해 반환된 것과 같은 쌍의 시퀀스로부터 :class:`Header` 인스턴스를 "
"만듭니다."

#: ../../library/email.header.rst:198
msgid ""
":func:`decode_header` takes a header value string and returns a sequence "
"of pairs of the format ``(decoded_string, charset)`` where *charset* is "
"the name of the character set."
msgstr ""
":func:`decode_header`\\는 헤더 값 문자열을 취하고 ``(decoded_string, charset)`` 형식의 "
"쌍의 시퀀스를 반환합니다. 여기서 *charset*\\은 문자 집합의 이름입니다."

#: ../../library/email.header.rst:202
msgid ""
"This function takes one of those sequence of pairs and returns a "
":class:`Header` instance.  Optional *maxlinelen*, *header_name*, and "
"*continuation_ws* are as in the :class:`Header` constructor."
msgstr ""
"이 함수는 해당 쌍의 시퀀스 중 하나를 취해서 :class:`Header` 인스턴스를 반환합니다. 선택적 *maxlinelen*, "
"*header_name* 및 *continuation_ws*\\는 :class:`Header` 생성자에서와 같습니다."

