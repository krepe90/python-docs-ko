# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/dataclasses.rst:2
#, fuzzy
msgid ":mod:`!dataclasses` --- Data Classes"
msgstr ":mod:`dataclasses` --- 데이터 클래스"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**소스 코드:** :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
#, fuzzy
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special methods <special method>` such as "
":meth:`~object.__init__` and :meth:`~object.__repr__` to user-defined "
"classes.  It was originally described in :pep:`557`."
msgstr ""
"이 모듈은 :meth:`__init__` 나 :meth:`__repr__` 과 같은 생성된 :term:`특수 메서드 <special"
" method>` 를 사용자 정의 클래스에 자동으로 추가하는 데코레이터와 함수를 제공합니다. 원래 :pep:`557` 에 설명되어 "
"있습니다."

#: ../../library/dataclasses.rst:19
#, fuzzy
msgid ""
"The member variables to use in these generated methods are defined using "
":pep:`526` type annotations.  For example, this code::"
msgstr "생성된 메서드에서 사용할 멤버 변수는 :pep:`526` 형 어노테이션을 사용하여 정의됩니다. 예를 들어, 이 코드는::"

#: ../../library/dataclasses.rst:22
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"
msgstr ""

#: ../../library/dataclasses.rst:34
#, fuzzy
msgid "will add, among other things, a :meth:`!__init__` that looks like::"
msgstr "다른 것 중에서도, 다음과 같은 :meth:`__init__` 를 추가합니다::"

#: ../../library/dataclasses.rst:36
msgid ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"
msgstr ""

#: ../../library/dataclasses.rst:41
#, fuzzy
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the :class:`!InventoryItem` definition shown above."
msgstr "이 메서드는 클래스에 자동으로 추가됩니다: 위의 ``InventoryItem`` 정의에서 직접 지정되지는 않았습니다."

#: ../../library/dataclasses.rst:47
msgid "Module contents"
msgstr ""

#: ../../library/dataclasses.rst:51
#, fuzzy
msgid ""
"This function is a :term:`decorator` that is used to add generated "
":term:`special methods <special method>` to classes, as described below."
msgstr ""
"이 함수는 (아래에서 설명하는) 생성된 :term:`특수 메서드 <special method>`\\를 클래스에 추가하는데 사용되는 "
":term:`데코레이터 <decorator>` 입니다."

#: ../../library/dataclasses.rst:54
#, fuzzy
msgid ""
"The ``@dataclass`` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type "
"annotation <variable annotation>`.  With two exceptions described below, "
"nothing in ``@dataclass`` examines the type specified in the variable "
"annotation."
msgstr ""
":func:`dataclass` 데코레이터는 클래스를 검사하여 필드를 찾습니다. 필드는 :term:`형 어노테이션 <variable"
" annotation>`\\을 가진 클래스 변수로 정의됩니다. 아래에 설명된 두 가지 예외를 제외하고는, "
":func:`dataclass` 는 변수 어노테이션에 지정된 형을 검사하지 않습니다."

#: ../../library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr "생성된 모든 메서드의 필드 순서는 클래스 정의에 나타나는 순서입니다."

#: ../../library/dataclasses.rst:63
#, fuzzy
msgid ""
"The ``@dataclass`` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the"
" class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
":func:`dataclass` 데코레이터는 여러 \"던더(dunder)\" 메서드들을 클래스에 추가하는데, 아래에서 설명합니다. "
"추가할 메서드가 클래스에 이미 존재하면, 동작은 아래에 설명된 대로 매개변수에 따라 다릅니다. 데코레이터는 호출된 클래스와 같은 "
"클래스를 반환합니다; 새 클래스가 만들어지지 않습니다."

#: ../../library/dataclasses.rst:69
#, fuzzy
msgid ""
"If ``@dataclass`` is used just as a simple decorator with no parameters, "
"it acts as if it has the default values documented in this signature.  "
"That is, these three uses of ``@dataclass`` are equivalent::"
msgstr ""
":func:`dataclass` 가 매개변수 없는 단순한 데코레이터로 사용되면, 이 서명에 문서화 된 기본값들이 제공된 것처럼 "
"행동합니다. 즉, 다음 :func:`dataclass` 의 세 가지 용법은 동등합니다::"

#: ../../library/dataclasses.rst:74
msgid ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False,"
" frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, "
"weakref_slot=False)\n"
"class C:\n"
"    ..."
msgstr ""

#: ../../library/dataclasses.rst:87
#, fuzzy
msgid "The parameters to ``@dataclass`` are:"
msgstr ":func:`dataclass` 의 매개변수는 다음과 같습니다:"

#: ../../library/dataclasses.rst:89
#, fuzzy
msgid ""
"*init*: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr "``init``: 참(기본값)이면, :meth:`__init__` 메서드가 생성됩니다."

#: ../../library/dataclasses.rst:92
#, fuzzy
msgid "If the class already defines :meth:`!__init__`, this parameter is ignored."
msgstr "클래스가 이미 :meth:`__init__` 를 정의했으면, 이 매개변수는 무시됩니다."

#: ../../library/dataclasses.rst:95
#, fuzzy
msgid ""
"*repr*: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the "
"name and repr of each field, in the order they are defined in the class."
"  Fields that are marked as being excluded from the repr are not "
"included.  For example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"``repr``: 참(기본값)이면, :meth:`__repr__` 메서드가 생성됩니다. 생성된 repr 문자열은 클래스 이름과 각 "
"필드의 이름과 repr 을 갖습니다. 각 필드는 클래스에 정의된 순서대로 표시됩니다. repr에서 제외하도록 표시된 필드는 포함되지"
" 않습니다. 예를 들어: 예 :``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."

#: ../../library/dataclasses.rst:102
#, fuzzy
msgid "If the class already defines :meth:`!__repr__`, this parameter is ignored."
msgstr "클래스가 이미 :meth:`__repr__` 을 정의했으면, 이 매개변수는 무시됩니다."

#: ../../library/dataclasses.rst:105
#, fuzzy
msgid ""
"*eq*: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the "
"identical type."
msgstr ""
"``eq``: 참(기본값)이면, :meth:`__eq__` 메서드가 생성됩니다. 이 메서드는 클래스를 필드의 튜플인 것처럼 순서대로"
" 비교합니다. 비교되는 두 인스턴스는 같은 형이어야 합니다."

#: ../../library/dataclasses.rst:110
#, fuzzy
msgid "If the class already defines :meth:`!__eq__`, this parameter is ignored."
msgstr "클래스가 이미 :meth:`__eq__` 를 정의했으면, 이 매개변수는 무시됩니다."

#: ../../library/dataclasses.rst:113
#, fuzzy
msgid ""
"*order*: If true (the default is ``False``), :meth:`~object.__lt__`, "
":meth:`~object.__le__`, :meth:`~object.__gt__`, and "
":meth:`~object.__ge__` methods will be generated.  These compare the "
"class as if it were a tuple of its fields, in order.  Both instances in "
"the comparison must be of the identical type.  If *order* is true and "
"*eq* is false, a :exc:`ValueError` is raised."
msgstr ""
"``order``: 참이면 (기본값은 ``False``), :meth:`__lt__`, :meth:`__le__`, "
":meth:`__gt__`, :meth:`__ge__` 메서드가 생성됩니다. 이것들은 클래스를 필드의 튜플인 것처럼 순서대로 "
"비교합니다. 비교되는 두 인스턴스는 같은 형이어야 합니다. ``order`` 가 참이고 ``eq`` 가 거짓이면 "
":exc:`ValueError` 가 발생합니다."

#: ../../library/dataclasses.rst:120
#, fuzzy
msgid ""
"If the class already defines any of :meth:`!__lt__`, :meth:`!__le__`, "
":meth:`!__gt__`, or :meth:`!__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"클래스가 이미 :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, :meth:`__ge__` 중 "
"하나를 정의하고 있다면 :exc:`TypeError` 가 발생합니다."

#: ../../library/dataclasses.rst:124
#, fuzzy
msgid ""
"*unsafe_hash*: If ``False`` (the default), a :meth:`~object.__hash__` "
"method is generated according to how *eq* and *frozen* are set."
msgstr ""
"``unsafe_hash``: ``False`` (기본값) 면 : ``eq`` 와 ``frozen`` 의 설정에 따라 "
":meth:`__hash__` 메서드가 생성됩니다."

#: ../../library/dataclasses.rst:127
#, fuzzy
msgid ""
":meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a "
":meth:`!__hash__` implies that instances of the class are immutable. "
"Mutability is a complicated property that depends on the programmer's "
"intent, the existence and behavior of :meth:`!__eq__`, and the values of "
"the *eq* and *frozen* flags in the ``@dataclass`` decorator."
msgstr ""
":meth:`__hash__` 는 내장 :meth:`hash()` 에 의해 사용되며, 딕셔너리와 집합 같은 해시 컬렉션에 객체가 "
"추가될 때 사용됩니다. :meth:`__hash__` 를 갖는다는 것은 클래스의 인스턴스가 불변이라는 것을 의미합니다. 가변성은 "
"프로그래머의 의도, :meth:`__eq__` 의 존재와 행동, :func:`dataclass` 데코레이터의 ``eq`` 와 "
"``frozen`` 플래그의 값에 의존하는 복잡한 성질입니다."

#: ../../library/dataclasses.rst:134
#, fuzzy
msgid ""
"By default, ``@dataclass`` will not implicitly add a "
":meth:`~object.__hash__` method unless it is safe to do so.  Neither will"
" it add or change an existing explicitly defined :meth:`!__hash__` "
"method.  Setting the class attribute ``__hash__ = None`` has a specific "
"meaning to Python, as described in the :meth:`!__hash__` documentation."
msgstr ""
"기본적으로, :func:`dataclass` 는 안전하지 않다면 :meth:`__hash__` 메서드를 묵시적으로 추가하지 "
"않습니다. 기존에 명시적으로 정의된 :meth:`__hash__` 메서드를 추가하거나 변경하지도 않습니다. "
":meth:`__hash__` 문서에서 설명된 대로, 클래스 어트리뷰트를 ``__hash__ = None`` 로 설정하는 것은 "
"파이썬에 특별한 의미가 있습니다."

#: ../../library/dataclasses.rst:140
#, fuzzy
msgid ""
"If :meth:`!__hash__` is not explicitly defined, or if it is set to "
"``None``, then ``@dataclass`` *may* add an implicit :meth:`!__hash__` "
"method. Although not recommended, you can force ``@dataclass`` to create "
"a :meth:`!__hash__` method with ``unsafe_hash=True``. This might be the "
"case if your class is logically immutable but can still be mutated. This "
"is a specialized use case and should be considered carefully."
msgstr ""
":meth:`__hash__` 가 명시적으로 정의되어 있지 않거나 ``None`` 으로 설정된 경우, "
":func:`dataclass` 는 묵시적 :meth:`__hash__` 메서드를 *추가할 수 있습니다*. 권장하지는 않지만, "
"``unsafe_hash=True`` 로 :func:`dataclass` 가 :meth:`__hash__` 메서드를 만들도록 강제할"
" 수 있습니다. 이것은 당신의 클래스가 논리적으로 불변이지만, 그런데도 변경될 수 있는 경우 일 수 있습니다. 이는 특수한 사용 "
"사례이므로 신중하게 고려해야 합니다."

#: ../../library/dataclasses.rst:147
#, fuzzy
msgid ""
"Here are the rules governing implicit creation of a :meth:`!__hash__` "
"method.  Note that you cannot both have an explicit :meth:`!__hash__` "
"method in your dataclass and set ``unsafe_hash=True``; this will result "
"in a :exc:`TypeError`."
msgstr ""
"다음은 :meth:`__hash__` 메서드의 묵시적 생성을 관장하는 규칙입니다. 데이터 클래스에 명시적 "
":meth:`__hash__` 메서드를 가지면서 ``unsafe_hash=True`` 를 설정할 수는 없습니다; 그러면 "
":exc:`TypeError` 가 발생합니다."

#: ../../library/dataclasses.rst:152
#, fuzzy
msgid ""
"If *eq* and *frozen* are both true, by default ``@dataclass`` will "
"generate a :meth:`!__hash__` method for you.  If *eq* is true and "
"*frozen* is false, :meth:`!__hash__` will be set to ``None``, marking it "
"unhashable (which it is, since it is mutable).  If *eq* is false, "
":meth:`!__hash__` will be left untouched meaning the :meth:`!__hash__` "
"method of the superclass will be used (if the superclass is "
":class:`object`, this means it will fall back to id-based hashing)."
msgstr ""
"``eq`` 와 ``frozen`` 이 모두 참이면, 기본적으로 :func:`dataclass` 는 :meth:`__hash__` "
"메서드를 만듭니다. ``eq`` 가 참이고 ``frozen`` 이 거짓이면, :meth:`__hash__` 가 ``None`` 으로"
" 설정되어 해시 불가능하다고 표시됩니다(가변이기 때문입니다). 만약 ``eq`` 가 거짓이면, :meth:`__hash__` 를 "
"건드리지 않는데, 슈퍼 클래스의 :meth:`__hash__` 가 사용된다는 뜻이 됩니다 (슈퍼 클래스가 "
":class:`object` 라면, id 기반 해싱으로 돌아간다는 뜻입니다)."

#: ../../library/dataclasses.rst:160
#, fuzzy
msgid ""
"*frozen*: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If "
":meth:`~object.__setattr__` or :meth:`~object.__delattr__` is defined in "
"the class, then :exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"``frozen``: 참이면 (기본값은 ``False``), 필드에 대입하면 예외를 발생시킵니다. 이것은 읽기 전용 고정 인스턴스를"
" 흉내 냅니다. :meth:`__setattr__` 또는 :meth:`__delattr__` 이 클래스에 정의되어 있다면 "
":exc:`TypeError` 가 발생합니다. 아래 토론을 참조하십시오."

#: ../../library/dataclasses.rst:165
msgid ""
"*match_args*: If true (the default is ``True``), the "
":attr:`~object.__match_args__` tuple will be created from the list of non"
" keyword-only parameters to the generated :meth:`~object.__init__` method"
" (even if :meth:`!__init__` is not generated, see above).  If false, or "
"if :attr:`!__match_args__` is already defined in the class, then "
":attr:`!__match_args__` will not be generated."
msgstr ""

#: ../../library/dataclasses.rst:174
msgid ""
"*kw_only*: If true (the default value is ``False``), then all fields will"
" be marked as keyword-only.  If a field is marked as keyword-only, then "
"the only effect is that the :meth:`~object.__init__` parameter generated "
"from a keyword-only field must be specified with a keyword when "
":meth:`!__init__` is called. See the :term:`parameter` glossary entry for"
" details.  Also see the :const:`KW_ONLY` section."
msgstr ""

#: ../../library/dataclasses.rst:182
msgid "Keyword-only fields are not included in :attr:`!__match_args__`."
msgstr ""

#: ../../library/dataclasses.rst:186
#, fuzzy
msgid ""
"*slots*: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the"
" original one. If :attr:`!__slots__` is already defined in the class, "
"then :exc:`TypeError` is raised."
msgstr ""
"``frozen``: 참이면 (기본값은 ``False``), 필드에 대입하면 예외를 발생시킵니다. 이것은 읽기 전용 고정 인스턴스를"
" 흉내 냅니다. :meth:`__setattr__` 또는 :meth:`__delattr__` 이 클래스에 정의되어 있다면 "
":exc:`TypeError` 가 발생합니다. 아래 토론을 참조하십시오."

#: ../../library/dataclasses.rst:192
msgid ""
"Calling no-arg :func:`super` in dataclasses using ``slots=True`` will "
"result in the following exception being raised: ``TypeError: super(type, "
"obj): obj must be an instance or subtype of type``. The two-arg "
":func:`super` is a valid workaround. See :gh:`90562` for full details."
msgstr ""

#: ../../library/dataclasses.rst:199
msgid ""
"Passing parameters to a base class :meth:`~object.__init_subclass__` when"
" using ``slots=True`` will result in a :exc:`TypeError`. Either use "
"``__init_subclass__`` with no parameters or use default values as a "
"workaround. See :gh:`91126` for full details."
msgstr ""

#: ../../library/dataclasses.rst:207
msgid ""
"If a field name is already included in the :attr:`!__slots__` of a base "
"class, it will not be included in the generated :attr:`!__slots__` to "
"prevent :ref:`overriding them <datamodel-note-slots>`. Therefore, do not "
"use :attr:`!__slots__` to retrieve the field names of a dataclass. Use "
":func:`fields` instead. To be able to determine inherited slots, base "
"class :attr:`!__slots__` may be any iterable, but *not* an iterator."
msgstr ""

#: ../../library/dataclasses.rst:217
msgid ""
"*weakref_slot*: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance :func:`weakref-"
"able <weakref.ref>`. It is an error to specify ``weakref_slot=True`` "
"without also specifying ``slots=True``."
msgstr ""

#: ../../library/dataclasses.rst:225
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr "필드는 선택적으로 일반적인 파이썬 문법을 사용하여 기본값을 지정할 수 있습니다::"

#: ../../library/dataclasses.rst:228
msgid ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"
msgstr ""

#: ../../library/dataclasses.rst:233
#, fuzzy
msgid ""
"In this example, both :attr:`!a` and :attr:`!b` will be included in the "
"added :meth:`~object.__init__` method, which will be defined as::"
msgstr "이 예제에서, ``a`` 와 ``b`` 모두 추가된 :meth:`__init__` 메서드에 포함되는데, 이런 식으로 정의됩니다::"

#: ../../library/dataclasses.rst:236
msgid "def __init__(self, a: int, b: int = 0):"
msgstr ""

#: ../../library/dataclasses.rst:238
#, fuzzy
msgid ""
":exc:`TypeError` will be raised if a field without a default value "
"follows a field with a default value.  This is true whether this occurs "
"in a single class, or as a result of class inheritance."
msgstr ""
"기본값이 없는 필드가 기본값이 있는 필드 뒤에 오는 경우 :exc:`TypeError` 가 발생합니다. 이것은 단일 클래스에서 "
"일어날 수도 있고, 클래스 상속의 결과일 때도 마찬가지입니다."

#: ../../library/dataclasses.rst:244
#, fuzzy
msgid ""
"For common and simple use cases, no other functionality is required.  "
"There are, however, some dataclass features that require additional per-"
"field information.  To satisfy this need for additional information, you "
"can replace the default field value with a call to the provided "
":func:`!field` function.  For example::"
msgstr ""
"일반적이고 간단한 사용 사례의 경우 다른 기능은 필요하지 않습니다. 그러나 필드별로 추가 정보가 필요한 일부 데이터 클래스 기능이 "
"있습니다. 추가 정보에 대한 필요성을 충족시키기 위해, 기본 필드 값을 제공된 :func:`field` 함수 호출로 바꿀 수 "
"있습니다. 예를 들면::"

#: ../../library/dataclasses.rst:250
msgid ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"
msgstr ""

#: ../../library/dataclasses.rst:257
#, fuzzy
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used"
" because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"위에서 보인 것처럼, ``MISSING`` 값은 ``default`` 와 ``default_factory`` 매개변수가 제공되는지를"
" 탐지하는데 사용되는 표지 객체입니다. ``None`` 이 ``default`` 에 유효한 값이기 때문에 이 표지가 사용됩니다. "
"어떤 코드도 ``MISSING`` 값을 직접 사용해서는 안 됩니다."

#: ../../library/dataclasses.rst:262
#, fuzzy
msgid "The parameters to :func:`!field` are:"
msgstr ":func:`field` 의 매개변수는 다음과 같습니다:"

#: ../../library/dataclasses.rst:264
#, fuzzy
msgid ""
"*default*: If provided, this will be the default value for this field.  "
"This is needed because the :func:`!field` call itself replaces the normal"
" position of the default value."
msgstr ""
"``default``: 제공되면, 이 필드의 기본값이 됩니다. 이것은 :meth:`field` 호출 자체가 기본값의 정상 위치를 "
"대체하기 때문에 필요합니다."

#: ../../library/dataclasses.rst:268
#, fuzzy
msgid ""
"*default_factory*: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among "
"other purposes, this can be used to specify fields with mutable default "
"values, as discussed below.  It is an error to specify both *default* and"
" *default_factory*."
msgstr ""
"``default_factory``: 제공되면, 이 필드의 기본값이 필요할 때 호출되는 인자가 없는 콜러블이어야 합니다. 여러 용도"
" 중에서도, 이것은 아래에서 논의되는 것처럼 가변 기본값을 가진 필드를 지정하는 데 사용될 수 있습니다. ``default`` 와 "
"``default_factory`` 를 모두 지정하는 것은 에러입니다."

#: ../../library/dataclasses.rst:274
#, fuzzy
msgid ""
"*init*: If true (the default), this field is included as a parameter to "
"the generated :meth:`~object.__init__` method."
msgstr "``init``: 참(기본값)이면, 이 필드는 생성된 :meth:`__init__` 메서드의 매개변수로 포함됩니다."

#: ../../library/dataclasses.rst:277
#, fuzzy
msgid ""
"*repr*: If true (the default), this field is included in the string "
"returned by the generated :meth:`~object.__repr__` method."
msgstr "``repr``: 참(기본값)이면, 이 필드는 생성된 :meth:`__repr__` 메서드가 돌려주는 문자열에 포함됩니다."

#: ../../library/dataclasses.rst:280
#, fuzzy
msgid ""
"*hash*: This can be a bool or ``None``.  If true, this field is included "
"in the generated :meth:`~object.__hash__` method.  If false, this field "
"is excluded from the generated :meth:`~object.__hash__`. If ``None`` (the"
" default), use the value of *compare*: this would normally be the "
"expected behavior, since a field should be included in the hash if it's "
"used for comparisons.  Setting this value to anything other than ``None``"
" is discouraged."
msgstr ""
"``hash``: 이것은 bool 또는 ``None`` 일 수 있습니다. 참이면, 이 필드는 생성된 :meth:`__hash__` "
"메서드에 포함됩니다. ``None`` (기본값) 이면, ``compare`` 의 값을 사용합니다. 이것은 일반적으로 기대되는 "
"행동입니다. 필드가 비교에 사용되면 해시에서 고려해야 합니다. 이 값을 ``None`` 이외의 값으로 설정하는 것은 권장하지 "
"않습니다."

#: ../../library/dataclasses.rst:288
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be "
"if a field is expensive to compute a hash value for, that field is needed"
" for equality testing, and there are other fields that contribute to the "
"type's hash value.  Even if a field is excluded from the hash, it will "
"still be used for comparisons."
msgstr ""
"``hash=False`` 이지만 ``compare=True`` 로 설정하는 한 가지 가능한 이유는, 동등 비교에 포함되는 필드가 "
"해시값을 계산하는 데 비용이 많이 들고, 형의 해시값에 이바지하는 다른 필드가 있는 경우입니다. 필드가 해시에서 제외된 경우에도 "
"비교에는 계속 사용됩니다."

#: ../../library/dataclasses.rst:294
#, fuzzy
msgid ""
"*compare*: If true (the default), this field is included in the generated"
" equality and comparison methods (:meth:`~object.__eq__`, "
":meth:`~object.__gt__`, et al.)."
msgstr ""
"``compare``: 참(기본값)이면, 이 필드는 생성된 같음 및 비교 메서드(:meth:`__eq__`, "
":meth:`__gt__` 등)에 포함됩니다."

#: ../../library/dataclasses.rst:298
#, fuzzy
msgid ""
"*metadata*: This can be a mapping or ``None``. ``None`` is treated as an "
"empty dict.  This value is wrapped in :func:`~types.MappingProxyType` to "
"make it read-only, and exposed on the :class:`Field` object. It is not "
"used at all by Data Classes, and is provided as a third-party extension "
"mechanism. Multiple third-parties can each have their own key, to use as "
"a namespace in the metadata."
msgstr ""
"``metadata``: 매핑이나 None이 될 수 있습니다. None은 빈 딕셔너리로 취급됩니다. 이 값은 "
":func:`~types.MappingProxyType` 로 감싸져서 읽기 전용으로 만들어지고, :class:`Field` 객체에 "
"노출됩니다. 데이터 클래스에서는 전혀 사용되지 않으며, 제삼자 확장 메커니즘으로 제공됩니다. 여러 제삼자는 이름 공간으로 사용할 "
"자신만의 키를 가질 수 있습니다."

#: ../../library/dataclasses.rst:306
msgid ""
"*kw_only*: If true, this field will be marked as keyword-only. This is "
"used when the generated :meth:`~object.__init__` method's parameters are "
"computed."
msgstr ""

#: ../../library/dataclasses.rst:310
msgid "Keyword-only fields are also not included in :attr:`!__match_args__`."
msgstr ""

#: ../../library/dataclasses.rst:314
#, fuzzy
msgid ""
"If the default value of a field is specified by a call to :func:`!field`,"
" then the class attribute for this field will be replaced by the "
"specified *default* value.  If *default* is not provided, then the class "
"attribute will be deleted.  The intent is that after the "
":func:`@dataclass <dataclass>` decorator runs, the class attributes will "
"all contain the default values for the fields, just as if the default "
"value itself were specified.  For example, after::"
msgstr ""
"필드의 기본값이 :func:`field()` 호출로 지정되면, 이 필드의 클래스 어트리뷰트는 지정한 ``default`` 값으로 "
"대체됩니다. ``default`` 가 제공되지 않으면 클래스 어트리뷰트는 삭제됩니다. 그 의도는, :func:`dataclass` "
"데코레이터 실행 후에, 기본값 자체가 지정된 것처럼 클래스 어트리뷰트가 모드 필드의 기본값을 갖도록 만드는 것입니다. 예를 들어, "
"이렇게 한 후에는::"

#: ../../library/dataclasses.rst:323
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"
msgstr ""

#: ../../library/dataclasses.rst:330
#, fuzzy
msgid ""
"The class attribute :attr:`!C.z` will be ``10``, the class attribute "
":attr:`!C.t` will be ``20``, and the class attributes :attr:`!C.x` and "
":attr:`!C.y` will not be set."
msgstr ""
"클래스 어트리뷰트 ``C.z`` 는 ``10`` 이 되고, 클래스 어트리뷰트 ``C.t`` 는 ``20`` 이 되고, 클래스 "
"어트리뷰트 ``C.x`` 와 ``C.y`` 는 설정되지 않게 됩니다."

#: ../../library/dataclasses.rst:336
#, fuzzy
msgid ""
":class:`!Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`!Field` "
"object directly.  Its documented attributes are:"
msgstr ""
":class:`Field` 객체는 정의된 각 필드를 설명합니다. 이 객체는 내부적으로 생성되며 :func:`fields` 모듈 수준"
" 메서드(아래 참조)가 돌려줍니다. 사용자는 직접 :class:`Field` 인스턴스 객체를 만들어서는 안 됩니다. 문서화 된 "
"어트리뷰트는 다음과 같습니다:"

#: ../../library/dataclasses.rst:341
#, fuzzy
msgid ":attr:`!name`: The name of the field."
msgstr "``name``: 필드의 이름."

#: ../../library/dataclasses.rst:342
#, fuzzy
msgid ":attr:`!type`: The type of the field."
msgstr "``type``: 필드의 형."

#: ../../library/dataclasses.rst:343
#, fuzzy
msgid ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`,"
" :attr:`!hash`, :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only`"
" have the identical meaning and values as they do in the :func:`field` "
"function."
msgstr ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, "
"``compare``, ``metadata`` 는 :func:`field` 선언에서와 같은 의미와 값을 가지고 있습니다."

#: ../../library/dataclasses.rst:347
msgid ""
"Other attributes may exist, but they are private and must not be "
"inspected or relied on."
msgstr "다른 어트리뷰트도 있을 수 있지만, 내부적인 것이므로 검사하거나 의존해서는 안 됩니다."

#: ../../library/dataclasses.rst:352
msgid ""
"``InitVar[T]`` type annotations describe variables that are :ref:`init-"
"only <dataclasses-init-only-variables>`. Fields annotated with "
":class:`!InitVar` are considered pseudo-fields, and thus are neither "
"returned by the :func:`fields` function nor used in any way except adding"
" them as parameters to :meth:`~object.__init__` and an optional "
":meth:`__post_init__`."
msgstr ""

#: ../../library/dataclasses.rst:361
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this"
" dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. "
"Does not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"데이터 클래스의 필드들을 정의하는 :class:`Field` 객체들의 튜플을 돌려줍니다. 데이터 클래스나 데이터 클래스의 인스턴스를"
" 받아들입니다. 데이터 클래스 나 데이터 클래스의 인스턴스를 전달하지 않으면 :exc:`TypeError` 를 돌려줍니다. "
"``ClassVar`` 또는 ``InitVar`` 인 의사 필드는 반환하지 않습니다."

#: ../../library/dataclasses.rst:368
#, fuzzy
msgid ""
"Converts the dataclass *obj* to a dict (by using the factory function "
"*dict_factory*).  Each dataclass is converted to a dict of its fields, as"
" ``name: value`` pairs.  dataclasses, dicts, lists, and tuples are "
"recursed into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"데이터 클래스 ``instance`` 를 딕셔너리로 변환합니다 (팩토리 함수 ``dict_factory`` 를 사용합니다). 각 "
"데이터 클래스는 각 필드를 ``name: value`` 쌍으로 갖는 딕셔너리로 변환됩니다. 데이터 클래스, 딕셔너리, 리스트 및 "
"튜플은 재귀적으로 변환됩니다. 예를 들면::"

#: ../../library/dataclasses.rst:374
msgid "Example of using :func:`!asdict` on nested dataclasses::"
msgstr ""

#: ../../library/dataclasses.rst:376
#, python-brace-format
msgid ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"
msgstr ""

#: ../../library/dataclasses.rst:391 ../../library/dataclasses.rst:411
msgid "To create a shallow copy, the following workaround may be used::"
msgstr ""

#: ../../library/dataclasses.rst:393
#, python-brace-format
msgid "{field.name: getattr(obj, field.name) for field in fields(obj)}"
msgstr ""

#: ../../library/dataclasses.rst:395
#, fuzzy
msgid ""
":func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr "``instance`` 가 데이터 클래스 인스턴스가 아닌 경우 :exc:`TypeError` 를 일으킵니다."

#: ../../library/dataclasses.rst:400
#, fuzzy
msgid ""
"Converts the dataclass *obj* to a tuple (by using the factory function "
"*tuple_factory*).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"데이터 클래스 ``instance`` 를 튜플로 변환합니다 (팩토리 함수 ``tuple_factory`` 를 사용합니다). 각 "
"데이터 클래스는 각 필드 값들의 튜플로 변환됩니다. 데이터 클래스, 딕셔너리, 리스트 및 튜플은 재귀적으로 변환됩니다."

#: ../../library/dataclasses.rst:406
msgid "Continuing from the previous example::"
msgstr "이전 예에서 계속하면::"

#: ../../library/dataclasses.rst:408
msgid ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"
msgstr ""

#: ../../library/dataclasses.rst:413
msgid "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"
msgstr ""

#: ../../library/dataclasses.rst:415
#, fuzzy
msgid ""
":func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr "``instance`` 가 데이터 클래스 인스턴스가 아닌 경우 :exc:`TypeError` 를 일으킵니다."

#: ../../library/dataclasses.rst:420
#, fuzzy
msgid ""
"Creates a new dataclass with name *cls_name*, fields as defined in "
"*fields*, base classes as given in *bases*, and initialized with a "
"namespace as given in *namespace*.  *fields* is an iterable whose "
"elements are each either ``name``, ``(name, type)``, or ``(name, type, "
"Field)``.  If just ``name`` is supplied, :data:`typing.Any` is used for "
"``type``.  The values of *init*, *repr*, *eq*, *order*, *unsafe_hash*, "
"*frozen*, *match_args*, *kw_only*, *slots*, and *weakref_slot* have the "
"same meaning as they do in :func:`@dataclass <dataclass>`."
msgstr ""
"새로운 데이터 클래스를 만드는데, 이름은 ``cls_name`` 이고, ``fields`` 에 정의된 필드들을 갖고, "
"``bases`` 에 주어진 베이스 클래스들을 갖고, ``namespace`` 로 주어진 이름 공간으로 초기화됩니다. "
"``fields`` 는 요소가 ``name``, ``(name, type)`` 또는 ``(name, type, Field)`` 인 "
"이터러블입니다. ``name`` 만 제공되면 ``typing.Any`` 가 ``type`` 으로 사용됩니다. ``init``, "
"``repr``, ``eq``, ``order``, ``unsafe_hash``, ``frozen`` 의 값은 "
":func:`dataclass` 에서와 같은 의미가 있습니다."

#: ../../library/dataclasses.rst:430
msgid ""
"If *module* is defined, the :attr:`!__module__` attribute of the "
"dataclass is set to that value. By default, it is set to the module name "
"of the caller."
msgstr ""

#: ../../library/dataclasses.rst:434
#, fuzzy
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with :attr:`!__annotations__` can then apply the "
":func:`@dataclass <dataclass>` function to convert that class to a "
"dataclass.  This function is provided as a convenience.  For example::"
msgstr ""
"이 함수가 꼭 필요하지는 않습니다. 임의의 파이썬 메커니즘으로 ``__annotations__`` 을 갖는 새 클래스를 만든 후에 "
":func:`dataclass` 함수를 적용하면 데이터 클래스로 변환되기 때문입니다. 이 함수는 편의상 제공됩니다. 예를 들어::"

#: ../../library/dataclasses.rst:440
#, python-brace-format
msgid ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"
msgstr ""

#: ../../library/dataclasses.rst:446
msgid "Is equivalent to::"
msgstr "는 다음과 동등합니다::"

#: ../../library/dataclasses.rst:448
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"
msgstr ""

#: ../../library/dataclasses.rst:459
#, fuzzy
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with "
"values from *changes*.  If *obj* is not a Data Class, raises "
":exc:`TypeError`.  If keys in *changes* are not field names of the given "
"dataclass, raises :exc:`TypeError`."
msgstr ""
"``instance`` 와 같은 형의 새 객체를 만드는데, 필드를 ``changes`` 의 값들로 대체합니다. "
"``instance`` 가 데이터 클래스가 아니라면 :exc:`TypeError` 를 발생시킵니다. ``changes`` 의 값이 "
"필드를 지정하지 않으면 :exc:`TypeError` 를 발생시킵니다."

#: ../../library/dataclasses.rst:464
#, fuzzy
msgid ""
"The newly returned object is created by calling the "
":meth:`~object.__init__` method of the dataclass.  This ensures that "
":meth:`__post_init__`, if present, is also called."
msgstr ""
"새로 반환된 객체는 데이터 클래스의 :meth:`__init__` 메서드를 호출하여 생성됩니다. 이렇게 함으로써 (있는 경우) "
":meth:`__post_init__` 의 호출을 보장합니다."

#: ../../library/dataclasses.rst:468
#, fuzzy
msgid ""
"Init-only variables without default values, if any exist, must be "
"specified on the call to :func:`!replace` so that they can be passed to "
":meth:`!__init__` and :meth:`__post_init__`."
msgstr ""
"기본값을 가지지 않는 초기화 전용 변수가 존재한다면, :func:`replace` 호출에 반드시 지정해서 "
":meth:`__init__` 와 :meth:`__post_init__` 에 전달 될 수 있도록 해야 합니다."

#: ../../library/dataclasses.rst:472
#, fuzzy
msgid ""
"It is an error for *changes* to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"``changes`` 가 ``init=False`` 를 갖는 것으로 정의된 필드를 포함하는 것은 에러입니다. 이 경우 "
":exc:`ValueError` 가 발생합니다."

#: ../../library/dataclasses.rst:476
#, fuzzy
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to "
":func:`!replace`.  They are not copied from the source object, but rather"
" are initialized in :meth:`__post_init__`, if they're initialized at all."
"  It is expected that ``init=False`` fields will be rarely and "
"judiciously used.  If they are used, it might be wise to have alternate "
"class constructors, or perhaps a custom :func:`!replace` (or similarly "
"named) method which handles instance copying."
msgstr ""
":func:`replace`\\를 호출하는 동안 ``init=False`` 필드가 어떻게 작동하는지 미리 경고합니다. 그것들은 소스"
" 객체로부터 복사되는 것이 아니라, (초기화되기는 한다면) :meth:`__post_init__` 에서 초기화됩니다. "
"``init=False`` 필드는 거의 사용되지 않으리라고 예상합니다. 사용된다면, 대체 클래스 생성자를 사용하거나, 인스턴스 "
"복사를 처리하는 사용자 정의 ``replace()`` (또는 비슷하게 이름 지어진) 메서드를 사용하는 것이 좋을 것입니다."

#: ../../library/dataclasses.rst:485
msgid ""
"Dataclass instances are also supported by generic function "
":func:`copy.replace`."
msgstr ""

#: ../../library/dataclasses.rst:489
#, fuzzy
msgid ""
"Return ``True`` if its parameter is a dataclass (including subclasses of "
"a dataclass) or an instance of one, otherwise return ``False``."
msgstr ""
"매개변수가 데이터 클래스나 데이터 클래스의 인스턴스면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 "
"반환합니다."

#: ../../library/dataclasses.rst:492
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"(데이터 클래스 자체가 아니라) 데이터 클래스의 인스턴스인지 알아야 한다면 ``not isinstance(obj, type)`` "
"검사를 추가하십시오::"

#: ../../library/dataclasses.rst:496
msgid ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"
msgstr ""

#: ../../library/dataclasses.rst:501
msgid "A sentinel value signifying a missing default or default_factory."
msgstr ""

#: ../../library/dataclasses.rst:505
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-"
"field with the type of :const:`!KW_ONLY` are marked as keyword-only "
"fields.  Note that a pseudo-field of type :const:`!KW_ONLY` is otherwise "
"completely ignored.  This includes the name of such a field.  By "
"convention, a name of ``_`` is used for a :const:`!KW_ONLY` field.  "
"Keyword-only fields signify :meth:`~object.__init__` parameters that must"
" be specified as keywords when the class is instantiated."
msgstr ""

#: ../../library/dataclasses.rst:514
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-"
"only fields::"
msgstr ""

#: ../../library/dataclasses.rst:516
msgid ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"
msgstr ""

#: ../../library/dataclasses.rst:525
msgid ""
"In a single dataclass, it is an error to specify more than one field "
"whose type is :const:`!KW_ONLY`."
msgstr ""

#: ../../library/dataclasses.rst:532
#, fuzzy
msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or "
":meth:`~object.__delattr__` is called on a dataclass which was defined "
"with ``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"``frozen=True`` 로 정의된 데이터 클래스에서 묵시적으로 정의된 :meth:`__setattr__` 또는 "
":meth:`__delattr__` 이 호출 될 때 발생합니다."

#: ../../library/dataclasses.rst:539
msgid "Post-init processing"
msgstr "초기화 후처리"

#: ../../library/dataclasses.rst:543
#, fuzzy
msgid ""
"When defined on the class, it will be called by the generated "
":meth:`~object.__init__`, normally as :meth:`!self.__post_init__`. "
"However, if any ``InitVar`` fields are defined, they will also be passed "
"to :meth:`!__post_init__` in the order they were defined in the class.  "
"If no :meth:`!__init__` method is generated, then :meth:`!__post_init__` "
"will not automatically be called."
msgstr ""
"클래스에 :meth:`__post_init__` 가 정의된 경우, 생성된 :meth:`__init__` 코드는 "
":meth:`__post_init__` 메서드를 호출합니다. 일반적으로 ``self.__post_init__()`` 로 호출됩니다."
" 그러나, ``InitVar`` 필드가 정의되어 있으면, 클래스에 정의된 순서대로 :meth:`__post_init__` 로 "
"전달됩니다. :meth:`__init__` 메서드가 생성되지 않으면, :meth:`__post_init__` 가 자동으로 호출되지 "
"않습니다."

#: ../../library/dataclasses.rst:550
msgid ""
"Among other uses, this allows for initializing field values that depend "
"on one or more other fields.  For example::"
msgstr "다른 용도 중에서도, 하나나 그 이상의 다른 필드에 의존하는 필드 값을 초기화하는데 사용할 수 있습니다. 예를 들면::"

#: ../../library/dataclasses.rst:553
msgid ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"
msgstr ""

#: ../../library/dataclasses.rst:562
msgid ""
"The :meth:`~object.__init__` method generated by :func:`@dataclass "
"<dataclass>` does not call base class :meth:`!__init__` methods. If the "
"base class has an :meth:`!__init__` method that has to be called, it is "
"common to call this method in a :meth:`__post_init__` method::"
msgstr ""

#: ../../library/dataclasses.rst:567
msgid ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"        self.height = height\n"
"        self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"
msgstr ""

#: ../../library/dataclasses.rst:579
msgid ""
"Note, however, that in general the dataclass-generated :meth:`!__init__` "
"methods don't need to be called, since the derived dataclass will take "
"care of initializing all fields of any base class that is a dataclass "
"itself."
msgstr ""

#: ../../library/dataclasses.rst:583
#, fuzzy
msgid ""
"See the section below on init-only variables for ways to pass parameters "
"to :meth:`!__post_init__`.  Also see the warning about how "
":func:`replace` handles ``init=False`` fields."
msgstr ""
"매개변수를 :meth:`__post_init__` 에 전달하는 방법은 초기화 전용 변수에 대한 아래 섹션을 참조하십시오. 또한 "
":func:`replace` 가 ``init=False`` 필드를 처리하는 방식에 관한 경고를 보십시오."

#: ../../library/dataclasses.rst:590
msgid "Class variables"
msgstr "클래스 변수"

#: ../../library/dataclasses.rst:592
#, fuzzy
msgid ""
"One of the few places where :func:`@dataclass <dataclass>` actually "
"inspects the type of a field is to determine if a field is a class "
"variable as defined in :pep:`526`.  It does this by checking if the type "
"of the field is :data:`typing.ClassVar`.  If a field is a ``ClassVar``, "
"it is excluded from consideration as a field and is ignored by the "
"dataclass mechanisms.  Such ``ClassVar`` pseudo-fields are not returned "
"by the module-level :func:`fields` function."
msgstr ""
":func:`dataclass` 가 실제로 필드의 형을 검사하는 두 곳 중 하나는 필드가 :pep:`526` 에 정의된 클래스 "
"변수인지를 확인하는 것입니다. 필드의 형이 ``typing.ClassVar`` 인지 검사합니다. 필드가 ``ClassVar`` 인 "
"경우, 필드로 취급되지 않고 데이터 클래스 메커니즘에서 무시됩니다. 이런 ``ClassVar`` 의사 필드는 모듈 수준 "
":func:`fields` 함수에 의해 반환되지 않습니다."

#: ../../library/dataclasses.rst:603
msgid "Init-only variables"
msgstr "초기화 전용 변수"

#: ../../library/dataclasses.rst:605
#, fuzzy
msgid ""
"Another place where :func:`@dataclass <dataclass>` inspects a type "
"annotation is to determine if a field is an init-only variable.  It does "
"this by seeing if the type of a field is of type :class:`InitVar`.  If a "
"field is an :class:`InitVar`, it is considered a pseudo-field called an "
"init-only field.  As it is not a true field, it is not returned by the "
"module-level :func:`fields` function.  Init-only fields are added as "
"parameters to the generated :meth:`~object.__init__` method, and are "
"passed to the optional :meth:`__post_init__` method.  They are not "
"otherwise used by dataclasses."
msgstr ""
":func:`dataclass` 가 형 어노테이션을 검사하는 다른 한 곳은 필드가 초기화 전용 변수인지 확인하는 것입니다. 필드의 "
"형이 ``dataclasses.InitVar`` 인지 검사합니다. 필드가 ``InitVar`` 인 경우, 초기화 전용 변수라고 "
"불리는 의사 필드로 간주합니다. 실제 필드가 아니므로, 모듈 수준 :func:`fields` 함수에 의해 반환되지 않습니다. 초기화"
" 전용 필드는 생성된 :meth:`__init__` 메서드의 매개변수로 추가되며, 선택적인 :meth:`__post_init__` "
"메서드로 전달됩니다. 이 외에 데이터 클래스에서 사용되는 곳은 없습니다."

#: ../../library/dataclasses.rst:615
msgid ""
"For example, suppose a field will be initialized from a database, if a "
"value is not provided when creating the class::"
msgstr "예를 들어, 클래스를 만들 때 값이 제공되지 않으면, 필드가 데이터베이스로부터 초기화된다고 가정합시다::"

#: ../../library/dataclasses.rst:618
msgid ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"
msgstr ""

#: ../../library/dataclasses.rst:630
#, fuzzy
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for "
":attr:`!i` and :attr:`!j`, but not for :attr:`!database`."
msgstr ""
"이 경우, :func:`fields` 는 ``i`` 와 ``j`` 를 위한 :class:`Field` 객체를 반환하지만, "
"``database`` 는 반환하지 않습니다."

#: ../../library/dataclasses.rst:636
msgid "Frozen instances"
msgstr "고정 인스턴스"

#: ../../library/dataclasses.rst:638
#, fuzzy
msgid ""
"It is not possible to create truly immutable Python objects.  However, by"
" passing ``frozen=True`` to the :func:`@dataclass <dataclass>` decorator "
"you can emulate immutability.  In that case, dataclasses will add "
":meth:`~object.__setattr__` and :meth:`~object.__delattr__` methods to "
"the class.  These methods will raise a :exc:`FrozenInstanceError` when "
"invoked."
msgstr ""
"정말로 불변인 파이썬 객체를 만드는 것은 불가능합니다. 그러나, ``frozen=True`` 를 :meth:`dataclass` "
"데코레이터에 전달함으로써 불변성을 흉내 낼 수 있습니다. 이 경우, 데이터 클래스는 :meth:`__setattr__` 과 "
":meth:`__delattr__` 메서드를 클래스에 추가합니다. 이 메서드는 호출될 때 "
":exc:`FrozenInstanceError` 를 발생시킵니다."

#: ../../library/dataclasses.rst:644
#, fuzzy
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: "
":meth:`~object.__init__` cannot use simple assignment to initialize "
"fields, and must use :meth:`!object.__setattr__`."
msgstr ""
"``frozen=True`` 를 사용할 때 약간의 성능 저하가 있습니다: :meth:`__init__` 는 필드를 초기화하는데 "
"간단한 대입을 사용할 수 없고, :meth:`object.__setattr__` 을 사용해야 합니다."

#: ../../library/dataclasses.rst:653
msgid "Inheritance"
msgstr "계승"

#: ../../library/dataclasses.rst:655
#, fuzzy
msgid ""
"When the dataclass is being created by the :func:`@dataclass <dataclass>`"
" decorator, it looks through all of the class's base classes in reverse "
"MRO (that is, starting at :class:`object`) and, for each dataclass that "
"it finds, adds the fields from that base class to an ordered mapping of "
"fields. After all of the base class fields are added, it adds its own "
"fields to the ordered mapping.  All of the generated methods will use "
"this combined, calculated ordered mapping of fields.  Because the fields "
"are in insertion order, derived classes override base classes.  An "
"example::"
msgstr ""
"데이터 클래스가 :meth:`dataclass` 데코레이터에 의해 생성될 때, 클래스의 모든 베이스 클래스들을 MRO 역순(즉, "
":class:`object` 에서 시작해서)으로 조사하고, 발견되는 데이터 클래스마다 그 베이스 클래스의 필드들을 순서 있는 필드 "
"매핑에 추가합니다. 모든 생성된 메서드들은 이 합쳐지고 계산된 순서 있는 필드 매핑을 사용합니다. 필드들이 삽입 순서이기 때문에, "
"파생 클래스는 베이스 클래스를 재정의합니다. 예::"

#: ../../library/dataclasses.rst:665
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"
msgstr ""

#: ../../library/dataclasses.rst:675
#, fuzzy
msgid ""
"The final list of fields is, in order, :attr:`!x`, :attr:`!y`, "
":attr:`!z`.  The final type of :attr:`!x` is :class:`int`, as specified "
"in class :class:`!C`."
msgstr ""
"필드의 최종 목록은 순서대로 ``x``, ``y``, ``z`` 입니다. ``x`` 의 최종 형은 클래스 ``C`` 에서 지정된 "
"``int`` 입니다."

#: ../../library/dataclasses.rst:678
#, fuzzy
msgid ""
"The generated :meth:`~object.__init__` method for :class:`!C` will look "
"like::"
msgstr "생성된 ``C`` 의 :meth:`__init__` 메서드는 이렇게 됩니다::"

#: ../../library/dataclasses.rst:680
msgid "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"
msgstr ""

#: ../../library/dataclasses.rst:683
msgid "Re-ordering of keyword-only parameters in :meth:`!__init__`"
msgstr ""

#: ../../library/dataclasses.rst:685
msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, "
"any keyword-only parameters are moved to come after all regular (non-"
"keyword-only) parameters.  This is a requirement of how keyword-only "
"parameters are implemented in Python: they must come after non-keyword-"
"only parameters."
msgstr ""

#: ../../library/dataclasses.rst:691
msgid ""
"In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are "
"keyword-only fields, and :attr:`!Base.x` and :attr:`!D.z` are regular "
"fields::"
msgstr ""

#: ../../library/dataclasses.rst:694
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"
msgstr ""

#: ../../library/dataclasses.rst:706
#, fuzzy
msgid "The generated :meth:`!__init__` method for :class:`!D` will look like::"
msgstr "생성된 ``C`` 의 :meth:`__init__` 메서드는 이렇게 됩니다::"

#: ../../library/dataclasses.rst:708
msgid ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1,"
" t: int = 0):"
msgstr ""

#: ../../library/dataclasses.rst:710
msgid ""
"Note that the parameters have been re-ordered from how they appear in the"
" list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""

#: ../../library/dataclasses.rst:714
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`!__init__` parameter list."
msgstr ""

#: ../../library/dataclasses.rst:719
msgid "Default factory functions"
msgstr "기본 팩토리 함수"

#: ../../library/dataclasses.rst:721
#, fuzzy
msgid ""
"If a :func:`field` specifies a *default_factory*, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
":func:`field` 가 ``default_factory`` 를 지정하면, 필드의 기본값이 필요할 때 인자 없이 호출됩니다. "
"예를 들어, 리스트의 새 인스턴스를 만들려면, 이렇게 하세요::"

#: ../../library/dataclasses.rst:725
msgid "mylist: list = field(default_factory=list)"
msgstr ""

#: ../../library/dataclasses.rst:727
#, fuzzy
msgid ""
"If a field is excluded from :meth:`~object.__init__` (using "
"``init=False``) and the field also specifies *default_factory*, then the "
"default factory function will always be called from the generated "
":meth:`!__init__` function.  This happens because there is no other way "
"to give the field an initial value."
msgstr ""
"필드가 (``init=False`` 를 사용해서) :meth:`__init__` 에서 제외되고, 그 필드가 "
"``default_factory`` 를 지정하면, 생성된 :meth:`__init__` 함수는 항상 기본 팩토리 함수를 호출합니다."
" 이는 필드에 초기화 값을 제공할 수 있는 다른 방법이 없기 때문입니다."

#: ../../library/dataclasses.rst:734
msgid "Mutable default values"
msgstr "가변 기본값"

#: ../../library/dataclasses.rst:736
msgid ""
"Python stores default member variable values in class attributes. "
"Consider this example, not using dataclasses::"
msgstr "파이썬은 기본 멤버 변숫값을 클래스 어트리뷰트에 저장합니다. 데이터 클래스를 사용하지 않는 이 예제를 생각해보세요::"

#: ../../library/dataclasses.rst:739
msgid ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"
msgstr ""

#: ../../library/dataclasses.rst:751
#, fuzzy
msgid ""
"Note that the two instances of class :class:`!C` share the same class "
"variable :attr:`!x`, as expected."
msgstr "클래스 ``C`` 의 두 인스턴스는 예상대로 같은 클래스 변수 ``x`` 를 공유합니다."

#: ../../library/dataclasses.rst:754
msgid "Using dataclasses, *if* this code was valid::"
msgstr "데이터 클래스를 사용해서, *만약* 이 코드가 올바르다면::"

#: ../../library/dataclasses.rst:756
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"
msgstr ""

#: ../../library/dataclasses.rst:762
msgid "it would generate code similar to::"
msgstr "비슷한 코드를 생성합니다::"

#: ../../library/dataclasses.rst:764
msgid ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"
msgstr ""

#: ../../library/dataclasses.rst:773
#, fuzzy
msgid ""
"This has the same issue as the original example using class :class:`!C`. "
"That is, two instances of class :class:`!D` that do not specify a value "
"for :attr:`!x` when creating a class instance will share the same copy of"
" :attr:`!x`.  Because dataclasses just use normal Python class creation "
"they also share this behavior.  There is no general way for Data Classes "
"to detect this condition.  Instead, the :func:`@dataclass <dataclass>` "
"decorator will raise a :exc:`ValueError` if it detects an unhashable "
"default parameter.  The assumption is that if a value is unhashable, it "
"is mutable.  This is a partial solution, but it does protect against many"
" common errors."
msgstr ""
"이것은 클래스 ``C`` 를 사용한 원래 예제와 같은 문제를 가지고 있습니다. 즉, 클래스 인스턴스를 만들 때 ``x`` 에 대한 "
"값을 지정하지 않는 클래스 ``D`` 의 두 인스턴스는 같은 ``x`` 를 공유합니다. 데이터 클래스는 일반적인 파이썬 클래스 "
"생성을 사용하기 때문에, 이 동작 역시 공유합니다. 데이터 클래스가 이 조건을 감지하는 일반적인 방법은 없습니다. 대신, 데이터 "
"클래스는 ``list``, ``dict``, ``set`` 형의 기본 매개변수를 탐지하면 :exc:`TypeError` 를 "
"발생시킵니다. 이것은 부분적인 해결책이지만, 흔한 오류로부터 보호합니다."

#: ../../library/dataclasses.rst:784
msgid ""
"Using default factory functions is a way to create new instances of "
"mutable types as default values for fields::"
msgstr "기본 팩토리 함수를 사용하면 필드의 기본값으로 가변형의 새 인스턴스를 만들 수 있습니다::"

#: ../../library/dataclasses.rst:787
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"
msgstr ""

#: ../../library/dataclasses.rst:793
msgid ""
"Instead of looking for and disallowing objects of type :class:`list`, "
":class:`dict`, or :class:`set`, unhashable objects are now not allowed as"
" default values.  Unhashability is used to approximate mutability."
msgstr ""

#: ../../library/dataclasses.rst:800
msgid "Descriptor-typed fields"
msgstr ""

#: ../../library/dataclasses.rst:802
msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their"
" default value have the following special behaviors:"
msgstr ""

#: ../../library/dataclasses.rst:805
msgid ""
"The value for the field passed to the dataclass's "
":meth:`~object.__init__` method is passed to the descriptor's "
":meth:`~object.__set__` method rather than overwriting the descriptor "
"object."
msgstr ""

#: ../../library/dataclasses.rst:809
msgid ""
"Similarly, when getting or setting the field, the descriptor's "
":meth:`~object.__get__` or :meth:`!__set__` method is called rather than "
"returning or overwriting the descriptor object."
msgstr ""

#: ../../library/dataclasses.rst:813
msgid ""
"To determine whether a field contains a default value, :func:`@dataclass "
"<dataclass>` will call the descriptor's :meth:`!__get__` method using its"
" class access form: ``descriptor.__get__(obj=None, type=cls)``.  If the "
"descriptor returns a value in this case, it will be used as the field's "
"default. On the other hand, if the descriptor raises "
":exc:`AttributeError` in this situation, no default value will be "
"provided for the field."
msgstr ""

#: ../../library/dataclasses.rst:823
msgid ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"
msgstr ""

#: ../../library/dataclasses.rst:848
msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act "
"like a normal field."
msgstr ""

#~ msgid "Module-level decorators, classes, and functions"
#~ msgstr "모듈 수준의 데코레이터, 클래스 및 함수"

#~ msgid "Exceptions"
#~ msgstr "예외"

