# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/contextvars.rst:2
msgid ":mod:`!contextvars` --- Context Variables"
msgstr ":mod:`!contextvars` --- 컨텍스트 변수"

#: ../../library/contextvars.rst:11
msgid ""
"This module provides APIs to manage, store, and access context-local "
"state.  The :class:`~contextvars.ContextVar` class is used to declare and"
" work with *Context Variables*.  The :func:`~contextvars.copy_context` "
"function and the :class:`~contextvars.Context` class should be used to "
"manage the current context in asynchronous frameworks."
msgstr ""
"이 모듈은 컨텍스트-로컬 상태를 관리, 저장, 액세스하기 위한 API를 제공합니다. "
":class:`~contextvars.ContextVar` 클래스는 *컨텍스트 변수* 를 선언하고 사용하는 데 쓰입니다. "
":func:`~contextvars.copy_context` 함수와 :class:`~contextvars.Context` 클래스는 "
"비동기 프레임워크에서 현재 컨텍스트를 관리하는 데 사용해야 합니다."

#: ../../library/contextvars.rst:17
msgid ""
"Context managers that have state should use Context Variables instead of "
":func:`threading.local` to prevent their state from bleeding to other "
"code unexpectedly, when used in concurrent code."
msgstr ""
"상태가 있는 컨텍스트 관리자는 동시성 코드에서 상태가 예기치 않게 다른 코드로 유출되는 것을 방지하기 위해 "
":func:`threading.local` 대신 컨텍스트 변수를 사용해야 합니다."

#: ../../library/contextvars.rst:21
msgid "See also :pep:`567` for additional details."
msgstr "자세한 내용은 :pep:`567`\\을 참조하십시오."

#: ../../library/contextvars.rst:27
msgid "Context Variables"
msgstr "컨텍스트 변수"

#: ../../library/contextvars.rst:31
msgid "This class is used to declare a new Context Variable, e.g.::"
msgstr "이 클래스는 새로운 컨텍스트 변수를 선언하는 데 사용됩니다. 예::"

#: ../../library/contextvars.rst:33
msgid "var: ContextVar[int] = ContextVar('var', default=42)"
msgstr "var: ContextVar[int] = ContextVar('var', default=42)"

#: ../../library/contextvars.rst:35
msgid ""
"The required *name* parameter is used for introspection and debug "
"purposes."
msgstr "필수 *name* 매개 변수는 인트로스팩션 및 디버그 목적으로 사용됩니다."

#: ../../library/contextvars.rst:38
msgid ""
"The optional keyword-only *default* parameter is returned by "
":meth:`ContextVar.get` when no value for the variable is found in the "
"current context."
msgstr ""
"선택적 키워드 전용 *default* 매개 변수는 변수에 대한 값이 현재 컨텍스트에서 발견되지 않으면 "
":meth:`ContextVar.get` 에 의해 반환됩니다."

#: ../../library/contextvars.rst:42
msgid ""
"**Important:** Context Variables should be created at the top module "
"level and never in closures.  :class:`Context` objects hold strong "
"references to context variables which prevents context variables from "
"being properly garbage collected."
msgstr ""
"**중요:** 컨텍스트 변수는 최상위 모듈 수준에서 만들어져야 하고 클로저에서 만들어져서는 안 됩니다. "
":class:`Context` 객체는 컨텍스트 변수에 대해 강한 참조를 유지해서 컨텍스트 변수가 제대로 가비지 수집되지 못하게 "
"합니다."

#: ../../library/contextvars.rst:49
msgid "The name of the variable.  This is a read-only property."
msgstr "변수의 이름. 읽기 전용 프로퍼티입니다."

#: ../../library/contextvars.rst:55
msgid "Return a value for the context variable for the current context."
msgstr "현재 컨텍스트의 컨텍스트 변수에 대한 값을 반환합니다."

#: ../../library/contextvars.rst:57
msgid ""
"If there is no value for the variable in the current context, the method "
"will:"
msgstr "현재 컨텍스트에서 변수에 대한 값이 없는 경우 메서드는:"

#: ../../library/contextvars.rst:60
msgid "return the value of the *default* argument of the method, if provided; or"
msgstr "제공된 경우 메서드의 *default* 인자 값을 반환합니다; 또는"

#: ../../library/contextvars.rst:63
msgid ""
"return the default value for the context variable, if it was created with"
" one; or"
msgstr "생성 시에 제공된 경우, 컨텍스트 변수의 기본값을 반환합니다; 또는"

#: ../../library/contextvars.rst:66
msgid "raise a :exc:`LookupError`."
msgstr ":exc:`LookupError` 를 발생시킵니다."

#: ../../library/contextvars.rst:70
msgid "Call to set a new value for the context variable in the current context."
msgstr "현재 컨텍스트에서 컨텍스트 변수의 새 값을 설정하려면 호출합니다."

#: ../../library/contextvars.rst:73
msgid "The required *value* argument is the new value for the context variable."
msgstr "필수 *value* 인자는 컨텍스트 변수의 새 값입니다."

#: ../../library/contextvars.rst:76
msgid ""
"Returns a :class:`~contextvars.Token` object that can be used to restore "
"the variable to its previous value via the :meth:`ContextVar.reset` "
"method."
msgstr ""
":meth:`ContextVar.reset` 메서드를 통해 변수를 이전 값으로 복원하는 데 사용할 수 있는 "
":class:`~contextvars.Token` 객체를 반환합니다."

#: ../../library/contextvars.rst:82
msgid ""
"Reset the context variable to the value it had before the "
":meth:`ContextVar.set` that created the *token* was used."
msgstr "*token* 을 생성 한 :meth:`ContextVar.set` 이 사용되기 전의 값으로 컨텍스트 변수를 재설정합니다."

#: ../../library/contextvars.rst:85
msgid "For example::"
msgstr "예를 들면::"

#: ../../library/contextvars.rst:87
msgid ""
"var = ContextVar('var')\n"
"\n"
"token = var.set('new value')\n"
"# code that uses 'var'; var.get() returns 'new value'.\n"
"var.reset(token)\n"
"\n"
"# After the reset call the var has no value again, so\n"
"# var.get() would raise a LookupError."
msgstr ""
"var = ContextVar('var')\n"
"\n"
"token = var.set('new value')\n"
"# 'var'를 사용하는 코드; var.get() 은 'new value'를 반환합니다.\n"
"var.reset(token)\n"
"\n"
"# reset 호출 후에 var에는 값이 다시 없으므로, var.get() 은\n"
"# LookupError를 발생시킵니다."

#: ../../library/contextvars.rst:99
msgid ""
"*Token* objects are returned by the :meth:`ContextVar.set` method. They "
"can be passed to the :meth:`ContextVar.reset` method to revert the value "
"of the variable to what it was before the corresponding *set*."
msgstr ""
"*Token* 객체는 :meth:`ContextVar.set` 메서드에 의해 반환됩니다. "
":meth:`ContextVar.reset` 메서드에 전달해서 변수의 값을 해당 *set* 이전의 값으로 되돌릴 수 있습니다."

#: ../../library/contextvars.rst:106
msgid ""
"A read-only property.  Points to the :class:`ContextVar` object that "
"created the token."
msgstr "읽기 전용 프로퍼티. 토큰을 생성 한 :class:`ContextVar` 객체를 가리 킵니다."

#: ../../library/contextvars.rst:111
msgid ""
"A read-only property.  Set to the value the variable had before the "
":meth:`ContextVar.set` method call that created the token. It points to "
":attr:`Token.MISSING` if the variable was not set before the call."
msgstr ""
"읽기 전용 프로퍼티. 토큰을 생성 한 :meth:`ContextVar.set` 메서드 호출 전 변수의 값으로 설정됩니다. 호출 전에"
" 변수가 설정되지 않았으면 :attr:`Token.MISSING`\\을 가리킵니다."

#: ../../library/contextvars.rst:118
msgid "A marker object used by :attr:`Token.old_value`."
msgstr ":attr:`Token.old_value` 에 의해 사용되는 표지 객체."

#: ../../library/contextvars.rst:122
msgid "Manual Context Management"
msgstr "수동 컨텍스트 관리"

#: ../../library/contextvars.rst:126
msgid "Returns a copy of the current :class:`~contextvars.Context` object."
msgstr "현재 :class:`~contextvars.Context` 객체의 복사본을 반환합니다."

#: ../../library/contextvars.rst:128
msgid ""
"The following snippet gets a copy of the current context and prints all "
"variables and their values that are set in it::"
msgstr "다음 코드 조각은 현재 컨텍스트의 복사본을 가져와서 모든 변수와 그 변수에 설정된 값을 출력합니다::"

#: ../../library/contextvars.rst:131
msgid ""
"ctx: Context = copy_context()\n"
"print(list(ctx.items()))"
msgstr ""
"ctx: Context = copy_context()\n"
"print(list(ctx.items()))"

#: ../../library/contextvars.rst:134
msgid ""
"The function has an *O*\\ (1) complexity, i.e. works equally fast for "
"contexts with a few context variables and for contexts that have a lot of"
" them."
msgstr ""
"이 함수는 *O*\\ (1) 복잡도를 갖고 있습니다. 즉, 몇 가지 컨텍스트 변수가 있는 컨텍스트와 컨텍스트 변수가 잔뜩 있는 "
"컨텍스트에 대해 똑같이 빠르게 작동합니다."

#: ../../library/contextvars.rst:141
msgid "A mapping of :class:`ContextVars <ContextVar>` to their values."
msgstr ":class:`ContextVars <ContextVar>` 에서 그 값으로의 매핑."

#: ../../library/contextvars.rst:143
msgid ""
"``Context()`` creates an empty context with no values in it. To get a "
"copy of the current context use the :func:`~contextvars.copy_context` "
"function."
msgstr ""
"``Context()`` 는 값이 없는 빈 컨텍스트를 만듭니다. 현재 컨텍스트의 복사본을 얻으려면 "
":func:`~contextvars.copy_context` 함수를 사용하십시오."

#: ../../library/contextvars.rst:147
msgid ""
"Each thread has its own effective stack of :class:`!Context` objects.  "
"The :term:`current context` is the :class:`!Context` object at the top of"
" the current thread's stack.  All :class:`!Context` objects in the stacks"
" are considered to be *entered*."
msgstr ""

#: ../../library/contextvars.rst:152
msgid ""
"*Entering* a context, which can be done by calling its "
":meth:`~Context.run` method, makes the context the current context by "
"pushing it onto the top of the current thread's context stack."
msgstr ""

#: ../../library/contextvars.rst:156
msgid ""
"*Exiting* from the current context, which can be done by returning from "
"the callback passed to the :meth:`~Context.run` method, restores the "
"current context to what it was before the context was entered by popping "
"the context off the top of the context stack."
msgstr ""

#: ../../library/contextvars.rst:161
msgid ""
"Since each thread has its own context stack, :class:`ContextVar` objects "
"behave in a similar fashion to :func:`threading.local` when values are "
"assigned in different threads."
msgstr ""

#: ../../library/contextvars.rst:165
msgid ""
"Attempting to enter an already entered context, including contexts "
"entered in other threads, raises a :exc:`RuntimeError`."
msgstr ""

#: ../../library/contextvars.rst:168
msgid "After exiting a context, it can later be re-entered (from any thread)."
msgstr ""

#: ../../library/contextvars.rst:170
msgid ""
"Any changes to :class:`ContextVar` values via the :meth:`ContextVar.set` "
"method are recorded in the current context.  The :meth:`ContextVar.get` "
"method returns the value associated with the current context.  Exiting a "
"context effectively reverts any changes made to context variables while "
"the context was entered (if needed, the values can be restored by re-"
"entering the context)."
msgstr ""

#: ../../library/contextvars.rst:177
msgid "Context implements the :class:`collections.abc.Mapping` interface."
msgstr "Context는 :class:`collections.abc.Mapping` 인터페이스를 구현합니다."

#: ../../library/contextvars.rst:181
msgid ""
"Enters the Context, executes ``callable(*args, **kwargs)``, then exits "
"the Context.  Returns *callable*'s return value, or propagates an "
"exception if one occurred."
msgstr ""
"컨텍스트에 진입하고, ``callable(*args, **kwargs)``\\를 실행한 다음, 컨텍스트에서 빠져나옵니다. "
"*callable*\\의 반환값을 반환하거나, 예외가 발생하면 예외를 전파합니다."

#: ../../library/contextvars.rst:185
msgid "Example:"
msgstr "예제:"

#: ../../library/contextvars.rst:187
msgid ""
"import contextvars\n"
"\n"
"var = contextvars.ContextVar('var')\n"
"var.set('spam')\n"
"print(var.get())  # 'spam'\n"
"\n"
"ctx = contextvars.copy_context()\n"
"\n"
"def main():\n"
"    # 'var' was set to 'spam' before\n"
"    # calling 'copy_context()' and 'ctx.run(main)', so:\n"
"    print(var.get())  # 'spam'\n"
"    print(ctx[var])  # 'spam'\n"
"\n"
"    var.set('ham')\n"
"\n"
"    # Now, after setting 'var' to 'ham':\n"
"    print(var.get())  # 'ham'\n"
"    print(ctx[var])  # 'ham'\n"
"\n"
"# Any changes that the 'main' function makes to 'var'\n"
"# will be contained in 'ctx'.\n"
"ctx.run(main)\n"
"\n"
"# The 'main()' function was run in the 'ctx' context,\n"
"# so changes to 'var' are contained in it:\n"
"print(ctx[var])  # 'ham'\n"
"\n"
"# However, outside of 'ctx', 'var' is still set to 'spam':\n"
"print(var.get())  # 'spam'"
msgstr ""
"import contextvars\n"
"\n"
"var = contextvars.ContextVar('var')\n"
"var.set('spam')\n"
"print(var.get())  # 'spam'\n"
"\n"
"ctx = contextvars.copy_context()\n"
"\n"
"def main():\n"
"    # 'var' 는 'copy_context()' 와 'ctx.run(main)' 을\n"
"    # 호출하기 전에 'spam' 으로 설정되었습니다. 그래서:\n"
"    print(var.get())  # 'spam'\n"
"    print(ctx[var])  # 'spam'\n"
"\n"
"    var.set('ham')\n"
"\n"
"    # 이제, 'var' 를 'ham' 으로 설정한 후에:\n"
"    print(var.get())  # 'ham'\n"
"    print(ctx[var])  # 'ham'\n"
"\n"
"# 'main' 함수가 'var' 에 적용한 모든 변경은 'ctx' 에 포함됩니다.\n"
"ctx.run(main)\n"
"\n"
"# 'main()' 함수는 'ctx' 컨텍스트에서 실행되었으므로,\n"
"# 'var' 에 대한 변경은 'ctx' 에 포함되어 있습니다:\n"
"print(ctx[var])  # 'ham'\n"
"\n"
"# 그러나, 'ctx' 외부에서, 'var' 는 여전히 'spam' 으로 설정되어있습니다:\n"
"print(var.get())  # 'spam'"

#: ../../library/contextvars.rst:233
msgid "Return a shallow copy of the context object."
msgstr "컨텍스트 객체의 얕은 복사본을 반환합니다."

#: ../../library/contextvars.rst:237
msgid ""
"Return ``True`` if the *context* has a value for *var* set; return "
"``False`` otherwise."
msgstr "*context* 에 *var* 의 값이 설정되었으면 ``True`` 를, 그렇지 않으면 `False`\\를 반환합니다."

#: ../../library/contextvars.rst:242
msgid ""
"Return the value of the *var* :class:`ContextVar` variable. If the "
"variable is not set in the context object, a :exc:`KeyError` is raised."
msgstr ""
"*var* :class:`ContextVar` 변수의 값을 돌려줍니다. 컨텍스트 객체에 변수가 설정되어 있지 않으면 "
":exc:`KeyError` 가 발생합니다."

#: ../../library/contextvars.rst:248
msgid ""
"Return the value for *var* if *var* has the value in the context object."
"  Return *default* otherwise.  If *default* is not given, return "
"``None``."
msgstr ""
"컨텍스트 객체에 *var* 의 값이 있으면, *var* 의 값을 돌려줍니다. 그렇지 않으면 *default* 를 반환합니다. "
"*default* 가 주어지지 않으면 ``None`` 을 반환합니다."

#: ../../library/contextvars.rst:254
msgid "Return an iterator over the variables stored in the context object."
msgstr "컨텍스트 객체에 저장된 변수에 대한 이터레이터를 반환합니다."

#: ../../library/contextvars.rst:259
msgid "Return the number of variables set in the context object."
msgstr "컨텍스트 객체에 설정된 변수의 개수를 반환합니다."

#: ../../library/contextvars.rst:263
msgid "Return a list of all variables in the context object."
msgstr "컨텍스트 객체의 모든 변수 목록을 반환합니다."

#: ../../library/contextvars.rst:267
msgid "Return a list of all variables' values in the context object."
msgstr "컨텍스트 객체의 모든 변수의 값 목록을 반환합니다."

#: ../../library/contextvars.rst:272
msgid ""
"Return a list of 2-tuples containing all variables and their values in "
"the context object."
msgstr "컨텍스트 객체에서 모든 변수와 해당 값을 포함하는 2-튜플의 목록을 반환합니다."

#: ../../library/contextvars.rst:277
msgid "asyncio support"
msgstr "asyncio 지원"

#: ../../library/contextvars.rst:279
msgid ""
"Context variables are natively supported in :mod:`asyncio` and are ready "
"to be used without any extra configuration.  For example, here is a "
"simple echo server, that uses a context variable to make the address of a"
" remote client available in the Task that handles that client::"
msgstr ""
"컨텍스트 변수는 :mod:`asyncio` 에서 기본적으로 지원되며 추가 구성없이 사용할 수 있습니다. 예를 들어, 이것은 컨텍스트"
" 변수를 사용하여, 원격 클라이언트의 주소를 해당 클라이언트를 처리하는 Task에서 사용할 수 있도록 하는 간단한 메아리 "
"서버입니다::"

#: ../../library/contextvars.rst:285
#, python-brace-format
msgid ""
"import asyncio\n"
"import contextvars\n"
"\n"
"client_addr_var = contextvars.ContextVar('client_addr')\n"
"\n"
"def render_goodbye():\n"
"    # The address of the currently handled client can be accessed\n"
"    # without passing it explicitly to this function.\n"
"\n"
"    client_addr = client_addr_var.get()\n"
"    return f'Good bye, client @ {client_addr}\\r\\n'.encode()\n"
"\n"
"async def handle_request(reader, writer):\n"
"    addr = writer.transport.get_extra_info('socket').getpeername()\n"
"    client_addr_var.set(addr)\n"
"\n"
"    # In any code that we call is now possible to get\n"
"    # client's address by calling 'client_addr_var.get()'.\n"
"\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        print(line)\n"
"        if not line.strip():\n"
"            break\n"
"\n"
"    writer.write(b'HTTP/1.1 200 OK\\r\\n')  # status line\n"
"    writer.write(b'\\r\\n')  # headers\n"
"    writer.write(render_goodbye())  # body\n"
"    writer.close()\n"
"\n"
"async def main():\n"
"    srv = await asyncio.start_server(\n"
"        handle_request, '127.0.0.1', 8081)\n"
"\n"
"    async with srv:\n"
"        await srv.serve_forever()\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# To test it you can use telnet or curl:\n"
"#     telnet 127.0.0.1 8081\n"
"#     curl 127.0.0.1:8081"
msgstr ""
"import asyncio\n"
"import contextvars\n"
"\n"
"client_addr_var = contextvars.ContextVar('client_addr')\n"
"\n"
"def render_goodbye():\n"
"    # 현재 처리중인 클라이언트의 주소를 이 함수에 명시 적으로 전달하지 않고도\n"
"    # 액세스 할 수 있습니다.\n"
"\n"
"    client_addr = client_addr_var.get()\n"
"    return f'Good bye, client @ {client_addr}\\r\\n'.encode()\n"
"\n"
"async def handle_request(reader, writer):\n"
"    addr = writer.transport.get_extra_info('socket').getpeername()\n"
"    client_addr_var.set(addr)\n"
"\n"
"    # 우리가 호출하는 모든 코드에서 이제 'client_addr_var.get()' 을\n"
"    # 호출하여 클라이언트의 주소를 가져올 수 있습니다.\n"
"\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        print(line)\n"
"        if not line.strip():\n"
"            break\n"
"\n"
"    writer.write(b'HTTP/1.1 200 OK\\r\\n')  # status line\n"
"    writer.write(b'\\r\\n')  # headers\n"
"    writer.write(render_goodbye())  # body\n"
"    writer.close()\n"
"\n"
"async def main():\n"
"    srv = await asyncio.start_server(\n"
"        handle_request, '127.0.0.1', 8081)\n"
"\n"
"    async with srv:\n"
"        await srv.serve_forever()\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# 테스트하려면 telnet이나 curl을 사용할 수 있습니다:\n"
"#     telnet 127.0.0.1 8081\n"
"#     curl 127.0.0.1:8081"

#~ msgid ""
#~ "Any changes to any context variables "
#~ "that *callable* makes will be contained"
#~ " in the context object::"
#~ msgstr "*callable* 이 만드는 모든 컨텍스트 변수에 대한 변경 사항은 컨텍스트 개체에 포함됩니다::"

#~ msgid ""
#~ "The method raises a :exc:`RuntimeError` "
#~ "when called on the same context "
#~ "object from more than one OS "
#~ "thread, or when called recursively."
#~ msgstr ""
#~ "이 메서드는 둘 이상의 OS 스레드에서 같은 "
#~ "컨텍스트 객체에 대해 호출될 때나 재귀적으로 호출될 "
#~ "때 :exc:`RuntimeError` 를 발생시킵니다."

