# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../library/bisect.rst:2
#, fuzzy
msgid ":mod:`!bisect` --- Array bisection algorithm"
msgstr ":mod:`bisect` --- 배열 이진 분할 알고리즘"

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**소스 코드:** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
#, fuzzy
msgid ""
"This module provides support for maintaining a list in sorted order "
"without having to sort the list after each insertion.  For long lists of "
"items with expensive comparison operations, this can be an improvement "
"over linear searches or frequent resorting."
msgstr ""
"이 모듈은 정렬된 리스트를 삽입 후에 다시 정렬할 필요 없도록 관리할 수 있도록 지원합니다. 값비싼 비교 연산이 포함된 항목의 긴 "
"리스트의 경우, 이는 일반적인 방법에 비해 개선된 것입니다. 이 모듈은 기본적인 이진 분할 알고리즘을 사용하기 때문에 "
":mod:`bisect`\\라고 불립니다. 소스 코드는 알고리즘의 실제 예로서 가장 유용할 수 있습니다 (경계 조건은 이미 "
"옳습니다!)."

#: ../../library/bisect.rst:19
msgid ""
"The module is called :mod:`bisect` because it uses a basic bisection "
"algorithm to do its work.  Unlike other bisection tools that search for a"
" specific value, the functions in this module are designed to locate an "
"insertion point. Accordingly, the functions never call an "
":meth:`~object.__eq__` method to determine whether a value has been "
"found.  Instead, the functions only call the :meth:`~object.__lt__` "
"method and will return an insertion point between values in an array."
msgstr ""

#: ../../library/bisect.rst:29
msgid "The following functions are provided:"
msgstr "다음과 같은 함수가 제공됩니다:"

#: ../../library/bisect.rst:34
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list "
"which should be considered; by default the entire list is used.  If *x* "
"is already present in *a*, the insertion point will be before (to the "
"left of) any existing entries.  The return value is suitable for use as "
"the first parameter to ``list.insert()`` assuming that *a* is already "
"sorted."
msgstr ""
"정렬된 순서를 유지하도록 *a*\\에 *x*\\를 삽입할 위치를 찾습니다. 매개 변수 *lo* 와 *hi*\\는 고려해야 할 "
"리스트의 부분집합을 지정하는 데 사용될 수 있습니다; 기본적으로 전체 리스트가 사용됩니다. *x*\\가 *a*\\에 이미 있으면, "
"삽입 위치는 기존 항목 앞(왼쪽)이 됩니다. 반환 값은 *a*\\가 이미 정렬되었다고 가정할 때 "
"``list.insert()``\\의 첫 번째 매개 변수로 사용하기에 적합합니다."

#: ../../library/bisect.rst:41
#, fuzzy
msgid ""
"The returned insertion point *ip* partitions the array *a* into two "
"slices such that ``all(elem < x for elem in a[lo : ip])`` is true for the"
" left slice and ``all(elem >= x for elem in a[ip : hi])`` is true for the"
" right slice."
msgstr ""
"반환된 삽입 위치 *i*\\는 배열 *a*\\를 이분하여, 왼쪽은 ``all(val < x for val in a[lo:i])``,"
" 오른쪽은 ``all(val >= x for val in a[i:hi])``\\이 되도록 만듭니다."

#: ../../library/bisect.rst:46
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each element in the array.  To support "
"searching complex records, the key function is not applied to the *x* "
"value."
msgstr ""

#: ../../library/bisect.rst:50
msgid ""
"If *key* is ``None``, the elements are compared directly and no key "
"function is called."
msgstr ""

#: ../../library/bisect.rst:53 ../../library/bisect.rst:67
#: ../../library/bisect.rst:85 ../../library/bisect.rst:105
msgid "Added the *key* parameter."
msgstr ""

#: ../../library/bisect.rst:60
#, fuzzy
msgid ""
"Similar to :py:func:`~bisect.bisect_left`, but returns an insertion point"
" which comes after (to the right of) any existing entries of *x* in *a*."
msgstr ""
":func:`bisect_left`\\와 비슷하지만, *a*\\에 있는 *x*\\의 기존 항목 뒤(오른쪽)에 오는 삽입 위치를 "
"반환합니다."

#: ../../library/bisect.rst:63
#, fuzzy
msgid ""
"The returned insertion point *ip* partitions the array *a* into two "
"slices such that ``all(elem <= x for elem in a[lo : ip])`` is true for "
"the left slice and ``all(elem > x for elem in a[ip : hi])`` is true for "
"the right slice."
msgstr ""
"반환된 삽입 위치 *i*\\는 배열 *a*\\를 이분하여, 왼쪽은 ``all(val <= x for val in "
"a[lo:i])``, 오른쪽은 ``all(val > x for val in a[i:hi])``\\이 되도록 만듭니다."

#: ../../library/bisect.rst:73
msgid "Insert *x* in *a* in sorted order."
msgstr ""

#: ../../library/bisect.rst:75
msgid ""
"This function first runs :py:func:`~bisect.bisect_left` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to "
"insert *x* at the appropriate position to maintain sort order."
msgstr ""

#: ../../library/bisect.rst:79 ../../library/bisect.rst:99
msgid ""
"To support inserting records in a table, the *key* function (if any) is "
"applied to *x* for the search step but not for the insertion step."
msgstr ""

#: ../../library/bisect.rst:82 ../../library/bisect.rst:102
msgid ""
"Keep in mind that the *O*\\ (log *n*) search is dominated by the slow "
"*O*\\ (*n*) insertion step."
msgstr ""

#: ../../library/bisect.rst:92
#, fuzzy
msgid ""
"Similar to :py:func:`~bisect.insort_left`, but inserting *x* in *a* after"
" any existing entries of *x*."
msgstr ":func:`insort_left`\\와 비슷하지만, *a*\\에 *x*\\를 *x*\\의 기존 항목 다음에 삽입합니다."

#: ../../library/bisect.rst:95
msgid ""
"This function first runs :py:func:`~bisect.bisect_right` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to "
"insert *x* at the appropriate position to maintain sort order."
msgstr ""

#: ../../library/bisect.rst:110
msgid "Performance Notes"
msgstr ""

#: ../../library/bisect.rst:112
msgid ""
"When writing time sensitive code using *bisect()* and *insort()*, keep "
"these thoughts in mind:"
msgstr ""

#: ../../library/bisect.rst:115
msgid ""
"Bisection is effective for searching ranges of values. For locating "
"specific values, dictionaries are more performant."
msgstr ""

#: ../../library/bisect.rst:118
msgid ""
"The *insort()* functions are *O*\\ (*n*) because the logarithmic search "
"step is dominated by the linear time insertion step."
msgstr ""

#: ../../library/bisect.rst:121
msgid ""
"The search functions are stateless and discard key function results after"
" they are used.  Consequently, if the search functions are used in a "
"loop, the key function may be called again and again on the same array "
"elements. If the key function isn't fast, consider wrapping it with "
":py:func:`functools.cache` to avoid duplicate computations.  "
"Alternatively, consider searching an array of precomputed keys to locate "
"the insertion point (as shown in the examples section below)."
msgstr ""

#: ../../library/bisect.rst:131
msgid ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ is"
" a high performance module that uses *bisect* to managed sorted "
"collections of data."
msgstr ""

#: ../../library/bisect.rst:135
#, fuzzy
msgid ""
"The `SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ uses "
"bisect to build a full-featured collection class with straight-forward "
"search methods and support for a key-function.  The keys are precomputed "
"to save unnecessary calls to the key function during searches."
msgstr ""
"bisect를 사용하여 직접적인 검색 메서드와 키 함수 지원을 포함하는 완전한 기능을 갖춘 컬렉션 클래스를 만드는 "
"`SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_. 검색 중에 "
"불필요한 키 함수 호출을 피하고자 키는 미리 계산됩니다."

#: ../../library/bisect.rst:143
msgid "Searching Sorted Lists"
msgstr "정렬된 리스트 검색하기"

#: ../../library/bisect.rst:145
#, fuzzy
msgid ""
"The above `bisect functions`_ are useful for finding insertion points but"
" can be tricky or awkward to use for common searching tasks. The "
"following five functions show how to transform them into the standard "
"lookups for sorted lists::"
msgstr ""
"위의 :func:`bisect` 함수는 삽입 위치를 찾는 데 유용하지만, 일반적인 검색 작업에 사용하기가 까다롭거나 어색할 수 "
"있습니다. 다음 다섯 함수는 정렬된 리스트에 대한 표준 조회로 변환하는 방법을 보여줍니다::"

#: ../../library/bisect.rst:150
msgid ""
"def index(a, x):\n"
"    'Locate the leftmost value exactly equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a) and a[i] == x:\n"
"        return i\n"
"    raise ValueError\n"
"\n"
"def find_lt(a, x):\n"
"    'Find rightmost value less than x'\n"
"    i = bisect_left(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_le(a, x):\n"
"    'Find rightmost value less than or equal to x'\n"
"    i = bisect_right(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_gt(a, x):\n"
"    'Find leftmost value greater than x'\n"
"    i = bisect_right(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError\n"
"\n"
"def find_ge(a, x):\n"
"    'Find leftmost item greater than or equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError"
msgstr ""

#: ../../library/bisect.rst:187
#, fuzzy
msgid "Examples"
msgstr "다른 예제"

#: ../../library/bisect.rst:191
#, fuzzy
msgid ""
"The :py:func:`~bisect.bisect` function can be useful for numeric table "
"lookups. This example uses :py:func:`~bisect.bisect` to look up a letter "
"grade for an exam score (say) based on a set of ordered numeric "
"breakpoints: 90 and up is an 'A', 80 to 89 is a 'B', and so on::"
msgstr ""
":func:`bisect` 함수는 숫자 테이블 조회에 유용할 수 있습니다. 이 예제는 :func:`bisect`\\를 사용하여 "
"(가령) 시험 점수에 대한 문자 등급을 조회하는데, 정렬된 숫자 경계점 집합에 기반합니다: 90 이상은 'A', 80에서 89는 "
"'B' 등입니다::"

#: ../../library/bisect.rst:196
msgid ""
">>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n"
"...     i = bisect(breakpoints, score)\n"
"...     return grades[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"
msgstr ""

#: ../../library/bisect.rst:203
msgid ""
"The :py:func:`~bisect.bisect` and :py:func:`~bisect.insort` functions "
"also work with lists of tuples.  The *key* argument can serve to extract "
"the field used for ordering records in a table::"
msgstr ""

#: ../../library/bisect.rst:207
msgid ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Find the first movie released after 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insert a movie while maintaining sort order\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"
msgstr ""

#: ../../library/bisect.rst:237
#, fuzzy
msgid ""
"If the key function is expensive, it is possible to avoid repeated "
"function calls by searching a list of precomputed keys to find the index "
"of a record::"
msgstr "대신, 해당 레코드의 인덱스를 찾기 위해 미리 계산된 키 리스트를 검색하는 것이 좋습니다::"

#: ../../library/bisect.rst:240
msgid ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])       # Or use operator.itemgetter(1).\n"
">>> keys = [r[1] for r in data]         # Precompute a list of keys.\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"
msgstr ""

#~ msgid ""
#~ "Insert *x* in *a* in sorted order."
#~ "  This is equivalent to "
#~ "``a.insert(bisect.bisect_left(a, x, lo, hi), "
#~ "x)`` assuming that *a* is already "
#~ "sorted.  Keep in mind that the "
#~ "O(log n) search is dominated by "
#~ "the slow O(n) insertion step."
#~ msgstr ""
#~ "*a*\\에 *x*\\를 정렬된 순서로 삽입합니다. *a*\\가 "
#~ "이미 정렬되었다고 가정할 때 "
#~ "``a.insert(bisect.bisect_left(a, x, lo, hi), "
#~ "x)``\\와 동등합니다. O(log n) 검색이 느린 "
#~ "O(n) 삽입 단계에 가려짐에 유념하십시오."

#~ msgid ""
#~ "Unlike the :func:`sorted` function, it "
#~ "does not make sense for the "
#~ ":func:`bisect` functions to have *key* "
#~ "or *reversed* arguments because that "
#~ "would lead to an inefficient design "
#~ "(successive calls to bisect functions "
#~ "would not \"remember\" all of the "
#~ "previous key lookups)."
#~ msgstr ""
#~ ":func:`sorted` 함수와 달리, :func:`bisect` 함수는 "
#~ "*key* 나 *reversed* 인자를 갖는 것은 의미가"
#~ " 없는데, 비효율적인 설계 (연속적인 bisect 함수 "
#~ "호출이 이전의 모든 키 조회를 \"기억\"하지 못합니다)를"
#~ " 초래하기 때문입니다."

