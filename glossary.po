# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "용어집"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
#, fuzzy
msgid ""
"The default Python prompt of the :term:`interactive` shell.  Often seen "
"for code examples which can be executed interactively in the interpreter."
msgstr "대화형 셸의 기본 파이썬 프롬프트. 인터프리터에서 대화형으로 실행될 수 있는 코드 예에서 자주 볼 수 있습니다."

#: ../../glossary.rst:15
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:17
msgid "Can refer to:"
msgstr "다음과 같은 것들을 가리킬 수 있습니다:"

#: ../../glossary.rst:19
#, fuzzy
msgid ""
"The default Python prompt of the :term:`interactive` shell when entering "
"the code for an indented code block, when within a pair of matching left "
"and right delimiters (parentheses, square brackets, curly braces or "
"triple quotes), or after specifying a decorator."
msgstr ""
"들여쓰기 된 코드 블록의 코드를 입력할 때, 쌍을 이루는 구분자 (괄호, 대괄호, 중괄호) 안에 코드를 입력할 때, 데코레이터 지정"
" 후의 대화형 셸의 기본 파이썬 프롬프트."

#: ../../glossary.rst:24
msgid "The :const:`Ellipsis` built-in constant."
msgstr ":const:`Ellipsis` 내장 상수."

#: ../../glossary.rst:25
msgid "abstract base class"
msgstr "abstract base class (추상 베이스 클래스)"

#: ../../glossary.rst:27
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way "
"to define interfaces when other techniques like :func:`hasattr` would be "
"clumsy or subtly wrong (for example with :ref:`magic methods <special-"
"lookup>`).  ABCs introduce virtual subclasses, which are classes that "
"don't inherit from a class but are still recognized by :func:`isinstance`"
" and :func:`issubclass`; see the :mod:`abc` module documentation.  Python"
" comes with many built-in ABCs for data structures (in the "
":mod:`collections.abc` module), numbers (in the :mod:`numbers` module), "
"streams (in the :mod:`io` module), import finders and loaders (in the "
":mod:`importlib.abc` module).  You can create your own ABCs with the "
":mod:`abc` module."
msgstr ""
"추상 베이스 클래스는 :func:`hasattr` 같은 다른 테크닉들이 불편하거나 미묘하게 잘못된 (예를 들어, :ref:`매직 "
"메서드 <special-lookup>`) 경우, 인터페이스를 정의하는 방법을 제공함으로써 :term:`덕 타이핑 <duck-"
"typing>` 을 보완합니다. ABC는 가상 서브 클래스를 도입하는데, 클래스를 계승하지 않으면서도 "
":func:`isinstance` 와 :func:`issubclass` 에 의해 감지될 수 있는 클래스들입니다; :mod:`abc`"
" 모듈 설명서를 보세요. 파이썬에는 많은 내장 ABC 들이 따라오는데 다음과 같은 것들이 있습니다: 자료 구조 "
"(:mod:`collections.abc` 모듈에서), 숫자 (:mod:`numbers` 모듈에서), 스트림 (:mod:`io` "
"모듈에서), 임포트 파인더와 로더 (:mod:`importlib.abc` 모듈에서). :mod:`abc` 모듈을 사용해서 자신만의 "
"ABC를 만들 수도 있습니다."

#: ../../glossary.rst:38
msgid "annotation"
msgstr "annotation (어노테이션)"

#: ../../glossary.rst:40
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"관습에 따라 :term:`형 힌트 <type hint>` 로 사용되는 변수, 클래스 어트리뷰트 또는 함수 매개변수 나 반환 값과 "
"연결된 레이블입니다."

#: ../../glossary.rst:44
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are "
"stored in the :attr:`__annotations__` special attribute of modules, "
"classes, and functions, respectively."
msgstr ""
"지역 변수의 어노테이션은 실행 시간에 액세스할 수 없지만, 전역 변수, 클래스 속성 및 함수의 어노테이션은 각각 모듈, 클래스, "
"함수의 :attr:`__annotations__` 특수 어트리뷰트에 저장됩니다."

#: ../../glossary.rst:50
#, fuzzy
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` "
"and :pep:`526`, which describe this functionality. Also see :ref"
":`annotations-howto` for best practices on working with annotations."
msgstr ""
"이 기능을 설명하는 :term:`변수 어노테이션 <variable annotation>`, :term:`함수 어노테이션 "
"<function annotation>`, :pep:`484`, :pep:`526`\\을 참조하세요."

#: ../../glossary.rst:54
msgid "argument"
msgstr "argument (인자)"

#: ../../glossary.rst:56
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the"
" function.  There are two kinds of argument:"
msgstr ""
"함수를 호출할 때 :term:`함수 <function>` (또는 :term:`메서드 <method>`) 로 전달되는 값. 두 종류의"
" 인자가 있습니다:"

#: ../../glossary.rst:59
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary "
"preceded by ``**``.  For example, ``3`` and ``5`` are both keyword "
"arguments in the following calls to :func:`complex`::"
msgstr ""
":dfn:`키워드 인자 (keyword argument)`: 함수 호출 때 식별자가 앞에 붙은 인자 (예를 들어, "
"``name=``) 또는 ``**`` 를 앞에 붙인 딕셔너리로 전달되는 인자. 예를 들어, 다음과 같은 :func:`complex`"
" 호출에서 ``3`` 과 ``5`` 는 모두 키워드 인자입니다::"

#: ../../glossary.rst:64
#, python-brace-format
msgid ""
"complex(real=3, imag=5)\n"
"complex(**{'real': 3, 'imag': 5})"
msgstr ""

#: ../../glossary.rst:67
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list "
"and/or be passed as elements of an :term:`iterable` preceded by ``*``. "
"For example, ``3`` and ``5`` are both positional arguments in the "
"following calls::"
msgstr ""
":dfn:`위치 인자 (positional argument)`: 키워드 인자가 아닌 인자. 위치 인자들은 인자 목록의 처음에 "
"나오거나 :term:`이터러블 <iterable>` 의 앞에 ``*`` 를 붙여 전달할 수 있습니다. 예를 들어, 다음과 같은 "
"호출에서 ``3`` 과 ``5`` 는 모두 위치 인자입니다."

#: ../../glossary.rst:73
msgid ""
"complex(3, 5)\n"
"complex(*(3, 5))"
msgstr ""

#: ../../glossary.rst:76
msgid ""
"Arguments are assigned to the named local variables in a function body. "
"See the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"인자는 함수 바디의 이름 붙은 지역 변수에 대입됩니다. 이 대입에 적용되는 규칙들에 대해서는 :ref:`calls` 절을 보세요. "
"문법적으로, 어떤 표현식이건 인자로 사용될 수 있습니다; 구해진 값이 지역 변수에 대입됩니다."

#: ../../glossary.rst:81
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on "
":ref:`the difference between arguments and parameters <faq-argument-vs-"
"parameter>`, and :pep:`362`."
msgstr ""
"용어집의 :term:`매개변수 <parameter>` 항목과 FAQ 질문 :ref:`인자와 매개변수의 차이 <faq-"
"argument-vs-parameter>` 와 :pep:`362`\\도 보세요."

#: ../../glossary.rst:84
msgid "asynchronous context manager"
msgstr "asynchronous context manager (비동기 컨텍스트 관리자)"

#: ../../glossary.rst:86
#, fuzzy
msgid ""
"An object which controls the environment seen in an :keyword:`async with`"
" statement by defining :meth:`~object.__aenter__` and "
":meth:`~object.__aexit__` methods.  Introduced by :pep:`492`."
msgstr ""
":meth:`__aenter__` 와 :meth:`__aexit__` 메서드를 정의함으로써 :keyword:`async with` "
"문에서 보이는 환경을 제어하는 객체. :pep:`492`\\로 도입되었습니다."

#: ../../glossary.rst:89
msgid "asynchronous generator"
msgstr "asynchronous generator (비동기 제너레이터)"

#: ../../glossary.rst:91
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
":term:`비동기 제너레이터 이터레이터 <asynchronous generator iterator>` 를 돌려주는 함수. "
":keyword:`async def` 로 정의되는 코루틴 함수처럼 보이는데, :keyword:`async for` 루프가 사용할 수"
" 있는 일련의 값들을 만드는 :keyword:`yield` 표현식을 포함한다는 점이 다릅니다."

#: ../../glossary.rst:96
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an"
" *asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"보통 비동기 제너레이터 함수를 가리키지만, 어떤 문맥에서는 *비동기 제너레이터 이터레이터* 를 가리킵니다. 의도하는 의미가 명확하지"
" 않은 경우는, 완전한 용어를 써서 모호함을 없앱니다."

#: ../../glossary.rst:100
msgid ""
"An asynchronous generator function may contain :keyword:`await` "
"expressions as well as :keyword:`async for`, and :keyword:`async with` "
"statements."
msgstr ""
"비동기 제너레이터 함수는 :keyword:`await` 표현식과, :keyword:`async for` 문과, "
":keyword:`async with` 문을 포함할 수 있습니다."

#: ../../glossary.rst:103
msgid "asynchronous generator iterator"
msgstr "asynchronous generator iterator (비동기 제너레이터 이터레이터)"

#: ../../glossary.rst:105
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ":term:`비동기 제너레이터 <asynchronous generator>` 함수가 만드는 객체."

#: ../../glossary.rst:107
#, fuzzy
msgid ""
"This is an :term:`asynchronous iterator` which when called using the "
":meth:`~object.__anext__` method returns an awaitable object which will "
"execute the body of the asynchronous generator function until the next "
":keyword:`yield` expression."
msgstr ""
":term:`비동기 이터레이터 <asynchronous iterator>` 인데 :meth:`__anext__` 를 호출하면 "
"어웨이터블 객체를 돌려주고, 이것은 다음 :keyword:`yield` 표현식 까지 비동기 제너레이터 함수의 바디를 실행합니다."

#: ../../glossary.rst:112
#, fuzzy
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *asynchronous generator iterator* effectively resumes with "
"another awaitable returned by :meth:`~object.__anext__`, it picks up "
"where it left off.  See :pep:`492` and :pep:`525`."
msgstr ""
"각 :keyword:`yield`\\는 일시적으로 처리를 중단하고, 그 위치의 (지역 변수들과 대기 중인 try-문들을 포함하는) "
"실행 상태를 기억합니다. *비동기 제너레이터 이터레이터* 가 :meth:`__anext__` 가 돌려주는 또 하나의 어웨이터블로 "
"재개되면, 떠난 곳으로 복귀합니다. :pep:`492`\\와 :pep:`525`\\를 보세요."

#: ../../glossary.rst:117
msgid "asynchronous iterable"
msgstr "asynchronous iterable (비동기 이터러블)"

#: ../../glossary.rst:119
#, fuzzy
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its "
":meth:`~object.__aiter__` method.  Introduced by :pep:`492`."
msgstr ""
":keyword:`async for` 문에서 사용될 수 있는 객체. :meth:`__aiter__` 메서드는 :term:`비동기 "
"이터레이터 <asynchronous iterator>` 를 돌려줘야 합니다. :pep:`492` 로 도입되었습니다."

#: ../../glossary.rst:122
msgid "asynchronous iterator"
msgstr "asynchronous iterator (비동기 이터레이터)"

#: ../../glossary.rst:124
#, fuzzy
msgid ""
"An object that implements the :meth:`~object.__aiter__` and "
":meth:`~object.__anext__` methods.  :meth:`~object.__anext__` must return"
" an :term:`awaitable` object. :keyword:`async for` resolves the "
"awaitables returned by an asynchronous iterator's "
":meth:`~object.__anext__` method until it raises a "
":exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
":meth:`__aiter__` 와 :meth:`__anext__` 메서드를 구현하는 객체. ``__anext__`` 는 "
":term:`어웨이터블 <awaitable>` 객체를 돌려줘야 합니다. :keyword:`async for`\\는 "
":exc:`StopAsyncIteration` 예외가 발생할 때까지 비동기 이터레이터의 :meth:`__anext__` 메서드가 "
"돌려주는 어웨이터블을 풉니다. :pep:`492`\\로 도입되었습니다."

#: ../../glossary.rst:129
msgid "attribute"
msgstr "attribute (어트리뷰트)"

#: ../../glossary.rst:131
#, fuzzy
msgid ""
"A value associated with an object which is usually referenced by name "
"using dotted expressions. For example, if an object *o* has an attribute "
"*a* it would be referenced as *o.a*."
msgstr ""
"점표현식을 사용하는 이름으로 참조되는 객체와 결합한 값. 예를 들어, 객체 *o*\\가 어트리뷰트 *a*\\를 가지면, "
"*o.a*\\처럼 참조됩니다."

#: ../../glossary.rst:136
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using "
":func:`setattr`, if the object allows it. Such an attribute will not be "
"accessible using a dotted expression, and would instead need to be "
"retrieved with :func:`getattr`."
msgstr ""

#: ../../glossary.rst:141
msgid "awaitable"
msgstr "awaitable (어웨이터블)"

#: ../../glossary.rst:143
#, fuzzy
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a "
":term:`coroutine` or an object with an :meth:`~object.__await__` method. "
"See also :pep:`492`."
msgstr ""
":keyword:`await` 표현식에 사용할 수 있는 객체. :term:`코루틴 <coroutine>` 이나 "
":meth:`__await__` 메서드를 가진 객체가 될 수 있습니다. :pep:`492`\\를 보세요."

#: ../../glossary.rst:146
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:148
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum "
"<https://gvanrossum.github.io/>`_, Python's creator."
msgstr ""
"자비로운 종신 독재자 (Benevolent Dictator For Life), 즉 `Guido van Rossum "
"<https://gvanrossum.github.io/>`_, 파이썬의 창시자."

#: ../../glossary.rst:150
msgid "binary file"
msgstr "binary file (바이너리 파일)"

#: ../../glossary.rst:152
#, fuzzy
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary"
" mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer "
"<sys.stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, and instances of "
":class:`io.BytesIO` and :class:`gzip.GzipFile`."
msgstr ""
":term:`바이트열류 객체들 <bytes-like object>`\\을 읽고 쓸 수 있는 :term:`파일 객체 <file "
"object>`. 바이너리 파일의 예로는 바이너리 모드 (``'rb'``, ``'wb'`` 또는 ``'rb+'``) 로 열린 파일,"
" :data:`sys.stdin.buffer`, :data:`sys.stdout.buffer`, :class:`io.BytesIO`"
" 와 :class:`gzip.GzipFile` 의 인스턴스를 들 수 있습니다."

#: ../../glossary.rst:159
msgid ""
"See also :term:`text file` for a file object able to read and write "
":class:`str` objects."
msgstr ":class:`str` 객체를 읽고 쓸 수 있는 파일 객체에 대해서는 :term:`텍스트 파일 <text file>` 도 참조하세요."

#: ../../glossary.rst:161
msgid "borrowed reference"
msgstr ""

#: ../../glossary.rst:163
msgid ""
"In Python's C API, a borrowed reference is a reference to an object, "
"where the code using the object does not own the reference. It becomes a "
"dangling pointer if the object is destroyed. For example, a garbage "
"collection can remove the last :term:`strong reference` to the object and"
" so destroy it."
msgstr ""

#: ../../glossary.rst:169
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is "
"recommended to convert it to a :term:`strong reference` in-place, except "
"when the object cannot be destroyed before the last usage of the borrowed"
" reference. The :c:func:`Py_NewRef` function can be used to create a new "
":term:`strong reference`."
msgstr ""

#: ../../glossary.rst:174
msgid "bytes-like object"
msgstr "bytes-like object (바이트열류 객체)"

#: ../../glossary.rst:176
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a "
"C-:term:`contiguous` buffer. This includes all :class:`bytes`, "
":class:`bytearray`, and :class:`array.array` objects, as well as many "
"common :class:`memoryview` objects.  Bytes-like objects can be used for "
"various operations that work with binary data; these include compression,"
" saving to a binary file, and sending over a socket."
msgstr ""
":ref:`bufferobjects` 를 지원하고 C-:term:`연속 <contiguous>` 버퍼를 익스포트 할 수 있습니다. "
"여러 공통 :class:`memoryview` 객체들은 물론이고 :class:`bytes`, :class:`bytearray`, "
":class:`array.array` 객체들을 포함합니다. 바이트열류 객체들은 바이너리 데이터를 다루는 여러 가지 연산들에 사용될 "
"수 있습니다; 압축, 바이너리 파일로 저장, 소켓을 통한 전송 같은 것들이 있습니다."

#: ../../glossary.rst:183
msgid ""
"Some operations need the binary data to be mutable.  The documentation "
"often refers to these as \"read-write bytes-like objects\".  Example "
"mutable buffer objects include :class:`bytearray` and a "
":class:`memoryview` of a :class:`bytearray`. Other operations require the"
" binary data to be stored in immutable objects (\"read-only bytes-like "
"objects\"); examples of these include :class:`bytes` and a "
":class:`memoryview` of a :class:`bytes` object."
msgstr ""
"어떤 연산들은 바이너리 데이터가 가변적일 필요가 있습니다. 이런 경우에 설명서는 종종 \"읽고-쓰기 바이트열류 객체\"라고 "
"표현합니다. 가변 버퍼 객체의 예로는 :class:`bytearray` 와 :class:`bytearray` 의 "
":class:`memoryview` 가 있습니다. 다른 연산들은 바이너리 데이터가 불변 객체 (\"읽기 전용 바이트열류 객체\")에"
" 저장되도록 요구합니다; 이런 것들의 예로는 :class:`bytes`\\와 :class:`bytes` 객체의 "
":class:`memoryview` 가 있습니다."

#: ../../glossary.rst:191
msgid "bytecode"
msgstr "bytecode (바이트 코드)"

#: ../../glossary.rst:193
msgid ""
"Python source code is compiled into bytecode, the internal representation"
" of a Python program in the CPython interpreter.  The bytecode is also "
"cached in ``.pyc`` files so that executing the same file is faster the "
"second time (recompilation from source to bytecode can be avoided).  This"
" \"intermediate language\" is said to run on a :term:`virtual machine` "
"that executes the machine code corresponding to each bytecode. Do note "
"that bytecodes are not expected to work between different Python virtual "
"machines, nor to be stable between Python releases."
msgstr ""
"파이썬 소스 코드는 바이트 코드로 컴파일되는데, CPython 인터프리터에서 파이썬 프로그램의 내부 표현입니다. 바이트 코드는 "
"``.pyc`` 파일에 캐시 되어, 같은 파일을 두 번째 실행할 때 더 빨라지게 만듭니다 (소스에서 바이트 코드로의 재컴파일을 피할"
" 수 있습니다). 이 \"중간 언어\" 는 각 바이트 코드에 대응하는 기계를 실행하는 :term:`가상 기계 <virtual "
"machine>` 에서 실행된다고 말합니다. 바이트 코드는 서로 다른 파이썬 가상 기계에서 작동할 것으로 기대하지도, 파이썬 배포 "
"간에 안정적이지도 않다는 것에 주의해야 합니다."

#: ../../glossary.rst:203
msgid ""
"A list of bytecode instructions can be found in the documentation for "
":ref:`the dis module <bytecodes>`."
msgstr "바이트 코드 명령어들의 목록은 :ref:`dis 모듈 <bytecodes>` 설명서에 나옵니다."

#: ../../glossary.rst:205
#, fuzzy
msgid "callable"
msgstr "hashable (해시 가능)"

#: ../../glossary.rst:207
msgid ""
"A callable is an object that can be called, possibly with a set of "
"arguments (see :term:`argument`), with the following syntax::"
msgstr ""

#: ../../glossary.rst:210
msgid "callable(argument1, argument2, argumentN)"
msgstr ""

#: ../../glossary.rst:212
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method "
"is also a callable."
msgstr ""

#: ../../glossary.rst:215
msgid "callback"
msgstr "callback (콜백)"

#: ../../glossary.rst:217
msgid ""
"A subroutine function which is passed as an argument to be executed at "
"some point in the future."
msgstr "인자로 전달되는 미래의 어느 시점에서 실행될 서브 루틴 함수."

#: ../../glossary.rst:219
msgid "class"
msgstr "class (클래스)"

#: ../../glossary.rst:221
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr "사용자 정의 객체들을 만들기 위한 주형. 클래스 정의는 보통 클래스의 인스턴스를 대상으로 연산하는 메서드 정의들을 포함합니다."

#: ../../glossary.rst:224
msgid "class variable"
msgstr "class variable (클래스 변수)"

#: ../../glossary.rst:226
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr "클래스에서 정의되고 클래스 수준 (즉, 클래스의 인스턴스에서가 아니라) 에서만 수정되는 변수."

#: ../../glossary.rst:228
#, fuzzy
msgid "closure variable"
msgstr "class variable (클래스 변수)"

#: ../../glossary.rst:230
msgid ""
"A :term:`free variable` referenced from a :term:`nested scope` that is "
"defined in an outer scope rather than being resolved at runtime from the "
"globals or builtin namespaces. May be explicitly defined with the "
":keyword:`nonlocal` keyword to allow write access, or implicitly defined "
"if the variable is only being read."
msgstr ""

#: ../../glossary.rst:235
msgid ""
"For example, in the ``inner`` function in the following code, both ``x`` "
"and ``print`` are :term:`free variables <free variable>`, but only ``x`` "
"is a *closure variable*::"
msgstr ""

#: ../../glossary.rst:238
msgid ""
"def outer():\n"
"    x = 0\n"
"    def inner():\n"
"        nonlocal x\n"
"        x += 1\n"
"        print(x)\n"
"    return inner"
msgstr ""

#: ../../glossary.rst:246
msgid ""
"Due to the :attr:`codeobject.co_freevars` attribute (which, despite its "
"name, only includes the names of closure variables rather than listing "
"all referenced free variables), the more general :term:`free variable` "
"term is sometimes used even when the intended meaning is to refer "
"specifically to closure variables."
msgstr ""

#: ../../glossary.rst:250
msgid "complex number"
msgstr "complex number (복소수)"

#: ../../glossary.rst:252
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary "
"numbers are real multiples of the imaginary unit (the square root of "
"``-1``), often written ``i`` in mathematics or ``j`` in engineering.  "
"Python has built-in support for complex numbers, which are written with "
"this latter notation; the imaginary part is written with a ``j`` suffix, "
"e.g., ``3+1j``.  To get access to complex equivalents of the :mod:`math` "
"module, use :mod:`cmath`.  Use of complex numbers is a fairly advanced "
"mathematical feature.  If you're not aware of a need for them, it's "
"almost certain you can safely ignore them."
msgstr ""
"익숙한 실수 시스템의 확장인데, 모든 숫자가 실수부와 허수부의 합으로 표현됩니다. 허수부는 실수에 허수 단위(``-1``\\의 "
"제곱근)를 곱한 것인데, 종종 수학에서는 ``i``\\로, 공학에서는 ``j``\\로 표기합니다. 파이썬은 후자의 표기법을 쓰는 "
"복소수를 기본 지원합니다; 허수부는 ``j`` 접미사를 붙여서 표기합니다, 예를 들어, ``3+1j``. :mod:`math` "
"모듈의 복소수 버전이 필요하면, :mod:`cmath`\\를 사용합니다. 복소수의 활용은 꽤 수준 높은 수학적 기능입니다. "
"필요하다고 느끼지 못한다면, 거의 확실히 무시해도 좋습니다."

#: ../../glossary.rst:262
#, fuzzy
msgid "context"
msgstr "context manager (컨텍스트 관리자)"

#: ../../glossary.rst:264
msgid ""
"This term has different meanings depending on where and how it is used. "
"Some common meanings:"
msgstr ""

#: ../../glossary.rst:267
msgid ""
"The temporary state or environment established by a :term:`context "
"manager` via a :keyword:`with` statement."
msgstr ""

#: ../../glossary.rst:269
msgid ""
"The collection of key­value bindings associated with a particular "
":class:`contextvars.Context` object and accessed via "
":class:`~contextvars.ContextVar` objects.  Also see :term:`context "
"variable`."
msgstr ""

#: ../../glossary.rst:273
msgid "A :class:`contextvars.Context` object.  Also see :term:`current context`."
msgstr ""

#: ../../glossary.rst:275
#, fuzzy
msgid "context management protocol"
msgstr "context manager (컨텍스트 관리자)"

#: ../../glossary.rst:277
msgid ""
"The :meth:`~object.__enter__` and :meth:`~object.__exit__` methods called"
" by the :keyword:`with` statement.  See :pep:`343`."
msgstr ""

#: ../../glossary.rst:279
msgid "context manager"
msgstr "context manager (컨텍스트 관리자)"

#: ../../glossary.rst:281
#, fuzzy
msgid ""
"An object which implements the :term:`context management protocol` and "
"controls the environment seen in a :keyword:`with` statement.  See "
":pep:`343`."
msgstr ""
":meth:`__enter__` 와 :meth:`__exit__` 메서드를 정의함으로써 :keyword:`with` 문에서 보이는 "
"환경을 제어하는 객체. :pep:`343`\\으로 도입되었습니다."

#: ../../glossary.rst:284
msgid "context variable"
msgstr "context variable (컨텍스트 변수)"

#: ../../glossary.rst:286
msgid ""
"A variable whose value depends on which context is the :term:`current "
"context`.  Values are accessed via :class:`contextvars.ContextVar` "
"objects.  Context variables are primarily used to isolate state between "
"concurrent asynchronous tasks."
msgstr ""

#: ../../glossary.rst:290
msgid "contiguous"
msgstr "contiguous (연속)"

#: ../../glossary.rst:294
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* "
"or *Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in "
"memory next to each other, in order of increasing indexes starting from "
"zero.  In multidimensional C-contiguous arrays, the last index varies the"
" fastest when visiting items in order of memory address.  However, in "
"Fortran contiguous arrays, the first index varies the fastest."
msgstr ""
"버퍼는 정확히 *C-연속(C-contiguous)*\\이거나 *포트란 연속(Fortran contiguous)*\\일 때 연속이라고"
" 여겨집니다. 영차원 버퍼는 C-연속이면서 포트란 연속입니다. 일차원 배열에서, 항목들은 서로에 인접하고, 0에서 시작하는 오름차순"
" 인덱스의 순서대로 메모리에 배치되어야 합니다. 다차원 C-연속 배열에서, 메모리 주소의 순서대로 항목들을 방문할 때 마지막 "
"인덱스가 가장 빨리 변합니다. 하지만, 포트란 연속 배열에서는, 첫 번째 인덱스가 가장 빨리 변합니다."

#: ../../glossary.rst:302
msgid "coroutine"
msgstr "coroutine (코루틴)"

#: ../../glossary.rst:304
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also "
":pep:`492`."
msgstr ""
"코루틴은 서브루틴의 더 일반화된 형태입니다. 서브루틴은 한 지점에서 진입하고 다른 지점에서 탈출합니다. 코루틴은 여러 다른 지점에서"
" 진입하고, 탈출하고, 재개할 수 있습니다. 이것들은 :keyword:`async def` 문으로 구현할 수 있습니다. "
":pep:`492`\\를 보세요."

#: ../../glossary.rst:309
msgid "coroutine function"
msgstr "coroutine function (코루틴 함수)"

#: ../../glossary.rst:311
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine "
"function may be defined with the :keyword:`async def` statement, and may "
"contain :keyword:`await`, :keyword:`async for`, and :keyword:`async with`"
" keywords.  These were introduced by :pep:`492`."
msgstr ""
":term:`코루틴 <coroutine>` 객체를 돌려주는 함수. 코루틴 함수는 :keyword:`async def` 문으로 정의될"
" 수 있고, :keyword:`await` 와 :keyword:`async for`\\와 :keyword:`async with` "
"키워드를 포함할 수 있습니다. 이것들은 :pep:`492` 에 의해 도입되었습니다."

#: ../../glossary.rst:316
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:318
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term "
"\"CPython\" is used when necessary to distinguish this implementation "
"from others such as Jython or IronPython."
msgstr ""
"파이썬 프로그래밍 언어의 규범적인 구현인데, `python.org <https://www.python.org>`_\\에서 "
"배포됩니다. 이 구현을 Jython 이나 IronPython 과 같은 다른 것들과 구별할 필요가 있을 때 용어 \"CPython\""
" 이 사용됩니다."

#: ../../glossary.rst:322
#, fuzzy
msgid "current context"
msgstr "reference count (참조 횟수)"

#: ../../glossary.rst:324
msgid ""
"The :term:`context` (:class:`contextvars.Context` object) that is "
"currently used by :class:`~contextvars.ContextVar` objects to access (get"
" or set) the values of :term:`context variables <context variable>`.  "
"Each thread has its own current context.  Frameworks for executing "
"asynchronous tasks (see :mod:`asyncio`) associate each task with a "
"context which becomes the current context whenever the task starts or "
"resumes execution."
msgstr ""

#: ../../glossary.rst:330
msgid "decorator"
msgstr "decorator (데코레이터)"

#: ../../glossary.rst:332
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"다른 함수를 돌려주는 함수인데, 보통 ``@wrapper`` 문법을 사용한 함수 변환으로 적용됩니다. 데코레이터의 흔한 예는 "
":func:`classmethod` 과 :func:`staticmethod` 입니다."

#: ../../glossary.rst:336
msgid ""
"The decorator syntax is merely syntactic sugar, the following two "
"function definitions are semantically equivalent::"
msgstr "데코레이터 문법은 단지 편의 문법일 뿐입니다. 다음 두 함수 정의는 의미상으로 동등합니다::"

#: ../../glossary.rst:339
msgid ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@staticmethod\n"
"def f(arg):\n"
"    ..."
msgstr ""

#: ../../glossary.rst:347
msgid ""
"The same concept exists for classes, but is less commonly used there.  "
"See the documentation for :ref:`function definitions <function>` and "
":ref:`class definitions <class>` for more about decorators."
msgstr ""
"같은 개념이 클래스에도 존재하지만, 덜 자주 쓰입니다. 데코레이터에 대한 더 자세한 내용은 :ref:`함수 정의 "
"<function>` 와 :ref:`클래스 정의 <class>` 의 설명서를 보면 됩니다."

#: ../../glossary.rst:350
msgid "descriptor"
msgstr "descriptor (디스크립터)"

#: ../../glossary.rst:352
#, fuzzy
msgid ""
"Any object which defines the methods :meth:`~object.__get__`, "
":meth:`~object.__set__`, or :meth:`~object.__delete__`. When a class "
"attribute is a descriptor, its special binding behavior is triggered upon"
" attribute lookup.  Normally, using *a.b* to get, set or delete an "
"attribute looks up the object named *b* in the class dictionary for *a*, "
"but if *b* is a descriptor, the respective descriptor method gets called."
"  Understanding descriptors is a key to a deep understanding of Python "
"because they are the basis for many features including functions, "
"methods, properties, class methods, static methods, and reference to "
"super classes."
msgstr ""
"메서드 :meth:`__get__` 이나 :meth:`__set__` 이나 :meth:`__delete__`\\를 정의하는 객체. "
"클래스 어트리뷰트가 디스크립터일 때, 어트리뷰트 조회는 특별한 연결 작용을 일으킵니다. 보통, *a.b*\\를 읽거나, 쓰거나, "
"삭제하는데 사용할 때, *a*\\의 클래스 딕셔너리에서 *b* 라고 이름 붙여진 객체를 찾습니다. 하지만 *b*\\가 디스크립터면,"
" 해당하는 디스크립터 메서드가 호출됩니다. 디스크립터를 이해하는 것은 파이썬에 대한 깊은 이해의 열쇠인데, 함수, 메서드, "
"프로퍼티, 클래스 메서드, 스태틱 메서드, 슈퍼 클래스 참조 등의 많은 기능의 기초를 이루고 있기 때문입니다."

#: ../../glossary.rst:363
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` "
"or the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"디스크립터의 메서드들에 대한 자세한 내용은 :ref:`descriptors`\\나 :ref:`디스크립터 사용법 안내서 "
"<descriptorhowto>`\\에 나옵니다."

#: ../../glossary.rst:365
msgid "dictionary"
msgstr "dictionary (딕셔너리)"

#: ../../glossary.rst:367
#, fuzzy
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The "
"keys can be any object with :meth:`~object.__hash__` and "
":meth:`~object.__eq__` methods. Called a hash in Perl."
msgstr ""
"임의의 키를 값에 대응시키는 연관 배열 (associative array). 키는 :meth:`__hash__` 와 "
":meth:`__eq__` 메서드를 갖는 모든 객체가 될 수 있습니다. 펄에서 해시라고 부릅니다."

#: ../../glossary.rst:371
msgid "dictionary comprehension"
msgstr "dictionary comprehension (딕셔너리 컴프리헨션)"

#: ../../glossary.rst:373
#, python-brace-format
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value "
"``n ** 2``. See :ref:`comprehensions`."
msgstr ""
"이터러블에 있는 요소 전체나 일부를 처리하고 결과를 담은 딕셔너리를 반환하는 간결한 방법. ``results = {n: n ** 2"
" for n in range(10)}``\\은 값 ``n ** 2``\\에 매핑된 키 ``n``\\을 포함하는 딕셔너리를 "
"생성합니다. :ref:`comprehensions`\\을 참조하십시오."

#: ../../glossary.rst:377
msgid "dictionary view"
msgstr "dictionary view (딕셔너리 뷰)"

#: ../../glossary.rst:379
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and "
":meth:`dict.items` are called dictionary views. They provide a dynamic "
"view on the dictionary’s entries, which means that when the dictionary "
"changes, the view reflects these changes. To force the dictionary view to"
" become a full list use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values`, :meth:`dict.items` 메서드가 돌려주는 객체들을"
" 딕셔너리 뷰라고 부릅니다. 이것들은 딕셔너리 항목들에 대한 동적인 뷰를 제공하는데, 딕셔너리가 변경될 때, 뷰가 이 변화를 "
"반영한다는 뜻입니다. 딕셔너리 뷰를 완전한 리스트로 바꾸려면 ``list(dictview)``\\를 사용하면 됩니다. :ref"
":`dict-views`\\를 보세요."

#: ../../glossary.rst:385
msgid "docstring"
msgstr "docstring (독스트링)"

#: ../../glossary.rst:387
#, fuzzy
msgid ""
"A string literal which appears as the first expression in a class, "
"function or module.  While ignored when the suite is executed, it is "
"recognized by the compiler and put into the :attr:`~definition.__doc__` "
"attribute of the enclosing class, function or module.  Since it is "
"available via introspection, it is the canonical place for documentation "
"of the object."
msgstr ""
"클래스, 함수, 모듈에서 첫 번째 표현식으로 나타나는 문자열 리터럴. 스위트가 실행될 때는 무시되지만, 컴파일러에 의해 인지되어 "
"둘러싼 클래스, 함수, 모듈의 :attr:`__doc__` 어트리뷰트로 삽입됩니다. 인트로스펙션을 통해 사용할 수 있으므로, 객체의"
" 설명서를 위한 규범적인 장소입니다."

#: ../../glossary.rst:393
msgid "duck-typing"
msgstr "duck-typing (덕 타이핑)"

#: ../../glossary.rst:395
msgid ""
"A programming style which does not look at an object's type to determine "
"if it has the right interface; instead, the method or attribute is simply"
" called or used (\"If it looks like a duck and quacks like a duck, it "
"must be a duck.\")  By emphasizing interfaces rather than specific types,"
" well-designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or "
":func:`isinstance`.  (Note, however, that duck-typing can be complemented"
" with :term:`abstract base classes <abstract base class>`.)  Instead, it "
"typically employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"올바른 인터페이스를 가졌는지 판단하는데 객체의 형을 보지 않는 프로그래밍 스타일; 대신, 단순히 메서드나 어트리뷰트가 호출되거나 "
"사용됩니다 (\"오리처럼 보이고 오리처럼 꽥꽥댄다면, 그것은 오리다.\") 특정한 형 대신에 인터페이스를 강조함으로써, 잘 설계된 "
"코드는 다형적인 치환을 허락함으로써 유연성을 개선할 수 있습니다. 덕 타이핑은 :func:`type` 이나 "
":func:`isinstance` 을 사용한 검사를 피합니다. (하지만, 덕 타이핑이 :term:`추상 베이스 클래스 "
"<abstract base class>` 로 보완될 수 있음에 유의해야 합니다.) 대신에, :func:`hasattr` 검사나 "
":term:`EAFP` 프로그래밍을 씁니다."

#: ../../glossary.rst:404
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:406
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding"
" style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and "
":keyword:`except` statements.  The technique contrasts with the "
":term:`LBYL` style common to many other languages such as C."
msgstr ""
"허락보다는 용서를 구하기가 쉽다 (Easier to ask for forgiveness than permission). 이 흔히 볼"
" 수 있는 파이썬 코딩 스타일은, 올바른 키나 어트리뷰트의 존재를 가정하고, 그 가정이 틀리면 예외를 잡습니다. 이 깔끔하고 빠른 "
"스타일은 많은 :keyword:`try`\\와 :keyword:`except` 문의 존재로 특징지어집니다. 이 테크닉은 C와 같은 "
"다른 많은 언어에서 자주 사용되는 :term:`LBYL` 스타일과 대비됩니다."

#: ../../glossary.rst:412
msgid "expression"
msgstr "expression (표현식)"

#: ../../glossary.rst:414
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, "
"an expression is an accumulation of expression elements like literals, "
"names, attribute access, operators or function calls which all return a "
"value.  In contrast to many other languages, not all language constructs "
"are expressions.  There are also :term:`statement`\\s which cannot be "
"used as expressions, such as :keyword:`while`.  Assignments are also "
"statements, not expressions."
msgstr ""
"어떤 값으로 구해질 수 있는 문법적인 조각. 다른 말로 표현하면, 표현식은 리터럴, 이름, 어트리뷰트 액세스, 연산자, 함수들과 "
"같은 값을 돌려주는 표현 요소들을 쌓아 올린 것입니다. 다른 많은 언어와 대조적으로, 모든 언어 구성물들이 표현식인 것은 아닙니다."
" :keyword:`while`\\처럼, 표현식으로 사용할 수 없는 :term:`문장 <statement>` 들이 있습니다. 대입 "
"또한 문장이고, 표현식이 아닙니다."

#: ../../glossary.rst:421
msgid "extension module"
msgstr "extension module (확장 모듈)"

#: ../../glossary.rst:423
msgid ""
"A module written in C or C++, using Python's C API to interact with the "
"core and with user code."
msgstr "C 나 C++로 작성된 모듈인데, 파이썬의 C API를 사용해서 핵심이나 사용자 코드와 상호 작용합니다."

#: ../../glossary.rst:425
msgid "f-string"
msgstr "f-string (f-문자열)"

#: ../../glossary.rst:427
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called "
"\"f-strings\" which is short for :ref:`formatted string literals "
"<f-strings>`.  See also :pep:`498`."
msgstr ""
"``'f'`` 나 ``'F'`` 를 앞에 붙인 문자열 리터럴들을 흔히 \"f-문자열\"이라고 부르는데, :ref:`포맷 문자열 "
"리터럴 <f-strings>` 의 줄임말입니다. :pep:`498` 을 보세요."

#: ../../glossary.rst:430
msgid "file object"
msgstr "file object (파일 객체)"

#: ../../glossary.rst:432
#, fuzzy
msgid ""
"An object exposing a file-oriented API (with methods such as "
":meth:`!read` or :meth:`!write`) to an underlying resource.  Depending on"
" the way it was created, a file object can mediate access to a real on-"
"disk file or to another type of storage or communication device (for "
"example standard input/output, in-memory buffers, sockets, pipes, etc.)."
"  File objects are also called :dfn:`file-like objects` or "
":dfn:`streams`."
msgstr ""
"하부 자원에 대해 파일 지향적 API(:meth:`read()` 나 :meth:`write()` 같은 메서드들)를 드러내는 객체. "
"만들어진 방법에 따라, 파일 객체는 실제 디스크 상의 파일이나 다른 저장 장치나 통신 장치 (예를 들어, 표준 입출력, 인-메모리 "
"버퍼, 소켓, 파이프, 등등)에 대한 액세스를 중계할 수 있습니다. 파일 객체는 :dfn:`파일류 객체 (file-like "
"objects)`\\나 :dfn:`스트림 (streams)` 이라고도 불립니다."

#: ../../glossary.rst:440
msgid ""
"There are actually three categories of file objects: raw :term:`binary "
"files <binary file>`, buffered :term:`binary files <binary file>` and "
":term:`text files <text file>`. Their interfaces are defined in the "
":mod:`io` module.  The canonical way to create a file object is by using "
"the :func:`open` function."
msgstr ""
"실제로는 세 부류의 파일 객체들이 있습니다. 날(raw) :term:`바이너리 파일 <binary file>`, "
"버퍼드(buffered) :term:`바이너리 파일 <binary file>`, :term:`텍스트 파일 <text file>`. "
"이들의 인터페이스는 :mod:`io` 모듈에서 정의됩니다. 파일 객체를 만드는 규범적인 방법은 :func:`open` 함수를 쓰는 "
"것입니다."

#: ../../glossary.rst:445
msgid "file-like object"
msgstr "file-like object (파일류 객체)"

#: ../../glossary.rst:447
msgid "A synonym for :term:`file object`."
msgstr ":term:`파일 객체 <file object>` 의 비슷한 말."

#: ../../glossary.rst:448
msgid "filesystem encoding and error handler"
msgstr ""

#: ../../glossary.rst:450
msgid ""
"Encoding and error handler used by Python to decode bytes from the "
"operating system and encode Unicode to the operating system."
msgstr ""

#: ../../glossary.rst:453
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, "
"API functions can raise :exc:`UnicodeError`."
msgstr ""

#: ../../glossary.rst:457
msgid ""
"The :func:`sys.getfilesystemencoding` and "
":func:`sys.getfilesystemencodeerrors` functions can be used to get the "
"filesystem encoding and error handler."
msgstr ""

#: ../../glossary.rst:461
msgid ""
"The :term:`filesystem encoding and error handler` are configured at "
"Python startup by the :c:func:`PyConfig_Read` function: see "
":c:member:`~PyConfig.filesystem_encoding` and "
":c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""

#: ../../glossary.rst:466
#, fuzzy
msgid "See also the :term:`locale encoding`."
msgstr ":term:`패키지 <package>` 도 보세요."

#: ../../glossary.rst:467
msgid "finder"
msgstr "finder (파인더)"

#: ../../glossary.rst:469
msgid ""
"An object that tries to find the :term:`loader` for a module that is "
"being imported."
msgstr "임포트될 모듈을 위한 :term:`로더 <loader>` 를 찾으려고 시도하는 객체."

#: ../../glossary.rst:472
#, fuzzy
msgid ""
"There are two types of finder: :term:`meta path finders <meta path "
"finder>` for use with :data:`sys.meta_path`, and :term:`path entry "
"finders <path entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"파이썬 3.3. 이후로, 두 종류의 파인더가 있습니다: :data:`sys.meta_path` 와 함께 사용하는 :term:`메타 "
"경로 파인더 <meta path finder>` 와 :data:`sys.path_hooks` 과 함께 사용하는 :term:`경로 "
"엔트리 파인더 <path entry finder>`."

#: ../../glossary.rst:476
#, fuzzy
msgid "See :ref:`finders-and-loaders` and :mod:`importlib` for much more detail."
msgstr "더 자세한 내용은 :pep:`302`, :pep:`420`, :pep:`451` 에 나옵니다."

#: ../../glossary.rst:477
msgid "floor division"
msgstr "floor division (정수 나눗셈)"

#: ../../glossary.rst:479
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"가장 가까운 정수로 내림하는 수학적 나눗셈. 정수 나눗셈 연산자는 ``//`` 다. 예를 들어, 표현식 ``11 // 4`` 의 "
"값은 ``2``\\가 되지만, 실수 나눗셈은 ``2.75``\\를 돌려줍니다. ``(-11) // 4`` 가 ``-2.75``\\를"
" *내림* 한 ``-3``\\이 됨에 유의해야 합니다. :pep:`238`\\을 보세요."

#: ../../glossary.rst:484
msgid "free threading"
msgstr ""

#: ../../glossary.rst:486
msgid ""
"A threading model where multiple threads can run Python bytecode "
"simultaneously within the same interpreter.  This is in contrast to the "
":term:`global interpreter lock` which allows only one thread to execute "
"Python bytecode at a time.  See :pep:`703`."
msgstr ""

#: ../../glossary.rst:490
#, fuzzy
msgid "free variable"
msgstr "context variable (컨텍스트 변수)"

#: ../../glossary.rst:492
msgid ""
"Formally, as defined in the :ref:`language execution model <bind_names>`,"
" a free variable is any variable used in a namespace which is not a local"
" variable in that namespace. See :term:`closure variable` for an example."
" Pragmatically, due to the name of the :attr:`codeobject.co_freevars` "
"attribute, the term is also sometimes used as a synonym for "
":term:`closure variable`."
msgstr ""

#: ../../glossary.rst:497
msgid "function"
msgstr "function (함수)"

#: ../../glossary.rst:499
msgid ""
"A series of statements which returns some value to a caller. It can also "
"be passed zero or more :term:`arguments <argument>` which may be used in "
"the execution of the body. See also :term:`parameter`, :term:`method`, "
"and the :ref:`function` section."
msgstr ""
"호출자에게 어떤 값을 돌려주는 일련의 문장들. 없거나 그 이상의 :term:`인자 <argument>` 가 전달될 수 있는데, "
"바디의 실행에 사용될 수 있습니다. :term:`매개변수 <parameter>` 와 :term:`메서드 <method>` 와 "
":ref:`function` 섹션도 보세요."

#: ../../glossary.rst:503
msgid "function annotation"
msgstr "function annotation (함수 어노테이션)"

#: ../../glossary.rst:505
msgid "An :term:`annotation` of a function parameter or return value."
msgstr "함수 매개변수나 반환 값의 :term:`어노테이션 <annotation>`."

#: ../../glossary.rst:507
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`:"
" for example, this function is expected to take two :class:`int` "
"arguments and is also expected to have an :class:`int` return value::"
msgstr ""
"함수 어노테이션은 일반적으로 :term:`형 힌트 <type hint>` 로 사용됩니다: 예를 들어, 이 함수는 두 개의 "
":class:`int` 인자를 받아들일 것으로 기대되고, 동시에 :class:`int` 반환 값을 줄 것으로 기대됩니다::"

#: ../../glossary.rst:512
msgid ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   return a + b"
msgstr ""

#: ../../glossary.rst:515
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "함수 어노테이션 문법은 :ref:`function` 절에서 설명합니다."

#: ../../glossary.rst:517
#, fuzzy
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr "이 기능을 설명하는 :term:`변수 어노테이션 <variable annotation>` 과 :pep:`484`\\를 참조하세요."

#: ../../glossary.rst:521
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:523
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``,"
" directs the compiler to compile the current module using syntax or "
"semantics that will become standard in a future release of Python. The "
":mod:`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a "
"new feature was first added to the language and when it will (or did) "
"become the default::"
msgstr ""

#: ../../glossary.rst:531
msgid ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"
msgstr ""

#: ../../glossary.rst:534
msgid "garbage collection"
msgstr "garbage collection (가비지 수거)"

#: ../../glossary.rst:536
msgid ""
"The process of freeing memory when it is not used anymore.  Python "
"performs garbage collection via reference counting and a cyclic garbage "
"collector that is able to detect and break reference cycles.  The garbage"
" collector can be controlled using the :mod:`gc` module."
msgstr ""
"더 사용되지 않는 메모리를 반납하는 절차. 파이썬은 참조 횟수 추적과 참조 순환을 감지하고 끊을 수 있는 순환 가비지 수거기를 통해"
" 가비지 수거를 수행합니다. 가비지 수거기는 :mod:`gc` 모듈을 사용해서 제어할 수 있습니다."

#: ../../glossary.rst:541 ../../glossary.rst:542
msgid "generator"
msgstr "generator (제너레이터)"

#: ../../glossary.rst:544
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be "
"retrieved one at a time with the :func:`next` function."
msgstr ""
":term:`제너레이터 이터레이터 <generator iterator>` 를 돌려주는 함수. 일반 함수처럼 보이는데, 일련의 값들을"
" 만드는 :keyword:`yield` 표현식을 포함한다는 점이 다릅니다. 이 값들은 for-루프로 사용하거나 "
":func:`next` 함수로 한 번에 하나씩 꺼낼 수 있습니다."

#: ../../glossary.rst:549
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"보통 제너레이터 함수를 가리키지만, 어떤 문맥에서는 *제너레이터 이터레이터* 를 가리킵니다. 의도하는 의미가 명확하지 않은 경우는,"
" 완전한 용어를 써서 모호함을 없앱니다."

#: ../../glossary.rst:552
msgid "generator iterator"
msgstr "generator iterator (제너레이터 이터레이터)"

#: ../../glossary.rst:554
msgid "An object created by a :term:`generator` function."
msgstr ":term:`제너레이터 <generator>` 함수가 만드는 객체."

#: ../../glossary.rst:556
#, fuzzy
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *generator iterator* resumes, it picks up where it left off (in "
"contrast to functions which start fresh on every invocation)."
msgstr ""
"각 :keyword:`yield`\\는 일시적으로 처리를 중단하고, 그 위치의 (지역 변수들과 대기 중인 try-문들을 포함하는) "
"실행 상태를 기억합니다. *제너레이터 이터레이터* 가 재개되면, 떠난 곳으로 복귀합니다 (호출마다 새로 시작하는 함수와 "
"대비됩니다)."

#: ../../glossary.rst:562 ../../glossary.rst:563
msgid "generator expression"
msgstr "generator expression (제너레이터 표현식)"

#: ../../glossary.rst:565
#, fuzzy
msgid ""
"An :term:`expression` that returns an :term:`iterator`.  It looks like a "
"normal expression followed by a :keyword:`!for` clause defining a loop "
"variable, range, and an optional :keyword:`!if` clause.  The combined "
"expression generates values for an enclosing function::"
msgstr ""
"이터레이터를 돌려주는 표현식. 루프 변수와 범위를 정의하는 :keyword:`!for` 절과 생략 가능한 :keyword:`!if`"
" 절이 뒤에 붙는 일반 표현식 처럼 보입니다. 결합한 표현식은 둘러싼 함수를 위한 값들을 만들어냅니다::"

#: ../../glossary.rst:570
msgid ""
">>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n"
"285"
msgstr ""

#: ../../glossary.rst:572
msgid "generic function"
msgstr "generic function (제네릭 함수)"

#: ../../glossary.rst:574
msgid ""
"A function composed of multiple functions implementing the same operation"
" for different types. Which implementation should be used during a call "
"is determined by the dispatch algorithm."
msgstr ""
"같은 연산을 서로 다른 형들에 대해 구현한 여러 함수로 구성된 함수. 호출 때 어떤 구현이 사용될지는 디스패치 알고리즘에 의해 "
"결정됩니다."

#: ../../glossary.rst:578
msgid ""
"See also the :term:`single dispatch` glossary entry, the "
":func:`functools.singledispatch` decorator, and :pep:`443`."
msgstr ""
":term:`싱글 디스패치 <single dispatch>` 용어집 항목과 "
":func:`functools.singledispatch` 데코레이터와 :pep:`443`\\도 보세요."

#: ../../glossary.rst:580
msgid "generic type"
msgstr "generic type (제네릭 형)"

#: ../../glossary.rst:582
#, fuzzy
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for "
":term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
"매개 변수화 할 수 있는 :term:`형 <type>`; 일반적으로 :class:`list`\\와 같은 컨테이너. :term:`형 "
"힌트 <type hint>`\\와 :term:`어노테이션 <annotation>`\\에 사용됩니다."

#: ../../glossary.rst:587
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, "
":pep:`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""

#: ../../glossary.rst:589
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:591
msgid "See :term:`global interpreter lock`."
msgstr ":term:`전역 인터프리터 록 <global interpreter lock>` 을 보세요."

#: ../../glossary.rst:592
msgid "global interpreter lock"
msgstr "global interpreter lock (전역 인터프리터 록)"

#: ../../glossary.rst:594
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only"
" one thread executes Python :term:`bytecode` at a time. This simplifies "
"the CPython implementation by making the object model (including critical"
" built-in types such as :class:`dict`) implicitly safe against concurrent"
" access.  Locking the entire interpreter makes it easier for the "
"interpreter to be multi-threaded, at the expense of much of the "
"parallelism afforded by multi-processor machines."
msgstr ""
"한 번에 오직 하나의 스레드가 파이썬 :term:`바이트 코드 <bytecode>` 를 실행하도록 보장하기 위해 "
":term:`CPython` 인터프리터가 사용하는 메커니즘. (:class:`dict`\\와 같은 중요한 내장형들을 포함하는) 객체"
" 모델이 묵시적으로 동시 액세스에 대해 안전하도록 만들어서 CPython 구현을 단순하게 만듭니다. 인터프리터 전체를 잠그는 것은 "
"인터프리터를 다중스레드화하기 쉽게 만드는 대신, 다중 프로세서 기계가 제공하는 병렬성의 많은 부분을 희생합니다."

#: ../../glossary.rst:603
#, fuzzy
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive "
"tasks such as compression or hashing.  Also, the GIL is always released "
"when doing I/O."
msgstr ""
"하지만, 어떤 확장 모듈들은, 표준이나 제삼자 모두, 압축이나 해싱 같은 계산 집약적인 작업을 수행할 때는 GIL을 반납하도록 "
"설계되었습니다. 또한, I/O를 할 때는 항상 GIL을 반납합니다."

#: ../../glossary.rst:608
msgid ""
"As of Python 3.13, the GIL can be disabled using the :option:`--disable-"
"gil` build configuration. After building Python with this option, code "
"must be run with :option:`-X gil=0 <-X>` or after setting the "
":envvar:`PYTHON_GIL=0 <PYTHON_GIL>` environment variable. This feature "
"enables improved performance for multi-threaded applications and makes it"
" easier to use multi-core CPUs efficiently. For more details, see "
":pep:`703`."
msgstr ""

#: ../../glossary.rst:614
msgid "hash-based pyc"
msgstr "hash-based pyc (해시 기반 pyc)"

#: ../../glossary.rst:616
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified "
"time of the corresponding source file to determine its validity. See :ref"
":`pyc-invalidation`."
msgstr ""
"유효성을 판별하기 위해 해당 소스 파일의 최종 수정 시간이 아닌 해시를 사용하는 바이트 코드 캐시 파일. :ref:`pyc-"
"invalidation`\\을 참조하세요."

#: ../../glossary.rst:619
msgid "hashable"
msgstr "hashable (해시 가능)"

#: ../../glossary.rst:621
#, fuzzy
msgid ""
"An object is *hashable* if it has a hash value which never changes during"
" its lifetime (it needs a :meth:`~object.__hash__` method), and can be "
"compared to other objects (it needs an :meth:`~object.__eq__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr ""
"객체가 일생 그 값이 변하지 않는 해시값을 갖고 (:meth:`__hash__` 메서드가 필요합니다), 다른 객체와 비교될 수 "
"있으면 (:meth:`__eq__` 메서드가 필요합니다), *해시 가능*\\하다고 합니다. 같다고 비교되는 해시 가능한 객체들의 "
"해시값은 같아야 합니다."

#: ../../glossary.rst:627
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"해시 가능성은 객체를 딕셔너리의 키나 집합의 멤버로 사용할 수 있게 하는데, 이 자료 구조들이 내부적으로 해시값을 사용하기 "
"때문입니다."

#: ../../glossary.rst:630
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable "
"containers (such as lists or dictionaries) are not; immutable containers "
"(such as tuples and frozensets) are only hashable if their elements are "
"hashable.  Objects which are instances of user-defined classes are "
"hashable by default.  They all compare unequal (except with themselves), "
"and their hash value is derived from their :func:`id`."
msgstr ""
"대부분 파이썬의 불변 내장 객체들은 해시 가능합니다; (리스트나 딕셔너리 같은) 가변 컨테이너들은 그렇지 않습니다; (튜플이나 "
"frozenset 같은) 불변 컨테이너들은 그들의 요소들이 해시 가능할 때만 해시 가능합니다. 사용자 정의 클래스의 인스턴스 "
"객체들은 기본적으로 해시 가능합니다. (자기 자신을 제외하고는) 모두 다르다고 비교되고, 해시값은 :func:`id`\\로 부터 "
"만들어집니다."

#: ../../glossary.rst:637
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:639
#, fuzzy
msgid ""
"An Integrated Development and Learning Environment for Python. "
":ref:`idle` is a basic editor and interpreter environment which ships "
"with the standard distribution of Python."
msgstr ""
"파이썬을 위한 통합 개발 환경 (Integrated Development Environment). IDLE은 파이썬의 표준 배포판에"
" 따라오는 기초적인 편집기와 인터프리터 환경입니다."

#: ../../glossary.rst:642
#, fuzzy
msgid "immortal"
msgstr "immutable (불변)"

#: ../../glossary.rst:644
msgid ""
"*Immortal objects* are a CPython implementation detail introduced in "
":pep:`683`."
msgstr ""

#: ../../glossary.rst:647
msgid ""
"If an object is immortal, its :term:`reference count` is never modified, "
"and therefore it is never deallocated while the interpreter is running. "
"For example, :const:`True` and :const:`None` are immortal in CPython."
msgstr ""

#: ../../glossary.rst:650
msgid "immutable"
msgstr "immutable (불변)"

#: ../../glossary.rst:652
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings"
" and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important "
"role in places where a constant hash value is needed, for example as a "
"key in a dictionary."
msgstr ""
"고정된 값을 갖는 객체. 불변 객체는 숫자, 문자열, 튜플을 포함합니다. 이런 객체들은 변경될 수 없습니다. 새 값을 저장하려면 새"
" 객체를 만들어야 합니다. 변하지 않는 해시값이 있어야 하는 곳에서 중요한 역할을 합니다, 예를 들어, 딕셔너리의 키."

#: ../../glossary.rst:657
msgid "import path"
msgstr "import path (임포트 경로)"

#: ../../glossary.rst:659
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are "
"searched by the :term:`path based finder` for modules to import. During "
"import, this list of locations usually comes from :data:`sys.path`, but "
"for subpackages it may also come from the parent package's ``__path__`` "
"attribute."
msgstr ""
":term:`경로 기반 파인더 <path based finder>` 가 임포트 할 모듈을 찾기 위해 검색하는 장소들 (또는 "
":term:`경로 엔트리 <path entry>`) 의 목록. 임포트 하는 동안, 이 장소들의 목록은 보통 "
":data:`sys.path` 로부터 옵니다, 하지만 서브 패키지의 경우 부모 패키지의 ``__path__`` 어트리뷰트로부터 올 "
"수도 있습니다."

#: ../../glossary.rst:664
msgid "importing"
msgstr "importing (임포팅)"

#: ../../glossary.rst:666
msgid ""
"The process by which Python code in one module is made available to "
"Python code in another module."
msgstr "한 모듈의 파이썬 코드가 다른 모듈의 파이썬 코드에서 사용될 수 있도록 하는 절차."

#: ../../glossary.rst:668
msgid "importer"
msgstr "importer (임포터)"

#: ../../glossary.rst:670
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and "
":term:`loader` object."
msgstr ""
"모듈을 찾기도 하고 로드 하기도 하는 객체; 동시에 :term:`파인더 <finder>` 이자 :term:`로더 <loader>` "
"객체입니다."

#: ../../glossary.rst:672
msgid "interactive"
msgstr "interactive (대화형)"

#: ../../glossary.rst:674
#, fuzzy
msgid ""
"Python has an interactive interpreter which means you can enter "
"statements and expressions at the interpreter prompt, immediately execute"
" them and see their results.  Just launch ``python`` with no arguments "
"(possibly by selecting it from your computer's main menu). It is a very "
"powerful way to test out new ideas or inspect modules and packages "
"(remember ``help(x)``). For more on interactive mode, see :ref:`tut-"
"interac`."
msgstr ""
"파이썬은 대화형 인터프리터를 갖고 있는데, 인터프리터 프롬프트에서 문장과 표현식을 입력할 수 있고, 즉각 실행된 결과를 볼 수 "
"있다는 뜻입니다. 인자 없이 단지 ``python``\\을 실행하세요 (컴퓨터의 주메뉴에서 선택하는 것도 가능할 수 있습니다). 새"
" 아이디어를 검사하거나 모듈과 패키지를 들여다보는 매우 강력한 방법입니다 (``help(x)``\\를 기억하세요)."

#: ../../glossary.rst:681
msgid "interpreted"
msgstr "interpreted (인터프리티드)"

#: ../../glossary.rst:683
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though "
"the distinction can be blurry because of the presence of the bytecode "
"compiler.  This means that source files can be run directly without "
"explicitly creating an executable which is then run. Interpreted "
"languages typically have a shorter development/debug cycle than compiled "
"ones, though their programs generally also run more slowly.  See also "
":term:`interactive`."
msgstr ""
"바이트 코드 컴파일러의 존재 때문에 그 구분이 흐릿해지기는 하지만, 파이썬은 컴파일 언어가 아니라 인터프리터 언어입니다. 이것은 "
"명시적으로 실행 파일을 만들지 않고도, 소스 파일을 직접 실행할 수 있다는 뜻입니다. 그 프로그램이 좀 더 천천히 실행되기는 "
"하지만, 인터프리터 언어는 보통 컴파일 언어보다 짧은 개발/디버깅 주기를 갖습니다. :term:`대화형 <interactive>` "
"도 보세요."

#: ../../glossary.rst:690
msgid "interpreter shutdown"
msgstr "interpreter shutdown (인터프리터 종료)"

#: ../../glossary.rst:692
msgid ""
"When asked to shut down, the Python interpreter enters a special phase "
"where it gradually releases all allocated resources, such as modules and "
"various critical internal structures.  It also makes several calls to the"
" :term:`garbage collector <garbage collection>`. This can trigger the "
"execution of code in user-defined destructors or weakref callbacks. Code "
"executed during the shutdown phase can encounter various exceptions as "
"the resources it relies on may not function anymore (common examples are "
"library modules or the warnings machinery)."
msgstr ""
"종료하라는 요청을 받을 때, 파이썬 인터프리터는 특별한 시기에 진입하는데, 모듈이나 여러 가지 중요한 내부 구조들과 같은 모든 "
"할당된 자원들을 단계적으로 반납합니다. 또한, :term:`가비지 수거기 <garbage collection>` 를 여러 번 "
"호출합니다. 사용자 정의 파괴자나 weakref 콜백에 있는 코드들의 실행을 시작시킬 수 있습니다. 종료 시기 동안 실행되는 코드는"
" 다양한 예외들을 만날 수 있는데, 그것이 의존하는 자원들이 더 기능하지 않을 수 있기 때문입니다 (흔한 예는 라이브러리 모듈이나 "
"경고 장치들입니다)."

#: ../../glossary.rst:701
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module "
"or the script being run has finished executing."
msgstr "인터프리터 종료의 주된 원인은 실행되는 ``__main__`` 모듈이나 스크립트가 실행을 끝내는 것입니다."

#: ../../glossary.rst:703
msgid "iterable"
msgstr "iterable (이터러블)"

#: ../../glossary.rst:705
#, fuzzy
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, "
":class:`str`, and :class:`tuple`) and some non-sequence types like "
":class:`dict`, :term:`file objects <file object>`, and objects of any "
"classes you define with an :meth:`~object.__iter__` method or with a "
":meth:`~object.__getitem__` method that implements :term:`sequence` "
"semantics."
msgstr ""
"멤버들을 한 번에 하나씩 돌려줄 수 있는 객체. 이터러블의 예로는 모든 (:class:`list`, :class:`str`, "
":class:`tuple` 같은) 시퀀스 형들, :class:`dict` 같은 몇몇 비 시퀀스 형들, :term:`파일 객체들 "
"<file object>`, :meth:`__iter__` 나 :term:`시퀀스 <sequence>` 개념을 구현하는 "
":meth:`__getitem__` 메서드를 써서 정의한 모든 클래스의 객체들이 있습니다."

#: ../../glossary.rst:713
#, fuzzy
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function "
":func:`iter`, it returns an iterator for the object.  This iterator is "
"good for one pass over the set of values.  When using iterables, it is "
"usually not necessary to call :func:`iter` or deal with iterator objects "
"yourself.  The :keyword:`for` statement does that automatically for you, "
"creating a temporary unnamed variable to hold the iterator for the "
"duration of the loop.  See also :term:`iterator`, :term:`sequence`, and "
":term:`generator`."
msgstr ""
"이터러블은 :keyword:`for` 루프에 사용될 수 있고, 시퀀스를 필요로 하는 다른 많은 곳 (:func:`zip`, "
":func:`map`, ...) 에 사용될 수 있습니다. 이터러블 객체가 내장 함수 :func:`iter` 에 인자로 전달되면, 그"
" 객체의 이터레이터를 돌려줍니다. 이 이터레이터는 값들의 집합을 한 번 거치는 동안 유효합니다. 이터러블을 사용할 때, 보통은 "
":func:`iter` 를 호출하거나, 이터레이터 객체를 직접 다룰 필요는 없습니다. ``for`` 문은 이것들을 여러분을 대신해서"
" 자동으로 해주는데, 루프를 도는 동안 이터레이터를 잡아둘 이름 없는 변수를 만듭니다. :term:`이터레이터 "
"<iterator>`, :term:`시퀀스 <sequence>`, :term:`제너레이터 <generator>` 도 보세요."

#: ../../glossary.rst:723
msgid "iterator"
msgstr "iterator (이터레이터)"

#: ../../glossary.rst:725
#, fuzzy
msgid ""
"An object representing a stream of data.  Repeated calls to the "
"iterator's :meth:`~iterator.__next__` method (or passing it to the built-"
"in function :func:`next`) return successive items in the stream.  When no"
" more data are available a :exc:`StopIteration` exception is raised "
"instead.  At this point, the iterator object is exhausted and any further"
" calls to its :meth:`!__next__` method just raise :exc:`StopIteration` "
"again.  Iterators are required to have an :meth:`~iterator.__iter__` "
"method that returns the iterator object itself so every iterator is also "
"iterable and may be used in most places where other iterables are "
"accepted.  One notable exception is code which attempts multiple "
"iteration passes.  A container object (such as a :class:`list`) produces "
"a fresh new iterator each time you pass it to the :func:`iter` function "
"or use it in a :keyword:`for` loop.  Attempting this with an iterator "
"will just return the same exhausted iterator object used in the previous "
"iteration pass, making it appear like an empty container."
msgstr ""
"데이터의 스트림을 표현하는 객체. 이터레이터의 :meth:`~iterator.__next__` 메서드를 반복적으로 호출하면 (또는 "
"내장 함수 :func:`next` 로 전달하면) 스트림에 있는 항목들을 차례대로 돌려줍니다. 더 이상의 데이터가 없을 때는 대신 "
":exc:`StopIteration` 예외를 일으킵니다. 이 지점에서, 이터레이터 객체는 소진되고, 이후의 모든 "
":meth:`__next__` 메서드 호출은 :exc:`StopIteration` 예외를 다시 일으키기만 합니다. 이터레이터는 "
"이터레이터 객체 자신을 돌려주는 :meth:`__iter__` 메서드를 가질 것이 요구되기 때문에, 이터레이터는 이터러블이기도 하고"
" 다른 이터러블들을 받아들이는 대부분의 곳에서 사용될 수 있습니다. 중요한 예외는 여러 번의 이터레이션을 시도하는 코드입니다. "
"(:class:`list` 같은) 컨테이너 객체는 :func:`iter` 함수로 전달하거나 :keyword:`for` 루프에 사용할"
" 때마다 새 이터레이터를 만듭니다. 이런 것을 이터레이터에 대해서 수행하려고 하면, 지난 이터레이션에 사용된 이미 소진된 "
"이터레이터를 돌려줘서, 빈 컨테이너처럼 보이게 만듭니다."

#: ../../glossary.rst:740
msgid "More information can be found in :ref:`typeiter`."
msgstr ":ref:`typeiter` 에 더 자세한 내용이 있습니다."

#: ../../glossary.rst:744
msgid ""
"CPython does not consistently apply the requirement that an iterator "
"define :meth:`~iterator.__iter__`. And also please note that the free-"
"threading CPython does not guarantee the thread-safety of iterator "
"operations."
msgstr ""

#: ../../glossary.rst:749
msgid "key function"
msgstr "key function (키 함수)"

#: ../../glossary.rst:751
msgid ""
"A key function or collation function is a callable that returns a value "
"used for sorting or ordering.  For example, :func:`locale.strxfrm` is "
"used to produce a sort key that is aware of locale specific sort "
"conventions."
msgstr ""
"키 함수 또는 콜레이션(collation) 함수는 정렬(sorting)이나 배열(ordering)에 사용되는 값을 돌려주는 "
"콜러블입니다. 예를 들어, :func:`locale.strxfrm` 은 로케일 특정 방식을 따르는 정렬 키를 만드는 데 사용됩니다."

#: ../../glossary.rst:756
msgid ""
"A number of tools in Python accept key functions to control how elements "
"are ordered or grouped.  They include :func:`min`, :func:`max`, "
":func:`sorted`, :meth:`list.sort`, :func:`heapq.merge`, "
":func:`heapq.nsmallest`, :func:`heapq.nlargest`, and "
":func:`itertools.groupby`."
msgstr ""
"파이썬의 많은 도구가 요소들이 어떻게 순서 지어지고 묶이는지를 제어하기 위해 키 함수를 받아들입니다. 이런 것들에는 "
":func:`min`, :func:`max`, :func:`sorted`, :meth:`list.sort`, "
":func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq.nlargest`, "
":func:`itertools.groupby` 이 있습니다."

#: ../../glossary.rst:762
#, fuzzy
msgid ""
"There are several ways to create a key function.  For example. the "
":meth:`str.lower` method can serve as a key function for case insensitive"
" sorts.  Alternatively, a key function can be built from a "
":keyword:`lambda` expression such as ``lambda r: (r[0], r[2])``.  Also, "
":func:`operator.attrgetter`, :func:`operator.itemgetter`, and "
":func:`operator.methodcaller` are three key function constructors.  See "
"the :ref:`Sorting HOW TO <sortinghowto>` for examples of how to create "
"and use key functions."
msgstr ""
"키 함수를 만드는 데는 여러 방법이 있습니다. 예를 들어, :meth:`str.lower` 메서드는 케이스 구분 없는 정렬을 위한 "
"키 함수로 사용될 수 있습니다. 대안적으로, 키 함수는 :keyword:`lambda` 표현식으로 만들 수도 있는데, 이런 "
"식입니다: ``lambda r: (r[0], r[2])``. 또한, :mod:`operator` 모듈은 세 개의 키 함수 생성자를 "
"제공합니다: :func:`~operator.attrgetter`, :func:`~operator.itemgetter`, "
":func:`~operator.methodcaller`. 키 함수를 만들고 사용하는 법에 대한 예로 :ref:`Sorting HOW"
" TO <sortinghowto>` 를 보세요."

#: ../../glossary.rst:769
msgid "keyword argument"
msgstr "keyword argument (키워드 인자)"

#: ../../glossary.rst:771 ../../glossary.rst:1086
msgid "See :term:`argument`."
msgstr ":term:`인자 <argument>` 를 보세요."

#: ../../glossary.rst:772
msgid "lambda"
msgstr "lambda (람다)"

#: ../../glossary.rst:774
msgid ""
"An anonymous inline function consisting of a single :term:`expression` "
"which is evaluated when the function is called.  The syntax to create a "
"lambda function is ``lambda [parameters]: expression``"
msgstr ""
"호출될 때 값이 구해지는 하나의 :term:`표현식 <expression>` 으로 구성된 이름 없는 인라인 함수. 람다 함수를 "
"만드는 문법은 ``lambda [parameters]: expression`` 입니다."

#: ../../glossary.rst:777
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:779
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-"
"conditions before making calls or lookups.  This style contrasts with the"
" :term:`EAFP` approach and is characterized by the presence of many "
":keyword:`if` statements."
msgstr ""
"뛰기 전에 보라 (Look before you leap). 이 코딩 스타일은 호출이나 조회를 하기 전에 명시적으로 사전 조건들을 "
"검사합니다. 이 스타일은 :term:`EAFP` 접근법과 대비되고, 많은 :keyword:`if` 문의 존재로 특징지어집니다."

#: ../../glossary.rst:784
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a"
" race condition between \"the looking\" and \"the leaping\".  For "
"example, the code, ``if key in mapping: return mapping[key]`` can fail if"
" another thread removes *key* from *mapping* after the test, but before "
"the lookup. This issue can be solved with locks or by using the EAFP "
"approach."
msgstr ""
"다중 스레드 환경에서, LBYL 접근법은 \"보기\"와 \"뛰기\" 간에 경쟁 조건을 만들게 될 위험이 있습니다. 예를 들어, 코드"
" ``if key in mapping: return mapping[key]`` 는 검사 후에, 하지만 조회 전에, 다른 스레드가 "
"*key*\\를 *mapping*\\에서 제거하면 실패할 수 있습니다. 이런 이슈는 록이나 EAFP 접근법을 사용함으로써 해결될 수"
" 있습니다."

#: ../../glossary.rst:789
msgid "lexical analyzer"
msgstr ""

#: ../../glossary.rst:792
msgid "Formal name for the *tokenizer*; see :term:`token`."
msgstr ""

#: ../../glossary.rst:793
msgid "list"
msgstr "list (리스트)"

#: ../../glossary.rst:795
#, fuzzy
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to "
"an array in other languages than to a linked list since access to "
"elements is *O*\\ (1)."
msgstr ""
"내장 파이썬 :term:`시퀀스 <sequence>`. 그 이름에도 불구하고, 원소에 대한 액세스가 O(1)이기 때문에, 연결 "
"리스트(linked list)보다는 다른 언어의 배열과 유사합니다."

#: ../../glossary.rst:798
msgid "list comprehension"
msgstr "list comprehension (리스트 컴프리헨션)"

#: ../../glossary.rst:800
#, python-brace-format
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in"
" range(256) if x % 2 == 0]`` generates a list of strings containing even "
"hex numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause "
"is optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"시퀀스의 요소들 전부 또는 일부를 처리하고 그 결과를 리스트로 돌려주는 간결한 방법. ``result = "
"['{:#04x}'.format(x) for x in range(256) if x % 2 == 0]`` 는 0에서 255 사이에 "
"있는 짝수들의 16진수 (0x..) 들을 포함하는 문자열의 리스트를 만듭니다. :keyword:`if` 절은 생략할 수 있습니다. "
"생략하면, ``range(256)``\\에 있는 모든 요소가 처리됩니다."

#: ../../glossary.rst:806
msgid "loader"
msgstr "loader (로더)"

#: ../../glossary.rst:808
msgid ""
"An object that loads a module. It must define the :meth:`!exec_module` "
"and :meth:`!create_module` methods to implement the "
":class:`~importlib.abc.Loader` interface. A loader is typically returned "
"by a :term:`finder`. See also:"
msgstr ""

#: ../../glossary.rst:814
msgid ":ref:`finders-and-loaders`"
msgstr ""

#: ../../glossary.rst:815
msgid ":class:`importlib.abc.Loader`"
msgstr ""

#: ../../glossary.rst:816
#, fuzzy
msgid ":pep:`302`"
msgstr ":pep:`1` 참조하세요."

#: ../../glossary.rst:817
#, fuzzy
msgid "locale encoding"
msgstr "text encoding (텍스트 인코딩)"

#: ../../glossary.rst:819
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with "
":func:`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""

#: ../../glossary.rst:822
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr ""

#: ../../glossary.rst:824
msgid "On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr ""

#: ../../glossary.rst:826
msgid ":func:`locale.getencoding` can be used to get the locale encoding."
msgstr ""

#: ../../glossary.rst:828
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr ""

#: ../../glossary.rst:829
msgid "magic method"
msgstr "magic method (매직 메서드)"

#: ../../glossary.rst:833
msgid "An informal synonym for :term:`special method`."
msgstr ":term:`특수 메서드 <special method>` 의 비공식적인 비슷한 말."

#: ../../glossary.rst:834
msgid "mapping"
msgstr "mapping (매핑)"

#: ../../glossary.rst:836
#, fuzzy
msgid ""
"A container object that supports arbitrary key lookups and implements the"
" methods specified in the :class:`collections.abc.Mapping` or "
":class:`collections.abc.MutableMapping` :ref:`abstract base classes "
"<collections-abstract-base-classes>`.  Examples include :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict` and "
":class:`collections.Counter`."
msgstr ""
"임의의 키 조회를 지원하고 :class:`~collections.abc.Mapping` 이나 "
":class:`~collections.abc.MutableMapping` :ref:`추상 베이스 클래스 <collections-"
"abstract-base-classes>` 에 지정된 메서드들을 구현하는 컨테이너 객체. 예로는 :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict`, "
":class:`collections.Counter` 를 들 수 있습니다."

#: ../../glossary.rst:842
msgid "meta path finder"
msgstr "meta path finder (메타 경로 파인더)"

#: ../../glossary.rst:844
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta "
"path finders are related to, but different from :term:`path entry finders"
" <path entry finder>`."
msgstr ""
":data:`sys.meta_path` 의 검색이 돌려주는 :term:`파인더 <finder>`. 메타 경로 파인더는 "
":term:`경로 엔트리 파인더 <path entry finder>` 와 관련되어 있기는 하지만 다릅니다."

#: ../../glossary.rst:848
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr "메타 경로 파인더가 구현하는 메서드들에 대해서는 :class:`importlib.abc.MetaPathFinder` 를 보면 됩니다."

#: ../../glossary.rst:850
msgid "metaclass"
msgstr "metaclass (메타 클래스)"

#: ../../glossary.rst:852
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for"
" taking those three arguments and creating the class.  Most object "
"oriented programming languages provide a default implementation.  What "
"makes Python special is that it is possible to create custom metaclasses."
"  Most users never need this tool, but when the need arises, metaclasses "
"can provide powerful, elegant solutions.  They have been used for logging"
" attribute access, adding thread-safety, tracking object creation, "
"implementing singletons, and many other tasks."
msgstr ""
"클래스의 클래스. 클래스 정의는 클래스 이름, 클래스 딕셔너리, 베이스 클래스들의 목록을 만듭니다. 메타 클래스는 이 세 인자를 "
"받아서 클래스를 만드는 책임을 집니다. 대부분의 객체 지향형 프로그래밍 언어들은 기본 구현을 제공합니다. 파이썬을 특별하게 만드는 "
"것은 커스텀 메타 클래스를 만들 수 있다는 것입니다. 대부분 사용자에게는 이 도구가 전혀 필요 없지만, 필요가 생길 때, 메타 "
"클래스는 강력하고 우아한 해법을 제공합니다. 어트리뷰트 액세스의 로깅(logging), 스레드 안전성의 추가, 객체 생성 추적, "
"싱글톤 구현과 많은 다른 작업에 사용됐습니다."

#: ../../glossary.rst:862
msgid "More information can be found in :ref:`metaclasses`."
msgstr ":ref:`metaclasses` 에서 더 자세한 내용을 찾을 수 있습니다."

#: ../../glossary.rst:831 ../../glossary.rst:863 ../../glossary.rst:1231
msgid "method"
msgstr "method (메서드)"

#: ../../glossary.rst:865
msgid ""
"A function which is defined inside a class body.  If called as an "
"attribute of an instance of that class, the method will get the instance "
"object as its first :term:`argument` (which is usually called ``self``). "
"See :term:`function` and :term:`nested scope`."
msgstr ""
"클래스 바디 안에서 정의되는 함수. 그 클래스의 인스턴스의 어트리뷰트로서 호출되면, 그 메서드는 첫 번째 :term:`인자 "
"<argument>` (보통 ``self`` 라고 불린다) 로 인스턴스 객체를 받습니다. :term:`함수 <function>` 와"
" :term:`중첩된 스코프 <nested scope>` 를 보세요."

#: ../../glossary.rst:869
msgid "method resolution order"
msgstr "method resolution order (메서드 결정 순서)"

#: ../../glossary.rst:871
#, fuzzy
msgid ""
"Method Resolution Order is the order in which base classes are searched "
"for a member during lookup. See :ref:`python_2.3_mro` for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""
"메서드 결정 순서는 조회하는 동안 멤버를 검색하는 베이스 클래스들의 순서입니다. 2.3 릴리스부터 파이썬 인터프리터에 사용된 "
"알고리즘의 상세한 내용은 `The Python 2.3 Method Resolution Order "
"<https://www.python.org/download/releases/2.3/mro/>`_\\를 보면 됩니다."

#: ../../glossary.rst:874
msgid "module"
msgstr "module (모듈)"

#: ../../glossary.rst:876
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded"
" into Python by the process of :term:`importing`."
msgstr ""
"파이썬 코드의 조직화 단위를 담당하는 객체. 모듈은 임의의 파이썬 객체들을 담는 이름 공간을 갖습니다. 모듈은 :term:`임포팅 "
"<importing>` 절차에 의해 파이썬으로 로드됩니다."

#: ../../glossary.rst:880
msgid "See also :term:`package`."
msgstr ":term:`패키지 <package>` 도 보세요."

#: ../../glossary.rst:881
msgid "module spec"
msgstr "module spec (모듈 스펙)"

#: ../../glossary.rst:883
msgid ""
"A namespace containing the import-related information used to load a "
"module. An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"모듈을 로드하는데 사용되는 임포트 관련 정보들을 담고 있는 이름 공간. "
":class:`importlib.machinery.ModuleSpec` 의 인스턴스."

#: ../../glossary.rst:886
#, fuzzy
msgid "See also :ref:`module-specs`."
msgstr ":term:`모듈 <module>` 도 보세요."

#: ../../glossary.rst:887
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:889
msgid "See :term:`method resolution order`."
msgstr ":term:`메서드 결정 순서 <method resolution order>` 를 보세요."

#: ../../glossary.rst:890
msgid "mutable"
msgstr "mutable (가변)"

#: ../../glossary.rst:892
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See "
"also :term:`immutable`."
msgstr "가변 객체는 값이 변할 수 있지만 :func:`id` 는 일정하게 유지합니다. :term:`불변 <immutable>` 도 보세요."

#: ../../glossary.rst:894
msgid "named tuple"
msgstr "named tuple (네임드 튜플)"

#: ../../glossary.rst:896
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"\"named tuple(네임드 튜플)\"이라는 용어는 튜플에서 상속하고 이름 붙은 어트리뷰트를 사용하여 인덱스 할 수 있는 요소에"
" 액세스 할 수 있는 모든 형이나 클래스에 적용됩니다. 형이나 클래스에는 다른 기능도 있을 수 있습니다."

#: ../../glossary.rst:900
msgid ""
"Several built-in types are named tuples, including the values returned by"
" :func:`time.localtime` and :func:`os.stat`.  Another example is "
":data:`sys.float_info`::"
msgstr ""
":func:`time.localtime`\\과 :func:`os.stat`\\가 반환한 값을 포함하여, 여러 내장형이 네임드 "
"튜플입니다. 또 다른 예는 :data:`sys.float_info`\\입니다::"

#: ../../glossary.rst:904
msgid ""
">>> sys.float_info[1]                   # indexed access\n"
"1024\n"
">>> sys.float_info.max_exp              # named field access\n"
"1024\n"
">>> isinstance(sys.float_info, tuple)   # kind of tuple\n"
"True"
msgstr ""

#: ../../glossary.rst:911
#, fuzzy
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class "
"definition that inherits from :class:`tuple` and that defines named "
"fields.  Such a class can be written by hand, or it can be created by "
"inheriting :class:`typing.NamedTuple`, or with the factory function "
":func:`collections.namedtuple`.  The latter techniques also add some "
"extra methods that may not be found in hand-written or built-in named "
"tuples."
msgstr ""
"일부 네임드 튜플은 내장형(위의 예)입니다. 또는, :class:`tuple`\\에서 상속하고 이름 붙은 필드를 정의하는 일반 "
"클래스 정의로 네임드 튜플을 만들 수 있습니다. 이러한 클래스는 직접 작성하거나 팩토리 함수 "
":func:`collections.namedtuple`\\로 만들 수 있습니다. 후자의 기법은 직접 작성하거나 내장 네임드 "
"튜플에서는 찾을 수 없는 몇 가지 추가 메서드를 추가하기도 합니다."

#: ../../glossary.rst:919
msgid "namespace"
msgstr "namespace (이름 공간)"

#: ../../glossary.rst:921
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as "
"well as nested namespaces in objects (in methods).  Namespaces support "
"modularity by preventing naming conflicts.  For instance, the functions "
":func:`builtins.open <.open>` and :func:`os.open` are distinguished by "
"their namespaces.  Namespaces also aid readability and maintainability by"
" making it clear which module implements a function.  For instance, "
"writing :func:`random.seed` or :func:`itertools.islice` makes it clear "
"that those functions are implemented by the :mod:`random` and "
":mod:`itertools` modules, respectively."
msgstr ""
"변수가 저장되는 장소. 이름 공간은 딕셔너리로 구현됩니다. 객체에 중첩된 이름 공간 (메서드 에서) 뿐만 아니라 지역, 전역, 내장"
" 이름 공간이 있습니다. 이름 공간은 이름 충돌을 방지해서 모듈성을 지원합니다. 예를 들어, 함수 "
":func:`builtins.open <.open>` 과 :func:`os.open` 은 그들의 이름 공간에 의해 구별됩니다. "
"또한, 이름 공간은 어떤 모듈이 함수를 구현하는지를 분명하게 만들어서 가독성과 유지 보수성에 도움을 줍니다. 예를 들어, "
":func:`random.seed` 또는 :func:`itertools.islice` 라고 쓰면 그 함수들이 각각 "
":mod:`random` 과 :mod:`itertools` 모듈에 의해 구현되었음이 명확해집니다."

#: ../../glossary.rst:931
msgid "namespace package"
msgstr "namespace package (이름 공간 패키지)"

#: ../../glossary.rst:933
#, fuzzy
msgid ""
"A :term:`package` which serves only as a container for subpackages. "
"Namespace packages may have no physical representation, and specifically "
"are not like a :term:`regular package` because they have no "
"``__init__.py`` file."
msgstr ""
"오직 서브 패키지들의 컨테이너로만 기능하는 :pep:`420` :term:`패키지 <package>`. 이름 공간 패키지는 물리적인"
" 실체가 없을 수도 있고, 특히 ``__init__.py`` 파일이 없으므로 :term:`정규 패키지 <regular "
"package>` 와는 다릅니다."

#: ../../glossary.rst:938
msgid ""
"Namespace packages allow several individually installable packages to "
"have a common parent package. Otherwise, it is recommended to use a "
":term:`regular package`."
msgstr ""

#: ../../glossary.rst:941
msgid ""
"For more information, see :pep:`420` and :ref:`reference-namespace-"
"package`."
msgstr ""

#: ../../glossary.rst:943
msgid "See also :term:`module`."
msgstr ":term:`모듈 <module>` 도 보세요."

#: ../../glossary.rst:944
msgid "nested scope"
msgstr "nested scope (중첩된 스코프)"

#: ../../glossary.rst:946
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to "
"variables in the outer function.  Note that nested scopes by default work"
" only for reference and not for assignment.  Local variables both read "
"and write in the innermost scope.  Likewise, global variables read and "
"write to the global namespace.  The :keyword:`nonlocal` allows writing to"
" outer scopes."
msgstr ""
"둘러싼 정의에서 변수를 참조하는 능력. 예를 들어, 다른 함수 내부에서 정의된 함수는 바깥 함수에 있는 변수들을 참조할 수 "
"있습니다. 중첩된 스코프는 기본적으로는 참조만 가능할 뿐, 대입은 되지 않는다는 것에 주의해야 합니다. 지역 변수들은 가장 내부의 "
"스코프에서 읽고 씁니다. 마찬가지로, 전역 변수들은 전역 이름 공간에서 읽고 씁니다. :keyword:`nonlocal` 은 바깥 "
"스코프에 쓰는 것을 허락합니다."

#: ../../glossary.rst:953
msgid "new-style class"
msgstr "new-style class (뉴스타일 클래스)"

#: ../../glossary.rst:955
#, fuzzy
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer,"
" versatile features like :attr:`~object.__slots__`, descriptors, "
"properties, :meth:`~object.__getattribute__`, class methods, and static "
"methods."
msgstr ""
"지금은 모든 클래스 객체에 사용되고 있는 클래스 버전의 예전 이름. 초기의 파이썬 버전에서는, 오직 뉴스타일 클래스만 "
":attr:`~object.__slots__`, 디스크립터, 프라퍼티, :meth:`__getattribute__`, 클래스 "
"메서드, 스태틱 메서드와 같은 파이썬의 새롭고 다양한 기능들을 사용할 수 있었습니다."

#: ../../glossary.rst:960
msgid "object"
msgstr "object (객체)"

#: ../../glossary.rst:962
msgid ""
"Any data with state (attributes or value) and defined behavior (methods)."
"  Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"상태 (어트리뷰트나 값) 를 갖고 동작 (메서드) 이 정의된 모든 데이터. 또한, 모든 :term:`뉴스타일 클래스 <new-"
"style class>` 의 최종적인 베이스 클래스입니다."

#: ../../glossary.rst:965
#, fuzzy
msgid "optimized scope"
msgstr "nested scope (중첩된 스코프)"

#: ../../glossary.rst:967
msgid ""
"A scope where target local variable names are reliably known to the "
"compiler when the code is compiled, allowing optimization of read and "
"write access to these names. The local namespaces for functions, "
"generators, coroutines, comprehensions, and generator expressions are "
"optimized in this fashion. Note: most interpreter optimizations are "
"applied to all scopes, only those relying on a known set of local and "
"nonlocal variable names are restricted to optimized scopes."
msgstr ""

#: ../../glossary.rst:974
msgid "package"
msgstr "package (패키지)"

#: ../../glossary.rst:976
#, fuzzy
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a "
"``__path__`` attribute."
msgstr ""
"서브 모듈들이나, 재귀적으로 서브 패키지들을 포함할 수 있는 파이썬 :term:`모듈 <module>`. 기술적으로, 패키지는 "
"``__path__`` 어트리뷰트가 있는 파이썬 모듈입니다."

#: ../../glossary.rst:980
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr ""
":term:`정규 패키지 <regular package>` 와 :term:`이름 공간 패키지 <namespace package>` "
"도 보세요."

#: ../../glossary.rst:981
msgid "parameter"
msgstr "parameter (매개변수)"

#: ../../glossary.rst:983
msgid ""
"A named entity in a :term:`function` (or method) definition that "
"specifies an :term:`argument` (or in some cases, arguments) that the "
"function can accept.  There are five kinds of parameter:"
msgstr ""
":term:`함수 <function>` (또는 메서드) 정의에서 함수가 받을 수 있는 :term:`인자 <argument>` (또는"
" 어떤 경우 인자들) 를 지정하는 이름 붙은 엔티티. 다섯 종류의 매개변수가 있습니다:"

#: ../../glossary.rst:987
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* "
"and *bar* in the following::"
msgstr ""
":dfn:`위치-키워드 (positional-or-keyword)`: :term:`위치 인자 <positional "
"argument>` 나 :term:`키워드 인자 <keyword argument>` 로 전달될 수 있는 인자를 지정합니다. 이것이 "
"기본 형태의 매개변수입니다, 예를 들어 다음에서 *foo* 와 *bar*::"

#: ../../glossary.rst:992
msgid "def func(foo, bar=None): ..."
msgstr ""

#: ../../glossary.rst:996
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only "
"by position. Positional-only parameters can be defined by including a "
"``/`` character in the parameter list of the function definition after "
"them, for example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`위치-전용 (positional-only)`: 위치로만 제공될 수 있는 인자를 지정합니다. 위치 전용 매개변수는 함수 "
"정의의 매개변수 목록에 ``/`` 문자를 포함하고 그 뒤에 정의할 수 있습니다, 예를 들어 다음에서 *posonly1*\\과 "
"*posonly2*::"

#: ../../glossary.rst:1001
msgid "def func(posonly1, posonly2, /, positional_or_keyword): ..."
msgstr ""

#: ../../glossary.rst:1005
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single "
"var-positional parameter or bare ``*`` in the parameter list of the "
"function definition before them, for example *kw_only1* and *kw_only2* in"
" the following::"
msgstr ""
":dfn:`키워드-전용 (keyword-only)`: 키워드로만 제공될 수 있는 인자를 지정합니다. 키워드-전용 매개변수는 함수 "
"정의의 매개변수 목록에서 앞에 하나의 가변-위치 매개변수나 ``*``\\를 그대로 포함해서 정의할 수 있습니다. 예를 들어, "
"다음에서 *kw_only1* 와 *kw_only2*::"

#: ../../glossary.rst:1011
msgid "def func(arg, *, kw_only1, kw_only2): ..."
msgstr ""

#: ../../glossary.rst:1013
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional"
" arguments can be provided (in addition to any positional arguments "
"already accepted by other parameters).  Such a parameter can be defined "
"by prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`가변-위치 (var-positional)`: (다른 매개변수들에 의해서 이미 받아들여진 위치 인자들에 더해) 제공될 수 "
"있는 위치 인자들의 임의의 시퀀스를 지정합니다. 이런 매개변수는 매개변수 이름에 ``*`` 를 앞에 붙여서 정의될 수 있습니다, "
"예를 들어 다음에서 *args*::"

#: ../../glossary.rst:1019
msgid "def func(*args, **kwargs): ..."
msgstr ""

#: ../../glossary.rst:1021
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can"
" be provided (in addition to any keyword arguments already accepted by "
"other parameters).  Such a parameter can be defined by prepending the "
"parameter name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`가변-키워드 (var-keyword)`: (다른 매개변수들에 의해서 이미 받아들여진 키워드 인자들에 더해) 제공될 수 "
"있는 임의의 개수 키워드 인자들을 지정합니다. 이런 매개변수는 매개변수 이름에 ``**``\\를 앞에 붙여서 정의될 수 있습니다, "
"예를 들어 위의 예에서 *kwargs*."

#: ../../glossary.rst:1027
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr "매개변수는 선택적 인자들을 위한 기본값뿐만 아니라 선택적이거나 필수 인자들을 지정할 수 있습니다."

#: ../../glossary.rst:1030
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on "
":ref:`the difference between arguments and parameters <faq-argument-vs-"
"parameter>`, the :class:`inspect.Parameter` class, the :ref:`function` "
"section, and :pep:`362`."
msgstr ""
":term:`인자 <argument>` 용어집 항목, :ref:`인자와 매개변수의 차이 <faq-argument-vs-"
"parameter>`\\에 나오는 FAQ 질문, :class:`inspect.Parameter` 클래스, "
":ref:`function` 절, :pep:`362`\\도 보세요."

#: ../../glossary.rst:1034
msgid "path entry"
msgstr "path entry (경로 엔트리)"

#: ../../glossary.rst:1036
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
":term:`경로 기반 파인더 <path based finder>` 가 임포트 할 모듈들을 찾기 위해 참고하는 :term:`임포트 "
"경로 <import path>` 상의 하나의 장소."

#: ../../glossary.rst:1038
msgid "path entry finder"
msgstr "path entry finder (경로 엔트리 파인더)"

#: ../../glossary.rst:1040
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a"
" :term:`path entry hook`) which knows how to locate modules given a "
":term:`path entry`."
msgstr ""
":data:`sys.path_hooks` 에 있는 콜러블 (즉, :term:`경로 엔트리 훅 <path entry hook>`) 이"
" 돌려주는 :term:`파인더 <finder>` 인데, 주어진 :term:`경로 엔트리 <path entry>` 로 모듈을 찾는 "
"방법을 알고 있습니다."

#: ../../glossary.rst:1044
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path "
"entry finders implement."
msgstr "경로 엔트리 파인더들이 구현하는 메서드들은 :class:`importlib.abc.PathEntryFinder` 에 나옵니다."

#: ../../glossary.rst:1046
msgid "path entry hook"
msgstr "path entry hook (경로 엔트리 훅)"

#: ../../glossary.rst:1048
#, fuzzy
msgid ""
"A callable on the :data:`sys.path_hooks` list which returns a :term:`path"
" entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
":data:`sys.path_hook` 리스트에 있는 콜러블인데, 특정 :term:`경로 엔트리 <path entry>` 에서 "
"모듈을 찾는 법을 알고 있다면 :term:`경로 엔트리 파인더 <path entry finder>` 를 돌려줍니다."

#: ../../glossary.rst:1051
msgid "path based finder"
msgstr "path based finder (경로 기반 파인더)"

#: ../../glossary.rst:1053
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"기본 :term:`메타 경로 파인더들 <meta path finder>` 중 하나인데, :term:`임포트 경로 <import "
"path>` 에서 모듈을 찾습니다."

#: ../../glossary.rst:1055
msgid "path-like object"
msgstr "path-like object (경로류 객체)"

#: ../../glossary.rst:1057
msgid ""
"An object representing a file system path. A path-like object is either a"
" :class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports "
"the :class:`os.PathLike` protocol can be converted to a :class:`str` or "
":class:`bytes` file system path by calling the :func:`os.fspath` "
"function; :func:`os.fsdecode` and :func:`os.fsencode` can be used to "
"guarantee a :class:`str` or :class:`bytes` result instead, respectively. "
"Introduced by :pep:`519`."
msgstr ""
"파일 시스템 경로를 나타내는 객체. 경로류 객체는 경로를 나타내는 :class:`str` 나 :class:`bytes` 객체이거나 "
":class:`os.PathLike` 프로토콜을 구현하는 객체입니다. :class:`os.PathLike` 프로토콜을 지원하는 "
"객체는 :func:`os.fspath` 함수를 호출해서 :class:`str` 나 :class:`bytes` 파일 시스템 경로로 "
"변환될 수 있습니다; 대신 :func:`os.fsdecode` 와 :func:`os.fsencode` 는 각각 "
":class:`str` 나 :class:`bytes` 결과를 보장하는데 사용될 수 있습니다. :pep:`519`\\로 "
"도입되었습니다."

#: ../../glossary.rst:1065
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:1067
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for "
"Python or its processes or environment. PEPs should provide a concise "
"technical specification and a rationale for proposed features."
msgstr ""
"파이썬 개선 제안. PEP는 파이썬 커뮤니티에 정보를 제공하거나 파이썬 또는 그 프로세스 또는 환경에 대한 새로운 기능을 설명하는 "
"설계 문서입니다. PEP는 제안된 기능에 대한 간결한 기술 사양 및 근거를 제공해야 합니다."

#: ../../glossary.rst:1073
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting"
" the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP는 주요 새로운 기능을 제안하고 문제에 대한 커뮤니티 입력을 수집하며 파이썬에 들어간 설계 결정을 문서로 만들기 위한 기본 "
"메커니즘입니다. PEP 작성자는 커뮤니티 내에서 합의를 구축하고 반대 의견을 문서화 할 책임이 있습니다."

#: ../../glossary.rst:1079
msgid "See :pep:`1`."
msgstr ":pep:`1` 참조하세요."

#: ../../glossary.rst:1080
msgid "portion"
msgstr "portion (포션)"

#: ../../glossary.rst:1082
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that"
" contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
":pep:`420` 에서 정의한 것처럼, 이름 공간 패키지에 이바지하는 하나의 디렉터리에 들어있는 파일들의 집합 (zip 파일에 "
"저장되는 것도 가능합니다)."

#: ../../glossary.rst:1084
msgid "positional argument"
msgstr "positional argument (위치 인자)"

#: ../../glossary.rst:1087
msgid "provisional API"
msgstr "provisional API (잠정 API)"

#: ../../glossary.rst:1089
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major "
"changes to such interfaces are not expected, as long as they are marked "
"provisional, backwards incompatible changes (up to and including removal "
"of the interface) may occur if deemed necessary by core developers.  Such"
" changes will not be made gratuitously -- they will occur only if serious"
" fundamental flaws are uncovered that were missed prior to the inclusion "
"of the API."
msgstr ""
"잠정 API는 표준 라이브러리의 과거 호환성 보장으로부터 신중히 제외된 것입니다. 인터페이스의 큰 변화가 예상되지는 않지만, "
"잠정적이라고 표시되는 한, 코어 개발자들이 필요하다고 생각한다면 과거 호환성이 유지되지 않는 변경이 일어날 수 있습니다. 그런 "
"변경은 불필요한 방식으로 일어나지는 않을 것입니다 --- API를 포함하기 전에 놓친 중대하고 근본적인 결함이 발견된 경우에만 "
"일어날 것입니다."

#: ../../glossary.rst:1098
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"잠정 API에서조차도, 과거 호환성이 유지되지 않는 변경은 \"최후의 수단\"으로 여겨집니다 - 모든 식별된 문제들에 대해 과거 "
"호환성을 유지하는 해법을 찾으려는 모든 시도가 선행됩니다."

#: ../../glossary.rst:1102
msgid ""
"This process allows the standard library to continue to evolve over time,"
" without locking in problematic design errors for extended periods of "
"time.  See :pep:`411` for more details."
msgstr ""
"이 절차는 표준 라이브러리가 오랜 시간 동안 잘못된 설계 오류에 발목 잡히지 않고 발전할 수 있도록 만듭니다. 더 자세한 내용은 "
":pep:`411`\\을 보면 됩니다."

#: ../../glossary.rst:1105
msgid "provisional package"
msgstr "provisional package (잠정 패키지)"

#: ../../glossary.rst:1107
msgid "See :term:`provisional API`."
msgstr ":term:`잠정 API <provisional API>` 를 보세요."

#: ../../glossary.rst:1108
msgid "Python 3000"
msgstr "Python 3000 (파이썬 3000)"

#: ../../glossary.rst:1110
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the "
"release of version 3 was something in the distant future.)  This is also "
"abbreviated \"Py3k\"."
msgstr ""
"파이썬 3.x 배포 라인의 별명 (버전 3의 배포가 먼 미래의 이야기던 시절에 만들어진 이름이다.) 이것을 \"Py3k\" 로 줄여"
" 쓰기도 합니다."

#: ../../glossary.rst:1113
msgid "Pythonic"
msgstr "Pythonic (파이썬다운)"

#: ../../glossary.rst:1115
msgid ""
"An idea or piece of code which closely follows the most common idioms of "
"the Python language, rather than implementing code using concepts common "
"to other languages.  For example, a common idiom in Python is to loop "
"over all elements of an iterable using a :keyword:`for` statement.  Many "
"other languages don't have this type of construct, so people unfamiliar "
"with Python sometimes use a numerical counter instead::"
msgstr ""
"다른 언어들에서 일반적인 개념들을 사용해서 코드를 구현하는 대신, 파이썬 언어에서 가장 자주 사용되는 이디엄들을 가까이 따르는 "
"아이디어나 코드 조각. 예를 들어, 파이썬에서 자주 쓰는 이디엄은 :keyword:`for` 문을 사용해서 이터러블의 모든 요소로 "
"루핑하는 것입니다. 다른 많은 언어에는 이런 종류의 구성물이 없으므로, 파이썬에 익숙하지 않은 사람들은 대신에 숫자 카운터를 "
"사용하기도 합니다::"

#: ../../glossary.rst:1122
msgid ""
"for i in range(len(food)):\n"
"    print(food[i])"
msgstr ""

#: ../../glossary.rst:1125
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "더 깔끔한, 파이썬다운 방법은 이렇습니다::"

#: ../../glossary.rst:1127
msgid ""
"for piece in food:\n"
"    print(piece)"
msgstr ""

#: ../../glossary.rst:1129
msgid "qualified name"
msgstr "qualified name (정규화된 이름)"

#: ../../glossary.rst:1131
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a "
"class, function or method defined in that module, as defined in "
":pep:`3155`.  For top-level functions and classes, the qualified name is "
"the same as the object's name::"
msgstr ""
"모듈의 전역 스코프에서 모듈에 정의된 클래스, 함수, 메서드에 이르는 \"경로\"를 보여주는 점으로 구분된 이름. "
":pep:`3155` 에서 정의됩니다. 최상위 함수와 클래스의 경우에, 정규화된 이름은 객체의 이름과 같습니다::"

#: ../../glossary.rst:1136
msgid ""
">>> class C:\n"
"...     class D:\n"
"...         def meth(self):\n"
"...             pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__qualname__\n"
"'C.D'\n"
">>> C.D.meth.__qualname__\n"
"'C.D.meth'"
msgstr ""

#: ../../glossary.rst:1148
msgid ""
"When used to refer to modules, the *fully qualified name* means the "
"entire dotted path to the module, including any parent packages, e.g. "
"``email.mime.text``::"
msgstr ""
"모듈을 가리키는데 사용될 때, *완전히 정규화된 이름(fully qualified name)*\\은 모든 부모 패키지들을 포함해서 "
"모듈로 가는 점으로 분리된 이름을 의미합니다, 예를 들어, ``email.mime.text``::"

#: ../../glossary.rst:1152
msgid ""
">>> import email.mime.text\n"
">>> email.mime.text.__name__\n"
"'email.mime.text'"
msgstr ""

#: ../../glossary.rst:1155
msgid "reference count"
msgstr "reference count (참조 횟수)"

#: ../../glossary.rst:1157
#, fuzzy
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Some objects are "
":term:`immortal` and have reference counts that are never modified, and "
"therefore the objects are never deallocated.  Reference counting is "
"generally not visible to Python code, but it is a key element of the "
":term:`CPython` implementation.  Programmers can call the "
":func:`sys.getrefcount` function to return the reference count for a "
"particular object."
msgstr ""
"객체에 대한 참조의 개수. 객체의 참조 횟수가 0으로 떨어지면, 메모리가 반납됩니다. 참조 횟수 추적은 일반적으로 파이썬 코드에 "
"노출되지는 않지만, :term:`CPython` 구현의 핵심 요소입니다. :mod:`sys` 모듈은 특정 객체의 참조 횟수를 "
"돌려주는 :func:`~sys.getrefcount` 을 정의합니다."

#: ../../glossary.rst:1165
msgid "regular package"
msgstr "regular package (정규 패키지)"

#: ../../glossary.rst:1167
msgid ""
"A traditional :term:`package`, such as a directory containing an "
"``__init__.py`` file."
msgstr "``__init__.py`` 파일을 포함하는 디렉터리와 같은 전통적인 :term:`패키지 <package>`."

#: ../../glossary.rst:1170
msgid "See also :term:`namespace package`."
msgstr ":term:`이름 공간 패키지 <namespace package>` 도 보세요."

#: ../../glossary.rst:1171
msgid "REPL"
msgstr ""

#: ../../glossary.rst:1173
msgid ""
"An acronym for the \"read–eval–print loop\", another name for the "
":term:`interactive` interpreter shell."
msgstr ""

#: ../../glossary.rst:1175
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1177
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for"
" instance attributes and eliminating instance dictionaries.  Though "
"popular, the technique is somewhat tricky to get right and is best "
"reserved for rare cases where there are large numbers of instances in a "
"memory-critical application."
msgstr ""
"클래스 내부의 선언인데, 인스턴스 어트리뷰트들을 위한 공간을 미리 선언하고 인스턴스 딕셔너리를 제거함으로써 메모리를 절감하는 효과를"
" 줍니다. 인기 있기는 하지만, 이 테크닉은 올바르게 사용하기가 좀 까다로운 편이라서, 메모리에 민감한 응용 프로그램에서 많은 수의"
" 인스턴스가 있는 특별한 경우로 한정하는 것이 좋습니다."

#: ../../glossary.rst:1182
msgid "sequence"
msgstr "sequence (시퀀스)"

#: ../../glossary.rst:1184
#, fuzzy
msgid ""
"An :term:`iterable` which supports efficient element access using integer"
" indices via the :meth:`~object.__getitem__` special method and defines a"
" :meth:`~object.__len__` method that returns the length of the sequence. "
"Some built-in sequence types are :class:`list`, :class:`str`, "
":class:`tuple`, and :class:`bytes`. Note that :class:`dict` also supports"
" :meth:`~object.__getitem__` and :meth:`!__len__`, but is considered a "
"mapping rather than a sequence because the lookups use arbitrary "
":term:`hashable` keys rather than integers."
msgstr ""
":meth:`__getitem__` 특수 메서드를 통해 정수 인덱스를 사용한 빠른 요소 액세스를 지원하고, 시퀀스의 길이를 돌려주는"
" :meth:`__len__` 메서드를 정의하는 :term:`이터러블 <iterable>`. 몇몇 내장 시퀀스들을 나열해보면, "
":class:`list`, :class:`str`, :class:`tuple`, :class:`bytes` 가 있습니다. "
":class:`dict` 또한 :meth:`__getitem__` 과 :meth:`__len__` 을 지원하지만, 조회에 정수 대신"
" 임의의 :term:`불변 <immutable>` 키를 사용하기 때문에 시퀀스가 아니라 매핑으로 취급된다는 것에 주의해야 합니다."

#: ../../glossary.rst:1193
#, fuzzy
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`~object.__getitem__` and "
":meth:`~object.__len__`, adding :meth:`!count`, :meth:`!index`, "
":meth:`~object.__contains__`, and :meth:`~object.__reversed__`. Types "
"that implement this expanded interface can be registered explicitly using"
" :func:`~abc.ABCMeta.register`. For more documentation on sequence "
"methods generally, see :ref:`Common Sequence Operations <typesseq-"
"common>`."
msgstr ""
":class:`collections.abc.Sequence` 추상 베이스 클래스는 :meth:`__getitem__` 과 "
":meth:`__len__`\\을 넘어서 훨씬 풍부한 인터페이스를 정의하는데, :meth:`count`, :meth:`index`,"
" :meth:`__contains__`, :meth:`__reversed__`\\를 추가합니다. 이 확장된 인터페이스를 구현한 형을"
" :func:`~abc.ABCMeta.register`\\를 사용해서 명시적으로 등록할 수 있습니다."

#: ../../glossary.rst:1202
msgid "set comprehension"
msgstr "set comprehension (집합 컴프리헨션)"

#: ../../glossary.rst:1204
#, python-brace-format
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c"
" not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See "
":ref:`comprehensions`."
msgstr ""
"이터러블에 있는 요소 전체나 일부를 처리하고 결과를 담은 집합을 반환하는 간결한 방법. ``results = {c for c in "
"'abracadabra' if c not in 'abc'}``\\는 문자열의 집합 ``{'r', 'd'}``\\를 생성합니다. "
":ref:`comprehensions`\\을 참조하십시오."

#: ../../glossary.rst:1208
msgid "single dispatch"
msgstr "single dispatch (싱글 디스패치)"

#: ../../glossary.rst:1210
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr "구현이 하나의 인자의 형에 기초해서 결정되는 :term:`제네릭 함수 <generic function>` 디스패치의 한 형태."

#: ../../glossary.rst:1212
msgid "slice"
msgstr "slice (슬라이스)"

#: ../../glossary.rst:1214
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is"
" created using the subscript notation, ``[]`` with colons between numbers"
" when several are given, such as in ``variable_name[1:3:5]``.  The "
"bracket (subscript) notation uses :class:`slice` objects internally."
msgstr ""
"보통 :term:`시퀀스 <sequence>` 의 일부를 포함하는 객체. 슬라이스는 서브 스크립트 표기법을 사용해서 만듭니다. "
"``variable_name[1:3:5]`` 처럼, ``[]`` 안에서 여러 개의 숫자를 콜론으로 분리합니다. 대괄호 (서브 "
"스크립트) 표기법은 내부적으로 :class:`slice` 객체를 사용합니다."

#: ../../glossary.rst:1218
#, fuzzy
msgid "soft deprecated"
msgstr "interpreted (인터프리티드)"

#: ../../glossary.rst:1220
msgid ""
"A soft deprecated API should not be used in new code, but it is safe for "
"already existing code to use it. The API remains documented and tested, "
"but will not be enhanced further."
msgstr ""

#: ../../glossary.rst:1224
msgid ""
"Soft deprecation, unlike normal deprecation, does not plan on removing "
"the API and will not emit warnings."
msgstr ""

#: ../../glossary.rst:1227
msgid ""
"See `PEP 387: Soft Deprecation <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_."
msgstr ""

#: ../../glossary.rst:1229
msgid "special method"
msgstr "special method (특수 메서드)"

#: ../../glossary.rst:1233
msgid ""
"A method that is called implicitly by Python to execute a certain "
"operation on a type, such as addition.  Such methods have names starting "
"and ending with double underscores.  Special methods are documented in "
":ref:`specialnames`."
msgstr ""
"파이썬이 형에 어떤 연산을, 덧셈 같은, 실행할 때 묵시적으로 호출되는 메서드. 이런 메서드는 두 개의 밑줄로 시작하고 끝나는 "
"이름을 갖고 있습니다. 특수 메서드는 :ref:`specialnames` 에 문서로 만들어져 있습니다."

#: ../../glossary.rst:1237
msgid "statement"
msgstr "statement (문장)"

#: ../../glossary.rst:1239
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is "
"either an :term:`expression` or one of several constructs with a keyword,"
" such as :keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"문장은 스위트 (코드의 \"블록(block)\") 를 구성하는 부분입니다. 문장은 :term:`표현식 <expression>` "
"이거나 키워드를 사용하는 여러 가지 구조물 중의 하나입니다. 가령 :keyword:`if`, :keyword:`while`, "
":keyword:`for`."

#: ../../glossary.rst:1242
msgid "static type checker"
msgstr ""

#: ../../glossary.rst:1244
msgid ""
"An external tool that reads Python code and analyzes it, looking for "
"issues such as incorrect types. See also :term:`type hints <type hint>` "
"and the :mod:`typing` module."
msgstr ""

#: ../../glossary.rst:1247
msgid "strong reference"
msgstr ""

#: ../../glossary.rst:1249
msgid ""
"In Python's C API, a strong reference is a reference to an object which "
"is owned by the code holding the reference.  The strong reference is "
"taken by calling :c:func:`Py_INCREF` when the reference is created and "
"released with :c:func:`Py_DECREF` when the reference is deleted."
msgstr ""

#: ../../glossary.rst:1255
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference"
" to an object. Usually, the :c:func:`Py_DECREF` function must be called "
"on the strong reference before exiting the scope of the strong reference,"
" to avoid leaking one reference."
msgstr ""

#: ../../glossary.rst:1260
#, fuzzy
msgid "See also :term:`borrowed reference`."
msgstr ":term:`모듈 <module>` 도 보세요."

#: ../../glossary.rst:1261
msgid "text encoding"
msgstr "text encoding (텍스트 인코딩)"

#: ../../glossary.rst:1263
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""

#: ../../glossary.rst:1267
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", "
"and recreating the string from the sequence of bytes is known as "
"\"decoding\"."
msgstr ""

#: ../../glossary.rst:1270
msgid ""
"There are a variety of different text serialization :ref:`codecs "
"<standard-encodings>`, which are collectively referred to as \"text "
"encodings\"."
msgstr ""

#: ../../glossary.rst:1273
msgid "text file"
msgstr "text file (텍스트 파일)"

#: ../../glossary.rst:1275
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often,"
" a text file actually accesses a byte-oriented datastream and handles the"
" :term:`text encoding` automatically. Examples of text files are files "
"opened in text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, "
":data:`sys.stdout`, and instances of :class:`io.StringIO`."
msgstr ""
":class:`str` 객체를 읽고 쓸 수 있는 :term:`파일 객체 <file object>`. 종종, 텍스트 파일은 실제로는 "
"바이트 지향 데이터스트림을 액세스하고 :term:`텍스트 인코딩 <text encoding>` 을 자동 처리합니다. 텍스트 파일의 "
"예로는 텍스트 모드 (``'r'`` 또는 ``'w'``) 로 열린 파일, :data:`sys.stdin`, "
":data:`sys.stdout`, :class:`io.StringIO` 의 인스턴스를 들 수 있습니다."

#: ../../glossary.rst:1282
msgid ""
"See also :term:`binary file` for a file object able to read and write "
":term:`bytes-like objects <bytes-like object>`."
msgstr ""
":term:`바이트열류 객체 <bytes-like object>` 를 읽고 쓸 수 있는 파일 객체에 대해서는 :term:`바이너리 "
"파일 <binary file>` 도 참조하세요."

#: ../../glossary.rst:1284
msgid "token"
msgstr ""

#: ../../glossary.rst:1287
msgid ""
"A small unit of source code, generated by the :ref:`lexical analyzer "
"<lexical>` (also called the *tokenizer*). Names, numbers, strings, "
"operators, newlines and similar are represented by tokens."
msgstr ""

#: ../../glossary.rst:1292
msgid ""
"The :mod:`tokenize` module exposes Python's lexical analyzer. The "
":mod:`token` module contains information on the various types of tokens."
msgstr ""

#: ../../glossary.rst:1295
msgid "triple-quoted string"
msgstr "triple-quoted string (삼중 따옴표 된 문자열)"

#: ../../glossary.rst:1297
msgid ""
"A string which is bound by three instances of either a quotation mark "
"(\") or an apostrophe (').  While they don't provide any functionality "
"not available with single-quoted strings, they are useful for a number of"
" reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"따옴표 (\") 나 작은따옴표 (') 세 개로 둘러싸인 문자열. 그냥 따옴표 하나로 둘러싸인 문자열에 없는 기능을 제공하지는 "
"않지만, 여러 가지 이유에서 쓸모가 있습니다. 이스케이프 되지 않은 작은따옴표나 큰따옴표를 문자열 안에 포함할 수 있도록 하고, "
"연결 문자를 쓰지 않고도 여러 줄에 걸칠 수 있는데, 독스트링을 쓸 때 특히 쓸모 있습니다."

#: ../../glossary.rst:1304
msgid "type"
msgstr "type (형)"

#: ../../glossary.rst:1306
#, fuzzy
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its "
":attr:`~object.__class__` attribute or can be retrieved with "
"``type(obj)``."
msgstr ""
"파이썬 객체의 형은 그것이 어떤 종류의 객체인지를 결정합니다; 모든 객체는 형이 있습니다. 객체의 형은 "
":attr:`~instance.__class__` 어트리뷰트로 액세스할 수 있거나 ``type(obj)``\\로 얻을 수 있습니다."

#: ../../glossary.rst:1310
msgid "type alias"
msgstr "type alias (형 에일리어스)"

#: ../../glossary.rst:1312
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "형을 식별자에 대입하여 만들어지는 형의 동의어."

#: ../../glossary.rst:1314
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. "
"For example::"
msgstr "형 에일리어스는 :term:`형 힌트 <type hint>`\\를 단순화하는 데 유용합니다. 예를 들면::"

#: ../../glossary.rst:1317
msgid ""
"def remove_gray_shades(\n"
"        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, "
"int]]:\n"
"    pass"
msgstr ""

#: ../../glossary.rst:1321
msgid "could be made more readable like this::"
msgstr "는 다음과 같이 더 읽기 쉽게 만들 수 있습니다::"

#: ../../glossary.rst:1323
msgid ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"
msgstr ""

#: ../../glossary.rst:1328 ../../glossary.rst:1342
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "이 기능을 설명하는 :mod:`typing`\\과 :pep:`484`\\를 참조하세요."

#: ../../glossary.rst:1329
msgid "type hint"
msgstr "type hint (형 힌트)"

#: ../../glossary.rst:1331
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr "변수, 클래스 어트리뷰트 및 함수 매개변수 나 반환 값의 기대되는 형을 지정하는 :term:`어노테이션 <annotation>`."

#: ../../glossary.rst:1334
#, fuzzy
msgid ""
"Type hints are optional and are not enforced by Python but they are "
"useful to :term:`static type checkers <static type checker>`. They can "
"also aid IDEs with code completion and refactoring."
msgstr ""
"형 힌트는 선택 사항이며 파이썬에서 강제되지는 않습니다. 하지만, 정적 형 분석 도구에 유용하며 IDE의 코드 완성 및 리팩토링을 "
"돕습니다."

#: ../../glossary.rst:1338
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"지역 변수를 제외하고, 전역 변수, 클래스 어트리뷰트 및 함수의 형 힌트는 "
":func:`typing.get_type_hints`\\를 사용하여 액세스할 수 있습니다."

#: ../../glossary.rst:1343
msgid "universal newlines"
msgstr "universal newlines (유니버설 줄 넘김)"

#: ../../glossary.rst:1345
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, "
"the Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as "
":func:`bytes.splitlines` for an additional use."
msgstr ""
"다음과 같은 것들을 모두 줄의 끝으로 인식하는, 텍스트 스트림을 해석하는 태도: 유닉스 개행 문자 관례 ``'\\n'``, 윈도우즈"
" 관례 ``'\\r\\n'``, 예전의 매킨토시 관례 ``'\\r'``. 추가적인 사용에 관해서는 "
":func:`bytes.splitlines` 뿐만 아니라 :pep:`278` 와 :pep:`3116` 도 보세요."

#: ../../glossary.rst:1350
msgid "variable annotation"
msgstr "variable annotation (변수 어노테이션)"

#: ../../glossary.rst:1352
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr "변수 또는 클래스 어트리뷰트의 :term:`어노테이션 <annotation>`."

#: ../../glossary.rst:1354
msgid "When annotating a variable or a class attribute, assignment is optional::"
msgstr "변수 또는 클래스 어트리뷰트에 어노테이션을 달 때 대입은 선택 사항입니다::"

#: ../../glossary.rst:1356
msgid ""
"class C:\n"
"    field: 'annotation'"
msgstr ""

#: ../../glossary.rst:1359
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`:"
" for example this variable is expected to take :class:`int` values::"
msgstr ""
"변수 어노테이션은 일반적으로 :term:`형 힌트 <type hint>`\\로 사용됩니다: 예를 들어, 이 변수는 "
":class:`int` 값을 가질 것으로 기대됩니다::"

#: ../../glossary.rst:1363
msgid "count: int = 0"
msgstr ""

#: ../../glossary.rst:1365
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr "변수 어노테이션 문법은 섹션 :ref:`annassign` 에서 설명합니다."

#: ../../glossary.rst:1367
#, fuzzy
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which "
"describe this functionality. Also see :ref:`annotations-howto` for best "
"practices on working with annotations."
msgstr ""
"이 기능을 설명하는 :term:`함수 어노테이션 <function annotation>`, :pep:`484` 및 "
":pep:`526`\\을 참조하세요."

#: ../../glossary.rst:1371
msgid "virtual environment"
msgstr "virtual environment (가상 환경)"

#: ../../glossary.rst:1373
msgid ""
"A cooperatively isolated runtime environment that allows Python users and"
" applications to install and upgrade Python distribution packages without"
" interfering with the behaviour of other Python applications running on "
"the same system."
msgstr ""
"파이썬 사용자와 응용 프로그램이, 같은 시스템에서 실행되는 다른 파이썬 응용 프로그램들의 동작에 영향을 주지 않으면서, 파이썬 배포"
" 패키지들을 설치하거나 업그레이드하는 것을 가능하게 하는, 협력적으로 격리된 실행 환경."

#: ../../glossary.rst:1378
msgid "See also :mod:`venv`."
msgstr ":mod:`venv` 도 보세요."

#: ../../glossary.rst:1379
msgid "virtual machine"
msgstr "virtual machine (가상 기계)"

#: ../../glossary.rst:1381
msgid ""
"A computer defined entirely in software.  Python's virtual machine "
"executes the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"소프트웨어만으로 정의된 컴퓨터. 파이썬의 가상 기계는 바이트 코드 컴파일러가 출력하는 :term:`바이트 코드 "
"<bytecode>`\\를 실행합니다."

#: ../../glossary.rst:1383
msgid "Zen of Python"
msgstr "Zen of Python (파이썬 젠)"

#: ../../glossary.rst:1385
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing"
" \"``import this``\" at the interactive prompt."
msgstr ""
"파이썬 디자인 원리와 철학들의 목록인데, 언어를 이해하고 사용하는 데 도움이 됩니다. 이 목록은 대화형 프롬프트에서 "
"\"``import this``\" 를 입력하면 보입니다."

#: ../../glossary.rst:292
#, fuzzy
msgid "C-contiguous"
msgstr "contiguous (연속)"

#: ../../glossary.rst:292
#, fuzzy
msgid "Fortran contiguous"
msgstr "contiguous (연속)"

#: ../../glossary.rst:831
msgid "magic"
msgstr ""

#: ../../glossary.rst:1231
#, fuzzy
msgid "special"
msgstr "special method (특수 메서드)"

#~ msgid "2to3"
#~ msgstr "2to3"

#~ msgid ""
#~ "A tool that tries to convert "
#~ "Python 2.x code to Python 3.x code"
#~ " by handling most of the "
#~ "incompatibilities which can be detected "
#~ "by parsing the source and traversing "
#~ "the parse tree."
#~ msgstr ""
#~ "파이썬 2.x 코드를 파이썬 3.x 코드로 변환하려고 "
#~ "시도하는 도구인데, 소스를 구문 분석하고 구문 분석 "
#~ "트리를 탐색해서 감지할 수 있는 대부분의 비호환성을 "
#~ "다룹니다."

#~ msgid ""
#~ "2to3 is available in the standard "
#~ "library as :mod:`lib2to3`; a standalone "
#~ "entry point is provided as "
#~ ":file:`Tools/scripts/2to3`.  See :ref:`2to3-reference`."
#~ msgstr ""
#~ "2to3 는 표준 라이브러리에서 :mod:`lib2to3` 로 "
#~ "제공됩니다; 독립적으로 실행할 수 있는 스크립트는 "
#~ ":file:`Tools/scripts/2to3` 로 제공됩니다. "
#~ ":ref:`2to3-reference`\\을 보세요."

#~ msgid "coercion"
#~ msgstr "coercion (코어션)"

#~ msgid ""
#~ "The implicit conversion of an instance"
#~ " of one type to another during "
#~ "an operation which involves two "
#~ "arguments of the same type.  For "
#~ "example, ``int(3.15)`` converts the floating"
#~ " point number to the integer ``3``,"
#~ " but in ``3+4.5``, each argument is"
#~ " of a different type (one int, "
#~ "one float), and both must be "
#~ "converted to the same type before "
#~ "they can be added or it will "
#~ "raise a :exc:`TypeError`.  Without coercion,"
#~ " all arguments of even compatible "
#~ "types would have to be normalized "
#~ "to the same value by the "
#~ "programmer, e.g., ``float(3)+4.5`` rather than"
#~ " just ``3+4.5``."
#~ msgstr ""
#~ "같은 형의 두 인자를 수반하는 연산이 일어나는 "
#~ "동안, 한 형의 인스턴스를 다른 형으로 묵시적으로 "
#~ "변환하는 것. 예를 들어, ``int(3.15)``\\는 실수를 "
#~ "정수 ``3``\\으로 변환합니다. 하지만, ``3+4.5`` 에서,"
#~ " 각 인자는 다른 형이고 (하나는 int, 다른 "
#~ "하나는 float), 둘을 더하기 전에 같은 형으로 "
#~ "변환해야 합니다. 그렇지 않으면 :exc:`TypeError`\\를 "
#~ "일으킵니다. 코어션 없이는, 호환되는 형들조차도 프로그래머가 "
#~ "같은 형으로 정규화해주어야 합니다, 예를 들어, 그냥 "
#~ "``3+4.5`` 하는 대신 ``float(3)+4.5``."

#~ msgid ""
#~ "A variable which can have different "
#~ "values depending on its context. This"
#~ " is similar to Thread-Local Storage"
#~ " in which each execution thread may"
#~ " have a different value for a "
#~ "variable. However, with context variables, "
#~ "there may be several contexts in "
#~ "one execution thread and the main "
#~ "usage for context variables is to "
#~ "keep track of variables in concurrent"
#~ " asynchronous tasks. See :mod:`contextvars`."
#~ msgstr ""
#~ "컨텍스트에 따라 다른 값을 가질 수 있는 변수."
#~ " 이는 각 실행 스레드가 변수에 대해 다른 "
#~ "값을 가질 수 있는 스레드-로컬 저장소와 비슷합니다. "
#~ "그러나, 컨텍스트 변수를 통해, 하나의 실행 스레드에 "
#~ "여러 컨텍스트가 있을 수 있으며 컨텍스트 변수의 주"
#~ " 용도는 동시성 비동기 태스크에서 변수를 추적하는 "
#~ "것입니다. :mod:`contextvars`\\를 참조하십시오."

#~ msgid ""
#~ "A pseudo-module which programmers can"
#~ " use to enable new language features"
#~ " which are not compatible with the"
#~ " current interpreter."
#~ msgstr "프로그래머가 현재 인터프리터와 호환되지 않는 새 언어 기능들을 활성화할 수 있도록 하는 가상 모듈."

#~ msgid ""
#~ "By importing the :mod:`__future__` module "
#~ "and evaluating its variables, you can"
#~ " see when a new feature was "
#~ "first added to the language and "
#~ "when it becomes the default::"
#~ msgstr ""
#~ ":mod:`__future__` 모듈을 임포트하고 그 변수들의 값들을"
#~ " 구해서, 새 기능이 언제 처음으로 언어에 추가되었고,"
#~ " 언제부터 그것이 기본이 되는지 볼 수 있습니다::"

#~ msgid ""
#~ "See :pep:`483` for more details, and "
#~ ":mod:`typing` or :ref:`generic alias type "
#~ "<types-genericalias>` for its uses."
#~ msgstr ""
#~ "자세한 내용은 :pep:`483`\\를 참조하고, 용도에 대해서는 "
#~ ":mod:`typing`\\이나 :ref:`제네릭 에일리어스 형 <types-"
#~ "genericalias>`\\을 참조하십시오."

#~ msgid ""
#~ "Past efforts to create a \"free-"
#~ "threaded\" interpreter (one which locks "
#~ "shared data at a much finer "
#~ "granularity) have not been successful "
#~ "because performance suffered in the "
#~ "common single-processor case. It is "
#~ "believed that overcoming this performance "
#~ "issue would make the implementation much"
#~ " more complicated and therefore costlier"
#~ " to maintain."
#~ msgstr ""
#~ "(훨씬 더 미세하게 공유 데이터를 잠그는) \"스레드에 "
#~ "자유로운(free-threaded)\" 인터프리터를 만들고자 하는 과거의"
#~ " 노력은 성공적이지 못했는데, 흔한 단일 프로세서 경우의"
#~ " 성능 저하가 심하기 때문입니다. 이 성능 이슈를 "
#~ "극복하는 것은 구현을 훨씬 복잡하게 만들어서 유지 "
#~ "비용이 더 들어갈 것으로 여겨지고 있습니다."

#~ msgid ""
#~ "An object that loads a module. It"
#~ " must define a method named "
#~ ":meth:`load_module`. A loader is typically "
#~ "returned by a :term:`finder`. See "
#~ ":pep:`302` for details and "
#~ ":class:`importlib.abc.Loader` for an :term:`abstract"
#~ " base class`."
#~ msgstr ""
#~ "모듈을 로드하는 객체. :meth:`load_module` 이라는 이름의"
#~ " 메서드를 정의해야 합니다. 로더는 보통 :term:`파인더 "
#~ "<finder>` 가 돌려줍니다. 자세한 내용은 :pep:`302`"
#~ " 를, :term:`추상 베이스 클래스 <abstract base"
#~ " class>` 는 :class:`importlib.abc.Loader` 를 "
#~ "보세요."

#~ msgid "A codec which encodes Unicode strings to bytes."
#~ msgstr "유니코드 문자열을 바이트열로 인코딩하는 코덱."

