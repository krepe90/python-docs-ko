# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "복합문(Compound statements)"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general,"
" compound statements span multiple lines, although in simple incarnations"
" a whole compound statement may be contained in one line."
msgstr ""
"복합문은 다른 문장들(의 그룹들)을 포함합니다; 어떤 방법으로 그 다른 문장들의 실행에 영향을 주거나 제어합니다. 간단하게 표현할 "
"때, 전체 복합문을 한 줄로 쓸 수 있기는 하지만, 일반적으로 복합문은 여러 줄에 걸칩니다."

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements "
"implement traditional control flow constructs.  :keyword:`try` specifies "
"exception handlers and/or cleanup code for a group of statements, while "
"the :keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions"
" are also syntactically compound statements."
msgstr ""
":keyword:`if`, :keyword:`while`, :keyword:`for` 문장은 전통적인 제어 흐름 구조를 구현합니다."
" 문장들의 그룹에 대해 :keyword:`try` 는 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 반면, "
":keyword:`with` 문은 코드 블록 주변으로 초기화와 파이널리제이션 코드를 실행할 수 있도록 합니다. 함수와 클래스 정의 "
"또한 문법적으로 복합문입니다."

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause "
"consists of a header and a 'suite.'  The clause headers of a particular "
"compound statement are all at the same indentation level. Each clause "
"header begins with a uniquely identifying keyword and ends with a colon."
"  A suite is a group of statements controlled by a clause.  A suite can "
"be one or more semicolon-separated simple statements on the same line as "
"the header, following the header's colon, or it can be one or more "
"indented statements on subsequent lines.  Only the latter form of a suite"
" can contain nested compound statements; the following is illegal, mostly"
" because it wouldn't be clear to which :keyword:`if` clause a following "
":keyword:`else` clause would belong::"
msgstr ""
"복합문은 하나나 그 이상의 '절'로 구성됩니다. 절은 헤더와 '스위트(suite)'로 구성됩니다. 특정 복합문의 절 헤더들은 모두 "
"같은 들여쓰기 수준을 갖습니다. 각 절 헤더는 특별하게 식별되는 키워드로 시작하고 콜론으로 끝납니다. 스위트는 절에 의해 제어되는 "
"문장들의 그룹입니다. 스위트는 헤더의 콜론 뒤에서 같은 줄에 세미콜론으로 분리된 하나나 그 이상의 단순문일 수 있습니다. 또는 "
"그다음 줄에 들여쓰기 된 하나나 그 이상의 문장들일 수도 있습니다. 오직 후자의 형태만 중첩된 복합문을 포함할 수 있습니다; 다음과"
" 같은 것은 올바르지 않은데, 대체로 뒤따르는 :keyword:`else` 절이 있다면 어떤 :keyword:`if` 절에 속하는지"
" 명확하지 않기 때문입니다."

#: ../../reference/compound_stmts.rst:37
msgid "if test1: if test2: print(x)"
msgstr ""

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this "
"context, so that in the following example, either all or none of the "
":func:`print` calls are executed::"
msgstr ""
"또한, 이 문맥에서 세미콜론이 콜론보다 더 강하게 결합해서, 다음과 같은 예에서, :func:`print` 호출들은 모두 실행되거나"
" 어느 하나도 실행되지 않습니다는 것에 주의해야 합니다::"

#: ../../reference/compound_stmts.rst:43
msgid "if x < y < z: print(x); print(y); print(z)"
msgstr ""

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "요약하면:"

#: ../../reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin "
"with a keyword that cannot start a statement, thus there are no "
"ambiguities (the 'dangling :keyword:`else`' problem is solved in Python "
"by requiring nested :keyword:`if` statements to be indented)."
msgstr ""
"문장들이 항상 ``NEWLINE`` 으로 끝나고 ``DEDENT`` 가 그 뒤를 따를 수 있음에 주목해야 합니다. 또한, 생략 "
"가능한 연결 절들이 항상 문장을 시작시킬 수 없는 키워드로 시작하기 때문에, 모호함이 없다는 것도 주목하세요 (파이썬에서는 중첩된 "
":keyword:`if` 문이 들여쓰기 되는 것을 요구함으로써 '매달린(dangling) :keyword:`else`' 문제를 "
"해결합니다)."

#: ../../reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each"
" clause on a separate line for clarity."
msgstr "명확함을 위해 다음에 오는 절들에서 나오는 문법 규칙들은 각 절을 별도의 줄에 놓도록 포매팅합니다."

#: ../../reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr ":keyword:`!if` 문"

#: ../../reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 문은 조건부 실행에 사용됩니다:"

#: ../../reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by"
" one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if "
"present, is executed."
msgstr ""
"참이 되는 것을 발견할 때까지 표현식들의 값을 하나씩 차례대로 구해서 정확히 하나의 스위트를 선택합니다 (참과 거짓의 정의는 "
":ref:`booleans` 섹션을 보세요); 그런 다음 그 스위트를 실행합니다 (그리고는 :keyword:`if` 문의 다른 어떤"
" 부분도 실행되거나 값이 구해지지 않습니다). 모든 표현식들이 거짓이면 :keyword:`else` 절의 스위트가 (있다면) "
"실행됩니다."

#: ../../reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr ":keyword:`!while` 문"

#: ../../reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as "
"an expression is true:"
msgstr ":keyword:`while` 문은 표현식이 참인 동안 실행을 반복하는 데 사용됩니다:"

#: ../../reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the "
"first suite; if the expression is false (which may be the first time it "
"is tested) the suite of the :keyword:`!else` clause, if present, is "
"executed and the loop terminates."
msgstr ""
"이것은 표현식을 반복적으로 검사하고, 참이면, 첫 번째 스위트를 실행합니다; 표현식이 거짓이면 (처음부터 거짓일 수도 있습니다) "
":keyword:`!else` 절의 스위트가 (있다면) 실행되고 루프를 종료합니다."

#: ../../reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the "
"loop without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and goes back to testing the expression."
msgstr ""
"첫 번째 스위트에서 실행되는 :keyword:`break` 문은 :keyword:`!else` 절을 실행하지 않고 루프를 "
"종료합니다. 첫 번째 스위트에서 실행되는 :keyword:`continue` 문은 스위트의 나머지 부분을 건너뛰고 표현식의 검사로 "
"돌아갑니다."

#: ../../reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for` 문"

#: ../../reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ":keyword:`for` 문은 (문자열, 튜플, 리스트 같은) 시퀀스 나 다른 이터러블 객체의 요소들을 이터레이트하는데 사용됩니다:"

#: ../../reference/compound_stmts.rst:160
#, fuzzy
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an "
":term:`iterable` object.  An :term:`iterator` is created for that "
"iterable. The first item provided by the iterator is then assigned to the"
" target list using the standard rules for assignments (see "
":ref:`assignment`), and the suite is executed.  This repeats for each "
"item provided by the iterator.  When the iterator is exhausted, the suite"
" in the :keyword:`!else` clause, if present, is executed, and the loop "
"terminates."
msgstr ""
"표현식 목록은 한 번만 값이 구해집니다; 이터러블 객체가 나와야 합니다. ``expression_list`` 의 결과로 이터레이터가"
" 만들어집니다. 그런 다음 이터레이터가 제공하는 항목마다, 이터레이터가 돌려주는 순서대로, 스위트가 한 번씩 실행됩니다. 순환마다 "
"각 항목이 대입의 표준 규칙 (:ref:`assignment` 을 보세요) 으로 타깃 목록에 대입된 다음, 스위트가 실행됩니다. "
"항목들이 소진되었을 때 (이터레이터가 :exc:`StopIteration` 예외를 일으킬 때나 빈 시퀀스인 경우는 즉시 "
"발생합니다), the :keyword:`!else` 절의 스위트가 (있다면) 실행되고 루프를 종료합니다."

#: ../../reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the "
"loop without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and continues with the next item, or with the "
":keyword:`!else` clause if there is no next item."
msgstr ""
"첫 번째 스위트에서 실행되는 :keyword:`break` 문은 :keyword:`!else` 절을 실행하지 않고 루프를 "
"종료합니다. 첫 번째 스위트에서 실행되는 :keyword:`continue` 문은 스위트의 나머지 부분을 건너뛰고 다음 항목으로 "
"넘어가거나, 다음 항목이 없으면 :keyword:`!else` 절로 갑니다."

#: ../../reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those "
"made in the suite of the for-loop::"
msgstr ""
"for-루프는 타깃 목록의 변수들에 대입합니다. for-루프의 스위트에서 이루어진 것들도 포함해서, 그 변수에 앞서 대입된 값들을 "
"모두 덮어씁니다::"

#: ../../reference/compound_stmts.rst:183
msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""

#: ../../reference/compound_stmts.rst:193
#, fuzzy
msgid ""
"Names in the target list are not deleted when the loop is finished, but "
"if the sequence is empty, they will not have been assigned to at all by "
"the loop.  Hint: the built-in type :func:`range` represents immutable "
"arithmetic sequences of integers. For instance, iterating ``range(3)`` "
"successively yields 0, 1, and then 2."
msgstr ""
"타깃 목록의 이름들은 루프가 종료될 때 삭제되지 않지만, 시퀀스가 비어있다면, 루프에 의해 전혀 대입이 일어나지 않을 수도 "
"있습니다. 힌트: 내장 함수 :func:`range` 는 파스칼의 ``for i := a to b do`` 의 효과를 흉내 내는데 "
"적합한 정수의 이터레이터를 돌려줍니다; 예를 들어, ``list(range(3))`` 는 리스트 ``[0, 1, 2]`` 를 "
"돌려줍니다."

#: ../../reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr ""

#: ../../reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try` 문"

#: ../../reference/compound_stmts.rst:215
#, fuzzy
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup"
" code for a group of statements:"
msgstr ""
":keyword:`try` 문은 문장 그룹에 대한 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 데 "
"사용됩니다."

#: ../../reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information on using the :keyword:`raise` "
"statement to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"예외에 관한 추가의 정보는 :ref:`exceptions` 섹션에서 찾을 수 있고, 예외를 일으키기 위해 "
":keyword:`raise` 문을 사용하는 것에 관한 정보는 :ref:`raise` 섹션에서 찾을 수 있습니다."

#: ../../reference/compound_stmts.rst:239
msgid ":keyword:`!except` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:241
#, fuzzy
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception "
"handler is executed. When an exception occurs in the :keyword:`!try` "
"suite, a search for an exception handler is started. This search inspects"
" the :keyword:`!except` clauses in turn until one is found that matches "
"the exception. An expression-less :keyword:`!except` clause, if present, "
"must be last; it matches any exception."
msgstr ""
":keyword:`except` 절(들)은 하나나 그 이상의 예외 처리기를 지정합니다. :keyword:`try` 절에서 예외가 "
"발생하지 않으면 아무런 예외 처리기도 실행되지 않습니다. :keyword:`!try` 스위트에서 예외가 발생할 때, 예외 처리기 "
"검색이 시작됩니다. 이 검색은 그 예외에 매치되는 것을 발견할 때까지 except 절을 차례대로 들여다봅니다. 표현식이 없는 "
"except 절이 있다면 가장 마지막에 와야 합니다; 모든 예외와 매치됩니다. 표현식이 있는 except 절의 경우, 표현식의 값을"
" 구하고, 결과 객체가 예외와 \"호환\" 되면 그 절이 예외에 매치됩니다. 객체는 예외 객체의 클래스나 베이스 클래스일 때, 또는"
" 예외 객체의 클래스나 베이스 클래스인 항목을 포함한 튜플일 때 예외와 호환됩니다."

#: ../../reference/compound_stmts.rst:249
msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. The raised "
"exception matches an :keyword:`!except` clause whose expression evaluates"
" to the class or a :term:`non-virtual base class <abstract base class>` "
"of the exception object, or to a tuple that contains such a class."
msgstr ""

#: ../../reference/compound_stmts.rst:255
#, fuzzy
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation"
" stack.  [#]_"
msgstr "except 절 중 어느 것도 예외와 매치되지 않으면, 예외 처리기 검색은 둘러싼 코드와 호출 스택에서 계속됩니다. [#]_"

#: ../../reference/compound_stmts.rst:259
#, fuzzy
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except`"
" clause raises an exception, the original search for a handler is "
"canceled and a search starts for the new exception in the surrounding "
"code and on the call stack (it is treated as if the entire :keyword:`try`"
" statement raised the exception)."
msgstr ""
"만약 except 절의 헤더에 있는 표현식의 값을 구할 때 예외가 발생하면, 원래의 처리기 검색은 취소되고 둘러싼 코드와 호출 "
"스택에서 새 예외에 대해 검사가 시작됩니다 (:keyword:`try` 문 전체가 예외를 일으킨 것으로 취급됩니다)."

#: ../../reference/compound_stmts.rst:267
#, fuzzy
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that"
" :keyword:`!except` clause, if present, and the :keyword:`!except` "
"clause's suite is executed. All :keyword:`!except` clauses must have an "
"executable block. When the end of this block is reached, execution "
"continues normally after the entire :keyword:`try` statement. (This means"
" that if two nested handlers exist for the same exception, and the "
"exception occurs in the :keyword:`!try` clause of the inner handler, the "
"outer handler will not handle the exception.)"
msgstr ""
"매치되는 except 절이 발견되면, 예외는 그 except 절에 있는 :keyword:`!as` 키워드 (가 있다면) 뒤에 지정된"
" 타깃에 대입되고, except 절의 스위트가 실행됩니다. 모든 except 절은 실행 가능한 블록을 가져야 합니다. 블록의 끝에 "
"도달하면, try 문 전체의 뒤에서 일반적인 실행이 계속됩니다. (이것은 같은 예외에 대해 두 개의 중첩된 처리기가 있고, 예외가 "
"안쪽 처리기의 try 절에서 발생했다면, 바깥 처리기는 예외를 처리하지 않게 된다는 뜻이 됩니다.)"

#: ../../reference/compound_stmts.rst:278
#, fuzzy
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at"
" the end of the :keyword:`!except` clause.  This is as if ::"
msgstr "예외가 ``as target`` 을 사용해서 대입될 때, except 절 끝에서 삭제됩니다. 이것은 마치 ::"

#: ../../reference/compound_stmts.rst:281
msgid ""
"except E as N:\n"
"    foo"
msgstr ""

#: ../../reference/compound_stmts.rst:284
msgid "was translated to ::"
msgstr "가 이렇게 변환되는 것과 같습니다 ::"

#: ../../reference/compound_stmts.rst:286
msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""

#: ../../reference/compound_stmts.rst:292
#, fuzzy
msgid ""
"This means the exception must be assigned to a different name to be able "
"to refer to it after the :keyword:`!except` clause. Exceptions are "
"cleared because with the traceback attached to them, they form a "
"reference cycle with the stack frame, keeping all locals in that frame "
"alive until the next garbage collection occurs."
msgstr ""
"이것은 except 절 후에 참조하려면 예외를 다른 이름에 대입해야 한다는 뜻입니다. 예외를 제거하는 이유는, 그것에 첨부된 "
"트레이스백으로 인해, 스택 프레임과 참조 순환을 형성해서 다음 가비지 수거가 일어나기 전까지 그 프레임의 모든 지역 변수들을 "
"잡아두기 때문입니다."

#: ../../reference/compound_stmts.rst:302
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is"
" stored in the :mod:`sys` module, where it can be accessed from within "
"the body of the :keyword:`!except` clause by calling "
":func:`sys.exception`. When leaving an exception handler, the exception "
"stored in the :mod:`sys` module is reset to its previous value::"
msgstr ""

#: ../../reference/compound_stmts.rst:308
msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""

#: ../../reference/compound_stmts.rst:333
msgid ":keyword:`!except*` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:335
msgid ""
"The :keyword:`!except*` clause(s) are used for handling "
":exc:`ExceptionGroup`\\s. The exception type for matching is interpreted "
"as in the case of :keyword:`except`, but in the case of exception groups "
"we can have partial matches when the type matches some of the exceptions "
"in the group. This means that multiple :keyword:`!except*` clauses can "
"execute, each handling part of the exception group. Each clause executes "
"at most once and handles an exception group of all matching exceptions.  "
"Each exception in the group is handled by at most one :keyword:`!except*`"
" clause, the first that matches it. ::"
msgstr ""

#: ../../reference/compound_stmts.rst:345
#, python-brace-format
msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""

#: ../../reference/compound_stmts.rst:363
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*`"
" clause are re-raised at the end, along with all exceptions that were "
"raised from within the :keyword:`!except*` clauses. If this list contains"
" more than one exception to reraise, they are combined into an exception "
"group."
msgstr ""

#: ../../reference/compound_stmts.rst:369
msgid ""
"If the raised exception is not an exception group and its type matches "
"one of the :keyword:`!except*` clauses, it is caught and wrapped by an "
"exception group with an empty message string. ::"
msgstr ""

#: ../../reference/compound_stmts.rst:373
msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""

#: ../../reference/compound_stmts.rst:380
msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot "
"be ``except*:``. Furthermore, this expression cannot contain exception "
"group types, because that would have ambiguous semantics."
msgstr ""

#: ../../reference/compound_stmts.rst:384
msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in "
"the same :keyword:`try`. :keyword:`break`, :keyword:`continue` and "
":keyword:`return` cannot appear in an :keyword:`!except*` clause."
msgstr ""

#: ../../reference/compound_stmts.rst:399
#, fuzzy
msgid ":keyword:`!else` clause"
msgstr ":keyword:`!while` 문"

#: ../../reference/compound_stmts.rst:401
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow "
"leaves the :keyword:`try` suite, no exception was raised, and no "
":keyword:`return`, :keyword:`continue`, or :keyword:`break` statement was"
" executed.  Exceptions in the :keyword:`!else` clause are not handled by "
"the preceding :keyword:`except` clauses."
msgstr ""
"생략 가능한 :keyword:`!else` 절은 제어 흐름이 :keyword:`try` 스위트를 빠져나가고, 예외가 발생하지 "
"않았고, :keyword:`return`, :keyword:`continue` 또는 :keyword:`break` 문이 실행되지 "
"않으면 실행됩니다. :keyword:`!else` 절에서 발생하는 예외는 앞에 나오는 :keyword:`except` 절에서 "
"처리되지 않습니다."

#: ../../reference/compound_stmts.rst:413
msgid ":keyword:`!finally` clause"
msgstr ""

#: ../../reference/compound_stmts.rst:415
#, fuzzy
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The"
" :keyword:`try` clause is executed, including any :keyword:`except` and "
":keyword:`else` clauses.  If an exception occurs in any of the clauses "
"and is not handled, the exception is temporarily saved. The "
":keyword:`!finally` clause is executed.  If there is a saved exception it"
" is re-raised at the end of the :keyword:`!finally` clause.  If the "
":keyword:`!finally` clause raises another exception, the saved exception "
"is set as the context of the new exception. If the :keyword:`!finally` "
"clause executes a :keyword:`return`, :keyword:`break` or "
":keyword:`continue` statement, the saved exception is discarded::"
msgstr ""
":keyword:`finally` 가 있으면, '정리(cleanup)' 처리기를 지정합니다. :keyword:`except` 와 "
":keyword:`!else` 절을 포함해서, 먼저 :keyword:`try` 절이 실행됩니다. 이 절들의 어디에서건 예외가 "
"일어나면, 예외는 임시 저장됩니다. :keyword:`!finally` 절이 실행됩니다. 만약 저장된 예외가 있으면, "
":keyword:`!finally` 절의 끝에서 다시 발생시킨다. :keyword:`!finally` 절이 다른 예외를 일으키면, "
"저장된 예외는 새 예외의 컨텍스트(context) 로 설정됩니다. :keyword:`!finally` 절이 "
":keyword:`return`, :keyword:`break` 또는 :keyword:`continue` 문을 실행하면, 저장된 "
"예외는 버립니다."

#: ../../reference/compound_stmts.rst:425
msgid ""
">>> def f():\n"
"...     try:\n"
"...         1/0\n"
"...     finally:\n"
"...         return 42\n"
"...\n"
">>> f()\n"
"42"
msgstr ""

#: ../../reference/compound_stmts.rst:434
#, fuzzy
msgid ""
"The exception information is not available to the program during "
"execution of the :keyword:`!finally` clause."
msgstr ":keyword:`finally` 절을 실행하는 동안 예외 정보는 프로그램에 제공되지 않습니다."

#: ../../reference/compound_stmts.rst:442
#, fuzzy
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` "
"statement is executed in the :keyword:`try` suite of a "
":keyword:`!try`...\\ :keyword:`!finally` statement, the "
":keyword:`!finally` clause is also executed 'on the way out.'"
msgstr ""
":keyword:`!try`...\\ :keyword:`!finally` 문의 :keyword:`try` 스위트에서 "
":keyword:`return`, :keyword:`break`, :keyword:`continue` 문이 실행될 때, "
":keyword:`finally` 절도 '나가는 길에' 실행됩니다."

#: ../../reference/compound_stmts.rst:446
#, fuzzy
msgid ""
"The return value of a function is determined by the last "
":keyword:`return` statement executed.  Since the :keyword:`!finally` "
"clause always executes, a :keyword:`!return` statement executed in the "
":keyword:`!finally` clause will always be the last one executed::"
msgstr ""
"함수의 반환 값은 마지막에 실행된 :keyword:`return` 문으로 결정됩니다. :keyword:`finally` 절이 항상 "
"실행되기 때문에, :keyword:`!finally` 절에서 실행되는 :keyword:`!return` 문이 항상 마지막에 실행되는"
" 것이 됩니다::"

#: ../../reference/compound_stmts.rst:451
msgid ""
">>> def foo():\n"
"...     try:\n"
"...         return 'try'\n"
"...     finally:\n"
"...         return 'finally'\n"
"...\n"
">>> foo()\n"
"'finally'"
msgstr ""

#: ../../reference/compound_stmts.rst:460
#, fuzzy
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the "
":keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"파이썬 3.8 이전에는, :keyword:`continue` 문이 구현 문제로 인해 :keyword:`finally` 절에서 "
"유효하지 않았습니다."

#: ../../reference/compound_stmts.rst:469
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with` 문"

#: ../../reference/compound_stmts.rst:478
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block "
"with methods defined by a context manager (see section :ref:`context-"
"managers`). This allows common :keyword:`try`...\\ :keyword:`except`...\\"
" :keyword:`finally` usage patterns to be encapsulated for convenient "
"reuse."
msgstr ""
":keyword:`with` 문은 블록의 실행을 컨텍스트 관리자 (:ref:`context-managers` 섹션을 보세요) 가 "
"정의한 메서드들로 감싸는 데 사용됩니다. 이것은 흔한 :keyword:`try`...\\ :keyword:`except`...\\ "
":keyword:`finally` 사용 패턴을 편리하게 재사용할 수 있도록 캡슐화할 수 있도록 합니다."

#: ../../reference/compound_stmts.rst:488
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds"
" as follows:"
msgstr "하나의 \"item\" 을 사용하는 :keyword:`with` 문의 실행은 다음과 같이 진행됩니다:"

#: ../../reference/compound_stmts.rst:490
#, fuzzy
msgid ""
"The context expression (the expression given in the :token:`~python-"
"grammar:with_item`) is evaluated to obtain a context manager."
msgstr "컨텍스트 관리자를 얻기 위해 컨텍스트 표현식 (:token:`with_item` 에 주어진 expression) 의 값을 구합니다."

#: ../../reference/compound_stmts.rst:493
#, fuzzy
msgid "The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr "나중에 사용하기 위해 컨텍스트 관리자의 :meth:`__enter__` 가 로드됩니다."

#: ../../reference/compound_stmts.rst:495
#, fuzzy
msgid "The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr "나중에 사용하기 위해 컨텍스트 관리자의 :meth:`__exit__` 가 로드됩니다."

#: ../../reference/compound_stmts.rst:497
#, fuzzy
msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr "컨텍스트 관리자의 :meth:`__enter__` 메서드를 호출합니다."

#: ../../reference/compound_stmts.rst:499
#, fuzzy
msgid ""
"If a target was included in the :keyword:`with` statement, the return "
"value from :meth:`~object.__enter__` is assigned to it."
msgstr ":keyword:`with` 문에 타깃이 포함되었으면, 그것에 :meth:`__enter__` 의 반환 값을 대입합니다."

#: ../../reference/compound_stmts.rst:504
#, fuzzy
msgid ""
"The :keyword:`with` statement guarantees that if the "
":meth:`~object.__enter__` method returns without an error, then "
":meth:`~object.__exit__` will always be called. Thus, if an error occurs "
"during the assignment to the target list, it will be treated the same as "
"an error occurring within the suite would be. See step 7 below."
msgstr ""
":keyword:`with` 문은 :meth:`__enter__` 메서드가 에러 없이 돌아왔을 때, :meth:`__exit__` "
"가 항상 호출됨을 보장합니다. 그래서, 타깃에 대입하는 동안 에러가 발생하면, 스위트 안에서 에러가 발생한 것과 같이 취급됩니다. "
"아래의 6단계를 보세요."

#: ../../reference/compound_stmts.rst:510
msgid "The suite is executed."
msgstr "스위트가 실행됩니다."

#: ../../reference/compound_stmts.rst:512
#, fuzzy
msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback "
"are passed as arguments to :meth:`~object.__exit__`. Otherwise, three "
":const:`None` arguments are supplied."
msgstr ""
"컨텍스트 관리자의 :meth:`__exit__` 메서드를 호출합니다. 예외가 스위트를 종료되도록 만들었다면, 그것의 형, 값, "
"트레이스백이 :meth:`__exit__` 의 인자로 전달됩니다. 그렇지 않으면 세 개의 :const:`None` 이 인자로 "
"공급됩니다."

#: ../../reference/compound_stmts.rst:517
#, fuzzy
msgid ""
"If the suite was exited due to an exception, and the return value from "
"the :meth:`~object.__exit__` method was false, the exception is reraised."
"  If the return value was true, the exception is suppressed, and "
"execution continues with the statement following the :keyword:`with` "
"statement."
msgstr ""
"스위트가 예외 때문에 종료되었고, :meth:`__exit__` 메서드의 반환 값이 거짓이면, 그 예외를 다시 일으킨다. 반환 값이"
" 참이면, 예외를 억누르고, :keyword:`with` 문 뒤에 오는 문장으로 실행을 계속합니다. "

#: ../../reference/compound_stmts.rst:522
#, fuzzy
msgid ""
"If the suite was exited for any reason other than an exception, the "
"return value from :meth:`~object.__exit__` is ignored, and execution "
"proceeds at the normal location for the kind of exit that was taken."
msgstr ""
"스위트가 예외 이외의 이유로 종료되면, :meth:`__exit__` 의 반환 값은 무시되고, 해당 종료의 종류에 맞는 위치에서 "
"실행을 계속합니다."

#: ../../reference/compound_stmts.rst:526
#: ../../reference/compound_stmts.rst:1549
#: ../../reference/compound_stmts.rst:1590
msgid "The following code::"
msgstr "다음과 같은 코드는::"

#: ../../reference/compound_stmts.rst:528
msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""

#: ../../reference/compound_stmts.rst:531
#: ../../reference/compound_stmts.rst:556
#: ../../reference/compound_stmts.rst:1595
msgid "is semantically equivalent to::"
msgstr "의미상으로 다음과 동등합니다::"

#: ../../reference/compound_stmts.rst:533
msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""

#: ../../reference/compound_stmts.rst:550
msgid ""
"With more than one item, the context managers are processed as if "
"multiple :keyword:`with` statements were nested::"
msgstr "하나 보다 많은 항목을 주면, 컨텍스트 관리자는 :keyword:`with` 문이 중첩된 것처럼 진행합니다::"

#: ../../reference/compound_stmts.rst:553
msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""

#: ../../reference/compound_stmts.rst:558
msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""

#: ../../reference/compound_stmts.rst:562
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""

#: ../../reference/compound_stmts.rst:565
msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""

#: ../../reference/compound_stmts.rst:571
msgid "Support for multiple context expressions."
msgstr "다중 컨텍스트 표현식의 지원"

#: ../../reference/compound_stmts.rst:574
msgid ""
"Support for using grouping parentheses to break the statement in multiple"
" lines."
msgstr ""

#: ../../reference/compound_stmts.rst:579
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 문"

#: ../../reference/compound_stmts.rst:580
msgid ""
"The specification, background, and examples for the Python "
":keyword:`with` statement."
msgstr "파이썬 :keyword:`with` 문의 규격, 배경, 예."

#: ../../reference/compound_stmts.rst:586
#, fuzzy
msgid "The :keyword:`!match` statement"
msgstr ":keyword:`!with` 문"

#: ../../reference/compound_stmts.rst:600
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:609
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""

#: ../../reference/compound_stmts.rst:612
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a "
"subject value (following ``match``).  The pattern (which may contain "
"subpatterns) is matched against the subject value.  The outcomes are:"
msgstr ""

#: ../../reference/compound_stmts.rst:616
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""

#: ../../reference/compound_stmts.rst:618
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this"
" are further discussed below."
msgstr ""

#: ../../reference/compound_stmts.rst:621
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""

#: ../../reference/compound_stmts.rst:625
#: ../../reference/compound_stmts.rst:1182
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ""

#: ../../reference/compound_stmts.rst:626
#: ../../reference/compound_stmts.rst:1183
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ""

#: ../../reference/compound_stmts.rst:630
msgid "Overview"
msgstr ""

#: ../../reference/compound_stmts.rst:632
msgid "Here's an overview of the logical flow of a match statement:"
msgstr ""

#: ../../reference/compound_stmts.rst:635
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting "
"subject value obtained. If the subject expression contains a comma, a "
"tuple is constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""

#: ../../reference/compound_stmts.rst:639
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The"
" match attempt can also bind some or all of the standalone names within "
"the pattern. The precise pattern binding rules vary per pattern type and "
"are specified below.  **Name bindings made during a successful pattern "
"match outlive the executed block and can be used after the match "
"statement**."
msgstr ""

#: ../../reference/compound_stmts.rst:648
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely"
" on bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior "
"is dependent on implementation and may vary.  This is an intentional "
"decision made to allow different implementations to add optimizations."
msgstr ""

#: ../../reference/compound_stmts.rst:655
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is "
"evaluated. In this case all name bindings are guaranteed to have "
"happened."
msgstr ""

#: ../../reference/compound_stmts.rst:658
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""

#: ../../reference/compound_stmts.rst:661
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr ""

#: ../../reference/compound_stmts.rst:663
msgid "If there are no further case blocks, the match statement is completed."
msgstr ""

#: ../../reference/compound_stmts.rst:667
msgid ""
"Users should generally never rely on a pattern being evaluated.  "
"Depending on implementation, the interpreter may cache values or use "
"other optimizations which skip repeated evaluations."
msgstr ""

#: ../../reference/compound_stmts.rst:671
msgid "A sample match statement::"
msgstr ""

#: ../../reference/compound_stmts.rst:673
#, python-brace-format
msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""

#: ../../reference/compound_stmts.rst:687
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""

#: ../../reference/compound_stmts.rst:690
msgid "Guards"
msgstr ""

#: ../../reference/compound_stmts.rst:697
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside "
"the ``case`` block to execute.  It takes the form: :keyword:`if` followed"
" by an expression."
msgstr ""

#: ../../reference/compound_stmts.rst:702
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr ""

#: ../../reference/compound_stmts.rst:704
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""

#: ../../reference/compound_stmts.rst:708
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr ""

#: ../../reference/compound_stmts.rst:710
msgid "If the ``guard`` condition evaluates as true, the case block is selected."
msgstr ""

#: ../../reference/compound_stmts.rst:713
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""

#: ../../reference/compound_stmts.rst:716
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""

#: ../../reference/compound_stmts.rst:719
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., "
"guard evaluation must happen in order.) Guard evaluation must stop once a"
" case block is selected."
msgstr ""

#: ../../reference/compound_stmts.rst:729
msgid "Irrefutable Case Blocks"
msgstr ""

#: ../../reference/compound_stmts.rst:733
msgid ""
"An irrefutable case block is a match-all case block.  A match statement "
"may have at most one irrefutable case block, and it must be last."
msgstr ""

#: ../../reference/compound_stmts.rst:736
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern"
" is irrefutable.  A pattern is considered irrefutable if we can prove "
"from its syntax alone that it will always succeed.  Only the following "
"patterns are irrefutable:"
msgstr ""

#: ../../reference/compound_stmts.rst:741
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ""

#: ../../reference/compound_stmts.rst:743
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ""

#: ../../reference/compound_stmts.rst:745
msgid ":ref:`capture-patterns`"
msgstr ""

#: ../../reference/compound_stmts.rst:747
msgid ":ref:`wildcard-patterns`"
msgstr ""

#: ../../reference/compound_stmts.rst:749
msgid "parenthesized irrefutable patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:753
msgid "Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:760
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr ""

#: ../../reference/compound_stmts.rst:762
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr ""

#: ../../reference/compound_stmts.rst:764
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""

#: ../../reference/compound_stmts.rst:767
msgid "The top-level syntax for ``patterns`` is:"
msgstr ""

#: ../../reference/compound_stmts.rst:781
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond "
"Hettinger for a document that inspired most of the descriptions). Note "
"that these descriptions are purely for illustration purposes and **may "
"not** reflect the underlying implementation.  Furthermore, they do not "
"cover all valid forms."
msgstr ""

#: ../../reference/compound_stmts.rst:791
msgid "OR Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:793
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:799
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, "
"and each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""

#: ../../reference/compound_stmts.rst:802
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject "
"value, until one succeeds.  The OR pattern is then considered successful."
"  Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:806
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails "
"it will try to match ``P2``, succeeding immediately if any succeeds, "
"failing otherwise."
msgstr ""

#: ../../reference/compound_stmts.rst:812
msgid "AS Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:814
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` "
"keyword against a subject.  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:820
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern"
" binds the subject to the name on the right of the as keyword and "
"succeeds. ``capture_pattern`` cannot be a ``_``."
msgstr ""

#: ../../reference/compound_stmts.rst:824
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it "
"will set ``NAME = <subject>``."
msgstr ""

#: ../../reference/compound_stmts.rst:831
msgid "Literal Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:833
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in "
"Python.  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:846
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the "
":doc:`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings`"
" are not supported."
msgstr ""

#: ../../reference/compound_stmts.rst:851
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` "
"are for expressing :ref:`complex numbers <imaginary>`; they require a "
"real number on the left and an imaginary number on the right. E.g. ``3 + "
"4j``."
msgstr ""

#: ../../reference/compound_stmts.rst:855
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == "
"LITERAL``. For the singletons ``None``, ``True`` and ``False``, the "
":keyword:`is` operator is used."
msgstr ""

#: ../../reference/compound_stmts.rst:861
msgid "Capture Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:863
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:869
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'``"
" expresses). It is instead treated as a :token:`~python-"
"grammar:wildcard_pattern`."
msgstr ""

#: ../../reference/compound_stmts.rst:873
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""

#: ../../reference/compound_stmts.rst:876
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name"
" becomes a local variable in the closest containing function scope unless"
" there's an applicable :keyword:`global` or :keyword:`nonlocal` "
"statement."
msgstr ""

#: ../../reference/compound_stmts.rst:881
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""

#: ../../reference/compound_stmts.rst:886
msgid "Wildcard Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:888
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name."
"  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:894
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but "
"only within patterns.  It is an identifier, as usual, even within "
"``match`` subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""

#: ../../reference/compound_stmts.rst:898
msgid "In simple terms, ``_`` will always succeed."
msgstr ""

#: ../../reference/compound_stmts.rst:903
msgid "Value Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:905
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:913
msgid ""
"The dotted name in the pattern is looked up using standard Python "
":ref:`name resolution rules <resolve_names>`.  The pattern succeeds if "
"the value found compares equal to the subject value (using the ``==`` "
"equality operator)."
msgstr ""

#: ../../reference/compound_stmts.rst:918
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == "
"NAME1.NAME2``"
msgstr ""

#: ../../reference/compound_stmts.rst:922
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than "
"repeat the same lookup.  This cache is strictly tied to a given execution"
" of a given match statement."
msgstr ""

#: ../../reference/compound_stmts.rst:930
msgid "Group Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:932
msgid ""
"A group pattern allows users to add parentheses around patterns to "
"emphasize the intended grouping.  Otherwise, it has no additional syntax."
" Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:939
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr ""

#: ../../reference/compound_stmts.rst:944
msgid "Sequence Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:946
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or "
"tuple."
msgstr ""

#: ../../reference/compound_stmts.rst:957
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""

#: ../../reference/compound_stmts.rst:961
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. "
"``(3 | 4)``) is a :ref:`group pattern <group-patterns>`. While a single "
"pattern enclosed in square brackets (e.g. ``[3 | 4]``) is still a "
"sequence pattern."
msgstr ""

#: ../../reference/compound_stmts.rst:966
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, "
"the sequence pattern is a fixed-length sequence pattern; otherwise it is "
"a variable-length sequence pattern."
msgstr ""

#: ../../reference/compound_stmts.rst:971
msgid ""
"The following is the logical flow for matching a sequence pattern against"
" a subject value:"
msgstr ""

#: ../../reference/compound_stmts.rst:974
msgid "If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:977
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or "
"``bytearray`` the sequence pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:980
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""

#: ../../reference/compound_stmts.rst:983
msgid "If the sequence pattern is fixed-length:"
msgstr ""

#: ../../reference/compound_stmts.rst:985
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""

#: ../../reference/compound_stmts.rst:988
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding "
"items in the subject sequence from left to right.  Matching stops as soon"
" as a subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""

#: ../../reference/compound_stmts.rst:993
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr ""

#: ../../reference/compound_stmts.rst:995
msgid ""
"If the length of the subject sequence is less than the number of non-star"
" subpatterns, the sequence pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:998
msgid ""
"The leading non-star subpatterns are matched to their corresponding items"
" as for fixed-length sequences."
msgstr ""

#: ../../reference/compound_stmts.rst:1001
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed "
"of the remaining subject items, excluding the remaining items "
"corresponding to non-star subpatterns following the star subpattern."
msgstr ""

#: ../../reference/compound_stmts.rst:1005
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject"
" items, as for a fixed-length sequence."
msgstr ""

#: ../../reference/compound_stmts.rst:1008
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the "
"interpreter in a similar manner as :ref:`value patterns <value-"
"patterns>`."
msgstr ""

#: ../../reference/compound_stmts.rst:1014
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""

#: ../../reference/compound_stmts.rst:1017
msgid "check ``<subject>`` is a sequence"
msgstr ""

#: ../../reference/compound_stmts.rst:1018
msgid "``len(subject) == <N>``"
msgstr ""

#: ../../reference/compound_stmts.rst:1019
msgid "``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""

#: ../../reference/compound_stmts.rst:1020
msgid "``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""

#: ../../reference/compound_stmts.rst:1021
msgid "... and so on for the corresponding pattern/element."
msgstr ""

#: ../../reference/compound_stmts.rst:1026
msgid "Mapping Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:1028
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is"
" similar to the construction of a dictionary. Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:1039
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""

#: ../../reference/compound_stmts.rst:1042
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys"
" will raise a :exc:`SyntaxError`. Two keys that otherwise have the same "
"value will raise a :exc:`ValueError` at runtime."
msgstr ""

#: ../../reference/compound_stmts.rst:1046
msgid ""
"The following is the logical flow for matching a mapping pattern against "
"a subject value:"
msgstr ""

#: ../../reference/compound_stmts.rst:1049
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:1051
msgid ""
"If every key given in the mapping pattern is present in the subject "
"mapping, and the pattern for each key matches the corresponding item of "
"the subject mapping, the mapping pattern succeeds."
msgstr ""

#: ../../reference/compound_stmts.rst:1055
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""

#: ../../reference/compound_stmts.rst:1059
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be "
"present in the mapping, and not created on-the-fly via "
":meth:`__missing__` or :meth:`~object.__getitem__`."
msgstr ""

#: ../../reference/compound_stmts.rst:1064
#, python-brace-format
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""

#: ../../reference/compound_stmts.rst:1067
msgid "check ``<subject>`` is a mapping"
msgstr ""

#: ../../reference/compound_stmts.rst:1068
msgid "``KEY1 in <subject>``"
msgstr ""

#: ../../reference/compound_stmts.rst:1069
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr ""

#: ../../reference/compound_stmts.rst:1070
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr ""

#: ../../reference/compound_stmts.rst:1076
msgid "Class Patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:1078
msgid ""
"A class pattern represents a class and its positional and keyword "
"arguments (if any).  Syntax:"
msgstr ""

#: ../../reference/compound_stmts.rst:1089
msgid "The same keyword should not be repeated in class patterns."
msgstr ""

#: ../../reference/compound_stmts.rst:1091
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""

#: ../../reference/compound_stmts.rst:1094
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , "
"raise :exc:`TypeError`."
msgstr ""

#: ../../reference/compound_stmts.rst:1097
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via "
":func:`isinstance`), the class pattern fails."
msgstr ""

#: ../../reference/compound_stmts.rst:1100
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, "
"the subsequent steps depend on whether keyword or positional argument "
"patterns are present."
msgstr ""

#: ../../reference/compound_stmts.rst:1104
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these "
"types keyword patterns also work as for other types."
msgstr ""

#: ../../reference/compound_stmts.rst:1108
msgid ""
"If only keyword patterns are present, they are processed as follows, one "
"by one:"
msgstr ""

#: ../../reference/compound_stmts.rst:1111
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr ""

#: ../../reference/compound_stmts.rst:1113
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the "
"exception bubbles up."
msgstr ""

#: ../../reference/compound_stmts.rst:1116
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr ""

#: ../../reference/compound_stmts.rst:1118
msgid ""
"Else, the subpattern associated with the keyword pattern is matched "
"against the subject's attribute value.  If this fails, the class pattern "
"fails; if this succeeds, the match proceeds to the next keyword."
msgstr ""

#: ../../reference/compound_stmts.rst:1123
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr ""

#: ../../reference/compound_stmts.rst:1125
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""

#: ../../reference/compound_stmts.rst:1129
msgid "I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""

#: ../../reference/compound_stmts.rst:1131
msgid "If this raises an exception, the exception bubbles up."
msgstr ""

#: ../../reference/compound_stmts.rst:1133
msgid ""
"If the returned value is not a tuple, the conversion fails and "
":exc:`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1136
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, "
":exc:`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1139
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern "
"using ``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must "
"be a string; if not :exc:`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1143
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr ""

#: ../../reference/compound_stmts.rst:1145
msgid ":ref:`class-pattern-matching`"
msgstr ""

#: ../../reference/compound_stmts.rst:1147
msgid "II. Once all positional patterns have been converted to keyword patterns,"
msgstr ""

#: ../../reference/compound_stmts.rst:1148
msgid "the match proceeds as if there were only keyword patterns."
msgstr ""

#: ../../reference/compound_stmts.rst:1150
msgid ""
"For the following built-in types the handling of positional subpatterns "
"is different:"
msgstr ""

#: ../../reference/compound_stmts.rst:1153
msgid ":class:`bool`"
msgstr ""

#: ../../reference/compound_stmts.rst:1154
msgid ":class:`bytearray`"
msgstr ""

#: ../../reference/compound_stmts.rst:1155
msgid ":class:`bytes`"
msgstr ""

#: ../../reference/compound_stmts.rst:1156
msgid ":class:`dict`"
msgstr ""

#: ../../reference/compound_stmts.rst:1157
msgid ":class:`float`"
msgstr ""

#: ../../reference/compound_stmts.rst:1158
msgid ":class:`frozenset`"
msgstr ""

#: ../../reference/compound_stmts.rst:1159
msgid ":class:`int`"
msgstr ""

#: ../../reference/compound_stmts.rst:1160
#: ../../reference/compound_stmts.rst:1880
msgid ":class:`list`"
msgstr ""

#: ../../reference/compound_stmts.rst:1161
msgid ":class:`set`"
msgstr ""

#: ../../reference/compound_stmts.rst:1162
msgid ":class:`str`"
msgstr ""

#: ../../reference/compound_stmts.rst:1163
#: ../../reference/compound_stmts.rst:1883
msgid ":class:`tuple`"
msgstr ""

#: ../../reference/compound_stmts.rst:1165
msgid ""
"These classes accept a single positional argument, and the pattern there "
"is matched against the whole object rather than an attribute. For example"
" ``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""

#: ../../reference/compound_stmts.rst:1169
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following "
"happens:"
msgstr ""

#: ../../reference/compound_stmts.rst:1171
msgid "``isinstance(<subject>, CLS)``"
msgstr ""

#: ../../reference/compound_stmts.rst:1172
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""

#: ../../reference/compound_stmts.rst:1173
msgid "For each keyword argument ``attr=P2``:"
msgstr ""

#: ../../reference/compound_stmts.rst:1175
msgid "``hasattr(<subject>, \"attr\")``"
msgstr ""

#: ../../reference/compound_stmts.rst:1176
msgid "``P2`` matches ``<subject>.attr``"
msgstr ""

#: ../../reference/compound_stmts.rst:1178
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr ""

#: ../../reference/compound_stmts.rst:1193
msgid "Function definitions"
msgstr "함수 정의"

#: ../../reference/compound_stmts.rst:1208
msgid ""
"A function definition defines a user-defined function object (see section"
" :ref:`types`):"
msgstr "함수 정의는 사용자 정의 함수 객체 (:ref:`types` 섹션을 보세요) 를 정의합니다:"

#: ../../reference/compound_stmts.rst:1230
msgid ""
"A function definition is an executable statement.  Its execution binds "
"the function name in the current local namespace to a function object (a "
"wrapper around the executable code for the function).  This function "
"object contains a reference to the current global namespace as the global"
" namespace to be used when the function is called."
msgstr ""
"함수 정의는 실행할 수 있는 문장입니다. 실행하면 현재 지역 이름 공간의 함수 이름을 함수 객체 (함수의 실행 가능한 코드를 둘러싼"
" 래퍼(wrapper)). 이 함수 객체는 현재의 이름 공간에 대한 참조를 포함하는데, 함수가 호출될 때 전역 이름 공간으로 "
"사용됩니다."

#: ../../reference/compound_stmts.rst:1236
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "함수 정의는 함수의 바디를 실행하지 않습니다. 함수가 호출될 때 실행됩니다. [#]_"

#: ../../reference/compound_stmts.rst:1242
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only"
" argument. The returned value is bound to the function name instead of "
"the function object.  Multiple decorators are applied in nested fashion. "
"For example, the following code ::"
msgstr ""
"함수 정의는 하나나 그 이상의 :term:`데코레이터 <decorator>` 표현식으로 감싸질 수 있습니다. 데코레이터 표현식은 "
"함수가 정의될 때, 함수 정의를 포함하는 스코프에서 값을 구합니다. 그 결과는 콜러블이어야 하는데, 함수 객체만을 인자로 사용해서 "
"호출됩니다. 반환 값이 함수 객체 대신 함수의 이름에 연결됩니다. 여러 개의 데코레이터는 중첩되는 방식으로 적용됩니다. 예를 들어,"
" 다음과 같은 코드 ::"

#: ../../reference/compound_stmts.rst:1249
msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""

#: ../../reference/compound_stmts.rst:1253
#: ../../reference/compound_stmts.rst:1448
msgid "is roughly equivalent to ::"
msgstr "는 대략 다음과 동등합니다 ::"

#: ../../reference/compound_stmts.rst:1255
msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""

#: ../../reference/compound_stmts.rst:1258
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "원래의 함수가 임시로 이름 ``func`` 에 연결되지 않는다는 점만 다릅니다."

#: ../../reference/compound_stmts.rst:1260
#, fuzzy
msgid ""
"Functions may be decorated with any valid :token:`~python-"
"grammar:assignment_expression`. Previously, the grammar was much more "
"restrictive; see :pep:`614` for details."
msgstr ""
"함수는 모든 유효한 :token:`assignment_expression`\\으로 데코레이트 될 수 있습니다. 이전에는, 문법이 "
"훨씬 제한적이었습니다; 자세한 내용은 :pep:`614`\\를 참조하십시오."

#: ../../reference/compound_stmts.rst:1265
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function "
"is generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref"
":`generic-functions` for more."
msgstr ""

#: ../../reference/compound_stmts.rst:1272
#: ../../reference/compound_stmts.rst:1467
msgid "Type parameter lists are new in Python 3.12."
msgstr ""

#: ../../reference/compound_stmts.rst:1280
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter*"
" ``=`` *expression*, the function is said to have \"default parameter "
"values.\"  For a parameter with a default value, the corresponding "
":term:`argument` may be omitted from a call, in which case the "
"parameter's default value is substituted.  If a parameter has a default "
"value, all following parameters up until the \"``*``\" must also have a "
"default value --- this is a syntactic restriction that is not expressed "
"by the grammar."
msgstr ""
"하나나 그 이상의 :term:`매개변수 <parameter>` 들이 *parameter* ``=`` *expression* 형태를 "
"가질 때, 함수가 \"기본 매개변수 값\"을 갖는다고 말합니다. 기본값이 있는 매개변수의 경우, 호출할 때 대응하는 "
":term:`인자 <argument>` 를 생략할 수 있고, 그럴 때 매개변수의 기본값이 적용됩니다. 만약 매개변수가 기본값을 "
"가지면, \"``*``\" 까지 그 뒤를 따르는 모든 매개변수도 기본값을 가져야 합니다 --- 이것은 문법 규칙에서 표현되지 않는 "
"문법적 제약입니다."

#: ../../reference/compound_stmts.rst:1288
#, fuzzy
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by "
"appending an item to a list), the default parameter value is in effect "
"modified.  This is generally not what was intended.  A way around this is"
" to use ``None`` as the default, and explicitly test for it in the body "
"of the function, e.g.::"
msgstr ""
"**함수 정의가 실행될 때, 기본 매개변수 값은 왼쪽에서 오른쪽으로 값이 구해집니다.** 이것은 표현식이 함수가 정의될 때 한 번 "
"값이 구해지고, 호출마다 같은 \"미리 계산된\" 값이 사용된다는 것을 뜻합니다. 이것을 이해하는 것은 특히 기본값이 리스트나 "
"딕셔너리와 같은 가변 객체일 때 중요합니다: 만약 함수가 그 객체를 수정하면 (가령, 리스트에 항목을 추가합니다), 그 결과 "
"기본값이 수정됩니다. 이것은 일반적으로 의도하고 있는 것이 아니다. 이 문제를 회피하는 방법은 기본값으로 ``None`` 을 "
"사용하고, 함수 바디에서 명시적으로 검사하는 것입니다, 예를 들어::"

#: ../../reference/compound_stmts.rst:1298
msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""

#: ../../reference/compound_stmts.rst:1309
#, fuzzy
msgid ""
"Function call semantics are described in more detail in section "
":ref:`calls`. A function call always assigns values to all parameters "
"mentioned in the parameter list, either from positional arguments, from "
"keyword arguments, or from default values.  If the form "
"\"``*identifier``\" is present, it is initialized to a tuple receiving "
"any excess positional parameters, defaulting to the empty tuple. If the "
"form \"``**identifier``\" is present, it is initialized to a new ordered "
"mapping receiving any excess keyword arguments, defaulting to a new empty"
" mapping of the same type.  Parameters after \"``*``\" or "
"\"``*identifier``\" are keyword-only parameters and may only be passed by"
" keyword arguments.  Parameters before \"``/``\" are positional-only "
"parameters and may only be passed by positional arguments."
msgstr ""
"함수 호출의 의미는 섹션 :ref:`calls` 에서 더 자세히 설명됩니다. 함수 호출은 항상 매개변수 목록에서 언급하는 모든 "
"매개변수에 값을 대입하는데, 위치 인자들에서 올 수도, 키워드 인자들에서 올 수도, 기본값에서 올 수도 있습니다. "
"\"``*identifier``\" 형태가 존재하면, 남는 위치 매개변수들을 받는 튜플로 초기화됩니다. 기본값은 빈 튜플입니다. "
"\"``**identifier``\" 형태가 존재하면, 남는 키워드 인자들을 받는 순서 있는 매핑으로 초기화됩니다. 기본값은 빈 "
"매핑입니다. \"``*``\" 나 \"``*identifier``\" 뒤에 오는 매개변수들은 키워드 전용 매개변수들이고, 키워드 "
"인자로만 전달될 수 있습니다."

#: ../../reference/compound_stmts.rst:1321
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-"
"only parameters. See :pep:`570` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:1330
#, fuzzy
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the "
"form \"``: expression``\" following the parameter name.  Any parameter "
"may have an annotation, even those of the form ``*identifier`` or "
"``**identifier``. (As a special case, parameters of the form "
"``*identifier`` may have an annotation \"``: *expression``\".) Functions "
"may have \"return\" annotation of the form \"``-> expression``\" after "
"the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of"
" a function.  The annotation values are available as values of a "
"dictionary keyed by the parameters' names in the :attr:`__annotations__` "
"attribute of the function object.  If the ``annotations`` import from "
":mod:`__future__` is used, annotations are preserved as strings at "
"runtime which enables postponed evaluation.  Otherwise, they are "
"evaluated when the function definition is executed.  In this case "
"annotations may be evaluated in a different order than they appear in the"
" source code."
msgstr ""
"매개변수들은 매개변수 이름 뒤에 오는 \"``: expression``\" 형태의 :term:`어노테이션 <function "
"annotation>`\\을 가질 수 있습니다. 모든 매개변수는 어노테이션을 가질 수 있는데, ``*identifier`` 나 "
"``**identifier`` 형태조차 그렇습니다. 함수는 매개변수 목록 뒤에 오는 \"``-> expression``\" 형태의 "
"반환(\"return\") 어노테이션을 가질 수 있습니다. 이 어노테이션들은 올바른 파이썬 표현식이면 어떤 것이건 될 수 있습니다."
" 어노테이션의 존재는 함수의 의미를 바꾸지 않습니다. 어노테이션 값들은 함수 객체의 :attr:`__annotations__` "
"어트리뷰트에서 매개변수의 이름을 키로 하는 딕셔너리의 값으로 제공됩니다. :mod:`__future__` 에서 "
"``annotations`` 을 임포트하면, 지연된 평가가 활성화되어 어노테이션은 실행시간에 문자열로 보존됩니다. 그렇지 않으면 "
"함수 정의가 실행될 때 평가됩니다. 이 경우 어노테이션은 소스 코드에 나오는 순서와 다른 순서로 평가될 수 있습니다."

#: ../../reference/compound_stmts.rst:1344
msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr ""

#: ../../reference/compound_stmts.rst:1350
msgid ""
"It is also possible to create anonymous functions (functions not bound to"
" a name), for immediate use in expressions.  This uses lambda "
"expressions, described in section :ref:`lambda`.  Note that the lambda "
"expression is merely a shorthand for a simplified function definition; a "
"function defined in a \":keyword:`def`\" statement can be passed around "
"or assigned to another name just like a function defined by a lambda "
"expression.  The \":keyword:`!def`\" form is actually more powerful since"
" it allows the execution of multiple statements and annotations."
msgstr ""
"표현식에서 즉시 사용하기 위해, 이름 없는 함수(이름에 연결되지 않은 함수)를 만드는 것도 가능합니다. 이것은 람다 표현식을 "
"사용하는데, :ref:`lambda` 섹션에서 설명합니다. 람다 표현식은 단순화된 함수 정의를 위한 줄임 표현에 지나지 않는다는 "
"것에 주의하세요; \":keyword:`def`\" 문장에서 정의된 함수는 람다 표현식으로 정의된 함수처럼 전달되거나 다른 이름에 "
"대입될 수 있습니다. 여러 개의 문장을 실행하는 것과 어노테이션을 허락하기 때문에, \":keyword:`!def`\" 형태가 사실"
" 더 강력합니다."

#: ../../reference/compound_stmts.rst:1358
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested"
" function can access the local variables of the function containing the "
"def.  See section :ref:`naming` for details."
msgstr ""
"**프로그래머 유의 사항:** 함수는 퍼스트 클래스(first-class) 객체다. 함수 정의 안에서 실행되는 \"``def``\""
" 문은 돌려주거나 전달할 수 있는 지역 함수를 정의합니다. 중첩된 함수에서 사용되는 자유 변수들은 그 def 를 포함하는 함수의 "
"지역 변수들을 액세스할 수 있습니다. 더 자세한 내용은 :ref:`naming` 섹션을 보세요."

#: ../../reference/compound_stmts.rst:1366
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - 함수 어노테이션"

#: ../../reference/compound_stmts.rst:1367
msgid "The original specification for function annotations."
msgstr "함수 어노테이션의 최초 규격."

#: ../../reference/compound_stmts.rst:1369
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 형 힌트"

#: ../../reference/compound_stmts.rst:1370
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "어노테이션에 대한 표준 의미 정의: 형 힌트."

#: ../../reference/compound_stmts.rst:1372
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 변수 어노테이션 문법"

#: ../../reference/compound_stmts.rst:1373
#, fuzzy
msgid ""
"Ability to type hint variable declarations, including class variables and"
" instance variables."
msgstr "클래스 변수 및 인스턴스 변수를 포함하는 변수 선언에 형 힌트를 줄 수 있는 기능"

#: ../../reference/compound_stmts.rst:1376
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - 어노테이션의 지연된 평가"

#: ../../reference/compound_stmts.rst:1377
msgid ""
"Support for forward references within annotations by preserving "
"annotations in a string form at runtime instead of eager evaluation."
msgstr "즉시 평가하는 대신 실행시간에 어노테이션을 문자열 형식으로 보존하여 어노테이션 내에서의 전방 참조를 지원합니다."

#: ../../reference/compound_stmts.rst:1380
#, fuzzy
msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`3107` - 함수 어노테이션"

#: ../../reference/compound_stmts.rst:1381
#, fuzzy
msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr "클래스 데코레이터를 추가하는 제안. 함수와 메서드 데코레이터는 :pep:`318`\\에서 도입되었습니다."

#: ../../reference/compound_stmts.rst:1387
msgid "Class definitions"
msgstr "클래스 정의"

#: ../../reference/compound_stmts.rst:1402
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "클래스 정의는 클래스 객체(:ref:`types` 섹션을 보세요)를 정의합니다:"

#: ../../reference/compound_stmts.rst:1409
msgid ""
"A class definition is an executable statement.  The inheritance list "
"usually gives a list of base classes (see :ref:`metaclasses` for more "
"advanced uses), so each item in the list should evaluate to a class "
"object which allows subclassing.  Classes without an inheritance list "
"inherit, by default, from the base class :class:`object`; hence, ::"
msgstr ""
"클래스 정의는 실행 가능한 문장입니다. 계승(inheritance) 목록은 보통 베이스 클래스들의 목록을 제공하는데 (더 고급 "
"사용에 대해서는 :ref:`metaclasses` 를 보세요), 목록의 각 항목은 값을 구할 때 서브 클래싱을 허락하는 클래스 "
"객체가 되어야 합니다. 계승 목록이 없는 클래스는, 기본적으로, 베이스 클래스 :class:`object` 를 계승합니다; 그래서 "
"::"

#: ../../reference/compound_stmts.rst:1415
msgid ""
"class Foo:\n"
"    pass"
msgstr ""

#: ../../reference/compound_stmts.rst:1418
msgid "is equivalent to ::"
msgstr "는 다음과 동등합니다 ::"

#: ../../reference/compound_stmts.rst:1420
msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""

#: ../../reference/compound_stmts.rst:1423
msgid ""
"The class's suite is then executed in a new execution frame (see "
":ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function "
"definitions.)  When the class's suite finishes execution, its execution "
"frame is discarded but its local namespace is saved. [#]_ A class object "
"is then created using the inheritance list for the base classes and the "
"saved local namespace for the attribute dictionary.  The class name is "
"bound to this class object in the original local namespace."
msgstr ""
"클래스의 스위트는 새로 만들어진 지역 이름 공간과 원래의 전역 이름 공간을 사용하는 새 실행 프레임 (:ref:`naming` 을 "
"보세요)에서 실행됩니다. (보통, 스위트는 대부분 함수 정의들을 포함합니다.) 클래스의 스위트가 실행을 마치면, 실행 프레임은 "
"파기하지만, 그것의 지역 이름 공간은 보존합니다. [#]_ 그런 다음, 계승 목록을 베이스 클래스들로, 보존된 지역 이름 공간을 "
"어트리뷰트 딕셔너리로 사용해서 새 클래스 객체를 만듭니다. 클래스의 이름은 원래의 지역 이름 공간에서 이 클래스 객체와 연결됩니다."

#: ../../reference/compound_stmts.rst:1432
#, fuzzy
msgid ""
"The order in which attributes are defined in the class body is preserved "
"in the new class's :attr:`~type.__dict__`.  Note that this is reliable "
"only right after the class is created and only for classes that were "
"defined using the definition syntax."
msgstr ""
"클래스 바디에서 어트리뷰트가 정의되는 순서는, 새 클래스의 ``__dict__`` 에 보존됩니다. 이것은 클래스가 만들어진 직후에,"
" 정의 문법을 사용해서 정의되는 클래스들에서만 신뢰할 수 있다는 것에 주의해야 합니다."

#: ../../reference/compound_stmts.rst:1437
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "클래스 생성은 :ref:`메타 클래스 <metaclasses>` 를 사용해서 심하게 커스터마이즈할 수 있습니다."

#: ../../reference/compound_stmts.rst:1442
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "클래스 역시 함수를 데코레이팅할 때처럼 테코레이트할 수 있습니다, ::"

#: ../../reference/compound_stmts.rst:1444
msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""

#: ../../reference/compound_stmts.rst:1450
msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""

#: ../../reference/compound_stmts.rst:1453
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "데코레이터 표현식의 값을 구하는 규칙은 함수 데코레이터와 같습니다. 그런 다음 그 결과가 클래스 이름에 연결됩니다."

#: ../../reference/compound_stmts.rst:1456
#, fuzzy
msgid ""
"Classes may be decorated with any valid :token:`~python-"
"grammar:assignment_expression`. Previously, the grammar was much more "
"restrictive; see :pep:`614` for details."
msgstr ""
"클래스는 모든 유효한 :token:`assignment_expression`\\으로 데코레이트 될 수 있습니다. 이전에는, 문법이 "
"훨씬 제한적이었습니다; 자세한 내용은 :pep:`614`\\를 참조하십시오."

#: ../../reference/compound_stmts.rst:1461
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static "
"type checkers that the class is generic. At runtime, the type parameters "
"can be retrieved from the class's :attr:`~type.__type_params__` "
"attribute. See :ref:`generic-classes` for more."
msgstr ""

#: ../../reference/compound_stmts.rst:1470
msgid ""
"**Programmer's note:** Variables defined in the class definition are "
"class attributes; they are shared by instances.  Instance attributes can "
"be set in a method with ``self.name = value``.  Both class and instance "
"attributes are accessible through the notation \"``self.name``\", and an "
"instance attribute hides a class attribute with the same name when "
"accessed in this way.  Class attributes can be used as defaults for "
"instance attributes, but using mutable values there can lead to "
"unexpected results.  :ref:`Descriptors <descriptors>` can be used to "
"create instance variables with different implementation details."
msgstr ""
"**프로그래머 유의 사항:** 클래스 정의에서 정의되는 변수들은 클래스 어트리뷰트입니다; 이것들은 인스턴스 간에 공유됩니다. "
"인스턴스 어트리뷰트는 메서드에서 ``self.name = value`` 로 설정될 수 있습니다. 클래스와 인스턴스 어트리뷰트 모두 "
"\"``self.name``\" 표기법으로 액세스할 수 있고, 이런 식으로 액세스할 때 인스턴스 어트리뷰트는 같은 이름의 클래스 "
"어트리뷰트를 가립니다. 클래스 어트리뷰트는 인스턴스 어트리뷰트의 기본값으로 사용될 수 있지만, 가변 값을 사용하는 것은 예상하지 "
"않은 결과를 줄 수 있습니다. :ref:`디스크립터 <descriptors>` 를 다른 구현 상세를 갖는 인스턴스 변수를 만드는데 "
"사용할 수 있습니다."

#: ../../reference/compound_stmts.rst:1482
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - 파이썬 3000의 메타 클래스"

#: ../../reference/compound_stmts.rst:1483
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are "
"constructed."
msgstr "메타 클래스 선언을 현재 문법으로 변경하고, 메타 클래스가 있는 클래스를 구성하는 방법의 의미를 변경하는 제안."

#: ../../reference/compound_stmts.rst:1487
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - 클래스 데코레이터"

#: ../../reference/compound_stmts.rst:1488
msgid ""
"The proposal that added class decorators.  Function and method decorators"
" were introduced in :pep:`318`."
msgstr "클래스 데코레이터를 추가하는 제안. 함수와 메서드 데코레이터는 :pep:`318`\\에서 도입되었습니다."

#: ../../reference/compound_stmts.rst:1495
msgid "Coroutines"
msgstr "코루틴"

#: ../../reference/compound_stmts.rst:1503
msgid "Coroutine function definition"
msgstr "코루틴 함수 정의"

#: ../../reference/compound_stmts.rst:1513
#, fuzzy
msgid ""
"Execution of Python coroutines can be suspended and resumed at many "
"points (see :term:`coroutine`). :keyword:`await` expressions, "
":keyword:`async for` and :keyword:`async with` can only be used in the "
"body of a coroutine function."
msgstr ""
"파이썬 코루틴의 실행은 여러 지점에서 일시 중지되거나 재개될 수 있습니다 (:term:`코루틴 <coroutine>` 을 "
"보세요.). 코루틴의 바디 안에서, ``await`` 와 ``async`` 식별자는 예약 키워드가 됩니다; "
"어웨이트(:keyword:`await`) 표현식, :keyword:`async for`, :keyword:`async with` 는"
" 코루틴 바디에서만 사용할 수 있습니다."

#: ../../reference/compound_stmts.rst:1517
msgid ""
"Functions defined with ``async def`` syntax are always coroutine "
"functions, even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"``async def`` 문법으로 정의된 함수는 항상 코루틴 함수인데, ``await`` 나 ``async`` 키워드를 포함하지 "
"않는 경우도 그렇습니다."

#: ../../reference/compound_stmts.rst:1520
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr "코루틴 함수의 바디 안에서 ``yield from`` 표현식을 사용하는 것은 :exc:`SyntaxError` 입니다."

#: ../../reference/compound_stmts.rst:1523
msgid "An example of a coroutine function::"
msgstr "코루틴 함수의 예::"

#: ../../reference/compound_stmts.rst:1525
msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""

#: ../../reference/compound_stmts.rst:1529
msgid ""
"``await`` and ``async`` are now keywords; previously they were only "
"treated as such inside the body of a coroutine function."
msgstr ""

#: ../../reference/compound_stmts.rst:1537
msgid "The :keyword:`!async for` statement"
msgstr ":keyword:`!async for` 문"

#: ../../reference/compound_stmts.rst:1542
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`비동기 이터러블 <asynchronous iterable>` 은 :term:`비동기 이터레이터 <asynchronous"
" iterator>` 를 직접 반환하는 ``__aiter__`` 메서드를 제공하고, 비동기 이터레이터는 자신의 "
"``__anext__`` 메서드에서 비동기 코드를 호출할 수 있습니다."

#: ../../reference/compound_stmts.rst:1546
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous"
" iterables."
msgstr "``async for`` 문은 비동기 이터러블에 대한 편리한 이터레이션을 허락합니다."

#: ../../reference/compound_stmts.rst:1551
msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""

#: ../../reference/compound_stmts.rst:1556
msgid "Is semantically equivalent to::"
msgstr "의미상으로 다음과 동등합니다::"

#: ../../reference/compound_stmts.rst:1558
msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""

#: ../../reference/compound_stmts.rst:1572
#, fuzzy
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for "
"details."
msgstr "더 자세한 내용은 :meth:`__aiter__` 를 :meth:`__anext__` 보면 됩니다."

#: ../../reference/compound_stmts.rst:1574
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr "코루틴 함수의 바디 밖에서 ``async for`` 문을 사용하는 것은 :exc:`SyntaxError` 입니다."

#: ../../reference/compound_stmts.rst:1582
msgid "The :keyword:`!async with` statement"
msgstr ":keyword:`!async with` 문"

#: ../../reference/compound_stmts.rst:1587
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that"
" is able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`비동기 컨텍스트 관리자 <asynchronous context manager>` 는 *enter* 와 *exit* "
"메서드에서 실행을 일시 중지할 수 있는 :term:`컨텍스트 관리자 <context manager>` 입니다."

#: ../../reference/compound_stmts.rst:1592
msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""

#: ../../reference/compound_stmts.rst:1597
msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""

#: ../../reference/compound_stmts.rst:1614
#, fuzzy
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr "더 자세한 내용은 :meth:`__aenter__` 와 :meth:`__aexit__` 를 보면 됩니다."

#: ../../reference/compound_stmts.rst:1616
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the"
" body of a coroutine function."
msgstr "코루틴 함수의 바디 밖에서 ``async with`` 문을 사용하는 것은 :exc:`SyntaxError` 입니다."

#: ../../reference/compound_stmts.rst:1621
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - async 와 await 문법을 사용하는 코루틴"

#: ../../reference/compound_stmts.rst:1622
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, "
"and added supporting syntax."
msgstr "코루틴을 파이썬에서 적절한 독립적인 개념으로 만들고, 문법 지원을 추가한 제안."

#: ../../reference/compound_stmts.rst:1628
msgid "Type parameter lists"
msgstr ""

#: ../../reference/compound_stmts.rst:1632
msgid "Support for default values was added (see :pep:`696`)."
msgstr ""

#: ../../reference/compound_stmts.rst:1645
msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async def>`), "
":ref:`classes <class>` and :ref:`type aliases <type>` may contain a type "
"parameter list::"
msgstr ""

#: ../../reference/compound_stmts.rst:1649
msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""

#: ../../reference/compound_stmts.rst:1664
msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by "
"static type checkers, and at runtime, generic objects behave much like "
"their non-generic counterparts."
msgstr ""

#: ../../reference/compound_stmts.rst:1669
msgid ""
"Type parameters are declared in square brackets (``[]``) immediately "
"after the name of the function, class, or type alias. The type parameters"
" are accessible within the scope of the generic object, but not "
"elsewhere. Thus, after a declaration ``def func[T](): pass``, the name "
"``T`` is not available in the module scope. Below, the semantics of "
"generic objects are described with more precision. The scope of type "
"parameters is modeled with a special function (technically, an "
":ref:`annotation scope <annotation-scopes>`) that wraps the creation of "
"the generic object."
msgstr ""

#: ../../reference/compound_stmts.rst:1678
msgid ""
"Generic functions, classes, and type aliases have a "
":attr:`~definition.__type_params__` attribute listing their type "
"parameters."
msgstr ""

#: ../../reference/compound_stmts.rst:1681
msgid "Type parameters come in three kinds:"
msgstr ""

#: ../../reference/compound_stmts.rst:1683
msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""

#: ../../reference/compound_stmts.rst:1685
msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""

#: ../../reference/compound_stmts.rst:1688
msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two "
"asterisks (e.g., ``**P``). Semantically, this stands for the parameters "
"of a callable."
msgstr ""

#: ../../reference/compound_stmts.rst:1691
msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints*"
" with a colon (``:``) followed by an expression. A single expression "
"after the colon indicates a bound (e.g. ``T: int``). Semantically, this "
"means that the :data:`!typing.TypeVar` can only represent types that are "
"a subtype of this bound. A parenthesized tuple of expressions after the "
"colon indicates a set of constraints (e.g. ``T: (str, bytes)``). Each "
"member of the tuple should be a type (again, this is not enforced at "
"runtime). Constrained type variables can only take on one of the types in"
" the list of constraints."
msgstr ""

#: ../../reference/compound_stmts.rst:1700
msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic "
"object is created, but only when the value is explicitly accessed through"
" the attributes ``__bound__`` and ``__constraints__``. To accomplish "
"this, the bounds or constraints are evaluated in a separate "
":ref:`annotation scope <annotation-scopes>`."
msgstr ""

#: ../../reference/compound_stmts.rst:1706
msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot "
"have bounds or constraints."
msgstr ""

#: ../../reference/compound_stmts.rst:1709
msgid ""
"All three flavors of type parameters can also have a *default value*, "
"which is used when the type parameter is not explicitly provided. This is"
" added by appending a single equals sign (``=``) followed by an "
"expression. Like the bounds and constraints of type variables, the "
"default value is not evaluated when the object is created, but only when "
"the type parameter's ``__default__`` attribute is accessed. To this end, "
"the default value is evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`. If no default value is specified for a type "
"parameter, the ``__default__`` attribute is set to the special sentinel "
"object :data:`typing.NoDefault`."
msgstr ""

#: ../../reference/compound_stmts.rst:1719
msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr ""

#: ../../reference/compound_stmts.rst:1721
msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1739
msgid "Generic functions"
msgstr ""

#: ../../reference/compound_stmts.rst:1741
msgid "Generic functions are declared as follows::"
msgstr ""

#: ../../reference/compound_stmts.rst:1743
msgid "def func[T](arg: T): ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1745
#: ../../reference/compound_stmts.rst:1805
#, fuzzy
msgid "This syntax is equivalent to::"
msgstr "의미상으로 다음과 동등합니다::"

#: ../../reference/compound_stmts.rst:1747
msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""

#: ../../reference/compound_stmts.rst:1754
msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance of "
":data:`typing.TypeVar` directly.)"
msgstr ""

#: ../../reference/compound_stmts.rst:1760
msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults"
" and decorators are not."
msgstr ""

#: ../../reference/compound_stmts.rst:1764
msgid ""
"The following example illustrates the scoping rules for these cases, as "
"well as for additional flavors of type parameters::"
msgstr ""

#: ../../reference/compound_stmts.rst:1767
msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = "
"some_default):\n"
"    ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1771
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the "
":class:`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""

#: ../../reference/compound_stmts.rst:1774
msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""

#: ../../reference/compound_stmts.rst:1793
msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr ""

#: ../../reference/compound_stmts.rst:1799
msgid "Generic classes"
msgstr ""

#: ../../reference/compound_stmts.rst:1801
msgid "Generic classes are declared as follows::"
msgstr ""

#: ../../reference/compound_stmts.rst:1803
msgid "class Bag[T]: ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1807
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""

#: ../../reference/compound_stmts.rst:1815
msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates an "
":ref:`annotation scope <annotation-scopes>`, and the name "
"``TYPE_PARAMS_OF_Bag`` is not actually bound at runtime."
msgstr ""

#: ../../reference/compound_stmts.rst:1819
msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the"
" type scope for the type parameters, and decorators are evaluated outside"
" that scope. This is illustrated by this example::"
msgstr ""

#: ../../reference/compound_stmts.rst:1825
msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""

#: ../../reference/compound_stmts.rst:1828
#, fuzzy
msgid "This is equivalent to::"
msgstr "는 다음과 동등합니다 ::"

#: ../../reference/compound_stmts.rst:1830
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""

#: ../../reference/compound_stmts.rst:1841
msgid "Generic type aliases"
msgstr ""

#: ../../reference/compound_stmts.rst:1843
#, fuzzy
msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ":keyword:`if` 문은 조건부 실행에 사용됩니다:"

#: ../../reference/compound_stmts.rst:1845
msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr ""

#: ../../reference/compound_stmts.rst:1847
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, "
"this is equivalent to::"
msgstr ""

#: ../../reference/compound_stmts.rst:1850
msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""

#: ../../reference/compound_stmts.rst:1859
msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an "
":ref:`annotation scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""

#: ../../reference/compound_stmts.rst:1864
msgid "Footnotes"
msgstr "각주"

#: ../../reference/compound_stmts.rst:1865
msgid ""
"The exception is propagated to the invocation stack unless there is a "
":keyword:`finally` clause which happens to raise another exception. That "
"new exception causes the old one to be lost."
msgstr ""
"다른 예외를 일으키는 :keyword:`finally` 절이 있지 않은 한 예외는 호출 스택으로 퍼집니다. 그 새 예외는 예전의 "
"것을 잃어버리게 만듭니다."

#: ../../reference/compound_stmts.rst:1869
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr ""

#: ../../reference/compound_stmts.rst:1871
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr ""

#: ../../reference/compound_stmts.rst:1872
msgid ""
"a Python class that has been registered as "
":class:`collections.abc.Sequence`"
msgstr ""

#: ../../reference/compound_stmts.rst:1873
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit"
" set"
msgstr ""

#: ../../reference/compound_stmts.rst:1874
#: ../../reference/compound_stmts.rst:1893
msgid "a class that inherits from any of the above"
msgstr ""

#: ../../reference/compound_stmts.rst:1876
msgid "The following standard library classes are sequences:"
msgstr ""

#: ../../reference/compound_stmts.rst:1878
msgid ":class:`array.array`"
msgstr ""

#: ../../reference/compound_stmts.rst:1879
msgid ":class:`collections.deque`"
msgstr ""

#: ../../reference/compound_stmts.rst:1881
msgid ":class:`memoryview`"
msgstr ""

#: ../../reference/compound_stmts.rst:1882
msgid ":class:`range`"
msgstr ""

#: ../../reference/compound_stmts.rst:1885
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match"
" sequence patterns."
msgstr ""

#: ../../reference/compound_stmts.rst:1888
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""

#: ../../reference/compound_stmts.rst:1890
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr ""

#: ../../reference/compound_stmts.rst:1891
msgid ""
"a Python class that has been registered as "
":class:`collections.abc.Mapping`"
msgstr ""

#: ../../reference/compound_stmts.rst:1892
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit "
"set"
msgstr ""

#: ../../reference/compound_stmts.rst:1895
msgid ""
"The standard library classes :class:`dict` and "
":class:`types.MappingProxyType` are mappings."
msgstr ""

#: ../../reference/compound_stmts.rst:1898
#, fuzzy
msgid ""
"A string literal appearing as the first statement in the function body is"
" transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"함수 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 함수의 ``__doc__`` 어트리뷰트로 변환되어 함수의 "
":term:`독스트링 <docstring>` 이 됩니다."

#: ../../reference/compound_stmts.rst:1902
#, fuzzy
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore"
" the class's :term:`docstring`."
msgstr ""
"클래스 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 그 이름 공간의 ``__doc__`` 항목으로 변환되어 클래스의 "
":term:`독스트링 <docstring>` 이 됩니다."

#: ../../reference/compound_stmts.rst:7
msgid "compound"
msgstr ""

#: ../../reference/compound_stmts.rst:7 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
#: ../../reference/compound_stmts.rst:1499
#: ../../reference/compound_stmts.rst:1533
#: ../../reference/compound_stmts.rst:1578
#, fuzzy
msgid "statement"
msgstr "복합문(Compound statements)"

#: ../../reference/compound_stmts.rst:21
msgid "clause"
msgstr ""

#: ../../reference/compound_stmts.rst:21
msgid "suite"
msgstr ""

#: ../../reference/compound_stmts.rst:21
msgid "; (semicolon)"
msgstr ""

#: ../../reference/compound_stmts.rst:64
msgid "NEWLINE token"
msgstr ""

#: ../../reference/compound_stmts.rst:64
msgid "DEDENT token"
msgstr ""

#: ../../reference/compound_stmts.rst:64
msgid "dangling"
msgstr ""

#: ../../reference/compound_stmts.rst:64 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:390
msgid "else"
msgstr ""

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:588
msgid "if"
msgstr ""

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:327
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:408
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1509
msgid "keyword"
msgstr ""

#: ../../reference/compound_stmts.rst:86
msgid "elif"
msgstr ""

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1325
#: ../../reference/compound_stmts.rst:1389
msgid ": (colon)"
msgstr ""

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
#, fuzzy
msgid "compound statement"
msgstr "복합문(Compound statements)"

#: ../../reference/compound_stmts.rst:111
msgid "while"
msgstr ""

#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
msgid "loop"
msgstr ""

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
msgid "break"
msgstr ""

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
#, fuzzy
msgid "continue"
msgstr "코루틴"

#: ../../reference/compound_stmts.rst:144
msgid "for"
msgstr ""

#: ../../reference/compound_stmts.rst:144
msgid "in"
msgstr ""

#: ../../reference/compound_stmts.rst:144
msgid "target"
msgstr ""

#: ../../reference/compound_stmts.rst:144
msgid "list"
msgstr ""

#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:298
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "object"
msgstr ""

#: ../../reference/compound_stmts.rst:144
msgid "sequence"
msgstr ""

#: ../../reference/compound_stmts.rst:190
msgid "built-in function"
msgstr ""

#: ../../reference/compound_stmts.rst:190
msgid "range"
msgstr ""

#: ../../reference/compound_stmts.rst:207
msgid "try"
msgstr ""

#: ../../reference/compound_stmts.rst:207
msgid "except"
msgstr ""

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:408
msgid "finally"
msgstr ""

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:265
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
msgid "as"
msgstr ""

#: ../../reference/compound_stmts.rst:265
msgid "except clause"
msgstr ""

#: ../../reference/compound_stmts.rst:298
msgid "module"
msgstr ""

#: ../../reference/compound_stmts.rst:298
msgid "sys"
msgstr ""

#: ../../reference/compound_stmts.rst:298
msgid "traceback"
msgstr ""

#: ../../reference/compound_stmts.rst:327
msgid "except_star"
msgstr ""

#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
msgid "return"
msgstr ""

#: ../../reference/compound_stmts.rst:471
msgid "with"
msgstr ""

#: ../../reference/compound_stmts.rst:471
#, fuzzy
msgid "with statement"
msgstr ":keyword:`!with` 문"

#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid ", (comma)"
msgstr ""

#: ../../reference/compound_stmts.rst:588
msgid "match"
msgstr ""

#: ../../reference/compound_stmts.rst:588
msgid "case"
msgstr ""

#: ../../reference/compound_stmts.rst:588
msgid "pattern matching"
msgstr ""

#: ../../reference/compound_stmts.rst:588
#, fuzzy
msgid "match statement"
msgstr "복합문(Compound statements)"

#: ../../reference/compound_stmts.rst:692
msgid "guard"
msgstr ""

#: ../../reference/compound_stmts.rst:731
msgid "irrefutable case block"
msgstr ""

#: ../../reference/compound_stmts.rst:731
msgid "case block"
msgstr ""

#: ../../reference/compound_stmts.rst:755
msgid "! patterns"
msgstr ""

#: ../../reference/compound_stmts.rst:755
msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr ""

#: ../../reference/compound_stmts.rst:1186
#: ../../reference/compound_stmts.rst:1275
msgid "parameter"
msgstr ""

#: ../../reference/compound_stmts.rst:1186
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1239
#: ../../reference/compound_stmts.rst:1275
#: ../../reference/compound_stmts.rst:1304
#, fuzzy
msgid "function definition"
msgstr "함수 정의"

#: ../../reference/compound_stmts.rst:1195
msgid "def"
msgstr ""

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1325
msgid "function"
msgstr ""

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
#, fuzzy
msgid "definition"
msgstr "클래스 정의"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "name"
msgstr ""

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "binding"
msgstr ""

#: ../../reference/compound_stmts.rst:1195
msgid "user-defined function"
msgstr ""

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "() (parentheses)"
msgstr ""

#: ../../reference/compound_stmts.rst:1195
msgid "parameter list"
msgstr ""

#: ../../reference/compound_stmts.rst:1239
#: ../../reference/compound_stmts.rst:1439
msgid "@ (at)"
msgstr ""

#: ../../reference/compound_stmts.rst:1275
msgid "default"
msgstr ""

#: ../../reference/compound_stmts.rst:1275
msgid "value"
msgstr ""

#: ../../reference/compound_stmts.rst:1275
msgid "argument"
msgstr ""

#: ../../reference/compound_stmts.rst:1275
msgid "= (equals)"
msgstr ""

#: ../../reference/compound_stmts.rst:1304
msgid "/ (slash)"
msgstr ""

#: ../../reference/compound_stmts.rst:1304
msgid "* (asterisk)"
msgstr ""

#: ../../reference/compound_stmts.rst:1304
msgid "**"
msgstr ""

#: ../../reference/compound_stmts.rst:1325
msgid "annotations"
msgstr ""

#: ../../reference/compound_stmts.rst:1325
msgid "->"
msgstr ""

#: ../../reference/compound_stmts.rst:1325
#, fuzzy
msgid "function annotations"
msgstr "함수 정의"

#: ../../reference/compound_stmts.rst:1348
msgid "lambda"
msgstr ""

#: ../../reference/compound_stmts.rst:1348
msgid "expression"
msgstr ""

#: ../../reference/compound_stmts.rst:1389
msgid "class"
msgstr ""

#: ../../reference/compound_stmts.rst:1389
msgid "execution"
msgstr ""

#: ../../reference/compound_stmts.rst:1389
msgid "frame"
msgstr ""

#: ../../reference/compound_stmts.rst:1389
msgid "inheritance"
msgstr ""

#: ../../reference/compound_stmts.rst:1389
msgid "docstring"
msgstr ""

#: ../../reference/compound_stmts.rst:1389
#: ../../reference/compound_stmts.rst:1439
#, fuzzy
msgid "class definition"
msgstr "클래스 정의"

#: ../../reference/compound_stmts.rst:1389
msgid "expression list"
msgstr ""

#: ../../reference/compound_stmts.rst:1499
msgid "async def"
msgstr ""

#: ../../reference/compound_stmts.rst:1509
msgid "async"
msgstr ""

#: ../../reference/compound_stmts.rst:1509
msgid "await"
msgstr ""

#: ../../reference/compound_stmts.rst:1533
msgid "async for"
msgstr ""

#: ../../reference/compound_stmts.rst:1578
msgid "async with"
msgstr ""

#: ../../reference/compound_stmts.rst:1635
msgid "type parameters"
msgstr ""

#~ msgid ""
#~ "There is a subtlety when the "
#~ "sequence is being modified by the "
#~ "loop (this can only occur for "
#~ "mutable sequences, e.g. lists).  An "
#~ "internal counter is used to keep "
#~ "track of which item is used next,"
#~ " and this is incremented on each "
#~ "iteration.  When this counter has "
#~ "reached the length of the sequence "
#~ "the loop terminates.  This means that"
#~ " if the suite deletes the current "
#~ "(or a previous) item from the "
#~ "sequence, the next item will be "
#~ "skipped (since it gets the index "
#~ "of the current item which has "
#~ "already been treated).  Likewise, if the"
#~ " suite inserts an item in the "
#~ "sequence before the current item, the"
#~ " current item will be treated again"
#~ " the next time through the loop. "
#~ "This can lead to nasty bugs that"
#~ " can be avoided by making a "
#~ "temporary copy using a slice of "
#~ "the whole sequence, e.g., ::"
#~ msgstr ""
#~ "시퀀스가 루프에 의해 수정될 때는 미묘한 점이 "
#~ "있습니다 (이것은 오직 가변 시퀀스에서만 일어납니다, 가령"
#~ " 리스트). 다음에 어떤 항목이 사용될지를 추적하는 내부"
#~ " 카운터가 사용되고, 각 이터레이션마다 증가합니다. 이 "
#~ "카운터가 시퀀스의 길이에 도달하면 루프가 종료됩니다. 이것은"
#~ " 만약 스위트가 시퀀스에서 현재 (또는 그 이전의)"
#~ " 항목을 삭제하면, 다음 항목을 건너뛰게 된다는 뜻입니다"
#~ " (다음 항목이 이미 다뤄진 현재 항목의 인덱스를 "
#~ "갖게 되기 때문입니다). 마찬가지로, 스위트가 현재 항목"
#~ " 앞으로 시퀀스에 항목을 삽입하면, 현재 항목은 루프의"
#~ " 다음 순환에서 현재 항목이 한 번 더 "
#~ "다뤄지게 됩니다. 이것은 고약한 버그로 이어질 수 "
#~ "있는데, 전체 시퀀스의 슬라이스로 임시 사본을 만듦으로써"
#~ " 피할 수 있습니다, 예를 들어 ::"

#~ msgid ""
#~ "Before an except clause's suite is "
#~ "executed, details about the exception "
#~ "are stored in the :mod:`sys` module "
#~ "and can be accessed via "
#~ ":func:`sys.exc_info`. :func:`sys.exc_info` returns a"
#~ " 3-tuple consisting of the exception "
#~ "class, the exception instance and a "
#~ "traceback object (see section :ref:`types`)"
#~ " identifying the point in the program"
#~ " where the exception occurred.  "
#~ ":func:`sys.exc_info` values are restored to"
#~ " their previous values (before the "
#~ "call) when returning from a function "
#~ "that handled an exception."
#~ msgstr ""
#~ "except 절의 스위트가 실행되기 전에, 예외의 상세 "
#~ "내용이 :mod:`sys` 모듈에 저장되는데, :func:`sys.exc_info`"
#~ " 를 통해 액세스할 수 있습니다. "
#~ ":func:`sys.exc_info` 는 예외 클래스, 예외 인스턴스,"
#~ " 예외가 프로그램의 어디에서 발생했는지를 알려주는 트레이스백 "
#~ "객체 (:ref:`types` 를 보세요) 로 이루어진 "
#~ "3-튜플을 돌려줍니다. :func:`sys.exc_info` 값들은 예외를 "
#~ "처리한 함수로부터 복귀할 때 이전 값으로 복구됩니다."

