# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "데이터 모델"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "객체, 값, 형"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`객체 (Objects)`\\는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 "
"모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 \"프로그램 내장식 컴퓨터(stored "
"program computer)\" 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니다.)"

#: ../../reference/datamodel.rst:35
#, fuzzy
msgid ""
"Every object has an identity, a type and a value.  An object's *identity*"
" never changes once it has been created; you may think of it as the "
"object's address in memory.  The :keyword:`is` operator compares the "
"identity of two objects; the :func:`id` function returns an integer "
"representing its identity."
msgstr ""
"모든 객체는 아이덴티티(identity), 형(type), 값(value)을 갖습니다. 객체의 *아이덴티티* 는 한 번 만들어진 "
"후에는 변경되지 않습니다. 메모리상에서의 객체의 주소로 생각해도 좋습니다. ':keyword:`is`' 연산자는 두 객체의 "
"아이덴티티를 비교합니다; :func:`id` 함수는 아이덴티티를 정수로 표현한 값을 돌려줍니다."

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "CPython 의 경우, ``id(x)`` 는 ``x`` 가 저장된 메모리의 주소입니다."

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports "
"(e.g., \"does it have a length?\") and also defines the possible values "
"for objects of that type.  The :func:`type` function returns an object's "
"type (which is an object itself).  Like its identity, an object's "
":dfn:`type` is also unchangeable. [#]_"
msgstr ""
"객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, \"길이를 갖고 있나?\") 그 형의 객체들이 가질 수 있는 가능한 "
"값들을 정의합니다. :func:`type` 함수는 객체의 형(이것 역시 객체다)을 돌려줍니다. 아이덴티티와 마찬가지로, 객체의 "
":dfn:`형 (type)` 역시 변경되지 않습니다. [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change "
"are said to be *mutable*; objects whose value is unchangeable once they "
"are created are called *immutable*. (The value of an immutable container "
"object that contains a reference to a mutable object can change when the "
"latter's value is changed; however the container is still considered "
"immutable, because the collection of objects it contains cannot be "
"changed.  So, immutability is not strictly the same as having an "
"unchangeable value, it is more subtle.) An object's mutability is "
"determined by its type; for instance, numbers, strings and tuples are "
"immutable, while dictionaries and lists are mutable."
msgstr ""
"어떤 객체들의 *값* 은 변경할 수 있습니다. 값을 변경할 수 있는 객체들을 *가변(mutable)* 이라고 합니다. 일단 만들어진"
" 후에 값을 변경할 수 없는 객체들을 *불변(immutable)* 이라고 합니다. (가변 객체에 대한 참조를 저장하고 있는 불변 "
"컨테이너의 값은 가변 객체의 값이 변할 때 변경된다고 볼 수도 있습니다; 하지만 저장하고 있는 객체들의 집합이 바뀔 수 없으므로 "
"컨테이너는 여전히 불변이라고 여겨집니다. 따라서 불변성은 엄밀하게는 변경 불가능한 값을 갖는 것과는 다릅니다. 좀 더 미묘합니다.)"
" 객체의 가변성(mutability)은 그것의 형에 의해 결정됩니다; 예를 들어 숫자, 문자열, 튜플(tuple)은 불변이지만, "
"딕셔너리(dictionary) 와 리스트(list)는 가변입니다."

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed "
"to postpone garbage collection or omit it altogether --- it is a matter "
"of implementation quality how garbage collection is implemented, as long "
"as no objects are collected that are still reachable."
msgstr ""
"객체는 결코 명시적으로 파괴되지 않습니다; 더 참조되지 않을 때(unreachable) 가비지 수거(garbage "
"collect)됩니다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락됩니다 --- 아직 참조되는 객체들을 수거하지 않는"
" 이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 문제입니다."

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) "
"delayed detection of cyclically linked garbage, which collects most "
"objects as soon as they become unreachable, but is not guaranteed to "
"collect garbage containing circular references.  See the documentation of"
" the :mod:`gc` module for information on controlling the collection of "
"cyclic garbage. Other implementations act differently and CPython may "
"change. Do not depend on immediate finalization of objects when they "
"become unreachable (so you should always close files explicitly)."
msgstr ""
"CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) 순환적으로 연결된 "
"가비지의 지연된 감지가 추가됩니다. 이 방법으로 대부분 객체를 참조가 제거되자마자 수거할 수 있습니다. 하지만 순환 참조가 있는 "
"가비지들을 수거한다는 보장은 없습니다. 순환적 가비지 수거의 제어에 관한 정보는 :mod:`gc` 모듈 문서를 참조하면 됩니다. "
"다른 구현들은 다른 식으로 동작하고, CPython 도 변경될 수 있습니다. 참조가 제거될 때 즉각적으로 "
"파이널리제이션(finalization)되는 것에 의존하지 말아야 합니다 (그래서 항상 파일을 명시적으로 닫아주어야 합니다)."

#: ../../reference/datamodel.rst:82
#, fuzzy
msgid ""
"Note that the use of the implementation's tracing or debugging facilities"
" may keep objects alive that would normally be collectable. Also note "
"that catching an exception with a :keyword:`try`...\\ :keyword:`except` "
"statement may keep objects alive."
msgstr ""
"구현이 제공하는 추적이나 디버깅 장치의 사용은 그렇지 않으면 수거될 수 있는 객체들을 살아있도록 만들 수 있음에 주의해야 합니다. "
"또한 ':keyword:`try`...\\ :keyword:`except`' 문으로 예외를 잡는 것도 객체를 살아있게 만들 수 "
"있습니다."

#: ../../reference/datamodel.rst:87
#, fuzzy
msgid ""
"Some objects contain references to \"external\" resources such as open "
"files or windows.  It is understood that these resources are freed when "
"the object is garbage-collected, but since garbage collection is not "
"guaranteed to happen, such objects also provide an explicit way to "
"release the external resource, usually a :meth:`!close` method. Programs "
"are strongly recommended to explicitly close such objects.  The "
":keyword:`try`...\\ :keyword:`finally` statement and the :keyword:`with` "
"statement provide convenient ways to do this."
msgstr ""
"어떤 객체들은 열린 파일이나 창 같은 \"외부(external)\" 자원들에 대한 참조를 포함합니다. 이 자원들은 객체가 가비지 "
"수거될 때 반납된다고 이해되지만, 가비지 수거는 보장되는 것이 아니므로, 그런 객체들은 외부자원을 반납하는 명시적인 방법 또한 "
"제공합니다. 보통 :meth:`close` 메서드다. 프로그램을 작성할 때는 그러한 객체들을 항상 명시적으로 닫아야(close) "
"합니다. ':keyword:`try`...\\ :keyword:`finally`' 문과 ':keyword:`with`' 문은 이렇게"
" 하는 편리한 방법을 제공합니다."

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries."
"  The references are part of a container's value.  In most cases, when we"
" talk about the value of a container, we imply the values, not the "
"identities of the contained objects; however, when we talk about the "
"mutability of a container, only the identities of the immediately "
"contained objects are implied.  So, if an immutable container (like a "
"tuple) contains a reference to a mutable object, its value changes if "
"that mutable object is changed."
msgstr ""
"어떤 객체들은 다른 객체에 대한 참조를 포함하고 있습니다. 이런 것들을 *컨테이너(container)* 라고 부릅니다. 튜플, "
"리스트, 딕셔너리등이 컨테이너의 예입니다. 이 참조들은 컨테이너의 값의 일부입니다. 대부분은, 우리가 컨테이너의 값을 논할 때는, "
"들어있는 객체들의 아이덴티티 보다는 값을 따집니다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 가진 객체들의 아이덴티티만을 "
"따집니다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 하고 있다면, 그 가변 객체가 변경되면 컨테이너의 값도 "
"변경됩니다."

#: ../../reference/datamodel.rst:106
#, fuzzy
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance "
"of object identity is affected in some sense: for immutable types, "
"operations that compute new values may actually return a reference to any"
" existing object with the same type and value, while for mutable objects "
"this is not allowed. For example, after ``a = 1; b = 1``, *a* and *b* may"
" or may not refer to the same object with the value one, depending on the"
" implementation. This is because :class:`int` is an immutable type, so "
"the reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be"
" aware of when making use of object identity tests. However, after ``c = "
"[]; d = []``, *c* and *d* are guaranteed to refer to two different, "
"unique, newly created empty lists. (Note that ``e = f = []`` assigns the "
"*same* object to both *e* and *f*.)"
msgstr ""
"형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 줍니다. 객체의 아이덴티디가 갖는 중요성조차도 어떤 면에서는 영향을 "
"받습니다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 "
"있습니다. 반면에 가변 객체에서는 이런 것이 허용되지 않습니다. 예를 들어, ``a = 1; b = 1`` 후에, ``a`` 와 "
"``b`` 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있습니다. 하지만 ``c = []; d = []`` 후에, "
"``c`` 와 ``d`` 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장됩니다. (``c = d = "
"[]`` 는 객은 객체를 ``c`` 와 ``d`` 에 대입합니다.)"

#: ../../reference/datamodel.rst:124
msgid "The standard type hierarchy"
msgstr "표준형 계층"

#: ../../reference/datamodel.rst:133
msgid ""
"Below is a list of the types that are built into Python.  Extension "
"modules (written in C, Java, or other languages, depending on the "
"implementation) can define additional types.  Future versions of Python "
"may add types to the type hierarchy (e.g., rational numbers, efficiently "
"stored arrays of integers, etc.), although such additions will often be "
"provided via the standard library instead."
msgstr ""
"아래에 파이썬에 내장된 형들의 목록이 있습니다. (구현에 따라 C 나 자바나 다른 언어로 작성된) 확장 모듈들은 추가의 형을 정의할"
" 수 있습니다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 (예를 들어, 유리수, 효율적으로 저장된 정수 배열 "
"등등), 표준 라이브러리를 통해 추가될 가능성이 더 크기는 합니다."

#: ../../reference/datamodel.rst:144
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the "
"implementation and are not intended for general use.  Their definition "
"may change in the future."
msgstr ""
"아래에 나오는 몇몇 형에 대한 설명은 '특수 어트리뷰트(special attribute)' 를 나열하는 문단을 포함합니다. 이것들은"
" 구현에 접근할 방법을 제공하는데, 일반적인 사용을 위한 것이 아닙니다. 정의는 앞으로 변경될 수 있습니다."

#: ../../reference/datamodel.rst:150 ../../reference/datamodel.rst:152
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to"
" signify the absence of a value in many situations, e.g., it is returned "
"from functions that don't explicitly return anything. Its truth value is "
"false."
msgstr ""
"이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 ``None`` 을 통해 "
"접근합니다. 여러 가지 상황에서 값의 부재를 알리는 데 사용됩니다. 예를 들어, 명시적으로 뭔가를 돌려주지 않는 함수의 반환 "
"값입니다. 논리값은 거짓입니다."

#: ../../reference/datamodel.rst:161 ../../reference/datamodel.rst:163
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:165
#, fuzzy
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`."
" Numeric methods and rich comparison methods should return this value if "
"they do not implement the operation for the operands provided.  (The "
"interpreter will then try the reflected operation, or some other "
"fallback, depending on the operator.)  It should not be evaluated in a "
"boolean context."
msgstr ""
"이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 "
"``NotImplemented`` 을 통해 접근합니다. 숫자 메서드(numeric method)와 비교(rich "
"comparison) 메서드는 제공된 피연산자에 대해 연산이 구현되지 않으면 이 값을 돌려줘야 합니다. (그러면 인터프리터는 "
"연산자에 따라 뒤집힌 연산이나, 어떤 다른 대안을 시도합니다.) 불리언 문맥에서 평가되지 않아야 합니다."

#: ../../reference/datamodel.rst:172
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "더 자세한 내용은 :ref:`implementing-the-arithmetic-operations` 을 참고하십시오."

#: ../../reference/datamodel.rst:176
#, fuzzy
msgid ""
"Evaluating :data:`NotImplemented` in a boolean context is deprecated. "
"While it currently evaluates as true, it will emit a "
":exc:`DeprecationWarning`. It will raise a :exc:`TypeError` in a future "
"version of Python."
msgstr ""
"불리언 문맥에서 ``NotImplemented``\\를 평가하는 것은 폐지되었습니다. 현재는 참으로 평가되지만, "
":exc:`DeprecationWarning`\\를 방출합니다. 향후 버전의 파이썬에서는 :exc:`TypeError`\\를 "
"발생시킬 것입니다."

#: ../../reference/datamodel.rst:183 ../../reference/datamodel.rst:184
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:188
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 리터럴 ``...`` 이나 내장된 이름 "
"``Ellipsis`` 을 통해 접근합니다. 논리값은 참입니다. "

#: ../../reference/datamodel.rst:194
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:198
msgid ""
"These are created by numeric literals and returned as results by "
"arithmetic operators and arithmetic built-in functions.  Numeric objects "
"are immutable; once created their value never changes.  Python numbers "
"are of course strongly related to mathematical numbers, but subject to "
"the limitations of numerical representation in computers."
msgstr ""
"이것들은 숫자 리터럴에 의해 만들어지고, 산술 연산과 내장 산술 함수들이 결과로 돌려줍니다. 숫자 객체는 불변입니다; 한 번 값이 "
"만들어지면 절대 변하지 않습니다. 파이썬의 숫자는 당연히 수학적인 숫자들과 밀접하게 관련되어 있습니다, 하지만 컴퓨터의 숫자 "
"표현상의 제약을 받고 있습니다."

#: ../../reference/datamodel.rst:204
#, fuzzy
msgid ""
"The string representations of the numeric classes, computed by "
":meth:`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
":meth:`__repr__`\\과 :meth:`__str__`\\로 계산되는 숫자 클래스의 문자열 표현에는 다음과 같은 특성이 "
"있습니다:"

#: ../../reference/datamodel.rst:208
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr "클래스 생성자에 전달될 때 원래 숫자 값을 가진 객체를 생성하는 유효한 숫자 리터럴 입니다."

#: ../../reference/datamodel.rst:212
msgid "The representation is in base 10, when possible."
msgstr "가능하면, 표현은 10진법입니다."

#: ../../reference/datamodel.rst:214
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, "
"are not shown."
msgstr "소수점 앞의 단일 0을 제외하고, 선행 0은 표시되지 않습니다."

#: ../../reference/datamodel.rst:217
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, "
"are not shown."
msgstr "소수점 뒤의 단일 0을 제외하고, 후행 0은 표시되지 않습니다."

#: ../../reference/datamodel.rst:220
msgid "A sign is shown only when the number is negative."
msgstr "부호는 숫자가 음수일 때만 표시됩니다."

#: ../../reference/datamodel.rst:222
#, fuzzy
msgid ""
"Python distinguishes between integers, floating-point numbers, and "
"complex numbers:"
msgstr "파이썬은 정수, 실수, 복소수를 구분합니다:"

#: ../../reference/datamodel.rst:227
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../../reference/datamodel.rst:231
msgid ""
"These represent elements from the mathematical set of integers (positive "
"and negative)."
msgstr "이것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타냅니다."

#: ../../reference/datamodel.rst:237
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative"
" integers."
msgstr "정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미 있는 해석을 제공하기 위한 것입니다."

#: ../../reference/datamodel.rst:240
msgid "There are two types of integers:"
msgstr "두 가지 종류의 정수가 있습니다:"

#: ../../reference/datamodel.rst:242
msgid "Integers (:class:`int`)"
msgstr "정수 (:class:`int`)"

#: ../../reference/datamodel.rst:243
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in"
" a variant of 2's complement which gives the illusion of an infinite "
"string of sign bits extending to the left."
msgstr ""
"이것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현합니다. 시프트(shift)와 마스크(mask) 연산이 목적일 "
"때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2's complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된"
" 것과 같은 효과를 줍니다."

#: ../../reference/datamodel.rst:249
msgid "Booleans (:class:`bool`)"
msgstr "불린 (:class:`bool`)"

#: ../../reference/datamodel.rst:255
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean "
"objects. The Boolean type is a subtype of the integer type, and Boolean "
"values behave like the values 0 and 1, respectively, in almost all "
"contexts, the exception being that when converted to a string, the "
"strings ``\"False\"`` or ``\"True\"`` are returned, respectively."
msgstr ""
"이것은 논리값 거짓과 참을 나타냅니다. ``False`` 와 ``True`` 두 객체만 불린 형 객체입니다. 불린 형은 int 형의"
" 자식형(subtype)이고, 대부분 상황에서 각기 0과1처럼 동작합니다. 예외는 문자열로 변환되는 경우인데, 각기 문자열 "
"``\"False\"`` 와 ``\"True\"`` 가 반환됩니다."

#: ../../reference/datamodel.rst:263
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:271
#, fuzzy
msgid ""
"These represent machine-level double precision floating-point numbers. "
"You are at the mercy of the underlying machine architecture (and C or "
"Java implementation) for the accepted range and handling of overflow. "
"Python does not support single-precision floating-point numbers; the "
"savings in processor and memory usage that are usually the reason for "
"using these are dwarfed by the overhead of using objects in Python, so "
"there is no reason to complicate the language with two kinds of floating-"
"point numbers."
msgstr ""
"이것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타냅니다. 허락되는 값의 범위와 오버플로의 처리에 "
"관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수밖에 없습니다. 파이썬은 단정도(single precision) 부동 "
"소수점 수를 지원하지 않습니다; 이것들을 사용하는 이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 "
"비용과 상쇄되어 미미해집니다. 그 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없습니다."

#: ../../reference/datamodel.rst:281
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:287
#, fuzzy
msgid ""
"These represent complex numbers as a pair of machine-level double "
"precision floating-point numbers.  The same caveats apply as for "
"floating-point numbers. The real and imaginary parts of a complex number "
"``z`` can be retrieved through the read-only attributes ``z.real`` and "
"``z.imag``."
msgstr ""
"이것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타냅니다. 부동 소수점 수와 한계와 문제점을 공유합니다. 복소수 "
"``z`` 의 실수부와 허수부는, 읽기 전용 어트리뷰트 ``z.real`` 와 ``z.imag`` 로 꺼낼 수 있습니다."

#: ../../reference/datamodel.rst:294
msgid "Sequences"
msgstr "시퀀스들"

#: ../../reference/datamodel.rst:303
#, fuzzy
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers "
"0, 1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some"
" sequences, including built-in sequences, interpret negative subscripts "
"by adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, "
"the second to last item of sequence a with length ``n``."
msgstr ""
"음이 아닌 정수로 인덱싱(indexing)될 수 있는 유한한 길이의 순서 있는 집합을 나타냅니다. 내장함수 :func:`len` 은"
" 시퀀스가 가진 항목들의 개수를 돌려줍니다. 시퀀스의 길이가 *n* 일 때, 인덱스(index) 집합은 숫자 0, 1, ..., "
"*n*-1을 포함합니다. 시퀀스 *a* 의 항목 *i* 는 ``a[i]`` 로 선택됩니다."

#: ../../reference/datamodel.rst:313
#, fuzzy
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index "
"*k* such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a "
"slice is a sequence of the same type. The comment above about negative "
"indexes also applies to negative slice positions."
msgstr ""
"시퀀스는 슬라이싱도 지원합니다: ``a[i:j]`` 는 *i* ``<=`` *k* ``<`` *j* 를 만족하는 모든 항목 *k* "
"를 선택합니다. 표현식에서 사용될 때, 슬라이스는 같은 형의 시퀀스입니다. 인덱스 집합은 0에서 시작되도록 다시 번호 매겨집니다."

#: ../../reference/datamodel.rst:318
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x"
" = i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"어떤 시퀀스는 세 번째 \"스텝(step)\" 매개변수를 사용하는 \"확장 슬라이싱(extended slicing)\"도 "
"지원합니다: ``a[i:j:k]`` 는 ``x = i + n*k``, *n* ``>=`` ``0``, *i* ``<=`` *x* "
"``<`` *j* 를 만족하는 모든 항목 *x* 를 선택합니다."

#: ../../reference/datamodel.rst:322
msgid "Sequences are distinguished according to their mutability:"
msgstr "시퀀스는 불변성에 따라 구분됩니다"

#: ../../reference/datamodel.rst:326
msgid "Immutable sequences"
msgstr "불변 시퀀스"

#: ../../reference/datamodel.rst:332
msgid ""
"An object of an immutable sequence type cannot change once it is created."
"  (If the object contains references to other objects, these other "
"objects may be mutable and may be changed; however, the collection of "
"objects directly referenced by an immutable object cannot change.)"
msgstr ""
"불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없습니다. (만약 다른 객체로의 참조를 포함하면, 그 객체는 가변일 수 "
"있고, 변경될 수 있습니다; 하지만, 불변 객체로부터 참조되는 객체의 집합 자체는 변경될 수 없습니다.)"

#: ../../reference/datamodel.rst:337
msgid "The following types are immutable sequences:"
msgstr "다음과 같은 형들은 불변 시퀀스입니다:"

#: ../../reference/datamodel.rst:342
msgid "Strings"
msgstr "문자열(Strings)"

#: ../../reference/datamodel.rst:350
#, fuzzy
msgid ""
"A string is a sequence of values that represent Unicode code points. All "
"the code points in the range ``U+0000 - U+10FFFF`` can be represented in "
"a string.  Python doesn't have a :c:expr:`char` type; instead, every code"
" point in the string is represented as a string object with length ``1``."
"  The built-in function :func:`ord` converts a code point from its string"
" form to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an "
"integer in the range ``0 - 10FFFF`` to the corresponding length ``1`` "
"string object. :meth:`str.encode` can be used to convert a :class:`str` "
"to :class:`bytes` using the given text encoding, and :meth:`bytes.decode`"
" can be used to achieve the opposite."
msgstr ""
"문자열은 유니코드 코드 포인트(Unicode code point)들을 표현하는 값들의 시퀀스입니다. ``U+0000 - "
"U+10FFFF`` 범위의 모든 코드 포인트들은 문자열로 표현될 수 있습니다. 파이썬에는 :c:type:`char` 형이 없습니다."
" 대신에 문자열에 있는 각 코드 포인트는 길이 ``1`` 인 문자열 객체로 표현됩니다. 내장 함수 :func:`ord` 는 코드 "
"포인트를 문자열 형식에서 ``0 - 10FFFF`` 범위의 정수로 변환합니다; :func:`chr` 은 범위 ``0 - "
"10FFFF`` 의 정수를 해당하는 길이 ``1`` 의 문자열 객체로 변환합니다. :meth:`str.encode` 는 주어진 "
"텍스트 인코딩을 사용해서 :class:`str` 을 :class:`bytes` 로 변환하고, :meth:`bytes.decode` "
"는 그 반대 작업을 수행합니다."

#: ../../reference/datamodel.rst:362
msgid "Tuples"
msgstr "튜플(Tuples)"

#: ../../reference/datamodel.rst:368
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one"
" item (a 'singleton') can be formed by affixing a comma to an expression "
"(an expression by itself does not create a tuple, since parentheses must "
"be usable for grouping of expressions).  An empty tuple can be formed by "
"an empty pair of parentheses."
msgstr ""
"튜플의 항목은 임의의 파이썬 객체입니다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 목록으로 만들 수 있습니다."
" 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 붙여서 만들 수 있습니다(괄호로 표현식을 묶을 수 "
"있으므로, 표현식 만으로는 튜플을 만들지 않습니다). 빈 튜플은 한 쌍의 빈 괄호로 만들 수 있습니다."

#: ../../reference/datamodel.rst:375
msgid "Bytes"
msgstr "바이트열(Bytes)"

#: ../../reference/datamodel.rst:378
#, fuzzy
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"바이트열(bytes) 객체는 불변 배열입니다. 항목은 8-비트 바이트인데, 0 <= x < 256 범위의 정수로 표현됩니다. 바이트"
" 객체를 만들 때는 바이트열 리터럴(``b'abc'`` 와 같은) 과 내장 :func:`bytes()` "
"생성자(constructor)를 사용할 수 있습니다. 또한, 바이트열 객체는 :meth:`~bytes.decode` 메서드를 통해 "
"문자열로 디코딩될 수 있습니다."

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "가변 시퀀스"

#: ../../reference/datamodel.rst:395
msgid ""
"Mutable sequences can be changed after they are created.  The "
"subscription and slicing notations can be used as the target of "
"assignment and :keyword:`del` (delete) statements."
msgstr ""
"가변 시퀀스는 만들어진 후에 변경될 수 있습니다. 서브스크립션(subscription)과 슬라이싱은 대입문과 "
":keyword:`del` (삭제) 문의 대상으로 사용될 수 있습니다."

#: ../../reference/datamodel.rst:403
msgid ""
"The :mod:`collections` and :mod:`array` module provide additional "
"examples of mutable sequence types."
msgstr ""

#: ../../reference/datamodel.rst:406
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "현재 두 개의 내장 가변 시퀀스형이 있습니다:"

#: ../../reference/datamodel.rst:408
msgid "Lists"
msgstr "리스트(Lists)"

#: ../../reference/datamodel.rst:411
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note "
"that there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"리스트의 항목은 임의의 파이썬 객체입니다. 리스트는 콤마로 분리된 표현식을 대괄호 안에 넣어서 만들 수 있습니다. (길이 0이나 "
"1의 리스트를 만드는데 별도의 규칙이 필요 없습니다.)"

#: ../../reference/datamodel.rst:415
msgid "Byte Arrays"
msgstr "바이트 배열(Byte Arrays)"

#: ../../reference/datamodel.rst:418
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"바이트 배열(bytearray) 객체는 가변 배열입니다. 내장 :func:`bytearray` 생성자로 만들어집니다. 가변이라는 "
"것(그래서 해싱 불가능하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( :class:`bytes`) 객체와 같은 인터페이스와 "
"기능을 제공합니다."

#: ../../reference/datamodel.rst:425
msgid "Set types"
msgstr "집합 형들(Set types)"

#: ../../reference/datamodel.rst:431
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be "
"iterated over, and the built-in function :func:`len` returns the number "
"of items in a set. Common uses for sets are fast membership testing, "
"removing duplicates from a sequence, and computing mathematical "
"operations such as intersection, union, difference, and symmetric "
"difference."
msgstr ""
"이것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타냅니다. 인덱싱할 수 없습니다. 하지만 이터레이트할 수 있고, 내장 "
"함수 :func:`len` 은 집합 안에 있는 항목들의 개수를 돌려줍니다. 집합의 일반적인 용도는 빠른 멤버십 검사(fast "
"membership testing), 시퀀스에서 중복된 항목 제거, 교집합(intersection), 합집합(union), "
"차집합(difference), 대칭차집합(symmetric difference)과 같은 집합 연산을 계산하는 것입니다."

#: ../../reference/datamodel.rst:438
msgid ""
"For set elements, the same immutability rules apply as for dictionary "
"keys. Note that numeric types obey the normal rules for numeric "
"comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``), only "
"one of them can be contained in a set."
msgstr ""
"집합의 원소들에는 딕셔너리 키와 같은 불변성 규칙이 적용됩니다. 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다는 점에 "
"주의해야 합니다: 만약 두 숫자가 같다고 비교되면(예를 들어, ``1`` 과 ``1.0``), 그중 하나만 집합에 들어갈 수 "
"있습니다."

#: ../../reference/datamodel.rst:443
msgid "There are currently two intrinsic set types:"
msgstr "현재 두 개의 내장 집합 형이 있습니다:"

#: ../../reference/datamodel.rst:446
msgid "Sets"
msgstr "집합(Sets)"

#: ../../reference/datamodel.rst:449
msgid ""
"These represent a mutable set. They are created by the built-in "
":func:`set` constructor and can be modified afterwards by several "
"methods, such as :meth:`~set.add`."
msgstr ""
"이것들은 가변 집합을 나타냅니다. 내장 :func:`set` 생성자로 만들 수 있고, :meth:`~set.add` 같은 메서드들을"
" 사용해서 나중에 수정할 수 있습니다."

#: ../../reference/datamodel.rst:454
msgid "Frozen sets"
msgstr "불변 집합(Frozen sets)"

#: ../../reference/datamodel.rst:457
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or "
"as a dictionary key."
msgstr ""
"이것들은 불변 집합을 나타냅니다. 내장 :func:`frozenset` 생성자로 만들 수 있습니다. 불변 집합(frozenset)은"
" 불변이고 :term:`해시 가능 <hashable>` 하므로, 다른 집합의 원소나, 딕셔너리의 키로 사용될 수 있습니다."

#: ../../reference/datamodel.rst:464
msgid "Mappings"
msgstr "매핑(Mappings)"

#: ../../reference/datamodel.rst:471
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. "
"The subscript notation ``a[k]`` selects the item indexed by ``k`` from "
"the mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function "
":func:`len` returns the number of items in a mapping."
msgstr ""
"이것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 인덱스 표기법(subscript notation) "
"``a[k]`` 는 매핑 ``a`` 에서 ``k`` 로 인덱스 되는 항목을 선택합니다; 이것은 표현식에 사용될 수도 있고, 대입이나"
" :keyword:`del` 문장의 대상이 될 수도 있습니다. 내장 함수 :func:`len` 은 매핑에 포함된 항목들의 개수를 "
"돌려줍니다."

#: ../../reference/datamodel.rst:477
msgid "There is currently a single intrinsic mapping type:"
msgstr "현재 한 개의 내장 매핑 형이 있습니다:"

#: ../../reference/datamodel.rst:481
msgid "Dictionaries"
msgstr "딕셔너리(Dictionaries)"

#: ../../reference/datamodel.rst:485
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary "
"values.  The only types of values not acceptable as keys are values "
"containing lists or dictionaries or other mutable types that are compared"
" by value rather than by object identity, the reason being that the "
"efficient implementation of dictionaries requires a key's hash value to "
"remain constant. Numeric types used for keys obey the normal rules for "
"numeric comparison: if two numbers compare equal (e.g., ``1`` and "
"``1.0``) then they can be used interchangeably to index the same "
"dictionary entry."
msgstr ""
"이것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 키로 사용할 수 없는 것들은 리스트, 딕셔너리나"
" 그 외의 가변형 중에서 아이덴티티가 아니라 값으로 비교되는 것들뿐입니다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 "
"변경되지 않고 계속 같은 값으로 유지되도록 요구하고 있기 때문입니다. 키로 사용되는 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이"
" 적용됩니다: 만약 두 숫자가 같다고 비교되면(예를 들어, ``1`` 과 ``1.0``), 둘 다 같은 딕셔너리 항목을 인덱싱하는데"
" 사용될 수 있습니다."

#: ../../reference/datamodel.rst:494
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced"
" in the same order they were added sequentially over the dictionary. "
"Replacing an existing key does not change the order, however removing a "
"key and re-inserting it will add it to the end instead of keeping its old"
" place."
msgstr ""
"딕셔너리는 삽입 순서를 유지합니다, 키가 딕셔너리에 순차적으로 추가된 순서와 같은 순서로 생성됨을 뜻합니다. 기존 키를 교체해도 "
"순서는 변경되지 않지만, 키를 제거했다가 다시 삽입하면 이전 위치를 유지하는 대신 끝에 추가됩니다."

#: ../../reference/datamodel.rst:499
#, fuzzy, python-brace-format
msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see"
" section :ref:`dict`)."
msgstr "딕셔너리는 가변입니다; ``{...}`` 표기법으로 만들 수 있습니다 (:ref:`dict` 섹션을 참고하십시오)."

#: ../../reference/datamodel.rst:506
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide "
"additional examples of mapping types, as does the :mod:`collections` "
"module."
msgstr ""
"확장 모듈 :mod:`dbm.ndbm` 과 :mod:`dbm.gnu` 는 추가의 매핑 형을 제공하는데, "
":mod:`collections` 모듈 역시 마찬가지입니다."

#: ../../reference/datamodel.rst:510
msgid ""
"Dictionaries did not preserve insertion order in versions of Python "
"before 3.6. In CPython 3.6, insertion order was preserved, but it was "
"considered an implementation detail at that time rather than a language "
"guarantee."
msgstr ""
"딕셔너리는 3.6 이전의 파이썬 버전에서 삽입 순서를 유지하지 않았습니다. CPython 3.6에서, 삽입 순서가 유지되었지만, 그"
" 시점에는 언어 보증이 아니라 구현 세부 사항으로 간주하였습니다."

#: ../../reference/datamodel.rst:517
msgid "Callable types"
msgstr "콜러블(Callable types)"

#: ../../reference/datamodel.rst:525
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr "이것들은 함수 호출 연산(:ref:`calls` 섹션 참고)이 적용될 수 있는 형들입니다:"

#: ../../reference/datamodel.rst:532
msgid "User-defined functions"
msgstr "사용자 정의 함수"

#: ../../reference/datamodel.rst:539
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter "
"list."
msgstr ""
"사용자 정의 함수 객체는 함수 정의를 통해 만들어집니다 (:ref:`function` 섹션 참고). 함수의 형식 "
"매개변수(formal parameter) 목록과 같은 개수의 항목을 포함하는 인자(argument) 목록으로 호출되어야 합니다."

#: ../../reference/datamodel.rst:545 ../../reference/datamodel.rst:1395
#: ../../reference/datamodel.rst:1596
#, fuzzy
msgid "Special read-only attributes"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../../reference/datamodel.rst:555 ../../reference/datamodel.rst:590
#: ../../reference/datamodel.rst:1170
msgid "Attribute"
msgstr "어트리뷰트"

#: ../../reference/datamodel.rst:556 ../../reference/datamodel.rst:591
#: ../../reference/datamodel.rst:1171
msgid "Meaning"
msgstr "의미"

#: ../../reference/datamodel.rst:559
#, fuzzy
msgid ""
"A reference to the :class:`dictionary <dict>` that holds the function's "
":ref:`global variables <naming>` -- the global namespace of the module in"
" which the function was defined."
msgstr "함수의 전역 변수들을 가진 딕셔너리에 대한 참조 --- 함수가 정의된 모듈의 전역 이름 공간(namespace)"

#: ../../reference/datamodel.rst:564
msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the names"
" specified in the :attr:`~codeobject.co_freevars` attribute of the "
"function's :attr:`code object <function.__code__>`."
msgstr ""

#: ../../reference/datamodel.rst:568
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to "
"get the value of the cell, as well as set the value."
msgstr ""
"셀 객체는 ``cell_contents`` 어트리뷰트를 가지고 있습니다. 셀의 값을 읽을 뿐만 아니라 값을 설정하는 데도 사용할 수"
" 있습니다."

#: ../../reference/datamodel.rst:572 ../../reference/datamodel.rst:1638
#, fuzzy
msgid "Special writable attributes"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../../reference/datamodel.rst:585
#, fuzzy
msgid "Most of these attributes check the type of the assigned value:"
msgstr "\"쓰기 가능\" 하다고 표시된 대부분의 어트리뷰트들은 값이 대입될 때 형을 검사합니다."

#: ../../reference/datamodel.rst:594
#, fuzzy
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr "함수를 설명하는 문자열 또는 없는 경우 ``None``; 서브 클래스로 상속되지 않습니다."

#: ../../reference/datamodel.rst:597
msgid ""
"The function's name. See also: :attr:`__name__ attributes "
"<definition.__name__>`."
msgstr ""

#: ../../reference/datamodel.rst:601
msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""

#: ../../reference/datamodel.rst:607
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "함수가 정의된 모듈의 이름 또는 (없는 경우) ``None``"

#: ../../reference/datamodel.rst:611
#, fuzzy
msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a "
"default value."
msgstr "인자의 기본값 또는 (없는 경우) `None` 으로 만들어진 튜플."

#: ../../reference/datamodel.rst:616
#, fuzzy
msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr "컴파일된 함수의 바디(body) 를 나타내는 코드 객체"

#: ../../reference/datamodel.rst:620
#, fuzzy
msgid ""
"The namespace supporting arbitrary function attributes. See also: "
":attr:`__dict__ attributes <object.__dict__>`."
msgstr "임의의 함수 어트리뷰트를 지원하는 이름 공간."

#: ../../reference/datamodel.rst:624
#, fuzzy
msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See also: :ref"
":`annotations-howto`."
msgstr ""
"매개변수의 어노테이션을 가진 dict. dict의 키는 매개변수의 이름인데, 반환 값 어노테이션이 있다면 ``'return'`` 을"
" 키로 사용합니다."

#: ../../reference/datamodel.rst:631
#, fuzzy
msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-only "
":term:`parameters <parameter>`."
msgstr "키워드 형태로만 전달 가능한 매개변수들의 기본값을 가진 dict."

#: ../../reference/datamodel.rst:635
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a"
" :ref:`generic function <generic-functions>`."
msgstr ""

#: ../../reference/datamodel.rst:640
#, fuzzy
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular"
" attribute dot-notation is used to get and set such attributes."
msgstr ""
"함수 객체는 임의의 어트리뷰트를 읽고 쓸 수 있도록 지원하는데, 예를 들어 함수에 메타데이터(metadata)를 붙이는데 사용될 수"
" 있습니다. 어트리뷰트를 읽거나 쓸 때는 일반적인 점 표현법(dot-notation)이 사용됩니다. *현재 구현은 오직 사용자 정의"
" 함수만 함수 어트리뷰트를 지원함에 주의해야 합니다. 내장 함수의 함수 어트리뷰트는 미래에 지원될 수 있습니다.*"

#: ../../reference/datamodel.rst:646
msgid ""
"CPython's current implementation only supports function attributes on "
"user-defined functions. Function attributes on :ref:`built-in functions "
"<builtin-functions>` may be supported in the future."
msgstr ""

#: ../../reference/datamodel.rst:651
msgid ""
"Additional information about a function's definition can be retrieved "
"from its :ref:`code object <code-objects>` (accessible via the "
":attr:`~function.__code__` attribute)."
msgstr ""

#: ../../reference/datamodel.rst:659
msgid "Instance methods"
msgstr "인스턴스 메서드(Instance methods)"

#: ../../reference/datamodel.rst:666
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr "인스턴스 메서드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합합니다."

#: ../../reference/datamodel.rst:676 ../../reference/datamodel.rst:1734
#, fuzzy
msgid "Special read-only attributes:"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../../reference/datamodel.rst:681
msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr ""

#: ../../reference/datamodel.rst:685
msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr ""

#: ../../reference/datamodel.rst:688
msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ "
"<function.__doc__>`). A :class:`string <str>` if the original function "
"had a docstring, else ``None``."
msgstr ""

#: ../../reference/datamodel.rst:694
msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ "
"<function.__name__>`)"
msgstr ""

#: ../../reference/datamodel.rst:698
#, fuzzy
msgid ""
"The name of the module the method was defined in, or ``None`` if "
"unavailable."
msgstr "함수가 정의된 모듈의 이름 또는 (없는 경우) ``None``"

#: ../../reference/datamodel.rst:701
#, fuzzy
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr "메서드는 기반 함수의 모든 함수 어트리뷰트들을 읽을 수 있도록 지원합니다(하지만 쓰기는 지원하지 않습니다)."

#: ../../reference/datamodel.rst:704
#, fuzzy
msgid ""
"User-defined method objects may be created when getting an attribute of a"
" class (perhaps via an instance of that class), if that attribute is a "
"user-defined :ref:`function object <user-defined-funcs>` or a "
":class:`classmethod` object."
msgstr ""
"어트리뷰트가 사용자 정의 함수 객체이거나 클래스 메서드 객체면, 사용자 정의 메서드 객체는 클래스의 어트리뷰트를 읽을 때 만들어질 "
"수 있습니다 (아마도 그 클래스의 인스턴스를 통해서)."

#: ../../reference/datamodel.rst:711
#, fuzzy
msgid ""
"When an instance method object is created by retrieving a user-defined "
":ref:`function object <user-defined-funcs>` from a class via one of its "
"instances, its :attr:`~method.__self__` attribute is the instance, and "
"the method object is said to be *bound*.  The new method's "
":attr:`~method.__func__` attribute is the original function object."
msgstr ""
"인스턴스 메서드 객체가 클래스 인스턴스를 통해 클래스의 사용자 정의 함수 객체를 읽음으로써 만들어질 때, "
":attr:`__self__` 어트리뷰트는 인스턴스이고, 메서드 객체는 결합(bound)하였다고 말합니다. 새 메서드의 "
":attr:`__func__` 어트리뷰트는 원래의 함수 객체입니다."

#: ../../reference/datamodel.rst:717
#, fuzzy
msgid ""
"When an instance method object is created by retrieving a "
":class:`classmethod` object from a class or instance, its "
":attr:`~method.__self__` attribute is the class itself, and its "
":attr:`~method.__func__` attribute is the function object underlying the "
"class method."
msgstr ""
"인스턴스 메서드 객체가 클래스나 인스턴스로부터 클래스 메서드 객체를 읽음으로써 만들어질 때, :attr:`__self__` "
"어트리뷰트는 클래스 자신이고, :attr:`__func__` 어트리뷰트는 클래스 메서드가 기반을 두는 함수 객체입니다."

#: ../../reference/datamodel.rst:722
#, fuzzy
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`~method.__func__`) is called, inserting the class instance "
"(:attr:`~method.__self__`) in front of the argument list.  For instance, "
"when :class:`!C` is a class which contains a definition for a function "
":meth:`!f`, and ``x`` is an instance of :class:`!C`, calling ``x.f(1)`` "
"is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"인스턴스 메서드 객체가 호출될 때, 기반을 두는 함수 (:attr:`__func__`) 가 호출되는데, 인자 목록의 앞에 클래스 "
"인스턴스 (:attr:`__self__`) 가 삽입됩니다. 예를 들어, :class:`C` 가 함수 :meth:`f` 의 정의를 "
"포함하는 클래스이고, ``x`` 가 :class:`C` 의 인스턴스일 때, ``x.f(1)`` 를 호출하는 것은 ``C.f(x, "
"1)`` 을 호출하는 것과 같습니다."

#: ../../reference/datamodel.rst:729
#, fuzzy
msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or "
"``C.f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the "
"underlying function."
msgstr ""
"인스턴스 메서드 객체가 클래스 메서드 객체로부터 올 때, :attr:`__self__` 에 저장된 \"클래스 인스턴스\" 는 "
"실제로는 클래스 자신입니다. 그래서 ``x.f(1)`` 이나 ``C.f(1)`` 을 호출하는 것은 ``f(C,1)`` 를 호출하는 "
"것과 같습니다 (``f`` 는 기반 함수입니다)."

#: ../../reference/datamodel.rst:734
msgid ""
"It is important to note that user-defined functions which are attributes "
"of a class instance are not converted to bound methods; this *only* "
"happens when the function is an attribute of the class."
msgstr ""

#: ../../reference/datamodel.rst:741
msgid "Generator functions"
msgstr "제너레이터 함수(Generator functions)"

#: ../../reference/datamodel.rst:747
#, fuzzy
msgid ""
"A function or method which uses the :keyword:`yield` statement (see "
"section :ref:`yield`) is called a :dfn:`generator function`.  Such a "
"function, when called, always returns an :term:`iterator` object which "
"can be used to execute the body of the function:  calling the iterator's "
":meth:`iterator.__next__` method will cause the function to execute until"
" it provides a value using the :keyword:`!yield` statement.  When the "
"function executes a :keyword:`return` statement or falls off the end, a "
":exc:`StopIteration` exception is raised and the iterator will have "
"reached the end of the set of values to be returned."
msgstr ""
":keyword:`yield` 문(:ref:`yield` 절 참조)을 사용하는 함수나 메서드를 :dfn:`제너레이터 함수 "
"(generator function)` 라고 부릅니다. 이런 함수를 호출하면 항상 이터레이터(iterator) 객체를 돌려주는데, "
"함수의 바디(body)를 실행하는 데 사용됩니다: 이터레이터의 :meth:`iterator.__next__` 메서드를 호출하면 "
":keyword:`!yield` 문이 값을 제공할 때까지 함수가 실행됩니다. 함수가 :keyword:`return` 문을 실행하거나"
" 끝에 도달하면 :exc:`StopIteration` 예외를 일으키고, 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다."

#: ../../reference/datamodel.rst:759
msgid "Coroutine functions"
msgstr "코루틴 함수(Coroutine functions)"

#: ../../reference/datamodel.rst:764
msgid ""
"A function or method which is defined using :keyword:`async def` is "
"called a :dfn:`coroutine function`.  Such a function, when called, "
"returns a :term:`coroutine` object.  It may contain :keyword:`await` "
"expressions, as well as :keyword:`async with` and :keyword:`async for` "
"statements. See also the :ref:`coroutine-objects` section."
msgstr ""
":keyword:`async def` 를 사용해서 정의되는 함수나 메서드를 :dfn:`코루틴 함수 (coroutine "
"function)` 라고 부릅니다. 이런 함수를 호출하면 :term:`코루틴 <coroutine>` 객체를 돌려줍니다. "
":keyword:`await` 표현식을 비롯해, :keyword:`async with` 와 :keyword:`async for` "
"문을 사용할 수 있습니다. :ref:`coroutine-objects` 섹션을 참조하십시오."

#: ../../reference/datamodel.rst:772
msgid "Asynchronous generator functions"
msgstr "비동기 제너레이터 함수(Asynchronous generator functions)"

#: ../../reference/datamodel.rst:778
#, fuzzy
msgid ""
"A function or method which is defined using :keyword:`async def` and "
"which uses the :keyword:`yield` statement is called a :dfn:`asynchronous "
"generator function`.  Such a function, when called, returns an "
":term:`asynchronous iterator` object which can be used in an "
":keyword:`async for` statement to execute the body of the function."
msgstr ""
":keyword:`async def` 를 사용해서 정의되는 함수가 :keyword:`yield` 문을 사용하면 :dfn:`비동기 "
"제너레이터 함수 (asynchronous generator function)` 라고 부릅니다. 이런 함수를 호출하면 항상 비동기 "
"이터레이터(asynchronous iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하기 위해 "
":keyword:`async for` 문에서 사용됩니다."

#: ../../reference/datamodel.rst:784
#, fuzzy
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ "
"<object.__anext__>` method will return an :term:`awaitable` which when "
"awaited will execute until it provides a value using the :keyword:`yield`"
" expression.  When the function executes an empty :keyword:`return` "
"statement or falls off the end, a :exc:`StopAsyncIteration` exception is "
"raised and the asynchronous iterator will have reached the end of the set"
" of values to be yielded."
msgstr ""
"비동기 이터레이터의 :meth:`aiterator.__anext__` 메서드를 호출하면 :term:`어웨이터블 "
"<awaitable>` 을 돌려주는데, await 할 때 :keyword:`yield` 문이 값을 제공할 때까지 함수가 실행됩니다."
" 함수가 빈 :keyword:`return` 문을 실행하거나 끝에 도달하면 :exc:`StopAsyncIteration` 예외를 "
"일으키고, 비동기 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다."

#: ../../reference/datamodel.rst:797
msgid "Built-in functions"
msgstr "내장 함수(Built-in functions)"

#: ../../reference/datamodel.rst:804
#, fuzzy
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of"
" built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is "
"a standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""
"내장 함수 객체는 C 함수를 둘러싸고 있습니다(wrapper). 내장 함수의 예로는 :func:`len` 과 "
":func:`math.sin` (:mod:`math` 는 표준 내장 모듈입니다) 가 있습니다. 인자의 개수와 형은 C 함수에 의해 "
"결정됩니다. 특수 읽기 전용 어트리뷰트들: :attr:`__doc__` 은 함수의 설명 문자열 또는 없는 경우 ``None`` "
"입니다; :attr:`~definition.__name__` 은 함수의 이름입니다; :attr:`__self__` 는 "
"``None`` 으로 설정됩니다 (하지만 다음 항목을 보십시오); :attr:`__module__` 은 함수가 정의된 모듈의 "
"이름이거나 없는 경우 ``None`` 입니다."

#: ../../reference/datamodel.rst:809
#, fuzzy
msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr "함수를 설명하는 문자열 또는 없는 경우 ``None``; 서브 클래스로 상속되지 않습니다."

#: ../../reference/datamodel.rst:811
msgid ":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ""

#: ../../reference/datamodel.rst:812
msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ""

#: ../../reference/datamodel.rst:813
#, fuzzy
msgid ""
":attr:`!__module__` is the name of the module the function was defined in"
" or ``None`` if unavailable. See :attr:`function.__module__`."
msgstr "함수가 정의된 모듈의 이름 또는 (없는 경우) ``None``"

#: ../../reference/datamodel.rst:821
msgid "Built-in methods"
msgstr "내장 메서드(Built-in methods)"

#: ../../reference/datamodel.rst:828
#, fuzzy
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, "
"assuming *alist* is a list object. In this case, the special read-only "
"attribute :attr:`!__self__` is set to the object denoted by *alist*. (The"
" attribute has the same semantics as it does with :attr:`other instance "
"methods <method.__self__>`.)"
msgstr ""
"이것은 사실 내장 함수의 다른 모습입니다. 이번에는 묵시적인 추가의 인자로 C 함수에 전달되는 객체를 갖고 있습니다. 내장 메서드의"
" 예로는 ``alist.append()`` 가 있는데, *alist* 는 리스트 객체입니다. 이 경우에, 특수 읽기 전용 어트리뷰트"
" :attr:`__self__` 는 *alist* 로 표현된 객체로 설정됩니다."

#: ../../reference/datamodel.rst:838
msgid "Classes"
msgstr "클래스(Classes)"

#: ../../reference/datamodel.rst:840
#, fuzzy
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that"
" override :meth:`~object.__new__`.  The arguments of the call are passed "
"to :meth:`!__new__` and, in the typical case, to :meth:`~object.__init__`"
" to initialize the new instance."
msgstr ""
"클래스는 콜러블입니다. 이 객체들은 보통 자신의 새로운 인스턴스를 만드는 팩토리(factory)로 동작하는데, "
":meth:`__new__` 메서드를 재정의(override)하는 클래스 형에서는 달라질 수도 있습니다. 호출 인자는 "
":meth:`__new__` 로 전달되고, 일반적으로, 새 인스턴스를 초기화하기 위해 :meth:`__init__` 로도 "
"전달됩니다."

#: ../../reference/datamodel.rst:848
msgid "Class Instances"
msgstr "클래스 인스턴스(Class Instances)"

#: ../../reference/datamodel.rst:850
#, fuzzy
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`~object.__call__` method in their class."
msgstr "클래스에서 :meth:`__call__` 메서드를 정의함으로써, 클래스 인스턴스를 콜러블로 만들 수 있습니다."

#: ../../reference/datamodel.rst:857
msgid "Modules"
msgstr "모듈(Modules)"

#: ../../reference/datamodel.rst:863
#, fuzzy
msgid ""
"Modules are a basic organizational unit of Python code, and are created "
"by the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement, or by calling functions such as "
":func:`importlib.import_module` and built-in :func:`__import__`.  A "
"module object has a namespace implemented by a :class:`dictionary <dict>`"
" object (this is the dictionary referenced by the "
":attr:`~function.__globals__` attribute of functions defined in the "
"module).  Attribute references are translated to lookups in this "
"dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A "
"module object does not contain the code object used to initialize the "
"module (since it isn't needed once the initialization is done)."
msgstr ""
"모듈은 파이썬 코드의 기본적인 조직화 단위이고, :keyword:`import` 문이나, "
":func:`importlib.import_module` 과 내장 :func:`__import__` 함수를 호출해서 구동할 수 있는"
" :ref:`임포트 시스템 <importsystem>` 에 의해 만들어집니다. 모듈 객체는 딕셔너리 객체로 구현되는 이름 공간을 "
"갖습니다(이 딕셔너리 객체는 모듈에서 정의되는 함수들의 ``__globals__`` 어트리뷰트로 참조됩니다). 어트리뷰트 참조는 이"
" 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, ``m.x`` 는 ``m.__dict__[\"x\"]`` 와 같습니다. 모듈 "
"객체는 모듈을 초기화하는데 사용된 코드 객체를 갖고 있지 않습니다 (일단 초기화가 끝나면 필요 없으므로)."

#: ../../reference/datamodel.rst:876
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., "
"``m.x = 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"어트리뷰트 대입은 모듈의 이름 공간 딕셔너리를 갱신합니다. 예를 들어, ``m.x = 1`` 은 ``m.__dict__[\"x\"]"
" = 1`` 과 같습니다."

#: ../../reference/datamodel.rst:894
msgid "Import-related attributes on module objects"
msgstr ""

#: ../../reference/datamodel.rst:896
msgid ""
"Module objects have the following attributes that relate to the "
":ref:`import system <importsystem>`. When a module is created using the "
"machinery associated with the import system, these attributes are filled "
"in based on the module's :term:`spec <module spec>`, before the "
":term:`loader` executes and loads the module."
msgstr ""

#: ../../reference/datamodel.rst:902
msgid ""
"To create a module dynamically rather than using the import system, it's "
"recommended to use :func:`importlib.util.module_from_spec`, which will "
"set the various import-controlled attributes to appropriate values. It's "
"also possible to use the :class:`types.ModuleType` constructor to create "
"modules directly, but this technique is more error-prone, as most "
"attributes must be manually set on the module object after it has been "
"created when using this approach."
msgstr ""

#: ../../reference/datamodel.rst:912
msgid ""
"With the exception of :attr:`~module.__name__`, it is **strongly** "
"recommended that you rely on :attr:`~module.__spec__` and its attributes "
"instead of any of the other individual attributes listed in this "
"subsection. Note that updating an attribute on :attr:`!__spec__` will not"
" update the corresponding attribute on the module itself:"
msgstr ""

#: ../../reference/datamodel.rst:918
msgid ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"
msgstr ""

#: ../../reference/datamodel.rst:932
msgid ""
"The name used to uniquely identify the module in the import system. For a"
" directly executed module, this will be set to ``\"__main__\"``."
msgstr ""

#: ../../reference/datamodel.rst:935
msgid ""
"This attribute must be set to the fully qualified name of the module. It "
"is expected to match the value of :attr:`module.__spec__.name "
"<importlib.machinery.ModuleSpec.name>`."
msgstr ""

#: ../../reference/datamodel.rst:941
msgid "A record of the module's import-system-related state."
msgstr ""

#: ../../reference/datamodel.rst:943
msgid ""
"Set to the :class:`module spec <importlib.machinery.ModuleSpec>` that was"
" used when importing the module. See :ref:`module-specs` for more "
"details."
msgstr ""

#: ../../reference/datamodel.rst:950
msgid "The :term:`package` a module belongs to."
msgstr ""

#: ../../reference/datamodel.rst:952
msgid ""
"If the module is top-level (that is, not a part of any specific package) "
"then the attribute should be set to ``''`` (the empty string). Otherwise,"
" it should be set to the name of the module's package (which can be equal"
" to :attr:`module.__name__` if the module itself is a package). See "
":pep:`366` for further details."
msgstr ""

#: ../../reference/datamodel.rst:958
msgid ""
"This attribute is used instead of :attr:`~module.__name__` to calculate "
"explicit relative imports for main modules. It defaults to ``None`` for "
"modules created dynamically using the :class:`types.ModuleType` "
"constructor; use :func:`importlib.util.module_from_spec` instead to "
"ensure the attribute is set to a :class:`str`."
msgstr ""

#: ../../reference/datamodel.rst:964
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.parent"
" <importlib.machinery.ModuleSpec.parent>` instead of "
":attr:`!module.__package__`. :attr:`__package__` is now only used as a "
"fallback if :attr:`!__spec__.parent` is not set, and this fallback path "
"is deprecated."
msgstr ""

#: ../../reference/datamodel.rst:970 ../../reference/datamodel.rst:1011
msgid ""
"This attribute now defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor. Previously the attribute"
" was optional."
msgstr ""

#: ../../reference/datamodel.rst:975
msgid ""
"The value of :attr:`!__package__` is expected to be the same as "
":attr:`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. "
":attr:`__package__` is now only used as a fallback during import "
"resolution if :attr:`!__spec__.parent` is not defined."
msgstr ""

#: ../../reference/datamodel.rst:981
msgid ""
":exc:`ImportWarning` is raised if an import resolution falls back to "
":attr:`!__package__` instead of :attr:`__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>`."
msgstr ""

#: ../../reference/datamodel.rst:986
msgid ""
"Raise :exc:`DeprecationWarning` instead of :exc:`ImportWarning` when "
"falling back to :attr:`!__package__` during import resolution."
msgstr ""

#: ../../reference/datamodel.rst:990
msgid ""
":attr:`!__package__` will cease to be set or taken into consideration by "
"the import system or standard library."
msgstr ""

#: ../../reference/datamodel.rst:996
msgid ""
"The :term:`loader` object that the import machinery used to load the "
"module."
msgstr ""

#: ../../reference/datamodel.rst:998
msgid ""
"This attribute is mostly useful for introspection, but can be used for "
"additional loader-specific functionality, for example getting data "
"associated with a loader."
msgstr ""

#: ../../reference/datamodel.rst:1002
msgid ""
":attr:`!__loader__` defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor; use "
":func:`importlib.util.module_from_spec` instead to ensure the attribute "
"is set to a :term:`loader` object."
msgstr ""

#: ../../reference/datamodel.rst:1007
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.loader"
" <importlib.machinery.ModuleSpec.loader>` instead of "
":attr:`!module.__loader__`."
msgstr ""

#: ../../reference/datamodel.rst:1016
msgid ""
"Setting :attr:`!__loader__` on a module while failing to set "
":attr:`!__spec__.loader` is deprecated. In Python 3.16, "
":attr:`!__loader__` will cease to be set or taken into consideration by "
"the import system or the standard library."
msgstr ""

#: ../../reference/datamodel.rst:1024
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"where the package's submodules will be found. Non-package modules should "
"not have a :attr:`!__path__` attribute. See :ref:`package-path-rules` for"
" more details."
msgstr ""

#: ../../reference/datamodel.rst:1029
msgid ""
"It is **strongly** recommended that you use "
":attr:`module.__spec__.submodule_search_locations "
"<importlib.machinery.ModuleSpec.submodule_search_locations>` instead of "
":attr:`!module.__path__`."
msgstr ""

#: ../../reference/datamodel.rst:1036
msgid ""
":attr:`!__file__` and :attr:`!__cached__` are both optional attributes "
"that may or may not be set. Both attributes should be a :class:`str` when"
" they are available."
msgstr ""

#: ../../reference/datamodel.rst:1040
msgid ""
":attr:`!__file__` indicates the pathname of the file from which the "
"module was loaded (if loaded from a file), or the pathname of the shared "
"library file for extension modules loaded dynamically from a shared "
"library. It might be missing for certain types of modules, such as C "
"modules that are statically linked into the interpreter, and the "
":ref:`import system <importsystem>` may opt to leave it unset if it has "
"no semantic meaning (for example, a module loaded from a database)."
msgstr ""

#: ../../reference/datamodel.rst:1048
msgid ""
"If :attr:`!__file__` is set then the :attr:`!__cached__` attribute might "
"also be set,  which is the path to any compiled version of the code (for "
"example, a byte-compiled file). The file does not need to exist to set "
"this attribute; the path can simply point to where the compiled file "
"*would* exist (see :pep:`3147`)."
msgstr ""

#: ../../reference/datamodel.rst:1054
msgid ""
"Note that :attr:`!__cached__` may be set even if :attr:`!__file__` is not"
" set.  However, that scenario is quite atypical.  Ultimately, the "
":term:`loader` is what makes use of the module spec provided by the "
":term:`finder` (from which :attr:`!__file__` and :attr:`!__cached__` are "
"derived).  So if a loader can load from a cached module but otherwise "
"does not load from a file, that atypical scenario may be appropriate."
msgstr ""

#: ../../reference/datamodel.rst:1061
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.cached"
" <importlib.machinery.ModuleSpec.cached>` instead of "
":attr:`!module.__cached__`."
msgstr ""

#: ../../reference/datamodel.rst:1065
msgid ""
"Setting :attr:`!__cached__` on a module while failing to set "
":attr:`!__spec__.cached` is deprecated. In Python 3.15, "
":attr:`!__cached__` will cease to be set or taken into consideration by "
"the import system or standard library."
msgstr ""

#: ../../reference/datamodel.rst:1072
msgid "Other writable attributes on module objects"
msgstr ""

#: ../../reference/datamodel.rst:1074
msgid ""
"As well as the import-related attributes listed above, module objects "
"also have the following writable attributes:"
msgstr ""

#: ../../reference/datamodel.rst:1079
#, fuzzy
msgid ""
"The module's documentation string, or ``None`` if unavailable. See also: "
":attr:`__doc__ attributes <definition.__doc__>`."
msgstr "함수를 설명하는 문자열 또는 없는 경우 ``None``; 서브 클래스로 상속되지 않습니다."

#: ../../reference/datamodel.rst:1084
msgid ""
"A dictionary containing :term:`variable annotations <variable "
"annotation>` collected during module body execution.  For best practices "
"on working with :attr:`__annotations__`, please see :ref:`annotations-"
"howto`."
msgstr ""

#: ../../reference/datamodel.rst:1090
#, fuzzy
msgid "Module dictionaries"
msgstr "딕셔너리(Dictionaries)"

#: ../../reference/datamodel.rst:1092
msgid "Module objects also have the following special read-only attribute:"
msgstr ""

#: ../../reference/datamodel.rst:1097
msgid ""
"The module's namespace as a dictionary object. Uniquely among the "
"attributes listed here, :attr:`!__dict__` cannot be accessed as a global "
"variable from within a module; it can only be accessed as an attribute on"
" module objects."
msgstr ""

#: ../../reference/datamodel.rst:1103
msgid ""
"Because of the way CPython clears module dictionaries, the module "
"dictionary will be cleared when the module falls out of scope even if the"
" dictionary still has live references.  To avoid this, copy the "
"dictionary or keep the module around while using its dictionary directly."
msgstr ""
"CPython 이 모듈 딕셔너리를 비우는 방법 때문에, 딕셔너리에 대한 참조가 남아있더라도, 모듈이 스코프를 벗어나면 모듈 "
"딕셔너리는 비워집니다. 이것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 이용하는 동안은 모듈을 잡아두어야 합니다."

#: ../../reference/datamodel.rst:1112
msgid "Custom classes"
msgstr "사용자 정의 클래스(Custom classes)"

#: ../../reference/datamodel.rst:1114
#, fuzzy
msgid ""
"Custom class types are typically created by class definitions (see "
"section :ref:`class`).  A class has a namespace implemented by a "
"dictionary object. Class attribute references are translated to lookups "
"in this dictionary, e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` "
"(although there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes. This search of the base "
"classes uses the C3 method resolution order which behaves correctly even "
"in the presence of 'diamond' inheritance structures where there are "
"multiple inheritance paths leading back to a common ancestor. Additional "
"details on the C3 MRO used by Python can be found at "
":ref:`python_2.3_mro`."
msgstr ""
"사용자 정의 클래스 형들은 보통 클래스 정의 때문에 만들어집니다 (:ref:`class` 섹션 참조). 클래스는 딕셔너리로 구현된 "
"이름 공간을 갖습니다. 클래스 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, ``C.x`` 는 "
"``C.__dict__[\"x\"]`` 로 변환됩니다 (하지만 어트리뷰트에 접근하는 다른 방법들을 허락하는 여러 가지 "
"훅(hook)이 있습니다.). 거기에서 어트리뷰트 이름이 발견되지 않으면, 어트리뷰트 검색은 부모 클래스들에서 계속됩니다. 이 부모"
" 클래스 검색은 C3 메서드 결정 순서(method resolution order)를 사용하는데, 다중 상속이 같은 부모 클래스로 "
"모이는 '다이아몬드(diamond)' 계승 구조가 존재해도 올바르게 동작합니다. 파이썬이 사용하는 C3 MRO에 관한 좀 더 자세한"
" 내용은 2.3 배포에 첨부된 문서 https://www.python.org/download/releases/2.3/mro/ 에서 "
"찾아볼 수 있습니다."

#: ../../reference/datamodel.rst:1135
#, fuzzy
msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield"
" a class method object, it is transformed into an instance method object "
"whose :attr:`~method.__self__` attribute is :class:`!C`. When it would "
"yield a :class:`staticmethod` object, it is transformed into the object "
"wrapped by the static method object. See section :ref:`descriptors` for "
"another way in which attributes retrieved from a class may differ from "
"those actually contained in its :attr:`~object.__dict__`."
msgstr ""
"클래스 어트리뷰트 참조가 (클래스 :class:`C` 라고 하자) 클래스 메서드 객체로 귀결될 때는, :attr:`__self__`"
" 어트리뷰트가 :class:`C` 인 인스턴스 메서드 객체로 변환됩니다. 스태틱 메서드로 귀결될 때는, 스태틱 메서드 객체가 감싸고"
" 있는 객체로 변환됩니다. 클래스로부터 얻은 어트리뷰트가 :attr:`~object.__dict__` 에 저장된 값과 달라지도록 "
"만드는 다른 방법이 :ref:`descriptors` 섹션에 나옵니다."

#: ../../reference/datamodel.rst:1146
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 건드리지는 않습니다."

#: ../../reference/datamodel.rst:1151
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보십시오) 호출될 수 있습니다(위를 보십시오)."

#: ../../reference/datamodel.rst:1154 ../../reference/datamodel.rst:1301
#, fuzzy
msgid "Special attributes"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../../reference/datamodel.rst:1174
msgid ""
"The class's name. See also: :attr:`__name__ attributes "
"<definition.__name__>`."
msgstr ""

#: ../../reference/datamodel.rst:1178
msgid ""
"The class's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""

#: ../../reference/datamodel.rst:1182
#, fuzzy
msgid "The name of the module in which the class was defined."
msgstr "함수가 정의된 모듈의 이름 또는 (없는 경우) ``None``"

#: ../../reference/datamodel.rst:1185
msgid ""
"A :class:`mapping proxy <types.MappingProxyType>` providing a read-only "
"view of the class's namespace. See also: :attr:`__dict__ attributes "
"<object.__dict__>`."
msgstr ""

#: ../../reference/datamodel.rst:1190
msgid ""
"A :class:`tuple` containing the class's bases. In most cases, for a class"
" defined as ``class X(A, B, C)``, ``X.__bases__`` will be exactly equal "
"to ``(A, B, C)``."
msgstr ""

#: ../../reference/datamodel.rst:1195
#, fuzzy
msgid ""
"The class's documentation string, or ``None`` if undefined. Not inherited"
" by subclasses."
msgstr "함수를 설명하는 문자열 또는 없는 경우 ``None``; 서브 클래스로 상속되지 않습니다."

#: ../../reference/datamodel.rst:1199
msgid ""
"A dictionary containing :term:`variable annotations <variable "
"annotation>` collected during class body execution. For best practices on"
" working with :attr:`!__annotations__`, please see :ref:`annotations-"
"howto`."
msgstr ""

#: ../../reference/datamodel.rst:1206
msgid ""
"Accessing the :attr:`!__annotations__` attribute of a class object "
"directly may yield incorrect results in the presence of metaclasses. In "
"addition, the attribute may not exist for some classes. Use "
":func:`inspect.get_annotations` to retrieve class annotations safely."
msgstr ""

#: ../../reference/datamodel.rst:1213
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a"
" :ref:`generic class <generic-classes>`."
msgstr ""

#: ../../reference/datamodel.rst:1219
msgid ""
"A :class:`tuple` containing names of attributes of this class which are "
"assigned through ``self.X`` from any function in its body."
msgstr ""

#: ../../reference/datamodel.rst:1225
msgid ""
"The line number of the first line of the class definition, including "
"decorators. Setting the :attr:`__module__` attribute removes the "
":attr:`!__firstlineno__` item from the type's dictionary."
msgstr ""

#: ../../reference/datamodel.rst:1233
msgid ""
"The :class:`tuple` of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""

#: ../../reference/datamodel.rst:1238
#, fuzzy
msgid "Special methods"
msgstr "특수 메서드 이름들"

#: ../../reference/datamodel.rst:1240
msgid ""
"In addition to the special attributes described above, all Python classes"
" also have the following two methods available:"
msgstr ""

#: ../../reference/datamodel.rst:1245
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation,"
" and its result is stored in :attr:`~type.__mro__`."
msgstr ""

#: ../../reference/datamodel.rst:1251
msgid ""
"Each class keeps a list of weak references to its immediate subclasses. "
"This method returns a list of all those references still alive. The list "
"is in definition order. Example:"
msgstr ""

#: ../../reference/datamodel.rst:1255
msgid ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"
msgstr ""

#: ../../reference/datamodel.rst:1263
msgid "Class instances"
msgstr "클래스 인스턴스(Class instances)"

#: ../../reference/datamodel.rst:1271
#, fuzzy
msgid ""
"A class instance is created by calling a class object (see above).  A "
"class instance has a namespace implemented as a dictionary which is the "
"first place in which attribute references are searched.  When an "
"attribute is not found there, and the instance's class has an attribute "
"by that name, the search continues with the class attributes.  If a class"
" attribute is found that is a user-defined function object, it is "
"transformed into an instance method object whose :attr:`~method.__self__`"
" attribute is the instance.  Static method and class method objects are "
"also transformed; see above under \"Classes\".  See section "
":ref:`descriptors` for another way in which attributes of a class "
"retrieved via its instances may differ from the objects actually stored "
"in the class's :attr:`~object.__dict__`.  If no class attribute is found,"
" and the object's class has a :meth:`~object.__getattr__` method, that is"
" called to satisfy the lookup."
msgstr ""
"클래스 인스턴스는 클래스 객체를 호출해서 (위를 보십시오) 만들어집니다. 클래스 인스턴스는 딕셔너리로 구현되는 이름 공간을 갖는데,"
" 어트리뷰트를 참조할 때 가장 먼저 검색되는 곳입니다. 그곳에서 어트리뷰트가 발견되지 않고, 인스턴스의 클래스가 그 이름의 "
"어트리뷰트를 갖고 있으면, 클래스 어트리뷰트로 검색이 계속됩니다. 만약 발견된 클래스 어트리뷰트가 사용자 정의 함수면, "
":attr:`__self__` 어트리뷰트가 인스턴스인 인스턴스 메서드로 변환됩니다. 스태틱 메서드와 클래스 메서드 객체 또한 "
"변환됩니다. 위의 \"사용자 정의 클래스(Custom Classes)\" 부분을 보십시오. 클래스로부터 얻은 어트리뷰트가 클래스의 "
":attr:`~object.__dict__` 에 저장된 값과 달라지도록 만드는 다른 방법이 :ref:`descriptors` 섹션에"
" 나옵니다. 만약 클래스 어트리뷰트도 발견되지 않고, 클래스가 :meth:`__getattr__` 메서드를 가지면, 조회를 "
"만족시키기 위해 그 메서드를 호출합니다."

#: ../../reference/datamodel.rst:1287
#, fuzzy
msgid ""
"Attribute assignments and deletions update the instance's dictionary, "
"never a class's dictionary.  If the class has a "
":meth:`~object.__setattr__` or :meth:`~object.__delattr__` method, this "
"is called instead of updating the instance dictionary directly."
msgstr ""
"어트리뷰트 대입과 삭제는 인스턴스의 딕셔너리를 갱신할 뿐, 결코 클래스의 딕셔너리를 건드리지 않습니다. 만약 클래스가 "
":meth:`__setattr__` 이나 :meth:`__delattr__` 메서드를 가지면, 인스턴스의 딕셔너리를 갱신하는 대신에"
" 그 메서드들을 호출합니다."

#: ../../reference/datamodel.rst:1297
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they"
" have methods with certain special names.  See section "
":ref:`specialnames`."
msgstr ""
"어떤 특별한 이름들의 메서드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인 척할 수 있습니다. "
":ref:`specialnames` 섹션을 보십시오."

#: ../../reference/datamodel.rst:1309
msgid "The class to which a class instance belongs."
msgstr ""

#: ../../reference/datamodel.rst:1313
msgid ""
"A dictionary or other mapping object used to store an object's (writable)"
" attributes. Not all instances have a :attr:`!__dict__` attribute; see "
"the section on :ref:`slots` for more details."
msgstr ""

#: ../../reference/datamodel.rst:1319
msgid "I/O objects (also known as file objects)"
msgstr "I/O 객체 (파일 객체라고도 알려져 있습니다)"

#: ../../reference/datamodel.rst:1334
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and"
" also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
":term:`파일 객체 <file object>` 는 열린 파일을 나타냅니다. 파일 객체를 만드는 여러 가지 단축법이 있습니다: "
":func:`open` 내장 함수, :func:`os.popen`, :func:`os.fdopen` 과 소켓 객체의 "
":meth:`~socket.socket.makefile` 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 "
"메서드들)."

#: ../../reference/datamodel.rst:1340
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are "
"initialized to file objects corresponding to the interpreter's standard "
"input, output and error streams; they are all open in text mode and "
"therefore follow the interface defined by the :class:`io.TextIOBase` "
"abstract class."
msgstr ""
"``sys.stdin``, ``sys.stdout``, ``sys.stderr`` 는 인터프리터의 표준 입력, 출력, 에러 "
"스트림으로 초기화된 파일 객체들입니다; 모두 텍스트 모드로 열려서 :class:`io.TextIOBase` 추상 클래스에 의해 "
"정의된 인터페이스를 따릅니다."

#: ../../reference/datamodel.rst:1348
msgid "Internal types"
msgstr "내부 형(Internal types)"

#: ../../reference/datamodel.rst:1354
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but"
" they are mentioned here for completeness."
msgstr ""
"인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출됩니다. 인터프리터의 미래 버전에서 이들의 정의는 변경될 수 있지만, "
"완전함을 위해 여기서 언급합니다."

#: ../../reference/datamodel.rst:1362
msgid "Code objects"
msgstr "코드 객체(Code objects)"

#: ../../reference/datamodel.rst:1366
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function "
"object is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code "
"object contains no context; also the default argument values are stored "
"in the function object, not in the code object (because they represent "
"values calculated at run-time).  Unlike function objects, code objects "
"are immutable and contain no references (directly or indirectly) to "
"mutable objects."
msgstr ""
"코드 객체는 *바이트로 컴파일된(byte-compiled)* 실행 가능한 파이썬 코드를 나타내는데, 그냥 :term:`바이트 코드 "
"<bytecode>` 라고도 부릅니다. 코드 객체와 함수 객체 간에는 차이가 있습니다; 함수 객체는 함수의 전역 "
"공간(globals) (함수가 정의된 모듈)을 명시적으로 참조하고 있지만, 코드 객체는 어떤 문맥(context)도 갖고 있지 "
"않습니다; 또한 기본 인자값들이 함수 객체에 저장되어 있지만 코드 객체에는 들어있지 않습니다 (실행 시간에 계산되는 값들을 나타내기"
" 때문입니다). 함수 객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) 갖고 있지 "
"않습니다."

#: ../../reference/datamodel.rst:1400
#, fuzzy
msgid "The function name"
msgstr "함수의 이름."

#: ../../reference/datamodel.rst:1403
#, fuzzy
msgid "The fully qualified function name"
msgstr "함수의 이름."

#: ../../reference/datamodel.rst:1408
msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""

#: ../../reference/datamodel.rst:1413
msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""

#: ../../reference/datamodel.rst:1417
msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""

#: ../../reference/datamodel.rst:1421
msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""

#: ../../reference/datamodel.rst:1425
msgid ""
"A :class:`tuple` containing the names of the local variables in the "
"function (starting with the parameter names)"
msgstr ""

#: ../../reference/datamodel.rst:1429
msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced from at least one :term:`nested scope` inside the "
"function"
msgstr ""

#: ../../reference/datamodel.rst:1433
msgid ""
"A :class:`tuple` containing the names of :term:`free (closure) variables "
"<closure variable>` that a :term:`nested scope` references in an outer "
"scope. See also :attr:`function.__closure__`."
msgstr ""

#: ../../reference/datamodel.rst:1437
msgid "Note: references to global and builtin names are *not* included."
msgstr ""

#: ../../reference/datamodel.rst:1440
msgid ""
"A string representing the sequence of :term:`bytecode` instructions in "
"the function"
msgstr ""

#: ../../reference/datamodel.rst:1444
msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in "
"the function"
msgstr ""

#: ../../reference/datamodel.rst:1448
msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the"
" function"
msgstr ""

#: ../../reference/datamodel.rst:1452
msgid "The name of the file from which the code was compiled"
msgstr ""

#: ../../reference/datamodel.rst:1455
msgid "The line number of the first line of the function"
msgstr ""

#: ../../reference/datamodel.rst:1458
msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line "
"numbers. For details, see the source code of the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:1461
msgid ""
"This attribute of code objects is deprecated, and may be removed in "
"Python 3.15."
msgstr ""

#: ../../reference/datamodel.rst:1466
msgid "The required stack size of the code object"
msgstr ""

#: ../../reference/datamodel.rst:1469
msgid "An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:1474
#, fuzzy
msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit"
" ``0x04`` is set if the function uses the ``*arguments`` syntax to accept"
" an arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. See :ref"
":`inspect-module-co-flags` for details on the semantics of each flags "
"that might be present."
msgstr ""
"다음과 같은 값들이 :attr:`co_flags` 를 위해 정의되어 있습니다: 함수가 가변 개수의 위치 인자를 받아들이기 위해 "
"사용되는 ``*arguments`` 문법을 사용하면 비트 ``0x04`` 가 1이 됩니다; 임의의 키워드 인자를 받아들이기 위해 "
"사용하는 ``**keywords`` 문법을 사용하면 비트 ``0x08`` 이 1이 됩니다; 비트 ``0x20`` 은 함수가 "
"제너레이터일 때 설정됩니다."

#: ../../reference/datamodel.rst:1482
#, fuzzy
msgid ""
"Future feature declarations (``from __future__ import division``) also "
"use bits in :attr:`~codeobject.co_flags` to indicate whether a code "
"object was compiled with a particular feature enabled: bit ``0x2000`` is "
"set if the function was compiled with future division enabled; bits "
"``0x10`` and ``0x1000`` were used in earlier versions of Python."
msgstr ""
"퓨처 기능 선언 (``from __future__ import division``) 또한 코드 객체가 특정 기능이 활성화된 상태에서"
" 컴파일되었는지를 나타내기 위해 :attr:`co_flags` 의 비트들을 사용합니다: 함수가 퓨처 division이 활성화된 "
"상태에서 컴파일되었으면 비트 ``0x2000`` 이 설정됩니다; 비트 ``0x10`` 과 ``0x1000`` 는 예전 버전의 "
"파이썬에서 사용되었습니다."

#: ../../reference/datamodel.rst:1488
#, fuzzy
msgid "Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` 의 다른 비트들은 내부 사용을 위해 예약되어 있습니다."

#: ../../reference/datamodel.rst:1492
#, fuzzy
msgid ""
"If a code object represents a function, the first item in "
":attr:`~codeobject.co_consts` is the documentation string of the "
"function, or ``None`` if undefined."
msgstr ""
"만약 코드 객체가 함수를 나타낸다면, :attr:`co_consts` 의 첫 번째 항목은 설명 문자열이거나 정의되지 않으면 "
"``None`` 입니다. "

#: ../../reference/datamodel.rst:1497
#, fuzzy
msgid "Methods on code objects"
msgstr "코드 객체(Code objects)"

#: ../../reference/datamodel.rst:1501
msgid ""
"Returns an iterable over the source code positions of each "
":term:`bytecode` instruction in the code object."
msgstr ""

#: ../../reference/datamodel.rst:1504
msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to "
"the position of the source code that compiled to the *i-th* code unit. "
"Column information is 0-indexed utf-8 byte offsets on the given source "
"line."
msgstr ""

#: ../../reference/datamodel.rst:1510
msgid ""
"This positional information can be missing. A non-exhaustive lists of "
"cases where this may happen:"
msgstr ""

#: ../../reference/datamodel.rst:1513
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr ""

#: ../../reference/datamodel.rst:1514
msgid "Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""

#: ../../reference/datamodel.rst:1515
msgid "Position tuples corresponding to artificial instructions."
msgstr ""

#: ../../reference/datamodel.rst:1516
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""

#: ../../reference/datamodel.rst:1519
msgid "When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""

#: ../../reference/datamodel.rst:1525
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the "
":envvar:`PYTHONNODEBUGRANGES` environment variable can be used."
msgstr ""

#: ../../reference/datamodel.rst:1534
msgid ""
"Returns an iterator that yields information about successive ranges of "
":term:`bytecode`\\s. Each item yielded is a ``(start, end, lineno)`` "
":class:`tuple`:"
msgstr ""

#: ../../reference/datamodel.rst:1538
msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the "
"start of the :term:`bytecode` range"
msgstr ""

#: ../../reference/datamodel.rst:1540
msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of"
" the :term:`bytecode` range"
msgstr ""

#: ../../reference/datamodel.rst:1542
msgid ""
"``lineno`` is an :class:`int` representing the line number of the "
":term:`bytecode` range, or ``None`` if the bytecodes in the given range "
"have no line number"
msgstr ""

#: ../../reference/datamodel.rst:1546
msgid "The items yielded will have the following properties:"
msgstr ""

#: ../../reference/datamodel.rst:1548
msgid "The first range yielded will have a ``start`` of 0."
msgstr ""

#: ../../reference/datamodel.rst:1549
msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That "
"is, for any pair of :class:`tuple`\\s, the ``start`` of the second will "
"be equal to the ``end`` of the first."
msgstr ""

#: ../../reference/datamodel.rst:1552
msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr ""

#: ../../reference/datamodel.rst:1553
msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of "
"the :term:`bytecode`."
msgstr ""

#: ../../reference/datamodel.rst:1556
msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges"
" are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""

#: ../../reference/datamodel.rst:1564
msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ""

#: ../../reference/datamodel.rst:1565
msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr ""

#: ../../reference/datamodel.rst:1569
msgid "Return a copy of the code object with new values for the specified fields."
msgstr ""

#: ../../reference/datamodel.rst:1571
msgid ""
"Code objects are also supported by the generic function "
":func:`copy.replace`."
msgstr ""

#: ../../reference/datamodel.rst:1579
msgid "Frame objects"
msgstr "프레임 객체(Frame objects)"

#: ../../reference/datamodel.rst:1583
#, fuzzy
msgid ""
"Frame objects represent execution frames.  They may occur in "
":ref:`traceback objects <traceback-objects>`, and are also passed to "
"registered trace functions."
msgstr ""
"프레임 객체는 실행 프레임(execution frame)을 나타냅니다. 트레이스백 객체에 등장할 수 있고 (아래를 보십시오), "
"등록된 추적 함수로도 전달됩니다."

#: ../../reference/datamodel.rst:1601
msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if "
"this is the bottom stack frame"
msgstr ""

#: ../../reference/datamodel.rst:1605
#, fuzzy
msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"특정 민감한 어트리뷰트 액세스의 경우, 인자 ``obj``\\와 ``name``\\으로 :ref:`감사 이벤트 <auditing>`"
" ``object.__getattr__``\\을 발생시킵니다."

#: ../../reference/datamodel.rst:1610
msgid ""
"The mapping used by the frame to look up :ref:`local variables <naming>`."
" If the frame refers to an :term:`optimized scope`, this may return a "
"write-through proxy object."
msgstr ""

#: ../../reference/datamodel.rst:1615
msgid "Return a proxy for optimized scopes."
msgstr ""

#: ../../reference/datamodel.rst:1619
msgid ""
"The dictionary used by the frame to look up :ref:`global variables "
"<naming>`"
msgstr ""

#: ../../reference/datamodel.rst:1623
msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) "
"names <naming>`"
msgstr ""

#: ../../reference/datamodel.rst:1627
msgid ""
"The \"precise instruction\" of the frame object (this is an index into "
"the :term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""

#: ../../reference/datamodel.rst:1643
#, fuzzy
msgid ""
"If not ``None``, this is a function called for various events during code"
" execution (this is used by debuggers). Normally an event is triggered "
"for each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""
"특수 쓰기 가능 어트리뷰트들: :attr:`f_trace` 는, ``None`` 이 아니면, 코드 실행 중의 여러 이벤트로 인해 "
"호출되는 함수입니다 (디버거에서 사용됩니다). 보통 이벤트는 각 새 소스 줄에서 발생합니다 - "
":attr:`f_trace_lines`\\를 :const:`False`\\로 설정하면 이것을 비활성화할 수 있습니다."

#: ../../reference/datamodel.rst:1648
msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing "
"event for each source line."
msgstr ""

#: ../../reference/datamodel.rst:1652
#, fuzzy
msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being "
"traced."
msgstr ""
"구현은 :attr:`f_trace_opcodes`\\를 :const:`True`\\로 설정하는 것으로 요청되는 옵코드(opcode)"
" 당 이벤트를 허용할 수 있습니다. 추적 함수에 의해 발생 된 예외가 추적되는 함수로 빠져나오면 정의되지 않은 인터프리터 동작을 "
"유발할 수 있음에 주의해야 합니다."

#: ../../reference/datamodel.rst:1658
#, fuzzy
msgid ""
"The current line number of the frame -- writing to this from within a "
"trace function jumps to the given line (only for the bottom-most frame)."
"  A debugger can implement a Jump command (aka Set Next Statement) by "
"writing to this attribute."
msgstr ""
":attr:`f_lineno` 는 프레임의 현재 줄 번호입니다 --- 트레이스 함수(f_trace)에서 이 값을 쓰면 해당 줄로 "
"점프합니다 (오직 가장 바닥 프레임에서만 가능합니다). 디버거는 f_lineno 를 쓰기 위한 점프 명령을 구현할 수 있습니다 "
"(소위 Set Next Statement)."

#: ../../reference/datamodel.rst:1664
#, fuzzy
msgid "Frame object methods"
msgstr "프레임 객체(Frame objects)"

#: ../../reference/datamodel.rst:1666
msgid "Frame objects support one method:"
msgstr "프레임 객체는 한가지 메서드를 지원합니다:"

#: ../../reference/datamodel.rst:1670
#, fuzzy
msgid ""
"This method clears all references to :ref:`local variables <naming>` held"
" by the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving "
"frame objects (for example when catching an :ref:`exception <bltin-"
"exceptions>` and storing its :ref:`traceback <traceback-objects>` for "
"later use)."
msgstr ""
"이 메서드는 프레임이 잡은 지역 변수들에 대한 모든 참조를 제거합니다. 또한, 만약 프레임이 제너레이터에 속하면, 제너레이터가 "
"종료됩니다(finalize). 이것은 프레임 객체가 관련된 참조 순환을 깨는 데 도움을 줍니다 (예를 들어, 예외를 잡아서 "
"트레이스백을 추후 사용을 위해 저장할 때)."

#: ../../reference/datamodel.rst:1676
#, fuzzy
msgid ""
":exc:`RuntimeError` is raised if the frame is currently executing or "
"suspended."
msgstr "만약 프레임이 현재 실행 중이면 :exc:`RuntimeError` 예외가 발생합니다."

#: ../../reference/datamodel.rst:1681
msgid ""
"Attempting to clear a suspended frame raises :exc:`RuntimeError` (as has "
"always been the case for executing frames)."
msgstr ""

#: ../../reference/datamodel.rst:1689
msgid "Traceback objects"
msgstr "트레이스백 객체(Traceback objects)"

#: ../../reference/datamodel.rst:1702
#, fuzzy
msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception "
"occurs, and may also be explicitly created by calling "
":class:`types.TracebackType`."
msgstr ""
"트레이스백 객체는 예외의 스택 트레이스를 나타냅니다. 트레이스백 객체는 예외가 발생할 때 만들어지고, "
":class:`types.TracebackType` 를 호출해서 명시적으로 만들 수도 있습니다."

#: ../../reference/datamodel.rst:1707
#, fuzzy
msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr ""
"트레이스백 객체는 이제 파이썬 코드에서 명시적으로 인스턴스를 만들 수 있으며 기존 인스턴스의 ``tb_next`` 어트리뷰트를 "
"변경할 수 있습니다."

#: ../../reference/datamodel.rst:1710
#, fuzzy
msgid ""
"For implicitly created tracebacks, when the search for an exception "
"handler unwinds the execution stack, at each unwound level a traceback "
"object is inserted in front of the current traceback.  When an exception "
"handler is entered, the stack trace is made available to the program. "
"(See section :ref:`try`.) It is accessible as the third item of the tuple"
" returned by :func:`sys.exc_info`, and as the "
":attr:`~BaseException.__traceback__` attribute of the caught exception."
msgstr ""
"묵시적으로 만들어진 트레이스백의 경우, 예외 처리기를 찾아서 실행 스택을 되감을 때, 각각 되감기 단계마다 현재 트레이스백의 앞에 "
"트레이스백 객체를 삽입합니다. 예외 처리기에 들어가면, 스택 트레이스를 프로그램이 사용할 수 있습니다. (:ref:`try` 섹션 "
"참조.) ``sys.exc_info()`` 가 돌려주는 튜플의 세 번째 항목이나 잡힌 예외의 ``__traceback__`` "
"어트리뷰트로 액세스할 수 있습니다."

#: ../../reference/datamodel.rst:1719
#, fuzzy
msgid ""
"When the program contains no suitable handler, the stack trace is written"
" (nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as "
":data:`sys.last_traceback`."
msgstr ""
"프로그램이 적절한 처리기를 제공하지 않는 경우, 스택 트레이스는 표준 에러 스트림으로 (보기 좋게 포맷되어) 출력됩니다; 만약 "
"인터프리터가 대화형이면, ``sys.last_traceback`` 으로 사용자에게 제공합니다."

#: ../../reference/datamodel.rst:1724
#, fuzzy
msgid ""
"For explicitly created tracebacks, it is up to the creator of the "
"traceback to determine how the :attr:`~traceback.tb_next` attributes "
"should be linked to form a full stack trace."
msgstr ""
"명시적으로 생성된 트레이스백의 경우, ``tb_next`` 어트리뷰트를 어떻게 연결하여 전체 스택 트레이스를 형성해야 하는지를 "
"결정하는 것은 트레이스백을 만드는 주체에게 달려 있습니다."

#: ../../reference/datamodel.rst:1739
msgid "Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr ""

#: ../../reference/datamodel.rst:1742
#, fuzzy
msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"특정 민감한 어트리뷰트 액세스의 경우, 인자 ``obj``\\와 ``name``\\으로 :ref:`감사 이벤트 <auditing>`"
" ``object.__getattr__``\\을 발생시킵니다."

#: ../../reference/datamodel.rst:1747
msgid "Gives the line number where the exception occurred"
msgstr ""

#: ../../reference/datamodel.rst:1750
msgid "Indicates the \"precise instruction\"."
msgstr ""

#: ../../reference/datamodel.rst:1752
#, fuzzy
msgid ""
"The line number and last instruction in the traceback may differ from the"
" line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`tb_frame` 은 현 단계에서의 실행 프레임입니다; :attr:`tb_lineno` "
"는 예외가 발생한 줄의 번호를 줍니다; :attr:`tb_lasti` 정확한 바이트 코드 명령을 가리킵니다. 만약 예외가 "
"except 절이나 finally 절이 없는 :keyword:`try` 문에서 발생하면, 줄 번호와 트레이스백의 마지막 "
"명령(last instruction)은 프레임 객체의 줄 번호와 다를 수 있습니다."

#: ../../reference/datamodel.rst:1763
#, fuzzy
msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None``"
" if there is no next level."
msgstr ""
"특수 쓰기 가능 어트리뷰트: :attr:`tb_next` 는 스택 트레이스의 다음 단계 (예외가 발생한 프레임 방향으로)이거나 다음"
" 단계가 없으면 ``None`` 입니다."

#: ../../reference/datamodel.rst:1767
#, fuzzy
msgid "This attribute is now writable"
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../../reference/datamodel.rst:1772
msgid "Slice objects"
msgstr "슬라이스 객체(Slice objects)"

#: ../../reference/datamodel.rst:1776
#, fuzzy
msgid ""
"Slice objects are used to represent slices for "
":meth:`~object.__getitem__` methods.  They are also created by the built-"
"in :func:`slice` function."
msgstr ""
"슬라이스 객체는 :meth:`__getitem__` 메서드를 위한 슬라이스를 나타냅니다. 내장 함수 :func:`slice` 로 "
"만들 수도 있습니다."

#: ../../reference/datamodel.rst:1785
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`~slice.start` 는 하한(lower bound) 입니다; "
":attr:`~slice.stop` 은 상한(upper bound) 입니다; :attr:`~slice.step` 은 스텝 값입니다;"
" 각 값은 생략될 경우 ``None`` 입니다. 이 어트리뷰트들은 임의의 형이 될 수 있습니다."

#: ../../reference/datamodel.rst:1789
msgid "Slice objects support one method:"
msgstr "슬라이스 객체는 하나의 메서드를 지원합니다."

#: ../../reference/datamodel.rst:1793
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices "
"are handled in a manner consistent with regular slices."
msgstr ""
"이 메서드는 하나의 정수 인자 *length* 를 받아서 슬라이스 객체가 길이 *length* 인 시퀀스에 적용되었을 때 그 "
"슬라이스에 대한 정보를 계산합니다. 세 개의 정수로 구성된 튜플을 돌려줍니다: 이것들은 각각 *start* 와 *stop* "
"인덱스와, *step* 또는 슬라이스의 스트라이드(stride) 길이입니다. 생략되었거나 범위를 벗어난 인덱스들은 일반적인 "
"슬라이스와 같은 방법으로 다뤄집니다."

#: ../../reference/datamodel.rst:1802
msgid "Static method objects"
msgstr "스태틱 메서드 객체(Static method objects)"

#: ../../reference/datamodel.rst:1804
#, fuzzy
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method "
"object is a wrapper around any other object, usually a user-defined "
"method object. When a static method object is retrieved from a class or a"
" class instance, the object actually returned is the wrapped object, "
"which is not subject to any further transformation. Static method objects"
" are also callable. Static method objects are created by the built-in "
":func:`staticmethod` constructor."
msgstr ""
"스태틱 메서드 객체는 위에서 설명한 함수 객체를 메서드 객체로 변환하는 과정을 방지하는 방법을 제공합니다. 스태틱 메서드 객체는 "
"다른 임의의 객체, 보통 사용자 정의 메서드를 둘러쌉니다. 스태틱 메서드가 클래스나 클래스 인스턴스로부터 읽힐 때 객체가 실제로 "
"돌려주는 것은 둘러싸여 있던 객체인데, 다른 어떤 변환도 적용되지 않은 상태입니다. 둘러싸는 객체는 그렇더라도, 스태틱 메서드 객체"
" 자체는 콜러블이 아닙니다. 스태틱 메서드 객체는 내장 :func:`staticmethod` 생성자로 만듭니다."

#: ../../reference/datamodel.rst:1814
msgid "Class method objects"
msgstr "클래스 메서드 객체(Class method objects)"

#: ../../reference/datamodel.rst:1816
#, fuzzy
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from"
" classes and class instances. The behaviour of class method objects upon "
"such retrieval is described above, under :ref:`\"instance methods\" "
"<instance-methods>`. Class method objects are created by the built-in "
":func:`classmethod` constructor."
msgstr ""
"스태틱 메서드 객체처럼, 클래스 메서드 객체 역시 다른 객체를 둘러싸는데, 클래스와 클래스 인스턴스로부터 그 객체를 꺼내는 방식에 "
"변화를 줍니다. 그런 조회에서 클래스 메서드 객체가 동작하는 방식에 대해서는 위 \"사용자 정의 메서드(User-defined "
"methods)\" 에서 설명했습니다. 클래스 메서드 객체는 내장 :func:`classmethod` 생성자로 만듭니다."

#: ../../reference/datamodel.rst:1826
msgid "Special method names"
msgstr "특수 메서드 이름들"

#: ../../reference/datamodel.rst:1832
#, fuzzy
msgid ""
"A class can implement certain operations that are invoked by special "
"syntax (such as arithmetic operations or subscripting and slicing) by "
"defining methods with special names. This is Python's approach to "
":dfn:`operator overloading`, allowing classes to define their own "
"behavior with respect to language operators.  For instance, if a class "
"defines a method named :meth:`~object.__getitem__`, and ``x`` is an "
"instance of this class, then ``x[i]`` is roughly equivalent to "
"``type(x).__getitem__(x, i)``.  Except where mentioned, attempts to "
"execute an operation raise an exception when no appropriate method is "
"defined (typically :exc:`AttributeError` or :exc:`TypeError`)."
msgstr ""
"클래스는 특별한 이름의 메서드들을 정의함으로써 특별한 문법 (산술 연산이나 인덱싱이나 슬라이딩 같은)에 의해 시작되는 어떤 연산들을"
" 구현할 수 있습니다. 이것이 :dfn:`연산자 오버 로딩 (operator overloading)`\\에 대한 파이썬의 "
"접근법인데, 클래스가 언어의 연산자에 대해 자기 자신의 동작을 정의할 수 있도록 합니다. 예를 들어, 클래스가 "
":meth:`__getitem__` 이라는 이름의 메서드를 정의하고, ``x`` 가 이 클래스의 인스턴스라면, ``x[i]`` 는 "
"대략 ``type(x).__getitem__(x, i)`` 와 동등합니다. 언급된 경우를 제외하고, 적절한 메서드가 정의되지 않았을"
" 때 연산은 예외를 일으킵니다 (보통 :exc:`AttributeError` 나 :exc:`TypeError`)."

#: ../../reference/datamodel.rst:1843
#, fuzzy
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets "
":meth:`~object.__iter__` to ``None``, the class is not iterable, so "
"calling :func:`iter` on its instances will raise a :exc:`TypeError` "
"(without falling back to :meth:`~object.__getitem__`). [#]_"
msgstr ""
"특수 메서드를 ``None`` 으로 설정하는 것은 해당 연산이 제공되지 않는다는 것을 가리킵니다. 예를 들어, 만약 클래스가 "
":meth:`__iter__` 를 ``None`` 으로 설정하면, 클래스는 이터러블이 아닙니다. 따라서 이 인스턴스에 "
":func:`iter` 를 호출하면 :exc:`TypeError` 가 발생합니다. (:meth:`__getitem__` 을 대안으로"
" 시도하지 않습니다.) [#]_"

#: ../../reference/datamodel.rst:1849
msgid ""
"When implementing a class that emulates any built-in type, it is "
"important that the emulation only be implemented to the degree that it "
"makes sense for the object being modelled.  For example, some sequences "
"may work well with retrieval of individual elements, but extracting a "
"slice may not make sense.  (One example of this is the "
":class:`~xml.dom.NodeList` interface in the W3C's Document Object Model.)"
msgstr ""
"내장형을 흉내 내는 클래스를 구현할 때, 모방은 모형화하는 객체에 말이 되는 수준까지만 구현하는 것이 중요합니다. 예를 들어, 어떤"
" 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있습니다. 하지만 슬라이스를 꺼내는 것은 말이 안 될 수 있습니다. (이런"
" 한가지 예는 W3C의 Document Object Model의 :class:`~xml.dom.NodeList` 인터페이스입니다.)"

#: ../../reference/datamodel.rst:1860
msgid "Basic customization"
msgstr "기본적인 커스터마이제이션"

#: ../../reference/datamodel.rst:1866
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a "
"static method (special-cased so you need not declare it as such) that "
"takes the class of which an instance was requested as its first argument."
"  The remaining arguments are those passed to the object constructor "
"expression (the call to the class).  The return value of :meth:`__new__` "
"should be the new object instance (usually an instance of *cls*)."
msgstr ""
"클래스 *cls* 의 새 인스턴스를 만들기 위해 호출됩니다. :meth:`__new__` 는 스태틱 메서드입니다 (그렇게 선언하지 "
"않아도 되는 특별한 경우입니다)인데, 첫 번째 인자로 만들려고 하는 인스턴스의 클래스가 전달됩니다. 나머지 인자들은 객체 생성자 "
"표현(클래스 호출)에 전달된 것들입니다. :meth:`__new__` 의 반환 값은 새 객체 인스턴스이어야 합니다 (보통 *cls*"
" 의 인스턴스)."

#: ../../reference/datamodel.rst:1873
#, fuzzy
msgid ""
"Typical implementations create a new instance of the class by invoking "
"the superclass's :meth:`__new__` method using ``super().__new__(cls[, "
"...])`` with appropriate arguments and then modifying the newly created "
"instance as necessary before returning it."
msgstr ""
"일반적인 구현은 ``super().__new__(cls[, ...])`` 에 적절한 인자들을 전달하는 방법으로 슈퍼 클래스의 "
":meth:`__new__` 를 호출해서 새 인스턴스를 만든 후에, 돌려주기 전에 필요한 수정을 가합니다."

#: ../../reference/datamodel.rst:1878
#, fuzzy
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns "
"an instance of *cls*, then the new instance’s :meth:`__init__` method "
"will be invoked like ``__init__(self[, ...])``, where *self* is the new "
"instance and the remaining arguments are the same as were passed to the "
"object constructor."
msgstr ""
"만약 :meth:`__new__` 가 객체 생성 중에 호출되고, *cls*\\나 서브 클래스의 인스턴스를 돌려준다면, 새 인스턴스의"
" :meth:`__init__` 메서드가 ``__init__(self[, ...])`` 처럼 호출되는데, *self* 는 새 "
"인스턴스이고, 나머지 인자들은 객체 생성자로 전달된 것들과 같습니다."

#: ../../reference/datamodel.rst:1883
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"만약 :meth:`__new__` 가 *cls* 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 :meth:`__init__` 는 "
"호출되지 않습니다."

#: ../../reference/datamodel.rst:1886
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types"
" (like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` 는 주로 불변형(int, str, tuple과 같은)의 서브 클래스가 인스턴스 생성을 커스터마이즈할 수"
" 있도록 하는 데 사용됩니다. 또한, 사용자 정의 메타 클래스에서 클래스 생성을 커스터마이즈하기 위해 자주 사용됩니다."

#: ../../reference/datamodel.rst:1895
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but "
"before it is returned to the caller.  The arguments are those passed to "
"the class constructor expression.  If a base class has an "
":meth:`__init__` method, the derived class's :meth:`__init__` method, if "
"any, must explicitly call it to ensure proper initialization of the base "
"class part of the instance; for example: ``super().__init__([args...])``."
msgstr ""
"(:meth:`__new__` 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 호출됩니다. 인자들은 클래스 "
"생성자 표현으로 전달된 것들입니다. 만약 베이스 클래스가 :meth:`__init__` 메서드를 갖고 있다면, 서브 클래스의 "
":meth:`__init__` 메서드는, 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분이 올바르게 초기화됨을 확실히 하기 위해"
" 명시적으로 호출해주어야 합니다; 예를 들어: ``super().__init__([args...])``."

#: ../../reference/datamodel.rst:1902
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in "
"constructing objects (:meth:`__new__` to create it, and :meth:`__init__` "
"to customize it), no non-``None`` value may be returned by "
":meth:`__init__`; doing so will cause a :exc:`TypeError` to be raised at "
"runtime."
msgstr ""
"객체를 만드는데 :meth:`__new__` 와 :meth:`__init__` 가 협력하고 있으므로 (:meth:`__new__` "
"는 만들고, :meth:`__init__` 는 그것을 커스터마이즈합니다), :meth:`__init__` 가 ``None`` 이외의"
" 값을 돌려주면 실행시간에 :exc:`TypeError` 를 일으킵니다."

#: ../../reference/datamodel.rst:1915
msgid ""
"Called when the instance is about to be destroyed.  This is also called a"
" finalizer or (improperly) a destructor.  If a base class has a "
":meth:`__del__` method, the derived class's :meth:`__del__` method, if "
"any, must explicitly call it to ensure proper deletion of the base class "
"part of the instance."
msgstr ""
"인스턴스가 파괴되기 직전에 호출됩니다. 파이널라이저 또는 (부적절하게) 파괴자라고 불립니다. 만약 베이스 클래스가 "
":meth:`__del__` 메서드를 갖고 있다면, 자식 클래스의 :meth:`__del__` 메서드는, 정의되어 있다면, "
"인스턴스에서 베이스 클래스가 차지하는 부분을 적절하게 삭제하기 위해, 명시적으로 베이스 클래스의 메서드를 호출해야 합니다."

#: ../../reference/datamodel.rst:1921
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method "
"to postpone destruction of the instance by creating a new reference to "
"it.  This is called object *resurrection*.  It is implementation-"
"dependent whether :meth:`__del__` is called a second time when a "
"resurrected object is about to be destroyed; the current :term:`CPython` "
"implementation only calls it once."
msgstr ""
"(권장하지는 않지만!) :meth:`__del__` 메서드는 인스턴스에 대한 새로운 참조를 만듦으로써 인스턴스의 파괴를 지연시킬 수"
" 있습니다. 이것을 객체 *부활* 이라고 부릅니다. 부활한 객체가 파괴될 때 :meth:`__del__` 이 두 번째로 호출될지는 "
"구현에 따라 다릅니다; 현재 :term:`CPython` 구현은 오직 한 번만 호출합니다."

#: ../../reference/datamodel.rst:1928
#, fuzzy
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be "
"called when an object is garbage collected."
msgstr "인터프리터가 종료할 때 아직 남아있는 객체들에 대해서는 :meth:`__del__` 메서드의 호출이 보장되지 않습니다."

#: ../../reference/datamodel.rst:1935
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements"
" the reference count for ``x`` by one, and the latter is only called when"
" ``x``'s reference count reaches zero."
msgstr ""
"``del x`` 는 직접 ``x.__del__()`` 를 호출하지 않습니다 --- 앞에 있는 것은 ``x`` 의 참조 "
"횟수(reference count)를 하나 감소시키고, 뒤에 있는 것은 ``x`` 의 참조 횟수가 0 이 될 때 호출됩니다."

#: ../../reference/datamodel.rst:1940
msgid ""
"It is possible for a reference cycle to prevent the reference count of an"
" object from going to zero.  In this case, the cycle will be later "
"detected and deleted by the :term:`cyclic garbage collector <garbage "
"collection>`.  A common cause of reference cycles is when an exception "
"has been caught in a local variable.  The frame's locals then reference "
"the exception, which references its own traceback, which references the "
"locals of all frames caught in the traceback."
msgstr ""

#: ../../reference/datamodel.rst:1950
msgid "Documentation for the :mod:`gc` module."
msgstr ":mod:`gc` 모듈에 대한 문서."

#: ../../reference/datamodel.rst:1954
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods "
"are invoked, exceptions that occur during their execution are ignored, "
"and a warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
":meth:`__del__` 이 호출되는 불안정한 상황 때문에, 이것이 실행 중에 발생시키는 예외는 무시되고, 대신에 "
"``sys.stderr`` 로 경고가 출력됩니다. 특히:"

#: ../../reference/datamodel.rst:1958
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the "
"resource may already be taken by the code that gets interrupted to "
"execute :meth:`__del__`."
msgstr ""
":meth:`__del__` 은 (임의의 스레드에서) 임의의 코드가 실행되는 동안 호출될 수 있습니다. :meth:`__del__`"
" 이 록을 얻어야 하거나 다른 블로킹 자원을 호출하면, :meth:`__del__` 을 실행하기 위해 중단된 코드가 자원을 이미 "
"차지했을 수 있으므로 교착 상태에 빠질 수 있습니다."

#: ../../reference/datamodel.rst:1964
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python "
"guarantees that globals whose name begins with a single underscore are "
"deleted from their module before other globals are deleted; if no other "
"references to such globals exist, this may help in assuring that imported"
" modules are still available at the time when the :meth:`__del__` method "
"is called."
msgstr ""
":meth:`__del__` 은 인터프리터를 종료할 때 실행될 수 있습니다. 결과적으로, 액세스해야 하는 전역 변수(다른 모듈 "
"포함)가 이미 삭제되었거나 ``None`` 으로 설정되었을 수 있습니다. 파이썬은 이름이 하나의 밑줄로 시작하는 전역 객체가 다른 "
"전역 객체들보다 먼저 삭제됨을 보장합니다; 이것은, 만약 그 전역 객체들에 대한 다른 참조가 존재하지 않는다면, "
":meth:`__del__` 메서드가 호출되는 시점에, 임포트된 모듈들이 남아있도록 확실히 하는 데 도움이 될 수 있습니다."

#: ../../reference/datamodel.rst:1979
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look"
" like a valid Python expression that could be used to recreate an object "
"with the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should"
" be returned. The return value must be a string object. If a class "
"defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` "
"is also used when an \"informal\" string representation of instances of "
"that class is required."
msgstr ""
":func:`repr` 내장 함수에 의해 호출되어 객체의 \"형식적인(official)\" 문자열 표현을 계산합니다. 만약 "
"가능하다면, 이것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 수 있는 올바른 파이썬 표현식처럼 보여야 합니다."
" 가능하지 않다면, ``<...쓸모있는 설명...>`` 형태의 문자열을 돌려줘야 합니다. 반환 값은 반드시 문자열이어야 합니다. "
"만약 클래스가 :meth:`__str__` 없이 :meth:`__repr__` 만 정의한다면, :meth:`__repr__` 은 그"
" 클래스 인스턴스의 \"비형식적인(informal)\" 문자열 표현이 요구될 때 사용될 수 있습니다."

#: ../../reference/datamodel.rst:1988
#, fuzzy
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous. A default "
"implementation is provided by the :class:`object` class itself."
msgstr "이것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않게 하는 것이 중요합니다."

#: ../../reference/datamodel.rst:2000
#, fuzzy
msgid ""
"Called by :func:`str(object) <str>`, the default :meth:`__format__` "
"implementation, and the built-in function :func:`print`, to compute the "
"\"informal\" or nicely printable string representation of an object.  The"
" return value must be a :ref:`str <textseq>` object."
msgstr ""
":func:`str(object) <str>` 와 내장 함수 :func:`format`, :func:`print` 에 의해 호출되어"
" 객체의 \"비형식적인(informal)\" 또는 보기 좋게 인쇄 가능한 문자열 표현을 계산합니다. 반환 값은 반드시 "
":ref:`문자열 <textseq>` 객체여야 합니다."

#: ../../reference/datamodel.rst:2005
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more"
" convenient or concise representation can be used."
msgstr ""
"이 메서드는 :meth:`__str__` 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 점에서 "
":meth:`object.__repr__` 과 다릅니다: 더 편리하고 간결한 표현이 사용될 수 있습니다."

#: ../../reference/datamodel.rst:2009
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr "내장형 :class:`object` 에 정의된 기본 구현은 :meth:`object.__repr__` 을 호출합니다."

#: ../../reference/datamodel.rst:2019
#, fuzzy
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string "
"representation of an object. This should return a :class:`bytes` object. "
"The :class:`object` class itself does not provide this method."
msgstr ""
":ref:`bytes <func-bytes>` 에 의해 호출되어 객체의 바이트열 표현을 계산합니다. 반환 값은 반드시 "
":class:`bytes` 객체여야 합니다."

#: ../../reference/datamodel.rst:2031
msgid ""
"Called by the :func:`format` built-in function, and by extension, "
"evaluation of :ref:`formatted string literals <f-strings>` and the "
":meth:`str.format` method, to produce a \"formatted\" string "
"representation of an object. The *format_spec* argument is a string that "
"contains a description of the formatting options desired. The "
"interpretation of the *format_spec* argument is up to the type "
"implementing :meth:`__format__`, however most classes will either "
"delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
":func:`format` 내장 함수, 확대하면, :ref:`포맷 문자열 리터럴(formatted string literals) "
"<f-strings>` 의 계산과 :meth:`str.format` 메서드에 의해 호출되어, 객체의 \"포맷된\" 문자열 표현을 "
"만들어냅니다. *format_spec* 인자는 요구되는 포맷 옵션들을 포함하는 문자열입니다. *format_spec* 인자의 해석은"
" :meth:`__format__` 을 구현하는 형에 달려있으나, 대부분 클래스는 포매팅을 내향형들의 하나로 위임하거나, 비슷한 "
"포맷 옵션 문법을 사용합니다."

#: ../../reference/datamodel.rst:2041
msgid "See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr "표준 포매팅 문법에 대해서는 :ref:`formatspec` 를 참고하면 됩니다."

#: ../../reference/datamodel.rst:2043
msgid "The return value must be a string object."
msgstr "반환 값은 반드시 문자열이어야 합니다."

#: ../../reference/datamodel.rst:2045
msgid ""
"The default implementation by the :class:`object` class should be given "
"an empty *format_spec* string. It delegates to :meth:`__str__`."
msgstr ""

#: ../../reference/datamodel.rst:2048
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"``object`` 의 __format__ 메서드 자신은, 빈 문자열이 아닌 인자가 전달되면 :exc:`TypeError` 를 "
"발생시킵니다."

#: ../../reference/datamodel.rst:2052
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"이제 ``object.__format__(x, '')`` 는 ``format(str(x), '')`` 가 아니라 ``str(x)``"
" 와 동등합니다."

#: ../../reference/datamodel.rst:2068
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"이것들은 소위 \"풍부한 비교(rich comparison)\" 메서드입니다. 연산자 기호와 메서드 이름 간의 관계는 다음과 "
"같습니다: ``x<y`` 는 ``x.__lt__(y)`` 를 호출합니다, ``x<=y`` 는 ``x.__le__(y)`` 를 "
"호출합니다, ``x==y`` 는 ``x.__eq__(y)`` 를 호출합니다, ``x!=y`` 는 ``x.__ne__(y)`` 를 "
"호출합니다, ``x>y`` 는 ``x.__gt__(y)`` 를 호출합니다, ``x>=y`` 는 ``x.__ge__(y)`` 를 "
"호출합니다."

#: ../../reference/datamodel.rst:2074
#, fuzzy
msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` "
"if it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful "
"comparison. However, these methods can return any value, so if the "
"comparison operator is used in a Boolean context (e.g., in the condition "
"of an ``if`` statement), Python will call :func:`bool` on the value to "
"determine if the result is true or false."
msgstr ""
"풍부한 비교 메서드는 주어진 한 쌍의 인자에게 해당 연산을 구현하지 않는 경우 단일자(singleton) "
"``NotImplemented`` 를 돌려줄 수 있습니다. 관례상, 성공적인 비교면 ``False`` 나 ``True`` 를 "
"돌려줍니다. 하지만, 이 메서드는 어떤 형의 값이건 돌려줄 수 있습니다, 그래서 비교 연산자가 논리 문맥(Boolean "
"context) (예를 들어 ``if`` 문의 조건)에서 사용되면, 파이썬은 결과의 참 거짓을 파악하기 위해 값에 대해 "
":func:`bool` 을 호출합니다."

#: ../../reference/datamodel.rst:2081
#, fuzzy
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, "
"returning :data:`NotImplemented` in the case of a false comparison: "
"``True if x is y else NotImplemented``. For :meth:`__ne__`, by default it"
" delegates to :meth:`__eq__` and inverts the result unless it is "
":data:`!NotImplemented`.  There are no other implied relationships among "
"the comparison operators or default implementations; for example, the "
"truth of ``(x<y or x==y)`` does not imply ``x<=y``. To automatically "
"generate ordering operations from a single root operation, see "
":func:`functools.total_ordering`."
msgstr ""
"기본적으로, ``object``\\는 ``is``\\를 사용해서 거짓으로 비교될 때 ``NotImplemented``\\를 반환하는"
" :meth:`__eq__`\\를 구현합니다: ``True if x is y else NotImplemented``. "
":meth:`__ne__`\\의 경우는, 기본적으로 :meth:`__eq__`\\에 위임하고 ``NotImplemented`` 가 "
"아니라면 그 결과를 뒤집습니다. 비교 연산자나 기본 구현 간의 다른 암시적인 관계는 없습니다; 예를 들어, ``(x<y or "
"x==y)`` 가 참이라고 해서 ``x<=y`` 가 참일 필요는 없습니다. 하나의 기본 연산으로부터 대소관계 연산을 자동으로 "
"만들어내려면, :func:`functools.total_ordering`\\을 보십시오."

#: ../../reference/datamodel.rst:2090
msgid ""
"By default, the :class:`object` class provides implementations consistent"
" with :ref:`expressions-value-comparisons`: equality compares according "
"to object identity, and order comparisons raise :exc:`TypeError`. Each "
"default method may generate these results directly, but may also return "
":data:`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:2096
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on "
"creating :term:`hashable` objects which support custom comparison "
"operations and are usable as dictionary keys."
msgstr ""
"사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 :term:`해시 가능 <hashable>` 객체를 만드는 것에 "
"관한 몇 가지 중요한 내용이 :meth:`__hash__` 에 관한 문단에 나옵니다."

#: ../../reference/datamodel.rst:2100
#, fuzzy
msgid ""
"There are no swapped-argument versions of these methods (to be used when "
"the left argument does not support the operation but the right argument "
"does); rather, :meth:`__lt__` and :meth:`__gt__` are each other's "
"reflection, :meth:`__le__` and :meth:`__ge__` are each other's "
"reflection, and :meth:`__eq__` and :meth:`__ne__` are their own "
"reflection. If the operands are of different types, and the right "
"operand's type is a direct or indirect subclass of the left operand's "
"type, the reflected method of the right operand has priority, otherwise "
"the left operand's method has priority.  Virtual subclassing is not "
"considered."
msgstr ""
"이 메서드들에 대한 (왼편의 인자는 연산을 지원하지 않지만, 오른편 인자가 지원할 때 사용되는) 뒤집힌 버전은 따로 없습니다; "
"대신에 :meth:`__lt__` 와 :meth:`__gt__` 는 서로의 뒤집힌 연산입니다; :meth:`__le__` 와 "
":meth:`__ge__` 는 서로의 뒤집힌 연산입니다; :meth:`__eq__` 와 :meth:`__ne__` 는 서로의 뒤집힌"
" 연산입니다; 만약 피연산자가 서로 다른 형이고, 오른편 피연산자의 형이 왼편 피연산자의 형의 직간접적인 서브 클래스면, 오른편 "
"피연산자의 뒤집힌 버전이 우선순위가 높습니다; 그렇지 않으면 왼편 피연산자의 메서드가 우선순위가 높습니다. 가상 서브 "
"클래싱(virtual subclassing)은 고려되지 않습니다."

#: ../../reference/datamodel.rst:2111
msgid ""
"When no appropriate method returns any value other than "
":data:`NotImplemented`, the ``==`` and ``!=`` operators will fall back to"
" ``is`` and ``is not``, respectively."
msgstr ""

#: ../../reference/datamodel.rst:2120
#, fuzzy
msgid ""
"Called by built-in function :func:`hash` and for operations on members of"
" hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  The ``__hash__()`` method should return an integer. The "
"only required property is that objects which compare equal have the same "
"hash value; it is advised to mix together the hash values of the "
"components of the object that also play a part in comparison of objects "
"by packing them into a tuple and hashing the tuple. Example::"
msgstr ""
"내장 함수 :func:`hash` 와 :class:`set`, :class:`frozenset`, :class:`dict` 와 같은"
" 해시형 컬렉션의 멤버에 대한 연산에서 호출됩니다. :meth:`__hash__` 는 정수를 돌려줘야 합니다. 같다고 비교되는 "
"객체들이 같은 해시값을 가져야 한다는 성질만 요구됩니다. 객체의 비교에 사용되는 요소들로 튜플을 구성하고, 그 튜플의 해시값을 "
"취함으로써 요소들의 해시값을 섞는 것을 권합니다. 예를 들면::"

#: ../../reference/datamodel.rst:2128
msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""

#: ../../reference/datamodel.rst:2133
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way "
"to do this is with ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` 는 객체가 정의한 :meth:`__hash__` 메서드가 돌려주는 값을 :c:type:`Py_ssize_t`"
" 의 크기로 자릅니다(truncate). 이것은 보통 64-bit 빌드에서는 8바이트고, 32-bit 빌드에서는 4바이트입니다. "
"만약 객체의 :meth:`__hash__` 가 서로 다른 비트 크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 "
"빌드들에서의 폭을 검사해야 합니다. 이렇게 하는 쉬운 방법은 ``python -c \"import sys; "
"print(sys.hash_info.width)\"`` 입니다."

#: ../../reference/datamodel.rst:2141
#, fuzzy
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define "
"a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but not"
" :meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since "
"the implementation of :term:`hashable` collections requires that a key's "
"hash value is immutable (if the object's hash value changes, it will be "
"in the wrong hash bucket)."
msgstr ""
"만약 클래스가 :meth:`__eq__` 를 정의하지 않으면 :meth:`__hash__` 역시 정의하지 말아야 합니다. 만약 "
":meth:`__eq__` 를 정의하지만 :meth:`__hash__` 를 정의하지 않는다면, 그것의 인스턴스는 해시 가능 "
"컬렉션에서 사용될 수 없습니다. 만약 클래스가 가변형 객체를 정의하고 있고 :meth:`__eq__` 를 구현한다면, "
":meth:`__hash__` 를 구현하지 말아야 하는데, 해시 가능 컬렉션들의 구현이 키의 해시값이 불변이도록 요구하고 있기 "
"때문입니다(만약 객체의 해시값이 변하면, 잘못된 해시 버킷(hash bucket)에 있게 됩니다)."

#: ../../reference/datamodel.rst:2150
#, fuzzy
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default (inherited from the :class:`object` class); with them, all "
"objects compare unequal (except with themselves) and ``x.__hash__()`` "
"returns an appropriate value such that ``x == y`` implies both that ``x "
"is y`` and ``hash(x) == hash(y)``."
msgstr ""
"사용자 정의 클래스는 기본적으로 :meth:`__eq__` 와 :meth:`__hash__` 메서드를 갖습니다; 모든 객체는 (자기"
" 자신을 제외하고) 같지 않다고 비교되고, ``x.__hash__()`` 는 적절한 값을 돌려주어, ``x == y`` 일 때 "
"``x is y`` 와 ``hash(x) == hash(y)`` 가 동시에 성립할 수 있도록 합니다."

#: ../../reference/datamodel.rst:2155
msgid ""
"A class that overrides :meth:`__eq__` and does not define "
":meth:`__hash__` will have its :meth:`__hash__` implicitly set to "
"``None``.  When the :meth:`__hash__` method of a class is ``None``, "
"instances of the class will raise an appropriate :exc:`TypeError` when a "
"program attempts to retrieve their hash value, and will also be correctly"
" identified as unhashable when checking ``isinstance(obj, "
"collections.abc.Hashable)``."
msgstr ""
":meth:`__eq__` 를 재정의하고 :meth:`__hash__` 를 정의하지 않는 클래스는 :meth:`__hash__` 가"
" ``None`` 으로 설정됩니다. 클래스의 :meth:`__hash__` 메서드가 ``None`` 이면, 클래스의 인스턴스는 "
"프로그램이 해시값을 얻으려 시도할 때 :exc:`TypeError` 를 일으키고, ``isinstance(obj, "
"collections.abc.Hashable)`` 로 검사할 때 해시 가능하지 않다고 올바로 감지됩니다."

#: ../../reference/datamodel.rst:2162
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the "
"implementation of :meth:`__hash__` from a parent class, the interpreter "
"must be told this explicitly by setting ``__hash__ = "
"<ParentClass>.__hash__``."
msgstr ""
"만약 :meth:`__eq__` 를 재정의하는 클래스가 부모 클래스로부터 :meth:`__hash__` 의 구현을 물려받고 싶으면 "
"인터프리터에게 명시적으로 이렇게 지정해주어야 합니다: ``__hash__ = <ParentClass>.__hash__``."

#: ../../reference/datamodel.rst:2166
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A"
" class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"만약 :meth:`__eq__` 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 ``__hash__ = "
"None`` 을 포함해야 합니다. 자신의 :meth:`__hash__` 을 정의한 후에 직접 :exc:`TypeError` 를 "
"일으키는 경우는 ``isinstance(obj, collections.abc.Hashable)`` 호출이 해시 가능하다고 잘못 "
"인식합니다."

#: ../../reference/datamodel.rst:2175
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"기본적으로, str과 bytes 객체들의 :meth:`__hash__` 값은 예측할 수 없는 난수값으로 "
"\"솔트되어(salted)\" 있습니다. 개별 파이썬 프로세스 내에서는 변하지 않는 값으로 유지되지만, 파이썬을 반복적으로 실행할 "
"때는 예측할 수 없게 됩니다."

#: ../../reference/datamodel.rst:2180
#, fuzzy
msgid ""
"This is intended to provide protection against a denial-of-service caused"
" by carefully chosen inputs that exploit the worst case performance of a "
"dict insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See "
"http://ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"이것은 dict 삽입의 최악의 경우 성능(worst case performance), O(n^2) 복잡도, 을 활용하기 위해 주의 "
"깊게 선택한 입력에 의한 서비스 거부(denial-of-service) 공격에 대한 방어를 제공하기 위한 목적입니다. 자세한 내용은"
" http://www.ocert.org/advisories/ocert-2011-003.html 에 있습니다."

#: ../../reference/datamodel.rst:2185
msgid ""
"Changing hash values affects the iteration order of sets. Python has "
"never made guarantees about this ordering (and it typically varies "
"between 32-bit and 64-bit builds)."
msgstr ""
"해시값의 변경은 집합의 이터레이션 순서에 영향을 줍니다, 파이썬은 이 순서에 대해 어떤 보장도 하지 않습니다 (그리고 보통 "
"32-bit 와 64-bit 빌드 사이에서도 다릅니다)."

#: ../../reference/datamodel.rst:2189
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ":envvar:`PYTHONHASHSEED` 를 참고하십시오."

#: ../../reference/datamodel.rst:2191
msgid "Hash randomization is enabled by default."
msgstr "해시 난수 화는 기본적으로 활성화됩니다."

#: ../../reference/datamodel.rst:2199
#, fuzzy
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not"
" defined, :meth:`~object.__len__` is called, if it is defined, and the "
"object is considered true if its result is nonzero.  If a class defines "
"neither :meth:`!__len__` nor :meth:`!__bool__` (which is true of the "
":class:`object` class itself), all its instances are considered true."
msgstr ""
"논리값 검사와 내장 연산 ``bool()`` 구현을 위해 호출됩니다; ``False`` 나 ``True`` 를 돌려줘야 합니다. 이"
" 메서드가 정의되지 않는 경우, 정의되어 있다면 :meth:`__len__` 이 호출되어, 값이 0 이 아니면 참으로 인식합니다. "
"만약 클래스가 :meth:`__len__` 과 :meth:`__bool__` 모두 정의하지 않는다면, 모든 인스턴스는 참으로 "
"취급됩니다."

#: ../../reference/datamodel.rst:2210
msgid "Customizing attribute access"
msgstr "어트리뷰트 액세스 커스터마이제이션"

#: ../../reference/datamodel.rst:2212
msgid ""
"The following methods can be defined to customize the meaning of "
"attribute access (use of, assignment to, or deletion of ``x.name``) for "
"class instances."
msgstr ""
"클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, ``x.name`` 을 삭제하기)의 의미를 변경하기 위해 다음과 같은 메서드들이"
" 정의될 수 있습니다."

#: ../../reference/datamodel.rst:2220
#, fuzzy
msgid ""
"Called when the default attribute access fails with an "
":exc:`AttributeError` (either :meth:`__getattribute__` raises an "
":exc:`AttributeError` because *name* is not an instance attribute or an "
"attribute in the class tree for ``self``; or :meth:`__get__` of a *name* "
"property raises :exc:`AttributeError`).  This method should either return"
" the (computed) attribute value or raise an :exc:`AttributeError` "
"exception. The :class:`object` class itself does not provide this method."
msgstr ""
"기본 어트리뷰트 액세스가 :exc:`AttributeError` 로 실패할 때 호출됩니다 (*name* 이 인스턴스 어트리뷰트 또는"
" ``self`` 의 클래스 트리에 있는 어트리뷰트가 아니라서 :meth:`__getattribute__` 가 "
":exc:`AttributeError` 를 일으키거나; *name* 프로퍼티의 :meth:`__get__` 이 "
":exc:`AttributeError` 를 일으킬 때). 이 메서드는 (계산된) 어트리뷰트 값을 반환하거나 "
":exc:`AttributeError` 예외를 일으켜야 합니다."

#: ../../reference/datamodel.rst:2228
#, fuzzy
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both "
"for efficiency reasons and because otherwise :meth:`__getattr__` would "
"have no way to access other attributes of the instance.  Note that at "
"least for instance variables, you can take total control by not inserting"
" any values in the instance attribute dictionary (but instead inserting "
"them in another object).  See the :meth:`__getattribute__` method below "
"for a way to actually get total control over attribute access."
msgstr ""
"일반적인 메커니즘을 통해 어트리뷰트가 발견되면 :meth:`__getattr__` 이 호출되지 않음에 주의해야 합니다 (이것은 "
":meth:`__getattr__` 과 :meth:`__setattr__` 간의 의도된 비대칭입니다). 이렇게 하는 이유는 효율 "
"때문이기도 하고, 그렇게 하지 않으면 :meth:`__getattr__` 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 "
"때문이기도 합니다. 적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그것들을 다른 "
"객체에 넣습니다) 완전한 제어인 것처럼 조작할 수 있습니다. 어트리뷰트 액세스를 실제로 완전히 조작하는 방법에 대해서는 아래에 "
"나오는 :meth:`__getattribute__` 에서 다룹니다."

#: ../../reference/datamodel.rst:2241
msgid ""
"Called unconditionally to implement attribute accesses for instances of "
"the class. If the class also defines :meth:`__getattr__`, the latter will"
" not be called unless :meth:`__getattribute__` either calls it explicitly"
" or raises an :exc:`AttributeError`. This method should return the "
"(computed) attribute value or raise an :exc:`AttributeError` exception. "
"In order to avoid infinite recursion in this method, its implementation "
"should always call the base class method with the same name to access any"
" attributes it needs, for example, ``object.__getattribute__(self, "
"name)``."
msgstr ""
"클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건 없이 호출됩니다. 만약 클래스가 :meth:`__getattr__` 도 "
"함께 구현하면, :meth:`__getattribute__` 가 명시적으로 호출하거나 :exc:`AttributeError` 를 "
"일으키지 않는 이상 `__getattr__` 는 호출되지 않습니다. 이 메서드는 어트리뷰트의 (계산된) 값을 돌려주거나 "
":exc:`AttributeError` 예외를 일으켜야 합니다. 이 메서드에서 무한 재귀(infinite recursion)가 "
"발생하는 것을 막기 위해, 구현은 언제나 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. "
"예를 들어, ``object.__getattribute__(self, name)``."

#: ../../reference/datamodel.rst:2252
#, fuzzy
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""
"언어 문법이나 내장 함수에 의한 묵시적인 호출이 결과로 특수 메서드를 참조하는 경우에는 이 메서드를 거치지 않을 수 있습니다. "
"자세한 내용은 :ref:`special-lookup` 에서 다룹니다."

#: ../../reference/datamodel.rst:2257 ../../reference/datamodel.rst:2259
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"특정 민감한 어트리뷰트 액세스의 경우, 인자 ``obj``\\와 ``name``\\으로 :ref:`감사 이벤트 <auditing>`"
" ``object.__getattr__``\\을 발생시킵니다."

#: ../../reference/datamodel.rst:2266
msgid ""
"Called when an attribute assignment is attempted.  This is called instead"
" of the normal mechanism (i.e. store the value in the instance "
"dictionary). *name* is the attribute name, *value* is the value to be "
"assigned to it."
msgstr ""
"어트리뷰트 대입이 시도될 때 호출됩니다. 일반적인 메커니즘(즉 인스턴스 딕셔너리에 값을 저장하는 것) 대신에 이것이 호출됩니다. "
"*name* 은 어트리뷰트 이름이고, *value* 는 그것에 대입하려는 값입니다. "

#: ../../reference/datamodel.rst:2270
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it "
"should call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` 에서 인스턴스 어트리뷰트에 대입하려고 할 때는, 같은 이름의 베이스 클래스의 메서드를 호출해야 "
"합니다. 예를 들어 ``object.__setattr__(self, name, value)``"

#: ../../reference/datamodel.rst:2274 ../../reference/datamodel.rst:2276
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing "
"event <auditing>` ``object.__setattr__`` with arguments ``obj``, "
"``name``, ``value``."
msgstr ""
"특정 민감한 어트리뷰트 대입의 경우, 인자 ``obj``, ``name``, ``value``\\로 :ref:`감사 이벤트 "
"<auditing>` ``object.__setattr__``\\을 발생시킵니다."

#: ../../reference/datamodel.rst:2283
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of "
"assignment.  This should only be implemented if ``del obj.name`` is "
"meaningful for the object."
msgstr ""
":meth:`__setattr__` 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제합니다. 이것은 ``del obj.name`` 이"
" 객체에 의미가 있는 경우에만 구현되어야 합니다."

#: ../../reference/datamodel.rst:2286 ../../reference/datamodel.rst:2288
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event"
" <auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"특정 민감한 어트리뷰트 삭제의 경우, 인자 ``obj``\\와 ``name``\\으로 :ref:`감사 이벤트 <auditing>` "
"``object.__delattr__``\\을 발생시킵니다."

#: ../../reference/datamodel.rst:2295
#, fuzzy
msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts "
"it."
msgstr ""
"객체에 :func:`dir` 이 호출될 때 호출됩니다. 시퀀스를 돌려줘야 합니다. :func:`dir` 은 돌려준 시퀀스를 리스트로"
" 변환한 후 정렬합니다."

#: ../../reference/datamodel.rst:2300
msgid "Customizing module attribute access"
msgstr "모듈 어트리뷰트 액세스 커스터마이제이션"

#: ../../reference/datamodel.rst:2307
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to "
"customize access to module attributes. The ``__getattr__`` function at "
"the module level should accept one argument which is the name of an "
"attribute and return the computed value or raise an "
":exc:`AttributeError`. If an attribute is not found on a module object "
"through the normal lookup, i.e. :meth:`object.__getattribute__`, then "
"``__getattr__`` is searched in the module ``__dict__`` before raising an "
":exc:`AttributeError`. If found, it is called with the attribute name and"
" the result is returned."
msgstr ""
"특수한 이름 ``__getattr__`` 과 ``__dir__`` 는 모듈 어트리뷰트에 대한 접근을 사용자 정의하는 데 사용될 수도"
" 있습니다. 모듈 수준의 ``__getattr__`` 함수는 하나의 인자로 어트리뷰트의 이름을 받아서 계산된 값을 돌려주거나 "
":exc:`AttributeError` 를 발생시켜야 합니다. 일반적인 조회(즉 "
":meth:`object.__getattribute__`)를 통해 어트리뷰트가 모듈 객체에서 발견되지 않으면, "
":exc:`AttributeError` 를 일으키기 전에 모듈 ``__dict__`` 에서 ``__getattr__`` 을 "
"검색합니다. 발견되면, 어트리뷰트 이름으로 그 함수를 호출하고 결과를 돌려줍니다."

#: ../../reference/datamodel.rst:2316
#, fuzzy
msgid ""
"The ``__dir__`` function should accept no arguments, and return an "
"iterable of strings that represents the names accessible on module. If "
"present, this function overrides the standard :func:`dir` search on a "
"module."
msgstr ""
"``__dir__`` 함수는 인자를 받지 않고 모듈에서 접근 할 수 있는 이름을 나타내는 문자열의 시퀀스를 돌려줘야 합니다. "
"존재하면, 이 함수는 모듈에 대한 표준 :func:`dir` 검색을 재정의합니다."

#: ../../reference/datamodel.rst:2320
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of"
" a module object to a subclass of :class:`types.ModuleType`. For "
"example::"
msgstr ""
"모듈 동작(어트리뷰트 설정, 프로퍼티 등)을 보다 세밀하게 사용자 정의하려면, 모듈 객체의 ``__class__`` 어트리뷰트를 "
":class:`types.ModuleType` 의 서브 클래스로 설정할 수 있습니다. 예를 들면::"

#: ../../reference/datamodel.rst:2324
#, python-brace-format
msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""

#: ../../reference/datamodel.rst:2338
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only "
"affect lookups made using the attribute access syntax -- directly "
"accessing the module globals (whether by code within the module, or via a"
" reference to the module's globals dictionary) is unaffected."
msgstr ""
"모듈 ``__getattr__`` 정의와 모듈 ``__class__`` 설정은 어트리뷰트 액세스 구문을 사용하는 조회에만 영향을 "
"미칩니다 -- 모듈 전역에 대한 직접적인 액세스(모듈 내의 코드에 의한 액세스이거나 모듈의 전역 딕셔너리에 대한 참조를 거치거나)는"
" 영향받지 않습니다."

#: ../../reference/datamodel.rst:2343
msgid "``__class__`` module attribute is now writable."
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../../reference/datamodel.rst:2346
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "``__getattr__`` 과 ``__dir__`` 모듈 어트리뷰트."

#: ../../reference/datamodel.rst:2351
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - 모듈 __getattr__ 과 __dir__"

#: ../../reference/datamodel.rst:2352
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "모듈에 대한 ``__getattr__`` 과 ``__dir__`` 함수를 설명합니다."

#: ../../reference/datamodel.rst:2358
msgid "Implementing Descriptors"
msgstr "디스크립터 구현하기"

#: ../../reference/datamodel.rst:2360
#, fuzzy
msgid ""
"The following methods only apply when an instance of the class containing"
" the method (a so-called *descriptor* class) appears in an *owner* class "
"(the descriptor must be in either the owner's class dictionary or in the "
"class dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property"
" in the owner class' :attr:`~object.__dict__`.  The :class:`object` class"
" itself does not implement any of these protocols."
msgstr ""
"다음에 오는 메서드들은 메서드를 가진 클래스(소위 *디스크립터(descriptor)* 클래스)의 인스턴스가 *소유자(owner)* "
"클래스에 등장할 때만 적용됩니다(디스크립터는 소유자 클래스의 딕셔너리나 그 부모 클래스 중 하나의 딕셔너리에 있어야 합니다). "
"아래의 예에서, \"어트리뷰트\" 는 이름이 소유자 클래스의 :attr:`~object.__dict__` 의 키로 사용되고 있는 "
"어트리뷰트를 가리킵니다."

#: ../../reference/datamodel.rst:2370
msgid ""
"Called to get the attribute of the owner class (class attribute access) "
"or of an instance of that class (instance attribute access). The optional"
" *owner* argument is the owner class, while *instance* is the instance "
"that the attribute was accessed through, or ``None`` when the attribute "
"is accessed through the *owner*."
msgstr ""
"소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 어트리뷰트를 취하려고 할 때 "
"호출됩니다. 선택적 *owner* 인자는 소유자 클래스입니다. 반면에 *instance* 는 어트리뷰트 참조가 일어나고 있는 "
"인스턴스이거나, 어트리뷰트가 *owner* 를 통해 액세스 되는 경우 `None` 입니다."

#: ../../reference/datamodel.rst:2376
msgid ""
"This method should return the computed attribute value or raise an "
":exc:`AttributeError` exception."
msgstr "이 메서드는 계산된 어트리뷰트 값을 돌려주거나 :exc:`AttributeError` 예외를 일으켜야 합니다."

#: ../../reference/datamodel.rst:2379
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification;"
" however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required "
"or not."
msgstr ""
":PEP:`252`\\는 :meth:`__get__`\\이 하나나 두 개의 인자를 갖는 콜러블이라고 지정합니다. 파이썬 자신의 내장"
" 디스크립터는 이 명세를 지원합니다; 그러나, 일부 제삼자 도구에는 두 인수를 모두 요구하는 디스크립터가 있을 수 있습니다. 파이썬"
" 자신의 :meth:`__getattribute__` 구현은 필요한지와 관계없이 항상 두 인자를 모두 전달합니다."

#: ../../reference/datamodel.rst:2388
msgid ""
"Called to set the attribute on an instance *instance* of the owner class "
"to a new value, *value*."
msgstr "소유자 클래스의 인스턴스 *instance* 의 어트리뷰트를 새 값 *value* 로 설정할 때 호출됩니다."

#: ../../reference/datamodel.rst:2391
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` "
"for more details."
msgstr ""
":meth:`__set__`\\이나 :meth:`__delete__`\\를 추가하면 디스크립터 유형이 \"데이터 디스크립터(data"
" descriptor)\"로 변경됨에 유의하십시오. 자세한 내용은 :ref:`descriptor-invocation`\\를 "
"참조하십시오."

#: ../../reference/datamodel.rst:2397
msgid ""
"Called to delete the attribute on an instance *instance* of the owner "
"class."
msgstr "소유자 클래스의 인스턴스 *instance* 의 어트리뷰트를 삭제할 때 호출됩니다."

#: ../../reference/datamodel.rst:2399
msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` "
"attribute present:"
msgstr ""

#: ../../reference/datamodel.rst:2404
#, fuzzy
msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting "
"this appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given"
" type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods "
"that are implemented in C)."
msgstr ""
"어트리뷰트 :attr:`__objclass__` 는 :mod:`inspect` 모듈에 의해 이 객체가 정의된 클래스를 지정하는 "
"것으로 해석됩니다(이 값을 적절히 설정하면 동적인 클래스 어트리뷰트의 실행시간 인트로스펙션(introspection)을 지원할 수 "
"있습니다). 콜러블의 경우, 첫 번째 위치 인자에, 주어진 형(또는 서브 클래스)의 인스턴스가 기대되거나 요구됨을 가리킬 수 "
"있습니다(예를 들어, CPython 은 C로 구현된 연결되지 않은 메서드(unbound method)에 이 어트리뷰트를 "
"설정합니다)."

#: ../../reference/datamodel.rst:2415
msgid "Invoking Descriptors"
msgstr "디스크립터 호출하기"

#: ../../reference/datamodel.rst:2417
#, fuzzy
msgid ""
"In general, a descriptor is an object attribute with \"binding "
"behavior\", one whose attribute access has been overridden by methods in "
"the descriptor protocol:  :meth:`~object.__get__`, "
":meth:`~object.__set__`, and :meth:`~object.__delete__`. If any of those "
"methods are defined for an object, it is said to be a descriptor."
msgstr ""
"일반적으로, 디스크립터는 \"결합한 동작(binding behavior)\"을 가진 객체 어트리뷰트입니다. 어트리뷰트 액세스가 "
"디스크립터 프로토콜(descriptor protocol)의 메서드들에 의해 재정의됩니다: :meth:`__get__`, "
":meth:`__set__`, :meth:`__delete__`. 이 메서드들 중 하나라도 정의되어 있으면, 디스크립터라고 "
"부릅니다."

#: ../../reference/datamodel.rst:2423
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup"
" chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``,"
" and continuing through the base classes of ``type(a)`` excluding "
"metaclasses."
msgstr ""
"어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것입니다. 예를 들어 ``a.x`` 는 "
"``a.__dict__['x']`` 에서 시작해서 ``type(a).__dict__['x']`` 를 거쳐 ``type(a)`` 의 "
"메타 클래스를 제외한 베이스 클래스들을 거쳐 가는 일련의 조회로 구성됩니다."

#: ../../reference/datamodel.rst:2428
msgid ""
"However, if the looked-up value is an object defining one of the "
"descriptor methods, then Python may override the default behavior and "
"invoke the descriptor method instead.  Where this occurs in the "
"precedence chain depends on which descriptor methods were defined and how"
" they were called."
msgstr ""
"그러나, 만약 조회한 값이 디스크립터 메서드를 구현한 객체면, 파이썬은 기본 동작 대신에 디스크립터 메서드를 호출할 수 있습니다. "
"우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 메서드가 정의되어 있고 어떤 식으로 호출되는지에 따라 "
"다릅니다."

#: ../../reference/datamodel.rst:2433
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How "
"the arguments are assembled depends on ``a``:"
msgstr "디스크립터 호출의 시작점은 결합(binding)입니다, ``a.x``. 어떻게 인자들이 조합되는지는 ``a`` 에 따라 다릅니다:"

#: ../../reference/datamodel.rst:2436
msgid "Direct Call"
msgstr "직접 호출"

#: ../../reference/datamodel.rst:2437
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr "가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메서드를 직접 호출할 때입니다: ``x.__get__(a)``"

#: ../../reference/datamodel.rst:2440
msgid "Instance Binding"
msgstr "인스턴스 결합"

#: ../../reference/datamodel.rst:2441
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"객체 인스턴스에 결합하면, ``a.x`` 는 이런 호출로 변환됩니다: ``type(a).__dict__['x'].__get__(a,"
" type(a))``."

#: ../../reference/datamodel.rst:2444
msgid "Class Binding"
msgstr "클래스 결합"

#: ../../reference/datamodel.rst:2445
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr "클래스에 결합하면, ``A.x`` 는 이런 호출로 변환됩니다: ``A.__dict__['x'].__get__(None, A)``."

#: ../../reference/datamodel.rst:2448
msgid "Super Binding"
msgstr "Super 결합"

#: ../../reference/datamodel.rst:2449
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches "
"``a.__class__.__mro__`` for a base class ``B`` following ``A`` and then "
"returns ``B.__dict__['x'].__get__(a, A)``.  If not a descriptor, ``x`` is"
" returned unchanged."
msgstr ""

#: ../../reference/datamodel.rst:2486
#, fuzzy
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on"
" which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and "
":meth:`~object.__delete__`.  If it does not define :meth:`!__get__`, then"
" accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  "
"Normally, data descriptors define both :meth:`!__get__` and "
":meth:`!__set__`, while non-data descriptors have just the "
":meth:`!__get__` method.  Data descriptors with :meth:`!__get__` and "
":meth:`!__set__` (and/or :meth:`!__delete__`) defined always override a "
"redefinition in an instance dictionary.  In contrast, non-data "
"descriptors can be overridden by instances."
msgstr ""
"인스턴스 결합의 경우, 디스크립터 호출의 우선순위는 어떤 디스크립터 메서드가 정의되어있는지에 따라 다릅니다. 디스크립터는 "
":meth:`__get__`, :meth:`__set__`, :meth:`__delete__` 를 어떤 조합으로도 정의할 수 "
"있습니다. 만약 :meth:`__get__` 를 정의하지 않는다면, 어트리뷰트 액세스는, 객체의 인스턴스 딕셔너리에 값이 있지 않은"
" 이상 디스크립터 객체 자신을 돌려줍니다. 만약 디스크립터가 :meth:`__set__` 이나 :meth:`__delete__` 중"
" 어느 하나나 둘 다 정의하면, 데이터 디스크립터(data descriptor)입니다. 둘 다 정의하지 않는다면 비데이터 디스크립터"
"(non-data descriptor)입니다. 보통, 데이터 디스크립터가 :meth:`__get__` 과 "
":meth:`__set__` 을 모두 정의하는 반면, 비데이터 디스크립터는 :meth:`__get__` 메서드만 정의합니다. "
":meth:`__get__` 과 :meth:`__set__` (그리고/또는 :meth:`__delete__`) 이 있는 데이터 "
"디스크립터는 인스턴스 딕셔너리에 있는 값에 우선합니다. 반면에 비데이터 디스크립터는 인스턴스보다 우선순위가 낮습니다."

#: ../../reference/datamodel.rst:2501
#, fuzzy
msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented "
"as non-data descriptors.  Accordingly, instances can redefine and "
"override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""
"파이썬 메서드 (:func:`staticmethod` 와 :func:`classmethod` 를 포함해서) 는 비데이터 디스크립터로"
" 구현됩니다. 이 때문에, 인스턴스는 메서드를 새로 정의하거나 덮어쓸 수 있습니다. 이것은 개별 인스턴스가 같은 클래스의 다른 "
"인스턴스들과는 다른 동작을 얻을 수 있도록 만듭니다."

#: ../../reference/datamodel.rst:2507
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` 함수는 데이터 디스크립터로 구현됩니다. 이 때문에, 인스턴스는 프로퍼티(property)의 동작을 "
"변경할 수 없습니다."

#: ../../reference/datamodel.rst:2514
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:2516
#, fuzzy
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties)"
" and deny the creation of :attr:`~object.__dict__` and *__weakref__* "
"(unless explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* 은 (프로퍼티처럼) 데이터 멤버를 명시적으로 선언하고 (*__slots__* 에 명시적으로 선언하거나 "
"부모로부터 물려받지 않는 한) *__dict__* 와 *__weakref__* 생성을 거부할 수 있도록 합니다."

#: ../../reference/datamodel.rst:2520
#, fuzzy
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr "*__dict__* 를 사용할 때에 비교해 절약되는 공간은 상당할 수 있습니다. 어트리뷰트 조회 속도도 크게 개선할 수 있습니다."

#: ../../reference/datamodel.rst:2525
#, fuzzy
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves "
"space for the declared variables and prevents the automatic creation of "
":attr:`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"이 클래스 변수에는 인스턴스에 의해 사용되는 변수들의 이름을 제공하는 문자열, 이터러블(iterable), 문자열의 시퀀스가 대입될"
" 수 있습니다. *__slots__* 은 선언된 변수들을 위한 공간을 예약하고, 간 인스턴스마다 *__dict__* 와 "
"*__weakref__* 가 만들어지는 것을 막습니다."

#: ../../reference/datamodel.rst:2534
#, fuzzy
msgid "Notes on using *__slots__*:"
msgstr "*__slots__* 사용에 관한 노트"

#: ../../reference/datamodel.rst:2536
#, fuzzy
msgid ""
"When inheriting from a class without *__slots__*, the "
":attr:`~object.__dict__` and *__weakref__* attribute of the instances "
"will always be accessible."
msgstr ""
"*__slots__* 가 없는 클래스를 계승할 때, 인스턴스의 *__dict__* 와 *__weakref__* 어트리뷰트는 항상 "
"제공됩니다."

#: ../../reference/datamodel.rst:2540
#, fuzzy
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned"
" new variables not listed in the *__slots__* definition.  Attempts to "
"assign to an unlisted variable name raises :exc:`AttributeError`. If "
"dynamic assignment of new variables is desired, then add ``'__dict__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"*__dict__* 변수가 없으므로 인스턴스는 *__slots__* 정의에 나열되지 않은 새 변수를 대입할 수 없습니다. 나열되지 "
"않은 변수명으로 대입하려고 하면 :exc:`AttributeError` 를 일으킵니다. 만약 동적으로 새 변수를 대입하는 것이 "
"필요하다면, *__slots__* 선언의 문자열 시퀀스에 ``'__dict__'`` 를 추가합니다."

#: ../../reference/datamodel.rst:2547
#, fuzzy
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add "
"``'__weakref__'`` to the sequence of strings in the *__slots__* "
"declaration."
msgstr ""
"인스턴스마다 *__weakref__* 변수가 없으므로, *__slots__* 를 정의하는 클래스는 인스턴스에 대한 약한 "
"참조(weak reference)를 지원하지 않습니다. 만약 약한 참조 지원이 필요하다면, *__slots__* 선언의 문자열 "
"시퀀스에 ``'__weakref__'`` 를 추가합니다."

#: ../../reference/datamodel.rst:2553
#, fuzzy
msgid ""
"*__slots__* are implemented at the class level by creating "
":ref:`descriptors <descriptors>` for each variable name.  As a result, "
"class attributes cannot be used to set default values for instance "
"variables defined by *__slots__*; otherwise, the class attribute would "
"overwrite the descriptor assignment."
msgstr ""
"*__slots__* 는 각 변수 이름마다 디스크립터를 만드는 방식으로 클래스 수준에서 "
"구현됩니다(:ref:`descriptors`). 결과적으로, 클래스 어트리뷰트는 *__slots__* 로 정의된 인스턴스 변수들을 "
"위한 기본값을 제공할 목적으로 사용될 수 없습니다. 클래스 어트리뷰트는 디스크립터 대입을 무효로 합니다."

#: ../../reference/datamodel.rst:2559
#, fuzzy
msgid ""
"The action of a *__slots__* declaration is not limited to the class where"
" it is defined.  *__slots__* declared in parents are available in child "
"classes. However, instances of a child subclass will get a "
":attr:`~object.__dict__` and *__weakref__* unless the subclass also "
"defines *__slots__* (which should only contain names of any *additional* "
"slots)."
msgstr ""
"*__slots__* 선언으로 인한 효과는 그것이 정의된 클래스로 한정되지 않습니다. 부모가 선언한 *__slots__* 은 자식 "
"클래스에 제공됩니다. 하지만, 자식 서브 클래스가 자신의 *__slots__* (새로 *추가되는* 변수들만 포함해야 합니다) 을 "
"정의하지 않는다면 *__dict__* 와 *__weakref__* 를 갖게 됩니다."

#: ../../reference/datamodel.rst:2565
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the"
" meaning of the program undefined.  In the future, a check may be added "
"to prevent this."
msgstr ""
"클래스가 베이스 클래스의 *__slots__* 에 정의된 이름과 같은 이름의 변수를 *__slots__* 에 선언한다면, 베이스 "
"클래스가 정의한 변수는 액세스할 수 없는 상태가 됩니다(베이스 클래스로부터 디스크립터를 직접 조회하는 경우는 예외다). 이것은 "
"프로그램을 정의되지 않은 상태로 보내게 됩니다. 미래에는, 이를 방지하기 위한 검사가 추가될 것입니다."

#: ../../reference/datamodel.rst:2570
#, fuzzy
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a"
" class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and "
":class:`tuple`."
msgstr ""
":class:`int`, :class:`bytes`, :class:`tuple`\\과 같은 \"가변 길이(valiable-"
"length)\" 의 내장형들을 계승하는 클래스에서는 오직 빈 *__slots__* 만 지원됩니다."

#: ../../reference/datamodel.rst:2575
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr ""

#: ../../reference/datamodel.rst:2577
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the "
"dictionary can be used to provide per-attribute docstrings that will be "
"recognised by :func:`inspect.getdoc` and displayed in the output of "
":func:`help`."
msgstr ""

#: ../../reference/datamodel.rst:2582
#, fuzzy
msgid ""
":attr:`~object.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr "두 클래스가 같은 *__slots__* 을 갖는 경우만 *__class__* 대입이 동작합니다."

#: ../../reference/datamodel.rst:2585
#, fuzzy
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - "
"violations raise :exc:`TypeError`."
msgstr ""
"슬롯을 사용하는 여러 부모 클래스들을 다중 상속할 수 있지만, 오직 하나의 부모만 슬롯으로 만들어진 어트리뷰트를 가질 수 있습니다 "
"(다른 베이스들은 빈 슬롯을 가져야만 합니다) - 이를 어기면 :exc:`TypeError` 를 일으킵니다."

#: ../../reference/datamodel.rst:2591
#, fuzzy
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` "
"is created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"이터레이터가 *__slots__*\\에 사용되면 각 이터레이터의 값에 대해 디스크립터가 만들어집니다. 그러나, *__slots__*"
" 어트리뷰트는 빈 이터레이터가 됩니다."

#: ../../reference/datamodel.rst:2599
msgid "Customizing class creation"
msgstr "클래스 생성 커스터마이제이션"

#: ../../reference/datamodel.rst:2601
#, fuzzy
msgid ""
"Whenever a class inherits from another class, "
":meth:`~object.__init_subclass__` is called on the parent class. This "
"way, it is possible to write classes which change the behavior of "
"subclasses. This is closely related to class decorators, but where class "
"decorators only affect the specific class they're applied to, "
"``__init_subclass__`` solely applies to future subclasses of the class "
"defining the method."
msgstr ""
"클래스가 다른 클래스를 상속할 때, 그 클래스의 *__init_subclass__* 가 호출됩니다. 이 방법으로, 서브 클래스의 "
"동작을 변경하는 클래스를 쓰는 것이 가능합니다. 이런 용도는 클래스 데코레이터와도 밀접히 관련되어 있습니다. 하지만 클래스 "
"데코레이터는 그들을 사용하는 특정한 클래스에만 작용하지만, ``__init_subclass__`` 단독으로 그 메서드를 정의하는 "
"클래스의 미래 서브 클래스 모두에게 작용합니다."

#: ../../reference/datamodel.rst:2610
msgid ""
"This method is called whenever the containing class is subclassed. *cls* "
"is then the new subclass. If defined as a normal instance method, this "
"method is implicitly converted to a class method."
msgstr ""
"이 메서드는 포함하는 클래스의 서브 클래스가 만들어질 때마다 호출됩니다. *cls* 는 새 서브 클래스입니다. 만약 일반적인 "
"인스턴스 메서드로 정의되면, 이 메서드는 묵시적으로 클래스 메서드로 변경됩니다."

#: ../../reference/datamodel.rst:2614
#, fuzzy
msgid ""
"Keyword arguments which are given to a new class are passed to the parent"
" class's ``__init_subclass__``. For compatibility with other classes "
"using ``__init_subclass__``, one should take out the needed keyword "
"arguments and pass the others over to the base class, as in::"
msgstr ""
"새 클래스에 주어진 키워드 인자들은 부모 클래스의 ``__init_subclass__`` 로 전달됩니다. "
"``__init_subclass__`` 를 사용하는 다른 클래스들과의 호환성을 위해, 필요한 키워드 인자들을 꺼낸 후에 다른 것들을"
" 베이스 클래스로 전달해야 합니다. 이런 식입니다::"

#: ../../reference/datamodel.rst:2620
msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""

#: ../../reference/datamodel.rst:2628
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but"
" raises an error if it is called with any arguments."
msgstr ""
"기본 구현 ``object.__init_subclass__`` 는 아무 일도 하지 않지만, 인자가 포함되어 호출되면 예외를 "
"발생시킵니다."

#: ../../reference/datamodel.rst:2633
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. "
"The actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"메타 클래스 힌트 ``metaclass`` 는 나머지 형 절차에 의해 소비되고, ``__init_subclass__`` 로 전달되지"
" 않습니다. 실제 메타 클래스 (명시적인 힌트 대신에) 는 ``type(cls)`` 로 액세스할 수 있습니다."

#: ../../reference/datamodel.rst:2641
msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables "
"and makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""

#: ../../reference/datamodel.rst:2646
#, fuzzy
msgid ""
"Automatically called at the time the owning class *owner* is created. The"
" object has been assigned to *name* in that class::"
msgstr "소유자 클래스 *owner* 가 만들어질 때 호출됩니다. 이 디스크립터가 *name* 에 대입되었습니다."

#: ../../reference/datamodel.rst:2649
msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""

#: ../../reference/datamodel.rst:2652
msgid ""
"If the class variable is assigned after the class is created, "
":meth:`__set_name__` will not be called automatically. If needed, "
":meth:`__set_name__` can be called directly::"
msgstr ""

#: ../../reference/datamodel.rst:2656
msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""

#: ../../reference/datamodel.rst:2663
msgid "See :ref:`class-object-creation` for more details."
msgstr "더 자세한 내용은 :ref:`class-object-creation` 을 참고하십시오."

#: ../../reference/datamodel.rst:2671
msgid "Metaclasses"
msgstr "메타 클래스"

#: ../../reference/datamodel.rst:2678
msgid ""
"By default, classes are constructed using :func:`type`. The class body is"
" executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"기본적으로, 클래스는 :func:`type` 을 사용해서 만들어집니다. 클래스의 바디는 새 이름 공간에서 실행되고, 클래스 이름은 "
"``type(name, bases, namespace)`` 의 결과에 지역적으로 연결됩니다."

#: ../../reference/datamodel.rst:2682
msgid ""
"The class creation process can be customized by passing the ``metaclass``"
" keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"클래스를 만드는 과정은 클래스 정의 줄에 ``metaclass`` 키워드 인자를 전달하거나, 그런 인자를 포함한 이미 존재하는 "
"클래스를 계승함으로써 커스터마이즈될 수 있습니다. 다음 예에서, ``MyClass`` 와 ``MySubclass`` 는 모두 "
"``Meta`` 의 인스턴스입니다."

#: ../../reference/datamodel.rst:2687
msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""

#: ../../reference/datamodel.rst:2696
msgid ""
"Any other keyword arguments that are specified in the class definition "
"are passed through to all metaclass operations described below."
msgstr "클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타 클래스 연산들로 전달됩니다."

#: ../../reference/datamodel.rst:2699
msgid "When a class definition is executed, the following steps occur:"
msgstr "클래스 정의가 실행될 때, 다음과 같은 단계가 수행됩니다.:"

#: ../../reference/datamodel.rst:2701
msgid "MRO entries are resolved;"
msgstr "MRO 항목이 결정됩니다;"

#: ../../reference/datamodel.rst:2702
msgid "the appropriate metaclass is determined;"
msgstr "적절한 메타 클래스가 결정됩니다;"

#: ../../reference/datamodel.rst:2703
msgid "the class namespace is prepared;"
msgstr "클래스 이름 공간이 준비됩니다;"

#: ../../reference/datamodel.rst:2704
msgid "the class body is executed;"
msgstr "클래스 바디가 실행됩니다;"

#: ../../reference/datamodel.rst:2705
msgid "the class object is created."
msgstr "클래스 객체가 만들어집니다."

#: ../../reference/datamodel.rst:2709
msgid "Resolving MRO entries"
msgstr "MRO 항목 결정하기"

#: ../../reference/datamodel.rst:2713
#, fuzzy
msgid ""
"If a base that appears in a class definition is not an instance of "
":class:`type`, then an :meth:`!__mro_entries__` method is searched on the"
" base. If an :meth:`!__mro_entries__` method is found, the base is "
"substituted with the result of a call to :meth:`!__mro_entries__` when "
"creating the class. The method is called with the original bases tuple "
"passed to the *bases* parameter, and must return a tuple of classes that "
"will be used instead of the base. The returned tuple may be empty: in "
"these cases, the original base is ignored."
msgstr ""
"클래스 정의에 나타나는 베이스 클래스가 :class:`type` 의 인스턴스가 아닌 경우, 거기에서 "
"``__mro_entries__`` 메서드를 검색합니다. 발견되면, 원래의 베이스 튜플로 호출됩니다. 이 메서드는 이 베이스 대신에"
" 사용될 클래스의 튜플을 돌려줘야 합니다. 튜플은 비어있을 수 있습니다. 이 경우 원래 베이스는 무시됩니다."

#: ../../reference/datamodel.rst:2724
msgid ":func:`types.resolve_bases`"
msgstr ""

#: ../../reference/datamodel.rst:2725
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr ""

#: ../../reference/datamodel.rst:2727
msgid ":func:`types.get_original_bases`"
msgstr ""

#: ../../reference/datamodel.rst:2728
msgid ""
"Retrieve a class's \"original bases\" prior to modifications by "
":meth:`~object.__mro_entries__`."
msgstr ""

#: ../../reference/datamodel.rst:2731
msgid ":pep:`560`"
msgstr ""

#: ../../reference/datamodel.rst:2732
#, fuzzy
msgid "Core support for typing module and generic types."
msgstr ":pep:`560` - typing 모듈과 제네릭 형에 대한 코어 지원"

#: ../../reference/datamodel.rst:2736
msgid "Determining the appropriate metaclass"
msgstr "적절한 메타 클래스 선택하기"

#: ../../reference/datamodel.rst:2740
msgid "The appropriate metaclass for a class definition is determined as follows:"
msgstr "클래스 정의의 적절한 메타 클래스는 다음과 같이 결정됩니다:"

#: ../../reference/datamodel.rst:2742
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is "
"used;"
msgstr "베이스와 명시적인 메타 클래스를 주지 않는 경우 :func:`type` 이 사용됩니다;"

#: ../../reference/datamodel.rst:2743
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass;"
msgstr "명시적인 메타 클래스가 지정되고, 그것이 :func:`type` 의 인스턴스가 *아니면*, 그것을 메타 클래스로 사용합니다;"

#: ../../reference/datamodel.rst:2745
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or "
"bases are defined, then the most derived metaclass is used."
msgstr ""
":func:`type` 의 인스턴스가 명시적인 메타 클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타 클래스가 "
"사용됩니다."

#: ../../reference/datamodel.rst:2748
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all "
"specified base classes. The most derived metaclass is one which is a "
"subtype of *all* of these candidate metaclasses. If none of the candidate"
" metaclasses meets that criterion, then the class definition will fail "
"with ``TypeError``."
msgstr ""
"가장 많이 파생된 메타 클래스는 명시적으로 지정된 메타 클래스(있다면)와 지정된 모든 베이스 클래스들의 메타 클래스들(즉, "
"``type(cls)``) 중에서 선택됩니다. 가장 많이 파생된 메타 클래스는 이들 *모두* 의 서브 타입(subtype)입니다. "
"만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 ``TypeError`` 를 발생시키며 실패합니다."

#: ../../reference/datamodel.rst:2758
msgid "Preparing the class namespace"
msgstr "클래스 이름 공간 준비하기"

#: ../../reference/datamodel.rst:2763
#, fuzzy
msgid ""
"Once the appropriate metaclass has been identified, then the class "
"namespace is prepared. If the metaclass has a ``__prepare__`` attribute, "
"it is called as ``namespace = metaclass.__prepare__(name, bases, "
"**kwds)`` (where the additional keyword arguments, if any, come from the "
"class definition). The ``__prepare__`` method should be implemented as a "
":func:`classmethod <classmethod>`. The namespace returned by "
"``__prepare__`` is passed in to ``__new__``, but when the final class "
"object is created the namespace is copied into a new ``dict``."
msgstr ""
"일단 적절한 메타 클래스가 식별되면, 클래스 이름 공간이 준비됩니다. 만약 메타 클래스가 ``__prepare__`` 어트리뷰트를 "
"가지면, ``namespace = metaclass.__prepare__(name, bases, **kwds)`` 같은 식으로 "
"호출됩니다(추가적인 키워드 인자가 있다면 클래스 정의에서 온 것입니다). ``__prepare__`` 메서드는 "
":func:`classmethod`\\로 구현되어야 합니다. ``__prepare__``\\에 의해 반환된 이름 공간은 "
"``__new__``\\에 전달되지만, 최종 클래스 객체가 만들어질 때 이름 공간이 새로운 ``dict``\\에 복사됩니다."

#: ../../reference/datamodel.rst:2772
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class "
"namespace is initialised as an empty ordered mapping."
msgstr "만약 메타 클래스에 ``__prepare__`` 어트리뷰트가 없다면, 클래스 이름 공간은 빈 순서 있는 매핑으로 초기화됩니다."

#: ../../reference/datamodel.rst:2777
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - 파이썬 3000 에서의 메타 클래스"

#: ../../reference/datamodel.rst:2778
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "``__prepare__`` 이름 공간 훅을 도입했습니다"

#: ../../reference/datamodel.rst:2782
msgid "Executing the class body"
msgstr "클래스 바디 실행하기"

#: ../../reference/datamodel.rst:2787
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is "
"that lexical scoping allows the class body (including any methods) to "
"reference names from the current and outer scopes when the class "
"definition occurs inside a function."
msgstr ""
"클래스 바디는 (대략) ``exec(body, globals(), namespace)`` 과같이 실행됩니다. 일반적인 "
":func:`exec` 호출과 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 어휘 스코핑(lexical scoping) 이"
" 클래스 바디(모든 메서드들을 포함해서)로 하여금 현재와 외부 스코프에 있는 이름들을 참조하도록 허락한다는 것입니다."

#: ../../reference/datamodel.rst:2793
msgid ""
"However, even when the class definition occurs inside the function, "
"methods defined inside the class still cannot see names defined at the "
"class scope. Class variables must be accessed through the first parameter"
" of instance or class methods, or through the implicit lexically scoped "
"``__class__`` reference described in the next section."
msgstr ""
"하지만, 클래스 정의가 함수 내부에서 이루어질 때조차도, 클래스 내부에서 정의된 메서드들은 클래스 스코프에서 정의된 이름들을 볼 수"
" 없습니다. 클래스 변수는 인스턴스나 클래스 메서드의 첫 번째 매개변수를 통해 액세스하거나 다음 섹션에서 설명하는 묵시적으로 어휘 "
"스코핑된 ``__class__`` 참조를 통해야 합니다."

#: ../../reference/datamodel.rst:2802
msgid "Creating the class object"
msgstr "클래스 객체 만들기"

#: ../../reference/datamodel.rst:2809
msgid ""
"Once the class namespace has been populated by executing the class body, "
"the class object is created by calling ``metaclass(name, bases, "
"namespace, **kwds)`` (the additional keywords passed here are the same as"
" those passed to ``__prepare__``)."
msgstr ""
"일단 클래스 이름 공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 ``metaclass(name, bases, "
"namespace, **kwds)`` 을 통해 만들어집니다(여기에서 전달되는 추가적인 키워드 인자들은 ``__prepare__`` "
"에 전달된 것들과 같습니다)."

#: ../../reference/datamodel.rst:2814
msgid ""
"This class object is the one that will be referenced by the zero-argument"
" form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on "
"lexical scoping, while the class or instance that was used to make the "
"current call is identified based on the first argument passed to the "
"method."
msgstr ""
"이 클래스 객체는 :func:`super` 에 인자를 주지 않는 경우 참조되는 것입니다. ``__class__`` 는 클래스 바디의"
" 메서드들 중 어느 하나라도 ``__class__`` 나 ``super`` 를 참조할 경우 컴파일러에 의해 만들어지는 묵시적인 "
"클로저(closure) 참조입니다. 이것은 인자 없는 형태의 :func:`super` 가 어휘 스코핑 기반으로 현재 정의되고 있는 "
"클래스를 올바르게 찾을 수 있도록 합니다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메서드로 전달된 첫 번째 인자에 기초해서"
" 식별됩니다."

#: ../../reference/datamodel.rst:2824
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the "
"metaclass as a ``__classcell__`` entry in the class namespace. If "
"present, this must be propagated up to the ``type.__new__`` call in order"
" for the class to be initialised correctly. Failing to do so will result "
"in a :exc:`RuntimeError` in Python 3.8."
msgstr ""
"CPython 3.6 이상에서, ``__class__`` 셀(cell)은 클래스 이름 공간의 ``__classcell__`` "
"엔트리로 메타 클래스에 전달됩니다. 만약 존재한다면, 이것은 클래스가 올바르게 초기화되기 위해 ``type.__new__`` "
"호출까지 거슬러서 전파되어야 합니다. 이렇게 하지 못하면 파이썬 3.8 에서는 :exc:`RuntimeError`\\로 이어질 "
"것입니다."

#: ../../reference/datamodel.rst:2830
#, fuzzy
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization"
" steps are invoked after creating the class object:"
msgstr ""
"기본 메타 클래스 :class:`type` 을 사용할 때나 다른 메타 클래스가 결국 ``type.__new__`` 를 호출할 때, "
"클래스 객체를 만든 후에, 다음과 같은 추가의 커스터마이제이션 단계가 실행됩니다:"

#: ../../reference/datamodel.rst:2834
#, fuzzy
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"첫째로, ``type.__new__`` 는 :meth:`~object.__set_name__` 을 정의하는 클래스 이름 공간의 모든"
" 디스크립터들을 수집합니다;"

#: ../../reference/datamodel.rst:2836
#, fuzzy
msgid ""
"Those ``__set_name__`` methods are called with the class being defined "
"and the assigned name of that particular attribute;"
msgstr ""
"둘째로, 이렇게 수집된 모든 ``__set_name__`` 을 호출하는데, 정의되고 있는 클래스와 디스크립터에 주어진 이름을 인자로"
" 전달합니다;"

#: ../../reference/datamodel.rst:2838
#, fuzzy
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate "
"parent of the new class in its method resolution order."
msgstr ""
"마지막으로, 메서드 결정 순서에 따라 가장 가까운 부모에 대해 :meth:`~object.__init_subclass__` 훅이 "
"호출됩니다."

#: ../../reference/datamodel.rst:2841
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is "
"bound in the local namespace as the defined class."
msgstr ""
"클래스 객체가 만들어진 후에, 클래스 정의에 포함된 클래스 데코레이터들에게 (있다면) 클래스를 전달하고, 그 결과를 클래스가 "
"정의되는 지역 이름 공간에 연결합니다."

#: ../../reference/datamodel.rst:2845
#, fuzzy
msgid ""
"When a new class is created by ``type.__new__``, the object provided as "
"the namespace parameter is copied to a new ordered mapping and the "
"original object is discarded. The new copy is wrapped in a read-only "
"proxy, which becomes the :attr:`~type.__dict__` attribute of the class "
"object."
msgstr ""
"``type.__new__`` 로 새 클래스가 만들어질 때, 이름 공간 매개변수로 제공되는 객체는 새로 만든 순서 있는 매핑으로 "
"복사되고, 원래의 객체는 버립니다. 새 사본은 읽기 전용 프락시(read-only proxy)로 둘러싸이는데, 이것이 클래스 객체의"
" :attr:`~object.__dict__` 어트리뷰트가 됩니다."

#: ../../reference/datamodel.rst:2852
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - 새 super"

#: ../../reference/datamodel.rst:2853
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "묵시적인 \\__class__ 클로저 참조를 설명합니다"

#: ../../reference/datamodel.rst:2857
msgid "Uses for metaclasses"
msgstr "메타 클래스의 용도"

#: ../../reference/datamodel.rst:2859
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have "
"been explored include enum, logging, interface checking, automatic "
"delegation, automatic property creation, proxies, frameworks, and "
"automatic resource locking/synchronization."
msgstr ""
"메타 클래스의 잠재적인 용도에는 한계가 없습니다. 탐색 된 몇 가지 아이디어들에는 enum, 로깅, 인터페이스 검사, 자동화된 "
"위임(automatic delegation), 자동화된 프로퍼티(properety) 생성, 프락시(proxy), "
"프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource "
"locking/synchronization) 등이 있습니다."

#: ../../reference/datamodel.rst:2866
msgid "Customizing instance and subclass checks"
msgstr "인스턴스 및 서브 클래스 검사 커스터마이제이션"

#: ../../reference/datamodel.rst:2868
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"다음 메서드들은 :func:`isinstance` 와 :func:`issubclass` 내장 함수들의 기본 동작을 재정의하는 데 "
"사용됩니다."

#: ../../reference/datamodel.rst:2871
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these "
"methods in order to allow the addition of Abstract Base Classes (ABCs) as"
" \"virtual base classes\" to any class or type (including built-in "
"types), including other ABCs."
msgstr ""
"특히, 메타 클래스 :class:`abc.ABCMeta` 는 추상 베이스 클래스(Abstract Base Class, ABC)를 "
"다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함합니다)에 \"가상 베이스 클래스(virtual base class)\"로 "
"추가할 수 있게 하려고 이 메서드들을 구현합니다."

#: ../../reference/datamodel.rst:2878
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement "
"``isinstance(instance, class)``."
msgstr ""
"*instance* 가 (직접적이거나 간접적으로) *class* 의 인스턴스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, "
"``isinstance(instance, class)`` 를 구현하기 위해 호출됩니다."

#: ../../reference/datamodel.rst:2885
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement "
"``issubclass(subclass, class)``."
msgstr ""
"*subclass* 가 (직접적이거나 간접적으로) *class* 의 서브 클래스로 취급될 수 있으면 참을 돌려줍니다. 만약 "
"정의되면, ``issubclass(subclass, class)`` 를 구현하기 위해 호출됩니다."

#: ../../reference/datamodel.rst:2890
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class."
"  They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on "
"instances, only in this case the instance is itself a class."
msgstr ""
"이 메서드들은 클래스의 형(메타 클래스)에서 조회된다는 것에 주의해야 합니다. 실제 클래스에서 클래스 메서드로 정의될 수 없습니다."
" 이것은 인스턴스에 대해 호출되는 특수 메서드들의 조회와 일관성 있습니다. 이 경우 인스턴스는 클래스 자체다."

#: ../../reference/datamodel.rst:2897
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 추상 베이스 클래스의 도입"

#: ../../reference/datamodel.rst:2898
#, fuzzy
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~type.__instancecheck__` and "
":meth:`~type.__subclasscheck__`, with motivation for this functionality "
"in the context of adding Abstract Base Classes (see the :mod:`abc` "
"module) to the language."
msgstr ""
":meth:`~class.__instancecheck__` 와 :meth:`~class.__subclasscheck__` 를 통해 "
":func:`isinstance` 와 :func:`issubclass` 의 동작을 커스터마이징하는 데 필요한 규약을 포함하는데, 이"
" 기능의 동기는 언어에 추상 베이스 클래스 (:mod:`abc` 모듈을 보십시오)를 추가하고자 하는 데 있습니다."

#: ../../reference/datamodel.rst:2906
msgid "Emulating generic types"
msgstr "제네릭 형 흉내 내기"

#: ../../reference/datamodel.rst:2908
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to "
"signify a :class:`list` in which all the elements are of type "
":class:`int`."
msgstr ""

#: ../../reference/datamodel.rst:2915
#, fuzzy
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`343` - \"with\" 문"

#: ../../reference/datamodel.rst:2916
msgid "Introducing Python's framework for type annotations"
msgstr ""

#: ../../reference/datamodel.rst:2918
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ""

#: ../../reference/datamodel.rst:2919
msgid "Documentation for objects representing parameterized generic classes"
msgstr ""

#: ../../reference/datamodel.rst:2921
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and "
":class:`typing.Generic`"
msgstr ""

#: ../../reference/datamodel.rst:2922
msgid ""
"Documentation on how to implement generic classes that can be "
"parameterized at runtime and understood by static type-checkers."
msgstr ""

#: ../../reference/datamodel.rst:2925
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""

#: ../../reference/datamodel.rst:2930
msgid ""
"Return an object representing the specialization of a generic class by "
"type arguments found in *key*."
msgstr "*key* 에 있는 형 인자에 의한 제네릭 클래스의 특수화를 나타내는 객체를 돌려줍니다."

#: ../../reference/datamodel.rst:2933
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class"
" method. As such, there is no need for it to be decorated with "
":func:`@classmethod<classmethod>` when it is defined."
msgstr ""

#: ../../reference/datamodel.rst:2939
msgid "The purpose of *__class_getitem__*"
msgstr ""

#: ../../reference/datamodel.rst:2941
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more "
"easily apply :term:`type hints<type hint>` to these classes."
msgstr ""

#: ../../reference/datamodel.rst:2945
msgid ""
"To implement custom generic classes that can be parameterized at runtime "
"and understood by static type-checkers, users should either inherit from "
"a standard library class that already implements "
":meth:`~object.__class_getitem__`, or inherit from "
":class:`typing.Generic`, which has its own implementation of "
"``__class_getitem__()``."
msgstr ""

#: ../../reference/datamodel.rst:2951
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-"
"party type-checkers such as mypy. Using ``__class_getitem__()`` on any "
"class for purposes other than type hinting is discouraged."
msgstr ""

#: ../../reference/datamodel.rst:2961
msgid "*__class_getitem__* versus *__getitem__*"
msgstr ""

#: ../../reference/datamodel.rst:2963
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square"
" brackets will call the :meth:`~object.__getitem__` instance method "
"defined on the object's class. However, if the object being subscribed is"
" itself a class, the class method :meth:`~object.__class_getitem__` may "
"be called instead. ``__class_getitem__()`` should return a "
":ref:`GenericAlias<types-genericalias>` object if it is properly defined."
msgstr ""

#: ../../reference/datamodel.rst:2970
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether "
":meth:`~object.__getitem__` or :meth:`~object.__class_getitem__` should "
"be called::"
msgstr ""

#: ../../reference/datamodel.rst:2975
#, python-brace-format
msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""

#: ../../reference/datamodel.rst:2998
msgid ""
"In Python, all classes are themselves instances of other classes. The "
"class of a class is known as that class's :term:`metaclass`, and most "
"classes have the :class:`type` class as their metaclass. :class:`type` "
"does not define :meth:`~object.__getitem__`, meaning that expressions "
"such as ``list[int]``, ``dict[str, float]`` and ``tuple[str, bytes]`` all"
" result in :meth:`~object.__class_getitem__` being called::"
msgstr ""

#: ../../reference/datamodel.rst:3005
msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""

#: ../../reference/datamodel.rst:3017
msgid ""
"However, if a class has a custom metaclass that defines "
":meth:`~object.__getitem__`, subscribing the class may result in "
"different behaviour. An example of this can be found in the :mod:`enum` "
"module::"
msgstr ""

#: ../../reference/datamodel.rst:3021
msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""

#: ../../reference/datamodel.rst:3040
#, fuzzy
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ":pep:`560` - typing 모듈과 제네릭 형에 대한 코어 지원"

#: ../../reference/datamodel.rst:3041
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a "
":ref:`subscription<subscriptions>` results in ``__class_getitem__()`` "
"being called instead of :meth:`~object.__getitem__`"
msgstr ""

#: ../../reference/datamodel.rst:3049
msgid "Emulating callable objects"
msgstr "콜러블 객체 흉내 내기"

#: ../../reference/datamodel.rst:3056
#, fuzzy
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to "
"``type(x).__call__(x, arg1, ...)``. The :class:`object` class itself does"
" not provide this method."
msgstr ""
"인스턴스가 함수처럼 \"호출될\" 때 호출됩니다; 이 메서드가 정의되면, ``x(arg1, arg2, ...)`` 는 대략 "
"``type(x).__call__(x, arg1, ...)``\\로 번역됩니다."

#: ../../reference/datamodel.rst:3064
msgid "Emulating container types"
msgstr "컨테이너형 흉내 내기"

#: ../../reference/datamodel.rst:3066
#, fuzzy
msgid ""
"The following methods can be defined to implement container objects. None"
" of them are provided by the :class:`object` class itself. Containers "
"usually are :term:`sequences <sequence>` (such as :class:`lists <list>` "
"or :class:`tuples <tuple>`) or :term:`mappings <mapping>` (like "
":term:`dictionaries <dictionary>`), but can represent other containers as"
" well.  The first set of methods is used either to emulate a sequence or "
"to emulate a mapping; the difference is that for a sequence, the "
"allowable keys should be the integers *k* for which ``0 <= k < N`` where "
"*N* is the length of the sequence, or :class:`slice` objects, which "
"define a range of items.  It is also recommended that mappings provide "
"the methods :meth:`!keys`, :meth:`!values`, :meth:`!items`, :meth:`!get`,"
" :meth:`!clear`, :meth:`!setdefault`, :meth:`!pop`, :meth:`!popitem`, "
":meth:`!copy`, and :meth:`!update` behaving similar to those for Python's"
" standard :class:`dictionary <dict>` objects.  The :mod:`collections.abc`"
" module provides a :class:`~collections.abc.MutableMapping` "
":term:`abstract base class` to help create those methods from a base set "
"of :meth:`~object.__getitem__`, :meth:`~object.__setitem__`, "
":meth:`~object.__delitem__`, and :meth:`!keys`. Mutable sequences should "
"provide methods :meth:`!append`, :meth:`!count`, :meth:`!index`, "
":meth:`!extend`, :meth:`!insert`, :meth:`!pop`, :meth:`!remove`, "
":meth:`!reverse` and :meth:`!sort`, like Python standard :class:`list` "
"objects. Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`~object.__add__`, :meth:`~object.__radd__`, "
":meth:`~object.__iadd__`, :meth:`~object.__mul__`, "
":meth:`~object.__rmul__` and :meth:`~object.__imul__` described below; "
"they should not define other numerical operators.  It is recommended that"
" both mappings and sequences implement the :meth:`~object.__contains__` "
"method to allow efficient use of the ``in`` operator; for mappings, "
"``in`` should search the mapping's keys; for sequences, it should search "
"through the values.  It is further recommended that both mappings and "
"sequences implement the :meth:`~object.__iter__` method to allow "
"efficient iteration through the container; for mappings, "
":meth:`!__iter__` should iterate through the object's keys; for "
"sequences, it should iterate through the values."
msgstr ""
"컨테이너 객체를 구현하기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 컨테이너는 보통 시퀀스(리스트와 튜플 같은)나 "
"매핑(딕셔너리 같은)이지만, 다른 컨테이너들 역시 표현할 수 있습니다. 첫 번째 메서드 집합은 시퀀스나 매핑을 흉내 내는 데 "
"사용됩니다; 차이점은, 시퀀스의 경우 허락되는 키는 *N* 이 시퀀스의 길이일 때 ``0 <= k < N`` 를 만족하는 정수 "
"*k* 와 항목들의 범위를 정의하는 슬라이스 객체만 허락된다는 것입니다. 파이썬의 표준 딕셔너리 객체와 비슷하게 동작하도록, 매핑에"
" 메서드 :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`get`, "
":meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:`popitem`, "
":meth:`!copy`, :meth:`update` 를 제공하는 것이 좋습니다. :mod:`collections.abc` 모듈은 "
":class:`~collections.abc.MutableMapping` 추상 베이스 클래스를 제공하는데, 기본 집합 "
":meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, "
":meth:`keys` 로 부터 이들 메서드들을 만드는 데 도움을 줍니다. 파이썬의 표준 리스트 객체처럼, 가변 시퀀스는 메서드 "
":meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, "
":meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse`, "
":meth:`sort` 를 제공해야 합니다. 마지막으로 시퀀스 형은 아래에서 설명하는 메서드 :meth:`__add__`, "
":meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__`, "
":meth:`__imul__` 를 정의해서 더하기(이어붙이기를 뜻합니다)와 곱하기(반복을 뜻합니다)를 구현해야 합니다. 다른 숫자 "
"연산자들은 정의하지 말아야 합니다. ``in`` 연산자의 효과적인 사용을 허락하기 위해, 매핑과 시퀀스 모두 "
":meth:`__contains__` 메서드를 구현하도록 권장합니다. 매핑의 경우, ``in`` 은 매핑의 키를 검색해야 합니다; "
"시퀀스의 경우, 값들을 검색해야 합니다. 컨테이너의 효율적인 이터레이션을 허락하기 위해, 매핑과 시퀀스 모두 "
":meth:`__iter__` 메서드를 구현하는 것 또한 권장합니다; 매핑의 경우, :meth:`__iter__` 는 객체의 키를 "
"이터레이트 해야 합니다; 시퀀스의 경우, 값들을 이터레이트해야 합니다."

#: ../../reference/datamodel.rst:3108
#, fuzzy
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the"
" length of the object, an integer ``>=`` 0.  Also, an object that doesn't"
" define a :meth:`~object.__bool__` method and whose :meth:`!__len__` "
"method returns zero is considered to be false in a Boolean context."
msgstr ""
"내장함수 :func:`len` 를 구현하기 위해 호출됩니다. 객체의 길이를 돌려줘야 하는데, ``>=`` 0인 정수입니다. 또한 "
":meth:`__bool__` 메서드를 정의하지 않은 객체의 :meth:`__len__` 이 0을 돌려주면 논리 문맥에서 거짓으로 "
"취급됩니다."

#: ../../reference/datamodel.rst:3115
#, fuzzy
msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If "
"the length is larger than :data:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`~object.__bool__` method."
msgstr ""
"CPython 에서, 길이는 최대 :attr:`sys.maxsize` 일 것이 요구됩니다. 만약 길이가 "
":attr:`!sys.maxsize` 보다 크면, 어떤 기능들 (:func:`len` 과 같은)은 "
":exc:`OverflowError` 를 일으킬 수 있습니다. 참 거짓 검사에서 :exc:`!OverflowError` 가 일어나는"
" 것을 막기 위해, 객체는 :meth:`__bool__` 를 정의해야 합니다."

#: ../../reference/datamodel.rst:3124
#, fuzzy
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an "
"estimated length for the object (which may be greater or less than the "
"actual length). The length must be an integer ``>=`` 0. The return value "
"may also be :data:`NotImplemented`, which is treated the same as if the "
"``__length_hint__`` method didn't exist at all. This method is purely an "
"optimization and is never required for correctness."
msgstr ""
":func:`operator.length_hint` 를 구현하기 위해 호출됩니다. 객체의 추정된 길이를 돌려줘야 합니다(실제 "
"길이보다 크거나 작을 수 있습니다). 길이는 ``>=`` 0인 정수여야 합니다. 반환 값은 "
":const:`NotImplemented` 일 수도 있으며, ``__length_hint__`` 메서드가 아예 존재하지 않는 것처럼"
" 처리됩니다. 이 메서드는 순수하게 최적화를 위한 것이고 결코 올바름이 요구되지는 않습니다."

#: ../../reference/datamodel.rst:3138
msgid ""
"Slicing is done exclusively with the following three methods.  A call "
"like ::"
msgstr "슬라이싱은 전적으로 다음에 나오는 세 메서드들에의해 수행됩니다 ::"

#: ../../reference/datamodel.rst:3140
msgid "a[1:2] = b"
msgstr ""

#: ../../reference/datamodel.rst:3142
msgid "is translated to ::"
msgstr "과 같은 호출은 ::"

#: ../../reference/datamodel.rst:3144
msgid "a[slice(1, 2, None)] = b"
msgstr ""

#: ../../reference/datamodel.rst:3146
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "로 번역되고, 다른 형태도 마찬가지입니다. 빠진 슬라이스 항목은 항상 ``None`` 으로 채워집니다."

#: ../../reference/datamodel.rst:3151
#, fuzzy
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` "
"types, the accepted keys should be integers. Optionally, they may support"
" :class:`slice` objects as well.  Negative index support is also "
"optional. If *key* is of an inappropriate type, :exc:`TypeError` may be "
"raised; if *key* is a value outside the set of indexes for the sequence "
"(after any special interpretation of negative values), :exc:`IndexError` "
"should be raised. For :term:`mapping` types, if *key* is missing (not in "
"the container), :exc:`KeyError` should be raised."
msgstr ""
"``self[key]`` 의 값을 구하기 위해 호출됩니다. 시퀀스형의 경우, 정수와 슬라이스 객체만 키로 허용됩니다. 음수 "
"인덱스(만약 클래스가 시퀀스 형을 흉내 내길 원한다면)의 특별한 해석은 :meth:`__getitem__` 메서드에 달려있음에 "
"주의해야 합니다. 만약 *key* 가 적절하지 않은 형인 경우, :exc:`TypeError` 가 발생할 수 있습니다; 만약 "
"시퀀스의 인덱스 범위를 벗어나면(음수에 대한 특별한 해석 후에), :exc:`IndexError` 를 일으켜야 합니다. 매핑 형의 "
"경우, *key* 가 (컨테이너에) 없으면, :exc:`KeyError` 를 일으켜야 합니다."

#: ../../reference/datamodel.rst:3163
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` 루프는 시퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 :exc:`IndexError` 가 "
"일어날 것으로 기대하고 있습니다."

#: ../../reference/datamodel.rst:3168
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class "
"method :meth:`~object.__class_getitem__` may be called instead of "
"``__getitem__()``. See :ref:`classgetitem-versus-getitem` for more "
"details."
msgstr ""

#: ../../reference/datamodel.rst:3176
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support changes to the values for keys, or if new keys can be "
"added, or for sequences if elements can be replaced.  The same exceptions"
" should be raised for improper *key* values as for the "
":meth:`__getitem__` method."
msgstr ""
"``self[key]`` 로의 대입을 구현하기 위해 호출됩니다. :meth:`__getitem__` 과 같은 주의가 필요합니다. "
"매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 경우는 항목이 교체될 수 있을 때만 "
"구현되어야 합니다. 잘못된 *key* 값의 경우는 :meth:`__getitem__` 에서와 같은 예외를 일으켜야 합니다."

#: ../../reference/datamodel.rst:3185
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support removal of keys, or for sequences if elements can be "
"removed from the sequence.  The same exceptions should be raised for "
"improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` 의 삭제를 구현하기 위해 호출됩니다. :meth:`__getitem__` 과 같은 주의가 필요합니다. "
"매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 제거될 수 있을 때만 구현되어야 합니다. "
"잘못된 *key* 값의 경우는 :meth:`__getitem__` 에서와 같은 예외를 일으켜야 합니다."

#: ../../reference/datamodel.rst:3194
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement "
"``self[key]`` for dict subclasses when key is not in the dictionary."
msgstr ""
":class:`dict`\\ .\\ :meth:`__getitem__` 이 dict 서브 클래스에서 키가 딕셔너리에 없으면 "
"``self[key]`` 를 구현하기 위해 호출합니다."

#: ../../reference/datamodel.rst:3200
#, fuzzy
msgid ""
"This method is called when an :term:`iterator` is required for a "
"container. This method should return a new iterator object that can "
"iterate over all the objects in the container.  For mappings, it should "
"iterate over the keys of the container."
msgstr ""
"컨테이너의 이터레이터가 필요할 때 이 메서드가 호출됩니다. 이 메서드는 컨테이너에 포함된 모든 객체를 이터레이트할 수 있는 "
"이터레이터 객체를 돌려줘야 합니다. 매핑의 경우, 컨테이너의 키를 이터레이트해야 합니다."

#: ../../reference/datamodel.rst:3208
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse"
" iteration.  It should return a new iterator object that iterates over "
"all the objects in the container in reverse order."
msgstr ""
":func:`reversed` 내장 함수가 역 이터레이션(reverse iteration)을 구현하기 위해 (있다면) 호출합니다. "
"컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 합니다."

#: ../../reference/datamodel.rst:3212
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` "
"and :meth:`__getitem__`).  Objects that support the sequence protocol "
"should only provide :meth:`__reversed__` if they can provide an "
"implementation that is more efficient than the one provided by "
":func:`reversed`."
msgstr ""
":meth:`__reversed__` 메서드가 제공되지 않으면, :func:`reversed` 내장함수는 시퀀스 "
"프로토콜(:meth:`__len__` 과 :meth:`__getitem__`)을 대안으로 사용합니다. 시퀀스 프로토콜을 지원하는 "
"객체들은 :func:`reversed` 가 제공하는 것보다 더 효율적인 구현을 제공할 수 있을 때만 "
":meth:`__reversed__` 를 제공해야 합니다."

#: ../../reference/datamodel.rst:3219
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, "
"container objects can supply the following special method with a more "
"efficient implementation, which also does not require the object be "
"iterable."
msgstr ""
"멤버십 검사 연산자들(:keyword:`in` 과 :keyword:`not in`) 은 보통 컨테이너에 대한 이터레이션으로 "
"구현됩니다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 특수 메서드를 통해 제공할 수 있습니다. 이 경우 객체는 "
"이터러블일 필요도 없습니다."

#: ../../reference/datamodel.rst:3226
msgid ""
"Called to implement membership test operators.  Should return true if "
"*item* is in *self*, false otherwise.  For mapping objects, this should "
"consider the keys of the mapping rather than the values or the key-item "
"pairs."
msgstr ""
"멤버십 검사 연산자를 구현하기 위해 호출됩니다. *item* 이 *self* 에 있으면 참을, 그렇지 않으면 거짓을 돌려줘야 "
"합니다. 매핑 객체의 경우, 키-값 쌍이 아니라 매핑의 키가 고려되어야 합니다."

#: ../../reference/datamodel.rst:3230
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence "
"iteration protocol via :meth:`__getitem__`, see :ref:`this section in the"
" language reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` 를 정의하지 않는 객체의 경우, 멤버십 검사는 먼저 :meth:`__iter__` 를 통한 "
"이터레이션을 시도한 후, :meth:`__getitem__` 을 통한 낡은 시퀀스 이터레이션 프로토콜을 시도합니다. :ref:`언어"
" 레퍼런스의 이 절 <membership-test-details>`\\을 참고하십시오."

#: ../../reference/datamodel.rst:3239
msgid "Emulating numeric types"
msgstr "숫자 형 흉내 내기"

#: ../../reference/datamodel.rst:3241
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind"
" of number implemented (e.g., bitwise operations for non-integral "
"numbers) should be left undefined."
msgstr ""
"숫자 형을 흉내 내기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 구현되는 특별한 종류의 숫자에 의해 지원되지 않는 "
"연산들(예를 들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메서드들을 정의되지 않은 채로 남겨두어야 합니다."

#: ../../reference/datamodel.rst:3267
#, fuzzy
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance,"
" to evaluate the expression ``x + y``, where *x* is an instance of a "
"class that has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is "
"called.  The :meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to "
"accept an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""
"이 메서드들은 이항 산술 연산들(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, "
":func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, "
"``|``)을 구현하기 위해 호출됩니다. 예를 들어, *x* 가 :meth:`__add__` 메서드를 가진 클래스의 인스턴스일 때,"
" 표현식 ``x + y`` 의 값을 구하기 위해, ``x.__add__(y)`` 가 호출됩니다. :meth:`__divmod__` "
"메서드는 :meth:`__floordiv__` 와 :meth:`__mod__` 를 사용하는 것과 동등해야 합니다; "
":meth:`__truediv__` 와 연관되지 않아야 합니다; 내장 :func:`pow` 함수의 삼 항 버전이 지원되기 위해서는,"
" :meth:`__pow__` 메서드가 생략할 수 있는 세 번째 인자를 받도록 정의되어야 함에 주의해야 합니다."

#: ../../reference/datamodel.rst:3278
#, fuzzy
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr "만약 이 메서드들 중 하나가 제공된 인자에 대해 연산을 지원하지 않으면, ``NotImplemented`` 를 돌려줘야 합니다."

#: ../../reference/datamodel.rst:3301
#, fuzzy
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of"
" different types. [#]_ For instance, to evaluate the expression ``x - "
"y``, where *y* is an instance of a class that has an :meth:`__rsub__` "
"method, ``type(y).__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)``"
" returns :data:`NotImplemented`."
msgstr ""
"이 메서드들은 뒤집힌 피연산자들에 대해 이항 산술 연산들(``+``, ``-``, ``*``, ``@``, ``/``, "
"``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, "
"``&``, ``^``, ``|``)을 구현하기 위해 호출됩니다. 이 함수들은 왼쪽의 피연산자가 해당 연산을 지원하지 않고 "
"[#]_, 피연산자들이 서로 다른 형일 때만 호출됩니다. [#]_ 예를 들어, 표현식 ``x - y`` 의 값을 구하려고 할 때, "
"*y* 가 :meth:`__rsub__` 를 갖는 클래스의 인스턴스이고, ``x.__sub__(y)`` 가 "
"*NotImplemented* 를 돌려주면 ``y.__rsub__(x)`` 가 호출됩니다."

#: ../../reference/datamodel.rst:3313
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"삼 항 :func:`pow` 는 :meth:`__rpow__` 를 호출하려고 시도하지 않음에 주의해야 합니다 (그렇게 하려면 코어션"
" 규칙이 너무 복잡해집니다)."

#: ../../reference/datamodel.rst:3318
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method"
" for the operation, this method will be called before the left operand's "
"non-reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브 클래스이고, 그 서브 클래스가 연산의 뒤집힌 메서드의 다른 구현을 제공하면,"
" 이 메서드가 왼쪽 연산자의 뒤집히지 않은 메서드보다 먼저 호출됩니다. 이 동작은 서브 클래스가 조상들의 연산을 재정의할 수 있도록"
" 합니다."

#: ../../reference/datamodel.rst:3339
#, fuzzy
msgid ""
"These methods are called to implement the augmented arithmetic "
"assignments (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods should"
" attempt to do the operation in-place (modifying *self*) and return the "
"result (which could be, but does not have to be, *self*).  If a specific "
"method is not defined, or if that method returns :data:`NotImplemented`, "
"the augmented assignment falls back to the normal methods.  For instance,"
" if *x* is an instance of a class with an :meth:`__iadd__` method, ``x +="
" y`` is equivalent to ``x = x.__iadd__(y)`` . If :meth:`__iadd__` does "
"not exist, or if ``x.__iadd__(y)`` returns :data:`!NotImplemented`, "
"``x.__add__(y)`` and ``y.__radd__(x)`` are considered, as with the "
"evaluation of ``x + y``. In certain situations, augmented assignment can "
"result in unexpected errors (see :ref:`faq-augmented-assignment-tuple-"
"error`), but this behavior is in fact part of the data model."
msgstr ""
"이 메서드들은 증분 산술 대입(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``,"
" ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``)을 구현하기 위해 호출됩니다. 이 "
"메서드는 연산을 제자리에서(*self* 를 수정해서) 하도록 시도해야 하고, 결과(반드시 그래야 하는 것은 아니지만 *self* 일"
" 수 있습니다)를 돌려줘야 합니다. 만약 특정 메서드가 정의되지 않으면, 중분 대입은 일반적인 메서드들을 대신 사용합니다. 예를 "
"들어, *x* 가 :meth:`__iadd__` 메서드를 갖는 클래스의 인스턴스면, ``x += y`` 는 ``x = "
"x.__iadd__(y)`` 와 동등합니다. 그렇지 않으면, ``x + y`` 의 값을 구할 때처럼, ``x.__add__(y)``"
" 와 ``y.__radd__(x)`` 가 고려됩니다. 어떤 상황에서, 증분 대입은 예상치 못한 에러로 이어질 수 있습니다. "
"(:ref:`faq-augmented-assignment-tuple-error` 를 보십시오). 하지만 이 동작은 사실 데이터 "
"모델의 일부입니다."

#: ../../reference/datamodel.rst:3362
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr "일 항 산술 연산(``-``, ``+``, :func:`abs`, ``~``)을 구현하기 위해 호출됩니다."

#: ../../reference/datamodel.rst:3375
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` "
"and :func:`float`.  Should return a value of the appropriate type."
msgstr ""
"내장 함수 :func:`complex`, :func:`int`, :func:`float`\\를 구현하기 위해 호출됩니다. 적절한 "
"형의 값을 돌려줘야 합니다."

#: ../../reference/datamodel.rst:3382
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is "
"an integer type.  Must return an integer."
msgstr ""
":func:`operator.index` 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 없이 변환해야 할 "
"때(슬라이싱이나 내장 :func:`bin`, :func:`hex`, :func:`oct` 함수들에서와같이)마다 호출됩니다. 이 "
"메서드의 존재는 숫자 객체가 정수 형임을 가리킵니다. 반드시 정수를 돌려줘야 합니다."

#: ../../reference/datamodel.rst:3388
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
":meth:`__int__`, :meth:`__float__` 및 :meth:`__complex__`\\가 정의되어 있지 않으면, "
"해당 내장 함수 :func:`int`, :func:`float` 및 :func:`complex`\\는 "
":meth:`__index__`\\를 사용합니다."

#: ../../reference/datamodel.rst:3400
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and "
":func:`~math.ceil`. Unless *ndigits* is passed to :meth:`!__round__` all "
"these methods should return the value of the object truncated to an "
":class:`~numbers.Integral` (typically an :class:`int`)."
msgstr ""
"내장 함수 :func:`round`\\와 :mod:`math` 함수 :func:`~math.trunc`, "
":func:`~math.floor`, :func:`~math.ceil` 을 구현하기 위해 호출됩니다. *ndigits* 가 "
":meth:`!__round__` 로 전달되지 않는 한, 이 메서드들은 모두 :class:`~numbers.Integral` (보통"
" :class:`int`) 로 잘린 객체의 값을 돌려줘야 합니다."

#: ../../reference/datamodel.rst:3406
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""

#: ../../reference/datamodel.rst:3409
msgid "The delegation of :func:`int` to :meth:`__trunc__` is deprecated."
msgstr ""

#: ../../reference/datamodel.rst:3416
msgid "With Statement Context Managers"
msgstr "with 문 컨텍스트 관리자"

#: ../../reference/datamodel.rst:3418
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to"
" be established when executing a :keyword:`with` statement. The context "
"manager handles the entry into, and the exit from, the desired runtime "
"context for the execution of the block of code.  Context managers are "
"normally invoked using the :keyword:`!with` statement (described in "
"section :ref:`with`), but can also be used by directly invoking their "
"methods."
msgstr ""
":dfn:`컨텍스트 관리자 (context manager)` 는 :keyword:`with` 문을 실행할 때 자리 잡는 실행 "
"컨텍스트(context)를 정의하는 객체입니다. 코드 블록의 실행을 위해, 컨텍스트 관리자는 원하는 실행시간 컨텍스트로의 진입과 "
"탈출을 처리합니다. 컨텍스트 관리자는 보통 :keyword:`!with` 문(:ref:`with` 섹션에서 설명합니다)으로 "
"시작되지만, 그들의 메서드를 호출해서 직접 사용할 수도 있습니다."

#: ../../reference/datamodel.rst:3429
msgid ""
"Typical uses of context managers include saving and restoring various "
"kinds of global state, locking and unlocking resources, closing opened "
"files, etc."
msgstr ""
"컨텍스트 관리자의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 복구하는 것, 자원을 "
"로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것 등이 있습니다."

#: ../../reference/datamodel.rst:3432
#, fuzzy
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`. "
"The :class:`object` class itself does not provide the context manager "
"methods."
msgstr "컨텍스트 관리자에 대한 더 자세한 정보는 :ref:`typecontextmanager` 에 나옵니다."

#: ../../reference/datamodel.rst:3438
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified"
" in the :keyword:`!as` clause of the statement, if any."
msgstr ""
"이 객체와 연관된 실행시간 컨텍스트에 진입합니다. :keyword:`with` 문은 :keyword:`!as` 절로 지정된 대상이 "
"있다면, 이 메서드의 반환 값을 연결합니다."

#: ../../reference/datamodel.rst:3445
msgid ""
"Exit the runtime context related to this object. The parameters describe "
"the exception that caused the context to be exited. If the context was "
"exited without an exception, all three arguments will be :const:`None`."
msgstr ""
"이 객체와 연관된 실행시간 컨텍스트를 종료합니다. 매개변수들은 컨텍스트에서 벗어나게 만든 예외를 기술합니다. 만약 컨텍스트가 예외 "
"없이 종료한다면, 세 인자 모두 :const:`None` 이 됩니다."

#: ../../reference/datamodel.rst:3449
msgid ""
"If an exception is supplied, and the method wishes to suppress the "
"exception (i.e., prevent it from being propagated), it should return a "
"true value. Otherwise, the exception will be processed normally upon exit"
" from this method."
msgstr ""
"만약 예외가 제공되고, 메서드가 예외를 중지시키고 싶으면 (즉 확산하는 것을 막으려면) 참(true)을 돌려줘야 합니다. 그렇지 "
"않으면 예외는 이 메서드가 종료한 후에 계속 진행됩니다."

#: ../../reference/datamodel.rst:3453
#, fuzzy
msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-"
"in exception; this is the caller's responsibility."
msgstr ""
":meth:`__exit__` 메서드가 전달된 예외를 다시 일으키지(reraise) 않도록 주의해야 합니다; 이것은 "
"호출자(caller)의 책임입니다."

#: ../../reference/datamodel.rst:3459
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 문"

#: ../../reference/datamodel.rst:3460
msgid ""
"The specification, background, and examples for the Python "
":keyword:`with` statement."
msgstr "파이썬 :keyword:`with` 문에 대한 규격, 배경, 예."

#: ../../reference/datamodel.rst:3467
msgid "Customizing positional arguments in class pattern matching"
msgstr ""

#: ../../reference/datamodel.rst:3469
msgid ""
"When using a class name in a pattern, positional arguments in the pattern"
" are not allowed by default, i.e. ``case MyClass(x, y)`` is typically "
"invalid without special support in ``MyClass``. To be able to use that "
"kind of pattern, the class needs to define a *__match_args__* attribute."
msgstr ""

#: ../../reference/datamodel.rst:3476
msgid ""
"This class variable can be assigned a tuple of strings. When this class "
"is used in a class pattern with positional arguments, each positional "
"argument will be converted into a keyword argument, using the "
"corresponding value in *__match_args__* as the keyword. The absence of "
"this attribute is equivalent to setting it to ``()``."
msgstr ""

#: ../../reference/datamodel.rst:3482
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to "
"``case MyClass(left=x, center=y)``. Note that the number of arguments in "
"the pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a"
" :exc:`TypeError`."
msgstr ""

#: ../../reference/datamodel.rst:3492
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ""

#: ../../reference/datamodel.rst:3493
#, fuzzy
msgid "The specification for the Python ``match`` statement."
msgstr "파이썬 :keyword:`with` 문에 대한 규격, 배경, 예."

#: ../../reference/datamodel.rst:3499
#, fuzzy
msgid "Emulating buffer types"
msgstr "숫자 형 흉내 내기"

#: ../../reference/datamodel.rst:3501
msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python "
"objects to expose efficient access to a low-level memory array. This "
"protocol is implemented by builtin types such as :class:`bytes` and "
":class:`memoryview`, and third-party libraries may define additional "
"buffer types."
msgstr ""

#: ../../reference/datamodel.rst:3506
msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""

#: ../../reference/datamodel.rst:3511
msgid ""
"Called when a buffer is requested from *self* (for example, by the "
":class:`memoryview` constructor). The *flags* argument is an integer "
"representing the kind of buffer requested, affecting for example whether "
"the returned buffer is read-only or writable. "
":class:`inspect.BufferFlags` provides a convenient way to interpret the "
"flags. The method must return a :class:`memoryview` object."
msgstr ""

#: ../../reference/datamodel.rst:3520
msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is a "
":class:`memoryview` object that was previously returned by "
":meth:`~object.__buffer__`. The method must release any resources "
"associated with the buffer. This method should return ``None``. Buffer "
"objects that do not need to perform any cleanup are not required to "
"implement this method."
msgstr ""

#: ../../reference/datamodel.rst:3531
msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ""

#: ../../reference/datamodel.rst:3532
msgid "Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr ""

#: ../../reference/datamodel.rst:3534
msgid ":class:`collections.abc.Buffer`"
msgstr ""

#: ../../reference/datamodel.rst:3535
msgid "ABC for buffer types."
msgstr ""

#: ../../reference/datamodel.rst:3540
msgid "Special method lookup"
msgstr "특수 메서드 조회"

#: ../../reference/datamodel.rst:3542
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"사용자 정의 클래스의 경우, 묵시적인 특수 메서드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 형에 정의되어 있을 때만 올바르게"
" 동작함이 보장됩니다. 이런 동작은 다음과 같은 코드가 예외를 일으키는 원인입니다:"

#: ../../reference/datamodel.rst:3547
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""

#: ../../reference/datamodel.rst:3557
#, fuzzy
msgid ""
"The rationale behind this behaviour lies with a number of special methods"
" such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit "
"lookup of these methods used the conventional lookup process, they would "
"fail when invoked on the type object itself::"
msgstr ""
"이런 동작의 배경에 깔린 논리는, 모든 객체(형 객체를 포함해서)에 의해 구현되는 :meth:`__hash__` 나 "
":meth:`__repr__` 과 같은 많은 특수 메서드들과 관련이 있습니다. 만약 이 메서드들에 대한 묵시적인 조회가 일반적인 "
"조회 프로세스를 거친다면, 형 객체 자체에 대해 호출되었을 때 실패하게 됩니다:"

#: ../../reference/datamodel.rst:3564
msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""

#: ../../reference/datamodel.rst:3571
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way"
" is sometimes referred to as 'metaclass confusion', and is avoided by "
"bypassing the instance when looking up special methods::"
msgstr ""
"클래스의 연결되지 않은 메서드를 호출하려는 이런 식의 잘못된 시도는 종종 '메타 클래스 혼란(metaclass confusion)'"
" 이라고 불리고, 특수 메서드를 조회할 때 인스턴스를 우회하는 방법으로 피할 수 있습니다."

#: ../../reference/datamodel.rst:3575
msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""

#: ../../reference/datamodel.rst:3580
#, fuzzy
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"올바름을 추구하기 위해 인스턴스 어트리뷰트들을 우회하는 것에 더해, 묵시적인 특수 메서드 조회는 객체의 메타 클래스의 "
":meth:`__getattribute__` 메서드 조차도 우회합니다::"

#: ../../reference/datamodel.rst:3584
msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""

#: ../../reference/datamodel.rst:3606
#, fuzzy
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the "
"interpreter, at the cost of some flexibility in the handling of special "
"methods (the special method *must* be set on the class object itself in "
"order to be consistently invoked by the interpreter)."
msgstr ""
"이런 식으로 :meth:`__getattribute__` 절차를 우회하는 것은 특수 메서드 처리의 유연함을 일부 포기하는 대신(특수"
" 메서드가 인터프리터에 의해 일관성 있게 호출되기 위해서는 *반드시* 클래스 객체에 설정되어야 합니다), 인터프리터 내부에서의 속도"
" 최적화를 위한 상당한 기회를 제공합니다."

#: ../../reference/datamodel.rst:3617
msgid "Coroutines"
msgstr "코루틴(Coroutines)"

#: ../../reference/datamodel.rst:3621
msgid "Awaitable Objects"
msgstr "어웨이터블 객체(Awaitable Objects)"

#: ../../reference/datamodel.rst:3623
#, fuzzy
msgid ""
"An :term:`awaitable` object generally implements an "
":meth:`~object.__await__` method. :term:`Coroutine objects <coroutine>` "
"returned from :keyword:`async def` functions are awaitable."
msgstr ""
":term:`어웨이터블 <awaitable>` 객체는 일반적으로 :meth:`__await__` 메서드를 구현합니다. "
":keyword:`async def` 함수가 돌려주는 :term:`코루틴 객체 <coroutine>`\\는 어웨이터블입니다."

#: ../../reference/datamodel.rst:3629
#, fuzzy
msgid ""
"The :term:`generator iterator` objects returned from generators decorated"
" with :func:`types.coroutine` are also awaitable, but they do not "
"implement :meth:`~object.__await__`."
msgstr ""
":func:`types.coroutine` 이나 :func:`asyncio.coroutine` 로 데코레이션된 제너레이터가 돌려주는"
" :term:`제너레이터 이터레이터 <generator iterator>` 객체 또한 어웨이터블이지만 "
":meth:`__await__` 를 구현하지 않습니다."

#: ../../reference/datamodel.rst:3635
#, fuzzy
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` "
"implements this method to be compatible with the :keyword:`await` "
"expression. The :class:`object` class itself is not awaitable and does "
"not provide this method."
msgstr ""
":term:`이터레이터 <iterator>` 를 돌려줘야 합니다. :term:`어웨이터블 <awaitable>` 객체를 구현하기 "
"위해 사용되어야 합니다. 예를 들어, :class:`asyncio.Future` 는 :keyword:`await` 표현식과 호환되기"
" 위해 이 메서드를 구현합니다."

#: ../../reference/datamodel.rst:3643
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework "
"(e.g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""

#: ../../reference/datamodel.rst:3651
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있습니다."

#: ../../reference/datamodel.rst:3657
msgid "Coroutine Objects"
msgstr "코루틴 객체(Coroutine Objects)"

#: ../../reference/datamodel.rst:3659
#, fuzzy
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling "
":meth:`~object.__await__` and iterating over the result.  When the "
"coroutine has finished executing and returns, the iterator raises "
":exc:`StopIteration`, and the exception's :attr:`~StopIteration.value` "
"attribute holds the return value.  If the coroutine raises an exception, "
"it is propagated by the iterator.  Coroutines should not directly raise "
"unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`코루틴 객체 <coroutine>`\\는 :term:`어웨이터블 <awaitable>` 객체입니다. 코루틴의 실행은 "
":meth:`__await__` 를 호출하고 그 결과를 이터레이트하는 방법으로 제어될 수 있습니다. 코루틴이 실행을 완료하고 복귀할"
" 때, 이터레이터는 :exc:`StopIteration` 을 일으키고, 예외의 :attr:`~StopIteration.value` "
"어트리뷰트가 반환 값을 갖고 있습니다. 만약 코루틴이 예외를 일으키면, 이터레이터에 의해 퍼집니다. 코루틴이 직접 잡히지 않은 "
":exc:`StopIteration` 예외를 일으키지는 말아야 합니다."

#: ../../reference/datamodel.rst:3667
msgid ""
"Coroutines also have the methods listed below, which are analogous to "
"those of generators (see :ref:`generator-methods`).  However, unlike "
"generators, coroutines do not directly support iteration."
msgstr ""
"코루틴은 다음에 나열하는 메서드들 또한 갖고 있는데, 제너레이터(:ref:`generator-methods` 를 보십시오)의 것들과"
" 닮았습니다. 하지만, 제너레이터와는 달리, 코루틴은 이터레이션을 직접 지원하지는 않습니다."

#: ../../reference/datamodel.rst:3671
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "코루틴을 두 번 await 하면 :exc:`RuntimeError` 를 일으킵니다."

#: ../../reference/datamodel.rst:3677
#, fuzzy
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, "
"this is equivalent to advancing the iterator returned by "
":meth:`~object.__await__`.  If *value* is not ``None``, this method "
"delegates to the :meth:`~generator.send` method of the iterator that "
"caused the coroutine to suspend.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating "
"over the :meth:`!__await__` return value, described above."
msgstr ""
"코루틴의 실행을 시작하거나 재개합니다. *value* 가 ``None`` 이면, :meth:`__await__` 가 돌려준 "
"이터레이터를 전진시키는 것과 같습니다. *value* 가 ``None`` 이 아니면, 이 메서드는 코루틴이 일시 중지되도록 한 "
"이터레이터의 :meth:`~generator.send` 메서드로 위임합니다. 결과(반환 값, :exc:`StopIteration` "
"이나 다른 예외)는 위에서 설명한 :meth:`__await__` 의 반환 값을 이터레이트할 때와 같습니다."

#: ../../reference/datamodel.rst:3688
#, fuzzy
msgid ""
"Raises the specified exception in the coroutine.  This method delegates "
"to the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception "
"is raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating "
"over the :meth:`~object.__await__` return value, described above.  If the"
" exception is not caught in the coroutine, it propagates back to the "
"caller."
msgstr ""
"코루틴에서 지정한 예외가 발생하도록 합니다. 이 메서드는 코루틴이 일시 중지되도록 한 이터레이터의 "
":meth:`~generator.throw` 메서드로 위임합니다(그런 메서드를 가지는 경우). 그렇지 않으면, 일시 중지지점에서 "
"예외가 발생합니다. 결과(반환 값, :exc:`StopIteration` 이나 다른 예외)는 위에서 설명한 "
":meth:`__await__` 의 반환 값을 이터레이트할 때와 같습니다. 만약 예외가 코루틴에서 잡히지 않는다면 호출자에게 되돌아"
" 전파됩니다."

#: ../../reference/datamodel.rst:3699
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is "
"deprecated and may be removed in a future version of Python."
msgstr ""

#: ../../reference/datamodel.rst:3704
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has "
"such a method.  Then it raises :exc:`GeneratorExit` at the suspension "
"point, causing the coroutine to immediately clean itself up. Finally, the"
" coroutine is marked as having finished executing, even if it was never "
"started."
msgstr ""
"코루틴이 자신을 정리하고 종료하도록 만듭니다. 만약 코루틴이 일시 중지 중이면, 이 메서드는 먼저 코루틴이 일시 중지되도록 한 "
"이터레이터의 :meth:`~generator.close` 메서드로 위임합니다(그런 메서드를 가지는 경우). 그런 다음 일시 "
"중지지점에서 :exc:`GeneratorExit` 를 발생시키는데, 코루틴이 즉시 자신을 정리하도록 만듭니다. 마지막으로 코루틴에 "
"실행을 종료했다고 표시하는데, 아직 시작하지조차 않았을 때도 그렇다."

#: ../../reference/datamodel.rst:3712
msgid ""
"Coroutine objects are automatically closed using the above process when "
"they are about to be destroyed."
msgstr "코루틴 객체가 파괴될 때는 위의 프로세스에 따라 자동으로 닫힙니다(closed)."

#: ../../reference/datamodel.rst:3718
msgid "Asynchronous Iterators"
msgstr "비동기 이터레이터(Asynchronous Iterators)"

#: ../../reference/datamodel.rst:3720
msgid ""
"An *asynchronous iterator* can call asynchronous code in its "
"``__anext__`` method."
msgstr "*비동기 이터레이터* 는 자신의 ``__anext__`` 메서드에서 비동기 코드를 호출할 수 있습니다."

#: ../../reference/datamodel.rst:3723
msgid "Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "비동기 이터레이터는 :keyword:`async for` 문에서 사용될 수 있습니다."

#: ../../reference/datamodel.rst:3725 ../../reference/datamodel.rst:3774
msgid "The :class:`object` class itself does not provide these methods."
msgstr ""

#: ../../reference/datamodel.rst:3730
msgid "Must return an *asynchronous iterator* object."
msgstr "*비동기 이터레이터* 객체를 돌려줘야 합니다."

#: ../../reference/datamodel.rst:3734
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is "
"over."
msgstr ""
"이터레이터의 다음 값을 주는 *어웨이터블* 을 돌려줘야 합니다. 이터레이션이 끝나면 :exc:`StopAsyncIteration` "
"에러를 일으켜야 합니다."

#: ../../reference/datamodel.rst:3737
msgid "An example of an asynchronous iterable object::"
msgstr "비동기 이터러블 객체의 예::"

#: ../../reference/datamodel.rst:3739
msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""

#: ../../reference/datamodel.rst:3754
#, fuzzy
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an "
"*awaitable* that would resolve to an :term:`asynchronous iterator "
"<asynchronous iterator>`."
msgstr ""
"파이썬 3.7 이전에, ``__aiter__`` 는 :term:`비동기 이터레이터 <asynchronous iterator>` 로 "
"결정될 *어웨이터블* 을 반환 할 수 있었습니다."

#: ../../reference/datamodel.rst:3759
#, fuzzy
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a "
":exc:`TypeError` error."
msgstr ""
"파이썬 3.7부터, ``__aiter__`` 는 반드시 비동기 이터레이터 객체를 돌려줘야 합니다. 다른 것을 돌려주면 "
":exc:`TypeError` 에러가 발생합니다."

#: ../../reference/datamodel.rst:3767
msgid "Asynchronous Context Managers"
msgstr "비동기 컨텍스트 관리자"

#: ../../reference/datamodel.rst:3769
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*비동기 컨텍스트 관리자(asynchronous context manager)* 는 ``__aenter__`` 와 "
"``__aexit__`` 메서드에서 실행을 일시 중지할 수 있는 *컨텍스트 관리자* 입니다."

#: ../../reference/datamodel.rst:3772
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr "비동기 컨텍스트 관리자는 :keyword:`async with` 문에서 사용될 수 있습니다."

#: ../../reference/datamodel.rst:3778
#, fuzzy
msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference "
"being that it must return an *awaitable*."
msgstr ":meth:`__enter__` 메서드와 의미상으로 유사한데, 유일한 차이점은 *어웨이터블* 을 돌려줘야 한다는 것입니다."

#: ../../reference/datamodel.rst:3783
#, fuzzy
msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference "
"being that it must return an *awaitable*."
msgstr ":meth:`__exit__` 메서드와 의미상으로 유사한데, 유일한 차이점은 *어웨이터블* 을 돌려줘야 한다는 것입니다."

#: ../../reference/datamodel.rst:3786
msgid "An example of an asynchronous context manager class::"
msgstr "비동기 컨텍스트 관리자 클래스의 예::"

#: ../../reference/datamodel.rst:3788
msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""

#: ../../reference/datamodel.rst:3799
msgid "Footnotes"
msgstr "각주"

#: ../../reference/datamodel.rst:3800
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it "
"can lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"어떤 제한된 조건으로, 어떤 경우에 객체의 형을 변경하는 것이 *가능합니다*. 하지만 잘못 다뤄지면 아주 괴상한 결과로 이어질 수 "
"있으므로 일반적으로 좋은 생각이 아닙니다."

#: ../../reference/datamodel.rst:3804
#, fuzzy
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, "
":meth:`~object.__reversed__`, :meth:`~object.__contains__`, "
":meth:`~object.__class_getitem__` and :meth:`~os.PathLike.__fspath__` "
"methods have special handling for this. Others will still raise a "
":exc:`TypeError`, but may do so by relying on the behavior that ``None`` "
"is not callable."
msgstr ""
":meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, "
":meth:`__contains__` 메서드들이 이런 경우에 대한 특별한 처리를 포함하고 있습니다; 다른 것들도 여전히 "
":exc:`TypeError` 을 일으키지만, 단지 ``None`` 이 콜러블이 아니므로 그런 것뿐입니다."

#: ../../reference/datamodel.rst:3811
#, fuzzy
msgid ""
"\"Does not support\" here means that the class has no such method, or the"
" method returns :data:`NotImplemented`.  Do not set the method to "
"``None`` if you want to force fallback to the right operand's reflected "
"method—that will instead have the opposite effect of explicitly "
"*blocking* such fallback."
msgstr ""
"여기서 \"지원하지 않는다\" 는 클래스가 그런 메서드를 갖지 않거나, 메서드가 ``NotImplemented`` 를 돌려줌을 "
"뜻합니다. 오른쪽 피연산자의 뒤집힌 메서드를 사용하는 대안이 시도되도록 하려면 메서드를 ``None`` 으로 설정하지 말아야 합니다"
" - 그렇게 하는 것은 그런 대안을 명시적으로 *금지하는* 반대 효과를 줍니다."

#: ../../reference/datamodel.rst:3817
#, fuzzy
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not "
"called."
msgstr ""
"피연산자들이 같은 형이면, 뒤집히지 않은 메서드(가령 :meth:`__add__`)가 실패하면 그 전체 연산이 지원되지 않는 것으로"
" 간주합니다. 이것이 뒤집힌 메서드가 호출되지 않는 이유입니다."

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:152
#: ../../reference/datamodel.rst:163 ../../reference/datamodel.rst:184
#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:229
#: ../../reference/datamodel.rst:250 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:328 ../../reference/datamodel.rst:363
#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:409
#: ../../reference/datamodel.rst:427 ../../reference/datamodel.rst:447
#: ../../reference/datamodel.rst:455 ../../reference/datamodel.rst:466
#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:519
#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:661
#: ../../reference/datamodel.rst:799 ../../reference/datamodel.rst:823
#: ../../reference/datamodel.rst:859 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:1265 ../../reference/datamodel.rst:1292
#: ../../reference/datamodel.rst:1364 ../../reference/datamodel.rst:1472
#: ../../reference/datamodel.rst:1581 ../../reference/datamodel.rst:1691
#: ../../reference/datamodel.rst:2116 ../../reference/datamodel.rst:3134
#, fuzzy
msgid "object"
msgstr "코드 객체(Code objects)"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:126
msgid "data"
msgstr ""

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:343 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:799
#: ../../reference/datamodel.rst:1321 ../../reference/datamodel.rst:1774
#: ../../reference/datamodel.rst:2017 ../../reference/datamodel.rst:2023
#: ../../reference/datamodel.rst:2116 ../../reference/datamodel.rst:2673
#: ../../reference/datamodel.rst:3104 ../../reference/datamodel.rst:3262
#: ../../reference/datamodel.rst:3297 ../../reference/datamodel.rst:3311
#: ../../reference/datamodel.rst:3360 ../../reference/datamodel.rst:3370
#: ../../reference/datamodel.rst:3398
#, fuzzy
msgid "built-in function"
msgstr "내장 함수(Built-in functions)"

#: ../../reference/datamodel.rst:23
msgid "id"
msgstr ""

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:126
#: ../../reference/datamodel.rst:2673
#, fuzzy
msgid "type"
msgstr "집합 형들(Set types)"

#: ../../reference/datamodel.rst:23
msgid "identity of an object"
msgstr ""

#: ../../reference/datamodel.rst:23
msgid "value of an object"
msgstr ""

#: ../../reference/datamodel.rst:23
#, fuzzy
msgid "type of an object"
msgstr "프레임 객체(Frame objects)"

#: ../../reference/datamodel.rst:23
#, fuzzy
msgid "mutable object"
msgstr "어웨이터블 객체(Awaitable Objects)"

#: ../../reference/datamodel.rst:23
#, fuzzy
msgid "immutable object"
msgstr "어웨이터블 객체(Awaitable Objects)"

#: ../../reference/datamodel.rst:60
msgid "garbage collection"
msgstr ""

#: ../../reference/datamodel.rst:60
msgid "reference counting"
msgstr ""

#: ../../reference/datamodel.rst:60
#, fuzzy
msgid "unreachable object"
msgstr "어웨이터블 객체(Awaitable Objects)"

#: ../../reference/datamodel.rst:95 ../../reference/datamodel.rst:1126
#, fuzzy
msgid "container"
msgstr "코루틴(Coroutines)"

#: ../../reference/datamodel.rst:126
msgid "hierarchy"
msgstr ""

#: ../../reference/datamodel.rst:126
msgid "extension"
msgstr ""

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:400
#: ../../reference/datamodel.rst:401 ../../reference/datamodel.rst:502
#: ../../reference/datamodel.rst:859 ../../reference/datamodel.rst:879
#: ../../reference/datamodel.rst:1321
#, fuzzy
msgid "module"
msgstr "모듈(Modules)"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:799
msgid "C"
msgstr ""

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:799
msgid "language"
msgstr ""

#: ../../reference/datamodel.rst:139 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:1144 ../../reference/datamodel.rst:1265
#: ../../reference/datamodel.rst:1285
#, fuzzy
msgid "attribute"
msgstr "어트리뷰트"

#: ../../reference/datamodel.rst:139
msgid "special"
msgstr ""

#: ../../reference/datamodel.rst:139
msgid "generic"
msgstr ""

#: ../../reference/datamodel.rst:184
msgid "..."
msgstr ""

#: ../../reference/datamodel.rst:184
#, fuzzy
msgid "ellipsis literal"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:1292
msgid "numeric"
msgstr ""

#: ../../reference/datamodel.rst:229 ../../reference/datamodel.rst:235
#: ../../reference/datamodel.rst:343
msgid "integer"
msgstr ""

#: ../../reference/datamodel.rst:235
msgid "representation"
msgstr ""

#: ../../reference/datamodel.rst:250
msgid "Boolean"
msgstr ""

#: ../../reference/datamodel.rst:250
msgid "False"
msgstr ""

#: ../../reference/datamodel.rst:250
#, fuzzy
msgid "True"
msgstr "어트리뷰트"

#: ../../reference/datamodel.rst:265
msgid "floating-point"
msgstr ""

#: ../../reference/datamodel.rst:265 ../../reference/datamodel.rst:283
msgid "number"
msgstr ""

#: ../../reference/datamodel.rst:265
msgid "Java"
msgstr ""

#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:3370
msgid "complex"
msgstr ""

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:3104
msgid "len"
msgstr ""

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:1292
#, fuzzy
msgid "sequence"
msgstr "시퀀스들"

#: ../../reference/datamodel.rst:296
msgid "index operation"
msgstr ""

#: ../../reference/datamodel.rst:296
msgid "item selection"
msgstr ""

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:388
#: ../../reference/datamodel.rst:466
msgid "subscription"
msgstr ""

#: ../../reference/datamodel.rst:311 ../../reference/datamodel.rst:388
msgid "slicing"
msgstr ""

#: ../../reference/datamodel.rst:328
#, fuzzy
msgid "immutable sequence"
msgstr "불변 시퀀스"

#: ../../reference/datamodel.rst:328
#, fuzzy
msgid "immutable"
msgstr "쓰기 가능"

#: ../../reference/datamodel.rst:339 ../../reference/datamodel.rst:1992
#: ../../reference/datamodel.rst:2023
#, fuzzy
msgid "string"
msgstr "문자열(Strings)"

#: ../../reference/datamodel.rst:339
#, fuzzy
msgid "immutable sequences"
msgstr "불변 시퀀스"

#: ../../reference/datamodel.rst:343
msgid "chr"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "ord"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "character"
msgstr ""

#: ../../reference/datamodel.rst:343
msgid "Unicode"
msgstr ""

#: ../../reference/datamodel.rst:363
#, fuzzy
msgid "tuple"
msgstr "튜플(Tuples)"

#: ../../reference/datamodel.rst:363
msgid "singleton"
msgstr ""

#: ../../reference/datamodel.rst:363
msgid "empty"
msgstr ""

#: ../../reference/datamodel.rst:376 ../../reference/datamodel.rst:2017
#, fuzzy
msgid "bytes"
msgstr "바이트열(Bytes)"

#: ../../reference/datamodel.rst:376
#, fuzzy
msgid "byte"
msgstr "바이트열(Bytes)"

#: ../../reference/datamodel.rst:388
#, fuzzy
msgid "mutable sequence"
msgstr "가변 시퀀스"

#: ../../reference/datamodel.rst:388
#, fuzzy
msgid "mutable"
msgstr "쓰기 가능"

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:1144
#: ../../reference/datamodel.rst:1285
msgid "assignment"
msgstr ""

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:859
#: ../../reference/datamodel.rst:1728 ../../reference/datamodel.rst:1910
#: ../../reference/datamodel.rst:3425
msgid "statement"
msgstr ""

#: ../../reference/datamodel.rst:400
#, fuzzy
msgid "array"
msgstr "바이트 배열(Byte Arrays)"

#: ../../reference/datamodel.rst:401
#, fuzzy
msgid "collections"
msgstr "코루틴 함수(Coroutine functions)"

#: ../../reference/datamodel.rst:409
#, fuzzy
msgid "list"
msgstr "리스트(Lists)"

#: ../../reference/datamodel.rst:416
#, fuzzy
msgid "bytearray"
msgstr "바이트 배열(Byte Arrays)"

#: ../../reference/datamodel.rst:427
#, fuzzy
msgid "set type"
msgstr "집합 형들(Set types)"

#: ../../reference/datamodel.rst:447
#, fuzzy
msgid "set"
msgstr "집합(Sets)"

#: ../../reference/datamodel.rst:455
#, fuzzy
msgid "frozenset"
msgstr "불변 집합(Frozen sets)"

#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:1292
#, fuzzy
msgid "mapping"
msgstr "매핑(Mappings)"

#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:2116
#, fuzzy
msgid "dictionary"
msgstr "딕셔너리(Dictionaries)"

#: ../../reference/datamodel.rst:502
msgid "dbm.ndbm"
msgstr ""

#: ../../reference/datamodel.rst:502
msgid "dbm.gnu"
msgstr ""

#: ../../reference/datamodel.rst:519
#, fuzzy
msgid "callable"
msgstr "콜러블(Callable types)"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:534
#: ../../reference/datamodel.rst:743 ../../reference/datamodel.rst:761
#: ../../reference/datamodel.rst:774 ../../reference/datamodel.rst:799
#, fuzzy
msgid "function"
msgstr "내장 함수(Built-in functions)"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:1126
#: ../../reference/datamodel.rst:1149 ../../reference/datamodel.rst:3054
msgid "call"
msgstr ""

#: ../../reference/datamodel.rst:519
msgid "invocation"
msgstr ""

#: ../../reference/datamodel.rst:519
msgid "argument"
msgstr ""

#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:661
#, fuzzy
msgid "user-defined"
msgstr "사용자 정의 함수"

#: ../../reference/datamodel.rst:534
#, fuzzy
msgid "user-defined function"
msgstr "사용자 정의 함수"

#: ../../reference/datamodel.rst:547
msgid "__closure__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:547
msgid "__globals__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:547
msgid "global"
msgstr ""

#: ../../reference/datamodel.rst:547 ../../reference/datamodel.rst:879
msgid "namespace"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__doc__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__name__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__module__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__dict__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__defaults__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__code__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__annotations__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__kwdefaults__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:574
msgid "__type_params__ (function attribute)"
msgstr ""

#: ../../reference/datamodel.rst:661 ../../reference/datamodel.rst:823
msgid "method"
msgstr ""

#: ../../reference/datamodel.rst:661
#, fuzzy
msgid "user-defined method"
msgstr "사용자 정의 함수"

#: ../../reference/datamodel.rst:669
msgid "__func__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__self__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__doc__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__name__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:669
msgid "__module__ (method attribute)"
msgstr ""

#: ../../reference/datamodel.rst:743 ../../reference/datamodel.rst:1472
#, fuzzy
msgid "generator"
msgstr "제너레이터 함수(Generator functions)"

#: ../../reference/datamodel.rst:743
msgid "iterator"
msgstr ""

#: ../../reference/datamodel.rst:761 ../../reference/datamodel.rst:3613
#, fuzzy
msgid "coroutine"
msgstr "코루틴(Coroutines)"

#: ../../reference/datamodel.rst:774
#, fuzzy
msgid "asynchronous generator"
msgstr "비동기 이터레이터(Asynchronous Iterators)"

#: ../../reference/datamodel.rst:774
#, fuzzy
msgid "asynchronous iterator"
msgstr "비동기 이터레이터(Asynchronous Iterators)"

#: ../../reference/datamodel.rst:823
#, fuzzy
msgid "built-in method"
msgstr "내장 메서드(Built-in methods)"

#: ../../reference/datamodel.rst:823
#, fuzzy
msgid "built-in"
msgstr "내장 메서드(Built-in methods)"

#: ../../reference/datamodel.rst:859
msgid "import"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__name__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
#, fuzzy
msgid "__spec__ (module attribute)"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../../reference/datamodel.rst:879
msgid "__package__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
#, fuzzy
msgid "__loader__ (module attribute)"
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../../reference/datamodel.rst:879
msgid "__path__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
msgid "__file__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:879
#, fuzzy
msgid "__cached__ (module attribute)"
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../../reference/datamodel.rst:879
#, fuzzy
msgid "__doc__ (module attribute)"
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../../reference/datamodel.rst:879
msgid "__annotations__ (module attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1094
#, fuzzy
msgid "__dict__ (module attribute)"
msgstr "모듈 어트리뷰트 액세스 커스터마이제이션"

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1144
#: ../../reference/datamodel.rst:1265 ../../reference/datamodel.rst:1893
#: ../../reference/datamodel.rst:2784
#, fuzzy
msgid "class"
msgstr "클래스(Classes)"

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1265
#: ../../reference/datamodel.rst:1285
#, fuzzy
msgid "class instance"
msgstr "클래스 인스턴스(Class instances)"

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1265
#: ../../reference/datamodel.rst:3054
#, fuzzy
msgid "instance"
msgstr "클래스 인스턴스(Class instances)"

#: ../../reference/datamodel.rst:1126 ../../reference/datamodel.rst:1149
#, fuzzy
msgid "class object"
msgstr "클래스 메서드 객체(Class method objects)"

#: ../../reference/datamodel.rst:1156
msgid "__name__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__module__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__dict__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
#, fuzzy
msgid "__bases__ (class attribute)"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../../reference/datamodel.rst:1156
msgid "__doc__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__annotations__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__type_params__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__static_attributes__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1156
msgid "__firstlineno__ (class attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1303
msgid "__dict__ (instance attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1303
#, fuzzy
msgid "__class__ (instance attribute)"
msgstr "클래스 인스턴스(Class instances)"

#: ../../reference/datamodel.rst:1321
msgid "open"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "io"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "popen() (in module os)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "makefile() (socket method)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "sys.stdin"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "sys.stdout"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "sys.stderr"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stdio"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stdin (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stdout (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid "stderr (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1350
#, fuzzy
msgid "internal type"
msgstr "내부 형(Internal types)"

#: ../../reference/datamodel.rst:1350
msgid "types, internal"
msgstr ""

#: ../../reference/datamodel.rst:1364
#, fuzzy
msgid "bytecode"
msgstr "바이트열(Bytes)"

#: ../../reference/datamodel.rst:1364
msgid "code"
msgstr ""

#: ../../reference/datamodel.rst:1364
#, fuzzy
msgid "code object"
msgstr "코드 객체(Code objects)"

#: ../../reference/datamodel.rst:1375
msgid "co_argcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_posonlyargcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_kwonlyargcount (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_code (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_consts (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_filename (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_firstlineno (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_flags (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_lnotab (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_name (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_names (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_nlocals (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_stacksize (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_varnames (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_cellvars (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_freevars (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1375
msgid "co_qualname (code object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1490
msgid "documentation string"
msgstr ""

#: ../../reference/datamodel.rst:1581
msgid "frame"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_back (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_code (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_globals (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_locals (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_lasti (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1587
msgid "f_builtins (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_trace (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_trace_lines (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_trace_opcodes (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1631
msgid "f_lineno (frame attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1691
#, fuzzy
msgid "traceback"
msgstr "트레이스백 객체(Traceback objects)"

#: ../../reference/datamodel.rst:1691
msgid "stack"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "trace"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "exception"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "handler"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "execution"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "exc_info (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "last_traceback (in module sys)"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "sys.exc_info"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "sys.exception"
msgstr ""

#: ../../reference/datamodel.rst:1691
msgid "sys.last_traceback"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "tb_frame (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "tb_lineno (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "tb_lasti (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid "try"
msgstr ""

#: ../../reference/datamodel.rst:1758
msgid "tb_next (traceback attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1774 ../../reference/datamodel.rst:3134
msgid "slice"
msgstr ""

#: ../../reference/datamodel.rst:1780
msgid "start (slice object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1780
msgid "stop (slice object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1780
msgid "step (slice object attribute)"
msgstr ""

#: ../../reference/datamodel.rst:1828
msgid "operator"
msgstr ""

#: ../../reference/datamodel.rst:1828
msgid "overloading"
msgstr ""

#: ../../reference/datamodel.rst:1828
msgid "__getitem__() (mapping object method)"
msgstr ""

#: ../../reference/datamodel.rst:1864
#, fuzzy
msgid "subclassing"
msgstr "클래스 결합"

#: ../../reference/datamodel.rst:1864
#, fuzzy
msgid "immutable types"
msgstr "불변 시퀀스"

#: ../../reference/datamodel.rst:1893
msgid "constructor"
msgstr ""

#: ../../reference/datamodel.rst:1910
msgid "destructor"
msgstr ""

#: ../../reference/datamodel.rst:1910
msgid "finalizer"
msgstr ""

#: ../../reference/datamodel.rst:1910
msgid "del"
msgstr ""

#: ../../reference/datamodel.rst:1974
#, fuzzy
msgid "repr() (built-in function)"
msgstr "내장 함수(Built-in functions)"

#: ../../reference/datamodel.rst:1974
msgid "__repr__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:1992
msgid "__str__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:1992
#, fuzzy
msgid "format() (built-in function)"
msgstr "내장 함수(Built-in functions)"

#: ../../reference/datamodel.rst:1992
#, fuzzy
msgid "print() (built-in function)"
msgstr "내장 함수(Built-in functions)"

#: ../../reference/datamodel.rst:2023
msgid "__format__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:2023
msgid "conversion"
msgstr ""

#: ../../reference/datamodel.rst:2023
msgid "print"
msgstr ""

#: ../../reference/datamodel.rst:2065
msgid "comparisons"
msgstr ""

#: ../../reference/datamodel.rst:2116
msgid "hash"
msgstr ""

#: ../../reference/datamodel.rst:2197
msgid "__len__() (mapping object method)"
msgstr ""

#: ../../reference/datamodel.rst:2302
#, fuzzy
msgid "__getattr__ (module attribute)"
msgstr "``__getattr__`` 과 ``__dir__`` 모듈 어트리뷰트."

#: ../../reference/datamodel.rst:2302
#, fuzzy
msgid "__dir__ (module attribute)"
msgstr "``__getattr__`` 과 ``__dir__`` 모듈 어트리뷰트."

#: ../../reference/datamodel.rst:2302
#, fuzzy
msgid "__class__ (module attribute)"
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../../reference/datamodel.rst:2673
#, fuzzy
msgid "metaclass"
msgstr "메타 클래스"

#: ../../reference/datamodel.rst:2673
msgid "= (equals)"
msgstr ""

#: ../../reference/datamodel.rst:2673
#, fuzzy
msgid "class definition"
msgstr "클래스 결합"

#: ../../reference/datamodel.rst:2737
#, fuzzy
msgid "metaclass hint"
msgstr "메타 클래스"

#: ../../reference/datamodel.rst:2760
msgid "__prepare__ (metaclass method)"
msgstr ""

#: ../../reference/datamodel.rst:2784
msgid "body"
msgstr ""

#: ../../reference/datamodel.rst:2804
#, fuzzy
msgid "__class__ (method cell)"
msgstr "클래스 메서드 객체(Class method objects)"

#: ../../reference/datamodel.rst:2804
msgid "__classcell__ (class namespace entry)"
msgstr ""

#: ../../reference/datamodel.rst:3104
msgid "__bool__() (object method)"
msgstr ""

#: ../../reference/datamodel.rst:3262 ../../reference/datamodel.rst:3297
msgid "divmod"
msgstr ""

#: ../../reference/datamodel.rst:3262 ../../reference/datamodel.rst:3297
#: ../../reference/datamodel.rst:3311
msgid "pow"
msgstr ""

#: ../../reference/datamodel.rst:3360
msgid "abs"
msgstr ""

#: ../../reference/datamodel.rst:3370
msgid "int"
msgstr ""

#: ../../reference/datamodel.rst:3370
msgid "float"
msgstr ""

#: ../../reference/datamodel.rst:3398
msgid "round"
msgstr ""

#: ../../reference/datamodel.rst:3425
msgid "with"
msgstr ""

#: ../../reference/datamodel.rst:3425
#, fuzzy
msgid "context manager"
msgstr "비동기 컨텍스트 관리자"

#~ msgid ""
#~ "The extension module :mod:`array` provides "
#~ "an additional example of a mutable "
#~ "sequence type, as does the "
#~ ":mod:`collections` module."
#~ msgstr ""
#~ "확장 모듈 :mod:`array` 는 추가의 가변 시퀀스"
#~ " 형을 제공하는데, :mod:`collections` 모듈 역시 "
#~ "마찬가지입니다."

#~ msgid ":attr:`__doc__`"
#~ msgstr ":attr:`__doc__`"

#~ msgid ":attr:`~definition.\\ __name__`"
#~ msgstr ":attr:`~definition.\\ __name__`"

#~ msgid ":attr:`~definition.\\ __qualname__`"
#~ msgstr ":attr:`~definition.\\ __qualname__`"

#~ msgid "The function's :term:`qualified name`."
#~ msgstr "함수의 :term:`정규화된 이름 <qualified name>`."

#~ msgid ":attr:`__module__`"
#~ msgstr ":attr:`__module__`"

#~ msgid ":attr:`__defaults__`"
#~ msgstr ":attr:`__defaults__`"

#~ msgid ":attr:`__code__`"
#~ msgstr ":attr:`__code__`"

#~ msgid ":attr:`__globals__`"
#~ msgstr ":attr:`__globals__`"

#~ msgid "Read-only"
#~ msgstr "읽기 전용"

#~ msgid ":attr:`~object.__dict__`"
#~ msgstr ":attr:`~object.__dict__`"

#~ msgid ":attr:`__closure__`"
#~ msgstr ":attr:`__closure__`"

#~ msgid ""
#~ "``None`` or a tuple of cells that"
#~ " contain bindings for the function's "
#~ "free variables. See below for "
#~ "information on the ``cell_contents`` "
#~ "attribute."
#~ msgstr ""
#~ "``None`` 또는 함수의 자유 변수(free variable)들에"
#~ " 대한 연결을 가진 셀(cell)들의 튜플. "
#~ "``cell_contents`` 어트리뷰트에 대한 정보는 아래를 "
#~ "보십시오."

#~ msgid ":attr:`__annotations__`"
#~ msgstr ":attr:`__annotations__`"

#~ msgid ":attr:`__kwdefaults__`"
#~ msgstr ":attr:`__kwdefaults__`"

#~ msgid ""
#~ "Additional information about a function's "
#~ "definition can be retrieved from its "
#~ "code object; see the description of "
#~ "internal types below. The :data:`cell "
#~ "<types.CellType>` type can be accessed "
#~ "in the :mod:`types` module."
#~ msgstr ""
#~ "함수 정의에 관한 추가적인 정보를 코드 객체로부터 "
#~ "얻을 수 있습니다. 아래에 나오는 내부 형의 기술을"
#~ " 참고하십시오. :data:`셀 <types.CellType>` 형은 "
#~ ":mod:`types` 모듈에서 액세스할 수 있습니다."

#~ msgid ""
#~ "Special read-only attributes: :attr:`__self__`"
#~ " is the class instance object, "
#~ ":attr:`__func__` is the function object; "
#~ ":attr:`__doc__` is the method's documentation"
#~ " (same as ``__func__.__doc__``); "
#~ ":attr:`~definition.__name__` is the method "
#~ "name (same as ``__func__.__name__``); "
#~ ":attr:`__module__` is the name of the"
#~ " module the method was defined in,"
#~ " or ``None`` if unavailable."
#~ msgstr ""
#~ "특수 읽기 전용 어트리뷰트들: :attr:`__self__` 는 "
#~ "클래스 인스턴스 객체, :attr:`__func__` 는 함수 "
#~ "객체; :attr:`__doc__` 은 메서드의 설명 "
#~ "(``__func__.__doc__`` 과 같습니다); "
#~ ":attr:`~definition.__name__` 은 메서드의 이름 "
#~ "(``__func__.__name__`` 과 같습니다); :attr:`__module__`"
#~ " 은 메서드가 정의된 모듈의 이름이거나 없는 경우 "
#~ "``None``."

#~ msgid ""
#~ "Note that the transformation from "
#~ "function object to instance method "
#~ "object happens each time the attribute"
#~ " is retrieved from the instance.  In"
#~ " some cases, a fruitful optimization "
#~ "is to assign the attribute to a"
#~ " local variable and call that local"
#~ " variable. Also notice that this "
#~ "transformation only happens for user-"
#~ "defined functions; other callable objects "
#~ "(and all non-callable objects) are "
#~ "retrieved without transformation.  It is "
#~ "also important to note that user-"
#~ "defined functions which are attributes "
#~ "of a class instance are not "
#~ "converted to bound methods; this *only*"
#~ " happens when the function is an "
#~ "attribute of the class."
#~ msgstr ""
#~ "함수 객체에서 인스턴스 객체로의 변환은 인스턴스로부터 "
#~ "어트리뷰트를 읽을 때마다 일어남에 주의해야 합니다. 어떤"
#~ " 경우에, 어트리뷰트를 지역 변수에 대입하고, 그 지역"
#~ " 변수를 호출하는 것이 효과적인 최적화가 됩니다. 또한,"
#~ " 이 변환이 사용자 정의 함수에 대해서만 발생함에 "
#~ "주의해야 합니다; 다른 콜러블 객체 (그리고 콜러블이 "
#~ "아닌 모든 객체)는 변환 없이 읽힙니다. 클래스 "
#~ "인스턴스의 어트리뷰트인 사용자 정의 함수는 결합한 메서드로"
#~ " 변환되지 않는다는 것도 중요합니다; 이 변환은 함수가"
#~ " 클래스 어트리뷰트일 때만 일어납니다."

#~ msgid ""
#~ "Predefined (writable) attributes: :attr:`__name__`"
#~ " is the module's name; :attr:`__doc__` "
#~ "is the module's documentation string, or"
#~ " ``None`` if unavailable; :attr:`__annotations__`"
#~ " (optional) is a dictionary containing "
#~ ":term:`variable annotations <variable annotation>`"
#~ " collected during module body execution;"
#~ " :attr:`__file__` is the pathname of "
#~ "the file from which the module was"
#~ " loaded, if it was loaded from "
#~ "a file. The :attr:`__file__` attribute "
#~ "may be missing for certain types "
#~ "of modules, such as C modules that"
#~ " are statically linked into the "
#~ "interpreter; for extension modules loaded "
#~ "dynamically from a shared library, it"
#~ " is the pathname of the shared "
#~ "library file."
#~ msgstr ""
#~ "미리 정의된 (쓰기 가능한) 어트리뷰트들: :attr:`__name__`"
#~ " 은 모듈의 이름입니다; :attr:`__doc__` 은 모듈의"
#~ " 설명 문자열 또는 없는 경우 ``None`` 입니다;"
#~ " (없을 수도 있는) :attr:`__annotations__` 는 "
#~ "모듈의 바디를 실행하면서 수집된 :term:`변수 어노테이션 "
#~ "<variable annotation>` 들을 담은 딕셔너리입니다; "
#~ ":attr:`__file__` 은 모듈이 로드된 파일의 경로명입니다."
#~ " 인터프리터에 정적으로 연결된 C 모듈과 같은 어떤"
#~ " 종류의 모듈들에서는 :attr:`__file__` 어트리뷰트가 제공되지"
#~ " 않습니다; 공유 라이브러리(shared library)로부터 동적으로 "
#~ "로딩되는 확장 모듈의 경우 공유 라이브러리의 경로명이 "
#~ "제공됩니다."

#~ msgid ""
#~ "Special read-only attribute: "
#~ ":attr:`~object.__dict__` is the module's "
#~ "namespace as a dictionary object."
#~ msgstr "특수 읽기 전용 어트리뷰트들: :attr:`~object.__dict__` 는 딕셔너리로 표현되는 모듈의 이름 공간입니다."

#~ msgid ""
#~ "Special attributes: :attr:`~definition.__name__` is"
#~ " the class name; :attr:`__module__` is "
#~ "the module name in which the class"
#~ " was defined; :attr:`~object.__dict__` is "
#~ "the dictionary containing the class's "
#~ "namespace; :attr:`~class.__bases__` is a tuple"
#~ " containing the base classes, in the"
#~ " order of their occurrence in the "
#~ "base class list; :attr:`__doc__` is the"
#~ " class's documentation string, or ``None``"
#~ " if undefined; :attr:`__annotations__` (optional)"
#~ " is a dictionary containing :term:`variable"
#~ " annotations <variable annotation>` collected "
#~ "during class body execution."
#~ msgstr ""
#~ "특수 어트리뷰트들::attr:`~definition.__name__` 은 클래스의 "
#~ "이름입니다. :attr:`__module__` 은 클래스가 정의된 모듈의"
#~ " 이름입니다. :attr:`~object.__dict__` 는 클래스의 이름"
#~ " 공간을 저장하는 딕셔너리입니다; :attr:`~class.__bases__` "
#~ "는 부모 클래스들을 저장하는 튜플입니다; 부모 클래스 "
#~ "목록에 나타나는 순서를 유지합니다; :attr:`__doc__` 은"
#~ " 클래스의 설명 문자열 이거나 정의되지 않으면 "
#~ "``None`` 입니다; (없을 수 있는) "
#~ ":attr:`__annotations__` 는 클래스의 바디를 실행하면서 "
#~ "수집된 :term:`변수 어노테이션 <variable annotation>` "
#~ "들을 담은 딕셔너리입니다."

#~ msgid ""
#~ "Special attributes: :attr:`~object.__dict__` is "
#~ "the attribute dictionary; "
#~ ":attr:`~instance.__class__` is the instance's "
#~ "class."
#~ msgstr ""
#~ "특수 어트리뷰트들: :attr:`~object.__dict__` 는 어트리뷰트"
#~ " 딕셔너리입니다; :attr:`~instance.__class__` 는 인스턴스의 "
#~ "클래스입니다."

#~ msgid ""
#~ "Special read-only attributes: :attr:`co_name`"
#~ " gives the function name; "
#~ ":attr:`co_argcount` is the total number "
#~ "of positional arguments (including "
#~ "positional-only arguments and arguments "
#~ "with default values); :attr:`co_posonlyargcount` "
#~ "is the number of positional-only "
#~ "arguments (including arguments with default"
#~ " values); :attr:`co_kwonlyargcount` is the "
#~ "number of keyword-only arguments "
#~ "(including arguments with default values); "
#~ ":attr:`co_nlocals` is the number of "
#~ "local variables used by the function "
#~ "(including arguments); :attr:`co_varnames` is "
#~ "a tuple containing the names of "
#~ "the local variables (starting with the"
#~ " argument names); :attr:`co_cellvars` is a"
#~ " tuple containing the names of local"
#~ " variables that are referenced by "
#~ "nested functions; :attr:`co_freevars` is a "
#~ "tuple containing the names of free "
#~ "variables; :attr:`co_code` is a string "
#~ "representing the sequence of bytecode "
#~ "instructions; :attr:`co_consts` is a tuple "
#~ "containing the literals used by the "
#~ "bytecode; :attr:`co_names` is a tuple "
#~ "containing the names used by the "
#~ "bytecode; :attr:`co_filename` is the filename"
#~ " from which the code was compiled;"
#~ " :attr:`co_firstlineno` is the first line"
#~ " number of the function; :attr:`co_lnotab`"
#~ " is a string encoding the mapping "
#~ "from bytecode offsets to line numbers"
#~ " (for details see the source code "
#~ "of the interpreter); :attr:`co_stacksize` is"
#~ " the required stack size; :attr:`co_flags`"
#~ " is an integer encoding a number "
#~ "of flags for the interpreter."
#~ msgstr ""
#~ "특수 읽기 전용 어트리뷰트들: :attr:`co_name` 은 "
#~ "함수의 이름입니다; :attr:`co_argcount` 는 위치 인자들"
#~ " (위치 전용 인자와 기본값이 있는 인자들도 "
#~ "포함됩니다)의 총 개수입니다; :attr:`co_posonlyargcount` 는"
#~ " 위치 전용 인자들 (기본값이 있는 인자들도 "
#~ "포함됩니다)의 개수입니다; :attr:`co_kwonlyargcount` 는 키워드"
#~ " 전용 인자들 (기본값이 있는 인자들도 포함됩니다)의 "
#~ "개수입니다; :attr:`co_nlocals` 는 함수가 사용하는 지역"
#~ " 변수들 (인자들을 포함합니다)의 개수입니다; "
#~ ":attr:`co_varnames` 는 지역 변수들의 이름을 담고 "
#~ "있는 튜플입니다(인자들의 이름이 먼저 나옵니다); "
#~ ":attr:`co_cellvars` 는 중첩된 함수들이 참조하는 지역"
#~ " 변수들의 이름을 담고 있는 튜플입니다; "
#~ ":attr:`co_freevars` 는 자유 변수(free variables)들의"
#~ " 이름을 담고 있는 튜플입니다; :attr:`co_code` 는"
#~ " 바이트 코드 명령 시퀀스를 나타내는 문자열입니다; "
#~ ":attr:`co_consts` 는 바이트 코드가 사용하는 리터럴을"
#~ " 포함하는 튜플입니다; :attr:`co_names` 는 바이트 "
#~ "코드가 사용하는 이름들을 담고 있는 튜플입니다; "
#~ ":attr:`co_filename` 은 컴파일된 코드를 제공한 파일의"
#~ " 이름입니다; :attr:`co_firstlineno` 는 함수의 첫 "
#~ "번째 줄 번호입니다; :attr:`co_lnotab` 은 바이트 "
#~ "코드에서의 위치를 줄 번호로 매핑하는 법을 문자열로 "
#~ "인코딩한 값입니다 (자세한 내용은 인터프리터의 소스 코드를"
#~ " 참고하십시오); :attr:`co_stacksize` 는 필요한 스택의"
#~ " 크기입니다; :attr:`co_flags` 는 인터프리터의 여러 "
#~ "플래그(flag)들을 정수로 인코딩한 값입니다."

#~ msgid ""
#~ "Special read-only attributes: :attr:`f_back`"
#~ " is to the previous stack frame "
#~ "(towards the caller), or ``None`` if "
#~ "this is the bottom stack frame; "
#~ ":attr:`f_code` is the code object being"
#~ " executed in this frame; :attr:`f_locals`"
#~ " is the dictionary used to look "
#~ "up local variables; :attr:`f_globals` is "
#~ "used for global variables; :attr:`f_builtins`"
#~ " is used for built-in (intrinsic) "
#~ "names; :attr:`f_lasti` gives the precise "
#~ "instruction (this is an index into "
#~ "the bytecode string of the code "
#~ "object)."
#~ msgstr ""
#~ "특수 읽기 전용 어트리뷰트들: :attr:`f_back` 은 "
#~ "이전 스택 프레임 (호출자 방향으로)을 가리키거나, 이게"
#~ " 스택의 바닥이라면 ``None``; :attr:`f_code` 는 "
#~ "이 프레임에서 실행되는 코드 객체; :attr:`f_locals` "
#~ "는 지역 변수를 조회하는데 사용되는 딕셔너리; "
#~ ":attr:`f_globals` 는 전역 변수에 사용됩니다; "
#~ ":attr:`f_builtins` 는 내장된(intrinsic) 이름들에 "
#~ "사용됩니다; :attr:`f_lasti` 는 정확한 바이트 코드 "
#~ "명령(instruction)을 제공합니다 (코드 객체의 바이트 코드"
#~ " 문자열에 대한 인덱스입니다). "

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``object.__getattr__`` with arguments ``obj``, "
#~ "``name``."
#~ msgstr ""
#~ "인자 ``obj``, ``name``\\으로 :ref:`감사 이벤트 "
#~ "<auditing>` ``object.__getattr__``\\을 발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``object.__setattr__`` with arguments ``obj``, "
#~ "``name``, ``value``."
#~ msgstr ""
#~ "인자 ``obj``, ``name``, ``value``\\로 :ref:`감사"
#~ " 이벤트 <auditing>` ``object.__setattr__``\\을 "
#~ "발생시킵니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``object.__delattr__`` with arguments ``obj``, "
#~ "``name``."
#~ msgstr ""
#~ "인자 ``obj``, ``name``\\으로 :ref:`감사 이벤트 "
#~ "<auditing>` ``object.__delattr__``\\을 발생시킵니다."

#~ msgid ""
#~ ":meth:`__set_name__` is only called implicitly"
#~ " as part of the :class:`type` "
#~ "constructor, so it will need to be"
#~ " called explicitly with the appropriate "
#~ "parameters when a descriptor is added"
#~ " to a class after initial creation::"
#~ msgstr ""
#~ ":meth:`__set_name__`\\은 :class:`type` 생성자의 일부로 "
#~ "묵시적으로만 호출되므로, 초기 생성 이후에 디스크립터가 "
#~ "클래스에 추가될 때 적절한 매개 변수로 명시적으로 "
#~ "호출할 필요가 있습니다::"

#~ msgid ""
#~ "If ``a`` is an instance of "
#~ ":class:`super`, then the binding ``super(B,"
#~ " obj).m()`` searches ``obj.__class__.__mro__`` "
#~ "for the base class ``A`` immediately "
#~ "preceding ``B`` and then invokes the "
#~ "descriptor with the call: "
#~ "``A.__dict__['m'].__get__(obj, obj.__class__)``."
#~ msgstr ""
#~ ":class:`super` 의 인스턴스에 결합하면, 결합 "
#~ "``super(B, obj).m()`` 은 ``obj.__class__.__mro__``"
#~ " 를 검색해서 ``B`` 바로 다음에 나오는 베이스"
#~ " 클래스 ``A`` 를 찾은 후에 이렇게 디스크립터를"
#~ " 호출합니다: ``A.__dict__['m'].__get__(obj, "
#~ "obj.__class__)``."

#~ msgid ""
#~ "Any non-string iterable may be "
#~ "assigned to *__slots__*. Mappings may "
#~ "also be used; however, in the "
#~ "future, special meaning may be assigned"
#~ " to the values corresponding to each"
#~ " key."
#~ msgstr ""
#~ "*__slots__* 에는 문자열 이외의 이터러블을 대입할 수"
#~ " 있습니다. 매핑도 역시 사용할 수 있습니다. 하지만,"
#~ " 미래에, 각 키에 대응하는 값들의 의미가 부여될 "
#~ "수 있습니다."

#~ msgid ""
#~ "One can implement the generic class "
#~ "syntax as specified by :pep:`484` (for"
#~ " example ``List[int]``) by defining a "
#~ "special method:"
#~ msgstr ""
#~ "특수 메서드를 정의함으로써 :pep:`484`\\에서 지정된 제네릭"
#~ " 클래스 문법(예를 들면 ``List[int]``)을 구현할 수"
#~ " 있습니다:"

#~ msgid ""
#~ "This method is looked up on the"
#~ " class object itself, and when "
#~ "defined in the class body, this "
#~ "method is implicitly a class method."
#~ "  Note, this mechanism is primarily "
#~ "reserved for use with static type "
#~ "hints, other usage is discouraged."
#~ msgstr ""
#~ "이 메서드는 클래스 개체 자체에서 조회되며, 클래스 "
#~ "바디에 정의된 경우, 이 메서드는 묵시적으로 클래스 "
#~ "메서드입니다. 이 메커니즘은 주로 정적 형 힌트와 "
#~ "함께 사용하기 위해 예약되어 있습니다. 다른 용도는 "
#~ "권장하지 않습니다."

#~ msgid ""
#~ "Iterator objects also need to implement"
#~ " this method; they are required to"
#~ " return themselves.  For more information"
#~ " on iterator objects, see :ref:`typeiter`."
#~ msgstr ""
#~ "이터레이터 객체 역시 이 메서드를 구현할 필요가 "
#~ "있습니다; 자기 자신을 돌려줘야 합니다. 이터레이터 객체에"
#~ " 대한 추가의 정보는 :ref:`typeiter` 에 있습니다."

#~ msgid ""
#~ "Due to a bug in the dispatching"
#~ " mechanism for ``**=``, a class that"
#~ " defines :meth:`__ipow__` but returns "
#~ "``NotImplemented`` would fail to fall "
#~ "back to ``x.__pow__(y)`` and "
#~ "``y.__rpow__(x)``. This bug is fixed in"
#~ " Python 3.10."
#~ msgstr ""
#~ "``**=`` 디스패치 메커니즘의 버그로 인해, "
#~ ":meth:`__ipow__`\\를 정의하지만 ``NotImplemented``\\를 반환하는"
#~ " 클래스는 ``x.__pow__(y)``\\와 ``y.__rpow__(x)``\\로 폴백"
#~ " 되지 않습니다. 이 버그는 파이썬 3.10에서 "
#~ "수정되었습니다."

#~ msgid ""
#~ "If :meth:`__int__` is not defined then"
#~ " the built-in function :func:`int` "
#~ "falls back to :meth:`__trunc__`."
#~ msgstr ""
#~ ":meth:`__int__` 가 정의되어 있지 않으면, 내장 "
#~ "함수 :func:`int` 는 :meth:`__trunc__` 를 "
#~ "사용합니다."

