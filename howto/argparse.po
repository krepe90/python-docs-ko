# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/argparse.rst:5
msgid "Argparse Tutorial"
msgstr "Argparse 자습서"

#: ../../howto/argparse.rst
msgid "author"
msgstr "저자"

#: ../../howto/argparse.rst:7
msgid "Tshepang Mbambo"
msgstr ""

#: ../../howto/argparse.rst:11
msgid ""
"This tutorial is intended to be a gentle introduction to :mod:`argparse`,"
" the recommended command-line parsing module in the Python standard "
"library."
msgstr "이 자습서는 파이썬 표준 라이브러리에서 권장하는 명령행 파싱 모듈인 :mod:`argparse` 에 대한 소개입니다."

#: ../../howto/argparse.rst:16
msgid ""
"The standard library includes two other libraries directly related to "
"command-line parameter processing: the lower level :mod:`optparse` module"
" (which may require more code to configure for a given application, but "
"also allows an application to request behaviors that ``argparse`` doesn't"
" support), and the very low level :mod:`getopt` (which specifically "
"serves as an equivalent to the :c:func:`!getopt` family of functions "
"available to C programmers). While neither of those modules is covered "
"directly in this guide, many of the core concepts in ``argparse`` first "
"originated in ``optparse``, so some aspects of this tutorial will also be"
" relevant to ``optparse`` users."
msgstr ""

#: ../../howto/argparse.rst:29
msgid "Concepts"
msgstr "개념"

#: ../../howto/argparse.rst:31
msgid ""
"Let's show the sort of functionality that we are going to explore in this"
" introductory tutorial by making use of the :command:`ls` command:"
msgstr ":command:`ls` 명령을 사용하여 이 입문서에서 다룰 기능들을 살펴봅시다:"

#: ../../howto/argparse.rst:34
msgid ""
"$ ls\n"
"cpython  devguide  prog.py  pypy  rm-unused-function.patch\n"
"$ ls pypy\n"
"ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...\n"
"$ ls -l\n"
"total 20\n"
"drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython\n"
"drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide\n"
"-rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py\n"
"drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy\n"
"-rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch\n"
"$ ls --help\n"
"Usage: ls [OPTION]... [FILE]...\n"
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified."
"\n"
"..."
msgstr ""

#: ../../howto/argparse.rst:53
msgid "A few concepts we can learn from the four commands:"
msgstr "네 가지 명령에서 배울 수 있는 몇 가지 개념들입니다:"

#: ../../howto/argparse.rst:55
msgid ""
"The :command:`ls` command is useful when run without any options at all. "
"It defaults to displaying the contents of the current directory."
msgstr ":command:`ls` 명령은 옵션 없이 실행될 때도 유용합니다. 기본적으로 현재 디렉터리의 내용을 표시합니다."

#: ../../howto/argparse.rst:58
msgid ""
"If we want beyond what it provides by default, we tell it a bit more. In "
"this case, we want it to display a different directory, ``pypy``. What we"
" did is specify what is known as a positional argument. It's named so "
"because the program should know what to do with the value, solely based "
"on where it appears on the command line. This concept is more relevant to"
" a command like :command:`cp`, whose most basic usage is ``cp SRC DEST``."
" The first position is *what you want copied,* and the second position is"
" *where you want it copied to*."
msgstr ""
"기본적으로 제공하는 것 이상으로 원한다면, 조금 더 말합니다. 이 경우에는 다른 디렉터리인 ``pypy`` 를 표시하기를 원합니다."
" 우리가 한 것은 위치 인자라고 알려진 것을 지정하는 것입니다. 프로그램이 명령행에 표시되는 위치를 기준으로 값을 어떻게 처리해야 "
"하는지를 알아야 하므로 이런 이름이 사용됩니다. 이 개념은 :command:`cp` 와 같은 명령에 더 적절합니다. 가장 기본적인 "
"사용법은 ``cp SRC DEST`` 입니다. 첫 번째 위치는 *복사하고자 하는 것* 이고 두 번째 위치는 *사본을 저장할 곳* "
"입니다."

#: ../../howto/argparse.rst:67
msgid ""
"Now, say we want to change behaviour of the program. In our example, we "
"display more info for each file instead of just showing the file names. "
"The ``-l`` in that case is known as an optional argument."
msgstr ""
"자, 프로그램의 행동을 바꾸고 싶다고 합시다. 이 예에서는 파일 이름만 표시하는 대신 각 파일에 대한 정보를 더 많이 표시합니다. "
"이 경우 ``-l`` 은 옵션 인자로 알려져 있습니다."

#: ../../howto/argparse.rst:71
msgid ""
"That's a snippet of the help text. It's very useful in that you can come "
"across a program you have never used before, and can figure out how it "
"works simply by reading its help text."
msgstr ""
"이것이 도움말 텍스트입니다. 이전에 사용해보지 않은 프로그램을 접했을 때 도움말 텍스트를 읽는 것만으로 작동하는 방식을 이해할 수 "
"있다는 점에서 매우 유용합니다."

#: ../../howto/argparse.rst:77
msgid "The basics"
msgstr "기본"

#: ../../howto/argparse.rst:79
msgid "Let us start with a very simple example which does (almost) nothing::"
msgstr "(거의) 아무것도 하지 않는 아주 간단한 예제로 시작합시다::"

#: ../../howto/argparse.rst:81
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.parse_args()"
msgstr ""

#: ../../howto/argparse.rst:85 ../../howto/argparse.rst:193
#: ../../howto/argparse.rst:214
msgid "Following is a result of running the code:"
msgstr "다음은 코드를 실행한 결과입니다:"

#: ../../howto/argparse.rst:87
msgid ""
"$ python prog.py\n"
"$ python prog.py --help\n"
"usage: prog.py [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"$ python prog.py --verbose\n"
"usage: prog.py [-h]\n"
"prog.py: error: unrecognized arguments: --verbose\n"
"$ python prog.py foo\n"
"usage: prog.py [-h]\n"
"prog.py: error: unrecognized arguments: foo"
msgstr ""

#: ../../howto/argparse.rst:102 ../../howto/argparse.rst:259
#: ../../howto/argparse.rst:303
msgid "Here is what is happening:"
msgstr "일어난 일은 이렇습니다:"

#: ../../howto/argparse.rst:104
msgid ""
"Running the script without any options results in nothing displayed to "
"stdout. Not so useful."
msgstr "옵션 없이 스크립트를 실행하면 아무것도 표준 출력에 표시되지 않습니다. 별로 유용하지 않습니다."

#: ../../howto/argparse.rst:107
msgid ""
"The second one starts to display the usefulness of the :mod:`argparse` "
"module. We have done almost nothing, but already we get a nice help "
"message."
msgstr "두 번째는 :mod:`argparse` 모듈의 쓸모를 보여주기 시작합니다. 거의 아무것도 하지 않았지만 이미 도움말을 얻었습니다."

#: ../../howto/argparse.rst:110
msgid ""
"The ``--help`` option, which can also be shortened to ``-h``, is the only"
" option we get for free (i.e. no need to specify it). Specifying anything"
" else results in an error. But even then, we do get a useful usage "
"message, also for free."
msgstr ""
"``--help`` 옵션은, ``-h`` 로 단축할 수도 있습니다, 무료로 얻을 수 있는 유일한 옵션입니다 (즉, 지정할 필요가 "
"없습니다). 다른 값을 지정하면 오류가 발생합니다. 그러나 그때조차도 우리는 사용 안내를 얻습니다, 여전히 공짜입니다."

#: ../../howto/argparse.rst:117
msgid "Introducing Positional arguments"
msgstr "위치 인자 소개"

#: ../../howto/argparse.rst:119
msgid "An example::"
msgstr "예::"

#: ../../howto/argparse.rst:121
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"
msgstr ""

#: ../../howto/argparse.rst:127
msgid "And running the code:"
msgstr "코드를 실행합니다:"

#: ../../howto/argparse.rst:129
msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] echo\n"
"prog.py: error: the following arguments are required: echo\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] echo\n"
"\n"
"positional arguments:\n"
"  echo\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"$ python prog.py foo\n"
"foo"
msgstr ""

#: ../../howto/argparse.rst:145
msgid "Here is what's happening:"
msgstr "이런 일이 일어났습니다:"

#: ../../howto/argparse.rst:147
#, fuzzy
msgid ""
"We've added the :meth:`~ArgumentParser.add_argument` method, which is "
"what we use to specify which command-line options the program is willing "
"to accept. In this case, I've named it ``echo`` so that it's in line with"
" its function."
msgstr ""
":meth:`add_argument` 메서드를 추가했습니다. 이 메서드는 프로그램이 받고 싶은 명령행 옵션을 지정하기 위해 "
"사용합니다. 이 경우 기능과 일치하도록 ``echo`` 라고 이름 붙였습니다."

#: ../../howto/argparse.rst:151
msgid "Calling our program now requires us to specify an option."
msgstr "이제 프로그램을 호출하려면 옵션을 지정해야 합니다."

#: ../../howto/argparse.rst:153
#, fuzzy
msgid ""
"The :meth:`~ArgumentParser.parse_args` method actually returns some data "
"from the options specified, in this case, ``echo``."
msgstr ":meth:`parse_args` 메서드는 실제로 지정된 옵션으로부터 온 데이터를 돌려줍니다. 이 경우에는 ``echo`` 입니다."

#: ../../howto/argparse.rst:156
msgid ""
"The variable is some form of 'magic' that :mod:`argparse` performs for "
"free (i.e. no need to specify which variable that value is stored in). "
"You will also notice that its name matches the string argument given to "
"the method, ``echo``."
msgstr ""
"변수는 :mod:`argparse` 이 공짜로 수행하는 일종의 '마법' 입니다 (즉, 값이 저장되는 변수를 지정할 필요가 "
"없습니다). 또한, 그 이름이 메서드에 주어진 문자열 인자 ``echo`` 와 일치함을 알 수 있습니다."

#: ../../howto/argparse.rst:161
msgid ""
"Note however that, although the help display looks nice and all, it "
"currently is not as helpful as it can be. For example we see that we got "
"``echo`` as a positional argument, but we don't know what it does, other "
"than by guessing or by reading the source code. So, let's make it a bit "
"more useful::"
msgstr ""
"그러나 도움말이 멋지게 보이지만, 현재로서는 가능한 최선이 아닙니다. 예를 들어 ``echo`` 가 위치 인자임을 볼 수 있지만, "
"추측하거나 소스 코드를 읽는 것 외에는 그것이 무엇을 하는지 모릅니다. 그럼 좀 더 유용하게 만들어 봅시다::"

#: ../../howto/argparse.rst:166
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\", help=\"echo the string you use here\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"
msgstr ""

#: ../../howto/argparse.rst:172
msgid "And we get:"
msgstr "그러면 이렇게 됩니다:"

#: ../../howto/argparse.rst:174
msgid ""
"$ python prog.py -h\n"
"usage: prog.py [-h] echo\n"
"\n"
"positional arguments:\n"
"  echo        echo the string you use here\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""

#: ../../howto/argparse.rst:185
msgid "Now, how about doing something even more useful::"
msgstr "이제, 뭔가 더 쓸모있는 일을 하는 것은 어떻습니까::"

#: ../../howto/argparse.rst:187
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\")\n"
"args = parser.parse_args()\n"
"print(args.square**2)"
msgstr ""

#: ../../howto/argparse.rst:195
msgid ""
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 5, in <module>\n"
"    print(args.square**2)\n"
"TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'"
msgstr ""

#: ../../howto/argparse.rst:203
msgid ""
"That didn't go so well. That's because :mod:`argparse` treats the options"
" we give it as strings, unless we tell it otherwise. So, let's tell "
":mod:`argparse` to treat that input as an integer::"
msgstr ""
"잘 안됐습니다. 우리가 달리 지시하지 않는다면, :mod:`argparse` 는 우리가 준 옵션들을 문자열로 취급하기 때문입니다. "
"그럼, :mod:`argparse` 에게 그 입력을 정수로 취급하라고 알려줍시다::"

#: ../../howto/argparse.rst:207
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\",\n"
"                    type=int)\n"
"args = parser.parse_args()\n"
"print(args.square**2)"
msgstr ""

#: ../../howto/argparse.rst:216
msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py four\n"
"usage: prog.py [-h] square\n"
"prog.py: error: argument square: invalid int value: 'four'"
msgstr ""

#: ../../howto/argparse.rst:224
msgid ""
"That went well. The program now even helpfully quits on bad illegal input"
" before proceeding."
msgstr "잘 됩니다. 이제 이 프로그램은 잘못된 입력이 올 때 더 진행하지 않고 종료하기조차 합니다."

#: ../../howto/argparse.rst:229
msgid "Introducing Optional arguments"
msgstr "옵션 인자 소개"

#: ../../howto/argparse.rst:231
msgid ""
"So far we have been playing with positional arguments. Let us have a look"
" on how to add optional ones::"
msgstr "지금까지 우리는 위치 인자를 다뤘습니다. 옵션 인자를 추가하는 방법에 대해 살펴봅시다::"

#: ../../howto/argparse.rst:234
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbosity\", help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"if args.verbosity:\n"
"    print(\"verbosity turned on\")"
msgstr ""

#: ../../howto/argparse.rst:241 ../../howto/argparse.rst:287
#: ../../howto/argparse.rst:403 ../../howto/argparse.rst:437
msgid "And the output:"
msgstr "출력은 이렇습니다:"

#: ../../howto/argparse.rst:243
msgid ""
"$ python prog.py --verbosity 1\n"
"verbosity turned on\n"
"$ python prog.py\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [--verbosity VERBOSITY]\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  --verbosity VERBOSITY\n"
"                        increase output verbosity\n"
"$ python prog.py --verbosity\n"
"usage: prog.py [-h] [--verbosity VERBOSITY]\n"
"prog.py: error: argument --verbosity: expected one argument"
msgstr ""

#: ../../howto/argparse.rst:261
msgid ""
"The program is written so as to display something when ``--verbosity`` is"
" specified and display nothing when not."
msgstr ""
"이 프로그램은 ``--verbosity`` 가 지정되었을 때 어떤 것을 표시하고 그렇지 않을 때는 아무것도 표시하지 않도록 "
"작성되었습니다."

#: ../../howto/argparse.rst:264
#, fuzzy
msgid ""
"To show that the option is actually optional, there is no error when "
"running the program without it. Note that by default, if an optional "
"argument isn't used, the relevant variable, in this case "
"``args.verbosity``, is given ``None`` as a value, which is the reason it "
"fails the truth test of the :keyword:`if` statement."
msgstr ""
"옵션이 실제로 선택 사항임을 확인하기 위해, 이 옵션을 사용하지 않고 프로그램을 실행할 때 오류가 없습니다. 기본적으로 옵션 인자가"
" 사용되지 않는다면 관련 변수 (이 경우 :attr:`args.verbosity`)는 값으로 ``None`` 이 주어집니다. 이 "
"때문에 :keyword:`if` 문의 논리값 검사가 실패합니다."

#: ../../howto/argparse.rst:270
msgid "The help message is a bit different."
msgstr "도움말 메시지가 약간 달라졌습니다."

#: ../../howto/argparse.rst:272
msgid ""
"When using the ``--verbosity`` option, one must also specify some value, "
"any value."
msgstr "``--verbosity`` 옵션을 사용할 때, 어떤 값을 지정해야 합니다. 어떤 값이건 상관없습니다."

#: ../../howto/argparse.rst:275
msgid ""
"The above example accepts arbitrary integer values for ``--verbosity``, "
"but for our simple program, only two values are actually useful, ``True``"
" or ``False``. Let's modify the code accordingly::"
msgstr ""
"위의 예제는 ``--verbosity`` 에 임의의 정숫값을 허용하지만, 우리의 간단한 프로그램에서는 실제로 ``True`` 또는 "
"``False`` 두 값만 쓸모 있습니다. 그것에 맞게 코드를 수정합시다::"

#: ../../howto/argparse.rst:279
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbose\", help=\"increase output verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"
msgstr ""

#: ../../howto/argparse.rst:289
msgid ""
"$ python prog.py --verbose\n"
"verbosity turned on\n"
"$ python prog.py --verbose 1\n"
"usage: prog.py [-h] [--verbose]\n"
"prog.py: error: unrecognized arguments: 1\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [--verbose]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --verbose   increase output verbosity"
msgstr ""

#: ../../howto/argparse.rst:305
#, fuzzy
msgid ""
"The option is now more of a flag than something that requires a value. We"
" even changed the name of the option to match that idea. Note that we now"
" specify a new keyword, ``action``, and give it the value "
"``\"store_true\"``. This means that, if the option is specified, assign "
"the value ``True`` to ``args.verbose``. Not specifying it implies "
"``False``."
msgstr ""
"이 옵션은 이제 값을 요구하는 것이 아니라 플래그입니다. 이 개념과 일치하도록 옵션의 이름을 변경하기까지 했습니다. 새로운 키워드 "
"``action`` 을 지정하고, ``\"store_true\"`` 값을 지정했습니다. 이것은, 옵션이 지정되면 "
":data:`args.verbose` 에 값 ``True`` 를 대입하라는 뜻입니다. 지정하지 않으면 묵시적으로 ``False`` "
"입니다."

#: ../../howto/argparse.rst:312
msgid ""
"It complains when you specify a value, in true spirit of what flags "
"actually are."
msgstr "값을 지정하면 불평하는데, 플래그의 정의를 따르고 있습니다."

#: ../../howto/argparse.rst:315
msgid "Notice the different help text."
msgstr "도움말 텍스트가 바뀐 것을 확인하십시오."

#: ../../howto/argparse.rst:319
msgid "Short options"
msgstr "짧은 옵션"

#: ../../howto/argparse.rst:321
msgid ""
"If you are familiar with command line usage, you will notice that I "
"haven't yet touched on the topic of short versions of the options. It's "
"quite simple::"
msgstr "명령행 사용법에 익숙하다면 짧은 옵션 버전에 관한 내용을 아직 다루지 않았음을 알 수 있을 겁니다. 아주 간단합니다::"

#: ../../howto/argparse.rst:325
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"-v\", \"--verbose\", help=\"increase output "
"verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"
msgstr ""

#: ../../howto/argparse.rst:333
msgid "And here goes:"
msgstr "그러면 이렇게 됩니다:"

#: ../../howto/argparse.rst:335
msgid ""
"$ python prog.py -v\n"
"verbosity turned on\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [-v]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  -v, --verbose  increase output verbosity"
msgstr ""

#: ../../howto/argparse.rst:346
msgid "Note that the new ability is also reflected in the help text."
msgstr "새로운 기능은 도움말 텍스트에도 반영됩니다."

#: ../../howto/argparse.rst:350
msgid "Combining Positional and Optional arguments"
msgstr "위치 및 옵션 인자 결합하기"

#: ../../howto/argparse.rst:352
msgid "Our program keeps growing in complexity::"
msgstr "프로그램이 점점 복잡해지고 있습니다::"

#: ../../howto/argparse.rst:354
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbose:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:367
msgid "And now the output:"
msgstr "이제 출력은 이렇게 됩니다:"

#: ../../howto/argparse.rst:369
msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] [-v] square\n"
"prog.py: error: the following arguments are required: square\n"
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 --verbose\n"
"the square of 4 equals 16\n"
"$ python prog.py --verbose 4\n"
"the square of 4 equals 16"
msgstr ""

#: ../../howto/argparse.rst:381
msgid "We've brought back a positional argument, hence the complaint."
msgstr "위치 인자를 다시 도입했기 때문에, 불평합니다."

#: ../../howto/argparse.rst:383
msgid "Note that the order does not matter."
msgstr "순서는 중요하지 않습니다."

#: ../../howto/argparse.rst:385
msgid ""
"How about we give this program of ours back the ability to have multiple "
"verbosity values, and actually get to use them::"
msgstr "이 프로그램에 여러 상세도를 지정할 수 있도록 하는 능력을 다시 부여하고, 실제로 그것을 사용하는 것은 어떨까요::"

#: ../../howto/argparse.rst:388
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:405
msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"usage: prog.py [-h] [-v VERBOSITY] square\n"
"prog.py: error: argument -v/--verbosity: expected one argument\n"
"$ python prog.py 4 -v 1\n"
"4^2 == 16\n"
"$ python prog.py 4 -v 2\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -v 3\n"
"16"
msgstr ""

#: ../../howto/argparse.rst:419
msgid ""
"These all look good except the last one, which exposes a bug in our "
"program. Let's fix it by restricting the values the ``--verbosity`` "
"option can accept::"
msgstr ""
"우리 프로그램의 버그를 드러내는 마지막 것을 제외하고는 그럴듯해 보입니다. ``--verbosity`` 옵션이 받아들일 수 있는 "
"값을 제한해서 고쳐봅시다::"

#: ../../howto/argparse.rst:422
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2],"
"\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:439
#, python-brace-format
msgid ""
"$ python prog.py 4 -v 3\n"
"usage: prog.py [-h] [-v {0,1,2}] square\n"
"prog.py: error: argument -v/--verbosity: invalid choice: 3 (choose from "
"0, 1, 2)\n"
"$ python prog.py 4 -h\n"
"usage: prog.py [-h] [-v {0,1,2}] square\n"
"\n"
"positional arguments:\n"
"  square                display a square of a given number\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbosity {0,1,2}\n"
"                        increase output verbosity"
msgstr ""

#: ../../howto/argparse.rst:455
msgid ""
"Note that the change also reflects both in the error message as well as "
"the help string."
msgstr "변경 내용은 오류 메시지와 도움말 문자열에도 반영됩니다."

#: ../../howto/argparse.rst:458
msgid ""
"Now, let's use a different approach of playing with verbosity, which is "
"pretty common. It also matches the way the CPython executable handles its"
" own verbosity argument (check the output of ``python --help``)::"
msgstr ""
"이제 상세도를 다루는 다른 접근법을 사용해 봅시다, 이 방법은 꽤 널리 사용됩니다. 또한, 이 방법은 CPython 실행 파일이 "
"자신의 상세도를 처리하는 방식과도 일치합니다 (``python --help`` 의 결과를 확인하십시오)::"

#: ../../howto/argparse.rst:462
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display the square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:477
#, fuzzy
msgid ""
"We have introduced another action, \"count\", to count the number of "
"occurrences of specific options."
msgstr "특정 옵션 인자를 지정한 횟수를 계산하기 위해 \"count\" 라는 또 다른 액션을 도입했습니다:"

#: ../../howto/argparse.rst:481
msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 -vv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 --verbosity --verbosity\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -v 1\n"
"usage: prog.py [-h] [-v] square\n"
"prog.py: error: unrecognized arguments: 1\n"
"$ python prog.py 4 -h\n"
"usage: prog.py [-h] [-v] square\n"
"\n"
"positional arguments:\n"
"  square           display a square of a given number\n"
"\n"
"options:\n"
"  -h, --help       show this help message and exit\n"
"  -v, --verbosity  increase output verbosity\n"
"$ python prog.py 4 -vvv\n"
"16"
msgstr ""

#: ../../howto/argparse.rst:506
msgid ""
"Yes, it's now more of a flag (similar to ``action=\"store_true\"``) in "
"the previous version of our script. That should explain the complaint."
msgstr ""
"예, 이제 이전 버전의 스크립트처럼 (``action=\"store_true\"`` 와 유사하게) 플래그가 되었습니다. 출력되는 "
"불평이 설명됩니다."

#: ../../howto/argparse.rst:509
msgid "It also behaves similar to \"store_true\" action."
msgstr "또한 \"store_true\" 액션과 비슷하게 작동하기도 합니다."

#: ../../howto/argparse.rst:511
msgid ""
"Now here's a demonstration of what the \"count\" action gives. You've "
"probably seen this sort of usage before."
msgstr "이제 여기에서 \"count\" 액션이 제공하는 것을 보여줍니다. 이런 종류의 사용법을 전에도 보았을 것입니다."

#: ../../howto/argparse.rst:514
msgid ""
"And if you don't specify the ``-v`` flag, that flag is considered to have"
" ``None`` value."
msgstr "그리고, ``-v`` 플래그를 지정하지 않으면 그 플래그는 ``None`` 값으로 간주합니다."

#: ../../howto/argparse.rst:517
msgid ""
"As should be expected, specifying the long form of the flag, we should "
"get the same output."
msgstr "예측하듯이, 플래그의 긴 형식을 지정하면, 같은 출력이 얻어져야 합니다."

#: ../../howto/argparse.rst:520
msgid ""
"Sadly, our help output isn't very informative on the new ability our "
"script has acquired, but that can always be fixed by improving the "
"documentation for our script (e.g. via the ``help`` keyword argument)."
msgstr ""
"안타깝게도 스크립트가 얻은 새로운 기능에 대한 도움말 출력은 그다지 유익하지 않지만, 스크립트의 문서를 개선하면 항상 해결할 수 "
"있습니다 (예, ``help`` 키워드 인자를 사용해서)."

#: ../../howto/argparse.rst:524
msgid "That last output exposes a bug in our program."
msgstr "마지막 출력은 우리 프로그램의 버그를 노출합니다."

#: ../../howto/argparse.rst:527
msgid "Let's fix::"
msgstr "고칩시다::"

#: ../../howto/argparse.rst:529
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"\n"
"# bugfix: replace == with >=\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:546
msgid "And this is what it gives:"
msgstr "그러면 이렇게 됩니다:"

#: ../../howto/argparse.rst:548
msgid ""
"$ python prog.py 4 -vvv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -vvvv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 11, in <module>\n"
"    if args.verbosity >= 2:\n"
"TypeError: '>=' not supported between instances of 'NoneType' and 'int'"
msgstr ""

#: ../../howto/argparse.rst:561
msgid ""
"First output went well, and fixes the bug we had before. That is, we want"
" any value >= 2 to be as verbose as possible."
msgstr ""
"첫 번째 출력은 잘 동작하고, 앞에서 나온 버그를 고칩니다. 즉, 2보다 크거나 같은 (>=) 모든 값을 최대의 상세도로 취급하고 "
"싶습니다."

#: ../../howto/argparse.rst:564
msgid "Third output not so good."
msgstr "세 번째 결과가 좋지 않습니다."

#: ../../howto/argparse.rst:566
msgid "Let's fix that bug::"
msgstr "이 버그를 고쳐 봅시다::"

#: ../../howto/argparse.rst:568
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0,"
"\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:583
msgid ""
"We've just introduced yet another keyword, ``default``. We've set it to "
"``0`` in order to make it comparable to the other int values. Remember "
"that by default, if an optional argument isn't specified, it gets the "
"``None`` value, and that cannot be compared to an int value (hence the "
":exc:`TypeError` exception)."
msgstr ""
"또 다른 키워드 ``default`` 를 소개했습니다. 다른 int 값과 비교하기 위해 ``0`` 으로 설정했습니다. 기본적으로, "
"옵션 인자가 지정되지 않으면 ``None`` 값을 갖게 되고, 그것은 int 값과 비교될 수 없음을 (그래서 "
":exc:`TypeError` 예외를 일으킵니다) 기억하십시오."

#: ../../howto/argparse.rst:590
msgid "And:"
msgstr "그리고:"

#: ../../howto/argparse.rst:592
msgid ""
"$ python prog.py 4\n"
"16"
msgstr ""

#: ../../howto/argparse.rst:597
msgid ""
"You can go quite far just with what we've learned so far, and we have "
"only scratched the surface. The :mod:`argparse` module is very powerful, "
"and we'll explore a bit more of it before we end this tutorial."
msgstr ""
"여러분은 지금까지 배운 것만으로도 아주 멀리 갈 수 있으며, 우리는 단지 표면을 긁었을 뿐입니다. :mod:`argparse` "
"모듈은 매우 강력합니다. 이 자습서를 끝내기 전에 좀 더 탐색해 보겠습니다."

#: ../../howto/argparse.rst:604
msgid "Getting a little more advanced"
msgstr "조금 더 발전시키기"

#: ../../howto/argparse.rst:606
msgid ""
"What if we wanted to expand our tiny program to perform other powers, not"
" just squares::"
msgstr "우리의 작은 프로그램을 확장하여 제곱만이 아닌 다른 거듭제곱을 수행하기를 원하면 어떻게 될까요::"

#: ../../howto/argparse.rst:609
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)"
"\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""

#: ../../howto/argparse.rst:623 ../../howto/argparse.rst:661
#: ../../howto/argparse.rst:877
msgid "Output:"
msgstr "출력:"

#: ../../howto/argparse.rst:625
msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] [-v] x y\n"
"prog.py: error: the following arguments are required: x, y\n"
"$ python prog.py -h\n"
"usage: prog.py [-h] [-v] x y\n"
"\n"
"positional arguments:\n"
"  x                the base\n"
"  y                the exponent\n"
"\n"
"options:\n"
"  -h, --help       show this help message and exit\n"
"  -v, --verbosity\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16"
msgstr ""

#: ../../howto/argparse.rst:644
msgid ""
"Notice that so far we've been using verbosity level to *change* the text "
"that gets displayed. The following example instead uses verbosity level "
"to display *more* text instead::"
msgstr ""
"지금까지는 표시되는 텍스트를 *변경* 하기 위해 상세도를 사용했습니다. 다음 예제는 대신 *더 많은* 텍스트를 표시하기 위해 "
"상세도를 사용합니다::"

#: ../../howto/argparse.rst:648
#, python-brace-format
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)"
"\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"Running '{__file__}'\")\n"
"if args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == \", end=\"\")\n"
"print(answer)"
msgstr ""

#: ../../howto/argparse.rst:663
msgid ""
"$ python prog.py 4 2\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -vv\n"
"Running 'prog.py'\n"
"4^2 == 16"
msgstr ""

#: ../../howto/argparse.rst:677
msgid "Specifying ambiguous arguments"
msgstr ""

#: ../../howto/argparse.rst:679
msgid ""
"When there is ambiguity in deciding whether an argument is positional or "
"for an argument, ``--`` can be used to tell "
":meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""

#: ../../howto/argparse.rst:683
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-n', nargs='+')\n"
">>> parser.add_argument('args', nargs='*')\n"
"\n"
">>> # ambiguous, so parse_args assumes it's an option\n"
">>> parser.parse_args(['-f'])\n"
"usage: PROG [-h] [-n N [N ...]] [args ...]\n"
"PROG: error: unrecognized arguments: -f\n"
"\n"
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(args=['-f'], n=None)\n"
"\n"
">>> # ambiguous, so the -n option greedily accepts arguments\n"
">>> parser.parse_args(['-n', '1', '2', '3'])\n"
"Namespace(args=[], n=['1', '2', '3'])\n"
"\n"
">>> parser.parse_args(['-n', '1', '--', '2', '3'])\n"
"Namespace(args=['2', '3'], n=['1'])"
msgstr ""

#: ../../howto/argparse.rst:704
msgid "Conflicting options"
msgstr "충돌하는 옵션들"

#: ../../howto/argparse.rst:706
#, fuzzy
msgid ""
"So far, we have been working with two methods of an "
":class:`argparse.ArgumentParser` instance. Let's introduce a third one, "
":meth:`~ArgumentParser.add_mutually_exclusive_group`. It allows for us to"
" specify options that conflict with each other. Let's also change the "
"rest of the program so that the new functionality makes more sense: we'll"
" introduce the ``--quiet`` option, which will be the opposite of the "
"``--verbose`` one::"
msgstr ""
"지금까지 우리는 :class:`argparse.ArgumentParser` 인스턴스의 두 가지 메서드로 작업 해왔습니다. 세 번째를"
" 소개합시다, :meth:`add_mutually_exclusive_group`. 이것은 서로 배타적인 옵션을 지정할 수 있도록 "
"합니다. 새로운 기능을 더 잘 이해할 수 있도록 프로그램의 나머지 부분을 변경해 보겠습니다: ``--quiet`` 옵션을 도입하는데"
" ``--verbose`` 의 반대입니다::"

#: ../../howto/argparse.rst:714
#, python-brace-format
msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"
msgstr ""

#: ../../howto/argparse.rst:732
msgid ""
"Our program is now simpler, and we've lost some functionality for the "
"sake of demonstration. Anyways, here's the output:"
msgstr "프로그램은 이제 더 간단 해졌으며, 데모를 위해 일부 기능을 잃어버렸습니다. 어쨌든, 출력은 이렇습니다:"

#: ../../howto/argparse.rst:735
msgid ""
"$ python prog.py 4 2\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -q\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4 to the power 2 equals 16\n"
"$ python prog.py 4 2 -vq\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"prog.py: error: argument -q/--quiet: not allowed with argument "
"-v/--verbose\n"
"$ python prog.py 4 2 -v --quiet\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"prog.py: error: argument -q/--quiet: not allowed with argument "
"-v/--verbose"
msgstr ""

#: ../../howto/argparse.rst:750
msgid ""
"That should be easy to follow. I've added that last output so you can see"
" the sort of flexibility you get, i.e. mixing long form options with "
"short form ones."
msgstr ""
"따라가기 쉽습니다. 여러분이 얻는 유연성을 볼 수 있도록 마지막 출력을 추가했습니다. 즉, 긴 형식 옵션을 짧은 형식 옵션과 섞어 "
"쓸 수 있습니다."

#: ../../howto/argparse.rst:754
msgid ""
"Before we conclude, you probably want to tell your users the main purpose"
" of your program, just in case they don't know::"
msgstr "결론을 내리기 전에, 여러분은 아마도 사용자들이 모를 경우를 대비해서 프로그램의 주요 목적을 알려주기를 원할 것입니다::"

#: ../../howto/argparse.rst:757
#, python-brace-format
msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description=\"calculate X to the power "
"of Y\")\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"
msgstr ""

#: ../../howto/argparse.rst:775
msgid ""
"Note that slight difference in the usage text. Note the ``[-v | -q]``, "
"which tells us that we can either use ``-v`` or ``-q``, but not both at "
"the same time:"
msgstr ""
"사용법 텍스트의 약간의 차이점에 유의하십시오. ``[-v | -q]`` 에 주목해야 하는데, ``-v`` 나 ``-q`` 를 사용할"
" 수 있지만 동시에 둘 다를 사용할 수는 없다는 뜻입니다:"

#: ../../howto/argparse.rst:779 ../../howto/argparse.rst:806
msgid ""
"$ python prog.py --help\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"\n"
"calculate X to the power of Y\n"
"\n"
"positional arguments:\n"
"  x              the base\n"
"  y              the exponent\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  -v, --verbose\n"
"  -q, --quiet"
msgstr ""

#: ../../howto/argparse.rst:797
msgid "How to translate the argparse output"
msgstr ""

#: ../../howto/argparse.rst:799
msgid ""
"The output of the :mod:`argparse` module such as its help text and error "
"messages are all made translatable using the :mod:`gettext` module. This "
"allows applications to easily localize messages produced by "
":mod:`argparse`. See also :ref:`i18n-howto`."
msgstr ""

#: ../../howto/argparse.rst:804
msgid "For instance, in this :mod:`argparse` output:"
msgstr ""

#: ../../howto/argparse.rst:822
msgid ""
"The strings ``usage:``, ``positional arguments:``, ``options:`` and "
"``show this help message and exit`` are all translatable."
msgstr ""

#: ../../howto/argparse.rst:825
msgid ""
"In order to translate these strings, they must first be extracted into a "
"``.po`` file. For example, using `Babel <https://babel.pocoo.org/>`__, "
"run this command:"
msgstr ""

#: ../../howto/argparse.rst:829
msgid "$ pybabel extract -o messages.po /usr/lib/python3.12/argparse.py"
msgstr ""

#: ../../howto/argparse.rst:833
msgid ""
"This command will extract all translatable strings from the "
":mod:`argparse` module and output them into a file named ``messages.po``."
" This command assumes that your Python installation is in ``/usr/lib``."
msgstr ""

#: ../../howto/argparse.rst:837
msgid ""
"You can find out the location of the :mod:`argparse` module on your "
"system using this script::"
msgstr ""

#: ../../howto/argparse.rst:840
msgid ""
"import argparse\n"
"print(argparse.__file__)"
msgstr ""

#: ../../howto/argparse.rst:843
msgid ""
"Once the messages in the ``.po`` file are translated and the translations"
" are installed using :mod:`gettext`, :mod:`argparse` will be able to "
"display the translated messages."
msgstr ""

#: ../../howto/argparse.rst:847
msgid ""
"To translate your own strings in the :mod:`argparse` output, use "
":mod:`gettext`."
msgstr ""

#: ../../howto/argparse.rst:850
msgid "Custom type converters"
msgstr ""

#: ../../howto/argparse.rst:852
msgid ""
"The :mod:`argparse` module allows you to specify custom type converters "
"for your command-line arguments. This allows you to modify user input "
"before it's stored in the :class:`argparse.Namespace`. This can be useful"
" when you need to pre-process the input before it is used in your "
"program."
msgstr ""

#: ../../howto/argparse.rst:857
msgid ""
"When using a custom type converter, you can use any callable that takes a"
" single string argument (the argument value) and returns the converted "
"value. However, if you need to handle more complex scenarios, you can use"
" a custom action class with the **action** parameter instead."
msgstr ""

#: ../../howto/argparse.rst:862
msgid ""
"For example, let's say you want to handle arguments with different "
"prefixes and process them accordingly::"
msgstr ""

#: ../../howto/argparse.rst:865
msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(prefix_chars='-+')\n"
"\n"
"parser.add_argument('-a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('-', x))\n"
"parser.add_argument('+a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('+', x))\n"
"\n"
"args = parser.parse_args()\n"
"print(args)"
msgstr ""

#: ../../howto/argparse.rst:879
msgid ""
"$ python prog.py -a value1 +a value2\n"
"Namespace(a=[('-', 'value1'), ('+', 'value2')])"
msgstr ""

#: ../../howto/argparse.rst:884
#, fuzzy
msgid "In this example, we:"
msgstr "예::"

#: ../../howto/argparse.rst:886
msgid ""
"Created a parser with custom prefix characters using the ``prefix_chars``"
" parameter."
msgstr ""

#: ../../howto/argparse.rst:889
msgid ""
"Defined two arguments, ``-a`` and ``+a``, which used the ``type`` "
"parameter to create custom type converters to store the value in a tuple "
"with the prefix."
msgstr ""

#: ../../howto/argparse.rst:892
msgid ""
"Without the custom type converters, the arguments would have treated the "
"``-a`` and ``+a`` as the same argument, which would have been "
"undesirable. By using custom type converters, we were able to "
"differentiate between the two arguments."
msgstr ""

#: ../../howto/argparse.rst:897
msgid "Conclusion"
msgstr "맺음말"

#: ../../howto/argparse.rst:899
msgid ""
"The :mod:`argparse` module offers a lot more than shown here. Its docs "
"are quite detailed and thorough, and full of examples. Having gone "
"through this tutorial, you should easily digest them without feeling "
"overwhelmed."
msgstr ""
":mod:`argparse` 모듈은 여기에 제시된 것보다 훨씬 많은 것을 제공합니다. 문서는 아주 상세하고 철저하며 예제가 "
"풍부합니다. 이 자습서를 끝내면 압도감 없이 쉽게 소화할 수 있을 겁니다."

#~ msgid "Tshepang Lekhonkhobe"
#~ msgstr "Tshepang Lekhonkhobe"

#~ msgid ""
#~ "There are two other modules that "
#~ "fulfill the same task, namely "
#~ ":mod:`getopt` (an equivalent for "
#~ ":c:func:`getopt` from the C language) "
#~ "and the deprecated :mod:`optparse`. Note "
#~ "also that :mod:`argparse` is based on"
#~ " :mod:`optparse`, and therefore very "
#~ "similar in terms of usage."
#~ msgstr ""
#~ "같은 작업을 수행하는 다른 두 모듈이 있습니다, "
#~ ":mod:`getopt` (C 언어에서 :c:func:`getopt` 와 "
#~ "동등합니다) 와 폐지된 :mod:`optparse`. :mod:`argparse`"
#~ " 는 :mod:`optparse` 에 기반을 두고 있어서 "
#~ "사용법 면에서 매우 비슷합니다."

