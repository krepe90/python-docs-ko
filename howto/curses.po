# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/curses.rst:5
msgid "Curses Programming with Python"
msgstr "파이썬 curses 프로그래밍"

#: ../../howto/curses.rst
msgid "Author"
msgstr "저자"

#: ../../howto/curses.rst:9
msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

#: ../../howto/curses.rst
msgid "Release"
msgstr "버전"

#: ../../howto/curses.rst:10
msgid "2.04"
msgstr "2.04"

#: ../../howto/curses.rst:-1
msgid "Abstract"
msgstr "요약"

#: ../../howto/curses.rst:15
msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr "이 문서는 :mod:`curses` 확장 모듈을 사용하여 텍스트 모드 디스플레이를 제어하는 방법을 설명합니다."

#: ../../howto/curses.rst:20
msgid "What is curses?"
msgstr "curses란 무엇입니까?"

#: ../../howto/curses.rst:22
msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals "
"include VT100s, the Linux console, and the simulated terminal provided by"
" various programs.  Display terminals support various control codes to "
"perform common operations such as moving the cursor, scrolling the "
"screen, and erasing areas.  Different terminals use widely differing "
"codes, and often have their own minor quirks."
msgstr ""
"curses 라이브러리는 텍스트 기반 터미널을 위한 터미널 독립적인 스크린 페인팅과 키보드 처리 기능을 제공합니다; 이러한 "
"터미널에는 VT100, 리눅스 콘솔 및 다양한 프로그램에서 제공하는 시뮬레이트 된 터미널이 포함됩니다. 디스플레이 터미널은 커서 "
"이동, 화면 스크롤 및 영역 지우기와 같은 일반적인 작업을 수행하기 위해 다양한 제어 코드를 지원합니다. 터미널마다 서로 다른 "
"코드를 사용하며 종종 자신만의 사소한 문제가 있습니다."

#: ../../howto/curses.rst:30
msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's "
"true that character-cell display terminals are an obsolete technology, "
"but there are niches in which being able to do fancy things with them are"
" still valuable.  One niche is on small-footprint or embedded Unixes that"
" don't run an X server.  Another is tools such as OS installers and "
"kernel configurators that may have to run before any graphical support is"
" available."
msgstr ""
"그래픽 디스플레이의 세계에서, 이렇게 물을 수 있습니다. \"왜 신경 써야 하나요\"? 문자 셀 디스플레이 터미널은 한물간 "
"기술이지만, 사실 여전히 가치 있는 멋진 작업을 수행할 수 있는 틈새가 존재합니다. 한가지 틈새는 X 서버를 실행하지 않는 작은 "
"크기 혹은 내장 유닉스입니다. 다른 것으로는 그래픽 지원을 사용할 수 있기 전에 실행해야 할 OS 설치 프로그램과 커널 구성기와 "
"같은 도구가 있습니다."

#: ../../howto/curses.rst:38
msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the"
" curses library will figure out what control codes need to be sent to the"
" terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need "
"such features, consider a user interface library such as :pypi:`Urwid`."
msgstr ""
"curses 라이브러리는 상당히 기본적인 기능을 제공하여, 프로그래머에게 겹치지 않는 여러 개의 텍스트 창을 포함하는 디스플레이의 "
"추상화를 제공합니다. 창의 내용은 텍스트 추가, 삭제, 모양 변경 등 다양한 방법으로 변경될 수 있으며 curses 라이브러리는 "
"올바른 출력을 생성하기 위해 터미널에 어떤 제어 코드를 보내야 하는지 파악합니다. curses는 버튼, 체크 박스 또는 대화 상자와"
" 같은 많은 사용자 인터페이스 개념을 제공하지 않습니다; 이러한 기능이 필요하면 :pypi:`Urwid`\\와 같은 사용자 "
"인터페이스 라이브러리를 고려하십시오."

#: ../../howto/curses.rst:48
msgid ""
"The curses library was originally written for BSD Unix; the later System "
"V versions of Unix from AT&T added many enhancements and new functions. "
"BSD curses is no longer maintained, having been replaced by ncurses, "
"which is an open-source implementation of the AT&T interface.  If you're "
"using an open-source Unix such as Linux or FreeBSD, your system almost "
"certainly uses ncurses.  Since most current commercial Unix versions are "
"based on System V code, all the functions described here will probably be"
" available.  The older versions of curses carried by some proprietary "
"Unixes may not support everything, though."
msgstr ""
"curses 라이브러리는 원래 BSD 유닉스용으로 작성되었습니다; 그 이후 AT&T의 유닉스 시스템 V 버전에는 많은 개선 사항과 "
"새로운 기능이 추가되었습니다. BSD curses는 더는 유지되지 않고, AT&T 인터페이스의 오픈 소스 구현인 ncurses로 "
"대체되었습니다. 리눅스나 FreeBSD 와 같은 오픈 소스 유닉스를 사용하고 있다면, 시스템은 거의 확실히 ncurses를 "
"사용합니다. 최신 상용 유닉스 버전은 대부분 시스템 V 코드를 기반으로 하므로, 여기에 설명된 모든 기능을 아마도 사용할 수 있을 "
"것입니다. 그러나 일부 독점적 유닉스가 제공하는 이전 버전의 curses는 모든 것을 지원하지 않을 수 있습니다."

#: ../../howto/curses.rst:58
msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  "
"A ported version called :pypi:`UniCurses` is available."
msgstr ""
"윈도우 버전의 파이썬은 :mod:`curses` 모듈을 포함하지 않습니다. 이식된 버전인 :pypi:`UniCurses`\\를 "
"사용할 수 있습니다."

#: ../../howto/curses.rst:63
msgid "The Python curses module"
msgstr "파이썬 curses 모듈"

#: ../../howto/curses.rst:65
msgid ""
"The Python module is a fairly simple wrapper over the C functions "
"provided by curses; if you're already familiar with curses programming in"
" C, it's really easy to transfer that knowledge to Python.  The biggest "
"difference is that the Python interface makes things simpler by merging "
"different C functions such as :c:func:`!addstr`, :c:func:`!mvaddstr`, and"
" :c:func:`!mvwaddstr` into a single :meth:`~curses.window.addstr` method."
"  You'll see this covered in more detail later."
msgstr ""
"파이썬 모듈은 curses가 제공하는 C 함수에 대한 상당히 간단한 래퍼입니다; C의 curses 프로그래밍에 이미 익숙하다면 이 "
"지식을 파이썬으로 쉽게 옮길 수 있습니다. 가장 큰 차이점은 파이썬 인터페이스가 :c:func:`!addstr`, "
":c:func:`!mvaddstr` 및 :c:func:`!mvwaddstr`\\와 같은 다른 C 함수를 단일 "
":meth:`~curses.window.addstr` 메서드로 병합하여 작업을 단순화한다는 것입니다. 나중에 자세히 다루겠습니다."

#: ../../howto/curses.rst:73
msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses "
"and Python. It doesn't attempt to be a complete guide to the curses API; "
"for that, see the Python library guide's section on ncurses, and the C "
"manual pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"이 HOWTO는 curses와 파이썬으로 텍스트 모드 프로그램을 작성하는 방법을 소개합니다. curses API에 대한 완전한 "
"안내서가 되려는 것은 아닙니다; 그것을 위해서는 ncurses에 대한 파이썬 라이브러리 안내서 섹션과 ncurses에 대한 C "
"매뉴얼 페이지를 참조하십시오. 그러나 기본 아이디어는 제공합니다."

#: ../../howto/curses.rst:80
msgid "Starting and ending a curses application"
msgstr "curses 응용 프로그램 시작과 종료"

#: ../../howto/curses.rst:82
msgid ""
"Before doing anything, curses must be initialized.  This is done by "
"calling the :func:`~curses.initscr` function, which will determine the "
"terminal type, send any required setup codes to the terminal, and create "
"various internal data structures.  If successful, :func:`!initscr` "
"returns a window object representing the entire screen; this is usually "
"called ``stdscr`` after the name of the corresponding C variable. ::"
msgstr ""
"무언가를 하기 전에 curses를 초기화해야 합니다. 이것은 :func:`~curses.initscr` 함수를 호출함으로써 "
"수행되는데, 터미널 유형을 결정하고, 필요한 설정 코드를 터미널에 보내고, 다양한 내부 데이터 구조를 만듭니다. 성공하면 "
":func:`!initscr`\\은 전체 화면을 나타내는 창 객체를 반환합니다; 이를 일반적으로 해당 C 변수 이름을 따라 "
"``stdscr``\\이라고 합니다. ::"

#: ../../howto/curses.rst:90
msgid ""
"import curses\n"
"stdscr = curses.initscr()"
msgstr ""
"import curses\n"
"stdscr = curses.initscr()"

#: ../../howto/curses.rst:93
msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under "
"certain circumstances.  This requires calling the :func:`~curses.noecho` "
"function. ::"
msgstr ""
"일반적으로 curses 응용 프로그램은 키를 읽고 특정 상황에서만 표시할 수 있도록 화면으로 키를 자동 에코 하는 기능을 끕니다. "
"이를 위해서는 :func:`~curses.noecho` 함수를 호출해야 합니다. ::"

#: ../../howto/curses.rst:98
msgid "curses.noecho()"
msgstr "curses.noecho()"

#: ../../howto/curses.rst:100
msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr ""
"응용 프로그램은 또한 일반적으로 Enter 키를 누르지 않아도 즉시 키에 반응해야 합니다; 이것을 일반적인 버퍼 입력 모드와 "
"대비하여 cbreak 모드라고 합니다. ::"

#: ../../howto/curses.rst:104
msgid "curses.cbreak()"
msgstr "curses.cbreak()"

#: ../../howto/curses.rst:106
msgid ""
"Terminals usually return special keys, such as the cursor keys or "
"navigation keys such as Page Up and Home, as a multibyte escape sequence."
"  While you could write your application to expect such sequences and "
"process them accordingly, curses can do it for you, returning a special "
"value such as :const:`curses.KEY_LEFT`.  To get curses to do the job, "
"you'll have to enable keypad mode. ::"
msgstr ""
"터미널은 일반적으로 커서 키나 Page Up, Home 등의 탐색 키와 같은 특수 키를 멀티 바이트 이스케이프 시퀀스로 반환합니다."
" 이러한 시퀀스를 예상하고 적절하게 처리하도록 응용 프로그램을 작성할 수는 있지만, curses가 이를 수행하여 "
":const:`curses.KEY_LEFT`\\와 같은 특수 값을 반환할 수 있습니다. curses가 이런 일을 하도록 하려면, "
"키패드 모드를 활성화해야 합니다. ::"

#: ../../howto/curses.rst:113
msgid "stdscr.keypad(True)"
msgstr "stdscr.keypad(True)"

#: ../../howto/curses.rst:115
msgid ""
"Terminating a curses application is much easier than starting one. You'll"
" need to call::"
msgstr "curses 응용 프로그램을 종료하는 것은 시작하기보다 훨씬 쉽습니다. 다음과 같이 호출합니다::"

#: ../../howto/curses.rst:118
msgid ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"
msgstr ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"

#: ../../howto/curses.rst:122
msgid ""
"to reverse the curses-friendly terminal settings. Then call the "
":func:`~curses.endwin` function to restore the terminal to its original "
"operating mode. ::"
msgstr ""
"curses 친화적인 터미널 설정을 되돌립니다. 그런 다음 :func:`~curses.endwin` 함수를 호출하여 터미널을 원래 "
"작동 모드로 복원하십시오. ::"

#: ../../howto/curses.rst:126
msgid "curses.endwin()"
msgstr "curses.endwin()"

#: ../../howto/curses.rst:128
msgid ""
"A common problem when debugging a curses application is to get your "
"terminal messed up when the application dies without restoring the "
"terminal to its previous state.  In Python this commonly happens when "
"your code is buggy and raises an uncaught exception.  Keys are no longer "
"echoed to the screen when you type them, for example, which makes using "
"the shell difficult."
msgstr ""
"curses 응용 프로그램을 디버깅할 때 일반적인 문제점은 터미널을 이전 상태로 복원하지 않고 응용 프로그램이 죽을 때 터미널이 "
"엉망이 되는 것입니다. 파이썬에서 코드에 버그가 있고 잡히지 않는 예외를 일으킬 때 흔히 일어납니다. 예를 들어, 키를 입력해도 "
"키가 더는 화면에 표시되지 않아 셸 사용이 어려워집니다."

#: ../../howto/curses.rst:134
msgid ""
"In Python you can avoid these complications and make debugging much "
"easier by importing the :func:`curses.wrapper` function and using it like"
" this::"
msgstr ""
"파이썬에서는 :func:`curses.wrapper` 함수를 임포트하고 다음과 같이 사용하여 이러한 복잡성을 피하고 디버깅을 훨씬 "
"쉽게 할 수 있습니다::"

#: ../../howto/curses.rst:137
#, python-brace-format
msgid ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # Clear screen\n"
"    stdscr.clear()\n"
"\n"
"    # This raises ZeroDivisionError when i == 10.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"        stdscr.refresh()\n"
"        stdscr.getkey()\n"
"\n"
"wrapper(main)"
msgstr ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # 화면을 지웁니다\n"
"    stdscr.clear()\n"
"\n"
"    # i == 10일 때 ZeroDivisionError를 발생시킵니다.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"        stdscr.refresh()\n"
"        stdscr.getkey()\n"
"\n"
"wrapper(main)"

#: ../../howto/curses.rst:153
msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the"
" initializations described above, also initializing colors if color "
"support is present.  :func:`!wrapper` then runs your provided callable. "
"Once the callable returns, :func:`!wrapper` will restore the original "
"state of the terminal.  The callable is called inside a "
":keyword:`try`...\\ :keyword:`except` that catches exceptions, restores "
"the state of the terminal, and then re-raises the exception.  Therefore "
"your terminal won't be left in a funny state on exception and you'll be "
"able to read the exception's message and traceback."
msgstr ""
":func:`~curses.wrapper` 함수는 콜러블 객체를 취하고 위에서 설명한 초기화를 수행합니다, 색상 지원이 있으면 "
"색상도 초기화합니다. 그런 다음 :func:`!wrapper`\\는 제공된 콜러블을 실행합니다. 일단 콜러블이 반환되면, "
":func:`!wrapper`\\는 터미널의 원래 상태를 복원합니다. 콜러블은 예외를 잡는 :keyword:`try`...\\ "
":keyword:`except` 내에서 호출되고, 터미널의 상태를 복원한 다음 예외를 다시 발생시킵니다. 따라서 터미널은 예외 "
"상황에서 망가진 상태로 남지 않고 예외 메시지와 트레이스백을 읽을 수 있습니다."

#: ../../howto/curses.rst:165
msgid "Windows and Pads"
msgstr "창과 패드"

#: ../../howto/curses.rst:167
msgid ""
"Windows are the basic abstraction in curses.  A window object represents "
"a rectangular area of the screen, and supports methods to display text, "
"erase it, allow the user to input strings, and so forth."
msgstr ""
"창은 curses의 기본 추상화입니다. 창 객체는 화면의 사각형 영역을 나타내며, 텍스트를 표시하고, 지우고, 사용자가 문자열을 "
"입력할 수 있도록 하는 등의 메서드를 지원합니다."

#: ../../howto/curses.rst:171
msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is"
" a window object that covers the entire screen.  Many programs may need "
"only this single window, but you might wish to divide the screen into "
"smaller windows, in order to redraw or clear them separately. The "
":func:`~curses.newwin` function creates a new window of a given size, "
"returning the new window object. ::"
msgstr ""
":func:`~curses.initscr` 함수가 반환한 ``stdscr`` 객체는 전체 화면을 덮는 창 객체입니다. 많은 "
"프로그램에서 이 창 하나만 필요할 수도 있지만, 따로 다시 그리거나 지우기 위해 화면을 작은 창으로 나누고 싶을 수 있습니다. "
":func:`~curses.newwin` 함수는 지정된 크기의 새 창을 만들어 새 창 객체를 반환합니다. ::"

#: ../../howto/curses.rst:178
msgid ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"
msgstr ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"

#: ../../howto/curses.rst:182
msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates "
"are always passed in the order *y,x*, and the top-left corner of a window"
" is coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate"
" difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things "
"now."
msgstr ""
"curses에 사용된 좌표계는 일반적이지 않음에 주의하십시오. 좌표는 항상 *y,x* 순서로 전달되며, 창의 왼쪽 상단 모서리는 "
"좌표 (0,0) 입니다. 이것은 *x* 좌표가 먼저 오는, 좌표를 다루는 일반적인 규칙을 위반합니다. 이것은 대부분 다른 컴퓨터 "
"응용 프로그램과의 불행한 차이점이지만, 처음 작성된 이후로 curses 일부였으며, 지금 되돌리기에는 너무 늦었습니다."

#: ../../howto/curses.rst:190
msgid ""
"Your application can determine the size of the screen by using the "
":data:`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* "
"and *x* sizes.  Legal coordinates will then extend from ``(0,0)`` to "
"``(curses.LINES - 1, curses.COLS - 1)``."
msgstr ""
"응용 프로그램은 *y*\\와 *x* 크기를 얻기 위해 :data:`curses.LINES`\\와 :data:`curses.COLS`"
" 변수를 사용하여 화면 크기를 결정할 수 있습니다. 그러면 유효한 좌표는 ``(0,0)``\\에서 ``(curses.LINES - "
"1, curses.COLS - 1)``\\에 이릅니다."

#: ../../howto/curses.rst:195
msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the "
":meth:`~curses.window.refresh` method of window objects to update the "
"screen."
msgstr ""
"텍스트를 표시하거나 지우기 위해 메서드를 호출할 때, 효과는 즉시 디스플레이에 나타나지 않습니다. 대신 화면을 갱신하기 위해 창 "
"객체의 :meth:`~curses.window.refresh` 메서드를 호출해야 합니다."

#: ../../howto/curses.rst:200
msgid ""
"This is because curses was originally written with slow 300-baud terminal"
" connections in mind; with these terminals, minimizing the time required "
"to redraw the screen was very important.  Instead curses accumulates "
"changes to the screen and displays them in the most efficient manner when"
" you call :meth:`!refresh`.  For example, if your program displays some "
"text in a window and then clears the window, there's no need to send the "
"original text because they're never visible."
msgstr ""
"curses는 원래 300-baud 터미널 연결을 염두에 두고 작성되었기 때문입니다; 이러한 터미널에서는 화면을 다시 그리는 데 "
"필요한 시간을 최소화하는 것이 매우 중요했습니다. 대신 curses는 화면의 변경 사항을 누적하고 "
":meth:`!refresh`\\를 호출할 때 가장 효율적인 방식으로 표시합니다. 예를 들어, 프로그램이 창에 일부 텍스트를 표시한"
" 다음 창을 지우면, 원래 텍스트가 표시되지 않기 때문에 보낼 필요가 없습니다."

#: ../../howto/curses.rst:209
msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry "
"of activity, and then pause waiting for a keypress or some other action "
"on the part of the user.  All you have to do is to be sure that the "
"screen has been redrawn before pausing to wait for user input, by first "
"calling :meth:`!stdscr.refresh` or the :meth:`!refresh` method of some "
"other relevant window."
msgstr ""
"실제로는, 창을 다시 그리도록 명시적으로 curses에 지시한다고 해서 curses 프로그래밍이 실제로 복잡해지는 것은 아닙니다. "
"대부분 프로그램은 복잡한 행동을 한 다음 키 입력이나 사용자의 다른 동작을 기다리기 위해 일시 중지합니다. 여러분이 해야 할 것은 "
"사용자 입력을 기다리기 위해 일시 중지하기 전에 :meth:`!stdscr.refresh`\\나 다른 적절한 창의 "
":meth:`!refresh` 메서드를 먼저 호출하여 화면을 다시 그리도록 하는 것뿐입니다."

#: ../../howto/curses.rst:217
msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. "
"Creating a pad requires the pad's height and width, while refreshing a "
"pad requires giving the coordinates of the on-screen area where a "
"subsection of the pad will be displayed.  ::"
msgstr ""
"패드(pad)는 창의 특별한 경우입니다; 실제 디스플레이 화면보다 클 수 있으며, 한 번에 패드의 일부만 표시될 수 있습니다. "
"패드를 만들려면 패드의 높이와 너비가 필요하지만, 패드를 새로 고치려면 패드의 서브 섹션이 표시될 화면 영역의 좌표를 지정해야 "
"합니다. ::"

#: ../../howto/curses.rst:223
msgid ""
"pad = curses.newpad(100, 100)\n"
"# These loops fill the pad with letters; addch() is\n"
"# explained in the next section\n"
"for y in range(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# Displays a section of the pad in the middle of the screen.\n"
"# (0,0) : coordinate of upper-left corner of pad area to display.\n"
"# (5,5) : coordinate of upper-left corner of window area to be filled\n"
"#         with pad content.\n"
"# (20, 75) : coordinate of lower-right corner of window area to be\n"
"#          : filled with pad content.\n"
"pad.refresh( 0,0, 5,5, 20,75)"
msgstr ""
"pad = curses.newpad(100, 100)\n"
"# 이 루프는 패드를 글자로 채웁니다; addch()는\n"
"# 다음 섹션에서 설명합니다\n"
"for y in range(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# 화면 중간에 패드의 섹션을 표시합니다.\n"
"# (0,0) : 표시할 패드 영역의 왼쪽 위 모서리 좌표.\n"
"# (5,5) : 패드 내용으로 채울 창 영역의 왼쪽 위\n"
"#         모서리 좌표.\n"
"# (20, 75) : 패드 내용으로 채울 창 영역의 오른쪽 아래\n"
"#          : 모서리 좌표.\n"
"pad.refresh( 0,0, 5,5, 20,75)"

#: ../../howto/curses.rst:238
msgid ""
"The :meth:`!refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the "
"pad.  Beyond that difference, pads are exactly like ordinary windows and "
"support the same methods."
msgstr ""
":meth:`!refresh` 호출은 화면의 좌표 (5,5)에서 좌표 (20,75) 까지 확장된 사각형에 패드 섹션을 표시합니다; "
"표시된 섹션의 왼쪽 위 모서리는 패드의 좌표 (0,0) 입니다. 이 차이를 제외하고, 패드는 일반 창과 똑같으며 같은 메서드를 "
"지원합니다."

#: ../../howto/curses.rst:244
msgid ""
"If you have multiple windows and pads on screen there is a more efficient"
" way to update the screen and prevent annoying screen flicker as each "
"part of the screen gets updated.  :meth:`!refresh` actually does two "
"things:"
msgstr ""
"화면에 여러 개의 창과 패드가 있으면, 화면을 갱신하고 화면의 각 부분이 갱신될 때 성가신 화면 깜박임을 방지하는 더 효율적인 "
"방법이 있습니다. :meth:`!refresh`\\는 실제로 두 가지 작업을 수행합니다:"

#: ../../howto/curses.rst:249
msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to "
"update an underlying data structure representing the desired state of the"
" screen."
msgstr ""
"각 창의 :meth:`~curses.window.noutrefresh` 메서드를 호출하여 원하는 화면 상태를 나타내는 하부 데이터 "
"구조를 갱신합니다."

#: ../../howto/curses.rst:252
msgid ""
"Calls the function :func:`~curses.doupdate` function to change the "
"physical screen to match the desired state recorded in the data "
"structure."
msgstr ":func:`~curses.doupdate` 함수를 호출하여 데이터 구조에 기록된 원하는 상태와 일치하도록 물리적 화면을 변경합니다."

#: ../../howto/curses.rst:255
msgid ""
"Instead you can call :meth:`!noutrefresh` on a number of windows to "
"update the data structure, and then call :func:`!doupdate` to update the "
"screen."
msgstr ""
"대신 여러 창에서 :meth:`!noutrefresh`\\를 호출하여 데이터 구조를 갱신한 다음, "
":func:`!doupdate`\\를 호출하여 화면을 갱신할 수 있습니다."

#: ../../howto/curses.rst:261
msgid "Displaying Text"
msgstr "텍스트 표시"

#: ../../howto/curses.rst:263
msgid ""
"From a C programmer's point of view, curses may sometimes look like a "
"twisty maze of functions, all subtly different.  For example, "
":c:func:`!addstr` displays a string at the current cursor location in the"
" ``stdscr`` window, while :c:func:`!mvaddstr` moves to a given y,x "
"coordinate first before displaying the string. :c:func:`!waddstr` is just"
" like :c:func:`!addstr`, but allows specifying a window to use instead of"
" using ``stdscr`` by default. :c:func:`!mvwaddstr` allows specifying both"
" a window and a coordinate."
msgstr ""
"C 프로그래머의 관점에서 보면, curses는 때때로 모두 조금씩 다른 함수의 미로처럼 보일 수 있습니다. 예를 들어, "
":c:func:`!addstr`\\은 ``stdscr`` 창의 현재 커서 위치에 문자열을 표시하고, "
":c:func:`!mvaddstr`\\은 문자열을 표시하기 전에 주어진 y,x 좌표로 먼저 이동합니다. "
":c:func:`!waddstr`\\은 :c:func:`!addstr`\\과 비슷하지만, 기본적으로 ``stdscr``\\을 "
"사용하는 대신 사용할 창을 지정할 수 있습니다. :c:func:`!mvwaddstr`\\은 창과 좌표를 모두 지정할 수 있습니다."

#: ../../howto/curses.rst:272
msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is "
"a window object like any other, and methods such as "
":meth:`~curses.window.addstr` accept multiple argument forms.  Usually "
"there are four different forms."
msgstr ""
"다행히 파이썬 인터페이스는 이러한 모든 세부 사항을 숨깁니다. ``stdscr``\\은 다른 것과 마찬가지로 창 객체이며, "
":meth:`~curses.window.addstr`\\과 같은 메서드는 여러 인자 형식을 허용합니다. 일반적으로 네 가지 형식이 "
"있습니다."

#: ../../howto/curses.rst:278
msgid "Form"
msgstr "형식"

#: ../../howto/curses.rst:278 ../../howto/curses.rst:346
msgid "Description"
msgstr "설명"

#: ../../howto/curses.rst:280
msgid "*str* or *ch*"
msgstr "*str* 또는 *ch*"

#: ../../howto/curses.rst:280
msgid "Display the string *str* or character *ch* at the current position"
msgstr "현재 위치에 문자열 *str*\\이나 문자 *ch*\\를 표시합니다"

#: ../../howto/curses.rst:283
msgid "*str* or *ch*, *attr*"
msgstr "*str* 또는 *ch*, *attr*"

#: ../../howto/curses.rst:283
msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the"
" current position"
msgstr "현재 위치에 속성 *attr*\\을 사용하여 문자열 *str*\\이나 문자 *ch*\\를 표시합니다"

#: ../../howto/curses.rst:287
msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*, *x*, *str* 또는 *ch*"

#: ../../howto/curses.rst:287
msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr "창에서 *y,x* 위치로 이동하고, *str*\\이나 *ch*\\를 표시합니다"

#: ../../howto/curses.rst:290
msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*, *x*, *str* 또는 *ch*, *attr*"

#: ../../howto/curses.rst:290
msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, "
"using attribute *attr*"
msgstr "창에서 *y,x* 위치로 이동하고, *attr* 속성을 사용하여 *str*\\이나 *ch*\\를 표시합니다"

#: ../../howto/curses.rst:294
msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more "
"detail in the next subsection."
msgstr ""
"속성을 사용하면 굵은 체, 밑줄, 반전 코드 또는 색상과 같은 강조 표시된 형태로 텍스트를 표시할 수 있습니다. 이에 대해서는 다음"
" 서브 섹션에서 자세히 설명합니다."

#: ../../howto/curses.rst:299
msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or "
"bytestring as the value to be displayed.  The contents of bytestrings are"
" sent to the terminal as-is.  Strings are encoded to bytes using the "
"value of the window's :attr:`~window.encoding` attribute; this defaults "
"to the default system encoding as returned by :func:`locale.getencoding`."
msgstr ""
":meth:`~curses.window.addstr` 메서드는 표시할 값으로 파이썬 문자열이나 바이트열을 추합니다. 바이트열의 "
"내용은 그대로 터미널로 전송됩니다. 문자열은 창의 :attr:`~window.encoding` 어트리뷰트 값을 사용하여 바이트열로 "
"인코딩됩니다; 이 어트리뷰트의 기본값은 :func:`locale.getencoding` 에 의해 반환되는 기본 시스템 인코딩입니다."

#: ../../howto/curses.rst:305
msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ""
":meth:`~curses.window.addch` 메서드는 길이가 1인 문자열, 길이가 1인 바이트열 또는 정수일 수 있는 문자를"
" 취합니다."

#: ../../howto/curses.rst:308
msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box "
"(handy for drawing borders).  You can also use the appropriate Unicode "
"character."
msgstr ""
"확장 문자를 위한 상수가 제공됩니다; 이 상수는 255보다 큰 정수입니다. 예를 들어, :const:`ACS_PLMINUS`\\는 "
"+/- 기호이고, :const:`ACS_ULCORNER`\\는 상자의 왼쪽 위 모서리입니다 (경계를 그리기에 편리합니다). 적절한 "
"유니코드 문자를 사용할 수도 있습니다."

#: ../../howto/curses.rst:314
msgid ""
"Windows remember where the cursor was left after the last operation, so "
"if you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always "
"display a flashing cursor, you may want to ensure that the cursor is "
"positioned in some location where it won't be distracting; it can be "
"confusing to have the cursor blinking at some apparently random location."
msgstr ""
"창은 마지막 조작 후 커서가 있던 위치를 기억하므로, *y,x* 좌표를 생략하면 마지막 조작이 중단된 위치에 문자열이나 문자가 "
"표시됩니다. ``move(y,x)`` 메서드로 커서를 이동할 수도 있습니다. 일부 터미널은 항상 깜빡이는 커서를 표시하기 때문에, "
"방해받지 않는 위치에 커서를 놓아야 합니다; 임의의 위치에서 커서가 깜박이는 것은 혼란스러울 수 있습니다."

#: ../../howto/curses.rst:322
msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym "
"for :func:`~curses.curs_set`.  When *bool* is true, the curses library "
"will attempt to suppress the flashing cursor, and you won't need to worry"
" about leaving it in odd locations."
msgstr ""
"응용 프로그램에 깜박이는 커서가 전혀 필요하지 않으면, ``curs_set(False)``\\를 호출하여 보이지 않게 할 수 "
"있습니다. 이전 curses 버전과의 호환성을 위해, :func:`~curses.curs_set`\\과 동의어인 "
"``leaveok(bool)`` 함수가 있습니다. *bool* 이 참이면, curses 라이브러리는 깜박이는 커서를 억제하려고 "
"시도하고, 커서를 부적절한 위치에 두는 것에 대해 걱정할 필요가 없습니다."

#: ../../howto/curses.rst:331
msgid "Attributes and Color"
msgstr "속성과 색상"

#: ../../howto/curses.rst:333
msgid ""
"Characters can be displayed in different ways.  Status lines in a text-"
"based application are commonly shown in reverse video, or a text viewer "
"may need to highlight certain words.  curses supports this by allowing "
"you to specify an attribute for each cell on the screen."
msgstr ""
"문자는 다른 방식으로 표시될 수 있습니다. 텍스트 기반 응용 프로그램의 상태 줄(status line)은 일반적으로 반전 비디오로 "
"표시되거나 텍스트 뷰어에서 특정 단어를 강조 표시해야 할 수 있습니다. curses는 화면에 있는 각 셀의 속성을 지정할 수 있도록"
" 하여 이를 지원합니다."

#: ../../howto/curses.rst:338
msgid ""
"An attribute is an integer, each bit representing a different attribute."
"  You can try to display text with multiple attribute bits set, but "
"curses doesn't guarantee that all the possible combinations are "
"available, or that they're all visually distinct.  That depends on the "
"ability of the terminal being used, so it's safest to stick to the most "
"commonly available attributes, listed here."
msgstr ""
"속성은 정수이며, 각 비트는 다른 속성을 나타냅니다. 여러 속성 비트가 설정된 텍스트를 표시하려고 시도 할 수 있지만, "
"curses는 가능한 모든 조합을 사용할 수 있거나 시각적으로 구별됨을 보증하지 않습니다. 사용하는 터미널의 기능에 따라 다르므로,"
" 여기에 나열된 가장 일반적으로 사용 가능한 속성을 고수하는 것이 가장 안전합니다."

#: ../../howto/curses.rst:346
msgid "Attribute"
msgstr "속성"

#: ../../howto/curses.rst:348
msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLINK`"

#: ../../howto/curses.rst:348
msgid "Blinking text"
msgstr "깜박거리는 텍스트"

#: ../../howto/curses.rst:350
msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

#: ../../howto/curses.rst:350
msgid "Extra bright or bold text"
msgstr "매우 밝거나 굵은 텍스트"

#: ../../howto/curses.rst:352
msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

#: ../../howto/curses.rst:352
msgid "Half bright text"
msgstr "절반 밝기의 텍스트"

#: ../../howto/curses.rst:354
msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

#: ../../howto/curses.rst:354
msgid "Reverse-video text"
msgstr "반전 비디오 텍스트"

#: ../../howto/curses.rst:356
msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

#: ../../howto/curses.rst:356
msgid "The best highlighting mode available"
msgstr "사용 가능한 최고 강조 표시 모드"

#: ../../howto/curses.rst:358
msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

#: ../../howto/curses.rst:358
msgid "Underlined text"
msgstr "밑줄이 그어진 텍스트"

#: ../../howto/curses.rst:361
msgid ""
"So, to display a reverse-video status line on the top line of the screen,"
" you could code::"
msgstr "따라서 화면 상단 줄에 반전 비디오 상태 줄을 표시하려면, 다음과 같이 코딩할 수 있습니다::"

#: ../../howto/curses.rst:364
msgid ""
"stdscr.addstr(0, 0, \"Current mode: Typing mode\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"
msgstr ""
"stdscr.addstr(0, 0, \"Current mode: Typing mode\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"

#: ../../howto/curses.rst:368
msgid ""
"The curses library also supports color on those terminals that provide "
"it. The most common such terminal is probably the Linux console, followed"
" by color xterms."
msgstr ""
"curses 라이브러리는 또한 색상을 제공하는 터미널에서 색상을 지원합니다. 이러한 터미널 중 가장 일반적인 터미널은 리눅스 "
"콘솔이고, 그다음은 컬러 xterm입니다."

#: ../../howto/curses.rst:372
msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon"
" after calling :func:`~curses.initscr`, to initialize the default color "
"set (the :func:`curses.wrapper` function does this automatically).  Once "
"that's done, the :func:`~curses.has_colors` function returns TRUE if the "
"terminal in use can actually display color.  (Note: curses uses the "
"American spelling 'color', instead of the Canadian/British spelling "
"'colour'.  If you're used to the British spelling, you'll have to resign "
"yourself to misspelling it for the sake of these functions.)"
msgstr ""
"색상을 사용하려면, :func:`~curses.initscr`\\을 호출한 직후 :func:`~curses.start_color` "
"함수를 호출하여, 기본 색상 집합을 초기화해야 합니다 (:func:`curses.wrapper` 함수는 이것을 자동으로 "
"수행합니다). 일단 이렇게 하면, :func:`~curses.has_colors` 함수는 사용 중인 터미널이 실제로 색상을 표시할 "
"수 있으면 True를 반환합니다. (참고: curses는 캐나다/영국 철자법 'colour' 대신 미국식 철자법 'color'를 "
"사용합니다. 영국 철자법에 익숙하다면 이러한 함수를 위해 철자법을 바꾸는 것을 감수해야 합니다.)"

#: ../../howto/curses.rst:382
msgid ""
"The curses library maintains a finite number of color pairs, containing a"
" foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the "
":func:`~curses.color_pair` function; this can be bitwise-OR'ed with other"
" attributes such as :const:`A_REVERSE`, but again, such combinations are "
"not guaranteed to work on all terminals."
msgstr ""
"curses 라이브러리는 전경(또는 텍스트)색과 배경색을 포함하여 유한한 수의 색 쌍을 유지합니다. "
":func:`~curses.color_pair` 함수를 사용하여 색상 쌍에 해당하는 속성값을 얻을 수 있습니다; 이것은 "
":const:`A_REVERSE`\\와 같은 다른 속성과 비트별 OR 될 수 있지만, 다시 한번, 이러한 조합이 모든 터미널에서 "
"작동하는 것은 아닙니다."

#: ../../howto/curses.rst:389
msgid "An example, which displays a line of text using color pair 1::"
msgstr "색상 쌍 1을 사용하여 텍스트 줄을 표시하는 예::"

#: ../../howto/curses.rst:391
msgid ""
"stdscr.addstr(\"Pretty text\", curses.color_pair(1))\n"
"stdscr.refresh()"
msgstr ""
"stdscr.addstr(\"Pretty text\", curses.color_pair(1))\n"
"stdscr.refresh()"

#: ../../howto/curses.rst:394
msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of "
"color pair *n*, to foreground color f and background color b.  Color pair"
" 0 is hard-wired to white on black, and cannot be changed."
msgstr ""
"앞에서 말했듯이, 색상 쌍은 전경색과 배경색으로 구성됩니다. ``init_pair(n, f, b)`` 함수는 색상 쌍 *n*\\의 "
"정의를 전경색 f와 배경색 b로 변경합니다. 색상 쌍 0은 검은 배경에 흰 전경으로 강제되어 있으며 변경할 수 없습니다."

#: ../../howto/curses.rst:399
msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors "
"when it activates color mode.  They are: 0:black, 1:red, 2:green, "
"3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` "
"module defines named constants for each of these colors: "
":const:`curses.COLOR_BLACK`, :const:`curses.COLOR_RED`, and so forth."
msgstr ""
"색상은 번호가 매겨지며, :func:`start_color`\\는 색상 모드를 활성화할 때 8가지 기본 색상을 초기화합니다. "
"0:검정(black), 1:빨강(red), 2:녹색(green), 3:노랑(yellow), 4:파랑(blue), "
"5:자홍색(magenta), 6:청록색(cyan) 및 7:하양(white) 입니다. :mod:`curses` 모듈은 "
":const:`curses.COLOR_BLACK`, :const:`curses.COLOR_RED` 등 각 색상에 대해 이름 붙인 "
"상수를 정의합니다."

#: ../../howto/curses.rst:405
msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr "이 모든 것을 써봅시다. 색상 1을 흰색 배경의 빨간색 텍스트로 변경하려면, 다음과 같이 호출할 수 있습니다::"

#: ../../howto/curses.rst:408
msgid "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"
msgstr "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"

#: ../../howto/curses.rst:410
msgid ""
"When you change a color pair, any text already displayed using that color"
" pair will change to the new colors.  You can also display new text in "
"this color with::"
msgstr ""
"색상 쌍을 변경할 때, 해당 색상 쌍을 사용하여 이미 표시된 텍스트가 새 색상으로 변경됩니다. 이 색상으로 새 텍스트를 표시 할 "
"수도 있습니다::"

#: ../../howto/curses.rst:414
msgid "stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1))"
msgstr "stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1))"

#: ../../howto/curses.rst:416
msgid ""
"Very fancy terminals can change the definitions of the actual colors to a"
" given RGB value.  This lets you change color 1, which is usually red, to"
" purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't "
"provide any examples.  You can check if your terminal can do this by "
"calling :func:`~curses.can_change_color`, which returns ``True`` if the "
"capability is there.  If you're lucky enough to have such a talented "
"terminal, consult your system's man pages for more information."
msgstr ""
"매우 멋진 터미널은 실제 색상의 정의를 주어진 RGB 값으로 변경할 수 있습니다. 이를 통해 일반적으로 빨간색인 색상 1을 "
"보라색이나 파란색 또는 원하는 어떤 색상으로도 변경할 수 있습니다. 불행히도, 리눅스 콘솔은 이것을 지원하지 않아서, 저는 시도해 "
"볼 수 없고 예제를 제공할 수 없습니다. :func:`~curses.can_change_color`\\를 호출하여 여러분의 터미널이"
" 이를 수행 할 수 있는지를 확인할 수 있습니다. 기능이 있으면 ``True``\\를 반환합니다. 이러한 재능있는 터미널을 보유할 "
"만큼 운이 좋다면, 자세한 내용은 시스템 매뉴얼 페이지를 참조하십시오."

#: ../../howto/curses.rst:427
msgid "User Input"
msgstr "사용자 입력"

#: ../../howto/curses.rst:429
msgid ""
"The C curses library offers only very simple input mechanisms. Python's "
":mod:`curses` module adds a basic text-input widget.  (Other libraries "
"such as :pypi:`Urwid` have more extensive collections of widgets.)"
msgstr ""
"C curses 라이브러리는 매우 간단한 입력 메커니즘만 제공합니다. 파이썬의 :mod:`curses` 모듈은 기본 텍스트 입력 "
"위젯을 추가합니다. (:pypi:`Urwid`\\와 같은 다른 라이브러리에는 더 광범위한 위젯 모음이 있습니다.)"

#: ../../howto/curses.rst:433
msgid "There are two methods for getting input from a window:"
msgstr "창에서 입력을 얻는 메서드는 두 가지가 있습니다.:"

#: ../../howto/curses.rst:435
msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the "
"cursor should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch`\\는 화면을 새로 고친 다음 사용자가 키를 누를 때까지 기다립니다. "
":func:`~curses.echo`\\가 이전에 호출되었으면 키를 표시합니다. 일시 정지하기 전에 커서를 이동시킬 좌표를 "
"선택적으로 지정할 수 있습니다."

#: ../../howto/curses.rst:440
msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the "
"integer to a string.  Individual characters are returned as 1-character "
"strings, and special keys such as function keys return longer strings "
"containing a key name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey`\\는 같은 작업을 수행하지만, 정수를 문자열로 변환합니다. 개별 문자는 "
"1-문자 문자열로 반환되며, 기능 키와 같은 특수키는 ``KEY_UP``\\이나 ``^G``\\와 같은 키 이름을 포함하는 더 긴 "
"문자열을 반환합니다."

#: ../../howto/curses.rst:445
msgid ""
"It's possible to not wait for the user using the "
":meth:`~curses.window.nodelay` window method. After ``nodelay(True)``, "
":meth:`!getch` and :meth:`!getkey` for the window become non-blocking. To"
" signal that no input is ready, :meth:`!getch` returns ``curses.ERR`` (a "
"value of -1) and :meth:`!getkey` raises an exception. There's also a "
":func:`~curses.halfdelay` function, which can be used to (in effect) set "
"a timer on each :meth:`!getch`; if no input becomes available within a "
"specified delay (measured in tenths of a second), curses raises an "
"exception."
msgstr ""
":meth:`~curses.window.nodelay` 창 메서드를 사용하여 사용자를 기다리지 않을 수 있습니다. "
"``nodelay(True)`` 이후에는, 창의 :meth:`!getch`\\와 :meth:`!getkey`\\가 블로킹 되지 "
"않습니다. 입력이 준비되지 않았다는 신호를 보내기 위해 :meth:`!getch`\\는 ``curses.ERR``\\(-1 값)을 "
"반환하고 :meth:`!getkey`\\는 예외를 발생시킵니다. :func:`~curses.halfdelay` 함수도 있는데, 각 "
":meth:`!getch`\\에 (효과적으로) 타이머를 설정하는 데 사용할 수 있습니다; 지정된 지연 시간 (10분의 1초로 "
"측정됩니다) 내에 입력이 없으면 curses는 예외를 발생시킵니다."

#: ../../howto/curses.rst:455
msgid ""
"The :meth:`!getch` method returns an integer; if it's between 0 and 255, "
"it represents the ASCII code of the key pressed.  Values greater than 255"
" are special keys such as Page Up, Home, or the cursor keys. You can "
"compare the value returned to constants such as "
":const:`curses.KEY_PPAGE`, :const:`curses.KEY_HOME`, or "
":const:`curses.KEY_LEFT`.  The main loop of your program may look "
"something like this::"
msgstr ""
":meth:`!getch` 메서드는 정수를 반환합니다; 0에서 255 사이이면, 누른 키의 ASCII 코드를 나타냅니다. 255보다"
" 큰 값은 Page Up, Home 또는 커서 키와 같은 특수 키입니다. 반환 값을 :const:`curses.KEY_PPAGE`,"
" :const:`curses.KEY_HOME` 또는 :const:`curses.KEY_LEFT`\\와 같은 상수와 비교할 수 "
"있습니다. 프로그램의 메인 루프는 이런 식입니다::"

#: ../../howto/curses.rst:462
msgid ""
"while True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break  # Exit the while loop\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"
msgstr ""
"while True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break  # while 루프를 종료합니다\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"

#: ../../howto/curses.rst:471
msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, "
":func:`curses.ascii.ctrl` returns the control character corresponding to "
"its argument."
msgstr ""
":mod:`curses.ascii` 모듈은 정수나 1문자 문자열 인자를 취하는 ASCII 클래스 멤버십 함수를 제공합니다; 이러한 "
"루프에서 더 읽기 쉬운 검사를 작성하는 데 유용 할 수 있습니다. 이것은 또한 정수나 1문자 문자열 인자를 취하고 같은 유형을 "
"반환하는 변환 함수를 제공합니다. 예를 들어, :func:`curses.ascii.ctrl`\\은 인자에 해당하는 제어 문자를 "
"반환합니다."

#: ../../howto/curses.rst:478
msgid ""
"There's also a method to retrieve an entire string, "
":meth:`~curses.window.getstr`.  It isn't used very often, because its "
"functionality is quite limited; the only editing keys available are the "
"backspace key and the Enter key, which terminates the string.  It can "
"optionally be limited to a fixed number of characters. ::"
msgstr ""
"전체 문자열을 꺼내는 메서드도 있습니다, :meth:`~curses.window.getstr`. 기능이 상당히 제한되어 있기 때문에"
" 자주 사용되지 않습니다; 사용 가능한 편집 키는 백스페이스키와 문자열을 종료하는 Enter 키뿐입니다. 고정된 수의 문자로 "
"선택적으로 제한될 수 있습니다. ::"

#: ../../howto/curses.rst:484
msgid ""
"curses.echo()            # Enable echoing of characters\n"
"\n"
"# Get a 15-character string, with the cursor on the top line\n"
"s = stdscr.getstr(0,0, 15)"
msgstr ""
"curses.echo()            # 문자 에코를 활성화합니다\n"
"\n"
"# 커서를 맨 윗줄에 놓고 15자 문자열을 가져옵니다\n"
"s = stdscr.getstr(0,0, 15)"

#: ../../howto/curses.rst:489
msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an "
"Emacs-like set of keybindings.  Various methods of the "
":class:`~curses.textpad.Textbox` class support editing with input "
"validation and gathering the edit results either with or without trailing"
" spaces.  Here's an example::"
msgstr ""
":mod:`curses.textpad` 모듈은 Emacs와 같은 키 바인딩 집합을 지원하는 텍스트 상자를 제공합니다. "
":class:`~curses.textpad.Textbox` 클래스의 다양한 메서드는 입력 유효성 검증을 사용한 편집과 후행 공백이 "
"있거나 없는 편집 결과 수집을 지원합니다. 예를 들면 다음과 같습니다::"

#: ../../howto/curses.rst:495
msgid ""
"import curses\n"
"from curses.textpad import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Enter IM message: (hit Ctrl-G to send)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Let the user edit until Ctrl-G is struck.\n"
"    box.edit()\n"
"\n"
"    # Get resulting contents\n"
"    message = box.gather()"
msgstr ""
"import curses\n"
"from curses.textpad import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Enter IM message: (hit Ctrl-G to send)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Ctrl-G를 칠 때까지 사용자가 편집하도록 합니다.\n"
"    box.edit()\n"
"\n"
"    # 결과 내용물을 얻습니다\n"
"    message = box.gather()"

#: ../../howto/curses.rst:513
msgid "See the library documentation on :mod:`curses.textpad` for more details."
msgstr "자세한 내용은 :mod:`curses.textpad`\\의 라이브러리 설명서를 참조하십시오."

#: ../../howto/curses.rst:517
msgid "For More Information"
msgstr "추가 정보"

#: ../../howto/curses.rst:519
msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the "
"contents of the screen or capturing mouse events from an xterm instance, "
"but the Python library page for the :mod:`curses` module is now "
"reasonably complete.  You should browse it next."
msgstr ""
"이 HOWTO는 화면의 내용을 읽거나 xterm 인스턴스에서 마우스 이벤트를 캡처하는 등의 고급 주제를 다루지 않지만, "
":mod:`curses` 모듈의 파이썬 라이브러리 페이지는 이제 어느 정도 완전합니다. 다음으로 그 페이지를 보십시오."

#: ../../howto/curses.rst:524
msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document "
"any quirks, and provide complete lists of all the functions, attributes, "
"and :ref:`ACS_\\* <curses-acs-codes>` characters available to you."
msgstr ""
"curses 함수의 자세한 동작에 대해 확신이 없으면, curses 구현(ncurses이건 독점 유닉스 벤더의 것이건)에 대한 "
"매뉴얼 페이지를 참조하십시오. 매뉴얼 페이지는 모든 뒤틀림(quirks)을 문서화하고, 사용 가능한 모든 함수, 속성 및 "
":ref:`ACS_\\* <curses-acs-codes>` 문자의 전체 목록을 제공합니다."

#: ../../howto/curses.rst:531
msgid ""
"Because the curses API is so large, some functions aren't supported in "
"the Python interface.  Often this isn't because they're difficult to "
"implement, but because no one has needed them yet.  Also, Python doesn't "
"yet support the menu library associated with ncurses. Patches adding "
"support for these would be welcome; see `the Python Developer's Guide "
"<https://devguide.python.org/>`_ to learn more about submitting patches "
"to Python."
msgstr ""
"curses API가 아주 크기 때문에, 일부 함수는 파이썬 인터페이스에서 지원되지 않습니다. 종종 구현하기가 어렵기 때문이 "
"아니라, 아직 아무도 원하지 않았기 때문입니다. 또한, 파이썬은 ncurses와 관련된 메뉴 라이브러리를 아직 지원하지 않습니다. "
"이들에 대한 지원을 추가하는 패치를 환영합니다; 파이썬에 패치를 제출하는 방법에 대한 자세한 내용은 `파이썬 개발자 지침서 "
"<https://devguide.python.org/>`_\\를 참조하십시오."

#: ../../howto/curses.rst:539
msgid ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses"
"/ncurses-intro.html>`_: a lengthy tutorial for C programmers."
msgstr ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses"
"/ncurses-intro.html>`_: C 프로그래머를 위한 긴 자습서."

#: ../../howto/curses.rst:541
msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "`ncurses 매뉴얼 페이지 <https://linux.die.net/man/3/ncurses>`_"

#: ../../howto/curses.rst:542
msgid "`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr "`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"

#: ../../howto/curses.rst:543
msgid ""
"`\"Use curses... don't swear\" "
"<https://www.youtube.com/watch?v=eN1eZtjLEnU>`_: video of a PyCon 2013 "
"talk on controlling terminals using curses or Urwid."
msgstr ""
"`\"Use curses... don't swear\" "
"<https://www.youtube.com/watch?v=eN1eZtjLEnU>`_: curses나 Urwid를 사용하여 터미널을"
" 제어하는 PyCon 2013 발표 비디오."

#: ../../howto/curses.rst:545
msgid ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568"
"/console-applications-with-urwid>`_: video of a PyCon CA 2012 talk "
"demonstrating some applications written using Urwid."
msgstr ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568"
"/console-applications-with-urwid>`_: Urwid를 사용하여 작성된 몇몇 응용 프로그램을 보여주는 "
"PyCon CA 2012 발표 비디오."

