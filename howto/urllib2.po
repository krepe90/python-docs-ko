# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "urllib 패키지를 사용하여 인터넷 리소스를 가져오는 방법"

#: ../../howto/urllib2.rst
msgid "Author"
msgstr "저자"

#: ../../howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

#: ../../howto/urllib2.rst:11
msgid "Introduction"
msgstr "소개"

#: ../../howto/urllib2.rst:15
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr "파이썬으로 웹 리소스를 가져오는 방법에 대한 다음 기사도 유용합니다:"

#: ../../howto/urllib2.rst:18
msgid ""
"`Basic Authentication "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Basic Authentication "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../../howto/urllib2.rst:20
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "파이썬 예제가 있는 *기본 인증(Basic Authentication)*\\에 대한 자습서."

#: ../../howto/urllib2.rst:22
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource"
" Locators). It offers a very simple interface, in the form of the "
"*urlopen* function. This is capable of fetching URLs using a variety of "
"different protocols. It also offers a slightly more complex interface for"
" handling common situations - like basic authentication, cookies, proxies"
" and so on. These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request**\\는 URL(Uniform Resource Locator)을 가져오기 위한 파이썬 모듈입니다. "
"*urlopen* 함수의 형태로, 매우 간단한 인터페이스를 제공합니다. 다양한 프로토콜을 사용하여 URL을 가져올 수 있습니다. "
"또한 기본 인증(basic authentication), 쿠키, 프락시 등과 같은 일반적인 상황을 처리하기 위한 약간 더 복잡한 "
"인터페이스도 제공합니다. 이들은 처리기와 오프너라는 객체에 의해 제공됩니다."

#: ../../howto/urllib2.rst:29
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" "
"(identified by the string before the ``\":\"`` in URL - for example "
"``\"ftp\"`` is the URL scheme of ``\"ftp://python.org/\"``) using their "
"associated network protocols (e.g. FTP, HTTP). This tutorial focuses on "
"the most common case, HTTP."
msgstr ""
"urllib.request는 관련 네트워크 프로토콜(예를 들어 FTP, HTTP)을 사용하여 많은 \"URL 스킴(scheme)\""
" (URL에서 ``\":\"`` 앞의 문자열로 식별됩니다 - 예를 들어 ``\"ftp\"``\\는 "
"``\"ftp://python.org/\"``\\의 URL 스킴입니다)에 대해 URL을 가져오는 것을 지원합니다. 이 자습서는 가장"
" 흔한 경우인 HTTP에 초점을 맞춥니다."

#: ../../howto/urllib2.rst:34
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon"
" as you encounter errors or non-trivial cases when opening HTTP URLs, you"
" will need some understanding of the HyperText Transfer Protocol. The "
"most comprehensive and authoritative reference to HTTP is :rfc:`2616`. "
"This is a technical document and not intended to be easy to read. This "
"HOWTO aims to illustrate using *urllib*, with enough detail about HTTP to"
" help you through. It is not intended to replace the "
":mod:`urllib.request` docs, but is supplementary to them."
msgstr ""
"간단한 상황에서 *urlopen*\\은 사용하기가 매우 쉽습니다. 그러나 HTTP URL을 열 때 에러나 사소하지 않은 사례를 "
"만나자마자, HTTP(HyperText Transfer Protocol)에 대한 이해가 필요합니다. HTTP에 대한 가장 포괄적이고"
" 권위 있는 레퍼런스는 :rfc:`2616`\\입니다. 이것은 기술 문서이며 읽기 쉽지 않습니다. 이 HOWTO에서는 "
"*urllib*\\를 사용하는 방법을 설명하고, HTTP에 대해 충분히 자세하게 설명합니다. :mod:`urllib.request`"
" 문서를 대체하려는 것이 아니라, 보조하려는 것입니다."

#: ../../howto/urllib2.rst:44
msgid "Fetching URLs"
msgstr "URL을 가져오기"

#: ../../howto/urllib2.rst:46
msgid "The simplest way to use urllib.request is as follows::"
msgstr "urllib.request를 사용하는 가장 간단한 방법은 다음과 같습니다::"

#: ../../howto/urllib2.rst:48
msgid ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"
msgstr ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"

#: ../../howto/urllib2.rst:52
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and "
":func:`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"URL을 통해 리소스를 가져와서 임시 위치에 저장하려면, :func:`shutil.copyfileobj`\\와 "
":func:`tempfile.NamedTemporaryFile` 함수를 통해 수행할 수 있습니다::"

#: ../../howto/urllib2.rst:56
msgid ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"
msgstr ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"

#: ../../howto/urllib2.rst:67
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' "
"URL we could have used a URL starting with 'ftp:', 'file:', etc.).  "
"However, it's the purpose of this tutorial to explain the more "
"complicated cases, concentrating on HTTP."
msgstr ""
"urllib의 많은 용도는 이렇게 간단합니다 ('http:' URL 대신 'ftp:', 'file:' 등으로 시작하는 URL을 "
"사용할 수 있음에 유의하십시오). 그러나, 이 자습서의 목적은 HTTP에 집중하여 더 복잡한 경우를 설명하는 것입니다."

#: ../../howto/urllib2.rst:72
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to "
"fetch. Calling ``urlopen`` with this Request object returns a response "
"object for the URL requested. This response is a file-like object, which "
"means you can for example call ``.read()`` on the response::"
msgstr ""
"HTTP는 요청과 응답을 기반으로 합니다 - 클라이언트는 요청하고 서버는 응답을 보냅니다. urllib.request는 HTTP "
"요청을 나타내는 ``Request`` 객체로 이것을 반영합니다. 가장 간단한 형식에서 가져오려는 URL을 지정하는 Request "
"객체를 만듭니다. 이 Request 객체로 ``urlopen``\\을 호출하면 요청된 URL에 대한 응답 객체를 반환합니다. 이 "
"응답은 파일류 객체입니다, 응답에서 예를 들어 ``.read()``\\를 호출할 수 있다는 뜻입니다::"

#: ../../howto/urllib2.rst:80
msgid ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

#: ../../howto/urllib2.rst:86
msgid ""
"Note that urllib.request makes use of the same Request interface to "
"handle all URL schemes.  For example, you can make an FTP request like "
"so::"
msgstr ""
"urllib.request는 모든 URL 스킴을 처리하기 위해 같은 Request 인터페이스를 사용합니다. 예를 들어, 다음과 같이"
" FTP 요청을 할 수 있습니다::"

#: ../../howto/urllib2.rst:89
msgid "req = urllib.request.Request('ftp://example.com/')"
msgstr "req = urllib.request.Request('ftp://example.com/')"

#: ../../howto/urllib2.rst:91
msgid ""
"In the case of HTTP, there are two extra things that Request objects "
"allow you to do: First, you can pass data to be sent to the server.  "
"Second, you can pass extra information (\"metadata\") *about* the data or"
" about the request itself, to the server - this information is sent as "
"HTTP \"headers\".  Let's look at each of these in turn."
msgstr ""
"HTTP의 경우, Request 객체로 수행할 수 있는 추가 작업이 두 가지 있습니다: 첫째, 서버로 보낼 데이터를 전달할 수 "
"있습니다. 둘째, 데이터나 요청 자체에 *관한* 추가 정보(\"메타 데이터\")를 서버에 전달할 수 있습니다 - 이 정보는 HTTP"
" \"헤더\"로 전송됩니다. 이들을 차례로 살펴봅시다."

#: ../../howto/urllib2.rst:98
msgid "Data"
msgstr "데이터"

#: ../../howto/urllib2.rst:100
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a "
"CGI (Common Gateway Interface) script or other web application). With "
"HTTP, this is often done using what's known as a **POST** request. This "
"is often what your browser does when you submit a HTML form that you "
"filled in on the web. Not all POSTs have to come from forms: you can use "
"a POST to transmit arbitrary data to your own application. In the common "
"case of HTML forms, the data needs to be encoded in a standard way, and "
"then passed to the Request object as the ``data`` argument. The encoding "
"is done using a function from the :mod:`urllib.parse` library. ::"
msgstr ""
"URL로 데이터를 보내려고 할 때도 있습니다 (종종 URL은 CGI (Common Gateway Interface) 스크립트나 다른"
" 웹 응용 프로그램을 가리킵니다). HTTP에서, 이것은 종종 **POST** 요청이라고 알려진 것을 사용하여 수행됩니다. 이것은 "
"종종 웹에서 채워 넣은 HTML 폼(form)을 제출할 때 브라우저가 수행하는 것입니다. 모든 POST가 폼에서 비롯될 필요는 "
"없습니다: POST를 사용하여 임의의 데이터를 여러분 자신의 응용 프로그램으로 전송할 수 있습니다. 일반적인 HTML 폼의 경우, "
"데이터를 표준 방식으로 인코딩할 필요가 있고, 그런 다음 ``data`` 인자로 Request 객체에 전달합니다. 인코딩은 "
":mod:`urllib.parse` 라이브러리의 함수를 사용하여 수행됩니다. ::"

#: ../../howto/urllib2.rst:110
#, python-brace-format
msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data should be bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data는 바이트열이어야 합니다\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

#: ../../howto/urllib2.rst:124
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload "
"from HTML forms - see `HTML Specification, Form Submission "
"<https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13>`_ for more"
" details)."
msgstr ""
"다른 인코딩이 필요한 경우도 있음에 유의하십시오 (예를 들어 HTML 폼에서 파일을 업로드하는 경우 자세한 내용은 `HTML "
"Specification, Form Submission <https://www.w3.org/TR/REC-"
"html40/interact/forms.html#h-17.13>`_\\을 참조하십시오)."

#: ../../howto/urllib2.rst:129
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. "
"One way in which GET and POST requests differ is that POST requests often"
" have \"side-effects\": they change the state of the system in some way "
"(for example by placing an order with the website for a hundredweight of "
"tinned spam to be delivered to your door).  Though the HTTP standard "
"makes it clear that POSTs are intended to *always* cause side-effects, "
"and GET requests *never* to cause side-effects, nothing prevents a GET "
"request from having side-effects, nor a POST requests from having no "
"side-effects. Data can also be passed in an HTTP GET request by encoding "
"it in the URL itself."
msgstr ""
"``data`` 인자를 전달하지 않으면, urllib는 **GET** 요청을 사용합니다. GET과 POST 요청이 다른 한 가지는 "
"POST 요청에 종종 \"부작용\"이 있다는 것입니다: 어떤 방식으로든 시스템의 상태를 변경합니다 (예를 들어 캔에 담긴 스팸이 "
"여러분의 문 앞에 배달되도록 주문을 넣습니다). HTTP 표준이 POST는 *항상* 부작용을 일으키려는 것이고, GET은 *절대* "
"부작용을 일으키지 않는다고 분명히 하고 있지만, GET 요청이 부작용을 일으키거나 POST 요청에 부작용이 없는 것을 막을 수는 "
"없습니다. URL 자체에 인코딩하여 HTTP GET 요청에 데이터를 전달할 수도 있습니다."

#: ../../howto/urllib2.rst:139
msgid "This is done as follows::"
msgstr "다음과 같이 수행됩니다::"

#: ../../howto/urllib2.rst:141
#, python-brace-format
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # 순서는 아래와 다를 수 있습니다.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"

#: ../../howto/urllib2.rst:154
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, "
"followed by the encoded values."
msgstr "전체 URL은 URL에 ``?``\\를 추가한 다음 인코딩된 값을 추가하여 만들어짐에 유의하십시오."

#: ../../howto/urllib2.rst:158
msgid "Headers"
msgstr "헤더"

#: ../../howto/urllib2.rst:160
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr "여기서는 HTTP 요청에 헤더를 추가하는 방법을 설명하기 위해 한 가지 특정 HTTP 헤더에 관해 설명합니다."

#: ../../howto/urllib2.rst:163
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself "
"as ``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor "
"version numbers of the Python release, e.g. ``Python-urllib/2.5``), which"
" may confuse the site, or just plain not work. The way a browser "
"identifies itself is through the ``User-Agent`` header [#]_. When you "
"create a Request object you can pass a dictionary of headers in. The "
"following example makes the same request as above, but identifies itself "
"as a version of Internet Explorer [#]_. ::"
msgstr ""
"일부 웹 사이트는 [#]_ 프로그램이 브라우징하는 것을 싫어하거나, 브라우저에 따라 다른 버전을 보냅니다 [#]_. 기본적으로, "
"urllib는 자신을 ``Python-urllib/x.y``\\(여기서 ``x`` 와 ``y``\\는 파이썬 배포의 주 버전과 부 "
"버전 번호입니다, 예를 들어 ``Python-urllib/2.5``)로 식별하는데, 이는 사이트를 혼동시키거나, 단지 작동하지 않을"
" 수 있습니다. 브라우저가 자신을 식별하는 방식은 ``User-Agent`` 헤더를 [#]_ 통하는 것입니다. Request 객체를"
" 만들 때 헤더가 담긴 딕셔너리를 전달할 수 있습니다. 다음 예제는 위와 같은 요청을 하지만, 자신을 Internet "
"Explorer의 한 버전으로 식별합니다 [#]_. ::"

#: ../../howto/urllib2.rst:174
#, python-brace-format
msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

#: ../../howto/urllib2.rst:190
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"응답에는 두 가지 유용한 메서드도 있습니다. 문제가 발생했을 때 어떤 일이 발생했는지 살펴본 후에 나오는 `info와 geturl "
"<info and geturl_>`_ 섹션을 참조하십시오."

#: ../../howto/urllib2.rst:195
msgid "Handling Exceptions"
msgstr "예외 처리"

#: ../../howto/urllib2.rst:197
msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as "
":exc:`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen*\\은 응답을 처리할 수 없을 때 :exc:`~urllib.error.URLError`\\를 발생시킵니다 (하지만 "
"파이썬 API에서 일상적으로 발생하는 :exc:`ValueError`, :exc:`TypeError` 등과 같은 내장 예외도 발생할"
" 수 있습니다)."

#: ../../howto/urllib2.rst:201
msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of "
":exc:`~urllib.error.URLError` raised in the specific case of HTTP URLs."
msgstr ""
":exc:`~urllib.error.HTTPError`\\는 HTTP URL의 특정 경우에 발생하는 "
":exc:`~urllib.error.URLError`\\의 서브 클래스입니다."

#: ../../howto/urllib2.rst:204
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "예외 클래스는 :mod:`urllib.error` 모듈이 내보냅니다."

#: ../../howto/urllib2.rst:207
msgid "URLError"
msgstr "URLError"

#: ../../howto/urllib2.rst:209
msgid ""
"Often, URLError is raised because there is no network connection (no "
"route to the specified server), or the specified server doesn't exist.  "
"In this case, the exception raised will have a 'reason' attribute, which "
"is a tuple containing an error code and a text error message."
msgstr ""
"종종, 네트워크 연결이 없거나 (지정된 서버로의 경로가 없거나), 지정된 서버가 없기 때문에 URLError가 발생합니다. 이 "
"경우, 발생한 예외에는 'reason' 어트리뷰트가 있으며, 이는 에러 코드와 텍스트 에러 메시지를 포함하는 튜플입니다."

#: ../../howto/urllib2.rst:214
msgid "e.g. ::"
msgstr "예를 들어 ::"

#: ../../howto/urllib2.rst:216
msgid ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"
msgstr ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"

#: ../../howto/urllib2.rst:225
msgid "HTTPError"
msgstr "HTTPError"

#: ../../howto/urllib2.rst:227
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil "
"the request. The default handlers will handle some of these responses for"
" you (for example, if the response is a \"redirection\" that requests the"
" client fetch the document from a different URL, urllib will handle that "
"for you). For those it can't handle, urlopen will raise an "
":exc:`~urllib.error.HTTPError`. Typical errors include '404' (page not "
"found), '403' (request forbidden), and '401' (authentication required)."
msgstr ""
"서버의 모든 HTTP 응답에는 숫자 \"상태 코드\"가 포함됩니다. 때때로 상태 코드는 서버가 요청을 이행할 수 없음을 나타냅니다."
" 기본 처리기는 이러한 응답 중 일부를 처리합니다 (예를 들어, 응답이 클라이언트가 다른 URL에서 문서를 가져오도록 요청하는 "
"\"리디렉션\"인 경우, urllib가 이를 처리합니다). 처리할 수 없는 것들의 경우, urlopen은 "
":exc:`~urllib.error.HTTPError`\\를 발생시킵니다. 일반적인 에러에는 '404' (page not found"
" - 페이지를 찾을 수 없음), '403' (request forbidden - 요청이 금지됨) 및 '401' "
"(authentication required - 인증이 필요함)이 있습니다."

#: ../../howto/urllib2.rst:235
msgid "See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr "모든 HTTP 에러 코드에 대한 레퍼런스는 :rfc:`2616`\\의 섹션 10을 참조하십시오."

#: ../../howto/urllib2.rst:237
msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""
"발생한 :exc:`~urllib.error.HTTPError` 인스턴스는 서버에서 전송된 에러에 해당하는 정수 'code' "
"어트리뷰트를 갖습니다."

#: ../../howto/urllib2.rst:241
msgid "Error Codes"
msgstr "에러 코드"

#: ../../howto/urllib2.rst:243
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), "
"and codes in the 100--299 range indicate success, you will usually only "
"see error codes in the 400--599 range."
msgstr ""
"기본 처리기는 리디렉션(300 범위의 코드)을 처리하고, 100--299 범위의 코드는 성공을 나타내므로, 보통 400--599 "
"범위의 에러 코드만 보게 됩니다."

#: ../../howto/urllib2.rst:247
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful "
"dictionary of response codes in that shows all the response codes used by"
" :rfc:`2616`. The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses`\\는 :rfc:`2616`\\가 "
"사용하는 모든 응답 코드를 표시하는 유용한 응답 코드 딕셔너리입니다. 편의를 위해 딕셔너리를 여기에 재현합니다 ::"

#: ../../howto/urllib2.rst:251
#, python-brace-format
msgid ""
"# Table mapping response codes to messages; entries have the\n"
"# form {code: (shortmessage, longmessage)}.\n"
"responses = {\n"
"    100: ('Continue', 'Request received, please continue'),\n"
"    101: ('Switching Protocols',\n"
"          'Switching to new protocol; obey Upgrade header'),\n"
"\n"
"    200: ('OK', 'Request fulfilled, document follows'),\n"
"    201: ('Created', 'Document created, URL follows'),\n"
"    202: ('Accepted',\n"
"          'Request accepted, processing continues off-line'),\n"
"    203: ('Non-Authoritative Information', 'Request fulfilled from "
"cache'),\n"
"    204: ('No Content', 'Request fulfilled, nothing follows'),\n"
"    205: ('Reset Content', 'Clear input form for further input.'),\n"
"    206: ('Partial Content', 'Partial content follows.'),\n"
"\n"
"    300: ('Multiple Choices',\n"
"          'Object has several resources -- see URI list'),\n"
"    301: ('Moved Permanently', 'Object moved permanently -- see URI "
"list'),\n"
"    302: ('Found', 'Object moved temporarily -- see URI list'),\n"
"    303: ('See Other', 'Object moved -- see Method and URL list'),\n"
"    304: ('Not Modified',\n"
"          'Document has not changed since given time'),\n"
"    305: ('Use Proxy',\n"
"          'You must use proxy specified in Location to access this '\n"
"          'resource.'),\n"
"    307: ('Temporary Redirect',\n"
"          'Object moved temporarily -- see URI list'),\n"
"\n"
"    400: ('Bad Request',\n"
"          'Bad request syntax or unsupported method'),\n"
"    401: ('Unauthorized',\n"
"          'No permission -- see authorization schemes'),\n"
"    402: ('Payment Required',\n"
"          'No payment -- see charging schemes'),\n"
"    403: ('Forbidden',\n"
"          'Request forbidden -- authorization will not help'),\n"
"    404: ('Not Found', 'Nothing matches the given URI'),\n"
"    405: ('Method Not Allowed',\n"
"          'Specified method is invalid for this server.'),\n"
"    406: ('Not Acceptable', 'URI not available in preferred format.'),\n"
"    407: ('Proxy Authentication Required', 'You must authenticate with '\n"
"          'this proxy before proceeding.'),\n"
"    408: ('Request Timeout', 'Request timed out; try again later.'),\n"
"    409: ('Conflict', 'Request conflict.'),\n"
"    410: ('Gone',\n"
"          'URI no longer exists and has been permanently removed.'),\n"
"    411: ('Length Required', 'Client must specify Content-Length.'),\n"
"    412: ('Precondition Failed', 'Precondition in headers is false.'),\n"
"    413: ('Request Entity Too Large', 'Entity is too large.'),\n"
"    414: ('Request-URI Too Long', 'URI is too long.'),\n"
"    415: ('Unsupported Media Type', 'Entity body in unsupported "
"format.'),\n"
"    416: ('Requested Range Not Satisfiable',\n"
"          'Cannot satisfy request range.'),\n"
"    417: ('Expectation Failed',\n"
"          'Expect condition could not be satisfied.'),\n"
"\n"
"    500: ('Internal Server Error', 'Server got itself in trouble'),\n"
"    501: ('Not Implemented',\n"
"          'Server does not support this operation'),\n"
"    502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),"
"\n"
"    503: ('Service Unavailable',\n"
"          'The server cannot process the request due to a high load'),\n"
"    504: ('Gateway Timeout',\n"
"          'The gateway server did not receive a timely response'),\n"
"    505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),\n"
"    }"
msgstr ""
"# 응답 코드를 메시지로 매핑하는 표; 항목은 {코드: (짧은 메시지, 긴 메시지)}\n"
"# 형식을 취합니다.\n"
"responses = {\n"
"    100: ('Continue', 'Request received, please continue'),\n"
"    101: ('Switching Protocols',\n"
"          'Switching to new protocol; obey Upgrade header'),\n"
"\n"
"    200: ('OK', 'Request fulfilled, document follows'),\n"
"    201: ('Created', 'Document created, URL follows'),\n"
"    202: ('Accepted',\n"
"          'Request accepted, processing continues off-line'),\n"
"    203: ('Non-Authoritative Information', 'Request fulfilled from "
"cache'),\n"
"    204: ('No Content', 'Request fulfilled, nothing follows'),\n"
"    205: ('Reset Content', 'Clear input form for further input.'),\n"
"    206: ('Partial Content', 'Partial content follows.'),\n"
"\n"
"    300: ('Multiple Choices',\n"
"          'Object has several resources -- see URI list'),\n"
"    301: ('Moved Permanently', 'Object moved permanently -- see URI "
"list'),\n"
"    302: ('Found', 'Object moved temporarily -- see URI list'),\n"
"    303: ('See Other', 'Object moved -- see Method and URL list'),\n"
"    304: ('Not Modified',\n"
"          'Document has not changed since given time'),\n"
"    305: ('Use Proxy',\n"
"          'You must use proxy specified in Location to access this '\n"
"          'resource.'),\n"
"    307: ('Temporary Redirect',\n"
"          'Object moved temporarily -- see URI list'),\n"
"\n"
"    400: ('Bad Request',\n"
"          'Bad request syntax or unsupported method'),\n"
"    401: ('Unauthorized',\n"
"          'No permission -- see authorization schemes'),\n"
"    402: ('Payment Required',\n"
"          'No payment -- see charging schemes'),\n"
"    403: ('Forbidden',\n"
"          'Request forbidden -- authorization will not help'),\n"
"    404: ('Not Found', 'Nothing matches the given URI'),\n"
"    405: ('Method Not Allowed',\n"
"          'Specified method is invalid for this server.'),\n"
"    406: ('Not Acceptable', 'URI not available in preferred format.'),\n"
"    407: ('Proxy Authentication Required', 'You must authenticate with '\n"
"          'this proxy before proceeding.'),\n"
"    408: ('Request Timeout', 'Request timed out; try again later.'),\n"
"    409: ('Conflict', 'Request conflict.'),\n"
"    410: ('Gone',\n"
"          'URI no longer exists and has been permanently removed.'),\n"
"    411: ('Length Required', 'Client must specify Content-Length.'),\n"
"    412: ('Precondition Failed', 'Precondition in headers is false.'),\n"
"    413: ('Request Entity Too Large', 'Entity is too large.'),\n"
"    414: ('Request-URI Too Long', 'URI is too long.'),\n"
"    415: ('Unsupported Media Type', 'Entity body in unsupported "
"format.'),\n"
"    416: ('Requested Range Not Satisfiable',\n"
"          'Cannot satisfy request range.'),\n"
"    417: ('Expectation Failed',\n"
"          'Expect condition could not be satisfied.'),\n"
"\n"
"    500: ('Internal Server Error', 'Server got itself in trouble'),\n"
"    501: ('Not Implemented',\n"
"          'Server does not support this operation'),\n"
"    502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),"
"\n"
"    503: ('Service Unavailable',\n"
"          'The server cannot process the request due to a high load'),\n"
"    504: ('Gateway Timeout',\n"
"          'The gateway server did not receive a timely response'),\n"
"    505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),\n"
"    }"

#: ../../howto/urllib2.rst:319
msgid ""
"When an error is raised the server responds by returning an HTTP error "
"code *and* an error page. You can use the :exc:`~urllib.error.HTTPError` "
"instance as a response on the page returned. This means that as well as "
"the code attribute, it also has read, geturl, and info, methods as "
"returned by the ``urllib.response`` module::"
msgstr ""
"에러가 발생할 때 서버는 HTTP 에러 코드\\*와* 에러 페이지를 반환하여 응답합니다. "
":exc:`~urllib.error.HTTPError` 인스턴스를 반환된 페이지의 응답으로 사용할 수 있습니다. 이것은 code "
"어트리뷰트뿐만 아니라, ``urllib.response`` 모듈이 반환하는 것처럼 read, geturl 및 info 메서드도 "
"가지고 있음을 의미합니다::"

#: ../../howto/urllib2.rst:324
msgid ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  "
"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\\n\\n\\n<html"
"\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."
msgstr ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  "
"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\\n\\n\\n<html"
"\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."

#: ../../howto/urllib2.rst:339
msgid "Wrapping it Up"
msgstr "마무리"

#: ../../howto/urllib2.rst:341
msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* "
":exc:`~urllib.error.URLError` there are two basic approaches. I prefer "
"the second approach."
msgstr ""
"따라서 :exc:`~urllib.error.HTTPError` *또는* :exc:`~urllib.error.URLError`\\를 "
"대비하려면 두 가지 기본적인 접근법이 있습니다. 저는 두 번째 접근법을 선호합니다."

#: ../../howto/urllib2.rst:345
msgid "Number 1"
msgstr "1번"

#: ../../howto/urllib2.rst:350
msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # 문제없습니다"

#: ../../howto/urllib2.rst:367
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError``"
" will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""
"``except HTTPError``\\가 *반드시* 먼저 나와야 합니다. 그렇지 않으면 ``except URLError``\\가 "
":exc:`~urllib.error.HTTPError` *도* 잡습니다."

#: ../../howto/urllib2.rst:371
msgid "Number 2"
msgstr "2번"

#: ../../howto/urllib2.rst:375
msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # 문제없습니다"

#: ../../howto/urllib2.rst:392
msgid "info and geturl"
msgstr "info와 geturl"

#: ../../howto/urllib2.rst:394
msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`!info` and :meth:`!geturl` and is"
" defined in the module :mod:`urllib.response`."
msgstr ""
"urlopen에 의해 반환된 응답(또는 :exc:`~urllib.error.HTTPError` 인스턴스)에는 두 가지 유용한 메서드"
" :meth:`!info`\\와 :meth:`!geturl`\\이 있으며 :mod:`urllib.response` 모듈에 정의되어 "
"있습니다."

#: ../../howto/urllib2.rst:398
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is "
"useful because ``urlopen`` (or the opener object used) may have followed "
"a redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - 가져온 페이지의 실제 URL을 반환합니다. 이는 ``urlopen``\\(또는 사용된 오프너 객체)이 "
"리디렉션을 수행했을 수 있기 때문에 유용합니다. 가져온 페이지의 URL은 요청한 URL과 같지 않을 수 있습니다."

#: ../../howto/urllib2.rst:402
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an "
":class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - 가져온 페이지를 설명하는 딕셔너리류 객체, 특히 서버가 보낸 헤더. 현재 "
":class:`http.client.HTTPMessage` 인스턴스입니다."

#: ../../howto/urllib2.rst:406
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See "
"the `Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ "
"for a useful listing of HTTP headers with brief explanations of their "
"meaning and use."
msgstr ""
"일반적인 헤더에는 'Content-length', 'Content-type' 등이 있습니다. 의미와 용도에 대한 간단한 설명이 붙은"
" 유용한 HTTP 헤더 목록은 `Quick Reference to HTTP Headers "
"<https://jkorpela.fi/http.html>`_\\를 참조하십시오."

#: ../../howto/urllib2.rst:413
msgid "Openers and Handlers"
msgstr "오프너와 처리기"

#: ../../howto/urllib2.rst:415
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we "
"have been using the default opener - via ``urlopen`` - but you can create"
" custom openers. Openers use handlers. All the \"heavy lifting\" is done "
"by the handlers. Each handler knows how to open URLs for a particular URL"
" scheme (http, ftp, etc.), or how to handle an aspect of URL opening, for"
" example HTTP redirections or HTTP cookies."
msgstr ""
"URL을 가져올 때 오프너(아마도 혼란스럽게 이름 붙여진 :class:`urllib.request.OpenerDirector`\\의"
" 인스턴스)를 사용합니다. 일반적으로 ``urlopen``\\을 통해 기본 오프너를 사용했지만, 사용자 정의 오프너를 만들 수 "
"있습니다. 오프너는 처리기를 사용합니다. 모든 \"어려운 일은\"은 처리기가 수행합니다. 각 처리기는 특정 URL 스킴(http, "
"ftp 등)에 대한 URL을 여는 방법이나 URL 열기의 한 측면(예를 들어 HTTP 리디렉션이나 HTTP 쿠키)을 처리하는 방법을"
" 알고 있습니다."

#: ../../howto/urllib2.rst:423
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or"
" to get an opener that does not handle redirections."
msgstr ""
"특정 처리기가 설치된 상태로 URL을 가져오려면 오프너를 만듭니다, 예를 들면 쿠키를 처리하는 오프너를 얻거나, 리디렉션을 처리하지"
" 않는 오프너를 얻는 것이 있습니다."

#: ../../howto/urllib2.rst:427
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call "
"``.add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"오프너를 만들려면, ``OpenerDirector``\\를 인스턴스화 한 다음, "
"``.add_handler(some_handler_instance)``\\를 반복적으로 호출합니다."

#: ../../howto/urllib2.rst:430
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience "
"function for creating opener objects with a single function call.  "
"``build_opener`` adds several handlers by default, but provides a quick "
"way to add more and/or override the default handlers."
msgstr ""
"또는, 단일 함수 호출로 오프너 객체를 만드는 편의 함수인 ``build_opener``\\를 사용할 수 있습니다. "
"``build_opener``\\는 기본적으로 여러 처리기를 추가하지만, 더 추가하거나 기본 처리기를 재정의하는 빠른 방법을 "
"제공합니다."

#: ../../howto/urllib2.rst:435
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr "여러분이 원할 수도 있는 다른 유형의 처리기는 프락시, 인증 및 다른 흔하지만 약간 특수한 상황을 처리할 수 있습니다."

#: ../../howto/urllib2.rst:438
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener "
"you have installed."
msgstr ""
"``install_opener``\\를 사용하여 ``opener`` 객체를 (전역) 기본 오프너로 만들 수 있습니다. 즉, "
"``urlopen``\\을 호출하면 설치한 오프너가 사용됩니다."

#: ../../howto/urllib2.rst:442
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need "
"to call ``install_opener``, except as a convenience."
msgstr ""
"오프너 객체에는 ``urlopen`` 함수와 같은 방식으로 URL을 가져오기 위해 직접 호출할 수 있는 ``open`` 메서드가 "
"있습니다: 편의 이외에, ``install_opener``\\를 호출할 필요는 없습니다."

#: ../../howto/urllib2.rst:448
msgid "Basic Authentication"
msgstr "기본 인증"

#: ../../howto/urllib2.rst:450
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject "
"-- including an explanation of how Basic Authentication works - see the "
"`Basic Authentication Tutorial "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"처리기를 만들고 설치하는 것을 설명하기 위해 ``HTTPBasicAuthHandler``\\를 사용합니다. 기본 인증(Basic "
"Authentication) 작동 방식에 대한 설명을 포함하여 이 주제에 대한 자세한 설명은 `Basic Authentication"
" Tutorial "
"<https://web.archive.org/web/20201215133350/http://www.voidspace.org.uk/python/articles/authentication.shtml>`__\\을"
" 참조하십시오."

#: ../../howto/urllib2.rst:456
msgid ""
"When authentication is required, the server sends a header (as well as "
"the 401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"인증이 필요할 때, 서버는 (401 에러 코드와 함께) 인증을 요청하는 헤더를 보냅니다. 이것은 인증 스킴과 '영역(realm)'을"
" 지정합니다. 헤더는 이렇게 생겼습니다: ``WWW-Authenticate: SCHEME realm=\"REALM\"``."

#: ../../howto/urllib2.rst:461
msgid "e.g."
msgstr "예를 들어"

#: ../../howto/urllib2.rst:463
msgid "WWW-Authenticate: Basic realm=\"cPanel Users\""
msgstr "WWW-Authenticate: Basic realm=\"cPanel Users\""

#: ../../howto/urllib2.rst:468
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is "
"'basic authentication'. In order to simplify this process we can create "
"an instance of ``HTTPBasicAuthHandler`` and an opener to use this "
"handler."
msgstr ""
"그러면 클라이언트는 영역에 적절한 이름과 비밀번호를 요청의 헤더로 포함해 요청을 다시 시도해야 합니다. 이것이 '기본 "
"인증(basic authentication)'입니다. 이 프로세스를 단순화하기 위해 ``HTTPBasicAuthHandler`` "
"인스턴스와 이 처리기를 사용할 오프너를 만들 수 있습니다."

#: ../../howto/urllib2.rst:473
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the "
"server), then you can use a ``HTTPPasswordMgr``. Frequently one doesn't "
"care what the realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default"
" username and password for a URL. This will be supplied in the absence of"
" you providing an alternative combination for a specific realm. We "
"indicate this by providing ``None`` as the realm argument to the "
"``add_password`` method."
msgstr ""
"``HTTPBasicAuthHandler``\\는 비밀번호 관리자(password manager)라는 객체를 사용하여 URL과 "
"영역에서 비밀번호(password)와 사용자 이름(username)으로의 매핑을 처리합니다. (서버가 보낸 인증 헤더로부터) 영역이"
" 무엇인지 안다면, ``HTTPPasswordMgr``\\를 사용할 수 있습니다. 종종 영역이 무엇인지 상관하지 않습니다. 이 "
"경우, ``HTTPPasswordMgrWithDefaultRealm``\\를 사용하는 것이 편리합니다. 이것은 URL의 기본 사용자"
" 이름과 비밀번호를 지정할 수 있습니다. 특정 영역에 대한 대체 조합을 제공하지 않으면 이것이 제공됩니다. ``None``\\을 "
"``add_password`` 메서드에 대한 realm 인자로 제공하여 이를 나타냅니다."

#: ../../howto/urllib2.rst:483
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"최상위 URL은 인증이 필요한 첫 번째 URL입니다. .add_password()에 전달한 URL보다 \"더 깊은\" URL도 "
"일치합니다. ::"

#: ../../howto/urllib2.rst:486
msgid ""
"# create a password manager\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# Add the username and password.\n"
"# If we knew the realm, we could use it instead of None.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# create \"opener\" (OpenerDirector instance)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# use the opener to fetch a URL\n"
"opener.open(a_url)\n"
"\n"
"# Install the opener.\n"
"# Now all calls to urllib.request.urlopen use our opener.\n"
"urllib.request.install_opener(opener)"
msgstr ""
"# 비밀번호 관리자를 만듭니다\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# 사용자 이름과 비밀번호를 추가합니다.\n"
"# 영역을 알면, None 대신 사용할 수 있습니다.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# \"오프너(opener)\" (OpenerDirector 인스턴스)를 만듭니다\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# 오프너를 사용해서 URL을 가져옵니다\n"
"opener.open(a_url)\n"
"\n"
"# 오프너를 설치합니다.\n"
"# 이제 모든 urllib.request.urlopen 호출은 이 오프너를 사용합니다.\n"
"urllib.request.install_opener(opener)"

#: ../../howto/urllib2.rst:508
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal "
"situations -- ``ProxyHandler`` (if a proxy setting such as an "
":envvar:`!http_proxy` environment variable is set), ``UnknownHandler``, "
"``HTTPHandler``, ``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, "
"``FTPHandler``, ``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"위의 예에서 ``HTTPBasicAuthHandler`` 만 ``build_opener``\\에 제공했습니다. 기본적으로 오프너에는"
" 일반적인 상황을 위한 처리기가 있습니다 -- ``ProxyHandler`` (:envvar:`!http_proxy` 환경 변수와 "
"같은 프락시 설정이 설정된 경우), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."

#: ../../howto/urllib2.rst:515
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  "
"The authority, if present, must NOT contain the \"userinfo\" component - "
"for example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url``\\은 실제로 ('http:' 스킴 구성 요소와 호스트 이름 및 선택적인 포트 번호를 포함하는) 전체"
" URL, 예를 들어 ``\"http://example.com/\"`` *이거나* \"주체(authority)\" (즉, 선택적으로"
" 포트 번호를 포함하는 호스트명), 예를 들어 ``\"example.com\"``\\이나 "
"``\"example.com:8080\"`` (후자의 예는 포트 번호를 포함합니다)입니다. 주체가 있다면 \"userinfo\" "
"구성 요소를 포함하지 않아야 합니다 - 예를 들어 ``\"joe:password@example.com\"``\\은 올바르지 "
"않습니다."

#: ../../howto/urllib2.rst:525
msgid "Proxies"
msgstr "프락시"

#: ../../howto/urllib2.rst:527
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain "
"when a proxy setting is detected.  Normally that's a good thing, but "
"there are occasions when it may not be helpful [#]_. One way to do this "
"is to setup our own ``ProxyHandler``, with no proxies defined. This is "
"done using similar steps to setting up a `Basic Authentication`_ handler:"
" ::"
msgstr ""
"**urllib**\\는 프락시 설정을 자동 감지하여 사용합니다. 이는 프락시 설정이 감지될 때 일반 처리기 체인의 일부가 되는 "
"``ProxyHandler``\\를 통해 이루어집니다. 일반적으로 좋은 일이지만, 도움이 되지 않는 경우가 있습니다 [#]_. 이를"
" 위한 한 가지 방법은 프락시가 정의되지 않은 자체 ``ProxyHandler``\\를 설정하는 것입니다. 이것은 `Basic "
"Authentication`_ 처리기 설정과 비슷한 단계를 사용하여 수행됩니다: ::"

#: ../../howto/urllib2.rst:534
#, python-brace-format
msgid ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"
msgstr ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"

#: ../../howto/urllib2.rst:540
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending "
"urllib.request as shown in the recipe [#]_."
msgstr ""
"현재 ``urllib.request``\\는 프락시를 통한 ``https`` 위치를 가져오는 것을 지원하지 *않습니다*. 그러나, "
"조리법에 표시된 대로 urllib.request를 확장하여 활성화할 수 있습니다 [#]_."

#: ../../howto/urllib2.rst:546
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; "
"see the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"변수 ``REQUEST_METHOD``\\가 설정되면 ``HTTP_PROXY``\\는 무시됩니다; "
":func:`~urllib.request.getproxies`\\의 설명서를 참조하십시오."

#: ../../howto/urllib2.rst:551
msgid "Sockets and Layers"
msgstr "소켓과 계층"

#: ../../howto/urllib2.rst:553
msgid ""
"The Python support for fetching resources from the web is layered.  "
"urllib uses the :mod:`http.client` library, which in turn uses the socket"
" library."
msgstr ""
"웹에서 리소스를 가져오기 위한 파이썬 지원은 계층화되어 있습니다. urllib는 :mod:`http.client` 라이브러리를 "
"사용하고, 이것은 다시 socket 라이브러리를 사용합니다."

#: ../../howto/urllib2.rst:556
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have"
" to fetch web pages. By default the socket module has *no timeout* and "
"can hang. Currently, the socket timeout is not exposed at the http.client"
" or urllib.request levels. However, you can set the default timeout "
"globally for all sockets using ::"
msgstr ""
"파이썬 2.3부터 시간제한으로 중단되기 전에 소켓이 응답을 기다리는 시간을 지정할 수 있습니다. 웹 페이지를 가져와야 하는 응용 "
"프로그램에서 유용 할 수 있습니다. 기본적으로 소켓 모듈에는 *시간제한이 없고* 멈출(hang) 수 있습니다. 현재, 소켓 "
"시간제한은 http.client나 urllib.request 수준에서 노출되지 않습니다. 그러나, 다음과 같이 모든 소켓에 대해 "
"기본 시간제한을 전역적으로 설정할 수 있습니다 ::"

#: ../../howto/urllib2.rst:562
msgid ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout in seconds\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# this call to urllib.request.urlopen now uses the default timeout\n"
"# we have set in the socket module\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"
msgstr ""
"import socket\n"
"import urllib.request\n"
"\n"
"# 초 단위 시간제한\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# 이 urllib.request.urlopen 호출은 이제 우리가 socket 모듈에 설정한 기본\n"
"# 시간제한을 사용합니다\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"

#: ../../howto/urllib2.rst:579
msgid "Footnotes"
msgstr "각주"

#: ../../howto/urllib2.rst:581
msgid "This document was reviewed and revised by John Lee."
msgstr "이 문서는 John Lee가 검토하고 수정했습니다."

#: ../../howto/urllib2.rst:583
msgid "Google for example."
msgstr "예를 들어 구글."

#: ../../howto/urllib2.rst:584
msgid ""
"Browser sniffing is a very bad practice for website design - building "
"sites using web standards is much more sensible. Unfortunately a lot of "
"sites still send different versions to different browsers."
msgstr ""
"브라우저 스니핑(browser sniffing)은 웹 사이트 디자인에 매우 나쁜 습관입니다 - 웹 표준을 사용하여 사이트를 구축하는"
" 것이 훨씬 합리적입니다. 불행히도 많은 사이트가 여전히 브라우저마다 다른 버전을 보냅니다."

#: ../../howto/urllib2.rst:587
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows"
" NT 5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"MSIE 6의 사용자 에이전트(user agent)는 *'Mozilla/4.0 (compatible; MSIE 6.0; "
"Windows NT 5.1; SV1; .NET CLR 1.1.4322)'*\\입니다."

#: ../../howto/urllib2.rst:589
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr "더 많은 HTTP 요청 헤더에 대한 자세한 내용은 `Quick Reference to HTTP Headers`_\\를 참조하십시오."

#: ../../howto/urllib2.rst:591
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE "
"is set to use the proxy, which urllib picks up on. In order to test "
"scripts with a localhost server, I have to prevent urllib from using the "
"proxy."
msgstr ""
"제 경우에는 직장에서 인터넷에 액세스하려면 프락시를 사용해야 합니다. 이 프락시를 통해 *localhost* URL을 가져오려고 "
"시도하면 차단됩니다. IE는 프락시를 사용하도록 설정되어 있고, urllib는 이것을 선택합니다. localhost 서버로 "
"스크립트를 테스트하려면, urllib가 프락시를 사용하지 못하게 해야 합니다."

#: ../../howto/urllib2.rst:596
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-"
"proxy-connect-method/>`_."
msgstr ""
"SSL 프락시용 urllib 오프너 (CONNECT 메서드): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-"
"proxy-connect-method/>`_."

