# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/ipaddress.rst:9
msgid "An introduction to the ipaddress module"
msgstr "ipaddress 모듈에 대한 소개"

#: ../../howto/ipaddress.rst
msgid "author"
msgstr "저자"

#: ../../howto/ipaddress.rst:11
msgid "Peter Moody"
msgstr "Peter Moody"

#: ../../howto/ipaddress.rst:12
msgid "Nick Coghlan"
msgstr "Nick Coghlan"

#: ../../howto/ipaddress.rst:-1
msgid "Overview"
msgstr "개요"

#: ../../howto/ipaddress.rst:16
msgid ""
"This document aims to provide a gentle introduction to the "
":mod:`ipaddress` module. It is aimed primarily at users that aren't "
"already familiar with IP networking terminology, but may also be useful "
"to network engineers wanting an overview of how :mod:`ipaddress` "
"represents IP network addressing concepts."
msgstr ""
"이 문서에서는 :mod:`ipaddress` 모듈을 간략하게 소개하고자 합니다. 주로 IP 네트워킹 용어에 익숙하지 않은 사용자를 "
"대상으로 하지만, :mod:`ipaddress`\\가 IP 네트워크 주소 개념을 나타내는 방식에 대한 개요를 원하는 네트워크 "
"엔지니어에게 유용할 수도 있습니다."

#: ../../howto/ipaddress.rst:24
msgid "Creating Address/Network/Interface objects"
msgstr "주소/네트워크/인터페이스 객체 만들기"

#: ../../howto/ipaddress.rst:26
msgid ""
"Since :mod:`ipaddress` is a module for inspecting and manipulating IP "
"addresses, the first thing you'll want to do is create some objects.  You"
" can use :mod:`ipaddress` to create objects from strings and integers."
msgstr ""
":mod:`ipaddress`\\는 IP 주소를 검사하고 조작하는 모듈이기 때문에, 가장 먼저 하고 싶어 할 일은 몇몇 객체를 "
"만드는 것입니다. :mod:`ipaddress`\\를 사용하여 문자열과 정수로 객체를 만들 수 있습니다."

#: ../../howto/ipaddress.rst:32
msgid "A Note on IP Versions"
msgstr "IP 버전에 대한 참고 사항"

#: ../../howto/ipaddress.rst:34
msgid ""
"For readers that aren't particularly familiar with IP addressing, it's "
"important to know that the Internet Protocol (IP) is currently in the "
"process of moving from version 4 of the protocol to version 6. This "
"transition is occurring largely because version 4 of the protocol doesn't"
" provide enough addresses to handle the needs of the whole world, "
"especially given the increasing number of devices with direct connections"
" to the internet."
msgstr ""
"특히 IP 주소 지정에 익숙하지 않은 독자는, 인터넷 프로토콜(IP)이 현재 프로토콜 버전 4에서 버전 6으로 이동하는 과정에 "
"있음을 아는 것이 중요합니다. 이러한 전환은 주로 프로토콜 버전 4가 전 세계의 요구 사항을 처리할 수 있는 충분한 주소를 제공하지"
" 못하기 때문에 발생하고 있습니다. 특히 인터넷에 직접 연결되는 장치의 수가 증가함에 따라 더욱더 그렇습니다."

#: ../../howto/ipaddress.rst:41
msgid ""
"Explaining the details of the differences between the two versions of the"
" protocol is beyond the scope of this introduction, but readers need to "
"at least be aware that these two versions exist, and it will sometimes be"
" necessary to force the use of one version or the other."
msgstr ""
"프로토콜의 두 버전 간의 차이점에 대한 자세한 설명은 이 소개의 범위를 벗어나지만, 독자는 최소한 이 두 버전이 존재한다는 사실을 "
"알고 있어야 하며, 때로는 한 버전이나 다른 버전을 강제로 사용해야 할 필요가 있습니다."

#: ../../howto/ipaddress.rst:48
msgid "IP Host Addresses"
msgstr "IP 호스트 주소"

#: ../../howto/ipaddress.rst:50
msgid ""
"Addresses, often referred to as \"host addresses\" are the most basic "
"unit when working with IP addressing. The simplest way to create "
"addresses is to use the :func:`ipaddress.ip_address` factory function, "
"which automatically determines whether to create an IPv4 or IPv6 address "
"based on the passed in value:"
msgstr ""
"주소, 종종 \"호스트 주소\" 라고 하는 것은 IP 주소 지정으로 작업할 때 가장 기본 단위입니다. 주소를 만드는 가장 간단한 "
"방법은 :func:`ipaddress.ip_address` 팩토리 함수를 사용하는 것인데, 전달된 값을 기반으로 IPv4나 IPv6"
" 주소 중 어느 것을 만들지 자동으로 결정합니다:"

#: ../../howto/ipaddress.rst:61
msgid ""
"Addresses can also be created directly from integers. Values that will "
"fit within 32 bits are assumed to be IPv4 addresses::"
msgstr "주소는 정수에서 직접 만들 수도 있습니다. 32비트에 들어맞는 값은 IPv4 주소로 간주합니다::"

#: ../../howto/ipaddress.rst:64
msgid ""
">>> ipaddress.ip_address(3221225985)\n"
"IPv4Address('192.0.2.1')\n"
">>> ipaddress.ip_address(42540766411282592856903984951653826561)\n"
"IPv6Address('2001:db8::1')"
msgstr ""
">>> ipaddress.ip_address(3221225985)\n"
"IPv4Address('192.0.2.1')\n"
">>> ipaddress.ip_address(42540766411282592856903984951653826561)\n"
"IPv6Address('2001:db8::1')"

#: ../../howto/ipaddress.rst:69
msgid ""
"To force the use of IPv4 or IPv6 addresses, the relevant classes can be "
"invoked directly. This is particularly useful to force creation of IPv6 "
"addresses for small integers::"
msgstr ""
"IPv4나 IPv6 주소를 강제로 사용하려면, 해당 클래스를 직접 호출할 수 있습니다. 이것은 작은 정수를 위한 IPv6 주소 "
"생성을 강제하는 데 특히 유용합니다::"

#: ../../howto/ipaddress.rst:73
msgid ""
">>> ipaddress.ip_address(1)\n"
"IPv4Address('0.0.0.1')\n"
">>> ipaddress.IPv4Address(1)\n"
"IPv4Address('0.0.0.1')\n"
">>> ipaddress.IPv6Address(1)\n"
"IPv6Address('::1')"
msgstr ""
">>> ipaddress.ip_address(1)\n"
"IPv4Address('0.0.0.1')\n"
">>> ipaddress.IPv4Address(1)\n"
"IPv4Address('0.0.0.1')\n"
">>> ipaddress.IPv6Address(1)\n"
"IPv6Address('::1')"

#: ../../howto/ipaddress.rst:82
msgid "Defining Networks"
msgstr "네트워크 정의"

#: ../../howto/ipaddress.rst:84
msgid ""
"Host addresses are usually grouped together into IP networks, so "
":mod:`ipaddress` provides a way to create, inspect and manipulate network"
" definitions. IP network objects are constructed from strings that define"
" the range of host addresses that are part of that network. The simplest "
"form for that information is a \"network address/network prefix\" pair, "
"where the prefix defines the number of leading bits that are compared to "
"determine whether or not an address is part of the network and the "
"network address defines the expected value of those bits."
msgstr ""
"호스트 주소는 대개 IP 네트워크로 그룹화되므로, :mod:`ipaddress`\\는 네트워크 정의를 만들고, 검사하고, 조작할 "
"방법을 제공합니다. IP 네트워크 객체는 해당 네트워크의 일부인 호스트 주소의 범위를 정의하는 문자열로 만들어집니다. 이 정보의 "
"가장 간단한 형식은 \"네트워크 주소/네트워크 접두사\" 쌍입니다. 접두어는 주소가 네트워크 일부인지 판별하기 위해 비교되는 선행 "
"비트 수를 정의하고, 네트워크 주소는 그 비트들의 기대되는 값을 정의합니다."

#: ../../howto/ipaddress.rst:93
msgid ""
"As for addresses, a factory function is provided that determines the "
"correct IP version automatically::"
msgstr "주소의 경우, 정확한 IP 버전을 자동으로 결정하는 팩토리 함수가 제공됩니다::"

#: ../../howto/ipaddress.rst:96
msgid ""
">>> ipaddress.ip_network('192.0.2.0/24')\n"
"IPv4Network('192.0.2.0/24')\n"
">>> ipaddress.ip_network('2001:db8::0/96')\n"
"IPv6Network('2001:db8::/96')"
msgstr ""
">>> ipaddress.ip_network('192.0.2.0/24')\n"
"IPv4Network('192.0.2.0/24')\n"
">>> ipaddress.ip_network('2001:db8::0/96')\n"
"IPv6Network('2001:db8::/96')"

#: ../../howto/ipaddress.rst:101
msgid ""
"Network objects cannot have any host bits set.  The practical effect of "
"this is that ``192.0.2.1/24`` does not describe a network.  Such "
"definitions are referred to as interface objects since the ip-"
"on-a-network notation is commonly used to describe network interfaces of "
"a computer on a given network and are described further in the next "
"section."
msgstr ""
"네트워크 객체는 호스트 비트가 설정될 수 없습니다. 이것의 실제 효과는 ``192.0.2.1/24``\\가 네트워크를 설명하지 "
"않는다는 것입니다. 이러한 정의는 인터페이스 객체라고 불리는데, 그 이유는 주어진 네트워크상의 컴퓨터의 네트워크 인터페이스를 "
"기술하기 위해 네트워크상의 IP(ip-on-a-network) 표기법이 일반적으로 사용되기 때문입니다. 자세한 내용은 다음 절에서 "
"설명합니다."

#: ../../howto/ipaddress.rst:107
msgid ""
"By default, attempting to create a network object with host bits set will"
" result in :exc:`ValueError` being raised. To request that the additional"
" bits instead be coerced to zero, the flag ``strict=False`` can be passed"
" to the constructor::"
msgstr ""
"기본적으로, 호스트 비트가 설정된 네트워크 객체를 만들려고 하면 :exc:`ValueError`\\가 발생합니다. 추가 비트를 "
"강제로 0으로 변환하도록 요청하려면, 플래그 ``strict=False``\\를 생성자에 전달할 수 있습니다::"

#: ../../howto/ipaddress.rst:112
msgid ""
">>> ipaddress.ip_network('192.0.2.1/24')\n"
"Traceback (most recent call last):\n"
"   ...\n"
"ValueError: 192.0.2.1/24 has host bits set\n"
">>> ipaddress.ip_network('192.0.2.1/24', strict=False)\n"
"IPv4Network('192.0.2.0/24')"
msgstr ""
">>> ipaddress.ip_network('192.0.2.1/24')\n"
"Traceback (most recent call last):\n"
"   ...\n"
"ValueError: 192.0.2.1/24 has host bits set\n"
">>> ipaddress.ip_network('192.0.2.1/24', strict=False)\n"
"IPv4Network('192.0.2.0/24')"

#: ../../howto/ipaddress.rst:119
msgid ""
"While the string form offers significantly more flexibility, networks can"
" also be defined with integers, just like host addresses. In this case, "
"the network is considered to contain only the single address identified "
"by the integer, so the network prefix includes the entire network "
"address::"
msgstr ""
"문자열 형식은 유연성이 훨씬 뛰어나지만, 호스트 주소와 마찬가지로 정수로 네트워크를 정의할 수도 있습니다. 이 경우, 네트워크는 "
"정수로 식별되는 단일 주소만 포함하는 것으로 간주하므로, 네트워크 접두사는 전체 네트워크 주소를 포함합니다::"

#: ../../howto/ipaddress.rst:124
msgid ""
">>> ipaddress.ip_network(3221225984)\n"
"IPv4Network('192.0.2.0/32')\n"
">>> ipaddress.ip_network(42540766411282592856903984951653826560)\n"
"IPv6Network('2001:db8::/128')"
msgstr ""
">>> ipaddress.ip_network(3221225984)\n"
"IPv4Network('192.0.2.0/32')\n"
">>> ipaddress.ip_network(42540766411282592856903984951653826560)\n"
"IPv6Network('2001:db8::/128')"

#: ../../howto/ipaddress.rst:129
msgid ""
"As with addresses, creation of a particular kind of network can be forced"
" by calling the class constructor directly instead of using the factory "
"function."
msgstr "주소와 마찬가지로, 팩토리 함수를 사용하는 대신 클래스 생성자를 직접 호출하여 특정 종류의 네트워크를 만들 수 있습니다."

#: ../../howto/ipaddress.rst:135
msgid "Host Interfaces"
msgstr "호스트 인터페이스"

#: ../../howto/ipaddress.rst:137
msgid ""
"As mentioned just above, if you need to describe an address on a "
"particular network, neither the address nor the network classes are "
"sufficient. Notation like ``192.0.2.1/24`` is commonly used by network "
"engineers and the people who write tools for firewalls and routers as "
"shorthand for \"the host ``192.0.2.1`` on the network ``192.0.2.0/24``\","
" Accordingly, :mod:`ipaddress` provides a set of hybrid classes that "
"associate an address with a particular network. The interface for "
"creation is identical to that for defining network objects, except that "
"the address portion isn't constrained to being a network address."
msgstr ""
"위에서 언급했듯이, 특정 네트워크상의 주소를 설명해야 하는 경우, 주소로도 네트워크 클래스로도 충분하지 않습니다. "
"``192.0.2.1/24``\\와 같은 표기법은 네트워크 엔지니어와 방화벽과 라우터 용 도구를 작성하는 사람들이 \"네트워크 "
"``192.0.2.0/24`` 상의 호스트 ``192.0.2.1``\\\" 의 줄임말로 많이 사용합니다. 따라서, "
":mod:`ipaddress`\\는 주소를 특정 네트워크와 결합하는 혼성 클래스 집합을 제공합니다. 생성을 위한 인터페이스는 주소 "
"부분이 네트워크 주소로 제한되지 않는 것을 제외하고는 네트워크 객체를 정의하는 것과 같습니다."

#: ../../howto/ipaddress.rst:152
msgid ""
"Integer inputs are accepted (as with networks), and use of a particular "
"IP version can be forced by calling the relevant constructor directly."
msgstr "정수 입력이 받아들여지고 (네트워크처럼), 특정 IP 버전의 사용은 관련 생성자를 직접 호출함으로써 강제될 수 있습니다."

#: ../../howto/ipaddress.rst:157
msgid "Inspecting Address/Network/Interface Objects"
msgstr "주소/네트워크/인터페이스 객체 검사"

#: ../../howto/ipaddress.rst:159
msgid ""
"You've gone to the trouble of creating an "
"IPv(4|6)(Address|Network|Interface) object, so you probably want to get "
"information about it.  :mod:`ipaddress` tries to make doing this easy and"
" intuitive."
msgstr ""
"여러분은 IPv(4|6)(Address|Network|Interface) 객체를 만드는 데 어려움을 겪었다면, 아마도 이에 대한 "
"정보를 얻고 자 할 것입니다. :mod:`ipaddress`\\는 이 작업을 쉽고 직관적으로 만들려고 합니다."

#: ../../howto/ipaddress.rst:163
msgid "Extracting the IP version::"
msgstr "IP 버전 추출하기::"

#: ../../howto/ipaddress.rst:165
msgid ""
">>> addr4 = ipaddress.ip_address('192.0.2.1')\n"
">>> addr6 = ipaddress.ip_address('2001:db8::1')\n"
">>> addr6.version\n"
"6\n"
">>> addr4.version\n"
"4"
msgstr ""
">>> addr4 = ipaddress.ip_address('192.0.2.1')\n"
">>> addr6 = ipaddress.ip_address('2001:db8::1')\n"
">>> addr6.version\n"
"6\n"
">>> addr4.version\n"
"4"

#: ../../howto/ipaddress.rst:172
msgid "Obtaining the network from an interface::"
msgstr "인터페이스에서 네트워크 얻기::"

#: ../../howto/ipaddress.rst:174
msgid ""
">>> host4 = ipaddress.ip_interface('192.0.2.1/24')\n"
">>> host4.network\n"
"IPv4Network('192.0.2.0/24')\n"
">>> host6 = ipaddress.ip_interface('2001:db8::1/96')\n"
">>> host6.network\n"
"IPv6Network('2001:db8::/96')"
msgstr ""
">>> host4 = ipaddress.ip_interface('192.0.2.1/24')\n"
">>> host4.network\n"
"IPv4Network('192.0.2.0/24')\n"
">>> host6 = ipaddress.ip_interface('2001:db8::1/96')\n"
">>> host6.network\n"
"IPv6Network('2001:db8::/96')"

#: ../../howto/ipaddress.rst:181
msgid "Finding out how many individual addresses are in a network::"
msgstr "네트워크에 있는 개별 주소의 개수 찾기::"

#: ../../howto/ipaddress.rst:183
msgid ""
">>> net4 = ipaddress.ip_network('192.0.2.0/24')\n"
">>> net4.num_addresses\n"
"256\n"
">>> net6 = ipaddress.ip_network('2001:db8::0/96')\n"
">>> net6.num_addresses\n"
"4294967296"
msgstr ""
">>> net4 = ipaddress.ip_network('192.0.2.0/24')\n"
">>> net4.num_addresses\n"
"256\n"
">>> net6 = ipaddress.ip_network('2001:db8::0/96')\n"
">>> net6.num_addresses\n"
"4294967296"

#: ../../howto/ipaddress.rst:190
msgid "Iterating through the \"usable\" addresses on a network::"
msgstr "네트워크에서 \"사용 가능한\" 주소 이터레이트하기::"

#: ../../howto/ipaddress.rst:192
msgid ""
">>> net4 = ipaddress.ip_network('192.0.2.0/24')\n"
">>> for x in net4.hosts():\n"
"...     print(x)\n"
"192.0.2.1\n"
"192.0.2.2\n"
"192.0.2.3\n"
"192.0.2.4\n"
"...\n"
"192.0.2.252\n"
"192.0.2.253\n"
"192.0.2.254"
msgstr ""
">>> net4 = ipaddress.ip_network('192.0.2.0/24')\n"
">>> for x in net4.hosts():\n"
"...     print(x)\n"
"192.0.2.1\n"
"192.0.2.2\n"
"192.0.2.3\n"
"192.0.2.4\n"
"...\n"
"192.0.2.252\n"
"192.0.2.253\n"
"192.0.2.254"

#: ../../howto/ipaddress.rst:205
msgid ""
"Obtaining the netmask (i.e. set bits corresponding to the network prefix)"
" or the hostmask (any bits that are not part of the netmask):"
msgstr ""
"넷 마스크(netmask)(즉, 네트워크 접두사에 해당하는 비트들)나 호스트 마스크(hostmask)(넷 마스크에 포함되지 않은 "
"비트들) 얻기:"

#: ../../howto/ipaddress.rst:220
msgid "Exploding or compressing the address::"
msgstr "주소를 펼치거나 압축하기::"

#: ../../howto/ipaddress.rst:222
msgid ""
">>> addr6.exploded\n"
"'2001:0db8:0000:0000:0000:0000:0000:0001'\n"
">>> addr6.compressed\n"
"'2001:db8::1'\n"
">>> net6.exploded\n"
"'2001:0db8:0000:0000:0000:0000:0000:0000/96'\n"
">>> net6.compressed\n"
"'2001:db8::/96'"
msgstr ""
">>> addr6.exploded\n"
"'2001:0db8:0000:0000:0000:0000:0000:0001'\n"
">>> addr6.compressed\n"
"'2001:db8::1'\n"
">>> net6.exploded\n"
"'2001:0db8:0000:0000:0000:0000:0000:0000/96'\n"
">>> net6.compressed\n"
"'2001:db8::/96'"

#: ../../howto/ipaddress.rst:231
msgid ""
"While IPv4 doesn't support explosion or compression, the associated "
"objects still provide the relevant properties so that version neutral "
"code can easily ensure the most concise or most verbose form is used for "
"IPv6 addresses while still correctly handling IPv4 addresses."
msgstr ""
"IPv4는 펼치기와 압축을 지원하지 않지만, 연관된 객체는 여전히 관련 프로퍼티를 제공하므로 버전 중립적인 코드가 IPv4 주소를 "
"올바르게 처리하면서도 IPv6 주소에 대해 가장 간결하거나 가장 자세한 형식을 쉽게 사용할 수 있습니다."

#: ../../howto/ipaddress.rst:238
msgid "Networks as lists of Addresses"
msgstr "주소 리스트로서의 네트워크"

#: ../../howto/ipaddress.rst:240
msgid ""
"It's sometimes useful to treat networks as lists.  This means it is "
"possible to index them like this::"
msgstr "네트워크를 리스트로 취급하는 것이 때로 유용합니다. 즉, 다음과 같이 인덱싱할 수 있습니다::"

#: ../../howto/ipaddress.rst:243
msgid ""
">>> net4[1]\n"
"IPv4Address('192.0.2.1')\n"
">>> net4[-1]\n"
"IPv4Address('192.0.2.255')\n"
">>> net6[1]\n"
"IPv6Address('2001:db8::1')\n"
">>> net6[-1]\n"
"IPv6Address('2001:db8::ffff:ffff')"
msgstr ""
">>> net4[1]\n"
"IPv4Address('192.0.2.1')\n"
">>> net4[-1]\n"
"IPv4Address('192.0.2.255')\n"
">>> net6[1]\n"
"IPv6Address('2001:db8::1')\n"
">>> net6[-1]\n"
"IPv6Address('2001:db8::ffff:ffff')"

#: ../../howto/ipaddress.rst:253
msgid ""
"It also means that network objects lend themselves to using the list "
"membership test syntax like this::"
msgstr "이것은 또한 네트워크 객체가 다음과 같은 리스트 멤버십 테스트 문법을 사용하는 데 적합하다는 것을 의미합니다::"

#: ../../howto/ipaddress.rst:256
msgid ""
"if address in network:\n"
"    # do something"
msgstr ""
"if address in network:\n"
"    # 뭔가 합니다"

#: ../../howto/ipaddress.rst:259
msgid "Containment testing is done efficiently based on the network prefix::"
msgstr "포함 테스트는 네트워크 접두어를 기반으로 효율적으로 수행됩니다::"

#: ../../howto/ipaddress.rst:261
msgid ""
">>> addr4 = ipaddress.ip_address('192.0.2.1')\n"
">>> addr4 in ipaddress.ip_network('192.0.2.0/24')\n"
"True\n"
">>> addr4 in ipaddress.ip_network('192.0.3.0/24')\n"
"False"
msgstr ""
">>> addr4 = ipaddress.ip_address('192.0.2.1')\n"
">>> addr4 in ipaddress.ip_network('192.0.2.0/24')\n"
"True\n"
">>> addr4 in ipaddress.ip_network('192.0.3.0/24')\n"
"False"

#: ../../howto/ipaddress.rst:269
msgid "Comparisons"
msgstr "비교"

#: ../../howto/ipaddress.rst:271
msgid ""
":mod:`ipaddress` provides some simple, hopefully intuitive ways to "
"compare objects, where it makes sense::"
msgstr ":mod:`ipaddress`\\는 의미가 있는 곳에서 객체를 비교하는 간단하고 직관적인 방법을 제공합니다::"

#: ../../howto/ipaddress.rst:274
msgid ""
">>> ipaddress.ip_address('192.0.2.1') < ipaddress.ip_address('192.0.2.2')"
"\n"
"True"
msgstr ""
">>> ipaddress.ip_address('192.0.2.1') < ipaddress.ip_address('192.0.2.2')"
"\n"
"True"

#: ../../howto/ipaddress.rst:277
msgid ""
"A :exc:`TypeError` exception is raised if you try to compare objects of "
"different versions or different types."
msgstr "다른 버전이나 다른 형의 객체를 비교하려고 하면 :exc:`TypeError` 예외가 발생합니다."

#: ../../howto/ipaddress.rst:282
msgid "Using IP Addresses with other modules"
msgstr "다른 모듈과 함께 IP 주소 사용하기"

#: ../../howto/ipaddress.rst:284
msgid ""
"Other modules that use IP addresses (such as :mod:`socket`) usually won't"
" accept objects from this module directly. Instead, they must be coerced "
"to an integer or string that the other module will accept::"
msgstr ""
"IP 주소를 사용하는 다른 모듈(가령 :mod:`socket`)은 일반적으로 이 모듈의 객체를 직접 받아들이지 않습니다. 대신, "
"다른 모듈이 받아들일 수 있는 정수나 문자열로 강제 변환되어야 합니다::"

#: ../../howto/ipaddress.rst:288
msgid ""
">>> addr4 = ipaddress.ip_address('192.0.2.1')\n"
">>> str(addr4)\n"
"'192.0.2.1'\n"
">>> int(addr4)\n"
"3221225985"
msgstr ""
">>> addr4 = ipaddress.ip_address('192.0.2.1')\n"
">>> str(addr4)\n"
"'192.0.2.1'\n"
">>> int(addr4)\n"
"3221225985"

#: ../../howto/ipaddress.rst:296
msgid "Getting more detail when instance creation fails"
msgstr "인스턴스 생성 실패 시 세부 사항 가져오기"

#: ../../howto/ipaddress.rst:298
msgid ""
"When creating address/network/interface objects using the version-"
"agnostic factory functions, any errors will be reported as "
":exc:`ValueError` with a generic error message that simply says the "
"passed in value was not recognized as an object of that type. The lack of"
" a specific error is because it's necessary to know whether the value is "
"*supposed* to be IPv4 or IPv6 in order to provide more detail on why it "
"has been rejected."
msgstr ""
"버전에 구애받지 않는 팩토리 함수를 사용하여 주소/네트워크/인터페이스 객체를 만들 때, 단순히 전달된 값이 해당 형의 객체로 "
"인식되지 않는다는 일반 에러 메시지와 함께 에러가 :exc:`ValueError`\\로 보고됩니다. 구체적인 에러가 없는 이유는 "
"거부된 이유에 대한 자세한 정보를 제공하기 위해서는 값이 IPv4나 IPv6 중 어는 것으로 *가정되는지*\\를 알아야 하기 "
"때문입니다."

#: ../../howto/ipaddress.rst:305
msgid ""
"To support use cases where it is useful to have access to this additional"
" detail, the individual class constructors actually raise the "
":exc:`ValueError` subclasses :exc:`ipaddress.AddressValueError` and "
":exc:`ipaddress.NetmaskValueError` to indicate exactly which part of the "
"definition failed to parse correctly."
msgstr ""
"이 추가 세부 정보를 액세스하는 것이 유용한 사용 사례를 지원하기 위해, 개별 클래스 생성자는 실제로 "
":exc:`ValueError` 서브 클래스 :exc:`ipaddress.AddressValueError`\\와 "
":exc:`ipaddress.NetmaskValueError`\\를 발생시켜 정의의 어느 부분에서 구문 분석하는 데 실패했는지 "
"정확히 가리킵니다."

#: ../../howto/ipaddress.rst:311
msgid ""
"The error messages are significantly more detailed when using the class "
"constructors directly. For example::"
msgstr "에러 메시지는 클래스 생성자를 직접 사용할 때 훨씬 자세해집니다. 예를 들어::"

#: ../../howto/ipaddress.rst:314
msgid ""
">>> ipaddress.ip_address(\"192.168.0.256\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: '192.168.0.256' does not appear to be an IPv4 or IPv6 address"
"\n"
">>> ipaddress.IPv4Address(\"192.168.0.256\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ipaddress.AddressValueError: Octet 256 (> 255) not permitted in "
"'192.168.0.256'\n"
"\n"
">>> ipaddress.ip_network(\"192.168.0.1/64\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: '192.168.0.1/64' does not appear to be an IPv4 or IPv6 "
"network\n"
">>> ipaddress.IPv4Network(\"192.168.0.1/64\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ipaddress.NetmaskValueError: '64' is not a valid netmask"
msgstr ""
">>> ipaddress.ip_address(\"192.168.0.256\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: '192.168.0.256' does not appear to be an IPv4 or IPv6 address"
"\n"
">>> ipaddress.IPv4Address(\"192.168.0.256\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ipaddress.AddressValueError: Octet 256 (> 255) not permitted in "
"'192.168.0.256'\n"
"\n"
">>> ipaddress.ip_network(\"192.168.0.1/64\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: '192.168.0.1/64' does not appear to be an IPv4 or IPv6 "
"network\n"
">>> ipaddress.IPv4Network(\"192.168.0.1/64\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ipaddress.NetmaskValueError: '64' is not a valid netmask"

#: ../../howto/ipaddress.rst:332
msgid ""
"However, both of the module specific exceptions have :exc:`ValueError` as"
" their parent class, so if you're not concerned with the particular type "
"of error, you can still write code like the following::"
msgstr ""
"그러나, 두 모듈 특정 예외 모두 부모 클래스로 :exc:`ValueError`\\를 가지므로, 특정 유형의 에러에 관심이 없다면,"
" 여전히 다음과 같은 코드를 작성할 수 있습니다::"

#: ../../howto/ipaddress.rst:336
msgid ""
"try:\n"
"    network = ipaddress.IPv4Network(address)\n"
"except ValueError:\n"
"    print('address/netmask is invalid for IPv4:', address)"
msgstr ""
"try:\n"
"    network = ipaddress.IPv4Network(address)\n"
"except ValueError:\n"
"    print('address/netmask is invalid for IPv4:', address)"

