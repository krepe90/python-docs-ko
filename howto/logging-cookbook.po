# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "로깅 요리책"

#: ../../howto/logging-cookbook.rst
msgid "Author"
msgstr "저자"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
#, fuzzy
msgid ""
"This page contains a number of recipes related to logging, which have "
"been found useful in the past. For links to tutorial and reference "
"information, please see :ref:`cookbook-ref-links`."
msgstr "이 페이지는 과거에 유용했던 로깅 관련 조리법을 많이 포함하고 있습니다."

#: ../../howto/logging-cookbook.rst:16
msgid "Using logging in multiple modules"
msgstr "여러 모듈에서 로깅 사용하기"

#: ../../howto/logging-cookbook.rst:18
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference "
"to the same logger object.  This is true not only within the same module,"
" but also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module "
"and create (but not configure) a child logger in a separate module, and "
"all logger calls to the child will pass up to the parent.  Here is a main"
" module::"
msgstr ""
"``logging.getLogger('someLogger')`` 를 여러 번 호출하면 같은 로거 객체에 대한 참조가 반환됩니다. "
"같은 모듈 내에서뿐만 아니라, 같은 파이썬 인터프리터 프로세스에 있는 한, 여러 모듈에서도 마찬가지입니다. 참조가 같은 객체를 "
"가리킨다는 것에 더해, 응용 프로그램 코드는 하나의 모듈에서 부모 로거를 정의 및 구성하고 별도의 모듈에서 자식 로거를 생성 "
"(구성하지 않음) 할 수 있으며, 자식에 대한 모든 로거 호출은 부모로 전달됩니다. 다음은 메인 모듈입니다::"

#: ../../howto/logging-cookbook.rst:26
#, python-format
msgid ""
"import logging\n"
"import auxiliary_module\n"
"\n"
"# create logger with 'spam_application'\n"
"logger = logging.getLogger('spam_application')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"fh.setFormatter(formatter)\n"
"ch.setFormatter(formatter)\n"
"# add the handlers to the logger\n"
"logger.addHandler(fh)\n"
"logger.addHandler(ch)\n"
"\n"
"logger.info('creating an instance of auxiliary_module.Auxiliary')\n"
"a = auxiliary_module.Auxiliary()\n"
"logger.info('created an instance of auxiliary_module.Auxiliary')\n"
"logger.info('calling auxiliary_module.Auxiliary.do_something')\n"
"a.do_something()\n"
"logger.info('finished auxiliary_module.Auxiliary.do_something')\n"
"logger.info('calling auxiliary_module.some_function()')\n"
"auxiliary_module.some_function()\n"
"logger.info('done with auxiliary_module.some_function()')"
msgstr ""

#: ../../howto/logging-cookbook.rst:56
msgid "Here is the auxiliary module::"
msgstr "다음은 보조 모듈입니다::"

#: ../../howto/logging-cookbook.rst:58
msgid ""
"import logging\n"
"\n"
"# create logger\n"
"module_logger = logging.getLogger('spam_application.auxiliary')\n"
"\n"
"class Auxiliary:\n"
"    def __init__(self):\n"
"        self.logger = "
"logging.getLogger('spam_application.auxiliary.Auxiliary')\n"
"        self.logger.info('creating an instance of Auxiliary')\n"
"\n"
"    def do_something(self):\n"
"        self.logger.info('doing something')\n"
"        a = 1 + 1\n"
"        self.logger.info('done doing something')\n"
"\n"
"def some_function():\n"
"    module_logger.info('received a call to \"some_function\"')"
msgstr ""

#: ../../howto/logging-cookbook.rst:76
msgid "The output looks like this:"
msgstr "출력은 이렇게 됩니다:"

#: ../../howto/logging-cookbook.rst:78
msgid ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   creating an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   creating an instance of Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   created an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   calling auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   doing something\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   done doing something\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   finished auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   calling auxiliary_module.some_function()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -\n"
"   received a call to 'some_function'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   done with auxiliary_module.some_function()"
msgstr ""

#: ../../howto/logging-cookbook.rst:102
msgid "Logging from multiple threads"
msgstr "여러 스레드에서 로깅 하기"

#: ../../howto/logging-cookbook.rst:104
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"여러 스레드에서 로깅 하는데 특별한 노력이 필요하지는 않습니다. 다음 예제에서는 메인 (최초) 스레드와 다른 스레드에서의 로깅을 "
"보여줍니다::"

#: ../../howto/logging-cookbook.rst:107
#, python-brace-format, python-format
msgid ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def worker(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Hi from myfunc')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d"
" %(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=worker, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Hello from main')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:133
msgid "When run, the script should print something like the following:"
msgstr "실행하면 스크립트는 다음과 같이 인쇄합니다:"

#: ../../howto/logging-cookbook.rst:135
msgid ""
"   0 Thread-1 Hi from myfunc\n"
"   3 MainThread Hello from main\n"
" 505 Thread-1 Hi from myfunc\n"
" 755 MainThread Hello from main\n"
"1007 Thread-1 Hi from myfunc\n"
"1507 MainThread Hello from main\n"
"1508 Thread-1 Hi from myfunc\n"
"2010 Thread-1 Hi from myfunc\n"
"2258 MainThread Hello from main\n"
"2512 Thread-1 Hi from myfunc\n"
"3009 MainThread Hello from main\n"
"3013 Thread-1 Hi from myfunc\n"
"3515 Thread-1 Hi from myfunc\n"
"3761 MainThread Hello from main\n"
"4017 Thread-1 Hi from myfunc\n"
"4513 MainThread Hello from main\n"
"4518 Thread-1 Hi from myfunc"
msgstr ""

#: ../../howto/logging-cookbook.rst:155
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr "예상대로 로그 출력이 산재해 있음을 볼 수 있습니다. 물론, 이 방법은 여기에 표시된 것보다 많은 스레드에서도 작동합니다."

#: ../../howto/logging-cookbook.rst:159
msgid "Multiple handlers and formatters"
msgstr "다중 처리기 및 포매터"

#: ../../howto/logging-cookbook.rst:161
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method "
"has no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of"
" all severities to a text file while simultaneously logging errors or "
"above to the console.  To set this up, simply configure the appropriate "
"handlers.  The logging calls in the application code will remain "
"unchanged.  Here is a slight modification to the previous simple module-"
"based configuration example::"
msgstr ""
"로거는 일반 파이썬 객체입니다. :meth:`~Logger.addHandler` 메서드에는 추가할 수 있는 처리기의 수에 대한 최소"
" 또는 최대 할당량이 없습니다. 때로는 응용 프로그램이 모든 심각도의 모든 메시지를 텍스트 파일에 기록하는 동시에, 에러 또는 그 "
"이상을 콘솔에 기록하는 것이 유용 할 수 있습니다. 이렇게 설정하려면, 적절한 처리기를 구성하기만 하면 됩니다. 응용 프로그램 "
"코드의 로깅 호출은 변경되지 않습니다. 다음은 앞의 간단한 모듈 기반 구성 예제를 약간 수정 한 것입니다::"

#: ../../howto/logging-cookbook.rst:169
#, python-format
msgid ""
"import logging\n"
"\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"ch.setFormatter(formatter)\n"
"fh.setFormatter(formatter)\n"
"# add the handlers to logger\n"
"logger.addHandler(ch)\n"
"logger.addHandler(fh)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""

#: ../../howto/logging-cookbook.rst:194
msgid ""
"Notice that the 'application' code does not care about multiple handlers."
"  All that changed was the addition and configuration of a new handler "
"named *fh*."
msgstr "'응용 프로그램' 코드는 여러 처리기에 신경 쓰지 않습니다. 변경된 것은 *fh* 라는 새로운 처리기의 추가 및 구성뿐입니다."

#: ../../howto/logging-cookbook.rst:197
msgid ""
"The ability to create new handlers with higher- or lower-severity filters"
" can be very helpful when writing and testing an application.  Instead of"
" using many ``print`` statements for debugging, use ``logger.debug``: "
"Unlike the print statements, which you will have to delete or comment out"
" later, the logger.debug statements can remain intact in the source code "
"and remain dormant until you need them again.  At that time, the only "
"change that needs to happen is to modify the severity level of the logger"
" and/or handler to debug."
msgstr ""
"중요도가 높거나 낮은 필터를 사용하여 새 처리기를 만드는 기능은 응용 프로그램을 작성하고 테스트할 때 매우 유용합니다. 디버깅을 "
"위해 많은 ``print`` 문을 사용하는 대신에 ``logger.debug`` 를 사용하십시오: 나중에 삭제하거나 주석 처리해야 "
"할 print 문과 달리, logger.debug 문은 소스 코드에서 그대로 유지될 수 있고, 그들을 다시 필요로 할 때까지 휴면 "
"상태로 남아 있습니다. 그때, 필요한 유일한 변경은 로거 또는 처리기의 심각도 수준을 DEBUG로 수정하는 것입니다."

#: ../../howto/logging-cookbook.rst:208
msgid "Logging to multiple destinations"
msgstr "여러 대상으로 로깅 하기"

#: ../../howto/logging-cookbook.rst:210
msgid ""
"Let's say you want to log to console and file with different message "
"formats and in differing circumstances. Say you want to log messages with"
" levels of DEBUG and higher to file, and those messages at level INFO and"
" higher to the console. Let's also assume that the file should contain "
"timestamps, but the console messages should not. Here's how you can "
"achieve this::"
msgstr ""
"다른 메시지 포맷으로 다른 상황에서 콘솔과 파일에 기록하려고 한다고 가정 해 봅시다. DEBUG 이상 수준의 메시지를 파일에 "
"기록하고, 수준 INFO 이상인 메시지를 콘솔에 기록하려고 한다고 가정 해보십시오. 또한, 타임스탬프가 파일에는 포함되어야 하지만,"
" 콘솔 메시지에는 없어야 한다고 가정합시다. 이렇게 하면 됩니다::"

#: ../../howto/logging-cookbook.rst:216
#, python-format
msgid ""
"import logging\n"
"\n"
"# set up logging to file - see previous section for more details\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    format='%(asctime)s %(name)-12s %(levelname)-8s "
"%(message)s',\n"
"                    datefmt='%m-%d %H:%M',\n"
"                    filename='/tmp/myapp.log',\n"
"                    filemode='w')\n"
"# define a Handler which writes INFO messages or higher to the sys.stderr"
"\n"
"console = logging.StreamHandler()\n"
"console.setLevel(logging.INFO)\n"
"# set a format which is simpler for console use\n"
"formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')"
"\n"
"# tell the handler to use this format\n"
"console.setFormatter(formatter)\n"
"# add the handler to the root logger\n"
"logging.getLogger('').addHandler(console)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the "
"root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in "
"your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""

#: ../../howto/logging-cookbook.rst:248
msgid "When you run this, on the console you will see"
msgstr "실행하면 콘솔에는 다음과 같이 출력됩니다."

#: ../../howto/logging-cookbook.rst:250
msgid ""
"root        : INFO     Jackdaws love my big sphinx of quartz.\n"
"myapp.area1 : INFO     How quickly daft jumping zebras vex.\n"
"myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"myapp.area2 : ERROR    The five boxing wizards jump quickly."
msgstr ""

#: ../../howto/logging-cookbook.rst:257
msgid "and in the file you will see something like"
msgstr "파일에는 이렇게 기록됩니다."

#: ../../howto/logging-cookbook.rst:259
msgid ""
"10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.\n"
"10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.\n"
"10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from "
"quack.\n"
"10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly."
msgstr ""

#: ../../howto/logging-cookbook.rst:267
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr "보시다시피 DEBUG 메시지는 파일에만 표시됩니다. 다른 메시지는 두 목적지로 전송됩니다."

#: ../../howto/logging-cookbook.rst:270
msgid ""
"This example uses console and file handlers, but you can use any number "
"and combination of handlers you choose."
msgstr "이 예제는 콘솔과 파일 처리기를 사용하지만, 여러분이 선택하는 처리기의 수나 조합에 제약이 없습니다."

#: ../../howto/logging-cookbook.rst:273
msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use"
" of a standard location for temporary files on POSIX systems. On Windows,"
" you may need to choose a different directory name for the log - just "
"ensure that the directory exists and that you have the permissions to "
"create and update files in it."
msgstr ""

#: ../../howto/logging-cookbook.rst:282
msgid "Custom handling of levels"
msgstr ""

#: ../../howto/logging-cookbook.rst:284
msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a "
"threshold get processed by a handler. To do this, you need to use "
"filters. Let's look at a scenario where you want to arrange things as "
"follows:"
msgstr ""

#: ../../howto/logging-cookbook.rst:289
msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr ""

#: ../../howto/logging-cookbook.rst:290
msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr ""

#: ../../howto/logging-cookbook.rst:291
msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr ""

#: ../../howto/logging-cookbook.rst:293
msgid "Suppose you configure logging with the following JSON:"
msgstr ""

#: ../../howto/logging-cookbook.rst:295
#, python-brace-format, python-format
msgid ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:335
msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout``"
" would show messages of severity ``ERROR`` and only events of this "
"severity and higher will be tracked as well as ``INFO`` and ``WARNING`` "
"messages. To prevent this, we can set up a filter which excludes those "
"messages and add it to the relevant handler. This can be configured by "
"adding a ``filters`` section parallel to ``formatters`` and ``handlers``:"
msgstr ""

#: ../../howto/logging-cookbook.rst:341
#, python-brace-format
msgid ""
"{\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:352
msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr ""

#: ../../howto/logging-cookbook.rst:354
#, python-brace-format
msgid ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"warnings_and_below\"]\n"
"    }\n"
"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:366
msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr ""

#: ../../howto/logging-cookbook.rst:369
msgid ""
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter"
msgstr ""

#: ../../howto/logging-cookbook.rst:379
msgid ""
"This converts the string argument passed in to a numeric level, and "
"returns a function which only returns ``True`` if the level of the passed"
" in record is at or below the specified level. Note that in this example "
"I have defined the ``filter_maker`` in a test script ``main.py`` that I "
"run from the command line, so its module will be ``__main__`` - hence the"
" ``__main__.filter_maker`` in the filter configuration. You will need to "
"change that if you define it in a different module."
msgstr ""

#: ../../howto/logging-cookbook.rst:387
msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr ""

#: ../../howto/logging-cookbook.rst:389
#, python-brace-format, python-format
msgid ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"warnings_and_below\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('A DEBUG message')\n"
"logging.info('An INFO message')\n"
"logging.warning('A WARNING message')\n"
"logging.error('An ERROR message')\n"
"logging.critical('A CRITICAL message')"
msgstr ""

#: ../../howto/logging-cookbook.rst:457
msgid "And after running it like this:"
msgstr ""

#: ../../howto/logging-cookbook.rst:459
msgid "python main.py 2>stderr.log >stdout.log"
msgstr ""

#: ../../howto/logging-cookbook.rst:463
msgid "We can see the results are as expected:"
msgstr ""

#: ../../howto/logging-cookbook.rst:465
msgid ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - A DEBUG message\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message"
msgstr ""

#: ../../howto/logging-cookbook.rst:489
msgid "Configuration server example"
msgstr "구성 서버 예제"

#: ../../howto/logging-cookbook.rst:491
msgid "Here is an example of a module using the logging configuration server::"
msgstr "다음은 로깅 구성 서버를 사용하는 모듈의 예입니다::"

#: ../../howto/logging-cookbook.rst:493
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"import os\n"
"\n"
"# read initial config file\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create and start listener on port 9999\n"
"t = logging.config.listen(9999)\n"
"t.start()\n"
"\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"try:\n"
"    # loop through logging calls to see the difference\n"
"    # new configurations make, until Ctrl+C is pressed\n"
"    while True:\n"
"        logger.debug('debug message')\n"
"        logger.info('info message')\n"
"        logger.warning('warn message')\n"
"        logger.error('error message')\n"
"        logger.critical('critical message')\n"
"        time.sleep(5)\n"
"except KeyboardInterrupt:\n"
"    # cleanup\n"
"    logging.config.stopListening()\n"
"    t.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:522
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new "
"logging configuration::"
msgstr ""
"다음은 파일 이름을 받아서, 그 파일을 새 로깅 구성으로 (이진 인코딩된 길이를 적절하게 앞에 붙여서) 서버로 보내는 "
"스크립트입니다::"

#: ../../howto/logging-cookbook.rst:526
msgid ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('connecting...')\n"
"s.connect((HOST, PORT))\n"
"print('sending config...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('complete')"
msgstr ""

#: ../../howto/logging-cookbook.rst:547
msgid "Dealing with handlers that block"
msgstr "블록 하는 처리기 다루기"

#: ../../howto/logging-cookbook.rst:551
#, fuzzy
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web "
"applications, though of course it also occurs in other scenarios."
msgstr ""
"때로는 로깅 처리기가 로깅 중인 스레드를 블록 하지 않고 작업을 수행해야 하는 경우가 있습니다. 이것은 웹 응용 프로그램에서 흔히 "
"나타나는 요구사항이지만, 물론 다른 시나리오에서도 발생합니다."

#: ../../howto/logging-cookbook.rst:555
msgid ""
"A common culprit which demonstrates sluggish behaviour is the "
":class:`SMTPHandler`: sending emails can take a long time, for a number "
"of reasons outside the developer's control (for example, a poorly "
"performing mail or network infrastructure). But almost any network-based "
"handler can block: Even a :class:`SocketHandler` operation may do a DNS "
"query under the hood which is too slow (and this query can be deep in the"
" socket library code, below the Python layer, and outside your control)."
msgstr ""
"흔히 느린 행동을 보이는 범인은 :class:`SMTPHandler` 입니다: 개발자의 통제 밖에 있는 여러 가지 이유로, 전자 "
"우편을 보내는 데 오랜 시간이 걸릴 수 있습니다 (예를 들어, 잘 동작하지 않는 메일 또는 네트워크 인프라). 그러나 거의 모든 "
"네트워크 기반 처리기는 블록 할 수 있습니다. :class:`SocketHandler` 작업도 너무 느린 DNS 질의를 이면에서 "
"수행 할 수 있습니다 (그리고 이 질의는 여러분의 통제 밖에 있는, 파이썬 계층 아래의 소켓 라이브러리 코드 깊숙이 있을 수 "
"있습니다)."

#: ../../howto/logging-cookbook.rst:563
msgid ""
"One solution is to use a two-part approach. For the first part, attach "
"only a :class:`QueueHandler` to those loggers which are accessed from "
"performance-critical threads. They simply write to their queue, which can"
" be sized to a large enough capacity or initialized with no upper bound "
"to their size. The write to the queue will typically be accepted quickly,"
" though you will probably need to catch the :exc:`queue.Full` exception "
"as a precaution in your code. If you are a library developer who has "
"performance-critical threads in their code, be sure to document this "
"(together with a suggestion to attach only ``QueueHandlers`` to your "
"loggers) for the benefit of other developers who will use your code."
msgstr ""
"한 가지 해결책은 두 부분으로 된 접근법을 사용하는 것입니다. 첫 번째 부분에서는, 성능이 중요한 스레드에서 액세스하는 로거에 "
":class:`QueueHandler` 만 붙입니다. 그들은 단순히 큐에 씁니다. 충분한 용량으로 큐의 크기를 조정하거나, 크기의 "
"상한이 없도록 초기화 할 수 있습니다. 큐에 대한 쓰기는 일반적으로 신속하게 받아들여지지만, 코드에서 예방책으로 "
":exc:`queue.Full` 예외를 잡아야 할 것입니다. 코드에 성능이 중요한 스레드가 있는 라이브러리 개발자인 경우, 코드를 "
"사용할 다른 개발자의 이익을 위해 이것을 (여러분의 로거에 ``QueueHandlers`` 만 붙이라는 제안과 함께) 문서로 "
"만들어야 합니다."

#: ../../howto/logging-cookbook.rst:574
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been"
" designed as the counterpart to :class:`QueueHandler`.  A "
":class:`QueueListener` is very simple: it's passed a queue and some "
"handlers, and it fires up an internal thread which listens to its queue "
"for LogRecords sent from ``QueueHandlers`` (or any other source of "
"``LogRecords``, for that matter). The ``LogRecords`` are removed from the"
" queue and passed to the handlers for processing."
msgstr ""
"해결책의 두 번째 부분은 :class:`QueueListener`\\며, 이는 :class:`QueueHandler` 에 상응하여 "
"설계되었습니다. :class:`QueueListener` 는 매우 간단합니다: 큐와 처리기를 넘겨주면 "
"``QueueHandlers`` (또는 ``LogRecords`` 의 다른 소스)에서 보낸 LogRecord를 큐에서 수신하는 내부"
" 스레드를 시작합니다. ``LogRecords`` 는 큐에서 제거되고 처리를 위해 처리기로 전달됩니다."

#: ../../howto/logging-cookbook.rst:582
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that "
"you can use the same instance to service multiple ``QueueHandlers``. This"
" is more resource-friendly than, say, having threaded versions of the "
"existing handler classes, which would eat up one thread per handler for "
"no particular benefit."
msgstr ""
"별도의 :class:`QueueListener` 클래스를 사용하면 같은 인스턴스를 사용하여 여러 개의 "
"``QueueHandlers`` 를 처리할 수 있다는 장점이 있습니다. 이것은 특별한 이점 없이 처리기당 하나의 스레드를 먹게 되는"
" 기존의 처리기 클래스의 스레드 버전을 만드는 것보다 자원 친화적입니다."

#: ../../howto/logging-cookbook.rst:587
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "이 두 클래스를 사용하는 예제는 다음과 같습니다 (임포트 생략)::"

#: ../../howto/logging-cookbook.rst:589
#, python-format
msgid ""
"que = queue.Queue(-1)  # no limit on size\n"
"queue_handler = QueueHandler(que)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(que, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# The log output will display the thread which generated\n"
"# the event (the main thread) rather than the internal\n"
"# thread which monitors the internal queue. This is what\n"
"# you want to happen.\n"
"root.warning('Look out!')\n"
"listener.stop()"
msgstr ""

#: ../../howto/logging-cookbook.rst:605
msgid "which, when run, will produce:"
msgstr "실행하면, 다음과 같은 결과를 만듭니다:"

#: ../../howto/logging-cookbook.rst:607
msgid "MainThread: Look out!"
msgstr ""

#: ../../howto/logging-cookbook.rst:611
msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that "
"when logging from async code, network and even file handlers could lead "
"to problems (blocking the event loop) because some logging is done from "
":mod:`asyncio` internals. It might be best, if any async code is used in "
"an application, to use the above approach for logging, so that any "
"blocking code runs only in the ``QueueListener`` thread."
msgstr ""

#: ../../howto/logging-cookbook.rst:619
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every "
"message received from the queue to every handler it was initialized with."
" (This was because it was assumed that level filtering was all done on "
"the other side, where the queue is filled.) From 3.5 onwards, this "
"behaviour can be changed by passing a keyword argument "
"``respect_handler_level=True`` to the listener's constructor. When this "
"is done, the listener compares the level of each message with the "
"handler's level, and only passes a message to a handler if it's "
"appropriate to do so."
msgstr ""
"파이썬 3.5 이전 버전에서는, :class:`QueueListener` 는 항상 큐에서 받은 모든 메시지를 초기화될 때 제공된 "
"모든 처리기로 전달했습니다. (이것은 큐가 채워질 때 수준 필터링이 모두 반대편에서 행해졌다고 가정했기 때문입니다.) 3.5 "
"이후부터, 이 동작은 키워드 인자 ``respect_handler_level=True`` 를 리스너의 생성자에 전달함으로써 변경될 "
"수 있습니다. 이렇게 할 때, 리스너는 각 메시지의 수준을 처리기의 수준과 비교하여, 적절한 메시지만 처리기에 전달되도록 합니다."

#: ../../howto/logging-cookbook.rst:632
msgid "Sending and receiving logging events across a network"
msgstr "네트워크에서 로깅 이벤트 보내고 받기"

#: ../../howto/logging-cookbook.rst:634
msgid ""
"Let's say you want to send logging events across a network, and handle "
"them at the receiving end. A simple way of doing this is attaching a "
":class:`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"네트워크를 통해 로깅 이벤트를 보내고, 받는 쪽에서 처리하려고 한다고 합시다. 이렇게 하는 간단한 방법은 "
":class:`SocketHandler` 인스턴스를 보내는 쪽의 루트 로거에 연결하는 것입니다::"

#: ../../howto/logging-cookbook.rst:638
msgid ""
"import logging, logging.handlers\n"
"\n"
"rootLogger = logging.getLogger('')\n"
"rootLogger.setLevel(logging.DEBUG)\n"
"socketHandler = logging.handlers.SocketHandler('localhost',\n"
"                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"# don't bother with a formatter, since a socket handler sends the event "
"as\n"
"# an unformatted pickle\n"
"rootLogger.addHandler(socketHandler)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the "
"root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in "
"your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""

#: ../../howto/logging-cookbook.rst:662
msgid ""
"At the receiving end, you can set up a receiver using the "
":mod:`socketserver` module. Here is a basic working example::"
msgstr ""
"수신 측에서는 :mod:`socketserver` 모듈을 사용하여 수신기를 구성할 수 있습니다. 기본적인 작업 예제는 다음과 "
"같습니다::"

#: ../../howto/logging-cookbook.rst:665
#, python-format
msgid ""
"import pickle\n"
"import logging\n"
"import logging.handlers\n"
"import socketserver\n"
"import struct\n"
"\n"
"\n"
"class LogRecordStreamHandler(socketserver.StreamRequestHandler):\n"
"    \"\"\"Handler for a streaming logging request.\n"
"\n"
"    This basically logs the record using whatever logging policy is\n"
"    configured locally.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        \"\"\"\n"
"        Handle multiple requests - each expected to be a 4-byte length,\n"
"        followed by the LogRecord in pickle format. Logs the record\n"
"        according to whatever policy is configured locally.\n"
"        \"\"\"\n"
"        while True:\n"
"            chunk = self.connection.recv(4)\n"
"            if len(chunk) < 4:\n"
"                break\n"
"            slen = struct.unpack('>L', chunk)[0]\n"
"            chunk = self.connection.recv(slen)\n"
"            while len(chunk) < slen:\n"
"                chunk = chunk + self.connection.recv(slen - len(chunk))\n"
"            obj = self.unPickle(chunk)\n"
"            record = logging.makeLogRecord(obj)\n"
"            self.handleLogRecord(record)\n"
"\n"
"    def unPickle(self, data):\n"
"        return pickle.loads(data)\n"
"\n"
"    def handleLogRecord(self, record):\n"
"        # if a name is specified, we use the named logger rather than the"
" one\n"
"        # implied by the record.\n"
"        if self.server.logname is not None:\n"
"            name = self.server.logname\n"
"        else:\n"
"            name = record.name\n"
"        logger = logging.getLogger(name)\n"
"        # N.B. EVERY record gets logged. This is because Logger.handle\n"
"        # is normally called AFTER logger-level filtering. If you want\n"
"        # to do filtering, do it at the client end to save wasting\n"
"        # cycles and network bandwidth!\n"
"        logger.handle(record)\n"
"\n"
"class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):\n"
"    \"\"\"\n"
"    Simple TCP socket-based logging receiver suitable for testing.\n"
"    \"\"\"\n"
"\n"
"    allow_reuse_address = True\n"
"\n"
"    def __init__(self, host='localhost',\n"
"                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n"
"                 handler=LogRecordStreamHandler):\n"
"        socketserver.ThreadingTCPServer.__init__(self, (host, port), "
"handler)\n"
"        self.abort = 0\n"
"        self.timeout = 1\n"
"        self.logname = None\n"
"\n"
"    def serve_until_stopped(self):\n"
"        import select\n"
"        abort = 0\n"
"        while not abort:\n"
"            rd, wr, ex = select.select([self.socket.fileno()],\n"
"                                       [], [],\n"
"                                       self.timeout)\n"
"            if rd:\n"
"                self.handle_request()\n"
"            abort = self.abort\n"
"\n"
"def main():\n"
"    logging.basicConfig(\n"
"        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s "
"%(message)s')\n"
"    tcpserver = LogRecordSocketReceiver()\n"
"    print('About to start TCP server...')\n"
"    tcpserver.serve_until_stopped()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:750
msgid ""
"First run the server, and then the client. On the client side, nothing is"
" printed on the console; on the server side, you should see something "
"like:"
msgstr ""
"먼저 서버를 실행한 다음 클라이언트를 실행합니다. 클라이언트 쪽에서는 콘솔에 아무것도 인쇄되지 않습니다. 서버 측에서 다음과 같은 "
"내용이 보여야 합니다.:"

#: ../../howto/logging-cookbook.rst:753
msgid ""
"About to start TCP server...\n"
"   59 root            INFO     Jackdaws love my big sphinx of quartz.\n"
"   59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"   69 myapp.area1     INFO     How quickly daft jumping zebras vex.\n"
"   69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from "
"quack.\n"
"   69 myapp.area2     ERROR    The five boxing wizards jump quickly."
msgstr ""

#: ../../howto/logging-cookbook.rst:762
#, fuzzy
msgid ""
"Note that there are some security issues with pickle in some scenarios. "
"If these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~SocketHandler.makePickle` method and implementing "
"your alternative there, as well as adapting the above script to use your "
"alternative serialization."
msgstr ""
"일부 시나리오에서는 피클이 몇 가지 보안 문제를 수반함에 유의하십시오. 이 문제가 중요하면, "
":meth:`~handlers.SocketHandler.makePickle` 메서드를 재정의하고 거기서 여러분의 대안을 구현해서 "
"다른 직렬화를 사용하는 한편, 위의 스크립트가 그 직렬화를 사용하도록 수정하십시오."

#: ../../howto/logging-cookbook.rst:770
msgid "Running a logging socket listener in production"
msgstr ""

#: ../../howto/logging-cookbook.rst:774
msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is"
" a Gist <socket-listener-gist_>`__ which provides the bare-bones files to"
" run the above functionality using Supervisor. It consists of the "
"following files:"
msgstr ""

#: ../../howto/logging-cookbook.rst:781
msgid "File"
msgstr ""

#: ../../howto/logging-cookbook.rst:781
msgid "Purpose"
msgstr ""

#: ../../howto/logging-cookbook.rst:783
msgid ":file:`prepare.sh`"
msgstr ""

#: ../../howto/logging-cookbook.rst:783
msgid "A Bash script to prepare the environment for testing"
msgstr ""

#: ../../howto/logging-cookbook.rst:786
msgid ":file:`supervisor.conf`"
msgstr ""

#: ../../howto/logging-cookbook.rst:786
msgid ""
"The Supervisor configuration file, which has entries for the listener and"
" a multi-process web application"
msgstr ""

#: ../../howto/logging-cookbook.rst:790
msgid ":file:`ensure_app.sh`"
msgstr ""

#: ../../howto/logging-cookbook.rst:790
msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr ""

#: ../../howto/logging-cookbook.rst:793
msgid ":file:`log_listener.py`"
msgstr ""

#: ../../howto/logging-cookbook.rst:793
msgid ""
"The socket listener program which receives log events and records them to"
" a file"
msgstr ""

#: ../../howto/logging-cookbook.rst:796
msgid ":file:`main.py`"
msgstr ""

#: ../../howto/logging-cookbook.rst:796
msgid ""
"A simple web application which performs logging via a socket connected to"
" the listener"
msgstr ""

#: ../../howto/logging-cookbook.rst:799
msgid ":file:`webapp.json`"
msgstr ""

#: ../../howto/logging-cookbook.rst:799
#, fuzzy
msgid "A JSON configuration file for the web application"
msgstr "logging 모듈용 구성 API."

#: ../../howto/logging-cookbook.rst:801
msgid ":file:`client.py`"
msgstr ""

#: ../../howto/logging-cookbook.rst:801
msgid "A Python script to exercise the web application"
msgstr ""

#: ../../howto/logging-cookbook.rst:804
msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to "
"the same log file without conflicting with one another --- they all go "
"through the socket listener."
msgstr ""

#: ../../howto/logging-cookbook.rst:809
msgid "To test these files, do the following in a POSIX environment:"
msgstr ""

#: ../../howto/logging-cookbook.rst:811
msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the "
":guilabel:`Download ZIP` button."
msgstr ""

#: ../../howto/logging-cookbook.rst:814
msgid "Unzip the above files from the archive into a scratch directory."
msgstr ""

#: ../../howto/logging-cookbook.rst:816
msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. "
"This creates a :file:`run` subdirectory to contain Supervisor-related and"
" log files, and a :file:`venv` subdirectory to contain a virtual "
"environment into which ``bottle``, ``gunicorn`` and ``supervisor`` are "
"installed."
msgstr ""

#: ../../howto/logging-cookbook.rst:821
msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr ""

#: ../../howto/logging-cookbook.rst:824
msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr ""

#: ../../howto/logging-cookbook.rst:827
msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the"
" most recent log lines in files matching the pattern :file:`app.log*`. "
"They won't be in any particular order, since they have been handled "
"concurrently by different worker processes in a non-deterministic way."
msgstr ""

#: ../../howto/logging-cookbook.rst:832
msgid ""
"You can shut down the listener and the web application by running "
"``venv/bin/supervisorctl -c supervisor.conf shutdown``."
msgstr ""

#: ../../howto/logging-cookbook.rst:835
msgid ""
"You may need to tweak the configuration files in the unlikely event that "
"the configured ports clash with something else in your test environment."
msgstr ""

#: ../../howto/logging-cookbook.rst:838
msgid ""
"The default configuration uses a TCP socket on port 9020. You can use a "
"Unix Domain socket instead of a TCP socket by doing the following:"
msgstr ""

#: ../../howto/logging-cookbook.rst:841
msgid ""
"In :file:`listener.json`, add a ``socket`` key with the path to the "
"domain socket you want to use. If this key is present, the listener "
"listens on the corresponding domain socket and not on a TCP socket (the "
"``port`` key is ignored)."
msgstr ""

#: ../../howto/logging-cookbook.rst:846
msgid ""
"In :file:`webapp.json`, change the socket handler configuration "
"dictionary so that the ``host`` value is the path to the domain socket, "
"and set the ``port`` value to ``null``."
msgstr ""

#: ../../howto/logging-cookbook.rst:856
msgid "Adding contextual information to your logging output"
msgstr "로그 출력에 문맥 정보 추가"

#: ../../howto/logging-cookbook.rst:858
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, "
"this is not a good idea because these instances are not garbage "
"collected. While this is not a problem in practice, when the number of "
":class:`Logger` instances is dependent on the level of granularity you "
"want to use in logging an application, it could be hard to manage if the "
"number of :class:`Logger` instances becomes effectively unbounded."
msgstr ""
"로깅 호출에 전달된 매개 변수 외에도 로깅 출력에 문맥 정보가 포함되기 원하는 경우가 있습니다. 예를 들어, 네트워크 응용 "
"프로그램에서, (원격 클라이언트의 사용자 이름 또는 IP 주소와 같은) 클라이언트별 정보를 로그에 기록하는 것이 바람직 할 수 "
"있습니다. 이를 달성하기 위해 *extra* 매개 변수를 사용할 수는 있지만, 이러한 방식으로 정보를 전달하는 것이 항상 편리하지는"
" 않습니다. 연결마다 :class:`Logger` 인스턴스를 만들고 싶을지 모르지만, 이러한 인스턴스는 가비지 수집되지 않기 때문에"
" 좋지 않습니다. :class:`Logger` 인스턴스의 수가 응용 프로그램 로깅에 사용하고자 하는 세분성 수준에 의존적일 때 "
"이것이 실제로 문제가 되지는 않지만, :class:`Logger` 인스턴스의 수가 실질적으로 무제한이 되면 관리하기 어려울 수 "
"있습니다."

#: ../../howto/logging-cookbook.rst:873
msgid "Using LoggerAdapters to impart contextual information"
msgstr "문맥 정보 전달에 LoggerAdapters 사용하기"

#: ../../howto/logging-cookbook.rst:875
msgid ""
"An easy way in which you can pass contextual information to be output "
"along with logging event information is to use the :class:`LoggerAdapter`"
" class. This class is designed to look like a :class:`Logger`, so that "
"you can call :meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`,"
" :meth:`exception`, :meth:`critical` and :meth:`log`. These methods have "
"the same signatures as their counterparts in :class:`Logger`, so you can "
"use the two types of instances interchangeably."
msgstr ""
"로깅 이벤트 정보와 함께 출력되는 문맥 정보를 전달하는 쉬운 방법은 :class:`LoggerAdapter` 클래스를 사용하는 "
"것입니다. 이 클래스는 :class:`Logger`\\처럼 보이도록 설계되어 있어서, :meth:`debug`, "
":meth:`info`, :meth:`warning`, :meth:`error`, :meth:`exception`, "
":meth:`critical` 및 :meth:`log`\\를 호출할 수 있습니다. 이 메서드들은 :class:`Logger` 에 "
"있는 것과 똑같은 서명을 가지므로, 두 형의 인스턴스를 같은 의미로 사용할 수 있습니다."

#: ../../howto/logging-cookbook.rst:883
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a "
":class:`Logger` instance and a dict-like object which contains your "
"contextual information. When you call one of the logging methods on an "
"instance of :class:`LoggerAdapter`, it delegates the call to the "
"underlying instance of :class:`Logger` passed to its constructor, and "
"arranges to pass the contextual information in the delegated call. Here's"
" a snippet from the code of :class:`LoggerAdapter`::"
msgstr ""
":class:`LoggerAdapter` 의 인스턴스를 생성할 때, :class:`Logger` 인스턴스와 문맥 정보가 포함된 "
"딕셔너리류 객체를 전달합니다. :class:`LoggerAdapter` 의 인스턴스에서 로깅 메서드 중 하나를 호출하면, 생성자에 "
"전달된 하위 :class:`Logger` 인스턴스에 호출을 위임하고, 이 호출에 문맥 정보를 전달하도록 배치합니다. 다음은 "
":class:`LoggerAdapter` 코드에서 발췌한 내용입니다::"

#: ../../howto/logging-cookbook.rst:891
msgid ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    Delegate a debug call to the underlying logger, after adding\n"
"    contextual information from this adapter instance.\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"
msgstr ""

#: ../../howto/logging-cookbook.rst:899
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is "
"where the contextual information is added to the logging output. It's "
"passed the message and keyword arguments of the logging call, and it "
"passes back (potentially) modified versions of these to use in the call "
"to the underlying logger. The default implementation of this method "
"leaves the message alone, but inserts an 'extra' key in the keyword "
"argument whose value is the dict-like object passed to the constructor. "
"Of course, if you had passed an 'extra' keyword argument in the call to "
"the adapter, it will be silently overwritten."
msgstr ""
":class:`LoggerAdapter` 의 :meth:`~LoggerAdapter.process` 메서드는 문맥 정보가 로그 "
"출력에 추가되는 곳입니다. 로깅 호출의 메시지 및 키워드 인자를 받아서, 하부 로거에 대한 호출에서 사용될 (대체로) 수정된 버전을"
" 돌려줍니다. 이 메서드의 기본 구현은 메시지는 그대로 두고, 키워드 인자에 생성자로 전달된 딕셔너리류 객체를 값으로 갖는 "
"'extra' 키를 삽입합니다. 물론, 어댑터에 대한 호출에서 'extra' 키워드 인자를 전달한 경우 자동으로 덮어씁니다."

#: ../../howto/logging-cookbook.rst:908
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object"
" are merged into the :class:`LogRecord` instance's __dict__, allowing you"
" to use customized strings with your :class:`Formatter` instances which "
"know about the keys of the dict-like object. If you need a different "
"method, e.g. if you want to prepend or append the contextual information "
"to the message string, you just need to subclass :class:`LoggerAdapter` "
"and override :meth:`~LoggerAdapter.process` to do what you need. Here is "
"a simple example::"
msgstr ""
"'extra'\\를 사용하는 장점은, 딕셔너리류 객체에 들어있는 값이 :class:`LogRecord` 인스턴스의 __dict__에"
" 병합되어, 키에 대해 알고 있는 :class:`Formatter` 인스턴스로 사용자 정의된 문자열을 사용할 수 있게 된다는 "
"것입니다. 다른 방법이 필요한 경우, 가령 메시지 문자열의 앞이나 뒤에 문맥 정보를 덧붙이려는 경우, "
":class:`LoggerAdapter` 의 서브 클래스를 만들고, 필요한 작업을 수행하기 위해 "
":meth:`~LoggerAdapter.process` 를 재정의해야 합니다. 다음은 간단한 예제입니다::"

#: ../../howto/logging-cookbook.rst:916
#, python-format
msgid ""
"class CustomAdapter(logging.LoggerAdapter):\n"
"    \"\"\"\n"
"    This example adapter expects the passed in dict-like object to have a"
"\n"
"    'connid' key, whose value in brackets is prepended to the log "
"message.\n"
"    \"\"\"\n"
"    def process(self, msg, kwargs):\n"
"        return '[%s] %s' % (self.extra['connid'], msg), kwargs"
msgstr ""

#: ../../howto/logging-cookbook.rst:924
msgid "which you can use like this::"
msgstr "이런 식으로 사용할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:926
#, python-brace-format
msgid ""
"logger = logging.getLogger(__name__)\n"
"adapter = CustomAdapter(logger, {'connid': some_conn_id})"
msgstr ""

#: ../../howto/logging-cookbook.rst:929
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr "그러면 어댑터에 로그 하는 모든 이벤트는 로그 메시지 앞에 ``some_conn_id`` 값이 붙습니다."

#: ../../howto/logging-cookbook.rst:933
msgid "Using objects other than dicts to pass contextual information"
msgstr "딕셔너리 이외의 객체를 사용하여 문맥 정보 전달하기"

#: ../../howto/logging-cookbook.rst:935
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be "
"useful if you want to generate values dynamically (whereas the values in "
"a dict would be constant)."
msgstr ""
"실제 딕셔너리를 :class:`LoggerAdapter` 에 전달할 필요는 없습니다 - 로깅에 딕셔너리처럼 보일 수 있도록, "
"``__getitem__`` 과 ``__iter__`` 를 구현하는 클래스의 인스턴스를 전달할 수 있습니다. 값을 동적으로 "
"생성하려는 경우 (반면에 딕셔너리에 들어있는 값은 바뀌지 않습니다) 유용합니다."

#: ../../howto/logging-cookbook.rst:944
msgid "Using Filters to impart contextual information"
msgstr "문맥 정보 전달에 필터 사용하기"

#: ../../howto/logging-cookbook.rst:946
msgid ""
"You can also add contextual information to log output using a user-"
"defined :class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes "
"which can then be output using a suitable format string, or if needed a "
"custom :class:`Formatter`."
msgstr ""
"사용자 정의 :class:`Filter`\\를 사용하여 로그 출력에 문맥 정보를 추가할 수도 있습니다. ``Filter`` "
"인스턴스는 전달된 ``LogRecords`` 를 수정할 수 있는데, 어트리뷰트를 추가해서 적절한 포맷 문자열이나 필요하다면 사용자 "
"정의 :class:`Formatter`\\를 사용해서 출력되도록 할 수 있습니다."

#: ../../howto/logging-cookbook.rst:951
msgid ""
"For example in a web application, the request being processed (or at "
"least, the interesting parts of it) can be stored in a threadlocal "
"(:class:`threading.local`) variable, and then accessed from a ``Filter`` "
"to add, say, information from the request - say, the remote IP address "
"and remote user's username - to the ``LogRecord``, using the attribute "
"names 'ip' and 'user' as in the ``LoggerAdapter`` example above. In that "
"case, the same format string can be used to get similar output to that "
"shown above. Here's an example script::"
msgstr ""
"예를 들어 웹 응용 프로그램에서, 처리 중인 요청(또는 적어도 그것의 흥미로운 부분)을 스레드 로컬 "
"(:class:`threading.local`) 변수에 저장한 다음, ``Filter`` 에서 액세스해서, 요청에서 온 정보를 - "
"원격 IP 주소와 원격 사용자의 사용자 이름이라고 합시다 - 위의 ``LoggerAdapter`` 예제에서와같이 어트리뷰트 이름 "
"'ip'\\와 'user'\\를 사용하여 ``LogRecord`` 에 추가할 수 있습니다. 이 경우 같은 포맷 문자열을 사용하여 "
"위에 표시된 것과 비슷한 출력을 얻을 수 있습니다. 다음은 스크립트 예입니다::"

#: ../../howto/logging-cookbook.rst:960
#, python-format
msgid ""
"import logging\n"
"from random import choice\n"
"\n"
"class ContextFilter(logging.Filter):\n"
"    \"\"\"\n"
"    This is a filter which injects contextual information into the log.\n"
"\n"
"    Rather than use actual contextual information, we just use random\n"
"    data in this demo.\n"
"    \"\"\"\n"
"\n"
"    USERS = ['jim', 'fred', 'sheila']\n"
"    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']\n"
"\n"
"    def filter(self, record):\n"
"\n"
"        record.ip = choice(ContextFilter.IPS)\n"
"        record.user = choice(ContextFilter.USERS)\n"
"        return True\n"
"\n"
"if __name__ == '__main__':\n"
"    levels = (logging.DEBUG, logging.INFO, logging.WARNING, "
"logging.ERROR, logging.CRITICAL)\n"
"    logging.basicConfig(level=logging.DEBUG,\n"
"                        format='%(asctime)-15s %(name)-5s %(levelname)-8s"
" IP: %(ip)-15s User: %(user)-8s %(message)s')\n"
"    a1 = logging.getLogger('a.b.c')\n"
"    a2 = logging.getLogger('d.e.f')\n"
"\n"
"    f = ContextFilter()\n"
"    a1.addFilter(f)\n"
"    a2.addFilter(f)\n"
"    a1.debug('A debug message')\n"
"    a1.info('An info message with %s', 'some parameters')\n"
"    for x in range(10):\n"
"        lvl = choice(levels)\n"
"        lvlname = logging.getLevelName(lvl)\n"
"        a2.log(lvl, 'A message at %s level with %d %s', lvlname, 2, "
"'parameters')"
msgstr ""

#: ../../howto/logging-cookbook.rst:997
msgid "which, when run, produces something like:"
msgstr "실행하면 다음과 같은 결과가 나옵니다:"

#: ../../howto/logging-cookbook.rst:999
msgid ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred"
"     A debug message\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila"
"   An info message with some parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila"
"   A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim"
"      A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila"
"   A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred"
"     A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim"
"      A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila"
"   A message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim"
"      A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila"
"   A message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred"
"     A message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred"
"     A message at INFO level with 2 parameters"
msgstr ""

#: ../../howto/logging-cookbook.rst:1015
msgid "Use of ``contextvars``"
msgstr ""

#: ../../howto/logging-cookbook.rst:1017
msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-"
"local storage which works for both :mod:`threading` and :mod:`asyncio` "
"processing needs. This type of storage may thus be generally preferable "
"to thread-locals. The following example shows how, in a multi-threaded "
"environment, logs can populated with contextual information such as, for "
"example, request attributes handled by web applications."
msgstr ""

#: ../../howto/logging-cookbook.rst:1023
msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same "
"Python process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the "
"library (and other request processing code) are directed to the "
"appropriate application's log file, while including in the log additional"
" contextual information such as client IP, HTTP request method and client"
" username?"
msgstr ""

#: ../../howto/logging-cookbook.rst:1030
msgid "Let's assume that the library can be simulated by the following code:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1032
msgid ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def useful():\n"
"    # Just a representative event logged from the library\n"
"    logger.debug('Hello from webapplib!')\n"
"    # Just sleep for a bit so other threads get to run\n"
"    time.sleep(0.01)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1046
msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web"
" applications work - each request is handled by a thread:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1050
#, python-format
msgid ""
"# main.py\n"
"import argparse\n"
"from contextvars import ContextVar\n"
"import logging\n"
"import os\n"
"from random import choice\n"
"import threading\n"
"import webapplib\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.DEBUG)\n"
"\n"
"class Request:\n"
"    \"\"\"\n"
"    A simple dummy request class which just holds dummy HTTP request "
"method,\n"
"    client IP address and client username\n"
"    \"\"\"\n"
"    def __init__(self, method, ip, user):\n"
"        self.method = method\n"
"        self.ip = ip\n"
"        self.user = user\n"
"\n"
"# A dummy set of requests which will be used in the simulation - we'll "
"just pick\n"
"# from this list randomly. Note that all GET requests are from "
"192.168.2.XXX\n"
"# addresses, whereas POST requests are from 192.16.3.XXX addresses. Three"
" users\n"
"# are represented in the sample requests.\n"
"\n"
"REQUESTS = [\n"
"    Request('GET', '192.168.2.20', 'jim'),\n"
"    Request('POST', '192.168.3.20', 'fred'),\n"
"    Request('GET', '192.168.2.21', 'sheila'),\n"
"    Request('POST', '192.168.3.21', 'jim'),\n"
"    Request('GET', '192.168.2.22', 'fred'),\n"
"    Request('POST', '192.168.3.22', 'sheila'),\n"
"]\n"
"\n"
"# Note that the format string includes references to request context "
"information\n"
"# such as HTTP method, client IP and username\n"
"\n"
"formatter = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s "
"%(user)-6s %(ip)s %(method)-4s %(message)s')\n"
"\n"
"# Create our context variables. These will be filled at the start of "
"request\n"
"# processing, and used in the logging that happens during that processing"
"\n"
"\n"
"ctx_request = ContextVar('request')\n"
"ctx_appname = ContextVar('appname')\n"
"\n"
"class InjectingFilter(logging.Filter):\n"
"    \"\"\"\n"
"    A filter which injects context-specific information into logs and "
"ensures\n"
"    that only information for a specific webapp is included in its log\n"
"    \"\"\"\n"
"    def __init__(self, app):\n"
"        self.app = app\n"
"\n"
"    def filter(self, record):\n"
"        request = ctx_request.get()\n"
"        record.method = request.method\n"
"        record.ip = request.ip\n"
"        record.user = request.user\n"
"        record.appName = appName = ctx_appname.get()\n"
"        return appName == self.app.name\n"
"\n"
"class WebApp:\n"
"    \"\"\"\n"
"    A dummy web application class which has its own handler and filter "
"for a\n"
"    webapp-specific log.\n"
"    \"\"\"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        handler = logging.FileHandler(name + '.log', 'w')\n"
"        f = InjectingFilter(self)\n"
"        handler.setFormatter(formatter)\n"
"        handler.addFilter(f)\n"
"        root.addHandler(handler)\n"
"        self.num_requests = 0\n"
"\n"
"    def process_request(self, request):\n"
"        \"\"\"\n"
"        This is the dummy method for processing a request. It's called on"
" a\n"
"        different thread for every request. We store the context "
"information into\n"
"        the context vars before doing anything else.\n"
"        \"\"\"\n"
"        ctx_request.set(request)\n"
"        ctx_appname.set(self.name)\n"
"        self.num_requests += 1\n"
"        logger.debug('Request processing started')\n"
"        webapplib.useful()\n"
"        logger.debug('Request processing finished')\n"
"\n"
"def main():\n"
"    fn = os.path.splitext(os.path.basename(__file__))[0]\n"
"    adhf = argparse.ArgumentDefaultsHelpFormatter\n"
"    ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,\n"
"                                 description='Simulate a couple of web '\n"
"                                             'applications handling some "
"'\n"
"                                             'requests, showing how "
"request '\n"
"                                             'context can be used to '\n"
"                                             'populate logs')\n"
"    aa = ap.add_argument\n"
"    aa('--count', '-c', type=int, default=100, help='How many requests to"
" simulate')\n"
"    options = ap.parse_args()\n"
"\n"
"    # Create the dummy webapps and put them in a list which we can use to"
" select\n"
"    # from randomly\n"
"    app1 = WebApp('app1')\n"
"    app2 = WebApp('app2')\n"
"    apps = [app1, app2]\n"
"    threads = []\n"
"    # Add a common handler which will capture all events\n"
"    handler = logging.FileHandler('app.log', 'w')\n"
"    handler.setFormatter(formatter)\n"
"    root.addHandler(handler)\n"
"\n"
"    # Generate calls to process requests\n"
"    for i in range(options.count):\n"
"        try:\n"
"            # Pick an app at random and a request for it to process\n"
"            app = choice(apps)\n"
"            request = choice(REQUESTS)\n"
"            # Process the request in its own thread\n"
"            t = threading.Thread(target=app.process_request, "
"args=(request,))\n"
"            threads.append(t)\n"
"            t.start()\n"
"        except KeyboardInterrupt:\n"
"            break\n"
"\n"
"    # Wait for the threads to terminate\n"
"    for t in threads:\n"
"        t.join()\n"
"\n"
"    for app in apps:\n"
"        print('%s processed %s requests' % (app.name, app.num_requests))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1190
msgid ""
"If you run the above, you should find that roughly half the requests go "
"into :file:`app1.log` and the rest into :file:`app2.log`, and the all the"
" requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request "
"information will be displayed consistently in the log (i.e. the "
"information in each dummy request will always appear together in a log "
"line). This is illustrated by the following shell output:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1197
msgid ""
"~/logging-contextual-webapp$ python main.py\n"
"app1 processed 51 requests\n"
"app2 processed 49 requests\n"
"~/logging-contextual-webapp$ wc -l *.log\n"
"  153 app1.log\n"
"  147 app2.log\n"
"  300 app.log\n"
"  600 total\n"
"~/logging-contextual-webapp$ head -3 app1.log\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST "
"Request processing started\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST "
"Request processing started\n"
"~/logging-contextual-webapp$ head -3 app2.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  "
"Request processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  "
"Request processing started\n"
"~/logging-contextual-webapp$ head app.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  "
"Request processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  "
"Request processing started\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST "
"Request processing started\n"
"Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello "
"from webapplib!\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  "
"Request processing started\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST "
"Request processing started\n"
"Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello "
"from webapplib!\n"
"Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST "
"Request processing started\n"
"~/logging-contextual-webapp$ grep app1 app1.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app2.log | wc -l\n"
"147\n"
"~/logging-contextual-webapp$ grep app1 app.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app.log | wc -l\n"
"147"
msgstr ""

#: ../../howto/logging-cookbook.rst:1237
#, fuzzy
msgid "Imparting contextual information in handlers"
msgstr "로그 출력에 문맥 정보 추가"

#: ../../howto/logging-cookbook.rst:1239
msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to "
"other handlers, you can use a filter that returns a new "
":class:`~LogRecord` instead of modifying it in-place, as shown in the "
"following script::"
msgstr ""

#: ../../howto/logging-cookbook.rst:1244
#, python-format
msgid ""
"import copy\n"
"import logging\n"
"\n"
"def filter(record: logging.LogRecord):\n"
"    record = copy.copy(record)\n"
"    record.user = 'jim'\n"
"    return record\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    handler = logging.StreamHandler()\n"
"    formatter = logging.Formatter('%(message)s from %(user)-8s')\n"
"    handler.setFormatter(formatter)\n"
"    handler.addFilter(filter)\n"
"    logger.addHandler(handler)\n"
"\n"
"    logger.info('A log message')"
msgstr ""

#: ../../howto/logging-cookbook.rst:1266
msgid "Logging to a single file from multiple processes"
msgstr "여러 프로세스에서 단일 파일에 로깅 하기"

#: ../../howto/logging-cookbook.rst:1268
msgid ""
"Although logging is thread-safe, and logging to a single file from "
"multiple threads in a single process *is* supported, logging to a single "
"file from *multiple processes* is *not* supported, because there is no "
"standard way to serialize access to a single file across multiple "
"processes in Python. If you need to log to a single file from multiple "
"processes, one way of doing this is to have all the processes log to a "
":class:`~handlers.SocketHandler`, and have a separate process which "
"implements a socket server which reads from the socket and logs to file. "
"(If you prefer, you can dedicate one thread in one of the existing "
"processes to perform this function.) :ref:`This section <network-"
"logging>` documents this approach in more detail and includes a working "
"socket receiver which can be used as a starting point for you to adapt in"
" your own applications."
msgstr ""
"logging 이 스레드-안전하고, 단일 프로세스의 여러 스레드에서 단일 파일로 로깅 하는 것이 *지원되지만*, 파이썬에서 여러 "
"프로세스가 단일 파일에 액세스하는 것을 직렬화하는 표준적인 방법이 없으므로, *여러 프로세스*\\에서 단일 파일로 로깅 하는 것은 "
"지원되지 *않습니다*. 여러 프로세스에서 하나의 파일에 로그 해야 하는 경우, 이 작업을 수행하는 한 가지 방법은 모든 프로세스가 "
"로그를 :class:`~handlers.SocketHandler` 에 기록하고, 소켓에서 읽어서 파일로 로그 하는 소켓 서버를 "
"구현하는 별도의 프로세스를 사용하는 것입니다. (원한다면, 기존 프로세스 중 하나에서 한 스레드가 이 기능을 전담하도록 할 수 "
"있습니다.) :ref:`이 섹션 <network-logging>`\\에서 이 접근법을 더 자세하게 설명하고, 여러분의 응용 "
"프로그램에 적용하기 위한 출발점으로 사용할 수 있는 작동하는 소켓 수신기를 제공합니다."

#: ../../howto/logging-cookbook.rst:1281
#, fuzzy
msgid ""
"You could also write your own handler which uses the "
":class:`~multiprocessing.Lock` class from the :mod:`multiprocessing` "
"module to serialize access to the file from your processes. The stdlib "
":class:`FileHandler` and subclasses do not make use of "
":mod:`multiprocessing`."
msgstr ""
":mod:`multiprocessing` 모듈의 :class:`~multiprocessing.Lock` 클래스를 사용하는 독자적인 "
"처리기를 작성하여 여러 프로세스에서 파일에 액세스하는 것을 직렬화 할 수 있습니다. 기존 :class:`FileHandler` 와 "
"서브 클래스들은, 앞으로는 가능할 수 있지만, 현재 :mod:`multiprocessing`\\을 사용하지 않습니다. 현재 "
":mod:`multiprocessing` 모듈이 모든 플랫폼에서 작동하는 록 기능을 제공하지는 않는다는 것에 유의하십시오 "
"(https://bugs.python.org/issue3770 를 참조하세요)."

#: ../../howto/logging-cookbook.rst:1288
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to "
"send all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do "
"this; in the example a separate listener process listens for events sent "
"by other processes and logs them according to its own logging "
"configuration. Although the example only demonstrates one way of doing it"
" (for example, you may want to use a listener thread rather than a "
"separate listener process -- the implementation would be analogous) it "
"does allow for completely different logging configurations for the "
"listener and the other processes in your application, and can be used as "
"the basis for code meeting your own specific requirements::"
msgstr ""
"또는, ``Queue`` 와 :class:`QueueHandler` 를 사용하여, 모든 로깅 이벤트를 다중 프로세스 응용 프로그램의"
" 프로세스 중 하나에 보낼 수 있습니다. 다음 예제 스크립트는 이렇게 하는 방법을 보여줍니다; 예제에서 별도의 리스너 프로세스가 "
"다른 프로세스가 보낸 이벤트를 수신하고 자체 로깅 구성에 따라 이벤트를 기록합니다. 이 예제가 한 가지 방법만을 보여 주지만 (예를"
" 들어, 별도의 리스너 프로세스 대신 리스너 스레드를 사용할 수도 있습니다 -- 구현은 비슷할 것입니다), 리스너와 응용 프로그램의"
" 다른 프로세스가 완전히 다른 로깅 구성을 사용하도록 허용하고, 여러분 자신의 특별한 요구 사항을 충족하는 코드의 기초로 사용할 수"
" 있습니다::"

#: ../../howto/logging-cookbook.rst:1299
#, python-format
msgid ""
"# You'll need these imports in your own code\n"
"import logging\n"
"import logging.handlers\n"
"import multiprocessing\n"
"\n"
"# Next two import lines for this demo only\n"
"from random import choice, random\n"
"import time\n"
"\n"
"#\n"
"# Because you'll want to define the logging configurations for listener "
"and workers, the\n"
"# listener and worker process functions take a configurer parameter which"
" is a callable\n"
"# for configuring logging for that process. These functions are also "
"passed the queue,\n"
"# which they use for communication.\n"
"#\n"
"# In practice, you can configure the listener however you want, but note "
"that in this\n"
"# simple example, the listener does not apply level or filter logic to "
"received records.\n"
"# In practice, you would probably want to do this logic in the worker "
"processes, to avoid\n"
"# sending events which would be filtered out between processes.\n"
"#\n"
"# The size of the rotated files is made small so you can see the results "
"easily.\n"
"def listener_configurer():\n"
"    root = logging.getLogger()\n"
"    h = logging.handlers.RotatingFileHandler('mptest.log', 'a', 300, 10)\n"
"    f = logging.Formatter('%(asctime)s %(processName)-10s %(name)s "
"%(levelname)-8s %(message)s')\n"
"    h.setFormatter(f)\n"
"    root.addHandler(h)\n"
"\n"
"# This is the listener process top-level loop: wait for logging events\n"
"# (LogRecords)on the queue and handle them, quit when you get a None for "
"a\n"
"# LogRecord.\n"
"def listener_process(queue, configurer):\n"
"    configurer()\n"
"    while True:\n"
"        try:\n"
"            record = queue.get()\n"
"            if record is None:  # We send this as a sentinel to tell the "
"listener to quit.\n"
"                break\n"
"            logger = logging.getLogger(record.name)\n"
"            logger.handle(record)  # No level or filter logic applied - "
"just do it!\n"
"        except Exception:\n"
"            import sys, traceback\n"
"            print('Whoops! Problem:', file=sys.stderr)\n"
"            traceback.print_exc(file=sys.stderr)\n"
"\n"
"# Arrays used for random selections in this demo\n"
"\n"
"LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING,\n"
"          logging.ERROR, logging.CRITICAL]\n"
"\n"
"LOGGERS = ['a.b.c', 'd.e.f']\n"
"\n"
"MESSAGES = [\n"
"    'Random message #1',\n"
"    'Random message #2',\n"
"    'Random message #3',\n"
"]\n"
"\n"
"# The worker configuration is done at the start of the worker process "
"run.\n"
"# Note that on Windows you can't rely on fork semantics, so each process\n"
"# will run the logging configuration code when it starts.\n"
"def worker_configurer(queue):\n"
"    h = logging.handlers.QueueHandler(queue)  # Just the one handler "
"needed\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # send all messages, for demo; no other level or filter logic "
"applied.\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"# This is the worker process top-level loop, which just logs ten events "
"with\n"
"# random intervening delays before terminating.\n"
"# The print messages are just so you know it's doing something!\n"
"def worker_process(queue, configurer):\n"
"    configurer(queue)\n"
"    name = multiprocessing.current_process().name\n"
"    print('Worker started: %s' % name)\n"
"    for i in range(10):\n"
"        time.sleep(random())\n"
"        logger = logging.getLogger(choice(LOGGERS))\n"
"        level = choice(LEVELS)\n"
"        message = choice(MESSAGES)\n"
"        logger.log(level, message)\n"
"    print('Worker finished: %s' % name)\n"
"\n"
"# Here's where the demo gets orchestrated. Create the queue, create and "
"start\n"
"# the listener, create ten workers and start them, wait for them to "
"finish,\n"
"# then send a None to the queue to tell the listener to finish.\n"
"def main():\n"
"    queue = multiprocessing.Queue(-1)\n"
"    listener = multiprocessing.Process(target=listener_process,\n"
"                                       args=(queue, listener_configurer))"
"\n"
"    listener.start()\n"
"    workers = []\n"
"    for i in range(10):\n"
"        worker = multiprocessing.Process(target=worker_process,\n"
"                                         args=(queue, worker_configurer))"
"\n"
"        workers.append(worker)\n"
"        worker.start()\n"
"    for w in workers:\n"
"        w.join()\n"
"    queue.put_nowait(None)\n"
"    listener.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1404
msgid ""
"A variant of the above script keeps the logging in the main process, in a"
" separate thread::"
msgstr "위의 스크립트 변형은 로깅을 메인 프로세스의 별도의 스레드에서 유지합니다::"

#: ../../howto/logging-cookbook.rst:1407
#, python-brace-format, python-format
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue\n"
"import random\n"
"import threading\n"
"import time\n"
"\n"
"def logger_thread(q):\n"
"    while True:\n"
"        record = q.get()\n"
"        if record is None:\n"
"            break\n"
"        logger = logging.getLogger(record.name)\n"
"        logger.handle(record)\n"
"\n"
"\n"
"def worker_process(q):\n"
"    qh = logging.handlers.QueueHandler(q)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(qh)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, "
"logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    d = {\n"
"        'version': 1,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO',\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'level': 'ERROR',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'level': 'DEBUG',\n"
"            'handlers': ['console', 'file', 'errors']\n"
"        },\n"
"    }\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1), "
"args=(q,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"    logging.config.dictConfig(d)\n"
"    lp = threading.Thread(target=logger_thread, args=(q,))\n"
"    lp.start()\n"
"    # At this point, the main process could do some useful work of its "
"own\n"
"    # Once it's done that, it can wait for the workers to terminate...\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # And now tell the logging thread to finish up, too\n"
"    q.put(None)\n"
"    lp.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1499
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be"
" used by the logging machinery in the main process (even though the "
"logging events are generated in the worker processes) to direct the "
"messages to the appropriate destinations."
msgstr ""
"이 변형은 특정 로거에 대한 구성을 적용하는 방법을 보여줍니다 - 예를 들어, ``foo`` 로거는 ``foo`` 서브 시스템의 "
"모든 이벤트를 ``mplog-foo.log`` 파일에 저장하는 특별한 처리기를 갖고 있습니다. 이것은 메인 프로세스의 로깅 시스템이"
" ( 로깅 이벤트가 작업자 프로세스에서 만들어졌다 하더라도) 메시지를 적절한 대상으로 전달하는 데 사용됩니다."

#: ../../howto/logging-cookbook.rst:1506
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "concurrent.futures.ProcessPoolExecutor 사용하기"

#: ../../howto/logging-cookbook.rst:1508
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to "
"start your worker processes, you need to create the queue slightly "
"differently. Instead of"
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor`\\를 사용하여 작업자 프로세스를 시작하려면, "
"약간 다른 방법으로 큐를 만들어야 합니다."

#: ../../howto/logging-cookbook.rst:1512
msgid "queue = multiprocessing.Queue(-1)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1516
msgid "you should use"
msgstr "대신에, 다음을 사용해야 합니다"

#: ../../howto/logging-cookbook.rst:1518
msgid ""
"queue = multiprocessing.Manager().Queue(-1)  # also works with the "
"examples above"
msgstr ""

#: ../../howto/logging-cookbook.rst:1522
msgid "and you can then replace the worker creation from this::"
msgstr "그런 다음 작업자 생성을::"

#: ../../howto/logging-cookbook.rst:1524
msgid ""
"workers = []\n"
"for i in range(10):\n"
"    worker = multiprocessing.Process(target=worker_process,\n"
"                                     args=(queue, worker_configurer))\n"
"    workers.append(worker)\n"
"    worker.start()\n"
"for w in workers:\n"
"    w.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1533
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "에서 다음과 같이 대체할 수 있습니다 (먼저 :mod:`concurrent.futures`\\를 임포트 하는 것을 기억하십시오)::"

#: ../../howto/logging-cookbook.rst:1535
msgid ""
"with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:\n"
"    for i in range(10):\n"
"        executor.submit(worker_process, queue, worker_configurer)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1540
msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr ""

#: ../../howto/logging-cookbook.rst:1542
msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_"
" or `uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar),"
" multiple worker processes are created to handle client requests. In such"
" environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using"
" a process management tool such as Supervisor - see `Running a logging "
"socket listener in production`_ for more details."
msgstr ""

#: ../../howto/logging-cookbook.rst:1552
msgid "Using file rotation"
msgstr "파일 회전 사용하기"

#: ../../howto/logging-cookbook.rst:1557
#, fuzzy
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a "
"new file and log to that. You may want to keep a certain number of these "
"files, and when that many files have been created, rotate the files so "
"that the number of files and the size of the files both remain bounded. "
"For this usage pattern, the logging package provides a "
":class:`RotatingFileHandler`::"
msgstr ""
"때로는 로그 파일이 특정 크기까지 커지도록 한 다음, 새 파일을 열고 그곳에 로그에 기록하려고 할 수 있습니다. 이 파일들을 특정 "
"수만 유지하고, 그 수 만큼의 파일이 만들어지면, 파일을 회전시켜 파일의 개수와 크기 모두 제한되도록 하고 싶을 수 있습니다. 이 "
"사용 패턴을 위해, logging 패키지는 :class:`~handlers.RotatingFileHandler` 를 제공합니다::"

#: ../../howto/logging-cookbook.rst:1563
#, python-format
msgid ""
"import glob\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"LOG_FILENAME = 'logging_rotatingfile_example.out'\n"
"\n"
"# Set up a specific logger with our desired output level\n"
"my_logger = logging.getLogger('MyLogger')\n"
"my_logger.setLevel(logging.DEBUG)\n"
"\n"
"# Add the log message handler to the logger\n"
"handler = logging.handlers.RotatingFileHandler(\n"
"              LOG_FILENAME, maxBytes=20, backupCount=5)\n"
"\n"
"my_logger.addHandler(handler)\n"
"\n"
"# Log some messages\n"
"for i in range(20):\n"
"    my_logger.debug('i = %d' % i)\n"
"\n"
"# See what files are created\n"
"logfiles = glob.glob('%s*' % LOG_FILENAME)\n"
"\n"
"for filename in logfiles:\n"
"    print(filename)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1589
msgid ""
"The result should be 6 separate files, each with part of the log history "
"for the application:"
msgstr "결과는 6개의 파일이어야 하고, 각기 응용 프로그램에 대한 로그 기록의 일부입니다:"

#: ../../howto/logging-cookbook.rst:1592
msgid ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"
msgstr ""

#: ../../howto/logging-cookbook.rst:1601
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`,"
" and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the "
"suffix (``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"가장 최근의 파일은 항상 :file:`logging_rotatingfile_example.out` 이며, 크기 제한에 도달할 때마다"
" 접미사 ``.1`` 이 붙은 이름으로 변경됩니다. 기존 백업 파일 각각의 이름이 변경되어 접미사가 증가하고 ( ``.1`` 이 "
"``.2`` 가 되는 등) ``.6`` 파일이 지워집니다."

#: ../../howto/logging-cookbook.rst:1606
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr "분명, 이 예제는 로그 길이를 극단적으로 작게 설정합니다. *maxBytes* 를 적절한 값으로 설정하고 싶을 겁니다."

#: ../../howto/logging-cookbook.rst:1614
msgid "Use of alternative formatting styles"
msgstr "대체 포매팅 스타일 사용하기"

#: ../../howto/logging-cookbook.rst:1616
#, python-format
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: "
":class:`string.Template` (added in Python 2.4) and :meth:`str.format` "
"(added in Python 2.6)."
msgstr ""
"logging이 파이썬 표준 라이브러리에 추가되었을 때, 가변 내용으로 메시지를 포맷하는 유일한 방법은 %-포매팅 방법을 사용하는 "
"것이었습니다. 그 이후로, 파이썬은 두 개의 새로운 포매팅 접근법을 얻었습니다: "
":class:`string.Template`\\(파이썬 2.4에 추가됨)과 :meth:`str.format`\\(파이썬 2.6에 "
"추가됨)."

#: ../../howto/logging-cookbook.rst:1622
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which "
"correspond to the other two formatting styles. Backwards compatibility is"
" maintained by default (as you would expect), but by explicitly "
"specifying a style parameter, you get the ability to specify format "
"strings which work with :meth:`str.format` or :class:`string.Template`. "
"Here's an example console session to show the possibilities:"
msgstr ""
"로깅은 (3.2부터) 이 두 가지 추가 포매팅 스타일에 대해 개선된 지원을 제공합니다. :class:`Formatter` 클래스는 "
"``style`` 이라는 추가적인 키워드 매개 변수를 취하도록 개선되었습니다. 기본값은 ``'%'`` 이지만, 다른 두 가지 포매팅"
" 스타일에 해당하는 ``'{'`` 및 ``'$'`` 를 사용할 수 있습니다. (여러분이 기대하듯이) 이전 버전과의 호환성은 "
"기본적으로 유지되지만, style 매개변수를 명시적으로 지정하면 :meth:`str.format` 또는 "
":class:`string.Template` 과 함께 작동하는 포맷 문자열을 지정할 수 있습니다. 다음은 가능성을 보여주기 위한 "
"예제 콘솔 세션입니다:"

#: ../../howto/logging-cookbook.rst:1632
msgid ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',\n"
"...                        style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message',\n"
"...                        style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:1656
#, python-format
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is "
"constructed. That can still use %-formatting, as shown here::"
msgstr ""
"로그로 최종 출력하기 위해 로깅 메시지를 포매팅하는 것은 개별 로깅 메시지가 구성되는 방식과 완전히 별개입니다. 개별 메시지에는 "
"다음과 같이 %-포매팅을 사용할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:1660
#, python-format
msgid ""
">>> logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:1664
#, python-format
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword"
" parameters used only for determining options for how to handle the "
"actual logging call (e.g. the ``exc_info`` keyword parameter to indicate "
"that traceback information should be logged, or the ``extra`` keyword "
"parameter to indicate additional contextual information to be added to "
"the log). So you cannot directly make logging calls using "
":meth:`str.format` or :class:`string.Template` syntax, because internally"
" the logging package uses %-formatting to merge the format string and the"
" variable arguments. There would be no changing this while preserving "
"backward compatibility, since all logging calls which are out there in "
"existing code will be using %-format strings."
msgstr ""
"로깅 호출(``logger.debug()``, ``logger.info()`` 등)은 실제 로깅 메시지 자체를 위해서는 위치 매개 "
"변수만을 취하고, 키워드 매개 변수는 실제 로깅 호출을 어떻게 다뤄야 하는지를 지정하는 옵션을 결정하는 용도로만 사용됩니다 (예를 "
"들어, 트레이스백 정보를 로그 해야 할지를 가리키는 ``exc_info`` 키워드 매개 변수나 로그에 추가되는 문맥 정보를 나타내는"
" ``extra`` 키워드 매개 변수). 그래서 여러분은 :meth:`str.format` 또는 "
":class:`string.Template` 문법을 사용하여 직접 로깅 호출을 할 수 없습니다, 내부적으로 logging 패키지가 "
"%-포매팅을 사용하여 포맷 문자열과 변수 인자를 병합하기 때문입니다. 이전 버전과의 호환성을 유지하는 동안은 이 상황이 바뀌지 않을"
" 것입니다. 기존 코드에 있는 모든 로깅 호출이 %-포맷 문자열을 사용하기 때문입니다."

#: ../../howto/logging-cookbook.rst:1677
#, python-brace-format
msgid ""
"There is, however, a way that you can use {}- and $- formatting to "
"construct your individual log messages. Recall that for a message you can"
" use an arbitrary object as a message format string, and that the logging"
" package will call ``str()`` on that object to get the actual format "
"string. Consider the following two classes::"
msgstr ""
"그러나 {}- 및 $- 포매팅을 사용하여 개별 로그 메시지를 구성하는 방법이 있습니다. 메시지의 경우, 메시지 포맷 문자열로 임의의"
" 객체를 사용할 수 있으며, logging 패키지는 실제 형식 문자열을 얻기 위해 그 객체에 대해 ``str()`` 을 호출한다는 "
"것을 상기하십시오. 다음 두 가지 클래스를 고려하십시오::"

#: ../../howto/logging-cookbook.rst:1683 ../../howto/logging-cookbook.rst:2771
msgid ""
"class BraceMessage:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class DollarMessage:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1701
#, python-brace-format, python-format
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which "
"appears in the formatted log output in place of \"%(message)s\" or "
"\"{message}\" or \"$message\". It's a little unwieldy to use the class "
"names whenever you want to log something, but it's quite palatable if you"
" use an alias such as __ (double underscore --- not to be confused with "
"_, the single underscore used as a synonym/alias for "
":func:`gettext.gettext` or its brethren)."
msgstr ""
"이 중 하나를 포맷 문자열 대신 사용하면, {}- 또는 $-포매팅을 사용하여 포맷된 로그 출력의 \"%(message)s\", "
"\"{message}\" 또는 \"$message\" 자리에 나타나는 실제 \"message\" 부분을 만들 수 있습니다. 어떤 "
"것을 로그 하고 싶을 때마다 클래스 이름을 사용하는 것은 다소 꼴사납지만, __(두 개의 밑줄 ---- "
":func:`gettext.gettext` 나 그 형제들의 동의어/별칭으로 사용되는 _ 과 혼동하지 마세요)와 같은 별칭을 사용하면"
" 꽤 쓸만합니다."

#: ../../howto/logging-cookbook.rst:1709
msgid ""
"The above classes are not included in Python, though they're easy enough "
"to copy and paste into your own code. They can be used as follows "
"(assuming that they're declared in a module called ``wherever``):"
msgstr ""
"위의 클래스가 파이썬에 포함되어 있지는 않지만, 아주 쉽게 여러분의 코드에 복사하여 붙여넣을 수 있습니다. 다음과 같이 사용될 수 "
"있습니다 (``wherever`` 라는 모듈에서 선언되었다고 가정합니다):"

#: ../../howto/logging-cookbook.rst:1713
#, python-brace-format
msgid ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Message with {0} {name}', 2, name='placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Message with coordinates: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:1731
msgid ""
"While the above examples use ``print()`` to show how the formatting "
"works, you would of course use ``logger.debug()`` or similar to actually "
"log using this approach."
msgstr ""
"위의 예제는 ``print()`` 를 사용하여 포매팅이 어떻게 작동하는지 보여주고 있지만, 물론 이 접근법으로 실제 로깅 할 때는 "
"``logger.debug()`` 나 그와 유사한 것을 사용해야 합니다."

#: ../../howto/logging-cookbook.rst:1735
#, fuzzy, python-brace-format
msgid ""
"One thing to note is that you pay no significant performance penalty with"
" this approach: the actual formatting happens not when you make the "
"logging call, but when (and if) the logged message is actually about to "
"be output to a log by a handler. So the only slightly unusual thing which"
" might trip you up is that the parentheses go around the format string "
"and the arguments, not just the format string. That's because the __ "
"notation is just syntax sugar for a constructor call to one of the "
":samp:`{XXX}Message` classes."
msgstr ""
"한 가지 지적할 점은, 이 접근법이 성능상으로 큰 문제가 없다는 것입니다: 실제 포매팅은 로깅 호출을 할 때가 아니라 로깅 된 "
"메시지를 실제로 처리기가 로그로 출력할 때 (그리고 실제로 그렇게 될 때만) 발생합니다. 그래서 여러분이 실수할 수도 있을 특이함은"
" 괄호가 포맷 문자열과 인자들을 모두 감싼다는 것뿐입니다. __ 표기법이 단지 XXXMessage 클래스 중 하나에 대한 생성자 "
"호출의 편의 문법이기 때문입니다."

#: ../../howto/logging-cookbook.rst:1743
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr "원한다면, :class:`LoggerAdapter` 를 사용하여 다음 예제와 같이 위와 유사한 효과를 얻을 수 있습니다::"

#: ../../howto/logging-cookbook.rst:1746
#, python-brace-format
msgid ""
"import logging\n"
"\n"
"class Message:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class StyleAdapter(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Message(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = StyleAdapter(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Hello, {}', 'world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1772
#, fuzzy
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.8 or later."
msgstr "이 스크립트는 파이썬 3.2 이상에서 실행될 때 ``Hello, world!`` 라는 메시지를 기록해야 합니다."

#: ../../howto/logging-cookbook.rst:1781
msgid "Customizing ``LogRecord``"
msgstr "사용자 정의 ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1783
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When"
" an event is logged and not filtered out by a logger's level, a "
":class:`LogRecord` is created, populated with information about the event"
" and then passed to the handlers for that logger (and its ancestors, up "
"to and including the logger where further propagation up the hierarchy is"
" disabled). Before Python 3.2, there were only two places where this "
"creation was done:"
msgstr ""
"모든 로깅 이벤트는 :class:`LogRecord` 인스턴스로 표현됩니다. 이벤트가 로그 되고 로거 수준에 의해 필터링 되지 "
"않으면, :class:`LogRecord` 가 생성되고 이벤트에 대한 정보로 채워진 다음 해당 로거(와 그 조상들, 계층 상위로의 "
"전파가 비활성화된 지점의 로거까지)의 처리기로 전달됩니다. 파이썬 3.2 이전에는, 이 생성이 일어나는 곳이 두 곳밖에 없었습니다:"

#: ../../howto/logging-cookbook.rst:1790
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of "
"logging an event. This invoked :class:`LogRecord` directly to create an "
"instance."
msgstr ""
":meth:`Logger.makeRecord`, 이벤트 로깅의 일반적인 프로세스에서 호출됩니다. 인스턴스를 생성하기 위해 "
":class:`LogRecord` 를 직접 호출합니다."

#: ../../howto/logging-cookbook.rst:1793
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a"
" suitable dictionary has been received over the network (e.g. in pickle "
"form via a :class:`~handlers.SocketHandler`, or in JSON form via an "
":class:`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`, LogRecord에 추가될 어트리뷰트를 포함하는 딕셔너리와 함께 호출됩니다. 보통 적절한 "
"딕셔너리가 네트워크를 통해 (예를 들어, :class:`~handlers.SocketHandler` 를 통해 피클 형태로, 또는 "
":class:`~handlers.HTTPHandler` 를 통해 JSON 형식으로) 수신될 때 호출됩니다."

#: ../../howto/logging-cookbook.rst:1799
msgid ""
"This has usually meant that if you need to do anything special with a "
":class:`LogRecord`, you've had to do one of the following."
msgstr "이것은 보통 :class:`LogRecord` 로 특별한 것을 할 필요가 있다면, 다음 중 하나를 해야 한다는 것을 의미합니다."

#: ../../howto/logging-cookbook.rst:1802
msgid ""
"Create your own :class:`Logger` subclass, which overrides "
":meth:`Logger.makeRecord`, and set it using "
":func:`~logging.setLoggerClass` before any loggers that you care about "
"are instantiated."
msgstr ""
":meth:`Logger.makeRecord` 를 재정의하는 자신만의 :class:`Logger` 서브 클래스를 만들고, 관심 있는"
" 로거의 인스턴스가 만들어지기 전에 :func:`~logging.setLoggerClass` 를 사용하여 설정하십시오."

#: ../../howto/logging-cookbook.rst:1805
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"로거나 처리기에 :class:`Filter`\\를 추가해서 :meth:`~Filter.filter` 메서드가 호출될 때 필요한 "
"특별한 조작을 하십시오."

#: ../../howto/logging-cookbook.rst:1809
msgid ""
"The first approach would be a little unwieldy in the scenario where (say)"
" several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did "
"this last would win."
msgstr ""
"첫 번째 접근법은 여러 라이브러리가 서로 다른 일을 하고 싶어 하는 시나리오에서는 다루기 힘들 것입니다. 각자 자신의 "
":class:`Logger` 서브 클래스를 설정하려고 시도할 것이고, 마지막 것이 이기게 될 것입니다."

#: ../../howto/logging-cookbook.rst:1814
msgid ""
"The second approach works reasonably well for many cases, but does not "
"allow you to e.g. use a specialized subclass of :class:`LogRecord`. "
"Library developers can set a suitable filter on their loggers, but they "
"would have to remember to do this every time they introduced a new logger"
" (which they would do simply by adding new packages or modules and doing "
"::"
msgstr ""
"두 번째 접근법은 많은 경우에 합리적으로 잘 작동하지만, :class:`LogRecord` 의 특별한 서브 클래스를 사용할 수는 "
"없습니다. 라이브러리 개발자는 로거에 적절한 필터를 설정할 수 있지만, 새로운 로거를 도입할 때마다 이를 수행해야 한다는 것을 "
"기억해야 합니다. 이를 고려하지 않는다면 새 패키지나 모듈을 추가하고 모듈 수준에서 단순히 다음과 같이 합니다::"

#: ../../howto/logging-cookbook.rst:1820
msgid "logger = logging.getLogger(__name__)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1822
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger "
"--- so output from that handler would not reflect the intentions of the "
"library developer."
msgstr ""
"이것은 아마도 고려해야 할 많은 것 중 하나일 뿐입니다. 개발자는 자신의 최상위 로거에 첨부된 "
":class:`~logging.NullHandler` 에도 필터를 추가 할 수 있지만, 응용 프로그램 개발자가 하위 수준 라이브러리"
" 로거에 처리기를 연결하면 호출되지 않습니다 --- 그래서 그 처리기로부터의 출력은 라이브러리 개발자의 의도를 반영하지 못합니다."

#: ../../howto/logging-cookbook.rst:1828
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable "
"you can set with :func:`~logging.setLogRecordFactory`, and interrogate "
"with :func:`~logging.getLogRecordFactory`. The factory is invoked with "
"the same signature as the :class:`~logging.LogRecord` constructor, as "
":class:`LogRecord` is the default setting for the factory."
msgstr ""
"파이썬 3.2 이상에서는, :class:`~logging.LogRecord` 생성이 사용자가 지정할 수 있는 팩토리를 통해 "
"수행됩니다. 팩토리는 :func:`~logging.setLogRecordFactory` 로 설정할 수 있고, "
":func:`~logging.getLogRecordFactory` 로 조회할 수 있는 콜러블입니다. 팩토리는 "
":class:`~logging.LogRecord` 생성자와 같은 서명으로 호출되고, 기본 설정은 :class:`LogRecord` "
"입니다."

#: ../../howto/logging-cookbook.rst:1835
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord"
" creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar"
" to this::"
msgstr ""
"이 방법을 사용하면 사용자 정의 팩토리가 LogRecord 생성의 모든 측면을 제어 할 수 있습니다. 예를 들어, 서브 클래스를 "
"반환하거나, 다음과 같은 방법으로 생성된 레코드에 어트리뷰트를 추가 할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:1839
msgid ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1848
msgid ""
"This pattern allows different libraries to chain factories together, and "
"as long as they don't overwrite each other's attributes or "
"unintentionally overwrite the attributes provided as standard, there "
"should be no surprises. However, it should be borne in mind that each "
"link in the chain adds run-time overhead to all logging operations, and "
"the technique should only be used when the use of a :class:`Filter` does "
"not provide the desired result."
msgstr ""
"이 패턴은 서로 다른 라이브러리가 팩토리를 체인으로 연결할 수 있도록 하며, 서로의 어트리뷰트를 덮어쓰거나 의도하지 않게 표준으로 "
"제공된 어트리뷰트를 덮어쓰지 않는 한, 놀랄 일은 없어야 합니다. 그러나 체인의 각 고리는 모든 로깅 작업에 실행시간 오버헤드를 "
"추가하므로, :class:`Filter`\\를 사용해서 원하는 결과를 얻을 수 없을 때만 이 기법을 사용해야 합니다."

#: ../../howto/logging-cookbook.rst:1860
#, fuzzy
msgid "Subclassing QueueHandler and QueueListener- a ZeroMQ example"
msgstr "QueueHandler 서브 클래스 만들기 - ZeroMQ 예제"

#: ../../howto/logging-cookbook.rst:1863 ../../howto/logging-cookbook.rst:1996
#, fuzzy
msgid "Subclass ``QueueHandler``"
msgstr "QueueHandler 서브 클래스 만들기 - ZeroMQ 예제"

#: ../../howto/logging-cookbook.rst:1865
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other "
"kinds of queues, for example a ZeroMQ 'publish' socket. In the example "
"below,the socket is created separately and passed to the handler (as its "
"'queue')::"
msgstr ""
":class:`QueueHandler` 서브 클래스를 사용하여 다른 유형의 큐에 메시지를 보낼 수 있습니다, 예를 들어 ZeroMQ"
" 'publish' 소켓. 아래 예제에서, 소켓은 별도로 생성되어 처리기로 ('queue'\\로) 전달됩니다::"

#: ../../howto/logging-cookbook.rst:1869
msgid ""
"import zmq   # using pyzmq, the Python binding for ZeroMQ\n"
"import json  # for serializing records portably\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB)  # or zmq.PUSH, or other suitable value\n"
"sock.bind('tcp://*:5556')        # or wherever\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1884
msgid ""
"Of course there are other ways of organizing this, for example passing in"
" the data needed by the handler to create the socket::"
msgstr "물론 구성하는 다른 방법이 있습니다. 예를 들어 처리기가 소켓을 만드는데 필요한 데이터를 전달하는 것입니다::"

#: ../../howto/logging-cookbook.rst:1887
msgid ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1902 ../../howto/logging-cookbook.rst:1932
#, fuzzy
msgid "Subclass ``QueueListener``"
msgstr "QueueListener 서브 클래스 만들기 - ZeroMQ 예제"

#: ../../howto/logging-cookbook.rst:1904
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an "
"example::"
msgstr ""
"다른 유형의 큐에서 메시지를 받기 위해 :class:`QueueListener` 의 서브 클래스를 만들 수도 있습니다, 예를 들어 "
"ZeroMQ 'subscribe' 소켓. 다음은 그 예입니다::"

#: ../../howto/logging-cookbook.rst:1907
msgid ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscribe to "
"everything\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1922
#, fuzzy
msgid "Subclassing QueueHandler and QueueListener- a ``pynng`` example"
msgstr "QueueHandler 서브 클래스 만들기 - ZeroMQ 예제"

#: ../../howto/logging-cookbook.rst:1924
msgid ""
"In a similar way to the above section, we can implement a listener and "
"handler using :pypi:`pynng`, which is a Python binding to `NNG "
"<https://nng.nanomsg.org/>`_, billed as a spiritual successor to ZeroMQ. "
"The following snippets illustrate -- you can test them in an environment "
"which has ``pynng`` installed. Just for variety, we present the listener "
"first."
msgstr ""

#: ../../howto/logging-cookbook.rst:1934
msgid ""
"# listener.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"interrupted = False\n"
"\n"
"class NNGSocketListener(logging.handlers.QueueListener):\n"
"\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        # Have a timeout for interruptability, and open a\n"
"        # subscriber socket\n"
"        socket = pynng.Sub0(listen=uri, recv_timeout=500)\n"
"        # The b'' subscription matches all topics\n"
"        topics = kwargs.pop('topics', None) or b''\n"
"        socket.subscribe(topics)\n"
"        # We treat the socket as a queue\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self, block):\n"
"        data = None\n"
"        # Keep looping while not interrupted and no data received over "
"the\n"
"        # socket\n"
"        while not interrupted:\n"
"            try:\n"
"                data = self.queue.recv(block=block)\n"
"                break\n"
"            except pynng.Timeout:\n"
"                pass\n"
"            except pynng.Closed:  # sometimes happens when you hit Ctrl-C"
"\n"
"                break\n"
"        if data is None:\n"
"            return None\n"
"        # Get the logging event sent from a publisher\n"
"        event = json.loads(data.decode('utf-8'))\n"
"        return logging.makeLogRecord(event)\n"
"\n"
"    def enqueue_sentinel(self):\n"
"        # Not used in this implementation, as the socket isn't really a\n"
"        # queue\n"
"        pass\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), "
"topics=b'')\n"
"listener.start()\n"
"print('Press Ctrl-C to stop.')\n"
"try:\n"
"    while True:\n"
"        pass\n"
"except KeyboardInterrupt:\n"
"    interrupted = True\n"
"finally:\n"
"    listener.stop()"
msgstr ""

#: ../../howto/logging-cookbook.rst:2000
#, python-format
msgid ""
"# sender.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"import time\n"
"import random\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"class NNGSocketHandler(logging.handlers.QueueHandler):\n"
"\n"
"    def __init__(self, uri):\n"
"        socket = pynng.Pub0(dial=uri, send_timeout=500)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        # Send the record as UTF-8 encoded JSON\n"
"        d = dict(record.__dict__)\n"
"        data = json.dumps(d)\n"
"        self.queue.send(data.encode('utf-8'))\n"
"\n"
"    def close(self):\n"
"        self.queue.close()\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"handler = NNGSocketHandler(DEFAULT_ADDR)\n"
"# Make sure the process ID is in the output\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    handlers=[logging.StreamHandler(), handler],\n"
"                    format='%(levelname)-8s %(name)10s %(process)6s "
"%(message)s')\n"
"levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')\n"
"msgno = 1\n"
"while True:\n"
"    # Just randomly select some loggers and levels and log away\n"
"    level = random.choice(levels)\n"
"    logger = logging.getLogger(random.choice(logger_names))\n"
"    logger.log(level, 'Message no. %5d' % msgno)\n"
"    msgno += 1\n"
"    delay = random.random() * 2 + 0.5\n"
"    time.sleep(delay)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2047
msgid ""
"You can run the above two snippets in separate command shells. If we run "
"the listener in one shell and run the sender in two separate shells, we "
"should see something like the following. In the first sender shell:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2051
msgid ""
"$ python sender.py\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"(and so on)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2064
msgid "In the second sender shell:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2066
msgid ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2079
msgid "In the listener shell:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2081
msgid ""
"$ python listener.py\n"
"Press Ctrl-C to stop.\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2103
msgid ""
"As you can see, the logging from the two sender processes is interleaved "
"in the listener's output."
msgstr ""

#: ../../howto/logging-cookbook.rst:2108
msgid "An example dictionary-based configuration"
msgstr "딕셔너리 기반 구성의 예"

#: ../../howto/logging-cookbook.rst:2110
msgid ""
"Below is an example of a logging configuration dictionary - it's taken "
"from the `documentation on the Django project "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_. This dictionary is passed to :func:`~config.dictConfig` to "
"put the configuration into effect::"
msgstr ""
"다음은 로깅 구성 딕셔너리의 예입니다 - `장고 프로젝트 설명서 "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_ 에서 가져왔습니다. 이 딕셔너리를 :func:`~config.dictConfig` 로 전달하여 구성을 "
"적용합니다::"

#: ../../howto/logging-cookbook.rst:2114
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} "
"{thread:d} {message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    'filters': {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': False,\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:2163
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/stable/topics/logging"
"/#configuring-logging>`_ of the Django documentation."
msgstr ""
"이 구성에 대한 더 자세한 정보는 장고 설명서의 `관련 섹션 "
"<https://docs.djangoproject.com/en/stable/topics/logging/#configuring-"
"logging>`_ 을 참조하세요."

#: ../../howto/logging-cookbook.rst:2170
msgid "Using a rotator and namer to customize log rotation processing"
msgstr "rotator와 namer를 사용해서 로그 회전 처리하기"

#: ../../howto/logging-cookbook.rst:2172
#, fuzzy
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following runnable script, which shows gzip compression of the log file::"
msgstr "다음 코드 조각에 namer 와 rotator를 정의하는 예가 있는데, 로그 파일을 zlib 기반으로 압축합니다::"

#: ../../howto/logging-cookbook.rst:2175
#, python-brace-format, python-format
msgid ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, "
"backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Message no. {i + 1}')"
msgstr ""

#: ../../howto/logging-cookbook.rst:2203
msgid ""
"After running this, you will see six new files, five of which are "
"compressed:"
msgstr ""

#: ../../howto/logging-cookbook.rst:2205
msgid ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Message no. 996\n"
"2023-01-20 02:28:17,767 Message no. 997\n"
"2023-01-20 02:28:17,767 Message no. 998"
msgstr ""

#: ../../howto/logging-cookbook.rst:2216
msgid "A more elaborate multiprocessing example"
msgstr "좀 더 정교한 multiprocessing 예제"

#: ../../howto/logging-cookbook.rst:2218
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be "
"implemented in a real multiprocessing scenario."
msgstr ""
"다음 동작하는 예제에서는 구성 파일을 사용하여 로깅을 multiprocessing과 함께 사용하는 방법을 보여줍니다. 구성은 매우 "
"간단하지만, 실제 multiprocessing 시나리오에서 더 복잡한 구성을 구현할 수 있음을 예시합니다."

#: ../../howto/logging-cookbook.rst:2223
msgid ""
"In the example, the main process spawns a listener process and some "
"worker processes. Each of the main process, the listener and the workers "
"have three separate configurations (the workers all share the same "
"configuration). We can see logging in the main process, how the workers "
"log to a QueueHandler and how the listener implements a QueueListener and"
" a more complex logging configuration, and arranges to dispatch events "
"received via the queue to the handlers specified in the configuration. "
"Note that these configurations are purely illustrative, but you should be"
" able to adapt this example to your own scenario."
msgstr ""
"이 예에서, 주 프로세스는 리스너 프로세스와 몇 개의 작업자 프로세스를 생성합니다. 주 프로세스, 리스너 및 작업자를 위한 세 가지"
" 구성이 있습니다 (모든 작업자는 같은 구성을 공유합니다). 주 프로세스에서의 로깅, 작업자가 QueueHandler에 로그 하는 "
"방법, 그리고 리스너가 QueueListener 및 더욱 복잡한 로깅 구성을 구현하고 큐를 통해 수신한 이벤트를 구성에서 지정된 "
"처리기로 전달하도록 배치하는 는 방법을 볼 수 있습니다. 이러한 구성은 설명을 위한 것이지만, 이 예제를 여러분 자신의 시나리오에 "
"적용할 수 있어야 합니다."

#: ../../howto/logging-cookbook.rst:2233
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how"
" it works::"
msgstr "스크립트는 다음과 같습니다 - 독스트링과 주석이 어떻게 작동하는지 잘 설명하기를 바랍니다::"

#: ../../howto/logging-cookbook.rst:2236
#, python-brace-format, python-format
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue, Event, current_process\n"
"import os\n"
"import random\n"
"import time\n"
"\n"
"class MyHandler:\n"
"    \"\"\"\n"
"    A simple handler for logging events. It runs in the listener process "
"and\n"
"    dispatches events to loggers based on the name in the received "
"record,\n"
"    which then get dispatched, by the logging system, to the handlers\n"
"    configured for those loggers.\n"
"    \"\"\"\n"
"\n"
"    def handle(self, record):\n"
"        if record.name == \"root\":\n"
"            logger = logging.getLogger()\n"
"        else:\n"
"            logger = logging.getLogger(record.name)\n"
"\n"
"        if logger.isEnabledFor(record.levelno):\n"
"            # The process name is transformed just to show that it's the "
"listener\n"
"            # doing the logging to files and console\n"
"            record.processName = '%s (for %s)' % (current_process().name,"
" record.processName)\n"
"            logger.handle(record)\n"
"\n"
"def listener_process(q, stop_event, config):\n"
"    \"\"\"\n"
"    This could be done in the main process, but is just done in a "
"separate\n"
"    process for illustrative purposes.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    starts the listener and waits for the main process to signal "
"completion\n"
"    via the event. The listener is then stopped, and the process exits.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    listener = logging.handlers.QueueListener(q, MyHandler())\n"
"    listener.start()\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled logger "
"...')\n"
"    stop_event.wait()\n"
"    listener.stop()\n"
"\n"
"def worker_process(config):\n"
"    \"\"\"\n"
"    A number of these are spawned for the purpose of illustration. In\n"
"    practice, they could be a heterogeneous bunch of processes rather "
"than\n"
"    ones which are identical to each other.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    and logs a hundred messages with random levels to randomly selected\n"
"    loggers.\n"
"\n"
"    A small sleep is added to allow other processes a chance to run. This"
"\n"
"    is not strictly needed, but it mixes the output from the different\n"
"    processes a bit more than if it's left out.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, "
"logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled logger "
"...')\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"        time.sleep(0.01)\n"
"\n"
"def main():\n"
"    q = Queue()\n"
"    # The main process gets a simple configuration which prints to the "
"console.\n"
"    config_initial = {\n"
"        'version': 1,\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO'\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The worker process configuration is just a QueueHandler attached to"
" the\n"
"    # root logger, which allows all messages to be sent to the queue.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in"
" the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_worker = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'handlers': {\n"
"            'queue': {\n"
"                'class': 'logging.handlers.QueueHandler',\n"
"                'queue': q\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['queue'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The listener process configuration shows that the full flexibility "
"of\n"
"    # logging configuration is available to dispatch events to handlers "
"however\n"
"    # you want.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in"
" the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_listener = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            },\n"
"            'simple': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(name)-15s %(levelname)-8s %(processName)-10s"
" %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'formatter': 'simple',\n"
"                'level': 'INFO'\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"                'level': 'ERROR'\n"
"            }\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console', 'file', 'errors'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # Log some initial events, just to show that logging in the parent "
"works\n"
"    # normally.\n"
"    logging.config.dictConfig(config_initial)\n"
"    logger = logging.getLogger('setup')\n"
"    logger.info('About to create workers ...')\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1),\n"
"                     args=(config_worker,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"        logger.info('Started worker: %s', wp.name)\n"
"    logger.info('About to create listener ...')\n"
"    stop_event = Event()\n"
"    lp = Process(target=listener_process, name='listener',\n"
"                 args=(q, stop_event, config_listener))\n"
"    lp.start()\n"
"    logger.info('Started listener')\n"
"    # We now hang around for the workers to finish their work.\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # Workers all done, listening can now stop.\n"
"    # Logging in the parent still works normally.\n"
"    logger.info('Telling listener to stop ...')\n"
"    stop_event.set()\n"
"    lp.join()\n"
"    logger.info('All done.')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:2445
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "SysLogHandler로 전송된 메시지에 BOM 삽입하기"

#: ../../howto/logging-cookbook.rst:2447
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as"
" a set of bytes which have the following structure: an optional pure-"
"ASCII component, followed by a UTF-8 Byte Order Mark (BOM), followed by "
"Unicode encoded using UTF-8. (See the :rfc:`relevant section of the "
"specification <5424#section-6>`.)"
msgstr ""
":rfc:`5424` 는 유니코드 메시지가 다음 구조를 갖는 바이트들로 syslog 데몬에 전송되어야 함을 요구합니다: 선택적인 "
"순수 ASCII 구성 요소, 그 뒤를 이어 UTF-8 바이트 순서 표식 (BOM), 그 뒤를 이어 UTF-8으로 인코딩된 유니코드."
" (:rfc:`이 규격의 관련 절 <5424#section-6>` 을 참조하십시오.)"

#: ../../howto/logging-cookbook.rst:2453
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler`"
" to insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"파이썬 3.1에서, BOM을 메시지에 삽입하는 코드가 :class:`~logging.handlers.SysLogHandler` 에 "
"추가되었지만, 유감스럽게도, BOM이 메시지의 시작 부분에 나타나서 그 앞에 순수 ASCII 구성 요소를 허락하지 않도록 잘못 "
"구현되었습니다."

#: ../../howto/logging-cookbook.rst:2459
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, "
"and if you want to produce :rfc:`5424`-compliant messages which include a"
" BOM, an optional pure-ASCII sequence before it and arbitrary Unicode "
"after it, encoded using UTF-8, then you need to do the following:"
msgstr ""
"이 동작이 잘못됨에 따라, 잘못된 BOM 삽입 코드가 파이썬 3.2.4 이상에서 제거되었습니다. 그러나, 올바른 코드로 대체되지는 "
"않았고, BOM을 포함하고, 그 앞에 순수 ASCII 시퀀스, 그 뒤에 UTF-8으로 인코딩된 임의의 유니코드로 구성된 "
":rfc:`5424`-호환 메시지를 생성하려는 경우 다음과 같이 해야 합니다:"

#: ../../howto/logging-cookbook.rst:2465
msgid ""
"Attach a :class:`~logging.Formatter` instance to your "
":class:`~logging.handlers.SysLogHandler` instance, with a format string "
"such as::"
msgstr ""
":class:`~logging.Formatter` 인스턴스를 "
":class:`~logging.handlers.SysLogHandler` 인스턴스에 다음과 같은 포맷 문자열과 함께 첨부하십시오::"

#: ../../howto/logging-cookbook.rst:2469
msgid "'ASCII section\\ufeffUnicode section'"
msgstr ""

#: ../../howto/logging-cookbook.rst:2471
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded "
"as a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"유니코드 코드 포인트 U+FEFF는, UTF-8을 사용하여 인코딩될 때, UTF-8 BOM으로 인코딩됩니다 -- 바이트열 "
"``b'\\xef\\xbb\\xbf'``."

#: ../../howto/logging-cookbook.rst:2474
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make "
"sure that the data that appears in there after substitution is always "
"ASCII (that way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"ASCII section을 원하는 자리 표시기로 바꾸십시오. 그러나 치환 후 나타나는 데이터가 항상 ASCII임미 보장되어야 합니다"
" (그렇게 되면, UTF-8 인코딩 이후에는 변경되지 않은 채로 유지됩니다)."

#: ../../howto/logging-cookbook.rst:2478
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the "
"data which appears there after substitution contains characters outside "
"the ASCII range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Unidcode section을 원하는 자리 표시기로 바꾸십시오; 치환 후 나타나는 데이터에 ASCII 범위를 벗어나는 문자가 "
"포함되어 있어도 괜찮습니다 -- UTF-8을 사용하여 인코딩됩니다."

#: ../../howto/logging-cookbook.rst:2482
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your "
"syslog daemon may complain."
msgstr ""
"포맷된 된 메시지는 ``SysLogHandler`` 에 의해 UTF-8 인코딩을 사용하여 인코딩\\*됩니다*. 위의 규칙을 따르는 "
"경우, :rfc:`5424`-호환 메시지를 생성할 수 있어야 합니다. 그렇지 않으면, logging이 불평하지 않을 수도 있지만, "
"메시지가 RFC 5424와 호환되지 않고 syslog 데몬이 불평 할 수 있습니다."

#: ../../howto/logging-cookbook.rst:2489
msgid "Implementing structured logging"
msgstr "구조적 로깅 구현"

#: ../../howto/logging-cookbook.rst:2491
msgid ""
"Although most logging messages are intended for reading by humans, and "
"thus not readily machine-parseable, there might be circumstances where "
"you want to output messages in a structured format which *is* capable of "
"being parsed by a program (without needing complex regular expressions to"
" parse the log message). This is straightforward to achieve using the "
"logging package. There are a number of ways in which this could be "
"achieved, but the following is a simple approach which uses JSON to "
"serialise the event in a machine-parseable manner::"
msgstr ""
"대부분의 로깅 메시지는 사람이 읽을 수 있도록 만들어졌기 때문에 쉽게 기계에서 파싱 할 수 없지만, 프로그램에서 (복잡한 정규식을 "
"사용하지 않고도) 구문 분석할 수 *있는* 구조화된 포맷으로 메시지를 출력하려는 상황이 있을 수 있습니다. 이것은 logging "
"패키지를 사용하여 쉽게 달성 할 수 있습니다. 이것이 달성될 수 있는 여러 가지 방법이 있지만, 다음은 JSON을 사용하여 기계가 "
"파싱할 수 있는 방식으로 이벤트를 직렬화하는 간단한 접근법입니다::"

#: ../../howto/logging-cookbook.rst:2499
#, python-format
msgid ""
"import json\n"
"import logging\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.message, json.dumps(self.kwargs))\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))"
msgstr ""

#: ../../howto/logging-cookbook.rst:2515
msgid "If the above script is run, it prints:"
msgstr "위의 스크립트가 실행되면 다음과 같이 인쇄됩니다:"

#: ../../howto/logging-cookbook.rst:2517
#, python-brace-format
msgid ""
"message 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", "
"\"foo\": \"bar\"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:2521 ../../howto/logging-cookbook.rst:2563
msgid ""
"Note that the order of items might be different according to the version "
"of Python used."
msgstr "항목의 순서는 사용된 파이썬 버전에 따라 다를 수 있습니다."

#: ../../howto/logging-cookbook.rst:2524
msgid ""
"If you need more specialised processing, you can use a custom JSON "
"encoder, as in the following complete example::"
msgstr "좀 더 특별한 처리가 필요한 경우, 다음 예제와 같이 사용자 정의 JSON 인코더를 사용할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:2527
#, python-brace-format, python-format
msgid ""
"import json\n"
"import logging\n"
"\n"
"\n"
"class Encoder(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Encoder().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.message, s)\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:2557
msgid "When the above script is run, it prints:"
msgstr "위의 스크립트를 실행하면 다음과 같이 인쇄합니다:"

#: ../../howto/logging-cookbook.rst:2559
#, python-brace-format
msgid "message 1 >>> {\"snowman\": \"\\u2603\", \"set_value\": [1, 2, 3]}"
msgstr ""

#: ../../howto/logging-cookbook.rst:2572
msgid "Customizing handlers with :func:`dictConfig`"
msgstr ":func:`dictConfig`\\로 처리기를 사용자 정의하기"

#: ../../howto/logging-cookbook.rst:2574
msgid ""
"There are times when you want to customize logging handlers in particular"
" ways, and if you use :func:`dictConfig` you may be able to do this "
"without subclassing. As an example, consider that you may want to set the"
" ownership of a log file. On POSIX, this is easily done using "
":func:`shutil.chown`, but the file handlers in the stdlib don't offer "
"built-in support. You can customize handler creation using a plain "
"function such as::"
msgstr ""
"특정 상황에서 로깅 처리기를 사용자 정의하고 싶을 때가 있고, :func:`dictConfig`\\를 사용하고 있다면 서브 클래스를"
" 만들지 않고도 이 작업을 수행 할 수 있습니다. 예를 들어, 로그 파일의 소유권을 설정하고 싶다고 합시다. POSIX에서, "
":func:`shutil.chown` 을 사용하면 쉽게 할 수 있지만, 표준 라이브러리의 파일 처리기는 내장된 지원을 제공하지 "
"않습니다. 다음과 같은 일반 함수를 사용하여 처리기 생성을 사용자 정의 할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:2581
msgid ""
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2588
msgid ""
"You can then specify, in a logging configuration passed to "
":func:`dictConfig`, that a logging handler be created by calling this "
"function::"
msgstr ""
"그런 다음, :func:`dictConfig` 에 전달되는 로깅 구성에서, 이 함수를 호출하여 로깅 처리기를 생성하도록 지정할 수 "
"있습니다::"

#: ../../howto/logging-cookbook.rst:2591
#, python-brace-format, python-format
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable"
"\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}"
msgstr ""

#: ../../howto/logging-cookbook.rst:2621
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"이 예제에서는 단지 예를 들기 위해 ``pulse`` 라는 사용자와 그룹을 사용하여 소유권을 설정합니다. 작동하는 스크립트 "
"``chowntest.py`` 로 정리하면::"

#: ../../howto/logging-cookbook.rst:2625
#, python-brace-format, python-format
msgid ""
"import logging, logging.config, os, shutil\n"
"\n"
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable"
"\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}\n"
"\n"
"logging.config.dictConfig(LOGGING)\n"
"logger = logging.getLogger('mylogger')\n"
"logger.debug('A debug message')"
msgstr ""

#: ../../howto/logging-cookbook.rst:2668
msgid "To run this, you will probably need to run as ``root``:"
msgstr "이것을 실행하기 위해서는, 아마도 ``root`` 로 실행해야 할 것입니다:"

#: ../../howto/logging-cookbook.rst:2670
msgid ""
"$ sudo python3.3 chowntest.py\n"
"$ cat chowntest.log\n"
"2013-11-05 09:34:51,128 DEBUG mylogger A debug message\n"
"$ ls -l chowntest.log\n"
"-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log"
msgstr ""

#: ../../howto/logging-cookbook.rst:2678
msgid ""
"Note that this example uses Python 3.3 because that's where "
":func:`shutil.chown` makes an appearance. This approach should work with "
"any Python version that supports :func:`dictConfig` - namely, Python 2.7,"
" 3.2 or later. With pre-3.3 versions, you would need to implement the "
"actual ownership change using e.g. :func:`os.chown`."
msgstr ""
"이 예제는 :func:`shutil.chown` 이 등장한 파이썬 3.3을 사용합니다. 이 접근법은 "
":func:`dictConfig`\\를 지원하는 모든 파이썬 버전에서 작동합니다 - 파이썬 2.7, 3.2 이상. 3.3 이전 "
"버전의 경우, (예를 들어) :func:`os.chown` 을 사용하여 실제 소유권 변경을 구현해야 합니다."

#: ../../howto/logging-cookbook.rst:2684
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr "실제로는, 처리기 생성 함수가 프로젝트 어딘가에 있는 유틸리티 모듈에 있을 수 있습니다. 구성에 있는 다음과 같은 줄 대신::"

#: ../../howto/logging-cookbook.rst:2687
msgid "'()': owned_file_handler,"
msgstr ""

#: ../../howto/logging-cookbook.rst:2689
msgid "you could use e.g.::"
msgstr "예를 들면 이렇게 쓸 수 있습니다::"

#: ../../howto/logging-cookbook.rst:2691
msgid "'()': 'ext://project.util.owned_file_handler',"
msgstr ""

#: ../../howto/logging-cookbook.rst:2693
msgid ""
"where ``project.util`` can be replaced with the actual name of the "
"package where the function resides. In the above working script, using "
"``'ext://__main__.owned_file_handler'`` should work. Here, the actual "
"callable is resolved by :func:`dictConfig` from the ``ext://`` "
"specification."
msgstr ""
"여기서 ``project.util`` 은 함수가 있는 패키지의 실제 이름으로 바꿀 수 있습니다. 위의 작업 스크립트에서 "
"``'ext://__main__.owned_file_handler'`` 를 사용해도 됩니다. 여기서, 실제 콜러블은 "
"``ext://`` 스펙으로부터 :func:`dictConfig` 에 의해 결정됩니다."

#: ../../howto/logging-cookbook.rst:2698
msgid ""
"This example hopefully also points the way to how you could implement "
"other types of file change - e.g. setting specific POSIX permission bits "
"- in the same way, using :func:`os.chmod`."
msgstr ""
"이 예제는 희망하건대 다른 형태의 파일 변경을 - 예를 들어 특정 POSIX 권한 비트 설정 - 같은 방법으로 "
"(:func:`os.chmod` 를 사용해서) 구현하는 방법도 알려줍니다."

#: ../../howto/logging-cookbook.rst:2702
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating "
"file handlers, or a different type of handler altogether."
msgstr ""
"물론 이 접근법은 :class:`~logging.FileHandler` 이외의 처리기 유형으로도 확장될 수 있습니다 - 예를 들어,"
" 회전 파일 처리기 중 하나 또는 다른 유형의 처리기 모두."

#: ../../howto/logging-cookbook.rst:2712
msgid "Using particular formatting styles throughout your application"
msgstr "응용 프로그램 전체에서 특정 포맷 스타일 사용하기"

#: ../../howto/logging-cookbook.rst:2714
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword"
" parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final "
"output to logs, and is completely orthogonal to how an individual logging"
" message is constructed."
msgstr ""
"파이썬 3.2에서, :class:`~logging.Formatter` 는 ``style`` 키워드 매개변수를 얻었는데, 이전 "
"버전과의 호환성을 위해 ``%`` 를 기본값으로 사용하면서 ``{`` 또는 ``$`` 를 지정하면 :meth:`str.format`"
" 과 :class:`string.Template` 에 의해 지원되는 포매팅 접근법을 사용할 수 있도록 합니다. 이것은 로그 되는 "
"최종 출력으로 로깅 메시지를 포매팅하는 것과 관계된 것이고, 개별 로깅 메시지가 만들어지는 방법과는 무관함에 주의하십시오."

#: ../../howto/logging-cookbook.rst:2721
#, fuzzy, python-format
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only "
"take positional parameters for the actual logging message itself, with "
"keyword parameters used only for determining options for how to handle "
"the logging call (e.g. the ``exc_info`` keyword parameter to indicate "
"that traceback information should be logged, or the ``extra`` keyword "
"parameter to indicate additional contextual information to be added to "
"the log). So you cannot directly make logging calls using "
":meth:`str.format` or :class:`string.Template` syntax, because internally"
" the logging package uses %-formatting to merge the format string and the"
" variable arguments. There would be no changing this while preserving "
"backward compatibility, since all logging calls which are out there in "
"existing code will be using %-format strings."
msgstr ""
"로깅 호출(:meth:`~Logger.debug`, :meth:`~Logger.info` 등)은 실제 로깅 메시지 자체를 위해서는 "
"위치 매개 변수만을 취하고, 키워드 매개 변수는 실제 로깅 호출을 어떻게 다뤄야 하는지를 지정하는 옵션을 결정하는 용도로만 "
"사용됩니다 (예를 들어, 트레이스백 정보를 로그 해야 할지를 가리키는 ``exc_info`` 키워드 매개 변수나 로그에 추가되는 "
"문맥 정보를 나타내는 ``extra`` 키워드 매개 변수). 그래서 여러분은 :meth:`str.format` 또는 "
":class:`string.Template` 문법을 사용하여 직접 로깅 호출을 할 수 없습니다, 내부적으로 logging 패키지가 "
"%-포매팅을 사용하여 포맷 문자열과 변수 인자를 병합하기 때문입니다. 이전 버전과의 호환성을 유지하는 동안은 이 상황이 바뀌지 않을"
" 것입니다. 기존 코드에 있는 모든 로깅 호출이 %-포맷 문자열을 사용하기 때문입니다."

#: ../../howto/logging-cookbook.rst:2733
#, python-format
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems"
" because any existing code could be using a given logger name and using "
"%-formatting."
msgstr ""
"포맷 스타일을 특정 로거와 연관시키는 제안이 있었지만, 이전 버전과의 호환성 문제가 있는데, 기존 코드가 그 로거 이름으로 "
"%-포매팅을 사용할 수 있기 때문입니다."

#: ../../howto/logging-cookbook.rst:2737
msgid ""
"For logging to work interoperably between any third-party libraries and "
"your code, decisions about formatting need to be made at the level of the"
" individual logging call. This opens up a couple of ways in which "
"alternative formatting styles can be accommodated."
msgstr ""
"제삼자 라이브러리와 여러분의 코드 간에 상호 운용이 가능하도록 로깅 하려면, 개별 로깅 호출 수준에서 포매팅을 결정해야 합니다. "
"이렇게 할 때 대체 포매팅 스타일을 수용 할 수 있는 몇 가지 길이 열립니다."

#: ../../howto/logging-cookbook.rst:2744
msgid "Using LogRecord factories"
msgstr "LogRecord 팩토리 사용"

#: ../../howto/logging-cookbook.rst:2746
#, python-format
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes "
"mentioned above, the logging package gained the ability to allow users to"
" set their own :class:`LogRecord` subclasses, using the "
":func:`setLogRecordFactory` function. You can use this to set your own "
"subclass of :class:`LogRecord`, which does the Right Thing by overriding "
"the :meth:`~LogRecord.getMessage` method. The base class implementation "
"of this method is where the ``msg % args`` formatting happens, and where "
"you can substitute your alternate formatting; however, you should be "
"careful to support all formatting styles and allow %-formatting as the "
"default, to ensure interoperability with other code. Care should also be "
"taken to call ``str(self.msg)``, just as the base implementation does."
msgstr ""
"파이썬 3.2에서, 위에서 언급 한 :class:`~logging.Formatter` 변경 사항과 함께, logging 패키지는 "
":func:`setLogRecordFactory` 함수를 사용하여 사용자가 자신의 :class:`LogRecord` 서브 클래스를 "
"설정할 수 있는 기능을 얻었습니다. 이것을 사용하면, 원하는 일을 하도록 :meth:`~LogRecord.getMessage` "
"메서드를 재정의하는 여러분 자신의 :class:`LogRecord` 서브 클래스를 설정할 수 있습니다. 이 메서드의 베이스 클래스 "
"구현이 ``msg % args`` 포매팅이 일어나는 곳이며, 여러분이 대체 포매팅으로 치환할 수 있는 곳입니다; 그러나, 모든 "
"포매팅 스타일을 지원하면서 다른 코드와의 상호 운용성을 보장하기 위해 %-포매팅을 기본값으로 사용하도록 주의해야 합니다. 또한, "
"베이스 구현과 마찬가지로 ``str(self.msg)`` 를 호출하도록 주의해야 합니다."

#: ../../howto/logging-cookbook.rst:2757
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and "
":class:`LogRecord` for more information."
msgstr ""
"자세한 정보는 :func:`setLogRecordFactory`\\와 :class:`LogRecord` 에 대한 레퍼런스 설명서를 "
"참조하십시오."

#: ../../howto/logging-cookbook.rst:2762
msgid "Using custom message objects"
msgstr "사용자 정의 메시지 객체 사용"

#: ../../howto/logging-cookbook.rst:2764
#, python-brace-format
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- "
"formatting to construct your individual log messages. You may recall "
"(from :ref:`arbitrary-object-messages`) that when logging you can use an "
"arbitrary object as a message format string, and that the logging package"
" will call :func:`str` on that object to get the actual format string. "
"Consider the following two classes::"
msgstr ""
"{}- 및 $-포매팅을 사용하여 개별 로그 메시지를 작성할 수 있는 또 다른, 아마도 더 간단한 방법이 있습니다. (:ref"
":`arbitrary-object-messages`\\에서) 로깅 할 때 임의의 객체를 메시지 포맷 문자열로 사용할 수 있고, "
"logging 패키지는 그 객체에 대해 :func:`str` 을 호출하여 실제 형식 문자열을 얻는다고 했던 것을 기억하실 수 있을 "
"겁니다. 다음 두 클래스를 생각해봅시다::"

#: ../../howto/logging-cookbook.rst:2789
#, python-brace-format, python-format
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which "
"appears in the formatted log output in place of “%(message)s” or "
"“{message}” or “$message”. If you find it a little unwieldy to use the "
"class names whenever you want to log something, you can make it more "
"palatable if you use an alias such as ``M`` or ``_`` for the message (or "
"perhaps ``__``, if you are using ``_`` for localization)."
msgstr ""
"이 중 하나를 포맷 문자열 대신 사용하면, {}- 또는 $-포매팅을 사용하여 포맷된 로그 출력의 \"%(message)s\", "
"\"{message}\" 또는 \"$message\" 자리에 나타나는 실제 \"message\" 부분을 만들 수 있습니다. 어떤 "
"것을 로그 하고 싶을 때마다 클래스 이름을 사용하는 것이 다소 꼴사납다면, 메시지에 ``M`` 이나 ``_`` 과 같은 별칭을 "
"사용해서 더 쓸만하게 만들 수 있습니다 (또는 지역화에 ``_`` 를 사용하고 있다면, 아마도 ``__``)."

#: ../../howto/logging-cookbook.rst:2797
msgid ""
"Examples of this approach are given below. Firstly, formatting with "
":meth:`str.format`::"
msgstr "이 접근법의 예가 아래에 나와 있습니다. 먼저, :meth:`str.format` 를 사용하는 포매팅입니다::"

#: ../../howto/logging-cookbook.rst:2800
#, python-brace-format
msgid ""
">>> __ = BraceMessage\n"
">>> print(__('Message with {0} {1}', 2, 'placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', "
"point=p))\n"
"Message with coordinates: (0.50, 0.50)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2811
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "두 번째로, :class:`string.Template` 를 사용하는 포매팅입니다::"

#: ../../howto/logging-cookbook.rst:2813
msgid ""
">>> __ = DollarMessage\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:2818
#, fuzzy, python-brace-format
msgid ""
"One thing to note is that you pay no significant performance penalty with"
" this approach: the actual formatting happens not when you make the "
"logging call, but when (and if) the logged message is actually about to "
"be output to a log by a handler. So the only slightly unusual thing which"
" might trip you up is that the parentheses go around the format string "
"and the arguments, not just the format string. That’s because the __ "
"notation is just syntax sugar for a constructor call to one of the "
":samp:`{XXX}Message` classes shown above."
msgstr ""
"한 가지 지적할 점은, 이 접근법이 성능상으로 큰 문제가 없다는 것입니다: 실제 포매팅은 로깅 호출을 할 때가 아니라 로깅 된 "
"메시지를 실제로 처리기가 로그로 출력할 때 (그리고 실제로 그렇게 될 때만) 발생합니다. 그래서 여러분이 실수할 수도 있을 특이함은"
" 괄호가 포맷 문자열과 인자들을 모두 감싼다는 것뿐입니다. __ 표기법이 단지 ``XXXMessage`` 클래스 중 하나에 대한 "
"생성자 호출의 편의 문법이기 때문입니다."

#: ../../howto/logging-cookbook.rst:2832
msgid "Configuring filters with :func:`dictConfig`"
msgstr ":func:`dictConfig`\\로 필터 구성하기"

#: ../../howto/logging-cookbook.rst:2834
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, "
"though it might not be obvious at first glance how to do it (hence this "
"recipe). Since :class:`~logging.Filter` is the only filter class included"
" in the standard library, and it is unlikely to cater to many "
"requirements (it's only there as a base class), you will typically need "
"to define your own :class:`~logging.Filter` subclass with an overridden "
":meth:`~logging.Filter.filter` method. To do this, specify the ``()`` key"
" in the configuration dictionary for the filter, specifying a callable "
"which will be used to create the filter (a class is the most obvious, but"
" you can provide any callable which returns a :class:`~logging.Filter` "
"instance). Here is a complete example::"
msgstr ""
":func:`~logging.config.dictConfig` 를 사용하여 필터를 구성할 수 *있습니다*. 하지만 처음에는 어떻게 "
"해야 할지 명확하지 않을 수 있습니다 (그래서 이 조리법을 제공합니다). :class:`~logging.Filter` 가 표준 "
"라이브러리에 포함된 유일한 필터 클래스이고, 많은 요구 사항을 충족시키지는 않을 것이기 때문에 (오직 베이스 클래스로 제공됩니다),"
" 일반적으로 :meth:`~logging.Filter.filter` 메서드를 재정의하는 여러분 자신의 "
":class:`~logging.Filter` 서브 클래스를 정의할 필요가 있습니다. 이렇게 하려면, 필터를 생성하는 데 사용될 "
"콜러블을 필터의 구성 딕셔너리에 ``()`` 키로 지정하십시오 (클래스가 가장 분명하지만 "
":class:`~logging.Filter` 인스턴스를 반환하는 콜러블은 모두 가능합니다). 다음은 완전한 예입니다::"

#: ../../howto/logging-cookbook.rst:2845
#, python-brace-format
msgid ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MyFilter(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'changed: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'myfilter': {\n"
"            '()': MyFilter,\n"
"            'param': 'noshow',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['myfilter']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['console']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('hello')\n"
"    logging.debug('hello - noshow')"
msgstr ""

#: ../../howto/logging-cookbook.rst:2887
msgid ""
"This example shows how you can pass configuration data to the callable "
"which constructs the instance, in the form of keyword parameters. When "
"run, the above script will print:"
msgstr ""
"이 예제는 인스턴스를 만드는 콜러블로 키워드 매개 변수 형식으로 구성 데이터를 전달하는 방법을 보여줍니다. 실행하면, 위의 "
"스크립트는 다음을 인쇄합니다:"

#: ../../howto/logging-cookbook.rst:2891
msgid "changed: hello"
msgstr ""

#: ../../howto/logging-cookbook.rst:2895
msgid "which shows that the filter is working as configured."
msgstr "필터가 구성된 대로 작동하고 있음을 보여줍니다."

#: ../../howto/logging-cookbook.rst:2897
msgid "A couple of extra points to note:"
msgstr "주목해야 할 몇 가지 추가 사항:"

#: ../../howto/logging-cookbook.rst:2899
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if"
" it lives in a different module, and you can't import it directly where "
"the configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you "
"could have used the text ``'ext://__main__.MyFilter'`` instead of "
"``MyFilter`` in the above example."
msgstr ""
"구성에서 직접 참조할 수 없는 경우 (예를 들어, 다른 모듈에 있고 구성 딕셔너리가 있는 곳에서 직접 임포트 할 수 없는 경우), "
":ref:`logging-config-dict-externalobj` 에 설명된 대로 ``ext://...`` 형식을 사용할 수 "
"있습니다. 예를 들어, 위의 예에서 ``MyFilter`` 대신 ``'ext://__main__.MyFilter'`` 를 사용할 수"
" 있습니다."

#: ../../howto/logging-cookbook.rst:2906
msgid ""
"As well as for filters, this technique can also be used to configure "
"custom handlers and formatters. See :ref:`logging-config-dict-userdef` "
"for more information on how logging supports using user-defined objects "
"in its configuration, and see the other cookbook recipe :ref:`custom-"
"handlers` above."
msgstr ""
"필터뿐만 아니라, 이 기술을 사용자 정의 처리기 및 포매터를 구성하는데 사용할 수도 있습니다. logging이 구성에서 사용자 정의"
" 객체를 어떻게 지원하는지에 대한 더 많은 정보는 :ref:`logging-config-dict-userdef` 를 보시고, 위의 "
"다른 요리책 조리법 :ref:`custom-handlers` 도 보십시오."

#: ../../howto/logging-cookbook.rst:2915
msgid "Customized exception formatting"
msgstr "사용자 정의된 예외 포매팅"

#: ../../howto/logging-cookbook.rst:2917
msgid ""
"There might be times when you want to do customized exception formatting "
"- for argument's sake, let's say you want exactly one line per logged "
"event, even when exception information is present. You can do this with a"
" custom formatter class, as shown in the following example::"
msgstr ""
"예외 포매팅을 사용자 정의하고 싶을 때가 있습니다 - 논쟁의 여지는 있지만, 예외 정보가 포함된 경우에도 이벤트 당 정확히 한 줄이"
" 기록되기 원한다고 합시다. 다음 예제처럼, 사용자 정의 포매터 클래스를 사용할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:2922
#, python-format
msgid ""
"import logging\n"
"\n"
"class OneLineExceptionFormatter(logging.Formatter):\n"
"    def formatException(self, exc_info):\n"
"        \"\"\"\n"
"        Format an exception so that it prints on a single line.\n"
"        \"\"\"\n"
"        result = super().formatException(exc_info)\n"
"        return repr(result)  # or format into one line however you want "
"to\n"
"\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        if record.exc_text:\n"
"            s = s.replace('\\n', '') + '|'\n"
"        return s\n"
"\n"
"def configure_logging():\n"
"    fh = logging.FileHandler('output.txt', 'w')\n"
"    f = "
"OneLineExceptionFormatter('%(asctime)s|%(levelname)s|%(message)s|',\n"
"                                  '%d/%m/%Y %H:%M:%S')\n"
"    fh.setFormatter(f)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(fh)\n"
"\n"
"def main():\n"
"    configure_logging()\n"
"    logging.info('Sample message')\n"
"    try:\n"
"        x = 1 / 0\n"
"    except ZeroDivisionError as e:\n"
"        logging.exception('ZeroDivisionError: %s', e)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:2958
msgid "When run, this produces a file with exactly two lines:"
msgstr "실행하면, 정확하게 두 줄의 파일이 생성됩니다:"

#: ../../howto/logging-cookbook.rst:2960
msgid ""
"28/01/2015 07:21:23|INFO|Sample message|\n"
"28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo "
"by zero|'Traceback (most recent call last):\\n  File \"logtest7.py\", "
"line 30, in main\\n    x = 1 / 0\\nZeroDivisionError: integer division or"
" modulo by zero'|"
msgstr ""

#: ../../howto/logging-cookbook.rst:2965
msgid ""
"While the above treatment is simplistic, it points the way to how "
"exception information can be formatted to your liking. The "
":mod:`traceback` module may be helpful for more specialized needs."
msgstr ""
"위의 처리는 단순하지만, 예외 정보를 원하는 대로 포맷하는 방법을 알려줍니다. :mod:`traceback` 모듈은 더욱 전문화된 "
"요구에 도움이 될 수 있습니다."

#: ../../howto/logging-cookbook.rst:2972
msgid "Speaking logging messages"
msgstr "로깅 메시지 말하기"

#: ../../howto/logging-cookbook.rst:2974
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do "
"if you have text-to-speech (TTS) functionality available in your system, "
"even if it doesn't have a Python binding. Most TTS systems have a command"
" line program you can run, and this can be invoked from a handler using "
":mod:`subprocess`. It's assumed here that TTS command line programs won't"
" expect to interact with users or take a long time to complete, and that "
"the frequency of logged messages will be not so high as to swamp the user"
" with messages, and that it's acceptable to have the messages spoken one "
"at a time rather than concurrently, The example implementation below "
"waits for one message to be spoken before the next is processed, and this"
" might cause other handlers to be kept waiting. Here is a short example "
"showing the approach, which assumes that the ``espeak`` TTS package is "
"available::"
msgstr ""
"로깅 메시지를 보여주는 대신 들려주는 것이 바람직한 상황이 있을 수 있습니다. 여러분의 시스템에 텍스트-음성 변환 (TTS) 기능이"
" 있다면 쉽습니다, 파이썬 바인딩이 없어도 됩니다. 대부분의 TTS 시스템에는 실행할 수 있는 명령행 프로그램이 있으며, 이것을 "
":mod:`subprocess` 를 사용하여 처리기에서 호출 할 수 있습니다. 여기서 TTS 명령행 프로그램이 사용자와 상호 "
"작용하거나, 완료하는 데 오랜 시간이 걸릴 것으로 기대되지 않으며, 로그 되는 메시지의 빈도가 메시지로 사용자를 압도할 정도로 높지"
" 않으며, 메시지는 동시에 처리되지 않고 한 번에 하나씩 읽어도 된다고 가정합니다. 아래의 예제 구현은 다음 메시지가 처리되기 전에"
" 하나의 메시지를 다 읽을 때까지 대기하고, 이 때문에 다른 처리기가 대기 상태로 유지될 수 있습니다. 다음은 ``espeak`` "
"TTS 패키지가 사용 가능하다고 가정하는 접근법을 보여주는 간단한 예입니다::"

#: ../../howto/logging-cookbook.rst:2987
msgid ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class TTSHandler(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # Speak slowly in a female English voice\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # wait for the program to finish\n"
"        p.communicate()\n"
"\n"
"def configure_logging():\n"
"    h = TTSHandler()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # the default formatter just returns the message\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Hello')\n"
"    logging.debug('Goodbye')\n"
"\n"
"if __name__ == '__main__':\n"
"    configure_logging()\n"
"    sys.exit(main())"
msgstr ""

#: ../../howto/logging-cookbook.rst:3016
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a "
"female voice."
msgstr "실행하면, 이 스크립트는 여성 음성으로 \"Hello\"와 \"Goodbye\"를 차례대로 말합니다."

#: ../../howto/logging-cookbook.rst:3018
msgid ""
"The above approach can, of course, be adapted to other TTS systems and "
"even other systems altogether which can process messages via external "
"programs run from a command line."
msgstr ""
"물론 위의 접근법은 다른 TTS 시스템과 명령행에서 실행되는 외부 프로그램을 통해 메시지를 처리 할 수 있는 전혀 다른 시스템에도 "
"적용될 수 있습니다."

#: ../../howto/logging-cookbook.rst:3026
msgid "Buffering logging messages and outputting them conditionally"
msgstr "로깅 메시지를 버퍼링하고 조건부 출력하기"

#: ../../howto/logging-cookbook.rst:3028
msgid ""
"There might be situations where you want to log messages in a temporary "
"area and only output them if a certain condition occurs. For example, you"
" may want to start logging debug events in a function, and if the "
"function completes without errors, you don't want to clutter the log with"
" the collected debug information, but if there is an error, you want all "
"the debug information to be output as well as the error."
msgstr ""
"임시 영역에 메시지를 기록하고 특정 조건이 발생할 때만 메시지를 출력하려는 상황이 있을 수 있습니다. 예를 들어, 함수에서 디버그 "
"이벤트를 로깅 하기를 원할 수 있습니다. 함수가 에러 없이 완료되면 수집된 디버그 정보로 로그를 어지럽히고 싶지 않지만, 에러가 "
"있으면 에러뿐만 아니라 모든 디버그 정보를 출력하고 싶습니다."

#: ../../howto/logging-cookbook.rst:3035
msgid ""
"Here is an example which shows how you could do this using a decorator "
"for your functions where you want logging to behave this way. It makes "
"use of the :class:`logging.handlers.MemoryHandler`, which allows "
"buffering of logged events until some condition occurs, at which point "
"the buffered events are ``flushed`` - passed to another handler (the "
"``target`` handler) for processing. By default, the ``MemoryHandler`` "
"flushed when its buffer gets filled up or an event whose level is greater"
" than or equal to a specified threshold is seen. You can use this recipe "
"with a more specialised subclass of ``MemoryHandler`` if you want custom "
"flushing behavior."
msgstr ""
"다음은 로깅이 이러한 방식으로 작동하기 원하는 함수에 데코레이터를 사용하여 이를 수행할 방법을 보여주는 예제입니다. "
":class:`logging.handlers.MemoryHandler` 를 사용하는데, 어떤 상황이 발생할 때까지 로그 된 이벤트를"
" 버퍼링할 수 있도록 하고, 때가 되면 버퍼링 된 이벤트들이 ``flush`` 됩니다 - 처리를 위해 다른 "
"처리기(``target`` 처리기)로 전달됩니다. 기본적으로, ``MemoryHandler`` 는 버퍼가 다 차거나 수준이 지정된 "
"임계값보다 크거나 같은 이벤트가 발생하면 플러시 됩니다. 사용자 정의 플러시 동작을 원할 경우, 이 조리법을 "
"``MemoryHandler`` 의 더 특수한 서브 클래스와 함께 사용할 수 있습니다."

#: ../../howto/logging-cookbook.rst:3045
msgid ""
"The example script has a simple function, ``foo``, which just cycles "
"through all the logging levels, writing to ``sys.stderr`` to say what "
"level it's about to log at, and then actually logging a message at that "
"level. You can pass a parameter to ``foo`` which, if true, will log at "
"ERROR and CRITICAL levels - otherwise, it only logs at DEBUG, INFO and "
"WARNING levels."
msgstr ""
"예제 스크립트에는 간단한 함수 ``foo`` 가 있는데, 모든 로그 수준을 순회하면서, 어떤 수준으로 로그 할지를 "
"``sys.stderr`` 에 쓴 다음, 그 수준으로 실제 메시지를 로깅 합니다. 매개 변수를 ``foo`` 에 전달할 수 있는데,"
" 참이면 ERROR 및 CRITICAL 수준으로 로그 합니다 - 그렇지 않으면 DEBUG, INFO 및 WARNING 수준에서만 "
"로그 합니다."

#: ../../howto/logging-cookbook.rst:3051
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will "
"do the conditional logging that's required. The decorator takes a logger "
"as a parameter and attaches a memory handler for the duration of the call"
" to the decorated function. The decorator can be additionally "
"parameterised using a target handler, a level at which flushing should "
"occur, and a capacity for the buffer (number of records buffered). These "
"default to a :class:`~logging.StreamHandler` which writes to "
"``sys.stderr``, ``logging.ERROR`` and ``100`` respectively."
msgstr ""
"이 스크립트는 필요한 조건부 로깅을 수행할 데코레이터로 ``foo`` 를 데코레이트 하기만 합니다. 데코레이터는 로거를 매개 변수로"
" 받고 데코레이트 된 함수가 호출되는 동안 메모리 처리기를 연결합니다. 데코레이터는 target 처리기, 플러싱이 발생해야 하는 "
"수준 및 버퍼 용량(버퍼 된 레코드의 수)을 추가로 매개 변수로 받을 수 있습니다. 이것들은 각각 ``sys.stderr`` 로 "
"쓰는 :class:`~logging.StreamHandler`, ``logging.ERROR``, ``100`` 을 기본값으로 "
"합니다."

#: ../../howto/logging-cookbook.rst:3059
msgid "Here's the script::"
msgstr "스크립트는 다음과 같습니다::"

#: ../../howto/logging-cookbook.rst:3061
#, python-format
msgid ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def log_if_errors(logger, target_handler=None, flush_level=None, "
"capacity=None):\n"
"    if target_handler is None:\n"
"        target_handler = logging.StreamHandler()\n"
"    if flush_level is None:\n"
"        flush_level = logging.ERROR\n"
"    if capacity is None:\n"
"        capacity = 100\n"
"    handler = MemoryHandler(capacity, flushLevel=flush_level, "
"target=target_handler)\n"
"\n"
"    def decorator(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(handler)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('call failed')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, handler).flush()\n"
"                logger.removeHandler(handler)\n"
"        return wrapper\n"
"\n"
"    return decorator\n"
"\n"
"def write_line(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(fail=False):\n"
"    write_line('about to log at DEBUG ...')\n"
"    logger.debug('Actually logged at DEBUG')\n"
"    write_line('about to log at INFO ...')\n"
"    logger.info('Actually logged at INFO')\n"
"    write_line('about to log at WARNING ...')\n"
"    logger.warning('Actually logged at WARNING')\n"
"    if fail:\n"
"        write_line('about to log at ERROR ...')\n"
"        logger.error('Actually logged at ERROR')\n"
"        write_line('about to log at CRITICAL ...')\n"
"        logger.critical('Actually logged at CRITICAL')\n"
"    return fail\n"
"\n"
"decorated_foo = log_if_errors(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    write_line('Calling undecorated foo with False')\n"
"    assert not foo(False)\n"
"    write_line('Calling undecorated foo with True')\n"
"    assert foo(True)\n"
"    write_line('Calling decorated foo with False')\n"
"    assert not decorated_foo(False)\n"
"    write_line('Calling decorated foo with True')\n"
"    assert decorated_foo(True)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3122
msgid "When this script is run, the following output should be observed:"
msgstr "이 스크립트를 실행하면 다음과 같은 출력이 나타납니다.:"

#: ../../howto/logging-cookbook.rst:3124
msgid ""
"Calling undecorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling undecorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"about to log at CRITICAL ...\n"
"Calling decorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling decorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"Actually logged at DEBUG\n"
"Actually logged at INFO\n"
"Actually logged at WARNING\n"
"Actually logged at ERROR\n"
"about to log at CRITICAL ...\n"
"Actually logged at CRITICAL"
msgstr ""

#: ../../howto/logging-cookbook.rst:3152
msgid ""
"As you can see, actual logging output only occurs when an event is logged"
" whose severity is ERROR or greater, but in that case, any previous "
"events at lower severities are also logged."
msgstr ""
"보시다시피, 실제 로깅 출력은 심각도가 ERROR 이상인 이벤트가 기록될 때만 발생하지만, 이 경우 심각도가 낮은 이전 이벤트도 "
"기록됩니다."

#: ../../howto/logging-cookbook.rst:3156
msgid "You can of course use the conventional means of decoration::"
msgstr "물론 전통적인 데코레이션 수단을 쓸 수 있습니다.::"

#: ../../howto/logging-cookbook.rst:3158
msgid ""
"@log_if_errors(logger)\n"
"def foo(fail=False):\n"
"    ..."
msgstr ""

#: ../../howto/logging-cookbook.rst:3166
msgid "Sending logging messages to email, with buffering"
msgstr ""

#: ../../howto/logging-cookbook.rst:3168
msgid ""
"To illustrate how you can send log messages via email, so that a set "
"number of messages are sent per email, you can subclass "
":class:`~logging.handlers.BufferingHandler`. In the following  example, "
"which you can adapt to suit your specific needs, a simple test harness is"
" provided which allows you to run the script with command line arguments "
"specifying what you typically need to send things via SMTP. (Run the "
"downloaded script with the ``-h`` argument to see the required and "
"optional arguments.)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3176
#, python-format
msgid ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class BufferingSMTPHandler(logging.handlers.BufferingHandler):\n"
"    def __init__(self, mailhost, port, username, password, fromaddr, "
"toaddrs,\n"
"                 subject, capacity):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacity)\n"
"        self.mailhost = mailhost\n"
"        self.mailport = port\n"
"        self.username = username\n"
"        self.password = password\n"
"        self.fromaddr = fromaddr\n"
"        if isinstance(toaddrs, str):\n"
"            toaddrs = [toaddrs]\n"
"        self.toaddrs = toaddrs\n"
"        self.subject = subject\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s"
" %(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.mailhost, self.mailport)\n"
"                smtp.starttls()\n"
"                smtp.login(self.username, self.password)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: "
"%s\\r\\n\\r\\n\" % (self.fromaddr, ','.join(self.toaddrs), self.subject)"
"\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='SMTP server')\n"
"    aa('--port', '-p', type=int, default=587, help='SMTP port')\n"
"    aa('user', metavar='USER', help='SMTP username')\n"
"    aa('password', metavar='PASSWORD', help='SMTP password')\n"
"    aa('to', metavar='TO', help='Addressee for emails')\n"
"    aa('sender', metavar='SENDER', help='Sender email address')\n"
"    aa('--subject', '-s',\n"
"       default='Test Logging email from Python logging module "
"(buffering)',\n"
"       help='Subject of email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = BufferingSMTPHandler(options.host, options.port, options.user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Info index = %d\", i)\n"
"    h.flush()\n"
"    h.close()"
msgstr ""

#: ../../howto/logging-cookbook.rst:3240
msgid ""
"If you run this script and your SMTP server is correctly set up, you "
"should find that it sends eleven emails to the addressee you specify. The"
" first ten emails will each have ten log messages, and the eleventh will "
"have two messages. That makes up 102 messages as specified in the script."
msgstr ""

#: ../../howto/logging-cookbook.rst:3248
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "구성을 통해 UTC(GMT)로 시간을 포맷하기"

#: ../../howto/logging-cookbook.rst:3250
#, fuzzy
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr "때로는 UTC를 사용하여 시간을 포맷하고 싶습니다. 아래에 표시된 `UTCFormatter` 와 같은 클래스를 사용할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:3253
msgid ""
"import logging\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime"
msgstr ""

#: ../../howto/logging-cookbook.rst:3259
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of "
":class:`~logging.Formatter`. If you want to do that via configuration, "
"you can use the :func:`~logging.config.dictConfig` API with an approach "
"illustrated by the following complete example::"
msgstr ""
"이제 :class:`~logging.Formatter` 대신 코드에서 ``UTCFormatter`` 를 사용할 수 있습니다. 구성을"
" 통해 이를 수행하려면, 다음에 나오는 완전한 예제에 의해 설명된 접근법으로 "
":func:`~logging.config.dictConfig` API를 사용할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:3264
#, python-brace-format, python-format
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': UTCFormatter,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'console2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['console1', 'console2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('The local time is %s', time.asctime())"
msgstr ""

#: ../../howto/logging-cookbook.rst:3302
msgid "When this script is run, it should print something like:"
msgstr "이 스크립트를 실행하면, 다음과 같은 내용을 인쇄합니다:"

#: ../../howto/logging-cookbook.rst:3304
msgid ""
"2015-10-17 12:53:29,501 The local time is Sat Oct 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 The local time is Sat Oct 17 13:53:29 2015"
msgstr ""

#: ../../howto/logging-cookbook.rst:3309
msgid ""
"showing how the time is formatted both as local time and UTC, one for "
"each handler."
msgstr "시간이 한 처리기에서는 UTC로, 다른 처리기에서는 지역 시간으로 포맷되는 것을 보여줍니다."

#: ../../howto/logging-cookbook.rst:3316
msgid "Using a context manager for selective logging"
msgstr "선택적 로깅을 위해 컨텍스트 관리자 사용하기"

#: ../../howto/logging-cookbook.rst:3318
msgid ""
"There are times when it would be useful to temporarily change the logging"
" configuration and revert it back after doing something. For this, a "
"context manager is the most obvious way of saving and restoring the "
"logging context. Here is a simple example of such a context manager, "
"which allows you to optionally change the logging level and add a logging"
" handler purely in the scope of the context manager::"
msgstr ""
"로깅 구성을 일시적으로 변경하고 무언가를 한 후에 되돌리는 것이 유용할 때가 있습니다. 이를 위해, 컨텍스트 관리자는 로깅 "
"컨텍스트를 저장하고 복원하는 가장 분명한 방법입니다. 다음은 그러한 컨텍스트 관리자의 간단한 예입니다. 컨텍스트 관리자의 범위 "
"안에서 선택적으로 로깅 수준을 변경하고 로깅 처리기를 추가 할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:3325
msgid ""
"import logging\n"
"import sys\n"
"\n"
"class LoggingContext:\n"
"    def __init__(self, logger, level=None, handler=None, close=True):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"        self.handler = handler\n"
"        self.close = close\n"
"\n"
"    def __enter__(self):\n"
"        if self.level is not None:\n"
"            self.old_level = self.logger.level\n"
"            self.logger.setLevel(self.level)\n"
"        if self.handler:\n"
"            self.logger.addHandler(self.handler)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.level is not None:\n"
"            self.logger.setLevel(self.old_level)\n"
"        if self.handler:\n"
"            self.logger.removeHandler(self.handler)\n"
"        if self.handler and self.close:\n"
"            self.handler.close()\n"
"        # implicit return of None => don't swallow exceptions"
msgstr ""

#: ../../howto/logging-cookbook.rst:3351
msgid ""
"If you specify a level value, the logger's level is set to that value in "
"the scope of the with block covered by the context manager. If you "
"specify a handler, it is added to the logger on entry to the block and "
"removed on exit from the block. You can also ask the manager to close the"
" handler for you on block exit - you could do this if you don't need the "
"handler any more."
msgstr ""
"수준 값을 지정하면, 로거의 수준은 컨텍스트 관리자가 적용되는 with 블록의 범위 안에서 해당 값으로 설정됩니다. 처리기를 "
"지정하면, 블록 진입 시 로거에 추가되고 블록에서 빠져나갈 때 제거됩니다. 블록을 빠져나갈 때 처리기를 닫도록 관리자에게 요청할 "
"수도 있습니다 - 더는 처리기가 필요하지 않으면 이렇게 할 수 있습니다."

#: ../../howto/logging-cookbook.rst:3357
msgid ""
"To illustrate how it works, we can add the following block of code to the"
" above::"
msgstr "작동 원리를 보여주기 위해, 다음 코드 블록을 위에 추가 할 수 있습니다::"

#: ../../howto/logging-cookbook.rst:3360
msgid ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. This should appear just once on stderr.')\n"
"    logger.debug('2. This should not appear.')\n"
"    with LoggingContext(logger, level=logging.DEBUG):\n"
"        logger.debug('3. This should appear once on stderr.')\n"
"    logger.debug('4. This should not appear.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with LoggingContext(logger, level=logging.DEBUG, handler=h, "
"close=True):\n"
"        logger.debug('5. This should appear twice - once on stderr and "
"once on stdout.')\n"
"    logger.info('6. This should appear just once on stderr.')\n"
"    logger.debug('7. This should not appear.')"
msgstr ""

#: ../../howto/logging-cookbook.rst:3375
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears "
"and message #2 doesn't. We then change the level to ``DEBUG`` temporarily"
" in the following ``with`` block, and so message #3 appears. After the "
"block exits, the logger's level is restored to ``INFO`` and so message #4"
" doesn't appear. In the next ``with`` block, we set the level to "
"``DEBUG`` again but also add a handler writing to ``sys.stdout``. Thus, "
"message #5 appears twice on the console (once via ``stderr`` and once via"
" ``stdout``). After the ``with`` statement's completion, the status is as"
" it was before so message #6 appears (like message #1) whereas message #7"
" doesn't (just like message #2)."
msgstr ""
"우리는 초기에 로거 수준을 ``INFO`` 로 설정합니다. 그래서 메시지 #1은 나타나고 메시지 #2는 나타나지 않습니다. 그다음에"
" ``with`` 블록에서 수준을 ``DEBUG`` 로 임시 변경하면, 메시지 #3이 나타납니다. 블록이 종료되면 로거 수준이 "
"``INFO`` 로 복원되므로, 메시지 #4가 표시되지 않습니다. 그다음 ``with`` 블록에서 수준을 다시 ``DEBUG`` 로"
" 다시 설정하지만, ``sys.stdout`` 으로 쓰는 처리기도 추가합니다. 따라서 메시지 #5는 콘솔에 두 번 표시됩니다 "
"(``stderr`` 를 통해 한 번, ``stdout`` 을 통해 한 번). ``with`` 문장이 완료된 후에 상태는 이전과 "
"같으므로, (메시지 #1처럼) 메시지 #6이 나타나고, (메시지 #2처럼) 메시지 #7은 보이지 않습니다."

#: ../../howto/logging-cookbook.rst:3385
msgid "If we run the resulting script, the result is as follows:"
msgstr "이렇게 만든 스크립트를 실행하면, 결과는 다음과 같습니다:"

#: ../../howto/logging-cookbook.rst:3387
msgid ""
"$ python logctx.py\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""

#: ../../howto/logging-cookbook.rst:3396
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"다시 실행하면서 ``stderr`` 를 ``/dev/null`` 로 리디렉트하면, 다음과 같이 ``stdout`` 으로 출력된 "
"메시지만 나타납니다:"

#: ../../howto/logging-cookbook.rst:3399
msgid ""
"$ python logctx.py 2>/dev/null\n"
"5. This should appear twice - once on stderr and once on stdout."
msgstr ""

#: ../../howto/logging-cookbook.rst:3404
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "다시 한번, 하지만 ``stdout`` 을 ``/dev/null`` 로 리디렉트하면, 이렇게 됩니다:"

#: ../../howto/logging-cookbook.rst:3406
msgid ""
"$ python logctx.py >/dev/null\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""

#: ../../howto/logging-cookbook.rst:3414
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr "이 경우, ``stdout`` 에 인쇄된 메시지 #5는 예상대로 나타나지 않습니다."

#: ../../howto/logging-cookbook.rst:3416
msgid ""
"Of course, the approach described here can be generalised, for example to"
" attach logging filters temporarily. Note that the above code works in "
"Python 2 as well as Python 3."
msgstr ""
"물론 여기서 설명한 방법을 일반화 할 수 있습니다. 예를 들어 로깅 필터를 임시로 첨부 할 수 있습니다. 위의 코드는 파이썬 2와 "
"파이썬 3에서 모두 작동합니다."

#: ../../howto/logging-cookbook.rst:3424
msgid "A CLI application starter template"
msgstr "CLI 응용 프로그램 시작 템플릿"

#: ../../howto/logging-cookbook.rst:3426
msgid "Here's an example which shows how you can:"
msgstr "다음과 같은 것들을 하는 방법을 보여주는 예입니다:"

#: ../../howto/logging-cookbook.rst:3428
msgid "Use a logging level based on command-line arguments"
msgstr "명령 줄 인자에 기반한 로깅 수준 사용하기"

#: ../../howto/logging-cookbook.rst:3429
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the "
"same level in a consistent way"
msgstr "별도의 파일에 있는 여러 부속 명령으로 분기하고, 모두 일관된 방식으로 같은 수준에서 로깅 하기"

#: ../../howto/logging-cookbook.rst:3431
msgid "Make use of simple, minimal configuration"
msgstr "간단하고 최소의 구성을 사용하기"

#: ../../howto/logging-cookbook.rst:3433
msgid ""
"Suppose we have a command-line application whose job is to stop, start or"
" restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, "
"``stop.py`` and ``restart.py``. Suppose further that we want to control "
"the verbosity of the application via a command-line argument, defaulting "
"to ``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"어떤 서비스를 중지, 시작 또는 다시 시작하는 작업을 위한 명령 줄 응용 프로그램이 있다고 가정합니다. 이것은 예시의 목적을 위해 "
"``start.py``, ``stop.py`` 및 ``restart.py``\\에 개별 명령이 구현되고, 응용 프로그램의 메인 "
"스크립트는 ``app.py`` 파일이 되도록 구성할 수 있습니다. 명령 줄 인자를 통해 응용 프로그램의 상세도를 제어하려고 하고, "
"``logging.INFO``\\를 기본값으로 한다고 더 가정해 봅시다. ``app.py``\\를 작성할 수 있는 한 가지 방법은 "
"다음과 같습니다::"

#: ../../howto/logging-cookbook.rst:3441
#, python-format
msgid ""
"import argparse\n"
"import importlib\n"
"import logging\n"
"import os\n"
"import sys\n"
"\n"
"def main(args=None):\n"
"    scriptname = os.path.basename(__file__)\n"
"    parser = argparse.ArgumentParser(scriptname)\n"
"    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n"
"    parser.add_argument('--log-level', default='INFO', choices=levels)\n"
"    subparsers = parser.add_subparsers(dest='command',\n"
"                                       help='Available commands:')\n"
"    start_cmd = subparsers.add_parser('start', help='Start a service')\n"
"    start_cmd.add_argument('name', metavar='NAME',\n"
"                           help='Name of service to start')\n"
"    stop_cmd = subparsers.add_parser('stop',\n"
"                                     help='Stop one or more services')\n"
"    stop_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                          help='Name of service to stop')\n"
"    restart_cmd = subparsers.add_parser('restart',\n"
"                                        help='Restart one or more "
"services')\n"
"    restart_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                             help='Name of service to restart')\n"
"    options = parser.parse_args()\n"
"    # the code to dispatch commands could all be in this file. For the "
"purposes\n"
"    # of illustration only, we implement each command in a separate "
"module.\n"
"    try:\n"
"        mod = importlib.import_module(options.command)\n"
"        cmd = getattr(mod, 'command')\n"
"    except (ImportError, AttributeError):\n"
"        print('Unable to find the code for command \\'%s\\'' % "
"options.command)\n"
"        return 1\n"
"    # Could get fancy here and load configuration from file or dictionary"
"\n"
"    logging.basicConfig(level=options.log_level,\n"
"                        format='%(levelname)s %(name)s %(message)s')\n"
"    cmd(options)\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())"
msgstr ""

#: ../../howto/logging-cookbook.rst:3482
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented "
"in separate modules, like so for starting::"
msgstr "그리고 ``start``, ``stop`` 및 ``restart`` 명령은 별도의 모듈로 구현할 수 있습니다, 가령 시작하려면::"

#: ../../howto/logging-cookbook.rst:3485
#, python-format
msgid ""
"# start.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    logger.debug('About to start %s', options.name)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Started the \\'%s\\' service.', options.name)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3495
msgid "and thus for stopping::"
msgstr "그리고 멈추려면::"

#: ../../howto/logging-cookbook.rst:3497
#, python-format
msgid ""
"# stop.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)"
"\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to stop %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Stopped the %s service%s.', services, plural)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3516
msgid "and similarly for restarting::"
msgstr "비슷하게, 다시 시작하려면::"

#: ../../howto/logging-cookbook.rst:3518
#, python-format
msgid ""
"# restart.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)"
"\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to restart %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Restarted the %s service%s.', services, plural)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3537
msgid ""
"If we run this application with the default log level, we get output like"
" this:"
msgstr "이 응용 프로그램을 기본 로그 수준으로 실행하면, 이런 출력을 얻습니다:"

#: ../../howto/logging-cookbook.rst:3539
msgid ""
"$ python app.py start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py stop foo bar\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py restart foo bar baz\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""

#: ../../howto/logging-cookbook.rst:3550
msgid ""
"The first word is the logging level, and the second word is the module or"
" package name of the place where the event was logged."
msgstr "첫 번째 단어는 로깅 수준이고, 두 번째 단어는 이벤트가 로그 된 장소의 모듈이나 패키지 이름입니다."

#: ../../howto/logging-cookbook.rst:3553
msgid ""
"If we change the logging level, then we can change the information sent "
"to the log. For example, if we want more information:"
msgstr "로깅 수준을 변경하면, 로그로 전송되는 정보를 변경할 수 있습니다. 예를 들어, 우리가 더 많은 정보를 원한다면:"

#: ../../howto/logging-cookbook.rst:3556
msgid ""
"$ python app.py --log-level DEBUG start foo\n"
"DEBUG start About to start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py --log-level DEBUG stop foo bar\n"
"DEBUG stop About to stop 'foo' and 'bar'\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py --log-level DEBUG restart foo bar baz\n"
"DEBUG restart About to restart 'foo', 'bar' and 'baz'\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""

#: ../../howto/logging-cookbook.rst:3570
msgid "And if we want less:"
msgstr "그리고 덜 원한다면:"

#: ../../howto/logging-cookbook.rst:3572
msgid ""
"$ python app.py --log-level WARNING start foo\n"
"$ python app.py --log-level WARNING stop foo bar\n"
"$ python app.py --log-level WARNING restart foo bar baz"
msgstr ""

#: ../../howto/logging-cookbook.rst:3578
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr "이 경우, ``WARNING`` 수준 이상으로 아무것도 로그 하지 않았으므로, 명령은 콘솔에 아무것도 인쇄하지 않습니다."

#: ../../howto/logging-cookbook.rst:3584
msgid "A Qt GUI for logging"
msgstr "로깅을 위한 Qt GUI"

#: ../../howto/logging-cookbook.rst:3586
#, fuzzy
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using :pypi:`PySide2` or "
":pypi:`PyQt5` libraries."
msgstr ""
"때때로 나오는 질문은 GUI 응용 프로그램에 로그 하는 방법입니다. `Qt <https://www.qt.io/>`_ 프레임워크는 "
"`PySide2 <https://pypi.org/project/PySide2/>`_\\나 `PyQt5 "
"<https://pypi.org/project/PyQt5/>`_ 라이브러리를 사용하는 파이썬 바인딩이 있는 인기 있는 교차 플랫폼 "
"UI 프레임워크입니다."

#: ../../howto/logging-cookbook.rst:3591
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a "
"simple ``QtHandler`` class which takes a callable, which should be a slot"
" in the main thread that does GUI updates. A worker thread is also "
"created to show how you can log to the GUI from both the UI itself (via a"
" button for manual logging) as well as a worker thread doing work in the "
"background (here, just logging messages at random levels with random "
"short delays in between)."
msgstr ""
"다음 예는 Qt GUI에 로그 하는 방법을 보여줍니다. 이것은 콜러블을 취하는 간단한 ``QtHandler`` 클래스를 소개합니다."
" 이 클래스는 GUI 업데이트를 하는 메인 스레드의 슬롯이어야 합니다. 또한 UI 자체 (수동 로깅을 위한 버튼을 통해) 뿐만 "
"아니라 백그라운드에서 작업하는 작업자 스레드에서 GUI에 로그 하는 방법을 보여주기 위해 작업자 스레드도 만듭니다 (여기서는, 단지"
" 임의의 짧은 지연을 주고 임의의 수준으로 메시지를 로깅 합니다)."

#: ../../howto/logging-cookbook.rst:3598
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than"
" the :mod:`threading` module, as there are circumstances where one has to"
" use ``QThread``, which offers better integration with other ``Qt`` "
"components."
msgstr ""
"작업자 스레드는 :mod:`threading` 모듈 대신 Qt의 ``QThread`` 클래스를 사용하여 구현되는데, 다른 "
"``Qt`` 구성 요소와 더 잘 통합되는 ``QThread``\\를 사용해야 하는 상황이 있기 때문입니다."

#: ../../howto/logging-cookbook.rst:3602
#, fuzzy
msgid ""
"The code should work with recent releases of any of ``PySide6``, "
"``PyQt6``, ``PySide2`` or ``PyQt5``. You should be able to adapt the "
"approach to earlier versions of Qt. Please refer to the comments in the "
"code snippet for more detailed information."
msgstr ""
"이 코드는 ``PySide2``\\나 ``PyQt5`` 최신 배포에서 작동해야 합니다. 여러분은 이 접근법을 이전 버전의 Qt에 "
"적용할 수 있을 겁니다. 자세한 내용은 코드 조각의 주석을 참조하십시오."

#: ../../howto/logging-cookbook.rst:3607
#, python-brace-format, python-format
msgid ""
"import datetime\n"
"import logging\n"
"import random\n"
"import sys\n"
"import time\n"
"\n"
"# Deal with minor differences between different Qt packages\n"
"try:\n"
"    from PySide6 import QtCore, QtGui, QtWidgets\n"
"    Signal = QtCore.Signal\n"
"    Slot = QtCore.Slot\n"
"except ImportError:\n"
"    try:\n"
"        from PyQt6 import QtCore, QtGui, QtWidgets\n"
"        Signal = QtCore.pyqtSignal\n"
"        Slot = QtCore.pyqtSlot\n"
"    except ImportError:\n"
"        try:\n"
"            from PySide2 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.Signal\n"
"            Slot = QtCore.Slot\n"
"        except ImportError:\n"
"            from PyQt5 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.pyqtSignal\n"
"            Slot = QtCore.pyqtSlot\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"#\n"
"# Signals need to be contained in a QObject or subclass in order to be "
"correctly\n"
"# initialized.\n"
"#\n"
"class Signaller(QtCore.QObject):\n"
"    signal = Signal(str, logging.LogRecord)\n"
"\n"
"#\n"
"# Output to a Qt GUI is only supposed to happen on the main thread. So, "
"this\n"
"# handler is designed to take a slot function which is set up to run in "
"the main\n"
"# thread. In this example, the function takes a string argument which is "
"a\n"
"# formatted log message, and the log record which generated it. The "
"formatted\n"
"# string is just a convenience - you could format a string for output any"
" way\n"
"# you like in the slot function itself.\n"
"#\n"
"# You specify the slot function to do whatever GUI updates you want. The "
"handler\n"
"# doesn't know or care about specific UI elements.\n"
"#\n"
"class QtHandler(logging.Handler):\n"
"    def __init__(self, slotfunc, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"        self.signaller = Signaller()\n"
"        self.signaller.signal.connect(slotfunc)\n"
"\n"
"    def emit(self, record):\n"
"        s = self.format(record)\n"
"        self.signaller.signal.emit(s, record)\n"
"\n"
"#\n"
"# This example uses QThreads, which means that the threads at the Python "
"level\n"
"# are named something like \"Dummy-1\". The function below gets the Qt "
"name of the\n"
"# current thread.\n"
"#\n"
"def ctname():\n"
"    return QtCore.QThread.currentThread().objectName()\n"
"\n"
"\n"
"#\n"
"# Used to generate random levels for logging.\n"
"#\n"
"LEVELS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"\n"
"#\n"
"# This worker class represents work that is done in a thread separate to "
"the\n"
"# main thread. The way the thread is kicked off to do work is via a "
"button press\n"
"# that connects to a slot in the worker.\n"
"#\n"
"# Because the default threadName value in the LogRecord isn't much use, "
"we add\n"
"# a qThreadName which contains the QThread name as computed above, and "
"pass that\n"
"# value in an \"extra\" dictionary which is used to update the LogRecord "
"with the\n"
"# QThread name.\n"
"#\n"
"# This example worker just outputs messages sequentially, interspersed "
"with\n"
"# random delays of the order of a few seconds.\n"
"#\n"
"class Worker(QtCore.QObject):\n"
"    @Slot()\n"
"    def start(self):\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.debug('Started work', extra=extra)\n"
"        i = 1\n"
"        # Let the thread run until interrupted. This allows reasonably "
"clean\n"
"        # thread termination.\n"
"        while not "
"QtCore.QThread.currentThread().isInterruptionRequested():\n"
"            delay = 0.5 + random.random() * 2\n"
"            time.sleep(delay)\n"
"            try:\n"
"                if random.random() < 0.1:\n"
"                    raise ValueError('Exception raised: %d' % i)\n"
"                else:\n"
"                    level = random.choice(LEVELS)\n"
"                    logger.log(level, 'Message after delay of %3.1f: %d',"
" delay, i, extra=extra)\n"
"            except ValueError as e:\n"
"                logger.exception('Failed: %s', e, extra=extra)\n"
"            i += 1\n"
"\n"
"#\n"
"# Implement a simple UI for this cookbook example. This contains:\n"
"#\n"
"# * A read-only text edit window which holds formatted log messages\n"
"# * A button to start work and log stuff in a separate thread\n"
"# * A button to log something from the main thread\n"
"# * A button to clear the log window\n"
"#\n"
"class Window(QtWidgets.QWidget):\n"
"\n"
"    COLORS = {\n"
"        logging.DEBUG: 'black',\n"
"        logging.INFO: 'blue',\n"
"        logging.WARNING: 'orange',\n"
"        logging.ERROR: 'red',\n"
"        logging.CRITICAL: 'purple',\n"
"    }\n"
"\n"
"    def __init__(self, app):\n"
"        super().__init__()\n"
"        self.app = app\n"
"        self.textedit = te = QtWidgets.QPlainTextEdit(self)\n"
"        # Set whatever the default monospace font is for the platform\n"
"        f = QtGui.QFont('nosuchfont')\n"
"        if hasattr(f, 'Monospace'):\n"
"            f.setStyleHint(f.Monospace)\n"
"        else:\n"
"            f.setStyleHint(f.StyleHint.Monospace)  # for Qt6\n"
"        te.setFont(f)\n"
"        te.setReadOnly(True)\n"
"        PB = QtWidgets.QPushButton\n"
"        self.work_button = PB('Start background work', self)\n"
"        self.log_button = PB('Log a message at a random level', self)\n"
"        self.clear_button = PB('Clear log window', self)\n"
"        self.handler = h = QtHandler(self.update_status)\n"
"        # Remember to use qThreadName rather than threadName in the "
"format string.\n"
"        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'"
"\n"
"        formatter = logging.Formatter(fs)\n"
"        h.setFormatter(formatter)\n"
"        logger.addHandler(h)\n"
"        # Set up to terminate the QThread when we exit\n"
"        app.aboutToQuit.connect(self.force_quit)\n"
"\n"
"        # Lay out all the widgets\n"
"        layout = QtWidgets.QVBoxLayout(self)\n"
"        layout.addWidget(te)\n"
"        layout.addWidget(self.work_button)\n"
"        layout.addWidget(self.log_button)\n"
"        layout.addWidget(self.clear_button)\n"
"        self.setFixedSize(900, 400)\n"
"\n"
"        # Connect the non-worker slots and signals\n"
"        self.log_button.clicked.connect(self.manual_update)\n"
"        self.clear_button.clicked.connect(self.clear_display)\n"
"\n"
"        # Start a new worker thread and connect the slots for the worker\n"
"        self.start_thread()\n"
"        self.work_button.clicked.connect(self.worker.start)\n"
"        # Once started, the button should be disabled\n"
"        self.work_button.clicked.connect(lambda : "
"self.work_button.setEnabled(False))\n"
"\n"
"    def start_thread(self):\n"
"        self.worker = Worker()\n"
"        self.worker_thread = QtCore.QThread()\n"
"        self.worker.setObjectName('Worker')\n"
"        self.worker_thread.setObjectName('WorkerThread')  # for "
"qThreadName\n"
"        self.worker.moveToThread(self.worker_thread)\n"
"        # This will start an event loop in the worker thread\n"
"        self.worker_thread.start()\n"
"\n"
"    def kill_thread(self):\n"
"        # Just tell the worker to stop, then tell it to quit and wait for"
" that\n"
"        # to happen\n"
"        self.worker_thread.requestInterruption()\n"
"        if self.worker_thread.isRunning():\n"
"            self.worker_thread.quit()\n"
"            self.worker_thread.wait()\n"
"        else:\n"
"            print('worker has already exited.')\n"
"\n"
"    def force_quit(self):\n"
"        # For use when the window is closed\n"
"        if self.worker_thread.isRunning():\n"
"            self.kill_thread()\n"
"\n"
"    # The functions below update the UI and run in the main thread "
"because\n"
"    # that's where the slots are set up\n"
"\n"
"    @Slot(str, logging.LogRecord)\n"
"    def update_status(self, status, record):\n"
"        color = self.COLORS.get(record.levelno, 'black')\n"
"        s = '<pre><font color=\"%s\">%s</font></pre>' % (color, status)\n"
"        self.textedit.appendHtml(s)\n"
"\n"
"    @Slot()\n"
"    def manual_update(self):\n"
"        # This function uses the formatted message passed in, but also "
"uses\n"
"        # information from the record to format the message in an "
"appropriate\n"
"        # color according to its severity (level).\n"
"        level = random.choice(LEVELS)\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.log(level, 'Manually logged!', extra=extra)\n"
"\n"
"    @Slot()\n"
"    def clear_display(self):\n"
"        self.textedit.clear()\n"
"\n"
"\n"
"def main():\n"
"    QtCore.QThread.currentThread().setObjectName('MainThread')\n"
"    logging.getLogger().setLevel(logging.DEBUG)\n"
"    app = QtWidgets.QApplication(sys.argv)\n"
"    example = Window(app)\n"
"    example.show()\n"
"    if hasattr(app, 'exec'):\n"
"        rc = app.exec()\n"
"    else:\n"
"        rc = app.exec_()\n"
"    sys.exit(rc)\n"
"\n"
"if __name__=='__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:3839
msgid "Logging to syslog with RFC5424 support"
msgstr ""

#: ../../howto/logging-cookbook.rst:3841
msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured "
"by default to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and "
"only existing) protocol at the time. Since RFC5424 came out, as there has"
" not been widespread deployment of it in syslog servers, the "
":class:`~logging.handlers.SysLogHandler` functionality has not been "
"updated."
msgstr ""

#: ../../howto/logging-cookbook.rst:3848
msgid ""
"RFC 5424 contains some useful features such as support for structured "
"data, and if you need to be able to log to a syslog server with support "
"for it, you can do so with a subclassed handler which looks something "
"like this::"
msgstr ""

#: ../../howto/logging-cookbook.rst:3852
#, python-brace-format
msgid ""
"import datetime\n"
"import logging.handlers\n"
"import re\n"
"import socket\n"
"import time\n"
"\n"
"class SysLogHandler5424(logging.handlers.SysLogHandler):\n"
"\n"
"    tz_offset = re.compile(r'([+-]\\d{2})(\\d{2})$')\n"
"    escaped = re.compile(r'([\\]\"\\\\])')\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        self.msgid = kwargs.pop('msgid', None)\n"
"        self.appname = kwargs.pop('appname', None)\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"    def format(self, record):\n"
"        version = 1\n"
"        asctime = "
"datetime.datetime.fromtimestamp(record.created).isoformat()\n"
"        m = self.tz_offset.match(time.strftime('%z'))\n"
"        has_offset = False\n"
"        if m and time.timezone:\n"
"            hrs, mins = m.groups()\n"
"            if int(hrs) or int(mins):\n"
"                has_offset = True\n"
"        if not has_offset:\n"
"            asctime += 'Z'\n"
"        else:\n"
"            asctime += f'{hrs}:{mins}'\n"
"        try:\n"
"            hostname = socket.gethostname()\n"
"        except Exception:\n"
"            hostname = '-'\n"
"        appname = self.appname or '-'\n"
"        procid = record.process\n"
"        msgid = '-'\n"
"        msg = super().format(record)\n"
"        sdata = '-'\n"
"        if hasattr(record, 'structured_data'):\n"
"            sd = record.structured_data\n"
"            # This should be a dict where the keys are SD-ID and the "
"value is a\n"
"            # dict mapping PARAM-NAME to PARAM-VALUE (refer to the RFC "
"for what these\n"
"            # mean)\n"
"            # There's no error checking here - it's purely for "
"illustration, and you\n"
"            # can adapt this code for use in production environments\n"
"            parts = []\n"
"\n"
"            def replacer(m):\n"
"                g = m.groups()\n"
"                return '\\\\' + g[0]\n"
"\n"
"            for sdid, dv in sd.items():\n"
"                part = f'[{sdid}'\n"
"                for k, v in dv.items():\n"
"                    s = str(v)\n"
"                    s = self.escaped.sub(replacer, s)\n"
"                    part += f' {k}=\"{s}\"'\n"
"                part += ']'\n"
"                parts.append(part)\n"
"            sdata = ''.join(parts)\n"
"        return f'{version} {asctime} {hostname} {appname} {procid} "
"{msgid} {sdata} {msg}'"
msgstr ""

#: ../../howto/logging-cookbook.rst:3914
msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above "
"code, and it may be that you have slightly different needs (e.g. for how "
"you pass structural data to the log). Nevertheless, the above should be "
"adaptable to your speciric needs. With the above handler, you'd pass "
"structured data using something like this::"
msgstr ""

#: ../../howto/logging-cookbook.rst:3919
#, python-brace-format, python-format
msgid ""
"sd = {\n"
"    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},\n"
"    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}\n"
"}\n"
"extra = {'structured_data': sd}\n"
"i = 1\n"
"logger.debug('Message %d', i, extra=extra)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3928
msgid "How to treat a logger like an output stream"
msgstr ""

#: ../../howto/logging-cookbook.rst:3930
msgid ""
"Sometimes, you need to interface to a third-party API which expects a "
"file-like object to write to, but you want to direct the API's output to "
"a logger. You can do this using a class which wraps a logger with a file-"
"like API. Here's a short script illustrating such a class:"
msgstr ""

#: ../../howto/logging-cookbook.rst:3935
msgid ""
"import logging\n"
"\n"
"class LoggerWriter:\n"
"    def __init__(self, logger, level):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"\n"
"    def write(self, message):\n"
"        if message != '\\n':  # avoid printing bare newlines, if you like"
"\n"
"            self.logger.log(self.level, message)\n"
"\n"
"    def flush(self):\n"
"        # doesn't actually do anything, but might be expected of a file-"
"like\n"
"        # object - so optional depending on your situation\n"
"        pass\n"
"\n"
"    def close(self):\n"
"        # doesn't actually do anything, but might be expected of a file-"
"like\n"
"        # object - so optional depending on your situation. You might "
"want\n"
"        # to set a flag so that later calls to write raise an exception\n"
"        pass\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    logger = logging.getLogger('demo')\n"
"    info_fp = LoggerWriter(logger, logging.INFO)\n"
"    debug_fp = LoggerWriter(logger, logging.DEBUG)\n"
"    print('An INFO message', file=info_fp)\n"
"    print('A DEBUG message', file=debug_fp)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:3970
#, fuzzy
msgid "When this script is run, it prints"
msgstr "위의 스크립트를 실행하면 다음과 같이 인쇄합니다:"

#: ../../howto/logging-cookbook.rst:3972
msgid ""
"INFO:demo:An INFO message\n"
"DEBUG:demo:A DEBUG message"
msgstr ""

#: ../../howto/logging-cookbook.rst:3977
msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and "
"``sys.stderr`` by doing something like this:"
msgstr ""

#: ../../howto/logging-cookbook.rst:3980
msgid ""
"import sys\n"
"\n"
"sys.stdout = LoggerWriter(logger, logging.INFO)\n"
"sys.stderr = LoggerWriter(logger, logging.WARNING)"
msgstr ""

#: ../../howto/logging-cookbook.rst:3987
msgid ""
"You should do this *after* configuring logging for your needs. In the "
"above example, the :func:`~logging.basicConfig` call does this (using the"
" ``sys.stderr`` value *before* it is overwritten by a ``LoggerWriter`` "
"instance). Then, you'd get this kind of result:"
msgstr ""

#: ../../howto/logging-cookbook.rst:3992
msgid ""
">>> print('Foo')\n"
"INFO:demo:Foo\n"
">>> print('Bar', file=sys.stderr)\n"
"WARNING:demo:Bar\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:4000
msgid ""
"Of course, the examples above show output according to the format used by"
" :func:`~logging.basicConfig`, but you can use a different formatter when"
" you configure logging."
msgstr ""

#: ../../howto/logging-cookbook.rst:4004
msgid ""
"Note that with the above scheme, you are somewhat at the mercy of "
"buffering and the sequence of write calls which you are intercepting. For"
" example, with the definition of ``LoggerWriter`` above, if you have the "
"snippet"
msgstr ""

#: ../../howto/logging-cookbook.rst:4008
msgid ""
"sys.stderr = LoggerWriter(logger, logging.WARNING)\n"
"1 / 0"
msgstr ""

#: ../../howto/logging-cookbook.rst:4013
msgid "then running the script results in"
msgstr ""

#: ../../howto/logging-cookbook.rst:4015
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line "
"53, in <module>\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line "
"49, in main\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:1 / 0\n"
"WARNING:demo:ZeroDivisionError\n"
"WARNING:demo::\n"
"WARNING:demo:division by zero"
msgstr ""

#: ../../howto/logging-cookbook.rst:4031
msgid ""
"As you can see, this output isn't ideal. That's because the underlying "
"code which writes to ``sys.stderr`` makes multiple writes, each of which "
"results in a separate logged line (for example, the last three lines "
"above). To get around this problem, you need to buffer things and only "
"output log lines when newlines are seen. Let's use a slightly better "
"implementation of ``LoggerWriter``:"
msgstr ""

#: ../../howto/logging-cookbook.rst:4037
msgid ""
"class BufferingLoggerWriter(LoggerWriter):\n"
"    def __init__(self, logger, level):\n"
"        super().__init__(logger, level)\n"
"        self.buffer = ''\n"
"\n"
"    def write(self, message):\n"
"        if '\\n' not in message:\n"
"            self.buffer += message\n"
"        else:\n"
"            parts = message.split('\\n')\n"
"            if self.buffer:\n"
"                s = self.buffer + parts.pop(0)\n"
"                self.logger.log(self.level, s)\n"
"            self.buffer = parts.pop()\n"
"            for part in parts:\n"
"                self.logger.log(self.level, part)"
msgstr ""

#: ../../howto/logging-cookbook.rst:4056
msgid ""
"This just buffers up stuff until a newline is seen, and then logs "
"complete lines. With this approach, you get better output:"
msgstr ""

#: ../../howto/logging-cookbook.rst:4059
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line "
"55, in <module>\n"
"WARNING:demo:    main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line "
"52, in main\n"
"WARNING:demo:    1/0\n"
"WARNING:demo:ZeroDivisionError: division by zero"
msgstr ""

#: ../../howto/logging-cookbook.rst:4072
msgid "Patterns to avoid"
msgstr ""

#: ../../howto/logging-cookbook.rst:4074
msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns"
" which are *unhelpful*, and which should therefore be avoided in most "
"cases. The following sections are in no particular order."
msgstr ""

#: ../../howto/logging-cookbook.rst:4080
msgid "Opening the same log file multiple times"
msgstr ""

#: ../../howto/logging-cookbook.rst:4082
msgid ""
"On Windows, you will generally not be able to open the same file multiple"
" times as this will lead to a \"file is in use by another process\" "
"error. However, on POSIX platforms you'll not get any errors if you open "
"the same file multiple times. This could be done accidentally, for "
"example by:"
msgstr ""

#: ../../howto/logging-cookbook.rst:4087
msgid ""
"Adding a file handler more than once which references the same file (e.g."
" by a copy/paste/forget-to-change error)."
msgstr ""

#: ../../howto/logging-cookbook.rst:4090
msgid ""
"Opening two files that look different, as they have different names, but "
"are the same because one is a symbolic link to the other."
msgstr ""

#: ../../howto/logging-cookbook.rst:4093
msgid ""
"Forking a process, following which both parent and child have a reference"
" to the same file. This might be through use of the "
":mod:`multiprocessing` module, for example."
msgstr ""

#: ../../howto/logging-cookbook.rst:4097
msgid ""
"Opening a file multiple times might *appear* to work most of the time, "
"but can lead to a number of problems in practice:"
msgstr ""

#: ../../howto/logging-cookbook.rst:4100
msgid ""
"Logging output can be garbled because multiple threads or processes try "
"to write to the same file. Although logging guards against concurrent use"
" of the same handler instance by multiple threads, there is no such "
"protection if concurrent writes are attempted by two different threads "
"using two different handler instances which happen to point to the same "
"file."
msgstr ""

#: ../../howto/logging-cookbook.rst:4106
msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based "
"rotation being supposedly in place."
msgstr ""

#: ../../howto/logging-cookbook.rst:4113
msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent "
"such issues."
msgstr ""

#: ../../howto/logging-cookbook.rst:4117
msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr ""

#: ../../howto/logging-cookbook.rst:4119
msgid ""
"While there might be unusual cases where you'll need to do this, in "
"general there is no point because loggers are singletons. Code can always"
" access a given logger instance by name using "
"``logging.getLogger(name)``, so passing instances around and holding them"
" as instance attributes is pointless. Note that in other languages such "
"as Java and C#, loggers are often static class attributes. However, this "
"pattern doesn't make sense in Python, where the module (and not the "
"class) is the unit of software decomposition."
msgstr ""

#: ../../howto/logging-cookbook.rst:4128
msgid ""
"Adding handlers other than :class:`~logging.NullHandler` to a logger in a"
" library"
msgstr ""

#: ../../howto/logging-cookbook.rst:4130
msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. "
"If you are maintaining a library, ensure that you don't add handlers to "
"any of your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""

#: ../../howto/logging-cookbook.rst:4136
msgid "Creating a lot of loggers"
msgstr ""

#: ../../howto/logging-cookbook.rst:4138
msgid ""
"Loggers are singletons that are never freed during a script execution, "
"and so creating lots of loggers will use up memory which can't then be "
"freed. Rather than create a logger per e.g. file processed or network "
"connection made, use the :ref:`existing mechanisms <context-info>` for "
"passing contextual information into your logs and restrict the loggers "
"created to those describing areas within your application (generally "
"modules, but occasionally slightly more fine-grained than that)."
msgstr ""

#: ../../howto/logging-cookbook.rst:4149
msgid "Other resources"
msgstr ""

#: ../../howto/logging-cookbook.rst:4153
msgid "Module :mod:`logging`"
msgstr "모듈 :mod:`logging`"

#: ../../howto/logging-cookbook.rst:4154
msgid "API reference for the logging module."
msgstr "logging 모듈에 대한 API 레퍼런스"

#: ../../howto/logging-cookbook.rst:4156
msgid "Module :mod:`logging.config`"
msgstr "모듈 :mod:`logging.config`"

#: ../../howto/logging-cookbook.rst:4157
msgid "Configuration API for the logging module."
msgstr "logging 모듈용 구성 API."

#: ../../howto/logging-cookbook.rst:4159
msgid "Module :mod:`logging.handlers`"
msgstr "모듈 :mod:`logging.handlers`"

#: ../../howto/logging-cookbook.rst:4160
msgid "Useful handlers included with the logging module."
msgstr "logging 모듈에 포함된 유용한 처리기."

#: ../../howto/logging-cookbook.rst:4162
#, fuzzy
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`기초 로깅 자습서 <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:4164
#, fuzzy
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`고급 로깅 자습서 <logging-advanced-tutorial>`"

#~ msgid ""
#~ "These are not \"true\" .gz files, "
#~ "as they are bare compressed data, "
#~ "with no \"container\" such as you’d "
#~ "find in an actual gzip file. This"
#~ " snippet is just for illustration "
#~ "purposes."
#~ msgstr ""
#~ "이것은 \"진짜\" .gz 파일이 아닙니다. 단순히 압축된"
#~ " 데이터일 뿐이고, 실제 gzip 파일에서 찾을 수"
#~ " 있는 \"컨테이너\" 가 없습니다. 이 코드 조각은"
#~ " 단지 설명을 위한 것일 뿐입니다."

