# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/clinic.rst:8
msgid "Argument Clinic How-To"
msgstr "인자 클리닉 How-To"

#: ../../howto/clinic.rst:13
msgid ""
"The Argument Clinic How-TO has been moved to the `Python Developer's "
"Guide <https://devguide.python.org/development-tools/clinic/>`__."
msgstr ""

#~ msgid "author"
#~ msgstr "저자"

#~ msgid "Larry Hastings"
#~ msgstr "Larry Hastings"

#~ msgid "Abstract"
#~ msgstr "요약"

#~ msgid ""
#~ "Argument Clinic is a preprocessor for"
#~ " CPython C files. Its purpose is "
#~ "to automate all the boilerplate involved"
#~ " with writing argument parsing code "
#~ "for \"builtins\". This document shows "
#~ "you how to convert your first C"
#~ " function to work with Argument "
#~ "Clinic, and then introduces some "
#~ "advanced topics on Argument Clinic "
#~ "usage."
#~ msgstr ""
#~ "인자 클리닉(Argument Clinic)은 CPython C 파일을"
#~ " 위한 전 처리기입니다. 그 목적은 \"내장\"에 대한"
#~ " 인자 구문 분석 코드 작성과 관련된 모든 "
#~ "상용구를 자동화하는 것입니다. 이 설명서는 여러분의 첫 "
#~ "번째 C 함수를 인자 클리닉과 함께 작동하도록 "
#~ "변환하는 방법을 보여준 다음, 인자 클리닉 사용에 "
#~ "대한 몇 가지 고급 주제를 소개합니다."

#~ msgid ""
#~ "Currently Argument Clinic is considered "
#~ "internal-only for CPython.  Its use "
#~ "is not supported for files outside "
#~ "CPython, and no guarantees are made "
#~ "regarding backwards compatibility for future"
#~ " versions.  In other words: if you"
#~ " maintain an external C extension for"
#~ " CPython, you're welcome to experiment "
#~ "with Argument Clinic in your own "
#~ "code.  But the version of Argument "
#~ "Clinic that ships with the next "
#~ "version of CPython *could* be totally"
#~ " incompatible and break all your "
#~ "code."
#~ msgstr ""
#~ "현재 인자 클리닉은 CPython에 내부 전용으로 간주합니다."
#~ " CPython 외부의 파일에 대해서는 사용이 지원되지 "
#~ "않으며, 향후 버전에서 이전 버전과의 호환성을 보장하지 "
#~ "않습니다. 즉: 여러분이 CPython에 대한 외부 C "
#~ "확장을 유지한다면, 여러분의 자체 코드에서 인자 클리닉을"
#~ " 실험하는 것은 환영합니다. 그러나 다음 버전의 "
#~ "CPython과 함께 제공되는 인자 클리닉 버전은 완전히"
#~ " 호환되지 않고 여러분의 모든 코드를 망가뜨릴 수 "
#~ "*있습니다*."

#~ msgid "The Goals Of Argument Clinic"
#~ msgstr "인자 클리닉의 목표"

#~ msgid ""
#~ "Argument Clinic's primary goal is to "
#~ "take over responsibility for all "
#~ "argument parsing code inside CPython.  "
#~ "This means that, when you convert "
#~ "a function to work with Argument "
#~ "Clinic, that function should no longer"
#~ " do any of its own argument "
#~ "parsing—the code generated by Argument "
#~ "Clinic should be a \"black box\" "
#~ "to you, where CPython calls in at"
#~ " the top, and your code gets "
#~ "called at the bottom, with ``PyObject"
#~ " *args`` (and maybe ``PyObject *kwargs``)"
#~ " magically converted into the C "
#~ "variables and types you need."
#~ msgstr ""
#~ "인자 클리닉의 주요 목표는 CPython 내부의 모든 "
#~ "인자 구문 분석 코드에 대한 책임을 인수하는 "
#~ "것입니다. 즉, 인자 클리닉에서 작동하도록 함수를 변환할"
#~ " 때, 해당 함수는 더는 자체 인자 구문 "
#~ "분석을 수행하지 않아야 합니다 - 인자 클리닉에서 "
#~ "생성된 코드는 여러분에게 \"블랙박스\"여야 합니다, CPython이"
#~ " 맨 위에서 호출하고, 맨 아래에서 여러분의 코드가"
#~ " 호출되고, ``PyObject *args`` (그리고 아마도 "
#~ "``PyObject *kwargs``)가 여러분이 필요로 하는 C "
#~ "변수와 형으로 마술처럼 변환됩니다."

#~ msgid ""
#~ "In order for Argument Clinic to "
#~ "accomplish its primary goal, it must "
#~ "be easy to use.  Currently, working "
#~ "with CPython's argument parsing library "
#~ "is a chore, requiring maintaining "
#~ "redundant information in a surprising "
#~ "number of places. When you use "
#~ "Argument Clinic, you don't have to "
#~ "repeat yourself."
#~ msgstr ""
#~ "인자 클리닉이 기본 목표를 달성하려면, 사용하기 쉬워야 "
#~ "합니다. 현재, CPython의 인자 구문 분석 라이브러리로"
#~ " 작업하는 것은 따분한 일이며, 놀랄 정도로 많은 "
#~ "장소에서 중복된 정보를 유지해야 합니다. 인자 클리닉을 "
#~ "사용할 때, 여러분 스스로 반복할 필요가 없습니다."

#~ msgid ""
#~ "Obviously, no one would want to "
#~ "use Argument Clinic unless it's solving"
#~ " their problem—and without creating new "
#~ "problems of its own. So it's "
#~ "paramount that Argument Clinic generate "
#~ "correct code. It'd be nice if the"
#~ " code was faster, too, but at "
#~ "the very least it should not "
#~ "introduce a major speed regression.  "
#~ "(Eventually Argument Clinic *should* make "
#~ "a major speedup possible—we could "
#~ "rewrite its code generator to produce"
#~ " tailor-made argument parsing code, "
#~ "rather than calling the general-purpose"
#~ " CPython argument parsing library.  That"
#~ " would make for the fastest argument"
#~ " parsing possible!)"
#~ msgstr ""
#~ "분명히, 자체적으로 새로운 문제를 만들지 않으면서 자신의"
#~ " 문제를 해결하지 않는 한 아무도 인자 클리닉을 "
#~ "사용하고 싶어 하지 않을 것입니다. 따라서 인자 "
#~ "클리닉이 올바른 코드를 생성하는 것이 가장 중요합니다. "
#~ "코드가 더 빠르면 좋겠지만, 최소한 주요 속도 "
#~ "회귀를 도입해서는 안 됩니다. (인자 클리닉은 결국 "
#~ "대폭적인 속도 향상을 가능하게 해야 *합니다* - "
#~ "범용 CPython 인자 구문 분석 라이브러리를 호출하는"
#~ " 대신 맞춤형 인자 구문 분석 코드를 생성하도록 "
#~ "코드 생성기를 다시 작성할 수 있습니다. 그러면 "
#~ "가능한 가장 빠른 인자 구문 분석이 될 것입니다!)"

#~ msgid ""
#~ "Additionally, Argument Clinic must be "
#~ "flexible enough to work with any "
#~ "approach to argument parsing.  Python "
#~ "has some functions with some very "
#~ "strange parsing behaviors; Argument Clinic's"
#~ " goal is to support all of "
#~ "them."
#~ msgstr ""
#~ "또한, 인자 클리닉은 인자 구문 분석에 대한 모든"
#~ " 접근 방식을 사용할 수 있을 만큼 유연해야 "
#~ "합니다. 파이썬에는 매우 이상한 구문 분석 동작을 "
#~ "가진 몇 가지 함수가 있습니다; 인자 클리닉의 "
#~ "목표는 이들 모두를 지원하는 것입니다."

#~ msgid ""
#~ "Finally, the original motivation for "
#~ "Argument Clinic was to provide "
#~ "introspection \"signatures\" for CPython "
#~ "builtins. It used to be, the "
#~ "introspection query functions would throw "
#~ "an exception if you passed in a"
#~ " builtin.  With Argument Clinic, that's "
#~ "a thing of the past!"
#~ msgstr ""
#~ "마지막으로, 인자 클리닉의 원래 동기는 CPython 내장에"
#~ " 대한 인트로스펙션 \"서명\"을 제공하는 것이었습니다. 예전에는"
#~ " 내장을 전달하면 인트로스펙션 조회 함수에서 예외가 "
#~ "발생했습니다. 인자 클리닉을 사용하면, 그것은 과거의 "
#~ "일입니다!"

#~ msgid ""
#~ "One idea you should keep in mind,"
#~ " as you work with Argument Clinic:"
#~ " the more information you give it,"
#~ " the better job it'll be able "
#~ "to do. Argument Clinic is admittedly "
#~ "relatively simple right now.  But as "
#~ "it evolves it will get more "
#~ "sophisticated, and it should be able "
#~ "to do many interesting and smart "
#~ "things with all the information you "
#~ "give it."
#~ msgstr ""
#~ "인자 클리닉과 함께 일할 때, 명심해야 할 한"
#~ " 가지 아이디어가 있습니다: 더 많은 정보를 제공할수록,"
#~ " 더 나은 작업을 수행할 수 있습니다. 인자 "
#~ "클리닉은 현재 비교적 간단합니다. 그러나 진화함에 따라 "
#~ "더 정교해질 것이며, 여러분이 제공하는 모든 정보로 "
#~ "많은 흥미롭고 현명한 일을 할 수 있어야 합니다."

#~ msgid "Basic Concepts And Usage"
#~ msgstr "기본 개념과 사용법"

#~ msgid ""
#~ "Argument Clinic ships with CPython; "
#~ "you'll find it in ``Tools/clinic/clinic.py``."
#~ " If you run that script, specifying"
#~ " a C file as an argument:"
#~ msgstr ""
#~ "인자 클리닉은 CPython과 함께 제공됩니다; "
#~ "``Tools/clinic/clinic.py``\\에서 찾을 수 있습니다. 해당"
#~ " 스크립트를 실행하면, C 파일을 인자로 지정합니다:"

#~ msgid ""
#~ "Argument Clinic will scan over the "
#~ "file looking for lines that look "
#~ "exactly like this:"
#~ msgstr "인자 클리닉은 파일을 스캔하여 다음과 같은 줄을 찾습니다:"

#~ msgid ""
#~ "When it finds one, it reads "
#~ "everything up to a line that looks"
#~ " exactly like this:"
#~ msgstr "찾으면, 다음과 같은 줄까지 모든 것을 읽습니다:"

#~ msgid ""
#~ "Everything in between these two lines"
#~ " is input for Argument Clinic. All"
#~ " of these lines, including the "
#~ "beginning and ending comment lines, are"
#~ " collectively called an Argument Clinic "
#~ "\"block\"."
#~ msgstr ""
#~ "이 두 줄 사이의 모든 것은 인자 클리닉에 "
#~ "대한 입력입니다. 시작과 끝 주석 줄을 포함하여, "
#~ "이러한 모든 줄을 총칭하여 인자 클리닉 \"블록\"이라고"
#~ " 합니다."

#~ msgid ""
#~ "When Argument Clinic parses one of "
#~ "these blocks, it generates output.  This"
#~ " output is rewritten into the C "
#~ "file immediately after the block, "
#~ "followed by a comment containing a "
#~ "checksum. The Argument Clinic block now"
#~ " looks like this:"
#~ msgstr ""
#~ "인자 클리닉이 이러한 블록 중 하나를 구문 분석할"
#~ " 때, 출력을 생성합니다. 이 출력은 C 파일의 "
#~ "블록 바로 뒤에 다시 쓰이고, 체크섬이 포함된 "
#~ "주석이 이어집니다. 인자 클리닉 블록은 이제 다음과 "
#~ "같습니다:"

#~ msgid ""
#~ "If you run Argument Clinic on the"
#~ " same file a second time, Argument"
#~ " Clinic will discard the old output"
#~ " and write out the new output "
#~ "with a fresh checksum line.  However,"
#~ " if the input hasn't changed, the "
#~ "output won't change either."
#~ msgstr ""
#~ "같은 파일에서 인자 클리닉을 두 번 실행하면, 인자"
#~ " 클리닉은 이전 출력을 버리고 새로운 체크섬 줄로 "
#~ "새 출력을 작성합니다. 그러나, 입력이 변경되지 않았으면,"
#~ " 출력도 변경되지 않습니다."

#~ msgid ""
#~ "You should never modify the output "
#~ "portion of an Argument Clinic block."
#~ "  Instead, change the input until it"
#~ " produces the output you want.  "
#~ "(That's the purpose of the checksum—to"
#~ " detect if someone changed the "
#~ "output, as these edits would be "
#~ "lost the next time Argument Clinic "
#~ "writes out fresh output.)"
#~ msgstr ""
#~ "인자 클리닉 블록의 출력 부분을 수정해서는 안 "
#~ "됩니다. 대신, 원하는 출력을 생성할 때까지 입력을 "
#~ "변경하십시오. (그것이 체크섬의 목적입니다 - 누군가 출력을"
#~ " 변경했는지 감지하는 것, 다음에 인자 클리닉이 새로운"
#~ " 출력을 작성할 때 이러한 편집이 손실되기 때문입니다.)"

#~ msgid ""
#~ "For the sake of clarity, here's "
#~ "the terminology we'll use with Argument"
#~ " Clinic:"
#~ msgstr "명확성을 위해, 인자 클리닉에서 사용할 용어는 다음과 같습니다:"

#~ msgid ""
#~ "The first line of the comment "
#~ "(``/*[clinic input]``) is the *start "
#~ "line*."
#~ msgstr "주석의 첫 번째 줄(``/*[clinic input]``)은 *시작 줄(start line)*\\입니다."

#~ msgid ""
#~ "The last line of the initial "
#~ "comment (``[clinic start generated code]*/``)"
#~ " is the *end line*."
#~ msgstr "초기 주석의 마지막 줄(``[clinic start generated code]*/``)은 *끝줄(end line)*\\입니다."

#~ msgid ""
#~ "The last line (``/*[clinic end generated"
#~ " code: checksum=...]*/``) is the *checksum"
#~ " line*."
#~ msgstr ""
#~ "마지막 줄(``/*[clinic end generated code: "
#~ "checksum=...]*/``)은 *체크섬 줄(checksum line)*\\입니다."

#~ msgid "In between the start line and the end line is the *input*."
#~ msgstr "시작 줄과 끝줄 사이에 잇는 것이 *입력(input)*\\입니다."

#~ msgid "In between the end line and the checksum line is the *output*."
#~ msgstr "끝줄과 체크섬 줄 사이에 있는 것이 *출력(output)*\\입니다."

#~ msgid ""
#~ "All the text collectively, from the "
#~ "start line to the checksum line "
#~ "inclusively, is the *block*.  (A block"
#~ " that hasn't been successfully processed"
#~ " by Argument Clinic yet doesn't have"
#~ " output or a checksum line, but "
#~ "it's still considered a block.)"
#~ msgstr ""
#~ "시작 줄에서 체크섬 줄까지 모든 텍스트는 총칭하여 "
#~ "*블록(block)*\\입니다. (인자 클리닉에서 성공적으로 처리되지 "
#~ "않은 블록은 아직 출력이나 체크섬 줄이 없지만, "
#~ "여전히 블록으로 간주합니다.)"

#~ msgid "Converting Your First Function"
#~ msgstr "첫 번째 함수 변환하기"

#~ msgid ""
#~ "The best way to get a sense "
#~ "of how Argument Clinic works is to"
#~ " convert a function to work with "
#~ "it.  Here, then, are the bare "
#~ "minimum steps you'd need to follow "
#~ "to convert a function to work with"
#~ " Argument Clinic.  Note that for code"
#~ " you plan to check in to "
#~ "CPython, you really should take the "
#~ "conversion farther, using some of the"
#~ " advanced concepts you'll see later "
#~ "on in the document (like \"return "
#~ "converters\" and \"self converters\"). But "
#~ "we'll keep it simple for this "
#~ "walkthrough so you can learn."
#~ msgstr ""
#~ "인자 클리닉의 작동 방식을 이해하는 가장 좋은 "
#~ "방법은 함수를 작동하도록 변환하는 것입니다. 다음은, 인자"
#~ " 클리닉에서 작동하도록 함수를 변환하기 위해 따라야 할"
#~ " 최소한의 단계입니다. CPython에 체크인하려는 코드의 경우,"
#~ " 설명서의 뒷부분에서 볼 수 있는 고급 개념(\"반환"
#~ " 변환기\"와 \"self 변환기\"와 같은)을 사용하여 변환"
#~ " 작업을 더 진행해야 합니다. 하지만 이 연습에서는"
#~ " 배우기 쉽도록 간단하게 유지하겠습니다."

#~ msgid "Let's dive in!"
#~ msgstr "뛰어듭시다!"

#~ msgid ""
#~ "Make sure you're working with a "
#~ "freshly updated checkout of the CPython"
#~ " trunk."
#~ msgstr "CPython trunk의 새로 갱신된 체크 아웃으로 작업하고 있는지 확인하십시오."

#~ msgid ""
#~ "Find a Python builtin that calls "
#~ "either :c:func:`PyArg_ParseTuple` or "
#~ ":c:func:`PyArg_ParseTupleAndKeywords`, and hasn't "
#~ "been converted to work with Argument "
#~ "Clinic yet. For my example I'm "
#~ "using ``_pickle.Pickler.dump()``."
#~ msgstr ""
#~ ":c:func:`PyArg_ParseTuple`\\이나 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` 를 호출하고, 아직 "
#~ "인자 클리닉에서 작동하도록 변환되지 않은 파이썬 내장을 "
#~ "찾습니다. 제 예에서는 ``_pickle.Pickler.dump()``\\를 "
#~ "사용하고 있습니다."

#~ msgid ""
#~ "If the call to the ``PyArg_Parse`` "
#~ "function uses any of the following "
#~ "format units:"
#~ msgstr "``PyArg_Parse`` 함수에 대한 호출이 다음 포맷 단위 중 하나를 사용하거나:"

#~ msgid ""
#~ "or if it has multiple calls to "
#~ ":c:func:`PyArg_ParseTuple`, you should choose "
#~ "a different function.  Argument Clinic "
#~ "*does* support all of these scenarios."
#~ "  But these are advanced topics—let's "
#~ "do something simpler for your first "
#~ "function."
#~ msgstr ""
#~ "또는 :c:func:`PyArg_ParseTuple`\\에 대한 여러 호출이 "
#~ "있으면, 다른 함수를 선택해야 합니다. 인자 클리닉은 "
#~ "이러한 모든 시나리오를 *지원합니다*. 그러나 이것들은 고급"
#~ " 주제입니다 - 첫 번째 함수로 더 간단한 "
#~ "것을 해봅시다."

#~ msgid ""
#~ "Also, if the function has multiple "
#~ "calls to :c:func:`PyArg_ParseTuple` or "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` where it "
#~ "supports different types for the same"
#~ " argument, or if the function uses"
#~ " something besides PyArg_Parse functions to"
#~ " parse its arguments, it probably "
#~ "isn't suitable for conversion to "
#~ "Argument Clinic.  Argument Clinic doesn't "
#~ "support generic functions or polymorphic "
#~ "parameters."
#~ msgstr ""
#~ "또한, 함수가 같은 인자에 대해 다른 형을 지원하는"
#~ " :c:func:`PyArg_ParseTuple`\\이나 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` 에 대한 여러 "
#~ "호출이 있거나, 함수가 인자를 구문 분석하기 위해 "
#~ "PyArg_Parse 함수 이외의 것을 사용하면, 인자 "
#~ "클리닉으로 변환하는 데 적합하지 않을 수 있습니다. "
#~ "인자 클리닉은 제네릭 함수나 다형성 매개 변수를 "
#~ "지원하지 않습니다."

#~ msgid "Add the following boilerplate above the function, creating our block::"
#~ msgstr "함수 위에 다음과 같은 상용구를 추가하여, 블록을 만듭니다::"

#~ msgid ""
#~ "Cut the docstring and paste it in"
#~ " between the ``[clinic]`` lines, removing"
#~ " all the junk that makes it a"
#~ " properly quoted C string. When "
#~ "you're done you should have just "
#~ "the text, based at the left "
#~ "margin, with no line wider than 80"
#~ " characters. (Argument Clinic will preserve"
#~ " indents inside the docstring.)"
#~ msgstr ""
#~ "독스트링을 잘라내어 ``[clinic]`` 줄 사이에 붙여넣고, "
#~ "적절하게 인용된 C 문자열을 만드는 모든 정크를 "
#~ "제거합니다. 완료되면 왼쪽 여백을 기준으로 텍스트가 80자보다"
#~ " 넓은 줄이 없는, 텍스트만 남게 됩니다. (인자 "
#~ "클리닉은 독스트링 내부의 들여쓰기를 유지합니다.)"

#~ msgid ""
#~ "If the old docstring had a first"
#~ " line that looked like a function "
#~ "signature, throw that line away.  (The"
#~ " docstring doesn't need it anymore—when "
#~ "you use ``help()`` on your builtin "
#~ "in the future, the first line will"
#~ " be built automatically based on the"
#~ " function's signature.)"
#~ msgstr ""
#~ "이전 독스트링에 함수 서명처럼 보이는 첫 번째 줄이"
#~ " 있으면, 해당 줄을 버립니다. (독스트링은 이것이 더는"
#~ " 필요하지 않습니다 - 향후 내장에 ``help()``\\를 "
#~ "사용할 때, 첫 번째 줄은 함수의 서명에 따라"
#~ " 자동으로 구축됩니다.)"

#~ msgid "Sample::"
#~ msgstr "샘플::"

#~ msgid ""
#~ "If your docstring doesn't have a "
#~ "\"summary\" line, Argument Clinic will "
#~ "complain.  So let's make sure it "
#~ "has one.  The \"summary\" line should"
#~ " be a paragraph consisting of a "
#~ "single 80-column line at the beginning"
#~ " of the docstring."
#~ msgstr ""
#~ "독스트링에 \"요약\" 줄이 없으면, 인자 클리닉이 "
#~ "불평합니다. 그러니 하나 있도록 합시다. \"요약\" 줄은"
#~ " 독스트링의 시작 부분에 있는 단일 80열 줄로 "
#~ "구성된 단락이어야 합니다."

#~ msgid ""
#~ "(Our example docstring consists solely "
#~ "of a summary line, so the sample"
#~ " code doesn't have to change for "
#~ "this step.)"
#~ msgstr "(예제 독스트링은 요약 줄로만 구성되어서, 이 단계에서 샘플 코드를 변경할 필요가 없습니다.)"

#~ msgid ""
#~ "Above the docstring, enter the name "
#~ "of the function, followed by a "
#~ "blank line.  This should be the "
#~ "Python name of the function, and "
#~ "should be the full dotted path to"
#~ " the function—it should start with "
#~ "the name of the module, include "
#~ "any sub-modules, and if the "
#~ "function is a method on a class"
#~ " it should include the class name "
#~ "too."
#~ msgstr ""
#~ "독스트링 위에, 함수 이름을 입력한 다음, 빈 줄을"
#~ " 입력합니다. 이것은 함수의 파이썬 이름이어야 하며, "
#~ "함수에 대한 전체 점표기법 경로여야 합니다 - 모듈"
#~ " 이름으로 시작하고, 모든 하위 모듈을 포함해야 하며,"
#~ " 함수가 클래스의 메서드이면 클래스 이름도 포함해야 "
#~ "합니다."

#~ msgid ""
#~ "If this is the first time that "
#~ "module or class has been used with"
#~ " Argument Clinic in this C file, "
#~ "you must declare the module and/or "
#~ "class.  Proper Argument Clinic hygiene "
#~ "prefers declaring these in a separate"
#~ " block somewhere near the top of "
#~ "the C file, in the same way "
#~ "that include files and statics go "
#~ "at the top.  (In our sample code"
#~ " we'll just show the two blocks "
#~ "next to each other.)"
#~ msgstr ""
#~ "이 C 파일에서 해당 모듈이나 클래스가 인자 "
#~ "클리닉과 함께 처음 사용된 것이면, 모듈 및/또는 "
#~ "클래스를 선언해야 합니다. 적절한 인자 클리닉 위생법은 "
#~ "인클루드 파일과 정적 객체가 상단에 가는 것과 같은"
#~ " 방식으로 C 파일의 상단 근처에 있는 별도의 "
#~ "블록에 이를 선언하는 것을 선호합니다. (샘플 코드에서는"
#~ " 서로 옆에 있는 두 블록만 표시합니다.)"

#~ msgid ""
#~ "The name of the class and module"
#~ " should be the same as the one"
#~ " seen by Python.  Check the name "
#~ "defined in the :c:type:`PyModuleDef` or "
#~ ":c:type:`PyTypeObject` as appropriate."
#~ msgstr ""
#~ "클래스와 모듈의 이름은 파이썬에서 보는 이름과 같아야 "
#~ "합니다. :c:type:`PyModuleDef`\\나 :c:type:`PyTypeObject`\\에"
#~ " 정의된 이름을 적절하게 확인하십시오."

#~ msgid ""
#~ "When you declare a class, you must"
#~ " also specify two aspects of its "
#~ "type in C: the type declaration "
#~ "you'd use for a pointer to an "
#~ "instance of this class, and a "
#~ "pointer to the :c:type:`PyTypeObject` for "
#~ "this class."
#~ msgstr ""
#~ "클래스를 선언할 때, C에서 해당 형의 두 가지"
#~ " 측면을 지정해야 합니다: 이 클래스의 인스턴스에 대한"
#~ " 포인터에 사용할 형 선언, 그리고 이 클래스를 "
#~ "위한 :c:type:`PyTypeObject`\\에 대한 포인터."

#~ msgid ""
#~ "Declare each of the parameters to "
#~ "the function.  Each parameter should get"
#~ " its own line.  All the parameter "
#~ "lines should be indented from the "
#~ "function name and the docstring."
#~ msgstr ""
#~ "각 매개 변수를 함수에 선언합니다. 각 매개 변수는"
#~ " 자체 줄을 가져야 합니다. 모든 매개 변수 "
#~ "줄은 함수 이름과 독스트링에서 들여쓰기 되어야 합니다."

#~ msgid "The general form of these parameter lines is as follows:"
#~ msgstr "이러한 매개 변수 줄의 일반적인 형식은 다음과 같습니다:"

#~ msgid "If the parameter has a default value, add that after the converter:"
#~ msgstr "매개 변수에 기본값이 있으면, 변환기(converter) 뒤에 추가하십시오:"

#~ msgid ""
#~ "Argument Clinic's support for \"default "
#~ "values\" is quite sophisticated; please "
#~ "see :ref:`the section below on default"
#~ " values <default_values>` for more "
#~ "information."
#~ msgstr ""
#~ "\"기본값\"에 대한 인자 클리닉의 지원은 매우 정교합니다;"
#~ " 자세한 내용은 :ref:`아래의 기본값에 관한 섹션 "
#~ "<default_values>`\\을 참조하십시오."

#~ msgid "Add a blank line below the parameters."
#~ msgstr "매개 변수 아래에 빈 줄을 추가합니다."

#~ msgid ""
#~ "What's a \"converter\"?  It establishes "
#~ "both the type of the variable used"
#~ " in C, and the method to "
#~ "convert the Python value into a C"
#~ " value at runtime. For now you're "
#~ "going to use what's called a "
#~ "\"legacy converter\"—a convenience syntax "
#~ "intended to make porting old code "
#~ "into Argument Clinic easier."
#~ msgstr ""
#~ "\"변환기(converter)\"는 무엇일까요? C에서 사용되는 변수의 "
#~ "형과, 실행 시간에 파이썬 값을 C값으로 변환하는 "
#~ "방법을 모두 설정합니다. 지금은 이전 코드를 인자 "
#~ "클리닉으로 더 쉽게 이식할 수 있도록 고안된 편의"
#~ " 문법인 \"레거시 변환기\"를 사용할 것입니다."

#~ msgid ""
#~ "For each parameter, copy the \"format"
#~ " unit\" for that parameter from the"
#~ " ``PyArg_Parse()`` format argument and "
#~ "specify *that* as its converter, as "
#~ "a quoted string.  (\"format unit\" is"
#~ " the formal name for the one-"
#~ "to-three character substring of the "
#~ "``format`` parameter that tells the "
#~ "argument parsing function what the type"
#~ " of the variable is and how to"
#~ " convert it.  For more on format "
#~ "units please see :ref:`arg-parsing`.)"
#~ msgstr ""
#~ "매개 변수마다, ``PyArg_Parse()`` format 인자에서 "
#~ "해당 매개 변수의 \"포맷 단위\"를 복사하고 *그것을*"
#~ " (따옴표로 묶은 문자열로) 변환기로 지정하십시오. (\"포맷"
#~ " 단위\"는 인자 구문 분석 함수에 변수 형과 "
#~ "변환 방법을 알려주는 ``format`` 매개 변수의 "
#~ "1~3문자 부분 문자열에 대한 공식 이름입니다. 포맷 "
#~ "단위에 대한 자세한 내용은 :ref:`arg-parsing`\\을 "
#~ "참조하십시오. )"

#~ msgid ""
#~ "For multicharacter format units like "
#~ "``z#``, use the entire two-or-"
#~ "three character string."
#~ msgstr "``z#``\\과 같은 다중 문자 포맷 단위의 경우, 전체 2~3문자 문자열 전체를 사용합니다."

#~ msgid ""
#~ "If your function has ``|`` in the"
#~ " format string, meaning some parameters "
#~ "have default values, you can ignore "
#~ "it.  Argument Clinic infers which "
#~ "parameters are optional based on whether"
#~ " or not they have default values."
#~ msgstr ""
#~ "함수의 포맷 문자열에 ``|``\\가 있으면 (일부 매개"
#~ " 변수에 기본값이 있음을 의미합니다), 무시할 수 "
#~ "있습니다. 인자 클리닉은 기본값이 있는지에 따라 어떤 "
#~ "매개 변수가 선택적인지 유추합니다."

#~ msgid ""
#~ "If your function has ``$`` in the"
#~ " format string, meaning it takes "
#~ "keyword-only arguments, specify ``*`` on"
#~ " a line by itself before the "
#~ "first keyword-only argument, indented "
#~ "the same as the parameter lines."
#~ msgstr ""
#~ "함수의 포맷 문자열에 ``$``\\가 있으면 (키워드 전용"
#~ " 인자를 취함을 의미합니다), 첫 번째 키워드 전용"
#~ " 인자 앞에 ``*``\\를 별도의 줄로 지정하고 매개"
#~ " 변수 줄과 같게 들여쓰기합니다."

#~ msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
#~ msgstr "(``_pickle.Pickler.dump``\\에는 둘 다 없어서, 샘플은 변경되지 않습니다.)"

#~ msgid ""
#~ "If the existing C function calls "
#~ ":c:func:`PyArg_ParseTuple` (as opposed to "
#~ ":c:func:`PyArg_ParseTupleAndKeywords`), then all its"
#~ " arguments are positional-only."
#~ msgstr ""
#~ "기존 C 함수가 :c:func:`PyArg_ParseTuple`\\을 호출하면"
#~ " (:c:func:`PyArg_ParseTupleAndKeywords` 가 아니라), "
#~ "모든 인자는 위치 전용입니다."

#~ msgid ""
#~ "To mark all parameters as positional-"
#~ "only in Argument Clinic, add a "
#~ "``/`` on a line by itself after"
#~ " the last parameter, indented the "
#~ "same as the parameter lines."
#~ msgstr ""
#~ "인자 클리닉에서 모든 매개 변수를 위치 전용으로 "
#~ "표시하려면, 마지막 매개 변수 뒤에 ``/``\\를 추가하고"
#~ " 매개 변수 줄과 같게 들여쓰기합니다."

#~ msgid ""
#~ "Currently this is all-or-nothing; "
#~ "either all parameters are positional-"
#~ "only, or none of them are.  (In"
#~ " the future Argument Clinic may relax"
#~ " this restriction.)"
#~ msgstr ""
#~ "현재 이것은 전부 아니면 전무입니다; 모든 매개 "
#~ "변수가 위치 전용이거나, 아무것도 아닙니다. (향후 인자"
#~ " 클리닉에서 이 제한을 완화할 수 있습니다.)"

#~ msgid ""
#~ "It's helpful to write a per-"
#~ "parameter docstring for each parameter. "
#~ "But per-parameter docstrings are "
#~ "optional; you can skip this step "
#~ "if you prefer."
#~ msgstr ""
#~ "매개 변수마다 매개 변수별 독스트링을 작성하는 것이 "
#~ "유용합니다. 그러나 매개 변수별 독스트링은 선택 사항입니다;"
#~ " 원한다면 이 단계를 건너뛸 수 있습니다."

#~ msgid ""
#~ "Here's how to add a per-parameter"
#~ " docstring.  The first line of the"
#~ " per-parameter docstring must be "
#~ "indented further than the parameter "
#~ "definition.  The left margin of this "
#~ "first line establishes the left margin"
#~ " for the whole per-parameter "
#~ "docstring; all the text you write "
#~ "will be outdented by this amount.  "
#~ "You can write as much text as "
#~ "you like, across multiple lines if "
#~ "you wish."
#~ msgstr ""
#~ "매개 변수별 독스트링을 추가하는 방법은 다음과 같습니다."
#~ " 매개 변수별 독스트링의 첫 번째 줄은 매개 "
#~ "변수 정의보다 더 들여 써야 합니다. 이 첫 "
#~ "번째 줄의 왼쪽 여백은 전체 매개 변수별 독스트링에"
#~ " 대한 왼쪽 여백을 설정합니다; 작성하는 모든 텍스트는"
#~ " 이 양만큼 내어 쓰게 됩니다. 원한다면 여러 "
#~ "줄에 걸쳐, 원하는 만큼 텍스트를 작성할 수 "
#~ "있습니다."

#~ msgid ""
#~ "Save and close the file, then run"
#~ " ``Tools/clinic/clinic.py`` on it.  With "
#~ "luck everything worked---your block now"
#~ " has output, and a ``.c.h`` file "
#~ "has been generated! Reopen the file "
#~ "in your text editor to see::"
#~ msgstr ""
#~ "파일을 저장하고 닫은 다음, 그것에 대해 "
#~ "``Tools/clinic/clinic.py``\\를 실행합니다. 운 좋게도 모든"
#~ " 것이 작동했습니다---이제 블록에 출력이 있고 "
#~ "``.c.h`` 파일이 생성되었습니다! 텍스트 편집기에서 파일을 "
#~ "다시 열어 다음을 확인하십시오::"

#~ msgid ""
#~ "Obviously, if Argument Clinic didn't "
#~ "produce any output, it's because it "
#~ "found an error in your input.  "
#~ "Keep fixing your errors and retrying "
#~ "until Argument Clinic processes your "
#~ "file without complaint."
#~ msgstr ""
#~ "명백히, 인자 클리닉이 출력을 생성하지 않았다면, 입력에서"
#~ " 에러를 발견했기 때문입니다. 인자 클리닉이 불평 없이"
#~ " 파일을 처리할 때까지 에러를 수정하고 재시도하십시오."

#~ msgid ""
#~ "For readability, most of the glue "
#~ "code has been generated to a "
#~ "``.c.h`` file.  You'll need to include"
#~ " that in your original ``.c`` file,"
#~ " typically right after the clinic "
#~ "module block::"
#~ msgstr ""
#~ "가독성을 위해, 대부분의 글루(glue) 코드는 ``.c.h`` "
#~ "파일에 생성되었습니다. 일반적으로 클리닉 모듈 블록 바로"
#~ " 뒤에서, 원본 ``.c`` 파일에 포함해야 할 필요가"
#~ " 있습니다::"

#~ msgid ""
#~ "Double-check that the argument-parsing"
#~ " code Argument Clinic generated looks "
#~ "basically the same as the existing "
#~ "code."
#~ msgstr "인자 클리닉에서 생성한 인자 구문 분석 코드가 기본적으로 기존 코드와 같은지 다시 확인합니다."

#~ msgid ""
#~ "First, ensure both places use the "
#~ "same argument-parsing function. The "
#~ "existing code must call either "
#~ ":c:func:`PyArg_ParseTuple` or "
#~ ":c:func:`PyArg_ParseTupleAndKeywords`; ensure that "
#~ "the code generated by Argument Clinic"
#~ " calls the *exact* same function."
#~ msgstr ""
#~ "먼저, 두 곳에서 같은 인자 구문 분석 함수를"
#~ " 사용하는지 확인하십시오. 기존 코드는 "
#~ ":c:func:`PyArg_ParseTuple`\\이나 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` 를 호출해야 합니다;"
#~ " 인자 클리닉에서 생성한 코드가 *정확히* 같은 함수를"
#~ " 호출하는지 확인합니다."

#~ msgid ""
#~ "Second, the format string passed in "
#~ "to :c:func:`PyArg_ParseTuple` or "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` should be "
#~ "*exactly* the same as the hand-"
#~ "written one in the existing function,"
#~ " up to the colon or semi-colon."
#~ msgstr ""
#~ "둘째, :c:func:`PyArg_ParseTuple`\\이나 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` 에 전달된 포맷 "
#~ "문자열은 콜론이나 세미콜론까지 기존 함수에서 손으로 쓴 "
#~ "것과 *정확히* 같아야 합니다."

#~ msgid ""
#~ "(Argument Clinic always generates its "
#~ "format strings with a ``:`` followed "
#~ "by the name of the function.  If"
#~ " the existing code's format string "
#~ "ends with ``;``, to provide usage "
#~ "help, this change is harmless—don't "
#~ "worry about it.)"
#~ msgstr ""
#~ "(인자 클리닉은 항상 ``:`` 뒤에 함수 이름이 "
#~ "있는 포맷 문자열을 생성합니다. 기존 코드의 포맷 "
#~ "문자열이 ``;``\\로 끝나면 (사용법 도움말을 제공하기 "
#~ "위해), 이 변경 사항은 무해합니다 - 걱정하지 "
#~ "마십시오.)"

#~ msgid ""
#~ "Third, for parameters whose format units"
#~ " require two arguments (like a length"
#~ " variable, or an encoding string, or"
#~ " a pointer to a conversion function),"
#~ " ensure that the second argument is"
#~ " *exactly* the same between the two"
#~ " invocations."
#~ msgstr ""
#~ "셋째, 포맷 단위가 두 개의 인자(가령 길이 변수,"
#~ " 인코딩 문자열 또는 변환 함수에 대한 포인터)를 "
#~ "요구하는 매개 변수의 경우, 두 번째 인자가 두"
#~ " 호출 간에 *정확히* 같은지 확인하십시오."

#~ msgid ""
#~ "Fourth, inside the output portion of "
#~ "the block you'll find a preprocessor "
#~ "macro defining the appropriate static "
#~ ":c:type:`PyMethodDef` structure for this "
#~ "builtin::"
#~ msgstr ""
#~ "넷째, 블록의 출력 부분 내부에 이 내장에 적합한"
#~ " 정적 :c:type:`PyMethodDef` 구조체를 정의하는 전 "
#~ "처리기 매크로가 있습니다::"

#~ msgid ""
#~ "This static structure should be "
#~ "*exactly* the same as the existing "
#~ "static :c:type:`PyMethodDef` structure for "
#~ "this builtin."
#~ msgstr "이 정적 구조체는 이 내장의 기존 정적 :c:type:`PyMethodDef` 구조체와 *정확히* 같아야 합니다."

#~ msgid ""
#~ "If any of these items differ in"
#~ " *any way*, adjust your Argument "
#~ "Clinic function specification and rerun "
#~ "``Tools/clinic/clinic.py`` until they *are* "
#~ "the same."
#~ msgstr ""
#~ "이러한 항목 중 *어떤 식으로*\\건 다른 항목이 "
#~ "있으면, 인자 클리닉 함수 명세를 조정하고 같아질 "
#~ "때까지 ``Tools/clinic/clinic.py``\\를 다시 실행합니다."

#~ msgid ""
#~ "Notice that the last line of its"
#~ " output is the declaration of your"
#~ " \"impl\" function.  This is where "
#~ "the builtin's implementation goes. Delete "
#~ "the existing prototype of the function"
#~ " you're modifying, but leave the "
#~ "opening curly brace.  Now delete its "
#~ "argument parsing code and the "
#~ "declarations of all the variables it "
#~ "dumps the arguments into. Notice how "
#~ "the Python arguments are now arguments"
#~ " to this impl function; if the "
#~ "implementation used different names for "
#~ "these variables, fix it."
#~ msgstr ""
#~ "출력의 마지막 줄은 \"impl\" 함수의 선언임에 "
#~ "유의하십시오. 여기가 내장 구현이 들어가는 곳입니다. 수정"
#~ " 중인 함수의 기존 프로토타입을 삭제하십시오, 하지만 "
#~ "여는 중괄호는 그대로 둡니다. 이제 인자 구문 분석"
#~ " 코드와 인자를 덤프하는 모든 변수의 선언을 삭제합니다."
#~ " 이제 어떤 식으로 파이썬 인자가 이 impl "
#~ "함수에 대한 인자가 되는지 주목하십시오; 구현에서 이러한"
#~ " 변수에 다른 이름을 사용했다면, 수정하십시오."

#~ msgid ""
#~ "Let's reiterate, just because it's kind"
#~ " of weird.  Your code should now "
#~ "look like this::"
#~ msgstr "좀 괴상하니, 반복합시다. 이제 코드는 다음과 같아야 합니다::"

#~ msgid ""
#~ "Argument Clinic generated the checksum "
#~ "line and the function prototype just "
#~ "above it.  You should write the "
#~ "opening (and closing) curly braces for"
#~ " the function, and the implementation "
#~ "inside."
#~ msgstr ""
#~ "인자 클리닉은 체크섬 줄과 그 바로 위에 함수"
#~ " 프로토타입을 생성했습니다. 함수와 내부 구현에 대한 "
#~ "여는 (그리고 닫는) 중괄호를 작성해야 합니다."

#~ msgid ""
#~ "Remember the macro with the "
#~ ":c:type:`PyMethodDef` structure for this "
#~ "function?  Find the existing "
#~ ":c:type:`PyMethodDef` structure for this "
#~ "function and replace it with a "
#~ "reference to the macro.  (If the "
#~ "builtin is at module scope, this "
#~ "will probably be very near the end"
#~ " of the file; if the builtin is"
#~ " a class method, this will probably"
#~ " be below but relatively near to "
#~ "the implementation.)"
#~ msgstr ""
#~ "이 함수에 대한 :c:type:`PyMethodDef` 구조체의 매크로를"
#~ " 기억하십니까? 이 함수에 대한 기존 "
#~ ":c:type:`PyMethodDef` 구조체를 찾아 매크로에 대한 "
#~ "참조로 바꿉니다. (내장이 모듈 스코프에 있으면, 아마도"
#~ " 파일의 끝부분에 가까울 것입니다; 내장이 클래스 "
#~ "메서드이면, 아마도 아래에 있지만, 상대적으로 구현에 가까울"
#~ " 것입니다.)"

#~ msgid ""
#~ "Note that the body of the macro"
#~ " contains a trailing comma.  So when"
#~ " you replace the existing static "
#~ ":c:type:`PyMethodDef` structure with the "
#~ "macro, *don't* add a comma to the"
#~ " end."
#~ msgstr ""
#~ "매크로 본문에는 후행 쉼표가 포함되어 있음에 유의하십시오."
#~ " 따라서 기존의 정적 :c:type:`PyMethodDef` 구조체를 "
#~ "매크로로 바꿀 때, 끝에 쉼표를 추가하지 *마십시오*."

#~ msgid ""
#~ "Compile, then run the relevant portions"
#~ " of the regression-test suite. This"
#~ " change should not introduce any new"
#~ " compile-time warnings or errors, and"
#~ " there should be no externally-"
#~ "visible change to Python's behavior."
#~ msgstr ""
#~ "컴파일한 다음, 회귀 테스트 스위트의 관련 부분을 "
#~ "실행합니다. 이 변경으로 인해 새로운 컴파일 시간 "
#~ "경고나 에러가 발생해서는 안 되며, 파이썬의 동작에 "
#~ "대해 외부에서 볼 수 있는 변경 사항이 없어야"
#~ " 합니다."

#~ msgid ""
#~ "Well, except for one difference: "
#~ "``inspect.signature()`` run on your function"
#~ " should now provide a valid "
#~ "signature!"
#~ msgstr ""
#~ "한 가지 차이점이 있습니다: 함수에 대해 실행되는 "
#~ "``inspect.signature()``\\는 이제 유효한 서명을 제공해야 "
#~ "합니다!"

#~ msgid ""
#~ "Congratulations, you've ported your first "
#~ "function to work with Argument Clinic!"
#~ msgstr "축하합니다, 인자 클리닉과 함께 작동하는 첫 번째 함수를 이식했습니다!"

#~ msgid "Advanced Topics"
#~ msgstr "고급 주제"

#~ msgid ""
#~ "Now that you've had some experience "
#~ "working with Argument Clinic, it's time"
#~ " for some advanced topics."
#~ msgstr "이제 인자 클리닉으로 작업한 경험이 있고, 몇 가지 고급 주제를 살펴볼 시간입니다."

#~ msgid "Symbolic default values"
#~ msgstr "기호 기본값"

#~ msgid ""
#~ "The default value you provide for "
#~ "a parameter can't be any arbitrary "
#~ "expression.  Currently the following are "
#~ "explicitly supported:"
#~ msgstr "매개 변수에 제공하는 기본값은 임의의 표현식이 될 수 없습니다. 현재 다음이 명시적으로 지원됩니다:"

#~ msgid "Numeric constants (integer and float)"
#~ msgstr "숫자 상수 (정수와 부동 소수점)"

#~ msgid "String constants"
#~ msgstr "문자열 상수"

#~ msgid "``True``, ``False``, and ``None``"
#~ msgstr "``True``, ``False`` 및 ``None``"

#~ msgid ""
#~ "Simple symbolic constants like "
#~ "``sys.maxsize``, which must start with "
#~ "the name of the module"
#~ msgstr "``sys.maxsize``\\와 같은 간단한 기호 상수, 모듈 이름으로 시작해야 합니다"

#~ msgid ""
#~ "In case you're curious, this is "
#~ "implemented in  ``from_builtin()`` in "
#~ "``Lib/inspect.py``."
#~ msgstr ""
#~ "궁금한 점이 있을 때를 위해, 이것은 "
#~ "``Lib/inspect.py``\\의 ``from_builtin()``\\에서 구현됩니다."

#~ msgid ""
#~ "(In the future, this may need to"
#~ " get even more elaborate, to allow"
#~ " full expressions like ``CONSTANT - "
#~ "1``.)"
#~ msgstr "(미래에는, ``CONSTANT - 1``\\과 같은 완전한 표현식을 허용하기 위해, 더 정교해질 필요가 있습니다.)"

#~ msgid "Renaming the C functions and variables generated by Argument Clinic"
#~ msgstr "인자 클리닉에서 생성한 C 함수와 변수 이름 변경하기"

#~ msgid ""
#~ "Argument Clinic automatically names the "
#~ "functions it generates for you. "
#~ "Occasionally this may cause a problem,"
#~ " if the generated name collides with"
#~ " the name of an existing C "
#~ "function.  There's an easy solution: "
#~ "override the names used for the C"
#~ " functions.  Just add the keyword "
#~ "``\"as\"`` to your function declaration "
#~ "line, followed by the function name "
#~ "you wish to use. Argument Clinic "
#~ "will use that function name for "
#~ "the base (generated) function, then add"
#~ " ``\"_impl\"`` to the end and use "
#~ "that for the name of the impl "
#~ "function."
#~ msgstr ""
#~ "인자 클리닉은 자동으로 생성되는 함수의 이름을 지정합니다."
#~ " 생성된 이름이 기존 C 함수의 이름과 충돌하면, "
#~ "때때로 이로 인해 문제가 발생할 수 있습니다. 쉬운"
#~ " 해결책이 있습니다: C 함수에 사용되는 이름을 "
#~ "재정의하는 것입니다. 함수 선언 줄에 키워드 "
#~ "``\"as\"``\\를 추가한 다음 사용하려는 함수 이름을 "
#~ "추가하면 됩니다. 인자 클리닉은 기본 (생성된) 함수에 "
#~ "해당 함수 이름을 사용한 다음, 끝에 "
#~ "``\"_impl\"``\\을 추가하고 이를 impl 함수의 이름에"
#~ " 사용합니다."

#~ msgid ""
#~ "For example, if we wanted to "
#~ "rename the C function names generated"
#~ " for ``pickle.Pickler.dump``, it'd look "
#~ "like this::"
#~ msgstr "예를 들어, ``pickle.Pickler.dump``\\에 대해 생성된 C 함수 이름을 바꾸려면, 다음과 같이 됩니다::"

#~ msgid ""
#~ "The base function would now be "
#~ "named ``pickler_dumper()``, and the impl "
#~ "function would now be named "
#~ "``pickler_dumper_impl()``."
#~ msgstr ""
#~ "이제 기본 함수의 이름은 ``pickler_dumper()``\\이고 "
#~ "impl 함수의 이름은 ``pickler_dumper_impl()``\\이 됩니다."

#~ msgid ""
#~ "Similarly, you may have a problem "
#~ "where you want to give a parameter"
#~ " a specific Python name, but that "
#~ "name may be inconvenient in C.  "
#~ "Argument Clinic allows you to give "
#~ "a parameter different names in Python"
#~ " and in C, using the same "
#~ "``\"as\"`` syntax::"
#~ msgstr ""
#~ "마찬가지로, 매개 변수에 특정 파이썬 이름을 지정하려고 "
#~ "하지만, 해당 이름이 C에서 불편할 수 있는 경우"
#~ " 문제가 있을 수 있습니다. 인자 클리닉에서는 같은"
#~ " ``\"as\"`` 문법을 사용하여, 파이썬과 C에서 매개 "
#~ "변수에 다른 이름을 지정할 수 있도록 합니다::"

#~ msgid ""
#~ "Here, the name used in Python (in"
#~ " the signature and the ``keywords`` "
#~ "array) would be ``file``, but the "
#~ "C variable would be named ``file_obj``."
#~ msgstr ""
#~ "여기서, 파이썬에서 사용되는 이름(서명과 ``keywords`` "
#~ "배열에서)은 ``file``\\이지만, C 변수의 이름은 "
#~ "``file_obj``\\입니다."

#~ msgid "You can use this to rename the ``self`` parameter too!"
#~ msgstr "이것을 사용하여 ``self`` 매개 변수의 이름도 바꿀 수 있습니다!"

#~ msgid "Converting functions using PyArg_UnpackTuple"
#~ msgstr "PyArg_UnpackTuple을 사용하여 함수 변환하기"

#~ msgid ""
#~ "To convert a function parsing its "
#~ "arguments with :c:func:`PyArg_UnpackTuple`, simply"
#~ " write out all the arguments, "
#~ "specifying each as an ``object``.  You"
#~ " may specify the ``type`` argument to"
#~ " cast the type as appropriate.  All"
#~ " arguments should be marked positional-"
#~ "only (add a ``/`` on a line "
#~ "by itself after the last argument)."
#~ msgstr ""
#~ ":c:func:`PyArg_UnpackTuple`\\로 인자를 구문 분석하는 함수를"
#~ " 변환하려면, 각 인자를 ``object``\\로 지정하여 모든"
#~ " 인자를 작성하면 됩니다. ``type`` 인자를 지정하여 "
#~ "형을 적절하게 캐스트 할 수 있습니다. 모든 인자는"
#~ " 위치 전용으로 표시되어야 합니다 (마지막 인자 뒤에"
#~ " ``/``\\를 자체 줄로 추가하십시오)."

#~ msgid ""
#~ "Currently the generated code will use"
#~ " :c:func:`PyArg_ParseTuple`, but this will "
#~ "change soon."
#~ msgstr "현재 생성된 코드는 :c:func:`PyArg_ParseTuple`\\을 사용하지만, 곧 변경됩니다."

#~ msgid "Optional Groups"
#~ msgstr "선택적 그룹"

#~ msgid ""
#~ "Some legacy functions have a tricky "
#~ "approach to parsing their arguments: "
#~ "they count the number of positional "
#~ "arguments, then use a ``switch`` "
#~ "statement to call one of several "
#~ "different :c:func:`PyArg_ParseTuple` calls depending"
#~ " on how many positional arguments "
#~ "there are.  (These functions cannot "
#~ "accept keyword-only arguments.)  This "
#~ "approach was used to simulate optional"
#~ " arguments back before "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` was created."
#~ msgstr ""
#~ "일부 레거시 함수는 인자를 구문 분석하는 데 "
#~ "까다로운 접근 방식을 사용합니다: 위치 인자의 수를 "
#~ "계산한 다음 ``switch`` 문을 사용하여 위치 인자의"
#~ " 수에 따라 여러 :c:func:`PyArg_ParseTuple` 호출 "
#~ "중 하나를 호출합니다. (이러한 함수는 키워드 전용 "
#~ "인자를 받아들일 수 없습니다.) 이 접근 방식은 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` 가 만들어지기 전에 "
#~ "선택적 인자를 시뮬레이션하는 데 사용되었습니다."

#~ msgid ""
#~ "While functions using this approach can"
#~ " often be converted to use "
#~ ":c:func:`PyArg_ParseTupleAndKeywords`, optional arguments,"
#~ " and default values, it's not always"
#~ " possible.  Some of these legacy "
#~ "functions have behaviors "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` doesn't directly "
#~ "support. The most obvious example is "
#~ "the builtin function ``range()``, which "
#~ "has an optional argument on the "
#~ "*left* side of its required argument!"
#~ " Another example is ``curses.window.addch()``,"
#~ " which has a group of two "
#~ "arguments that must always be specified"
#~ " together.  (The arguments are called "
#~ "``x`` and ``y``; if you call the"
#~ " function passing in ``x``, you must"
#~ " also pass in ``y``—and if you "
#~ "don't pass in ``x`` you may not"
#~ " pass in ``y`` either.)"
#~ msgstr ""
#~ "이 접근 방식을 사용하는 함수는 종종 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords`, 선택적 인자 및 "
#~ "기본값을 사용하도록 변환될 수 있지만, 항상 가능한 "
#~ "것은 아닙니다. 이러한 레거시 함수 중 일부에는 "
#~ ":c:func:`PyArg_ParseTupleAndKeywords` 가 직접 지원하지 "
#~ "않는 동작이 있습니다. 가장 명백한 예는 필수 "
#~ "인자의 *좌* 측에 선택적 인자가 있는 내장 함수"
#~ " ``range()``\\입니다! 또 다른 예는 항상 함께 "
#~ "지정되어야 하는 두 개의 인자 그룹이 있는 "
#~ "``curses.window.addch()``\\입니다. (인자는 ``x`` 와 "
#~ "``y``\\라고 합니다; 함수를 호출할 때 ``x``\\를 "
#~ "전달하면 ``y``\\도 전달해야 합니다 - 그리고 "
#~ "``x``\\를 전달하지 않으면 ``y``\\도 전달할 수 "
#~ "없습니다.)"

#~ msgid ""
#~ "In any case, the goal of Argument"
#~ " Clinic is to support argument "
#~ "parsing for all existing CPython "
#~ "builtins without changing their semantics. "
#~ "Therefore Argument Clinic supports this "
#~ "alternate approach to parsing, using "
#~ "what are called *optional groups*. "
#~ "Optional groups are groups of arguments"
#~ " that must all be passed in "
#~ "together. They can be to the left"
#~ " or the right of the required "
#~ "arguments.  They can *only* be used "
#~ "with positional-only parameters."
#~ msgstr ""
#~ "어쨌든, 인자 클리닉의 목표는 의미를 변경하지 않고 "
#~ "기존의 모든 CPython 내장에 대한 인자 구문 "
#~ "분석을 지원하는 것입니다. 따라서 인자 클리닉은 *선택적"
#~ " 그룹(optional groups)*\\이라는 것을 사용하여, 구문 "
#~ "분석에 대한 이러한 대체 접근 방식을 지원합니다. "
#~ "선택적 그룹은 모두 함께 전달되어야 하는 인자 "
#~ "그룹입니다. 필수 인자의 왼쪽 또는 오른쪽에 있을 "
#~ "수 있습니다. 위치 전용 매개 변수에만 사용할 수"
#~ " 있습니다."

#~ msgid ""
#~ "Optional groups are *only* intended for"
#~ " use when converting functions that "
#~ "make multiple calls to "
#~ ":c:func:`PyArg_ParseTuple`! Functions that use "
#~ "*any* other approach for parsing "
#~ "arguments should *almost never* be "
#~ "converted to Argument Clinic using "
#~ "optional groups.  Functions using optional "
#~ "groups currently cannot have accurate "
#~ "signatures in Python, because Python "
#~ "just doesn't understand the concept.  "
#~ "Please avoid using optional groups "
#~ "wherever possible."
#~ msgstr ""
#~ "선택적 그룹은 *오직* :c:func:`PyArg_ParseTuple`\\을 여러"
#~ " 번 호출하는 함수를 변환할 때 사용하려는 것입니다!"
#~ " 인자를 구문 분석하기 위해 *다른* 접근 방식을 "
#~ "사용하는 함수는 *거의 절대* 선택적 그룹을 사용하여 "
#~ "인자 클리닉으로 변환되지 않습니다. 선택적 그룹을 사용하는"
#~ " 함수는 현재 파이썬에서 정확한 서명을 가질 수 "
#~ "없습니다, 파이썬이 개념을 이해하지 못하기 때문입니다. 가능한"
#~ " 한 선택적 그룹을 사용하지 마십시오."

#~ msgid ""
#~ "To specify an optional group, add "
#~ "a ``[`` on a line by itself "
#~ "before the parameters you wish to "
#~ "group together, and a ``]`` on a"
#~ " line by itself after these "
#~ "parameters.  As an example, here's how"
#~ " ``curses.window.addch`` uses optional groups "
#~ "to make the first two parameters "
#~ "and the last parameter optional::"
#~ msgstr ""
#~ "선택적 그룹을 지정하려면, 함께 그룹화하려는 매개 변수 "
#~ "앞에 ``[``\\를 단독 줄로 추가하고, 이러한 매개 "
#~ "변수 뒤에 단독 줄로 ``]``\\를 추가합니다. 예를 "
#~ "들어, ``curses.window.addch``\\가 선택적 그룹을 사용하여"
#~ " 처음 두 매개 변수와 마지막 매개 변수를 "
#~ "선택적으로 만드는 방법은 다음과 같습니다::"

#~ msgid "Notes:"
#~ msgstr "노트:"

#~ msgid ""
#~ "For every optional group, one additional"
#~ " parameter will be passed into the"
#~ " impl function representing the group.  "
#~ "The parameter will be an int named"
#~ " ``group_{direction}_{number}``, where ``{direction}``"
#~ " is either ``right`` or ``left`` "
#~ "depending on whether the group is "
#~ "before or after the required parameters,"
#~ " and ``{number}`` is a monotonically "
#~ "increasing number (starting at 1) "
#~ "indicating how far away the group "
#~ "is from the required parameters.  When"
#~ " the impl is called, this parameter"
#~ " will be set to zero if this"
#~ " group was unused, and set to "
#~ "non-zero if this group was used. "
#~ "(By used or unused, I mean whether"
#~ " or not the parameters received "
#~ "arguments in this invocation.)"
#~ msgstr ""
#~ "모든 선택적 그룹에 대해, 하나의 추가 매개 변수가"
#~ " impl 함수로 전달되어 그룹을 나타냅니다. 매개 "
#~ "변수는 ``group_{direction}_{number}``\\라는 이름의 정수입니다."
#~ " 여기서 ``{direction}``\\은 그룹이 필수 매개 변수"
#~ " 앞인지 뒤인지에 따라 ``right``\\나 ``left``\\이고, "
#~ "``{number}``\\는 그룹이 필수 매개 변수에서 얼마나 "
#~ "멀리 떨어져 있는지를 나타내는 단조 증가 하는 "
#~ "숫자(1에서 시작)입니다. impl이 호출될 때, 이 그룹이"
#~ " 사용되지 않았으면 이 매개 변수는 0으로 설정되고,"
#~ " 이 그룹이 사용되면 0이 아닌 값으로 설정됩니다."
#~ " (사용했다는 표현은, 매개 변수가 이 호출에서 인자를"
#~ " 받았는지를 의미합니다.)"

#~ msgid ""
#~ "If there are no required arguments, "
#~ "the optional groups will behave as "
#~ "if they're to the right of the "
#~ "required arguments."
#~ msgstr "필수 인자가 없으면, 선택적 그룹은 필수 인자의 오른쪽에 있는 것처럼 작동합니다."

#~ msgid ""
#~ "In the case of ambiguity, the "
#~ "argument parsing code favors parameters "
#~ "on the left (before the required "
#~ "parameters)."
#~ msgstr "모호한 경우, 인자 구문 분석 코드는 왼쪽(필수 매개 변수 앞)의 매개 변수를 선호합니다."

#~ msgid "Optional groups can only contain positional-only parameters."
#~ msgstr "선택적 그룹은 위치 전용 매개 변수 만 포함할 수 있습니다."

#~ msgid ""
#~ "Optional groups are *only* intended for"
#~ " legacy code.  Please do not use "
#~ "optional groups for new code."
#~ msgstr "선택적 그룹은 *오직* 레거시 코드를 위한 것입니다. 새 코드에 선택적 그룹을 사용하지 마십시오."

#~ msgid "Using real Argument Clinic converters, instead of \"legacy converters\""
#~ msgstr "\"레거시 변환기\" 대신 실제 인자 클리닉 변환기 사용하기"

#~ msgid ""
#~ "To save time, and to minimize how"
#~ " much you need to learn to "
#~ "achieve your first port to Argument "
#~ "Clinic, the walkthrough above tells you"
#~ " to use \"legacy converters\".  \"Legacy"
#~ " converters\" are a convenience, designed"
#~ " explicitly to make porting existing "
#~ "code to Argument Clinic easier.  And "
#~ "to be clear, their use is "
#~ "acceptable when porting code for Python"
#~ " 3.4."
#~ msgstr ""
#~ "시간을 절약하고, 인자 클리닉으로의 첫 번째 이식을 "
#~ "달성하는 데 필요한 학습량을 최소화하기 위해, 위의 "
#~ "연습에서는 \"레거시 변환기\"를 사용하도록 지시합니다. \"레거시"
#~ " 변환기\"는 기존 코드를 인자 클리닉으로 더 쉽게"
#~ " 이식 할 수 있도록 명시적으로 설계된 편의 "
#~ "기능입니다. 명확하게 말하면, 파이썬 3.4 용 코드를 "
#~ "이식할 때는 사용할 수 있습니다."

#~ msgid ""
#~ "However, in the long term we "
#~ "probably want all our blocks to "
#~ "use Argument Clinic's real syntax for"
#~ " converters.  Why?  A couple reasons:"
#~ msgstr ""
#~ "그러나, 장기적으로 우리는 모든 블록이 변환기를 위한 "
#~ "인자 클리닉의 실제 문법을 사용하기를 원할 것입니다. "
#~ "왜일까요? 몇 가지 이유가 있습니다:"

#~ msgid ""
#~ "The proper converters are far easier "
#~ "to read and clearer in their "
#~ "intent."
#~ msgstr "적절한 변환기는 읽기가 훨씬 쉽고 의도가 명확합니다."

#~ msgid ""
#~ "There are some format units that "
#~ "are unsupported as \"legacy converters\", "
#~ "because they require arguments, and the"
#~ " legacy converter syntax doesn't support"
#~ " specifying arguments."
#~ msgstr ""
#~ "인자가 필요한데, 레거시 변환기 문법이 인자 지정을 "
#~ "지원하지 않아서, \"레거시 변환기\"로 지원되지 않는 일부"
#~ " 포맷 단위가 있습니다."

#~ msgid ""
#~ "In the future we may have a "
#~ "new argument parsing library that isn't"
#~ " restricted to what :c:func:`PyArg_ParseTuple`"
#~ " supports; this flexibility won't be "
#~ "available to parameters using legacy "
#~ "converters."
#~ msgstr ""
#~ "미래에 우리는 :c:func:`PyArg_ParseTuple`\\이 지원하는 것에"
#~ " 제한되지 않는 새로운 인자 구문 분석 라이브러리를"
#~ " 가질 수 있습니다; 이러한 유연성은 레거시 변환기를"
#~ " 사용하는 매개 변수에는 제공되지 않을 것입니다."

#~ msgid ""
#~ "Therefore, if you don't mind a "
#~ "little extra effort, please use the "
#~ "normal converters instead of legacy "
#~ "converters."
#~ msgstr "따라서, 약간의 추가 노력을 꺼리지 않는다면, 레거시 변환기 대신 일반 변환기를 사용하십시오."

#~ msgid ""
#~ "In a nutshell, the syntax for "
#~ "Argument Clinic (non-legacy) converters "
#~ "looks like a Python function call.  "
#~ "However, if there are no explicit "
#~ "arguments to the function (all functions"
#~ " take their default values), you may"
#~ " omit the parentheses.  Thus ``bool`` "
#~ "and ``bool()`` are exactly the same "
#~ "converters."
#~ msgstr ""
#~ "간단히 말해서, 인자 클리닉 (비 레거시) 변환기의 "
#~ "문법은 파이썬 함수 호출처럼 보입니다; 그러나, 함수에 "
#~ "대한 명시적 인자가 없으면 (모든 함수가 기본값을 "
#~ "취함), 괄호를 생략할 수 있습니다. 따라서 ``bool``"
#~ " 과 ``bool()`` 은 정확히 같은 변환기입니다."

#~ msgid ""
#~ "All arguments to Argument Clinic "
#~ "converters are keyword-only. All "
#~ "Argument Clinic converters accept the "
#~ "following arguments:"
#~ msgstr "인자 클리닉 변환기에 대한 모든 인자는 키워드 전용입니다. 모든 인자 클리닉 변환기는 다음 인자를 받아들입니다:"

#~ msgid "``c_default``"
#~ msgstr "``c_default``"

#~ msgid ""
#~ "The default value for this parameter "
#~ "when defined in C. Specifically, this"
#~ " will be the initializer for the "
#~ "variable declared in the \"parse "
#~ "function\".  See :ref:`the section on "
#~ "default values <default_values>` for how "
#~ "to use this. Specified as a "
#~ "string."
#~ msgstr ""
#~ "C에서 정의될 때 이 매개 변수의 기본값. 특히,"
#~ " 이것은 \"구문 분석 함수\"에서 선언된 변수의 "
#~ "초기화자가 됩니다. 이것을 사용하는 방법은 :ref:`기본값에 "
#~ "관한 섹션 <default_values>`\\을 참조하십시오. 문자열로 "
#~ "지정됩니다."

#~ msgid "``annotation``"
#~ msgstr "``annotation``"

#~ msgid ""
#~ "The annotation value for this parameter."
#~ "  Not currently supported, because :pep:`8`"
#~ " mandates that the Python library may"
#~ " not use annotations."
#~ msgstr ""
#~ "이 매개 변수의 어노테이션 값. :pep:`8`\\은 파이썬"
#~ " 라이브러리가 어노테이션을 사용하지 않도록 요구하므로, 현재 "
#~ "지원되지 않습니다."

#~ msgid ""
#~ "In addition, some converters accept "
#~ "additional arguments.  Here is a list"
#~ " of these arguments, along with their"
#~ " meanings:"
#~ msgstr "또한, 일부 변환기는 추가 인자를 받아들입니다. 다음은 의미와 함께, 이러한 인자들의 목록입니다:"

#~ msgid "``accept``"
#~ msgstr "``accept``"

#~ msgid ""
#~ "A set of Python types (and "
#~ "possibly pseudo-types); this restricts "
#~ "the allowable Python argument to values"
#~ " of these types. (This is not a"
#~ " general-purpose facility; as a rule"
#~ " it only supports specific lists of"
#~ " types as shown in the legacy "
#~ "converter table.)"
#~ msgstr ""
#~ "파이썬 형(그리고 의사 형도 가능)의 집합; 이는 "
#~ "허용 가능한 파이썬 인자를 이러한 형의 값으로 "
#~ "제한합니다. (이것은 범용 기능이 아닙니다; 일반적으로 레거시"
#~ " 변환기 표에 표시된 특정 형 리스트만 지원합니다.)"

#~ msgid "To accept ``None``, add ``NoneType`` to this set."
#~ msgstr "``None``\\을 받아들이려면, 이 집합에 ``NoneType``\\을 추가하십시오."

#~ msgid "``bitwise``"
#~ msgstr "``bitwise``"

#~ msgid ""
#~ "Only supported for unsigned integers.  "
#~ "The native integer value of this "
#~ "Python argument will be written to "
#~ "the parameter without any range "
#~ "checking, even for negative values."
#~ msgstr ""
#~ "부호 없는 정수에 대해서만 지원됩니다. 이 파이썬 "
#~ "인자의 네이티브 정숫값은 음수 값에 대해서조차 범위 "
#~ "검사 없이 매개 변수에 기록됩니다."

#~ msgid "``converter``"
#~ msgstr "``converter``"

#~ msgid ""
#~ "Only supported by the ``object`` "
#~ "converter.  Specifies the name of a "
#~ ":ref:`C \"converter function\" <o_ampersand>` "
#~ "to use to convert this object to"
#~ " a native type."
#~ msgstr ""
#~ "``object`` 변환기에서만 지원됩니다. 이 객체를 네이티브 "
#~ "형으로 변환하는 데 사용할 :ref:`C \"변환기 함수\""
#~ " <o_ampersand>`\\의 이름을 지정합니다."

#~ msgid "``encoding``"
#~ msgstr "``encoding``"

#~ msgid ""
#~ "Only supported for strings.  Specifies "
#~ "the encoding to use when converting "
#~ "this string from a Python str "
#~ "(Unicode) value into a C ``char "
#~ "*`` value."
#~ msgstr ""
#~ "문자열에 대해서만 지원됩니다. 이 문자열을 파이썬 str"
#~ " (유니코드) 값에서 C ``char *`` 값으로 "
#~ "변환할 때 사용할 인코딩을 지정합니다."

#~ msgid "``subclass_of``"
#~ msgstr "``subclass_of``"

#~ msgid ""
#~ "Only supported for the ``object`` "
#~ "converter.  Requires that the Python "
#~ "value be a subclass of a Python"
#~ " type, as expressed in C."
#~ msgstr "``object`` 변환기에 대해서만 지원됩니다. 파이썬 값은 C로 표현된 파이썬 형의 서브 클래스여야 합니다."

#~ msgid "``type``"
#~ msgstr "``type``"

#~ msgid ""
#~ "Only supported for the ``object`` and"
#~ " ``self`` converters.  Specifies the C "
#~ "type that will be used to declare"
#~ " the variable.  Default value is "
#~ "``\"PyObject *\"``."
#~ msgstr ""
#~ "``object``\\와 ``self`` 변환기에 대해서만 지원됩니다. "
#~ "변수를 선언하는 데 사용할 C형을 지정합니다. 기본값은 "
#~ "``\"PyObject *\"``\\입니다."

#~ msgid "``zeroes``"
#~ msgstr "``zeroes``"

#~ msgid ""
#~ "Only supported for strings.  If true,"
#~ " embedded NUL bytes (``'\\\\0'``) are "
#~ "permitted inside the value.  The length"
#~ " of the string will be passed "
#~ "in to the impl function, just "
#~ "after the string parameter, as a "
#~ "parameter named ``<parameter_name>_length``."
#~ msgstr ""
#~ "문자열에 대해서만 지원됩니다. 참이면, 값 내에 내장된 "
#~ "NUL 바이트(``'\\\\0'``)가 허용됩니다. 문자열의 길이는 "
#~ "문자열 매개 변수 바로 뒤에 "
#~ "``<parameter_name>_length``\\라는 이름의 매개 변수로 "
#~ "impl 함수에 전달됩니다."

#~ msgid ""
#~ "Please note, not every possible "
#~ "combination of arguments will work. "
#~ "Usually these arguments are implemented "
#~ "by specific ``PyArg_ParseTuple`` *format "
#~ "units*, with specific behavior.  For "
#~ "example, currently you cannot call "
#~ "``unsigned_short`` without also specifying "
#~ "``bitwise=True``. Although it's perfectly "
#~ "reasonable to think this would work, "
#~ "these semantics don't map to any "
#~ "existing format unit.  So Argument "
#~ "Clinic doesn't support it.  (Or, at "
#~ "least, not yet.)"
#~ msgstr ""
#~ "가능한 모든 인자 조합이 작동하는 것은 아님에 "
#~ "유의하십시오. 일반적으로 이러한 인자는 특정 동작을 갖는"
#~ " 특정 ``PyArg_ParseTuple`` *포맷 단위*\\에 의해 "
#~ "구현됩니다. 예를 들어, 현재 ``bitwise=True``\\를 "
#~ "지정하지 않고 ``unsigned_short``\\를 호출할 수 "
#~ "없습니다. 이것이 작동하리라 생각하는 것이 합리적이지만, "
#~ "이러한 의미는 기존 포맷 단위에 매핑되지 않습니다. "
#~ "그래서 인자 클리닉은 이것을 지원하지 않습니다. (또는,"
#~ " 적어도 아직은 아닙니다.)"

#~ msgid ""
#~ "Below is a table showing the "
#~ "mapping of legacy converters into real"
#~ " Argument Clinic converters.  On the "
#~ "left is the legacy converter, on "
#~ "the right is the text you'd "
#~ "replace it with."
#~ msgstr ""
#~ "다음은 레거시 변환기를 실제 인자 클리닉 변환기에 "
#~ "매핑하는 표입니다. 왼쪽에는 레거시 변환기가 있고, 오른쪽에는"
#~ " 교체할 텍스트가 있습니다."

#~ msgid "``'B'``"
#~ msgstr "``'B'``"

#~ msgid "``unsigned_char(bitwise=True)``"
#~ msgstr "``unsigned_char(bitwise=True)``"

#~ msgid "``'b'``"
#~ msgstr "``'b'``"

#~ msgid "``unsigned_char``"
#~ msgstr "``unsigned_char``"

#~ msgid "``'c'``"
#~ msgstr "``'c'``"

#~ msgid "``char``"
#~ msgstr "``char``"

#~ msgid "``'C'``"
#~ msgstr "``'C'``"

#~ msgid "``int(accept={str})``"
#~ msgstr "``int(accept={str})``"

#~ msgid "``'d'``"
#~ msgstr "``'d'``"

#~ msgid "``double``"
#~ msgstr "``double``"

#~ msgid "``'D'``"
#~ msgstr "``'D'``"

#~ msgid "``Py_complex``"
#~ msgstr "``Py_complex``"

#~ msgid "``'es'``"
#~ msgstr "``'es'``"

#~ msgid "``str(encoding='name_of_encoding')``"
#~ msgstr "``str(encoding='name_of_encoding')``"

#~ msgid "``'es#'``"
#~ msgstr "``'es#'``"

#~ msgid "``str(encoding='name_of_encoding', zeroes=True)``"
#~ msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#~ msgid "``'et'``"
#~ msgstr "``'et'``"

#~ msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
#~ msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#~ msgid "``'et#'``"
#~ msgstr "``'et#'``"

#~ msgid ""
#~ "``str(encoding='name_of_encoding', accept={bytes, "
#~ "bytearray, str}, zeroes=True)``"
#~ msgstr ""
#~ "``str(encoding='name_of_encoding', accept={bytes, "
#~ "bytearray, str}, zeroes=True)``"

#~ msgid "``'f'``"
#~ msgstr "``'f'``"

#~ msgid "``float``"
#~ msgstr "``float``"

#~ msgid "``'h'``"
#~ msgstr "``'h'``"

#~ msgid "``short``"
#~ msgstr "``short``"

#~ msgid "``'H'``"
#~ msgstr "``'H'``"

#~ msgid "``unsigned_short(bitwise=True)``"
#~ msgstr "``unsigned_short(bitwise=True)``"

#~ msgid "``'i'``"
#~ msgstr "``'i'``"

#~ msgid "``int``"
#~ msgstr "``int``"

#~ msgid "``'I'``"
#~ msgstr "``'I'``"

#~ msgid "``unsigned_int(bitwise=True)``"
#~ msgstr "``unsigned_int(bitwise=True)``"

#~ msgid "``'k'``"
#~ msgstr "``'k'``"

#~ msgid "``unsigned_long(bitwise=True)``"
#~ msgstr "``unsigned_long(bitwise=True)``"

#~ msgid "``'K'``"
#~ msgstr "``'K'``"

#~ msgid "``unsigned_long_long(bitwise=True)``"
#~ msgstr "``unsigned_long_long(bitwise=True)``"

#~ msgid "``'l'``"
#~ msgstr "``'l'``"

#~ msgid "``long``"
#~ msgstr "``long``"

#~ msgid "``'L'``"
#~ msgstr "``'L'``"

#~ msgid "``long long``"
#~ msgstr "``long long``"

#~ msgid "``'n'``"
#~ msgstr "``'n'``"

#~ msgid "``Py_ssize_t``"
#~ msgstr "``Py_ssize_t``"

#~ msgid "``'O'``"
#~ msgstr "``'O'``"

#~ msgid "``object``"
#~ msgstr "``object``"

#~ msgid "``'O!'``"
#~ msgstr "``'O!'``"

#~ msgid "``object(subclass_of='&PySomething_Type')``"
#~ msgstr "``object(subclass_of='&PySomething_Type')``"

#~ msgid "``'O&'``"
#~ msgstr "``'O&'``"

#~ msgid "``object(converter='name_of_c_function')``"
#~ msgstr "``object(converter='name_of_c_function')``"

#~ msgid "``'p'``"
#~ msgstr "``'p'``"

#~ msgid "``bool``"
#~ msgstr "``bool``"

#~ msgid "``'S'``"
#~ msgstr "``'S'``"

#~ msgid "``PyBytesObject``"
#~ msgstr "``PyBytesObject``"

#~ msgid "``'s'``"
#~ msgstr "``'s'``"

#~ msgid "``str``"
#~ msgstr "``str``"

#~ msgid "``'s#'``"
#~ msgstr "``'s#'``"

#~ msgid "``str(zeroes=True)``"
#~ msgstr "``str(zeroes=True)``"

#~ msgid "``'s*'``"
#~ msgstr "``'s*'``"

#~ msgid "``Py_buffer(accept={buffer, str})``"
#~ msgstr "``Py_buffer(accept={buffer, str})``"

#~ msgid "``'U'``"
#~ msgstr "``'U'``"

#~ msgid "``unicode``"
#~ msgstr "``unicode``"

#~ msgid "``'u'``"
#~ msgstr "``'u'``"

#~ msgid "``Py_UNICODE``"
#~ msgstr "``Py_UNICODE``"

#~ msgid "``'u#'``"
#~ msgstr "``'u#'``"

#~ msgid "``Py_UNICODE(zeroes=True)``"
#~ msgstr "``Py_UNICODE(zeroes=True)``"

#~ msgid "``'w*'``"
#~ msgstr "``'w*'``"

#~ msgid "``Py_buffer(accept={rwbuffer})``"
#~ msgstr "``Py_buffer(accept={rwbuffer})``"

#~ msgid "``'Y'``"
#~ msgstr "``'Y'``"

#~ msgid "``PyByteArrayObject``"
#~ msgstr "``PyByteArrayObject``"

#~ msgid "``'y'``"
#~ msgstr "``'y'``"

#~ msgid "``str(accept={bytes})``"
#~ msgstr "``str(accept={bytes})``"

#~ msgid "``'y#'``"
#~ msgstr "``'y#'``"

#~ msgid "``str(accept={robuffer}, zeroes=True)``"
#~ msgstr "``str(accept={robuffer}, zeroes=True)``"

#~ msgid "``'y*'``"
#~ msgstr "``'y*'``"

#~ msgid "``Py_buffer``"
#~ msgstr "``Py_buffer``"

#~ msgid "``'Z'``"
#~ msgstr "``'Z'``"

#~ msgid "``Py_UNICODE(accept={str, NoneType})``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType})``"

#~ msgid "``'Z#'``"
#~ msgstr "``'Z#'``"

#~ msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#~ msgid "``'z'``"
#~ msgstr "``'z'``"

#~ msgid "``str(accept={str, NoneType})``"
#~ msgstr "``str(accept={str, NoneType})``"

#~ msgid "``'z#'``"
#~ msgstr "``'z#'``"

#~ msgid "``str(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#~ msgid "``'z*'``"
#~ msgstr "``'z*'``"

#~ msgid "``Py_buffer(accept={buffer, str, NoneType})``"
#~ msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#~ msgid ""
#~ "As an example, here's our sample "
#~ "``pickle.Pickler.dump`` using the proper "
#~ "converter::"
#~ msgstr "예를 들어, 적절한 변환기를 사용하는 샘플 ``pickle.Pickler.dump``\\는 다음과 같습니다::"

#~ msgid ""
#~ "One advantage of real converters is "
#~ "that they're more flexible than legacy"
#~ " converters.  For example, the "
#~ "``unsigned_int`` converter (and all the "
#~ "``unsigned_`` converters) can be specified "
#~ "without ``bitwise=True``.  Their default "
#~ "behavior performs range checking on the"
#~ " value, and they won't accept "
#~ "negative numbers.  You just can't do "
#~ "that with a legacy converter!"
#~ msgstr ""
#~ "실제 변환기의 한 가지 장점은 레거시 변환기보다 "
#~ "유연하다는 것입니다. 예를 들어, ``unsigned_int`` "
#~ "변환기(그리고 모든 ``unsigned_`` 변환기)는 "
#~ "``bitwise=True`` 없이 지정될 수 있습니다. 기본 "
#~ "동작은 값에 대해 범위 검사를 수행하며, 음수를 "
#~ "허용하지 않습니다. 레거시 변환기로는 그렇게 할 수 "
#~ "없습니다!"

#~ msgid ""
#~ "Argument Clinic will show you all "
#~ "the converters it has available.  For"
#~ " each converter it'll show you all"
#~ " the parameters it accepts, along "
#~ "with the default value for each "
#~ "parameter. Just run ``Tools/clinic/clinic.py "
#~ "--converters`` to see the full list."
#~ msgstr ""
#~ "인자 클리닉은 사용 가능한 모든 변환기를 보여줍니다. "
#~ "각 변환기에 대해 허용되는 모든 매개 변수와 각"
#~ " 매개 변수의 기본값이 표시됩니다. 전체 목록을 보려면"
#~ " ``Tools/clinic/clinic.py --converters``\\를 실행하십시오."

#~ msgid "Py_buffer"
#~ msgstr "Py_buffer"

#~ msgid ""
#~ "When using the ``Py_buffer`` converter "
#~ "(or the ``'s*'``, ``'w*'``, ``'*y'``, or"
#~ " ``'z*'`` legacy converters), you *must*"
#~ " not call :c:func:`PyBuffer_Release` on the"
#~ " provided buffer. Argument Clinic generates"
#~ " code that does it for you (in"
#~ " the parsing function)."
#~ msgstr ""
#~ "``Py_buffer`` 변환기(또는 ``'s*'``, ``'w*'``, "
#~ "``'*y'`` 또는 ``'z*'`` 레거시 변환기)를 사용할 "
#~ "때, 제공된 버퍼에서 :c:func:`PyBuffer_Release`\\를 호출하지"
#~ " *않아야* 합니다. 인자 클리닉은 (구문 분석 "
#~ "함수에서) 이를 수행하는 코드를 생성합니다."

#~ msgid "Advanced converters"
#~ msgstr "고급 변환기"

#~ msgid ""
#~ "Remember those format units you skipped"
#~ " for your first time because they "
#~ "were advanced?  Here's how to handle "
#~ "those too."
#~ msgstr "고급이기 때문에 처음에는 건너뛴 포맷 단위를 기억하십니까? 다음은 이것도 처리하는 방법입니다."

#~ msgid ""
#~ "The trick is, all those format "
#~ "units take arguments—either conversion "
#~ "functions, or types, or strings "
#~ "specifying an encoding. (But \"legacy "
#~ "converters\" don't support arguments.  That's"
#~ " why we skipped them for your "
#~ "first function.)  The argument you "
#~ "specified to the format unit is "
#~ "now an argument to the converter; "
#~ "this argument is either ``converter`` "
#~ "(for ``O&``), ``subclass_of`` (for ``O!``),"
#~ " or ``encoding`` (for all the format"
#~ " units that start with ``e``)."
#~ msgstr ""
#~ "트릭은, 모든 포맷 단위가 인자를 취한다는 것입니다 "
#~ "- 변환 함수, 형 또는 인코딩을 지정하는 문자열."
#~ " (그러나 \"레거시 변환기\"는 인자를 지원하지 않습니다. "
#~ "이것이 바로 첫 번째 함수에서 건너뛴 이유입니다.) "
#~ "포맷 단위에 지정한 인자는 이제 변환기에 대한 "
#~ "인자입니다; 이 인자는 ``converter`` (``O&``\\의 "
#~ "경우), ``subclass_of`` (``O!`` 의 경우) 또는"
#~ " ``encoding`` (``e``\\로 시작하는 모든 포맷 "
#~ "단위의 경우)입니다."

#~ msgid ""
#~ "When using ``subclass_of``, you may also"
#~ " want to use the other custom "
#~ "argument for ``object()``: ``type``, which "
#~ "lets you set the type actually "
#~ "used for the parameter.  For example,"
#~ " if you want to ensure that the"
#~ " object is a subclass of "
#~ "``PyUnicode_Type``, you probably want to "
#~ "use the converter ``object(type='PyUnicodeObject "
#~ "*', subclass_of='&PyUnicode_Type')``."
#~ msgstr ""
#~ "``subclass_of``\\를 사용할 때, ``object()``\\에 대한"
#~ " 다른 사용자 정의 인자를 사용하고 싶을 수도 "
#~ "있습니다: 매개 변수에 실제로 사용되는 형을 설정할 "
#~ "수 있는 ``type``. 예를 들어, 객체가 "
#~ "``PyUnicode_Type``\\의 서브 클래스인지 확인하려면, "
#~ "``object(type='PyUnicodeObject *', "
#~ "subclass_of='&PyUnicode_Type')`` 변환기를 사용할 수 "
#~ "있습니다."

#~ msgid ""
#~ "One possible problem with using Argument"
#~ " Clinic: it takes away some possible"
#~ " flexibility for the format units "
#~ "starting with ``e``.  When writing a "
#~ "``PyArg_Parse`` call by hand, you could"
#~ " theoretically decide at runtime what "
#~ "encoding string to pass in to "
#~ ":c:func:`PyArg_ParseTuple`.   But now this "
#~ "string must be hard-coded at "
#~ "Argument-Clinic-preprocessing-time.  This "
#~ "limitation is deliberate; it made "
#~ "supporting this format unit much easier,"
#~ " and may allow for future "
#~ "optimizations. This restriction doesn't seem"
#~ " unreasonable; CPython itself always passes"
#~ " in static hard-coded encoding "
#~ "strings for parameters whose format "
#~ "units start with ``e``."
#~ msgstr ""
#~ "인자 클리닉을 사용할 때 발생할 수 있는 한 "
#~ "가지 문제: ``e``\\로 시작하는 포맷 단위에 대해 "
#~ "일부 가능한 유연성을 제거합니다. ``PyArg_Parse`` 호출을"
#~ " 직접 작성할 때, 이론적으로 실행 시간에 "
#~ ":c:func:`PyArg_ParseTuple`\\에 전달할 인코딩 문자열을 결정할"
#~ " 수 있습니다. 그러나 이제 이 문자열은 인자 "
#~ "클리닉 처리 시점에 하드 코딩되어야 합니다. 이 "
#~ "제한은 의도적입니다; 이 포맷 단위를 지원하는 것을 "
#~ "훨씬 쉽게 만들고, 향후 최적화를 허용할 수 "
#~ "있습니다. 이 제한은 비합리적으로 보이지 않습니다; "
#~ "CPython 자체는 항상 포맷 단위가 ``e``\\로 "
#~ "시작하는 매개 변수에 대해 정적 하드 코딩된 인코딩"
#~ " 문자열을 전달합니다."

#~ msgid "Parameter default values"
#~ msgstr "매개 변수 기본값"

#~ msgid ""
#~ "Default values for parameters can be "
#~ "any of a number of values. At "
#~ "their simplest, they can be string, "
#~ "int, or float literals:"
#~ msgstr "매개 변수의 기본값은 여러 값 중 하나일 수 있습니다. 가장 간단하게는, 문자열, 정수 또는 부동 소수점 리터럴일 수 있습니다:"

#~ msgid "They can also use any of Python's built-in constants:"
#~ msgstr "또한 파이썬의 내장 상수를 사용할 수 있습니다:"

#~ msgid ""
#~ "There's also special support for a "
#~ "default value of ``NULL``, and for "
#~ "simple expressions, documented in the "
#~ "following sections."
#~ msgstr "또한 다음 섹션에 설명된 ``NULL``\\과 단순 표현식 기본값에 대한 특별 지원도 있습니다."

#~ msgid "The ``NULL`` default value"
#~ msgstr "``NULL`` 기본값"

#~ msgid ""
#~ "For string and object parameters, you"
#~ " can set them to ``None`` to "
#~ "indicate that there's no default.  "
#~ "However, that means the C variable "
#~ "will be initialized to ``Py_None``.  For"
#~ " convenience's sakes, there's a special "
#~ "value called ``NULL`` for just this "
#~ "reason: from Python's perspective it "
#~ "behaves like a default value of "
#~ "``None``, but the C variable is "
#~ "initialized with ``NULL``."
#~ msgstr ""
#~ "문자열과 객체 매개 변수의 경우, ``None``\\으로 "
#~ "설정하여 기본값이 없음을 나타낼 수 있습니다. 그러나, "
#~ "이는 C 변수가 ``Py_None``\\으로 초기화됨을 의미합니다."
#~ " 편의상, 이 이유로 ``NULL``\\이라는 특수 값이 "
#~ "있습니다: 파이썬의 관점에서 보면 ``None``\\의 기본값처럼 "
#~ "동작하지만, C 변수는 ``NULL``\\로 초기화됩니다."

#~ msgid "Expressions specified as default values"
#~ msgstr "기본값으로 지정된 표현식"

#~ msgid ""
#~ "The default value for a parameter "
#~ "can be more than just a literal"
#~ " value. It can be an entire "
#~ "expression, using math operators and "
#~ "looking up attributes on objects.  "
#~ "However, this support isn't exactly "
#~ "simple, because of some non-obvious "
#~ "semantics."
#~ msgstr ""
#~ "매개 변수의 기본값은 단순한 리터럴 값 이상이 될"
#~ " 수 있습니다. 수학 연산자를 사용하고 객체의 "
#~ "어트리뷰트를 조회하는 전체 표현식이 될 수 있습니다. "
#~ "그러나, 이 지원은 일부 명확하지 않은 의미로 인해"
#~ " 간단하지 않습니다."

#~ msgid "Consider the following example:"
#~ msgstr "다음 예를 고려하십시오:"

#~ msgid ""
#~ "``sys.maxsize`` can have different values "
#~ "on different platforms.  Therefore Argument"
#~ " Clinic can't simply evaluate that "
#~ "expression locally and hard-code it "
#~ "in C.  So it stores the default"
#~ " in such a way that it will "
#~ "get evaluated at runtime, when the "
#~ "user asks for the function's signature."
#~ msgstr ""
#~ "``sys.maxsize``\\는 플랫폼마다 다른 값을 가질 수 "
#~ "있습니다. 따라서 인자 클리닉은 단순히 해당 표현식을 "
#~ "로컬에서 평가하고 C로 하드 코딩할 수 없습니다. "
#~ "따라서 사용자가 함수의 서명을 요청할 때, 실행 "
#~ "시간에 평가되는 방식으로 기본값을 저장합니다."

#~ msgid ""
#~ "What namespace is available when the "
#~ "expression is evaluated?  It's evaluated "
#~ "in the context of the module the"
#~ " builtin came from.  So, if your "
#~ "module has an attribute called "
#~ "\"``max_widgets``\", you may simply use "
#~ "it:"
#~ msgstr ""
#~ "식을 평가할 때 사용할 수 있는 이름 공간은 "
#~ "무엇입니까? 내장이 온 모듈의 컨텍스트에서 평가됩니다. "
#~ "따라서, 모듈에 \"``max_widgets``\"라는 어트리뷰트가 있으면, "
#~ "간단히 사용할 수 있습니다:"

#~ msgid ""
#~ "If the symbol isn't found in the"
#~ " current module, it fails over to "
#~ "looking in ``sys.modules``.  That's how "
#~ "it can find ``sys.maxsize`` for example."
#~ "  (Since you don't know in advance"
#~ " what modules the user will load "
#~ "into their interpreter, it's best to "
#~ "restrict yourself to modules that are"
#~ " preloaded by Python itself.)"
#~ msgstr ""
#~ "심볼이 현재 모듈에서 발견되지 않으면, ``sys.modules``\\를"
#~ " 찾는 것으로 폴백 됩니다. 이것이 예를 들어 "
#~ "``sys.maxsize``\\를 찾는 방법입니다. (사용자가 인터프리터에 "
#~ "로드할 모듈을 미리 알지 못하므로, 파이썬 자체에 "
#~ "의해 미리 로드된 모듈로 제한하는 것이 가장 "
#~ "좋습니다.)"

#~ msgid ""
#~ "Evaluating default values only at "
#~ "runtime means Argument Clinic can't "
#~ "compute the correct equivalent C default"
#~ " value.  So you need to tell it"
#~ " explicitly. When you use an "
#~ "expression, you must also specify the"
#~ " equivalent expression in C, using "
#~ "the ``c_default`` parameter to the "
#~ "converter:"
#~ msgstr ""
#~ "실행 시간에만 기본값을 평가한다는 것은 인자 클리닉이 "
#~ "올바른 동등한 C 기본값을 계산할 수 없음을 "
#~ "의미합니다. 그래서 여러분은 그것을 명시적으로 말할 필요가"
#~ " 있습니다. 표현식을 사용할 때, 변환기에 대한 "
#~ "``c_default`` 매개 변수를 사용하여 C에서 동등한 "
#~ "표현식도 지정해야 합니다:"

#~ msgid ""
#~ "Another complication: Argument Clinic can't"
#~ " know in advance whether or not "
#~ "the expression you supply is valid.  "
#~ "It parses it to make sure it "
#~ "looks legal, but it can't *actually* "
#~ "know.  You must be very careful "
#~ "when using expressions to specify values"
#~ " that are guaranteed to be valid "
#~ "at runtime!"
#~ msgstr ""
#~ "또 다른 복잡함: 인자 클리닉은 여러분이 제공한 "
#~ "표현식이 유효한지를 미리 알 수 없습니다. 올바르게 "
#~ "보이는지 확인하기 위해 구문 분석하지만, *실제로* 올바른지"
#~ " 알 수는 없습니다. 실행 시간에 유효하다고 보장되는"
#~ " 값을 지정하기 위해 표현식을 사용할 때 매우 "
#~ "주의해야 합니다!"

#~ msgid ""
#~ "Finally, because expressions must be "
#~ "representable as static C values, there"
#~ " are many restrictions on legal "
#~ "expressions.  Here's a list of Python"
#~ " features you're not permitted to "
#~ "use:"
#~ msgstr ""
#~ "마지막으로, 표현식은 정적 C값으로 표현할 수 있어야 "
#~ "하므로, 유효한 표현식에는 많은 제한이 있습니다. 다음은"
#~ " 사용이 허용되지 않는 파이썬 기능 목록입니다:"

#~ msgid "Function calls."
#~ msgstr "함수 호출."

#~ msgid "Inline if statements (``3 if foo else 5``)."
#~ msgstr "인라인 if 문 (``3 if foo else 5``)."

#~ msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
#~ msgstr "자동 시퀀스 언 패킹 (``*[1, 2, 3]``)."

#~ msgid "List/set/dict comprehensions and generator expressions."
#~ msgstr "리스트/집합/딕셔너리 컴프리헨션과 제너레이터 표현식."

#~ msgid "Tuple/list/set/dict literals."
#~ msgstr "튜플/이스트/집합/딕셔너리 리터럴."

#~ msgid "Using a return converter"
#~ msgstr "반환 변환기 사용하기"

#~ msgid ""
#~ "By default the impl function Argument"
#~ " Clinic generates for you returns "
#~ "``PyObject *``. But your C function "
#~ "often computes some C type, then "
#~ "converts it into the ``PyObject *`` "
#~ "at the last moment.  Argument Clinic "
#~ "handles converting your inputs from "
#~ "Python types into native C types—why "
#~ "not have it convert your return "
#~ "value from a native C type into"
#~ " a Python type too?"
#~ msgstr ""
#~ "기본적으로 인자 클리닉이 생성하는 impl 함수는 "
#~ "``PyObject *``\\를 반환합니다. 그러나 여러분의 C "
#~ "함수는 종종 어떤 C형을 계산한 다음, 마지막 "
#~ "순간에 ``PyObject *``\\로 변환합니다. 인자 클리닉은 "
#~ "파이썬 형의 입력을 네이티브 C형으로 변환하는 작업을 "
#~ "처리합니다 - 반환 값을 네이티브 C형에서 파이썬 "
#~ "형으로 변환하지 않을 이유가 무엇입니까?"

#~ msgid ""
#~ "That's what a \"return converter\" does."
#~ "  It changes your impl function to"
#~ " return some C type, then adds "
#~ "code to the generated (non-impl) "
#~ "function to handle converting that value"
#~ " into the appropriate ``PyObject *``."
#~ msgstr ""
#~ "이것이 \"반환 변환기(return converter)\"가 하는 "
#~ "일입니다. C형을 반환하도록 impl 함수를 변경한 다음,"
#~ " 생성된 (impl이 아닌) 함수에 코드를 추가하여 해당"
#~ " 값을 적절한 ``PyObject *``\\로 변환합니다."

#~ msgid ""
#~ "The syntax for return converters is "
#~ "similar to that of parameter converters."
#~ " You specify the return converter "
#~ "like it was a return annotation on"
#~ " the function itself.  Return converters"
#~ " behave much the same as parameter"
#~ " converters; they take arguments, the "
#~ "arguments are all keyword-only, and "
#~ "if you're not changing any of the"
#~ " default arguments you can omit the"
#~ " parentheses."
#~ msgstr ""
#~ "반환 변환기의 문법은 매개 변수 변환기의 것과 "
#~ "유사합니다. 함수 자체에 대한 반환 어노테이션처럼 반환 "
#~ "변환기를 지정합니다. 반환 변환기는 매개 변수 변환기와 "
#~ "거의 같게 작동합니다; 인자를 취하고, 인자는 모두 "
#~ "키워드 전용이며, 기본 인자를 변경하지 않으면 괄호를 "
#~ "생략할 수 있습니다."

#~ msgid ""
#~ "(If you use both ``\"as\"`` *and* "
#~ "a return converter for your function,"
#~ " the ``\"as\"`` should come before "
#~ "the return converter.)"
#~ msgstr ""
#~ "(함수에 대해 ``\"as\"``\\와 반환 변환기를 *모두* "
#~ "사용하면, ``\"as\"``\\가 반환 변환기 앞에 와야 "
#~ "합니다.)"

#~ msgid ""
#~ "There's one additional complication when "
#~ "using return converters: how do you "
#~ "indicate an error has occurred?  "
#~ "Normally, a function returns a valid "
#~ "(non-``NULL``) pointer for success, and "
#~ "``NULL`` for failure.  But if you "
#~ "use an integer return converter, all "
#~ "integers are valid.  How can Argument"
#~ " Clinic detect an error?  Its "
#~ "solution: each return converter implicitly "
#~ "looks for a special value that "
#~ "indicates an error.  If you return "
#~ "that value, and an error has been"
#~ " set (``PyErr_Occurred()`` returns a true"
#~ " value), then the generated code will"
#~ " propagate the error.  Otherwise it "
#~ "will encode the value you return "
#~ "like normal."
#~ msgstr ""
#~ "반환 변환기를 사용할 때 한 가지 추가적인 문제가"
#~ " 있습니다: 에러가 발생했음을 어떻게 표시합니까? 일반적으로,"
#~ " 함수는 성공에 대해 유효한 (``NULL``\\이 아닌) "
#~ "포인터를 반환하고, 실패에 대해 ``NULL``\\을 반환합니다. "
#~ "그러나 정수 반환 변환기를 사용하면, 모든 정수가 "
#~ "유효합니다. 인자 클리닉은 어떻게 에러를 감지할까요? 해결책:"
#~ " 각 반환 변환기는 에러를 나타내는 특수 값을 "
#~ "묵시적으로 찾습니다. 해당 값을 반환하고 에러가 설정되면"
#~ " (``PyErr_Occurred()``\\는 참값을 반환합니다), 생성된 "
#~ "코드가 에러를 전파합니다. 그렇지 않으면 정상일 때처럼 "
#~ "반환되는 값을 인코딩합니다."

#~ msgid "Currently Argument Clinic supports only a few return converters:"
#~ msgstr "현재 인자 클리닉은 단지 몇 가지 반환 변환기만 지원합니다:"

#~ msgid ""
#~ "None of these take parameters.  For "
#~ "the first three, return -1 to "
#~ "indicate error.  For ``DecodeFSDefault``, the"
#~ " return type is ``const char *``; "
#~ "return a ``NULL`` pointer to indicate"
#~ " an error."
#~ msgstr ""
#~ "이들 중 어느 것도 매개 변수를 취하지 않습니다."
#~ " 처음 세 개의 경우, -1을 반환하여 에러를 "
#~ "나타냅니다. ``DecodeFSDefault`` 의 경우, 반환형은 "
#~ "``const char *``\\입니다; 에러를 나타내기 위해 "
#~ "``NULL`` 포인터를 반환합니다."

#~ msgid ""
#~ "(There's also an experimental ``NoneType`` "
#~ "converter, which lets you return "
#~ "``Py_None`` on success or ``NULL`` on"
#~ " failure, without having to increment "
#~ "the reference count on ``Py_None``.  I'm"
#~ " not sure it adds enough clarity "
#~ "to be worth using.)"
#~ msgstr ""
#~ "(``Py_None``\\에 대한 참조 횟수를 늘리지 않고, "
#~ "성공 시 ``Py_None``\\을 반환하거나 실패 시 "
#~ "``NULL``\\을 반환할 수 있는, 실험적인 ``NoneType``"
#~ " 변환기도 있습니다. 사용할 가치가 있을 만큼 명확성을"
#~ " 추가할 수 있을지 모르겠습니다.)"

#~ msgid ""
#~ "To see all the return converters "
#~ "Argument Clinic supports, along with "
#~ "their parameters (if any), just run "
#~ "``Tools/clinic/clinic.py --converters`` for the "
#~ "full list."
#~ msgstr ""
#~ "인자 클리닉이 지원하는 모든 반환 변환기를 매개 "
#~ "변수(있다면)와 함께 보려면, 전체 목록을 위해 "
#~ "``Tools/clinic/clinic.py --converters``\\를 실행하십시오."

#~ msgid "Cloning existing functions"
#~ msgstr "기존 함수 복제하기"

#~ msgid ""
#~ "If you have a number of functions"
#~ " that look similar, you may be "
#~ "able to use Clinic's \"clone\" feature."
#~ "  When you clone an existing "
#~ "function, you reuse:"
#~ msgstr ""
#~ "유사해 보이는 함수가 여러 개이면, 클리닉의 "
#~ "\"복제(clone)\" 기능을 사용할 수 있습니다. 기존 "
#~ "함수를 복제할 때, 다음을 재사용합니다:"

#~ msgid "its parameters, including"
#~ msgstr "다음을 포함하는 매개 변수"

#~ msgid "their names,"
#~ msgstr "그들의 이름,"

#~ msgid "their converters, with all parameters,"
#~ msgstr "모든 매개 변수와 함께, 그들의 변환기,"

#~ msgid "their default values,"
#~ msgstr "그들의 기본값,"

#~ msgid "their per-parameter docstrings,"
#~ msgstr "그들의 매개 변수별 독스트링,"

#~ msgid ""
#~ "their *kind* (whether they're positional "
#~ "only, positional or keyword, or keyword"
#~ " only), and"
#~ msgstr "그들의 *종류(kind)* (위치 전용, 위치-키워드 또는 키워드 전용인지), 그리고"

#~ msgid "its return converter."
#~ msgstr "반환 변환기."

#~ msgid ""
#~ "The only thing not copied from the"
#~ " original function is its docstring; "
#~ "the syntax allows you to specify a"
#~ " new docstring."
#~ msgstr "원래 함수에서 복사되지 않는 유일한 것은 독스트링입니다; 문법은 새 독스트링을 지정할 수 있도록 합니다."

#~ msgid "Here's the syntax for cloning a function::"
#~ msgstr "다음은 함수 복제 문법입니다::"

#~ msgid ""
#~ "(The functions can be in different "
#~ "modules or classes.  I wrote "
#~ "``module.class`` in the sample just to"
#~ " illustrate that you must use the "
#~ "full path to *both* functions.)"
#~ msgstr ""
#~ "(함수는 다른 모듈이나 클래스에 있을 수 있습니다. "
#~ "*두* 함수에 전체 경로를 사용해야 함을 예시하기 "
#~ "위해 샘플에 ``module.class``\\를 작성했습니다.)"

#~ msgid ""
#~ "Sorry, there's no syntax for "
#~ "partially-cloning a function, or cloning"
#~ " a function then modifying it.  "
#~ "Cloning is an all-or nothing "
#~ "proposition."
#~ msgstr "죄송합니다, 함수를 부분적으로 복제하거나, 함수를 복제한 다음 수정하는 문법은 없습니다. 복제는 전부 아니면 전무입니다."

#~ msgid ""
#~ "Also, the function you are cloning "
#~ "from must have been previously defined"
#~ " in the current file."
#~ msgstr "또한, 복제하려는 함수는 현재 파일에 이전에 정의되어 있어야 합니다."

#~ msgid "Calling Python code"
#~ msgstr "파이썬 코드 호출하기"

#~ msgid ""
#~ "The rest of the advanced topics "
#~ "require you to write Python code "
#~ "which lives inside your C file and"
#~ " modifies Argument Clinic's runtime state."
#~ "  This is simple: you simply define"
#~ " a Python block."
#~ msgstr ""
#~ "나머지 고급 주제에서는 C 파일에서 파이썬 코드를 "
#~ "작성하고 인자 클리닉의 실행 시간 상태를 수정해야 "
#~ "합니다. 이것은 간단합니다: 파이썬 블록을 정의하기만 하면"
#~ " 됩니다."

#~ msgid ""
#~ "A Python block uses different delimiter"
#~ " lines than an Argument Clinic "
#~ "function block.  It looks like this::"
#~ msgstr "파이썬 블록은 인자 클리닉 함수 블록과 다른 구분자 줄을 사용합니다. 다음과 같이 보입니다::"

#~ msgid ""
#~ "All the code inside the Python "
#~ "block is executed at the time it's"
#~ " parsed.  All text written to stdout"
#~ " inside the block is redirected into"
#~ " the \"output\" after the block."
#~ msgstr ""
#~ "파이썬 블록 내부의 모든 코드는 구문 분석될 때"
#~ " 실행됩니다. 블록 내부에서 stdout에 기록된 모든 "
#~ "텍스트는 블록 뒤의 \"출력\"으로 리디렉션됩니다."

#~ msgid ""
#~ "As an example, here's a Python "
#~ "block that adds a static integer "
#~ "variable to the C code::"
#~ msgstr "예를 들어, 다음은 C 코드에 정적 정수 변수를 추가하는 파이썬 블록입니다::"

#~ msgid "Using a \"self converter\""
#~ msgstr "\"self 변환기\" 사용하기"

#~ msgid ""
#~ "Argument Clinic automatically adds a "
#~ "\"self\" parameter for you using a "
#~ "default converter.  It automatically sets "
#~ "the ``type`` of this parameter to "
#~ "the \"pointer to an instance\" you "
#~ "specified when you declared the type."
#~ "  However, you can override Argument "
#~ "Clinic's converter and specify one "
#~ "yourself. Just add your own ``self`` "
#~ "parameter as the first parameter in "
#~ "a block, and ensure that its "
#~ "converter is an instance of "
#~ "``self_converter`` or a subclass thereof."
#~ msgstr ""
#~ "인자 클리닉은 기본 변환기를 사용하여 \"self\" 매개"
#~ " 변수를 자동으로 추가합니다. 이 매개 변수의 "
#~ "``type``\\을 형을 선언할 때 지정한 \"인스턴스에 "
#~ "대한 포인터\"로 자동 설정합니다. 그러나, 인자 클리닉의"
#~ " 변환기를 재정의하고 직접 지정할 수 있습니다. 자신의"
#~ " ``self`` 매개 변수를 블록의 첫 번째 매개"
#~ " 변수로 추가하고, 변환기가 ``self_converter``\\나 서브"
#~ " 클래스의 인스턴스가 되도록 하십시오."

#~ msgid ""
#~ "What's the point?  This lets you "
#~ "override the type of ``self``, or "
#~ "give it a different default name."
#~ msgstr "요점은 무엇일까요? 이렇게 하면 ``self`` 형을 재정의하거나, 다른 기본 이름을 지정할 수 있습니다."

#~ msgid ""
#~ "How do you specify the custom type"
#~ " you want to cast ``self`` to? "
#~ "If you only have one or two "
#~ "functions with the same type for "
#~ "``self``, you can directly use Argument"
#~ " Clinic's existing ``self`` converter, "
#~ "passing in the type you want to"
#~ " use as the ``type`` parameter::"
#~ msgstr ""
#~ "``self``\\를 캐스트 하려는 사용자 정의 형을 어떻게"
#~ " 지정할까요? ``self``\\에 대해 같은 형의 함수가 "
#~ "하나나 두 개만 있으면, 인자 클리닉의 기존 "
#~ "``self`` 변환기를 직접 사용하여, 사용할 형을 "
#~ "``type`` 매개 변수로 전달할 수 있습니다::"

#~ msgid ""
#~ "On the other hand, if you have "
#~ "a lot of functions that will use"
#~ " the same type for ``self``, it's "
#~ "best to create your own converter, "
#~ "subclassing ``self_converter`` but overwriting "
#~ "the ``type`` member::"
#~ msgstr ""
#~ "반면에, ``self``\\에 대해 같은 형을 사용할 함수가"
#~ " 많으면, ``self_converter``\\를 서브 클래싱하지만 "
#~ "``type`` 멤버를 재정의하는 자체 변환기를 만드는 것이"
#~ " 가장 좋습니다::"

#~ msgid "Writing a custom converter"
#~ msgstr "사용자 정의 변환기 작성하기"

#~ msgid ""
#~ "As we hinted at in the previous"
#~ " section... you can write your own"
#~ " converters! A converter is simply a"
#~ " Python class that inherits from "
#~ "``CConverter``. The main purpose of a"
#~ " custom converter is if you have "
#~ "a parameter using the ``O&`` format "
#~ "unit—parsing this parameter means calling "
#~ "a :c:func:`PyArg_ParseTuple` \"converter function\"."
#~ msgstr ""
#~ "이전 섹션에서 암시했듯이... 자신만의 변환기를 작성할 수"
#~ " 있습니다! 변환기는 ``CConverter``\\를 상속하는 단순한 "
#~ "파이썬 클래스입니다. 사용자 정의 변환기의 주요 목적은 "
#~ "``O&`` 포맷 단위를 사용하는 매개 변수가 있을 "
#~ "때입니다 - 이 매개 변수를 구문 분석한다는 것은"
#~ " :c:func:`PyArg_ParseTuple` \"변환기 함수\"를 호출하는 "
#~ "것을 의미합니다."

#~ msgid ""
#~ "Your converter class should be named "
#~ "``*something*_converter``. If the name follows"
#~ " this convention, then your converter "
#~ "class will be automatically registered "
#~ "with Argument Clinic; its name will "
#~ "be the name of your class with "
#~ "the ``_converter`` suffix stripped off.  "
#~ "(This is accomplished with a metaclass.)"
#~ msgstr ""
#~ "변환기 클래스의 이름은 ``*something*_converter``\\여야 "
#~ "합니다. 이름이 이 규칙을 따르면, 변환기 클래스가 "
#~ "인자 클리닉에 자동으로 등록됩니다: 그 이름은 "
#~ "``_converter`` 접미사가 제거된 클래스 이름이 됩니다. "
#~ "(이는 메타 클래스로 수행됩니다.)"

#~ msgid ""
#~ "You shouldn't subclass ``CConverter.__init__``.  "
#~ "Instead, you should write a "
#~ "``converter_init()`` function.  ``converter_init()`` "
#~ "always accepts a ``self`` parameter; "
#~ "after that, all additional parameters "
#~ "*must* be keyword-only.  Any arguments"
#~ " passed in to the converter in "
#~ "Argument Clinic will be passed along "
#~ "to your ``converter_init()``."
#~ msgstr ""
#~ "``CConverter.__init__``\\를 서브 클래스 해서는 안 "
#~ "됩니다. 대신, ``converter_init()`` 함수를 작성해야 "
#~ "합니다. ``converter_init()``\\는 항상 ``self`` 매개"
#~ " 변수를 받아들입니다; 그 후에, 모든 추가 매개 "
#~ "변수는 *반드시* 키워드 전용이어야 합니다. 인자 클리닉의"
#~ " 변환기에 전달된 모든 인자는 여러분의 "
#~ "``converter_init()``\\로 전달됩니다."

#~ msgid ""
#~ "There are some additional members of "
#~ "``CConverter`` you may wish to specify"
#~ " in your subclass.  Here's the "
#~ "current list:"
#~ msgstr "서브 클래스에 지정하고 싶을 ``CConverter``\\의 추가 멤버가 있습니다. 현재 목록은 다음과 같습니다:"

#~ msgid ""
#~ "The C type to use for this "
#~ "variable. ``type`` should be a Python"
#~ " string specifying the type, e.g. "
#~ "``int``. If this is a pointer "
#~ "type, the type string should end "
#~ "with ``' *'``."
#~ msgstr ""
#~ "이 변수에 사용할 C형. ``type``\\은 형을 지정하는"
#~ " 파이썬 문자열이어야 합니다, 예를 들어 ``int``. "
#~ "포인터형이면, 형 문자열은 ``' *'``\\로 끝나야 "
#~ "합니다."

#~ msgid "``default``"
#~ msgstr "``default``"

#~ msgid ""
#~ "The Python default value for this "
#~ "parameter, as a Python value. Or "
#~ "the magic value ``unspecified`` if there"
#~ " is no default."
#~ msgstr "이 매개 변수의 파이썬 기본값 (파이썬 값). 또는 기본값이 없으면 매직 값 ``unspecified``."

#~ msgid "``py_default``"
#~ msgstr "``py_default``"

#~ msgid ""
#~ "``default`` as it should appear in "
#~ "Python code, as a string. Or "
#~ "``None`` if there is no default."
#~ msgstr "파이썬 코드에 나타날 ``default`` (문자열). 또는 기본값이 없으면 ``None``."

#~ msgid ""
#~ "``default`` as it should appear in "
#~ "C code, as a string. Or ``None``"
#~ " if there is no default."
#~ msgstr "C 코드에 나타날 ``default`` (문자열). 또는 기본값이 없으면 ``None``."

#~ msgid "``c_ignored_default``"
#~ msgstr "``c_ignored_default``"

#~ msgid ""
#~ "The default value used to initialize "
#~ "the C variable when there is no"
#~ " default, but not specifying a "
#~ "default may result in an \"uninitialized"
#~ " variable\" warning.  This can easily "
#~ "happen when using option groups—although "
#~ "properly-written code will never "
#~ "actually use this value, the variable"
#~ " does get passed in to the "
#~ "impl, and the C compiler will "
#~ "complain about the \"use\" of the "
#~ "uninitialized value.  This value should "
#~ "always be a non-empty string."
#~ msgstr ""
#~ "기본값은 없지만, 기본값을 지정하지 않으면 \"초기화되지 않은"
#~ " 변수\" 경고를 발생시킬 수 있을 때, C "
#~ "변수를 초기화하는 데 사용되는 기본값. 이는 옵션 "
#~ "그룹을 사용할 때 쉽게 발생할 수 있습니다 -"
#~ " 적절하게 작성된 코드는 실제로 이 값을 사용하지 "
#~ "않지만, 변수는 impl에 전달되며, C 컴파일러는 초기화되지"
#~ " 않은 값의 \"사용\"에 대해 불평합니다. 이 값은"
#~ " 항상 비어 있지 않은 문자열이어야 합니다."

#~ msgid "The name of the C converter function, as a string."
#~ msgstr "C 변환기 함수의 이름 (문자열)."

#~ msgid "``impl_by_reference``"
#~ msgstr "``impl_by_reference``"

#~ msgid ""
#~ "A boolean value.  If true, Argument "
#~ "Clinic will add a ``&`` in front"
#~ " of the name of the variable "
#~ "when passing it into the impl "
#~ "function."
#~ msgstr "불리언 값. 참이면, 인자 클리닉은 변수를 impl 함수에 전달할 때 변수 이름 앞에 ``&``\\를 추가합니다."

#~ msgid "``parse_by_reference``"
#~ msgstr "``parse_by_reference``"

#~ msgid ""
#~ "A boolean value.  If true, Argument "
#~ "Clinic will add a ``&`` in front"
#~ " of the name of the variable "
#~ "when passing it into "
#~ ":c:func:`PyArg_ParseTuple`."
#~ msgstr ""
#~ "불리언 값. 참이면, 인자 클리닉은 변수를 "
#~ ":c:func:`PyArg_ParseTuple`\\에 전달할 때 변수 이름 "
#~ "앞에 ``&``\\를 추가합니다."

#~ msgid ""
#~ "Here's the simplest example of a "
#~ "custom converter, from ``Modules/zlibmodule.c``::"
#~ msgstr "다음은 ``Modules/zlibmodule.c``\\에서 온, 사용자 정의 변환기의 가장 간단한 예입니다::"

#~ msgid ""
#~ "This block adds a converter to "
#~ "Argument Clinic named ``ssize_t``.  Parameters"
#~ " declared as ``ssize_t`` will be "
#~ "declared as type ``Py_ssize_t``, and "
#~ "will be parsed by the ``'O&'`` "
#~ "format unit, which will call the "
#~ "``ssize_t_converter`` converter function.  "
#~ "``ssize_t`` variables automatically support "
#~ "default values."
#~ msgstr ""
#~ "이 블록은 ``ssize_t``\\라는 이름의 변환기를 인자 "
#~ "클리닉에 추가합니다. ``ssize_t``\\로 선언된 매개 변수는"
#~ " ``Py_ssize_t`` 형으로 선언되고, ``ssize_t_converter``"
#~ " 변환기 함수를 호출하는 ``'O&'`` 포맷 단위로 "
#~ "구문 분석됩니다. ``ssize_t`` 변수는 자동으로 기본값을 "
#~ "지원합니다."

#~ msgid ""
#~ "More sophisticated custom converters can "
#~ "insert custom C code to handle "
#~ "initialization and cleanup. You can see"
#~ " more examples of custom converters "
#~ "in the CPython source tree; grep "
#~ "the C files for the string "
#~ "``CConverter``."
#~ msgstr ""
#~ "더욱 정교한 사용자 정의 변환기는 사용자 정의 C"
#~ " 코드를 삽입하여 초기화와 정리를 처리할 수 있습니다."
#~ " CPython 소스 트리에서 사용자 정의 변환기의 더"
#~ " 많은 예제를 볼 수 있습니다; 문자열 "
#~ "``CConverter``\\에 대해 C 파일을 grep 하십시오."

#~ msgid "Writing a custom return converter"
#~ msgstr "사용자 정의 반환 변환기 작성하기"

#~ msgid ""
#~ "Writing a custom return converter is "
#~ "much like writing a custom converter."
#~ "  Except it's somewhat simpler, because "
#~ "return converters are themselves much "
#~ "simpler."
#~ msgstr ""
#~ "사용자 정의 반환 변환기를 작성하는 것은 사용자 "
#~ "정의 변환기를 작성하는 것과 매우 유사합니다. 반환 "
#~ "변환기 자체가 훨씬 간단하기 때문에 다소 간단하다는 "
#~ "점만 다릅니다."

#~ msgid ""
#~ "Return converters must subclass "
#~ "``CReturnConverter``. There are no examples"
#~ " yet of custom return converters, "
#~ "because they are not widely used "
#~ "yet.  If you wish to write your"
#~ " own return converter, please read "
#~ "``Tools/clinic/clinic.py``, specifically the "
#~ "implementation of ``CReturnConverter`` and all"
#~ " its subclasses."
#~ msgstr ""
#~ "반환 변환기는 ``CReturnConverter``\\를 서브 클래스 "
#~ "해야 합니다. 아직 널리 사용되지 않기 때문에, "
#~ "사용자 정의 반환 변환기의 예는 아직 없습니다. "
#~ "자체 반환 변환기를 작성하려면, ``Tools/clinic/clinic.py``,"
#~ " 특히 ``CReturnConverter``\\와 모든 서브 클래스의 "
#~ "구현을 읽으십시오."

#~ msgid "METH_O and METH_NOARGS"
#~ msgstr "METH_O와 METH_NOARGS"

#~ msgid ""
#~ "To convert a function using ``METH_O``,"
#~ " make sure the function's single "
#~ "argument is using the ``object`` "
#~ "converter, and mark the arguments as "
#~ "positional-only::"
#~ msgstr ""
#~ "``METH_O``\\를 사용하는 함수를 변환하려면, 함수의 단일 "
#~ "인자가 ``object`` 변환기를 사용하고 있는지 확인하고, "
#~ "인자를 위치 전용으로 표시하십시오::"

#~ msgid ""
#~ "To convert a function using "
#~ "``METH_NOARGS``, just don't specify any "
#~ "arguments."
#~ msgstr "``METH_NOARGS``\\를 사용하는 함수를 변환하려면, 인자를 지정하지 마십시오."

#~ msgid ""
#~ "You can still use a self "
#~ "converter, a return converter, and "
#~ "specify a ``type`` argument to the "
#~ "object converter for ``METH_O``."
#~ msgstr ""
#~ "여전히 self 변환기, 반환 변환기를 사용하고, "
#~ "``METH_O``\\를 위한 객체 변환기에 ``type`` 인자를"
#~ " 지정할 수 있습니다."

#~ msgid "tp_new and tp_init functions"
#~ msgstr "tp_new와 tp_init 함수"

#~ msgid ""
#~ "You can convert ``tp_new`` and "
#~ "``tp_init`` functions.  Just name them "
#~ "``__new__`` or ``__init__`` as appropriate."
#~ "  Notes:"
#~ msgstr ""
#~ "``tp_new``\\와 ``tp_init`` 함수를 변환할 수 "
#~ "있습니다. 적절하게 ``__new__``\\나 ``__init__``\\로 이름을"
#~ " 지정하십시오. 참고:"

#~ msgid ""
#~ "The function name generated for "
#~ "``__new__`` doesn't end in ``__new__`` "
#~ "like it would by default.  It's "
#~ "just the name of the class, "
#~ "converted into a valid C identifier."
#~ msgstr ""
#~ "``__new__``\\에 대해 생성된 함수 이름은 기본적으로 "
#~ "그런 것처럼 ``__new__``\\로 끝나지 않습니다. 유효한 "
#~ "C 식별자로 변환된 클래스의 이름일 뿐입니다."

#~ msgid "No ``PyMethodDef`` ``#define`` is generated for these functions."
#~ msgstr "이러한 함수에 대해 ``PyMethodDef`` ``#define``\\이 생성되지 않습니다."

#~ msgid "``__init__`` functions return ``int``, not ``PyObject *``."
#~ msgstr "``__init__`` 함수는 ``PyObject *``\\가 아니라 ``int``\\를 반환합니다."

#~ msgid "Use the docstring as the class docstring."
#~ msgstr "독스트링을 클래스 독스트링으로 사용합니다."

#~ msgid ""
#~ "Although ``__new__`` and ``__init__`` "
#~ "functions must always accept both the"
#~ " ``args`` and ``kwargs`` objects, when "
#~ "converting you may specify any signature"
#~ " for these functions that you like."
#~ " (If your function doesn't support "
#~ "keywords, the parsing function generated "
#~ "will throw an exception if it "
#~ "receives any.)"
#~ msgstr ""
#~ "``__new__``\\와 ``__init__`` 함수는 항상 ``args``\\와"
#~ " ``kwargs`` 객체를 모두 받아들여야 하지만, 변환할 "
#~ "때 이러한 함수에 대해 원하는 서명을 지정할 수"
#~ " 있습니다. (함수가 키워드를 지원하지 않으면, 생성된 "
#~ "구문 분석 함수에서 받게 되면 예외가 발생합니다.)"

#~ msgid "Changing and redirecting Clinic's output"
#~ msgstr "클리닉 출력을 변경하고 리디렉션하기"

#~ msgid ""
#~ "It can be inconvenient to have "
#~ "Clinic's output interspersed with your "
#~ "conventional hand-edited C code.  "
#~ "Luckily, Clinic is configurable: you can"
#~ " buffer up its output for printing"
#~ " later (or earlier!), or write its"
#~ " output to a separate file.  You "
#~ "can also add a prefix or suffix"
#~ " to every line of Clinic's generated"
#~ " output."
#~ msgstr ""
#~ "기존의 수작업으로 편집 한 C 코드에 클리닉의 "
#~ "출력을 산재시키는 것은 불편할 수 있습니다. 운 "
#~ "좋게도, 클리닉은 구성 가능합니다: 나중에 (또는 이전에!)"
#~ " 인쇄하기 위해 출력을 버퍼링하거나, 별도의 파일에 "
#~ "출력을 쓸 수 있습니다. 클리닉의 생성된 출력의 "
#~ "모든 줄에 접두사나 접미사를 추가할 수도 있습니다."

#~ msgid ""
#~ "While changing Clinic's output in this"
#~ " manner can be a boon to "
#~ "readability, it may result in Clinic "
#~ "code using types before they are "
#~ "defined, or your code attempting to "
#~ "use Clinic-generated code before it "
#~ "is defined. These problems can be "
#~ "easily solved by rearranging the "
#~ "declarations in your file, or moving "
#~ "where Clinic's generated code goes.  "
#~ "(This is why the default behavior "
#~ "of Clinic is to output everything "
#~ "into the current block; while many "
#~ "people consider this hampers readability, "
#~ "it will never require rearranging your"
#~ " code to fix definition-before-use"
#~ " problems.)"
#~ msgstr ""
#~ "이러한 방식으로 클리닉의 출력을 변경하면 가독성에 도움이"
#~ " 될 수 있지만, 형이 정의되기 전에 형을 "
#~ "사용하는 클리닉 코드가 발생하거나, 정의되기 전에 클리닉에서"
#~ " 생성된 코드를 사용하려고 시도할 수 있습니다. 이러한"
#~ " 문제는 파일에서 선언을 재정렬하거나, 클리닉에서 생성된 "
#~ "코드가 있는 곳으로 이동하여 쉽게 해결할 수 "
#~ "있습니다. (이것이 클리닉의 기본 동작이 모든 것을 "
#~ "현재 블록으로 출력하는 이유입니다; 많은 사람이 이것이 "
#~ "가독성을 방해한다고 생각하지만, 사용 전 정의 문제를 "
#~ "고치기 위해 코드를 재배열할 필요가 없습니다.)"

#~ msgid "Let's start with defining some terminology:"
#~ msgstr "몇 가지 용어를 정의하는 것으로 시작하겠습니다:"

#~ msgid "*field*"
#~ msgstr "*field*"

#~ msgid ""
#~ "A field, in this context, is a "
#~ "subsection of Clinic's output. For "
#~ "example, the ``#define`` for the "
#~ "``PyMethodDef`` structure is a field, "
#~ "called ``methoddef_define``.  Clinic has seven"
#~ " different fields it can output per"
#~ " function definition:"
#~ msgstr ""
#~ "이 문맥에서, 필드는 클리닉 출력의 하위 섹션입니다. "
#~ "예를 들어, ``PyMethodDef`` 구조체의 ``#define``\\은 "
#~ "``methoddef_define``\\이라는 필드입니다. 클리닉에는 함수 정의당"
#~ " 출력할 수 있는 7가지 필드가 있습니다:"

#~ msgid ""
#~ "All the names are of the form "
#~ "``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
#~ "semantic object represented (the parsing "
#~ "function, the impl function, the "
#~ "docstring, or the methoddef structure) "
#~ "and ``\"<b>\"`` represents what kind of"
#~ " statement the field is.  Field names"
#~ " that end in ``\"_prototype\"`` represent"
#~ " forward declarations of that thing, "
#~ "without the actual body/data of the "
#~ "thing; field names that end in "
#~ "``\"_definition\"`` represent the actual "
#~ "definition of the thing, with the "
#~ "body/data of the thing.  (``\"methoddef\"``"
#~ " is special, it's the only one "
#~ "that ends with ``\"_define\"``, representing"
#~ " that it's a preprocessor #define.)"
#~ msgstr ""
#~ "모든 이름은 ``\"<a>_<b>\"`` 형식입니다. 여기서 "
#~ "``\"<a>\"``\\는 표현 된 의미 객체(구문 분석 "
#~ "함수, impl 함수, 독스트링 또는 methoddef "
#~ "구조체)이고 ``\"<b>\"``\\는 필드가 어떤 종류의 문장인지를"
#~ " 나타냅니다. ``\"_prototype\"``\\으로 끝나는 필드 이름은"
#~ " 무언가의 실제 본문/데이터 없이 무언가의 전방 선언을"
#~ " 나타냅니다; ``\"_definition\"``\\으로 끝나는 필드 이름은"
#~ " 무언가의 본문/데이터와 함께 무언가의 실제 정의를 "
#~ "나타냅니다. (``\"methoddef\"``\\는 특별합니다. 전 처리기 "
#~ "#define임을 나타내는 ``\"_define\"``\\으로 끝나는 유일한 "
#~ "것입니다.)"

#~ msgid "*destination*"
#~ msgstr "*destination*"

#~ msgid ""
#~ "A destination is a place Clinic "
#~ "can write output to.  There are "
#~ "five built-in destinations:"
#~ msgstr "목적지(destination)는 클리닉이 출력을 쓸 수 있는 장소입니다. 5개의 내장 목적지가 있습니다:"

#~ msgid "``block``"
#~ msgstr "``block``"

#~ msgid ""
#~ "The default destination: printed in the"
#~ " output section of the current Clinic"
#~ " block."
#~ msgstr "기본 목적지: 현재 클리닉 블록의 출력 섹션에 인쇄됩니다."

#~ msgid "``buffer``"
#~ msgstr "``buffer``"

#~ msgid ""
#~ "A text buffer where you can save"
#~ " text for later.  Text sent here "
#~ "is appended to the end of any "
#~ "existing text.  It's an error to "
#~ "have any text left in the buffer"
#~ " when Clinic finishes processing a "
#~ "file."
#~ msgstr ""
#~ "나중을 위해 텍스트를 저장할 수 있는 텍스트 버퍼."
#~ " 여기로 전송된 텍스트는 기존 텍스트의 끝에 추가됩니다."
#~ " 클리닉이 파일 처리를 완료할 때 버퍼에 텍스트가 "
#~ "남아 있으면 에러입니다."

#~ msgid "``file``"
#~ msgstr "``file``"

#~ msgid ""
#~ "A separate \"clinic file\" that will "
#~ "be created automatically by Clinic. The"
#~ " filename chosen for the file is "
#~ "``{basename}.clinic{extension}``, where ``basename`` "
#~ "and ``extension`` were assigned the "
#~ "output from ``os.path.splitext()`` run on "
#~ "the current file.  (Example: the "
#~ "``file`` destination for ``_pickle.c`` would"
#~ " be written to ``_pickle.clinic.c``.)"
#~ msgstr ""
#~ "클리닉이 자동으로 만들 별도의 \"클리닉 파일\"입니다. "
#~ "파일에 대해 선택한 파일명은 "
#~ "``{basename}.clinic{extension}``\\입니다. 여기서 ``basename``\\과"
#~ " ``extension``\\에는 현재 파일에 대해 실행되는 "
#~ "``os.path.splitext()``\\의 출력이 대입되었습니다. (예: "
#~ "``_pickle.c``\\의 ``file`` 목적지는 "
#~ "``_pickle.clinic.c``\\에 기록됩니다.)"

#~ msgid ""
#~ "**Important: When using a** ``file`` "
#~ "**destination, you** *must check in* "
#~ "**the generated file!**"
#~ msgstr "**중요:** ``file`` **목적지를 사용할 때, 생성된 파일을** *반드시 체크인하는* **것이 중요합니다!**"

#~ msgid "``two-pass``"
#~ msgstr "``two-pass``"

#~ msgid ""
#~ "A buffer like ``buffer``.  However, a"
#~ " two-pass buffer can only be "
#~ "dumped once, and it prints out all"
#~ " text sent to it during all "
#~ "processing, even from Clinic blocks "
#~ "*after* the dumping point."
#~ msgstr ""
#~ "``buffer``\\와 같은 버퍼. 그러나, 2 패스 버퍼는"
#~ " 한 번만 덤프 할 수 있으며, 모든 처리"
#~ " 중에 전송된 모든 텍스트를 인쇄합니다, 클리닉에서 덤프"
#~ " 지점 *이후의* 클리닉 블록에서 온 것마저도."

#~ msgid "``suppress``"
#~ msgstr "``suppress``"

#~ msgid "The text is suppressed—thrown away."
#~ msgstr "텍스트가 표시되지 않고 버려집니다."

#~ msgid "Clinic defines five new directives that let you reconfigure its output."
#~ msgstr "클리닉은 출력을 재구성 할 수 있는 5개의 새로운 지시문을 정의합니다."

#~ msgid "The first new directive is ``dump``:"
#~ msgstr "첫 번째 새 지시문은 ``dump``\\입니다:"

#~ msgid ""
#~ "This dumps the current contents of "
#~ "the named destination into the output"
#~ " of the current block, and empties"
#~ " it.  This only works with ``buffer``"
#~ " and ``two-pass`` destinations."
#~ msgstr ""
#~ "이것은 명명된 목적지의 현재 내용을 현재 블록의 "
#~ "출력으로 덤프하고, 목적지를 비웁니다. 이것은 ``buffer``\\와"
#~ " ``two-pass`` 목적지에서만 작동합니다."

#~ msgid ""
#~ "The second new directive is ``output``."
#~ "  The most basic form of ``output``"
#~ " is like this:"
#~ msgstr "두 번째 새 지시문은 ``output``\\입니다. ``output``\\의 가장 기본적인 형태는 다음과 같습니다:"

#~ msgid ""
#~ "This tells Clinic to output *field* "
#~ "to *destination*.  ``output`` also supports"
#~ " a special meta-destination, called "
#~ "``everything``, which tells Clinic to "
#~ "output *all* fields to that "
#~ "*destination*."
#~ msgstr ""
#~ "이것은 클리닉에 *field*\\를 *destination*\\으로 출력하도록"
#~ " 지시합니다. ``output``\\은 ``everything``\\이라는 특수 "
#~ "메타 목적지를 지원합니다. 이 메타 목적지는 클리닉에 "
#~ "*모든* 필드를 해당 *목적지*\\로 출력하도록 지시합니다."

#~ msgid "``output`` has a number of other functions:"
#~ msgstr "``output``\\에는 여러 가지 다른 함수가 있습니다:"

#~ msgid ""
#~ "``output push`` and ``output pop`` allow"
#~ " you to push and pop configurations"
#~ " on an internal configuration stack, "
#~ "so that you can temporarily modify "
#~ "the output configuration, then easily "
#~ "restore the previous configuration.  Simply"
#~ " push before your change to save "
#~ "the current configuration, then pop when"
#~ " you wish to restore the previous "
#~ "configuration."
#~ msgstr ""
#~ "``output push``\\와 ``output pop``\\을 사용하면 "
#~ "내부 구성 스택에 구성을 푸시하고 팝할 수 있어서,"
#~ " 출력 구성을 일시적으로 수정한 다음, 이전 구성을"
#~ " 쉽게 복원 할 수 있습니다. 변경하기 전에 "
#~ "푸시해서 현재 구성을 저장한 다음, 이전 구성을 "
#~ "복원하기 원할 때 팝 합니다."

#~ msgid ""
#~ "``output preset`` sets Clinic's output "
#~ "to one of several built-in preset"
#~ " configurations, as follows:"
#~ msgstr "``output preset``\\은 클리닉의 출력을 다음과 같은 여러 내장 사전 설정 구성 중 하나로 설정합니다:"

#~ msgid ""
#~ "Clinic's original starting configuration.  "
#~ "Writes everything immediately after the "
#~ "input block."
#~ msgstr "클리닉의 원래 시작 구성. 입력 블록 바로 뒤에 모든 것을 씁니다."

#~ msgid ""
#~ "Suppress the ``parser_prototype`` and "
#~ "``docstring_prototype``, write everything else "
#~ "to ``block``."
#~ msgstr ""
#~ "``parser_prototype``\\과 ``docstring_prototype``\\을 억제하고,"
#~ " 나머지는 모두 ``block``\\에 씁니다."

#~ msgid ""
#~ "Designed to write everything to the "
#~ "\"clinic file\" that it can. You "
#~ "then ``#include`` this file near the "
#~ "top of your file. You may need "
#~ "to rearrange your file to make "
#~ "this work, though usually this just "
#~ "means creating forward declarations for "
#~ "various ``typedef`` and ``PyTypeObject`` "
#~ "definitions."
#~ msgstr ""
#~ "가능한 모든 것을 \"클리닉 파일\"에 기록하도록 "
#~ "설계되었습니다. 그러면 여러분은 파일 상단 근처에서 이 "
#~ "파일을 ``#include`` 합니다. 이것이 작동하려면 파일을 "
#~ "다시 재배치해야 할 수 있습니다, 일반적으로 이것은 "
#~ "단지 다양한 ``typedef``\\와 ``PyTypeObject`` 정의에 "
#~ "대한 전방 선언을 만드는 것을 의미하지만."

#~ msgid ""
#~ "Suppress the ``parser_prototype`` and "
#~ "``docstring_prototype``, write the "
#~ "``impl_definition`` to ``block``, and write"
#~ " everything else to ``file``."
#~ msgstr ""
#~ "``parser_prototype``\\과 ``docstring_prototype``\\을 억제하고,"
#~ " ``impl_definition``\\을 ``block``\\에 쓰고 나머지는 "
#~ "모두 ``file``\\에 씁니다."

#~ msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
#~ msgstr "기본 파일명은 ``\"{dirname}/clinic/{basename}.h\"``\\입니다."

#~ msgid ""
#~ "Save up most of the output from"
#~ " Clinic, to be written into your "
#~ "file near the end.  For Python "
#~ "files implementing modules or builtin "
#~ "types, it's recommended that you dump"
#~ " the buffer just above the static "
#~ "structures for your module or builtin"
#~ " type; these are normally very near"
#~ " the end.  Using ``buffer`` may "
#~ "require even more editing than ``file``,"
#~ " if your file has static "
#~ "``PyMethodDef`` arrays defined in the "
#~ "middle of the file."
#~ msgstr ""
#~ "클리닉의 출력 대부분을 저장하여, 마지막에 파일에 기록합니다."
#~ " 모듈이나 내장형을 구현하는 파이썬 파일의 경우, "
#~ "모듈이나 내장형의 정적 구조 바로 위에 버퍼를 "
#~ "덤프하는 것이 좋습니다; 이것들은 일반적으로 거의 끝부분에"
#~ " 있습니다. 파일 중간에 정의된 정적 ``PyMethodDef``"
#~ " 배열이 있으면, ``buffer``\\를 사용하면 ``file``\\보다"
#~ " 더 많은 편집이 필요할 수 있습니다."

#~ msgid ""
#~ "Suppress the ``parser_prototype``, "
#~ "``impl_prototype``, and ``docstring_prototype``, "
#~ "write the ``impl_definition`` to ``block``,"
#~ " and write everything else to "
#~ "``file``."
#~ msgstr ""
#~ "``parser_prototype``, ``impl_prototype`` 및 "
#~ "``docstring_prototype``\\을 억제하고, ``impl_definition``\\을"
#~ " ``block``\\에 쓰고, 나머지는 모두 ``file``\\에 "
#~ "씁니다."

#~ msgid ""
#~ "Similar to the ``buffer`` preset, but"
#~ " writes forward declarations to the "
#~ "``two-pass`` buffer, and definitions to "
#~ "the ``buffer``. This is similar to "
#~ "the ``buffer`` preset, but may require"
#~ " less editing than ``buffer``.  Dump "
#~ "the ``two-pass`` buffer near the "
#~ "top of your file, and dump the "
#~ "``buffer`` near the end just like "
#~ "you would when using the ``buffer`` "
#~ "preset."
#~ msgstr ""
#~ "``buffer`` 사전 설정과 유사하지만, 전방 선언을 "
#~ "``two-pass`` 버퍼에 쓰고, 정의를 ``buffer``\\에 "
#~ "씁니다. 이것은 ``buffer`` 사전 설정과 유사하지만, "
#~ "``buffer``\\보다 편집이 덜 필요할 수 있습니다. "
#~ "파일 상단 근처에 ``two-pass`` 버퍼를 덤프하고,"
#~ " ``buffer`` 사전 설정을 사용할 때처럼 끝 "
#~ "근처에 ``buffer``\\를 덤프하십시오."

#~ msgid ""
#~ "Suppresses the ``impl_prototype``, write the"
#~ " ``impl_definition`` to ``block``, write "
#~ "``docstring_prototype``, ``methoddef_define``, and "
#~ "``parser_prototype`` to ``two-pass``, write"
#~ " everything else to ``buffer``."
#~ msgstr ""
#~ "``impl_prototype``\\을 억제하고, ``impl_definition``\\을 "
#~ "``block``\\에 쓰고, ``docstring_prototype``, "
#~ "``methoddef_define`` 및 ``parser_prototype``\\을 "
#~ "``two-pass``\\에 쓰고, 나머지는 모두 ``buffer``\\에"
#~ " 씁니다."

#~ msgid "``partial-buffer``"
#~ msgstr "``partial-buffer``"

#~ msgid ""
#~ "Similar to the ``buffer`` preset, but"
#~ " writes more things to ``block``, "
#~ "only writing the really big chunks "
#~ "of generated code to ``buffer``. This"
#~ " avoids the definition-before-use "
#~ "problem of ``buffer`` completely, at the"
#~ " small cost of having slightly more"
#~ " stuff in the block's output. Dump"
#~ " the ``buffer`` near the end, just"
#~ " like you would when using the "
#~ "``buffer`` preset."
#~ msgstr ""
#~ "``buffer`` 사전 설정과 유사하지만, ``block``\\에 더"
#~ " 많은 것을 쓰고, 생성된 코드의 정말 큰 "
#~ "덩어리만 ``buffer``\\에 씁니다. 이것은 블록의 출력에 "
#~ "약간 더 많은 것을 갖는 적은 비용으로, "
#~ "``buffer``\\의 사용 전 정의 문제를 완전히 "
#~ "피합니다. ``buffer`` 사전 설정을 사용할 때처럼, "
#~ "끝부분에 ``buffer``\\를 덤프하십시오."

#~ msgid ""
#~ "Suppresses the ``impl_prototype``, write the"
#~ " ``docstring_definition`` and ``parser_definition`` "
#~ "to ``buffer``, write everything else to"
#~ " ``block``."
#~ msgstr ""
#~ "``impl_prototype``\\을 억제하고, ``docstring_definition``\\과"
#~ " ``parser_definition``\\을 ``buffer``\\에 쓰고, 나머지는"
#~ " 모두 ``block``\\에 씁니다."

#~ msgid "The third new directive is ``destination``:"
#~ msgstr "세 번째 새 지시문은 ``destination``\\입니다:"

#~ msgid "This performs an operation on the destination named ``name``."
#~ msgstr "``name``\\이라는 목적지에서 작업을 수행합니다."

#~ msgid "There are two defined subcommands: ``new`` and ``clear``."
#~ msgstr "두 개의 정의된 부속 명령이 있습니다: ``new``\\와 ``clear``."

#~ msgid "The ``new`` subcommand works like this:"
#~ msgstr "``new`` 부속 명령은 다음과 같이 작동합니다:"

#~ msgid ""
#~ "This creates a new destination with "
#~ "name ``<name>`` and type ``<type>``."
#~ msgstr "이렇게 하면 이름이 ``<name>``\\이고 형이 ``<type>``\\인 새 목적지가 만들어집니다."

#~ msgid "There are five destination types:"
#~ msgstr "다음과 같은 5가지 목적지 형이 있습니다:"

#~ msgid "Throws the text away."
#~ msgstr "텍스트를 버립니다."

#~ msgid ""
#~ "Writes the text to the current "
#~ "block.  This is what Clinic originally"
#~ " did."
#~ msgstr "현재 블록에 텍스트를 씁니다. 이것이 클리닉이 원래 한 일입니다."

#~ msgid "A simple text buffer, like the \"buffer\" builtin destination above."
#~ msgstr "위의 \"buffer\" 내장 목적지와 같은, 간단한 텍스트 버퍼."

#~ msgid ""
#~ "A text file.  The file destination "
#~ "takes an extra argument, a template "
#~ "to use for building the filename, "
#~ "like so:"
#~ msgstr "텍스트 파일. 파일 목적지는 다음과 같이 파일명을 빌드하는 데 사용할 템플릿인 추가 인자를 취합니다:"

#~ msgid "destination <name> new <type> <file_template>"
#~ msgstr "destination <name> new <type> <file_template>"

#~ msgid ""
#~ "The template can use three strings "
#~ "internally that will be replaced by "
#~ "bits of the filename:"
#~ msgstr "템플릿은 내부적으로 파일명의 일부로 대체되는 세 개의 문자열을 사용할 수 있습니다:"

#~ msgid "{path}"
#~ msgstr "{path}"

#~ msgid "The full path to the file, including directory and full filename."
#~ msgstr "디렉터리와 전체 파일명을 포함하는, 파일의 전체 경로."

#~ msgid "{dirname}"
#~ msgstr "{dirname}"

#~ msgid "The name of the directory the file is in."
#~ msgstr "파일이 있는 디렉터리의 이름."

#~ msgid "{basename}"
#~ msgstr "{basename}"

#~ msgid "Just the name of the file, not including the directory."
#~ msgstr "디렉터리를 제외한, 파일의 이름."

#~ msgid "{basename_root}"
#~ msgstr "{basename_root}"

#~ msgid ""
#~ "Basename with the extension clipped off"
#~ " (everything up to but not including"
#~ " the last '.')."
#~ msgstr "확장자가 잘린 basename (마지막 '.'을 포함하지 않는 모든 것)."

#~ msgid "{basename_extension}"
#~ msgstr "{basename_extension}"

#~ msgid ""
#~ "The last '.' and everything after "
#~ "it.  If the basename does not "
#~ "contain a period, this will be the"
#~ " empty string."
#~ msgstr "마지막 '.' 그리고 그 이후의 모든 것. basename에 마침표가 포함되어 있지 않으면, 빈 문자열이 됩니다."

#~ msgid ""
#~ "If there are no periods in the "
#~ "filename, {basename} and {filename} are "
#~ "the same, and {extension} is empty.  "
#~ "\"{basename}{extension}\" is always exactly "
#~ "the same as \"{filename}\".\""
#~ msgstr ""
#~ "파일명에 마침표가 없으면, {basename}과 {filename}은 "
#~ "같고, {extension}은 비어 있습니다.\"{basename}{extension}\"은"
#~ " 항상 \"{filename}\".\"과 정확히 같습니다."

#~ msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
#~ msgstr "위의 \"two-pass\" 내장 목적지와 같은, 2 패스 버퍼."

#~ msgid "The ``clear`` subcommand works like this:"
#~ msgstr "``clear`` 부속 명령은 다음과 같이 작동합니다:"

#~ msgid ""
#~ "It removes all the accumulated text "
#~ "up to this point in the "
#~ "destination. (I don't know what you'd"
#~ " need this for, but I thought "
#~ "maybe it'd be useful while someone's "
#~ "experimenting.)"
#~ msgstr ""
#~ "목적지에서 이 지점까지 누적된 모든 텍스트를 제거합니다."
#~ " (이것이 무엇에 필요한지 모르겠지만, 누군가가 실험하는 "
#~ "동안 유용하리라 생각했습니다.)"

#~ msgid "The fourth new directive is ``set``:"
#~ msgstr "네 번째 새 지시문은 ``set``\\입니다:"

#~ msgid ""
#~ "``set`` lets you set two internal "
#~ "variables in Clinic. ``line_prefix`` is "
#~ "a string that will be prepended to"
#~ " every line of Clinic's output; "
#~ "``line_suffix`` is a string that will"
#~ " be appended to every line of "
#~ "Clinic's output."
#~ msgstr ""
#~ "``set``\\을 사용하면 클리닉에서 두 개의 내부 변수를"
#~ " 설정할 수 있습니다. ``line_prefix``\\는 클리닉 "
#~ "출력의 모든 줄 앞에 추가되는 문자열입니다; "
#~ "``line_suffix``\\는 클리닉 출력의 모든 줄에 뒤에 "
#~ "추가되는 문자열입니다."

#~ msgid "Both of these support two format strings:"
#~ msgstr "둘 다 두 가지 포맷 문자열을 지원합니다:"

#~ msgid "``{block comment start}``"
#~ msgstr "``{block comment start}``"

#~ msgid ""
#~ "Turns into the string ``/*``, the "
#~ "start-comment text sequence for C "
#~ "files."
#~ msgstr "C 파일의 시작 주석 텍스트 시퀀스인, ``/*`` 문자열로 바뀝니다."

#~ msgid "``{block comment end}``"
#~ msgstr "``{block comment end}``"

#~ msgid ""
#~ "Turns into the string ``*/``, the "
#~ "end-comment text sequence for C "
#~ "files."
#~ msgstr "C 파일의 종료 주석 텍스트 시퀀스인 ``*/`` 문자열로 바뀝니다."

#~ msgid ""
#~ "The final new directive is one you"
#~ " shouldn't need to use directly, "
#~ "called ``preserve``:"
#~ msgstr "마지막 새 지시문은 ``preserve``\\라고 하는 여러분이 직접 사용할 필요가 없는 것입니다:"

#~ msgid ""
#~ "This tells Clinic that the current "
#~ "contents of the output should be "
#~ "kept, unmodified. This is used "
#~ "internally by Clinic when dumping output"
#~ " into ``file`` files; wrapping it in"
#~ " a Clinic block lets Clinic use "
#~ "its existing checksum functionality to "
#~ "ensure the file was not modified "
#~ "by hand before it gets overwritten."
#~ msgstr ""
#~ "이것은 출력의 현재 내용이 수정되지 않고 유지되어야 "
#~ "함을 클리닉에 알려줍니다. 이는 ``file`` 파일로 출력을"
#~ " 덤프할 때 클리닉에서 내부적으로 사용됩니다; 클리닉 "
#~ "블록에서 래핑하면 클리닉이 기존 체크섬 기능을 사용하여 "
#~ "파일을 덮어쓰기 전에 수동으로 수정하지 않았는지 확인할 "
#~ "수 있습니다."

#~ msgid "The #ifdef trick"
#~ msgstr "#ifdef 트릭"

#~ msgid ""
#~ "If you're converting a function that "
#~ "isn't available on all platforms, "
#~ "there's a trick you can use to "
#~ "make life a little easier.  The "
#~ "existing code probably looks like this::"
#~ msgstr ""
#~ "모든 플랫폼에서 사용할 수 없는 함수를 변환한다면, "
#~ "좀 더 쉽게 만드는 데 사용할 수 있는 "
#~ "트릭이 있습니다. 기존 코드는 아마도 이럴 겁니다::"

#~ msgid ""
#~ "And then in the ``PyMethodDef`` "
#~ "structure at the bottom the existing "
#~ "code will have:"
#~ msgstr "그런 다음 하단의 ``PyMethodDef`` 구조체에서 기존 코드는 다음과 같습니다:"

#~ msgid ""
#~ "In this scenario, you should enclose "
#~ "the body of your impl function "
#~ "inside the ``#ifdef``, like so::"
#~ msgstr "이 시나리오에서는, 다음과 같이 ``#ifdef`` 안에 impl 함수의 본문을 묶어야 합니다::"

#~ msgid ""
#~ "Then, remove those three lines from "
#~ "the ``PyMethodDef`` structure, replacing them"
#~ " with the macro Argument Clinic "
#~ "generated:"
#~ msgstr "그런 다음, ``PyMethodDef`` 구조체에서 앞의 세 줄을 제거하고 인자 클리닉이 생성한 매크로로 바꿉니다:"

#~ msgid ""
#~ "(You can find the real name for"
#~ " this macro inside the generated "
#~ "code. Or you can calculate it "
#~ "yourself: it's the name of your "
#~ "function as defined on the first "
#~ "line of your block, but with "
#~ "periods changed to underscores, uppercased,"
#~ " and ``\"_METHODDEF\"`` added to the "
#~ "end.)"
#~ msgstr ""
#~ "(생성된 코드 내에서 이 매크로의 실제 이름을 찾을"
#~ " 수 있습니다. 또는 직접 계산할 수 있습니다: "
#~ "블록의 첫 번째 줄에 정의된 함수 이름이지만, "
#~ "마침표는 밑줄로 변경되고, 대문자로 변경되고, "
#~ "``\"_METHODDEF\"``\\를 끝에 추가합니다.)"

#~ msgid ""
#~ "Perhaps you're wondering: what if "
#~ "``HAVE_FUNCTIONNAME`` isn't defined? The "
#~ "``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be "
#~ "defined either!"
#~ msgstr ""
#~ "아마도 여러분은 궁금할 겁니다: ``HAVE_FUNCTIONNAME``\\이 "
#~ "정의되지 않으면? ``MODULE_FUNCTIONNAME_METHODDEF`` 매크로도 "
#~ "정의되지 않습니다!"

#~ msgid ""
#~ "Here's where Argument Clinic gets very"
#~ " clever.  It actually detects that "
#~ "the Argument Clinic block might be "
#~ "deactivated by the ``#ifdef``.  When "
#~ "that happens, it generates a little "
#~ "extra code that looks like this::"
#~ msgstr ""
#~ "여기가 인자 클리닉이 매우 영리해지는 곳입니다. 실제로 "
#~ "인자 클리닉 블록이 ``#ifdef``\\에 의해 비활성화될 "
#~ "수 있음을 감지합니다. 이 경우, 다음과 같은 "
#~ "약간의 추가 코드를 생성합니다::"

#~ msgid ""
#~ "That means the macro always works.  "
#~ "If the function is defined, this "
#~ "turns into the correct structure, "
#~ "including the trailing comma.  If the"
#~ " function is undefined, this turns "
#~ "into nothing."
#~ msgstr ""
#~ "이는 매크로가 항상 작동함을 의미합니다. 함수가 정의되면,"
#~ " 후행 쉼표를 포함하여 올바른 구조로 바뀝니다. 함수가"
#~ " 정의되어 있지 않으면, 아무것도 아니게 됩니다."

#~ msgid ""
#~ "However, this causes one ticklish "
#~ "problem: where should Argument Clinic "
#~ "put this extra code when using the"
#~ " \"block\" output preset?  It can't "
#~ "go in the output block, because "
#~ "that could be deactivated by the "
#~ "``#ifdef``.  (That's the whole point!)"
#~ msgstr ""
#~ "그러나 이것은 한 가지 귀찮은 문제를 일으킵니다: "
#~ "인자 클리닉은 \"block\" 출력 사전 설정을 사용할"
#~ " 때 이 추가 코드를 어디에 넣어야 할까요? "
#~ "``#ifdef``\\에 의해 비활성화될 수 있기 때문에, "
#~ "출력 블록에 들어갈 수 없습니다. (그게 요점입니다!)"

#~ msgid ""
#~ "In this situation, Argument Clinic "
#~ "writes the extra code to the "
#~ "\"buffer\" destination. This may mean "
#~ "that you get a complaint from "
#~ "Argument Clinic:"
#~ msgstr "이 상황에서, 인자 클리닉은 \"버퍼\" 목적지에 추가 코드를 작성합니다. 이는 인자 클리닉이 불평함을 의미 할 수 있습니다:"

#~ msgid ""
#~ "When this happens, just open your "
#~ "file, find the ``dump buffer`` block "
#~ "that Argument Clinic added to your "
#~ "file (it'll be at the very "
#~ "bottom), then move it above the "
#~ "``PyMethodDef`` structure where that macro "
#~ "is used."
#~ msgstr ""
#~ "이 경우, 파일을 열고, 인자 클리닉이 파일에 "
#~ "추가한 ``dump buffer`` 블록(맨 아래에 있습니다)을 "
#~ "찾은 다음, 해당 매크로가 사용되는 ``PyMethodDef`` "
#~ "구조체 위로 옮깁니다."

#~ msgid "Using Argument Clinic in Python files"
#~ msgstr "파이썬 파일에서 인자 클리닉 사용하기"

#~ msgid ""
#~ "It's actually possible to use Argument"
#~ " Clinic to preprocess Python files. "
#~ "There's no point to using Argument "
#~ "Clinic blocks, of course, as the "
#~ "output wouldn't make any sense to "
#~ "the Python interpreter.  But using "
#~ "Argument Clinic to run Python blocks "
#~ "lets you use Python as a Python"
#~ " preprocessor!"
#~ msgstr ""
#~ "인자 클리닉을 사용하여 파이썬 파일을 전처리하는 것이 "
#~ "실제로 가능합니다. 물론 인자 클리닉 블록을 사용하는 "
#~ "것은 의미가 없습니다. 출력이 파이썬 인터프리터에게 의미가"
#~ " 없기 때문입니다. 하지만 인자 클리닉을 사용하여 파이썬"
#~ " 블록을 실행하면 파이썬을 파이썬 전처리기로 사용할 수"
#~ " 있습니다!"

#~ msgid ""
#~ "Since Python comments are different from"
#~ " C comments, Argument Clinic blocks "
#~ "embedded in Python files look slightly"
#~ " different.  They look like this:"
#~ msgstr "파이썬 주석은 C 주석과 다르기 때문에, 파이썬 파일에 포함된 인자 클리닉 블록은 약간 다르게 보입니다. 이런 식입니다:"

