# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "정규식 HOWTO"

#: ../../howto/regex.rst
msgid "Author"
msgstr "저자"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rst:-1
msgid "Abstract"
msgstr "요약"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in"
" Python with the :mod:`re` module.  It provides a gentler introduction "
"than the corresponding section in the Library Reference."
msgstr ""
"이 설명서는 파이썬에서 :mod:`re` 모듈로 정규식을 사용하는 방법을 소개하는 입문서입니다. 라이브러리 레퍼런스의 해당 절보다 "
"더 부드러운 소개를 제공합니다."

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "소개"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded "
"inside Python and made available through the :mod:`re` module. Using this"
" little language, you specify the rules for the set of possible strings "
"that you want to match; this set might contain English sentences, or "
"e-mail addresses, or TeX commands, or anything you like.  You can then "
"ask questions such as \"Does this string match the pattern?\", or \"Is "
"there a match for the pattern anywhere in this string?\".  You can also "
"use REs to modify a string or to split it apart in various ways."
msgstr ""
"정규식(RE, regexes 또는 regex 패턴이라고 불립니다)은 본질적으로 파이썬에 내장된 매우 작고 고도로 특수화된 프로그래밍"
" 언어이며, :mod:`re` 모듈을 통해 사용할 수 있습니다. 이 작은 언어를 사용하여, 일치시키려는 가능한 문자열 집합에 대한 "
"규칙을 지정합니다; 이 집합은 영어 문장, 전자 메일 주소, TeX 명령 또는 원하는 어떤 것이건 포함 할 수 있습니다. 그런 다음"
" \"이 문자열이 패턴과 일치합니까?\", 또는 \"이 문자열의 어느 부분에 패턴과 일치하는 것이 있습니까?\"와 같은 질문을 할 "
"수 있습니다. 또한 RE를 사용하여 문자열을 수정하거나 여러 방법으로 분할할 수 있습니다."

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which"
" are then executed by a matching engine written in C.  For advanced use, "
"it may be necessary to pay careful attention to how the engine will "
"execute a given RE, and write the RE in a certain way in order to produce"
" bytecode that runs faster. Optimization isn't covered in this document, "
"because it requires that you have a good understanding of the matching "
"engine's internals."
msgstr ""
"정규식 패턴은 일련의 바이트 코드로 컴파일된 다음 C로 작성된 일치 엔진에 의해 실행됩니다. 고급 사용을 위해서는, 엔진이 지정된 "
"RE를 실행하는 방법에 주의를 기울이고, 더 빠르게 실행되는 바이트 코드를 생성하기 위해 특정한 방법으로 RE를 작성하는 것이 "
"필요할 수 있습니다. 최적화는 일치 엔진의 내부를 잘 이해하고 있어야 하므로 이 설명서에서 다루지 않습니다."

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so "
"not all possible string processing tasks can be done using regular "
"expressions.  There are also tasks that *can* be done with regular "
"expressions, but the expressions turn out to be very complicated.  In "
"these cases, you may be better off writing Python code to do the "
"processing; while Python code will be slower than an elaborate regular "
"expression, it will also probably be more understandable."
msgstr ""
"정규식 언어는 비교적 작고 제한적이므로, 정규식을 사용하여 가능한 모든 문자열 처리 작업을 수행할 수 있는 것은 아닙니다. "
"정규식으로 수행할 *수*\\는 있지만, 표현이 아주 복잡해지는 작업도 있습니다. 이럴 때, 처리하기 위한 파이썬 코드를 작성하는 "
"것이 더 나을 수 있습니다; 파이썬 코드는 정교한 정규식보다 느리겠지만, 아마도 더 이해하기 쉬울 겁니다."

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "단순한 패턴"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions."
"  Since regular expressions are used to operate on strings, we'll begin "
"with the most common task: matching characters."
msgstr ""
"우리는 가능한 가장 단순한 정규식에 대해 배우는 것으로 시작합니다. 정규식은 문자열에 대한 연산에 사용되므로, 가장 일반적인 "
"작업으로 시작하겠습니다: 문자 일치."

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you "
"can refer to almost any textbook on writing compilers."
msgstr ""
"정규식의 기초가 되는 컴퓨터 과학(결정적인 혹은 비결정적인 유한 오토마타)에 대한 자세한 설명은, 컴파일러 작성에 관한 거의 모든 "
"교과서를 참조 할 수 있습니다."

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "문자 일치"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, "
"the regular expression ``test`` will match the string ``test`` exactly.  "
"(You can enable a case-insensitive mode that would let this RE match "
"``Test`` or ``TEST`` as well; more about this later.)"
msgstr ""
"대부분 글자와 문자는 단순히 자신과 일치합니다. 예를 들어, 정규식 ``test``\\는 문자열 ``test``\\와 정확히 "
"일치합니다. (이 RE가 ``Test``\\나 ``TEST``\\와 일치하도록 대/소문자를 구분하지 않는 모드를 활성화할 수 "
"있습니다; 나중에 자세히 설명합니다.)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special "
":dfn:`metacharacters`, and don't match themselves.  Instead, they signal "
"that some out-of-the-ordinary thing should be matched, or they affect "
"other portions of the RE by repeating them or changing their meaning.  "
"Much of this document is devoted to discussing various metacharacters and"
" what they do."
msgstr ""
"이 규칙에는 예외가 있습니다; 일부 문자는 특수한 :dfn:`메타 문자 (metacharacters)`\\이며, 자신과 일치하지 "
"않습니다. 그 대신, 그들은 일반적이지 않은 것을 일치시켜야 한다는 신호를 보냅니다. 또는 반복하거나 의미를 바꾸어 RE의 다른 "
"부분에 영향을 줍니다. 이 설명서의 많은 부분은 다양한 메타 문자와 그 기능에 대해 논의하는데 할애하고 있습니다."

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr "다음은 메타 문자의 전체 목록입니다; 이것들의 의미는 이 HOWTO의 나머지 부분에서 논의될 것입니다."

#: ../../howto/regex.rst:79
#, python-brace-format
msgid ". ^ $ * + ? { } [ ] \\ | ( )"
msgstr ""

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used "
"for specifying a character class, which is a set of characters that you "
"wish to match.  Characters can be listed individually, or a range of "
"characters can be indicated by giving two characters and separating them "
"by a ``'-'``.  For example, ``[abc]`` will match any of the characters "
"``a``, ``b``, or ``c``; this is the same as ``[a-c]``, which uses a range"
" to express the same set of characters.  If you wanted to match only "
"lowercase letters, your RE would be ``[a-z]``."
msgstr ""
"우리가 살펴볼 첫 번째 메타 문자는 ``[``\\와 ``]``\\입니다. 일치시키려는 문자 집합인 문자 클래스를 지정하는 데 "
"사용됩니다. 문자는 개별적으로 나열되거나, 두 문자를 주고 ``'-'``\\로 구분하여 문자의 범위를 나타낼 수 있습니다. 예를 "
"들어, ``[abc]`` 는 ``a``, ``b`` 또는 ``c`` 문자와 일치합니다; 이것은 ``[a-c]``\\와 같은데, 같은"
" 문자 집합을 표현하기 위해 범위를 사용합니다. 소문자들만 일치시키려면, RE가 ``[a-z]``\\가 됩니다."

#: ../../howto/regex.rst:92
#, fuzzy
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For "
"example, ``[akm$]`` will match any of the characters ``'a'``, ``'k'``, "
"``'m'``, or ``'$'``; ``'$'`` is usually a metacharacter, but inside a "
"character class it's stripped of its special nature."
msgstr ""
"메타 문자는 클래스 내부에서는 활성화되지 않습니다. 예를 들어, ``[akm$]``\\는 ``'a'``, ``'k'``, "
"``'m'`` 또는 ``'$'`` 문자와 일치합니다; ``'$'``\\는 대개 메타 문자이지만, 문자 클래스 안에서는 특수한 특성이"
" 없어집니다."

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by "
":dfn:`complementing` the set.  This is indicated by including a ``'^'`` "
"as the first character of the class. For example, ``[^5]`` will match any"
" character except ``'5'``.  If the caret appears elsewhere in a character"
" class, it does not have special meaning. For example: ``[5^]`` will "
"match either a ``'5'`` or a ``'^'``."
msgstr ""
":dfn:`여집합 (complement set)`\\을 사용해서 클래스에 나열되지 않은 문자를 일치시킬 수 있습니다. 이것은 "
"클래스의 첫 번째 문자로 ``'^'``\\를 포함하는 것으로 나타냅니다. 예를 들어, ``[^5]`` 는 ``'5'``\\를 제외한"
" 모든 문자와 일치합니다. 캐럿이 문자 클래스의 다른 곳에 나타나면, 특별한 의미가 없습니다. 예를 들어, ``[5^]`` 는 "
"``'5'``\\나 ``'^'``\\와 일치합니다."

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As "
"in Python string literals, the backslash can be followed by various "
"characters to signal various special sequences.  It's also used to escape"
" all the metacharacters so you can still match them in patterns; for "
"example, if you need to match a ``[`` or  ``\\``, you can precede them "
"with a backslash to remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"아마도 가장 중요한 메타 문자는 백 슬래시(``\\``)입니다. 파이썬 문자열 리터럴에서와 같이, 백 슬래시 다음에 다양한 특수 "
"시퀀스를 알리는 다양한 문자가 따라올 수 있습니다. 또한, 모든 메타 문자를 이스케이프 처리하여 패턴으로 일치시킬 수 있도록 "
"합니다. 예를 들어, ``[``\\나 ``\\``\\와 일치시켜야 할 때, 특별한 의미를 제거하기 위해 앞에 백 슬래시를 붙일 수 "
"있습니다: ``\\[``\\나 ``\\\\``."

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent "
"predefined sets of characters that are often useful, such as the set of "
"digits, the set of letters, or the set of anything that isn't whitespace."
msgstr ""
"``'\\'``\\로 시작하는 특수 시퀀스 중 일부는 숫자(digit) 집합, 글자(letter) 집합 또는 공백이 아닌 모든 것의"
" 집합과 같이 종종 유용한 미리 정의된 문자 집합을 나타냅니다."

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If "
"the regex pattern is expressed in bytes, this is equivalent to the class "
"``[a-zA-Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match "
"all the characters marked as letters in the Unicode database provided by "
"the :mod:`unicodedata` module.  You can use the more restricted "
"definition of ``\\w`` in a string pattern by supplying the "
":const:`re.ASCII` flag when compiling the regular expression."
msgstr ""
"예를 들어 보겠습니다: ``\\w``\\는 모든 영숫자(alphanumeric character)와 일치합니다. 정규식 패턴을 "
"바이트열로 표현하면, 이것은 ``[a-zA-Z0-9_]`` 클래스와 동등합니다. 정규식 패턴이 문자열이면, ``\\w``\\는 "
":mod:`unicodedata` 모듈이 제공하는 유니코드 데이터베이스에서 글자(letter)로 표시된 모든 문자를 일치시킵니다. "
"정규식을 컴파일할 때 :const:`re.ASCII` 플래그를 제공하여 문자열 패턴에서 ``\\w``\\의 더 제한된 정의를 사용할"
" 수 있습니다."

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete "
"list of sequences and expanded class definitions for Unicode string "
"patterns, see the last part of :ref:`Regular Expression Syntax <re-"
"syntax>` in the Standard Library reference.  In general, the Unicode "
"versions match any character that's in the appropriate category in the "
"Unicode database."
msgstr ""
"다음 특수 시퀀스 목록은 완전하지 않습니다. 유니코드 문자열 패턴에 대한 시퀀스와 확장 클래스 정의의 전체 목록은, 표준 라이브러리"
" 레퍼런스에서 :ref:`정규식 문법 <re-syntax>`\\의 마지막 부분을 참조하십시오. 일반적으로, 유니코드 버전은 유니코드"
" 데이터베이스의 적절한 범주에 있는 모든 문자와 일치합니다."

#: ../../howto/regex.rst:130
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "모든 십진 숫자와 일치합니다; 이것은 클래스 ``[0-9]``\\와 동등합니다."

#: ../../howto/regex.rst:133
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class "
"``[^0-9]``."
msgstr "모든 비 숫자 문자와 일치합니다; 이것은 클래스 ``[^0-9]``\\와 동등합니다."

#: ../../howto/regex.rst:136
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr "모든 공백 문자와 일치합니다; 이것은 클래스 ``[ \\t\\n\\r\\f\\v]`` 와 동등합니다."

#: ../../howto/regex.rst:140
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class "
"``[^ \\t\\n\\r\\f\\v]``."
msgstr "모든 비 공백 문자와 일치합니다; 이것은 클래스 ``[^ \\t\\n\\r\\f\\v]`` 와 동등합니다."

#: ../../howto/regex.rst:144
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class "
"``[a-zA-Z0-9_]``."
msgstr "모든 영숫자(alphanumeric character)와 일치합니다; 이것은 클래스 ``[a-zA-Z0-9_]``\\와 동등합니다."

#: ../../howto/regex.rst:148
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr "모든 비 영숫자와 일치합니다; 이것은 클래스 ``[^a-zA-Z0-9_]``\\와 동등합니다."

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace "
"character, or ``','`` or ``'.'``."
msgstr ""
"이 시퀀스들은 문자 클래스 내에 포함될 수 있습니다. 예를 들어, ``[\\s,.]`` 는 모든 공백 문자, ``','`` 또는 "
"``'.'``\\와 일치하는 문자 클래스입니다."

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode "
"(:const:`re.DOTALL`) where it will match even a newline.  ``.`` is often "
"used where you want to match \"any character\"."
msgstr ""
"이 절의 마지막 메타 문자는 ``.``\\입니다. 개행 문자를 제외한 모든 문자와 일치하며, 개행 문자와도 일치하는 대체 "
"모드(:const:`re.DOTALL`)가 있습니다. ``.`` 은 \"모든 문자\"와 일치시키려고 할 때 자주 사용됩니다."

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "반복하기"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular"
" expressions can do that isn't already possible with the methods "
"available on strings.  However, if that was the only additional "
"capability of regexes, they wouldn't be much of an advance. Another "
"capability is that you can specify that portions of the RE must be "
"repeated a certain number of times."
msgstr ""
"다양한 문자 집합을 일치시킬 수 있다는 것이 문자열에서 사용할 수 있는 메서드로 이미 가능하지 않은 것을 정규식이 수행할 수 있는 "
"첫 번째 것입니다. 그러나, 이것이 정규식의 유일한 추가 기능이라면, 그다지 진보했다고 할 수 없습니다. 또 다른 기능은 RE의 "
"일부가 특정 횟수만큼 반복되어야 한다고 지정할 수 있다는 것입니다."

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``."
"  ``*`` doesn't match the literal character ``'*'``; instead, it "
"specifies that the previous character can be matched zero or more times, "
"instead of exactly once."
msgstr ""
"우리가 살펴볼 반복을 위한 첫 번째 메타 문자는 ``*``\\입니다. ``*``\\는 리터럴 문자 ``'*'``\\와 일치하지 "
"않습니다; 대신 이전 문자를 정확히 한 번이 아닌 0번 이상 일치시킬 수 있도록 지정합니다."

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), "
"``'cat'`` (1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"예를 들어, ``ca*t``\\는 ``'ct'`` (0개의 ``'a'`` 문자), ``'cat'`` (1개의 ``'a'``), "
"``'caaat'`` (3개의 ``'a'`` 문자) 등과 일치합니다."

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later"
" portions of the pattern don't match, the matching engine will then back "
"up and try again with fewer repetitions."
msgstr ""
"``*``\\와 같은 반복은 :dfn:`탐욕스럽습니다 (greedy)`; RE를 반복할 때, 일치 엔진은 가능한 한 여러 번 "
"반복하려고 시도합니다. 패턴의 뒷부분이 일치하지 않으면, 일치 엔진은 되돌아가서 더 작은 반복으로 다시 시도합니다."

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"단계별 예제를 통해 더 명확하게 알 수 있습니다. 정규식 ``a[bcd]*b``\\를 생각해 봅시다. 이 문자는 ``'a'`` "
"문자와 일치하고, 0개 이상의 ``[bcd]`` 클래스 문자가 뒤따르고, 마지막에 ``'b'``\\로 끝납니다. 이제 이 RE를 "
"문자열 ``'abcbd'``\\와 일치시킨다고 상상해보십시오."

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "단계"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "일치된 것"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "설명"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "RE의 ``a``\\가 일치합니다."

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the "
"end of the string."
msgstr "엔진은 가능한 한 길게 ``[bcd]*``\\와 일치시키려고 문자열의 끝까지 갑니다."

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*실패*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end "
"of the string, so it fails."
msgstr "엔진은 ``b``\\를 일치하려고 시도하지만, 현재 위치가 문자열의 끝이므로 실패합니다."

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "물러서서, ``[bcd]*``\\가 하나 적은 문자와 일치합니다."

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which"
" is a ``'d'``."
msgstr "``b``\\를 다시 시도하지만, 현재 위치는 ``'d'`` 인 마지막 문자에 있습니다."

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "다시 물러서서, ``[bcd]*``\\가 ``bc``\\하고 만 일치합니다."

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr "``b``\\를 다시 시도합니다. 이번에는 현재 위치의 문자가 ``'b'``\\이므로 성공합니다."

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  "
"This demonstrates how the matching engine goes as far as it can at first,"
" and if no match is found it will then progressively back up and retry "
"the rest of the RE again and again.  It will back up until it has tried "
"zero matches for ``[bcd]*``, and if that subsequently fails, the engine "
"will conclude that the string doesn't match the RE at all."
msgstr ""
"RE의 끝에 도달했으며, ``'abcb'``\\와 일치했습니다. 이것은 일치 엔진이 처음에는 갈 수 있는 데까지 가본 다음, "
"일치하는 것이 발견되지 않으면 점진적으로 물러서고, 나머지 RE의 나머지 부분을 반복해서 다시 시도하는 것을 보여줍니다. "
"``[bcd]*``\\에 대한 일치 항목의 길이가 0이 될 때까지 물러서고, 그것마저도 실패하면, 엔진은 문자열이 RE와 전혀 "
"일치하지 않는다고 결론을 내립니다."

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more "
"times.  Pay careful attention to the difference between ``*`` and ``+``; "
"``*`` matches *zero* or more times, so whatever's being repeated may not "
"be present at all, while ``+`` requires at least *one* occurrence.  To "
"use a similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), "
"``'caaat'`` (3 ``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"또 다른 반복 메타 문자는 ``+``\\인 데, 하나 이상과 일치합니다. ``*``\\와 ``+``\\의 차이점에 주의하십시오; "
"``*``\\는 *0* 이상과 일치하므로, 반복되는 내용이 전혀 표시되지 않을 수 있습니다. 반면 ``+``\\는 적어도 "
"*1*\\번 이상 나타날 것을 요구합니다. 비슷한 예제를 사용하면, ``ca+t``\\는 ``'cat'`` (1 ``'a'``), "
"``'caaat'`` (3 ``'a'``)와 일치하지만 ``'ct'``\\와 일치하지는 않습니다."

#: ../../howto/regex.rst:233
#, fuzzy
msgid ""
"There are two more repeating operators or quantifiers.  The question mark"
" character, ``?``, matches either once or zero times; you can think of it"
" as marking something as being optional.  For example, ``home-?brew`` "
"matches either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"반복 한정자(qualifier)가 두 개 더 있습니다. 물음표 문자 ``?``\\는 한 번이나 0번 일치합니다; 무언가를 "
"선택적이라고 표시한다고 생각해도 좋습니다. 예를 들어, ``home-?brew``\\는 ``'homebrew'``\\나 "
"``'home-brew'``\\와 일치합니다."

#: ../../howto/regex.rst:238
#, fuzzy, python-brace-format
msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are "
"decimal integers.  This quantifier means there must be at least *m* "
"repetitions, and at most *n*.  For example, ``a/{1,3}b`` will match "
"``'a/b'``, ``'a//b'``, and ``'a///b'``.  It won't match ``'ab'``, which "
"has no slashes, or ``'a////b'``, which has four."
msgstr ""
"가장 복잡한 반복 한정자는 ``{m,n}``\\입니다. 여기서 *m*\\과 *n*\\은 십진수입니다. 이 한정자는 적어도 *m* "
"반복, 최대 *n* 반복이 있어야 함을 의미합니다. 예를 들어, ``a/{1,3}b``\\는 ``'a/b'``, ``'a//b'``"
" 및 ``'a///b'``\\와 일치합니다. ``'ab'``\\에는 슬래시가 없어서 일치하지 않고, ``'a////b'``\\에는 "
"4개 있어서 일치하지 않습니다."

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is "
"assumed for the missing value.  Omitting *m* is interpreted as a lower "
"limit of 0, while omitting *n* results in an upper bound of infinity."
msgstr ""
"*m*\\이나 *n*\\을 생략 할 수 있습니다; 이때, 빠진 값에 대해 합리적인 값이 가정됩니다. *m*\\을 생략하면 0 "
"하한으로 해석하는 반면, *m*\\을 생략하면 무한대의 상한을 뜻합니다."

#: ../../howto/regex.rst:248
#, python-brace-format
msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. "
"For example, ``a/{2}b`` will only match ``'a//b'``."
msgstr ""

#: ../../howto/regex.rst:251
#, fuzzy, python-brace-format
msgid ""
"Readers of a reductionist bent may notice that the three other "
"quantifiers can all be expressed using this notation.  ``{0,}`` is the "
"same as ``*``, ``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same"
" as ``?``.  It's better to use ``*``, ``+``, or ``?`` when you can, "
"simply because they're shorter and easier to read."
msgstr ""
"환원주의로 기울어진 독자는 다른 세 한정자들을 이 표기법을 사용하여 표현할 수 있음을 알아챌 수 있을 겁니다. ``{0,}``\\은"
" ``*``\\와 같고, ``{1,}``\\은 ``+``\\와 같으며, ``{0,1}``\\은 ``?``\\와 같습니다. 그럴 수 "
"있다면 ``*``, ``+`` 또는 ``?``\\를 사용하는 것이 좋은데, 더 짧고 읽기 쉽기 때문입니다."

#: ../../howto/regex.rst:259
msgid "Using Regular Expressions"
msgstr "정규식 사용하기"

#: ../../howto/regex.rst:261
msgid ""
"Now that we've looked at some simple regular expressions, how do we "
"actually use them in Python?  The :mod:`re` module provides an interface "
"to the regular expression engine, allowing you to compile REs into "
"objects and then perform matches with them."
msgstr ""
"이제 간단한 정규식을 살펴보았습니다. 실제로 파이썬에서 어떻게 사용해야 할까요? :mod:`re` 모듈은 정규식 엔진에 대한 "
"인터페이스를 제공해서, RE를 객체로 컴파일한 다음 일치를 수행 할 수 있도록 합니다."

#: ../../howto/regex.rst:268
msgid "Compiling Regular Expressions"
msgstr "정규식 컴파일하기"

#: ../../howto/regex.rst:270
msgid ""
"Regular expressions are compiled into pattern objects, which have methods"
" for various operations such as searching for pattern matches or "
"performing string substitutions. ::"
msgstr ""
"정규식은 패턴 객체로 컴파일되는데, 패턴 일치를 검색하거나 문자열 치환을 수행하는 등의 다양한 작업을 위한 메서드를 갖고 있습니다."
" ::"

#: ../../howto/regex.rst:274
msgid ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"
msgstr ""

#: ../../howto/regex.rst:279
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to "
"enable various special features and syntax variations.  We'll go over the"
" available settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile`\\은 다양한 특수 기능과 문법 변형을 가능하게 하는 선택적 *flags* 인자도 받아들입니다. "
"나중에 사용할 수 있는 설정을 살펴보도록 하겠지만, 지금은 한 가지 예 만 보겠습니다::"

#: ../../howto/regex.rst:283
msgid ">>> p = re.compile('ab*', re.IGNORECASE)"
msgstr ""

#: ../../howto/regex.rst:285
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python "
"language, and no special syntax was created for expressing them.  (There "
"are applications that don't need REs at all, so there's no need to bloat "
"the language specification by including them.) Instead, the :mod:`re` "
"module is simply a C extension module included with Python, just like the"
" :mod:`socket` or :mod:`zlib` modules."
msgstr ""
"RE는 문자열로 :func:`re.compile`\\에 전달됩니다. 정규식이 핵심 파이썬 언어의 일부가 아니고, 정규식을 표현하기 "
"위한 특수 문법이 만들어지지 않았기 때문에 RE는 문자열로 다뤄집니다. (RE를 전혀 필요로하지 않는 응용 프로그램이 있기 때문에,"
" 이를 포함해서 언어 사양을 부풀릴 필요가 없습니다.) 대신, :mod:`re` 모듈은 :mod:`socket`\\이나 "
":mod:`zlib` 모듈과 마찬가지로 파이썬에 포함된 C 확장 모듈일 뿐입니다."

#: ../../howto/regex.rst:292
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr "RE를 문자열에 넣는 것은 파이썬 언어가 더 간단하게 유지되도록 하지만, 다음 절의 주제인 한 가지 단점이 있습니다."

#: ../../howto/regex.rst:299
msgid "The Backslash Plague"
msgstr "백 슬래시 전염병"

#: ../../howto/regex.rst:301
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be"
" used without invoking their special meaning. This conflicts with "
"Python's usage of the same character for the same purpose in string "
"literals."
msgstr ""
"앞에서 언급한 것처럼, 정규식은 백 슬래시 문자(``'\\'``)를 사용하여 특수 형식을 나타내거나 특수 문자 특별한 의미를 갖지 "
"않고 사용되도록 합니다. 이것은 파이썬이 문자열 리터럴에서 같은 목적으로 같은 문자를 사용하는 것과 충돌합니다."

#: ../../howto/regex.rst:306
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the"
" program code, start with the desired string to be matched.  Next, you "
"must escape any backslashes and other metacharacters by preceding them "
"with a backslash, resulting in the string ``\\\\section``.  The resulting"
" string that must be passed to :func:`re.compile` must be "
"``\\\\section``.  However, to express this as a Python string literal, "
"both backslashes must be escaped *again*."
msgstr ""
"LaTeX 파일에서 발견되는 문자열 ``\\section``\\과 일치하는 RE를 작성한다고 가정해 봅시다. 프로그램 코드에 무엇을"
" 쓸지 알아내기 위해, 일치시키고자 하는 문자열로 시작하십시오. 그런 다음, 백 슬래시와 다른 메타 문자 앞에 백 슬래시를 붙여 "
"이스케이프 처리하면, 문자열 ``\\\\section``\\을 얻게 됩니다. :func:`re.compile`\\에 전달되어야 하는"
" 결과 문자열은 ``\\\\section``\\이어야 합니다. 그러나, 이를 파이썬 문자열 리터럴로 표현하려면, 두 개의 백 "
"슬래시를 모두 *다시* 이스케이프 처리해야 합니다."

#: ../../howto/regex.rst:315
msgid "Characters"
msgstr "문자"

#: ../../howto/regex.rst:315
msgid "Stage"
msgstr "단계"

#: ../../howto/regex.rst:317
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:317
msgid "Text string to be matched"
msgstr "일치시킬 텍스트 문자열"

#: ../../howto/regex.rst:319
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:319
msgid "Escaped backslash for :func:`re.compile`"
msgstr ":func:`re.compile`\\을 위해 이스케이프 처리된 백 슬래시"

#: ../../howto/regex.rst:321 ../../howto/regex.rst:348
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:321
msgid "Escaped backslashes for a string literal"
msgstr "문자열 리터럴을 위해 이스케이프 처리된 백 슬래시"

#: ../../howto/regex.rst:324
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` "
"as the RE string, because the regular expression must be ``\\\\``, and "
"each backslash must be expressed as ``\\\\`` inside a regular Python "
"string literal.  In REs that feature backslashes repeatedly, this leads "
"to lots of repeated backslashes and makes the resulting strings difficult"
" to understand."
msgstr ""
"즉, 리터럴 백 슬래시와 일치시키려면, RE 문자열로 ``'\\\\\\\\'``\\을 작성해야 하는데, 정규식은 "
"``\\\\``\\이어야하고, 일반 파이썬 문자열 리터럴 안에서 각 백 슬래시를 ``\\\\``\\로 표현해야 하기 때문입니다. 백"
" 슬래시를 반복적으로 사용하는 RE에서는, 수없이 반복되는 백 슬래시로 이어져, 결과 문자열을 이해하기 어렵게 만듭니다."

#: ../../howto/regex.rst:330
msgid ""
"The solution is to use Python's raw string notation for regular "
"expressions; backslashes are not handled in any special way in a string "
"literal prefixed with ``'r'``, so ``r\"\\n\"`` is a two-character string "
"containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character "
"string containing a newline. Regular expressions will often be written in"
" Python code using this raw string notation."
msgstr ""
"해결책은 정규식에 파이썬의 날 문자열 표기법을 사용하는 것입니다; 백 슬래시는 ``'r'`` 접두사가 붙은 문자열 리터럴에서 특별한"
" 방법으로 처리되지 않아서, ``r\"\\n\"``\\는 ``'\\'``\\과 ``'n'``\\을 포함하는 두 문자 문자열이지만, "
"``\"\\n\"``\\는 줄 넘김을 포함하는 한 문자 문자열입니다. 정규식은 종종 이 날 문자열 표기법을 사용하여 파이썬 코드로 "
"작성됩니다."

#: ../../howto/regex.rst:336
msgid ""
"In addition, special escape sequences that are valid in regular "
"expressions, but not valid as Python string literals, now result in a "
":exc:`DeprecationWarning` and will eventually become a "
":exc:`SyntaxError`, which means the sequences will be invalid if raw "
"string notation or escaping the backslashes isn't used."
msgstr ""
"또한, 정규식에서는 유효하지만, 파이썬 문자열 리터럴에서는 유효하지 않은 특수 이스케이프 시퀀스는 이제 "
":exc:`DeprecationWarning`\\을 발생시키고 결국에는 :exc:`SyntaxError`\\가 될 것입니다. 이는 "
"날 문자열 표기법이나 백 슬래시 이스케이핑이 사용되지 않으면 시퀀스가 유효하지 않게 됨을 뜻합니다."

#: ../../howto/regex.rst:344
msgid "Regular String"
msgstr "일반 문자열"

#: ../../howto/regex.rst:344
msgid "Raw string"
msgstr "날 문자열"

#: ../../howto/regex.rst:346
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:346
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:348
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:350
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:350
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:355
msgid "Performing Matches"
msgstr "일치 수행하기"

#: ../../howto/regex.rst:357
msgid ""
"Once you have an object representing a compiled regular expression, what "
"do you do with it?  Pattern objects have several methods and attributes. "
"Only the most significant ones will be covered here; consult the "
":mod:`re` docs for a complete listing."
msgstr ""
"일단 컴파일된 정규식을 나타내는 객체가 있으면, 이것으로 무엇을 할까요? 패턴 객체에는 여러 가지 메서드와 어트리뷰트가 있습니다. "
"가장 중요한 것만 여기서 다루어집니다; 전체 목록을 보려면 :mod:`re` 설명서를 참조하십시오."

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1065
msgid "Method/Attribute"
msgstr "메서드/어트리뷰트"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1065
msgid "Purpose"
msgstr "목적"

#: ../../howto/regex.rst:365
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:365
msgid "Determine if the RE matches at the beginning of the string."
msgstr "문자열의 시작 부분에서 RE가 일치하는지 판단합니다."

#: ../../howto/regex.rst:368
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:368
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "이 RE가 일치하는 위치를 찾으면서, 문자열을 훑습니다."

#: ../../howto/regex.rst:371
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:371
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "RE가 일치하는 모든 부분 문자열을 찾아 리스트로 반환합니다."

#: ../../howto/regex.rst:374
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:374
msgid ""
"Find all substrings where the RE matches, and returns them as an "
":term:`iterator`."
msgstr "RE가 일치하는 모든 부분 문자열을 찾아 :term:`이터레이터 <iterator>`\\로 반환합니다."

#: ../../howto/regex.rst:378
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` "
"if no match can be found.  If they're successful, a :ref:`match object "
"<match-objects>` instance is returned, containing information about the "
"match: where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match`\\와 :meth:`~re.Pattern.search`\\는 일치하는 항목이 없으면 "
"``None``\\을 반환합니다. 성공하면, :ref:`일치 객체 <match-objects>` 인스턴스가 반환되고, 일치에 대한 "
"정보가 들어 있습니다: 어디에서 시작하고 끝나는지, 일치하는 부분 문자열 등입니다."

#: ../../howto/regex.rst:383
msgid ""
"You can learn about this by interactively experimenting with the "
":mod:`re` module."
msgstr ""

#: ../../howto/regex.rst:386
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, "
"run the Python interpreter, import the :mod:`re` module, and compile a "
"RE::"
msgstr ""
"이 HOWTO는 예제에 표준 파이썬 인터프리터를 사용합니다. 먼저, 파이썬 인터프리터를 실행하고, :mod:`re` 모듈을 임포트 "
"한 다음, RE를 컴파일하십시오::"

#: ../../howto/regex.rst:389
msgid ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"
msgstr ""

#: ../../howto/regex.rst:394
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this "
"case, which will cause the interpreter to print no output.  You can "
"explicitly print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"이제, 다양한 문자열을 RE ``[a-z]+``\\와 일치시켜볼 수 있습니다. ``+``\\는 '하나 이상의 반복'을 의미하므로, "
"빈 문자열은 전혀 일치하지 않아야 합니다. 이때 :meth:`~re.Pattern.match`\\는 ``None``\\을 반환해야 "
"하며, 인터프리터는 출력을 인쇄하지 않습니다. 분명하게 하기 위해 :meth:`!match`\\의 결과를 명시적으로 인쇄 할 수 "
"있습니다. ::"

#: ../../howto/regex.rst:400
msgid ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:404
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  "
"In this case, :meth:`~re.Pattern.match` will return a :ref:`match object "
"<match-objects>`, so you should store the result in a variable for later "
"use. ::"
msgstr ""
"이제, 일치해야 하는 문자열을 시도해 봅시다, 가령 ``tempo``. 이때, :meth:`~re.Pattern.match`\\는 "
":ref:`일치 객체 <match-objects>`\\를 반환하므로, 나중에 사용할 수 있도록 결과를 변수에 저장해야 합니다. ::"

#: ../../howto/regex.rst:408
msgid ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"
msgstr ""

#: ../../howto/regex.rst:412
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information"
" about the matching string.  Match object instances also have several "
"methods and attributes; the most important ones are:"
msgstr ""
"이제 :ref:`match object <match-objects>`\\를 조회하여 일치하는 문자열에 대한 정보를 얻을 수 "
"있습니다. 일치 객체 인스턴스에는 여러 메서드와 어트리뷰트가 있습니다; 가장 중요한 것들은 다음과 같습니다:"

#: ../../howto/regex.rst:419
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:419
msgid "Return the string matched by the RE"
msgstr "RE와 일치하는 문자열을 반환합니다."

#: ../../howto/regex.rst:421
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:421
msgid "Return the starting position of the match"
msgstr "일치의 시작 위치를 반환합니다"

#: ../../howto/regex.rst:423
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:423
msgid "Return the ending position of the match"
msgstr "일치의 끝 위치를 반환합니다"

#: ../../howto/regex.rst:425
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:425
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "일치의 (시작, 끝) 위치를 포함하는 튜플을 반환합니다."

#: ../../howto/regex.rst:429
msgid "Trying these methods will soon clarify their meaning::"
msgstr "이 메서드를 실험해보면 곧 그 의미가 분명해질 것입니다::"

#: ../../howto/regex.rst:431
msgid ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"
msgstr ""

#: ../../howto/regex.rst:438
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE."
"  :meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting "
"and ending index of the match. :meth:`~re.Match.span` returns both start "
"and end indexes in a single tuple.  Since the :meth:`~re.Pattern.match` "
"method only checks if the RE matches at the start of a string, "
":meth:`!start` will always be zero.  However, the "
":meth:`~re.Pattern.search` method of patterns scans through the string, "
"so  the match may not start at zero in that case. ::"
msgstr ""
":meth:`~re.Match.group`\\은 RE에 의해 일치된 부분 문자열을 반환합니다. "
":meth:`~re.Match.start`\\와 :meth:`~re.Match.end`\\는 일치의 시작과 끝 인덱스를 반환합니다."
" :meth:`~re.Match.span`\\은 시작과 끝 인덱스를 단일 튜플로 반환합니다. "
":meth:`~re.Pattern.match` 메서드는 문자열의 시작 부분에서 RE가 일치하는지 검사하므로, "
":meth:`!start`\\는 항상 0입니다. 그러나, 패턴의 :meth:`~re.Pattern.search` 메서드는 문자열을 "
"훑기 때문에, 일치가 0에서 시작하지 않을 수 있습니다. ::"

#: ../../howto/regex.rst:446
msgid ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"
msgstr ""

#: ../../howto/regex.rst:455
msgid ""
"In actual programs, the most common style is to store the :ref:`match "
"object <match-objects>` in a variable, and then check if it was ``None``."
"  This usually looks like::"
msgstr ""
"실제 프로그램에서, 가장 일반적인 스타일은 :ref:`일치 객체 <match-objects>`\\를 변수에 저장한 다음, "
"``None``\\인지 확인하는 것입니다. 보통 이런 식입니다::"

#: ../../howto/regex.rst:459
msgid ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"
msgstr ""

#: ../../howto/regex.rst:466
msgid ""
"Two pattern methods return all of the matches for a pattern. "
":meth:`~re.Pattern.findall` returns a list of matching strings::"
msgstr ""
"두 패턴 메서드는 패턴에 대한 모든 일치를 반환합니다. :meth:`~re.Pattern.findall`\\은 일치하는 문자열 "
"리스트를 반환합니다::"

#: ../../howto/regex.rst:469
msgid ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords "
"a-leaping')\n"
"['12', '11', '10']"
msgstr ""

#: ../../howto/regex.rst:473
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in "
"this example because escape sequences in a normal \"cooked\" string "
"literal that are not recognized by Python, as opposed to regular "
"expressions, now result in a :exc:`DeprecationWarning` and will "
"eventually become a :exc:`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"이 예제에서는 리터럴을 날 문자열 리터럴로 만드는 ``r`` 접두어가 필요한데, 일반적인 \"요리된(cooked)\" 문자열 "
"리터럴에 있는, 정규식에서는 허락되지만, 파이썬에서 인식하지 못하는, 이스케이프 시퀀스가 이제 "
":exc:`DeprecationWarning`\\을 발생시키고, 결국에는 결국 :exc:`SyntaxError`\\가 될 것이기 "
"때문입니다. :ref:`the-backslash-plague`\\를 참조하십시오."

#: ../../howto/regex.rst:479
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can "
"be returned as the result.  The :meth:`~re.Pattern.finditer` method "
"returns a sequence of :ref:`match object <match-objects>` instances as an"
" :term:`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall`\\은 결과로 반환하기 전에 전체 리스트를 만들어야 합니다. "
":meth:`~re.Pattern.finditer` 메서드는 :ref:`매치 객체 <match-objects>` 인스턴스의 시퀀스를"
" :term:`이터레이터 <iterator>`\\로 반환합니다::"

#: ../../howto/regex.rst:483
msgid ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator\n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"
msgstr ""

#: ../../howto/regex.rst:495
msgid "Module-Level Functions"
msgstr "모듈 수준 함수"

#: ../../howto/regex.rst:497
msgid ""
"You don't have to create a pattern object and call its methods; the "
":mod:`re` module also provides top-level functions called "
":func:`~re.match`, :func:`~re.search`, :func:`~re.findall`, "
":func:`~re.sub`, and so forth.  These functions take the same arguments "
"as the corresponding pattern method with the RE string added as the first"
" argument, and still return either ``None`` or a :ref:`match object "
"<match-objects>` instance. ::"
msgstr ""
"패턴 객체를 생성하고 메서드를 호출해야만 하는 것은 아닙니다; :mod:`re` 모듈은 :func:`~re.match`, "
":func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` 등의 최상위 수준 함수도 "
"제공합니다. 이 함수들은 첫 번째 인자로 RE 문자열이 추가된 해당 패턴 메서드와 같은 인자를 취하고, 여전히 "
"``None``\\이나 :ref:`일치 객체 <match-objects>` 인스턴스를 반환합니다. ::"

#: ../../howto/regex.rst:504
msgid ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n"
"<re.Match object; span=(0, 5), match='From '>"
msgstr ""

#: ../../howto/regex.rst:509
msgid ""
"Under the hood, these functions simply create a pattern object for you "
"and call the appropriate method on it.  They also store the compiled "
"object in a cache, so future calls using the same RE won't need to parse "
"the pattern again and again."
msgstr ""
"내부적으로, 이 함수는 단순히 패턴 객체를 만들고 적절한 메서드를 호출합니다. 또한 컴파일된 객체를 캐시에 저장하므로, 같은 RE를"
" 사용하는 이후의 호출에서는 패턴을 반복해서 구문 분석할 필요가 없습니다."

#: ../../howto/regex.rst:514
msgid ""
"Should you use these module-level functions, or should you get the "
"pattern and call its methods yourself?  If you're accessing a regex "
"within a loop, pre-compiling it will save a few function calls. Outside "
"of loops, there's not much difference thanks to the internal cache."
msgstr ""
"이러한 모듈 수준의 함수를 사용해야 할까요, 아니면 패턴을 얻어서 메서드를 직접 호출해야 할까요? 루프 내에서 정규식에 액세스하고 "
"있다면, 사전 컴파일이 몇 번의 함수 호출을 절약할 수 있습니다. 루프 바깥에서는, 내부 캐시 덕분에 큰 차이가 없습니다."

#: ../../howto/regex.rst:522
msgid "Compilation Flags"
msgstr "컴파일 플래그"

#: ../../howto/regex.rst:526
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long"
" name such as :const:`IGNORECASE` and a short, one-letter form such as "
":const:`I`.  (If you're familiar with Perl's pattern modifiers, the one-"
"letter forms use the same letters; the short form of :const:`re.VERBOSE` "
"is :const:`re.X`, for example.) Multiple flags can be specified by "
"bitwise OR-ing them; ``re.I | re.M`` sets both the :const:`I` and "
":const:`M` flags, for example."
msgstr ""
"컴파일 플래그를 사용하면 정규식의 작동 방식을 수정할 수 있습니다. 플래그는 :mod:`re` 모듈에서 "
":const:`IGNORECASE`\\와 같은 긴 이름과 :const:`I`\\와 같은 간단한 한 글자 형식의 두 가지 이름으로 "
"사용 가능합니다. (Perl의 패턴 수정자에 익숙하다면, 한 글자 형식은 같은 글자를 사용합니다; 예를 들어, "
":const:`re.VERBOSE`\\의 짧은 형식은 :const:`re.X`\\입니다.) 다중 플래그는 비트별 OR 하여 지정할 "
"수 있습니다; 예를 들어, ``re.I | re.M``\\은 :const:`I`\\와 :const:`M` 플래그를 모두 설정합니다."

#: ../../howto/regex.rst:534
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr "다음은 사용 가능한 플래그와 각 플래그에 대한 자세한 설명입니다."

#: ../../howto/regex.rst:538
msgid "Flag"
msgstr "플래그"

#: ../../howto/regex.rst:538
msgid "Meaning"
msgstr "의미"

#: ../../howto/regex.rst:540
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:540
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match "
"only on ASCII characters with the respective property."
msgstr ""
"``\\w``, ``\\b``, ``\\s`` 및 ``\\d``\\와 같은 여러 이스케이프가 해당 속성이 있는 ASCII 문자에만 "
"일치하도록 합니다."

#: ../../howto/regex.rst:544
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:544
msgid "Make ``.`` match any character, including newlines."
msgstr "``.``\\가 개행 문자를 포함한 모든 문자와 일치하도록 합니다."

#: ../../howto/regex.rst:547
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:547
msgid "Do case-insensitive matches."
msgstr "대소 문자 구분 없는 일치를 수행합니다."

#: ../../howto/regex.rst:549
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:549
msgid "Do a locale-aware match."
msgstr "로케일을 고려하는 일치를 수행합니다."

#: ../../howto/regex.rst:551
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:551
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "다중 행 일치, ``^``\\와 ``$``\\에 영향을 줍니다."

#: ../../howto/regex.rst:554
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` ('확장' 용)"

#: ../../howto/regex.rst:554
msgid ""
"Enable verbose REs, which can be organized more cleanly and "
"understandably."
msgstr "더 명확하고 이해하기 쉽게 정리될 수 있는 상세한 RE를 활성화합니다."

#: ../../howto/regex.rst:563
msgid ""
"Perform case-insensitive matching; character class and literal strings "
"will match letters by ignoring case.  For example, ``[A-Z]`` will match "
"lowercase letters, too. Full Unicode matching also works unless the "
":const:`ASCII` flag is used to disable non-ASCII matches.  When the "
"Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in combination with the "
":const:`IGNORECASE` flag, they will match the 52 ASCII letters and 4 "
"additional non-ASCII letters: 'İ' (U+0130, Latin capital letter I with "
"dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' (U+017F, "
"Latin small letter long s) and 'K' (U+212A, Kelvin sign).  ``Spam`` will "
"match ``'Spam'``, ``'spam'``, ``'spAM'``, or ``'ſpam'`` (the latter is "
"matched only in Unicode mode). This lowercasing doesn't take the current "
"locale into account; it will if you also set the :const:`LOCALE` flag."
msgstr ""
"대소 문자를 구분하지 않는 일치를 수행합니다; 문자 클래스와 리터럴 문자열은 대소 문자를 무시하여 문자와 일치합니다. 예를 들어 "
"``[A-Z]``\\는 소문자와도 일치합니다. :const:`ASCII` 플래그로 ASCII가 아닌 일치를 막지 않는 한, 전체 "
"유니코드 일치도 작동합니다. 유니코드 패턴 ``[a-z]``\\나 ``[A-Z]``\\가 :const:`IGNORECASE` "
"플래그와 함께 사용되면, 52 ASCII 문자와 4개의 추가 비 ASCII 문자와 일치합니다: 'İ' (U+0130, 위에 점이 "
"있는 라틴 대문자 I), 'ı' (U+0131, 라틴 소문자 점 없는 i), 'ſ' (U+017F, 라틴 소문자 긴 s) 및 'K'"
" (U+212A, 켈빈 기호). ``Spam``\\은 ``'Spam'``, ``'spam'``, ``'spAM'`` 또는 "
"``'ſpam'``\\과 일치합니다 (마지막은 유니코드 모드에서만 일치합니다). 이 소문자화는 현재 로케일을 고려하지 않습니다; "
"고려하려면 :const:`LOCALE` 플래그를 설정하면 됩니다."

#: ../../howto/regex.rst:581
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"``\\w``, ``\\W``, ``\\b``, ``\\B`` 및 대소 문자를 구분하지 않는 일치를 유니코드 데이터베이스 대신 현재"
" 로케일에 의존하도록 만듭니다."

#: ../../howto/regex.rst:584
msgid ""
"Locales are a feature of the C library intended to help in writing "
"programs that take account of language differences.  For example, if "
"you're processing encoded French text, you'd want to be able to write "
"``\\w+`` to match words, but ``\\w`` only matches the character class "
"``[A-Za-z]`` in bytes patterns; it won't match bytes corresponding to "
"``é`` or ``ç``. If your system is configured properly and a French locale"
" is selected, certain C functions will tell the program that the byte "
"corresponding to ``é`` should also be considered a letter. Setting the "
":const:`LOCALE` flag when compiling a regular expression will cause the "
"resulting compiled object to use these C functions for ``\\w``; this is "
"slower, but also enables ``\\w+`` to match French words as you'd expect. "
"The use of this flag is discouraged in Python 3 as the locale mechanism "
"is very unreliable, it only handles one \"culture\" at a time, and it "
"only works with 8-bit locales.  Unicode matching is already enabled by "
"default in Python 3 for Unicode (str) patterns, and it is able to handle "
"different locales/languages."
msgstr ""
"로케일은 언어 차이를 고려한 프로그램을 작성하는 데 도움이 되는 C 라이브러리의 기능입니다. 예를 들어, 인코딩된 프랑스어 텍스트를"
" 처리할 때, 단어와 일치하도록 ``\\w+``\\를 쓰고 싶습니다, 하지만 ``\\w``\\는 바이트열 패턴에서 "
"``[A-Za-z]`` 문자 클래스하고만 일치합니다; ``é``\\나 ``ç``\\에 해당하는 바이트는 일치하지 않습니다. 시스템이"
" 올바르게 구성되고 프랑스어 로케일이 선택되면, 특정 C 함수는 ``é``\\에 해당하는 바이트도 문자로 간주하여야 함을 프로그램에"
" 알립니다. 정규식을 컴파일할 때 :const:`LOCALE` 플래그를 설정하면, 컴파일된 결과 객체가 ``\\w``\\에 대해 "
"이러한 C 함수를 사용하게 됩니다; 더 느리기는 하지만, 기대하는 대로 ``\\w+``\\가 프랑스어 단어를 일치시킬 수 있습니다."
" 이 플래그의 사용은 파이썬 3에서는 권장하지 않는데, 로케일 메커니즘이 매우 신뢰성이 떨어지고, 한 번에 하나의 "
"\"컬처(culture)\" 만 처리하고, 8비트 로케일에서 만 작동하기 때문입니다. 파이썬 3에서 유니코드 (str) 패턴에 대해"
" 유니코드 일치가 기본적으로 이미 활성화되어 있으며, 다른 로케일/언어를 처리할 수 있습니다."

#: ../../howto/regex.rst:606
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^``\\과 ``$``\\는 아직 설명되지 않았습니다; :ref:`more-metacharacters` 절에서 소개될 "
"예정입니다.)"

#: ../../howto/regex.rst:609
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` "
"matches only at the end of the string and immediately before the newline "
"(if any) at the end of the string. When this flag is specified, ``^`` "
"matches at the beginning of the string and at the beginning of each line "
"within the string, immediately following each newline.  Similarly, the "
"``$`` metacharacter matches either at the end of the string and at the "
"end of each line (immediately preceding each newline)."
msgstr ""
"보통 ``^``\\는 문자열의 시작 부분에서만 일치하고, ``$``\\는 문자열의 끝부분과 문자열 끝에 있는 줄 바꿈 (있다면) "
"바로 앞에서 일치합니다. 이 플래그를 지정하면 ``^``\\는 문자열 시작 부분과 문자열 내의 각 줄 시작 부분(각 줄 바꿈의 바로"
" 뒤)에서 일치합니다. 비슷하게, ``$`` 메타 문자는 문자열 끝과 각 줄의 끝(각 줄 바꿈 바로 앞)에서 일치합니다."

#: ../../howto/regex.rst:622
msgid ""
"Makes the ``'.'`` special character match any character at all, including"
" a newline; without this flag, ``'.'`` will match anything *except* a "
"newline."
msgstr ""
"``'.'`` 특수 문자가 개행 문자를 포함하는 모든 문자와 일치하도록 만듭니다; 이 플래그가 없으면, ``'.'``\\는 개행 "
"문자를 *제외한* 모든 문자와 일치합니다."

#: ../../howto/regex.rst:630
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform "
"ASCII-only matching instead of full Unicode matching. This is only "
"meaningful for Unicode patterns, and is ignored for byte patterns."
msgstr ""
"``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` 및 ``\\S``\\가 전체 유니코드 일치 대신 "
"ASCII 전용 일치를 수행하도록 만듭니다. 유니코드 패턴에서만 의미가 있으며, 바이트열 패턴에서는 무시됩니다."

#: ../../howto/regex.rst:639
msgid ""
"This flag allows you to write regular expressions that are more readable "
"by granting you more flexibility in how you can format them.  When this "
"flag has been specified, whitespace within the RE string is ignored, "
"except when the whitespace is in a character class or preceded by an "
"unescaped backslash; this lets you organize and indent the RE more "
"clearly.  This flag also lets you put comments within a RE that will be "
"ignored by the engine; comments are marked by a ``'#'`` that's neither in"
" a character class or preceded by an unescaped backslash."
msgstr ""
"이 플래그는 정규식을 포매팅하는 더 유연한 방법을 제공해서 더 가독성 있는 정규식을 작성할 수 있도록 합니다. 이 플래그가 "
"지정되면, 문자 클래스에 있거나 이스케이프 되지 않은 백 슬래시 뒤에 있을 때를 제외하고, RE 문자열 내의 공백을 무시합니다; "
"이것은 RE를 보다 명확하게 구성하고 들여쓰기 할 수 있도록 합니다. 이 플래그는 RE 내에 엔진이 무시하는 주석을 넣을 수도 있게"
" 합니다; 주석은 문자 클래스나 이스케이프 처리되지 않은 백 슬래시 뒤에 있지 않은 ``'#'``\\로 표시됩니다."

#: ../../howto/regex.rst:648
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much "
"easier it is to read? ::"
msgstr "예를 들어, 여기에 :const:`re.VERBOSE`\\를 사용하는 RE가 있습니다; 얼마다 더 읽기 쉬워지는지 보이십니까? ::"

#: ../../howto/regex.rst:651
msgid ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Start of a numeric entity reference\n"
" (\n"
"     0[0-7]+         # Octal form\n"
"   | [0-9]+          # Decimal form\n"
"   | x[0-9a-fA-F]+   # Hexadecimal form\n"
" )\n"
" ;                   # Trailing semicolon\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:661
msgid "Without the verbose setting, the RE would look like this::"
msgstr "상세 설정이 없으면, RE는 이렇게 됩니다::"

#: ../../howto/regex.rst:663
msgid ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"
msgstr ""

#: ../../howto/regex.rst:667
msgid ""
"In the above example, Python's automatic concatenation of string literals"
" has been used to break up the RE into smaller pieces, but it's still "
"more difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"위의 예에서, 파이썬의 문자열 리터럴 자동 이어붙이기를 사용해서 RE를 더 작은 조각으로 나누었지만, "
":const:`re.VERBOSE`\\를 사용하는 버전보다 여전히 이해하기가 어렵습니다."

#: ../../howto/regex.rst:673
msgid "More Pattern Power"
msgstr "더 많은 패턴 기능"

#: ../../howto/regex.rst:675
msgid ""
"So far we've only covered a part of the features of regular expressions."
"  In this section, we'll cover some new metacharacters, and how to use "
"groups to retrieve portions of the text that was matched."
msgstr ""
"지금까지 정규식의 일부 기능에 관해서만 설명했습니다. 이 절에서는, 몇 가지 새로운 메타 문자와 그룹을 사용하여 일치하는 텍스트의 "
"부분을 꺼내는 방법을 다룹니다."

#: ../../howto/regex.rst:683
msgid "More Metacharacters"
msgstr "메타 문자 더 보기"

#: ../../howto/regex.rst:685
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr "우리가 아직 다루지 않은 몇 가지 메타 문자가 있습니다. 대부분 이 절에서 다룰 것입니다."

#: ../../howto/regex.rst:688
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width"
" assertions`.  They don't cause the engine to advance through the string;"
" instead, they consume no characters at all, and simply succeed or fail."
"  For example, ``\\b`` is an assertion that the current position is "
"located at a word boundary; the position isn't changed by the ``\\b`` at "
"all.  This means that zero-width assertions should never be repeated, "
"because if they match once at a given location, they can obviously be "
"matched an infinite number of times."
msgstr ""
"논의할 나머지 메타 문자 중 일부는 :dfn:`폭이 없는 어서션(zero-width assertions)`\\입니다. 이들은 엔진이"
" 문자열을 통해 앞으로 나아가도록 하지 않습니다; 대신, 문자를 전혀 소비하지 않고, 단순히 성공하거나 실패합니다. 예를 들어, "
"``\\b``\\는 현재 위치가 단어 경계에 위치한다는 어서션입니다; 위치는 ``\\b``\\에 의해 전혀 변경되지 않습니다. "
"이것은 폭이 없는 어서션을 반복해서는 안 된다는 뜻인데, 주어진 위치에서 일단 일치하면 명백히 무한한 횟수만큼 일치 할 수 있기 "
"때문입니다."

#: ../../howto/regex.rst:696
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:697
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or "
"*B*. ``|`` has very low precedence in order to make it work reasonably "
"when you're alternating multi-character strings. ``Crow|Servo`` will "
"match either ``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an "
"``'S'``, and ``'ervo'``."
msgstr ""
"대안, 또는 \"or\" 연산자. *A*\\와 *B*\\가 정규식이면, ``A|B``\\는 *A*\\나 *B*\\와 일치하는 "
"문자열과 일치합니다. ``|``\\는 여러 문자로 된 문자열의 대안을 사용할 때 합리적으로 작동하도록 하기 위해 우선순위가 매우 "
"낮습니다. ``Crow|Servo``\\는 ``'Crow'``\\나 ``'Servo'``\\와 일치합니다, ``'Cro'``, "
"``'w'``\\나 ``'S'`` 그리고 ``'ervo'``\\가 아닙니다."

#: ../../howto/regex.rst:703
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character"
" class, as in ``[|]``."
msgstr "리터럴 ``'|'``\\를 일치시키려면, ``\\|``\\를 사용하거나 ``[|]`` 처럼 문자 클래스 안에 넣으십시오."

#: ../../howto/regex.rst:706
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:707
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag "
"has been set, this will only match at the beginning of the string.  In "
":const:`MULTILINE` mode, this also matches immediately after each newline"
" within the string."
msgstr ""
"줄의 시작 부분에 일치합니다. :const:`MULTILINE` 플래그가 설정되어 있지 않은 한, 문자열 시작 부분에서만 "
"일치합니다. :const:`MULTILINE` 모드에서는, 문자열 내의 각 줄 바꿈 바로 뒤에서도 일치합니다."

#: ../../howto/regex.rst:711
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning"
" of a line, the RE to use is ``^From``. ::"
msgstr "예를 들어, ``From``\\이라는 단어를 줄의 시작 부분에서만 일치시키려면, 사용할 RE는 ``^From``\\입니다. ::"

#: ../../howto/regex.rst:714
msgid ""
">>> print(re.search('^From', 'From Here to Eternity'))\n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:719
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "리터럴 ``'^'``\\를 일치시키려면, ``\\^``\\를 사용하십시오."

#: ../../howto/regex.rst:721
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:722
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr "줄의 끝부분과 일치하는데, 문자열의 끝이나 줄 바꿈 문자 다음에 오는 모든 위치로 정의됩니다. ::"

#: ../../howto/regex.rst:725
msgid ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.Match object; span=(6, 7), match='}'>"
msgstr ""

#: ../../howto/regex.rst:732
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr "리터럴 ``'$'``\\를 일치시키려면, ``\\$``\\를 사용하거나 ``[$]`` 처럼 문자 클래스 안에 넣으십시오."

#: ../../howto/regex.rst:735
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:736
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of "
"the string, but ``^`` may match at any location inside the string that "
"follows a newline character."
msgstr ""
"문자열의 시작 부분에서만 일치합니다. :const:`MULTILINE` 모드가 아닐 때, ``\\A``\\와 ``^``\\는 "
"실질적으로 같습니다. :const:`MULTILINE` 모드에서는, 다릅니다: ``\\A``\\는 여전히 문자열의 시작 부분에서만 "
"일치하지만, ``^``\\는 문자열 내의 줄 바꿈 문자 뒤에 오는 모든 위치에서 일치 할 수 있습니다."

#: ../../howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:742
msgid "Matches only at the end of the string."
msgstr "문자열 끝부분에서만 일치합니다."

#: ../../howto/regex.rst:744
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:745
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of "
"alphanumeric characters, so the end of a word is indicated by whitespace "
"or a non-alphanumeric character."
msgstr ""
"단어 경계. 이것은 단어(word)의 시작이니 끝부분에서만 일치하는 폭이 없는 어서션입니다. 단어는 영숫자 문자의 시퀀스로 "
"정의되므로, 단어의 끝은 공백이나 영숫자가 아닌 문자로 표시됩니다."

#: ../../howto/regex.rst:750
msgid ""
"The following example matches ``class`` only when it's a complete word; "
"it won't match when it's contained inside another word. ::"
msgstr "다음 예제는 완전한 단어일 때만 ``class``\\와 일치합니다. 다른 단어 안에 포함되어 있으면 일치하지 않습니다. ::"

#: ../../howto/regex.rst:753
msgid ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:761
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using "
"raw strings, then Python will convert the ``\\b`` to a backspace, and "
"your RE won't match as you expect it to. The following example looks the "
"same as our previous RE, but omits the ``'r'`` in front of the RE string."
" ::"
msgstr ""
"이 특수 시퀀스를 사용할 때 기억해야 할 두 가지 미묘한 점이 있습니다. 첫째, 이것은 파이썬의 문자열 리터럴과 정규식 시퀀스 간의"
" 최악의 충돌입니다. 파이썬의 문자열 리터럴에서 ``\\b``\\는 ASCII 값 8을 갖는 백스페이스 문자입니다. 날 문자열을 "
"사용하지 않으면, 파이썬이 ``\\b``\\를 백스페이스로 변환하고, 여러분의 RE는 예상대로 일치하지 않습니다. 다음 예제는 앞의"
" RE와 같아 보이지만, RE 문자열 앞의 ``'r'``\\가 빠졌습니다. ::"

#: ../../howto/regex.rst:769
msgid ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"
msgstr ""

#: ../../howto/regex.rst:775
msgid ""
"Second, inside a character class, where there's no use for this "
"assertion, ``\\b`` represents the backspace character, for compatibility "
"with Python's string literals."
msgstr ""
"둘째, 이 어서선이 사용되지 않는 문자 클래스 내에서, ``\\b``\\는 파이썬의 문자열 리터럴과의 호환성을 위해 백스페이스 "
"문자를 나타냅니다."

#: ../../howto/regex.rst:779
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:780
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only "
"matching when the current position is not at a word boundary."
msgstr "또 다른 폭이 없는 어서션, 이것은 ``\\b``\\의 반대이며, 현재 위치가 단어 경계에 있지 않을 때만 일치합니다."

#: ../../howto/regex.rst:785
msgid "Grouping"
msgstr "그룹"

#: ../../howto/regex.rst:787
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by"
" writing a RE divided into several subgroups which match different "
"components of interest. For example, an RFC-822 header line is divided "
"into a header name and a value, separated by a ``':'``, like this:"
msgstr ""
"종종 단지 RE가 일치하는지보다 많은 정보를 얻을 필요가 있습니다. 정규식은 종종 관심 있는 다른 구성 요소와 일치하는 몇 개의 "
"서브 그룹으로 나누어진 RE를 작성하여 문자열을 해부하는 데 사용됩니다. 예를 들어, RFC-822 헤더 행은 다음과 같이 "
"``':'``\\로 구분된 헤더 이름과 값으로 나뉩니다:"

#: ../../howto/regex.rst:793
msgid ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"
msgstr ""

#: ../../howto/regex.rst:800
msgid ""
"This can be handled by writing a regular expression which matches an "
"entire header line, and has one group which matches the header name, and "
"another group which matches the header's value."
msgstr ""
"이것은 전체 헤더 행과 일치하는 정규식을 작성하고, 헤더 이름과 일치하는 그룹 하나와 헤더 값과 일치하는 다른 그룹을 가짐으로써 "
"처리 할 수 있습니다."

#: ../../howto/regex.rst:804
#, fuzzy, python-brace-format
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical "
"expressions; they group together the expressions contained inside them, "
"and you can repeat the contents of a group with a quantifier, such as "
"``*``, ``+``, ``?``, or ``{m,n}``.  For example, ``(ab)*`` will match "
"zero or more repetitions of ``ab``. ::"
msgstr ""
"그룹은 ``'('``, ``')'`` 메타 문자로 표시됩니다. ``'('``\\와 ``')'``\\는 수학적 표현에서와 거의 같은 "
"의미가 있습니다; 내부에 포함된 표현식을 함께 묶고, ``*``, ``+``, ``?`` 또는 ``{m,n}``\\과 같은 반복 "
"한정자로 그룹의 내용을 반복 할 수 있습니다. 예를 들어, ``(ab)*``\\는 ``ab``\\를 0번 이상 반복한 것에 "
"일치합니다. ::"

#: ../../howto/regex.rst:811
msgid ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"
msgstr ""

#: ../../howto/regex.rst:815
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and "
"ending index of the text that they match; this can be retrieved by "
"passing an argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, "
":meth:`~re.Match.end`, and :meth:`~re.Match.span`.  Groups are numbered "
"starting with 0.  Group 0 is always present; it's the whole RE, so "
":ref:`match object <match-objects>` methods all have group 0 as their "
"default argument.  Later we'll see how to express groups that don't "
"capture the span of text that they match. ::"
msgstr ""
"``'('``, ``')'``\\로 표시된 그룹은 일치하는 텍스트의 시작과 끝 인덱스도 포착합니다; 이것은 "
":meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re.Match.end` 및"
" :meth:`~re.Match.span`\\에 인자를 전달하여 꺼낼 수 있습니다. 그룹은 0부터 시작하여 번호가 매겨집니다. 그룹"
" 0은 항상 존재합니다; 이것은 전체 RE이므로 :ref:`일치 객체 <match-objects>` 메서드는 모두 그룹 0을 기본 "
"인자로 사용합니다. 나중에 일치하는 텍스트 범위를 포착하지 않는 그룹을 표현하는 방법을 살펴보겠습니다. ::"

#: ../../howto/regex.rst:824
msgid ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"
msgstr ""

#: ../../howto/regex.rst:831
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"서브 그룹은 왼쪽에서 오른쪽으로 1부터 위로 번호가 매겨집니다. 그룹은 중첩될 수 있습니다; 숫자를 결정하려면, 왼쪽에서 오른쪽으로"
" 가면서 여는 괄호 문자를 세십시오. ::"

#: ../../howto/regex.rst:835
msgid ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"
msgstr ""

#: ../../howto/regex.rst:844
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, "
"in which case it will return a tuple containing the corresponding values "
"for those groups. ::"
msgstr ""
":meth:`~re.Match.group`\\으로는 한 번에 여러 개의 그룹 번호를 전달할 수 있으며, 이때 해당 그룹에 해당하는 "
"값을 포함하는 튜플을 반환합니다. ::"

#: ../../howto/regex.rst:847
msgid ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"
msgstr ""

#: ../../howto/regex.rst:850
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the "
"strings for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
":meth:`~re.Match.groups` 메서드는 모든 서브 그룹에 대한 문자열을 포함하는 튜플을 반환합니다,  1에서 "
"최대까지. ::"

#: ../../howto/regex.rst:853
msgid ""
">>> m.groups()\n"
"('abc', 'b')"
msgstr ""

#: ../../howto/regex.rst:856
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the"
" string.  For example, ``\\1`` will succeed if the exact contents of "
"group 1 can be found at the current position, and fails otherwise.  "
"Remember that Python's string literals also use a backslash followed by "
"numbers to allow including arbitrary characters in a string, so be sure "
"to use a raw string when incorporating backreferences in a RE."
msgstr ""
"패턴의 역참조를 사용하면 이전 포착 그룹의 내용이 문자열의 현재 위치에서도 발견되어야 한다고 지정할 수 있습니다. 예를 들어, "
"``\\1``\\은 그룹 1의 정확한 내용이 현재 위치에서 발견되면 성공하고, 그렇지 않으면 실패합니다. 파이썬의 문자열 리터럴은 "
"백 슬래시 뒤에 숫자를 붙여 문자열에 임의의 문자를 포함할 수 있기 때문에, RE에 역참조를 포함할 때 날 문자열을 사용해야 "
"합니다."

#: ../../howto/regex.rst:864
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "예를 들어, 다음 RE는 문자열에서 중복 단어를 감지합니다. ::"

#: ../../howto/regex.rst:866
msgid ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""

#: ../../howto/regex.rst:870
msgid ""
"Backreferences like this aren't often useful for just searching through a"
" string --- there are few text formats which repeat data in this way --- "
"but you'll soon find out that they're *very* useful when performing "
"string substitutions."
msgstr ""
"이와 같은 역참조는 단순히 문자열을 검색하는 데는 별로 유용하지 않습니다 --- 이런 식으로 데이터를 반복하는 텍스트 형식은 거의 "
"없습니다 --- 하지만 곧 문자열 치환을 수행할 때 *아주* 유용하다는 것을 알게 될 것입니다."

#: ../../howto/regex.rst:876
msgid "Non-capturing and Named Groups"
msgstr "비 포착 그룹과 이름 있는 그룹"

#: ../../howto/regex.rst:878
msgid ""
"Elaborate REs may use many groups, both to capture substrings of "
"interest, and to group and structure the RE itself.  In complex REs, it "
"becomes difficult to keep track of the group numbers.  There are two "
"features which help with this problem.  Both of them use a common syntax "
"for regular expression extensions, so we'll look at that first."
msgstr ""
"정교한 RE는 관심 있는 부분 문자열을 포착하고 RE 자체를 그룹화하고 구조화하기 위해 많은 그룹을 사용할 수 있습니다. 복잡한 "
"RE에서는, 그룹 번호를 추적하기가 어려워집니다. 이 문제를 해결하는 데 도움이 되는 두 가지 기능이 있습니다. 둘 다 정규식 "
"확장에 같은 문법을 사용하므로, 그것부터 살펴보겠습니다."

#: ../../howto/regex.rst:884
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose "
"new single-keystroke metacharacters or new special sequences beginning "
"with ``\\`` without making Perl's regular expressions confusingly "
"different from standard REs.  If they chose ``&`` as a new metacharacter,"
" for example, old expressions would be assuming that ``&`` was a regular "
"character and wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5는 표준 정규식에 대한 강력한 추가 기능으로 유명합니다. 이러한 새로운 기능을 위해 Perl 개발자는 Perl의 정규식을"
" 표준 RE와 혼란스러울 만큼 다르게 만들지 않으면서 한 글자 메타 문자나 ``\\``\\로 시작하는 새로운 특수 시퀀스를 선택할 "
"수 없었습니다. 예를 들어, ``&``\\를 새로운 메타 문자로 선택하면, 예전 정규식은 ``&``\\가 일반 문자라고 가정하고 "
"``\\&``\\나 ``[&]``\\로 작성하여 이스케이프 하지 않을 것입니다."

#: ../../howto/regex.rst:891
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax "
"error because the ``?`` would have nothing to repeat, so this didn't "
"introduce any compatibility problems.  The characters immediately after "
"the ``?``  indicate what extension is being used, so ``(?=foo)`` is one "
"thing (a positive lookahead assertion) and ``(?:foo)`` is something else "
"(a non-capturing group containing the subexpression ``foo``)."
msgstr ""
"Perl 개발자가 선택한 해법은 ``(?...)``\\를 확장 문법으로 사용하는 것입니다. 괄호 바로 뒤에 있는 ``?``\\는 "
"``?``\\가 반복할 것이 없기 때문에 문법 에러였습니다. 따라서 이것은 어떤 호환성 문제도 일으키지 않습니다. ``?`` 다음에"
" 나오는 문자는 어떤 확장이 사용되는지 나타내므로, ``(?=foo)`` 는 한가지 확장이고 (긍정적인 미리 보기 어서션), "
"``(?:foo)`` 는 또 다른 것입니다 (서브 정규식 ``foo``\\를 포함하는 비 포착 그룹)."

#: ../../howto/regex.rst:899
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax"
" to Perl's extension syntax.  If the first character after the question "
"mark is a ``P``, you know that it's an extension that's specific to "
"Python."
msgstr ""
"파이썬은 여러 Perl의 확장을 지원하고 Perl의 확장 문법에 확장 문법을 추가합니다. 물음표 뒤의 첫 번째 문자가 "
"``P``\\이면, 파이썬에 특유한 확장임을 알 수 있습니다."

#: ../../howto/regex.rst:904
msgid ""
"Now that we've looked at the general extension syntax, we can return to "
"the features that simplify working with groups in complex REs."
msgstr "이제 일반적인 확장 문법을 살펴보았으므로, 복잡한 RE에서 그룹 작업을 단순화하는 기능으로 돌아갈 수 있습니다."

#: ../../howto/regex.rst:907
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You"
" can make this fact explicit by using a non-capturing group: ``(?:...)``,"
" where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"때로 그룹을 사용하여 정규식의 일부를 나타내고 싶지만, 그룹의 내용을 꺼내는 데는 관심이 없습니다. 이 사실을 비 포착 그룹을 "
"사용해서 명시적으로 만들 수 있습니다: ``(?:...)``, 여기서 ``...``\\을 다른 정규식으로 바꿀 수 있습니다. ::"

#: ../../howto/regex.rst:912
msgid ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"
msgstr ""

#: ../../howto/regex.rst:919
msgid ""
"Except for the fact that you can't retrieve the contents of what the "
"group matched, a non-capturing group behaves exactly the same as a "
"capturing group; you can put anything inside it, repeat it with a "
"repetition metacharacter such as ``*``, and nest it within other groups "
"(capturing or non-capturing). ``(?:...)`` is particularly useful when "
"modifying an existing pattern, since you can add new groups without "
"changing how all the other groups are numbered.  It should be mentioned "
"that there's no performance difference in searching between capturing and"
" non-capturing groups; neither form is any faster than the other."
msgstr ""
"그룹과 일치하는 내용을 꺼낼 수 없다는 점을 제외하면, 비 포착 그룹은 포착 그룹과 정확히 같게 작동합니다; 안에 어떤 것이든 넣을"
" 수 있고, ``*``\\와 같은 반복 메타 문자로 반복할 수 있고, 다른 그룹(포착이나 비 포착) 내에 중첩할 수 있습니다. "
"``(?:...)``\\는 기존 패턴을 수정할 때 특히 유용합니다. 다른 모든 그룹의 번호가 매겨지는 방식을 변경하지 않고 새 "
"그룹을 추가 할 수 있기 때문입니다. 포착 그룹과 비 포착 그룹을 검색할 때 성능 차이가 없다는 점을 짚고 넘어가야 할 것 "
"같습니다; 두 형태 중 어느 것도 다른 것보다 빠르지 않습니다."

#: ../../howto/regex.rst:928
msgid ""
"A more significant feature is named groups: instead of referring to them "
"by numbers, groups can be referenced by a name."
msgstr "더 중요한 기능은 이름 있는 그룹입니다: 번호로 참조하는 대신, 이름으로 그룹을 참조 할 수 있습니다."

#: ../../howto/regex.rst:931
msgid ""
"The syntax for a named group is one of the Python-specific extensions: "
"``(?P<name>...)``.  *name* is, obviously, the name of the group.  Named "
"groups behave exactly like capturing groups, and additionally associate a"
" name with a group.  The :ref:`match object <match-objects>` methods that"
" deal with capturing groups all accept either integers that refer to the "
"group by number or strings that contain the desired group's name.  Named "
"groups are still given numbers, so you can retrieve information about a "
"group in two ways::"
msgstr ""
"이름 있는 그룹의 문법은 파이썬 특정 확장 중 하나입니다: ``(?P<name>...)``. *name*\\은, 당연히, 그룹의 "
"이름입니다. 이름 있는 그룹은 포착 그룹과 똑같이 동작하며, 추가로 이름을 그룹과 연관시킵니다. 포착 그룹을 다루는 :ref:`일치"
" 객체 <match-objects>` 메서드는 모두 숫자로 그룹을 가리키는 정수나 원하는 그룹의 이름을 포함하는 문자열을 "
"받아들입니다. 이름 있는 그룹에는 여전히 번호가 매겨지므로, 두 가지 방법으로 그룹에 대한 정보를 꺼낼 수 있습니다::"

#: ../../howto/regex.rst:939
msgid ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"
msgstr ""

#: ../../howto/regex.rst:946
msgid ""
"Additionally, you can retrieve named groups as a dictionary with "
":meth:`~re.Match.groupdict`::"
msgstr "또한, :meth:`~re.Match.groupdict`\\로 이름 있는 그룹을 딕셔너리로 꺼낼 수 있습니다::"

#: ../../howto/regex.rst:949
#, python-brace-format
msgid ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"
msgstr ""

#: ../../howto/regex.rst:953
#, fuzzy
msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the "
":mod:`imaplib` module::"
msgstr ""
"이름 있는 그룹은 숫자를 기억하는 대신 쉽게 기억할 수 있는 이름을 사용할 수 있어서 편리합니다. 다음은 :mod:`imaplib`"
" 모듈에서 온 예제 RE입니다::"

#: ../../howto/regex.rst:957
msgid ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"
msgstr ""

#: ../../howto/regex.rst:964
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr "그룹 9를 꺼내는 것을 기억하는 대신, ``m.group('zonem')``\\을 꺼내기가 훨씬 쉽습니다."

#: ../../howto/regex.rst:967
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` "
"refers to the number of the group.  There's naturally a variant that uses"
" the group name instead of the number. This is another Python extension: "
"``(?P=name)`` indicates that the contents of the group called *name* "
"should again be matched at the current point.  The regular expression for"
" finding doubled words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"``(...)\\1``\\과 같은 정규식에서 역참조 문법은 그룹 번호를 나타냅니다. 자연스럽게 번호 대신 그룹 이름을 사용하는 "
"변형이 있습니다. 이것은 다른 파이썬 확장입니다: ``(?P=name)``\\은 *name*\\이라는 그룹의 내용이 현재 위치에서 "
"다시 일치해야 함을 나타냅니다. 중복된 단어를 찾는 정규식인 ``\\b(\\w+)\\s+\\1\\b``\\는 "
"``\\b(?P<word>\\w+)\\s+(?P=word)\\b``\\로 표현할 수도 있습니다::"

#: ../../howto/regex.rst:974
msgid ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""

#: ../../howto/regex.rst:980
msgid "Lookahead Assertions"
msgstr "미리 보기 어서션"

#: ../../howto/regex.rst:982
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look "
"like this:"
msgstr ""
"또 다른 폭이 없는 어서션은 미리 보기 어서션(lookahead assertion)입니다. 미리 보기 어서션은 긍정과 부정 형식 "
"모두 제공되며, 다음과 같이 표시됩니다:"

#: ../../howto/regex.rst:985
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:986
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the "
"current location, and fails otherwise. But, once the contained expression"
" has been tried, the matching engine doesn't advance at all; the rest of "
"the pattern is tried right where the assertion started."
msgstr ""
"긍정적인 미리 보기 어서션. 포함된 정규식(여기에서는 ``...``\\로 표시되었습니다)이 현재 위치에서 성공적으로 일치하면 "
"성공하고, 그렇지 않으면 실패합니다. 그러나, 일단 포함된 정규식이 시도되면, 일치 엔진은 전혀 앞으로 나아가지 않습니다; 어서선이"
" 시작한 곳에서 나머지 패턴을 시도합니다."

#: ../../howto/regex.rst:992
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:993
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the"
" current position in the string."
msgstr ""
"부정적인 미리 보기 어서션. 이것은 긍정적인 어서션의 반대입니다; 포함된 정규식이 문자열의 현재 위치에서 일치하지 *않으면* "
"성공합니다."

#: ../../howto/regex.rst:997
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a "
"base name and an extension, separated by a ``.``.  For example, in "
"``news.rc``, ``news`` is the base name, and ``rc`` is the filename's "
"extension."
msgstr ""
"이를 구체적으로 설명하기 위해, 미리 보기가 유용한 경우를 살펴보겠습니다. 파일 이름을 일치시키고 ``.``\\로 구분된 기본 "
"이름과 확장자로 분리하는 간단한 패턴을 생각해봅시다. 예를 들어, ``news.rc``\\에서, ``news``\\는 기본 이름이고"
" ``rc``\\는 파일명의 확장자입니다."

#: ../../howto/regex.rst:1002
msgid "The pattern to match this is quite simple:"
msgstr "이것과 일치하는 패턴은 매우 간단합니다:"

#: ../../howto/regex.rst:1004
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1006
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that "
"specific character.  Also notice the trailing ``$``; this is added to "
"ensure that all the rest of the string must be included in the extension."
"  This regular expression matches ``foo.bar`` and ``autoexec.bat`` and "
"``sendmail.cf`` and ``printers.conf``."
msgstr ""
"``.``\\는 메타 문자이므로 특수하게 처리해야 하므로, 해당 문자에만 일치하기 위해 문자 클래스 내에 있습니다. 또한 후행 "
"``$``\\도 유의하십시오; 나머지 문자열이 확장에 포함되어야 함을 보장하기 위해 추가됩니다. 이 정규식은 "
"``foo.bar``\\와 ``autoexec.bat``\\와 ``sendmail.cf``\\와 "
"``printers.conf``\\와 일치합니다."

#: ../../howto/regex.rst:1013
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"자, 문제를 조금 복잡하게 생각해보십시오; 확장자가 ``bat``\\이 아닌 파일명을 일치시키려면 어떻게 해야 합니까? 몇 가지 "
"잘못된 시도:"

#: ../../howto/regex.rst:1016
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This"
" is wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` 위의 첫 번째 시도는 확장자의 첫 번째 문자가 ``b``\\가 아니도록 요구하여 ``bat``\\를 "
"제외하려고 시도합니다. 패턴이 ``foo.bar``\\와도 일치하지 않기 때문에, 이것은 잘못된 것입니다."

#: ../../howto/regex.rst:1020
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1022
msgid ""
"The expression gets messier when you try to patch up the first solution "
"by requiring one of the following cases to match: the first character of "
"the extension isn't ``b``; the second character isn't ``a``; or the third"
" character isn't ``t``.  This accepts ``foo.bar`` and rejects "
"``autoexec.bat``, but it requires a three-letter extension and won't "
"accept a filename with a two-letter extension such as ``sendmail.cf``.  "
"We'll complicate the pattern again in an effort to fix it."
msgstr ""
"다음에서 하나를 요구하여 첫 번째 해결 방법을 패치할 때 정규식이 더 복잡해집니다: 확장자의 첫 번째 문자가 ``b``\\가 "
"아닙니다; 두 번째 문자가 ``a``\\가 아닙니다; 또는 세 번째 문자가 ``t``\\가 아닙니다. 이것은 "
"``foo.bar``\\를 받아들이고 ``autoexec.bat``\\를 거부하지만, 세 문자 확장자를 요구하고 "
"``sendmail.cf``\\와 같은 두 문자로 된 확장자를 가진 파일명을 허용하지 않습니다. 문제를 해결하기 위해 패턴을 다시 "
"복잡하게 만들 것입니다."

#: ../../howto/regex.rst:1030
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1032
msgid ""
"In the third attempt, the second and third letters are all made optional "
"in order to allow matching extensions shorter than three characters, such"
" as ``sendmail.cf``."
msgstr ""
"세 번째 시도에서, ``sendmail.cf``\\와 같이 세 문자보다 짧은 확장자를 허용하기 위해 두 번째와 세 번째 문자는 모두"
" 선택적입니다."

#: ../../howto/regex.rst:1036
msgid ""
"The pattern's getting really complicated now, which makes it hard to read"
" and understand.  Worse, if the problem changes and you want to exclude "
"both ``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"이제 패턴이 정말 복잡해져서, 읽고 이해하기 어렵습니다. 더욱이, 문제가 변경되어 확장자 ``bat``\\와 ``exe``\\를 "
"모두 제외하려면, 패턴이 훨씬 복잡하고 혼란스러워집니다."

#: ../../howto/regex.rst:1041
msgid "A negative lookahead cuts through all this confusion:"
msgstr "부정적인 미리 보기는 이 모든 혼란을 제거합니다:"

#: ../../howto/regex.rst:1043
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the "
"extension only starts with ``bat``, will be allowed.  The ``[^.]*`` makes"
" sure that the pattern works when there are multiple dots in the "
"filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` 부정적인 미리 보기는 다음과 같은 의미입니다: ``bat`` 정규식이 이 지점에서 "
"일치하지 않으면, 나머지 패턴을 시도합니다; ``bat$``\\가 일치하면, 전체 패턴이 실패합니다. 후행 ``$``\\는 "
"``sample.batch``\\와 같이 ``bat``\\로 시작하기만 하는 확장자를 허용하기 위해 필요합니다. "
"``[^.]*``\\는 파일명에 여러 점이 있을 때 패턴이 작동하도록 합니다."

#: ../../howto/regex.rst:1050
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes "
"filenames that end in either ``bat`` or ``exe``:"
msgstr ""
"다른 파일명 확장자를 제외하는 것이 이제는 쉽습니다; 단순히 어서션 안에 대안으로 추가하십시오. 다음 패턴은 ``bat``\\나 "
"``exe``\\로 끝나는 파일명을 제외합니다:"

#: ../../howto/regex.rst:1054
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1058
msgid "Modifying Strings"
msgstr "문자열 수정하기"

#: ../../howto/regex.rst:1060
msgid ""
"Up to this point, we've simply performed searches against a static "
"string. Regular expressions are also commonly used to modify strings in "
"various ways, using the following pattern methods:"
msgstr ""
"지금까지는, 정적 문자열에 대한 검색만 수행했습니다. 정규식은 다음과 같은 패턴 메서드를 사용하여 다양한 방법으로 문자열을 수정하는"
" 데 흔히 사용됩니다:"

#: ../../howto/regex.rst:1067
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1067
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "RE가 일치하는 모든 곳에서 분할하여, 문자열을 리스트로 분할합니다"

#: ../../howto/regex.rst:1070
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1070
msgid ""
"Find all substrings where the RE matches, and replace them with a "
"different string"
msgstr "RE가 일치하는 모든 부분 문자열을 찾고, 다른 문자열로 대체합니다."

#: ../../howto/regex.rst:1073
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1073
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ":meth:`!sub`\\와 같은 일을 하지만, 새로운 문자열과 치환 횟수를 반환합니다"

#: ../../howto/regex.rst:1080
msgid "Splitting Strings"
msgstr "문자열 분할하기"

#: ../../howto/regex.rst:1082
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more "
"generality in the delimiters that you can split by; string :meth:`!split`"
" only supports splitting by whitespace or by a fixed string.  As you'd "
"expect, there's a module-level :func:`re.split` function, too."
msgstr ""
"패턴의 :meth:`~re.Pattern.split` 메서드는 RE가 일치하는 모든 곳에서 문자열을 분할하여, 조각의 리스트를 "
"반환합니다. 이것은 :meth:`~str.split` 문자열 메서드와 비슷하지만 분리하는 데 사용되는 구분자에 훨씬 더 일반성을 "
"제공합니다; 문자열 :meth:`!split`\\는 공백이나 고정 문자열로의 분할 만 지원합니다. 예상대로, 모듈 수준의 "
":func:`re.split` 함수도 있습니다."

#: ../../howto/regex.rst:1093
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned"
" as part of the resulting list.  If *maxsplit* is nonzero, at most "
"*maxsplit* splits are performed."
msgstr ""
"정규식과 일치하는 것으로 *string*\\을 분할합니다. RE에서 포착하는 괄호가 사용되면, 해당 내용도 결과 리스트의 일부로 "
"반환됩니다. *maxsplit*\\가 0이 아니면, 최대 *maxsplit* 번 분할만 수행됩니다."

#: ../../howto/regex.rst:1098
msgid ""
"You can limit the number of splits made, by passing a value for "
"*maxsplit*. When *maxsplit* is nonzero, at most *maxsplit* splits will be"
" made, and the remainder of the string is returned as the final element "
"of the list.  In the following example, the delimiter is any sequence of "
"non-alphanumeric characters. ::"
msgstr ""
"*maxsplit* 값을 전달하여, 분할 수를 제한 할 수 있습니다. *maxsplit*\\가 0이 아니면, 최대 "
"*maxsplit* 번 분할만 이루어지고, 나머지 문자열은 리스트의 마지막 요소로 반환됩니다. 다음 예제에서, 구분자는 영숫자가 "
"아닌 문자 시퀀스입니다. ::"

#: ../../howto/regex.rst:1104
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"
msgstr ""

#: ../../howto/regex.rst:1110
msgid ""
"Sometimes you're not only interested in what the text between delimiters "
"is, but also need to know what the delimiter was.  If capturing "
"parentheses are used in the RE, then their values are also returned as "
"part of the list.  Compare the following calls::"
msgstr ""
"때로는 구분자 사이의 텍스트가 무엇인지에 관심이 있을 뿐만 아니라, 구분자가 무엇인지도 알아야 할 필요가 있습니다. RE에서 "
"포착하는 괄호가 사용되면, 해당 값도 리스트의 일부로 반환됩니다. 다음 호출을 비교하십시오::"

#: ../../howto/regex.rst:1115
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"
msgstr ""

#: ../../howto/regex.rst:1122
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr "모듈 수준 함수 :func:`re.split`\\는 첫 번째 인자로 사용할 RE를 추가하지만, 이를 제외하고는 같습니다. ::"

#: ../../howto/regex.rst:1125
msgid ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"
msgstr ""

#: ../../howto/regex.rst:1134
msgid "Search and Replace"
msgstr "검색과 치환"

#: ../../howto/regex.rst:1136
msgid ""
"Another common task is to find all the matches for a pattern, and replace"
" them with a different string.  The :meth:`~re.Pattern.sub` method takes "
"a replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"또 다른 흔한 작업은 패턴에 대한 모든 일치를 찾아 다른 문자열로 치환하는 것입니다. :meth:`~re.Pattern.sub` "
"메서드는 치환 값(문자열이나 함수일 수 있습니다)과 처리할 문자열을 취합니다."

#: ../../howto/regex.rst:1143
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If "
"the pattern isn't found, *string* is returned unchanged."
msgstr ""
"*string*\\에서 가장 왼쪽에 나타나는 겹쳐지지 않은 RE의 일치를 *replacement*\\로 치환한 문자열을 반환합니다."
" 패턴이 없으면, *string*\\이 변경 없이 반환됩니다."

#: ../../howto/regex.rst:1147
msgid ""
"The optional argument *count* is the maximum number of pattern "
"occurrences to be replaced; *count* must be a non-negative integer.  The "
"default value of 0 means to replace all occurrences."
msgstr ""
"선택적 인자 *count*\\는 치환될 패턴 일치의 최대 수입니다; *count*\\는 음수가 아닌 정수여야 합니다. 기본값 0은 "
"모든 일치를 치환하는 것을 의미합니다."

#: ../../howto/regex.rst:1151
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"다음은 :meth:`~re.Pattern.sub` 메서드를 사용하는 간단한 예제입니다. 색상 이름을 ``colour``\\라는 "
"단어로 바꿉니다::"

#: ../../howto/regex.rst:1154
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"
msgstr ""

#: ../../howto/regex.rst:1160
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a "
"2-tuple containing the new string value and the number of replacements  "
"that were performed::"
msgstr ""
":meth:`~re.Pattern.subn` 메서드는 같은 작업을 수행하지만, 새 문자열 값과 수행된 치환 수가 포함된 2-튜플을 "
"반환합니다::"

#: ../../howto/regex.rst:1163
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"
msgstr ""

#: ../../howto/regex.rst:1169
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr "빈 일치는 이전의 빈 일치와 인접하지 않은 경우에만 치환됩니다. ::"

#: ../../howto/regex.rst:1172
msgid ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"
msgstr ""

#: ../../howto/regex.rst:1176
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed."
"  That is, ``\\n`` is converted to a single newline character, ``\\r`` is"
" converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced "
"with the substring matched by the corresponding group in the RE.  This "
"lets you incorporate portions of the original text in the resulting "
"replacement string."
msgstr ""
"*replacement*\\가 문자열이면, 그 안에 있는 모든 역 슬래시 이스케이프가 처리됩니다. 즉, ``\\n``\\은 단일 "
"개행 문자로 변환되고, ``\\r``\\은 캐리지 리턴으로 변환되고, 나머지도 마찬가지입니다. ``\\&``\\와 같은 알 수 없는"
" 이스케이프는 그대로 남습니다. ``\\6``\\과 같은 역참조는 RE의 해당 그룹과 일치하는 부분 문자열로 치환됩니다. 이렇게 "
"하면 결과 치환 문자열에 원본 텍스트의 일부를 통합할 수 있습니다."

#: ../../howto/regex.rst:1183
#, python-brace-format
msgid ""
"This example matches the word ``section`` followed by a string enclosed "
"in ``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"이 예제는 뒤에 ``{``, ``}``\\로 묶인 문자열이 오는 단어 ``section``\\과 일치하고, "
"``section``\\을 ``subsection``\\으로 변경합니다::"

#: ../../howto/regex.rst:1186
#, python-brace-format
msgid ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"
msgstr ""

#: ../../howto/regex.rst:1190
msgid ""
"There's also a syntax for referring to named groups as defined by the "
"``(?P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched "
"by the group named ``name``, and  ``\\g<number>``  uses the corresponding"
" group number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't "
"ambiguous in a replacement string such as ``\\g<2>0``.  (``\\20`` would "
"be interpreted as a reference to group 20, not a reference to group 2 "
"followed by the literal character ``'0'``.)  The following substitutions "
"are all equivalent, but use all three variations of the replacement "
"string. ::"
msgstr ""
"또한 ``(?P<name>...)`` 문법으로 정의된 이름 있는 그룹을 참조하기 위한 문법이 있습니다. "
"``\\g<name>``\\은 ``name`` 그룹과 일치하는 부분 문자열을 사용하고, ``\\g<number>``\\는 해당 그룹"
" 번호를 사용합니다. 따라서 ``\\g<2>``\\는 ``\\2``\\와 동등하지만, ``\\g<2>0``\\과 같은 치환 "
"문자열에서 모호하지 않습니다. (``\\20``\\은 ``'0'``\\이 뒤에 오는 그룹 2에 대한 참조가 아닌, 그룹 20에 대한"
" 참조로 해석됩니다.) 다음 치환은 모두 동등하지만, 치환 문자열의 세 가지 변형을 모두 사용합니다. ::"

#: ../../howto/regex.rst:1199
#, python-brace-format
msgid ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"
msgstr ""

#: ../../howto/regex.rst:1207
msgid ""
"*replacement* can also be a function, which gives you even more control."
"  If *replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is "
"passed a :ref:`match object <match-objects>` argument for the match and "
"can use this information to compute the desired replacement string and "
"return it."
msgstr ""
"*replacement*\\는 함수일 수도 있는데, 더 많은 제어를 제공합니다. *replacement*\\가 함수면, "
"*pattern*\\의 겹쳐지지 않는 모든 일치에 대해 함수가 호출됩니다. 각 호출에서, 함수는 그 일치에 대한 :ref:`일치 "
"객체 <match-objects>` 인자를 전달받고, 이 정보를 사용하여 원하는 치환 문자열을 계산하고 이를 반환 할 수 있습니다."

#: ../../howto/regex.rst:1213
msgid ""
"In the following example, the replacement function translates decimals "
"into hexadecimal::"
msgstr "다음 예제에서, 치환 함수는 십진수를 16진수로 변환합니다::"

#: ../../howto/regex.rst:1216
msgid ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"
msgstr ""

#: ../../howto/regex.rst:1225
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is "
"passed as the first argument.  The pattern may be provided as an object "
"or as a string; if you need to specify regular expression flags, you must"
" either use a pattern object as the first parameter, or use embedded "
"modifiers in the pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb "
"BBBB\")`` returns ``'x x'``."
msgstr ""
"모듈 수준의 :func:`re.sub` 함수를 사용할 때, 패턴은 첫 번째 인자로 전달됩니다. 패턴은 객체나 문자열로 제공될 수 "
"있습니다; 정규식 플래그를 지정해야 하면, 패턴 객체를 첫 번째 매개 변수로 사용하거나 패턴 문자열에 포함된 수정자를 사용해야 "
"합니다, 예를 들어 ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")``\\는 ``'x x'``\\를 "
"반환합니다."

#: ../../howto/regex.rst:1233
msgid "Common Problems"
msgstr "일반적인 문제들"

#: ../../howto/regex.rst:1235
msgid ""
"Regular expressions are a powerful tool for some applications, but in "
"some ways their behaviour isn't intuitive and at times they don't behave "
"the way you may expect them to.  This section will point out some of the "
"most common pitfalls."
msgstr ""
"정규식은 일부 응용을 위한 강력한 도구이지만, 어떤 면에서는 동작이 직관적이지 않고 때때로 예상대로 동작하지 않을 수도 있습니다. "
"이 절에서는 가장 일반적인 함정 중 일부를 지적합니다."

#: ../../howto/regex.rst:1241
msgid "Use String Methods"
msgstr "문자열 메서드를 사용하십시오"

#: ../../howto/regex.rst:1243
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any "
":mod:`re` features such as the :const:`~re.IGNORECASE` flag, then the "
"full power of regular expressions may not be required. Strings have "
"several methods for performing operations with fixed strings and they're "
"usually much faster, because the implementation is a single small C loop "
"that's been optimized for the purpose, instead of the large, more "
"generalized regular expression engine."
msgstr ""
"때때로 :mod:`re` 모듈을 사용하는 것은 실수입니다. 고정된 문자열이나 단일 문자 클래스와 일치시키려고 하고, "
":const:`~re.IGNORECASE` 플래그와 같은 :mod:`re` 기능을 사용하지 않는다면, 정규식의 모든 기능이 필요하지"
" 않을 수 있습니다. 문자열은 고정 문자열을 사용하는 연산을 수행하는 몇 가지 메서드를 가지고 있으며, 대개 훨씬 빠릅니다. 더 "
"크고, 더 일반화된 정규식 엔진 대신, 구현이 목적에 맞게 최적화된 단일하고 작은 C 루프이기 때문입니다."

#: ../../howto/regex.rst:1251
msgid ""
"One example might be replacing a single fixed string with another one; "
"for example, you might replace ``word`` with ``deed``.  :func:`re.sub` "
"seems like the function to use for this, but consider the "
":meth:`~str.replace` method.  Note that :meth:`!replace` will also "
"replace ``word`` inside words, turning ``swordfish`` into ``sdeedfish``, "
"but the  naive RE ``word`` would have done that, too.  (To avoid "
"performing the substitution on parts of words, the pattern would have to "
"be ``\\bword\\b``, in order to require that ``word`` have a word boundary"
" on either side.  This takes the job beyond  :meth:`!replace`'s "
"abilities.)"
msgstr ""
"한가지 예는 하나의 고정 된 문자열을 다른 것으로 치환하는 것일 수 있습니다; 예를 들어, ``word``\\를 "
"``deed``\\로 바꿀 수 있습니다. :func:`re.sub`\\가 이를 위한 함수인 것처럼 보이지만, "
":meth:`~str.replace` 메서드를 고려하십시오. :meth:`!replace`\\는 또한 단어 안에 있는 "
"``word``\\를 치환해서, ``swordfish``\\를 ``sdeedfish``\\로 바꾸지만, 나이브한 RE "
"``word``\\도 그렇게 했을 것입니다. (단어의 일부에 대한 치환을 수행하는 것을 피하고자, 패턴은 ``word`` 양쪽에 "
"단어 경계가 있도록 ``\\bword\\b``\\여야 합니다. 이 작업은 :meth:`!replace`\\의 능력을 넘어섭니다.)"

#: ../../howto/regex.rst:1260
msgid ""
"Another common task is deleting every occurrence of a single character "
"from a string or replacing it with another single character.  You might "
"do this with something like ``re.sub('\\n', ' ', S)``, but "
":meth:`~str.translate` is capable of doing both tasks and will be faster "
"than any regular expression operation can be."
msgstr ""
"또 다른 일반적인 작업은 문자열에서 단일 문자를 모두 삭제하거나 다른 단일 문자로 바꾸는 것입니다. ``re.sub('\\n', '"
" ', S)``\\와 같은 방식으로 이 작업을 수행 할 수 있지만, :meth:`~str.translate`\\는 두 가지 작업을 "
"모두 수행 할 수 있으며 정규식 연산보다 빠릅니다."

#: ../../howto/regex.rst:1266
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr "정리하면, :mod:`re` 모듈을 사용하기 전에, 더 빠르고 간단한 문자열 메서드로 문제를 해결할 수 있는지 고려하십시오."

#: ../../howto/regex.rst:1271
msgid "match() versus search()"
msgstr "match()와 search() 비교"

#: ../../howto/regex.rst:1273
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward "
"through the string for a match. It's important to keep this distinction "
"in mind.  Remember,  :func:`!match` will only report a successful match "
"which will start at 0; if the match wouldn't start at zero,  "
":func:`!match` will *not* report it. ::"
msgstr ""
":func:`~re.match` 함수는 문자열 시작 부분에서 RE가 일치하는지만 확인하는 반면, "
":func:`~re.search`\\는 일치를 찾기 위해 문자열을 정방향으로 검색합니다. 이 차이를 염두에 두는 것이 중요합니다. "
"기억하십시오, :func:`!match`\\는 0에서 시작하는 성공적인 일치만을 보고합니다; 일치가 0에서 시작하지 않으면, "
":func:`!match`\\는 이를 보고하지 *않습니다*. ::"

#: ../../howto/regex.rst:1279
msgid ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"
msgstr ""

#: ../../howto/regex.rst:1284
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the "
"string, reporting the first match it finds. ::"
msgstr "반면에, :func:`~re.search`\\는 문자열을 정방향으로 검색하여, 발견된 첫 번째 일치를 보고합니다. ::"

#: ../../howto/regex.rst:1287
msgid ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"
msgstr ""

#: ../../howto/regex.rst:1292
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add "
"``.*`` to the front of your RE.  Resist this temptation and use "
":func:`re.search` instead.  The regular expression compiler does some "
"analysis of REs in order to speed up the process of looking for a match."
"  One such analysis figures out what the first character of a match must "
"be; for example, a pattern starting with ``Crow`` must match starting "
"with a ``'C'``.  The analysis lets the engine quickly scan through the "
"string looking for the starting character, only trying the full match if "
"a ``'C'`` is found."
msgstr ""
"때로 :func:`re.match`\\를 계속 사용하면서, 단지 ``.*``\\를 RE 앞에 추가하고 싶을 수 있습니다. 이 유혹에"
" 저항하고, 대신 :func:`re.search`\\를 사용하십시오. 정규식 컴파일러는 일치를 찾는 프로세스의 속도를 높이기 위해 "
"RE에 대한 분석을 수행합니다. 그러한 분석의 하나는 일치의 첫 번째 문자가 무엇인지 알아내는 것입니다; 예를 들어, "
"``Crow``\\로 시작하는 패턴은 ``'C'``\\로 시작하는 것과 일치해야 합니다. 이 분석을 통해 엔진은 시작 문자를 찾기 "
"위해 문자열을 빠르게 검색하고, ``'C'``\\가 발견될 때만 전체 일치를 시도합니다."

#: ../../howto/regex.rst:1301
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of"
" the string and then backtracking to find a match for the rest of the RE."
"  Use :func:`re.search` instead."
msgstr ""
"``.*``\\를 추가하면 이 최적화가 실패하고, 문자열의 끝부분까지 스캔한 다음, RE의 나머지에 대한 일치를 찾기 위해 역 "
"추적합니다. 대신 :func:`re.search`\\를 사용하십시오."

#: ../../howto/regex.rst:1307
msgid "Greedy versus Non-Greedy"
msgstr "탐욕적 과 비 탐욕적 비교"

#: ../../howto/regex.rst:1309
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action "
"is to consume as much of the pattern as possible.  This fact often bites "
"you when you're trying to match a pair of balanced delimiters, such as "
"the angle brackets surrounding an HTML tag.  The naive pattern for "
"matching a single HTML tag doesn't work because of the greedy nature of "
"``.*``. ::"
msgstr ""
"``a*``\\에서와같이 정규식을 반복할 때, 결과 동작은 가능한 한 많은 패턴을 소비하는 것입니다. 이 사실은 HTML 태그를 "
"둘러싼 화살 괄호(angle brackets)와 같이 쌍을 이루는 구분 기호 쌍을 일치시키려고 할 때 여러분을 물어뜯을 수 "
"있습니다. 하나의 HTML 태그를 일치하는 나이브한 패턴은 ``.*``\\의 탐욕스러운 성격 때문에 작동하지 않습니다. ::"

#: ../../howto/regex.rst:1315
msgid ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"
msgstr ""

#: ../../howto/regex.rst:1323
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the "
"rest of the string.  There's still more left in the RE, though, and the "
"``>`` can't match at the end of the string, so the regular expression "
"engine has to backtrack character by character until it finds a match for"
" the ``>``.   The final match extends from the ``'<'`` in ``'<html>'`` to"
" the ``'>'`` in ``'</title>'``, which isn't what you want."
msgstr ""
"RE는 ``'<html>'``\\의 ``'<'``\\와 일치하고, ``.*``\\는 나머지 문자열을 소비합니다. RE에는 여전히 "
"남아있는 것이 있고, ``>``\\는 문자열의 끝에서 일치할 수 없기 때문에, 정규식 엔진은 ``>``\\와 일치하는 것을 찾을 "
"때까지 문자 단위로 역 추적해야 합니다. 최종 일치는 ``'<html>'``\\의 ``'<'``\\에서 "
"``'</title>'``\\의 ``'>'``\\까지 확장되는데, 이는 여러분이 원하는 것이 아닙니다."

#: ../../howto/regex.rst:1330
#, fuzzy, python-brace-format
msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, "
"``+?``, ``??``, or ``{m,n}?``, which match as *little* text as possible."
"  In the above example, the ``'>'`` is tried immediately after the first "
"``'<'`` matches, and when it fails, the engine advances a character at a "
"time, retrying the ``'>'`` at every step.  This produces just the right "
"result::"
msgstr ""
"이 경우, 해결 방법은 가능한 한 *적은* 텍스트에 일치하는 비 탐욕적 한정자 ``*?``, ``+?``, ``??`` 또는 "
"``{m,n}?``\\를 사용하는 것입니다. 위의 예에서, 첫 번째 ``'<'``\\가 일치하면 ``'>'``\\가 즉시 시도되고,"
" 실패하면 엔진은 한 번에 한 문자씩 앞으로 이동하여 단계마다 ``'>'``\\를 다시 시도합니다. 이렇게 하면 올바른 결과를 얻을"
" 수 있습니다::"

#: ../../howto/regex.rst:1336
msgid ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"
msgstr ""

#: ../../howto/regex.rst:1339
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. "
"Quick-and-dirty patterns will handle common cases, but HTML and XML have "
"special cases that will break the obvious regular expression; by the time"
" you've written a regular expression that handles all of the possible "
"cases, the patterns will be *very* complicated.  Use an HTML or XML "
"parser module for such tasks.)"
msgstr ""
"(정규식으로 HTML이나 XML을 구문 분석하기는 쉽지 않습니다. 빠르지만 지저분한 패턴은 일반적인 경우를 처리할 것이지만, "
"HTML과 XML에는 명확한 정규식을 깨뜨릴 특수 사례가 있습니다; 모든 가능한 경우를 처리하도록 정규식을 작성하면, 패턴이 "
"*아주* 복잡해질 수 있습니다. 이러한 작업에는 HTML이나 XML 구문 분석 모듈을 사용하십시오.)"

#: ../../howto/regex.rst:1347
msgid "Using re.VERBOSE"
msgstr "re.VERBOSE 사용하기"

#: ../../howto/regex.rst:1349
msgid ""
"By now you've probably noticed that regular expressions are a very "
"compact notation, but they're not terribly readable.  REs of moderate "
"complexity can become lengthy collections of backslashes, parentheses, "
"and metacharacters, making them difficult to read and understand."
msgstr ""
"지금까지 정규식이 매우 콤팩트한 표기법이라는 사실을 눈치챘을 것입니다만, 극단적으로 읽기 어렵지는 않았습니다. 중간 정도의 복잡성을"
" 가진 RE는 역 슬래시, 괄호 및 메타 문자의 긴 모음이 되어 읽고 이해하기 어려울 수 있습니다."

#: ../../howto/regex.rst:1354
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"이러한 RE의 경우, 정규식을 컴파일할 때 :const:`re.VERBOSE` 플래그를 지정하면 정규식을 보다 명확하게 포맷할 수 "
"있어서 도움이 됩니다."

#: ../../howto/regex.rst:1358
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less "
"readable ``dog|cat``, but ``[a b]`` will still match the characters "
"``'a'``, ``'b'``, or a space.  In addition, you can also put comments "
"inside a RE; comments extend from a ``#`` character to the next newline."
"  When used with triple-quoted strings, this enables REs to be formatted "
"more neatly::"
msgstr ""
"``re.VERBOSE`` 플래그는 여러 가지 효과가 있습니다. 문자 클래스 안에 *있지 않은* 공백이 무시됩니다. 이것은, "
"``dog | cat``\\과 같은 정규식은 가독성이 떨어지는 ``dog|cat``\\과 동등하지만, ``[a b]``\\는 여전히"
" ``'a'``, ``'b'`` 또는 스페이스 문자와 일치함을 뜻합니다. 또한, 주석을 RE에 넣을 수도 있습니다; 주석은 "
"``#`` 문자에서 다음 줄 바꿈까지 확장됩니다. 삼중 따옴표로 묶은 문자열과 함께 사용하면, RE를 더 깔끔하게 포맷할 수 "
"있습니다::"

#: ../../howto/regex.rst:1366
msgid ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:1375
msgid "This is far more readable than::"
msgstr "이것이 다음보다 훨씬 읽기 쉽습니다::"

#: ../../howto/regex.rst:1377
msgid "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"
msgstr ""

#: ../../howto/regex.rst:1381
msgid "Feedback"
msgstr "피드백"

#: ../../howto/regex.rst:1383
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions "
"for improvements to the author."
msgstr ""
"정규식은 복잡한 주제입니다. 이 문서가 도움이 되었습니까? 불분명 한 부분이 있거나, 여기에서 다루지 않은 문제가 있습니까? "
"그렇다면 저자에게 개선을 위한 제안을 보내주십시오."

#: ../../howto/regex.rst:1388
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey"
" Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of"
" regular expressions, and doesn't contain any Python material at all, so "
"it won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't "
"help you much.)  Consider checking it out from your library."
msgstr ""
"정규식에 대한 가장 완벽한 책은 거의 확실히 O'Reilly가 출판한 Jeffrey Friedl의 Mastering Regular "
"Expressions 입니다. 불행히도, 이 책은 Perl과 Java의 정규식에만 집중하고, 파이썬 자료를 전혀 포함하지 않아서 "
"파이썬 프로그래밍에 대한 참조로는 유용하지 않습니다. (첫 번째 판은 지금은 제거된 파이썬의 :mod:`!regex` 모듈을 "
"다뤘습니다만, 큰 도움은 되지 못합니다.) 여러분의 도서관에서 확인해보십시오."

#~ msgid ""
#~ "You can learn about this by "
#~ "interactively experimenting with the :mod:`re`"
#~ " module.  If you have :mod:`tkinter` "
#~ "available, you may also want to "
#~ "look at :source:`Tools/demo/redemo.py`, a "
#~ "demonstration program included with the "
#~ "Python distribution.  It allows you to"
#~ " enter REs and strings, and displays"
#~ " whether the RE matches or fails. "
#~ ":file:`redemo.py` can be quite useful "
#~ "when trying to debug a complicated "
#~ "RE."
#~ msgstr ""
#~ ":mod:`re` 모듈로 대화식으로 실험해보면 알 수 "
#~ "있습니다. :mod:`tkinter`\\를 사용할 수 있다면, 파이썬"
#~ " 배포판에 포함된 데모 프로그램인 "
#~ ":source:`Tools/demo/redemo.py`\\를 살펴볼 수도 있습니다. "
#~ "RE와 문자열을 입력하면, RE가 일치하는지 실패하는지 "
#~ "표시합니다. :file:`redemo.py`\\는 복잡한 RE를 디버깅할 "
#~ "때 매우 유용 할 수 있습니다."

