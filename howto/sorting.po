# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/sorting.rst:4
msgid "Sorting Techniques"
msgstr "정렬 기법"

#: ../../howto/sorting.rst
msgid "Author"
msgstr "저자"

#: ../../howto/sorting.rst:6
msgid "Andrew Dalke and Raymond Hettinger"
msgstr "Andrew Dalke와 Raymond Hettinger"

#: ../../howto/sorting.rst:9
msgid ""
"Python lists have a built-in :meth:`list.sort` method that modifies the "
"list in-place.  There is also a :func:`sorted` built-in function that "
"builds a new sorted list from an iterable."
msgstr ""
"파이썬 리스트에는 리스트를 제자리에서(in-place) 수정하는 내장 :meth:`list.sort` 메서드가 있습니다. 또한, "
"이터러블로부터 새로운 정렬된 리스트를 만드는 :func:`sorted` 내장 함수가 있습니다."

#: ../../howto/sorting.rst:13
msgid ""
"In this document, we explore the various techniques for sorting data "
"using Python."
msgstr "이 문서에서는, 파이썬을 사용하여 데이터를 정렬하는 다양한 기술을 살펴봅니다."

#: ../../howto/sorting.rst:17
msgid "Sorting Basics"
msgstr "정렬 기초"

#: ../../howto/sorting.rst:19
msgid ""
"A simple ascending sort is very easy: just call the :func:`sorted` "
"function. It returns a new sorted list:"
msgstr "간단한 오름차순 정렬은 매우 쉽습니다; 그저 :func:`sorted` 함수를 호출하면 됩니다. 새로운 정렬된 리스트를 반환합니다:"

#: ../../howto/sorting.rst:22
msgid ""
">>> sorted([5, 2, 3, 1, 4])\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> sorted([5, 2, 3, 1, 4])\n"
"[1, 2, 3, 4, 5]"

#: ../../howto/sorting.rst:27
msgid ""
"You can also use the :meth:`list.sort` method. It modifies the list in-"
"place (and returns ``None`` to avoid confusion). Usually it's less "
"convenient than :func:`sorted` - but if you don't need the original list,"
" it's slightly more efficient."
msgstr ""
":meth:`list.sort` 메서드를 사용할 수도 있습니다. 리스트를 제자리에서 수정합니다 (그리고 혼동을 피하고자 "
"``None``\\을 반환합니다). 일반적으로 :func:`sorted`\\보다 덜 편리합니다 - 하지만 원래 목록이 필요하지 "
"않다면, 이것이 약간 더 효율적입니다."

#: ../../howto/sorting.rst:32
msgid ""
">>> a = [5, 2, 3, 1, 4]\n"
">>> a.sort()\n"
">>> a\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> a = [5, 2, 3, 1, 4]\n"
">>> a.sort()\n"
">>> a\n"
"[1, 2, 3, 4, 5]"

#: ../../howto/sorting.rst:39
msgid ""
"Another difference is that the :meth:`list.sort` method is only defined "
"for lists. In contrast, the :func:`sorted` function accepts any iterable."
msgstr ""
"또 다른 점은 :meth:`list.sort` 메서드가 리스트에게만 정의된다는 것입니다. 이와 달리, :func:`sorted` "
"함수는 모든 이터러블을 받아들입니다."

#: ../../howto/sorting.rst:42
#, python-brace-format
msgid ""
">>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n"
"[1, 2, 3, 4, 5]"

#: ../../howto/sorting.rst:48
msgid "Key Functions"
msgstr "키 함수"

#: ../../howto/sorting.rst:50
msgid ""
"Both :meth:`list.sort` and :func:`sorted` have a *key* parameter to "
"specify a function (or other callable) to be called on each list element "
"prior to making comparisons."
msgstr ""
":meth:`list.sort`\\와 :func:`sorted`\\는 모두 비교하기 전에 각 리스트 요소에 대해 호출할 함수(또는 "
"다른 콜러블)를 지정하는 *key* 매개 변수를 가지고 있습니다."

#: ../../howto/sorting.rst:54
msgid "For example, here's a case-insensitive string comparison:"
msgstr "예를 들어, 다음은 대소 문자를 구분하지 않는 문자열 비교입니다:"

#: ../../howto/sorting.rst:56
msgid ""
">>> sorted(\"This is a test string from Andrew\".split(), "
"key=str.casefold)\n"
"['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']"
msgstr ""
">>> sorted(\"This is a test string from Andrew\".split(), "
"key=str.casefold)\n"
"['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']"

#: ../../howto/sorting.rst:61
msgid ""
"The value of the *key* parameter should be a function (or other callable)"
" that takes a single argument and returns a key to use for sorting "
"purposes. This technique is fast because the key function is called "
"exactly once for each input record."
msgstr ""
"*key* 매개 변수의 값은 단일 인자를 취하고 정렬 목적으로 사용할 키를 반환하는 함수(또는 다른 콜러블)여야 합니다. 키 함수가"
" 각 입력 레코드에 대해 정확히 한 번 호출되기 때문에 이 기법은 빠릅니다."

#: ../../howto/sorting.rst:66
msgid ""
"A common pattern is to sort complex objects using some of the object's "
"indices as keys. For example:"
msgstr "일반적인 패턴은 객체의 인덱스 중 일부를 키로 사용하여 복잡한 객체를 정렬하는 것입니다. 예를 들어:"

#: ../../howto/sorting.rst:69
msgid ""
">>> student_tuples = [\n"
"...     ('john', 'A', 15),\n"
"...     ('jane', 'B', 12),\n"
"...     ('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_tuples, key=lambda student: student[2])   # sort by "
"age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> student_tuples = [\n"
"...     ('john', 'A', 15),\n"
"...     ('jane', 'B', 12),\n"
"...     ('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_tuples, key=lambda student: student[2])   # 나이로 정렬합니다\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:79
msgid "The same technique works for objects with named attributes. For example:"
msgstr "같은 기법이 이름있는 어트리뷰트를 갖는 객체에서도 작동합니다. 예를 들어:"

#: ../../howto/sorting.rst:81
msgid ""
">>> class Student:\n"
"...     def __init__(self, name, grade, age):\n"
"...         self.name = name\n"
"...         self.grade = grade\n"
"...         self.age = age\n"
"...     def __repr__(self):\n"
"...         return repr((self.name, self.grade, self.age))\n"
"\n"
">>> student_objects = [\n"
"...     Student('john', 'A', 15),\n"
"...     Student('jane', 'B', 12),\n"
"...     Student('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_objects, key=lambda student: student.age)   # sort by "
"age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> class Student:\n"
"...     def __init__(self, name, grade, age):\n"
"...         self.name = name\n"
"...         self.grade = grade\n"
"...         self.age = age\n"
"...     def __repr__(self):\n"
"...         return repr((self.name, self.grade, self.age))\n"
"\n"
">>> student_objects = [\n"
"...     Student('john', 'A', 15),\n"
"...     Student('jane', 'B', 12),\n"
"...     Student('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_objects, key=lambda student: student.age)   # 나이로 "
"정렬합니다\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:99
msgid ""
"Objects with named attributes can be made by a regular class as shown "
"above, or they can be instances of :class:`~dataclasses.dataclass` or a "
":term:`named tuple`."
msgstr ""

#: ../../howto/sorting.rst:104
msgid "Operator Module Functions and Partial Function Evaluation"
msgstr "operator 모듈 함수와 부분 함수 평가"

#: ../../howto/sorting.rst:106
msgid ""
"The :term:`key function` patterns shown above are very common, so Python "
"provides convenience functions to make accessor functions easier and "
"faster. The :mod:`operator` module has :func:`~operator.itemgetter`, "
":func:`~operator.attrgetter`, and a :func:`~operator.methodcaller` "
"function."
msgstr ""
"위에서 보여준 :term:`키 함수 <key function>` 패턴은 매우 일반적이므로, 파이썬은 액세스 함수를 더 쉽고 빠르게 "
"만드는 편리 함수를 제공합니다. :mod:`operator` 모듈에는 :func:`~operator.itemgetter`, "
":func:`~operator.attrgetter` 및 :func:`~operator.methodcaller` 함수가 있습니다."

#: ../../howto/sorting.rst:111
msgid "Using those functions, the above examples become simpler and faster:"
msgstr "이러한 함수를 사용하면, 위의 예제가 더 간단 해지고 빨라집니다:"

#: ../../howto/sorting.rst:113
msgid ""
">>> from operator import itemgetter, attrgetter\n"
"\n"
">>> sorted(student_tuples, key=itemgetter(2))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> from operator import itemgetter, attrgetter\n"
"\n"
">>> sorted(student_tuples, key=itemgetter(2))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:123
msgid ""
"The operator module functions allow multiple levels of sorting. For "
"example, to sort by *grade* then by *age*:"
msgstr ""
"operator 모듈 함수는 다중 수준의 정렬을 허용합니다. 예를 들어, 먼저 *grade*\\로 정렬한 다음 *age*\\로 "
"정렬하려면, 이렇게 합니다:"

#: ../../howto/sorting.rst:126
msgid ""
">>> sorted(student_tuples, key=itemgetter(1,2))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('grade', 'age'))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]"
msgstr ""
">>> sorted(student_tuples, key=itemgetter(1,2))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('grade', 'age'))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]"

#: ../../howto/sorting.rst:134
msgid ""
"The :mod:`functools` module provides another helpful tool for making key-"
"functions.  The :func:`~functools.partial` function can reduce the `arity"
" <https://en.wikipedia.org/wiki/Arity>`_ of a multi-argument function "
"making it suitable for use as a key-function."
msgstr ""

#: ../../howto/sorting.rst:139
msgid ""
">>> from functools import partial\n"
">>> from unicodedata import normalize\n"
"\n"
">>> names = 'Zoë Åbjørn Núñez Élana Zeke Abe Nubia Eloise'.split()\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFD'))\n"
"['Abe', 'Åbjørn', 'Eloise', 'Élana', 'Nubia', 'Núñez', 'Zeke', 'Zoë']\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFC'))\n"
"['Abe', 'Eloise', 'Nubia', 'Núñez', 'Zeke', 'Zoë', 'Åbjørn', 'Élana']"
msgstr ""
">>> from functools import partial\n"
">>> from unicodedata import normalize\n"
"\n"
">>> names = 'Zoë Åbjørn Núñez Élana Zeke Abe Nubia Eloise'.split()\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFD'))\n"
"['Abe', 'Åbjørn', 'Eloise', 'Élana', 'Nubia', 'Núñez', 'Zeke', 'Zoë']\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFC'))\n"
"['Abe', 'Eloise', 'Nubia', 'Núñez', 'Zeke', 'Zoë', 'Åbjørn', 'Élana']"

#: ../../howto/sorting.rst:153
msgid "Ascending and Descending"
msgstr "오름차순과 내림차순"

#: ../../howto/sorting.rst:155
msgid ""
"Both :meth:`list.sort` and :func:`sorted` accept a *reverse* parameter "
"with a boolean value. This is used to flag descending sorts. For example,"
" to get the student data in reverse *age* order:"
msgstr ""
":meth:`list.sort`\\와 :func:`sorted`\\는 모두 불리언 값을 갖는 *reverse* 매개 변수를 "
"받아들입니다. 내림차순 정렬을 지정하는 데 사용됩니다. 예를 들어, 학생 데이터를 역 *age* 순서로 얻으려면, 이렇게 합니다:"

#: ../../howto/sorting.rst:159
msgid ""
">>> sorted(student_tuples, key=itemgetter(2), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"
msgstr ""
">>> sorted(student_tuples, key=itemgetter(2), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"

#: ../../howto/sorting.rst:168
msgid "Sort Stability and Complex Sorts"
msgstr "정렬 안정성과 복잡한 정렬"

#: ../../howto/sorting.rst:170
msgid ""
"Sorts are guaranteed to be `stable "
"<https://en.wikipedia.org/wiki/Sorting_algorithm#Stability>`_\\. That "
"means that when multiple records have the same key, their original order "
"is preserved."
msgstr ""
"정렬은 `안정적 "
"<https://en.wikipedia.org/wiki/Sorting_algorithm#Stability>`_\\임이 보장됩니다. "
"즉, 여러 레코드가 같은 키를 가질 때, 원래의 순서가 유지됩니다."

#: ../../howto/sorting.rst:174
msgid ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> sorted(data, key=itemgetter(0))\n"
"[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]"
msgstr ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> sorted(data, key=itemgetter(0))\n"
"[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]"

#: ../../howto/sorting.rst:180
msgid ""
"Notice how the two records for *blue* retain their original order so that"
" ``('blue', 1)`` is guaranteed to precede ``('blue', 2)``."
msgstr ""
"*blue*\\에 대한 두 레코드가 원래 순서를 유지해서 ``('blue', 1)``\\이 ``('blue', 2)``\\보다 앞에"
" 나옴이 보장됨에 유의하십시오."

#: ../../howto/sorting.rst:183
msgid ""
"This wonderful property lets you build complex sorts in a series of "
"sorting steps. For example, to sort the student data by descending "
"*grade* and then ascending *age*, do the *age* sort first and then sort "
"again using *grade*:"
msgstr ""
"이 멋진 속성은 일련의 정렬 단계로 복잡한 정렬을 만들 수 있도록 합니다. 예를 들어, 학생 데이터를 *grade*\\의 "
"내림차순으로 정렬한 다음, *age*\\의 오름차순으로 정렬하려면, 먼저 *age* 정렬을 수행한 다음 *grade*\\를 사용하여"
" 다시 정렬합니다:"

#: ../../howto/sorting.rst:187
msgid ""
">>> s = sorted(student_objects, key=attrgetter('age'))     # sort on "
"secondary key\n"
">>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on "
"primary key, descending\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> s = sorted(student_objects, key=attrgetter('age'))     # 두 번째 키로 "
"정렬합니다\n"
">>> sorted(s, key=attrgetter('grade'), reverse=True)       # 이제 첫 번째 키로 "
"내림차순 정렬합니다\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:193
msgid ""
"This can be abstracted out into a wrapper function that can take a list "
"and tuples of field and order to sort them on multiple passes."
msgstr "이것은 다중 패스로 정렬하기 위해 필드와 순서의 튜플 리스트를 받을 수 있는 래퍼 함수로 추상화할 수 있습니다."

#: ../../howto/sorting.rst:196
msgid ""
">>> def multisort(xs, specs):\n"
"...     for key, reverse in reversed(specs):\n"
"...         xs.sort(key=attrgetter(key), reverse=reverse)\n"
"...     return xs\n"
"\n"
">>> multisort(list(student_objects), (('grade', True), ('age', False)))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> def multisort(xs, specs):\n"
"...     for key, reverse in reversed(specs):\n"
"...         xs.sort(key=attrgetter(key), reverse=reverse)\n"
"...     return xs\n"
"\n"
">>> multisort(list(student_objects), (('grade', True), ('age', False)))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:206
msgid ""
"The `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ algorithm used in "
"Python does multiple sorts efficiently because it can take advantage of "
"any ordering already present in a dataset."
msgstr ""
"파이썬에서 사용된 `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ 알고리즘은 데이터 "
"집합에 이미 존재하는 순서를 활용할 수 있으므로 효율적으로 여러 번의 정렬을 수행합니다."

#: ../../howto/sorting.rst:211
msgid "Decorate-Sort-Undecorate"
msgstr "장식-정렬-복원"

#: ../../howto/sorting.rst:213
msgid "This idiom is called Decorate-Sort-Undecorate after its three steps:"
msgstr "이 관용구는 그것의 세 단계를 따라 장식-정렬-복원(Decorate-Sort-Undecorate)이라고 합니다:"

#: ../../howto/sorting.rst:215
msgid ""
"First, the initial list is decorated with new values that control the "
"sort order."
msgstr "첫째, 초기 리스트가 정렬 순서를 제어하는 새로운 값으로 장식됩니다."

#: ../../howto/sorting.rst:217
msgid "Second, the decorated list is sorted."
msgstr "둘째, 장식된 리스트를 정렬합니다."

#: ../../howto/sorting.rst:219
msgid ""
"Finally, the decorations are removed, creating a list that contains only "
"the initial values in the new order."
msgstr "마지막으로, 장식을 제거하여, 새 순서로 초깃값만 포함하는 리스트를 만듭니다."

#: ../../howto/sorting.rst:222
msgid "For example, to sort the student data by *grade* using the DSU approach:"
msgstr "예를 들어, DSU 방식을 사용하여 *grade*\\로 학생 데이터를 정렬하려면 다음과 같이 합니다:"

#: ../../howto/sorting.rst:224
msgid ""
">>> decorated = [(student.grade, i, student) for i, student in "
"enumerate(student_objects)]\n"
">>> decorated.sort()\n"
">>> [student for grade, i, student in decorated]               # "
"undecorate\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"
msgstr ""
">>> decorated = [(student.grade, i, student) for i, student in "
"enumerate(student_objects)]\n"
">>> decorated.sort()\n"
">>> [student for grade, i, student in decorated]               # 복원\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"

#: ../../howto/sorting.rst:231
msgid ""
"This idiom works because tuples are compared lexicographically; the first"
" items are compared; if they are the same then the second items are "
"compared, and so on."
msgstr ""
"이 관용구는 튜플이 사전식으로 비교되기 때문에 작동합니다; 첫 번째 항목이 비교됩니다; 그들이 같으면 두 번째 항목이 비교되고, "
"이런 식으로 계속됩니다."

#: ../../howto/sorting.rst:235
msgid ""
"It is not strictly necessary in all cases to include the index *i* in the"
" decorated list, but including it gives two benefits:"
msgstr "모든 경우에 장식된 리스트에 인덱스 *i*\\를 포함할 필요는 없지만, 두 가지 이점이 있습니다:"

#: ../../howto/sorting.rst:238
msgid ""
"The sort is stable -- if two items have the same key, their order will be"
" preserved in the sorted list."
msgstr "정렬이 안정적입니다 -- 두 항목이 같은 키를 가지면, 그 들의 순서가 정렬된 리스트에 유지됩니다."

#: ../../howto/sorting.rst:241
msgid ""
"The original items do not have to be comparable because the ordering of "
"the decorated tuples will be determined by at most the first two items. "
"So for example the original list could contain complex numbers which "
"cannot be sorted directly."
msgstr ""
"장식된 튜플의 순서는 최대 처음 두 항목에 의해 결정되므로 원래 항목은 비교 가능할 필요가 없습니다. 그래서 예를 들어, 원래 "
"리스트에는 직접 정렬될 수 없는 복소수가 포함될 수 있습니다."

#: ../../howto/sorting.rst:246
msgid ""
"Another name for this idiom is `Schwartzian transform "
"<https://en.wikipedia.org/wiki/Schwartzian_transform>`_\\, after Randal "
"L. Schwartz, who popularized it among Perl programmers."
msgstr ""
"이 관용구의 또 다른 이름은 펄 프로그래머들 사이에서 이것을 대중화한 Randal L. Schwartz의 이름을 딴 "
"`Schwartzian 변환 "
"<https://en.wikipedia.org/wiki/Schwartzian_transform>`_\\입니다."

#: ../../howto/sorting.rst:250
msgid ""
"Now that Python sorting provides key-functions, this technique is not "
"often needed."
msgstr "이제 파이썬 정렬이 키 함수를 제공하기 때문에, 이 기법은 자주 필요하지 않습니다."

#: ../../howto/sorting.rst:253
msgid "Comparison Functions"
msgstr "비교 함수"

#: ../../howto/sorting.rst:255
msgid ""
"Unlike key functions that return an absolute value for sorting, a "
"comparison function computes the relative ordering for two inputs."
msgstr ""

#: ../../howto/sorting.rst:258
msgid ""
"For example, a `balance scale "
"<https://upload.wikimedia.org/wikipedia/commons/1/17/Balance_à_tabac_1850.JPG>`_"
" compares two samples giving a relative ordering: lighter, equal, or "
"heavier. Likewise, a comparison function such as ``cmp(a, b)`` will "
"return a negative value for less-than, zero if the inputs are equal, or a"
" positive value for greater-than."
msgstr ""

#: ../../howto/sorting.rst:265
msgid ""
"It is common to encounter comparison functions when translating "
"algorithms from other languages.  Also, some libraries provide comparison"
" functions as part of their API.  For example, :func:`locale.strcoll` is "
"a comparison function."
msgstr ""

#: ../../howto/sorting.rst:269
msgid ""
"To accommodate those situations, Python provides "
":class:`functools.cmp_to_key` to wrap the comparison function to make it "
"usable as a key function::"
msgstr ""

#: ../../howto/sorting.rst:273
msgid "sorted(words, key=cmp_to_key(strcoll))  # locale-aware sort order"
msgstr "sorted(words, key=cmp_to_key(strcoll))  # 로케일 인식 정렬 순서"

#: ../../howto/sorting.rst:276
msgid "Odds and Ends"
msgstr "잡동사니"

#: ../../howto/sorting.rst:278
msgid ""
"For locale aware sorting, use :func:`locale.strxfrm` for a key function "
"or :func:`locale.strcoll` for a comparison function.  This is necessary "
"because \"alphabetical\" sort orderings can vary across cultures even if "
"the underlying alphabet is the same."
msgstr ""
"로케일 인식 정렬의 경우, 키 함수로는 :func:`locale.strxfrm`\\를, 비교 함수로는 "
":func:`locale.strcoll`\\을 사용하십시오. 이는 하부 알파벳이 같더라도 문화권마다 \"알파벳순\" 정렬 순서가 "
"다를 수 있기 때문에 필요합니다."

#: ../../howto/sorting.rst:283
msgid ""
"The *reverse* parameter still maintains sort stability (so that records "
"with equal keys retain the original order). Interestingly, that effect "
"can be simulated without the parameter by using the builtin "
":func:`reversed` function twice:"
msgstr ""
"*reverse* 매개 변수는 여전히 정렬 안정성을 유지합니다 (그래서 같은 키를 갖는 레코드는 원래 순서를 유지합니다). "
"흥미롭게도, 그 효과는 내장 :func:`reversed` 함수를 두 번 사용하여 매개 변수 없이 흉내 낼 수 있습니다:"

#: ../../howto/sorting.rst:288
msgid ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> standard_way = sorted(data, key=itemgetter(0), reverse=True)\n"
">>> double_reversed = list(reversed(sorted(reversed(data), "
"key=itemgetter(0))))\n"
">>> assert standard_way == double_reversed\n"
">>> standard_way\n"
"[('red', 1), ('red', 2), ('blue', 1), ('blue', 2)]"
msgstr ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> standard_way = sorted(data, key=itemgetter(0), reverse=True)\n"
">>> double_reversed = list(reversed(sorted(reversed(data), "
"key=itemgetter(0))))\n"
">>> assert standard_way == double_reversed\n"
">>> standard_way\n"
"[('red', 1), ('red', 2), ('blue', 1), ('blue', 2)]"

#: ../../howto/sorting.rst:297
msgid ""
"The sort routines use ``<`` when making comparisons between two objects. "
"So, it is easy to add a standard sort order to a class by defining an "
":meth:`~object.__lt__` method:"
msgstr ""
"정렬 루틴은 두 객체를 비교할 때 ``<``\\를 사용합니다. 따라서 :meth:`~object.__lt__` 메서드를 정의하여, "
"표준 정렬 순서를 클래스에 추가하기는 쉽습니다:"

#: ../../howto/sorting.rst:301
msgid ""
">>> Student.__lt__ = lambda self, other: self.age < other.age\n"
">>> sorted(student_objects)\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> Student.__lt__ = lambda self, other: self.age < other.age\n"
">>> sorted(student_objects)\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

#: ../../howto/sorting.rst:307
msgid ""
"However, note that ``<`` can fall back to using :meth:`~object.__gt__` if"
" :meth:`~object.__lt__` is not implemented (see :func:`object.__lt__` for"
" details on the mechanics).  To avoid surprises, :pep:`8` recommends that"
" all six comparison methods be implemented. The "
":func:`~functools.total_ordering` decorator is provided to make that task"
" easier."
msgstr ""

#: ../../howto/sorting.rst:314
msgid ""
"Key functions need not depend directly on the objects being sorted. A key"
" function can also access external resources. For instance, if the "
"student grades are stored in a dictionary, they can be used to sort a "
"separate list of student names:"
msgstr ""
"키 함수는 정렬되는 객체에 직접 의존할 필요가 없습니다. 키 함수는 외부 자원에 액세스할 수도 있습니다. 예를 들어, 학생 성적이 "
"딕셔너리에 저장되어 있다면, 학생 이름의 별도 리스트를 정렬하는 데 사용할 수 있습니다:"

#: ../../howto/sorting.rst:319
#, python-brace-format
msgid ""
">>> students = ['dave', 'john', 'jane']\n"
">>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}\n"
">>> sorted(students, key=newgrades.__getitem__)\n"
"['jane', 'dave', 'john']"
msgstr ""
">>> students = ['dave', 'john', 'jane']\n"
">>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}\n"
">>> sorted(students, key=newgrades.__getitem__)\n"
"['jane', 'dave', 'john']"

#: ../../howto/sorting.rst:327
msgid "Partial Sorts"
msgstr ""

#: ../../howto/sorting.rst:329
msgid ""
"Some applications require only some of the data to be ordered.  The "
"standard library provides several tools that do less work than a full "
"sort:"
msgstr ""

#: ../../howto/sorting.rst:332
msgid ""
":func:`min` and :func:`max` return the smallest and largest values, "
"respectively.  These functions make a single pass over the input data and"
" require almost no auxiliary memory."
msgstr ""

#: ../../howto/sorting.rst:336
msgid ""
":func:`heapq.nsmallest` and :func:`heapq.nlargest` return the *n* "
"smallest and largest values, respectively.  These functions make a single"
" pass over the data keeping only *n* elements in memory at a time.  For "
"values of *n* that are small relative to the number of inputs, these "
"functions make far fewer comparisons than a full sort."
msgstr ""

#: ../../howto/sorting.rst:342
msgid ""
":func:`heapq.heappush` and :func:`heapq.heappop` create and maintain a "
"partially sorted arrangement of data that keeps the smallest element at "
"position ``0``.  These functions are suitable for implementing priority "
"queues which are commonly used for task scheduling."
msgstr ""

#~ msgid "Release"
#~ msgstr "배포"

#~ msgid "0.1"
#~ msgstr "0.1"

#~ msgid "The Old Way Using the *cmp* Parameter"
#~ msgstr "*cmp* 매개 변수를 사용하는 낡은 방법"

#~ msgid ""
#~ "Many constructs given in this HOWTO "
#~ "assume Python 2.4 or later. Before "
#~ "that, there was no :func:`sorted` "
#~ "builtin and :meth:`list.sort` took no "
#~ "keyword arguments. Instead, all of the"
#~ " Py2.x versions supported a *cmp* "
#~ "parameter to handle user specified "
#~ "comparison functions."
#~ msgstr ""
#~ "이 HOWTO에서 제공하는 많은 구문은 파이썬 2.4 "
#~ "이상을 가정합니다. 그전에는, :func:`sorted` 내장 함수가"
#~ " 없었으며 :meth:`list.sort`\\는 키워드 인자를 취하지 "
#~ "않았습니다. 대신, 모든 Py2.x 버전은 사용자 지정 "
#~ "비교 함수를 처리하기 위해 *cmp* 매개 변수를 "
#~ "지원했습니다."

#~ msgid ""
#~ "In Py3.0, the *cmp* parameter was "
#~ "removed entirely (as part of a "
#~ "larger effort to simplify and unify "
#~ "the language, eliminating the conflict "
#~ "between rich comparisons and the "
#~ ":meth:`__cmp__` magic method)."
#~ msgstr ""
#~ "Py3.0에서는, *cmp* 매개 변수가 완전히 제거되었습니다 "
#~ "(언어를 단순화하고 통합하기 위한 노력의 일환으로, 풍부한"
#~ " 비교(rich comparisons)와 :meth:`__cmp__` 매직 "
#~ "메서드 간의 충돌을 제거했습니다)."

#~ msgid ""
#~ "In Py2.x, sort allowed an optional "
#~ "function which can be called for "
#~ "doing the comparisons. That function "
#~ "should take two arguments to be "
#~ "compared and then return a negative "
#~ "value for less-than, return zero "
#~ "if they are equal, or return a "
#~ "positive value for greater-than. For "
#~ "example, we can do:"
#~ msgstr ""
#~ "Py2.x에서, sort는 비교 작업을 위해 호출할 수 "
#~ "있는 선택적 함수를 허용했습니다. 이 함수는 비교할 "
#~ "두 개의 인자를 취한 다음, 첫 번째가 두 "
#~ "번째보다 작으면(less-than) 음수 값을 반환하고, "
#~ "같으면 0을 반환하고, 크면(greater-than) 양수 "
#~ "값을 반환해야 합니다. 예를 들어, 다음과 같이 할"
#~ " 수 있습니다:"

#~ msgid "Or you can reverse the order of comparison with:"
#~ msgstr "또는 비교 순서를 다음과 같이 뒤집을 수 있습니다:"

#~ msgid ""
#~ "When porting code from Python 2.x "
#~ "to 3.x, the situation can arise "
#~ "when you have the user supplying a"
#~ " comparison function and you need to"
#~ " convert that to a key function. "
#~ "The following wrapper makes that easy"
#~ " to do::"
#~ msgstr ""
#~ "파이썬 2.x에서 3.x로 코드를 이식할 때, 사용자가 "
#~ "비교 함수를 제공하고 이를 키 함수로 변환해야 하는"
#~ " 상황이 발생할 수 있습니다. 다음 래퍼를 사용하면"
#~ " 쉽게 할 수 있습니다::"

#~ msgid "To convert to a key function, just wrap the old comparison function:"
#~ msgstr "키 함수로 변환하려면, 단지 이전 비교 함수를 감싸면 됩니다:"

#~ msgid ""
#~ "In Python 3.2, the "
#~ ":func:`functools.cmp_to_key` function was added "
#~ "to the :mod:`functools` module in the"
#~ " standard library."
#~ msgstr ""
#~ "파이썬 3.2에서, :func:`functools.cmp_to_key` 함수가 표준"
#~ " 라이브러리의 :mod:`functools` 모듈에 추가되었습니다."

