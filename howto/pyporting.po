# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/pyporting.rst:7
#, fuzzy
msgid "How to port Python 2 Code to Python 3"
msgstr "파이썬 2 코드를 파이썬 3으로 이식하기"

#: ../../howto/pyporting.rst
msgid "author"
msgstr "저자"

#: ../../howto/pyporting.rst:9
msgid "Brett Cannon"
msgstr "Brett Cannon"

#: ../../howto/pyporting.rst:11
msgid ""
"Python 2 reached its official end-of-life at the start of 2020. This "
"means that no new bug reports, fixes, or changes will be made to Python 2"
" - it's no longer supported: see :pep:`373` and `status of Python "
"versions <https://devguide.python.org/versions>`_."
msgstr ""

#: ../../howto/pyporting.rst:16
msgid ""
"If you are looking to port an extension module instead of pure Python "
"code, please see :ref:`cporting-howto`."
msgstr "순수 파이썬 코드 대신 확장 모듈을 이식하려고 한다면 :ref:`cporting-howto`\\를 참조하십시오."

#: ../../howto/pyporting.rst:19
msgid ""
"The archived python-porting_ mailing list may contain some useful "
"guidance."
msgstr ""

#: ../../howto/pyporting.rst:21
msgid ""
"Since Python 3.11 the original porting guide was discontinued. You can "
"find the old guide in the `archive "
"<https://docs.python.org/3.10/howto/pyporting.html>`_."
msgstr ""

#: ../../howto/pyporting.rst:27
msgid "Third-party guides"
msgstr ""

#: ../../howto/pyporting.rst:29
msgid "There are also multiple third-party guides that might be useful:"
msgstr ""

#: ../../howto/pyporting.rst:31
msgid "`Guide by Fedora <https://portingguide.readthedocs.io>`_"
msgstr ""

#: ../../howto/pyporting.rst:32
msgid "`PyCon 2020 tutorial <https://www.youtube.com/watch?v=JgIgEjASOlk>`_"
msgstr ""

#: ../../howto/pyporting.rst:33
msgid ""
"`Guide by DigitalOcean <https://www.digitalocean.com/community/tutorials"
"/how-to-port-python-2-code-to-python-3>`_"
msgstr ""

#: ../../howto/pyporting.rst:34
msgid ""
"`Guide by ActiveState <https://www.activestate.com/blog/how-to-migrate-"
"python-2-applications-to-python-3>`_"
msgstr ""

#~ msgid "Abstract"
#~ msgstr "요약"

#~ msgid ""
#~ "With Python 3 being the future of"
#~ " Python while Python 2 is still "
#~ "in active use, it is good to "
#~ "have your project available for both "
#~ "major releases of Python. This guide "
#~ "is meant to help you figure out"
#~ " how best to support both Python "
#~ "2 & 3 simultaneously."
#~ msgstr ""
#~ "파이썬 3이 파이썬의 미래이지만 파이썬 2가 여전히 "
#~ "활발하게 사용되고 있기 때문에, 두 가지 주요 "
#~ "파이썬 릴리스에서 프로젝트를 사용할 수 있게 하는 "
#~ "것이 좋습니다. 이 안내서는 파이썬 2와 3을 "
#~ "동시에 지원하는 가장 좋은 방법을 찾는 데 도움을"
#~ " 주려고 합니다."

#~ msgid ""
#~ "If you would like to read one "
#~ "core Python developer's take on why "
#~ "Python 3 came into existence, you "
#~ "can read Nick Coghlan's `Python 3 "
#~ "Q & A`_ or Brett Cannon's `Why "
#~ "Python 3 exists`_."
#~ msgstr ""
#~ "파이썬 3이 왜 등장했는지에 대한 핵심 파이썬 "
#~ "개발자의 글을 읽고 싶다면, Nick Coghlan의 "
#~ "`Python 3 Q & A`_\\나 Brett Cannon의"
#~ " `Why Python 3 exists`_\\를 추천합니다."

#~ msgid ""
#~ "For help with porting, you can "
#~ "email the python-porting_ mailing list"
#~ " with questions."
#~ msgstr "이식에 도움이 필요하면, python-porting_ 메일링 리스트에 질문을 전자 우편으로 보낼 수 있습니다."

#~ msgid "The Short Explanation"
#~ msgstr "짧은 설명"

#~ msgid ""
#~ "To make your project be single-"
#~ "source Python 2/3 compatible, the basic"
#~ " steps are:"
#~ msgstr "프로젝트를 단일 소스 파이썬 2/3 호환으로 만들려면, 기본 단계는 다음과 같습니다:"

#~ msgid "Only worry about supporting Python 2.7"
#~ msgstr "파이썬 2.7 지원만 신경 쓰십시오"

#~ msgid ""
#~ "Make sure you have good test "
#~ "coverage (coverage.py_ can help; ``python "
#~ "-m pip install coverage``)"
#~ msgstr ""
#~ "테스트 커버리지가 양호한지 확인하십시오 (coverage.py_\\가 "
#~ "도움이 될 수 있습니다; ``python -m pip "
#~ "install coverage``)"

#~ msgid "Learn the differences between Python 2 & 3"
#~ msgstr "파이썬 2와 3의 차이점을 공부하십시오"

#~ msgid ""
#~ "Use Futurize_ (or Modernize_) to update"
#~ " your code (e.g. ``python -m pip "
#~ "install future``)"
#~ msgstr ""
#~ "Futurize_\\(또는 Modernize_)를 사용하여 코드를 갱신하십시오"
#~ " (예를 들어 ``python -m pip install "
#~ "future``)"

#~ msgid ""
#~ "Use Pylint_ to help make sure you"
#~ " don't regress on your Python 3 "
#~ "support (``python -m pip install "
#~ "pylint``)"
#~ msgstr ""
#~ "Pylint_\\를 사용하여 파이썬 3 지원의 회귀 테스트가"
#~ " 실패하지 않도록 점검하십시오 (``python -m pip "
#~ "install pylint``)"

#~ msgid ""
#~ "Use caniusepython3_ to find out which"
#~ " of your dependencies are blocking "
#~ "your use of Python 3 (``python -m"
#~ " pip install caniusepython3``)"
#~ msgstr ""
#~ "caniusepython3_\\을 사용하여 파이썬 3 사용을 막는 "
#~ "의존성(dependencies)을 찾으십시오 (``python -m pip "
#~ "install caniusepython3``)"

#~ msgid ""
#~ "Once your dependencies are no longer "
#~ "blocking you, use continuous integration "
#~ "to make sure you stay compatible "
#~ "with Python 2 & 3 (tox_ can "
#~ "help test against multiple versions of"
#~ " Python; ``python -m pip install "
#~ "tox``)"
#~ msgstr ""
#~ "일단 의존성이 더는 여러분을 막지 않으면, 지속적인 "
#~ "통합을 사용하여 파이썬 2 & 3과의 호환성을 "
#~ "유지하십시오 (tox_\\는 여러 버전의 파이썬에서 테스트하는 "
#~ "데 도움이 됩니다; ``python -m pip install"
#~ " tox``)"

#~ msgid ""
#~ "Consider using optional static type "
#~ "checking to make sure your type "
#~ "usage works in both Python 2 & "
#~ "3 (e.g. use mypy_ to check your"
#~ " typing under both Python 2 & "
#~ "Python 3; ``python -m pip install "
#~ "mypy``)."
#~ msgstr ""
#~ "선택적으로 정적 형 검사를 사용하여 형 사용이 "
#~ "파이썬 2와 3에서 모두 작동하는지 확인하십시오 (예를 "
#~ "들어 mypy_\\를 사용하여 파이썬 2와 파이썬 3 "
#~ "모두에서 형 사용을 검사하십시오; ``python -m pip"
#~ " install mypy``)."

#~ msgid ""
#~ "Note: Using ``python -m pip install``"
#~ " guarantees that the ``pip`` you "
#~ "invoke is the one installed for "
#~ "the Python currently in use, whether "
#~ "it be a system-wide ``pip`` or "
#~ "one installed within a :ref:`virtual "
#~ "environment <tut-venv>`."
#~ msgstr ""
#~ "참고: ``python -m pip install``\\를 사용하면"
#~ " 호출하는 ``pip``\\가 시스템 전체 ``pip``\\이든 "
#~ ":ref:`가상 환경 <tut-venv>` 내에 설치된 "
#~ "``pip``\\이든 현재 사용 중인 파이썬을 위해 설치된"
#~ " ``pip``\\임이 보장됩니다."

#~ msgid "Details"
#~ msgstr "세부 사항"

#~ msgid ""
#~ "A key point about supporting Python "
#~ "2 & 3 simultaneously is that you"
#~ " can start **today**! Even if your"
#~ " dependencies are not supporting Python "
#~ "3 yet that does not mean you "
#~ "can't modernize your code **now** to "
#~ "support Python 3. Most changes required"
#~ " to support Python 3 lead to "
#~ "cleaner code using newer practices even"
#~ " in Python 2 code."
#~ msgstr ""
#~ "파이썬 2와 3을 동시에 지원하는 것에 대한 요점은"
#~ " **오늘** 시작할 수 있다는 것입니다! 의존성이 아직"
#~ " 파이썬 3을 지원하지 않을 때조차 여러분의 코드를"
#~ " 파이썬 3을 지원하도록 **지금** 현대화할 수 없다는"
#~ " 뜻은 아닙니다. 파이썬 3을 지원하는데 필요한 대부분의"
#~ " 변경은 파이썬 2 코드에서도 새로운 방법을 사용하여"
#~ " 더 깔끔한 코드를 만듭니다."

#~ msgid ""
#~ "Another key point is that modernizing"
#~ " your Python 2 code to also "
#~ "support Python 3 is largely automated"
#~ " for you. While you might have "
#~ "to make some API decisions thanks "
#~ "to Python 3 clarifying text data "
#~ "versus binary data, the lower-level "
#~ "work is now mostly done for you"
#~ " and thus can at least benefit "
#~ "from the automated changes immediately."
#~ msgstr ""
#~ "또 다른 요점은 파이썬 3도 지원하도록 파이썬 2"
#~ " 코드를 현대화하는 것이 대부분 자동화되어 있다는 "
#~ "것입니다. 여러분이 일부 API 결정을 내려야 할 "
#~ "수도 있지만, 텍스트 데이터와 바이너리 데이터를 명확히 "
#~ "구분하는 파이썬 3 덕분에, 이제 저수준 작업이 "
#~ "대부분 수행되므로 최소한 자동 변경의 이점을 즉시 "
#~ "누릴 수 있습니다."

#~ msgid ""
#~ "Keep those key points in mind "
#~ "while you read on about the "
#~ "details of porting your code to "
#~ "support Python 2 & 3 simultaneously."
#~ msgstr "파이썬 2와 3을 동시에 지원하기 위해 코드를 이식하는 것에 대한 자세한 내용을 읽는 동안 이러한 요점을 명심하십시오."

#~ msgid "Drop support for Python 2.6 and older"
#~ msgstr "파이썬 2.6 이하에 대한 지원을 중단하십시오"

#~ msgid ""
#~ "While you can make Python 2.5 work"
#~ " with Python 3, it is **much** "
#~ "easier if you only have to work"
#~ " with Python 2.7. If dropping Python"
#~ " 2.5 is not an option then the"
#~ " six_ project can help you support"
#~ " Python 2.5 & 3 simultaneously "
#~ "(``python -m pip install six``). Do "
#~ "realize, though, that nearly all the "
#~ "projects listed in this HOWTO will "
#~ "not be available to you."
#~ msgstr ""
#~ "파이썬 2.5를 파이썬 3에서 동작하게 만들 수 "
#~ "있지만, 파이썬 2.7만 지원한다면 **훨씬** 쉽습니다. "
#~ "파이썬 2.5를 포기하는 것이 옵션이 아니면 six_ "
#~ "프로젝트를 사용해서 파이썬 2.5와 3을 동시에 지원할 "
#~ "수 있습니다 (``python -m pip install "
#~ "six``). 그러나 이 HOWTO에 나열된 거의 모든 "
#~ "프로젝트를 이용할 수 없다는 것을 알고 계십시오."

#~ msgid ""
#~ "If you are able to skip Python "
#~ "2.5 and older, then the required "
#~ "changes to your code should continue "
#~ "to look and feel like idiomatic "
#~ "Python code. At worst you will "
#~ "have to use a function instead of"
#~ " a method in some instances or "
#~ "have to import a function instead "
#~ "of using a built-in one, but "
#~ "otherwise the overall transformation should"
#~ " not feel foreign to you."
#~ msgstr ""
#~ "파이썬 2.5와 그 이전 버전을 무시할 수 있다면,"
#~ " 코드에 필요한 변경 사항은 계속 관용적인 파이썬 "
#~ "코드처럼 보이고 느껴져야 합니다. 최악의 경우 일부 "
#~ "인스턴스에서 메서드 대신 함수를 사용해야 하거나 내장 "
#~ "함수를 사용하는 대신 함수를 임포트 해야 하지만, "
#~ "그 외에는 전체적인 변환이 이질적으로 느껴지지 않아야 "
#~ "합니다."

#~ msgid ""
#~ "But you should aim for only "
#~ "supporting Python 2.7. Python 2.6 is "
#~ "no longer freely supported and thus "
#~ "is not receiving bugfixes. This means"
#~ " **you** will have to work around "
#~ "any issues you come across with "
#~ "Python 2.6. There are also some "
#~ "tools mentioned in this HOWTO which "
#~ "do not support Python 2.6 (e.g., "
#~ "Pylint_), and this will become more "
#~ "commonplace as time goes on. It "
#~ "will simply be easier for you if"
#~ " you only support the versions of "
#~ "Python that you have to support."
#~ msgstr ""
#~ "그러나 파이썬 2.7만 지원해야 합니다. 파이썬 2.6은"
#~ " 더는 무료로 지원되지 않아서 버그 수정이 없습니다."
#~ " 이것은 여러분이 만나는 파이썬 2.6의 문제를 "
#~ "**여러분이** 해결해야 한다는 뜻입니다. 이 HOWTO에서 "
#~ "언급하는 몇 가지 도구는 파이썬 2.6을 지원하지 "
#~ "않기도 하고 (예를 들어 Pylint_), 시간이 지남에"
#~ " 따라 더 늘어날 것입니다. 지원해야만 하는 파이썬"
#~ " 버전만 지원하는 것이 더 쉬울 것입니다."

#~ msgid ""
#~ "Make sure you specify the proper "
#~ "version support in your ``setup.py`` "
#~ "file"
#~ msgstr "``setup.py`` 파일에서 올바른 버전 지원을 지정했는지 확인하십시오"

#~ msgid ""
#~ "In your ``setup.py`` file you should "
#~ "have the proper `trove classifier`_ "
#~ "specifying what versions of Python you"
#~ " support. As your project does not"
#~ " support Python 3 yet you should "
#~ "at least have ``Programming Language ::"
#~ " Python :: 2 :: Only`` specified. "
#~ "Ideally you should also specify each "
#~ "major/minor version of Python that you"
#~ " do support, e.g. ``Programming Language"
#~ " :: Python :: 2.7``."
#~ msgstr ""
#~ "``setup.py`` 파일에는 여러분이 지원하는 파이썬 버전을 "
#~ "지정하는 적절한 `trove 분류 <trove "
#~ "classifier_>`_\\가 있어야 합니다. 여러분의 프로젝트가 아직"
#~ " 파이썬 3을 지원하지 않기 때문에 최소한 "
#~ "``Programming Language :: Python :: 2"
#~ " :: Only``\\를 지정해야 합니다. 이상적으로는 지원하는"
#~ " 각 주/부 버전의 파이썬을 지정해야 합니다, 예를"
#~ " 들어 ``Programming Language :: Python "
#~ ":: 2.7``."

#~ msgid "Have good test coverage"
#~ msgstr "양호한 테스트 커버리지를 갖추십시오"

#~ msgid ""
#~ "Once you have your code supporting "
#~ "the oldest version of Python 2 you"
#~ " want it to, you will want to"
#~ " make sure your test suite has "
#~ "good coverage. A good rule of "
#~ "thumb is that if you want to "
#~ "be confident enough in your test "
#~ "suite that any failures that appear "
#~ "after having tools rewrite your code "
#~ "are actual bugs in the tools and"
#~ " not in your code. If you want"
#~ " a number to aim for, try to"
#~ " get over 80% coverage (and don't "
#~ "feel bad if you find it hard "
#~ "to get better than 90% coverage). "
#~ "If you don't already have a tool"
#~ " to measure test coverage then "
#~ "coverage.py_ is recommended."
#~ msgstr ""
#~ "일단 여러분이 원하는 가장 오래된 파이썬 2 버전을"
#~ " 지원하는 코드를 확보하면, 테스트 스위트가 양호한 "
#~ "커버리지를 갖는지 확인해야 합니다. 경험 규칙은 도구가 "
#~ "코드를 다시 작성한 후 나타나는 실패가 여러분의 "
#~ "코드가 아니라 도구에 있는 실제 버그라는 확신을 "
#~ "가질 만큼 테스트 스위트를 신뢰할 수 있는 "
#~ "수준입니다. 목표로 할 숫자가 필요하다면, 80% 이상의"
#~ " 커버리지를 시도하십시오 (그리고 90% 이상의 커버리지를 "
#~ "얻기 어려워도 실망하지 마십시오). 테스트 커버리지를 측정하는"
#~ " 도구가 없으면 coverage.py_\\를 추천합니다."

#~ msgid ""
#~ "Once you have your code well-"
#~ "tested you are ready to begin "
#~ "porting your code to Python 3! But"
#~ " to fully understand how your code"
#~ " is going to change and what "
#~ "you want to look out for while "
#~ "you code, you will want to learn"
#~ " what changes Python 3 makes in "
#~ "terms of Python 2. Typically the "
#~ "two best ways of doing that is "
#~ "reading the :ref:`\"What's New\" <whatsnew-"
#~ "index>` doc for each release of "
#~ "Python 3 and the `Porting to "
#~ "Python 3`_ book (which is free "
#~ "online). There is also a handy "
#~ "`cheat sheet`_ from the Python-Future"
#~ " project."
#~ msgstr ""
#~ "코드를 잘 테스트했으면, 코드를 파이썬 3으로 이식할 "
#~ "준비가 되었습니다! 그러나 코드가 어떻게 변경되고 코드를"
#~ " 작성하는 동안 무엇을 살펴야 하는지 완전히 이해하려면,"
#~ " 파이썬 3이 파이썬 2에 어떤 변경을 가했는지 "
#~ "배우고 싶을 것입니다. 일반적으로 가장 좋은 두 "
#~ "가지 방법은 각 파이썬 3 릴리스의 :ref:`\"새로운"
#~ " 기능\" <whatsnew-index>` 문서와 `Porting "
#~ "to Python 3`_ 책(온라인에서 무료로 제공됩니다)을 "
#~ "읽는 것입니다. Python-Future 프로젝트의 편리한 "
#~ "`cheat sheet`_\\도 있습니다."

#~ msgid "Update your code"
#~ msgstr "여러분의 코드를 갱신하십시오"

#~ msgid ""
#~ "Once you feel like you know what"
#~ " is different in Python 3 compared"
#~ " to Python 2, it's time to "
#~ "update your code! You have a "
#~ "choice between two tools in porting "
#~ "your code automatically: Futurize_ and "
#~ "Modernize_. Which tool you choose will"
#~ " depend on how much like Python "
#~ "3 you want your code to be. "
#~ "Futurize_ does its best to make "
#~ "Python 3 idioms and practices exist "
#~ "in Python 2, e.g. backporting the "
#~ "``bytes`` type from Python 3 so "
#~ "that you have semantic parity between"
#~ " the major versions of Python. "
#~ "Modernize_, on the other hand, is "
#~ "more conservative and targets a Python"
#~ " 2/3 subset of Python, directly "
#~ "relying on six_ to help provide "
#~ "compatibility. As Python 3 is the "
#~ "future, it might be best to "
#~ "consider Futurize to begin adjusting to"
#~ " any new practices that Python 3 "
#~ "introduces which you are not accustomed"
#~ " to yet."
#~ msgstr ""
#~ "일단 파이썬 3과 파이썬 2의 차이점이 무엇인지 "
#~ "안다고 느끼면, 코드를 갱신할 차례입니다! 여러분의 코드를"
#~ " 자동으로 이식하는 두 가지 도구 중에서 선택할 "
#~ "수 있습니다: Futurize_\\와 Modernize_. 어떤 도구를"
#~ " 선택하느냐는 여러분의 코드를 얼마나 파이썬 3 답게"
#~ " 만들고 싶은지에 달려 있습니다. Futurize_\\는 파이썬"
#~ " 3 관용구와 관행을 파이썬 2에 존재하도록 만들기"
#~ " 위해 최선을 다합니다, 예를 들어 파이썬 3의 "
#~ "``bytes`` 형을 역 이식하여 파이썬의 주 버전 "
#~ "간에 의미론적 일치가 이루어지도록 합니다. 반면 "
#~ "Modernize_\\는 더 보수적이며 호환성을 제공하기 위해 "
#~ "six_\\에 직접 의존하면서 파이썬의 파이썬 2/3 부분"
#~ " 집합을 타깃으로 합니다. 파이썬 3이 미래이기 때문에,"
#~ " 아직 익숙하지 않은 파이썬 3이 도입한 새로운 "
#~ "관행에 적응하기 시작하려면 Futurize를 고려하는 것이 "
#~ "가장 좋습니다."

#~ msgid ""
#~ "Regardless of which tool you choose, "
#~ "they will update your code to run"
#~ " under Python 3 while staying "
#~ "compatible with the version of Python"
#~ " 2 you started with. Depending on "
#~ "how conservative you want to be, "
#~ "you may want to run the tool "
#~ "over your test suite first and "
#~ "visually inspect the diff to make "
#~ "sure the transformation is accurate. "
#~ "After you have transformed your test "
#~ "suite and verified that all the "
#~ "tests still pass as expected, then "
#~ "you can transform your application code"
#~ " knowing that any tests which fail"
#~ " is a translation failure."
#~ msgstr ""
#~ "어떤 도구를 선택하든, 파이썬 3에서 실행되도록 코드를 "
#~ "갱신하면서 여러분이 시작한 파이썬 2 버전과 호환되도록 "
#~ "유지합니다. 여러분이 얼마나 보수적으로 되고 싶은지에 따라,"
#~ " 먼저 테스트 스위트에 도구를 실행하고 diff를 "
#~ "시각적으로 검사하여 변환이 정확한지 확인하고 싶을 수 "
#~ "있습니다. 테스트 스위트를 변환하고 모든 테스트가 여전히"
#~ " 예상대로 통과되는지 확인한 후에는, 실패한 모든 "
#~ "테스트가 변환 실패임을 아는 상태에서 응용 프로그램 "
#~ "코드를 변환할 수 있습니다."

#~ msgid ""
#~ "Unfortunately the tools can't automate "
#~ "everything to make your code work "
#~ "under Python 3 and so there are"
#~ " a handful of things you will "
#~ "need to update manually to get "
#~ "full Python 3 support (which of "
#~ "these steps are necessary vary between"
#~ " the tools). Read the documentation "
#~ "for the tool you choose to use "
#~ "to see what it fixes by default"
#~ " and what it can do optionally "
#~ "to know what will (not) be fixed"
#~ " for you and what you may have"
#~ " to fix on your own (e.g. using"
#~ " ``io.open()`` over the built-in "
#~ "``open()`` function is off by default"
#~ " in Modernize). Luckily, though, there "
#~ "are only a couple of things to "
#~ "watch out for which can be "
#~ "considered large issues that may be "
#~ "hard to debug if not watched for."
#~ msgstr ""
#~ "불행히도 도구가 파이썬 3에서 코드가 작동하도록 모든 "
#~ "것을 자동화할 수는 없기 때문에, 완전한 파이썬 3"
#~ " 지원을 얻기 위해 수동으로 갱신해야 하는 몇 "
#~ "가지 사항이 있습니다 (이 단계의 어떤 것이 "
#~ "필요한지는 도구마다 다릅니다). 어떤 것이 자동으로 수정되고"
#~ " (또는 되지 않고) 어떤 것을 여러분이 직접 "
#~ "수정해야 하는지 알기 위해, 기본적으로 수정되는 것과 "
#~ "선택적으로 수정되는 것에 대해 여러분이 선택한 도구의 "
#~ "설명서를 읽으십시오 (예를 들어 Modernize에서는 내장 "
#~ "``open()`` 함수 대신 ``io.open()``\\을 사용하는 "
#~ "것은 기본적으로 꺼져 있습니다). 다행히, 주의하지 않으면"
#~ " 디버깅하기 어려운 큰 문제로 간주할 수 있는 "
#~ "주의해야 할 사항은 몇 가지뿐입니다."

#~ msgid "Division"
#~ msgstr "나누기"

#~ msgid ""
#~ "In Python 3, ``5 / 2 == "
#~ "2.5`` and not ``2``; all division "
#~ "between ``int`` values result in a "
#~ "``float``. This change has actually been"
#~ " planned since Python 2.2 which was"
#~ " released in 2002. Since then users"
#~ " have been encouraged to add ``from"
#~ " __future__ import division`` to any "
#~ "and all files which use the ``/``"
#~ " and ``//`` operators or to be "
#~ "running the interpreter with the ``-Q``"
#~ " flag. If you have not been "
#~ "doing this then you will need to"
#~ " go through your code and do "
#~ "two things:"
#~ msgstr ""
#~ "파이썬 3에서, ``5 / 2 == 2.5``\\이고 "
#~ "``2``\\가 아닙니다; ``int`` 값 간의 모든 "
#~ "나누기는 ``float``\\가 됩니다. 이 변경은 실제로는 "
#~ "2002년에 릴리스 된 파이썬 2.2부터 계획되었습니다. "
#~ "그때부터 ``/``\\와 ``//`` 연산자를 사용하는 모든 "
#~ "파일에 ``from __future__ import division``\\을 "
#~ "추가하거나 ``-Q`` 플래그로 인터프리터를 실행하도록 권장되었습니다."
#~ " 이 작업을 수행하지 않았으면 코드를 살펴보고 두 "
#~ "가지 작업을 수행해야 합니다:"

#~ msgid "Add ``from __future__ import division`` to your files"
#~ msgstr "여러분의 파일에 ``from __future__ import division``\\을 추가하십시오"

#~ msgid ""
#~ "Update any division operator as "
#~ "necessary to either use ``//`` to "
#~ "use floor division or continue using "
#~ "``/`` and expect a float"
#~ msgstr ""
#~ "``//``\\를 사용하여 정수 나눗셈을 사용하거나 ``/``\\를"
#~ " 계속 사용하고 float를 기대하도록 필요에 따라 "
#~ "나눗셈 연산자를 갱신하십시오"

#~ msgid ""
#~ "The reason that ``/`` isn't simply "
#~ "translated to ``//`` automatically is "
#~ "that if an object defines a "
#~ "``__truediv__`` method but not "
#~ "``__floordiv__`` then your code would "
#~ "begin to fail (e.g. a user-defined"
#~ " class that uses ``/`` to signify "
#~ "some operation but not ``//`` for "
#~ "the same thing or at all)."
#~ msgstr ""
#~ "``/``\\가 단순히 ``//``\\로 자동 변환되지 않는 "
#~ "이유는 객체가 ``__truediv__`` 메서드를 정의하지만 "
#~ "``__floordiv__``\\를 정의하지 않으면 코드가 실패하기 "
#~ "시작하기 때문입니다 (예를 들어 ``/``\\를 사용하여 일부"
#~ " 작업을 나타내지만 ``//``\\로는 같은 것을 하지 "
#~ "않거나 아예 지원하지 않는 사용자 정의 클래스)."

#~ msgid "Text versus binary data"
#~ msgstr "텍스트 대 바이너리 데이터"

#~ msgid ""
#~ "In Python 2 you could use the "
#~ "``str`` type for both text and "
#~ "binary data. Unfortunately this confluence "
#~ "of two different concepts could lead "
#~ "to brittle code which sometimes worked"
#~ " for either kind of data, sometimes"
#~ " not. It also could lead to "
#~ "confusing APIs if people didn't "
#~ "explicitly state that something that "
#~ "accepted ``str`` accepted either text or"
#~ " binary data instead of one specific"
#~ " type. This complicated the situation "
#~ "especially for anyone supporting multiple "
#~ "languages as APIs wouldn't bother "
#~ "explicitly supporting ``unicode`` when they"
#~ " claimed text data support."
#~ msgstr ""
#~ "파이썬 2에서는 텍스트와 바이너리 데이터 모두에 ``str``"
#~ " 형을 사용할 수 있습니다. 불행히도 이 두 "
#~ "가지 다른 개념의 합류로 인해 때로는 두 유형의"
#~ " 데이터 모두에서 동작하고 때로는 동작하지 않는 믿을"
#~ " 수 없는 코드가 만들어질 수 있습니다. 하나의 "
#~ "구체적인 형 대신에 ``str``\\로 받아들인 것이 텍스트나"
#~ " 바이너리 데이터 중 어느 것을 받아들이는지 명시적으로"
#~ " 언급하지 않으면 혼란스러운 API가 될 수 있습니다."
#~ " API가 텍스트 데이터 지원을 주장할 때 명시적으로"
#~ " ``unicode``\\를 지원하지 않을 수 있어서 여러 "
#~ "언어를 지원하는 사람에게는 특히 상황을 복잡하게 만듭니다."

#~ msgid ""
#~ "To make the distinction between text "
#~ "and binary data clearer and more "
#~ "pronounced, Python 3 did what most "
#~ "languages created in the age of "
#~ "the internet have done and made "
#~ "text and binary data distinct types "
#~ "that cannot blindly be mixed together"
#~ " (Python predates widespread access to "
#~ "the internet). For any code that "
#~ "deals only with text or only "
#~ "binary data, this separation doesn't "
#~ "pose an issue. But for code that"
#~ " has to deal with both, it does"
#~ " mean you might have to now "
#~ "care about when you are using text"
#~ " compared to binary data, which is"
#~ " why this cannot be entirely "
#~ "automated."
#~ msgstr ""
#~ "텍스트와 바이너리 데이터의 구별을 보다 명확하고 뚜렷하게"
#~ " 하기 위해, 파이썬 3은 인터넷 시대에 만들어진 "
#~ "대부분의 언어가 수행한 작업을 수행했으며 텍스트와 바이너리"
#~ " 데이터를 맹목적으로 혼합할 수 없는 고유한 형으로"
#~ " 만들었습니다 (파이썬은 인터넷이 널리 퍼지기 전부터 "
#~ "존재해 왔습니다). 텍스트나 바이너리 데이터 어느 한 "
#~ "가지만 처리하는 코드의 경우, 이 분리는 문제를 "
#~ "일으키지 않습니다. 그러나 두 가지를 모두 다뤄야 "
#~ "하는 코드의 경우, 언제 텍스트 데이터를, 언제 "
#~ "바이너리 데이터를 사용해야 할지 이제 신경 써야 할"
#~ " 수 있음을 뜻하고, 이것이 완전히 자동화할 수 "
#~ "없는 이유입니다."

#~ msgid ""
#~ "To start, you will need to decide"
#~ " which APIs take text and which "
#~ "take binary (it is **highly** "
#~ "recommended you don't design APIs that"
#~ " can take both due to the "
#~ "difficulty of keeping the code working;"
#~ " as stated earlier it is difficult"
#~ " to do well). In Python 2 this"
#~ " means making sure the APIs that "
#~ "take text can work with ``unicode`` "
#~ "and those that work with binary "
#~ "data work with the ``bytes`` type "
#~ "from Python 3 (which is a subset"
#~ " of ``str`` in Python 2 and "
#~ "acts as an alias for ``bytes`` "
#~ "type in Python 2). Usually the "
#~ "biggest issue is realizing which methods"
#~ " exist on which types in Python "
#~ "2 & 3 simultaneously (for text "
#~ "that's ``unicode`` in Python 2 and "
#~ "``str`` in Python 3, for binary "
#~ "that's ``str``/``bytes`` in Python 2 and"
#~ " ``bytes`` in Python 3). The "
#~ "following table lists the **unique** "
#~ "methods of each data type across "
#~ "Python 2 & 3 (e.g., the "
#~ "``decode()`` method is usable on the "
#~ "equivalent binary data type in either"
#~ " Python 2 or 3, but it can't"
#~ " be used by the textual data "
#~ "type consistently between Python 2 and"
#~ " 3 because ``str`` in Python 3 "
#~ "doesn't have the method). Do note "
#~ "that as of Python 3.5 the "
#~ "``__mod__`` method was added to the "
#~ "bytes type."
#~ msgstr ""
#~ "시작하려면, 어떤 API가 텍스트를 취하고 어떤 것이 "
#~ "바이너리를 취할지 결정해야 합니다 (코드가 동작하도록 만드는"
#~ " 어려움 때문에 둘 다 취하는 API를 설계하지 "
#~ "말 것을 **강하게** 권고합니다; 앞서 언급했듯이 잘하기가"
#~ " 어렵습니다). 파이썬 2에서 이것은 텍스트를 취하는 "
#~ "API가 ``unicode``\\에서 작동하고 바이너리 데이터로 작동하는"
#~ " API가 파이썬 3에서 온 ``bytes`` 형(파이썬 "
#~ "2에서 ``str``\\의 부분 집합이며 파이썬 2에서 "
#~ "``bytes`` 형식의 별칭으로 작동합니다)으로 작동하는 것을 "
#~ "의미합니다. 일반적으로 가장 큰 문제는 파이썬 2와 "
#~ "3의 어떤 형에 어떤 메서드가 동시에 존재하는지 "
#~ "인식하는 것입니다 (텍스트의 경우 이것은 파이썬 2에서는"
#~ " ``unicode``\\고 파이썬 3에서는 ``str``\\입니다, "
#~ "바이너리의 경우 이것은 파이썬 2에서는 "
#~ "``str``/``bytes``\\이고 파이썬 3에서는 ``bytes``\\입니다). "
#~ "다음 표는 파이썬 2와 3을 가로질러 각 데이터형의"
#~ " **고유한** 메서드를 나열합니다 (예를 들어 "
#~ "``decode()`` 메서드는 파이썬 2와 3의 동등한 "
#~ "바이너리 데이터형에서 사용할 수 있지만, 파이썬 3의 "
#~ "``str``\\에는 메서드가 없기 때문에 텍스트 데이터형에서는 "
#~ "파이썬 2와 3간에 일관되게 사용할 수 없습니다). "
#~ "파이썬 3.5부터 ``__mod__`` 메서드가 bytes 형에 "
#~ "추가되었음에 유의하십시오."

#~ msgid "**Text data**"
#~ msgstr "**텍스트 데이터**"

#~ msgid "**Binary data**"
#~ msgstr "**바이너리 데이터**"

#~ msgid "\\"
#~ msgstr "\\"

#~ msgid "decode"
#~ msgstr "decode"

#~ msgid "encode"
#~ msgstr "encode"

#~ msgid "format"
#~ msgstr "format"

#~ msgid "isdecimal"
#~ msgstr "isdecimal"

#~ msgid "isnumeric"
#~ msgstr "isnumeric"

#~ msgid ""
#~ "Making the distinction easier to handle"
#~ " can be accomplished by encoding and"
#~ " decoding between binary data and "
#~ "text at the edge of your code. "
#~ "This means that when you receive "
#~ "text in binary data, you should "
#~ "immediately decode it. And if your "
#~ "code needs to send text as binary"
#~ " data then encode it as late as"
#~ " possible. This allows your code to"
#~ " work with only text internally and"
#~ " thus eliminates having to keep track"
#~ " of what type of data you are"
#~ " working with."
#~ msgstr ""
#~ "코드 가장자리에서 바이너리 데이터와 텍스트 간의 인코딩과"
#~ " 디코딩을 함으로써 구별을 더 쉽게 처리할 수 "
#~ "있습니다. 이는 바이너리 데이터로 텍스트를 수신하면 즉시"
#~ " 디코딩해야 함을 의미합니다. 그리고 코드가 텍스트를 "
#~ "바이너리 데이터로 보내야 하면 가능한 한 늦게 "
#~ "인코딩하십시오. 이렇게 하면 코드는 내부적으로 텍스트만 "
#~ "처리하고 작업 중인 데이터의 형을 추적할 필요가 "
#~ "없습니다."

#~ msgid ""
#~ "The next issue is making sure you"
#~ " know whether the string literals in"
#~ " your code represent text or binary"
#~ " data. You should add a ``b`` "
#~ "prefix to any literal that presents "
#~ "binary data. For text you should "
#~ "add a ``u`` prefix to the text "
#~ "literal. (there is a :mod:`__future__` "
#~ "import to force all unspecified literals"
#~ " to be Unicode, but usage has "
#~ "shown it isn't as effective as "
#~ "adding a ``b`` or ``u`` prefix to"
#~ " all literals explicitly)"
#~ msgstr ""
#~ "다음 문제는 코드의 문자열 리터럴이 텍스트나 바이너리 "
#~ "데이터 중 어느 것을 나타내는지를 확인하는 것입니다. "
#~ "바이너리 데이터를 나타내는 모든 리터럴에 ``b`` 접두사를"
#~ " 추가해야 합니다. 텍스트의 경우 텍스트 리터럴에 "
#~ "``u`` 접두사를 추가해야 합니다. (지정되지 않은 모든"
#~ " 리터럴을 유니코드로 강제 적용하는 :mod:`__future__` "
#~ "임포트가 있지만, 그간의 경험으로 보면 모든 리터럴에 "
#~ "``b``\\나 ``u`` 접두사를 명시적으로 추가하는 것만큼 "
#~ "효과적이지 않습니다)"

#~ msgid ""
#~ "As part of this dichotomy you also"
#~ " need to be careful about opening "
#~ "files. Unless you have been working "
#~ "on Windows, there is a chance you"
#~ " have not always bothered to add "
#~ "the ``b`` mode when opening a "
#~ "binary file (e.g., ``rb`` for binary "
#~ "reading).  Under Python 3, binary files"
#~ " and text files are clearly distinct"
#~ " and mutually incompatible; see the "
#~ ":mod:`io` module for details. Therefore, "
#~ "you **must** make a decision of "
#~ "whether a file will be used for"
#~ " binary access (allowing binary data "
#~ "to be read and/or written) or "
#~ "textual access (allowing text data to"
#~ " be read and/or written). You should"
#~ " also use :func:`io.open` for opening "
#~ "files instead of the built-in "
#~ ":func:`open` function as the :mod:`io` "
#~ "module is consistent from Python 2 "
#~ "to 3 while the built-in "
#~ ":func:`open` function is not (in Python"
#~ " 3 it's actually :func:`io.open`). Do "
#~ "not bother with the outdated practice"
#~ " of using :func:`codecs.open` as that's "
#~ "only necessary for keeping compatibility "
#~ "with Python 2.5."
#~ msgstr ""
#~ "이 이분법의 일부로 파일을 열 때도 주의해야 "
#~ "합니다. 윈도우에서 작업해보지 않았다면, 바이너리 파일을 열"
#~ " 때 항상 ``b`` 모드를 추가하지 (예를 들어 "
#~ "바이너리 읽기를 위한 ``rb``) 않았을 수 있습니다."
#~ " 파이썬 3에서는, 바이너리 파일과 텍스트 파일이 "
#~ "명확하게 구분되고 서로 호환되지 않습니다; 자세한 내용은"
#~ " :mod:`io` 모듈을 참조하십시오. 따라서, 파일을 바이너리"
#~ " 액세스(바이너리 데이터를 읽거나 쓸 수 있도록 "
#~ "합니다)나 텍스트 액세스(텍스트 데이터를 읽거나 쓸 수 "
#~ "있도록 합니다) 중 어느 것으로 사용할지를 **반드시**"
#~ " 결정해야 합니다. :mod:`io` 모듈은 파이썬 2와 "
#~ "3에서 일관성 있지만, 내장 :func:`open` 함수(파이썬 "
#~ "3에서 실제로는 :func:`io.open`\\입니다)는 그렇지 않기 "
#~ "때문에 내장 :func:`open` 함수 대신 "
#~ ":func:`io.open`\\을 사용하여 파일을 열어야 합니다. 파이썬"
#~ " 2.5와의 호환성을 유지하는 데만 필요하므로 "
#~ ":func:`codecs.open`\\을 사용하는 오래된 방법은 신경 "
#~ "쓰지 마십시오."

#~ msgid ""
#~ "The constructors of both ``str`` and "
#~ "``bytes`` have different semantics for "
#~ "the same arguments between Python 2 "
#~ "& 3. Passing an integer to "
#~ "``bytes`` in Python 2 will give "
#~ "you the string representation of the "
#~ "integer: ``bytes(3) == '3'``. But in "
#~ "Python 3, an integer argument to "
#~ "``bytes`` will give you a bytes "
#~ "object as long as the integer "
#~ "specified, filled with null bytes: "
#~ "``bytes(3) == b'\\x00\\x00\\x00'``. A similar"
#~ " worry is necessary when passing a"
#~ " bytes object to ``str``. In Python"
#~ " 2 you just get the bytes "
#~ "object back: ``str(b'3') == b'3'``. But"
#~ " in Python 3 you get the string"
#~ " representation of the bytes object: "
#~ "``str(b'3') == \"b'3'\"``."
#~ msgstr ""
#~ "``str``\\과 ``bytes``\\의 생성자는 모두 파이썬 2와"
#~ " 3 사이에서 같은 인자에 대해 다른 의미가 "
#~ "있습니다. 파이썬 2에서 정수를 ``bytes``\\에 전달하면 "
#~ "정수의 문자열 표현을 줍니다: ``bytes(3) == "
#~ "'3'``. 그러나 파이썬 3에서, ``bytes``\\에 대한 "
#~ "정수 인자는 지정된 정수 길이의 널 바이트로 채워진"
#~ " bytes 객체를 줍니다: ``bytes(3) == "
#~ "b'\\x00\\x00\\x00'``. bytes 객체를 ``str``\\로 전달할"
#~ " 때도 비슷한 주의가 필요합니다. 파이썬 2에서는 단지"
#~ " bytes 객체를 다시 받습니다: ``str(b'3') =="
#~ " b'3'``. 그러나 파이썬 3에서는 bytes 객체의 "
#~ "문자열 표현을 얻게 됩니다: ``str(b'3') == "
#~ "\"b'3'\"``."

#~ msgid ""
#~ "Finally, the indexing of binary data "
#~ "requires careful handling (slicing does "
#~ "**not** require any special handling). "
#~ "In Python 2, ``b'123'[1] == b'2'`` "
#~ "while in Python 3 ``b'123'[1] == "
#~ "50``. Because binary data is simply "
#~ "a collection of binary numbers, Python"
#~ " 3 returns the integer value for "
#~ "the byte you index on. But in "
#~ "Python 2 because ``bytes == str``, "
#~ "indexing returns a one-item slice "
#~ "of bytes. The six_ project has a"
#~ " function named ``six.indexbytes()`` which "
#~ "will return an integer like in "
#~ "Python 3: ``six.indexbytes(b'123', 1)``."
#~ msgstr ""
#~ "마지막으로, 바이너리 데이터의 인덱싱에는 신중한 처리가 "
#~ "필요합니다 (슬라이싱에는 특별한 처리가 필요하지 **않습니다**)."
#~ " 파이썬 2에서는, ``b'123'[1] == b'2'``\\인 "
#~ "반면 파이썬 3에서는 ``b'123'[1] == 50``\\입니다."
#~ " 바이너리 데이터는 단순히 바이너리 숫자의 컬렉션이므로, "
#~ "파이썬 3은 인덱싱한 바이트의 정숫값을 반환합니다. 그러나"
#~ " 파이썬 2에서는 ``bytes == str`` 때문에, "
#~ "인덱싱은 한 항목의 bytes 슬라이스를 반환합니다. six_"
#~ " 프로젝트에는 파이썬 2에서처럼 정수를 반환하는 "
#~ "``six.indexbytes()``\\라는 함수가 있습니다: "
#~ "``six.indexbytes(b'123', 1)``."

#~ msgid "To summarize:"
#~ msgstr "요약하면:"

#~ msgid "Decide which of your APIs take text and which take binary data"
#~ msgstr "어떤 API가 텍스트를 취하고 어떤 것이 바이너리 데이터를 취하는지 결정하십시오"

#~ msgid ""
#~ "Make sure that your code that "
#~ "works with text also works with "
#~ "``unicode`` and code for binary data "
#~ "works with ``bytes`` in Python 2 "
#~ "(see the table above for what "
#~ "methods you cannot use for each "
#~ "type)"
#~ msgstr ""
#~ "텍스트로 작동하는 코드가 ``unicode``\\에서도 작동하고 바이너리"
#~ " 데이터를 위한 코드는 파이썬 2에서 ``bytes``\\와 "
#~ "작동하도록 하십시오 (각 형에서 사용할 수 없는 "
#~ "메서드는 위의 표를 참조하십시오)"

#~ msgid ""
#~ "Mark all binary literals with a "
#~ "``b`` prefix, textual literals with a"
#~ " ``u`` prefix"
#~ msgstr "모든 바이너리 리터럴을 ``b`` 접두사로 표시하고, 텍스트 리터럴을 ``u`` 접두사로 표시하십시오"

#~ msgid ""
#~ "Decode binary data to text as soon"
#~ " as possible, encode text as binary"
#~ " data as late as possible"
#~ msgstr "바이너리 데이터를 가능한 한 빨리 텍스트로 디코딩하고, 텍스트를 가능한 한 늦게 바이너리 데이터로 인코딩하십시오"

#~ msgid ""
#~ "Open files using :func:`io.open` and "
#~ "make sure to specify the ``b`` "
#~ "mode when appropriate"
#~ msgstr ":func:`io.open`\\을 사용하여 파일을 열고 적절할 때 ``b`` 모드를 지정하십시오"

#~ msgid "Be careful when indexing into binary data"
#~ msgstr "바이너리 데이터로 인덱싱할 때 주의하십시오"

#~ msgid "Use feature detection instead of version detection"
#~ msgstr "버전 감지 대신 기능 감지를 사용하십시오"

#~ msgid ""
#~ "Inevitably you will have code that "
#~ "has to choose what to do based "
#~ "on what version of Python is "
#~ "running. The best way to do this"
#~ " is with feature detection of whether"
#~ " the version of Python you're running"
#~ " under supports what you need. If "
#~ "for some reason that doesn't work "
#~ "then you should make the version "
#~ "check be against Python 2 and not"
#~ " Python 3. To help explain this, "
#~ "let's look at an example."
#~ msgstr ""
#~ "필연적으로 실행 중인 파이썬 버전에 따라 수행할 "
#~ "작업을 선택해야 하는 코드를 갖게 됩니다. 가장 "
#~ "좋은 방법은 실행 중인 파이썬 버전이 필요한 것을"
#~ " 지원하는지에 대한 기능 감지를 사용하는 것입니다. 어떤"
#~ " 이유로 이 방법이 작동하지 않으면 버전 확인을 "
#~ "파이썬 3이 아닌 파이썬 2에 대해 수행해야 "
#~ "합니다. 이를 설명하기 위해, 예제를 살펴보겠습니다."

#~ msgid ""
#~ "Let's pretend that you need access "
#~ "to a feature of :mod:`importlib` that"
#~ " is available in Python's standard "
#~ "library since Python 3.3 and available"
#~ " for Python 2 through importlib2_ on"
#~ " PyPI. You might be tempted to "
#~ "write code to access e.g. the "
#~ ":mod:`importlib.abc` module by doing the "
#~ "following::"
#~ msgstr ""
#~ "파이썬 3.3 이후로 파이썬의 표준 라이브러리에서 사용할"
#~ " 수 있고 PyPI의 importlib2_\\를 통해 파이썬 "
#~ "2에서 사용할 수 있는 :mod:`importlib`\\의 기능에 "
#~ "액세스해야 한다고 가정해 봅시다. 다음과 같이 예를 "
#~ "들어 :mod:`importlib.abc` 모듈을 액세스하는 코드를 "
#~ "작성하려고 할 수 있습니다::"

#~ msgid ""
#~ "The problem with this code is what"
#~ " happens when Python 4 comes out? "
#~ "It would be better to treat Python"
#~ " 2 as the exceptional case instead"
#~ " of Python 3 and assume that "
#~ "future Python versions will be more "
#~ "compatible with Python 3 than Python "
#~ "2::"
#~ msgstr ""
#~ "이 코드는 문제점이 있는데, 파이썬 4가 나오면 "
#~ "어떻게 됩니까? 파이썬 3 대신 파이썬 2를 "
#~ "예외적인 사례로 취급하고 향후 파이썬 버전이 파이썬 "
#~ "2보다는 파이썬 3과 더 호환될 것이라고 가정하는 "
#~ "것이 좋습니다::"

#~ msgid ""
#~ "The best solution, though, is to "
#~ "do no version detection at all and"
#~ " instead rely on feature detection. "
#~ "That avoids any potential issues of "
#~ "getting the version detection wrong and"
#~ " helps keep you future-compatible::"
#~ msgstr ""
#~ "그러나 가장 좋은 해결책은 버전 감지를 않고 기능"
#~ " 감지에 의존하는 것입니다. 그러면 버전 감지가 잘못될"
#~ " 수 있는 잠재적인 문제를 피하고 미래 호환성을 "
#~ "유지할 수 있습니다::"

#~ msgid "Prevent compatibility regressions"
#~ msgstr "호환성 회귀를 방지하십시오"

#~ msgid ""
#~ "Once you have fully translated your "
#~ "code to be compatible with Python "
#~ "3, you will want to make sure "
#~ "your code doesn't regress and stop "
#~ "working under Python 3. This is "
#~ "especially true if you have a "
#~ "dependency which is blocking you from"
#~ " actually running under Python 3 at"
#~ " the moment."
#~ msgstr ""
#~ "일단 파이썬 3과 호환되도록 코드를 완전히 번역했으면, "
#~ "코드가 회귀하고 파이썬 3에서 작동을 멈추는 것을 "
#~ "방지하고 싶을 것입니다. 이는 이 시점에 여러분이 "
#~ "실제로 파이썬 3에서 실행하는 것을 막는 의존성이 "
#~ "있는 경우에 특히 그렇습니다."

#~ msgid ""
#~ "To help with staying compatible, any "
#~ "new modules you create should have "
#~ "at least the following block of "
#~ "code at the top of it::"
#~ msgstr "계속 호환되도록 하려면, 새로 만드는 모든 모듈의 맨 위에 최소한 다음 코드 블록이 있어야 합니다::"

#~ msgid ""
#~ "You can also run Python 2 with "
#~ "the ``-3`` flag to be warned about"
#~ " various compatibility issues your code "
#~ "triggers during execution. If you turn"
#~ " warnings into errors with ``-Werror`` "
#~ "then you can make sure that you"
#~ " don't accidentally miss a warning."
#~ msgstr ""
#~ "``-3`` 플래그로 파이썬 2를 실행하여 코드가 실행되는"
#~ " 동안 발생하는 다양한 호환성 문제에 대해 경고를 "
#~ "받을 수도 있습니다. ``-Werror``\\로 경고를 에러로 "
#~ "바꾸면 실수로 경고를 놓치지 않도록 할 수 "
#~ "있습니다."

#~ msgid ""
#~ "You can also use the Pylint_ "
#~ "project and its ``--py3k`` flag to "
#~ "lint your code to receive warnings "
#~ "when your code begins to deviate "
#~ "from Python 3 compatibility. This also"
#~ " prevents you from having to run "
#~ "Modernize_ or Futurize_ over your code"
#~ " regularly to catch compatibility "
#~ "regressions. This does require you only"
#~ " support Python 2.7 and Python 3.4"
#~ " or newer as that is Pylint's "
#~ "minimum Python version support."
#~ msgstr ""
#~ "Pylint_ 프로젝트와 그것의 ``--py3k`` 플래그를 사용하여"
#~ " 코드가 파이썬 3 호환성에서 벗어나기 시작할 때 "
#~ "경고를 받도록 코드를 검사할 수도 있습니다. 또한 "
#~ "이것은 호환성 회귀를 포착하기 위해 정기적으로 코드를 "
#~ "Modernize_\\나 Futurize_\\로 실행하지 않아도 되도록 "
#~ "합니다. 이것은 여러분이 파이썬 2.7과 파이썬 3.4 "
#~ "이상 만 지원할 것을 요구합니다, 이것이 Pylint의 "
#~ "최소 파이썬 버전 지원이기 때문입니다."

#~ msgid "Check which dependencies block your transition"
#~ msgstr "전환을 막는 의존성을 확인하십시오"

#~ msgid ""
#~ "**After** you have made your code "
#~ "compatible with Python 3 you should "
#~ "begin to care about whether your "
#~ "dependencies have also been ported. The"
#~ " caniusepython3_ project was created to "
#~ "help you determine which projects -- "
#~ "directly or indirectly -- are blocking"
#~ " you from supporting Python 3. There"
#~ " is both a command-line tool as"
#~ " well as a web interface at "
#~ "https://caniusepython3.com."
#~ msgstr ""
#~ "코드를 파이썬 3과 호환되게 만든 **후에** 의존성도 "
#~ "이식되었는지를 신경 쓰기 시작해야 합니다. caniusepython3_"
#~ " 프로젝트는 어떤 프로젝트가 -- 직접 또는 간접적으로"
#~ " -- 파이썬 3을 지원하는 것을 막는지 판단하는 "
#~ "데 도움을 주기 위해 만들어졌습니다. 명령 줄 "
#~ "도구뿐만 아니라 https://caniusepython3.com 에 웹 "
#~ "인터페이스가 있습니다."

#~ msgid ""
#~ "The project also provides code which "
#~ "you can integrate into your test "
#~ "suite so that you will have a "
#~ "failing test when you no longer "
#~ "have dependencies blocking you from "
#~ "using Python 3. This allows you to"
#~ " avoid having to manually check your"
#~ " dependencies and to be notified "
#~ "quickly when you can start running "
#~ "on Python 3."
#~ msgstr ""
#~ "이 프로젝트는 또한 테스트 스위트에 통합할 수 있는"
#~ " 코드를 제공해서 더는 파이썬 3 사용을 막는 "
#~ "의존성이 없을 때 테스트가 실패하도록 합니다. 이는 "
#~ "의존성을 수동으로 확인하지 않도록 하고 파이썬 3에서 "
#~ "실행할 수 있을 때 신속하게 알림을 받을 수 "
#~ "있도록 합니다. "

#~ msgid "Update your ``setup.py`` file to denote Python 3 compatibility"
#~ msgstr "파이썬 3 호환성을 나타내도록 ``setup.py`` 파일을 갱신하십시오."

#~ msgid ""
#~ "Once your code works under Python "
#~ "3, you should update the classifiers "
#~ "in your ``setup.py`` to contain "
#~ "``Programming Language :: Python :: 3``"
#~ " and to not specify sole Python "
#~ "2 support. This will tell anyone "
#~ "using your code that you support "
#~ "Python 2 **and** 3. Ideally you "
#~ "will also want to add classifiers "
#~ "for each major/minor version of Python"
#~ " you now support."
#~ msgstr ""
#~ "일단 코드가 파이썬 3에서 작동하면, ``Programming "
#~ "Language :: Python :: 3``\\을 포함하고 "
#~ "파이썬 2만 지원한다고 지정하지 않도록 ``setup.py``\\의"
#~ " 분류를 갱신해야 합니다. 이것은 코드를 사용하는 "
#~ "사람에게 파이썬 2\\**와** 3을 지원한다는 것을 알려줄"
#~ " 것입니다. 이상적으로는 현재 지원하는 파이썬의 각 "
#~ "주/부 버전을 위한 분류를 추가하고 싶을 것입니다."

#~ msgid "Use continuous integration to stay compatible"
#~ msgstr "지속적인 통합을 통해 호환성을 유지하십시오"

#~ msgid ""
#~ "Once you are able to fully run "
#~ "under Python 3 you will want to"
#~ " make sure your code always works "
#~ "under both Python 2 & 3. Probably"
#~ " the best tool for running your "
#~ "tests under multiple Python interpreters "
#~ "is tox_. You can then integrate "
#~ "tox with your continuous integration "
#~ "system so that you never accidentally"
#~ " break Python 2 or 3 support."
#~ msgstr ""
#~ "일단 파이썬 3에서 완전히 실행할 수 있다면 코드가"
#~ " 항상 파이썬 2와 3에서 작동하는지 확인하고 싶을"
#~ " 것입니다. 아마도 여러 파이썬 인터프리터에서 테스트를 "
#~ "실행하는 가장 좋은 도구는 tox_\\입니다. 실수로 파이썬"
#~ " 2나 3 지원을 망가뜨리지 않도록 지속적인 통합 "
#~ "시스템과 tox를 통합할 수 있습니다."

#~ msgid ""
#~ "You may also want to use the "
#~ "``-bb`` flag with the Python 3 "
#~ "interpreter to trigger an exception when"
#~ " you are comparing bytes to strings"
#~ " or bytes to an int (the latter"
#~ " is available starting in Python "
#~ "3.5). By default type-differing "
#~ "comparisons simply return ``False``, but "
#~ "if you made a mistake in your "
#~ "separation of text/binary data handling "
#~ "or indexing on bytes you wouldn't "
#~ "easily find the mistake. This flag "
#~ "will raise an exception when these "
#~ "kinds of comparisons occur, making the"
#~ " mistake much easier to track down."
#~ msgstr ""
#~ "바이트열을 문자열과 비교하거나 바이트열을 int와 비교할 때"
#~ " (후자는 파이썬 3.5부터 사용 가능합니다) 예외를 "
#~ "일으키도록 파이썬 3 인터프리터에 ``-bb`` 플래그를 "
#~ "사용할 수도 있습니다. 기본적으로 다른 형 간의 "
#~ "비교는 단순히 ``False``\\를 반환하지만, 텍스트/바이너리 데이터"
#~ " 처리의 분리나 바이트열에 대한 인덱싱에서 실수한다면 "
#~ "실수를 쉽게 찾을 수 없습니다. 이 플래그는 이러한"
#~ " 종류의 비교가 발생할 때 예외를 발생 시켜, "
#~ "실수를 훨씬 쉽게 추적할 수 있도록 합니다."

#~ msgid ""
#~ "And that's mostly it! At this "
#~ "point your code base is compatible "
#~ "with both Python 2 and 3 "
#~ "simultaneously. Your testing will also "
#~ "be set up so that you don't "
#~ "accidentally break Python 2 or 3 "
#~ "compatibility regardless of which version "
#~ "you typically run your tests under "
#~ "while developing."
#~ msgstr ""
#~ "그리고 이것이 대부분입니다! 이 시점에서 여러분의 코드 "
#~ "기반은 파이썬 2와 3과 동시에 호환됩니다. 여러분의 "
#~ "테스트도 개발 중에 어떤 버전으로 테스트를 실행하는지와 "
#~ "관계없이 실수로 파이썬 2나 3 호환성을 망가뜨리지 "
#~ "않도록 설정되었습니다."

#~ msgid "Consider using optional static type checking"
#~ msgstr "선택적 정적 형 검사 사용을 고려하십시오"

#~ msgid ""
#~ "Another way to help port your code"
#~ " is to use a static type "
#~ "checker like mypy_ or pytype_ on "
#~ "your code. These tools can be used"
#~ " to analyze your code as if "
#~ "it's being run under Python 2, "
#~ "then you can run the tool a "
#~ "second time as if your code is "
#~ "running under Python 3. By running "
#~ "a static type checker twice like "
#~ "this you can discover if you're "
#~ "e.g. misusing binary data type in "
#~ "one version of Python compared to "
#~ "another. If you add optional type "
#~ "hints to your code you can also"
#~ " explicitly state whether your APIs "
#~ "use textual or binary data, helping "
#~ "to make sure everything functions as "
#~ "expected in both versions of Python."
#~ msgstr ""
#~ "여러분의 코드를 이식하도록 돕는 또 다른 방법은 "
#~ "코드에서 mypy_\\나 pytype_\\과 같은 정적 형 "
#~ "검사기를 사용하는 것입니다. 이 도구를 사용하면 코드가 "
#~ "파이썬 2에서 실행되는 것처럼 코드를 분석할 수 "
#~ "있으며, 그런 다음 코드가 파이썬 3에서 실행되는 "
#~ "것처럼 두 번째로 도구를 실행할 수 있습니다. "
#~ "이처럼 정적 형 검사기를 두 번 실행하면 예를"
#~ " 들어 한 버전의 파이썬에서 다른 버전에 비해 "
#~ "바이너리 데이터형을 잘못 사용하고 있는지 발견할 수 "
#~ "있습니다. 코드에 선택적 형 힌트를 추가하면 API가 "
#~ "텍스트나 바이너리 데이터 중 어느 것을 사용하는지 "
#~ "명시적으로 명시할 수도 있어서 두 버전의 파이썬에서 "
#~ "예상대로 모든 것이 기능하도록 확인하는 데 도움을 "
#~ "줍니다."

