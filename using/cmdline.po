# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../using/cmdline.rst:9
msgid "Command line and environment"
msgstr "명령 줄과 환경"

#: ../../using/cmdline.rst:11
msgid ""
"The CPython interpreter scans the command line and the environment for "
"various settings."
msgstr "CPython 인터프리터는 명령 줄과 환경에서 다양한 설정을 찾습니다."

#: ../../using/cmdline.rst:16
msgid ""
"Other implementations' command line schemes may differ.  See "
":ref:`implementations` for further resources."
msgstr "다른 구현의 명령 줄 체계는 다를 수 있습니다. 자세한 내용은 :ref:`implementations` 참조하십시오."

#: ../../using/cmdline.rst:23
msgid "Command line"
msgstr "명령 줄"

#: ../../using/cmdline.rst:25
msgid "When invoking Python, you may specify any of these options::"
msgstr "파이썬을 호출할 때 다음 옵션들을 지정할 수 있습니다::"

#: ../../using/cmdline.rst:27
msgid ""
"python [-bBdEhiIOPqRsSuvVWx?] [-c command | -m module-name | script | - ]"
" [args]"
msgstr ""

#: ../../using/cmdline.rst:29
msgid "The most common use case is, of course, a simple invocation of a script::"
msgstr "물론, 가장 일반적인 사용 사례는 간단한 스크립트 호출입니다::"

#: ../../using/cmdline.rst:31
msgid "python myscript.py"
msgstr ""

#: ../../using/cmdline.rst:37
msgid "Interface options"
msgstr "인터페이스 옵션"

#: ../../using/cmdline.rst:39
msgid ""
"The interpreter interface resembles that of the UNIX shell, but provides "
"some additional methods of invocation:"
msgstr "인터프리터 인터페이스는 유닉스 셸의 인터페이스와 비슷하지만, 몇 가지 추가 호출 방법을 제공합니다:"

#: ../../using/cmdline.rst:42
#, fuzzy
msgid ""
"When called with standard input connected to a tty device, it prompts for"
" commands and executes them until an EOF (an end-of-file character, you "
"can produce that with :kbd:`Ctrl-D` on UNIX or :kbd:`Ctrl-Z, Enter` on "
"Windows) is read. For more on interactive mode, see :ref:`tut-interac`."
msgstr ""
"tty 장치에 연결된 표준 입력으로 호출하면, 명령을 입력하라는 프롬프트를 준 후 EOF(파일 끝 문자, 유닉스에서는 "
":kbd:`Ctrl-D`, 윈도우에서는 :kbd:`Ctrl-Z, Enter`\\로 만들 수 있습니다)가 읽힐 때까지 실행합니다."

#: ../../using/cmdline.rst:46
msgid ""
"When called with a file name argument or with a file as standard input, "
"it reads and executes a script from that file."
msgstr "파일 이름 인자나 파일을 표준 입력으로 사용해서 호출하면, 해당 파일에서 스크립트를 읽고 실행합니다."

#: ../../using/cmdline.rst:48
msgid ""
"When called with a directory name argument, it reads and executes an "
"appropriately named script from that directory."
msgstr "디렉터리 이름 인자로 호출되면, 해당 디렉터리에서 적절히 이름 붙은 스크립트를 읽고 실행합니다."

#: ../../using/cmdline.rst:50
msgid ""
"When called with ``-c command``, it executes the Python statement(s) "
"given as *command*.  Here *command* may contain multiple statements "
"separated by newlines. Leading whitespace is significant in Python "
"statements!"
msgstr ""
"``-c command`` 로 호출되면, *command*\\로 주어지는 파이썬 문장을 실행합니다. 여기서 *command*\\는 "
"개행 문자로 구분된 여러 개의 문장을 포함할 수 있습니다. 선행 공백은 파이썬 문장에서 중요합니다!"

#: ../../using/cmdline.rst:53
msgid ""
"When called with ``-m module-name``, the given module is located on the "
"Python module path and executed as a script."
msgstr "``-m module-name`` 으로 호출되면, 주어진 모듈을 파이썬 모듈 경로에서 찾은 후에 스크립트로 실행합니다."

#: ../../using/cmdline.rst:56
msgid "In non-interactive mode, the entire input is parsed before it is executed."
msgstr "비대화형 모드에서는, 실행하기 전에 전체 입력을 구문 분석합니다."

#: ../../using/cmdline.rst:58
msgid ""
"An interface option terminates the list of options consumed by the "
"interpreter, all consecutive arguments will end up in :data:`sys.argv` --"
" note that the first element, subscript zero (``sys.argv[0]``), is a "
"string reflecting the program's source."
msgstr ""
"인터페이스 옵션은 인터프리터에 의해 소비되는 옵션의 목록을 종료합니다, 뒤따르는 모든 인자는 :data:`sys.argv` 로 "
"들어갑니다 -- 첫 번째 요소, 서브 스크립트 0(``sys.argv[0]``)은 프로그램 소스를 반영하는 문자열임에 유의하세요."

#: ../../using/cmdline.rst:65
msgid ""
"Execute the Python code in *command*.  *command* can be one or more "
"statements separated by newlines, with significant leading whitespace as "
"in normal module code."
msgstr ""
"*command* 의 파이썬 코드를 실행합니다. *command* 는 개행 문자로 구분된 하나 이상의 문장일 수 있는데, 일반 모듈"
" 코드에서와같이 선행 공백은 의미가 있습니다."

#: ../../using/cmdline.rst:69
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"``\"-c\"`` and the current directory will be added to the start of "
":data:`sys.path` (allowing modules in that directory to be imported as "
"top level modules)."
msgstr ""
"이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 ``\"-c\"`` 가 되고, 현재 디렉터리를 "
":data:`sys.path` 의 시작 부분에 추가합니다 (그 디렉터리에 있는 모듈을 최상위 모듈로 임포트 할 수 있게 합니다)."

#: ../../using/cmdline.rst:74
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_command`` with "
"argument ``command``."
msgstr ""
"``command``\\를 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``cpython.run_command``\\를 발생시킵니다."

#: ../../using/cmdline.rst:78
msgid ""
"Search :data:`sys.path` for the named module and execute its contents as "
"the :mod:`__main__` module."
msgstr "제공된 이름의 모듈을 :data:`sys.path` 에서 검색하고 그 내용을 :mod:`__main__` 모듈로서 실행합니다."

#: ../../using/cmdline.rst:81
msgid ""
"Since the argument is a *module* name, you must not give a file extension"
" (``.py``).  The module name should be a valid absolute Python module "
"name, but the implementation may not always enforce this (e.g. it may "
"allow you to use a name that includes a hyphen)."
msgstr ""
"인자가 *모듈* 이름이기 때문에, 파일 확장자(``.py``)를 주지 않아야 합니다. 모듈 이름은 유효한 절대 파이썬 모듈 "
"이름이어야 하지만, 구현이 항상 이를 강제하는 것은 아닙니다 (예를 들어, 하이픈을 포함하는 이름을 허락할 수도 있습니다)."

#: ../../using/cmdline.rst:86
msgid ""
"Package names (including namespace packages) are also permitted. When a "
"package name is supplied instead of a normal module, the interpreter will"
" execute ``<pkg>.__main__`` as the main module. This behaviour is "
"deliberately similar to the handling of directories and zipfiles that are"
" passed to the interpreter as the script argument."
msgstr ""
"패키지 이름(이름 공간 패키지 포함)도 허용됩니다. 일반 모듈 대신 패키지 이름이 제공되면, 인터프리터는 "
"``<pkg>.__main__`` 을 메인 모듈로 실행합니다. 이 동작은 인터프리터에 스크립트 인자로 전달되는 디렉터리 및 zip "
"파일의 처리와 의도적으로 유사합니다."

#: ../../using/cmdline.rst:95
msgid ""
"This option cannot be used with built-in modules and extension modules "
"written in C, since they do not have Python module files. However, it can"
" still be used for precompiled modules, even if the original source file "
"is not available."
msgstr ""
"이 옵션은 내장 모듈이나 확장 모듈에는 사용될 수 없는데, 이것들은 파이썬 모듈 파일을 갖고 있지 않기 때문입니다. 그러나, 원래 "
"소스 파일이 없는 사전 컴파일된 모듈에는 여전히 사용할 수 있습니다."

#: ../../using/cmdline.rst:100
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"the full path to the module file (while the module file is being located,"
" the first element will be set to ``\"-m\"``). As with the :option:`-c` "
"option, the current directory will be added to the start of "
":data:`sys.path`."
msgstr ""
"이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 모듈 파일의 전체 경로가 됩니다 (모듈 파일을 찾는 동안에는 첫"
" 번째 요소를 ``\"-m\"`` 으로 설정합니다). :option:`-c` 옵션과 마찬가지로, 현재 디렉터리가 "
":data:`sys.path` 의 시작 부분에 추가됩니다."

#: ../../using/cmdline.rst:105
#, fuzzy
msgid ""
":option:`-I` option can  be used to run the script in isolated mode where"
" :data:`sys.path` contains neither the current directory nor the user's "
"site-packages directory. All ``PYTHON*`` environment variables are "
"ignored, too."
msgstr ""
":option:`-I` 옵션을 사용하면 :data:`sys.path`\\가 현재 디렉터리나 사용자의 site-packages "
"디렉터리를 포함하지 않는 격리 모드에서 스크립트를 실행할 수 있습니다. 모든 :envvar:`PYTHON*` 환경 변수도 "
"무시됩니다."

#: ../../using/cmdline.rst:110
msgid ""
"Many standard library modules contain code that is invoked on their "
"execution as a script.  An example is the :mod:`timeit` module::"
msgstr "많은 표준 라이브러리 모듈에는 스크립트로 실행할 때 호출되는 코드가 들어 있습니다. 한 예는 :mod:`timeit` 모듈입니다::"

#: ../../using/cmdline.rst:113
msgid ""
"python -m timeit -s \"setup here\" \"benchmarked code here\"\n"
"python -m timeit -h # for details"
msgstr ""

#: ../../using/cmdline.rst:116
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_module`` with "
"argument ``module-name``."
msgstr ""
"``module-name``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``cpython.run_module``\\을 발생시킵니다."

#: ../../using/cmdline.rst:119
msgid ":func:`runpy.run_module`"
msgstr ":func:`runpy.run_module`"

#: ../../using/cmdline.rst:120 ../../using/cmdline.rst:172
msgid "Equivalent functionality directly available to Python code"
msgstr "파이썬 코드에서 직접 사용할 수 있는 동등한 기능"

#: ../../using/cmdline.rst:122
msgid ":pep:`338` -- Executing modules as scripts"
msgstr ":pep:`338` -- 모듈을 스크립트로 실행하기"

#: ../../using/cmdline.rst:124
msgid "Supply the package name to run a ``__main__`` submodule."
msgstr "``__main__`` 서브 모듈을 실행할 패키지 이름을 제공할 수 있습니다."

#: ../../using/cmdline.rst:127
msgid "namespace packages are also supported"
msgstr "이름 공간 패키지도 지원됩니다."

#: ../../using/cmdline.rst:134
msgid ""
"Read commands from standard input (:data:`sys.stdin`).  If standard input"
" is a terminal, :option:`-i` is implied."
msgstr ""
"표준 입력(:data:`sys.stdin`)에서 명령을 읽습니다. 표준 입력이 터미널이면, :option:`-i` 가 묵시적으로 "
"적용됩니다."

#: ../../using/cmdline.rst:137
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"``\"-\"`` and the current directory will be added to the start of "
":data:`sys.path`."
msgstr ""
"이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 ``\"-\"`` 이 되고, 현재 디렉터리가 "
":data:`sys.path` 의 처음에 추가됩니다."

#: ../../using/cmdline.rst:141 ../../using/cmdline.rst:796
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_stdin`` with no "
"arguments."
msgstr ""
"인자 없이 :ref:`감사 이벤트(auditing event) <auditing>` ``cpython.run_stdin``\\을 "
"발생시킵니다."

#: ../../using/cmdline.rst:147
msgid ""
"Execute the Python code contained in *script*, which must be a filesystem"
" path (absolute or relative) referring to either a Python file, a "
"directory containing a ``__main__.py`` file, or a zipfile containing a "
"``__main__.py`` file."
msgstr ""
"*script* 에 담긴 파이썬 코드를 실행합니다. *script* 는 파이썬 파일이나 ``__main__.py`` 파일이 들어있는"
" 디렉터리나 ``__main__.py`` 파일을 포함하는 zip 파일을 가리키는 파일 시스템 경로(절대나 상대)여야 합니다."

#: ../../using/cmdline.rst:152
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"the script name as given on the command line."
msgstr "이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 명령 줄에서 주어진 스크립트 이름이 됩니다."

#: ../../using/cmdline.rst:155
msgid ""
"If the script name refers directly to a Python file, the directory "
"containing that file is added to the start of :data:`sys.path`, and the "
"file is executed as the :mod:`__main__` module."
msgstr ""
"스크립트 이름이 파이썬 파일을 직접 가리키면, 해당 파일을 포함하는 디렉터리가 :data:`sys.path` 의 시작 부분에 "
"추가되고, 파일은 :mod:`__main__` 모듈로 실행됩니다."

#: ../../using/cmdline.rst:159
msgid ""
"If the script name refers to a directory or zipfile, the script name is "
"added to the start of :data:`sys.path` and the ``__main__.py`` file in "
"that location is executed as the :mod:`__main__` module."
msgstr ""
"스크립트 이름이 디렉터리 나 zip 파일을 가리키면, 스크립트 이름이 :data:`sys.path` 의 시작 부분에 추가되고, 해당"
" 위치의 ``__main__.py`` 파일을 :mod:`__main__` 모듈로 실행합니다."

#: ../../using/cmdline.rst:163
#, fuzzy
msgid ""
":option:`-I` option can  be used to run the script in isolated mode where"
" :data:`sys.path` contains neither the script's directory nor the user's "
"site-packages directory. All ``PYTHON*`` environment variables are "
"ignored, too."
msgstr ""
":option:`-I` 옵션을 사용하면 :data:`sys.path`\\가 스크립트 디렉터리나 사용자의 site-packages "
"디렉터리를 포함하지 않는 격리 모드에서 스크립트를 실행할 수 있습니다. 모든 :envvar:`PYTHON*` 환경 변수도 "
"무시됩니다."

#: ../../using/cmdline.rst:168
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_file`` with "
"argument ``filename``."
msgstr ""
"``filename``\\을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``cpython.run_file``\\을 발생시킵니다."

#: ../../using/cmdline.rst:171
msgid ":func:`runpy.run_path`"
msgstr ":func:`runpy.run_path`"

#: ../../using/cmdline.rst:175
msgid ""
"If no interface option is given, :option:`-i` is implied, ``sys.argv[0]``"
" is an empty string (``\"\"``) and the current directory will be added to"
" the start of :data:`sys.path`.  Also, tab-completion and history editing"
" is automatically enabled, if available on your platform (see :ref"
":`rlcompleter-config`)."
msgstr ""
"인터페이스 옵션을 주지 않으면, :option:`-i` 가 묵시적으로 적용되고, ``sys.argv[0]`` 는 빈 "
"문자열(``\"\"``)이 되고, 현재 디렉터리가 :data:`sys.path` 의 처음에 추가됩니다. 또한, 플랫폼에서 사용 "
"가능한 경우 (:ref:`rlcompleter-config` 를 참조하세요), 탭 완성 및 히스토리 편집이 자동으로 활성화됩니다."

#: ../../using/cmdline.rst:181
msgid ":ref:`tut-invoking`"
msgstr ":ref:`tut-invoking`"

#: ../../using/cmdline.rst:183
msgid "Automatic enabling of tab-completion and history editing."
msgstr "탭 완성과 히스토리 편집의 자동 활성화."

#: ../../using/cmdline.rst:190
msgid "Generic options"
msgstr "일반 옵션"

#: ../../using/cmdline.rst:196
#, fuzzy
msgid ""
"Print a short description of all command line options and corresponding "
"environment variables and exit."
msgstr "모든 명령 줄 옵션에 대한 간단한 설명을 인쇄합니다."

#: ../../using/cmdline.rst:201
#, fuzzy
msgid ""
"Print a short description of Python-specific environment variables and "
"exit."
msgstr "모든 명령 줄 옵션에 대한 간단한 설명을 인쇄합니다."

#: ../../using/cmdline.rst:208
msgid ""
"Print a description of implementation-specific :option:`-X` options and "
"exit."
msgstr ""

#: ../../using/cmdline.rst:215
msgid "Print complete usage information and exit."
msgstr ""

#: ../../using/cmdline.rst:222
msgid "Print the Python version number and exit.  Example output could be:"
msgstr "파이썬 버전 번호를 출력하고 종료합니다. 출력 예는 다음과 같습니다:"

#: ../../using/cmdline.rst:224
msgid "Python 3.8.0b2+"
msgstr ""

#: ../../using/cmdline.rst:228
msgid "When given twice, print more information about the build, like:"
msgstr "두 번 지정하면, 다음과 같이 빌드에 관한 추가 정보를 인쇄합니다:"

#: ../../using/cmdline.rst:230
msgid ""
"Python 3.8.0b2+ (3.8:0c076caaa8, Apr 20 2019, 21:55:00)\n"
"[GCC 6.2.0 20161005]"
msgstr ""

#: ../../using/cmdline.rst:235
msgid "The ``-VV`` option."
msgstr "``-VV`` 옵션."

#: ../../using/cmdline.rst:242
msgid "Miscellaneous options"
msgstr "기타 옵션"

#: ../../using/cmdline.rst:246
#, fuzzy
msgid ""
"Issue a warning when converting :class:`bytes` or :class:`bytearray` to "
":class:`str` without specifying encoding or comparing :class:`!bytes` or "
":class:`!bytearray` with :class:`!str` or :class:`!bytes` with "
":class:`int`. Issue an error when the option is given twice "
"(:option:`!-bb`)."
msgstr ""
":class:`bytes` 나 :class:`bytearray` 를 :class:`str`\\과, :class:`bytes`\\를 "
":class:`int`\\와 비교할 때 경고를 합니다. 옵션이 두 번 주어지면 (:option:`!-bb`) 에러를 줍니다."

#: ../../using/cmdline.rst:251
#, fuzzy
msgid "Affects also comparisons of :class:`bytes` with :class:`int`."
msgstr ":class:`bytes` 와 :class:`int` 비교에도 적용됩니다."

#: ../../using/cmdline.rst:256
msgid ""
"If given, Python won't try to write ``.pyc`` files on the import of "
"source modules.  See also :envvar:`PYTHONDONTWRITEBYTECODE`."
msgstr ""
"주어지면, 파이썬은 소스 모듈을 임포트 할 때 ``.pyc`` 파일을 쓰려고 하지 않습니다. "
":envvar:`PYTHONDONTWRITEBYTECODE` 도 참조하십시오."

#: ../../using/cmdline.rst:262
msgid ""
"Control the validation behavior of hash-based ``.pyc`` files. See :ref"
":`pyc-invalidation`. When set to ``default``, checked and unchecked hash-"
"based bytecode cache files are validated according to their default "
"semantics. When set to ``always``, all hash-based ``.pyc`` files, whether"
" checked or unchecked, are validated against their corresponding source "
"file. When set to ``never``, hash-based ``.pyc`` files are not validated "
"against their corresponding source files."
msgstr ""
"해시 기반 ``.pyc`` 파일의 검증 동작을 제어합니다. :ref:`pyc-invalidation`\\를 참조하세요. "
"``default`` 로 설정하면, 검사형과 비검사형 해시 기반 바이트 코드 캐시 파일은 기본 의미에 따라 유효성이 검사됩니다. "
"``always`` 로 설정하면, 모든 해시 기반 ``.pyc`` 파일들은, 검사형과 비검사형을 가리지 않고, 해당 소스 파일에 "
"대해 유효성이 검사됩니다. ``never`` 로 설정되면, 해시 기반 ``.pyc`` 파일은 해당 소스 파일에 대해 유효성이 "
"검사되지 않습니다."

#: ../../using/cmdline.rst:270
msgid ""
"The semantics of timestamp-based ``.pyc`` files are unaffected by this "
"option."
msgstr "타임스탬프 기반 ``.pyc`` 파일의 의미는 이 옵션의 영향을 받지 않습니다."

#: ../../using/cmdline.rst:276
#, fuzzy
msgid ""
"Turn on parser debugging output (for expert only). See also the "
":envvar:`PYTHONDEBUG` environment variable."
msgstr ""
"파서 디버깅 출력을 켭니다 (컴파일 옵션에 따라 전문가만을 위한 기능입니다). :envvar:`PYTHONDEBUG` 도 "
"참조하십시오."

#: ../../using/cmdline.rst:279
msgid ""
"This option requires a :ref:`debug build of Python <debug-build>`, "
"otherwise it's ignored."
msgstr ""

#: ../../using/cmdline.rst:285
#, fuzzy
msgid ""
"Ignore all ``PYTHON*`` environment variables, e.g. :envvar:`PYTHONPATH` "
"and :envvar:`PYTHONHOME`, that might be set."
msgstr ""
"설정되었을 수 있는 모든 :envvar:`PYTHON*` 환경 변수를 무시합니다, 예를 들어 :envvar:`PYTHONPATH` "
"와 :envvar:`PYTHONHOME`."

#: ../../using/cmdline.rst:288
#, fuzzy
msgid "See also the :option:`-P` and :option:`-I` (isolated) options."
msgstr ":option:`-X` ``oldparser`` 옵션과 :pep:`617`\\도 참조하십시오."

#: ../../using/cmdline.rst:293
msgid "Enter interactive mode after execution."
msgstr ""

#: ../../using/cmdline.rst:295
msgid ""
"Using the :option:`-i` option will enter interactive mode in any of the "
"following circumstances\\:"
msgstr ""

#: ../../using/cmdline.rst:297
msgid "When a script is passed as first argument"
msgstr ""

#: ../../using/cmdline.rst:298
#, fuzzy
msgid "When the :option:`-c` option is used"
msgstr ":option:`-X` 옵션이 추가되었습니다."

#: ../../using/cmdline.rst:299
#, fuzzy
msgid "When the :option:`-m` option is used"
msgstr ":option:`-X` 옵션이 추가되었습니다."

#: ../../using/cmdline.rst:301
#, fuzzy
msgid ""
"Interactive mode will start even when :data:`sys.stdin` does not appear "
"to be a terminal. The :envvar:`PYTHONSTARTUP` file is not read."
msgstr ""
"스크립트가 첫 번째 인자로 전달되거나 :option:`-c` 옵션이 사용되면, :data:`sys.stdin` 가 터미널로 보이지 "
"않을 때도, 스크립트나 명령을 실행한 후에 대화형 모드에 진입합니다. :envvar:`PYTHONSTARTUP` 파일은 읽지 "
"않습니다."

#: ../../using/cmdline.rst:304
msgid ""
"This can be useful to inspect global variables or a stack trace when a "
"script raises an exception.  See also :envvar:`PYTHONINSPECT`."
msgstr ""
"이것은 스크립트가 예외를 발생시킬 때 전역 변수나 스택 트레이스를 검사하는 데 유용할 수 있습니다. "
":envvar:`PYTHONINSPECT` 도 참조하십시오."

#: ../../using/cmdline.rst:310
msgid ""
"Run Python in isolated mode. This also implies :option:`-E`, :option:`-P`"
" and :option:`-s` options."
msgstr ""

#: ../../using/cmdline.rst:313
#, fuzzy
msgid ""
"In isolated mode :data:`sys.path` contains neither the script's directory"
" nor the user's site-packages directory. All ``PYTHON*`` environment "
"variables are ignored, too. Further restrictions may be imposed to "
"prevent the user from injecting malicious code."
msgstr ""
"격리된 모드로 파이썬을 실행합니다. 이것은 또한 -E와 -s를 묵시적으로 적용합니다. 격리 모드에서 :data:`sys.path` "
"는 스크립트 디렉터리나 사용자의 site-packages 디렉터리를 포함하지 않습니다. 모든 :envvar:`PYTHON*` 환경 "
"변수도 무시됩니다. 사용자가 악성 코드를 주입하는 것을 방지하기 위해 추가 제한이 부과될 수 있습니다."

#: ../../using/cmdline.rst:323
msgid ""
"Remove assert statements and any code conditional on the value of "
":const:`__debug__`.  Augment the filename for compiled (:term:`bytecode`)"
" files by adding ``.opt-1`` before the ``.pyc`` extension (see "
":pep:`488`).  See also :envvar:`PYTHONOPTIMIZE`."
msgstr ""
"assert 문과 :const:`__debug__` 의 값에 대한 조건부 코드를 제거합니다. ``.pyc`` 확장자 앞에 "
"``.opt-1`` 을 추가하여 컴파일된 (:term:`바이트 코드 <bytecode>`) 파일의 이름을 구분합니다 "
"(:pep:`488`\\을 참조하세요). :envvar:`PYTHONOPTIMIZE` 도 참조하십시오."

#: ../../using/cmdline.rst:328 ../../using/cmdline.rst:338
msgid "Modify ``.pyc`` filenames according to :pep:`488`."
msgstr ":pep:`488` 에 따라 ``.pyc`` 파일명을 수정합니다."

#: ../../using/cmdline.rst:334
msgid ""
"Do :option:`-O` and also discard docstrings.  Augment the filename for "
"compiled (:term:`bytecode`) files by adding ``.opt-2`` before the "
"``.pyc`` extension (see :pep:`488`)."
msgstr ""
":option:`-O`\\를 적용하고 독스트링도 버립니다. ``.pyc`` 확장자 앞에 ``.opt-2`` 를 추가하여 컴파일 "
"된(:term:`바이트 코드 <bytecode>`) 파일의 이름을 구분합니다 (참조 :pep:`488`\\을 참조하세요)."

#: ../../using/cmdline.rst:344
msgid "Don't prepend a potentially unsafe path to :data:`sys.path`:"
msgstr ""

#: ../../using/cmdline.rst:346
msgid ""
"``python -m module`` command line: Don't prepend the current working "
"directory."
msgstr ""

#: ../../using/cmdline.rst:348
msgid ""
"``python script.py`` command line: Don't prepend the script's directory. "
"If it's a symbolic link, resolve symbolic links."
msgstr ""

#: ../../using/cmdline.rst:350
msgid ""
"``python -c code`` and ``python`` (REPL) command lines: Don't prepend an "
"empty string, which means the current working directory."
msgstr ""

#: ../../using/cmdline.rst:353
msgid ""
"See also the :envvar:`PYTHONSAFEPATH` environment variable, and "
":option:`-E` and :option:`-I` (isolated) options."
msgstr ""

#: ../../using/cmdline.rst:361
msgid "Don't display the copyright and version messages even in interactive mode."
msgstr "대화형 모드에서도 저작권과 버전 메시지를 표시하지 않습니다."

#: ../../using/cmdline.rst:368
msgid ""
"Turn on hash randomization. This option only has an effect if the "
":envvar:`PYTHONHASHSEED` environment variable is set to ``0``, since hash"
" randomization is enabled by default."
msgstr ""
"해시 무작위화를 켭니다. 이 옵션은 :envvar:`PYTHONHASHSEED` 환경 변수가 ``0`` 으로 설정된 경우에만 효과가"
" 있습니다, 해시 무작위화는 기본적으로 활성화되기 때문입니다."

#: ../../using/cmdline.rst:372
#, fuzzy
msgid ""
"On previous versions of Python, this option turns on hash randomization, "
"so that the :meth:`~object.__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"이전 버전의 파이썬에서는, 이 옵션이 해시 무작위화를 켜서, str과 bytes 객체의 :meth:`__hash__` 값이 예측할 "
"수 없는 난수로 \"솔트(salt)\" 됩니다. 개별 파이썬 프로세스 내에서 상수로 유지되지만, 반복되는 파이썬 실행 간에는 예측할"
" 수 없습니다."

#: ../../using/cmdline.rst:378
#, fuzzy
msgid ""
"Hash randomization is intended to provide protection against a denial-of-"
"service caused by carefully chosen inputs that exploit the worst case "
"performance of a dict construction, *O*\\ (*n*\\ :sup:`2`) complexity.  "
"See http://ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"해시 무작위화는 신중하게 선택된 입력으로 딕셔너리 구성의 성능을 최악의 O(n^2) 복잡도를 갖도록 만드는 서비스 거부에 대한 "
"보호를 제공하기 위한 것입니다. 자세한 내용은 "
"http://www.ocert.org/advisories/ocert-2011-003.html 을 참조하십시오."

#: ../../using/cmdline.rst:383
msgid ""
":envvar:`PYTHONHASHSEED` allows you to set a fixed value for the hash "
"seed secret."
msgstr ":envvar:`PYTHONHASHSEED` 는 해시 시드 시크릿에 고정값을 설정할 수 있게 합니다."

#: ../../using/cmdline.rst:388
msgid "The option is no longer ignored."
msgstr "이 옵션은 더는 무시되지 않습니다."

#: ../../using/cmdline.rst:394
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to "
":data:`sys.path`."
msgstr ""
":data:`사용자 site-packages 디렉터리 <site.USER_SITE>` 를 :data:`sys.path` 에 추가하지"
" 않습니다."

#: ../../using/cmdline.rst:397
#, fuzzy
msgid "See also :envvar:`PYTHONNOUSERSITE`."
msgstr ":envvar:`PYTHONUNBUFFERED` 도 참조하세요."

#: ../../using/cmdline.rst:401 ../../using/cmdline.rst:893
#: ../../using/cmdline.rst:905
msgid ":pep:`370` -- Per user site-packages directory"
msgstr ":pep:`370` -- 사용자별 site-packages 디렉터리"

#: ../../using/cmdline.rst:406
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call "
":func:`site.main` if you want them to be triggered)."
msgstr ""
":mod:`site` 모듈의 임포트와 이 모듈이 수반하는 :data:`sys.path` 의 사이트 의존적 조작을 비활성화합니다. "
"또한 :mod:`site` 가 나중에 명시적으로 임포트될 때도 이 조작을 비활성화합니다 (조작하기를 원하면 "
":func:`site.main` 을 호출하십시오)."

#: ../../using/cmdline.rst:414
msgid ""
"Force the stdout and stderr streams to be unbuffered.  This option has no"
" effect on the stdin stream."
msgstr "stdout 과 stderr 스트림을 버퍼링하지 않도록 만듭니다. 이 옵션은 stdin 스트림에는 영향을 미치지 않습니다."

#: ../../using/cmdline.rst:417
msgid "See also :envvar:`PYTHONUNBUFFERED`."
msgstr ":envvar:`PYTHONUNBUFFERED` 도 참조하세요."

#: ../../using/cmdline.rst:419
msgid "The text layer of the stdout and stderr streams now is unbuffered."
msgstr "stdout 과 stderr 스트림의 텍스트 계층은 이제 버퍼링 되지 않습니다."

#: ../../using/cmdline.rst:425
#, fuzzy
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  When given twice "
"(:option:`!-vv`), print a message for each file that is checked for when "
"searching for a module.  Also provides information on module cleanup at "
"exit."
msgstr ""
"모듈이 초기화될 때마다 메시지를 인쇄하여, 로드된 위치(파일명이나 내장 모듈)를 표시합니다. 두 번 주어지면 "
"(:option:`!-vv`), 모듈을 검색할 때 검사되는 각 파일에 대한 메시지를 인쇄합니다. 종료 시 모듈 정리에 대한 정보도 "
"제공합니다. :envvar:`PYTHONVERBOSE` 도 참조하십시오."

#: ../../using/cmdline.rst:430
msgid ""
"The :mod:`site` module reports the site-specific paths and :file:`.pth` "
"files being processed."
msgstr ""

#: ../../using/cmdline.rst:434
#, fuzzy
msgid "See also :envvar:`PYTHONVERBOSE`."
msgstr ":envvar:`PYTHONUNBUFFERED` 도 참조하세요."

#: ../../using/cmdline.rst:440
#, fuzzy
msgid ""
"Warning control. Python's warning machinery by default prints warning "
"messages to :data:`sys.stderr`."
msgstr ""
"경고 제어. 파이썬의 경고 장치는 기본적으로 :data:`sys.stderr` 로 경고 메시지를 인쇄합니다. 일반적인 경고 메시지의"
" 형식은 다음과 같습니다:"

#: ../../using/cmdline.rst:443 ../../using/cmdline.rst:921
msgid ""
"The simplest settings apply a particular action unconditionally to all "
"warnings emitted by a process (even those that are otherwise ignored by "
"default)::"
msgstr "가장 단순한 설정은 프로세스가 만드는 모든 경고에 무조건 특정 액션을 적용합니다 (그렇지 않으면 기본적으로 무시되는 경고조차도)::"

#: ../../using/cmdline.rst:447
msgid ""
"-Wdefault  # Warn once per call location\n"
"-Werror    # Convert to exceptions\n"
"-Walways   # Warn every time\n"
"-Wall      # Same as -Walways\n"
"-Wmodule   # Warn once per calling module\n"
"-Wonce     # Warn once per Python process\n"
"-Wignore   # Never warn"
msgstr ""

#: ../../using/cmdline.rst:455
#, fuzzy
msgid ""
"The action names can be abbreviated as desired and the interpreter will "
"resolve them to the appropriate action name. For example, ``-Wi`` is the "
"same as ``-Wignore``."
msgstr ""
"액션 이름은 원하면 줄일 수 있고 (예, ``-Wi``, ``-Wd``, ``-Wa``, ``-We``), 인터프리터는 이를 적절한"
" 액션 이름으로 해석합니다."

#: ../../using/cmdline.rst:459
msgid "The full form of argument is::"
msgstr ""

#: ../../using/cmdline.rst:461
msgid "action:message:category:module:lineno"
msgstr ""

#: ../../using/cmdline.rst:463
msgid ""
"Empty fields match all values; trailing empty fields may be omitted. For "
"example ``-W ignore::DeprecationWarning`` ignores all DeprecationWarning "
"warnings."
msgstr ""

#: ../../using/cmdline.rst:467
msgid ""
"The *action* field is as explained above but only applies to warnings "
"that match the remaining fields."
msgstr ""

#: ../../using/cmdline.rst:470
msgid ""
"The *message* field must match the whole warning message; this match is "
"case-insensitive."
msgstr ""

#: ../../using/cmdline.rst:473
msgid ""
"The *category* field matches the warning category (ex: "
"``DeprecationWarning``). This must be a class name; the match test "
"whether the actual warning category of the message is a subclass of the "
"specified warning category."
msgstr ""

#: ../../using/cmdline.rst:478
msgid ""
"The *module* field matches the (fully qualified) module name; this match "
"is case-sensitive."
msgstr ""

#: ../../using/cmdline.rst:481
msgid ""
"The *lineno* field matches the line number, where zero matches all line "
"numbers and is thus equivalent to an omitted line number."
msgstr ""

#: ../../using/cmdline.rst:484
#, fuzzy
msgid ""
"Multiple :option:`-W` options can be given; when a warning matches more "
"than one option, the action for the last matching option is performed. "
"Invalid :option:`-W` options are ignored (though, a warning message is "
"printed about invalid options when the first warning is issued)."
msgstr ""
"다중 :option:`-W` 옵션이 주어질 수 있습니다; 경고가 두 개 이상의 옵션과 일치하면 마지막으로 일치하는 옵션의 액션이 "
"수행됩니다. 유효하지 않은 :option:`-W` 옵션은 무시됩니다 (하지만, 최초의 경고가 발생할 때 유효하지 않은 옵션에 관한 "
"경고 메시지가 출력됩니다)."

#: ../../using/cmdline.rst:489
#, fuzzy
msgid ""
"Warnings can also be controlled using the :envvar:`PYTHONWARNINGS` "
"environment variable and from within a Python program using the "
":mod:`warnings` module. For example, the :func:`warnings.filterwarnings` "
"function can be used to use a regular expression on the warning message."
msgstr ""
"경고는 :envvar:`PYTHONWARNINGS` 환경 변수와 파이썬 프로그램 내에서 :mod:`warnings` 모듈을 사용해서"
" 제어할 수도 있습니다."

#: ../../using/cmdline.rst:494 ../../using/cmdline.rst:933
msgid ""
"See :ref:`warning-filter` and :ref:`describing-warning-filters` for more "
"details."
msgstr ""
"자세한 내용은 :ref:`warning-filter`\\와 :ref:`describing-warning-filters`\\를 "
"참조하십시오."

#: ../../using/cmdline.rst:500
msgid ""
"Skip the first line of the source, allowing use of non-Unix forms of "
"``#!cmd``.  This is intended for a DOS specific hack only."
msgstr ""
"소스의 첫 번째 줄을 건너 뛰어서, 유닉스 이외의 형식의 ``#!cmd`` 을 사용할 수 있게 합니다. 이것은 DOS 전용 "
"핵(hack)을 위한 것입니다."

#: ../../using/cmdline.rst:506
msgid ""
"Reserved for various implementation-specific options.  CPython currently "
"defines the following possible values:"
msgstr "다양한 구현 특정 옵션을 위해 예약되어 있습니다. CPython은 현재 다음과 같은 가능한 값을 정의합니다:"

#: ../../using/cmdline.rst:509
#, fuzzy
msgid ""
"``-X faulthandler`` to enable :mod:`faulthandler`. See also "
":envvar:`PYTHONFAULTHANDLER`."
msgstr "``-X faulthandler`` 는 :mod:`faulthandler` 를 활성화합니다;"

#: ../../using/cmdline.rst:514
#, fuzzy
msgid ""
"``-X showrefcount`` to output the total reference count and number of "
"used memory blocks when the program finishes or after each statement in "
"the interactive interpreter. This only works on :ref:`debug builds "
"<debug-build>`."
msgstr ""
"``-X showrefcount`` 는 프로그램이 끝나거나 대화형 인터프리터에서 각각의 문장 뒤에서, 총 참조 횟수와 사용된 메모리"
" 블록의 수를 출력합니다. 이것은 디버그 빌드에서만 작동합니다."

#: ../../using/cmdline.rst:521
#, fuzzy
msgid ""
"``-X tracemalloc`` to start tracing Python memory allocations using the "
":mod:`tracemalloc` module. By default, only the most recent frame is "
"stored in a traceback of a trace. Use ``-X tracemalloc=NFRAME`` to start "
"tracing with a traceback limit of *NFRAME* frames. See "
":func:`tracemalloc.start` and :envvar:`PYTHONTRACEMALLOC` for more "
"information."
msgstr ""
"``-X tracemalloc`` 은 :mod:`tracemalloc` 모듈을 사용하여 파이썬 메모리 할당 추적을 시작합니다. "
"기본적으로, 가장 최근 프레임만 추적의 트레이스백에 저장됩니다. *NFRAME* 프레임의 트레이스백 한도로 추적을 시작하려면 "
"``-X tracemalloc=NFRAME`` 을 사용하십시오. 자세한 정보는 :func:`tracemalloc.start` 를 "
"참조하십시오."

#: ../../using/cmdline.rst:530
msgid ""
"``-X int_max_str_digits`` configures the :ref:`integer string conversion "
"length limitation <int_max_str_digits>`.  See also "
":envvar:`PYTHONINTMAXSTRDIGITS`."
msgstr ""

#: ../../using/cmdline.rst:536
msgid ""
"``-X importtime`` to show how long each import takes. It shows module "
"name, cumulative time (including nested imports) and self time (excluding"
" nested imports).  Note that its output may be broken in multi-threaded "
"application.  Typical usage is ``python3 -X importtime -c 'import "
"asyncio'``.  See also :envvar:`PYTHONPROFILEIMPORTTIME`."
msgstr ""
"``-X importtime`` 은 각 임포트가 얼마나 오래 걸렸는지 보여줍니다. 모듈 이름, 누적 시간(중첩된 임포트 포함), "
"자체 시간(중첩 임포트 제외)을 표시합니다. 다중 스레드 응용 프로그램에서 출력이 깨질 수 있음에 유의하십시오. 일반적인 사용법은 "
"``python3 -X importtime -c 'import asyncio'`` 입니다. "
":envvar:`PYTHONPROFILEIMPORTTIME` 도 참조하십시오."

#: ../../using/cmdline.rst:544
#, fuzzy
msgid ""
"``-X dev``: enable :ref:`Python Development Mode <devmode>`, introducing "
"additional runtime checks that are too expensive to be enabled by "
"default.  See also :envvar:`PYTHONDEVMODE`."
msgstr ""
"``-X dev``: :ref:`파이썬 개발 모드 <devmode>`\\를 활성화해서, 기본적으로 활성화하기에는 너무 비싼 추가적인"
" 실행시간 검사를 도입합니다."

#: ../../using/cmdline.rst:550
#, fuzzy
msgid ""
"``-X utf8`` enables the :ref:`Python UTF-8 Mode <utf8-mode>`. ``-X "
"utf8=0`` explicitly disables :ref:`Python UTF-8 Mode <utf8-mode>` (even "
"when it would otherwise activate automatically). See also "
":envvar:`PYTHONUTF8`."
msgstr ""
"``-X utf8`` 은 운영 체제 인터페이스를 위한 UTF-8 모드를 활성화하여, 기본 로케일 인식 모드를 대체합니다. ``-X "
"utf8=0`` 은 명시적으로 UTF-8 모드를 비활성화합니다 (그렇지 않으면 자동으로 활성화될 때조차). 자세한 내용은 "
":envvar:`PYTHONUTF8` 을 참조하십시오."

#: ../../using/cmdline.rst:557
msgid ""
"``-X pycache_prefix=PATH`` enables writing ``.pyc`` files to a parallel "
"tree rooted at the given directory instead of to the code tree. See also "
":envvar:`PYTHONPYCACHEPREFIX`."
msgstr ""
"``-X pycache_prefix=PATH``\\는 ``.pyc`` 파일을 코드 트리 대신에 지정된 디렉터리를 루트로 하는 병렬 "
"트리에 쓰도록 합니다. :envvar:`PYTHONPYCACHEPREFIX`\\도 참조하십시오."

#: ../../using/cmdline.rst:563
msgid ""
"``-X warn_default_encoding`` issues a :class:`EncodingWarning` when the "
"locale-specific default encoding is used for opening files. See also "
":envvar:`PYTHONWARNDEFAULTENCODING`."
msgstr ""

#: ../../using/cmdline.rst:569
msgid ""
"``-X no_debug_ranges`` disables the inclusion of the tables mapping extra"
" location information (end line, start column offset and end column "
"offset) to every instruction in code objects. This is useful when smaller"
" code objects and pyc files are desired as well as suppressing the extra "
"visual location indicators when the interpreter displays tracebacks. See "
"also :envvar:`PYTHONNODEBUGRANGES`."
msgstr ""

#: ../../using/cmdline.rst:578
msgid ""
"``-X frozen_modules`` determines whether or not frozen modules are "
"ignored by the import machinery.  A value of ``on`` means they get "
"imported and ``off`` means they are ignored.  The default is ``on`` if "
"this is an installed Python (the normal case).  If it's under development"
" (running from the source tree) then the default is ``off``. Note that "
"the :mod:`!importlib_bootstrap` and :mod:`!importlib_bootstrap_external` "
"frozen modules are always used, even if this flag is set to ``off``. See "
"also :envvar:`PYTHON_FROZEN_MODULES`."
msgstr ""

#: ../../using/cmdline.rst:589
msgid ""
"``-X perf`` enables support for the Linux ``perf`` profiler. When this "
"option is provided, the ``perf`` profiler will be able to report Python "
"calls. This option is only available on some platforms and will do "
"nothing if is not supported on the current system. The default value is "
"\"off\". See also :envvar:`PYTHONPERFSUPPORT` and :ref:`perf_profiling`."
msgstr ""

#: ../../using/cmdline.rst:597
msgid ""
"``-X perf_jit`` enables support for the Linux ``perf`` profiler with "
"DWARF support. When this option is provided, the ``perf`` profiler will "
"be able to report Python calls using DWARF information. This option is "
"only available on some platforms and will do nothing if is not supported "
"on the current system. The default value is \"off\". See also "
":envvar:`PYTHON_PERF_JIT_SUPPORT` and :ref:`perf_profiling`."
msgstr ""

#: ../../using/cmdline.rst:606
#, python-brace-format
msgid ""
":samp:`-X cpu_count={n}` overrides :func:`os.cpu_count`, "
":func:`os.process_cpu_count`, and :func:`multiprocessing.cpu_count`. *n* "
"must be greater than or equal to 1. This option may be useful for users "
"who need to limit CPU resources of a container system. See also "
":envvar:`PYTHON_CPU_COUNT`. If *n* is ``default``, nothing is overridden."
msgstr ""

#: ../../using/cmdline.rst:615
#, python-brace-format
msgid ""
":samp:`-X presite={package.module}` specifies a module that should be "
"imported before the :mod:`site` module is executed and before the "
":mod:`__main__` module exists.  Therefore, the imported module isn't "
":mod:`__main__`. This can be used to execute code early during Python "
"initialization. Python needs to be :ref:`built in debug mode <debug-"
"build>` for this option to exist.  See also :envvar:`PYTHON_PRESITE`."
msgstr ""

#: ../../using/cmdline.rst:624
#, python-brace-format
msgid ""
":samp:`-X gil={0,1}` forces the GIL to be disabled or enabled, "
"respectively. Setting to ``0`` is only available in builds configured "
"with :option:`--disable-gil`. See also :envvar:`PYTHON_GIL` and "
":ref:`whatsnew313-free-threaded-cpython`."
msgstr ""

#: ../../using/cmdline.rst:631
msgid ""
"It also allows passing arbitrary values and retrieving them through the "
":data:`sys._xoptions` dictionary."
msgstr "또한 :data:`sys._xoptions` 딕셔너리를 통해 임의의 값을 전달하고 조회할 수 있도록 합니다."

#: ../../using/cmdline.rst:636
#, fuzzy
msgid "Removed the ``-X showalloccount`` option."
msgstr "``-X showalloccount`` 옵션."

#: ../../using/cmdline.rst:639
#, fuzzy
msgid "Removed the ``-X oldparser`` option."
msgstr "``-X oldparser`` 옵션."

#: ../../using/cmdline.rst:645
msgid "Controlling color"
msgstr ""

#: ../../using/cmdline.rst:647
msgid ""
"The Python interpreter is configured by default to use colors to "
"highlight output in certain situations such as when displaying "
"tracebacks. This behavior can be controlled by setting different "
"environment variables."
msgstr ""

#: ../../using/cmdline.rst:651
msgid "Setting the environment variable ``TERM`` to ``dumb`` will disable color."
msgstr ""

#: ../../using/cmdline.rst:653
msgid ""
"If the |FORCE_COLOR|_ environment variable is set, then color will be "
"enabled regardless of the value of TERM. This is useful on CI systems "
"which aren’t terminals but can still display ANSI escape sequences."
msgstr ""

#: ../../using/cmdline.rst:657
msgid ""
"If the |NO_COLOR|_ environment variable is set, Python will disable all "
"color in the output. This takes precedence over ``FORCE_COLOR``."
msgstr ""

#: ../../using/cmdline.rst:660
msgid ""
"All these environment variables are used also by other tools to control "
"color output. To control the color output only in the Python interpreter,"
" the :envvar:`PYTHON_COLORS` environment variable can be used. This "
"variable takes precedence over ``NO_COLOR``, which in turn takes "
"precedence over ``FORCE_COLOR``."
msgstr ""

#: ../../using/cmdline.rst:675
msgid "Options you shouldn't use"
msgstr "사용해서는 안 되는 옵션"

#: ../../using/cmdline.rst:679
msgid "Reserved for use by Jython_."
msgstr "Jython_ 이 사용하기 위해 예약되었습니다."

#: ../../using/cmdline.rst:687
msgid "Environment variables"
msgstr "환경 변수"

#: ../../using/cmdline.rst:689
msgid ""
"These environment variables influence Python's behavior, they are "
"processed before the command-line switches other than -E or -I.  It is "
"customary that command-line switches override environmental variables "
"where there is a conflict."
msgstr ""
"이 환경 변수들은 파이썬의 동작에 영향을 주며, -E와 -I 이외의 명령 줄 스위치보다 먼저 처리됩니다. 충돌하면 명령 줄 스위치가"
" 환경 변수에 우선하는 것이 관례입니다."

#: ../../using/cmdline.rst:696
#, python-brace-format
msgid ""
"Change the location of the standard Python libraries.  By default, the "
"libraries are searched in :file:`{prefix}/lib/python{version}` and "
":file:`{exec_prefix}/lib/python{version}`, where :file:`{prefix}` and "
":file:`{exec_prefix}` are installation-dependent directories, both "
"defaulting to :file:`/usr/local`."
msgstr ""
"표준 파이썬 라이브러리의 위치를 변경합니다. 기본적으로, 라이브러리는 "
":file:`{prefix}/lib/python{version}`\\과 "
":file:`{exec_prefix}/lib/python{version}`\\에서 검색되는데, :file:`{prefix}` 와 "
":file:`{exec_prefix}` 는 설치 의존적인 디렉터리이고, 둘 다 기본값은 :file:`/usr/local` 입니다."

#: ../../using/cmdline.rst:702
#, python-brace-format
msgid ""
"When :envvar:`PYTHONHOME` is set to a single directory, its value "
"replaces both :file:`{prefix}` and :file:`{exec_prefix}`.  To specify "
"different values for these, set :envvar:`PYTHONHOME` to "
":file:`{prefix}:{exec_prefix}`."
msgstr ""
":envvar:`PYTHONHOME` 이 하나의 디렉터리로 설정되면, 그 값은 :file:`{prefix}` 와 "
":file:`{exec_prefix}` 를 모두 대체합니다. 이들에 대해 다른 값을 지정하려면, "
":envvar:`PYTHONHOME` 을 :file:`{prefix}:{exec_prefix}` 로 설정하십시오."

#: ../../using/cmdline.rst:709
msgid ""
"Augment the default search path for module files.  The format is the same"
" as the shell's :envvar:`PATH`: one or more directory pathnames separated"
" by :data:`os.pathsep` (e.g. colons on Unix or semicolons on Windows). "
"Non-existent directories are silently ignored."
msgstr ""
"모듈 파일의 기본 검색 경로를 보강합니다. 형식은 셸의 :envvar:`PATH` 와 같습니다: 하나 이상의 디렉터리 경로명이 "
":data:`os.pathsep` (예를 들어, 유닉스에서는 콜론, 윈도우에서는 세미콜론) 로 구분됩니다. 존재하지 않는 디렉터리는"
" 조용히 무시됩니다."

#: ../../using/cmdline.rst:714
msgid ""
"In addition to normal directories, individual :envvar:`PYTHONPATH` "
"entries may refer to zipfiles containing pure Python modules (in either "
"source or compiled form). Extension modules cannot be imported from "
"zipfiles."
msgstr ""
"일반 디렉터리 외에도, 개별 :envvar:`PYTHONPATH` 엔트리는 순수 파이썬 모듈(소스 또는 컴파일된 형식)을 포함하는 "
"zip 파일을 가리킬 수 있습니다. 확장 모듈은 zip 파일에서 임포트될 수 없습니다."

#: ../../using/cmdline.rst:718
#, python-brace-format
msgid ""
"The default search path is installation dependent, but generally begins "
"with :file:`{prefix}/lib/python{version}` (see :envvar:`PYTHONHOME` "
"above).  It is *always* appended to :envvar:`PYTHONPATH`."
msgstr ""
"기본 검색 경로는 설치 의존적이지만, 일반적으로 :file:`{prefix}/lib/python{version}`\\으로 시작합니다"
" (위의 :envvar:`PYTHONHOME` 을 참조하세요). *항상* :envvar:`PYTHONPATH` 에 추가됩니다."

#: ../../using/cmdline.rst:722
msgid ""
"An additional directory will be inserted in the search path in front of "
":envvar:`PYTHONPATH` as described above under :ref:`using-on-interface-"
"options`. The search path can be manipulated from within a Python program"
" as the variable :data:`sys.path`."
msgstr ""
"위에서 설명한 대로 :ref:`using-on-interface-options` 하에서는 :envvar:`PYTHONPATH` 앞에"
" 검색 경로에 추가 디렉터리가 삽입됩니다. 검색 경로는 파이썬 프로그램 내에서 :data:`sys.path` 변수로 조작할 수 "
"있습니다."

#: ../../using/cmdline.rst:730
#, fuzzy
msgid ""
"If this is set to a non-empty string, don't prepend a potentially unsafe "
"path to :data:`sys.path`: see the :option:`-P` option for details."
msgstr "비어 있지 않은 문자열로 설정하면, :option:`-u` 옵션을 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:738
msgid ""
"If this is set to a non-empty string, it overrides the "
":data:`sys.platlibdir` value."
msgstr "이것을 비어 있지 않은 문자열로 설정하면, :data:`sys.platlibdir` 값을 재정의합니다."

#: ../../using/cmdline.rst:746
msgid ""
"If this is the name of a readable file, the Python commands in that file "
"are executed before the first prompt is displayed in interactive mode.  "
"The file is executed in the same namespace where interactive commands are"
" executed so that objects defined or imported in it can be used without "
"qualification in the interactive session.  You can also change the "
"prompts :data:`sys.ps1` and :data:`sys.ps2` and the hook "
":data:`sys.__interactivehook__` in this file."
msgstr ""
"이것이 읽을 수 있는 파일의 이름이면, 첫 번째 프롬프트가 대화형 모드에 표시되기 전에, 해당 파일의 파이썬 명령이 실행됩니다. 이"
" 파일은 대화형 명령이 실행되는 것과 같은 이름 공간에서 실행되므로, 여기에서 정의되거나 임포트 한 객체를 대화형 세션에서 그대로 "
"사용할 수 있습니다. 이 파일에서 프롬프트 :data:`sys.ps1` 과 :data:`sys.ps2` 와 훅 "
":data:`sys.__interactivehook__` 도 바꿀 수 있습니다."

#: ../../using/cmdline.rst:753 ../../using/cmdline.rst:755
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython.run_startup`` with "
"the filename as the argument when called on startup."
msgstr ""
"시작 시 호출될 때 filename을 인자로 :ref:`감사 이벤트(auditing event) <auditing>` "
"``cpython.run_startup``\\을 발생시킵니다."

#: ../../using/cmdline.rst:761
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-O` option.  If set to an integer, it is equivalent to "
"specifying :option:`-O` multiple times."
msgstr ""
"비어 있지 않은 문자열로 설정하면 :option:`-O` 옵션을 지정하는 것과 같습니다. 정수로 설정하면, "
":option:`-O`\\를 여러 번 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:768
msgid ""
"If this is set, it names a callable using dotted-path notation.  The "
"module containing the callable will be imported and then the callable "
"will be run by the default implementation of :func:`sys.breakpointhook` "
"which itself is called by built-in :func:`breakpoint`.  If not set, or "
"set to the empty string, it is equivalent to the value \"pdb.set_trace\"."
"  Setting this to the string \"0\" causes the default implementation of "
":func:`sys.breakpointhook` to do nothing but return immediately."
msgstr ""
"설정되면, 점으로 구분된 경로 표기법을 사용하여 콜러블의 이름을 지정합니다. 콜러블을 포함하는 모듈이 임포트 된 후에 콜러블은, "
"내장 :func:`breakpoint` 에 의해 호출되는 :func:`sys.breakpointhook` 의 기본 구현이 "
"실행합니다. 설정되지 않았거나 빈 문자열로 설정하면, 값 \"pdb.set_trace\"와 동등합니다. 문자열 \"0\"으로 "
"설정하면, :func:`sys.breakpointhook` 의 기본 구현은 아무것도 하지 않고 즉시 반환합니다."

#: ../../using/cmdline.rst:780
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-d` option.  If set to an integer, it is equivalent to "
"specifying :option:`-d` multiple times."
msgstr ""
"비어 있지 않은 문자열로 설정하면, :option:`-d` 옵션을 지정하는 것과 같습니다. 정수로 설정하면, "
":option:`-d`\\를 여러 번 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:784
msgid ""
"This environment variable requires a :ref:`debug build of Python <debug-"
"build>`, otherwise it's ignored."
msgstr ""

#: ../../using/cmdline.rst:790
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-i` option."
msgstr "비어 있지 않은 문자열로 설정하면, :option:`-i` 옵션을 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:793
msgid ""
"This variable can also be modified by Python code using "
":data:`os.environ` to force inspect mode on program termination."
msgstr ""
"이 변수는 프로그램 종료 시 검사 모드를 강제하기 위해, :data:`os.environ` 을 사용해서 파이썬 코드에 의해 수정될 "
"수도 있습니다."

#: ../../using/cmdline.rst:798
msgid "(also 3.11.10, 3.10.15, 3.9.20, and 3.8.20) Emits audit events."
msgstr ""

#: ../../using/cmdline.rst:801
msgid ""
"Uses PyREPL if possible, in which case :envvar:`PYTHONSTARTUP` is also "
"executed. Emits audit events."
msgstr ""

#: ../../using/cmdline.rst:808
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-u` option."
msgstr "비어 있지 않은 문자열로 설정하면, :option:`-u` 옵션을 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:814
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-v` option.  If set to an integer, it is equivalent to "
"specifying :option:`-v` multiple times."
msgstr ""
"비어 있지 않은 문자열로 설정하면, :option:`-v` 옵션을 지정하는 것과 같습니다. 정수로 설정하면 "
":option:`-v`\\를 여러 번 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:821
#, fuzzy
msgid ""
"If this is set, Python ignores case in :keyword:`import` statements.  "
"This only works on Windows and macOS."
msgstr "설정되면, 파이썬은 :keyword:`import` 문에서 대소 문자를 무시합니다. 이것은 윈도우와 OS X에서만 작동합니다."

#: ../../using/cmdline.rst:827
msgid ""
"If this is set to a non-empty string, Python won't try to write ``.pyc`` "
"files on the import of source modules.  This is equivalent to specifying "
"the :option:`-B` option."
msgstr ""
"비어 있지 않은 문자열로 설정되면, 파이썬은 소스 모듈을 임포트 할 때 ``.pyc`` 파일을 쓰지 않습니다. 이는 "
":option:`-B` 옵션을 지정하는 것과 같습니다."

#: ../../using/cmdline.rst:834
msgid ""
"If this is set, Python will write ``.pyc`` files in a mirror directory "
"tree at this path, instead of in ``__pycache__`` directories within the "
"source tree. This is equivalent to specifying the :option:`-X` "
"``pycache_prefix=PATH`` option."
msgstr ""
"설정되면, 파이썬은 소스 트리 내의 ``__pycache__`` 디렉터리 대신에 이 경로에 있는 미러 디렉터리 트리에 "
"``.pyc`` 파일을 씁니다. 이것은 :option:`-X` ``pycache_prefix=PATH`` 옵션을 지정하는 것과 "
"동등합니다."

#: ../../using/cmdline.rst:844
msgid ""
"If this variable is not set or set to ``random``, a random value is used "
"to seed the hashes of str and bytes objects."
msgstr "이 변수가 설정되어 있지 않거나 ``random`` 으로 설정되면, str과 bytes 객체의 해시 시드에 난수가 사용됩니다."

#: ../../using/cmdline.rst:847
msgid ""
"If :envvar:`PYTHONHASHSEED` is set to an integer value, it is used as a "
"fixed seed for generating the hash() of the types covered by the hash "
"randomization."
msgstr ""
":envvar:`PYTHONHASHSEED` 가 정숫값으로 설정되면, 해시 무작위화가 적용되는 형의 hash()를 생성하기 위한 "
"고정 시드로 사용됩니다."

#: ../../using/cmdline.rst:851
msgid ""
"Its purpose is to allow repeatable hashing, such as for selftests for the"
" interpreter itself, or to allow a cluster of python processes to share "
"hash values."
msgstr ""
"목적은 인터프리터 자체에 대한 셀프 테스트와 같은 이유로 반복 가능한 해싱을 허용하거나, 파이썬 프로세스 클러스터가 해시값을 "
"공유하도록 허용하는 것입니다."

#: ../../using/cmdline.rst:855
msgid ""
"The integer must be a decimal number in the range [0,4294967295].  "
"Specifying the value 0 will disable hash randomization."
msgstr "정수는 [0,4294967295] 범위의 십진수여야 합니다. 값 0을 지정하면 해시 무작위화가 비활성화됩니다."

#: ../../using/cmdline.rst:862
msgid ""
"If this variable is set to an integer, it is used to configure the "
"interpreter's global :ref:`integer string conversion length limitation "
"<int_max_str_digits>`."
msgstr ""

#: ../../using/cmdline.rst:870
msgid ""
"If this is set before running the interpreter, it overrides the encoding "
"used for stdin/stdout/stderr, in the syntax "
"``encodingname:errorhandler``.  Both the ``encodingname`` and the "
"``:errorhandler`` parts are optional and have the same meaning as in "
":func:`str.encode`."
msgstr ""
"인터프리터를 실행하기 전에 이것이 설정되면, stdin/stdout/stderr에 사용되는 인코딩을 대체합니다. 문법은 "
"``encodingname:errorhandler`` 형식입니다. ``encodingname`` 과 ``:errorhandler``"
" 부분은 모두 선택 사항이며 :func:`str.encode` 에서와 같은 의미입니다."

#: ../../using/cmdline.rst:875
msgid ""
"For stderr, the ``:errorhandler`` part is ignored; the handler will "
"always be ``'backslashreplace'``."
msgstr ""
"stderr의 경우, ``:errorhandler`` 부분은 무시됩니다; 처리기는 항상 ``'backslashreplace'`` "
"입니다."

#: ../../using/cmdline.rst:878
msgid "The ``encodingname`` part is now optional."
msgstr "``encodingname`` 부분은 이제 선택적입니다."

#: ../../using/cmdline.rst:881
msgid ""
"On Windows, the encoding specified by this variable is ignored for "
"interactive console buffers unless :envvar:`PYTHONLEGACYWINDOWSSTDIO` is "
"also specified. Files and pipes redirected through the standard streams "
"are not affected."
msgstr ""
"Windows에서, :envvar:`PYTHONLEGACYWINDOWSSTDIO` 도 지정하지 않는 한, 대화형 콘솔 버퍼에서 이 "
"변수로 지정된 인코딩이 무시됩니다. 표준 스트림을 통해 리디렉션 된 파일과 파이프는 영향을 받지 않습니다."

#: ../../using/cmdline.rst:888
msgid ""
"If this is set, Python won't add the :data:`user site-packages directory "
"<site.USER_SITE>` to :data:`sys.path`."
msgstr ""
"설정되면, 파이썬은 :data:`사용자 site-packages 디렉터리 <site.USER_SITE>` 를 "
":data:`sys.path` 에 추가하지 않습니다."

#: ../../using/cmdline.rst:898
#, fuzzy
msgid ""
"Defines the :data:`user base directory <site.USER_BASE>`, which is used "
"to compute the path of the :data:`user site-packages directory "
"<site.USER_SITE>` and :ref:`installation paths <sysconfig-user-scheme>` "
"for ``python -m pip install --user``."
msgstr ""
"``python setup.py install --user`` 에서 :data:`사용자 site-packages 디렉터리 "
"<site.USER_SITE>` 의 경로와 :ref:`Distutils 설치 경로 <inst-alt-install-user>` 를 "
"계산하기 위해 사용되는 :data:`사용자 베이스 디렉터리 <site.USER_BASE>` 를 정의합니다."

#: ../../using/cmdline.rst:910
#, fuzzy
msgid ""
"If this environment variable is set, ``sys.argv[0]`` will be set to its "
"value instead of the value got through the C runtime.  Only works on "
"macOS."
msgstr ""
"이 환경 변수가 설정되면, ``sys.argv[0]`` 는 C 런타임을 통해 얻은 값 대신에 이 값으로 설정됩니다. 맥 OS "
"X에서만 작동합니다."

#: ../../using/cmdline.rst:916
msgid ""
"This is equivalent to the :option:`-W` option. If set to a comma "
"separated string, it is equivalent to specifying :option:`-W` multiple "
"times, with filters later in the list taking precedence over those "
"earlier in the list."
msgstr ""
":option:`-W` 옵션과 동등합니다. 쉼표로 구분된 문자열로 설정하면, :option:`-W`\\를 여러 번 지정하는 것과 "
"같습니다. 목록의 뒷부분에 있는 필터는 목록의 이전 필터보다 우선합니다."

#: ../../using/cmdline.rst:925
msgid ""
"PYTHONWARNINGS=default  # Warn once per call location\n"
"PYTHONWARNINGS=error    # Convert to exceptions\n"
"PYTHONWARNINGS=always   # Warn every time\n"
"PYTHONWARNINGS=all      # Same as PYTHONWARNINGS=always\n"
"PYTHONWARNINGS=module   # Warn once per calling module\n"
"PYTHONWARNINGS=once     # Warn once per Python process\n"
"PYTHONWARNINGS=ignore   # Never warn"
msgstr ""

#: ../../using/cmdline.rst:939
#, fuzzy
msgid ""
"If this environment variable is set to a non-empty string, "
":func:`faulthandler.enable` is called at startup: install a handler for "
":const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, "
":const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` and "
":const:`~signal.SIGILL` signals to dump the Python traceback. This is "
"equivalent to :option:`-X` ``faulthandler`` option."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :func:`faulthandler.enable` 이 시작 시에 호출됩니다: "
"파이썬 트레이스백을 덤프하는 :const:`SIGSEGV`, :const:`SIGFPE`, :const:`SIGABRT`, "
":const:`SIGBUS` 그리고 :const:`SIGILL` 시그널 처리기를 설치합니다. 이는 :option:`-X` "
"``faulthandler`` 옵션과 동등합니다."

#: ../../using/cmdline.rst:951
#, fuzzy
msgid ""
"If this environment variable is set to a non-empty string, start tracing "
"Python memory allocations using the :mod:`tracemalloc` module. The value "
"of the variable is the maximum number of frames stored in a traceback of "
"a trace. For example, ``PYTHONTRACEMALLOC=1`` stores only the most recent"
" frame. See the :func:`tracemalloc.start` function for more information. "
"This is equivalent to setting the :option:`-X` ``tracemalloc`` option."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :mod:`tracemalloc` 모듈을 사용하여 파이썬 메모리 할당 추적을 "
"시작합니다. 변수의 값은 추적의 트레이스백에 저장되는 최대 프레임 수입니다. 예를 들어, ``PYTHONTRACEMALLOC=1``"
" 은 가장 최근의 프레임만을 저장합니다. 자세한 정보는 :func:`tracemalloc.start` 를 참조하십시오."

#: ../../using/cmdline.rst:964
#, fuzzy
msgid ""
"If this environment variable is set to a non-empty string, Python will "
"show how long each import takes. This is equivalent to setting the "
":option:`-X` ``importtime`` option."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, 파이썬은 각 임포트에 걸리는 시간을 보여줍니다. 이는 명령 줄에서 ``-X "
"importtime`` 을 설정하는 것과 정확히 같습니다."

#: ../../using/cmdline.rst:973
msgid ""
"If this environment variable is set to a non-empty string, enable the "
":ref:`debug mode <asyncio-debug-mode>` of the :mod:`asyncio` module."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :mod:`asyncio` 모듈의 :ref:`디버그 모드 <asyncio-"
"debug-mode>` 를 활성화합니다."

#: ../../using/cmdline.rst:981
msgid "Set the Python memory allocators and/or install debug hooks."
msgstr "파이썬 메모리 할당자를 설정하거나 디버그 훅을 설치합니다."

#: ../../using/cmdline.rst:983
msgid "Set the family of memory allocators used by Python:"
msgstr "파이썬이 사용하는 메모리 할당자를 설정합니다:"

#: ../../using/cmdline.rst:985
msgid ""
"``default``: use the :ref:`default memory allocators <default-memory-"
"allocators>`."
msgstr "``default``: :ref:`기본 메모리 할당자 <default-memory-allocators>` 를 사용합니다."

#: ../../using/cmdline.rst:987
#, fuzzy
msgid ""
"``malloc``: use the :c:func:`malloc` function of the C library for all "
"domains (:c:macro:`PYMEM_DOMAIN_RAW`, :c:macro:`PYMEM_DOMAIN_MEM`, "
":c:macro:`PYMEM_DOMAIN_OBJ`)."
msgstr ""
"``malloc``: 모든 영역(:c:data:`PYMEM_DOMAIN_RAW`, :c:data:`PYMEM_DOMAIN_MEM`,"
" :c:data:`PYMEM_DOMAIN_OBJ`)에서 C 라이브러리의 :c:func:`malloc` 함수를 사용합니다."

#: ../../using/cmdline.rst:990
#, fuzzy
msgid ""
"``pymalloc``: use the :ref:`pymalloc allocator <pymalloc>` for "
":c:macro:`PYMEM_DOMAIN_MEM` and :c:macro:`PYMEM_DOMAIN_OBJ` domains and "
"use the :c:func:`malloc` function for the :c:macro:`PYMEM_DOMAIN_RAW` "
"domain."
msgstr ""
"``pymalloc``: :c:data:`PYMEM_DOMAIN_MEM`\\과 :c:data:`PYMEM_DOMAIN_OBJ` "
"영역에서 :ref:`pymalloc 할당자 <pymalloc>` 를 사용하고, :c:data:`PYMEM_DOMAIN_RAW` "
"영역에서 :c:func:`malloc` 함수를 사용합니다."

#: ../../using/cmdline.rst:993
#, fuzzy
msgid ""
"``mimalloc``: use the :ref:`mimalloc allocator <mimalloc>` for "
":c:macro:`PYMEM_DOMAIN_MEM` and :c:macro:`PYMEM_DOMAIN_OBJ` domains and "
"use the :c:func:`malloc` function for the :c:macro:`PYMEM_DOMAIN_RAW` "
"domain."
msgstr ""
"``pymalloc``: :c:data:`PYMEM_DOMAIN_MEM`\\과 :c:data:`PYMEM_DOMAIN_OBJ` "
"영역에서 :ref:`pymalloc 할당자 <pymalloc>` 를 사용하고, :c:data:`PYMEM_DOMAIN_RAW` "
"영역에서 :c:func:`malloc` 함수를 사용합니다."

#: ../../using/cmdline.rst:997
msgid "Install :ref:`debug hooks <pymem-debug-hooks>`:"
msgstr ""

#: ../../using/cmdline.rst:999
msgid ""
"``debug``: install debug hooks on top of the :ref:`default memory "
"allocators <default-memory-allocators>`."
msgstr "``debug``: :ref:`기본 메모리 할당자 <default-memory-allocators>` 위에 디버그 훅을 설치합니다."

#: ../../using/cmdline.rst:1001
msgid "``malloc_debug``: same as ``malloc`` but also install debug hooks."
msgstr "``malloc_debug``: ``malloc`` 과 같지만, 디버그 훅도 설치합니다."

#: ../../using/cmdline.rst:1002
msgid "``pymalloc_debug``: same as ``pymalloc`` but also install debug hooks."
msgstr "``pymalloc_debug``: ``pymalloc`` 과 같지만, 디버그 훅도 설치합니다."

#: ../../using/cmdline.rst:1003
#, fuzzy
msgid "``mimalloc_debug``: same as ``mimalloc`` but also install debug hooks."
msgstr "``malloc_debug``: ``malloc`` 과 같지만, 디버그 훅도 설치합니다."

#: ../../using/cmdline.rst:1007
msgid "Added the ``\"default\"`` allocator."
msgstr "``\"default\"`` 할당자를 추가했습니다."

#: ../../using/cmdline.rst:1013
msgid ""
"If set to a non-empty string, Python will print statistics of the "
":ref:`pymalloc memory allocator <pymalloc>` every time a new pymalloc "
"object arena is created, and on shutdown."
msgstr ""
"비어 있지 않은 문자열로 설정되면, 파이썬은 새로운 pymalloc 객체 영역이 생성될 때마다, 그리고 종료할 때 "
":ref:`pymalloc 메모리 할당자 <pymalloc>` 의 통계를 인쇄합니다."

#: ../../using/cmdline.rst:1017
msgid ""
"This variable is ignored if the :envvar:`PYTHONMALLOC` environment "
"variable is used to force the :c:func:`malloc` allocator of the C "
"library, or if Python is configured without ``pymalloc`` support."
msgstr ""
":envvar:`PYTHONMALLOC` 환경 변수를 사용하여 C 라이브러리의 :c:func:`malloc` 할당자를 강제로 "
"사용하거나, ``pymalloc`` 지원 없이 파이썬을 구성하면, 이 변수는 무시됩니다."

#: ../../using/cmdline.rst:1021
msgid ""
"This variable can now also be used on Python compiled in release mode. It"
" now has no effect if set to an empty string."
msgstr "이 변수는 이제 배포 모드로 컴파일된 파이썬에서도 사용할 수 있습니다. 이제 빈 문자열로 설정하면 효과가 없습니다."

#: ../../using/cmdline.rst:1028
#, fuzzy
msgid ""
"If set to a non-empty string, the default :term:`filesystem encoding and "
"error handler` mode will revert to their pre-3.6 values of 'mbcs' and "
"'replace', respectively.  Otherwise, the new defaults 'utf-8' and "
"'surrogatepass' are used."
msgstr ""
"비어 있지 않은 문자열로 설정하면, 기본 파일 시스템 인코딩과 에러 모드를 3.6 이전의 값인 'mbcs'와 'replace'로 "
"각각 되돌립니다. 그렇지 않으면, 새 기본값 'utf-8'과 'surrogatepass'가 사용됩니다."

#: ../../using/cmdline.rst:1033
#, fuzzy
msgid ""
"This may also be enabled at runtime with "
":func:`sys._enablelegacywindowsfsencoding`."
msgstr ""
"이것은 또한 실행 시간에 :func:`sys._enablelegacywindowsfsencoding()` 으로 활성화 될 수 "
"있습니다."

#: ../../using/cmdline.rst:1036 ../../using/cmdline.rst:1050
#: ../../using/cmdline.rst:1101
msgid "Availability"
msgstr "가용성"

#: ../../using/cmdline.rst:1038
msgid "See :pep:`529` for more details."
msgstr "자세한 내용은 :pep:`529`\\를 참조하십시오."

#: ../../using/cmdline.rst:1043
msgid ""
"If set to a non-empty string, does not use the new console reader and "
"writer. This means that Unicode characters will be encoded according to "
"the active console code page, rather than using utf-8."
msgstr ""
"비어 있지 않은 문자열로 설정하면, 새 콘솔 입력기와 출력기를 사용하지 않습니다. 이것은 유니코드 문자가 utf-8을 사용하는 대신"
" 활성 콘솔 코드 페이지에 따라 인코딩됨을 의미합니다."

#: ../../using/cmdline.rst:1047
msgid ""
"This variable is ignored if the standard streams are redirected (to files"
" or pipes) rather than referring to console buffers."
msgstr "이 변수는 표준 스트림이 콘솔 버퍼를 참조하는 대신 리디렉트 된 (파일 또는 파이프로) 경우 무시됩니다."

#: ../../using/cmdline.rst:1057
msgid ""
"If set to the value ``0``, causes the main Python command line "
"application to skip coercing the legacy ASCII-based C and POSIX locales "
"to a more capable UTF-8 based alternative."
msgstr ""
"값 ``0`` 으로 설정하면, 주 파이썬 명령 줄 응용 프로그램이 레거시 ASCII 기반 C와 POSIX 로케일을 보다 유능한 "
"UTF-8 기반 대안으로 강제 변환하지 않습니다."

#: ../../using/cmdline.rst:1061
msgid ""
"If this variable is *not* set (or is set to a value other than ``0``), "
"the ``LC_ALL`` locale override environment variable is also not set, and "
"the current locale reported for the ``LC_CTYPE`` category is either the "
"default ``C`` locale, or else the explicitly ASCII-based ``POSIX`` "
"locale, then the Python CLI will attempt to configure the following "
"locales for the ``LC_CTYPE`` category in the order listed before loading "
"the interpreter runtime:"
msgstr ""
"이 변수가 설정되지 *않고* (또는 ``0`` 이외의 값으로 설정되고), 환경 변수에 우선하는 ``LC_ALL`` 로케일도 설정되지"
" 않고, ``LC_CTYPE`` 범주에 대해 보고되는 현재 로케일이 기본 ``C`` 로케일이거나 명시적인 ASCII 기반의 "
"``POSIX`` 로케일이면, 파이썬 CLI는 인터프리터 런타임을 로드하기 전에 ``LC_CTYPE`` 범주에 대해 다음 로케일을 "
"나열된 순서대로 구성하려고 시도합니다:"

#: ../../using/cmdline.rst:1069
msgid "``C.UTF-8``"
msgstr "``C.UTF-8``"

#: ../../using/cmdline.rst:1070
msgid "``C.utf8``"
msgstr "``C.utf8``"

#: ../../using/cmdline.rst:1071
msgid "``UTF-8``"
msgstr "``UTF-8``"

#: ../../using/cmdline.rst:1073
msgid ""
"If setting one of these locale categories succeeds, then the ``LC_CTYPE``"
" environment variable will also be set accordingly in the current process"
" environment before the Python runtime is initialized. This ensures that "
"in addition to being seen by both the interpreter itself and other "
"locale-aware components running in the same process (such as the GNU "
"``readline`` library), the updated setting is also seen in subprocesses "
"(regardless of whether or not those processes are running a Python "
"interpreter), as well as in operations that query the environment rather "
"than the current C locale (such as Python's own "
":func:`locale.getdefaultlocale`)."
msgstr ""
"이러한 로케일 범주 중 하나를 설정하는 데 성공하면, 파이썬 런타임이 초기화되기 전에 ``LC_CTYPE`` 환경 변수도 현재 "
"프로세스 환경에서 적절히 설정됩니다. 이렇게 하면 인터프리터 자신과 같은 프로세스에서 실행되는 다른 로케일 인식 구성 요소(가령 "
"GNU ``readline`` 라이브러리)가 볼 수 있는 것에 더해, 갱신된 설정을 현재 C 로케일이 아닌 환경을 조회하는 "
"연산(가령 파이썬 자체의 :func:`locale.getdefaultlocale`)뿐만 아니라, 자식 프로세스에서도 (이 프로세스가"
" 파이썬 인터프리터를 실행하는지에 관계없이) 볼 수 있습니다."

#: ../../using/cmdline.rst:1083
msgid ""
"Configuring one of these locales (either explicitly or via the above "
"implicit locale coercion) automatically enables the ``surrogateescape`` "
":ref:`error handler <error-handlers>` for :data:`sys.stdin` and "
":data:`sys.stdout` (:data:`sys.stderr` continues to use "
"``backslashreplace`` as it does in any other locale). This stream "
"handling behavior can be overridden using :envvar:`PYTHONIOENCODING` as "
"usual."
msgstr ""
"이러한 로케일 중 하나를 구성하면 (명시적으로나 위의 묵시적 로케일 강제 변경을 통해) :data:`sys.stdin` 과 "
":data:`sys.stdout` 에 대해 ``surrogateescape`` :ref:`에러 처리기 <error-"
"handlers>` 를 자동으로 활성화합니다 (:data:`sys.stderr` 는 다른 로케일에서처럼 "
"``backslashreplace`` 를 계속 사용합니다). 이 스트림 처리 동작은 평소처럼 "
":envvar:`PYTHONIOENCODING`\\을 사용하여 대체할 수 있습니다."

#: ../../using/cmdline.rst:1090
msgid ""
"For debugging purposes, setting ``PYTHONCOERCECLOCALE=warn`` will cause "
"Python to emit warning messages on ``stderr`` if either the locale "
"coercion activates, or else if a locale that *would* have triggered "
"coercion is still active when the Python runtime is initialized."
msgstr ""
"디버깅을 위해, ``PYTHONCOERCECLOCALE=warn`` 을 설정하면, 로케일 강제 변경이 일어나거나, 그렇지 않고 강제"
" 변경을 *유발할* 로케일이 파이썬 런타임이 초기화될 때 여전히 활성 상태면 파이썬은 ``stderr`` 로 경고 메시지를 "
"보냅니다."

#: ../../using/cmdline.rst:1095
msgid ""
"Also note that even when locale coercion is disabled, or when it fails to"
" find a suitable target locale, :envvar:`PYTHONUTF8` will still activate "
"by default in legacy ASCII-based locales. Both features must be disabled "
"in order to force the interpreter to use ``ASCII`` instead of ``UTF-8`` "
"for system interfaces."
msgstr ""
"또한, 로케일 강제 변환이 비활성화되거나 적절한 대상 로케일을 찾지 못할 때도, 레거시 ASCII 기반 로케일에서 "
":envvar:`PYTHONUTF8` 은 기본적으로 활성화됨에 유의하십시오. 인터프리터가 시스템 인터페이스에 대해 ``UTF-8``"
" 대신에 ``ASCII`` 를 사용하게 하려면, 두 가지 기능을 모두 비활성화시켜야 합니다."

#: ../../using/cmdline.rst:1103
msgid "See :pep:`538` for more details."
msgstr "자세한 내용은 :pep:`538`\\을 참조하십시오."

#: ../../using/cmdline.rst:1109
#, fuzzy
msgid ""
"If this environment variable is set to a non-empty string, enable "
":ref:`Python Development Mode <devmode>`, introducing additional runtime "
"checks that are too expensive to be enabled by default. This is "
"equivalent to setting the :option:`-X` ``dev`` option."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :ref:`파이썬 개발 모드 <devmode>`\\를 활성화하여, 기본적으로 "
"활성화하기에는 너무 비싼 추가 실행 시간 검사를 도입합니다."

#: ../../using/cmdline.rst:1118
msgid "If set to ``1``, enable the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr ""

#: ../../using/cmdline.rst:1120
msgid "If set to ``0``, disable the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr ""

#: ../../using/cmdline.rst:1122
msgid ""
"Setting any other non-empty string causes an error during interpreter "
"initialisation."
msgstr "다른 모든 비어 있지 않은 문자열로 설정하면, 인터프리터를 초기화하는 동안 에러가 발생합니다."

#: ../../using/cmdline.rst:1129
msgid ""
"If this environment variable is set to a non-empty string, issue a "
":class:`EncodingWarning` when the locale-specific default encoding is "
"used."
msgstr ""

#: ../../using/cmdline.rst:1132
msgid "See :ref:`io-encoding-warning` for details."
msgstr ""

#: ../../using/cmdline.rst:1138
msgid ""
"If this variable is set, it disables the inclusion of the tables mapping "
"extra location information (end line, start column offset and end column "
"offset) to every instruction in code objects. This is useful when smaller"
" code objects and pyc files are desired as well as suppressing the extra "
"visual location indicators when the interpreter displays tracebacks."
msgstr ""

#: ../../using/cmdline.rst:1148
msgid ""
"If this variable is set to a nonzero value, it enables support for the "
"Linux ``perf`` profiler so Python calls can be detected by it."
msgstr ""

#: ../../using/cmdline.rst:1151 ../../using/cmdline.rst:1164
msgid "If set to ``0``, disable Linux ``perf`` profiler support."
msgstr ""

#: ../../using/cmdline.rst:1153
#, fuzzy
msgid ""
"See also the :option:`-X perf <-X>` command-line option and "
":ref:`perf_profiling`."
msgstr ":option:`-X` ``oldparser`` 옵션과 :pep:`617`\\도 참조하십시오."

#: ../../using/cmdline.rst:1160
msgid ""
"If this variable is set to a nonzero value, it enables support for the "
"Linux ``perf`` profiler so Python calls can be detected by it using DWARF"
" information."
msgstr ""

#: ../../using/cmdline.rst:1166
#, fuzzy
msgid ""
"See also the :option:`-X perf_jit <-X>` command-line option and "
":ref:`perf_profiling`."
msgstr ":option:`-X` ``oldparser`` 옵션과 :pep:`617`\\도 참조하십시오."

#: ../../using/cmdline.rst:1175
msgid ""
"If this variable is set to a positive integer, it overrides the return "
"values of :func:`os.cpu_count` and :func:`os.process_cpu_count`."
msgstr ""

#: ../../using/cmdline.rst:1178
#, fuzzy
msgid "See also the :option:`-X cpu_count <-X>` command-line option."
msgstr ":option:`-X` ``oldparser`` 옵션과 :pep:`617`\\도 참조하십시오."

#: ../../using/cmdline.rst:1184
msgid ""
"If this variable is set to ``on`` or ``off``, it determines whether or "
"not frozen modules are ignored by the import machinery.  A value of "
"``on`` means they get imported and ``off`` means they are ignored.  The "
"default is ``on`` for non-debug builds (the normal case) and ``off`` for "
"debug builds. Note that the :mod:`!importlib_bootstrap` and "
":mod:`!importlib_bootstrap_external` frozen modules are always used, even"
" if this flag is set to ``off``."
msgstr ""

#: ../../using/cmdline.rst:1192
msgid "See also the :option:`-X frozen_modules <-X>` command-line option."
msgstr ""

#: ../../using/cmdline.rst:1198
msgid ""
"If this variable is set to ``1``, the interpreter will colorize various "
"kinds of output. Setting it to ``0`` deactivates this behavior. See also "
":ref:`using-on-controlling-color`."
msgstr ""

#: ../../using/cmdline.rst:1206
msgid ""
"If this variable is set to any value, the interpreter will not attempt to"
" load the Python-based :term:`REPL` that requires :mod:`curses` and "
":mod:`readline`, and will instead use the traditional parser-based "
":term:`REPL`."
msgstr ""

#: ../../using/cmdline.rst:1215
msgid ""
"This environment variable can be used to set the location of a "
"``.python_history`` file (by default, it is ``.python_history`` in the "
"user's home directory)."
msgstr ""

#: ../../using/cmdline.rst:1223
msgid ""
"If this variable is set to ``1``, the global interpreter lock (GIL) will "
"be forced on. Setting it to ``0`` forces the GIL off (needs Python "
"configured with the :option:`--disable-gil` build option)."
msgstr ""

#: ../../using/cmdline.rst:1227
msgid ""
"See also the :option:`-X gil <-X>` command-line option, which takes "
"precedence over this variable, and :ref:`whatsnew313-free-threaded-"
"cpython`."
msgstr ""

#: ../../using/cmdline.rst:1233
msgid "Debug-mode variables"
msgstr "디버그 모드 변수"

#: ../../using/cmdline.rst:1237
msgid ""
"If set, Python will dump objects and reference counts still alive after "
"shutting down the interpreter."
msgstr "설정되면, 파이썬은 인터프리터를 종료한 후에도 살아있는 객체와 참조 횟수를 덤프합니다."

#: ../../using/cmdline.rst:1240 ../../using/cmdline.rst:1248
#, fuzzy
msgid "Needs Python configured with the :option:`--with-trace-refs` build option."
msgstr "파이썬이 ``--with-trace-refs`` 빌드 옵션으로 구성되었어야 합니다."

#: ../../using/cmdline.rst:1244
#, fuzzy
msgid ""
"If set, Python will dump objects and reference counts still alive after "
"shutting down the interpreter into a file under the path given as the "
"value to this environment variable."
msgstr "설정되면, 파이썬은 인터프리터를 종료한 후에도 살아있는 객체와 참조 횟수를 덤프합니다."

#: ../../using/cmdline.rst:1254
msgid ""
"If this variable is set to a module, that module will be imported early "
"in the interpreter lifecycle, before the :mod:`site` module is executed, "
"and before the :mod:`__main__` module is created. Therefore, the imported"
" module is not treated as :mod:`__main__`."
msgstr ""

#: ../../using/cmdline.rst:1259
msgid "This can be used to execute code early during Python initialization."
msgstr ""

#: ../../using/cmdline.rst:1261
msgid ""
"To import a submodule, use ``package.module`` as the value, like in an "
"import statement."
msgstr ""

#: ../../using/cmdline.rst:1264
msgid ""
"See also the :option:`-X presite <-X>` command-line option, which takes "
"precedence over this variable."
msgstr ""

#: ../../using/cmdline.rst:1267
#, fuzzy
msgid "Needs Python configured with the :option:`--with-pydebug` build option."
msgstr "파이썬이 ``--with-pydebug`` 빌드 옵션으로 구성되었어야 합니다."

#~ msgid ""
#~ "By default, each warning is printed "
#~ "once for each source line where it"
#~ " occurs.  This option controls how "
#~ "often warnings are printed."
#~ msgstr "기본적으로, 각 경고는 발생하는 각 소스 행마다 한 번씩 인쇄됩니다. 이 옵션은 경고 인쇄 빈도를 제어합니다."

#~ msgid ""
#~ "``-X oldparser``: enable the traditional "
#~ "LL(1) parser.  See also "
#~ ":envvar:`PYTHONOLDPARSER` and :pep:`617`."
#~ msgstr ""
#~ "``-X oldparser``: 기존 LL(1) 파서를 활성화합니다."
#~ " :envvar:`PYTHONOLDPARSER`\\와 :pep:`617`\\도 참조하십시오."

#~ msgid "The ``-X faulthandler`` option."
#~ msgstr "``-X faulthandler`` 옵션."

#~ msgid "The ``-X showrefcount`` and ``-X tracemalloc`` options."
#~ msgstr "``-X showrefcount`` 와 ``-X tracemalloc`` 옵션."

#~ msgid "The ``-X importtime``, ``-X dev`` and ``-X utf8`` options."
#~ msgstr "``-X importtime``, ``-X dev``, ``-X utf8`` 옵션."

#~ msgid ""
#~ "The ``-X pycache_prefix`` option. The "
#~ "``-X dev`` option now logs ``close()``"
#~ " exceptions in :class:`io.IOBase` destructor."
#~ msgstr ""
#~ "``-X pycache_prefix`` 옵션. ``-X dev`` 옵션은"
#~ " 이제 :class:`io.IOBase` 파괴자에서 ``close()`` "
#~ "예외를 로그 합니다."

#~ msgid ""
#~ "Using ``-X dev`` option, check "
#~ "*encoding* and *errors* arguments on "
#~ "string encoding and decoding operations."
#~ msgstr ""
#~ "``-X dev`` 옵션을 사용하여, 문자열 인코딩과 디코딩"
#~ " 연산에서 *encoding*\\과 *errors* 인자를 확인합니다."

#~ msgid "The ``-X showalloccount`` option has been removed."
#~ msgstr "``-X showalloccount`` 옵션이 제거되었습니다."

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` "
#~ "``cpython.run_startup`` with argument ``filename``."
#~ msgstr ""
#~ "``filename``\\을 인자로 :ref:`감사 이벤트(auditing "
#~ "event) <auditing>` ``cpython.run_startup``\\을 "
#~ "발생시킵니다."

#~ msgid ""
#~ "If this is set to a non-"
#~ "empty string, enable the traditional "
#~ "LL(1) parser."
#~ msgstr "이것을 비어 있지 않은 문자열로 설정하면, 전통적인 LL(1) 구문 분석기를 활성화합니다."

#~ msgid "Install debug hooks:"
#~ msgstr "디버그 훅을 설치합니다:"

#~ msgid ""
#~ "See the :ref:`default memory allocators "
#~ "<default-memory-allocators>` and the "
#~ ":c:func:`PyMem_SetupDebugHooks` function (install "
#~ "debug hooks on Python memory "
#~ "allocators)."
#~ msgstr ""
#~ ":ref:`기본 메모리 할당자 <default-memory-"
#~ "allocators>` 와 :c:func:`PyMem_SetupDebugHooks` "
#~ "함수(파이썬 메모리 할당자에 디버그 훅을 설치합니다)도 "
#~ "참조하세요."

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`가용성 <availability>`: 윈도우."

#~ msgid ":ref:`Availability <availability>`: \\*nix."
#~ msgstr ":ref:`가용성 <availability>`: 유닉스."

#~ msgid ""
#~ "If set to ``1``, enables the "
#~ "interpreter's UTF-8 mode, where ``UTF-8`` "
#~ "is used as the text encoding for"
#~ " system interfaces, regardless of the "
#~ "current locale setting."
#~ msgstr ""
#~ "``1`` 로 설정하면, 인터프리터의 UTF-8 모드가 "
#~ "활성화됩니다. 이 모드에서는 현재 로케일 설정에 상관없이,"
#~ " 시스템 인터페이스의 텍스트 인코딩으로 ``UTF-8`` 이 "
#~ "사용됩니다."

#~ msgid "This means that:"
#~ msgstr "이는 다음을 의미합니다:"

#~ msgid ""
#~ ":func:`sys.getfilesystemencoding()` returns ``'UTF-8'``"
#~ " (the locale encoding is ignored)."
#~ msgstr ""
#~ ":func:`sys.getfilesystemencoding()` 은 ``'UTF-8'`` 을"
#~ " 반환합니다 (로케일 인코딩은 무시됩니다)."

#~ msgid ""
#~ ":func:`locale.getpreferredencoding()` returns ``'UTF-8'``"
#~ " (the locale encoding is ignored, and"
#~ " the function's ``do_setlocale`` parameter "
#~ "has no effect)."
#~ msgstr ""
#~ ":func:`locale.getpreferredencoding()` 은 ``'UTF-8'`` "
#~ "을 반환합니다 (로케일 인코딩은 무시되고, 함수의 "
#~ "``do_setlocale`` 매개 변수는 아무런 효과가 없습니다)."

#~ msgid ""
#~ ":data:`sys.stdin`, :data:`sys.stdout`, and "
#~ ":data:`sys.stderr` all use UTF-8 as "
#~ "their text encoding, with the "
#~ "``surrogateescape`` :ref:`error handler <error-"
#~ "handlers>` being enabled for :data:`sys.stdin`"
#~ " and :data:`sys.stdout` (:data:`sys.stderr` "
#~ "continues to use ``backslashreplace`` as "
#~ "it does in the default locale-"
#~ "aware mode)"
#~ msgstr ""
#~ ":data:`sys.stdin`, :data:`sys.stdout`, :data:`sys.stderr`"
#~ " 모두 텍스트 인코딩으로 UTF-8을 사용하고, "
#~ ":data:`sys.stdin` 과 :data:`sys.stdout` 은 "
#~ "``surrogateescape`` :ref:`에러 처리기 <error-"
#~ "handlers>` 가 활성화됩니다 (:data:`sys.stderr` 은 "
#~ "기본 로케일 인식 모드와 같이 ``backslashreplace``"
#~ " 를 계속 사용합니다)"

#~ msgid ""
#~ "As a consequence of the changes in"
#~ " those lower level APIs, other higher"
#~ " level APIs also exhibit different "
#~ "default behaviours:"
#~ msgstr "이러한 하위 수준 API의 변경으로 인해, 다른 상위 수준 API도 다른 기본 동작을 수행합니다:"

#~ msgid ""
#~ "Command line arguments, environment variables"
#~ " and filenames are decoded to text"
#~ " using the UTF-8 encoding."
#~ msgstr "명령 줄 인자, 환경 변수 및 파일명은 UTF-8 인코딩을 사용하여 텍스트로 디코딩됩니다."

#~ msgid ":func:`os.fsdecode()` and :func:`os.fsencode()` use the UTF-8 encoding."
#~ msgstr ":func:`os.fsdecode()`\\와 :func:`os.fsencode()` 는 UTF-8 인코딩을 사용합니다."

#~ msgid ""
#~ ":func:`open()`, :func:`io.open()`, and "
#~ ":func:`codecs.open()` use the UTF-8 encoding"
#~ " by default. However, they still use"
#~ " the strict error handler by default"
#~ " so that attempting to open a "
#~ "binary file in text mode is likely"
#~ " to raise an exception rather than"
#~ " producing nonsense data."
#~ msgstr ""
#~ ":func:`open()`, :func:`io.open()`, :func:`codecs.open()`"
#~ " 은 기본적으로 UTF-8 인코딩을 사용합니다. 그러나, "
#~ "이들은 기본적으로 여전히 strict 에러 처리기를 "
#~ "사용하므로, 바이너리 파일을 텍스트 모드로 열려고 하면 "
#~ "말도 안 되는 데이터가 생성되는 대신 예외가 "
#~ "발생합니다."

#~ msgid ""
#~ "Note that the standard stream settings"
#~ " in UTF-8 mode can be overridden "
#~ "by :envvar:`PYTHONIOENCODING` (just as they"
#~ " can be in the default locale-"
#~ "aware mode)."
#~ msgstr ""
#~ "UTF-8 모드에서 표준 스트림 설정은 "
#~ ":envvar:`PYTHONIOENCODING` 의해 대체될 수 있습니다 "
#~ "(기본 로케일 인식 모드에서와 마찬가지로)."

#~ msgid "If set to ``0``, the interpreter runs in its default locale-aware mode."
#~ msgstr "``0`` 으로 설정하면, 인터프리터는 기본 로케일 인식 모드로 실행됩니다."

#~ msgid ""
#~ "If this environment variable is not "
#~ "set at all, then the interpreter "
#~ "defaults to using the current locale "
#~ "settings, *unless* the current locale is"
#~ " identified as a legacy ASCII-based"
#~ " locale (as described for "
#~ ":envvar:`PYTHONCOERCECLOCALE`), and locale coercion"
#~ " is either disabled or fails. In "
#~ "such legacy locales, the interpreter "
#~ "will default to enabling UTF-8 mode "
#~ "unless explicitly instructed not to do"
#~ " so."
#~ msgstr ""
#~ "이 환경 변수가 전혀 설정되지 않으면, 인터프리터는 "
#~ "현재 로케일이 레거시 ASCII 기반 "
#~ "로케일(:envvar:`PYTHONCOERCECLOCALE` 에서 설명하는 것처럼)로 "
#~ "식별되고, 로케일 강제 변경이 비활성화되거나 실패하지 지"
#~ " *않는 한*, 인터프리터는 현재 로케일 설정을 "
#~ "사용합니다. 이러한 레거시 로케일에서, 명시적으로 그렇게 하지"
#~ " 말라고 지시하지 않는 한, 인터프리터는 기본적으로 "
#~ "UTF-8 모드를 활성화합니다."

#~ msgid "Also available as the :option:`-X` ``utf8`` option."
#~ msgstr ":option:`-X` ``utf8`` 옵션으로도 사용 가능합니다."

#~ msgid "See :pep:`540` for more details."
#~ msgstr "자세한 내용은 :pep:`540`\\을 참조하십시오."

#~ msgid "Setting these variables only has an effect in a debug build of Python."
#~ msgstr "이 변수들을 설정하는 것은 파이썬의 디버그 빌드에서만 효과가 있습니다."

#~ msgid "If set, Python will print threading debug info."
#~ msgstr "설정되면, 파이썬은 스레딩 디버그 정보를 인쇄합니다."

