# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "모듈"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the "
"definitions you have made (functions and variables) are lost. Therefore, "
"if you want to write a somewhat longer program, you are better off using "
"a text editor to prepare the input for the interpreter and running it "
"with that file as input instead.  This is known as creating a *script*.  "
"As your program gets longer, you may want to split it into several files "
"for easier maintenance.  You may also want to use a handy function that "
"you've written in several programs without copying its definition into "
"each program."
msgstr ""
"파이썬 인터프리터를 종료한 후에 다시 들어가면, 여러분이 만들었던 정의들이 사라집니다 (함수나 변수들). 그래서, 좀 긴 프로그램을"
" 쓰고자 한다면, 대신 인터프리터 입력을 편집기를 사용해서 준비한 후에 그 파일을 입력으로 사용해서 실행하는 것이 좋습니다. 이렇게"
" 하는 것을 *스크립트* 를 만든다고 합니다. 프로그램이 길어짐에 따라, 유지를 쉽게 하려고 여러 개의 파일로 나누고 싶을 수 "
"있습니다. 여러 프로그램에서 썼던 편리한 함수를 각 프로그램에 정의를 복사하지 않고도 사용하고 싶을 수도 있습니다."

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use "
"them in a script or in an interactive instance of the interpreter. Such a"
" file is called a *module*; definitions from a module can be *imported* "
"into other modules or into the *main* module (the collection of variables"
" that you have access to in a script executed at the top level and in "
"calculator mode)."
msgstr ""
"이런 것을 지원하기 위해, 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 수 있는 방법을 제공합니다."
" 그런 파일을 *모듈* 이라고 부릅니다; 모듈로부터 정의들이 다른 모듈이나 *메인* 모듈로 *임포트* 될 수 있습니다 (메인 모듈은"
" 최상위 수준에서 실행되는 스크립트나 계산기 모드에서 액세스하는 변수들의 컬렉션입니다)."

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The "
"file name is the module name with the suffix :file:`.py` appended.  "
"Within a module, the module's name (as a string) is available as the "
"value of the global variable ``__name__``.  For instance, use your "
"favorite text editor to create a file called :file:`fibo.py` in the "
"current directory with the following contents::"
msgstr ""
"모듈은 파이썬 정의와 문장들을 담고 있는 파일입니다. 파일의 이름은 모듈 이름에 확장자 :file:`.py` 를 붙입니다. 모듈 "
"내에서, 모듈의 이름은 전역 변수 ``__name__`` 으로 제공됩니다. 예를 들어, 여러분이 좋아하는 편집기로 "
":file:`fibo.py` 라는 이름의 파일을 현재 디렉터리에 만들고 다음과 같은 내용으로 채웁니다::"

#: ../../tutorial/modules.rst:28
msgid ""
"# Fibonacci numbers module\n"
"\n"
"def fib(n):    # write Fibonacci series up to n\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        print(a, end=' ')\n"
"        a, b = b, a+b\n"
"    print()\n"
"\n"
"def fib2(n):   # return Fibonacci series up to n\n"
"    result = []\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        result.append(a)\n"
"        a, b = b, a+b\n"
"    return result"
msgstr ""

#: ../../tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the "
"following command::"
msgstr "이제 파이썬 인터프리터에 들어가서 이 모듈을 다음과 같은 명령으로 임포트 합니다::"

#: ../../tutorial/modules.rst:48
msgid ">>> import fibo"
msgstr ""

#: ../../tutorial/modules.rst:50
#, fuzzy
msgid ""
"This does not add the names of the functions defined in ``fibo``  "
"directly to the current :term:`namespace` (see :ref:`tut-scopes` for more"
" details); it only adds the module name ``fibo`` there. Using the module "
"name you can access the functions::"
msgstr ""
"이렇게 한다고 ``fibo`` 에 정의된 함수들의 이름이 현재 심볼 테이블에 직접 들어가지는 않습니다; 오직 모듈 이름 "
"``fibo`` 만 들어갈 뿐입니다. 이 모듈 이름을 사용해서 함수들을 액세스할 수 있습니다::"

#: ../../tutorial/modules.rst:55
msgid ""
">>> fibo.fib(1000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n"
">>> fibo.fib2(100)\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
">>> fibo.__name__\n"
"'fibo'"
msgstr ""

#: ../../tutorial/modules.rst:62
msgid "If you intend to use a function often you can assign it to a local name::"
msgstr "함수를 자주 사용할 거라면 지역 이름으로 대입할 수 있습니다::"

#: ../../tutorial/modules.rst:64
msgid ""
">>> fib = fibo.fib\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""

#: ../../tutorial/modules.rst:72
msgid "More on Modules"
msgstr "모듈 더 보기"

#: ../../tutorial/modules.rst:74
msgid ""
"A module can contain executable statements as well as function "
"definitions. These statements are intended to initialize the module. They"
" are executed only the *first* time the module name is encountered in an "
"import statement. [#]_ (They are also run if the file is executed as a "
"script.)"
msgstr ""
"모듈은 함수 정의뿐만 아니라 실행 가능한 문장들도 포함할 수 있습니다. 이 문장들은 모듈을 초기화하는 데 사용됩니다. 이것들은 "
"임포트 문에서 모듈 이름이 *처음* 등장할 때만 실행됩니다. [#]_ (이것들은 파일이 스크립트로 실행될 때도 실행됩니다.)"

#: ../../tutorial/modules.rst:79
#, fuzzy
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if "
"you know what you are doing you can touch a module's global variables "
"with the same notation used to refer to its functions, "
"``modname.itemname``."
msgstr ""
"각 모듈은 자신만의 심볼 테이블을 갖고 있는데, 그 모듈에서 정의된 함수들의 전역 심볼 테이블로 사용됩니다. 그래서, 모듈의 저자는"
" 사용자의 전역 변수와 우연히 충돌할 것을 걱정하지 않고 전역 변수를 사용할 수 있습니다. 반면에, 여러분이 무얼 하는지 안다면, "
"모듈의 함수를 참조하는데 사용된 것과 같은 표기법으로 모듈의 전역 변수들을 건드릴 수 있습니다, "
"``modname.itemname``."

#: ../../tutorial/modules.rst:86
#, fuzzy
msgid ""
"Modules can import other modules.  It is customary but not required to "
"place all :keyword:`import` statements at the beginning of a module (or "
"script, for that matter).  The imported module names, if placed at the "
"top level of a module (outside any functions or classes), are added to "
"the module's global namespace."
msgstr ""
"모듈은 다른 모듈들을 임포트할 수 있습니다. 모든 :keyword:`import` 문들을 모듈의 처음에 놓는 것이 관례지만 반드시 "
"그래야 하는 것은 아닙니다 (그 점에 관한 한 스크립트도 마찬가집니다). 임포트되는 모듈 이름은 임포트하는 모듈의 전역 심볼 "
"테이블에 들어갑니다."

#: ../../tutorial/modules.rst:91
#, fuzzy
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For "
"example::"
msgstr ""
"모듈에 들어있는 이름들을 직접 임포트하는 모듈의 심볼 테이블로 임포트하는 :keyword:`import` 문의 변종이 있습니다. "
"예를 들어::"

#: ../../tutorial/modules.rst:94
msgid ""
">>> from fibo import fib, fib2\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""

#: ../../tutorial/modules.rst:98
#, fuzzy
msgid ""
"This does not introduce the module name from which the imports are taken "
"in the local namespace (so in the example, ``fibo`` is not defined)."
msgstr "이것은 지역 심볼 테이블에 임포트되는 모듈의 이름을 만들지 않습니다 (그래서 이 예에서는, ``fibo`` 가 정의되지 않습니다)."

#: ../../tutorial/modules.rst:101
msgid "There is even a variant to import all names that a module defines::"
msgstr "모듈이 정의하는 모든 이름을 임포트하는 변종도 있습니다::"

#: ../../tutorial/modules.rst:103
msgid ""
">>> from fibo import *\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""

#: ../../tutorial/modules.rst:107
msgid ""
"This imports all names except those beginning with an underscore (``_``)."
" In most cases Python programmers do not use this facility since it "
"introduces an unknown set of names into the interpreter, possibly hiding "
"some things you have already defined."
msgstr ""
"이것은 밑줄 (``_``) 로 시작하는 것들을 제외한 모든 이름을 임포트 합니다. 대부분 파이썬 프로그래머들은 이 기능을 사용하지 "
"않는데, 인터프리터로 알려지지 않은 이름들의 집합을 도입하게 되어, 여러분이 이미 정의한 것들을 가리게 될 수 있기 때문입니다."

#: ../../tutorial/modules.rst:112
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"일반적으로 모듈이나 패키지에서 ``*`` 를 임포트하는 것은 눈살을 찌푸리게 한다는 것에 유의하세요, 종종 읽기에 편하지 않은 "
"코드를 만들기 때문입니다. 하지만, 대화형 세션에서 입력을 줄이고자 사용하는 것은 상관없습니다."

#: ../../tutorial/modules.rst:116
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following"
" :keyword:`!as` is bound directly to the imported module."
msgstr "모듈 이름 다음에 :keyword:`!as` 가 올 경우, :keyword:`!as` 다음의 이름을 임포트한 모듈에 직접 연결합니다."

#: ../../tutorial/modules.rst:121
msgid ""
">>> import fibo as fib\n"
">>> fib.fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""

#: ../../tutorial/modules.rst:125
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as "
"``fib``."
msgstr ""
"이것은 ``import fibo`` 가하는 것과 같은 방식으로 모듈을 임포트 하는데, 유일한 차이점은 그 모듈을 ``fib`` 라는"
" 이름으로 사용할 수 있다는 것입니다."

#: ../../tutorial/modules.rst:128
msgid "It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ":keyword:`from`\\을 써서 비슷한 효과를 낼 때도 사용할 수 있습니다::"

#: ../../tutorial/modules.rst:130
msgid ""
">>> from fibo import fib as fibonacci\n"
">>> fibonacci(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""

#: ../../tutorial/modules.rst:137
msgid ""
"For efficiency reasons, each module is only imported once per interpreter"
" session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test "
"interactively, use :func:`importlib.reload`, e.g. ``import importlib; "
"importlib.reload(modulename)``."
msgstr ""
"효율성의 이유로, 각 모듈은 인터프리터 세션마다 한 번만 임포트됩니다. 그래서, 여러분이 모듈을 수정하면, 인터프리터를 다시 "
"시작시켜야 합니다 --- 또는, 대화형으로 시험하는 모듈이 하나뿐이라면, :func:`importlib.reload` 를 "
"사용하세요. 예를 들어, ``import importlib; importlib.reload(modulename)``."

#: ../../tutorial/modules.rst:147
msgid "Executing modules as scripts"
msgstr "모듈을 스크립트로 실행하기"

#: ../../tutorial/modules.rst:149
msgid "When you run a Python module with ::"
msgstr "여러분이 파이썬 모듈을 이렇게 실행하면 ::"

#: ../../tutorial/modules.rst:151
msgid "python fibo.py <arguments>"
msgstr ""

#: ../../tutorial/modules.rst:153
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding"
" this code at the end of your module::"
msgstr ""
"모듈에 있는 코드는, 그것을 임포트할 때처럼 실행됩니다. 하지만 ``__name__`` 은 ``\"__main__\"`` 로 "
"설정됩니다. 이것은, 이 코드를 모듈의 끝에 붙여서::"

#: ../../tutorial/modules.rst:157
msgid ""
"if __name__ == \"__main__\":\n"
"    import sys\n"
"    fib(int(sys.argv[1]))"
msgstr ""

#: ../../tutorial/modules.rst:161
msgid ""
"you can make the file usable as a script as well as an importable module,"
" because the code that parses the command line only runs if the module is"
" executed as the \"main\" file:"
msgstr ""
"파일을 임포트할 수 있는 모듈뿐만 아니라 스크립트로도 사용할 수 있도록 만들 수 있음을 의미하는데, 오직 모듈이 \"메인\" 파일로"
" 실행될 때만 명령행을 파싱하는 코드가 실행되기 때문입니다:"

#: ../../tutorial/modules.rst:165
msgid ""
"$ python fibo.py 50\n"
"0 1 1 2 3 5 8 13 21 34"
msgstr ""

#: ../../tutorial/modules.rst:170
msgid "If the module is imported, the code is not run::"
msgstr "모듈이 임포트될 때, 코드는 실행되지 않습니다::"

#: ../../tutorial/modules.rst:172
msgid ""
">>> import fibo\n"
">>>"
msgstr ""

#: ../../tutorial/modules.rst:175
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes "
"a test suite)."
msgstr ""
"이것은 종종 모듈에 대한 편리한 사용자 인터페이스를 제공하거나 테스트 목적으로 사용됩니다 (모듈을 스크립트로 실행하면 테스트 "
"스위트를 실행하기)."

#: ../../tutorial/modules.rst:182
msgid "The Module Search Path"
msgstr "모듈 검색 경로"

#: ../../tutorial/modules.rst:186
#, fuzzy
msgid ""
"When a module named :mod:`!spam` is imported, the interpreter first "
"searches for a built-in module with that name. These module names are "
"listed in :data:`sys.builtin_module_names`. If not found, it then "
"searches for a file named :file:`spam.py` in a list of directories given "
"by the variable :data:`sys.path`.  :data:`sys.path` is initialized from "
"these locations:"
msgstr ""
":mod:`spam` 이라는 이름의 모듈이 임포트될 때, 인터프리터는 먼저 그 이름의 내장 모듈을 찾습니다. 발견되지 않으면, 변수"
" :data:`sys.path` 로 주어지는 디렉터리들에서 :file:`spam.py` 라는 이름의 파일을 찾습니다. "
":data:`sys.path` 는 이 위치들로 초기화됩니다:"

#: ../../tutorial/modules.rst:192
msgid ""
"The directory containing the input script (or the current directory when "
"no file is specified)."
msgstr "입력 스크립트를 포함하는 디렉터리 (또는 파일이 지정되지 않았을 때는 현재 디렉터리)."

#: ../../tutorial/modules.rst:194
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as "
"the shell variable :envvar:`PATH`)."
msgstr ":envvar:`PYTHONPATH` (디렉터리 이름들의 목록, 셸 변수 :envvar:`PATH` 와 같은 문법)."

#: ../../tutorial/modules.rst:196
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""

#: ../../tutorial/modules.rst:199
msgid "More details are at :ref:`sys-path-init`."
msgstr ""

#: ../../tutorial/modules.rst:202
msgid ""
"On file systems which support symlinks, the directory containing the "
"input script is calculated after the symlink is followed. In other words "
"the directory containing the symlink is **not** added to the module "
"search path."
msgstr ""
"심볼릭 링크를 지원하는 파일 시스템에서, 입력 스크립트를 포함하는 디렉터리는 심볼릭 링크를 변환한 후에 계산됩니다. 다른 말로, "
"심볼릭 링크를 포함하는 디렉터리는 모듈 검색 경로에 포함되지 **않습니다**."

#: ../../tutorial/modules.rst:206
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of "
"the search path, ahead of the standard library path. This means that "
"scripts in that directory will be loaded instead of modules of the same "
"name in the library directory. This is an error unless the replacement is"
" intended.  See section :ref:`tut-standardmodules` for more information."
msgstr ""
"초기화 후에, 파이썬 프로그램은 :data:`sys.path` 를 수정할 수 있습니다. 스크립트를 포함하는 디렉터리는 검색 경로의 "
"처음에, 표준 라이브러리 경로의 앞에 놓입니다. 이것은 같은 이름일 경우 라이브러리 디렉터리에 있는 것 대신 스크립트를 포함하는 "
"디렉터리의 것이 로드된다는 뜻입니다. 이 치환이 의도된 것이 아니라면 에러입니다. 더 자세한 정보는 :ref:`tut-"
"standardmodules` 을 보세요."

#: ../../tutorial/modules.rst:219
msgid "\"Compiled\" Python files"
msgstr "\"컴파일된\" 파이썬 파일"

#: ../../tutorial/modules.rst:221
#, python-brace-format
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name "
":file:`module.{version}.pyc`, where the version encodes the format of the"
" compiled file; it generally contains the Python version number.  For "
"example, in CPython release 3.3 the compiled version of spam.py would be "
"cached as ``__pycache__/spam.cpython-33.pyc``.  This naming convention "
"allows compiled modules from different releases and different versions of"
" Python to coexist."
msgstr ""
"모듈 로딩을 빠르게 하려고, 파이썬은 ``__pycache__`` 디렉터리에 각 모듈의 컴파일된 버전을 "
":file:`module.{version}.pyc` 라는 이름으로 캐싱합니다. version 은 컴파일된 파일의 형식을 지정합니다;"
" 일반적으로 파이썬의 버전 번호를 포함합니다. 예를 들어, CPython 배포 3.3 에서 spam.py 의 컴파일된 버전은 "
"``__pycache__/spam.cpython-33.pyc`` 로 캐싱 됩니다. 이 명명법은 서로 다른 파이썬 배포와 버전의 "
"컴파일된 모듈들이 공존할 수 있도록 합니다."

#: ../../tutorial/modules.rst:229
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a"
" completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with "
"different architectures."
msgstr ""
"파이썬은 소스의 수정 시간을 컴파일된 버전과 비교해서 시효가 지나 다시 컴파일해야 하는지 검사합니다. 이것은 완전히 자동화된 "
"과정입니다. 또한, 컴파일된 모듈은 플랫폼 독립적이기 때문에, 같은 라이브러리를 서로 다른 아키텍처를 갖는 시스템들에서 공유할 수 "
"있습니다."

#: ../../tutorial/modules.rst:234
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and "
"there must not be a source module."
msgstr ""
"파이썬은 두 가지 상황에서 캐시를 검사하지 않습니다. 첫째로, 명령행에서 직접 로드되는 모듈들은 항상 재컴파일하고 그 결과를 "
"저장하지 않습니다. 둘째로, 소스 모듈이 없으면 캐시를 검사하지 않습니다. 소스 없는 (컴파일된 파일만 있는) 배포를 지원하려면, "
"컴파일된 모듈이 소스 디렉터리에 있어야 하고, 소스 모듈이 없어야 합니다."

#: ../../tutorial/modules.rst:241
msgid "Some tips for experts:"
msgstr "전문가를 위한 몇 가지 팁"

#: ../../tutorial/modules.rst:243
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python "
"command to reduce the size of a compiled module.  The ``-O`` switch "
"removes assert statements, the ``-OO`` switch removes both assert "
"statements and __doc__ strings.  Since some programs may rely on having "
"these available, you should only use this option if you know what you're "
"doing.  \"Optimized\" modules have an ``opt-`` tag and are usually "
"smaller.  Future releases may change the effects of optimization."
msgstr ""
"컴파일된 모듈의 크기를 줄이려면 파이썬 명령에 :option:`-O` 나 :option:`-OO` 스위치를 사용할 수 있습니다. "
"``-O`` 스위치는 assert 문을 제거하고, ``-OO`` 스위치는 assert 문과 __doc__ 문자열을 모두 제거합니다."
" 어떤 프로그램들은 이것들에 의존하기 때문에, 무엇을 하고 있는지 아는 경우만 이 옵션을 사용해야 합니다. \"최적화된\" 모듈은 "
"``opt-`` 태그를 갖고, 보통 더 작습니다. 미래의 배포에서는 최적화의 효과가 변경될 수 있습니다."

#: ../../tutorial/modules.rst:251
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file "
"than when it is read from a ``.py`` file; the only thing that's faster "
"about ``.pyc`` files is the speed with which they are loaded."
msgstr ""
"``.py`` 파일에서 읽을 때보다 ``.pyc`` 파일에서 읽을 때 프로그램이 더 빨리 실행되지는 않습니다; ``.pyc`` "
"파일에서 더 빨라지는 것은 로드되는 속도뿐입니다."

#: ../../tutorial/modules.rst:255
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr "모듈 :mod:`compileall` 은 디렉터리에 있는 모든 모듈의 .pyc 파일들을 만들 수 있습니다."

#: ../../tutorial/modules.rst:258
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr "이 절차에 대한 더 자세한 정보, 결정들의 순서도를 포함합니다, 는 :pep:`3147` 에 나옵니다."

#: ../../tutorial/modules.rst:265
msgid "Standard Modules"
msgstr "표준 모듈들"

#: ../../tutorial/modules.rst:269
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter)."
"  Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such "
"modules is a configuration option which also depends on the underlying "
"platform.  For example, the :mod:`winreg` module is only provided on "
"Windows systems. One particular module deserves some attention: "
":mod:`sys`, which is built into every Python interpreter.  The variables "
"``sys.ps1`` and ``sys.ps2`` define the strings used as primary and "
"secondary prompts::"
msgstr ""
"파이썬은 표준 모듈들의 라이브러리가 함께 오는데, 별도의 문서 파이썬 라이브러리 레퍼런스 (이후로는 \"라이브러리 레퍼런스\") "
"에서 설명합니다. 어떤 모듈들은 인터프리터에 내장됩니다; 이것들은 언어의 핵심적인 부분은 아니지만 그런데도 내장된 연산들에 대한 "
"액세스를 제공하는데, 효율이나 시스템 호출과 같은 운영 체제 기본 요소들에 대한 액세스를 제공하기 위함입니다. 그런 모듈들의 집합은"
" 설정 옵션인데 기반 플랫폼 의존적입니다. 예를 들어, :mod:`winreg` 모듈은 윈도우 시스템에서만 제공됩니다. 특별한 모듈"
" 하나는 주목을 받을 필요가 있습니다: :mod:`sys`. 모든 파이썬 인터프리터에 내장됩니다. 변수 ``sys.ps1`` 와 "
"``sys.ps2`` 는 기본과 보조 프롬프트로 사용되는 문자열을 정의합니다::"

#: ../../tutorial/modules.rst:281
msgid ""
">>> import sys\n"
">>> sys.ps1\n"
"'>>> '\n"
">>> sys.ps2\n"
"'... '\n"
">>> sys.ps1 = 'C> '\n"
"C> print('Yuck!')\n"
"Yuck!\n"
"C>"
msgstr ""

#: ../../tutorial/modules.rst:292
msgid ""
"These two variables are only defined if the interpreter is in interactive"
" mode."
msgstr "이 두 개의 변수들은 인터프리터가 대화형 모드일 때만 정의됩니다."

#: ../../tutorial/modules.rst:294
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default "
"path taken from the environment variable :envvar:`PYTHONPATH`, or from a "
"built-in default if :envvar:`PYTHONPATH` is not set.  You can modify it "
"using standard list operations::"
msgstr ""
"변수 ``sys.path`` 는 인터프리터의 모듈 검색 경로를 결정하는 문자열들의 리스트입니다. 환경 변수 "
":envvar:`PYTHONPATH` 에서 취한 기본 경로나, :envvar:`PYTHONPATH` 가 설정되지 않는 경우 내장 "
"기본값으로 초기화됩니다. 표준 리스트 연산을 사용해서 수정할 수 있습니다::"

#: ../../tutorial/modules.rst:300
msgid ""
">>> import sys\n"
">>> sys.path.append('/ufs/guido/lib/python')"
msgstr ""

#: ../../tutorial/modules.rst:307
msgid "The :func:`dir` Function"
msgstr ":func:`dir` 함수"

#: ../../tutorial/modules.rst:309
msgid ""
"The built-in function :func:`dir` is used to find out which names a "
"module defines.  It returns a sorted list of strings::"
msgstr "내장 함수 :func:`dir` 은 모듈이 정의하는 이름들을 찾는 데 사용됩니다. 문자열들의 정렬된 리스트를 돌려줍니다::"

#: ../../tutorial/modules.rst:312
msgid ""
">>> import fibo, sys\n"
">>> dir(fibo)\n"
"['__name__', 'fib', 'fib2']\n"
">>> dir(sys)\n"
"['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n"
" '__interactivehook__', '__loader__', '__name__', '__package__', "
"'__spec__',\n"
" '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n"
" '_clear_type_cache', '_current_frames', '_debugmallocstats', "
"'_framework',\n"
" '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n"
" 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n"
" 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n"
" 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', "
"'exc_info',\n"
" 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', "
"'float_info',\n"
" 'float_repr_style', 'get_asyncgen_hooks', "
"'get_coroutine_origin_tracking_depth',\n"
" 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n"
" 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n"
" 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n"
" 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n"
" 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n"
" 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n"
" 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', "
"'pycache_prefix',\n"
" 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', "
"'setdlopenflags',\n"
" 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', "
"'stderr',\n"
" 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', "
"'version_info',\n"
" 'warnoptions']"
msgstr ""

#: ../../tutorial/modules.rst:338
msgid ""
"Without arguments, :func:`dir` lists the names you have defined "
"currently::"
msgstr "인자가 없으면, :func:`dir` 는 현재 정의한 이름들을 나열합니다::"

#: ../../tutorial/modules.rst:340
msgid ""
">>> a = [1, 2, 3, 4, 5]\n"
">>> import fibo\n"
">>> fib = fibo.fib\n"
">>> dir()\n"
"['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']"
msgstr ""

#: ../../tutorial/modules.rst:346
msgid "Note that it lists all types of names: variables, modules, functions, etc."
msgstr "모든 형의 이름을 나열한다는 것에 유의해야 합니다: 변수, 모듈, 함수, 등등."

#: ../../tutorial/modules.rst:350
msgid ""
":func:`dir` does not list the names of built-in functions and variables."
"  If you want a list of those, they are defined in the standard module "
":mod:`builtins`::"
msgstr ""
":func:`dir` 은 내장 함수와 변수들의 이름을 나열하지 않습니다. 그것들의 목록을 원한다면, 표준 모듈 "
":mod:`builtins` 에 정의되어 있습니다::"

#: ../../tutorial/modules.rst:354
msgid ""
">>> import builtins\n"
">>> dir(builtins)\n"
"['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n"
" 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n"
" 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n"
" 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n"
" 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n"
" 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n"
" 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n"
" 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n"
" 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n"
" 'MemoryError', 'NameError', 'None', 'NotADirectoryError', "
"'NotImplemented',\n"
" 'NotImplementedError', 'OSError', 'OverflowError',\n"
" 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n"
" 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n"
" 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n"
" 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n"
" 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n"
" 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', "
"'UserWarning',\n"
" 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n"
" '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n"
" 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n"
" 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n"
" 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',"
"\n"
" 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', "
"'hasattr',\n"
" 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',"
"\n"
" 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n"
" 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', "
"'property',\n"
" 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',"
"\n"
" 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', "
"'vars',\n"
" 'zip']"
msgstr ""

#: ../../tutorial/modules.rst:389
msgid "Packages"
msgstr "패키지"

#: ../../tutorial/modules.rst:391
#, fuzzy
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`!A.B` "
"designates a submodule named ``B`` in a package named ``A``.  Just like "
"the use of modules saves the authors of different modules from having to "
"worry about each other's global variable names, the use of dotted module "
"names saves the authors of multi-module packages like NumPy or Pillow "
"from having to worry about each other's module names."
msgstr ""
"패키지는 \"점으로 구분된 모듈 이름\" 를 써서 파이썬의 모듈 이름 공간을 구조화하는 방법입니다. 예를 들어, 모듈 이름 "
":mod:`A.B` 는 ``A`` 라는 이름의 패키지에 있는 ``B`` 라는 이름의 서브 모듈을 가리킵니다. 모듈의 사용이 다른 "
"모듈의 저자들이 서로의 전역 변수 이름들을 걱정할 필요 없게 만드는 것과 마찬가지로, 점으로 구분된 모듈의 이름들은 NumPy 나 "
"Pillow 과 같은 다중 모듈 패키지들의 저자들이 서로의 모듈 이름들을 걱정할 필요 없게 만듭니다."

#: ../../tutorial/modules.rst:399
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for "
"the uniform handling of sound files and sound data.  There are many "
"different sound file formats (usually recognized by their extension, for "
"example: :file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to "
"create and maintain a growing collection of modules for the conversion "
"between the various file formats. There are also many different "
"operations you might want to perform on sound data (such as mixing, "
"adding echo, applying an equalizer function, creating an artificial "
"stereo effect), so in addition you will be writing a never-ending stream "
"of modules to perform these operations.  Here's a possible structure for "
"your package (expressed in terms of a hierarchical filesystem):"
msgstr ""
"음향 파일과 과 음향 데이터의 일관된 처리를 위한 모듈들의 컬렉션 (\"패키지\") 을 설계하길 원한다고 합시다. 여러 종류의 음향"
" 파일 형식이 있으므로 (보통 확장자로 구분됩니다, 예를 들어: :file:`.wav`, :file:`.aiff`, "
":file:`.au`), 다양한 파일 형식 간의 변환을 위해 계속 늘어나는 모듈들의 컬렉션을 만들고 유지할 필요가 있습니다. 또한,"
" 음향 데이터에 적용하고자 하는 많은 종류의 연산들도 있으므로 (믹싱, 에코 넣기, 이퀄라이저 기능 적용, 인공적인 스테레오 효과 "
"만들기와 같은), 이 연산들을 수행하기 위한 모듈들을 끊임없이 작성하게 될 것입니다. 패키지를 이렇게 구성해 볼 수 있습니다 "
"(계층적 파일 시스템으로 표현했습니다):"

#: ../../tutorial/modules.rst:410
msgid ""
"sound/                          Top-level package\n"
"      __init__.py               Initialize the sound package\n"
"      formats/                  Subpackage for file format conversions\n"
"              __init__.py\n"
"              wavread.py\n"
"              wavwrite.py\n"
"              aiffread.py\n"
"              aiffwrite.py\n"
"              auread.py\n"
"              auwrite.py\n"
"              ...\n"
"      effects/                  Subpackage for sound effects\n"
"              __init__.py\n"
"              echo.py\n"
"              surround.py\n"
"              reverse.py\n"
"              ...\n"
"      filters/                  Subpackage for filters\n"
"              __init__.py\n"
"              equalizer.py\n"
"              vocoder.py\n"
"              karaoke.py\n"
"              ..."
msgstr ""

#: ../../tutorial/modules.rst:436
msgid ""
"When importing the package, Python searches through the directories on "
"``sys.path`` looking for the package subdirectory."
msgstr "패키지를 임포트할 때, 파이썬은 ``sys.path`` 에 있는 디렉터리들을 검색하면서 패키지 서브 디렉터리를 찾습니다."

#: ../../tutorial/modules.rst:439
#, fuzzy
msgid ""
"The :file:`__init__.py` files are required to make Python treat "
"directories containing the file as packages (unless using a "
":term:`namespace package`, a relatively advanced feature). This prevents "
"directories with a common name, such as ``string``, from unintentionally "
"hiding valid modules that occur later on the module search path. In the "
"simplest case, :file:`__init__.py` can just be an empty file, but it can "
"also execute initialization code for the package or set the ``__all__`` "
"variable, described later."
msgstr ""
"파이썬이 디렉터리를 패키지로 취급하게 만들기 위해서 :file:`__init__.py` 파일이 필요합니다. 이렇게 하면 "
"``string`` 처럼 흔히 쓰는 이름의 디렉터리가, 의도하지 않게 모듈 검색 경로의 뒤에 등장하는 올바른 모듈들을 가리는 일을 "
"방지합니다. 가장 간단한 경우, :file:`__init__.py` 는 그냥 빈 파일일 수 있지만, 패키지의 초기화 코드를 "
"실행하거나 뒤에서 설명하는 ``__all__`` 변수를 설정할 수 있습니다."

#: ../../tutorial/modules.rst:447
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr "패키지 사용자는 패키지로부터 개별 모듈을 임포트할 수 있습니다, 예를 들어::"

#: ../../tutorial/modules.rst:450
msgid "import sound.effects.echo"
msgstr ""

#: ../../tutorial/modules.rst:452
#, fuzzy
msgid ""
"This loads the submodule :mod:`!sound.effects.echo`.  It must be "
"referenced with its full name. ::"
msgstr "이것은 서브 모듈 :mod:`sound.effects.echo` 를 로드합니다. 전체 이름으로 참조되어야 합니다. ::"

#: ../../tutorial/modules.rst:455
msgid "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)"
msgstr ""

#: ../../tutorial/modules.rst:457
msgid "An alternative way of importing the submodule is::"
msgstr "서브 모듈을 임포트하는 다른 방법은 이렇습니다::"

#: ../../tutorial/modules.rst:459
msgid "from sound.effects import echo"
msgstr ""

#: ../../tutorial/modules.rst:461
#, fuzzy
msgid ""
"This also loads the submodule :mod:`!echo`, and makes it available "
"without its package prefix, so it can be used as follows::"
msgstr ""
"이것도 서브 모듈 :mod:`echo` 를 로드하고, 패키지 접두어 없이 사용할 수 있게 합니다. 그래서 이런 식으로 사용할 수 "
"있습니다::"

#: ../../tutorial/modules.rst:464
msgid "echo.echofilter(input, output, delay=0.7, atten=4)"
msgstr ""

#: ../../tutorial/modules.rst:466
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr "또 다른 방법은 원하는 함수나 변수를 직접 임포트하는 것입니다::"

#: ../../tutorial/modules.rst:468
msgid "from sound.effects.echo import echofilter"
msgstr ""

#: ../../tutorial/modules.rst:470
#, fuzzy
msgid ""
"Again, this loads the submodule :mod:`!echo`, but this makes its function"
" :func:`!echofilter` directly available::"
msgstr ""
"또다시, 이것은 서브 모듈 :mod:`echo` 를 로드하지만, 함수 :func:`echofilter` 를 직접 사용할 수 있게 "
"만듭니다::"

#: ../../tutorial/modules.rst:473
msgid "echofilter(input, output, delay=0.7, atten=4)"
msgstr ""

#: ../../tutorial/modules.rst:475
msgid ""
"Note that when using ``from package import item``, the item can be either"
" a submodule (or subpackage) of the package, or some  other name defined "
"in the package, like a function, class or variable.  The ``import`` "
"statement first tests whether the item is defined in the package; if not,"
" it assumes it is a module and attempts to load it.  If it fails to find "
"it, an :exc:`ImportError` exception is raised."
msgstr ""
"``from package import item`` 를 사용할 때, item은 패키지의 서브 모듈 (또는 서브 패키지)일 수도 있고"
" 함수, 클래스, 변수 등 패키지에 정의된 다른 이름들일 수도 있음에 유의하세요. ``import`` 문은 먼저 item이 패키지에"
" 정의되어 있는지 검사하고, 그렇지 않으면 모듈이라고 가정하고 로드를 시도합니다. 찾지 못한다면, :exc:`ImportError`"
" 예외를 일으킵니다."

#: ../../tutorial/modules.rst:482
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, "
"each item except for the last must be a package; the last item can be a "
"module or a package but can't be a class or function or variable defined "
"in the previous item."
msgstr ""
"이에 반하여, ``import item.subitem.subsubitem`` 와 같은 문법을 사용할 때, 마지막 것을 제외한 각 "
"항목은 반드시 패키지여야 합니다; 마지막 항목은 모듈이나 패키지가 될 수 있지만, 앞의 항목에서 정의된 클래스, 함수, 변수 등이 "
"될 수는 없습니다."

#: ../../tutorial/modules.rst:491
msgid "Importing \\* From a Package"
msgstr "패키지에서 \\* 임포트 하기"

#: ../../tutorial/modules.rst:495
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, "
"finds which submodules are present in the package, and imports them all."
"  This could take a long time and importing sub-modules might have "
"unwanted side-effects that should only happen when the sub-module is "
"explicitly imported."
msgstr ""
"이제 ``from sound.effects import *`` 라고 쓰면 어떻게 될까? 이상적으로는, 어떻게든 파일 시스템에서 "
"패키지에 어떤 모듈들이 들어있는지 찾은 다음, 그것들 모두를 임포트 하기를 원할 것입니다. 이렇게 하는 데는 시간이 오래 걸리고 "
"서브 모듈을 임포트 함에 따라 어떤 서브 모듈을 명시적으로 임포트할 경우만 일어나야만 하는 원하지 않는 부수적 효과가 발생할 수 "
"있습니다."

#: ../../tutorial/modules.rst:501
msgid ""
"The only solution is for the package author to provide an explicit index "
"of the package.  The :keyword:`import` statement uses the following "
"convention: if a package's :file:`__init__.py` code defines a list named "
"``__all__``, it is taken to be the list of module names that should be "
"imported when ``from package import *`` is encountered.  It is up to the "
"package author to keep this list up-to-date when a new version of the "
"package is released.  Package authors may also decide not to support it, "
"if they don't see a use for importing \\* from their package.  For "
"example, the file :file:`sound/effects/__init__.py` could contain the "
"following code::"
msgstr ""
"유일한 해결책은 패키지 저자가 패키지의 색인을 명시적으로 제공하는 것입니다. :keyword:`import` 문은 다음과 같은 "
"관례가 있습니다: 패키지의 :file:`__init__.py` 코드가 ``__all__`` 이라는 이름의 목록을 제공하면, 이것을 "
"``from package import *`` 를 만날 때 임포트 해야만 하는 모듈 이름들의 목록으로 받아들입니다. 새 버전의 "
"패키지를 출시할 때 이 목록을 최신 상태로 유지하는 것은 패키지 저자의 책임입니다. 패키지 저자가 패키지에서 \\* 를 임포트하는 "
"용도가 없다고 판단한다면, 이것을 지원하지 않기로 할 수도 있습니다. 예를 들어, 파일 "
":file:`sound/effects/__init__.py` 는 다음과 같은 코드를 포함할 수 있습니다::"

#: ../../tutorial/modules.rst:511
msgid "__all__ = [\"echo\", \"surround\", \"reverse\"]"
msgstr ""

#: ../../tutorial/modules.rst:513
#, fuzzy
msgid ""
"This would mean that ``from sound.effects import *`` would import the "
"three named submodules of the :mod:`!sound.effects` package."
msgstr ""
"이것은 ``from sound.effects import *`` 이 :mod:`sound.effects` 패키지의 세 서브 모듈들을"
" 임포트하게 됨을 의미합니다."

#: ../../tutorial/modules.rst:516
msgid ""
"Be aware that submodules might become shadowed by locally defined names. "
"For example, if you added a ``reverse`` function to the "
":file:`sound/effects/__init__.py` file, the ``from sound.effects import "
"*`` would only import the two submodules ``echo`` and ``surround``, but "
"*not* the ``reverse`` submodule, because it is shadowed by the locally "
"defined ``reverse`` function::"
msgstr ""

#: ../../tutorial/modules.rst:523
msgid ""
"__all__ = [\n"
"    \"echo\",      # refers to the 'echo.py' file\n"
"    \"surround\",  # refers to the 'surround.py' file\n"
"    \"reverse\",   # !!! refers to the 'reverse' function now !!!\n"
"]\n"
"\n"
"def reverse(msg: str):  # <-- this name shadows the 'reverse.py' "
"submodule\n"
"    return msg[::-1]    #     in the case of a 'from sound.effects import"
" *'"
msgstr ""

#: ../../tutorial/modules.rst:532
#, fuzzy
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import "
"*`` does *not* import all submodules from the package "
":mod:`!sound.effects` into the current namespace; it only ensures that "
"the package :mod:`!sound.effects` has been imported (possibly running any"
" initialization code in :file:`__init__.py`) and then imports whatever "
"names are defined in the package.  This includes any names defined (and "
"submodules explicitly loaded) by :file:`__init__.py`.  It also includes "
"any submodules of the package that were explicitly loaded by previous "
":keyword:`import` statements.  Consider this code::"
msgstr ""
"``__all__`` 이 정의되지 않으면, 문장 ``from sound.effects import *`` 은 패키지 "
":mod:`sound.effects` 의 모든 서브 모듈들을 현재 이름 공간으로 임포트 하지 *않습니다*; 이것은 오직 패키지 "
":mod:`sound.effects` 가 임포트 되도록 만들고 (:file:`__init__.py` 에 있는 초기화 코드들이 수행될"
" 수 있습니다), 그 패키지가 정의하는 이름들을 임포트 합니다. 이 이름들은 :file:`__init__.py` 가 정의하는 모든 "
"이름 (그리고 명시적으로 로드된 서브 모듈들)을 포함합니다. 이 이름들에는 사전에 :keyword:`import` 문으로 명시적으로"
" 로드된 패키지의 서브 모듈들 역시 포함됩니다. 이 코드를 생각해봅시다::"

#: ../../tutorial/modules.rst:541
msgid ""
"import sound.effects.echo\n"
"import sound.effects.surround\n"
"from sound.effects import *"
msgstr ""

#: ../../tutorial/modules.rst:545
#, fuzzy
msgid ""
"In this example, the :mod:`!echo` and :mod:`!surround` modules are "
"imported in the current namespace because they are defined in the "
":mod:`!sound.effects` package when the ``from...import`` statement is "
"executed.  (This also works when ``__all__`` is defined.)"
msgstr ""
"이 예에서, :mod:`echo` 와 :mod:`surround` 모듈이 현재 이름 공간으로 임포트 되는데, "
"``from...import`` 문이 실행될 때 :mod:`sound.effects` 패키지에 정의되기 때문입니다. "
"(``__all__`` 이 정의될 때도 마찬가집니다.)"

#: ../../tutorial/modules.rst:550
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"설사 어떤 모듈이 ``import *`` 를 사용할 때 특정 패턴을 따르는 이름들만 익스포트 하도록 설계되었다 하더라도, 프로덕션 "
"코드에서는 여전히 좋지 않은 사례로 여겨집니다."

#: ../../tutorial/modules.rst:554
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless "
"the importing module needs to use submodules with the same name from "
"different packages."
msgstr ""
"``from package import specific_submodule`` 을 사용하는데 잘못된 것은 없다는 것을 기억하세요! "
"사실, 임포트하는 모듈이 다른 패키지에서 같은 이름의 서브 모듈을 사용할 필요가 없는 한 권장되는 표기법입니다."

#: ../../tutorial/modules.rst:563
msgid "Intra-package References"
msgstr "패키지 내부 간의 참조"

#: ../../tutorial/modules.rst:565
#, fuzzy
msgid ""
"When packages are structured into subpackages (as with the :mod:`!sound` "
"package in the example), you can use absolute imports to refer to "
"submodules of siblings packages.  For example, if the module "
":mod:`!sound.filters.vocoder` needs to use the :mod:`!echo` module in the"
" :mod:`!sound.effects` package, it can use ``from sound.effects import "
"echo``."
msgstr ""
"패키지가 서브 패키지들로 구조화될 때 (예에서 나온 :mod:`sound` 패키지처럼), 이웃 패키지의 서브 모듈을 가리키는데 절대"
" 임포트를 사용할 수 있습니다. 예를 들어, 모듈 :mod:`sound.filters.vocoder` 이 "
":mod:`sound.effects` 패키지의 :mod:`echo` 모듈이 필요하면, ``from sound.effects "
"import echo`` 를 사용할 수 있습니다."

#: ../../tutorial/modules.rst:571
#, fuzzy
msgid ""
"You can also write relative imports, with the ``from module import name``"
" form of import statement.  These imports use leading dots to indicate "
"the current and parent packages involved in the relative import.  From "
"the :mod:`!surround` module for example, you might use::"
msgstr ""
"상대 임포트를 쓸 수도 있는데, ``from module import name`` 형태의 임포트 문을 사용합니다. 이 임포트는 상대"
" 임포트에 수반되는 현재와 부모 패키지를 가리키기 위해 앞에 붙는 점을 사용합니다. 예를 들어, :mod:`surround` "
"모듈에서, 이렇게 사용할 수 있습니다::"

#: ../../tutorial/modules.rst:576
msgid ""
"from . import echo\n"
"from .. import formats\n"
"from ..filters import equalizer"
msgstr ""

#: ../../tutorial/modules.rst:580
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always "
"use absolute imports."
msgstr ""
"상대 임포트가 현재 모듈의 이름에 기반을 둔다는 것에 주의하세요. 메인 모듈의 이름은 항상 ``\"__main__\"`` 이기 "
"때문에, 파이썬 응용 프로그램의 메인 모듈로 사용될 목적의 모듈들은 반드시 절대 임포트를 사용해야 합니다."

#: ../../tutorial/modules.rst:586
msgid "Packages in Multiple Directories"
msgstr "여러 디렉터리에 있는 패키지"

#: ../../tutorial/modules.rst:588
#, fuzzy
msgid ""
"Packages support one more special attribute, :attr:`~module.__path__`.  "
"This is initialized to be a :term:`sequence` of strings containing the "
"name of the directory holding the package's :file:`__init__.py` before "
"the code in that file is executed.  This variable can be modified; doing "
"so affects future searches for modules and subpackages contained in the "
"package."
msgstr ""
"패키지는 특별한 어트리뷰트 하나를 더 지원합니다, :attr:`__path__`. 이것은 패키지의 "
":file:`__init__.py` 파일을 실행하기 전에, 이 파일이 들어있는 디렉터리의 이름을 포함하는 리스트로 초기화됩니다. 이"
" 변수는 수정할 수 있습니다; 그렇게 하면 그 이후로 패키지에 포함된 모듈과 서브 패키지를 검색하는 데 영향을 주게 됩니다."

#: ../../tutorial/modules.rst:595
msgid ""
"While this feature is not often needed, it can be used to extend the set "
"of modules found in a package."
msgstr "이 기능이 자주 필요하지는 않지만, 패키지에서 발견되는 모듈의 집합을 확장하는 데 사용됩니다."

#: ../../tutorial/modules.rst:600
msgid "Footnotes"
msgstr "각주"

#: ../../tutorial/modules.rst:601
#, fuzzy
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; "
"the execution of a module-level function definition adds the function "
"name to the module's global namespace."
msgstr "사실 함수 정의도 '실행' 되는 '문장' 입니다; 모듈 수준의 함수 정의를 실행하면 함수의 이름이 전역 심볼 테이블에 들어갑니다."

#: ../../tutorial/modules.rst:184 ../../tutorial/modules.rst:267
#: ../../tutorial/modules.rst:348
#, fuzzy
msgid "module"
msgstr "모듈"

#: ../../tutorial/modules.rst:184
msgid "search"
msgstr ""

#: ../../tutorial/modules.rst:184
msgid "path"
msgstr ""

#: ../../tutorial/modules.rst:267
msgid "sys"
msgstr ""

#: ../../tutorial/modules.rst:348
msgid "builtins"
msgstr ""

#: ../../tutorial/modules.rst:493
msgid "__all__"
msgstr ""

#~ msgid "The installation-dependent default."
#~ msgstr "설치 의존적인 기본값"

