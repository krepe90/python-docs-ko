# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "C나 C++로 파이썬 확장하기"

#: ../../extending/extending.rst:10
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how "
"to program in C.  Such :dfn:`extension modules` can do two things that "
"can't be done directly in Python: they can implement new built-in object "
"types, and they can call C library functions and system calls."
msgstr ""
"C로 프로그래밍하는 방법을 알고 있다면, 파이썬에 새로운 내장 모듈을 추가하기는 매우 쉽습니다. 그러한 :dfn:`확장 "
"모듈(extension modules)`\\은 파이썬에서 직접 할 수 없는 두 가지 일을 할 수 있습니다: 새로운 내장 객체 형을 "
"구현할 수 있고, C 라이브러리 함수와 시스템 호출을 호출할 수 있습니다."

#: ../../extending/extending.rst:15
msgid ""
"To support extensions, the Python API (Application Programmers Interface)"
" defines a set of functions, macros and variables that provide access to "
"most aspects of the Python run-time system.  The Python API is "
"incorporated in a C source file by including the header ``\"Python.h\"``."
msgstr ""
"확장을 지원하기 위해, 파이썬 API(Application Programmers Interface)는 파이썬 런타임 시스템의 대부분"
" 측면에 액세스 할 수 있는 함수, 매크로 및 변수 집합을 정의합니다. 파이썬 API는 헤더 ``\"Python.h\"``\\를 "
"포함해 C 소스 파일에 통합됩니다."

#: ../../extending/extending.rst:20
msgid ""
"The compilation of an extension module depends on its intended use as "
"well as on your system setup; details are given in later chapters."
msgstr "확장 모듈의 컴파일은 시스템 설정뿐만 아니라 의도하는 용도에 따라 다릅니다; 자세한 내용은 다음 장에서 설명합니다."

#: ../../extending/extending.rst:25
msgid ""
"The C extension interface is specific to CPython, and extension modules "
"do not work on other Python implementations.  In many cases, it is "
"possible to avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to "
"interface with C code and are more portable between implementations of "
"Python than writing and compiling a C extension module."
msgstr ""
"C 확장 인터페이스는 CPython에만 해당하며, 확장 모듈은 다른 파이썬 구현에서는 작동하지 않습니다. 많은 경우에, C 확장을 "
"작성하지 않고 다른 구현으로의 이식성을 유지하는 것이 가능합니다. 예를 들어, 사용 사례가 C 라이브러리 함수나 시스템 호출을 "
"호출하는 것이라면, 사용자 정의 C 코드를 작성하는 대신 :mod:`ctypes` 모듈이나 `cffi "
"<https://cffi.readthedocs.io/>`_ 라이브러리 사용을 고려해야 합니다. 이 모듈을 사용하면 C 코드와 "
"인터페이스 하기 위한 파이썬 코드를 작성할 수 있으며 C 확장 모듈을 작성하고 컴파일하는 것보다 파이썬 구현 간에 이식성이 더 "
"좋습니다."

#: ../../extending/extending.rst:40
msgid "A Simple Example"
msgstr "간단한 예"

#: ../../extending/extending.rst:42
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of "
"Monty Python fans...) and let's say we want to create a Python interface "
"to the C library function :c:func:`system` [#]_. This function takes a "
"null-terminated character string as argument and returns an integer.  We "
"want this function to be callable from Python as follows:"
msgstr ""
"``spam``\\(몬티 파이썬 팬들이 가장 좋아하는 음식...)이라는 확장 모듈을 만듭시다, 그리고 C 라이브러리 함수 "
":c:func:`system`\\에 대한 파이썬 인터페이스를 만들고 싶다고 합시다 [#]_. 이 함수는 널 종료 문자열을 인자로 "
"취하고 정수를 반환합니다. 우리는 이 함수를 다음과 같이 파이썬에서 호출할 수 있기를 원합니다:"

#: ../../extending/extending.rst:48
msgid ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"
msgstr ""

#: ../../extending/extending.rst:53
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a "
"module is called ``spam``, the C file containing its implementation is "
"called :file:`spammodule.c`; if the module name is very long, like "
"``spammify``, the module name can be just :file:`spammify.c`.)"
msgstr ""
":file:`spammodule.c` 파일을 만드는 것으로 시작하십시오. (역사적으로, 모듈을 ``spam``\\이라고 하면, 해당"
" 구현을 포함하는 C 파일은 :file:`spammodule.c`\\라고 합니다; 모듈 이름이 ``spammify``\\처럼 매우 "
"길면, 모듈 이름은 그냥 :file:`spammify.c`\\일 수 있습니다.)"

#: ../../extending/extending.rst:58
msgid "The first two lines of our file can be::"
msgstr "파일의 처음 두 줄은 다음과 같습니다::"

#: ../../extending/extending.rst:60 ../../extending/extending.rst:663
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""

#: ../../extending/extending.rst:63
msgid ""
"which pulls in the Python API (you can add a comment describing the "
"purpose of the module and a copyright notice if you like)."
msgstr "이것은 파이썬 API를 가져옵니다 (원한다면 모듈의 목적과 저작권 표시를 설명하는 주석을 추가할 수 있습니다)."

#: ../../extending/extending.rst:68
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` "
"before any standard headers are included."
msgstr ""
"파이썬이 일부 시스템의 표준 헤더에 영향을 미치는 일부 전처리기 정의를 정의할 수 있어서, 표준 헤더가 포함되기 전에 *반드시* "
":file:`Python.h`\\를 포함해야 합니다."

#: ../../extending/extending.rst:72
msgid ""
"``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` "
"should be used in some APIs instead of ``int``. It is not necessary since"
" Python 3.13, but we keep it here for backward compatibility. See :ref"
":`arg-parsing-string-and-buffers` for a description of this macro."
msgstr ""

#: ../../extending/extending.rst:77
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of "
"``Py`` or ``PY``, except those defined in standard header files. For "
"convenience, and since they are used extensively by the Python "
"interpreter, ``\"Python.h\"`` includes a few standard header files: "
"``<stdio.h>``, ``<string.h>``, ``<errno.h>``, and ``<stdlib.h>``.  If the"
" latter header file does not exist on your system, it declares the "
"functions :c:func:`malloc`, :c:func:`free` and :c:func:`realloc` "
"directly."
msgstr ""
":file:`Python.h`\\가 정의한 사용자가 볼 수 있는 기호는 표준 헤더 파일에 정의된 기호를 제외하고 모두 "
"``Py``\\나 ``PY`` 접두사를 갖습니다. 편의를 위해, 그리고 파이썬 인터프리터가 광범위하게 사용하기 때문에, "
"``\"Python.h\"``\\는 몇 가지 표준 헤더 파일을 포함합니다: ``<stdio.h>``, ``<string.h>``, "
"``<errno.h>`` 및 ``<stdlib.h>``. 후자의 헤더 파일이 시스템에 없으면, 함수 :c:func:`malloc`,"
" :c:func:`free` 및 :c:func:`realloc`\\을 직접 선언합니다."

#: ../../extending/extending.rst:85
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"다음으로 모듈 파일에 추가하는 것은 파이썬 표현식 ``spam.system(string)``\\이 평가될 때 호출될 C 함수입니다 "
"(이것이 어떻게 호출되는지 곧 보게 될 것입니다)::"

#: ../../extending/extending.rst:89
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:101
msgid ""
"There is a straightforward translation from the argument list in Python "
"(for example, the single expression ``\"ls -l\"``) to the arguments "
"passed to the C function.  The C function always has two arguments, "
"conventionally named *self* and *args*."
msgstr ""
"파이썬의 인자 목록(예를 들어, 단일 표현식 ``\"ls -l\"``)에서 C 함수로 전달되는 인자로의 간단한 변환이 있습니다. C"
" 함수에는 항상 *self*\\와 *args*\\라는 두 개의 인자가 있습니다."

#: ../../extending/extending.rst:106
msgid ""
"The *self* argument points to the module object for module-level "
"functions; for a method it would point to the object instance."
msgstr "*self* 인자는 모듈 수준 함수에서 모듈 객체를 가리킵니다; 메서드의 경우 객체 인스턴스를 가리킵니다."

#: ../../extending/extending.rst:109
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing"
" the arguments.  Each item of the tuple corresponds to an argument in the"
" call's argument list.  The arguments are Python objects --- in order to "
"do anything with them in our C function we have to convert them to C "
"values.  The function :c:func:`PyArg_ParseTuple` in the Python API checks"
" the argument types and converts them to C values.  It uses a template "
"string to determine the required types of the arguments as well as the "
"types of the C variables into which to store the converted values.  More "
"about this later."
msgstr ""
"*args* 인자는 인자를 포함하는 파이썬 튜플 객체에 대한 포인터입니다. 튜플의 각 항목은 호출의 인자 목록에 있는 인자에 "
"해당합니다. 인자는 파이썬 객체입니다 --- C 함수에서 무언가를 수행하려면 이들을 C 값으로 변환해야 합니다. 파이썬 API의 "
":c:func:`PyArg_ParseTuple` 함수는 인자 형을 확인하고 C 값으로 변환합니다. 템플릿 문자열을 사용하여 필요한 "
"인자 형과 변환된 값을 저장할 C 변수 형을 결정합니다. 나중에 이것에 대해 자세히 알아보겠습니다."

#: ../../extending/extending.rst:118
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have "
"the right type and its components have been stored in the variables whose"
" addresses are passed.  It returns false (zero) if an invalid argument "
"list was passed.  In the latter case it also raises an appropriate "
"exception so the calling function can return ``NULL`` immediately (as we "
"saw in the example)."
msgstr ""
"모든 인자의 형이 올바르고 해당 구성 요소가 주소가 전달된 변수에 저장되면, :c:func:`PyArg_ParseTuple`\\은 "
"참(0이 아닙니다)을 반환합니다. 유효하지 않은 인자 목록이 전달되면 거짓(0)을 반환합니다. 후자의 경우 호출 함수가  (예에서 "
"보듯이) ``NULL``\\을 즉시 반환할 수 있도록 적절한 예외를 발생시킵니다."

#: ../../extending/extending.rst:128
msgid "Intermezzo: Errors and Exceptions"
msgstr "막간극: 에러와 예외"

#: ../../extending/extending.rst:130
#, fuzzy
msgid ""
"An important convention throughout the Python interpreter is the "
"following: when a function fails, it should set an exception condition "
"and return an error value (usually ``-1`` or a ``NULL`` pointer).  "
"Exception information is stored in three members of the interpreter's "
"thread state.  These are ``NULL`` if there is no exception.  Otherwise "
"they are the C equivalents of the members of the Python tuple returned by"
" :meth:`sys.exc_info`.  These are the exception type, exception instance,"
" and a traceback object.  It is important to know about them to "
"understand how errors are passed around."
msgstr ""
"파이썬 인터프리터 전체에서 중요한 규칙은 다음과 같습니다: 함수가 실패하면 예외 조건을 설정하고 에러값(보통 ``NULL`` "
"포인터)을 반환해야 합니다. 예외는 인터프리터 내부의 정적 전역 변수에 저장됩니다; 이 변수가 ``NULL``\\이면 예외가 "
"발생하지 않은 것입니다. 두 번째 전역 변수는 예외의 \"연관된 값\"(:keyword:`raise`\\에 대한 두 번째 인자)을 "
"저장합니다. 세 번째 변수에는 에러가 파이썬 코드에서 발생한 경우 스택 트레이스백이 포함됩니다. 이 세 변수는 "
":meth:`sys.exc_info`\\의 파이썬 결과에 대한 C 동등 물입니다 (파이썬 라이브러리 레퍼런스에 있는 모듈 "
":mod:`sys`\\에 대한 섹션을 참조하십시오). 에러가 어떻게 전달되는지 이해하기 위해서는 이들에 대해 아는 것이 중요합니다."

#: ../../extending/extending.rst:139
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr "파이썬 API는 다양한 형의 예외를 설정하기 위한 여러 함수를 정의합니다."

#: ../../extending/extending.rst:141
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string "
"object and stored as the \"associated value\" of the exception."
msgstr ""
"가장 일반적인 것은 :c:func:`PyErr_SetString`\\입니다. 인자는 예외 객체와 C 문자열입니다. 예외 객체는 보통"
" :c:data:`PyExc_ZeroDivisionError`\\와 같은 미리 정의된 객체입니다. C 문자열은 에러의 원인을 "
"나타내며 파이썬 문자열 객체로 변환되어 예외의 \"연관된 값\"으로 저장됩니다."

#: ../../extending/extending.rst:147
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes"
" an exception argument and constructs the associated value by inspection "
"of the global variable :c:data:`errno`.  The most general function is "
":c:func:`PyErr_SetObject`, which takes two object arguments, the "
"exception and its associated value.  You don't need to "
":c:func:`Py_INCREF` the objects passed to any of these functions."
msgstr ""
"또 다른 유용한 함수는 :c:func:`PyErr_SetFromErrno`\\입니다. 이 함수는 예외 인자만 취하고 전역 변수 "
":c:data:`errno`\\를 검사하여 관련 값을 구성합니다. 가장 일반적인 함수는 "
":c:func:`PyErr_SetObject`\\이며, 예외와 관련 값인 두 개의 객체 인자를 취합니다. 이러한 함수들에 전달되는 "
"객체를 :c:func:`Py_INCREF` 할 필요는 없습니다."

#: ../../extending/extending.rst:154
msgid ""
"You can test non-destructively whether an exception has been set with "
":c:func:`PyErr_Occurred`.  This returns the current exception object, or "
"``NULL`` if no exception has occurred.  You normally don't need to call "
":c:func:`PyErr_Occurred` to see whether an error occurred in a function "
"call, since you should be able to tell from the return value."
msgstr ""
":c:func:`PyErr_Occurred`\\로 예외가 설정되어 있는지 비 파괴적으로 검사할 수 있습니다. 현재 예외 객체나 "
"예외가 발생하지 않았으면 ``NULL``\\을 반환합니다. 반환 값에서 알 수 있어야 해서 일반적으로 함수 호출에서 에러가 "
"발생했는지 확인하기 위해 :c:func:`PyErr_Occurred`\\를 호출할 필요는 없습니다."

#: ../../extending/extending.rst:160
#, fuzzy
msgid ""
"When a function *f* that calls another function *g* detects that the "
"latter fails, *f* should itself return an error value (usually ``NULL`` "
"or ``-1``).  It should *not* call one of the ``PyErr_*`` functions --- "
"one has already been called by *g*. *f*'s caller is then supposed to also"
" return an error indication to *its* caller, again *without* calling "
"``PyErr_*``, and so on --- the most detailed cause of the error was "
"already reported by the function that first detected it.  Once the error "
"reaches the Python interpreter's main loop, this aborts the currently "
"executing Python code and tries to find an exception handler specified by"
" the Python programmer."
msgstr ""
"다른 함수 *g*\\를 호출하는 함수 *f*\\가 *g*\\의 실패를 감지할 때, *f* 자체가 에러값(보통 ``NULL``\\이나"
" ``-1``)을 반환해야 합니다. :c:func:`PyErr_\\*` 함수 중 하나를 호출하지 *않아야* 합니다 --- "
"*g*\\에 의해 이미 호출되었습니다. 그러면 *f*\\의 호출자도 역시 :c:func:`PyErr_\\*` 호출 *없이*, "
"*자신의* 호출자에게 에러 표시를 반환하고, 이런 식으로 계속된다고 가정합니다 --- 에러를 가장 먼저 감지한 함수에 의해 에러의 "
"가장 자세한 원인이 이미 보고되었습니다. 일단 에러가 파이썬 인터프리터의 메인 루프에 도달하면, 현재 실행 중인 파이썬 코드를 "
"중단하고 파이썬 프로그래머가 지정한 예외 처리기를 찾으려고 시도합니다."

#: ../../extending/extending.rst:170
#, fuzzy
msgid ""
"(There are situations where a module can actually give a more detailed "
"error message by calling another ``PyErr_*`` function, and in such cases "
"it is fine to do so.  As a general rule, however, this is not necessary, "
"and can cause information about the cause of the error to be lost: most "
"operations can fail for a variety of reasons.)"
msgstr ""
"(모듈이 실제로 다른 :c:func:`PyErr_\\*` 함수를 호출하여 더 자세한 에러 메시지를 표시할 수 있는 상황이 있습니다."
" 그럴 때는 그렇게 하는 것이 좋습니다. 그러나, 일반적인 규칙으로 이는 필요하지 않고, 에러가 발생하는 원인에 관한 정보를 "
"잃어버리게 합니다: 대부분의 연산은 다양한 이유로 실패할 수 있습니다.)"

#: ../../extending/extending.rst:176
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  "
"The only time C code should call :c:func:`PyErr_Clear` is if it doesn't "
"want to pass the error on to the interpreter but wants to handle it "
"completely by itself (possibly by trying something else, or pretending "
"nothing went wrong)."
msgstr ""
"실패한 함수 호출로 설정된 예외를 무시하려면, :c:func:`PyErr_Clear`\\를 호출하여 예외 조건을 명시적으로 지워야 "
"합니다. C 코드가 :c:func:`PyErr_Clear`\\를 호출해야 하는 유일한 때는 에러를 인터프리터에 전달하지 않고 스스로"
" 완전히 처리하려고 하는 경우입니다 (아마 다른 것을 시도하거나, 아무것도 잘못되지 않은 척해서)."

#: ../../extending/extending.rst:182
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- "
"the direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call "
":c:func:`PyErr_NoMemory` and return a failure indicator itself.  All the "
"object-creating functions (for example, :c:func:`PyLong_FromLong`) "
"already do this, so this note is only relevant to those who call "
":c:func:`malloc` directly."
msgstr ""
"모든 실패한 :c:func:`malloc` 호출은 예외로 전환되어야 합니다 --- :c:func:`malloc`\\(또는 "
":c:func:`realloc`)의 직접 호출자는 스스로 :c:func:`PyErr_NoMemory`\\를 호출하고 실패 표시기를 "
"반환해야 합니다. 모든 객체 생성 함수(예를 들어, :c:func:`PyLong_FromLong`)는 이미 이 작업을 수행하므로, "
"이 주의는 :c:func:`malloc`\\을 직접 호출하는 호출자에게만 해당합니다."

#: ../../extending/extending.rst:188
msgid ""
"Also note that, with the important exception of "
":c:func:`PyArg_ParseTuple` and friends, functions that return an integer "
"status usually return a positive value or zero for success and ``-1`` for"
" failure, like Unix system calls."
msgstr ""
"또한 :c:func:`PyArg_ParseTuple`\\과 그 친구들의 중요한 예외를 제외하고, 정수 상태를 반환하는 함수는 유닉스"
" 시스템 호출처럼 일반적으로 성공 시 양수 값이나 0을 반환하고, 실패 시 ``-1``\\을 반환합니다."

#: ../../extending/extending.rst:192
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` "
"or :c:func:`Py_DECREF` calls for objects you have already created) when "
"you return an error indicator!"
msgstr ""
"마지막으로, 에러 표시기를 반환할 때 (이미 만든 객체를 :c:func:`Py_XDECREF`\\나 "
":c:func:`Py_DECREF`\\를 호출하여) 가비지를 정리하십시오!"

#: ../../extending/extending.rst:196
#, fuzzy
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, "
"such as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of"
" course, you should choose exceptions wisely --- don't use "
":c:data:`PyExc_TypeError` to mean that a file couldn't be opened (that "
"should probably be :c:data:`PyExc_OSError`). If something's wrong with "
"the argument list, the :c:func:`PyArg_ParseTuple` function usually raises"
" :c:data:`PyExc_TypeError`.  If you have an argument whose value must be "
"in a particular range or must satisfy other conditions, "
":c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"어떤 예외를 발생시킬지는 전적으로 여러분의 것입니다. 모든 내장 파이썬 예외에 해당하는 사전 선언된 C 객체(가령 "
":c:data:`PyExc_ZeroDivisionError`)가 있는데, 직접 사용할 수 있습니다. 물론, 예외를 현명하게 선택해야"
" 합니다 --- 파일을 열 수 없음을 뜻하는 데 :c:data:`PyExc_TypeError`\\를 사용하지 마십시오 (아마도 "
":c:data:`PyExc_IOError`\\여야 합니다). 인자 목록에 문제가 있으면, "
":c:func:`PyArg_ParseTuple` 함수는 일반적으로 :c:data:`PyExc_TypeError`\\를 발생시킵니다."
" 값이 특정 범위 내에 있어야 하거나 다른 조건을 만족해야 하는 인자가 있으면, "
":c:data:`PyExc_ValueError`\\가 적합합니다."

#: ../../extending/extending.rst:206
msgid ""
"You can also define a new exception that is unique to your module. For "
"this, you usually declare a static object variable at the beginning of "
"your file::"
msgstr "모듈에 고유한 새 예외를 정의할 수도 있습니다. 이를 위해, 일반적으로 파일 시작 부분에 정적 객체 변수를 선언합니다::"

#: ../../extending/extending.rst:209
msgid "static PyObject *SpamError;"
msgstr ""

#: ../../extending/extending.rst:211
#, fuzzy
msgid ""
"and initialize it in your module's initialization function "
"(:c:func:`!PyInit_spam`) with an exception object::"
msgstr "그리고 모듈의 초기화 함수(:c:func:`PyInit_spam`)에서 예외 객체로 초기화합니다::"

#: ../../extending/extending.rst:214
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    if (PyModule_AddObjectRef(m, \"error\", SpamError) < 0) {\n"
"        Py_CLEAR(SpamError);\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:233
#, fuzzy
msgid ""
"Note that the Python name for the exception object is :exc:`!spam.error`."
"  The :c:func:`PyErr_NewException` function may create a class with the "
"base class being :exc:`Exception` (unless another class is passed in "
"instead of ``NULL``), described in :ref:`bltin-exceptions`."
msgstr ""
"예외 객체의 파이썬 이름은 :exc:`spam.error`\\임에 유의하십시오. :c:func:`PyErr_NewException`"
" 함수는 (``NULL`` 대신 다른 클래스가 전달되지 않는 한) 베이스 클래스가 (:ref:`bltin-"
"exceptions`\\에서 설명된) :exc:`Exception`\\인 클래스를 만들 수 있습니다."

#: ../../extending/extending.rst:238
#, fuzzy
msgid ""
"Note also that the :c:data:`!SpamError` variable retains a reference to "
"the newly created exception class; this is intentional!  Since the "
"exception could be removed from the module by external code, an owned "
"reference to the class is needed to ensure that it will not be discarded,"
" causing :c:data:`!SpamError` to become a dangling pointer. Should it "
"become a dangling pointer, C code which raises the exception could cause "
"a core dump or other unintended side effects."
msgstr ""
":c:data:`SpamError` 변수는 새로 만들어진 예외 클래스에 대한 참조를 보유함에도 유의하십시오; 이것은 의도적입니다! "
"외부 코드에 의해 예외가 모듈에서 제거될 수 있기 때문에, 클래스가 버려져서 :c:data:`SpamError`\\가 "
"매달린(dangling) 포인터가 되지 않도록 하려면, 클래스에 대한 참조를 소유할 필요가 있습니다. 매달린 포인터가 되면, 예외를"
" 발생시키는 C 코드가 코어 덤프나 다른 의도하지 않은 부작용을 일으킬 수 있습니다."

#: ../../extending/extending.rst:245
#, fuzzy
msgid ""
"We discuss the use of :c:macro:`PyMODINIT_FUNC` as a function return type"
" later in this sample."
msgstr "이 샘플의 뒷부분에서 ``PyMODINIT_FUNC``\\를 함수 반환형으로 사용하는 것에 관해 설명합니다."

#: ../../extending/extending.rst:248
#, fuzzy
msgid ""
"The :exc:`!spam.error` exception can be raised in your extension module "
"using a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ""
"다음과 같이 :c:func:`PyErr_SetString`\\을 호출하여 확장 모듈에서 :exc:`spam.error` 예외를 "
"발생시킬 수 있습니다::"

#: ../../extending/extending.rst:251
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"System command failed\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:271
msgid "Back to the Example"
msgstr "예제로 돌아가기"

#: ../../extending/extending.rst:273
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr "예제 함수로 돌아가서, 이제 여러분은 이 문장을 이해할 수 있어야 합니다::"

#: ../../extending/extending.rst:276
msgid ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"
msgstr ""

#: ../../extending/extending.rst:279
#, fuzzy
msgid ""
"It returns ``NULL`` (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value "
"of the argument has been copied to the local variable :c:data:`!command`."
"  This is a pointer assignment and you are not supposed to modify the "
"string to which it points (so in Standard C, the variable "
":c:data:`!command` should properly be declared as ``const char "
"*command``)."
msgstr ""
"인자 목록에서 에러가 발견되면 :c:func:`PyArg_ParseTuple`\\에 의해 설정된 예외에 의존하면서 "
"``NULL``\\(객체 포인터를 반환하는 함수의 에러 표시기)을 반환합니다. 그렇지 않으면 인자의 문자열 값이 지역 변수 "
":c:data:`command`\\에 복사되었습니다. 이것은 포인터 대입이며 가리키는 문자열을 수정해서는 안 됩니다 (따라서 표준 "
"C에서, 변수 :c:data:`command`\\는 ``const char *command``\\로 올바르게 선언되어야 합니다)."

#: ../../extending/extending.rst:287
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, "
"passing it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"다음 문장은 유닉스 함수 :c:func:`system`\\을 호출인데, :c:func:`PyArg_ParseTuple`\\에서 얻은"
" 문자열을 전달합니다::"

#: ../../extending/extending.rst:290
msgid "sts = system(command);"
msgstr ""

#: ../../extending/extending.rst:292
#, fuzzy
msgid ""
"Our :func:`!spam.system` function must return the value of :c:data:`!sts`"
" as a Python object.  This is done using the function "
":c:func:`PyLong_FromLong`. ::"
msgstr ""
"우리의 :func:`spam.system` 함수는 :c:data:`sts`\\의 값을 파이썬 객체로 반환해야 합니다. 이것은 "
":c:func:`PyLong_FromLong` 함수를 사용하여 이루어집니다. ::"

#: ../../extending/extending.rst:295
msgid "return PyLong_FromLong(sts);"
msgstr ""

#: ../../extending/extending.rst:297
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr "이 경우, 정수 객체를 반환합니다. (예, 정수조차도 파이썬에서는 힙 상의 객체입니다!)"

#: ../../extending/extending.rst:300
#, fuzzy
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:expr:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the "
":c:macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"유용한 인자를 반환하지 않는 C 함수(:c:type:`void`\\를 반환하는 함수)가 있으면, 해당 파이썬 함수는 "
"``None``\\을 반환해야 합니다. 그렇게 하려면 이 관용구가 필요합니다 (:c:macro:`Py_RETURN_NONE` "
"매크로로 구현됩니다)::"

#: ../../extending/extending.rst:305
msgid ""
"Py_INCREF(Py_None);\n"
"return Py_None;"
msgstr ""

#: ../../extending/extending.rst:308
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  "
"It is a genuine Python object rather than a ``NULL`` pointer, which means"
" \"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None`\\은 특수 파이썬 객체 ``None``\\의 C 이름입니다. 앞에서 보았듯이, 대부분의 상황에서 "
"\"에러\"를 뜻하는 ``NULL`` 포인터가 아니라 진짜 파이썬 객체입니다."

#: ../../extending/extending.rst:316
msgid "The Module's Method Table and Initialization Function"
msgstr "모듈의 메서드 테이블과 초기화 함수"

#: ../../extending/extending.rst:318
#, fuzzy
msgid ""
"I promised to show how :c:func:`!spam_system` is called from Python "
"programs. First, we need to list its name and address in a \"method "
"table\"::"
msgstr ""
"파이썬 프로그램에서 :c:func:`spam_system`\\이 어떻게 호출되는지 보여 주겠다고 약속했습니다. 먼저, \"메서드 "
"테이블\"에 이름과 주소를 나열해야 합니다::"

#: ../../extending/extending.rst:321
msgid ""
"static PyMethodDef SpamMethods[] = {\n"
"    ...\n"
"    {\"system\",  spam_system, METH_VARARGS,\n"
"     \"Execute a shell command.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"
msgstr ""

#: ../../extending/extending.rst:329
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It "
"should normally always be ``METH_VARARGS`` or ``METH_VARARGS | "
"METH_KEYWORDS``; a value of ``0`` means that an obsolete variant of "
":c:func:`PyArg_ParseTuple` is used."
msgstr ""
"세 번째 항목 (``METH_VARARGS``)에 유의하십시오. 이것은 인터프리터에게 C 함수에 사용될 호출 규칙을 알려주는 "
"플래그입니다. 일반적으로 항상 ``METH_VARARGS``\\나 ``METH_VARARGS | METH_KEYWORDS``\\여야"
" 합니다; ``0`` 값은 더는 사용되지 않는 :c:func:`PyArg_ParseTuple` 변형이 사용됨을 의미합니다."

#: ../../extending/extending.rst:334
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via "
":c:func:`PyArg_ParseTuple`; more information on this function is provided"
" below."
msgstr ""
"``METH_VARARGS`` 만 사용할 때, 함수는 파이썬 수준 매개 변수가 :c:func:`PyArg_ParseTuple`\\을"
" 통한 구문 분석에 허용되는 튜플로 전달될 것으로 기대해야 합니다; 이 함수에 대한 자세한 정보는 아래에 제공됩니다."

#: ../../extending/extending.rst:338
#, fuzzy
msgid ""
"The :c:macro:`METH_KEYWORDS` bit may be set in the third field if keyword"
" arguments should be passed to the function.  In this case, the C "
"function should accept a third ``PyObject *`` parameter which will be a "
"dictionary of keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to "
"parse the arguments to such a function."
msgstr ""
"키워드 인자를 함수에 전달해야 하면, 세 번째 필드에서 :const:`METH_KEYWORDS` 비트를 설정할 수 있습니다. 이 "
"경우, C 함수는 키워드 딕셔너리가 될 세 번째 ``PyObject *`` 매개 변수를 받아들여야 합니다. 이러한 함수에는 "
":c:func:`PyArg_ParseTupleAndKeywords`\\를 사용하여 인자를 구문 분석하십시오."

#: ../../extending/extending.rst:344
msgid "The method table must be referenced in the module definition structure::"
msgstr "메서드 테이블은 모듈 정의 구조체에서 참조되어야 합니다::"

#: ../../extending/extending.rst:346
#, python-brace-format
msgid ""
"static struct PyModuleDef spammodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"spam\",   /* name of module */\n"
"    spam_doc, /* module documentation, may be NULL */\n"
"    -1,       /* size of per-interpreter state of the module,\n"
"                 or -1 if the module keeps state in global variables. */\n"
"    SpamMethods\n"
"};"
msgstr ""

#: ../../extending/extending.rst:355
#, fuzzy
msgid ""
"This structure, in turn, must be passed to the interpreter in the "
"module's initialization function.  The initialization function must be "
"named :c:func:`!PyInit_name`, where *name* is the name of the module, and"
" should be the only non-\\ ``static`` item defined in the module file::"
msgstr ""
"다시, 이 구조체는 모듈의 초기화 함수에서 인터프리터로 전달되어야 합니다. 초기화 함수의 이름은 "
":c:func:`PyInit_name`\\이어야 합니다, 여기서 *name*\\은 모듈의 이름이며, 모듈 파일에 정의된 유일한 비 "
"``static`` 항목이어야 합니다::"

#: ../../extending/extending.rst:360
#, python-brace-format
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModule_Create(&spammodule);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:366
#, fuzzy
msgid ""
"Note that :c:macro:`PyMODINIT_FUNC` declares the function as ``PyObject "
"*`` return type, declares any special linkage declarations required by "
"the platform, and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"PyMODINIT_FUNC는 함수를 ``PyObject *`` 반환형으로 선언하고, 플랫폼에 필요한 특수 링크 선언을 선언하며, "
"C++의 경우 함수를 ``extern \"C\"``\\로 선언함에 유의하십시오."

#: ../../extending/extending.rst:370
#, fuzzy
msgid ""
"When the Python program imports module :mod:`!spam` for the first time, "
":c:func:`!PyInit_spam` is called. (See below for comments about embedding"
" Python.) It calls :c:func:`PyModule_Create`, which returns a module "
"object, and inserts built-in function objects into the newly created "
"module based upon the table (an array of :c:type:`PyMethodDef` "
"structures) found in the module definition. :c:func:`PyModule_Create` "
"returns a pointer to the module object that it creates.  It may abort "
"with a fatal error for certain errors, or return ``NULL`` if the module "
"could not be initialized satisfactorily. The init function must return "
"the module object to its caller, so that it then gets inserted into "
"``sys.modules``."
msgstr ""
"파이썬 프로그램이 처음으로 모듈 :mod:`spam`\\을 임포트 할 때, :c:func:`PyInit_spam`\\이 호출됩니다."
" (파이썬 내장에 대해서는 아래에서 언급합니다.) 이는 :c:func:`PyModule_Create`\\를 호출하는데, 모듈 객체를"
" 반환하고 모듈 정의에서 찾은 테이블(:c:type:`PyMethodDef` 구조체의 배열)을 기반으로 내장 함수 객체들을 새로 "
"만든 모듈에 삽입합니다. :c:func:`PyModule_Create`\\는 만든 모듈 객체에 대한 포인터를 반환합니다. 특정 "
"에러의 경우 치명적인 에러로 중단되거나, 모듈을 만족스럽게 초기화할 수 없으면 ``NULL``\\을 반환할 수 있습니다. 초기화 "
"함수는 모듈 객체를 호출자에게 반환해야 합니다. 그러면 ``sys.modules``\\에 삽입됩니다."

#: ../../extending/extending.rst:381
#, fuzzy
msgid ""
"When embedding Python, the :c:func:`!PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use "
":c:func:`PyImport_AppendInittab`, optionally followed by an import of the"
" module::"
msgstr ""
"파이썬을 내장할 때, :c:data:`PyImport_Inittab` 테이블에 항목이 없으면 :c:func:`PyInit_spam`"
" 함수가 자동으로 호출되지 않습니다. 모듈을 초기화 테이블에 추가하려면, "
":c:func:`PyImport_AppendInittab`\\을 사용하고, 선택적으로 그다음에 모듈을 임포트 합니다::"

#: ../../extending/extending.rst:386
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* Add a built-in module, before Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules "
"table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pass argv[0] to the Python interpreter */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    /* Initialize the Python interpreter.  Required.\n"
"       If this step fails, it will be a fatal error. */\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    /* Optionally import the module; alternatively,\n"
"       import can be deferred until the embedded script\n"
"       imports it. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    // ... use Python C API here ...\n"
"\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:436
msgid ""
"Removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`) can create problems for some "
"extension modules. Extension module authors should exercise caution when "
"initializing internal data structures."
msgstr ""
"``sys.modules``\\에서 항목을 제거하거나 프로세스 내에서 컴파일된 모듈을 여러 인터프리터로 임포트 하면 (또는 "
":c:func:`exec`\\를 개입시키지 않고 :c:func:`fork`\\를 따르면) 일부 확장 모듈에 문제가 발생할 수 "
"있습니다. 확장 모듈 작성자는 내부 데이터 구조를 초기화할 때 주의를 기울여야 합니다."

#: ../../extending/extending.rst:442
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  "
"template or simply read as an example."
msgstr ""
"더욱 실질적인 예제 모듈이 :file:`Modules/xxmodule.c`\\로 파이썬 소스 배포판에 포함되어 있습니다. 이 파일은"
" 템플릿으로 사용되거나 단순히 예제로 읽을 수 있습니다."

#: ../../extending/extending.rst:448
msgid ""
"Unlike our ``spam`` example, ``xxmodule`` uses *multi-phase "
"initialization* (new in Python 3.5), where a PyModuleDef structure is "
"returned from ``PyInit_spam``, and creation of the module is left to the "
"import machinery. For details on multi-phase initialization, see "
":PEP:`489`."
msgstr ""
"``spam`` 예제와 달리 ``xxmodule``\\은 *다단계 초기화(multi-phase "
"initialization)*\\(파이썬 3.5의 새로운 기능)를 사용합니다. 여기서는 PyModuleDef 구조체가 "
"``PyInit_spam``\\에서 반환되고, 모듈 생성은 임포트 절차에 맡겨집니다. 다단계 초기화에 대한 자세한 내용은 "
":PEP:`489`\\를 참조하십시오."

#: ../../extending/extending.rst:457
msgid "Compilation and Linkage"
msgstr "컴파일과 링크"

#: ../../extending/extending.rst:459
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your "
"system uses; see the chapters about building extension modules (chapter "
":ref:`building`) and additional information that pertains only to "
"building on Windows (chapter :ref:`building-on-windows`) for more "
"information about this."
msgstr ""
"새로운 확장을 사용하기 전에 해야 할 두 가지 작업이 더 있습니다: 컴파일과 파이썬 시스템과의 링크. 동적 로딩을 사용하면, 세부 "
"사항은 시스템이 사용하는 동적 로딩 스타일에 따라 달라질 수 있습니다; 확장 모듈을 빌드하는 것에 관한 "
"장(:ref:`building` 장)과 윈도우 빌드에 대한 자세한 정보는 이에만 관련된 추가 정보(:ref:`building-on-"
"windows` 장)를 참조하십시오."

#: ../../extending/extending.rst:466
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) "
"in the :file:`Modules/` directory of an unpacked source distribution, add"
" a line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""
"동적 로딩을 사용할 수 없거나, 모듈을 파이썬 인터프리터의 영구적인 부분으로 만들려면, 구성 설정을 변경하고 인터프리터를 다시 "
"빌드해야 합니다. 운 좋게도, 이것은 유닉스에서 매우 간단합니다: 압축을 푼 소스 배포의 :file:`Modules/` 디렉터리에 "
"파일(예를 들어 :file:`spammodule.c`)을 놓고, :file:`Modules/Setup.local` 파일에 여러분의 "
"파일을 기술하는 한 줄을 추가하십시오:"

#: ../../extending/extending.rst:473
msgid "spam spammodule.o"
msgstr ""

#: ../../extending/extending.rst:477
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you "
"change the :file:`Setup` file.)"
msgstr ""
"그리고 최상위 디렉터리에서 :program:`make`\\를 실행하여 인터프리터를 다시 빌드하십시오. :file:`Modules/`"
" 서브 디렉터리에서 :program:`make`\\를 실행할 수도 있지만, 먼저 ':program:`make` Makefile'을 "
"실행하여 :file:`Makefile`\\을 다시 빌드해야 합니다. (이것은 :file:`Setup` 파일을 변경할 때마다 "
"필요합니다.)"

#: ../../extending/extending.rst:483
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr "모듈에 링크할 추가 라이브러리가 필요하면, 이것도 구성 파일의 줄에 나열될 수 있습니다, 예를 들어:"

#: ../../extending/extending.rst:486
msgid "spam spammodule.o -lX11"
msgstr ""

#: ../../extending/extending.rst:494
msgid "Calling Python Functions from C"
msgstr "C에서 파이썬 함수 호출하기"

#: ../../extending/extending.rst:496
msgid ""
"So far we have concentrated on making C functions callable from Python.  "
"The reverse is also useful: calling Python functions from C. This is "
"especially the case for libraries that support so-called \"callback\" "
"functions.  If a C interface makes use of callbacks, the equivalent "
"Python often needs to provide a callback mechanism to the Python "
"programmer; the implementation will require calling the Python callback "
"functions from a C callback.  Other uses are also imaginable."
msgstr ""
"지금까지 파이썬에서 C 함수를 호출할 수 있도록 하는 데 집중했습니다. 그 반대도 유용합니다: C에서 파이썬 함수 호출하기. 이것은"
" 특히 \"콜백\" 함수를 지원하는 라이브러리의 경우에 해당합니다. C 인터페이스가 콜백을 사용하면, 동등한 파이썬은 종종 파이썬 "
"프로그래머에게 콜백 메커니즘을 제공해야 할 필요가 있습니다; 구현은 C 콜백에서 파이썬 콜백 함수를 호출해야 합니다. 다른 용도도 "
"상상할 수 있습니다."

#: ../../extending/extending.rst:504
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and "
"there is a standard interface to call a Python function.  (I won't dwell "
"on how to call the Python parser with a particular string as input --- if"
" you're interested, have a look at the implementation of the :option:`-c`"
" command line option in :file:`Modules/main.c` from the Python source "
"code.)"
msgstr ""
"다행히, 파이썬 인터프리터는 재귀적으로 쉽게 호출되며, 파이썬 함수를 호출하는 표준 인터페이스가 있습니다. (특정 문자열을 입력으로"
" 파이썬 파서를 호출하는 방법에 대해서는 다루지 않겠습니다 --- 관심이 있다면, 파이썬 소스 코드에서 "
":file:`Modules/main.c`\\의 :option:`-c` 명령 줄 옵션 구현을 살펴보십시오.)"

#: ../../extending/extending.rst:510
msgid ""
"Calling a Python function is easy.  First, the Python program must "
"somehow pass you the Python function object.  You should provide a "
"function (or some other interface) to do this.  When this function is "
"called, save a pointer to the Python function object (be careful to "
":c:func:`Py_INCREF` it!) in a global variable --- or wherever you see "
"fit. For example, the following function might be part of a module "
"definition::"
msgstr ""
"파이썬 함수를 호출하기는 쉽습니다. 먼저, 파이썬 프로그램은 어떻게 든 여러분에게 파이썬 함수 객체를 전달해야 합니다. 이를 위해 "
"함수(또는 다른 인터페이스)를 제공해야 합니다. 이 함수가 호출될 때, 전역 변수(또는 여러분이 보기에 적절한 곳 어디에나)에 "
"파이썬 함수 객체에 대한 포인터를 저장하십시오 (:c:func:`Py_INCREF`\\해야 하는 것에 주의하십시오!). 예를 들어,"
" 다음 함수는 모듈 정의의 일부일 수 있습니다::"

#: ../../extending/extending.rst:517
#, python-brace-format
msgid ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parameter must be "
"callable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp);         /* Add a reference to new callback */\n"
"        Py_XDECREF(my_callback);  /* Dispose of previous callback */\n"
"        my_callback = temp;       /* Remember new callback */\n"
"        /* Boilerplate to return \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:540
#, fuzzy
msgid ""
"This function must be registered with the interpreter using the "
":c:macro:`METH_VARARGS` flag; this is described in section "
":ref:`methodtable`.  The :c:func:`PyArg_ParseTuple` function and its "
"arguments are documented in section :ref:`parsetuple`."
msgstr ""
"이 함수는 :const:`METH_VARARGS` 플래그를 사용하여 인터프리터에 등록해야 합니다; 이것은 섹션 "
":ref:`methodtable`\\에 설명되어 있습니다. :c:func:`PyArg_ParseTuple` 함수와 그것의 인자는 "
":ref:`parsetuple` 섹션에 설명되어 있습니다."

#: ../../extending/extending.rst:545
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` "
"increment/decrement the reference count of an object and are safe in the "
"presence of ``NULL`` pointers (but note that *temp* will not be  ``NULL``"
" in this context).  More info on them in section :ref:`refcounts`."
msgstr ""
"매크로 :c:func:`Py_XINCREF`\\와 :c:func:`Py_XDECREF`\\는 객체의 참조 횟수를 증가/감소시키며 "
"``NULL`` 포인터가 있을 때 안전합니다 (그러나 이 문맥에서 *temp*\\는 ``NULL``\\이 아님에 유의하십시오). "
"섹션 :ref:`refcounts`\\에 이에 대한 자세한 정보가 있습니다."

#: ../../extending/extending.rst:552
msgid ""
"Later, when it is time to call the function, you call the C function "
":c:func:`PyObject_CallObject`.  This function has two arguments, both "
"pointers to arbitrary Python objects: the Python function, and the "
"argument list.  The argument list must always be a tuple object, whose "
"length is the number of arguments.  To call the Python function with no "
"arguments, pass in ``NULL``, or an empty tuple; to call it with one "
"argument, pass a singleton tuple. :c:func:`Py_BuildValue` returns a tuple"
" when its format string consists of zero or more format codes between "
"parentheses.  For example::"
msgstr ""
"나중에, 함수를 호출할 때, C 함수 :c:func:`PyObject_CallObject`\\를 호출합니다. 이 함수에는 두 개의 "
"인자가 있는데, 모두 임의의 파이썬 객체에 대한 포인터입니다: 파이썬 함수와 인자 목록. 인자 목록은 항상 길이가 인자의 수인 튜플"
" 객체여야 합니다. 인자 없이 파이썬 함수를 호출하려면, ``NULL``\\이나 빈 튜플을 전달하십시오; 하나의 인자로 호출하려면,"
" 단 항목 튜플을 전달하십시오. :c:func:`Py_BuildValue`\\는 포맷 문자열이 괄호 사이에 0개 이상의 포맷 코드로"
" 구성되었을 때 튜플을 반환합니다. 예를 들면::"

#: ../../extending/extending.rst:561
msgid ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Time to call the callback */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"
msgstr ""

#: ../../extending/extending.rst:572
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is "
"the return value of the Python function.  :c:func:`PyObject_CallObject` "
"is \"reference-count-neutral\" with respect to its arguments.  In the "
"example a new tuple was created to serve as the argument list, which is "
":c:func:`Py_DECREF`\\ -ed immediately after the "
":c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject`\\는 파이썬 객체 포인터를 반환합니다: 이것은 파이썬 함수의 반환 값입니다. "
":c:func:`PyObject_CallObject`\\는 인자와 관련하여 \"참조 횟수 중립적\"입니다. 이 예에서는 "
":c:func:`PyObject_CallObject` 호출 직후 :c:func:`Py_DECREF`\\되는 인자 목록으로 사용할 새"
" 튜플이 만들어졌습니다."

#: ../../extending/extending.rst:579
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it "
"is a brand new object, or it is an existing object whose reference count "
"has been incremented.  So, unless you want to save it in a global "
"variable, you should somehow :c:func:`Py_DECREF` the result, even "
"(especially!) if you are not interested in its value."
msgstr ""
":c:func:`PyObject_CallObject`\\의 반환 값은 \"새것\"입니다: 완전히 새로운 객체이거나 참조 횟수가 "
"증가한 기존 객체입니다. 따라서, 전역 변수에 저장하려는 것이 아닌 한, 설사 (특히!) 그 값에 관심이 없더라도 결과를 "
":c:func:`Py_DECREF`\\해야 합니다."

#: ../../extending/extending.rst:585
msgid ""
"Before you do this, however, it is important to check that the return "
"value isn't ``NULL``.  If it is, the Python function terminated by "
"raising an exception. If the C code that called "
":c:func:`PyObject_CallObject` is called from Python, it should now return"
" an error indication to its Python caller, so the interpreter can print a"
" stack trace, or the calling Python code can handle the exception. If "
"this is not possible or desirable, the exception should be cleared by "
"calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"그러나, 이 작업을 수행하기 전에 반환 값이 ``NULL``\\이 아닌지 확인해야 합니다. 그렇다면, 파이썬 함수는 예외를 발생 "
"시켜 종료한 것입니다. :c:func:`PyObject_CallObject`\\라는 C 코드가 파이썬에서 호출되었다면 이제 파이썬 "
"호출자에게 에러 표시를 반환하여, 인터프리터가 스택 트레이스를 인쇄하거나 호출하는 파이썬 코드가 예외를 처리할 수 있도록 합니다. "
"이것이 불가능하거나 바람직하지 않으면, :c:func:`PyErr_Clear`\\를 호출하여 예외를 지워야 합니다. 예를 들면::"

#: ../../extending/extending.rst:593
msgid ""
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"...use result...\n"
"Py_DECREF(result);"
msgstr ""

#: ../../extending/extending.rst:598
msgid ""
"Depending on the desired interface to the Python callback function, you "
"may also have to provide an argument list to "
":c:func:`PyObject_CallObject`.  In some cases the argument list is also "
"provided by the Python program, through the same interface that specified"
" the callback function.  It can then be saved and used in the same manner"
" as the function object.  In other cases, you may have to construct a new"
" tuple to pass as the argument list.  The simplest way to do this is to "
"call :c:func:`Py_BuildValue`.  For example, if you want to pass an "
"integral event code, you might use the following code::"
msgstr ""
"파이썬 콜백 함수에 대해 원하는 인터페이스에 따라, :c:func:`PyObject_CallObject`\\에 인자 목록을 제공해야"
" 할 수도 있습니다. 때에 따라 인자 목록은 콜백 함수를 지정한 같은 인터페이스를 통해 파이썬 프로그램에서 제공됩니다. 그런 다음 "
"함수 객체와 같은 방식으로 저장하고 사용할 수 있습니다. 다른 경우에는, 인자 목록으로 전달할 새 튜플을 구성해야 할 수도 "
"있습니다. 이렇게 하는 가장 간단한 방법은 :c:func:`Py_BuildValue`\\를 호출하는 것입니다. 예를 들어, 정수 "
"이벤트 코드를 전달하려면, 다음 코드를 사용할 수 있습니다::"

#: ../../extending/extending.rst:607
msgid ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""

#: ../../extending/extending.rst:617
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is "
"not complete: :c:func:`Py_BuildValue` may run out of memory, and this "
"should be checked."
msgstr ""
"호출 직후, 에러 점검 전에 ``Py_DECREF(arglist)``\\의 배치에 유의하십시오! 또한 엄격하게 말하면 이 코드가 "
"완전하지 않음에도 유의하십시오: :c:func:`Py_BuildValue`\\에 메모리가 부족할 수 있어서 확인해야 합니다."

#: ../../extending/extending.rst:621
msgid ""
"You may also call a function with keyword arguments by using "
":c:func:`PyObject_Call`, which supports arguments and keyword arguments."
"  As in the above example, we use :c:func:`Py_BuildValue` to construct "
"the dictionary. ::"
msgstr ""
"인자와 키워드 인자를 지원하는 :c:func:`PyObject_Call`\\을 사용하여 키워드 인자가 있는 함수를 호출할 수도 "
"있습니다. 위의 예에서와같이, :c:func:`Py_BuildValue`\\를 사용하여 딕셔너리를 구성합니다. ::"

#: ../../extending/extending.rst:625
#, python-brace-format
msgid ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"name\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""

#: ../../extending/extending.rst:639
msgid "Extracting Parameters in Extension Functions"
msgstr "확장 함수에서 매개 변수 추출하기"

#: ../../extending/extending.rst:643
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr ":c:func:`PyArg_ParseTuple` 함수는 다음과 같이 선언됩니다::"

#: ../../extending/extending.rst:645
msgid "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"
msgstr ""

#: ../../extending/extending.rst:647
msgid ""
"The *arg* argument must be a tuple object containing an argument list "
"passed from Python to a C function.  The *format* argument must be a "
"format string, whose syntax is explained in :ref:`arg-parsing` in the "
"Python/C API Reference Manual.  The remaining arguments must be addresses"
" of variables whose type is determined by the format string."
msgstr ""
"*arg* 인자는 파이썬에서 C 함수로 전달되는 인자 목록이 포함된 튜플 객체여야 합니다. *format* 인자는 포맷 문자열이어야"
" 하며, 문법은 파이썬/C API 레퍼런스 매뉴얼의 :ref:`arg-parsing`\\에 설명되어 있습니다. 나머지 인자는 포맷 "
"문자열에 의해 형이 결정되는 변수의 주소여야 합니다."

#: ../../extending/extending.rst:653
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python "
"arguments have the required types, it cannot check the validity of the "
"addresses of C variables passed to the call: if you make mistakes there, "
"your code will probably crash or at least overwrite random bits in "
"memory.  So be careful!"
msgstr ""
":c:func:`PyArg_ParseTuple`\\은 파이썬 인자가 요구되는 형인지 확인하지만, 호출에 전달된 C 변수 주소의 "
"유효성을 확인할 수는 없습니다: 실수를 하면, 코드가 충돌하거나 적어도 메모리의 임의 비트를 덮어씁니다. 그러니 조심하십시오!"

#: ../../extending/extending.rst:658
msgid ""
"Note that any Python object references which are provided to the caller "
"are *borrowed* references; do not decrement their reference count!"
msgstr "호출자에게 제공되는 모든 파이썬 객체 참조는 *빌려온(borrowed)* 참조임에 유의하십시오; 참조 횟수를 줄이지 마십시오!"

#: ../../extending/extending.rst:661
msgid "Some example calls::"
msgstr "몇 가지 예제 호출::"

#: ../../extending/extending.rst:668
msgid ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* No arguments */\n"
"    /* Python call: f() */"
msgstr ""

#: ../../extending/extending.rst:679
msgid ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* A string */\n"
"    /* Possible Python call: f('whoops!') */"
msgstr ""

#: ../../extending/extending.rst:684
msgid ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Two longs and a "
"string */\n"
"    /* Possible Python call: f(1, 2, 'three') */"
msgstr ""

#: ../../extending/extending.rst:689
msgid ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* A pair of ints and a string, whose size is also returned */\n"
"    /* Possible Python call: f((1, 2), 'three') */"
msgstr ""

#: ../../extending/extending.rst:695
#, python-brace-format
msgid ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* A string, and optionally another string and an integer */\n"
"    /* Possible Python calls:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:709
#, python-brace-format
msgid ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* A rectangle and a point */\n"
"    /* Possible Python call:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:720
#, python-brace-format
msgid ""
"{\n"
"    Py_complex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* a complex, also providing a function name for errors */\n"
"    /* Possible Python call: myfunction(1+2j) */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:731
msgid "Keyword Parameters for Extension Functions"
msgstr "확장 함수를 위한 키워드 매개 변수"

#: ../../extending/extending.rst:735
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as "
"follows::"
msgstr ":c:func:`PyArg_ParseTupleAndKeywords` 함수는 다음과 같이 선언됩니다::"

#: ../../extending/extending.rst:737
msgid ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char * const *kwlist,"
" ...);"
msgstr ""

#: ../../extending/extending.rst:740
msgid ""
"The *arg* and *format* parameters are identical to those of the "
":c:func:`PyArg_ParseTuple` function.  The *kwdict* parameter is the "
"dictionary of keywords received as the third parameter from the Python "
"runtime.  The *kwlist* parameter is a ``NULL``-terminated list of strings"
" which identify the parameters; the names are matched with the type "
"information from *format* from left to right.  On success, "
":c:func:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns "
"false and raises an appropriate exception."
msgstr ""
"*arg*\\와 *format* 매개 변수는 :c:func:`PyArg_ParseTuple` 함수와 동일합니다. *kwdict* "
"매개 변수는 파이썬 런타임에서 세 번째 매개 변수로 수신된 키워드 딕셔너리입니다. *kwlist* 매개 변수는 매개 변수를 식별하는"
" 문자열의 ``NULL`` 종료 목록입니다; 이름은 왼쪽에서 오른쪽으로 *format*\\의 형 정보와 일치합니다. 성공하면, "
":c:func:`PyArg_ParseTupleAndKeywords`\\는 참을 반환하고, 그렇지 않으면 거짓을 반환하고 적절한 "
"예외를 발생시킵니다."

#: ../../extending/extending.rst:750
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause "
":exc:`TypeError` to be raised."
msgstr ""
"키워드 인자를 사용할 때 중첩된 튜플을 구문분석할 수 없습니다! *kwlist*\\에 없는 키워드 매개 변수가 전달되면 "
":exc:`TypeError`\\를 발생시킵니다."

#: ../../extending/extending.rst:756
msgid ""
"Here is an example module which uses keywords, based on an example by "
"Geoff Philbrick (philbrick@hks.com)::"
msgstr "다음은 Geoff Philbrick (philbrick@hks.com) 의 예제를 기반으로 한, 키워드를 사용하는 예제 모듈입니다::"

#: ../../extending/extending.rst:759
#, python-format
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int voltage;\n"
"    const char *state = \"a stiff\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"Norwegian Blue\";\n"
"\n"
"    static char *kwlist[] = {\"voltage\", \"state\", \"action\", "
"\"type\", NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        return NULL;\n"
"\n"
"    printf(\"-- This parrot wouldn't %s if you put %i Volts through "
"it.\\n\",\n"
"           action, voltage);\n"
"    printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* The cast of the function is necessary since PyCFunction values\n"
"     * only take two PyObject* parameters, and keywdarg_parrot() takes\n"
"     * three.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, "
"METH_VARARGS | METH_KEYWORDS,\n"
"     \"Print a lovely skit to standard output.\"},\n"
"    {NULL, NULL, 0, NULL}   /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdargmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    \"keywdarg\",\n"
"    NULL,\n"
"    -1,\n"
"    keywdarg_methods\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModule_Create(&keywdargmodule);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:811
msgid "Building Arbitrary Values"
msgstr "임의의 값을 구축하기"

#: ../../extending/extending.rst:813
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr "이 함수는 :c:func:`PyArg_ParseTuple`\\의 반대입니다. 다음과 같이 선언됩니다::"

#: ../../extending/extending.rst:816
msgid "PyObject *Py_BuildValue(const char *format, ...);"
msgstr ""

#: ../../extending/extending.rst:818
msgid ""
"It recognizes a set of format units similar to the ones recognized by "
":c:func:`PyArg_ParseTuple`, but the arguments (which are input to the "
"function, not output) must not be pointers, just values.  It returns a "
"new Python object, suitable for returning from a C function called from "
"Python."
msgstr ""
":c:func:`PyArg_ParseTuple`\\에서 인식되는 것과 유사한 포맷 단위 집합을 인식하지만, 인자(함수의 출력이 "
"아니라 입력입니다)는 포인터가 아니라 그냥 값이어야 합니다. 파이썬에서 호출한 C 함수에서 반환하기에 적합한 새 파이썬 객체를 "
"반환합니다."

#: ../../extending/extending.rst:823
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires"
" its first argument to be a tuple (since Python argument lists are always"
" represented as tuples internally), :c:func:`Py_BuildValue` does not "
"always build a tuple.  It builds a tuple only if its format string "
"contains two or more format units. If the format string is empty, it "
"returns ``None``; if it contains exactly one format unit, it returns "
"whatever object is described by that format unit.  To force it to return "
"a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`PyArg_ParseTuple`\\과의 한 가지 차이점: 후자는 첫 번째 인자가 튜플이어야 하지만 (파이썬 인자 "
"목록은 항상 내부적으로 튜플로 표현되기 때문입니다), :c:func:`Py_BuildValue`\\는 항상 튜플을 빌드하지는 "
"않습니다. 포맷 문자열에 둘 이상의 포맷 단위가 포함된 경우에만 튜플을 빌드합니다. 포맷 문자열이 비어 있으면 ``None``\\을"
" 반환합니다; 정확히 하나의 포맷 단위를 포함하면, 그것이 무엇이건 해당 포맷 단위가 기술하는 객체를 반환합니다. 크기가 0이나 "
"1인 튜플을 강제로 반환하도록 하려면, 포맷 문자열을 괄호로 묶으십시오."

#: ../../extending/extending.rst:831
msgid "Examples (to the left the call, to the right the resulting Python value):"
msgstr "예제 (왼쪽은 호출이고, 오른쪽은 결과 파이썬 값입니다):"

#: ../../extending/extending.rst:833
#, python-brace-format
msgid ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"
msgstr ""

#: ../../extending/extending.rst:857
msgid "Reference Counts"
msgstr "참조 횟수"

#: ../../extending/extending.rst:859
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done "
"using the functions :c:func:`malloc` and :c:func:`free`.  In C++, the "
"operators ``new`` and ``delete`` are used with essentially the same "
"meaning and we'll restrict the following discussion to the C case."
msgstr ""
"C나 C++ 와 같은 언어에서, 힙에서 메모리의 동적 할당과 할당 해제하는 것은 프로그래머가 담당합니다. C에서는, "
":c:func:`malloc`\\과 :c:func:`free` 함수를 사용하여 이 작업을 수행합니다. C++에서는, 연산자 "
"``new``\\와 ``delete``\\는 본질적으로 같은 의미로 사용되며 우리는 뒤따르는 논의를 C의 경우로 제한하겠습니다."

#: ../../extending/extending.rst:865
#, fuzzy
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually "
"be returned to the pool of available memory by exactly one call to "
":c:func:`free`. It is important to call :c:func:`free` at the right time."
"  If a block's address is forgotten but :c:func:`free` is not called for "
"it, the memory it occupies cannot be reused until the program terminates."
"  This is called a :dfn:`memory leak`.  On the other hand, if a program "
"calls :c:func:`free` for a block and then continues to use the block, it "
"creates a conflict with reuse of the block through another "
":c:func:`malloc` call.  This is called :dfn:`using freed memory`. It has "
"the same bad consequences as referencing uninitialized data --- core "
"dumps, wrong results, mysterious crashes."
msgstr ""
":c:func:`malloc`\\으로 할당된 모든 메모리 블록은 :c:func:`free`\\를 정확히 한 번 호출하여 사용 가능한"
" 메모리 풀로 반환되어야 합니다. 적시에 :c:func:`free`\\를 호출하는 것이 중요합니다. 블록의 주소를 잊어버렸지만, "
":c:func:`free`\\를 호출하지 않으면 프로그램이 종료될 때까지 블록을 차지하는 메모리를 재사용할 수 없습니다. 이것을 "
":dfn:`메모리 누수(memory leak)`\\라고 합니다. 반면에, 프로그램이 블록에 대해 :c:func:`free`\\를 "
"호출한 다음 블록을 계속 사용하면, 다른 :c:func:`malloc` 호출을 통해 블록을 재사용할 때 충돌이 발생합니다. 이것을 "
":dfn:`해제된 메모리 사용하기(using freed memory)`\\라고 합니다. 초기화되지 않은 데이터를 참조하는 것과 같은"
" 나쁜 결과를 초래합니다 --- 코어 덤프, 잘못된 결과, 미스테리한 충돌."

#: ../../extending/extending.rst:876
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation,"
" and then free the block again.  Now a change in the requirements for the"
" function may add a test to the calculation that detects an error "
"condition and can return prematurely from the function.  It's easy to "
"forget to free the allocated memory block when taking this premature "
"exit, especially when it is added later to the code.  Such leaks, once "
"introduced, often go undetected for a long time: the error exit is taken "
"only in a small fraction of all calls, and most modern machines have "
"plenty of virtual memory, so the leak only becomes apparent in a long-"
"running process that uses the leaking function frequently.  Therefore, "
"it's important to prevent leaks from happening by having a coding "
"convention or strategy that minimizes this kind of errors."
msgstr ""
"메모리 누수의 일반적인 원인은 코드를 통한 비정상적인 경로입니다. 예를 들어, 함수는 메모리 블록을 할당하고, 어떤 계산을 한 "
"다음, 블록을 다시 해제할 수 있습니다. 이제 함수에 대한 요구 사항이 변경되어 에러 조건을 감지하는 계산에 대한 검사를 추가하고 "
"함수가 조기에 반환할 수 있도록 합니다. 이 조기 탈출을 수행할 때, 특히 나중에 코드에 추가될 때, 할당된 메모리 블록을 해제하는"
" 것을 잊어버리기 쉽습니다. 이러한 누수는 일단 만들어지면 종종 오랫동안 탐지되지 않습니다: 에러 탈출은 전체 호출의 작은 "
"부분에서만 이루어지며, 대부분의 최신 시스템에는 많은 가상 메모리가 있어서, 누수 하는 함수를 자주 사용하는 오래 실행되는 "
"프로세스에서만 누수가 나타납니다. 따라서, 이런 종류의 에러를 코딩 규칙이나 전략을 통해 누수가 발생하지 않도록 하는 것이 "
"중요합니다."

#: ../../extending/extending.rst:889
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed "
"memory.  The chosen method is called :dfn:`reference counting`.  The "
"principle is simple: every object contains a counter, which is "
"incremented when a reference to the object is stored somewhere, and which"
" is decremented when a reference to it is deleted. When the counter "
"reaches zero, the last reference to the object has been deleted and the "
"object is freed."
msgstr ""
"파이썬은 :c:func:`malloc`\\과 :c:func:`free`\\를 많이 사용하기 때문에, 메모리 누수와 해제된 메모리 "
"사용을 피하는 전략이 필요합니다. 선택된 방법을 :dfn:`참조 횟수 세기(reference counting)`\\라고 합니다. "
"원리는 간단합니다: 모든 객체에는 카운터를 포함합니다, 카운터는 객체에 대한 참조가 어딘가에 저장될 때 증가하고, 참조가 삭제될 때"
" 감소합니다. 카운터가 0에 도달하면, 객체에 대한 마지막 참조가 삭제된 것이고 객체가 해제됩니다."

#: ../../extending/extending.rst:897
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage "
"collection strategy, hence my use of \"automatic\" to distinguish the "
"two.)  The big advantage of automatic garbage collection is that the user"
" doesn't need to call :c:func:`free` explicitly.  (Another claimed "
"advantage is an improvement in speed or memory usage --- this is no hard "
"fact however.)  The disadvantage is that for C, there is no truly "
"portable automatic garbage collector, while reference counting can be "
"implemented portably (as long as the functions :c:func:`malloc` and "
":c:func:`free` are available --- which the C Standard guarantees). Maybe "
"some day a sufficiently portable automatic garbage collector will be "
"available for C. Until then, we'll have to live with reference counts."
msgstr ""
"대체 전략을 :dfn:`자동 가비지 수집(automatic garbage collection)`\\이라고 합니다. (때로는, 참조 "
"횟수 세기도 가비지 수집 전략이라고 해서, 두 가지를 구별하기 위해 \"자동\"을 붙였습니다.) 자동 가비지 수집의 가장 큰 장점은"
" 사용자가 :c:func:`free`\\를 명시적으로 호출할 필요가 없다는 것입니다. (또 다른 주장된 이점은 속도나 메모리 "
"사용량의 개선이지만 --- 이것은 견고한 사실이 아닙니다.) 단점은 C의 경우 참조 횟수 세기는 이식성 있게 구현할 수 있지만 "
"(함수 :c:func:`malloc`\\과 :c:func:`free`\\를 사용할 수 있는 한 --- 이는 C 표준이 보장합니다),"
" 실제로 이식성 있는 자동 가비지 수집기가 없다는 것입니다. 언젠가 C를 위해 충분히 이식성 있는 자동 가비지 수집기를 사용할 수 "
"있을 것입니다. 그때까지, 우리는 참조 횟수와 함께 살아야 할 것입니다."

#: ../../extending/extending.rst:909
msgid ""
"While Python uses the traditional reference counting implementation, it "
"also offers a cycle detector that works to detect reference cycles.  This"
" allows applications to not worry about creating direct or indirect "
"circular references; these are the weakness of garbage collection "
"implemented using only reference counting.  Reference cycles consist of "
"objects which contain (possibly indirect) references to themselves, so "
"that each object in the cycle has a reference count which is non-zero.  "
"Typical reference counting implementations are not able to reclaim the "
"memory belonging to any objects in a reference cycle, or referenced from "
"the objects in the cycle, even though there are no further references to "
"the cycle itself."
msgstr ""
"파이썬은 전통적인 참조 횟수 세기 구현을 사용하지만, 참조 순환을 감지하는 순환 감지기도 제공합니다. 이를 통해 응용 프로그램은 "
"직접적이거나 간접적인 순환 참조를  만드는 것(이것이 참조 횟수만 사용하여 구현된 가비지 수집의 약점입니다)에 대해 걱정하지 않아도"
" 됩니다. 참조 순환은 (어쩌면 간접적으로) 자신에 대한 참조를 포함하는 객체로 구성되어서, 순환의 각 객체는 0이 아닌 참조 "
"횟수를 갖습니다. 일반적인 참조 횟수 세기 구현에서는 순환 자체에 대한 추가 참조가 없더라도 참조 순환의 객체에 속하는 메모리나 "
"순환에 속한 객체에서 참조된 메모리를 회수할 수 없습니다."

#: ../../extending/extending.rst:920
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them."
" The :mod:`gc` module exposes a way to run the detector (the "
":func:`~gc.collect` function), as well as configuration interfaces and "
"the ability to disable the detector at runtime."
msgstr ""

#: ../../extending/extending.rst:929
msgid "Reference Counting in Python"
msgstr "파이썬에서 참조 횟수 세기"

#: ../../extending/extending.rst:931
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle"
" the incrementing and decrementing of the reference count. "
":c:func:`Py_DECREF` also frees the object when the count reaches zero. "
"For flexibility, it doesn't call :c:func:`free` directly --- rather, it "
"makes a call through a function pointer in the object's :dfn:`type "
"object`.  For this purpose (and others), every object also contains a "
"pointer to its type object."
msgstr ""
"참조 횟수의 증가와 감소를 처리하는 두 개의 매크로 ``Py_INCREF(x)``\\와 ``Py_DECREF(x)``\\가 "
"있습니다. :c:func:`Py_DECREF`\\는 횟수가 0에 도달하면 객체를 해제하기도 합니다. 유연성을 위해, "
":c:func:`free`\\를 직접 호출하지 않습니다 --- 대신, 객체의 :dfn:`형 객체(type object)`\\에 있는"
" 함수 포인터를 통해 호출합니다. 이 목적(및 기타)을 위해 모든 객체에는 해당 형 객체에 대한 포인터도 포함됩니다."

#: ../../extending/extending.rst:938
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An "
"object's reference count is now defined as the number of owned references"
" to it.  The owner of a reference is responsible for calling "
":c:func:`Py_DECREF` when the reference is no longer needed.  Ownership of"
" a reference can be transferred.  There are three ways to dispose of an "
"owned reference: pass it on, store it, or call :c:func:`Py_DECREF`. "
"Forgetting to dispose of an owned reference creates a memory leak."
msgstr ""
"이제 큰 질문이 남습니다: 언제 ``Py_INCREF(x)``\\와 ``Py_DECREF(x)``\\를 사용합니까? 먼저 몇 가지 "
"용어를 소개하겠습니다. 아무도 객체를 \"소유(owns)\"하지 않습니다ㅣ 그러나, 객체에 대한 :dfn:`참조를 소유(own a "
"reference)`\\할 수 있습니다. 객체의 참조 횟수는 이제 이 객체에 대한 참조를 소유한 수로 정의됩니다. 참조 소유자는 "
"더는 참조가 필요하지 않을 때 :c:func:`Py_DECREF`\\를 호출해야 합니다. 참조의 소유권을 양도할 수 있습니다. "
"소유한 참조를 처분하는 세 가지 방법이 있습니다: 전달, 저장 및 :c:func:`Py_DECREF` 호출. 소유한 참조를 처분하지"
" 않으면 메모리 누수가 발생합니다."

#: ../../extending/extending.rst:947
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The "
"borrower must not hold on to the object longer than the owner from which "
"it was borrowed. Using a borrowed reference after the owner has disposed "
"of it risks using freed memory and should be avoided completely [#]_."
msgstr ""
"객체에 대한 참조를 :dfn:`빌리는(borrow)` [#]_ 것도 가능합니다. 참조의 대여자(borrower)는 "
":c:func:`Py_DECREF`\\를 호출해서는 안 됩니다. 대여자는 빌린 소유자보다 더 오래 객체를 붙잡아서는 안 됩니다. "
"소유자가 처분한 후 빌린 참조를 사용하면 해제된 메모리를 사용할 위험이 있어서 절대 피해야 합니다 [#]_."

#: ../../extending/extending.rst:953
msgid ""
"The advantage of borrowing over owning a reference is that you don't need"
" to take care of disposing of the reference on all possible paths through"
" the code --- in other words, with a borrowed reference you don't run the"
" risk of leaking when a premature exit is taken.  The disadvantage of "
"borrowing over owning is that there are some subtle situations where in "
"seemingly correct code a borrowed reference can be used after the owner "
"from which it was borrowed has in fact disposed of it."
msgstr ""
"참조 소유에 비교할 때 빌리기의 이점은 코드를 통한 가능한 모든 경로에서 참조를 처리할 필요가 없다는 것입니다 --- 즉, 빌려온 "
"참조를 사용하면 조기 종료 시에 누수의 위험이 없습니다. 소유하는 것에 비해 빌리는 것의 단점은, 겉보기에는 올바른 코드지만, "
"빌려준 소유자가 실제로는 참조를 처분한 후에 빌린 참조가 사용될 수 있는 미묘한 상황이 있다는 것입니다."

#: ../../extending/extending.rst:961
msgid ""
"A borrowed reference can be changed into an owned reference by calling "
":c:func:`Py_INCREF`.  This does not affect the status of the owner from "
"which the reference was borrowed --- it creates a new owned reference, "
"and gives full owner responsibilities (the new owner must dispose of the "
"reference properly, as well as the previous owner)."
msgstr ""
"빌린 참조는 :c:func:`Py_INCREF`\\를 호출하여 소유한 참조로 변경할 수 있습니다. 이는 참조를 빌려온 소유자의 "
"상태에 영향을 미치지 않습니다 --- 새로운 소유된 참조를 만들고, 완전한 소유자 책임을 부여합니다 (이전 소유자뿐만 아니라, 새 "
"소유자는 참조를 올바르게 처분해야 합니다)."

#: ../../extending/extending.rst:971
msgid "Ownership Rules"
msgstr "소유권 규칙"

#: ../../extending/extending.rst:973
msgid ""
"Whenever an object reference is passed into or out of a function, it is "
"part of the function's interface specification whether ownership is "
"transferred with the reference or not."
msgstr "객체 참조가 함수 안팎으로 전달될 때마다, 소유권이 참조와 함께 전달되는지 그렇지 않은지는 함수 인터페이스 명세의 일부입니다."

#: ../../extending/extending.rst:977
msgid ""
"Most functions that return a reference to an object pass on ownership "
"with the reference.  In particular, all functions whose function it is to"
" create a new object, such as :c:func:`PyLong_FromLong` and "
":c:func:`Py_BuildValue`, pass ownership to the receiver.  Even if the "
"object is not actually new, you still receive ownership of a new "
"reference to that object.  For instance, :c:func:`PyLong_FromLong` "
"maintains a cache of popular values and can return a reference to a "
"cached item."
msgstr ""
"객체에 대한 참조를 반환하는 대부분의 함수는 참조와 함께 소유권을 전달합니다. 특히, "
":c:func:`PyLong_FromLong`\\이나 :c:func:`Py_BuildValue`\\와 같은 새 객체를 만드는 기능을"
" 가진 모든 함수는 소유권을 수신자에게 전달합니다. 객체가 실제로 새 객체가 아니더라도, 여전히 해당 객체에 대한 새 참조의 "
"소유권을 받습니다. 예를 들어, :c:func:`PyLong_FromLong`\\은 흔히 사용되는 값의 캐시를 유지하고 캐시 된 "
"항목에 대한 참조를 반환할 수 있습니다."

#: ../../extending/extending.rst:985
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance "
":c:func:`PyObject_GetAttrString`.  The picture is less clear, here, "
"however, since a few common routines are exceptions: "
":c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, "
":c:func:`PyDict_GetItem`, and :c:func:`PyDict_GetItemString` all return "
"references that you borrow from the tuple, list or dictionary."
msgstr ""
"다른 객체에서 객체를 추출하는 많은 함수도 참조와 함께 소유권을 전달합니다, 예를 들어 "
":c:func:`PyObject_GetAttrString`. 그러나 몇 가지 일반적인 루틴이 예외이기 때문에 그림이 명확하지 "
"않습니다: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, "
":c:func:`PyDict_GetItem` 및 :c:func:`PyDict_GetItemString`\\은 모두 튜플, 리스트 "
"또는 딕셔너리에서 빌린 참조를 반환합니다."

#: ../../extending/extending.rst:992
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed "
"reference, even though it may actually create the object it returns: this"
" is possible because an owned reference to the object is stored in "
"``sys.modules``."
msgstr ""
":c:func:`PyImport_AddModule` 함수도 실제는 반환하는 객체를 만들 수 있지만 빌린 참조를 반환합니다: 객체에 "
"대한 소유한 참조가 ``sys.modules``\\에 저장되어 있기 때문에 가능합니다."

#: ../../extending/extending.rst:996
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it "
"will use :c:func:`Py_INCREF` to become an independent owner.  There are "
"exactly two important exceptions to this rule: :c:func:`PyTuple_SetItem` "
"and :c:func:`PyList_SetItem`.  These functions take over ownership of the"
" item passed to them --- even if they fail!  (Note that "
":c:func:`PyDict_SetItem` and friends don't take over ownership --- they "
"are \"normal.\")"
msgstr ""
"객체 참조를 다른 함수에 전달할 때, 일반적으로, 함수는 여러분으로부터 참조를 빌립니다 --- 참조를 저장해야 하면, "
":c:func:`Py_INCREF`\\를 사용하여 독립 소유자가 됩니다. 이 규칙에는 두 가지 중요한 예외가 있습니다: "
":c:func:`PyTuple_SetItem`\\과 :c:func:`PyList_SetItem`. 이 함수들은 전달된 항목에 대한 "
"소유권을 취합니다 --- 설사 실패하더라도! (:c:func:`PyDict_SetItem`\\과 그 친구들은 소유권을 취하지 "
"않습니다 --- 이들은 \"정상\" 입니다.)"

#: ../../extending/extending.rst:1004
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so"
" the borrowed reference's lifetime is guaranteed until the function "
"returns.  Only when such a borrowed reference must be stored or passed "
"on, it must be turned into an owned reference by calling "
":c:func:`Py_INCREF`."
msgstr ""
"C 함수가 파이썬에서 호출될 때, 호출자로부터 온 인자에 대한 참조를 빌립니다. 호출자는 객체에 대한 참조를 소유하기 때문에, 빌린"
" 참조의 수명은 함수가 반환될 때까지 보장됩니다. 이러한 빌린 참조를 저장하거나 전달해야 할 때만, "
":c:func:`Py_INCREF`\\를 호출하여 소유한 참조로 만들어야 합니다."

#: ../../extending/extending.rst:1010
msgid ""
"The object reference returned from a C function that is called from "
"Python must be an owned reference --- ownership is transferred from the "
"function to its caller."
msgstr "파이썬에서 호출된 C 함수에서 반환된 객체 참조는 소유한 참조여야 합니다 --- 소유권은 함수에서 호출자로 전달됩니다."

#: ../../extending/extending.rst:1018
msgid "Thin Ice"
msgstr "살얼음"

#: ../../extending/extending.rst:1020
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference "
"to dispose of it."
msgstr ""
"겉보기에 무해한 빌린 참조의 사용이 문제를 일으킬 수 있는 몇 가지 상황이 있습니다. 이것들은 모두 참조의 소유자가 참조를 "
"처분하도록 할 수 있는 인터프리터의 묵시적 호출과 관련이 있습니다."

#: ../../extending/extending.rst:1024
msgid ""
"The first and most important case to know about is using "
":c:func:`Py_DECREF` on an unrelated object while borrowing a reference to"
" a list item.  For instance::"
msgstr ""
"가장 먼저 알아야 할 가장 중요한 경우는 리스트 항목에 대한 참조를 빌리는 동안 관련이 없는 객체에서 "
":c:func:`Py_DECREF`\\를 사용하는 것입니다. 예를 들어::"

#: ../../extending/extending.rst:1027
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1036
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed "
"reference. Looks harmless, right?  But it's not!"
msgstr ""
"이 함수는 먼저 ``list[0]``\\에 대한 참조를 빌린 다음, ``list[1]``\\을 값 ``0``\\으로 바꾸고, "
"마지막으로 빌린 참조를 인쇄합니다. 무해해 보이지요? 하지만 그렇지 않습니다!"

#: ../../extending/extending.rst:1040
#, fuzzy
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list "
"owns references to all its items, so when item 1 is replaced, it has to "
"dispose of the original item 1.  Now let's suppose the original item 1 "
"was an instance of a user-defined class, and let's further suppose that "
"the class defined a :meth:`!__del__` method.  If this class instance has "
"a reference count of 1, disposing of it will call its :meth:`!__del__` "
"method."
msgstr ""
":c:func:`PyList_SetItem` 으로의 제어 흐름을 따라가 봅시다. 리스트는 모든 항목에 대한 참조를 소유해서, 항목 "
"1을 교체할 때 원래 항목 1을 처분(dispose)해야 합니다. 이제 원본 항목 1이 사용자 정의 클래스의 인스턴스라고 가정하고,"
" 클래스가 :meth:`__del__` 메서드를 정의했다고 더 가정해 봅시다. 이 클래스 인스턴스의 참조 횟수가 1일 때, 이를 "
"처분하면 :meth:`__del__` 메서드가 호출됩니다."

#: ../../extending/extending.rst:1047
#, fuzzy
msgid ""
"Since it is written in Python, the :meth:`!__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`!bug`?  You bet!  Assuming that the "
"list passed into :c:func:`!bug` is accessible to the :meth:`!__del__` "
"method, it could execute a statement to the effect of ``del list[0]``, "
"and assuming this was the last reference to that object, it would free "
"the memory associated with it, thereby invalidating ``item``."
msgstr ""
"파이썬으로 작성되었기 때문에, :meth:`__del__` 메서드는 임의의 파이썬 코드를 실행할 수 있습니다. 그것이 "
":c:func:`bug`\\에서 ``item``\\에 대한 참조를 무효로 하는 작업을 수행할 수 있을까요? 물론입니다! "
":c:func:`bug`\\에 전달된 리스트가 :meth:`__del__` 메서드에서 액세스 가능하다고 가정하면, ``del "
"list[0]``\\의 효과를 주는 문장을 실행할 수 있으며, 이것이 해당 객체에 대한 마지막 참조라고 가정하면, 그것과 연관된 "
"메모리를 해제하고, 그래서 ``item``\\을 무효로 합니다."

#: ../../extending/extending.rst:1055
msgid ""
"The solution, once you know the source of the problem, is easy: "
"temporarily increment the reference count.  The correct version of the "
"function reads::"
msgstr "문제의 원인을 알고 나면, 해결 방법은 쉽습니다: 일시적으로 참조 횟수를 늘리십시오. 올바른 버전의 함수는 다음과 같습니다::"

#: ../../extending/extending.rst:1058
#, python-brace-format
msgid ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1069
#, fuzzy
msgid ""
"This is a true story.  An older version of Python contained variants of "
"this bug and someone spent a considerable amount of time in a C debugger "
"to figure out why his :meth:`!__del__` methods would fail..."
msgstr ""
"이것은 실제 이야기입니다. 이전 버전의 파이썬에는 이 버그의 변형이 포함되어 있으며 누군가 :meth:`__del__` 메서드가 "
"실패하는 이유를 알아내기 위해 C 디버거에서 상당한 시간을 보냈습니다..."

#: ../../extending/extending.rst:1073
msgid ""
"The second case of problems with a borrowed reference is a variant "
"involving threads.  Normally, multiple threads in the Python interpreter "
"can't get in each other's way, because there is a global lock protecting "
"Python's entire object space.  However, it is possible to temporarily "
"release this lock using the macro :c:macro:`Py_BEGIN_ALLOW_THREADS`, and "
"to re-acquire it using :c:macro:`Py_END_ALLOW_THREADS`.  This is common "
"around blocking I/O calls, to let other threads use the processor while "
"waiting for the I/O to complete. Obviously, the following function has "
"the same problem as the previous one::"
msgstr ""
"빌린 참조에 문제가 있는 두 번째 경우는 스레드와 관련된 변형입니다. 일반적으로, 파이썬의 전체 객체 공간을 보호하는 전역 록이 "
"있어서, 파이썬 인터프리터의 여러 스레드는 다른 것들의 길에 끼어들 수 없습니다. 그러나, 매크로 "
":c:macro:`Py_BEGIN_ALLOW_THREADS`\\를 사용하여 이 록을 일시적으로 해제하고 "
":c:macro:`Py_END_ALLOW_THREADS`\\를 사용하여 다시 확보할 수 있습니다. 이는 블로킹 I/O 호출에서 "
"흔한데, I/O가 완료되기를 기다리는 동안 다른 스레드가 프로세서를 사용할 수 있도록 합니다. 분명히, 다음 함수는 이전 함수와 "
"같은 문제가 있습니다::"

#: ../../extending/extending.rst:1082
msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...some blocking I/O call...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1096
msgid "NULL Pointers"
msgstr "NULL 포인터"

#: ../../extending/extending.rst:1098
msgid ""
"In general, functions that take object references as arguments do not "
"expect you to pass them ``NULL`` pointers, and will dump core (or cause "
"later core dumps) if you do so.  Functions that return object references "
"generally return ``NULL`` only to indicate that an exception occurred.  "
"The reason for not testing for ``NULL`` arguments is that functions often"
" pass the objects they receive on to other function --- if each function "
"were to test for ``NULL``, there would be a lot of redundant tests and "
"the code would run more slowly."
msgstr ""
"일반적으로, 객체 참조를 인자로 취하는 함수는 ``NULL`` 포인터를 전달할 것으로 기대하지 않으며, 그렇게 하면 코어를 "
"덤프합니다 (또는 이후의 코어 덤프를 유발합니다). 객체 참조를 반환하는 함수는 일반적으로 예외가 발생했음을 나타내기 위해서만 "
"``NULL``\\을 반환합니다. ``NULL`` 인자를 검사하지 않는 이유는 함수들이 종종 자신이 받은 객체를 다른 함수에 "
"전달하기 때문입니다 --- 각 함수가 ``NULL``\\을 검사한다면, 중복 검사가 많이 발생하고 코드가 더 느리게 실행됩니다."

#: ../../extending/extending.rst:1106
msgid ""
"It is better to test for ``NULL`` only at the \"source:\" when a pointer "
"that may be ``NULL`` is received, for example, from :c:func:`malloc` or "
"from a function that may raise an exception."
msgstr ""
"``NULL``\\일 수 있는 포인터가 수신될 때 \"소스\"에서만 ``NULL``\\을 검사하는 것이 좋습니다, 예를 들어, "
":c:func:`malloc`\\이나 예외를 발생시킬 수 있는 함수에서."

#: ../../extending/extending.rst:1110
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"``NULL`` pointers --- however, their variants :c:func:`Py_XINCREF` and "
":c:func:`Py_XDECREF` do."
msgstr ""
"매크로 :c:func:`Py_INCREF`\\와 :c:func:`Py_DECREF`\\는 ``NULL`` 포인터를 검사하지 않습니다"
" --- 하지만, 그들의 변형 :c:func:`Py_XINCREF`\\와 :c:func:`Py_XDECREF`\\는 확인합니다."

#: ../../extending/extending.rst:1114
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``)"
" don't check for ``NULL`` pointers --- again, there is much code that "
"calls several of these in a row to test an object against various "
"different expected types, and this would generate redundant tests.  There"
" are no variants with ``NULL`` checking."
msgstr ""
"특정 객체 형을 확인하기 위한 매크로(``Pytype_Check()``)는 ``NULL`` 포인터를 확인하지 않습니다 --- 다시,"
" 여러 기대하는 형에 대해 객체를 검사하기 위해 연속해서 이들을 여러 번 호출하는 코드가 많아서, 중복 검사가 생성됩니다. "
"``NULL`` 검사를 하는 변형은 없습니다."

#: ../../extending/extending.rst:1120
msgid ""
"The C function calling mechanism guarantees that the argument list passed"
" to C functions (``args`` in the examples) is never ``NULL`` --- in fact "
"it guarantees that it is always a tuple [#]_."
msgstr ""
"C 함수 호출 메커니즘은 C 함수에 전달된 인자 목록(예에서는 ``args``)이 절대 ``NULL``\\이 아님을 보장합니다 "
"--- 실제로는 항상 튜플임을 보장합니다 [#]_."

#: ../../extending/extending.rst:1124
msgid ""
"It is a severe error to ever let a ``NULL`` pointer \"escape\" to the "
"Python user."
msgstr "``NULL`` 포인터를 파이썬 사용자에게 \"빠져나가게\" 만드는 것은 심각한 에러입니다."

#: ../../extending/extending.rst:1135
msgid "Writing Extensions in C++"
msgstr "C++로 확장 작성하기"

#: ../../extending/extending.rst:1137
#, python-brace-format
msgid ""
"It is possible to write extension modules in C++.  Some restrictions "
"apply.  If the main program (the Python interpreter) is compiled and "
"linked by the C compiler, global or static objects with constructors "
"cannot be used.  This is not a problem if the main program is linked by "
"the C++ compiler.  Functions that will be called by the Python "
"interpreter (in particular, module initialization functions) have to be "
"declared using ``extern \"C\"``. It is unnecessary to enclose the Python "
"header files in ``extern \"C\" {...}`` --- they use this form already if "
"the symbol ``__cplusplus`` is defined (all recent C++ compilers define "
"this symbol)."
msgstr ""
"C++로 확장 모듈을 작성할 수 있습니다. 일부 제한 사항이 적용됩니다. 메인 프로그램(파이썬 인터프리터)이 C 컴파일러로 "
"컴파일되고 링크되면, 생성자가 있는 전역이나 정적(static) 객체를 사용할 수 없습니다. 메인 프로그램이 C++ 컴파일러로 "
"링크된 경우에는 문제가 되지 않습니다. 파이썬 인터프리터가 호출할 함수(특히, 모듈 초기화 함수)는 ``extern "
"\"C\"``\\를 사용하여 선언해야 합니다. ``extern \"C\" {...}``\\로 파이썬 헤더 파일을 묶을 필요는 "
"없습니다 --- ``__cplusplus`` 기호가 정의되면 (모든 최신 C++ 컴파일러가 이 기호를 정의합니다) 이미 이 형식을 "
"사용합니다."

#: ../../extending/extending.rst:1151
msgid "Providing a C API for an Extension Module"
msgstr "확장 모듈을 위한 C API 제공하기"

#: ../../extending/extending.rst:1156
msgid ""
"Many extension modules just provide new functions and types to be used "
"from Python, but sometimes the code in an extension module can be useful "
"for other extension modules. For example, an extension module could "
"implement a type \"collection\" which works like lists without order. "
"Just like the standard Python list type has a C API which permits "
"extension modules to create and manipulate lists, this new collection "
"type should have a set of C functions for direct manipulation from other "
"extension modules."
msgstr ""
"많은 확장 모듈은 단지 파이썬에서 사용할 새로운 함수와 형을 제공하지만, 때로 확장 모듈의 코드가 다른 확장 모듈에 유용할 수 "
"있습니다. 예를 들어, 확장 모듈은 순서 없는 리스트처럼 작동하는 \"컬렉션\" 형을 구현할 수 있습니다. 표준 파이썬 리스트 형에"
" 확장 모듈이 리스트를 만들고 조작할 수 있게 하는 C API가 있는 것처럼, 이 새로운 컬렉션 형에는 다른 확장 모듈에서 직접 "
"조작할 수 있는 C 함수 집합이 있어야 합니다."

#: ../../extending/extending.rst:1164
msgid ""
"At first sight this seems easy: just write the functions (without "
"declaring them ``static``, of course), provide an appropriate header "
"file, and document the C API. And in fact this would work if all "
"extension modules were always linked statically with the Python "
"interpreter. When modules are used as shared libraries, however, the "
"symbols defined in one module may not be visible to another module. The "
"details of visibility depend on the operating system; some systems use "
"one global namespace for the Python interpreter and all extension modules"
" (Windows, for example), whereas others require an explicit list of "
"imported symbols at module link time (AIX is one example), or offer a "
"choice of different strategies (most Unices). And even if symbols are "
"globally visible, the module whose functions one wishes to call might not"
" have been loaded yet!"
msgstr ""
"첫눈에 이것은 쉬운 것처럼 보입니다; 단지 함수를 작성하고 (물론 ``static``\\을 선언하지 않고), 적절한 헤더 파일을 "
"제공하고, C API를 설명합니다. 사실 이것은 모든 확장 모듈이 항상 파이썬 인터프리터와 정적으로 링크되어 있다면 작동합니다. "
"그러나 모듈을 공유 라이브러리로 사용하면, 한 모듈에 정의된 기호가 다른 모듈에서 보이지 않을 수 있습니다. 가시성의 세부 사항은 "
"운영 체제에 따라 다릅니다; 어떤 시스템은 파이썬 인터프리터와 모든 확장 모듈에 하나의 전역 이름 공간을 사용하는 반면 (예를 들어"
" 윈도우), 다른 시스템은 모듈 링크 시점에 임포트 되는 기호의 목록을 명시적으로 요구하거나 (AIX가 하나의 예입니다), 여러 "
"전략 중 선택할 수 있도록 합니다 (대부분의 유닉스). 또한 기호가 전역적으로 보이더라도, 호출하려는 함수를 가진 모듈이 아직 "
"로드되지 않았을 수 있습니다!"

#: ../../extending/extending.rst:1176
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in"
" section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different "
"way."
msgstr ""
"따라서 이식성에는 기호 가시성에 대해 가정하지 않을 것이 요구됩니다. 이것은 다른 확장 모듈과의 이름 충돌을 피하고자, 모듈의 "
"초기화 함수를 제외한 확장 모듈의 모든 기호를 ``static``\\으로 선언해야 함을 의미합니다 (섹션 "
":ref:`methodtable`\\에서 설명되듯이). 그리고 이는 다른 확장 모듈에서 액세스 *해야만* 하는 기호를 다른 방식으로"
" 노출해야 함을 의미합니다."

#: ../../extending/extending.rst:1183
#, fuzzy
msgid ""
"Python provides a special mechanism to pass C-level information "
"(pointers) from one extension module to another one: Capsules. A Capsule "
"is a Python data type which stores a pointer (:c:expr:`void \\*`).  "
"Capsules can only be created and accessed via their C API, but they can "
"be passed around like any other Python object. In particular,  they can "
"be assigned to a name in an extension module's namespace. Other extension"
" modules can then import this module, retrieve the value of this name, "
"and then retrieve the pointer from the Capsule."
msgstr ""
"파이썬은 한 확장 모듈에서 다른 확장 모듈로 C 수준 정보(포인터)를 전달하는 특별한 메커니즘을 제공합니다: 캡슐(Capsule)."
" 캡슐은 포인터(:c:type:`void \\*`)를 저장하는 파이썬 데이터형입니다. 캡슐은 C API를 통해서만 만들고 액세스할 "
"수 있지만, 다른 파이썬 객체처럼 전달할 수 있습니다. 특히, 확장 모듈의 이름 공간에서 이름에 대입할 수 있습니다. 다른 확장 "
"모듈은 이 모듈을 임포트 해서, 이 이름의 값을 가져온 다음, 캡슐에서 포인터를 가져올 수 있습니다."

#: ../../extending/extending.rst:1191
msgid ""
"There are many ways in which Capsules can be used to export the C API of "
"an extension module. Each function could get its own Capsule, or all C "
"API pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can"
" be distributed in different ways between the module providing the code "
"and the client modules."
msgstr ""
"확장 모듈의 C API를 노출하는 데 캡슐을 사용하는 방법에는 여러 가지가 있습니다. 각 함수가 자신만의 캡슐을 얻거나, 모든 C "
"API 포인터가 저장된 배열의 주소를 캡슐로 게시할 수 있습니다. 그리고 포인터를 저장하고 꺼내는 다양한 작업은 코드를 제공하는 "
"모듈과 클라이언트 모듈 간에 여러 방식으로 분산될 수 있습니다."

#: ../../extending/extending.rst:1197
#, fuzzy
msgid ""
"Whichever method you choose, it's important to name your Capsules "
"properly. The function :c:func:`PyCapsule_New` takes a name parameter "
"(:c:expr:`const char \\*`); you're permitted to pass in a ``NULL`` name, "
"but we strongly encourage you to specify a name.  Properly named Capsules"
" provide a degree of runtime type-safety; there is no feasible way to "
"tell one unnamed Capsule from another."
msgstr ""
"어떤 방법을 선택하든, 캡슐 이름을 올바르게 지정하는 것이 중요합니다. :c:func:`PyCapsule_New` 함수는 name "
"매개 변수(:c:type:`const char \\*`)를 취합니다; ``NULL`` name을 전달할 수는 있지만, 이름을 "
"지정하도록 강력히 권고합니다. 적절하게 이름 붙인 캡슐은 어느 정도의 실행 시간 형 안전성을 제공합니다; 하나의 이름 없는 캡슐을 "
"다른 캡슐과 구별할 수 있는 적절한 방법은 없습니다."

#: ../../extending/extending.rst:1204
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr "특히, C API를 공개하는 데 사용되는 캡슐에는 다음 규칙에 따라 이름을 지정해야 합니다::"

#: ../../extending/extending.rst:1207
msgid "modulename.attributename"
msgstr ""

#: ../../extending/extending.rst:1209
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load"
" a C API provided via a Capsule, but only if the Capsule's name matches "
"this convention.  This behavior gives C API users a high degree of "
"certainty that the Capsule they load contains the correct C API."
msgstr ""
"편의 함수 :c:func:`PyCapsule_Import`\\를 사용하면 캡슐을 통해 제공된 C API를 쉽게 로드 할 수 있지만,"
" 캡슐 이름이 이 규칙과 일치할 때만 그렇습니다. 이 동작은 C API 사용자에게 자신이 로드 한 캡슐에 올바른 C API가 "
"포함되어 있다는 확신을 줍니다."

#: ../../extending/extending.rst:1214
#, fuzzy
msgid ""
"The following example demonstrates an approach that puts most of the "
"burden on the writer of the exporting module, which is appropriate for "
"commonly used library modules. It stores all C API pointers (just one in "
"the example!) in an array of :c:expr:`void` pointers which becomes the "
"value of a Capsule. The header file corresponding to the module provides "
"a macro that takes care of importing the module and retrieving its C API "
"pointers; client modules only have to call this macro before accessing "
"the C API."
msgstr ""
"다음 예제는 대부분의 부담을 내보내는 모듈의 작성자에게 주는 방식을 보여주는데, 일반적으로 사용되는 라이브러리 모듈에 적합합니다. "
"캡슐의 값이 되는 :c:type:`void` 포인터의 배열에 모든 C API 포인터(이 예에서는 하나뿐입니다!)를 저장합니다. "
"모듈에 해당하는 헤더 파일은 모듈을 임포트 하고 C API 포인터를 가져오는 매크로를 제공합니다; 클라이언트 모듈은 C API에 "
"액세스하기 전에 이 매크로를 호출하기만 하면 됩니다."

#: ../../extending/extending.rst:1222
#, fuzzy
msgid ""
"The exporting module is a modification of the :mod:`!spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`!spam.system`"
" does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`!PySpam_System`, which would of course do something "
"more complicated in reality (such as adding \"spam\" to every command). "
"This function :c:func:`!PySpam_System` is also exported to other "
"extension modules."
msgstr ""
"내보내는 모듈은 섹션 :ref:`extending-simpleexample`\\의 :mod:`spam` 모듈을 수정한 것입니다. "
":func:`spam.system` 함수는 C 라이브러리 함수 :c:func:`system`\\을 직접 호출하지는 않고, 실제로는 "
"더 복잡한 작업을 수행하는 (가령 모든 명령에 \"spam\"을 추가하는 것과 같은) :c:func:`PySpam_System` "
"함수를 호출합니다. 이 함수 :c:func:`PySpam_System`\\도 다른 확장 모듈로 내보냅니다."

#: ../../extending/extending.rst:1229
#, fuzzy
msgid ""
"The function :c:func:`!PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ""
"함수 :c:func:`PySpam_System`\\은 평범한 C 함수이며, 다른 모든 것과 같이 ``static``\\으로 "
"선언되었습니다::"

#: ../../extending/extending.rst:1232
#, python-brace-format
msgid ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1238
#, fuzzy
msgid "The function :c:func:`!spam_system` is modified in a trivial way::"
msgstr ":c:func:`spam_system` 함수는 사소하게 수정됩니다::"

#: ../../extending/extending.rst:1240
msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1252
msgid "In the beginning of the module, right after the line ::"
msgstr "모듈의 시작 부분에서, 다음 줄 바로 다음에 ::"

#: ../../extending/extending.rst:1254
msgid "#include <Python.h>"
msgstr ""

#: ../../extending/extending.rst:1256
msgid "two more lines must be added::"
msgstr "다음 두 줄을 더 추가해야 합니다::"

#: ../../extending/extending.rst:1258
msgid ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""
msgstr ""

#: ../../extending/extending.rst:1261
msgid ""
"The ``#define`` is used to tell the header file that it is being included"
" in the exporting module, not a client module. Finally, the module's "
"initialization function must take care of initializing the C API pointer "
"array::"
msgstr ""
"``#define``\\은 헤더 파일이 클라이언트 모듈이 아닌 내보내는 모듈에 포함됨을 알리는 데 사용됩니다. 마지막으로, 모듈의 "
"초기화 함수는 C API 포인터 배열을 초기화해야 합니다::"

#: ../../extending/extending.rst:1265
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    PyObject *m;\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    m = PyModule_Create(&spammodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    /* Initialize the C API pointer array */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Create a Capsule containing the API pointer array's address */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", "
"NULL);\n"
"\n"
"    if (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1290
#, fuzzy
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer "
"array would disappear when :c:func:`!PyInit_spam` terminates!"
msgstr ""
"``PySpam_API``\\는 ``static``\\으로 선언됩니다; 그렇지 않으면 :func:`PyInit_spam`\\이 "
"종료할 때 포인터 배열이 사라집니다!"

#: ../../extending/extending.rst:1293
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which "
"looks like this::"
msgstr "작업 대부분은 헤더 파일 :file:`spammodule.h`\\에 있으며, 다음과 같습니다::"

#: ../../extending/extending.rst:1296
msgid ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Header file for spammodule */\n"
"\n"
"/* C API functions */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* Total number of C API pointers */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* This section is used when compiling spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* This section is used in modules that use spammodule's API */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) "
"PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Return -1 on error, 0 on success.\n"
" * PyCapsule_Import will set an exception if there's an error.\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"
msgstr ""

#: ../../extending/extending.rst:1344
#, fuzzy
msgid ""
"All that a client module must do in order to have access to the function "
":c:func:`!PySpam_System` is to call the function (or rather macro) "
":c:func:`!import_spam` in its initialization function::"
msgstr ""
":c:func:`PySpam_System` 함수에 액세스하기 위해 클라이언트 모듈이 해야 할 일은 초기화 함수에서 함수 (사실 "
"매크로) :c:func:`import_spam`\\을 호출하는 것이 전부입니다::"

#: ../../extending/extending.rst:1348
#, python-brace-format
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_client(void)\n"
"{\n"
"    PyObject *m;\n"
"\n"
"    m = PyModule_Create(&clientmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"    if (import_spam() < 0)\n"
"        return NULL;\n"
"    /* additional initialization can happen here */\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/extending.rst:1362
msgid ""
"The main disadvantage of this approach is that the file "
":file:`spammodule.h` is rather complicated. However, the basic structure "
"is the same for each function that is exported, so it has to be learned "
"only once."
msgstr ""
"이 방법의 주요 단점은 파일 :file:`spammodule.h`\\가 다소 복잡하다는 것입니다. 그러나, 기본 구조는 내보내는 "
"함수마다 같아서, 한 번만 학습하면 됩니다."

#: ../../extending/extending.rst:1366
msgid ""
"Finally it should be mentioned that Capsules offer additional "
"functionality, which is especially useful for memory allocation and "
"deallocation of the pointer stored in a Capsule. The details are "
"described in the Python/C API Reference Manual in the section "
":ref:`capsules` and in the implementation of Capsules (files "
":file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c` in the Python"
" source code distribution)."
msgstr ""
"마지막으로 캡슐은 추가 기능을 제공하며, 특히 캡슐에 저장된 포인터의 메모리 할당과 할당 해제에 유용합니다. 세부 사항은 파이썬/C"
" API 레퍼런스 매뉴얼의 :ref:`capsules` 섹션과 캡슐 구현(파이썬 소스 코드 배포의 "
":file:`Include/pycapsule.h`\\와 :file:`Objects/pycapsule.c` 파일)에 설명되어 "
"있습니다."

#: ../../extending/extending.rst:1374
msgid "Footnotes"
msgstr "각주"

#: ../../extending/extending.rst:1375
msgid ""
"An interface for this function already exists in the standard module "
":mod:`os` --- it was chosen as a simple and straightforward example."
msgstr "이 함수에 대한 인터페이스는 표준 모듈 :mod:`os`\\에 이미 존재합니다 --- 간단하고 단순한 예제로 선택되었습니다."

#: ../../extending/extending.rst:1378
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr "참조 \"빌리기(borrowing)\" 은유는 완전히 올바르지 않습니다: 소유자는 여전히 참조 사본을 가지고 있습니다."

#: ../../extending/extending.rst:1381
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the"
" reference count itself could be in freed memory and may thus be reused "
"for another object!"
msgstr ""
"참조 횟수가 1 이상인지 확인하는 것은 **작동하지 않습니다** --- 참조 횟수 자체가 해제된 메모리에 있을 수 있어서 다른 "
"객체에 재사용될 수 있습니다!"

#: ../../extending/extending.rst:1385
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr "\"오래된\" 스타일 호출 규칙을 사용할 때 이러한 보장은 유지되지 않습니다 --- 이것은 여전히 기존 코드에서 많이 발견됩니다."

#: ../../extending/extending.rst:550
msgid "PyObject_CallObject (C function)"
msgstr ""

#: ../../extending/extending.rst:641
msgid "PyArg_ParseTuple (C function)"
msgstr ""

#: ../../extending/extending.rst:733
#, fuzzy
msgid "PyArg_ParseTupleAndKeywords (C function)"
msgstr ":c:func:`PyArg_ParseTupleAndKeywords` 함수는 다음과 같이 선언됩니다::"

#: ../../extending/extending.rst:754
msgid "Philbrick, Geoff"
msgstr ""

#~ msgid ""
#~ "It is recommended to always define "
#~ "``PY_SSIZE_T_CLEAN`` before including ``Python.h``."
#~ "  See :ref:`parsetuple` for a description"
#~ " of this macro."
#~ msgstr ""
#~ "``Python.h``\\를 포함하기 전에 항상 "
#~ "``PY_SSIZE_T_CLEAN``\\을 정의하는 것이 좋습니다. 이 "
#~ "매크로에 대한 설명은 :ref:`parsetuple`\\를 참조하십시오."

#~ msgid ""
#~ "The cycle detector is able to "
#~ "detect garbage cycles and can reclaim"
#~ " them. The :mod:`gc` module exposes a"
#~ " way to run the detector (the "
#~ ":func:`~gc.collect` function), as well as "
#~ "configuration interfaces and the ability "
#~ "to disable the detector at runtime.  "
#~ "The cycle detector is considered an "
#~ "optional component; though it is "
#~ "included by default, it can be "
#~ "disabled at build time using the "
#~ ":option:`!--without-cycle-gc` option to "
#~ "the :program:`configure` script on Unix "
#~ "platforms (including Mac OS X).  If "
#~ "the cycle detector is disabled in "
#~ "this way, the :mod:`gc` module will "
#~ "not be available."
#~ msgstr ""
#~ "순환 검출기는 가비지 순환을 감지하고 이를 재활용할 "
#~ "수 있습니다. :mod:`gc` 모듈은 구성 인터페이스와 실행"
#~ " 시간에 탐지기를 비활성화하는 기능뿐만 아니라 탐지기를 "
#~ "실행하는 방법(:func:`~gc.collect` 함수)을 제공합니다. 순환 "
#~ "검출기는 선택적 구성 요소로 간주합니다; 기본적으로 포함되어"
#~ " 있지만, 유닉스 플랫폼(맥 OS X 포함)의 "
#~ ":program:`configure` 스크립트에 :option:`!--without-"
#~ "cycle-gc` 옵션을 사용하여 빌드 시 비활성화 할"
#~ " 수 있습니다. 이런 방식으로 순환 탐지기를 비활성화하면"
#~ " :mod:`gc` 모듈을 사용할 수 없습니다."

