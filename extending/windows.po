# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "윈도우에서 C와 C++ 확장 빌드하기"

#: ../../extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module "
"for Python using Microsoft Visual C++, and follows with more detailed "
"background information on how it works.  The explanatory material is "
"useful for both the Windows programmer learning to build Python "
"extensions and the Unix programmer interested in producing software which"
" can be successfully built on both Unix and Windows."
msgstr ""
"이 장에서는 Microsoft Visual C++를 사용하여 파이썬 용 윈도우 확장 모듈을 만드는 방법을 간략히 설명하고, 이 확장"
" 모듈의 작동 방식에 대한 보다 자세한 배경 정보를 제공합니다. 설명 자료는 파이썬 확장을 빌드하는 법을 배우는 윈도우 프로그래머와"
" 유닉스와 윈도우 모두에서 성공적으로 빌드 할 수 있는 소프트웨어 제작에 관심이 있는 유닉스 프로그래머 모두에게 유용합니다."

#: ../../extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will"
" still need the C compiler that was used to build Python; typically "
"Microsoft Visual C++."
msgstr ""
"모듈 저자는 확장 모듈을 빌드하는데 이 섹션에서 설명하는 것 대신 distutils 접근 방식을 사용하는 것이 좋습니다. 파이썬을 "
"빌드하는 데 사용된 C 컴파일러가 여전히 필요합니다; 보통 Microsoft Visual C++입니다."

#: ../../extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded "
"Python version number.  These filenames are represented with the version "
"number shown as ``XY``; in practice, ``'X'`` will be the major version "
"number and ``'Y'`` will be the minor version number of the Python release"
" you're working with.  For example, if you are using Python 2.2.1, ``XY``"
" will actually be ``22``."
msgstr ""
"이 장에서는 인코딩된 파이썬 버전 번호를 포함하는 여러 파일 이름을 언급합니다. 이 파일 이름은 ``XY``\\로 나타낸 버전 "
"번호로 표시됩니다; 실제로, ``'X'``\\는 주(major) 버전 번호이고 ``'Y'``\\는 여러분이 작업 중인 파이썬 배포의"
" 부(minor) 버전 번호입니다. 예를 들어, 파이썬 2.2.1을 사용하면, ``XY``\\는 실제로는 ``22``\\가 됩니다."

#: ../../extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "요리책 접근법"

#: ../../extending/windows.rst:36
msgid ""
"There are two approaches to building extension modules on Windows, just "
"as there are on Unix: use the ``setuptools`` package to control the build"
" process, or do things manually.  The setuptools approach works well for "
"most extensions; documentation on using ``setuptools`` to build and "
"package extension modules is available in :ref:`setuptools-index`.  If "
"you find you really need to do things manually, it may be instructive to "
"study the project file for the :source:`winsound "
"<PCbuild/winsound.vcxproj>` standard library module."
msgstr ""
"유닉스에서처럼, 윈도우에서 확장 모듈을 빌드하는 두 가지 접근법이 있습니다: ``setuptools`` 패키지를 사용하여 빌드 "
"프로세스를 제어하거나 수동으로 작업합니다. setuptools 접근법은 대부분 확장에서 잘 작동합니다; "
"``setuptools``\\를 사용하여 확장 모듈을 빌드하고 패키징하는 방법에 대한 설명은 :ref:`setuptools-"
"index`\\에 있습니다. 수동으로 작업할 수밖에 없다면, :source:`winsound "
"<PCbuild/winsound.vcxproj>` 표준 라이브러리 모듈의 프로젝트 파일을 연구하는 것이 도움이 될 겁니다."

#: ../../extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "유닉스와 윈도우의 차이점"

#: ../../extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading "
"of code.  Before you try to build a module that can be dynamically "
"loaded, be aware of how your system works."
msgstr ""
"유닉스와 윈도우는 코드의 실행시간 로딩에 완전히 다른 패러다임을 사용합니다. 동적으로 로드 할 수 있는 모듈을 빌드하려고 시도하기 "
"전에, 시스템 작동 방식을 알고 있어야 합니다."

#: ../../extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by "
"the program, and also the names of functions and data that it expects to "
"find in the program.  When the file is joined to the program, all "
"references to those functions and data in the file's code are changed to "
"point to the actual locations in the program where the functions and data"
" are placed in memory. This is basically a link operation."
msgstr ""
"유닉스에서, 공유 오브젝트 (:file:`.so`) 파일은 프로그램에서 사용할 코드와 프로그램에서 찾을 것으로 예상되는 함수와 "
"데이터의 이름을 포함합니다. 파일이 프로그램에 결합할 때, 파일의 코드에 있는 함수와 데이터의 모든 참조가 함수와 데이터가 메모리에"
" 놓이게 되는 프로그램에서의 실제 위치를 가리키도록 변경됩니다. 이것은 기본적으로 링크 작업입니다."

#: ../../extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a "
"lookup table.  So the DLL code does not have to be fixed up at runtime to"
" refer to the program's memory; instead, the code already uses the DLL's "
"lookup table, and the lookup table is modified at runtime to point to the"
" functions and data."
msgstr ""
"윈도우에서, 동적 연결 라이브러리 (:file:`.dll`) 파일에는 매달린(dangling) 참조가 없습니다. 대신, 함수나 "
"데이터에 대한 액세스는 참조 테이블(lookup table)을 통해 이루어집니다. 따라서 DLL 코드는 프로그램의 메모리를 "
"참조하도록 실행 시간에 수정될 필요가 없습니다; 대신, 코드는 이미 DLL의 참조 테이블을 사용하고 있고, 실행 시간에 참조 "
"테이블이 함수와 데이터를 가리 키도록 수정됩니다."

#: ../../extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which "
"contains code from several object files (:file:`.o`).  During the link "
"step to create a shared object file (:file:`.so`), the linker may find "
"that it doesn't know where an identifier is defined.  The linker will "
"look for it in the object files in the libraries; if it finds it, it will"
" include all the code from that object file."
msgstr ""
"유닉스에는, 한가지 유형의 라이브러리 파일(:file:`.a`) 만 있는데, 여러 오브젝트 파일(:file:`.o`)의 코드가 "
"포함됩니다. 공유 오브젝트 파일(:file:`.so`)을 만들기 위한 링크 단계에서, 링커는 식별자가 정의된 위치를 알 수 없음을 "
"발견할 수 있습니다. 링커는 라이브러리의 오브젝트 파일에서 그것들을 찾습니다. 발견하면, 그 오브젝트 파일의 모든 코드를 "
"포함합니다."

#: ../../extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an "
"import library (both called :file:`.lib`).  A static library is like a "
"Unix :file:`.a` file; it contains code to be included as necessary. An "
"import library is basically used only to reassure the linker that a "
"certain identifier is legal, and will be present in the program when the "
"DLL is loaded.  So the linker uses the information from the import "
"library to build the lookup table for using identifiers that are not "
"included in the DLL.  When an application or a DLL is linked, an import "
"library may be generated, which will need to be used for all future DLLs "
"that depend on the symbols in the application or DLL."
msgstr ""
"윈도우에는, 두 가지 유형의 라이브러리, 정적 라이브러리와 임포트 라이브러리가 있습니다 (둘 다 :file:`.lib`\\라고 "
"합니다). 정적 라이브러리는 유닉스 :file:`.a` 파일과 같습니다; 필요할 때 포함될 코드가 들어 있습니다. 임포트 "
"라이브러리는 기본적으로 특정 식별자가 합법적이고 DLL이 로드될 때 프로그램에 존재하게 된다고 링커를 안심시키기 위해서만 "
"사용됩니다. 따라서 링커는 임포트 라이브러리의 정보를 사용하여 DLL에 포함되지 않은 식별자를 사용하는 참조 테이블을 작성합니다. "
"응용 프로그램이나 DLL이 링크될 때, 임포트 라이브러리가 만들어질 수 있습니다. 이것은 응용 프로그램이나 DLL의 심볼을 "
"사용하는, 이후의 모든 DLL에 사용해야 합니다."

#: ../../extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a`"
" to the linker for :file:`B.so` and :file:`C.so`; that would cause it to "
"be included twice, so that B and C would each have their own copy.  In "
"Windows, building :file:`A.dll` will also build :file:`A.lib`.  You *do* "
"pass :file:`A.lib` to the linker for B and C.  :file:`A.lib` does not "
"contain code; it just contains information which will be used at runtime "
"to access A's code."
msgstr ""
"다른 코드 블록 A를 공유해야 하는, 두 개의 동적 로드 모듈 B와 C를 빌드한다고 가정합니다. 유닉스에서는, "
":file:`B.so`\\와 :file:`C.so`\\에 대해 링커로 :file:`A.a`\\를 전달하지 *않습니다*; 전달하면 "
"B와 C가 각각 자신의 복사본을 갖게 되어 두 번 포함하게 됩니다. 윈도우에서는, :file:`A.dll`\\를 빌드하면 "
":file:`A.lib`\\도 빌드됩니다. 여러분은 B와 C에 대헤 링커로 :file:`A.lib`\\를 전달 *합니다*. "
":file:`A.lib`\\는 코드를 포함하지 않습니다; 실행 시간에 A의 코드에 액세스하는 데 사용될 정보만 포함합니다."

#: ../../extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import "
"spam``; it gives you access to spam's names, but does not create a "
"separate copy.  On Unix, linking with a library is more like ``from spam "
"import *``; it does create a separate copy."
msgstr ""
"윈도우에서, 임포트 라이브러리를 사용하는 것은 ``import spam``\\을 사용하는 것과 비슷합니다; 이것은 스팸의 이름에 "
"액세스할 수 있도록 하지만, 별도의 복사본을 만들지는 않습니다. 유닉스에서, 라이브러리와 링크하는 것은 ``from spam "
"import *``\\와 더 비슷합니다; 별도의 복사본을 만듭니다."

#: ../../extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr "DLL을 실제로 사용하기"

#: ../../extending/windows.rst:108
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers "
"may or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"윈도우 파이썬은 Microsoft Visual C++로 빌드되었습니다; 다른 컴파일러를 사용하는 것은 동작할 수도 있고 그렇지 않을"
" 수도 있습니다. 이 섹션의 나머지 부분은 MSVC++에만 해당합니다."

#: ../../extending/windows.rst:111
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"윈도우에서 DLL을 만들 때, :file:`pythonXY.lib`\\를 링커에 전달해야 합니다. 두 개의 DLL, spam과 "
"(spam에 있는 C 함수를 사용하는) ni를 빌드하려면, 다음 명령을 사용할 수 있습니다::"

#: ../../extending/windows.rst:115
msgid ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"
msgstr ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"

#: ../../extending/windows.rst:118
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll`"
" and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to "
"find the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"첫 번째 명령은 세 개의 파일을 만들었습니다: :file:`spam.obj`, :file:`spam.dll` 및 "
":file:`spam.lib`. :file:`Spam.dll`\\은 파이썬 함수(가령 "
":c:func:`PyArg_ParseTuple`)를 포함하지 않지만, :file:`pythonXY.lib` 덕분에 파이썬 코드를 "
"찾는 방법을 알고 있습니다."

#: ../../extending/windows.rst:123
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and "
":file:`.lib`), which knows how to find the necessary functions from spam,"
" and also from the Python executable."
msgstr ""
"두 번째 명령은 :file:`ni.dll`\\(그리고 :file:`.obj`\\와 :file:`.lib`)을 만들었습니다. "
"spam과 파이썬 실행 파일에서 필요한 함수를 찾는 방법을 알고 있습니다."

#: ../../extending/windows.rst:127
msgid ""
"Not every identifier is exported to the lookup table.  If you want any "
"other modules (including Python) to be able to see your identifiers, you "
"have to say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) "
"*NiGetSpamData(void)``."
msgstr ""
"모든 식별자를 참조 테이블로 내보내지는 않습니다. 다른 모듈(파이썬 포함)이 식별자를 볼 수 있게 하려면, ``void "
"_declspec(dllexport) initspam(void)``\\나 ``PyObject _declspec(dllexport) "
"*NiGetSpamData(void)``\\처럼 ``_declspec(dllexport)``\\라고 선언해야 합니다."

#: ../../extending/windows.rst:132
#, python-brace-format
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, "
"use the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrt{xx}.lib` to the list of "
"libraries."
msgstr ""
"Developer Studio는 실제로 필요하지 않은 많은 임포트 라이브러리를 던져넣어서 실행 파일에 약 100K를 추가합니다. "
"이것들을 제거하려면, 프로젝트 설정 대화 상자를 통해 *ignore default libraries*\\를 지정하십시오. 올바른 "
":file:`msvcrt{xx}.lib`\\를 라이브러리 목록에 추가하십시오."

