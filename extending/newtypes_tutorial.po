# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "확장형 정의하기: 자습서"

#: ../../extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that"
" can be manipulated from Python code, much like the built-in :class:`str`"
" and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before "
"you can get started.  This document is a gentle introduction to the "
"topic."
msgstr ""
"파이썬은 C 확장 모듈 작성자가 내장 :class:`str`\\과 :class:`list` 형과 마찬가지로 파이썬 코드에서 조작할 "
"수 있는 새로운 형을 정의할 수 있도록 합니다. 모든 확장형의 코드는 패턴을 따르지만, 시작하기 전에 이해해야 할 세부 사항이 "
"있습니다. 이 설명서는 주제에 대한 간단한 소개입니다."

#: ../../extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "기초"

#: ../../extending/newtypes_tutorial.rst:26
#, fuzzy
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type "
":c:expr:`PyObject*`, which serves as a \"base type\" for all Python "
"objects. The :c:type:`PyObject` structure itself only contains the "
"object's :term:`reference count` and a pointer to the object's \"type "
"object\". This is where the action is; the type object determines which "
"(C) functions get called by the interpreter when, for instance, an "
"attribute gets looked up on an object, a method called, or it is "
"multiplied by another object.  These C functions are called \"type "
"methods\"."
msgstr ""
":term:`CPython` 런타임은 모든 파이썬 객체를 :c:type:`PyObject\\*` 형의 변수로 간주하는데, 이는 모든"
" 파이썬 객체의 \"베이스형\" 역할을 합니다. :c:type:`PyObject` 구조체 자체는 객체의 :term:`참조 횟수 "
"<reference count>`\\와 객체의 \"형 객체\"에 대한 포인터만 포함합니다. 여기가 액션이 일어나는 곳입니다; 형 "
"객체는 예를 들어 객체에서 어트리뷰트를 조회하거나, 메서드를 호출하거나, 다른 객체와 곱할 때 인터프리터가 호출하는 (C) 함수를 "
"결정합니다. 이러한 C 함수를 \"형 메서드\"라고 합니다."

#: ../../extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr "따라서, 새 확장형을 정의하려면, 새 형 객체를 만들어야 합니다."

#: ../../extending/newtypes_tutorial.rst:38
#, fuzzy
msgid ""
"This sort of thing can only be explained by example, so here's a minimal,"
" but complete, module that defines a new type named :class:`!Custom` "
"inside a C extension module :mod:`!custom`:"
msgstr ""
"이런 종류의 것은 예제로만 설명할 수 있어서, 여기에 C 확장 모듈 :mod:`custom` 내에서 "
":class:`Custom`\\이라는 새 형을 정의하는 최소한이지만 완전한 모듈이 있습니다:"

#: ../../extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the "
":c:func:`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"여기에 표시하는 것은 *정적인(static)* 확장형을 정의하는 전통적인 방법입니다. 대부분의 용도에 적합해야 합니다. C API는"
" 또한 :c:func:`PyType_FromSpec` 함수를 사용하여 힙 할당 확장형을 정의 할 수 있습니다만, 이 자습서에서는 "
"다루지 않습니다."

#: ../../extending/newtypes_tutorial.rst:48
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    /* Type-specific fields go here. */\n"
"} CustomObject;\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr "이제는 한 번에 배워야 할 것이 많지만, 이전 장과 비슷해 보이기를 바랍니다. 이 파일은 세 가지를 정의합니다:"

#: ../../extending/newtypes_tutorial.rst:53
#, fuzzy
msgid ""
"What a :class:`!Custom` **object** contains: this is the ``CustomObject``"
" struct, which is allocated once for each :class:`!Custom` instance."
msgstr ""
":class:`Custom` **객체**\\에 포함된 것: ``CustomObject`` 구조체이며, 각 "
":class:`Custom` 인스턴스마다 한 번씩 할당됩니다."

#: ../../extending/newtypes_tutorial.rst:55
#, fuzzy
msgid ""
"How the :class:`!Custom` **type** behaves: this is the ``CustomType`` "
"struct, which defines a set of flags and function pointers that the "
"interpreter inspects when specific operations are requested."
msgstr ""
":class:`Custom` **형**\\의 작동 방식: ``CustomType`` 구조체이며, 특정 연산이 요청될 때 인터프리터가"
" 검사하는 플래그와 함수 포인터 집합을 정의합니다."

#: ../../extending/newtypes_tutorial.rst:58
#, fuzzy
msgid ""
"How to initialize the :mod:`!custom` module: this is the "
"``PyInit_custom`` function and the associated ``custommodule`` struct."
msgstr ""
":mod:`custom` 모듈을 초기화하는 방법: ``PyInit_custom`` 함수와 관련 ``custommodule`` "
"구조체입니다."

#: ../../extending/newtypes_tutorial.rst:61
msgid "The first bit is::"
msgstr "첫 번째 것은::"

#: ../../extending/newtypes_tutorial.rst:63
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} CustomObject;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:67
#, fuzzy
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is "
"mandatory at the start of each object struct and defines a field called "
"``ob_base`` of type :c:type:`PyObject`, containing a pointer to a type "
"object and a reference count (these can be accessed using the macros "
":c:macro:`Py_TYPE` and :c:macro:`Py_REFCNT` respectively).  The reason "
"for the macro is to abstract away the layout and to enable additional "
"fields in :ref:`debug builds <debug-build>`."
msgstr ""
"이것이 Custom 객체에 포함될 것입니다. ``PyObject_HEAD``\\는 각 객체 구조체의 시작 부분에 필수적으로 오는 "
"것이며, :c:type:`PyObject` 형의 ``ob_base``\\라는 필드를 정의하여, 형 객체에 대한 포인터와 참조 횟수를"
" 포함합니다 (이것들은 각각 매크로 :c:macro:`Py_TYPE`\\과 :c:macro:`Py_REFCNT`\\를 사용하여 "
"액세스 할 수 있습니다). 이것이 매크로인 이유는 배치(layout)를 추상화하고 디버그 빌드에서 추가 필드를 활성화하기 위한 "
"것입니다."

#: ../../extending/newtypes_tutorial.rst:76
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
":c:macro:`PyObject_HEAD` 매크로 뒤에는 세미콜론이 없습니다. 실수로 추가하는 것에 주의하십시오: 일부 컴파일러는"
" 불평할 것입니다."

#: ../../extending/newtypes_tutorial.rst:79
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"물론, 객체는 일반적으로 표준 ``PyObject_HEAD`` 관용구 외에 추가 데이터를 저장합니다; 예를 들어, 표준 파이썬 "
"floats에 대한 정의는 다음과 같습니다::"

#: ../../extending/newtypes_tutorial.rst:83
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    double ob_fval;\n"
"} PyFloatObject;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:88
msgid "The second bit is the definition of the type object. ::"
msgstr "두 번째 것은 형 객체의 정의입니다. ::"

#: ../../extending/newtypes_tutorial.rst:90
#, python-brace-format
msgid ""
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:101
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about "
"and also to avoid caring about the fields' declaration order."
msgstr ""
"신경 쓰지 않는 모든 :c:type:`PyTypeObject` 필드를 나열하지 않고 필드의 선언 순서를 신경 쓰지 않으려면, 위와 "
"같이 C99 스타일의 지명(designated) 초기화자를 사용하는 것이 좋습니다."

#: ../../extending/newtypes_tutorial.rst:105
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has "
"many more :ref:`fields <type-structs>` than the definition above.  The "
"remaining fields will be filled with zeros by the C compiler, and it's "
"common practice to not specify them explicitly unless you need them."
msgstr ""
":file:`object.h`\\에 있는 :c:type:`PyTypeObject`\\의 실제 정의는 위의 정의보다 더 많은 "
":ref:`필드 <type-structs>`\\를 갖습니다. 나머지 필드는 C 컴파일러에 의해 0으로 채워지며, 필요하지 않으면 "
"명시적으로 지정하지 않는 것이 일반적입니다."

#: ../../extending/newtypes_tutorial.rst:110
msgid "We're going to pick it apart, one field at a time::"
msgstr "한 번에 한 필드씩 따로 다루려고 합니다::"

#: ../../extending/newtypes_tutorial.rst:112
msgid ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:114
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr "이 줄은 위에서 언급한 ``ob_base`` 필드를 초기화하기 위한 필수 상용구입니다. ::"

#: ../../extending/newtypes_tutorial.rst:117
msgid ".tp_name = \"custom.Custom\","
msgstr ""

#: ../../extending/newtypes_tutorial.rst:119
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr "우리 형의 이름. 이것은 객체의 기본 텍스트 표현과 일부 에러 메시지에 나타납니다, 예를 들어:"

#: ../../extending/newtypes_tutorial.rst:122
msgid ""
">>> \"\" + custom.Custom()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: can only concatenate str (not \"custom.Custom\") to str"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:129
#, fuzzy
msgid ""
"Note that the name is a dotted name that includes both the module name "
"and the name of the type within the module. The module in this case is "
":mod:`!custom` and the type is :class:`!Custom`, so we set the type name "
"to :class:`!custom.Custom`. Using the real dotted import path is "
"important to make your type compatible with the :mod:`pydoc` and "
":mod:`pickle` modules. ::"
msgstr ""
"이름이 모듈 이름과 모듈 내 형의 이름을 모두 포함하는 점으로 구분된 이름임에 유의하십시오. 이 경우 모듈은 "
":mod:`custom`\\이고 형은 :class:`Custom`\\이라서, 형 이름을 "
":class:`custom.Custom`\\으로 설정합니다. 형이 :mod:`pydoc`\\과 :mod:`pickle` 모듈과 "
"호환되도록 하려면 실제 점으로 구분된 임포트 경로를 사용하는 것이 중요합니다. ::"

#: ../../extending/newtypes_tutorial.rst:135
msgid ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:138
#, fuzzy
msgid ""
"This is so that Python knows how much memory to allocate when creating "
"new :class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is"
" only used for variable-sized objects and should otherwise be zero."
msgstr ""
"이것은 새로운 :class:`Custom` 인스턴스를 만들 때 파이썬이 할당할 메모리양을 알 수 있도록 하기 위한 것입니다. "
":c:member:`~PyTypeObject.tp_itemsize`\\는 가변 크기 객체에만 사용되며 그렇지 않으면 0이어야 "
"합니다."

#: ../../extending/newtypes_tutorial.rst:144
#, fuzzy
msgid ""
"If you want your type to be subclassable from Python, and your type has "
"the same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may"
" have problems with multiple inheritance.  A Python subclass of your type"
" will have to list your type first in its :attr:`~type.__bases__`, or "
"else it will not be able to call your type's :meth:`~object.__new__` "
"method without getting an error.  You can avoid this problem by ensuring "
"that your type has a larger value for "
":c:member:`~PyTypeObject.tp_basicsize` than its base type does.  Most of "
"the time, this will be true anyway, because either your base type will be"
" :class:`object`, or else you will be adding data members to your base "
"type, and therefore increasing its size."
msgstr ""
"파이썬에서 형을 서브 클래싱 할 수 있기를 원하고, 형이 베이스형과 같은 "
":c:member:`~PyTypeObject.tp_basicsize`\\를 가지면, 다중 상속에 문제가 있을 수 있습니다. 형의 "
"파이썬 서브 클래스는 :attr:`~class.__bases__`\\에 이 형을 먼저 나열해야 합니다, 그렇지 않으면 에러 없이 "
"형의 :meth:`__new__` 메서드를 호출할 수 없습니다. 형이 베이스형보다 큰 "
":c:member:`~PyTypeObject.tp_basicsize` 값을 갖도록 하여 이 문제점을 피할 수 있습니다. 대부분의 "
"경우, 이것은 어쨌든 만족하는데, 베이스형이 :class:`object`\\이거나, 그렇지 않으면 베이스형에 데이터 멤버를 추가하여"
" 크기를 늘리기 때문입니다."

#: ../../extending/newtypes_tutorial.rst:154
#, fuzzy
msgid "We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "클래스 플래그를 :const:`Py_TPFLAGS_DEFAULT`\\로 설정합니다. ::"

#: ../../extending/newtypes_tutorial.rst:156
msgid ".tp_flags = Py_TPFLAGS_DEFAULT,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:158
msgid ""
"All types should include this constant in their flags.  It enables all of"
" the members defined until at least Python 3.3.  If you need further "
"members, you will need to OR the corresponding flags."
msgstr ""
"모든 형은 이 상수를 플래그에 포함해야 합니다. 적어도 파이썬 3.3까지 정의된 모든 멤버를 활성화합니다. 추가 멤버가 필요하면, "
"해당 플래그를 OR 해야 합니다."

#: ../../extending/newtypes_tutorial.rst:162
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`."
" ::"
msgstr ":c:member:`~PyTypeObject.tp_doc`\\에 형의 독스트링을 제공합니다. ::"

#: ../../extending/newtypes_tutorial.rst:164
msgid ".tp_doc = PyDoc_STR(\"Custom objects\"),"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:166
#, fuzzy
msgid ""
"To enable object creation, we have to provide a "
":c:member:`~PyTypeObject.tp_new` handler.  This is the equivalent of the "
"Python method :meth:`~object.__new__`, but has to be specified "
"explicitly.  In this case, we can just use the default implementation "
"provided by the API function :c:func:`PyType_GenericNew`. ::"
msgstr ""
"객체 생성을 가능하게 하려면, :c:member:`~PyTypeObject.tp_new` 처리기를 제공해야 합니다. 이것은 파이썬 "
"메서드 :meth:`__new__`\\와 동등하지만, 명시적으로 지정해야 합니다. 이 경우에는, API 함수 "
":c:func:`PyType_GenericNew`\\에서 제공하는 기본 구현을 그냥 사용할 수 있습니다. ::"

#: ../../extending/newtypes_tutorial.rst:171
msgid ".tp_new = PyType_GenericNew,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:173
#, fuzzy
msgid ""
"Everything else in the file should be familiar, except for some code in "
":c:func:`!PyInit_custom`::"
msgstr ":c:func:`PyInit_custom`\\의 일부 코드를 제외하고, 파일의 다른 모든 내용은 익숙해야 합니다::"

#: ../../extending/newtypes_tutorial.rst:176
msgid ""
"if (PyType_Ready(&CustomType) < 0)\n"
"    return;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:179
#, fuzzy
msgid ""
"This initializes the :class:`!Custom` type, filling in a number of "
"members to the appropriate default values, including "
":c:member:`~PyObject.ob_type` that we initially set to ``NULL``. ::"
msgstr ""
"이것은 :class:`Custom` 형을 초기화하는데, 처음에 ``NULL``\\로 설정한 :attr:`ob_type`\\을 "
"포함하여, 여러 멤버를 적절한 기본값으로 채웁니다. ::"

#: ../../extending/newtypes_tutorial.rst:183
#, python-brace-format
msgid ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {"
"\n"
"    Py_DECREF(m);\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:188
#, fuzzy
msgid ""
"This adds the type to the module dictionary.  This allows us to create "
":class:`!Custom` instances by calling the :class:`!Custom` class:"
msgstr ""
"이것은 형을 모듈 딕셔너리에 추가합니다. :class:`Custom` 클래스를 호출하여 :class:`Custom` 인스턴스를 만들"
" 수 있도록 합니다:"

#: ../../extending/newtypes_tutorial.rst:191
msgid ""
">>> import custom\n"
">>> mycustom = custom.Custom()"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:196
#, fuzzy
msgid ""
"That's it!  All that remains is to build it; put the above code in a file"
" called :file:`custom.c`,"
msgstr "이게 전부입니다! 남아있는 것은 빌드하는 것입니다; 위의 코드를 :file:`custom.c`\\라는 파일에 넣고:"

#: ../../extending/newtypes_tutorial.rst:199
msgid ""
"[build-system]\n"
"requires = [\"setuptools\"]\n"
"build-backend = \"setuptools.build_meta\"\n"
"\n"
"[project]\n"
"name = \"custom\"\n"
"version = \"1\"\n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:201
#, fuzzy
msgid "in a file called :file:`pyproject.toml`, and"
msgstr "를 :file:`setup.py`\\라는 파일에 넣은 다음; 다음을"

#: ../../extending/newtypes_tutorial.rst:203
msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:208
msgid "in a file called :file:`setup.py`; then typing"
msgstr "를 :file:`setup.py`\\라는 파일에 넣은 다음; 다음을"

#: ../../extending/newtypes_tutorial.rst:210
#: ../../extending/newtypes_tutorial.rst:525
msgid "$ python -m pip install ."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:214
#, fuzzy
msgid ""
"in a shell should produce a file :file:`custom.so` in a subdirectory and "
"install it; now fire up Python --- you should be able to ``import "
"custom`` and play around with ``Custom`` objects."
msgstr ""
"셸에서 입력하면 서브 디렉터리에 파일 :file:`custom.so`\\를 생성해야 합니다; 해당 디렉터리로 이동하여 파이썬을 "
"시작하십시오 --- ``import custom`` 할 수 있고 Custom 객체로 놀 수 있습니다."

#: ../../extending/newtypes_tutorial.rst:218
msgid "That wasn't so hard, was it?"
msgstr "그렇게 어렵지 않습니다, 그렇지 않나요?"

#: ../../extending/newtypes_tutorial.rst:220
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no "
"data and doesn't do anything. It can't even be subclassed."
msgstr "물론, 현재 Custom 형은 그리 흥미롭지 않습니다. 데이터가 없고 아무것도 하지 않습니다. 서브 클래싱조차 할 수 없습니다."

#: ../../extending/newtypes_tutorial.rst:225
msgid "Adding data and methods to the Basic example"
msgstr "기초 예제에 데이터와 메서드 추가하기"

#: ../../extending/newtypes_tutorial.rst:227
#, fuzzy
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, "
":mod:`!custom2` that adds these capabilities:"
msgstr ""
"데이터와 메서드를 추가하도록 기초 예제를 확장해 봅시다. 형을 베이스 클래스로도 사용할 수 있도록 합시다. 다음 기능을 추가하는 새"
" 모듈 :mod:`custom2`\\를 만들 것입니다:"

#: ../../extending/newtypes_tutorial.rst:231
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base =PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom2\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:234
msgid "This version of the module has a number of changes."
msgstr "이 버전의 모듈에는 여러 가지 변경 사항이 있습니다."

#: ../../extending/newtypes_tutorial.rst:236
#, fuzzy
msgid ""
"The  :class:`!Custom` type now has three data attributes in its C struct,"
" *first*, *last*, and *number*.  The *first* and *last* variables are "
"Python strings containing first and last names.  The *number* attribute "
"is a C integer."
msgstr ""
":class:`Custom` 형은 이제 C 구조체에 *first*, *last* 및 *number*\\의 세 가지 데이터 "
"어트리뷰트가 있습니다. *first*\\와 *last* 변수는 이름과 성을 포함하는 파이썬 문자열입니다. *number* "
"어트리뷰트는 C 정수입니다."

#: ../../extending/newtypes_tutorial.rst:240
msgid "The object structure is updated accordingly::"
msgstr "객체 구조체는 다음과 같이 갱신됩니다::"

#: ../../extending/newtypes_tutorial.rst:242
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:249
msgid ""
"Because we now have data to manage, we have to be more careful about "
"object allocation and deallocation.  At a minimum, we need a deallocation"
" method::"
msgstr "이제 관리할 데이터가 있기 때문에, 객체 할당과 할당 해제에 관해 더욱 신중해야 합니다. 최소한, 할당 해제 메서드가 필요합니다::"

#: ../../extending/newtypes_tutorial.rst:252
#, python-brace-format
msgid ""
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:260
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "이는 :c:member:`~PyTypeObject.tp_dealloc` 멤버에 대입됩니다::"

#: ../../extending/newtypes_tutorial.rst:262
msgid ".tp_dealloc = (destructor) Custom_dealloc,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:264
#, fuzzy
msgid ""
"This method first clears the reference counts of the two Python "
"attributes. :c:func:`Py_XDECREF` correctly handles the case where its "
"argument is ``NULL`` (which might happen here if ``tp_new`` failed "
"midway).  It then calls the :c:member:`~PyTypeObject.tp_free` member of "
"the object's type (computed by ``Py_TYPE(self)``) to free the object's "
"memory.  Note that the object's type might not be :class:`!CustomType`, "
"because the object may be an instance of a subclass."
msgstr ""
"이 메서드는 먼저 두 파이썬 어트리뷰트의 참조 횟수를 지웁니다. :c:func:`Py_XDECREF`\\는 인자가 "
"``NULL``\\인 경우(``tp_new``\\가 중간에 실패하면 발생할 수 있습니다)를 올바르게 처리합니다. 그런 다음 객체 "
"형(``Py_TYPE(self)``\\로 계산합니다)의 :c:member:`~PyTypeObject.tp_free` 멤버를 호출하여"
" 객체의 메모리를 해제합니다. 객체 형이 :class:`CustomType`\\이 아닐 수 있음에 유의하십시오, 객체는 서브 "
"클래스의 인스턴스일 수 있기 때문입니다."

#: ../../extending/newtypes_tutorial.rst:273
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""
"``CustomObject *`` 인자를 취하도록 ``Custom_dealloc``\\을 정의했지만, ``tp_dealloc`` "
"함수 포인터는 ``PyObject *`` 인자를 받을 것으로 기대하기 때문에 위의 ``destructor``\\로의 명시적 캐스트가"
" 필요합니다. 그렇지 않으면, 컴파일러에서 경고가 발생합니다. 이것이 C로 하는 객체 지향 다형성입니다!"

#: ../../extending/newtypes_tutorial.rst:279
msgid ""
"We want to make sure that the first and last names are initialized to "
"empty strings, so we provide a ``tp_new`` implementation::"
msgstr "우리는 성과 이름이 빈 문자열로 초기화되도록 하고 싶어서, ``tp_new`` 구현을 제공합니다::"

#: ../../extending/newtypes_tutorial.rst:282
msgid ""
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:303
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "그리고 그것을 :c:member:`~PyTypeObject.tp_new` 멤버에 설치합니다::"

#: ../../extending/newtypes_tutorial.rst:305
msgid ".tp_new = Custom_new,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:307
#, fuzzy
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the "
":meth:`~object.__new__` method. It is not required to define a ``tp_new``"
" member, and indeed many extension types will simply reuse "
":c:func:`PyType_GenericNew` as done in the first version of the "
":class:`!Custom` type above.  In this case, we use the ``tp_new`` handler"
" to initialize the ``first`` and ``last`` attributes to non-``NULL`` "
"default values."
msgstr ""
"``tp_new`` 처리기는 형의 객체를 (초기화와 대비하여) 생성하는 책임을 집니다. 파이썬에서 :meth:`__new__` "
"메서드로 노출됩니다. ``tp_new`` 멤버를 정의할 필요는 없으며, 실제로 많은 확장형은 위의 ``Custom`` 형의 첫 번째"
" 버전에서처럼 :c:func:`PyType_GenericNew`\\를 재사용하기만 합니다. 지금은, ``tp_new`` 처리기를 "
"사용하여 ``first``\\와 ``last`` 어트리뷰트를 ``NULL``\\이 아닌 기본값으로 초기화합니다."

#: ../../extending/newtypes_tutorial.rst:315
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed "
"when the type was called, and is expected to return the instance created."
"  ``tp_new`` handlers always accept positional and keyword arguments, but"
" they often ignore the arguments, leaving the argument handling to "
"initializer (a.k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new``\\는 인스턴스 화 되는 형(서브 클래스가 인스턴스 화 되면, 반드시 ``CustomType``\\일 필요는 "
"없습니다)과 형이 호출될 때 전달된 모든 인자가 전달되며, 만들어진 인스턴스를 반환할 것으로 기대됩니다. ``tp_new`` "
"처리기는 항상 위치와 키워드 인자를 받아들이지만, 종종 인자를 무시하고 인자 처리를 초기화 (C의 ``tp_init``\\나 "
"파이썬의 ``__init__``) 메서드에게 남겨둡니다."

#: ../../extending/newtypes_tutorial.rst:323
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will"
" do it itself."
msgstr "인터프리터가 직접 할 것이라서, ``tp_new``\\는 명시적으로 ``tp_init``\\를 호출하면 안 됩니다."

#: ../../extending/newtypes_tutorial.rst:326
msgid ""
"The ``tp_new`` implementation calls the "
":c:member:`~PyTypeObject.tp_alloc` slot to allocate memory::"
msgstr "``tp_new`` 구현은 :c:member:`~PyTypeObject.tp_alloc` 슬롯을 호출하여 메모리를 할당합니다::"

#: ../../extending/newtypes_tutorial.rst:329
msgid "self = (CustomObject *) type->tp_alloc(type, 0);"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:331
msgid ""
"Since memory allocation may fail, we must check the "
":c:member:`~PyTypeObject.tp_alloc` result against ``NULL`` before "
"proceeding."
msgstr ""
"메모리 할당이 실패할 수 있어서, 진행하기 전에 :c:member:`~PyTypeObject.tp_alloc` 결과가 "
"``NULL``\\이 아닌지 확인해야 합니다."

#: ../../extending/newtypes_tutorial.rst:335
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our "
"base class, which is :class:`object` by default.  Most types use the "
"default allocation strategy."
msgstr ""
"우리는 :c:member:`~PyTypeObject.tp_alloc` 슬롯을 직접 채우지 않았습니다. 대신 "
":c:func:`PyType_Ready`\\가 베이스 클래스(기본적으로 :class:`object`\\입니다)에서 상속하여 이를 "
"채웁니다. 대부분의 형은 기본 할당 전략을 사용합니다."

#: ../../extending/newtypes_tutorial.rst:341
#, fuzzy
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or "
":meth:`~object.__new__`), you must *not* try to determine what method to "
"call using method resolution order at runtime.  Always statically "
"determine what type you are going to call, and call its "
":c:member:`~PyTypeObject.tp_new` directly, or via "
"``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not "
"work correctly. (Specifically, you may not be able to create instances of"
" such subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"협업 :c:member:`~PyTypeObject.tp_new`\\(베이스형의 "
":c:member:`~PyTypeObject.tp_new`\\나 :meth:`__new__`\\를 호출하는 것)를 만드는 경우, "
"실행 시간에 메서드 결정 순서를 사용하여 호출할 메서드를 결정하려고 하지 *않아야* 합니다. 항상 어떤 형을 호출할지 정적으로 "
"결정하고, 그것의 :c:member:`~PyTypeObject.tp_new`\\를 직접, 또는 "
"``type->tp_base->tp_new``\\를 통해 호출하십시오. 이렇게 하지 않으면, 다른 파이썬 정의 클래스도 상속하는 "
"여러분 형의 파이썬 서브 클래스가 올바르게 작동하지 않을 수 있습니다. (특히, :exc:`TypeError`\\를 얻지 않으면서,"
" 이러한 서브 클래스의 인스턴스를 만들지 못할 수도 있습니다.)"

#: ../../extending/newtypes_tutorial.rst:351
msgid ""
"We also define an initialization function which accepts arguments to "
"provide initial values for our instance::"
msgstr "인스턴스의 초깃값을 제공하는 인자를 받아들이는 초기화 함수도 정의합니다::"

#: ../../extending/newtypes_tutorial.rst:354
msgid ""
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:380
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "이것으로 :c:member:`~PyTypeObject.tp_init` 슬롯을 채웁니다::"

#: ../../extending/newtypes_tutorial.rst:382
msgid ".tp_init = (initproc) Custom_init,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:384
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the "
":meth:`~object.__init__` method.  It is used to initialize an object "
"after it's created.  Initializers always accept positional and keyword "
"arguments, and they should return either ``0`` on success or ``-1`` on "
"error."
msgstr ""
":c:member:`~PyTypeObject.tp_init` 슬롯은 파이썬에서 :meth:`__init__` 메서드로 노출됩니다. "
"객체가 만들어진 후 초기화하는 데 사용됩니다. 초기화자는 항상 위치와 키워드 인자를 받아들이며 성공 시 ``0`` 또는 에러 시 "
"``-1``\\을 반환해야 합니다."

#: ../../extending/newtypes_tutorial.rst:389
#, fuzzy
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`~object.__init__` on unpickled instances).  It can also be "
"called multiple times.  Anyone can call the :meth:`!__init__` method on "
"our objects.  For this reason, we have to be extra careful when assigning"
" the new attribute values.  We might be tempted, for example to assign "
"the ``first`` member like this::"
msgstr ""
"``tp_new`` 처리기와 달리, ``tp_init``\\가 아예 호출되지 않을 수도 있습니다 (예를 들어, "
":mod:`pickle` 모듈은 기본적으로 역 피클 된 인스턴스에서 :meth:`__init__`\\를 호출하지 않습니다). 여러 "
"번 호출될 수도 있습니다. 누구나 우리 객체의 :meth:`__init__` 메서드를 호출할 수 있습니다. 이런 이유로, 새 "
"어트리뷰트 값을 대입할 때는 각별히 주의해야 합니다. 예를 들어 ``first`` 멤버를 다음과 같이 대입하려고 할 수 있습니다::"

#: ../../extending/newtypes_tutorial.rst:397
#, python-brace-format
msgid ""
"if (first) {\n"
"    Py_XDECREF(self->first);\n"
"    Py_INCREF(first);\n"
"    self->first = first;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:403
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock <GIL>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"하지만 이것은 위험합니다. 우리 형은 ``first`` 멤버의 형을 제한하지 않아서, 모든 종류의 객체가 될 수 있습니다. "
"``first`` 멤버에 액세스하려고 시도하는 코드가 실행되도록 하는 파괴자가 있을 수 있습니다; 또는 파괴자가 :term:`전역 "
"인터프리터 록 <GIL>`\\을 해제하고 다른 스레드에서 객체에 액세스하고 수정하는 임의의 코드가 실행되도록 할 수 있습니다."

#: ../../extending/newtypes_tutorial.rst:410
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When"
" don't we have to do this?"
msgstr ""
"편집증적이 되고 이 가능성으로부터 우리 자신을 보호하기 위해, 우리는 거의 항상 참조 횟수를 줄이기 전에 멤버를 다시 대입합니다. "
"언제 이렇게 하지 않아도 될까요?"

#: ../../extending/newtypes_tutorial.rst:414
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr "참조 횟수가 1보다 크다는 것을 확실히 알고 있을 때;"

#: ../../extending/newtypes_tutorial.rst:416
msgid ""
"when we know that deallocation of the object [#]_ will neither release "
"the :term:`GIL` nor cause any calls back into our type's code;"
msgstr "객체의 할당 해제가 :term:`GIL`\\을 해제하지도 않고 형의 코드를 다시 호출하지도 않음을 알고 있을 때 [#]_;"

#: ../../extending/newtypes_tutorial.rst:419
msgid ""
"when decrementing a reference count in a "
":c:member:`~PyTypeObject.tp_dealloc` handler on a type which doesn't "
"support cyclic garbage collection [#]_."
msgstr ""
"순환 가비지 수거를 지원하지 않는 형의 :c:member:`~PyTypeObject.tp_dealloc` 처리기에서 참조 횟수를 "
"감소시킬 때 [#]_."

#: ../../extending/newtypes_tutorial.rst:422
msgid ""
"We want to expose our instance variables as attributes. There are a "
"number of ways to do that. The simplest way is to define member "
"definitions::"
msgstr ""
"인스턴스 변수를 어트리뷰트로 노출하려고 합니다. 이를 수행하는 방법에는 여러 가지가 있습니다. 가장 간단한 방법은 멤버 정의를 "
"정의하는 것입니다::"

#: ../../extending/newtypes_tutorial.rst:425
msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:435
msgid "and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "그리고 :c:member:`~PyTypeObject.tp_members` 슬롯에 정의를 넣습니다::"

#: ../../extending/newtypes_tutorial.rst:437
msgid ".tp_members = Custom_members,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:439
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` "
"section below for details."
msgstr ""
"각 멤버 정의에는 멤버 이름, 형, 오프셋, 액세스 플래그 및 독스트링이 있습니다. 자세한 내용은 아래 :ref:`Generic-"
"Attribute-Management` 섹션을 참조하십시오."

#: ../../extending/newtypes_tutorial.rst:443
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to "
"restrict the types of objects that can be assigned to the Python "
"attributes.  We expect the first and last names to be strings, but any "
"Python objects can be assigned. Further, the attributes can be deleted, "
"setting the C pointers to ``NULL``.  Even though we can make sure the "
"members are initialized to non-``NULL`` values, the members can be set to"
" ``NULL`` if the attributes are deleted."
msgstr ""
"이 접근법의 단점은 파이썬 어트리뷰트에 대입할 수 있는 객체의 형을 제한할 방법을 제공하지 않는다는 것입니다. 이름과 성은 문자열일"
" 것으로 기대하지만, 모든 파이썬 객체를 할당할 수 있습니다. 또한 어트리뷰트를 삭제할 수 있습니다, C 포인터를 "
"``NULL``\\로 설정합니다. ``NULL``\\이 아닌 값으로 멤버를 초기화 할 수 있지만, 어트리뷰트를 삭제하면 멤버를 "
"``NULL``\\로 설정할 수 있습니다."

#: ../../extending/newtypes_tutorial.rst:450
#, fuzzy
msgid ""
"We define a single method, :meth:`!Custom.name`, that outputs the objects"
" name as the concatenation of the first and last names. ::"
msgstr "이름과 성을 이어붙여 객체 이름으로 출력하는 단일 메서드 :meth:`Custom.name()`\\을 정의합니다. ::"

#: ../../extending/newtypes_tutorial.rst:453
msgid ""
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:467
#, fuzzy
msgid ""
"The method is implemented as a C function that takes a :class:`!Custom` "
"(or :class:`!Custom` subclass) instance as the first argument.  Methods "
"always take an instance as the first argument. Methods often take "
"positional and keyword arguments as well, but in this case we don't take "
"any and don't need to accept a positional argument tuple or keyword "
"argument dictionary. This method is equivalent to the Python method:"
msgstr ""
"이 메서드는 :class:`Custom` (또는 :class:`Custom` 서브 클래스) 인스턴스를 첫 번째 인자로 취하는 C "
"함수로 구현됩니다. 메서드는 항상 인스턴스를 첫 번째 인자로 취합니다. 메서드는 종종 위치와 키워드 인자도 취하지만, 이 경우에는 "
"아무것도 취하지 않아서 위치 인자 튜플이나 키워드 인자 딕셔너리를 받아들일 필요 없습니다. 이 메서드는 다음과 같은 파이썬 메서드와"
" 동등합니다:"

#: ../../extending/newtypes_tutorial.rst:474
#, python-format
msgid ""
"def name(self):\n"
"    return \"%s %s\" % (self.first, self.last)"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:479
#, fuzzy
msgid ""
"Note that we have to check for the possibility that our :attr:`!first` "
"and :attr:`!last` members are ``NULL``.  This is because they can be "
"deleted, in which case they are set to ``NULL``.  It would be better to "
"prevent deletion of these attributes and to restrict the attribute values"
" to be strings.  We'll see how to do that in the next section."
msgstr ""
":attr:`first`\\와 :attr:`last` 멤버가 ``NULL``\\일 가능성을 확인해야 함에 유의하십시오. 삭제할 수 "
"있기 때문인데, 이때 ``NULL``\\로 설정됩니다. 이러한 어트리뷰트의 삭제를 방지하고 어트리뷰트 값을 문자열로 제한하는 것이 "
"더 좋습니다. 다음 섹션에서 이를 수행하는 방법을 살펴보겠습니다."

#: ../../extending/newtypes_tutorial.rst:485
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr "이제 메서드를 정의했습니다, 메서드 정의 배열을 만들어야 합니다::"

#: ../../extending/newtypes_tutorial.rst:488
msgid ""
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:495
#, fuzzy
msgid ""
"(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the "
"method is expecting no arguments other than *self*)"
msgstr ""
"(우리는 :const:`METH_NOARGS` 플래그를 사용하여 메서드가 *self* 이외의 인자를 기대하지 않음을 나타냈음에 "
"유의하십시오)"

#: ../../extending/newtypes_tutorial.rst:498
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "그리고 :c:member:`~PyTypeObject.tp_methods` 슬롯에 대입합니다::"

#: ../../extending/newtypes_tutorial.rst:500
msgid ".tp_methods = Custom_methods,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:502
#, fuzzy
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  "
"We've written our methods carefully so far so that they don't make any "
"assumptions about the type of the object being created or used, so all we"
" need to do is to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class "
"flag definition::"
msgstr ""
"마지막으로, 우리의 형을 서브 클래싱의 베이스 클래스로 사용할 수 있게 만들 것입니다. 우리는 지금까지 만들어지거나 사용되고 있는 "
"객체의 형에 대해 가정을 하지 않도록 메서드를 주의해서 작성했습니다, 그래서 클래스 플래그 정의에 "
":const:`Py_TPFLAGS_BASETYPE`\\을 추가하기만 하면 됩니다. ::"

#: ../../extending/newtypes_tutorial.rst:507
msgid ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:509
#, fuzzy
msgid ""
"We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update "
"the module name in the :c:type:`PyModuleDef` struct, and update the full "
"class name in the :c:type:`PyTypeObject` struct."
msgstr ""
":c:func:`PyInit_custom`\\의 이름을 :c:func:`PyInit_custom2`\\로 바꾸고, "
":c:type:`PyModuleDef` 구조체에서 모듈 이름을 갱신하고, :c:type:`PyTypeObject` 구조체에서 전체 "
"클래스 이름을 갱신합니다."

#: ../../extending/newtypes_tutorial.rst:513
#, fuzzy
msgid "Finally, we update our :file:`setup.py` file to include the new module,"
msgstr "마지막으로, 새 모듈을 빌드하기 위해 :file:`setup.py` 파일을 갱신합니다:"

#: ../../extending/newtypes_tutorial.rst:515
msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[\n"
"    Extension(\"custom\", [\"custom.c\"]),\n"
"    Extension(\"custom2\", [\"custom2.c\"]),\n"
"])"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:523
msgid "and then we re-install so that we can ``import custom2``:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:530
msgid "Providing finer control over data attributes"
msgstr "데이터 어트리뷰트를 더 세밀하게 제어하기"

#: ../../extending/newtypes_tutorial.rst:532
#, fuzzy
msgid ""
"In this section, we'll provide finer control over how the :attr:`!first` "
"and :attr:`!last` attributes are set in the :class:`!Custom` example. In "
"the previous version of our module, the instance variables :attr:`!first`"
" and :attr:`!last` could be set to non-string values or even deleted. We "
"want to make sure that these attributes always contain strings."
msgstr ""
"이 섹션에서는, :class:`Custom` 예제에서 :attr:`first`\\와 :attr:`last` 어트리뷰트가 설정되는 "
"방식을 더 세밀하게 제어합니다. 이전 버전의 모듈에서는, 인스턴스 변수 :attr:`first`\\와 :attr:`last`\\를 "
"문자열이 아닌 값으로 설정하거나 삭제할 수도 있습니다. 이 어트리뷰트들에 항상 문자열이 포함되도록 하고 싶습니다."

#: ../../extending/newtypes_tutorial.rst:538
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom3\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:541
#, fuzzy
msgid ""
"To provide greater control, over the :attr:`!first` and :attr:`!last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`!first` attribute::"
msgstr ""
":attr:`first`\\와 :attr:`last` 어트리뷰트를 더 효과적으로 제어하기 위해, 사용자 정의 게터(getter)와 "
"세터(setter) 함수를 사용합니다. :attr:`first` 어트리뷰트를 가져오고 설정하는 함수는 다음과 같습니다::"

#: ../../extending/newtypes_tutorial.rst:545
msgid ""
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    PyObject *tmp;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    tmp = self->first;\n"
"    Py_INCREF(value);\n"
"    self->first = value;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:572
#, fuzzy
msgid ""
"The getter function is passed a :class:`!Custom` object and a "
"\"closure\", which is a void pointer.  In this case, the closure is "
"ignored.  (The closure supports an advanced usage in which definition "
"data is passed to the getter and setter. This could, for example, be used"
" to allow a single set of getter and setter functions that decide the "
"attribute to get or set based on data in the closure.)"
msgstr ""
"게터(getter) 함수에는 :class:`Custom` 객체와 \"클로저(closure)\"(void 포인터)가 전달됩니다. 이 "
"경우, 클로저는 무시됩니다. (클로저는 정의 데이터가 게터(getter)와 세터(setter)로 전달되는 고급 사용법을 지원합니다."
" 예를 들어, 클로저의 데이터에 기반하여 가져오거나 설정할 어트리뷰트를 결정하는 단일 게터(getter)와 세터(setter) 함수"
" 집합을 가능하게 합니다.)"

#: ../../extending/newtypes_tutorial.rst:578
#, fuzzy
msgid ""
"The setter function is passed the :class:`!Custom` object, the new value,"
" and the closure.  The new value may be ``NULL``, in which case the "
"attribute is being deleted.  In our setter, we raise an error if the "
"attribute is deleted or if its new value is not a string."
msgstr ""
"세터(setter) 함수에는 :class:`Custom` 객체, 새 값 및 클로저(closure)가 전달됩니다. 새 값은 "
"``NULL``\\일 수 있으며, 이 경우 어트리뷰트가 삭제됩니다. 세터(setter)에서, 우리는 어트리뷰트가 삭제되거나 새 값이"
" 문자열이 아니면 에러를 발생시킵니다."

#: ../../extending/newtypes_tutorial.rst:583
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr ":c:type:`PyGetSetDef` 구조체의 배열을 만듭니다::"

#: ../../extending/newtypes_tutorial.rst:585
msgid ""
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:593
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "그리고 :c:member:`~PyTypeObject.tp_getset` 슬롯에 등록합니다::"

#: ../../extending/newtypes_tutorial.rst:595
msgid ".tp_getset = Custom_getsetters,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:597
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just "
"pass ``NULL``."
msgstr ""
":c:type:`PyGetSetDef` 구조체의 마지막 항목은 위에서 언급한 \"클로저\"입니다. 이 경우, 클로저를 사용하지 "
"않아서, ``NULL``\\만 전달합니다."

#: ../../extending/newtypes_tutorial.rst:600
msgid "We also remove the member definitions for these attributes::"
msgstr "또한 이러한 어트리뷰트에 대한 멤버 정의를 제거합니다::"

#: ../../extending/newtypes_tutorial.rst:602
msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:608
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to "
"only allow strings [#]_ to be passed::"
msgstr "또한 문자열만 전달되도록 [#]_ :c:member:`~PyTypeObject.tp_init` 처리기를 갱신해야 합니다::"

#: ../../extending/newtypes_tutorial.rst:611
msgid ""
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:637
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members"
" are never ``NULL`` so we can remove checks for ``NULL`` values in almost"
" all cases. This means that most of the :c:func:`Py_XDECREF` calls can be"
" converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in "
"``tp_new``."
msgstr ""
"이러한 변경을 통해, ``first``\\와 ``last`` 멤버가 절대 ``NULL``\\이 아니라고 확신할 수 있어서, 거의 "
"모든 경우에 ``NULL`` 값 검사를 제거할 수 있습니다. 이것은 대부분의 :c:func:`Py_XDECREF` 호출이 "
":c:func:`Py_DECREF` 호출로 변환될 수 있음을 의미합니다. 이러한 호출을 변경할 수 없는 유일한 장소는 "
"``tp_dealloc`` 구현에서인데, ``tp_new``\\에서 이 멤버의 초기화가 실패했을 가능성이 있습니다."

#: ../../extending/newtypes_tutorial.rst:644
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition"
" to the :file:`setup.py` file."
msgstr ""
"또한 이전과 마찬가지로, 초기화 함수에서 모듈 초기화 함수와 모듈 이름을 바꾸고, :file:`setup.py` 파일에 추가 정의를"
" 추가합니다."

#: ../../extending/newtypes_tutorial.rst:650
msgid "Supporting cyclic garbage collection"
msgstr "순환 가비지 수거 지원하기"

#: ../../extending/newtypes_tutorial.rst:652
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` "
"that can identify unneeded objects even when their reference counts are "
"not zero. This can happen when objects are involved in cycles.  For "
"example, consider:"
msgstr ""
"파이썬에는 참조 횟수가 0이 아닐 때도 불필요한 객체를 식별할 수 있는 :term:`순환 가비지 수거기 (GC) <garbage "
"collection>`\\가 있습니다. 이것은 객체가 순환에 참여할 때 일어날 수 있습니다. 예를 들어, 다음을 고려하십시오:"

#: ../../extending/newtypes_tutorial.rst:656
msgid ""
">>> l = []\n"
">>> l.append(l)\n"
">>> del l"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:662
msgid ""
"In this example, we create a list that contains itself. When we delete "
"it, it still has a reference from itself. Its reference count doesn't "
"drop to zero. Fortunately, Python's cyclic garbage collector will "
"eventually figure out that the list is garbage and free it."
msgstr ""
"이 예에서, 자신을 포함하는 리스트를 만듭니다. 삭제해도 여전히 자체 참조가 있습니다. 참조 횟수가 0으로 떨어지지 않습니다. "
"다행스럽게도, 파이썬의 순환 가비지 수거기는 결국 리스트가 가비지임을 확인하고 해제합니다."

#: ../../extending/newtypes_tutorial.rst:667
#, fuzzy
msgid ""
"In the second version of the :class:`!Custom` example, we allowed any "
"kind of object to be stored in the :attr:`!first` or :attr:`!last` "
"attributes [#]_. Besides, in the second and third versions, we allowed "
"subclassing :class:`!Custom`, and subclasses may add arbitrary "
"attributes.  For any of those two reasons, :class:`!Custom` objects can "
"participate in cycles:"
msgstr ""
":class:`Custom` 예제의 두 번째 버전에서는, 모든 종류의 객체를 :attr:`first`\\나 :attr:`last` "
"어트리뷰트에 저장할 수 있었습니다 [#]_. 게다가 두 번째와 세 번째 버전에서는, :class:`Custom`\\을 서브 클래싱 "
"할 수 있었고, 서브 클래스는 임의의 어트리뷰트를 추가할 수 있습니다. 이 두 가지 이유 중 어느 것으로도, "
":class:`Custom` 객체는 순환에 참여할 수 있습니다:"

#: ../../extending/newtypes_tutorial.rst:673
msgid ""
">>> import custom3\n"
">>> class Derived(custom3.Custom): pass\n"
"...\n"
">>> n = Derived()\n"
">>> n.some_attribute = n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:681
#, fuzzy
msgid ""
"To allow a :class:`!Custom` instance participating in a reference cycle "
"to be properly detected and collected by the cyclic GC, our "
":class:`!Custom` type needs to fill two additional slots and to enable a "
"flag that enables these slots:"
msgstr ""
"순환 GC가 참조 순환에 참여하는 :class:`Custom` 인스턴스를 올바르게 감지하고 수집할 수 있도록, "
":class:`Custom` 형은 두 개의 추가 슬롯을 채우고 이러한 슬롯을 활성화하는 플래그를 활성화해야 합니다:"

#: ../../extending/newtypes_tutorial.rst:685
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static int\n"
"Custom_clear(CustomObject *self)\n"
"{\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    Custom_clear(self);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_traverse = (traverseproc) Custom_traverse,\n"
"    .tp_clear = (inquiry) Custom_clear,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom4\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:688
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that"
" could participate in cycles::"
msgstr "첫째, 탐색(traversal) 메서드는 순환 GC가 순환에 참여할 수 있는 서브 객체에 대해 알 수 있도록 합니다::"

#: ../../extending/newtypes_tutorial.rst:691
msgid ""
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    int vret;\n"
"    if (self->first) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    if (self->last) {\n"
"        vret = visit(self->last, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:708
#, fuzzy
msgid ""
"For each subobject that can participate in cycles, we need to call the "
":c:func:`!visit` function, which is passed to the traversal method. The "
":c:func:`!visit` function takes as arguments the subobject and the extra "
"argument *arg* passed to the traversal method.  It returns an integer "
"value that must be returned if it is non-zero."
msgstr ""
"순환에 참여할 수 있는 각 서브 객체에 대해 탐색 메서드에 전달되는 :c:func:`visit` 함수를 호출해야 합니다. "
":c:func:`visit` 함수는 서브 객체와 탐색 메서드에 전달한 추가 인자 *arg* 인자를 인자로 취합니다. 0이 아닌 경우"
" 반환해야 하는 정숫값을 반환합니다."

#: ../../extending/newtypes_tutorial.rst:714
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"파이썬은 visit 함수 호출을 자동화하는 :c:func:`Py_VISIT` 매크로를 제공합니다. "
":c:func:`Py_VISIT`\\를 사용하면, ``Custom_traverse``\\에서 관용구 양을 최소화할 수 있습니다::"

#: ../../extending/newtypes_tutorial.rst:718
#, python-brace-format
msgid ""
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:727
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
":c:func:`Py_VISIT`\\를 사용하려면 :c:member:`~PyTypeObject.tp_traverse` 구현에서 인자"
" 이름을 *visit*\\과 *arg*\\로 정확하게 지정해야 합니다."

#: ../../extending/newtypes_tutorial.rst:730
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr "둘째, 순환에 참여할 수 있는 서브 객체를 지우는 메서드를 제공해야 합니다::"

#: ../../extending/newtypes_tutorial.rst:733
#, python-brace-format
msgid ""
"static int\n"
"Custom_clear(CustomObject *self)\n"
"{\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:741
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended "
"and safe way to clear data attributes of arbitrary types while "
"decrementing their reference counts.  If you were to call "
":c:func:`Py_XDECREF` instead on the attribute before setting it to "
"``NULL``, there is a possibility that the attribute's destructor would "
"call back into code that reads the attribute again (*especially* if there"
" is a reference cycle)."
msgstr ""
":c:func:`Py_CLEAR` 매크로 사용에 주목하십시오. 참조 횟수를 줄이면서 임의 형의 데이터 어트리뷰트를 지우는 권장되고 "
"안전한 방법입니다. ``NULL``\\로 설정하기 전에 어트리뷰트에서 :c:func:`Py_XDECREF`\\를 대신 호출했으면, "
"어트리뷰트의 파괴자가 어트리뷰트를 다시 읽는 코드(*특히* 참조 순환이 있으면 )를 다시 호출할 가능성이 있습니다."

#: ../../extending/newtypes_tutorial.rst:749
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "다음과 같이 작성하여 :c:func:`Py_CLEAR`\\를 에뮬레이션할 수 있습니다::"

#: ../../extending/newtypes_tutorial.rst:751
msgid ""
"PyObject *tmp;\n"
"tmp = self->first;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:756
msgid ""
"Nevertheless, it is much easier and less error-prone to always use "
":c:func:`Py_CLEAR` when deleting an attribute.  Don't try to micro-"
"optimize at the expense of robustness!"
msgstr ""
"그런데도, 어트리뷰트를 삭제할 때 항상 :c:func:`Py_CLEAR`\\를 사용하기가 훨씬 쉽고 에러가 적습니다. 견고성을 "
"희생하면서 세밀한 최적화를 시도하지 마십시오!"

#: ../../extending/newtypes_tutorial.rst:760
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the "
"function. Since the GC assumes reference count is not zero, we need to "
"untrack the object from the GC by calling :c:func:`PyObject_GC_UnTrack` "
"before clearing members. Here is our reimplemented deallocator using "
":c:func:`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"할당 해제기 ``Custom_dealloc``\\은 어트리뷰트를 지울 때 임의의 코드를 호출할 수 있습니다. 이는 함수 내에서 순환"
" GC가 트리거 될 수 있음을 의미합니다. GC는 참조 횟수가 0이 아니라고 가정하기 때문에, 멤버를 지우기 전에 "
":c:func:`PyObject_GC_UnTrack`\\을 호출하여 GC에서 객체를 추적 해제해야 합니다. 다음은 "
":c:func:`PyObject_GC_UnTrack`\\과 ``Custom_clear``\\를 사용하여 다시 구현된 할당 "
"해제기입니다::"

#: ../../extending/newtypes_tutorial.rst:767
#, python-brace-format
msgid ""
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    Custom_clear(self);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:775
#, fuzzy
msgid ""
"Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class "
"flags::"
msgstr "마지막으로, :const:`Py_TPFLAGS_HAVE_GC` 플래그를 클래스 플래그에 추가합니다::"

#: ../../extending/newtypes_tutorial.rst:777
msgid ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:779
msgid ""
"That's pretty much it.  If we had written custom "
":c:member:`~PyTypeObject.tp_alloc` or :c:member:`~PyTypeObject.tp_free` "
"handlers, we'd need to modify them for cyclic garbage collection.  Most "
"extensions will use the versions automatically provided."
msgstr ""
"거의 다 됐습니다. 사용자 정의 :c:member:`~PyTypeObject.tp_alloc`\\이나 "
":c:member:`~PyTypeObject.tp_free` 처리기를 작성했으면, 순환 가비지 수거를 위해 이를 수정해야 합니다. "
"대부분의 확장은 자동으로 제공된 버전을 사용합니다."

#: ../../extending/newtypes_tutorial.rst:785
msgid "Subclassing other types"
msgstr "다른 형의 서브 클래싱"

#: ../../extending/newtypes_tutorial.rst:787
msgid ""
"It is possible to create new extension types that are derived from "
"existing types. It is easiest to inherit from the built in types, since "
"an extension can easily use the :c:type:`PyTypeObject` it needs. It can "
"be difficult to share these :c:type:`PyTypeObject` structures between "
"extension modules."
msgstr ""
"기존 형에서 파생된 새 확장형을 만들 수 있습니다. 확장이 필요한 :c:type:`PyTypeObject`\\를 쉽게 사용할 수 "
"있어서, 내장형에서 상속하기가 가장 쉽습니다. 확장 모듈 간에 이러한 :c:type:`PyTypeObject` 구조체를 공유하기 "
"어려울 수 있습니다."

#: ../../extending/newtypes_tutorial.rst:792
#, fuzzy
msgid ""
"In this example we will create a :class:`!SubList` type that inherits "
"from the built-in :class:`list` type. The new type will be completely "
"compatible with regular lists, but will have an additional "
":meth:`!increment` method that increases an internal counter:"
msgstr ""
"이 예에서는 내장 :class:`list` 형을 상속하는 :class:`SubList` 형을 만듭니다. 새로운 형은 일반 리스트와 "
"완전히 호환되지만, 내부 카운터를 증가시키는 추가 :meth:`increment` 메서드가 있습니다:"

#: ../../extending/newtypes_tutorial.rst:797
msgid ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:809
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;\n"
"\n"
"static PyObject *\n"
"SubList_increment(SubListObject *self, PyObject *unused)\n"
"{\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", (PyCFunction) SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"increment state counter\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"static int\n"
"SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"static PyTypeObject SubListType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList objects\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = (initproc) SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"static PyModuleDef sublistmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    PyObject *m;\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&sublistmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) "
"< 0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:812
#, fuzzy
msgid ""
"As you can see, the source code closely resembles the :class:`!Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"보시다시피, 소스 코드는 이전 섹션의 :class:`Custom` 예제와 매우 유사합니다. 우리는 그들 사이의 주요 차이점을 분석할"
" 것입니다. ::"

#: ../../extending/newtypes_tutorial.rst:815
#, python-brace-format
msgid ""
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:820
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"파생형 객체의 주요 차이점은 베이스형의 객체 구조체가 첫 번째 값이어야 한다는 것입니다. 베이스형은 이미 구조체의 시작 부분에 "
":c:func:`PyObject_HEAD`\\를 포함합니다."

#: ../../extending/newtypes_tutorial.rst:824
#, fuzzy
msgid ""
"When a Python object is a :class:`!SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject"
" *``::"
msgstr ""
"파이썬 객체가 :class:`SubList` 인스턴스일 때, ``PyObject *`` 포인터는 ``PyListObject "
"*``\\와 ``SubListObject *`` 모두로 안전하게 캐스팅될 수 있습니다::"

#: ../../extending/newtypes_tutorial.rst:827
#, python-brace-format
msgid ""
"static int\n"
"SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:836
#, fuzzy
msgid ""
"We see above how to call through to the :meth:`~object.__init__` method "
"of the base type."
msgstr "위에서 베이스형의 :attr:`__init__` 메서드를 호출하는 방법을 볼 수 있습니다."

#: ../../extending/newtypes_tutorial.rst:839
msgid ""
"This pattern is important when writing a type with custom "
":c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc`"
" members.  The :c:member:`~PyTypeObject.tp_new` handler should not "
"actually create the memory for the object with its "
":c:member:`~PyTypeObject.tp_alloc`, but let the base class handle it by "
"calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"이 패턴은 사용자 정의 :c:member:`~PyTypeObject.tp_new`\\와 "
":c:member:`~PyTypeObject.tp_dealloc` 멤버를 갖는 형을 작성할 때 중요합니다. "
":c:member:`~PyTypeObject.tp_new` 처리기는 실제로 "
":c:member:`~PyTypeObject.tp_alloc`\\을 사용하여 객체의 메모리를 만들지 말고, 베이스 클래스가 자체 "
":c:member:`~PyTypeObject.tp_new`\\를 호출하여 처리하도록 해야 합니다."

#: ../../extending/newtypes_tutorial.rst:845
msgid ""
"The :c:type:`PyTypeObject` struct supports a "
":c:member:`~PyTypeObject.tp_base` specifying the type's concrete base "
"class.  Due to cross-platform compiler issues, you can't fill that field "
"directly with a reference to :c:type:`PyList_Type`; it should be done "
"later in the module initialization function::"
msgstr ""
":c:type:`PyTypeObject` 구조체는 형의 구상 베이스 클래스를 지정하는 "
":c:member:`~PyTypeObject.tp_base`\\를 지원합니다. 크로스 플랫폼 컴파일러 문제로 인해, "
":c:type:`PyList_Type`\\에 대한 참조로 해당 필드를 직접 채울 수 없습니다; 나중에 모듈 초기화 함수에서 수행해야"
" 합니다::"

#: ../../extending/newtypes_tutorial.rst:851
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    PyObject* m;\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&sublistmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) "
"< 0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:871
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the "
":c:member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving "
"an existing type, it is not necessary to fill out the "
":c:member:`~PyTypeObject.tp_alloc` slot with :c:func:`PyType_GenericNew` "
"-- the allocation function from the base type will be inherited."
msgstr ""
":c:func:`PyType_Ready`\\를 호출하기 전에, 형 구조체에 "
":c:member:`~PyTypeObject.tp_base` 슬롯이 채워져 있어야 합니다. 기존 형을 파생할 때, "
":c:func:`PyType_GenericNew`\\로 :c:member:`~PyTypeObject.tp_alloc` 슬롯을 채울 "
"필요는 없습니다 -- 베이스형의 할당 함수가 상속됩니다."

#: ../../extending/newtypes_tutorial.rst:877
#, fuzzy
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to "
"the module is the same as with the basic :class:`!Custom` examples."
msgstr ""
"그런 다음, :c:func:`PyType_Ready`\\를 호출하고 형 객체를 모듈에 추가하는 것은 기초 "
":class:`Custom` 예와 같습니다."

#: ../../extending/newtypes_tutorial.rst:882
msgid "Footnotes"
msgstr "각주"

#: ../../extending/newtypes_tutorial.rst:883
msgid ""
"This is true when we know that the object is a basic type, like a string "
"or a float."
msgstr "이것은 객체가 문자열이나 부동 소수점과 같은 기본형이라는 것을 알고 있을 때 참입니다."

#: ../../extending/newtypes_tutorial.rst:886
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""
"우리의 형이 가비지 수거를 지원하지 않기 때문에, 이 예제에서는 :c:member:`~PyTypeObject.tp_dealloc` "
"처리기에서 이것을 사용했습니다."

#: ../../extending/newtypes_tutorial.rst:889
msgid ""
"We now know that the first and last members are strings, so perhaps we "
"could be less careful about decrementing their reference counts, however,"
" we accept instances of string subclasses.  Even though deallocating "
"normal strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"우리는 이제 first와 last 멤버가 문자열이라는 것을 알고 있어서, 참조 횟수를 줄이는 데 덜 주의할 수 있지만, 우리는 "
"문자열 서브 클래스의 인스턴스를 받아들입니다. 일반 문자열을 할당 해제하는 것이 우리 객체로 다시 호출되지는 않더라도, 문자열 서브"
" 클래스의 인스턴스를 할당 해제하는 것이 객체로 다시 호출되지 않는다고 보장할 수 없습니다."

#: ../../extending/newtypes_tutorial.rst:895
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
"또한, 어트리뷰트가 문자열 인스턴스로 제한된 경우에도, 사용자는 임의의 :class:`str` 서브 클래스를 전달할 수 있어서 "
"여전히 참조 순환을 만들 수 있습니다."

#~ msgid ""
#~ "While this documentation showcases the "
#~ "standard :mod:`distutils` module for building"
#~ " C extensions, it is recommended in"
#~ " real-world use cases to use "
#~ "the newer and better-maintained "
#~ "``setuptools`` library.  Documentation on how"
#~ " to do this is out of scope "
#~ "for this document and can be found"
#~ " in the `Python Packaging User's "
#~ "Guide <https://packaging.python.org/tutorials/distributing-"
#~ "packages/>`_."
#~ msgstr ""
#~ "이 설명서는 C 확장을 빌드하기 위한 표준 "
#~ ":mod:`distutils` 모듈을 보여 주지만, 실제 사용 "
#~ "사례에서는 새롭고 유지 관리가 잘 된 "
#~ "``setuptools`` 라이브러리를 사용하는 것이 좋습니다. 이"
#~ " 작업을 수행하는 방법에 대한 설명서는 이 문서의 "
#~ "범위를 넘어서고 `파이썬 패키징 사용자 지침서 "
#~ "<https://packaging.python.org/tutorials/distributing-"
#~ "packages/>`_\\에서 찾을 수 있습니다."

#~ msgid "We've added an extra include::"
#~ msgstr "다음과 같은 추가 포함(include)을 추가했습니다::"

#~ msgid ""
#~ "This include provides declarations that "
#~ "we use to handle attributes, as "
#~ "described a bit later."
#~ msgstr "이 포함은 나중에 설명하는 것처럼 어트리뷰트를 처리하는 데 사용하는 선언을 제공합니다."

