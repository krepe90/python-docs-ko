# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../extending/newtypes.rst:7
msgid "Defining Extension Types: Assorted Topics"
msgstr "확장형 정의하기: 여러 가지 주제"

#: ../../extending/newtypes.rst:11
msgid ""
"This section aims to give a quick fly-by on the various type methods you "
"can implement and what they do."
msgstr "이 섹션은 구현할 수 있는 다양한 형 메서드와 그것이 하는 일에 대해 훑어보기를 제공하기 위한 것입니다."

#: ../../extending/newtypes.rst:14
#, fuzzy
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only "
"used in :ref:`debug builds <debug-build>` omitted:"
msgstr "다음은 디버그 빌드에서만 사용되는 일부 필드가 생략된 :c:type:`PyTypeObject`\\의 정의입니다:"

#: ../../extending/newtypes.rst:17
#, python-brace-format
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" "
"*/\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python "
"2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    struct PyMethodDef *tp_methods;\n"
"    struct PyMemberDef *tp_members;\n"
"    struct PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static "
"type\n"
"    struct _typeobject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache;\n"
"    PyObject *tp_subclasses;\n"
"    PyObject *tp_weaklist;\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6 */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"} PyTypeObject;\n"
msgstr ""

#: ../../extending/newtypes.rst:20
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you "
"have a type you want to define, the chances are very good that you will "
"only implement a handful of these."
msgstr "이제 메서드가 아주 *많습니다*. 너무 걱정하지 마십시오 -- 정의하려는 형이 있으면, 이 중 일부만 구현할 가능성이 매우 높습니다."

#: ../../extending/newtypes.rst:24
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they "
"are defined in the structure, because there is a lot of historical "
"baggage that impacts the ordering of the fields.  It's often easiest to "
"find an example that includes the fields you need and then change the "
"values to suit your new type. ::"
msgstr ""
"아마 지금까지 예상했듯이, 이것에 대해 살펴보고 다양한 처리기에 대한 자세한 정보를 제공할 것입니다. 필드의 순서에 영향을 미치는 "
"많은 과거의 짐이 있어서, 구조체에 정의된 순서대로 진행하지 않을 것입니다. 필요한 필드가 포함된 예제를 찾은 다음 새 형에 맞게 "
"값을 변경하기가 종종 가장 쉽습니다. ::"

#: ../../extending/newtypes.rst:31
msgid "const char *tp_name; /* For printing */"
msgstr ""

#: ../../extending/newtypes.rst:33
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to"
" choose something that will be helpful in such a situation! ::"
msgstr ""
"형의 이름 -- 이전 장에서 언급했듯이, 이것은 여러 곳에서 나타나는데, 거의 진단 목적입니다. 그러한 상황에서 도움이 될만한 것을"
" 선택하십시오! ::"

#: ../../extending/newtypes.rst:37
msgid "Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */"
msgstr ""

#: ../../extending/newtypes.rst:39
msgid ""
"These fields tell the runtime how much memory to allocate when new "
"objects of this type are created.  Python has some built-in support for "
"variable length structures (think: strings, tuples) which is where the "
":c:member:`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt"
" with later. ::"
msgstr ""
"이 필드는 이 형의 새 객체가 만들어질 때 할당할 메모리양을 런타임에 알려줍니다. 파이썬은 가변 길이 구조(생각하세요: 문자열, "
"튜플)에 대한 지원을 내장하고 있는데, 이때 :c:member:`~PyTypeObject.tp_itemsize` 필드가 참여합니다."
" 이것은 나중에 다룰 것입니다. ::"

#: ../../extending/newtypes.rst:44
msgid "const char *tp_doc;"
msgstr ""

#: ../../extending/newtypes.rst:46
msgid ""
"Here you can put a string (or its address) that you want returned when "
"the Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"여기에 파이썬 스크립트가 ``obj.__doc__``\\을 참조하여 독스트링을 꺼낼 때 반환할 문자열(또는 문자열의 주소)을 넣을 "
"수 있습니다."

#: ../../extending/newtypes.rst:49
msgid ""
"Now we come to the basic type methods -- the ones most extension types "
"will implement."
msgstr "이제 기본 형 메서드에 대해 살펴보겠습니다 -- 대부분의 확장형이 구현할 것들입니다."

#: ../../extending/newtypes.rst:54
msgid "Finalization and De-allocation"
msgstr "파이널리제이션과 할당 해제"

#: ../../extending/newtypes.rst:64
msgid "destructor tp_dealloc;"
msgstr ""

#: ../../extending/newtypes.rst:66
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  "
"If your type has memory to free or other clean-up to perform, you can put"
" it here.  The object itself needs to be freed here as well.  Here is an "
"example of this function::"
msgstr ""
"이 함수는 형의 인스턴스의 참조 횟수가 0으로 줄어들고 파이썬 인터프리터가 그것을 재활용하고자 할 때 호출됩니다. 여러분의 형에 "
"해제할 메모리가 있거나 수행할 기타 정리 작업이 있으면, 여기에 넣을 수 있습니다. 객체 자체도 여기서 해제해야 합니다. 이 함수의"
" 예는 다음과 같습니다::"

#: ../../extending/newtypes.rst:72
#, python-brace-format
msgid ""
"static void\n"
"newdatatype_dealloc(newdatatypeobject *obj)\n"
"{\n"
"    free(obj->obj_UnderlyingDatatypePtr);\n"
"    Py_TYPE(obj)->tp_free((PyObject *)obj);\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:79
msgid ""
"If your type supports garbage collection, the destructor should call "
":c:func:`PyObject_GC_UnTrack` before clearing any member fields::"
msgstr ""

#: ../../extending/newtypes.rst:82
#, python-brace-format
msgid ""
"static void\n"
"newdatatype_dealloc(newdatatypeobject *obj)\n"
"{\n"
"    PyObject_GC_UnTrack(obj);\n"
"    Py_CLEAR(obj->other_obj);\n"
"    ...\n"
"    Py_TYPE(obj)->tp_free((PyObject *)obj);\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:95
msgid ""
"One important requirement of the deallocator function is that it leaves "
"any pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), "
"nothing is done to protect the deallocators from seeing that an exception"
" has already been set.  Any actions which a deallocator performs which "
"may cause additional Python code to be executed may detect that an "
"exception has been set.  This can lead to misleading errors from the "
"interpreter.  The proper way to protect against this is to save a pending"
" exception before performing the unsafe action, and restoring it when "
"done.  This can be done using the :c:func:`PyErr_Fetch` and "
":c:func:`PyErr_Restore` functions::"
msgstr ""
"할당 해제 함수의 중요한 요구 사항 중 하나는 계류 중인 예외를 그대로 남겨 두어야 한다는 것입니다. 인터프리터가 파이썬 스택을 "
"되감을 때 할당 해제기가 자주 호출되기 때문에 중요합니다; 스택이 (정상적인 반환이 아닌) 예외로 인해 되감길 때, 할당 해제기가 "
"예외가 이미 설정되어 있음을 알 수 없도록 하는 것은 아무것도 수행되지 않습니다. 할당 해제기가 수행하는 추가 파이썬 코드가 실행될"
" 수 있도록 하는 추가 조치는 예외가 설정되었음을 감지할 수 있습니다. 이는 인터프리터가 혼동하도록 할 수 있습니다. 이를 방지하는"
" 올바른 방법은 안전하지 않은 조치를 수행하기 전에 계류 중인 예외를 저장하고 완료되면 복원하는 것입니다. "
":c:func:`PyErr_Fetch`\\와 :c:func:`PyErr_Restore` 함수를 사용하여 수행할 수 있습니다::"

#: ../../extending/newtypes.rst:107
msgid ""
"static void\n"
"my_dealloc(PyObject *obj)\n"
"{\n"
"    MyObject *self = (MyObject *) obj;\n"
"    PyObject *cbresult;\n"
"\n"
"    if (self->my_callback != NULL) {\n"
"        PyObject *err_type, *err_value, *err_traceback;\n"
"\n"
"        /* This saves the current exception state */\n"
"        PyErr_Fetch(&err_type, &err_value, &err_traceback);\n"
"\n"
"        cbresult = PyObject_CallNoArgs(self->my_callback);\n"
"        if (cbresult == NULL)\n"
"            PyErr_WriteUnraisable(self->my_callback);\n"
"        else\n"
"            Py_DECREF(cbresult);\n"
"\n"
"        /* This restores the saved exception state */\n"
"        PyErr_Restore(err_type, err_value, err_traceback);\n"
"\n"
"        Py_DECREF(self->my_callback);\n"
"    }\n"
"    Py_TYPE(obj)->tp_free((PyObject*)self);\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:134
msgid ""
"There are limitations to what you can safely do in a deallocator "
"function. First, if your type supports garbage collection (using "
":c:member:`~PyTypeObject.tp_traverse` and/or "
":c:member:`~PyTypeObject.tp_clear`), some of the object's members can "
"have been cleared or finalized by the time "
":c:member:`~PyTypeObject.tp_dealloc` is called.  Second, in "
":c:member:`~PyTypeObject.tp_dealloc`, your object is in an unstable "
"state: its reference count is equal to zero.  Any call to a non-trivial "
"object or API (as in the example above) might end up calling "
":c:member:`~PyTypeObject.tp_dealloc` again, causing a double free and a "
"crash."
msgstr ""
"할당 해제 함수에서 안전하게 수행할 수 있는 작업에는 제한이 있습니다. 먼저, 형이 가비지 수거를 지원하면 "
"(:c:member:`~PyTypeObject.tp_traverse` 및/또는 "
":c:member:`~PyTypeObject.tp_clear`\\를 사용해서), "
":c:member:`~PyTypeObject.tp_dealloc`\\이 호출될 때 객체의 일부 멤버가 지워지거나 파이널라이즈 될 수"
" 있습니다. 둘째, :c:member:`~PyTypeObject.tp_dealloc`\\에서, 객체는 불안정한 상태에 있습니다: "
"참조 횟수가 0입니다. (위의 예에서와같이) 사소하지 않은 객체나 API를 호출하면 "
":c:member:`~PyTypeObject.tp_dealloc`\\을 다시 호출하게 되어, 이중 해제와 충돌이 발생할 수 "
"있습니다."

#: ../../extending/newtypes.rst:143
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead "
"use the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"파이썬 3.4부터는, :c:member:`~PyTypeObject.tp_dealloc`\\에 복잡한 파이널리제이션 코드를 넣지 "
"말고, 대신 새로운 :c:member:`~PyTypeObject.tp_finalize` 형 메서드를 사용하는 것이 좋습니다."

#: ../../extending/newtypes.rst:148
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442`\\는 새로운 파이널리제이션 체계를 설명합니다."

#: ../../extending/newtypes.rst:155
msgid "Object Presentation"
msgstr "객체 표현"

#: ../../extending/newtypes.rst:157
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The "
":func:`print` function just calls :func:`str`.)  These handlers are both "
"optional."
msgstr ""
"파이썬에서, 객체의 텍스트 표현을 생성하는 두 가지 방법이 있습니다: :func:`repr` 함수와 :func:`str` 함수. "
"(:func:`print` 함수는 단지 :func:`str`\\을 호출합니다.) 이 처리기들은 모두 선택적입니다."

#: ../../extending/newtypes.rst:163
msgid ""
"reprfunc tp_repr;\n"
"reprfunc tp_str;"
msgstr ""

#: ../../extending/newtypes.rst:166
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string "
"object containing a representation of the instance for which it is "
"called.  Here is a simple example::"
msgstr ""
":c:member:`~PyTypeObject.tp_repr` 처리기는 호출된 인스턴스의 표현을 포함하는 문자열 객체를 반환해야 "
"합니다. 다음은 간단한 예입니다::"

#: ../../extending/newtypes.rst:170
#, python-format
msgid ""
"static PyObject *\n"
"newdatatype_repr(newdatatypeobject *obj)\n"
"{\n"
"    return PyUnicode_FromFormat(\"Repr-ified_newdatatype{{size:%d}}\",\n"
"                                obj->obj_UnderlyingDatatypePtr->size);\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:177
#, fuzzy
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's "
":c:member:`~PyTypeObject.tp_name` and a uniquely identifying value for "
"the object."
msgstr ""
":c:member:`~PyTypeObject.tp_repr` 처리기가 지정되지 않으면, 인터프리터는 형의 "
":c:member:`~PyTypeObject.tp_name`\\과 객체의 고유 식별 값을 사용하는 표현을 제공합니다."

#: ../../extending/newtypes.rst:181
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the "
":c:member:`~PyTypeObject.tp_repr` handler described above is to "
":func:`repr`; that is, it is called when Python code calls :func:`str` on"
" an instance of your object.  Its implementation is very similar to the "
":c:member:`~PyTypeObject.tp_repr` function, but the resulting string is "
"intended for human consumption.  If :c:member:`~PyTypeObject.tp_str` is "
"not specified, the :c:member:`~PyTypeObject.tp_repr` handler is used "
"instead."
msgstr ""
":c:member:`~PyTypeObject.tp_str` 처리기는 :func:`str`\\에 대한 것이고, 위에서 설명한 "
":c:member:`~PyTypeObject.tp_repr` 처리기와 :func:`repr` 간의 관계와 같은 관계입니다; 즉, "
"파이썬 코드가 객체의 인스턴스에서 :func:`str`\\을 호출할 때 호출됩니다. 구현은 "
":c:member:`~PyTypeObject.tp_repr` 함수와 매우 유사하지만, 결과 문자열은 사람이 사용하기 위한 것입니다."
" :c:member:`~PyTypeObject.tp_str`\\을 지정하지 않으면, "
":c:member:`~PyTypeObject.tp_repr` 처리기가 대신 사용됩니다."

#: ../../extending/newtypes.rst:188
msgid "Here is a simple example::"
msgstr "다음은 간단한 예입니다::"

#: ../../extending/newtypes.rst:190
#, python-format
msgid ""
"static PyObject *\n"
"newdatatype_str(newdatatypeobject *obj)\n"
"{\n"
"    return PyUnicode_FromFormat(\"Stringified_newdatatype{{size:%d}}\",\n"
"                                obj->obj_UnderlyingDatatypePtr->size);\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:200
msgid "Attribute Management"
msgstr "어트리뷰트 관리"

#: ../../extending/newtypes.rst:202
msgid ""
"For every object which can support attributes, the corresponding type "
"must provide the functions that control how the attributes are resolved."
"  There needs to be a function which can retrieve attributes (if any are "
"defined), and another to set attributes (if setting attributes is "
"allowed).  Removing an attribute is a special case, for which the new "
"value passed to the handler is ``NULL``."
msgstr ""
"어트리뷰트를 지원할 수 있는 모든 객체에 대해, 해당 형은 어트리뷰트가 결정되는(resolved) 방법을 제어하는 함수를 제공해야 "
"합니다. 어트리뷰트를 꺼낼 수 있는 함수와 (뭔가 정의되어 있다면), 어트리뷰트를 설정하는 다른 함수(어트리뷰트 설정이 "
"허용된다면)가 있어야 합니다. 어트리뷰트 제거는 특별한 경우이며, 처리기에 전달된 새 값이 ``NULL``\\입니다."

#: ../../extending/newtypes.rst:208
#, fuzzy
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a "
":c:expr:`char\\*`, while the other accepts a :c:expr:`PyObject*`.  Each "
"type can use whichever pair makes more sense for the implementation's "
"convenience. ::"
msgstr ""
"파이썬은 두 쌍의 어트리뷰트 처리기를 지원합니다; 어트리뷰트를 지원하는 형은 한 쌍의 함수만 구현하면 됩니다. 차이점은 한 쌍은 "
"어트리뷰트 이름을 :c:type:`char\\*`\\로 취하고, 다른 쌍은 :c:type:`PyObject\\*`\\를 받아들인다는"
" 것입니다. 각 형은 구현의 편의에 더 적합한 쌍을 사용할 수 있습니다. ::"

#: ../../extending/newtypes.rst:214
msgid ""
"getattrfunc  tp_getattr;        /* char * version */\n"
"setattrfunc  tp_setattr;\n"
"/* ... */\n"
"getattrofunc tp_getattro;       /* PyObject * version */\n"
"setattrofunc tp_setattro;"
msgstr ""

#: ../../extending/newtypes.rst:220
#, fuzzy
msgid ""
"If accessing attributes of an object is always a simple operation (this "
"will be explained shortly), there are generic implementations which can "
"be used to provide the :c:expr:`PyObject*` version of the attribute "
"management functions. The actual need for type-specific attribute "
"handlers almost completely disappeared starting with Python 2.2, though "
"there are many examples which have not been updated to use some of the "
"new generic mechanism that is available."
msgstr ""
"객체의 어트리뷰트에 액세스하는 것이 항상 간단한 연산이면 (짧게 설명할 것입니다), 어트리뷰트 관리 함수의 "
":c:type:`PyObject\\*` 버전을 제공하는 데 사용할 수 있는 일반적인 구현이 있습니다. 파이썬 2.2부터 형별 "
"어트리뷰트 처리기에 대한 실제 필요성은 거의 완전히 사라졌지만, 사용 가능한 새로운 일반 메커니즘을 사용하도록 갱신되지 않은 예제가"
" 많이 있습니다."

#: ../../extending/newtypes.rst:231
msgid "Generic Attribute Management"
msgstr "범용 어트리뷰트 관리"

#: ../../extending/newtypes.rst:233
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be "
"met:"
msgstr ""
"대부분의 확장형은 *간단한* 어트리뷰트만 사용합니다. 그렇다면, 어트리뷰트를 간단하게 만드는 것은 무엇입니까? 충족해야 하는 몇 "
"가지 조건만 있습니다:"

#: ../../extending/newtypes.rst:236
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ":c:func:`PyType_Ready`\\가 호출될 때 어트리뷰트의 이름을 알아야 합니다."

#: ../../extending/newtypes.rst:239
msgid ""
"No special processing is needed to record that an attribute was looked up"
" or set, nor do actions need to be taken based on the value."
msgstr "어트리뷰트를 찾거나 설정했음을 기록하는 데 특별한 처리가 필요하지 않으며 값을 기반으로 조처를 하지 않아도 됩니다."

#: ../../extending/newtypes.rst:242
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr "이 목록은 어트리뷰트 값, 값을 계산하는 시점 또는 관련 데이터가 저장되는 방법에 제한을 두지 않음에 유의하십시오."

#: ../../extending/newtypes.rst:245
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by"
" the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all"
" three are ``NULL``, instances of the type will only have attributes that"
" are inherited from their base type, and should leave the "
":c:member:`~PyTypeObject.tp_getattro` and "
":c:member:`~PyTypeObject.tp_setattro` fields ``NULL`` as well, allowing "
"the base type to handle attributes."
msgstr ""
":c:func:`PyType_Ready`\\가 호출될 때, 형 객체가 참조하는 3개의 테이블을 사용하여 형 객체의 딕셔너리에 "
"배치되는 :term:`디스크립터 <descriptor>`\\를 만듭니다. 각 디스크립터는 인스턴스 객체의 한 어트리뷰트에 대한 "
"액세스를 제어합니다. 각 테이블은 선택적입니다; 세 개 모두가 ``NULL``\\이면, 형의 인스턴스는 베이스형에서 상속된 "
"어트리뷰트만 갖게 되며, :c:member:`~PyTypeObject.tp_getattro`\\와 "
":c:member:`~PyTypeObject.tp_setattro` 필드도 ``NULL``\\로 남겨두어야 베이스형이 어트리뷰트를 "
"처리할 수 있습니다."

#: ../../extending/newtypes.rst:253
msgid "The tables are declared as three fields of the type object::"
msgstr "테이블은 형 객체의 세 필드로 선언됩니다::"

#: ../../extending/newtypes.rst:255
msgid ""
"struct PyMethodDef *tp_methods;\n"
"struct PyMemberDef *tp_members;\n"
"struct PyGetSetDef *tp_getset;"
msgstr ""

#: ../../extending/newtypes.rst:259
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to"
" an array of :c:type:`PyMethodDef` structures.  Each entry in the table "
"is an instance of this structure::"
msgstr ""
":c:member:`~PyTypeObject.tp_methods`\\가 ``NULL``\\이 아니면, "
":c:type:`PyMethodDef` 구조체의 배열을 참조해야 합니다. 테이블의 각 항목은 다음 구조체의 인스턴스입니다::"

#: ../../extending/newtypes.rst:263
#, python-brace-format
msgid ""
"typedef struct PyMethodDef {\n"
"    const char  *ml_name;       /* method name */\n"
"    PyCFunction  ml_meth;       /* implementation function */\n"
"    int          ml_flags;      /* flags */\n"
"    const char  *ml_doc;        /* docstring */\n"
"} PyMethodDef;"
msgstr ""

#: ../../extending/newtypes.rst:270
#, fuzzy
msgid ""
"One entry should be defined for each method provided by the type; no "
"entries are needed for methods inherited from a base type.  One "
"additional entry is needed at the end; it is a sentinel that marks the "
"end of the array.  The :c:member:`~PyMethodDef.ml_name` field of the "
"sentinel must be ``NULL``."
msgstr ""
"형에서 제공되는 각 메서드에 대해 하나의 항목을 정의해야 합니다; 베이스형에서 상속된 메서드에는 항목이 필요하지 않습니다. 마지막에"
" 하나의 추가 항목이 필요합니다; 배열의 끝을 나타내는 센티넬(sentinel)입니다. 센티넬의 :attr:`ml_name` 필드는"
" ``NULL``\\이어야 합니다."

#: ../../extending/newtypes.rst:275
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, "
"and access may be read-only or read-write.  The structures in the table "
"are defined as::"
msgstr ""
"두 번째 테이블은 인스턴스에 저장된 데이터에 직접 매핑되는 어트리뷰트를 정의하는 데 사용됩니다. 다양한 기본 C형이 지원되며, "
"액세스는 읽기 전용이거나 읽고 쓰기일 수 있습니다. 테이블의 구조체는 다음과 같이 정의됩니다::"

#: ../../extending/newtypes.rst:279
#, python-brace-format
msgid ""
"typedef struct PyMemberDef {\n"
"    const char *name;\n"
"    int         type;\n"
"    int         offset;\n"
"    int         flags;\n"
"    const char *doc;\n"
"} PyMemberDef;"
msgstr ""

#: ../../extending/newtypes.rst:287
#, fuzzy
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and"
" added to the type which will be able to extract a value from the "
"instance structure.  The :c:member:`~PyMemberDef.type` field should "
"contain a type code like :c:macro:`Py_T_INT` or :c:macro:`Py_T_DOUBLE`; "
"the value will be used to determine how to convert Python values to and "
"from C values.  The :c:member:`~PyMemberDef.flags` field is used to store"
" flags which control how the attribute can be accessed: you can set it to"
" :c:macro:`Py_READONLY` to prevent Python code from setting it."
msgstr ""
"테이블의 각 항목에 대해, :term:`디스크립터 <descriptor>`\\가 구성되고 형에 추가되어 인스턴스 구조체에서 값을 "
"추출할 수 있게 됩니다. :attr:`type` 필드는 :file:`structmember.h` 헤더에 정의된 형 코드 중 하나를 "
"포함해야 합니다; 이 값은 파이썬 값과 C값 간에 변환하는 방법을 결정하는 데 사용됩니다. :attr:`flags` 필드는 "
"어트리뷰트에 액세스하는 방법을 제어하는 플래그를 저장하는 데 사용됩니다."

#: ../../extending/newtypes.rst:295
#, fuzzy
msgid ""
"An interesting advantage of using the "
":c:member:`~PyTypeObject.tp_members` table to build descriptors that are "
"used at runtime is that any attribute defined this way can have an "
"associated doc string simply by providing the text in the table.  An "
"application can use the introspection API to retrieve the descriptor from"
" the class object, and get the doc string using its :attr:`~type.__doc__`"
" attribute."
msgstr ""
":c:member:`~PyTypeObject.tp_members` 테이블을 사용하여 실행 시간에 사용되는 디스크립터를 구축하는 것의"
" 흥미로운 이점은 이 방법으로 정의된 모든 어트리뷰트가 단순히 테이블에 텍스트를 제공하는 것으로 연관된 독스트링을 가질 수 있다는 "
"것입니다. 응용 프로그램은 내부 검사(introspection) API를 사용하여 클래스 객체에서 디스크립터를 꺼내고, 그것의 "
":attr:`__doc__` 어트리뷰트를 사용하여 독스트링을 얻을 수 있습니다."

#: ../../extending/newtypes.rst:301
#, fuzzy
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :c:member:`~PyMethodDef.ml_name` value of ``NULL`` is required."
msgstr ""
":c:member:`~PyTypeObject.tp_methods` 테이블과 마찬가지로, :attr:`name` 값이 "
"``NULL``\\인 센티넬 항목이 필요합니다."

#: ../../extending/newtypes.rst:315
msgid "Type-specific Attribute Management"
msgstr "형별 어트리뷰트 관리"

#: ../../extending/newtypes.rst:317
#, fuzzy
msgid ""
"For simplicity, only the :c:expr:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the "
":c:expr:`char\\*` and :c:expr:`PyObject*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but"
" does not use the generic support added in Python 2.2.  It explains how "
"the handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"간단히 하기 위해, :c:type:`char\\*` 버전 만 여기에서 예시합니다; name 매개 변수의 형이 인터페이스의 "
":c:type:`char\\*`\\와 :c:type:`PyObject\\*` 버전 간의 유일한 차이점입니다. 이 예제는 위의 범용 "
"예제와 효과적으로 같은 것을 수행하지만, 파이썬 2.2에 추가된 범용 지원은 사용하지 않습니다. 처리기 함수가 호출되는 방식을 "
"설명하므로, 기능을 확장해야 한다면, 무엇을 해야 할지 이해할 수 있을 겁니다."

#: ../../extending/newtypes.rst:325
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the "
"object requires an attribute look-up.  It is called in the same "
"situations where the :meth:`~object.__getattr__` method of a class would "
"be called."
msgstr ""
":c:member:`~PyTypeObject.tp_getattr` 처리기는 객체에 어트리뷰트 조회가 필요할 때 호출됩니다. 클래스의"
" :meth:`__getattr__` 메서드가 호출되는 것과 같은 상황에서 호출됩니다."

#: ../../extending/newtypes.rst:329
msgid "Here is an example::"
msgstr "예는 다음과 같습니다::"

#: ../../extending/newtypes.rst:331
#, python-format
msgid ""
"static PyObject *\n"
"newdatatype_getattr(newdatatypeobject *obj, char *name)\n"
"{\n"
"    if (strcmp(name, \"data\") == 0)\n"
"    {\n"
"        return PyLong_FromLong(obj->data);\n"
"    }\n"
"\n"
"    PyErr_Format(PyExc_AttributeError,\n"
"                 \"'%.100s' object has no attribute '%.400s'\",\n"
"                 Py_TYPE(obj)->tp_name, name);\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:345
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the "
":meth:`~object.__setattr__` or :meth:`~object.__delattr__` method of a "
"class instance would be called.  When an attribute should be deleted, the"
" third parameter will be ``NULL``.  Here is an example that simply raises"
" an exception; if this were really all you wanted, the "
":c:member:`~PyTypeObject.tp_setattr` handler should be set to ``NULL``. "
"::"
msgstr ""
":c:member:`~PyTypeObject.tp_setattr` 처리기는 클래스 인스턴스의 "
":meth:`__setattr__`\\이나 :meth:`__delattr__` 메서드가 호출될 때 호출됩니다. 어트리뷰트를 삭제해야"
" 하면, 세 번째 매개 변수는 ``NULL``\\이 됩니다. 다음은 단순히 예외를 발생시키는 예입니다; 이것이 정말로 여러분이 "
"원하는 전부라면, :c:member:`~PyTypeObject.tp_setattr` 처리기는 ``NULL``\\로 설정되어야 "
"합니다. ::"

#: ../../extending/newtypes.rst:351
#, python-brace-format, python-format
msgid ""
"static int\n"
"newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v)\n"
"{\n"
"    PyErr_Format(PyExc_RuntimeError, \"Read-only attribute: %s\", name);\n"
"    return -1;\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:359
msgid "Object Comparison"
msgstr "객체 비교"

#: ../../extending/newtypes.rst:363
msgid "richcmpfunc tp_richcompare;"
msgstr ""

#: ../../extending/newtypes.rst:365
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`!__lt__`, and also called by "
":c:func:`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
":c:member:`~PyTypeObject.tp_richcompare` 처리기는 비교가 필요할 때 호출됩니다. "
":meth:`__lt__`\\와 같은 :ref:`풍부한 비교 메서드 <richcmpfuncs>`\\에 해당하며, "
":c:func:`PyObject_RichCompare`\\와 :c:func:`PyObject_RichCompareBool`\\에 "
"의해서도 호출됩니다."

#: ../../extending/newtypes.rst:370
#, fuzzy
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GE``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects "
"with respect to the specified operator and return ``Py_True`` or "
"``Py_False`` if the comparison is successful, ``Py_NotImplemented`` to "
"indicate that comparison is not implemented and the other object's "
"comparison method should be tried, or ``NULL`` if an exception was set."
msgstr ""
"이 함수는 두 개의 파이썬 객체와 연산자를 인자로 사용하여 호출됩니다, 여기서 연산자는 ``Py_EQ``, ``Py_NE``, "
"``Py_LE``, ``Py_GT``, ``Py_LT`` 또는 ``Py_GT`` 중 하나입니다. 지정된 연산자로 두 객체를 비교하고"
" 비교에 성공하면 ``Py_True``\\나 ``Py_False``\\를, 비교가 구현되지 않았으며 다른 객체의 비교 메서드를 "
"시도해야 한다는 것을 나타내려면 ``Py_NotImplemented``\\를, 예외가 설정되면 ``NULL``\\을 반환해야 "
"합니다."

#: ../../extending/newtypes.rst:378
msgid ""
"Here is a sample implementation, for a datatype that is considered equal "
"if the size of an internal pointer is equal::"
msgstr "내부 포인터의 크기가 같으면 같다고 간주하는 데이터형에 대한 샘플 구현은 다음과 같습니다::"

#: ../../extending/newtypes.rst:381
msgid ""
"static PyObject *\n"
"newdatatype_richcmp(newdatatypeobject *obj1, newdatatypeobject *obj2, int"
" op)\n"
"{\n"
"    PyObject *result;\n"
"    int c, size1, size2;\n"
"\n"
"    /* code to make sure that both arguments are of type\n"
"       newdatatype omitted */\n"
"\n"
"    size1 = obj1->obj_UnderlyingDatatypePtr->size;\n"
"    size2 = obj2->obj_UnderlyingDatatypePtr->size;\n"
"\n"
"    switch (op) {\n"
"    case Py_LT: c = size1 <  size2; break;\n"
"    case Py_LE: c = size1 <= size2; break;\n"
"    case Py_EQ: c = size1 == size2; break;\n"
"    case Py_NE: c = size1 != size2; break;\n"
"    case Py_GT: c = size1 >  size2; break;\n"
"    case Py_GE: c = size1 >= size2; break;\n"
"    }\n"
"    result = c ? Py_True : Py_False;\n"
"    Py_INCREF(result);\n"
"    return result;\n"
" }"
msgstr ""

#: ../../extending/newtypes.rst:408
msgid "Abstract Protocol Support"
msgstr "추상 프로토콜 지원"

#: ../../extending/newtypes.rst:410
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific "
"interfaces provided to use these interfaces are documented in "
":ref:`abstract`."
msgstr ""
"파이썬은 다양한 *추상* '프로토콜'을 지원합니다; 이러한 인터페이스를 사용하기 위해 제공되는 구체적인 인터페이스는 "
":ref:`abstract`\\에 설명되어 있습니다."

#: ../../extending/newtypes.rst:414
msgid ""
"A number of these abstract interfaces were defined early in the "
"development of the Python implementation.  In particular, the number, "
"mapping, and sequence protocols have been part of Python since the "
"beginning.  Other protocols have been added over time.  For protocols "
"which depend on several handler routines from the type implementation, "
"the older protocols have been defined as optional blocks of handlers "
"referenced by the type object.  For newer protocols there are additional "
"slots in the main type object, with a flag bit being set to indicate that"
" the slots are present and should be checked by the interpreter.  (The "
"flag bit does not indicate that the slot values are non-``NULL``. The "
"flag may be set to indicate the presence of a slot, but a slot may still "
"be unfilled.) ::"
msgstr ""
"이러한 추상 인터페이스 중 다수는 파이썬 구현 개발 초기에 정의되었습니다. 특히, 숫자, 매핑 및 시퀀스 프로토콜은 처음부터 "
"파이썬의 일부였습니다. 다른 프로토콜은 시간이 지남에 따라 추가되었습니다. 형 구현의 여러 처리기 루틴에 의존하는 프로토콜의 경우,"
" 이전 프로토콜은 형 객체가 참조하는 선택적 처리기 블록으로 정의되었습니다. 최신 프로토콜의 경우 메인 형 객체에 추가 슬롯이 "
"있으며, 슬롯이 존재하고 인터프리터가 확인해야 함을 나타내는 플래그 비트가 설정됩니다. (플래그 비트는 슬롯 값이 "
"``NULL``\\이 아님을 나타내지 않습니다. 플래그는 슬롯의 존재를 나타내도록 설정될 수 있지만, 슬롯은 여전히 채워지지 않을 "
"수 있습니다.) ::"

#: ../../extending/newtypes.rst:425
msgid ""
"PyNumberMethods   *tp_as_number;\n"
"PySequenceMethods *tp_as_sequence;\n"
"PyMappingMethods  *tp_as_mapping;"
msgstr ""

#: ../../extending/newtypes.rst:429
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a"
" mapping object, then you place the address of a structure that "
"implements the C type :c:type:`PyNumberMethods`, "
":c:type:`PySequenceMethods`, or :c:type:`PyMappingMethods`, respectively."
" It is up to you to fill in this structure with appropriate values. You "
"can find examples of the use of each of these in the :file:`Objects` "
"directory of the Python source distribution. ::"
msgstr ""
"여러분의 객체가 숫자, 시퀀스 또는 매핑 객체처럼 작동하도록 하려면, C형 :c:type:`PyNumberMethods`, "
":c:type:`PySequenceMethods` 또는 :c:type:`PyMappingMethods`\\를 각각 구현하는 구조체의"
" 주소를 배치합니다. 이 구조체를 적절한 값으로 채우는 것은 여러분의 책임입니다. 파이썬 소스 배포의 :file:`Objects` "
"디렉터리에서 이들 각각의 사용 예를 찾을 수 있습니다. ::"

#: ../../extending/newtypes.rst:436
msgid "hashfunc tp_hash;"
msgstr ""

#: ../../extending/newtypes.rst:438
msgid ""
"This function, if you choose to provide it, should return a hash number "
"for an instance of your data type. Here is a simple example::"
msgstr "여러분이 제공하기로 선택했다면, 이 함수는 데이터형의 인스턴스에 대한 해시 숫자를 반환해야 합니다. 다음은 간단한 예입니다::"

#: ../../extending/newtypes.rst:441
#, python-brace-format
msgid ""
"static Py_hash_t\n"
"newdatatype_hash(newdatatypeobject *obj)\n"
"{\n"
"    Py_hash_t result;\n"
"    result = obj->some_size + 32767 * obj->some_number;\n"
"    if (result == -1)\n"
"       result = -2;\n"
"    return result;\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:451
msgid ""
":c:type:`Py_hash_t` is a signed integer type with a platform-varying "
"width. Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates "
"an error, which is why you should be careful to avoid returning it when "
"hash computation is successful, as seen above."
msgstr ""
":c:type:`Py_hash_t`\\는 플랫폼에 따라 변하는 너비의 부호 있는 정수 형입니다. "
":c:member:`~PyTypeObject.tp_hash`\\에서 ``-1``\\을 반환하면 에러를 표시해서, 위와 같이 해시 "
"계산에 성공했을 때 반환하지 않도록 주의해야 합니다."

#: ../../extending/newtypes.rst:458
msgid "ternaryfunc tp_call;"
msgstr ""

#: ../../extending/newtypes.rst:460
msgid ""
"This function is called when an instance of your data type is \"called\","
" for example, if ``obj1`` is an instance of your data type and the Python"
" script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call`"
" handler is invoked."
msgstr ""
"이 함수는 데이터형의 인스턴스가 \"호출\"될 때 호출됩니다, 예를 들어, ``obj1``\\이 데이터형의 인스턴스이고 파이썬 "
"스크립트에 ``obj1('hello')``\\가 포함되어 있으면 :c:member:`~PyTypeObject.tp_call` "
"처리기가 호출됩니다."

#: ../../extending/newtypes.rst:464
msgid "This function takes three arguments:"
msgstr "이 함수는 세 개의 인자를 취합니다:"

#: ../../extending/newtypes.rst:466
msgid ""
"*self* is the instance of the data type which is the subject of the call."
" If the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self*\\는 호출의 대상인 데이터형의 인스턴스입니다. 호출이 ``obj1('hello')``\\이면, *self*\\는 "
"``obj1``\\입니다."

#: ../../extending/newtypes.rst:469
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use "
":c:func:`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args*\\는 호출에 대한 인자를 포함하는 튜플입니다. :c:func:`PyArg_ParseTuple`\\을 사용하여 인자를 "
"추출할 수 있습니다."

#: ../../extending/newtypes.rst:472
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is "
"non-``NULL`` and you support keyword arguments, use "
":c:func:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you "
"do not want to support keyword arguments and this is non-``NULL``, raise "
"a :exc:`TypeError` with a message saying that keyword arguments are not "
"supported."
msgstr ""
"*kwds*\\는 전달된 키워드 인자의 딕셔너리입니다. 이것이 ``NULL``\\이 아니고 키워드 인자를 지원하면 "
":c:func:`PyArg_ParseTupleAndKeywords`\\를 사용하여 인자를 추출하십시오. 키워드 인자를 지원하지 않고"
" 이것이 ``NULL``\\이 아니면, 키워드 인자가 지원되지 않는다는 메시지와 함께 :exc:`TypeError`\\를 "
"발생시키십시오."

#: ../../extending/newtypes.rst:478
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "장난감 ``tp_call`` 구현은 다음과 같습니다::"

#: ../../extending/newtypes.rst:480
#, python-format
msgid ""
"static PyObject *\n"
"newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *kwds)\n"
"{\n"
"    PyObject *result;\n"
"    const char *arg1;\n"
"    const char *arg2;\n"
"    const char *arg3;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {\n"
"        return NULL;\n"
"    }\n"
"    result = PyUnicode_FromFormat(\n"
"        \"Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\\n\","
"\n"
"        obj->obj_UnderlyingDatatypePtr->size,\n"
"        arg1, arg2, arg3);\n"
"    return result;\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:500
msgid ""
"/* Iterators */\n"
"getiterfunc tp_iter;\n"
"iternextfunc tp_iternext;"
msgstr ""

#: ../../extending/newtypes.rst:504
#, fuzzy
msgid ""
"These functions provide support for the iterator protocol.  Both handlers"
" take exactly one parameter, the instance for which they are being "
"called, and return a new reference.  In the case of an error, they should"
" set an exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter`"
" corresponds to the Python :meth:`~object.__iter__` method, while "
":c:member:`~PyTypeObject.tp_iternext` corresponds to the Python "
":meth:`~iterator.__next__` method."
msgstr ""
"이 함수는 이터레이터 프로토콜 지원을 제공합니다. 두 처리기 모두 정확히 하나의 매개 변수, 호출되는 인스턴스를 취하고 새 참조를 "
"반환합니다. 에러가 발생하면, 예외를 설정하고 ``NULL``\\을 반환해야 합니다. "
":c:member:`~PyTypeObject.tp_iter`\\는 파이썬 :meth:`__iter__` 메서드에 해당하고, "
":c:member:`~PyTypeObject.tp_iternext`\\는 파이썬 :meth:`~iterator.__next__` "
"메서드에 해당합니다."

#: ../../extending/newtypes.rst:511
msgid ""
"Any :term:`iterable` object must implement the "
":c:member:`~PyTypeObject.tp_iter` handler, which must return an "
":term:`iterator` object.  Here the same guidelines apply as for Python "
"classes:"
msgstr ""
"모든 :term:`이터러블 <iterable>` 객체는 :term:`이터레이터 <iterator>` 객체를 반환해야 하는 "
":c:member:`~PyTypeObject.tp_iter` 처리기를 구현해야 합니다. 다음은 파이썬 클래스에도 적용되는 공통 "
"지침입니다:"

#: ../../extending/newtypes.rst:515
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by "
"each call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"여러 개의 독립 이터레이터를 지원할 수 있는 컬렉션(가령 리스트와 튜플)의 경우, "
":c:member:`~PyTypeObject.tp_iter`\\를 호출할 때마다 새 이터레이터가 만들어지고 반환되어야 합니다."

#: ../../extending/newtypes.rst:518
msgid ""
"Objects which can only be iterated over once (usually due to side effects"
" of iteration, such as file objects) can implement "
":c:member:`~PyTypeObject.tp_iter` by returning a new reference to "
"themselves -- and should also therefore implement the "
":c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"한 번만 이터레이트 될 수 있는 (보통 파일 객체처럼 이터레이션의 부작용으로 인해) 객체는 스스로에 대한 새로운 참조를 반환하여 "
":c:member:`~PyTypeObject.tp_iter`\\를 구현할 수 있습니다 -- 따라서 "
":c:member:`~PyTypeObject.tp_iternext` 처리기도 구현해야 합니다."

#: ../../extending/newtypes.rst:523
msgid ""
"Any :term:`iterator` object should implement both "
":c:member:`~PyTypeObject.tp_iter` and "
":c:member:`~PyTypeObject.tp_iternext`.  An iterator's "
":c:member:`~PyTypeObject.tp_iter` handler should return a new reference "
"to the iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler "
"should return a new reference to the next object in the iteration, if "
"there is one. If the iteration has reached the end, "
":c:member:`~PyTypeObject.tp_iternext` may return ``NULL`` without setting"
" an exception, or it may set :exc:`StopIteration` *in addition* to "
"returning ``NULL``; avoiding the exception can yield slightly better "
"performance.  If an actual error occurs, "
":c:member:`~PyTypeObject.tp_iternext` should always set an exception and "
"return ``NULL``."
msgstr ""
"모든 :term:`이터레이터 <iterator>` 객체는 :c:member:`~PyTypeObject.tp_iter`\\와 "
":c:member:`~PyTypeObject.tp_iternext`\\를 모두 구현해야 합니다. 이터레이터의 "
":c:member:`~PyTypeObject.tp_iter` 처리기는 이터레이터에 대한 새로운 참조를 반환해야 합니다. "
":c:member:`~PyTypeObject.tp_iternext` 처리기는 이터레이션의 다음 객체(있다면)에 대한 새 참조를 "
"반환해야 합니다. 이터레이션이 끝에 도달하면, :c:member:`~PyTypeObject.tp_iternext`\\는 예외를 "
"설정하지 않고 ``NULL``\\을 반환하거나, ``NULL``\\을 반환하는 것에 *더해* "
":exc:`StopIteration`\\을 설정할 수 있습니다; 예외를 피하면 성능이 약간 향상될 수 있습니다. 실제 에러가 "
"발생하면, :c:member:`~PyTypeObject.tp_iternext`\\는 항상 예외를 설정하고, ``NULL``\\을 "
"반환해야 합니다."

#: ../../extending/newtypes.rst:539
msgid "Weak Reference Support"
msgstr "약한 참조 지원"

#: ../../extending/newtypes.rst:541
msgid ""
"One of the goals of Python's weak reference implementation is to allow "
"any type to participate in the weak reference mechanism without incurring"
" the overhead on performance-critical objects (such as numbers)."
msgstr ""
"파이썬의 약한 참조 구현의 목표 중 하나는 성능에 중요한 객체(가령 숫자)에 대한 부하를 발생시키지 않고 모든 형이 약한 참조 "
"메커니즘에 참여할 수 있도록 하는 것입니다."

#: ../../extending/newtypes.rst:546
msgid "Documentation for the :mod:`weakref` module."
msgstr ":mod:`weakref` 모듈에 대한 설명서."

#: ../../extending/newtypes.rst:548
msgid ""
"For an object to be weakly referenceable, the extension type must set the"
" ``Py_TPFLAGS_MANAGED_WEAKREF`` bit of the "
":c:member:`~PyTypeObject.tp_flags` field. The legacy "
":c:member:`~PyTypeObject.tp_weaklistoffset` field should be left as zero."
msgstr ""

#: ../../extending/newtypes.rst:553
#, fuzzy
msgid "Concretely, here is how the statically declared type object would look::"
msgstr "그리고 정적으로 선언된 형 객체의 해당 멤버::"

#: ../../extending/newtypes.rst:555
#, python-brace-format
msgid ""
"static PyTypeObject TrivialType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    /* ... other members omitted for brevity ... */\n"
"    .tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,\n"
"};"
msgstr ""

#: ../../extending/newtypes.rst:562
#, fuzzy
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`)::"
msgstr ""
"유일한 추가 사항은 필드가 ``NULL``\\이 아니면 ``tp_dealloc``\\이 "
"(:c:func:`PyObject_ClearWeakRefs`\\를 호출하여) 모든 약한 참조를 지울 필요가 있다는 것입니다::"

#: ../../extending/newtypes.rst:565
#, python-brace-format
msgid ""
"static void\n"
"Trivial_dealloc(TrivialObject *self)\n"
"{\n"
"    /* Clear weakrefs first before calling any destructors */\n"
"    PyObject_ClearWeakRefs((PyObject *) self);\n"
"    /* ... remainder of destruction code omitted for brevity ... */\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:576
msgid "More Suggestions"
msgstr "추가 제안"

#: ../../extending/newtypes.rst:578
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function "
"you want (for example, ``tp_richcompare``).  You will find examples of "
"the function you want to implement."
msgstr ""
"새 데이터형에 특정 메서드를 구현하는 방법을 배우려면, :term:`CPython` 소스 코드를 구하십시오. "
":file:`Objects` 디렉터리로 이동한 다음, C 소스 파일에서 ``tp_``\\에 원하는 기능을 더한 것(예를 들어, "
"``tp_richcompare``)을 검색하십시오. 구현하려는 함수의 예를 찾을 수 있을 겁니다."

#: ../../extending/newtypes.rst:584
msgid ""
"When you need to verify that an object is a concrete instance of the type"
" you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""
"객체가 구현 중인 형의 구상 인스턴스인지 확인해야 하면, :c:func:`PyObject_TypeCheck` 함수를 사용하십시오. "
"사용 예는 다음과 같습니다::"

#: ../../extending/newtypes.rst:588
#, python-brace-format
msgid ""
"if (!PyObject_TypeCheck(some_object, &MyType)) {\n"
"    PyErr_SetString(PyExc_TypeError, \"arg #1 not a mything\");\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../../extending/newtypes.rst:594
msgid "Download CPython source releases."
msgstr "CPython 소스 릴리스를 다운로드하십시오."

#: ../../extending/newtypes.rst:595
msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

#: ../../extending/newtypes.rst:597
msgid "The CPython project on GitHub, where the CPython source code is developed."
msgstr "GitHub의 CPython 프로젝트, CPython 소스 코드가 개발되는 곳."

#: ../../extending/newtypes.rst:598
msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"

#: ../../extending/newtypes.rst:56
msgid "object"
msgstr ""

#: ../../extending/newtypes.rst:56
msgid "deallocation"
msgstr ""

#: ../../extending/newtypes.rst:56
msgid "deallocation, object"
msgstr ""

#: ../../extending/newtypes.rst:56
msgid "finalization"
msgstr ""

#: ../../extending/newtypes.rst:56
#, fuzzy
msgid "finalization, of objects"
msgstr "파이널리제이션과 할당 해제"

#: ../../extending/newtypes.rst:91
msgid "PyErr_Fetch (C function)"
msgstr ""

#: ../../extending/newtypes.rst:91
msgid "PyErr_Restore (C function)"
msgstr ""

#: ../../extending/newtypes.rst:150
msgid "string"
msgstr ""

#: ../../extending/newtypes.rst:150
#, fuzzy
msgid "object representation"
msgstr "객체 표현"

#: ../../extending/newtypes.rst:150
msgid "built-in function"
msgstr ""

#: ../../extending/newtypes.rst:150
msgid "repr"
msgstr ""

#~ msgid ""
#~ "The following flag constants are defined"
#~ " in :file:`structmember.h`; they may be "
#~ "combined using bitwise-OR."
#~ msgstr ""
#~ "다음 플래그 상수는 :file:`structmember.h`\\에 정의되어 "
#~ "있습니다; 비트별 OR를 사용하여 결합할 수 있습니다."

#~ msgid "Constant"
#~ msgstr "상수"

#~ msgid "Meaning"
#~ msgstr "의미"

#~ msgid ":const:`READONLY`"
#~ msgstr ":const:`READONLY`"

#~ msgid "Never writable."
#~ msgstr "쓸 수 없습니다."

#~ msgid ":const:`READ_RESTRICTED`"
#~ msgstr ":const:`READ_RESTRICTED`"

#~ msgid "Not readable in restricted mode."
#~ msgstr "제한된 모드에서는 읽을 수 없습니다."

#~ msgid ":const:`WRITE_RESTRICTED`"
#~ msgstr ":const:`WRITE_RESTRICTED`"

#~ msgid "Not writable in restricted mode."
#~ msgstr "제한된 모드에서는 쓸 수 없습니다."

#~ msgid ":const:`RESTRICTED`"
#~ msgstr ":const:`RESTRICTED`"

#~ msgid "Not readable or writable in restricted mode."
#~ msgstr "제한된 모드에서는 읽거나 쓸 수 없습니다."

#~ msgid ""
#~ "For an object to be weakly "
#~ "referencable, the extension type must do"
#~ " two things:"
#~ msgstr "객체가 약하게 참조될 수 있으려면, 확장형이 두 가지 작업을 수행해야 합니다:"

#~ msgid ""
#~ "Include a :c:type:`PyObject\\*` field in "
#~ "the C object structure dedicated to "
#~ "the weak reference mechanism.  The "
#~ "object's constructor should leave it "
#~ "``NULL`` (which is automatic when using"
#~ " the default :c:member:`~PyTypeObject.tp_alloc`)."
#~ msgstr ""
#~ "약한 참조 메커니즘 전용 C 객체 구조체에 "
#~ ":c:type:`PyObject\\*` 필드를 포함하십시오. 객체의 생성자는 "
#~ "이것을 ``NULL``\\로 남겨 두어야 합니다 (기본 "
#~ ":c:member:`~PyTypeObject.tp_alloc`\\을 사용할 때는 자동입니다)."

#~ msgid ""
#~ "Set the :c:member:`~PyTypeObject.tp_weaklistoffset` "
#~ "type member to the offset of the"
#~ " aforementioned field in the C object"
#~ " structure, so that the interpreter "
#~ "knows how to access and modify "
#~ "that field."
#~ msgstr ""
#~ "인터프리터가 해당 필드에 액세스하고 수정하는 방법을 알 "
#~ "수 있도록, :c:member:`~PyTypeObject.tp_weaklistoffset` 형"
#~ " 멤버를 C 객체 구조체에서 위에서 언급한 필드의 "
#~ "오프셋으로 설정하십시오."

#~ msgid ""
#~ "Concretely, here is how a trivial "
#~ "object structure would be augmented with"
#~ " the required field::"
#~ msgstr "구체적으로, 다음은 필수 필드로 사소한 객체 구조체를 확장하는 방법입니다::"

